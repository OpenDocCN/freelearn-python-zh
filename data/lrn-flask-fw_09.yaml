- en: Chapter 9. Excellent Extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。优秀的扩展
- en: In this chapter, we will learn about enhancing our Flask install with some popular
    third-party extensions. Extensions allow us to add extra security or functionality
    with very little effort and can polish your blogging app nicely. We will investigate
    **Cross-Site Request Forgery** (**CSRF**) protection for your forms, Atom feeds
    so others can find your blog updates, adding syntax highlighting to the code that
    you use, caching to reduce the load when rendering templates, and asynchronous
    tasks so that your app doesn't become unresponsive when it is doing something
    intensive.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何通过一些流行的第三方扩展增强我们的Flask安装。扩展允许我们以非常少的工作量添加额外的安全性或功能，并可以很好地完善您的博客应用程序。我们将研究**跨站点请求伪造**（**CSRF**）保护您的表单，Atom订阅源以便其他人可以找到您的博客更新，为您使用的代码添加语法高亮，减少渲染模板时的负载的缓存，以及异步任务，以便您的应用程序在进行密集操作时不会变得无响应。
- en: 'In this chapter we shall learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: CSRF protection using Flask-SeaSurf
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-SeaSurf进行CSRF保护
- en: Atom feeds using werkzeug.contrib
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用werkzeug.contrib生成Atom订阅源
- en: Syntax highlighting using Pygments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pygments进行语法高亮
- en: Caching using Flask-Cache and Redis
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Flask-Cache和Redis进行缓存
- en: Asynchronous task execution using Celery
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Celery进行异步任务执行
- en: SeaSurf and CSRF protection of forms
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SeaSurf和表单的CSRF保护
- en: CSRF protection adds security to your site by proving that a POST submission
    came from your site, and not a carefully crafted web form on another site designed
    to maliciously exploit the POST endpoints on your blog. These malicious requests
    can even work around authentication if your browser still considers you logged
    in.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF保护通过证明POST提交来自您的站点，而不是来自另一个站点上精心制作的恶意利用您博客上的POST端点的网络表单，为您的站点增加了安全性。这些恶意请求甚至可以绕过身份验证，如果您的浏览器仍然认为您已登录。
- en: The way we avoid this is to add a special hidden field to any form on the site
    that has a value in it, generated by the server. When the form is submitted, the
    value in the special field can then be checked against the values generated by
    the server and, if it matches, we can continue with the form submission. If the
    value does not match or is non-existent, the form has come from an invalid source.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们避免这种情况的方法是为站点上的任何表单添加一个特殊的隐藏字段，其中包含由服务器生成的值。当提交表单时，可以检查特殊字段中的值是否与服务器生成的值匹配，如果匹配，我们可以继续提交表单。如果值不匹配或不存在，则表单来自无效来源。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: What CSRF protection actually proves is that the template, with the CSRF field
    in it, was used to generate the form. This mitigates the most basic of CSRF attacks
    from other sites but isn't conclusive in validating that the form submission only
    came from our server. For example, a script could still screen-scrape the contents
    of the page.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF保护实际上证明了包含CSRF字段的模板用于生成表单。这可以减轻来自其他站点的最基本的CSRF攻击，但不能确定表单提交只来自我们的服务器。例如，脚本仍然可以屏幕抓取页面的内容。
- en: 'Now, it would be simple to build CSRF protection ourselves and WTForms, which
    is typically used to generate our forms, has this already built-in. However, let''s
    have a look at SeaSurf:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，自己构建CSRF保护并不难，而且通常用于生成我们的表单的WTForms已经内置了这个功能。但是，让我们来看看SeaSurf：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With SeaSurf installed and using WTForms, it is now really easy to integrate
    it into our app. Open your `app.py` file and add the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装SeaSurf并使用WTForms后，将其集成到我们的应用程序中现在变得非常容易。打开您的`app.py`文件并添加以下内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This simply enables SeaSurf for your app. Now, to enable the CSRF in your forms,
    open `forms.py` and create the following Mixin:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为您的应用程序启用了SeaSurf。现在，要在您的表单中启用CSRF，请打开`forms.py`并创建以下Mixin：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code creates a simple CSRF Mixin that can be used optionally
    within all your forms. The decorators ensure that the method is run before a request,
    in order to add the `HiddenField` field to your forms with the value of the randomly
    generated CSRF token. To use this Mixin in your forms, in this instance your login
    form, update the class as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个简单的CSRF Mixin，可以选择在所有表单中使用。装饰器确保在请求之前运行该方法，以便向您的表单添加具有随机生成的CSRF令牌值的`HiddenField`字段。要在您的表单中使用此Mixin，在这种情况下是您的登录表单，更新类如下：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's it. We need to make this change for all the forms we want to protect,
    which is usually all of them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们需要对所有要保护的表单进行这些更改，通常是所有表单。
- en: Creating Atom feeds
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Atom订阅源
- en: A really useful feature for any blog is to have the ability for your readers
    to keep up-to-date with the latest content. This most commonly happens with an
    RSS reader client that polls your RSS subscription feed. While RSS is widely used,
    a better, more mature subscription format is available and is called Atom.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何博客都非常有用的一个功能是让读者能够及时了解最新内容。这通常是通过RSS阅读器客户端来实现的，它会轮询您的RSS订阅源。虽然RSS被广泛使用，但更好、更成熟的订阅格式是可用的，称为Atom。
- en: Both are files that can be requested by a client, and are standard and simple
    XML data structures. Fortunately, an Atom feed generator is built into Flask;
    or, more specifically, a contributed module is built into the WSGI interface that
    Flask uses called Werkzeug.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件都可以由客户端请求，并且是标准和简单的XML数据结构。幸运的是，Flask内置了Atom订阅源生成器；或者更具体地说，Flask使用的WSGI接口中内置了一个贡献的模块，称为Werkzeug。
- en: 'Getting it up-and-running is simple, all we need to do is to get hold of our
    most recently published posts from the database. It may be best to create a new
    Blueprint for this; however, you can also do it within your `main.py`. We just
    need to make use of a few more modules:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让它运行起来很简单，我们只需要从数据库中获取最近发布的帖子。最好为此创建一个新的Blueprint；但是，您也可以在`main.py`中完成。我们只需要利用一些额外的模块：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And create a new route:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 并创建一个新的路由：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now run your Flask app and the Atom feed will be accessible from `http://127.0.0.1:5000/latest.atom`
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的Flask应用程序，Atom订阅源将可以从`http://127.0.0.1:5000/latest.atom`访问
- en: Syntax highlighting using Pygments
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Pygments进行语法高亮
- en: Often, as coders, we want to be able to display code in a web page, and while
    it is a skill to read that code without syntax highlighting, a few colors can
    make the reading experience much more pleasant.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，作为编码人员，我们希望能够在网页上显示代码，虽然不使用语法高亮显示阅读代码是一种技能，但一些颜色可以使阅读体验更加愉快。
- en: 'As is always the way with Python, there is a module already available that
    is able to do that for you, and of course it can be installed easily by the following
    command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python一样，已经有一个模块可以为您完成这项工作，当然，您可以通过以下命令轻松安装它：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pygments only works with the known sections of code. So, if you want to display
    code snippets, we can do that. If, however, you want to highlight inline sections
    of the code, we either follow the next section on Markdown, or we need to use
    some online Javascript such as `highlight.js`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Pygments仅适用于已知的代码部分。因此，如果您想显示代码片段，我们可以这样做。但是，如果您想突出显示代码的内联部分，我们要么遵循Markdown的下一节，要么需要使用一些在线Javascript，例如`highlight.js`。
- en: 'To create code snippets, we need to first create a new blueprint. Let''s create
    a directory called `snippets`, then an `__init__.py` file, followed by a `blueprint.py`
    file with the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建代码片段，我们需要首先创建一个新的蓝图。让我们创建一个名为`snippets`的目录，然后创建一个`__init__.py`文件，接着创建一个名为`blueprint.py`的文件，其中包含以下代码：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding example, we set up the Pygments template filter that allows
    a string of code to be converted into HTML code. We also sneakily make use of
    the entries templates that are perfectly adequate for our needs. We use our own
    `detail.html` because that is where the magic happens with Pygments. We need to
    create a templates directory within the snippets director and another directory
    called snippets within templates, this is where we store our detail.html. So now
    our directory structure looks like app/snippets/templates/snipperts/detail.html
    Let''s set up that file now, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们设置了Pygments模板过滤器，允许将一串代码转换为HTML代码。我们还巧妙地利用了完全适合我们需求的条目模板。我们使用我们自己的`detail.html`，因为那里是Pygments发生魔法的地方。我们需要在snippets目录中创建一个templates目录，然后在templates中创建一个名为snippets的目录，这是我们存储detail.html的地方。因此，现在我们的目录结构看起来像app/snippets/templates/snipperts/detail.html
    现在让我们设置该文件，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is mostly identical to the `detail.html` that we used earlier in the book,
    except that we now pass it through the Pygments filter that we created in the
    app .As the template filter we used earlier produces raw HTML, we also need to
    mark its output as safe.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们在书中早期使用的`detail.html`相同，只是现在我们通过我们在应用程序中创建的Pygments过滤器传递它。由于我们早期使用的模板过滤器生成原始HTML，我们还需要将其输出标记为安全。
- en: 'We also need to update our CSS file for the blog as Pygments uses CSS selectors
    to highlight words rather than wastefully writing the output to the page. It also
    allows us to modify the colors if we want. To find out what our CSS should be
    like, open up a Python shell and run the following commands:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新博客的CSS文件，因为Pygments使用CSS选择器来突出显示单词，而不是在页面上浪费地编写输出。它还允许我们根据需要修改颜色。要找出我们的CSS应该是什么样子，打开Python
    shell并运行以下命令：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding commands will now print out the example CSS that Pygments suggests
    and we can copy-and-paste it into our `.css` file in the `static` directory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令现在将打印出Pygments建议的示例CSS，我们可以将其复制粘贴到`static`目录中的`.css`文件中。
- en: The rest of this code is not a great deal different from the previous Entry
    objects. It simply allows you to create, update, and view snippets. You will notice
    that we are using a `SnippetForm` here that we will define in a bit.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的其余部分与之前的Entry对象没有太大不同。它只是允许您创建、更新和查看代码片段。您会注意到我们在这里使用了一个`SnippetForm`，我们稍后会定义。
- en: 'Also create a `models.py` with the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 还要创建一个`models.py`，其中包含以下内容：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we must re-run the `create_db.py` script to create the new table.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须重新运行`create_db.py`脚本以创建新表。
- en: 'We will also need to create a new form so that the Snippets can be created.
    Within `forms.py,` add the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建一个新的表单，以便可以创建代码片段。在`forms.py`中添加以下代码：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we need to make sure that this blueprint is used by editing the `main.py`
    file and adding in the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保通过编辑`main.py`文件使用此蓝图并添加以下内容：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And, once we have added some code here using the `Snippet` model, the resulting
    code will render as shown in the following image:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在这里添加了一些代码，使用`Snippet`模型，生成的代码将如下图所示呈现：
- en: '![Syntax highlighting using Pygments](img/1709_09_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![使用Pygments进行语法高亮](img/1709_09_01.jpg)'
- en: Simple editing with Markdown
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Markdown进行简单编辑
- en: Markdown is a now widely used mark-up language on the web. It allows you to
    write plain text in a special format that can be programmatically converted to
    HTML. This can be especially useful when editing text from a mobile device where,
    for example, highlighting text to make it bold is significantly trickier than
    on a PC. You can see how to use the Markdown syntax at [http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种现在广泛使用的网络标记语言。它允许您以特殊格式编写纯文本，可以通过程序转换为HTML。在从移动设备编辑文本时，这可能特别有用，例如，突出显示文本使其加粗比在PC上更加困难。您可以在[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)上查看如何使用Markdown语法。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One interesting thing to note with Markdown is that you can still use HTML as
    well as Markdown at the same time.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown的一个有趣之处在于，您仍然可以同时使用HTML和Markdown。
- en: 'Of course, to get this running is quick and simple in Python. We install it
    as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在Python中快速简单地运行这个是很容易的。我们按照以下步骤安装它：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then we can apply it to our blueprint or app as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将其应用到我们的蓝图或应用程序中，如下所示：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This makes a new filter available in our templates called `markdown` and that
    can be used when rendering your template:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们的模板中创建一个名为`markdown`的新过滤器，并且在渲染模板时可以使用它：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now all you need to do is write and save your blog entry content in Markdown.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您只需要在Markdown中编写并保存您的博客条目内容。
- en: 'As previously mentioned, you may also wish to prettify the code blocks; Markdown
    has this facility built-in, so we need to extend the previous example as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您可能还希望美化代码块；Markdown内置了这个功能，因此我们需要扩展先前的示例如下：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This can now render the Markdown code blocks using Pygments. However, as Pygments
    uses CSS to add color to the code, we need to generate our CSS from Pygments.
    However, this time the parent block used has a class called `codehilite` (earlier
    it was called highlight), so we need to accommodate for this. In a Python shell,
    type the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用Pygments来渲染Markdown代码块。但是，由于Pygments使用CSS为代码添加颜色，我们需要从Pygments生成我们的CSS。但是，这次使用的父块具有一个名为`codehilite`的类（之前称为highlight），因此我们需要进行调整。在Python
    shell中，键入以下内容：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now add the output to your `.css` file in the `static` directory. So, with
    your included CSS, your Markdown entry could now look like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将输出添加到`static`目录中的`.css`文件中。因此，使用包含的CSS，您的Markdown条目现在可能如下所示：
- en: '![Simple editing with Markdown](img/1709_09_02.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用Markdown进行简单编辑](img/1709_09_02.jpg)'
- en: There are lots of other Markdown extensions built-in that we could also use;
    you can check them out and just use their name as a string when initializing the
    Markdown object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他内置的Markdown扩展可以使用；您可以查看它们，只需在初始化Markdown对象时使用它们的名称作为字符串。
- en: Caching with Flask-Cache and Redis
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask-Cache和Redis进行缓存
- en: Sometimes, (and I know it's hard to imagine) we put a lot of effort into our
    sites, building in and adding features, and often that means we end up having
    to do a lot of database calls or complex template rendering for a page that is
    simply a static blog entry. Now database calls should not be slow and a lot of
    template renderings should not be noticeable but, if you expand that to lots of
    users (which hopefully you are expecting), this may become an issue.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有时（我知道很难想象），我们会为我们的网站付出很多努力，添加功能，这通常意味着我们最终不得不为一个简单的静态博客条目执行大量数据库调用或复杂的模板渲染。现在数据库调用不应该很慢，大量模板渲染也不应该引人注目，但是，如果将其扩展到大量用户（希望您是在预期的），这可能会成为一个问题。
- en: So, if the site is mostly static why not store your response in a single, high-speed
    memory-based data store? No need for expensive database calls or complex template
    renderings; for the same input, or path, get the same content, and faster.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果网站大部分是静态的，为什么不将响应存储在单个高速内存数据存储中呢？无需进行昂贵的数据库调用或复杂的模板渲染；对于相同的输入或路径，获取相同的内容，而且更快。
- en: 'As is becoming a kind of a catch-phrase by now, we can already do this in Python
    and it is as simple as the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如现在已经成为一种口头禅，我们已经可以在Python中做到这一点，而且就像以下这样简单：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To get it running, add this to your app or your blueprint:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其运行，请将其添加到您的应用程序或蓝图中：
- en: '[PRE19]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will also want to install Redis of course, this can be done on Debian and
    Ubuntu systems quite simply:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您还需要安装Redis，这在Debian和Ubuntu系统上非常简单：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Unfortunately, Redis is not yet available in the Red Hat and CentOS packaging
    system. You can, however, download and compile Redis from their site at
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Redis尚未在Red Hat和CentOS的打包系统中提供。但是，您可以从他们的网站上下载并编译Redis
- en: '[http://redis.io/download](http://redis.io/download)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://redis.io/download](http://redis.io/download)'
- en: By default, Redis is unsecured; as long as we don't expose it to our network
    this should be fine and we do not need any more configuration for Flask-Cache.
    If, however, you are looking to lock it down, check out the Flask-Cache configuration
    for Redis.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Redis是不安全的；只要我们不将其暴露给我们的网络，这应该没问题，而且对于Flask-Cache，我们不需要进行任何其他配置。但是，如果您希望对其进行锁定，请查看Redis的Flask-Cache配置。
- en: 'Now we can use caching in our views (as well as any methods). This is as simple
    as using a decorator on a route. So, open a view and add the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在视图中使用缓存（以及任何方法）。这就像在路由上使用装饰器一样简单。因此，打开一个视图并添加以下内容：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You will see here that the cached decorator is within the route and that we
    have a timeout value of 10 minutes, in seconds. This means that, however heavy
    the rendering of your homepage is, and however many database calls it may make,
    the response is going to be straight out of memory for that time period.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在这里看到，缓存的装饰器在路由内部，并且我们有一个10分钟的超时值，以秒为单位。这意味着，无论您的主页的渲染有多繁重，或者它可能进行多少数据库调用，响应都将在该时间段内直接从内存中获取。
- en: 'Obviously, caching has a time and a place and can be quite an art. If you have
    a custom homepage for each user, then caching will be useless. However, what we
    can do is cache sections of our template, so common areas such as all the `<link>`
    elements in the `<head>` will very rarely change but the `url_for(''static'',
    ...)` filter doesn''t have to be regenerated each time. Look at the following
    code for example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，缓存有其时间和地点，并且可能是一门艺术。如果每个用户都有一个自定义的主页，那么缓存将是无用的。但是，我们可以缓存模板的部分内容，因此诸如`<head>`中的所有`<link>`元素这样的常见区域很少会更改，但是`url_for('static',
    ...)`过滤器不必每次重新生成。例如，看下面的代码：
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding code section says that the link element should be cached for 30
    minutes, in seconds. You may also want to do this for your references to the scripts
    as well. We could also use it for loading a list of the latest blog posts, for
    example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码部分表示链接元素应该缓存30分钟，以秒为单位。您可能还希望对脚本的引用进行相同的操作。我们也可以用它来加载最新博客文章的列表，例如。
- en: Creating secure, stable versions of your site by creating static content
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过创建安全、稳定的站点版本来创建静态内容
- en: One technique for a high-volume site with low-dynamic content is to create a
    site that is simply a static copy of the dynamic site. This works great for blogs
    as the content is generally static and updated, at the most, a couple of times
    a day. However, you are still doing a bunch of database calls and template renderings
    for the content that effectively doesn't change.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 对于低动态内容的高流量网站的一种技术是创建一个简单的静态副本。这对博客非常有效，因为内容通常是静态的，并且每天最多更新几次。但是，您仍然需要为实际上没有变化的内容执行大量数据库调用和模板渲染。
- en: 'And, of course, there is a Flask extension that has this covered: Frozen-Flask.
    Frozen-Flask identifies the URLs in your Flask app and generates the content that
    should be there.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有一个Flask扩展程序可以解决这个问题：Frozen-Flask。Frozen-Flask识别Flask应用程序中的URL，并生成应该在那里的内容。
- en: So, for the pages it generates the HTML and, for static content such as JavaScript
    and images, it pulls them out into a base directory that is a static copy of your
    site and that can be served up by your web server as static content.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于生成的页面，它会生成HTML，对于JavaScript和图像等静态内容，它会将它们提取到一个基本目录中，这是您网站的静态副本，并且可以由您的Web服务器作为静态内容提供。
- en: This has the added benefit of the site being much more secure since the *active*
    version of the site cannot be changed by using the Flask app or the web server.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的另一个好处是，网站的*活动*版本更加安全，因为无法使用Flask应用程序或Web服务器更改它。
- en: 'There are some drawbacks to this, of course. If you have dynamic content on
    your site—for example, comments—it is no longer possible to store and render them
    in the conventional way. Also, if you have multiple authors on your site, you
    need a way of sharing your database content so they don''t end up producing separate
    copies of the site. Solutions are suggested at the end of this section. But first,
    let us install Frozen-Flask as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这也有一些缺点。如果您的网站上有动态内容，例如评论，就不再可能以常规方式存储和呈现它们。此外，如果您的网站上有多个作者，您需要一种共享数据库内容的方式，以便它们不会生成网站的单独副本。解决方案将在本节末尾提出。但首先，让我们按照以下方式安装Frozen-Flask：
- en: '[PRE23]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next we will need to create a file called `freeze.py`. This is a simple script
    that automatically sets up Frozen-Flask:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为`freeze.py`的文件。这是一个简单的脚本，可以自动设置Frozen-Flask：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The above code uses all the defaults of Frozen-Flask and when run as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以上代码使用了Frozen-Flask的所有默认设置，并在以下方式运行：
- en: '[PRE25]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: will create (or overwrite) the directory `build` that contains the static copy
    of your blog.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将创建（或覆盖）包含博客静态副本的`build`目录。
- en: 'Frozen-Flask is quite smart and will automatically find all your links, as
    long as they are hierarchically referenced from the root homepage; for blog posts
    this works quite well. However, if entries get dropped from your homepage and
    they are accessed by an archive page on another URL, you may need to give Frozen-Flask
    pointers as to where to find those. For example, add the following to the `freeze.py
    file`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Frozen-Flask非常智能，将自动查找所有链接，只要它们是从根主页按层次引用的；对于博客文章，这样做效果很好。但是，如果条目从主页中删除，并且它们通过另一个URL上的存档页面访问，您可能需要向Frozen-Flask提供指针以找到它们的位置。例如，将以下内容添加到`freeze.py文件`中：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Frozen-Flask is smart and uses the `url_for` method provided by Flask to create
    the static files. This means that anything that is available to the `url_for method`
    is available to be used by Frozen-Flask, if it cannot be found through the normal
    route.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Frozen-Flask很聪明，并使用Flask提供的`url_for`方法来创建静态文件。这意味着`url_for方法`可用的任何内容都可以被Frozen-Flask使用，如果无法通过正常路由找到。
- en: Commenting on a static site
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在静态站点上发表评论
- en: So, as you might have guessed, by creating a static site you lose out on some
    blogging fundamentals—the one area that encourages communication and debate. Fortunately,
    there is a simple solution.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可能已经猜到，通过创建静态站点，您会失去一些博客基本原理——这是鼓励交流和辩论的一个领域。幸运的是，有一个简单的解决方案。
- en: Blog comment hosting services such as Disqus and Discourse work much like a
    forum, with the exception that each topic is created by each blog post. You can
    use their services for free to run your discussion or, with Discourse, you can
    run their server on your own platform for free, as it is completely open source.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 博客评论托管服务，如Disqus和Discourse，工作方式类似于论坛，唯一的区别是每个博客帖子都创建了一个主题。您可以免费使用它们的服务来进行讨论，或者使用Discourse在自己的平台上免费运行他们的服务器，因为它是完全开源的。
- en: Synchronizing multiple editors
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步多个编辑器
- en: 'Another issue with Frozen-Flask, one that a person running the blog won''t
    notice, is this: with multiple authors spread across a network, how do you manage
    the database where your posts are stored? Everyone will need the same up-to-date
    copy of the database; otherwise, when you generate the static copy of the site,
    it won''t be able to create all the content.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Frozen-Flask的另一个问题是，对于分布在网络上的多个作者，您如何管理存储帖子的数据库？每个人都需要相同的最新数据库副本；否则，当您生成站点的静态副本时，它将无法创建所有内容。
- en: If you all work in the same environment, one solution is to have a working copy
    of the blog running on a server within the network and, when it comes to publishing
    time, it will use that centralized database to create the published version of
    the blog.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您都在同一个环境中工作，一个解决方案是在网络内的服务器上运行博客的工作副本，并且在发布时，它将使用集中式数据库来创建博客的已发布版本。
- en: If, however, you all work in disparate locations where a centralized database
    is not ideal or impossible to secure, the other solution is to use a file-system
    based database engine such as SQLite. Then, when an update is made to the database,
    that file can be spread to others via e-mail, Dropbox, Skype, and so on. They
    then have an up-to-date copy of the database that they can locally run Frozen-Flask
    from to create the publishable content.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您都在不同的地方工作，集中式数据库不是理想的解决方案或无法保护，另一个解决方案是使用基于文件系统的数据库引擎，如SQLite。然后，当对数据库进行更新时，可以通过电子邮件、Dropbox、Skype等方式将该文件传播给其他人。然后，他们可以从本地运行Frozen-Flask创建可发布内容的最新副本。
- en: Asynchronous tasks with Celery
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Celery进行异步任务
- en: Celery is a library that allows you to run asynchronous tasks within Python.
    This is especially helpful in Python as Python runs single threaded and you may
    find that you have a long-running task that you wish to either start and discard;
    or you may wish to give the user of your website some feedback on the progress
    of the said task.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Celery是一个允许您在Python中运行异步任务的库。这在Python中特别有帮助，因为Python是单线程运行的，您可能会发现自己有一个长时间运行的任务，您希望要么启动并丢弃；要么您可能希望向您网站的用户提供有关所述任务进度的反馈。
- en: One such example is e-mail. A user may request an e-mail to be sent, for example
    a password reset request, and you don't want them waiting for the page to load
    while the e-mail is generated and sent. We can set this up as a start and discard
    operation and let the user know that the request is being dealt with.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个这样的例子是电子邮件。用户可能会请求发送电子邮件，例如重置密码请求，您不希望他们在生成和发送电子邮件时等待页面加载。我们可以将其设置为启动和丢弃操作，并让用户知道该请求正在处理中。
- en: The way Celery is able to escape the single-threaded environment of Python is
    that we have to run a Celery broker instance separately which; this creates what
    Celery calls workers that do the actual work. Your Flask app and the workers then
    communicate with each other via the messaging broker.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Celery能够摆脱Python的单线程环境的方式是，我们必须单独运行一个Celery代理实例；这会创建Celery所谓的执行实际工作的工作进程。然后，您的Flask应用程序和工作进程通过消息代理进行通信。
- en: 'So obviously, we need to install Celery and I''m sure you can guess by now
    that the command you need is the following one:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要安装Celery，我相信您现在可以猜到您需要的命令是以下命令：
- en: '[PRE27]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now we need a message broker server. There are plenty to choose from; check
    out Celery's website for the supported ones, but, however, since we have already
    set up Redis in the Flask-Cache setup, let's use that.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个消息代理服务器。有很多选择；查看Celery的网站以获取支持的选择，但是，由于我们已经在Flask-Cache设置中设置了Redis，让我们使用它。
- en: 'Now we need to tell Celery how to use the Redis server. Open up the Flask app
    configuration file and add the following line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要告诉Celery如何使用Redis服务器。打开Flask应用程序配置文件并添加以下行：
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This configuration tells your instance of Celery where to find the message
    broker that it needs to communicate with the Celery broker. Now we need to initialize
    the Celery instance in our app. In the `main.py file,` add the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置告诉您的Celery实例在哪里找到它需要与Celery代理通信的消息代理。现在我们需要在我们的应用程序中初始化Celery实例。在`main.py文件`中添加以下内容：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This creates an instance of `Celery` with configuration from the Flask configuration
    file so we can also access the `celery` object from the Celery broker and share
    the same setup.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用来自Flask配置文件的配置创建一个`Celery`实例，因此我们还可以从Celery代理访问`celery`对象并共享相同的设置。
- en: 'Now we need something for the Celery worker processes to do. At this point,
    we are going to make use of the Flask-Mail library:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为Celery工作进程做一些事情。在这一点上，我们将利用Flask-Mail库：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We are also going to need some configuration for this to run. Add the following
    parameters to your Flask configuration file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一些配置才能运行。将以下参数添加到您的Flask配置文件中：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This configuration tells Flask-Mail where your e-mail server is. It is likely
    that the defaults may be good enough for you, or you may need more options. Check
    out the Flask-Mail configuration for more options.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置告诉Flask-Mail您的电子邮件服务器在哪里。很可能默认设置对您来说已经足够好，或者您可能需要更多选项。查看Flask-Mail配置以获取更多选项。
- en: 'Now lets create a new file called `tasks.py` and create some tasks to run as
    follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个名为`tasks.py`的新文件，并创建一些要运行的任务，如下所示：
- en: '[PRE32]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a really simple message generation; we are just generating an e-mail
    message with the content saying what the new password is, where the e-mail is
    from (our mail server), who the e-mail is going to, and the e-mail address of
    the user whose account it supposedly is, and then sends; the message is then sent
    via the already set up mail instance.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的消息生成；我们只是生成一封电子邮件，内容是新密码是什么，电子邮件来自哪里（我们的邮件服务器），电子邮件发送给谁，以及假设是用户账户的电子邮件地址，然后发送；然后通过已设置的邮件实例发送消息。
- en: Now we need to get our Flask app to make use of the new asynchronous ability.
    Let's create a view that listens for an e-mail address being POSTed to it. This
    could be in any of the blueprints to do with accounts or your main app.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要让我们的Flask应用程序利用新的异步能力。让我们创建一个视图，监听被POST到它的电子邮件地址。这可以在与帐户或主应用程序有关的任何蓝图中进行。
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding view accepts a POSTed message from a browser that contains the
    e-mail of the user who is is claiming to have forgotten his password. We first
    look up the user by their e-mail address to see if the user does indeed exist
    in our database. Obviously, there's no point resetting the password on an account
    that doesn't exist. Of course, if they don't exist, the user will be given a message
    accordingly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的视图接受来自浏览器的POST消息，其中包含声称忘记密码的用户的电子邮件。我们首先通过他们的电子邮件地址查找用户，以查看用户是否确实存在于我们的数据库中。显然，在不存在的帐户上重置密码是没有意义的。当然，如果他们不存在，用户将收到相应的消息。
- en: However, if the user account does exist, the first thing to do is to generate
    them a new password. We use a hard-coded example password here. That password
    is then updated in the database so that the user can use it to log in when they
    receive the e-mail. Once all of that is out of the way, we then run .delay on
    the `task` we created earlier with the arguments that we want to use. This instructs
    Celery to run the underlying method when it is ready.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果用户帐户确实存在，首先要做的是为他们生成一个新密码。我们在这里使用了一个硬编码的示例密码。然后更新数据库中的密码，以便用户在收到电子邮件时可以使用它进行登录。一切都搞定后，我们就可以在之前创建的`任务`上运行.delay，并使用我们想要使用的参数。这会指示Celery在准备好时运行底层方法。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this is not the best solution for doing password resets. It is just
    to illustrate how you may want to do it in a succinct way. Password rests are
    a surprisingly complicated area and there are lots of things you can do to improve
    the security and privacy of this facility such as checking the CSRF value, limiting
    how many times the method is called, and using a randomly generated URL for users
    to reset their passwords at rather than a hard-coded solution that is sent via
    e-mail.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不是进行密码重置的最佳解决方案。这只是为了说明您可能希望以简洁的方式执行此操作。密码重置是一个令人惊讶地复杂的领域，有很多事情可以做来提高此功能的安全性和隐私性，例如检查CSRF值，限制调用方法的次数，并使用随机生成的URL供用户重置密码，而不是通过电子邮件发送的硬编码解决方案。
- en: 'Finally, we need to run the Celery broker when we run our Flask app; otherwise,
    very little is going to happen. Don''t forget, this broker is the process that
    starts all our asynchronous workers. The simplest thing we can do is run the following
    command from within your Flask app directory:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们运行Flask应用程序时，我们需要运行Celery代理；否则，几乎不会发生任何事情。不要忘记，这个代理是启动所有异步工作者的进程。我们可以做的最简单的事情就是从Flask应用程序目录中运行以下命令：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This quite simply starts the Celery broker and tells it to look for the celery
    configuration within the `main` app so that it can find the configuration and
    the tasks it is supposed to be running.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单地启动了Celery代理，并告诉它查找`main`应用程序中的celery配置，以便它可以找到配置和应该运行的任务。
- en: Now we can start our Flask app and send some e-mails.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以启动我们的Flask应用程序并发送一些电子邮件。
- en: Creating command line instructions with Flask-script
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask-script创建命令行指令
- en: One really useful thing to do with Flask is to create a command-line interface
    so that, when others use your software, they can easily make use of the methods
    you provide, such as setting up the database, creating administrative users, or
    updating the CSRF secret key.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask非常有用的一件事是创建一个命令行界面，这样当其他人使用您的软件时，他们可以轻松地使用您提供的方法，比如设置数据库、创建管理用户或更新CSRF密钥。
- en: 'One area where we already have a script resembling this and one that can be
    used in this way is the `create_db.py` script in [Chapter 2](ch02.html "Chapter 2. Relational
    Databases with SQLAlchemy"), *Relational Databases with SQLAlchemy*. To do this,
    there is again, a Flask extension. Just run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一个类似的脚本，并且可以在这种方式中使用的脚本是[第2章](ch02.html "第2章。使用SQLAlchemy的关系数据库")中的`create_db.py`脚本，*使用SQLAlchemy的关系数据库*。为此，再次有一个Flask扩展。只需运行以下命令：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now the interesting thing with Flask-Script is that the commands work a lot
    like the routes and views in Flask. Let''s look at an example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Flask-Script的有趣之处在于，命令的工作方式与Flask中的路由和视图非常相似。让我们看一个例子：
- en: '[PRE36]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You can see here that Flask-Script refers to itself as Manager, but that the
    manager also hooks itself into the Flask app. This means you can do anything with
    the Flask app just by using the `app` reference.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里看到，Flask-Script将自己称为Manager，但管理器也将自己挂钩到Flask应用程序中。这意味着您可以通过使用`app`引用来对Flask应用程序执行任何操作。
- en: 'So, if we convert our `create_db.py` app into a Flask-Script app, we should
    create a file for this to work in. Let''s call it `manage.py` and insert from
    the file `create_db.py`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们将`create_db.py`应用程序转换为Flask-Script应用程序，我们应该创建一个文件来完成这项工作。让我们称之为`manage.py`，并从文件`create_db.py`中插入：
- en: '[PRE37]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: All this does is set up a decorator so that the `manage.py` with the argument
    `create_db` will run the method which was in `create_db.py`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些只是设置一个装饰器，以便`manage.py`带有参数`create_db`将运行`create_db.py`中的方法。
- en: 'We can now run from the following command line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以从以下命令行运行：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: References
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考
- en: '[https://highlightjs.org/](https://highlightjs.org/)'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://highlightjs.org/](https://highlightjs.org/)'
- en: '[http://pythonhosted.org/Flask-Markdown/](http://pythonhosted.org/Flask-Markdown/)'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://pythonhosted.org/Flask-Markdown/](http://pythonhosted.org/Flask-Markdown/)'
- en: '[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://daringfireball.net/projects/markdown/](http://daringfireball.net/projects/markdown/)'
- en: '[http://pythonhosted.org/Markdown/extensions](http://pythonhosted.org/Markdown/extensions)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://pythonhosted.org/Markdown/extensions](http://pythonhosted.org/Markdown/extensions)'
- en: '[https://pythonhosted.org/Frozen-Flask/](https://pythonhosted.org/Frozen-Flask/)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pythonhosted.org/Frozen-Flask/](https://pythonhosted.org/Frozen-Flask/)'
- en: '[https://disqus.com/](https://disqus.com/)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://disqus.com/](https://disqus.com/)'
- en: '[http://www.discourse.org](http://www.discourse.org)'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://www.discourse.org](http://www.discourse.org)'
- en: '[http://eviltrout.com/2014/01/22/embedding-discourse.html](http://eviltrout.com/2014/01/22/embedding-discourse.html)'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://eviltrout.com/2014/01/22/embedding-discourse.html](http://eviltrout.com/2014/01/22/embedding-discourse.html)'
- en: '[http://flask-script.readthedocs.org/en/latest/](http://flask-script.readthedocs.org/en/latest/)'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://flask-script.readthedocs.org/en/latest/](http://flask-script.readthedocs.org/en/latest/)'
- en: '[https://pythonhosted.org/Flask-Mail/](https://pythonhosted.org/Flask-Mail/)'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pythonhosted.org/Flask-Mail/](https://pythonhosted.org/Flask-Mail/)'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have done a wide variety of things. You have seen how to
    create your own Markdown renderer, so editing becomes easier, and move commands
    so they are within Flask and more manageable. We have created Atom feeds so that
    our readers can find new content when it is posted, and created asynchronous tasks
    so that we don't lock up the user's browser while waiting for a page to load.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们做了各种各样的事情。您已经看到如何创建自己的Markdown渲染器，以便编辑更容易，并将命令移动到Flask中，使其更易管理。我们创建了Atom
    feeds，这样我们的读者可以在发布新内容时找到它，并创建了异步任务，这样我们就不会在等待页面加载时锁定用户的浏览器。
- en: In our final chapter, we will learn how to turn our simple application into
    a fully deployed blog that has all the features discussed, secured, and ready
    to use.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们将学习如何将我们的简单应用程序转变为一个完全部署的博客，具有所有讨论的功能，已经得到保护，并且可以使用。
