- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Harnessing Web Services with the Raspberry Pi
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 利用树莓派利用网络服务
- en: In this chapter, we will begin to write code for web services to turn our Raspberry
    Pi into an **Internet of Things** (**IoT**) device. Using Python, we will design
    programs that pull data from online resources and use the data to create visuals
    on Sense HAT’s dot-matrix display. The practical examples we will cover in this
    chapter will serve as a building block for more advanced IoT web services development.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开始编写用于网络服务的代码，将我们的树莓派变成一个**物联网**（**IoT**）设备。使用Python，我们将设计程序从在线资源中提取数据，并使用这些数据在Sense
    HAT的点阵显示屏上创建视觉。本章中我们将涵盖的实用示例将作为更高级物联网网络服务开发的基石。
- en: We begin by exploring the world of web services – understanding their role and
    how we can exploit them to our advantage. We may think of web services as the
    lifeblood of the internet, circulating vital data across the digital world. Understanding
    web services isn’t just about adding another tool to our toolkit; it’s about unlocking
    a world filled with limitless potential.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先探索网络服务的世界——了解它们的作用以及我们如何利用它们来获得优势。我们可能会把网络服务视为互联网的生命线，在数字世界中循环传递重要数据。理解网络服务不仅仅是把另一个工具添加到我们的工具箱中；它是关于解锁一个充满无限潜力的世界。
- en: As we advance, we’ll transform theoretical knowledge into practical application
    through a series of programming projects. These projects are specifically designed
    to utilize the advanced web services offered by providers such as Alpha Vantage
    and OpenWeather. Using the versatile Raspberry Pi Sense HAT, or its emulator,
    we’ll construct applications including a scrolling stock ticker, a weather information
    display, and even a GO-NO-GO decision-maker for youth baseball games. These projects
    don’t just teach us how to use technology; they immerse us in the fundamental
    principles of IoT.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断进步，我们将通过一系列编程项目将理论知识转化为实际应用。这些项目专门设计用于利用Alpha Vantage和OpenWeather等提供商提供的先进网络服务。使用多功能的树莓派Sense
    HAT或其模拟器，我们将构建包括滚动股票行情、天气信息显示，甚至为青少年棒球比赛提供GO-NO-GO决策器的应用程序。这些项目不仅教会我们如何使用技术；它们让我们沉浸在物联网的基本原理中。
- en: Consider the vast array of opportunities that lie ahead with web services and
    the Raspberry Pi. Today, we’re starting with a simple stock ticker. Tomorrow,
    we might be developing a device that notifies us whenever our favorite team scores
    or even assists us in navigating through traffic. This chapter is our first step
    toward exploring a broader and more thrilling universe of IoT innovation.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下，随着网络服务和树莓派的出现，前方等待我们的广阔机会。今天，我们从简单的股票行情开始。明天，我们可能会开发出一种设备，在最喜欢的球队得分或帮助我们导航交通时通知我们。这一章节是我们探索更广阔、更激动人心的物联网创新宇宙的第一步。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring web services
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索网络服务
- en: Creating a scrolling stock ticker application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建滚动股票行情应用程序
- en: Developing weather display applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发天气显示应用程序
- en: Let’s begin!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is required to complete this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章需要以下内容：
- en: A Raspberry Pi 5 with either 4 GB or 8 GB of RAM (preferred); however, a late-model
    Raspberry Pi such as the Raspberry Pi 4 may be used.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台带有4 GB或8 GB RAM的Raspberry Pi 5（首选）；然而，可以使用最新型号的Raspberry Pi，如Raspberry Pi
    4。
- en: Raspberry Pi Sense HAT (Raspberry OS emulator may be used instead).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派Sense HAT（可以使用Raspberry OS模拟器代替）。
- en: Keyboard, mouse, and monitor.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键盘、鼠标和显示器。
- en: Access to a 3D printer or 3D printing service for the custom stand.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取3D打印机或定制展台的3D打印服务。
- en: The GitHub repository for the chapter, located at [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter2](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter2).
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章的GitHub仓库位于[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter2](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter2)。
- en: A general knowledge of programming. We will be using the Python programming
    language in this book.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对编程的一般了解。在这本书中，我们将使用Python编程语言。
- en: Exploring web services
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索网络服务
- en: Imagine remotely controlling our home’s devices from our smartphone – this amazing
    convenience is powered by web services, invisible messengers seamlessly connecting
    our digital world.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下从我们的智能手机远程控制我们家的设备——这种惊人的便利是由网络服务提供的，无形的信息使者无缝连接我们的数字世界。
- en: Web services form an integral part of today’s internet infrastructure. They
    allow for the seamless exchange of data between different software applications
    over the internet. As a result, they are an essential tool for IoT applications,
    including our Raspberry Pi IoT projects. With web services, we can draw on the
    wealth of data available online and bring it into the physical world using our
    Raspberry Pi.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务是当今互联网基础设施的重要组成部分。它们允许不同软件应用程序通过网络无缝交换数据。因此，它们是物联网应用，包括我们的树莓派物联网项目的一个基本工具。有了网络服务，我们可以利用在线数据的丰富资源，并通过我们的树莓派将其带入物理世界。
- en: 'At their core, web services are software interfaces that enable one software
    system to interact with another over a network. This interaction is typically
    done via specific protocols, such as **Representational State Transfer** (**REST**)
    or **Simple Object Access Protocol** (**SOAP**). To get a sense of the power of
    web services, consider the example shown in *Figure 2**.1* of a service that provides
    critical sensory data on a patient in a hospital room:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，网络服务是软件接口，它使一个软件系统能够通过网络与另一个系统交互。这种交互通常是通过特定的协议完成的，例如**表示状态转移**（**REST**）或**简单对象访问协议**（**SOAP**）。为了了解网络服务的强大功能，可以考虑*图2.1*中所示的一个服务示例，该服务提供医院病房中患者的关键感官数据：
- en: '![Figure 2.1 – Client application receiving data from the FHIR web service](img/B21282_02_1.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 客户端应用程序从FHIR网络服务接收数据](img/B21282_02_1.jpg)'
- en: Figure 2.1 – Client application receiving data from the FHIR web service
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 客户端应用程序从FHIR网络服务接收数据
- en: Here, we see a diagram representing the **Fast Healthcare Interoperability Resources**
    web service. **FHIR** (pronounced “fire”) is a standard developed by **Health
    Level Seven International** (**HL7**) for the electronic exchange of healthcare
    information. Web services such as FHIR offer universal accessibility, enabling
    healthcare professionals to access and share patient data from anywhere at any
    time. They provide superior interoperability, making them more efficient and practical
    than local network **Application Programming Interface** (**API**) calls, especially
    in the healthcare sector where data needs to be shared across different systems
    and devices.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个表示**快速健康互操作性资源**网络服务的图表。**FHIR**（发音为“fire”）是由**国际健康水平七组织**（**HL7**）制定的标准，用于医疗保健信息的电子交换。像FHIR这样的网络服务提供通用可访问性，使医疗保健专业人员能够随时随地访问和共享患者数据。它们提供优越的互操作性，比本地网络的**应用程序编程接口**（**API**）调用更高效、更实用，尤其是在需要在不同系统和设备之间共享数据的医疗保健领域。
- en: In this section, we will look at the protocols used by web services. We will
    also explore some of the more popular web services available before we write code
    to call a simple web service using our Raspberry Pi.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨网络服务使用的协议。在我们编写代码调用简单的网络服务之前，我们还将探索一些更受欢迎的网络服务。
- en: Understanding approaches for web services
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解网络服务的方法
- en: In the field of web services, two prominent approaches are the REST and SOAP
    protocols. RESTful web services use HTTP methods explicitly and are more straightforward
    and efficient, making them a popular choice for many developers. SOAP, on the
    other hand, is a protocol that permits programs running on siloed systems to communicate
    by using HTTP and its XML-based messaging system. SOAP is highly extensible and
    has strong support for security and reliability, making it suitable for complex
    applications.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务领域，两种突出的方法是REST和SOAP协议。RESTful网络服务明确使用HTTP方法，更加直接和高效，因此成为许多开发者的首选。另一方面，SOAP是一种允许在隔离系统中运行的程序通过HTTP及其基于XML的消息系统进行通信的协议。SOAP具有高度的扩展性，并且对安全和可靠性有强大的支持，使其适合复杂的应用程序。
- en: In our upcoming projects, we will primarily utilize REST for interacting with
    web services. However, understanding SOAP provides a broader view of the landscape
    of web service interactions. We will start by exploring SOAP, its functionality,
    and its applicable scenarios before diving into REST-based or RESTful web services.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们即将到来的项目中，我们将主要利用REST与网络服务进行交互。然而，了解SOAP提供了对网络服务交互领域的更广泛视角。我们将首先探索SOAP、其功能及其适用场景，然后再深入研究基于REST或RESTful的网络服务。
- en: Using SOAP web services
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用SOAP网络服务
- en: 'To understand SOAP, we turn our attention to the custom ordering system illustrated
    in *Figure 2**.2*. As this system was built in-house for a particular company’s
    business operations, it is a complex, enterprise-level application with significant
    requirements in terms of security and reliability. This ordering system represents
    an ideal use case for SOAP-based web services:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解SOAP，我们关注**图2.2**中展示的定制排序系统。由于这个系统是为特定公司的业务操作内部构建的，因此它是一个复杂的企业级应用，在安全性和可靠性方面有显著要求。这个排序系统代表了基于SOAP的网络服务的理想用例：
- en: '![Figure 2.2 – Custom ordering application connecting to the server using SOAP](img/B21282_02_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图2.2 – 使用SOAP连接服务器的定制排序应用程序](img/B21282_02_2.jpg)'
- en: Figure 2.2 – Custom ordering application connecting to the server using SOAP
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 使用SOAP连接服务器的定制排序应用程序
- en: With SOAP’s stateful nature, the application can manage complex transaction
    management that involves multiple steps, from inventory checks and payment processing
    to order confirmation. The SOAP protocol, with its built-in security features
    and error handling, enables the application to manage orders efficiently and securely.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SOAP具有有状态的性质，应用程序可以管理涉及多个步骤的复杂事务管理，包括库存检查、支付处理到订单确认。SOAP协议内置的安全功能和错误处理功能使得应用程序能够高效且安全地管理订单。
- en: As we can see in *Figure 2**.2*, an XML file is passed through HTTPS in a SOAP
    transaction. This XML file, nestled within the SOAP message, plays a crucial role
    in communication. It carries detailed instructions that guide the server’s actions.
    The structured format of XML enables complex data exchanges, allowing the custom
    ordering system to seamlessly interact with various other systems despite their
    possible diverse data formats.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如**图2.2**所示，在SOAP事务中，一个XML文件通过HTTPS传递。这个XML文件位于SOAP消息中，在通信中扮演着至关重要的角色。它携带详细的指令，指导服务器执行操作。XML的结构化格式使得复杂的数据交换成为可能，即使是在可能具有不同数据格式的各种系统之间，定制的排序系统也能无缝交互。
- en: If SOAP is the desired approach for enterprise-level applications, REST is preferred
    for public web services. REST’s simplicity, lightweight nature, scalability, and
    resource-oriented approach make it ideal for creating user-friendly and scalable
    web services that interact with resources through standard HTTP protocols.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果SOAP是企业级应用的首选方法，那么REST则更适用于公共网络服务。REST的简洁性、轻量级特性、可扩展性和面向资源的处理方式使其非常适合创建用户友好且可扩展的网络服务，这些服务通过标准的HTTP协议与资源进行交互。
- en: Investigating RESTful web services
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索RESTful网络服务
- en: RESTful web services are a key aspect of modern web applications, allowing for
    efficient communication between clients and servers using the REST architecture.
    RESTful web services employ HTTP methods such as `GET`, `POST`, `PUT`, and `DELETE`
    to interact with resources and are stateless. Unlike SOAP, which typically uses
    XML, RESTful services can support multiple data formats, including JSON and XML.
    This flexibility often leads to RESTful services being perceived as simpler to
    use and more adaptable than SOAP.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful网络服务是现代网络应用的关键组成部分，它允许客户端和服务器使用REST架构进行高效的通信。RESTful网络服务使用HTTP方法如`GET`、`POST`、`PUT`和`DELETE`与资源进行交互，并且是无状态的。与通常使用XML的SOAP不同，RESTful服务可以支持多种数据格式，包括JSON和XML。这种灵活性通常导致人们认为RESTful服务比SOAP更易于使用且更具适应性。
- en: Several widely recognized public RESTful web services have gained popularity
    due to their functionality and ease of use. Among them is the `Twitter` API, which
    allows developers to access and interact with core Twitter data, including timelines,
    status updates, and other information. Another notable example is the Google Maps
    API, which provides developers with the ability to embed Google Maps on web pages
    using JavaScript.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 几个广为人知的公共RESTful网络服务因其功能性和易用性而受到欢迎。其中之一是`Twitter` API，它允许开发者访问和交互核心Twitter数据，包括时间线、状态更新和其他信息。另一个值得注意的例子是Google
    Maps API，它为开发者提供了在网页上使用JavaScript嵌入Google Maps的能力。
- en: 'In *Figure 2**.3*, we see a simplified diagram of a RESTful web service communicating
    with a web page using the `GET`, `POST`, `PUT`, and `DELETE` HTTP methods. Each
    of these HTTP methods corresponds to a specific type of interaction with the server:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图2.3**中，我们看到一个简化图，展示了RESTful网络服务使用`GET`、`POST`、`PUT`和`DELETE` HTTP方法与网页进行通信。这些HTTP方法中的每一个都对应于与服务器交互的特定类型：
- en: '![Figure 2.3 – Simplified diagram of a RESTful web service](img/B21282_02_3.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图2.3 – RESTful网络服务的简化图](img/B21282_02_3.jpg)'
- en: Figure 2.3 – Simplified diagram of a RESTful web service
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – RESTful Web服务的简化图
- en: The `GET` method retrieves existing data, `POST` is typically used to send new
    data for the creation of a resource, `PUT` is used to update existing resources,
    and `DELETE` removes data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`GET`方法检索现有数据，`POST`通常用于发送新数据以创建资源，`PUT`用于更新现有资源，而`DELETE`用于删除数据。'
- en: Difference between an API and a web service
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: API与Web服务的区别
- en: We may find ourselves using the terms *API* and *web service* interchangeably;
    however, there is a difference. An **API** is a broad term defining rules and
    conventions for building and interacting with software applications. APIs can
    operate over various channels and not just the web. A **web service**, however,
    is a specific type of API that operates over the internet, typically using protocols
    such as HTTP. In essence, all web services are APIs, but not all APIs are web
    services.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会发现自己交替使用*API*和*Web服务*这两个术语；然而，它们之间是有区别的。**API**是一个广泛的术语，定义了构建和与软件应用程序交互的规则和约定。API可以在各种渠道上运行，而不仅仅是Web。然而，**Web服务**是一种特定的API类型，它通过互联网运行，通常使用HTTP等协议。本质上，所有Web服务都是API，但并非所有API都是Web服务。
- en: 'Considering the Twitter API as an example of a web service that we could develop
    a client for, the application of these HTTP methods would be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以Twitter API为例，我们可以为其开发客户端的Web服务，这些HTTP方法的运用如下：
- en: '`GET`: We would use this method to retrieve data from Twitter. For example,
    we would use a `GET` request to fetch a specific user’s tweets or search for tweets
    that contain a specific hashtag.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：我们会使用这种方法从Twitter检索数据。例如，我们会使用`GET`请求来获取特定用户的推文或搜索包含特定标签的推文。'
- en: '`POST`: We would use this method when we want to create new data on Twitter,
    such as a new tweet.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：当我们想在Twitter上创建新数据时，例如一条新推文，我们会使用这种方法。'
- en: '`PUT`: We wouldn’t use this method as the Twitter API doesn’t natively support
    the `PUT` HTTP method.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：我们不会使用这种方法，因为Twitter API原生不支持`PUT` HTTP方法。'
- en: '`DELETE`: We would use the `DELETE` method to remove existing data on Twitter.
    However, this method is not widely used in the Twitter API as deletion capabilities
    are limited due to Twitter’s policies.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：我们会使用`DELETE`方法来删除Twitter上的现有数据。然而，由于Twitter的政策限制，删除功能有限，这种方法在Twitter
    API中并不常用。'
- en: 'We can see REST methods outlined in the following table:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下表格中看到REST方法概述：
- en: '![Figure 2.4 – REST methods summarized](img/B21282_02_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图2.4 – REST方法概述](img/B21282_02_4.jpg)'
- en: Figure 2.4 – REST methods summarized
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – REST方法概述
- en: To summarize, REST is a straightforward approach that leverages standard HTTP
    or HTTPS methods such as `PUT`, `POST`, `GET`, and `DELETE` while also offering
    flexibility in data formats such as **JavaScript Object Notation** (**JSON**)
    or XML, whereas SOAP is a protocol that typically uses XML to transmit structured
    messages and can operate over various **Internet Protocol** (**IP**) suite networks
    such as HTTP or HTTPS.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，REST是一种简单直接的方法，它利用标准的HTTP或HTTPS方法，如`PUT`、`POST`、`GET`和`DELETE`，同时在数据格式方面提供灵活性，例如**JavaScript对象表示法**（**JSON**）或XML，而SOAP是一种通常使用XML来传输结构化消息的协议，并且可以在各种**互联网协议**（**IP**）套件网络，如HTTP或HTTPS上运行。
- en: Now that we have a basic understanding of web services and the way we can implement
    them, let’s create a real-world example using our Raspberry Pi and Sense HAT.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对Web服务和它们的实现方式有了基本的了解，让我们通过使用我们的Raspberry Pi和Sense HAT来创建一个现实世界的示例。
- en: Connecting to a web service with our Raspberry Pi and Sense HAT
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用我们的Raspberry Pi和Sense HAT连接到Web服务
- en: In this section, we will connect our Raspberry Pi to a web service and display
    the result on the dot-matrix screen of our Sense HAT (or emulator). The service
    we will connect to will be a dummy web service, designed to evaluate RESTful web
    service calls.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将把我们的Raspberry Pi连接到Web服务，并在Sense HAT（或模拟器）的点阵屏幕上显示结果。我们将连接到的服务将是一个虚拟Web服务，旨在评估RESTful
    Web服务的调用。
- en: 'In *Figure 2**.5*, we see an example of a Raspberry Pi pulling weather information
    from a web service and using the dot-matrix display of the Sense HAT to display
    a cloud:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图2.5**中，我们看到一个Raspberry Pi从Web服务中提取天气信息，并使用Sense HAT的点阵显示屏显示云图的示例：
- en: '![Figure 2.5 – Sense HAT displaying a cloud indicating current weather conditions](img/B21282_02_5.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图2.5 – Sense HAT显示表示当前天气状况的云图](img/B21282_02_5.jpg)'
- en: Figure 2.5 – Sense HAT displaying a cloud indicating current weather conditions
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 – Sense HAT显示表示当前天气状况的云图
- en: The cloud represents current weather conditions (not to be confused with the
    cloud representing the web service). Such an application could show an animation
    on the dot-matrix screen. We could even swap the weather web service for another
    web service and create an entirely new application, leveraging the existing code
    easily.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 云代表当前的天气状况（不要与代表Web服务的云混淆）。这样的应用程序可以在点阵屏幕上显示动画。我们甚至可以替换天气Web服务为另一个Web服务，并创建一个全新的应用程序，利用现有的代码轻松实现。
- en: Before creating a web service client, we need to set up our development environment
    and install the necessary packages for our code to work. We will incorporate a
    Python virtual environment to do so.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建Web服务客户端之前，我们需要设置我们的开发环境并安装代码运行所需的必要包。我们将整合一个Python虚拟环境来完成这一任务。
- en: Setting up our development environment
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we do the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的开发使用Python虚拟环境。由于有一些库只与Python的根安装版本兼容，我们将在Python虚拟环境中使用系统包。为此，我们执行以下操作：
- en: On our Raspberry Pi 5, we open a Terminal application.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的树莓派5上，我们打开一个终端应用程序。
- en: 'To store our project files, we create a new directory with the following command:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了存储我们的项目文件，我们使用以下命令创建一个新的目录：
- en: '[PRE0]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We then navigate to the new directory with the following command:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令导航到新目录：
- en: '[PRE1]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We create a new Python virtual environment for our project with the following
    command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令为我们的项目创建一个新的Python虚拟环境：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With our new Python virtual environment created, we source into it (set the
    Python virtual environment) with the following command:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们创建新的Python虚拟环境后，我们使用以下命令将其源码导入（设置Python虚拟环境）：
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Figure 2.6 – Terminal using ch2-env environment](img/B21282_02_6.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图2.6 – 使用ch2-env环境的终端](img/B21282_02_6.jpg)'
- en: Figure 2.6 – Terminal using ch2-env environment
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 使用ch2-env环境的终端
- en: 'We install the extra packages required for our code with the following command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令安装代码所需的额外包：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: exit
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 退出
- en: '[PRE5]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are now ready to load up Thonny. We do so by clicking on the **Menu** icon
    in the Raspberry Pi taskbar, navigating to the **Programming** category, and selecting
    **Thonny**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好加载Thonny。我们通过点击树莓派任务栏中的**菜单**图标，导航到**编程**类别，并选择**Thonny**来完成这一操作。
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it is not already selected.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Thonny使用树莓派内置的Python版本。对于我们的项目，我们将使用我们刚刚创建的Python虚拟环境。首先，我们需要通过点击**查看**并选择**文件**来查看项目文件（如果尚未选择）。
- en: In the `Files` section, we locate the `ch2-env` directory.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文件**部分，我们定位到`ch2-env`目录。
- en: 'We then right-click on the folder and select the **Activate virtual** **environment**
    option:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们右键点击文件夹并选择**激活虚拟环境**选项：
- en: '![Figure 2.7 – Activating a Python virtual environment in Thonny](img/B21282_02_7.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – 在Thonny中激活Python虚拟环境](img/B21282_02_7.jpg)'
- en: Figure 2.7 – Activating a Python virtual environment in Thonny
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 在Thonny中激活Python虚拟环境
- en: With our project folder created, our Python virtual environment set up and activated,
    and the `requests` package installed, we may now start writing code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建项目文件夹、设置并激活Python虚拟环境，以及安装了`requests`包之后，我们现在可以开始编写代码。
- en: Writing our first web service code
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写我们的第一个Web服务代码
- en: 'We are now ready to write our first web service code. This code will make a
    call to a dummy web service used for testing. Upon successful transmission, a
    success message will scroll across the dot-matrix screen of our Sense HAT:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好编写我们的第一个Web服务代码。此代码将对一个用于测试的虚拟Web服务进行调用。在成功传输后，成功信息将在我们的Sense HAT的点阵屏幕上滚动显示：
- en: 'To create our web service application, inside Thonny we create a new tab. Inside
    the tab, we write the following code:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建我们的Web服务应用程序，在Thonny中我们创建一个新的标签页。在标签页内，我们编写以下代码：
- en: '[PRE6]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before we run our code, let’s break it down:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行代码之前，让我们将其分解：
- en: We start by importing the `requests` library, a popular library in Python for
    making HTTP requests.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入`requests`库，这是Python中用于发送HTTP请求的流行库。
- en: We then import the `SenseHat` class from the `sense_hat` library, allowing us
    to interact with the Sense HAT board. For those of us using the Sense HAT emulator,
    we would use the `sense_emu` library instead.
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从 `sense_hat` 库中导入 `SenseHat` 类，使我们能够与 Sense HAT 板交互。对于使用 Sense HAT 模拟器的我们，我们会使用
    `sense_emu` 库。
- en: We send a `GET` request to the specified URL (`'https://jsonplaceholder.typicode.com/posts'`),
    which is an endpoint of a dummy API that provides placeholder data in the JSON
    format. The response from the server is stored in the `response` variable.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们向指定的 URL 发送 `GET` 请求（`'https://jsonplaceholder.typicode.com/posts'`），这是一个提供
    JSON 格式占位符数据的虚拟 API 的端点。服务器的响应存储在 `response` 变量中。
- en: We create an instance of the `SenseHat` class. We use this object to control
    the Sense HAT’s dot-matrix display.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个 `SenseHat` 类的实例。我们使用这个对象来控制 Sense HAT 的点阵显示屏。
- en: The `sense.set_rotation(270)` line adjusts the orientation of the Sense HAT’s
    LED matrix so that it matches the orientation of the Raspberry Pi in our custom
    case (refer to [*Chapter 1*](B21282_01.xhtml#_idTextAnchor014) for information
    on the custom Raspberry Pi case).
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`sense.set_rotation(270)` 这一行调整了 Sense HAT 的 LED 矩阵的方向，使其与我们的定制 Raspberry Pi
    案例中的 Raspberry Pi 方向相匹配（有关定制 Raspberry Pi 案例的信息，请参阅 [*第 1 章*](B21282_01.xhtml#_idTextAnchor014)）。'
- en: 'Our code then checks the HTTP response’s status code:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们的代码检查 HTTP 响应的状态码：
- en: 'If the status code is `200`, which indicates a successful HTTP request, the
    following then occurs:'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态码是 `200`，这表示一个成功的 HTTP 请求，那么接下来会发生以下情况：
- en: '`data = response.json()`: Our code converts the JSON response body into a Python
    data structure.'
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data = response.json()`: 我们的代码将 JSON 响应体转换为 Python 数据结构。'
- en: '`print(data[0][''title''])`: Our code prints the title of the first post from
    the response data to the shell in Thonny.'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print(data[0][''title''])`: 我们的代码将响应数据中的第一篇帖子的标题打印到 Thonny 的 Shell 中。'
- en: Our code displays a success message on the Sense HAT’s LED matrix, indicating
    the successful status code.
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码在 Sense HAT 的 LED 矩阵上显示一个成功消息，指示成功的状态码。
- en: 'If the status code is not `200`, which indicates an unsuccessful HTTP request,
    the following happens:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果状态码不是 `200`，这表示一个不成功的 HTTP 请求，以下情况会发生：
- en: Our code prints an error message to the Shell, indicating the unsuccessful status
    code.
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码将错误消息打印到 Shell，指示不成功的状态码。
- en: Our code displays a failure message on the Sense HAT’s LED matrix, indicating
    the unsuccessful status code.
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的代码在 Sense HAT 的 LED 矩阵上显示一个失败消息，指示不成功的状态码。
- en: We save the code as `webservice-test.py` and then run it by clicking on the
    green run button at the top, hitting *F5* on the keyboard, or clicking on the
    **Run** menu option at the top and then **Run** **current script**.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为 `webservice-test.py`，然后通过点击顶部的绿色运行按钮、按键盘上的 *F5* 或者在顶部的 **运行** 菜单选项中然后点击
    **运行** **当前脚本** 来运行它。
- en: 'Upon a successful web service call (which is to be expected with this dummy
    service), we should see a title print to the Shell looking like the following:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在成功完成网络服务调用（对于这个虚拟服务来说是预期的）后，我们应该在 Shell 中看到以下标题打印出来：
- en: '![Figure 2.8 – Testing a web service call using Thonny](img/B21282_02_8.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 使用 Thonny 测试网络服务调用](img/B21282_02_8.jpg)'
- en: Figure 2.8 – Testing a web service call using Thonny
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 使用 Thonny 测试网络服务调用
- en: We shouldn’t be too concerned about the contents of the title as it is just
    dummy data. Subsequently, upon successful completion of the web service call,
    we should observe a scrolling message on the Sense HAT display (or the emulator).
    This message signifies the successful status of our call, which should be denoted
    by the `200` HTTP status code.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不应该过分关注标题的内容，因为它只是占位符数据。随后，在成功完成网络服务调用后，我们应该在 Sense HAT 显示屏（或模拟器）上观察到滚动消息。这条消息表示我们的调用状态成功，应该用
    `200` HTTP 状态码表示。
- en: Although our code lacks error checking, we have successfully constructed our
    first IoT device powered by the Raspberry Pi. It’s important to note that considerations
    such as internet connectivity are not incorporated into our simple code.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的代码缺少错误检查，但我们已经成功构建了我们第一个由 Raspberry Pi 驱动的物联网设备。需要注意的是，像互联网连接这样的考虑因素并没有包含在我们的简单代码中。
- en: 'In the remaining sections of this chapter, we will elevate our IoT device from
    being a simple web service testing tool to something more engaging. We will take
    on two exciting projects: the construction of a stock ticker application and a
    weather-dependent GO-NO-GO decision-making application.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将把我们的物联网设备从简单的网络服务测试工具提升到一个更具吸引力的工具。我们将承担两个令人兴奋的项目：构建股票行情应用和基于天气的GO-NO-GO决策应用。
- en: Creating a scrolling stock ticker application
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个滚动股票行情应用
- en: It’s now time to build our first practical IoT device. For this project, we
    will create a stock ticker application with our Raspberry Pi and Sense HAT. A
    stock ticker is a device, physical or digital, that presents stock prices in real
    time. Our application will fetch real-time stock prices from Alpha Vantage, an
    online service providing free APIs for data on stocks. In our application, we
    will be retrieving the current stock price for Apple, listed on the Nasdaq stock
    exchange as *AAPL*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候构建我们的第一个实用物联网设备了。对于这个项目，我们将使用Raspberry Pi和Sense HAT创建一个股票行情应用。股票行情是一种设备，可以是物理的也可以是数字的，它实时显示股票价格。在我们的应用中，我们将从Alpha
    Vantage（一个提供股票数据免费API的在线服务）获取实时股票价格。在我们的应用中，我们将检索纳斯达克证券交易所上市的苹果公司（股票代码为*AAPL*）的当前股票价格。
- en: 'We can see our stock ticker application illustrated in *Figure 2**.9*. We will
    use the HTTP `GET` method to retrieve information with the response in JSON format,
    a lightweight data-interchange format that is easy for humans to read and write
    and easy for machines to parse and generate:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在*图2.9*中看到我们的股票行情应用示意图。我们将使用HTTP `GET`方法以JSON格式检索信息，这是一种轻量级的数据交换格式，易于人类阅读和编写，也易于机器解析和生成：
- en: '![Figure 2.9 – Diagram of our stock ticker application; the double arrows symbolize
    the call and subsequent response from the Alpha Vantage web service](img/B21282_02_9.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图2.9 – 我们股票行情应用的示意图；双箭头表示对Alpha Vantage网络服务的调用及其后续响应](img/B21282_02_9.jpg)'
- en: Figure 2.9 – Diagram of our stock ticker application; the double arrows symbolize
    the call and subsequent response from the Alpha Vantage web service
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 – 我们股票行情应用的示意图；双箭头表示对Alpha Vantage网络服务的调用及其后续响应
- en: 'In our case, when we request data for the `AAPL` stock symbol, the **Alpha
    Vantage API** sends back a JSON object response, as illustrated in *Figure 2**.10*:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，当我们请求`AAPL`股票符号的数据时，**Alpha Vantage API**会发送一个如图*图2.10*所示的JSON对象响应：
- en: '![Figure 2.10 – JSON object response from Alpha Vantage web service call](img/B21282_02_10.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – Alpha Vantage网络服务调用的JSON对象响应](img/B21282_02_10.jpg)'
- en: Figure 2.10 – JSON object response from Alpha Vantage web service call
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – Alpha Vantage网络服务调用的JSON对象响应
- en: The response encompasses 10 parameters for every successful API request. Out
    of these parameters, our stock ticker application will focus on `symbol`, `volume`,
    `price`, and `change`. These specific data points will be used to create a message
    that we will scroll across the dot-matrix screen of the Sense HAT.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 响应包含了每个成功的API请求的10个参数。在这些参数中，我们的股票行情应用将关注`symbol`、`volume`、`price`和`change`。这些具体的数据点将被用来创建一个信息，我们将滚动显示在Sense
    HAT的点阵屏幕上。
- en: However, before we can write our web service code, we must first acquire an
    API key from Alpha Vantage. This key grants us permission to make the necessary
    web service calls.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们编写网络服务代码之前，我们必须首先从Alpha Vantage获取一个API密钥。这个密钥赋予我们进行必要的网络服务调用的权限。
- en: Getting an API key
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取API密钥
- en: Securing an API key from Alpha Vantage is a straightforward process that can
    be accomplished in just a few steps. We start by navigating to the Alpha Vantage
    website at [https://www.alphavantage.co](https://www.alphavantage.co).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从Alpha Vantage获取API密钥是一个简单的过程，只需几个步骤即可完成。我们首先导航到Alpha Vantage网站[https://www.alphavantage.co](https://www.alphavantage.co)。
- en: From there, we click on the **GET FREE API KEY** button – this should be easy
    to locate on the home page. Clicking this button will lead us to a sign-up form.
    We fill out the required details on this form, making sure to provide a valid
    email address. We should be given an API key once the form has been filled out,
    and we click on the **GET FREE API** **KEY** button.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们点击**获取免费API密钥**按钮 – 这个按钮应该很容易在主页上找到。点击此按钮将带我们到一个注册表单。我们填写表单上的必要详细信息，确保提供一个有效的电子邮件地址。一旦填写完表单，我们应该会得到一个API密钥，然后点击**获取免费API密钥**按钮。
- en: Important note
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The preceding instructions are valid as of the time of this writing. Please
    follow any changes to the process to get the API key.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上述说明在撰写本文时有效。请遵循任何对获取 API 密钥过程的更改。
- en: Once the API key has been issued, we must copy and paste it into a text editor
    as we require this key every time we make a call to the Alpha Vantage web service.
    As a free user, we are limited to 5 API requests per minute and a total of 500
    API requests per day.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦颁发 API 密钥，我们必须将其复制并粘贴到文本编辑器中，因为我们每次调用 Alpha Vantage 网络服务都需要这个密钥。作为免费用户，我们每分钟限制
    5 个 API 请求，每天总共 500 个 API 请求。
- en: Armed with our API key, we can now start to write code for our application.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们的 API 密钥，我们现在可以开始编写应用程序的代码。
- en: Writing web services client code
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写网络服务客户端代码
- en: In this section, we will start developing web service code to fetch current
    stock information for the company Apple (AAPL). Our objective is to retrieve the
    JSON object response from the Alpha Vantage web service, which will contain the
    relevant stock data we need for our scrolling stock ticker application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将开始开发用于获取苹果公司（AAPL）当前股票信息的网络服务代码。我们的目标是检索 Alpha Vantage 网络服务的 JSON 对象响应，这将包含我们用于滚动股票行情应用所需的相关股票数据。
- en: 'To create our web service code, we do the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的网络服务代码，我们执行以下操作：
- en: We launch Thonny on our Raspberry Pi and activate the `ch2-env` Python virtual
    environment using the steps in the previous section.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Raspberry Pi 上启动 Thonny 并使用上一节中的步骤激活 `ch2-env` Python 虚拟环境。
- en: 'We then open a new tab in Thonny and enter the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在 Thonny 中打开一个新的标签页并输入以下代码：
- en: '[PRE7]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before we run our code, let’s break it down:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行代码之前，让我们将其分解：
- en: We start by importing the `requests` module, which is a widely used Python library
    for making HTTP requests. It provides convenient methods to send HTTP requests
    such as `GET`, `POST`, and so on and handles underlying network communication.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入 `requests` 模块，这是一个广泛使用的 Python 库，用于发送 HTTP 请求。它提供了发送 HTTP 请求（如 `GET`、`POST`
    等）的便捷方法，并处理底层网络通信。
- en: We then import the built-in `json` module in Python. The `json` module provides
    methods to work with JSON data. It allows encoding Python objects into JSON strings
    (`json.dumps()`) and decoding JSON strings into Python objects (`json.loads()`).
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导入 Python 的内置 `json` 模块。`json` 模块提供了处理 JSON 数据的方法。它允许将 Python 对象编码为 JSON
    字符串（`json.dumps()`）并将 JSON 字符串解码为 Python 对象（`json.loads()`）。
- en: We store our personal API key from Alpha Vantage in a variable called `api_key`.
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将来自 Alpha Vantage 的个人 API 密钥存储在一个名为 `api_key` 的变量中。
- en: We set the `symbol` variable to `'AAPL'`, representing the stock symbol for
    Apple.
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `symbol` 变量设置为 `'AAPL'`，代表苹果公司的股票符号。
- en: The `base_url` variable stores the base URL for the Alpha Vantage API.
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`base_url` 变量存储 Alpha Vantage API 的基础 URL。'
- en: We set the `function` variable to `'GLOBAL_QUOTE'`, indicating the specific
    function to retrieve global stock quotes.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `function` 变量设置为 `'GLOBAL_QUOTE'`，表示要检索全球股票报价的特定函数。
- en: We construct the `complete_url` variable by combining the base URL, function,
    symbol, and API key to form a complete URL for the API request.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过组合基础 URL、函数、符号和 API 密钥来构建 `complete_url` 变量，从而形成 API 请求的完整 URL。
- en: Our code then sends a `GET` request to the Alpha Vantage API using `requests.get()`
    and stores the response in the `response` variable.
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码随后使用 `requests.get()` 向 Alpha Vantage API 发送 `GET` 请求，并将响应存储在 `response`
    变量中。
- en: We extract the JSON response from the `response` object using `.json()`, and
    the resulting data is stored in the `data` variable.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `.json()` 从 `response` 对象中提取 JSON 响应，并将结果数据存储在 `data` 变量中。
- en: Finally, the code prints `data` in a formatted JSON representation using `json.dumps()`
    with the `indent` parameter set to `4`.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，代码使用 `json.dumps()` 并将 `indent` 参数设置为 `4` 来以格式化的 JSON 表示形式打印 `data`。
- en: We save the code as `alphavantage-test.py` and then run it by clicking on the
    green run button, hitting *F5* on the keyboard, or clicking on the **Run** menu
    option at the top and then **Run** **current script**.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为 `alphavantage-test.py`，然后通过点击绿色运行按钮、按键盘上的 *F5* 或者在顶部菜单中选择 **运行** 选项然后选择
    **运行当前脚本** 来运行它。
- en: 'We should see a JSON object like what we see in *Figure 2**.11* displayed in
    the console:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该在控制台中看到类似于 *图 2.11* 中显示的 JSON 对象：
- en: '![Figure 2.11 – JSON response displayed in Thonny’s Shell](img/B21282_02_11.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.11 – 在 Thonny 的 Shell 中显示的 JSON 响应](img/B21282_02_11.jpg)'
- en: Figure 2.11 – JSON response displayed in Thonny’s Shell
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.11 – 在 Thonny 的 Shell 中显示的 JSON 响应
- en: Important note – code not for production
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示 – 代码仅供演示
- en: Please note that in the provided code, error checking has been omitted for the
    sake of simplicity. If this application were to be deployed to a production environment
    (for use by customers, for example), we would be sure to include appropriate error-handling
    and error-checking mechanisms to ensure the reliability and stability of the application.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在提供的代码中，为了简化，省略了错误检查。如果这个应用程序要部署到生产环境（例如供客户使用），我们一定会包括适当的错误处理和错误检查机制，以确保应用程序的可靠性和稳定性。
- en: With our code to pull stock information from the internet done, it is now time
    to utilize the dot-matrix screen of the Sense HAT to create a scrolling stock
    ticker.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从互联网上拉取股票信息的代码完成后，现在是我们利用Sense HAT的点阵屏幕创建滚动股票行情的时候了。
- en: Enhancing our application
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化我们的应用程序
- en: With our understanding of how to use the Alpha Vantage web service, we are now
    able to create an application that fetches stock data and transforms it into a
    real-life scrolling stock ticker. Our application takes advantage of the Sense
    HAT’s dot-matrix display, turning it into a dynamic canvas for the stock ticker.
    Instead of printing the JSON response to the console, the stock information will
    elegantly scroll across the Sense HAT display, providing a visually captivating
    representation of the data.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们对Alpha Vantage网络服务的理解，我们现在能够创建一个应用程序，它能够获取股票数据并将其转换为现实生活中的滚动股票行情。我们的应用程序利用了Sense
    HAT的点阵显示屏，将其变成股票行情的动态画布。我们不再将JSON响应打印到控制台，股票信息将优雅地滚动穿过Sense HAT显示屏，提供数据的视觉吸引表示。
- en: 'To create our web service code, we launch Thonny on our Raspberry Pi and create
    a new tab:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的网络服务代码，我们在Raspberry Pi上启动Thonny并创建一个新标签页：
- en: We launch Thonny on our Raspberry Pi and activate the `ch2-env` Python virtual
    environment using the steps in the previous section.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Raspberry Pi上启动Thonny，并使用上一节中的步骤激活`ch2-env` Python虚拟环境。
- en: 'In a new tab in Thonny, we start our code by importing the necessary libraries:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Thonny的新标签页中，我们首先导入必要的库：
- en: '[PRE8]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In our code, we import the `requests` module, as well as the `SenseHat` class
    from the `sense_hat` module. For those of us using the Sense HAT emulator, we
    would change this to `from sense_emu import SenseHat`. We then import the `time`
    module.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们导入了`requests`模块，以及从`sense_hat`模块中导入的`SenseHat`类。对于使用Sense HAT模拟器的我们，需要将此改为`from
    sense_emu import SenseHat`。然后我们导入`time`模块。
- en: 'With our libraries in place, we create and set the variables we use in our
    code:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的库就绪后，我们创建并设置我们在代码中使用的变量：
- en: '[PRE9]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In these code lines, we use the `api_key` variable to store our unique Alpha
    Vantage API key for accessing a web service. We use the `symbol` variable to store
    the stock symbol (for example, `'AAPL'`) for which data will be fetched. The `base_url`
    variable is used to store the base URL of the web service API. The `function`
    variable is used to define the specific function to be called from the web service
    API (for example, `'GLOBAL_QUOTE'`). We then create an instance of the `SenseHat`
    class and assign it to the `sense` variable to interact with the Sense HAT (or
    emulator). We set the rotation of the Sense HAT display to `270` degrees using
    `sense.set_rotation(270)`. This is so that it matches the orientation of the Raspberry
    Pi in our custom case. We could comment this line out for the emulator. We then
    initialize the `last_call_time` variable with the current time minus 180 seconds,
    which allows an immediate first call to the web service. We initialize the `last_ticker_info`
    variable as an empty string to store the previous ticker information.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这些代码行中，我们使用`api_key`变量来存储我们访问网络服务的唯一Alpha Vantage API密钥。我们使用`symbol`变量来存储要获取数据的股票符号（例如，`'AAPL'`）。`base_url`变量用于存储网络服务API的基本URL。`function`变量用于定义要从网络服务API中调用的特定函数（例如，`'GLOBAL_QUOTE'`）。然后我们创建`SenseHat`类的实例，并将其分配给`sense`变量以与Sense
    HAT（或模拟器）交互。我们使用`sense.set_rotation(270)`将Sense HAT显示屏的旋转设置为`270`度，这样它就与我们的定制外壳中的Raspberry
    Pi的方向相匹配。对于模拟器，我们可以取消注释这一行。然后我们使用当前时间减去180秒初始化`last_call_time`变量，这样就可以立即对网络服务进行第一次调用。我们将`last_ticker_info`变量初始化为空字符串，以存储之前的股票行情信息。
- en: 'Below our variable declarations, we implement an infinite loop to continuously
    display the ticker information; however, to comply with API rate limits of 5 requests
    per minute and 500 requests per day, we introduce a time delay of 3 minutes between
    each web service call. We type the following code below our variable declarations:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的变量声明下方，我们实现了一个无限循环以持续显示行情信息；然而，为了遵守每分钟5次请求和每天500次请求的API速率限制，我们在每次网络服务调用之间引入了3分钟的时间延迟。我们在变量声明下方键入以下代码：
- en: '[PRE10]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our code is wrapped in a `while True` loop, which ensures continuous execution
    of the following code block:'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的代码被包裹在一个`while True`循环中，这确保了以下代码块的持续执行：
- en: We set the `current_time` variable to the current time using `time.time()`.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`time.time()`将`current_time`变量设置为当前时间。
- en: Our code then checks whether the difference between `current_time` and `last_call_time`
    is greater than or equal to 180 seconds.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码随后检查`current_time`和`last_call_time`之间的差异是否大于或等于180秒。
- en: 'If `True`, the following happens:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果为`True`，则发生以下情况：
- en: A `complete_url` variable is created using an f-string to form the URL for the
    API call.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用f-string创建一个`complete_url`变量，以形成API调用的URL。
- en: An HTTP `GET` request is sent to the API using `requests.get(complete_url)`,
    and the response is stored in the `response` variable.
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`requests.get(complete_url)`向API发送HTTP `GET`请求，并将响应存储在`response`变量中。
- en: The response is parsed as JSON using `response.json()` and assigned to the `data`
    variable.
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`response.json()`将响应解析为JSON，并分配给`data`变量。
- en: The relevant stock information is extracted from the `data` dictionary and formatted
    into a `ticker_info` string.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`data`字典中提取相关的股票信息，并将其格式化为`ticker_info`字符串。
- en: The `last_ticker_info` variable is updated to store the current `ticker_info`
    value.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`last_ticker_info`变量更新以存储当前的`ticker_info`值。
- en: The `ticker_info` string is displayed on the Sense HAT’s dot-matrix display
    using `sense.show_message()`, with a scrolling speed of 0.05 seconds and white
    text color (`255,255,255`).
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sense.show_message()`将`ticker_info`字符串显示在Sense HAT的点阵显示屏上，滚动速度为0.05秒，白色文字颜色（`255,255,255`）。
- en: The `last_call_time` variable is updated to the current time (`current_time`)
    to mark the timestamp of the last API call.
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`last_call_time`变量更新为当前时间（`current_time`），以标记上次API调用的时间戳。
- en: If `False`, the previous `last_ticker_info` variable is displayed on the Sense
    HAT display with a scrolling speed of 0.05 seconds and white text color (`255,255,255`).
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果为`False`，则将上一个`last_ticker_info`变量显示在Sense HAT显示屏上，滚动速度为0.05秒，白色文字颜色（`255,255,255`）。
- en: Our program then sleeps for 1 second using `time.sleep(1)` before the next iteration
    of the loop. This is done to regulate resource consumption and control the update
    frequency of the Sense HAT’s dot-matrix display.
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在循环的下一个迭代之前，我们的程序使用`time.sleep(1)`暂停1秒钟。这是为了调节资源消耗和控制Sense HAT点阵显示屏的更新频率。
- en: We save our code as `aapl-stock-ticker.py` and then run it by clicking on the
    green run button, hitting *F5* on the keyboard, or clicking on the **Run** menu
    option at the top and then **Run** **current script**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的代码保存为`aapl-stock-ticker.py`，然后通过点击绿色运行按钮，按键盘上的*F5*，或者在顶部菜单中选择**运行**然后**运行当前脚本**来运行它。
- en: 'After we execute the code, we should observe a stock message scrolling across
    the dot-matrix screen of the Sense HAT. If we are utilizing the emulator, the
    message will scroll across the simulated dot-matrix display, considering the 270-degree
    orientation set for the emulator. *Figure 2**.12* provides a visual representation
    of how this appears when using the emulator:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该在Sense HAT的点阵屏幕上观察到股票信息滚动。如果我们使用模拟器，信息将在模拟的点阵显示上滚动，考虑到模拟器设置的270度方向。*图2.12*提供了使用模拟器时这种显示的视觉表示：
- en: '![Figure 2.12 – Stock ticker information on Sense HAT emulator](img/B21282_02_12.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – Sense HAT模拟器上的股票行情信息](img/B21282_02_12.jpg)'
- en: Figure 2.12 – Stock ticker information on Sense HAT emulator
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – Sense HAT模拟器上的股票行情信息
- en: Congratulations are in order as we have successfully built our first real-world
    IoT device, a stock ticker using Raspberry Pi and Sense HAT! This device opens
    a world of possibilities beyond just displaying stock information. In the next
    section, we will start developing applications to display weather conditions.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 祝贺我们成功构建了我们第一个真正的物联网设备，一个使用Raspberry Pi和Sense HAT的股票行情显示设备！这个设备开启了一个超越仅显示股票信息的世界。在下一节中，我们将开始开发显示天气条件的应用程序。
- en: Developing weather display applications
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发天气显示应用程序
- en: Now that we are experienced IoT application developers, we are ready to take
    our skills to the next level and create more intricate projects. In this section,
    we will leverage the capabilities of Raspberry Pi and Sense HAT to create a weather
    display application and a weather-dependent GO-NO-GO decision-making application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为经验丰富的物联网应用开发者，我们准备将我们的技能提升到下一个层次，并创建更复杂的项目。在本节中，我们将利用 Raspberry Pi 和 Sense
    HAT 的功能来创建一个天气显示应用和一个基于天气的 GO-NO-GO 决策应用。
- en: 'In *Figure 2**.13*, we see a diagram depicting a call to the OpenWeather API
    from our Raspberry Pi and Sense HAT, enclosed within its custom case. For our
    weather display application, we will follow a similar approach to the scrolling
    stock ticker:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 2*.13 中，我们看到一个图表，展示了我们的 Raspberry Pi 和 Sense HAT（封装在其定制外壳中）对 OpenWeather
    API 的调用。对于我们的天气显示应用，我们将遵循与滚动股票指示器类似的方法：
- en: '![Figure 2.13 – Using the OpenWeather API to get the current weather conditions](img/B21282_02_13.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 使用 OpenWeather API 获取当前天气状况](img/B21282_02_13.jpg)'
- en: Figure 2.13 – Using the OpenWeather API to get the current weather conditions
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 使用 OpenWeather API 获取当前天气状况
- en: We will first acquire an API key from OpenWeather and verify the API call by
    printing the response to the Shell for testing purposes. We will then utilize
    the Sense HAT to create a ticker-style display that displays the current weather
    conditions.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先从 OpenWeather 获取一个 API 密钥，并通过将响应打印到 Shell 中进行测试来验证 API 调用。然后，我们将利用 Sense
    HAT 创建一个指示器风格的显示，显示当前的天气状况。
- en: Finally, we will replace the scrolling display with visuals as we build a weather-dependent
    GO-NO-GO decision-making application.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着我们构建一个基于天气的 GO-NO-GO 决策应用，我们将用视觉效果替换滚动显示。
- en: We will start by obtaining an API key.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先获取一个 API 密钥。
- en: Getting an API key
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取 API 密钥
- en: To utilize the OpenWeather web service, it is necessary to obtain an API key.
    This API key serves as a unique identifier that grants access to the OpenWeather
    web service. The key is acquired by creating an account on the OpenWeather website
    and generating an API key by subscribing to the appropriate service. The API key
    acts as a credential to authenticate and authorize our requests to the OpenWeather
    web service, enabling us to retrieve weather data for various locations around
    the world. It’s important to keep the API key confidential and securely store
    it as it grants access to the OpenWeather API on our behalf.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用 OpenWeather 网络服务，必须获取一个 API 密钥。这个 API 密钥作为一个唯一的标识符，允许访问 OpenWeather 网络服务。通过在
    OpenWeather 网站上创建账户并订阅适当的服务来生成 API 密钥。API 密钥作为凭证，用于验证和授权我们对 OpenWeather 网络服务的请求，使我们能够获取世界各地各种位置的天气数据。重要的是要保密
    API 密钥，并安全地存储它，因为它代表我们访问 OpenWeather API。
- en: 'To obtain a free API key from OpenWeather, we start by navigating to the OpenWeather
    price page located at [https://openweathermap.org/price](https://openweathermap.org/price).
    We then scroll down to the **Current weather and forecasts collection** section
    and click on the **Get API** **key** button:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要从 OpenWeather 获取免费的 API 密钥，我们首先导航到位于 [https://openweathermap.org/price](https://openweathermap.org/price)
    的 OpenWeather 价格页面。然后，我们滚动到 **当前天气和预报集合** 部分，并点击 **获取 API 密钥** 按钮：
- en: '![Figure 2.14 – Obtaining an API key from OpenWeather](img/B21282_02_14.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.14 – 从 OpenWeather 获取 API 密钥](img/B21282_02_14.jpg)'
- en: Figure 2.14 – Obtaining an API key from OpenWeather
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 – 从 OpenWeather 获取 API 密钥
- en: We follow the instructions for creating a new account. After successfully creating
    the account, we gain access to our personal dashboard. Inside the personal dashboard,
    we navigate to the **API keys** tab and locate the API key in the **Key** box.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遵循创建新账户的说明。成功创建账户后，我们就可以访问个人仪表板。在个人仪表板中，我们导航到 **API 密钥** 选项卡，并在 **密钥** 框中找到
    API 密钥。
- en: We copy and paste our key into a text editor as we require this key every time
    we make a call to the OpenWeather web service. As a free user, we are limited
    to 60 API requests per minute and a total of 1,000,000 API requests per month.
    This should be more than enough for our application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将密钥复制粘贴到文本编辑器中，因为我们每次调用 OpenWeather 网络服务时都需要这个密钥。作为免费用户，我们每分钟限制 60 个 API 请求，每月总共
    1,000,000 个 API 请求。这对我们的应用来说应该足够了。
- en: With our OpenWeather API key, we can now start to write code to test out the
    web service.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 OpenWeather API 密钥，我们现在可以开始编写代码来测试这个网络服务。
- en: Creating a scrolling weather information ticker
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个滚动的天气信息指示器
- en: With our OpenWeather API key, Raspberry Pi, and Sense HAT, we will now create
    a scrolling weather information device that mimics the functionality of our scrolling
    stock ticker. We will start by acquiring weather data and display the results
    in the Shell of Thonny.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 OpenWeather API 密钥、Raspberry Pi 和 Sense HAT，我们现在将创建一个模拟我们滚动股票行情功能的滚动天气信息设备。我们将首先获取天气数据，并在
    Thonny 的 Shell 中显示结果。
- en: After we are satisfied that our API key and web service work, we will integrate
    the web service data with the Sense HAT, displaying scrolling text that displays
    the temperature and weather conditions.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们满意我们的 API 密钥和网络服务工作后，我们将集成网络服务数据与 Sense HAT，显示滚动文本，显示温度和天气状况。
- en: Testing the web service
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试网络服务
- en: 'Before integrating the OpenWeather API into our Raspberry Pi and Sense HAT,
    we will ensure its functionality with a simple program. To create the test code,
    we do the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 OpenWeather API 集成到我们的 Raspberry Pi 和 Sense HAT 之前，我们将通过一个简单的程序确保其功能。为了创建测试代码，我们执行以下操作：
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` Python virtual
    environment, and create a new tab. Inside the tab, we write the following code:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Raspberry Pi 上启动 Thonny，激活 `ch2-env` Python 虚拟环境，并创建一个新标签。在标签内，我们编写以下代码：
- en: '[PRE11]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we run our code, let’s break it down:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们运行代码之前，让我们将其分解：
- en: We start by importing the `requests` module to make HTTP requests.
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先导入 `requests` 模块以发送 HTTP 请求。
- en: We then set the `url` variable to the OpenWeather API endpoint.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `url` 变量设置为 OpenWeather API 端点。
- en: We set the `api_key` variable with our OpenWeather API key.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `api_key` 变量设置为我们的 OpenWeather API 密钥。
- en: We set the `location` variable to the desired location for which we want to
    retrieve weather information. For our example, this is `"Toronto"`.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `location` 变量设置为我们要获取天气信息的所需位置。在我们的例子中，这是 `"Toronto"`。
- en: We then create a dictionary called `params` with the parameters for the API
    request, including the location, API key, and desired units.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个名为 `params` 的字典，其中包含 API 请求的参数，包括位置、API 密钥和所需的单位。
- en: A `GET` request is sent to the OpenWeather API using `requests.get()`, with
    `url` and `params` as arguments.
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `requests.get()` 发送一个 `GET` 请求到 OpenWeather API，其中 `url` 和 `params` 作为参数。
- en: We then check whether the response status code is `200` (indicating a successful
    request).
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查响应状态码是否为 `200`（表示请求成功）。
- en: 'If the response is successful, we parse the JSON data from the response using
    `response.json()` and then do the following:'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应成功，我们使用 `response.json()` 解析响应中的 JSON 数据，然后执行以下操作：
- en: We extract the temperature and weather description from the parsed data.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从解析的数据中提取温度和天气描述。
- en: We then print the current temperature and weather information for the specified
    location.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印指定位置的当前温度和天气信息。
- en: If there is an error (response status code other than `200`), we print an error
    message indicating the failure to retrieve weather information.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有错误（响应状态码不是 `200`），我们将打印一个错误消息，指出无法检索天气信息。
- en: We save our code as `weather-api-test.py` and then run it by clicking on the
    green run button, hitting *F5* on the keyboard, or clicking on the **Run** menu
    option at the top and then **Run** **current script**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的代码保存为 `weather-api-test.py`，然后通过点击绿色运行按钮、按键盘上的 *F5* 或者在顶部菜单中选择 **运行**
    然后选择 **运行当前脚本** 来运行它。
- en: 'After we execute the code, we should observe a message in the Shell:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行代码后，我们应该在 Shell 中看到一个消息：
- en: '![Figure 2.15 – OpenWeather API information on the weather in Toronto](img/B21282_02_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – OpenWeather API 关于多伦多天气的信息](img/B21282_02_15.jpg)'
- en: Figure 2.15 – OpenWeather API information on the weather in Toronto
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – OpenWeather API 关于多伦多天气的信息
- en: 'As we can see, it is `29.15 °C` and clear in Toronto at the time of this writing.
    If the web service call did not work, we would’ve seen an `Error: Failed to retrieve
    weather information` error in the console.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们所见，在撰写本文时，多伦多是 `29.15 °C`，天气晴朗。如果网络服务调用失败，我们将在控制台中看到 `Error: Failed to retrieve
    weather information` 错误。'
- en: With our understanding of how to use the OpenWeather API, we are now ready to
    use the Sense HAT to create our scrolling weather information ticker. For this,
    we may reuse much of the code we wrote for our scrolling stock ticker application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解了如何使用 OpenWeather API 后，我们现在准备好使用 Sense HAT 创建我们的滚动天气信息指示器。为此，我们可以重用我们为滚动股票行情应用编写的代码的大部分。
- en: Scrolling weather information on Sense HAT
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sense HAT 上的滚动天气信息
- en: 'As we highlighted in our previous project, the versatility of our scrolling
    stock ticker application allows us to adapt it to display various types of information
    beyond stocks. In this section, we will leverage this adaptability by integrating
    the OpenWeather API and our API key to transform our ticker into a dynamic weather
    display, scrolling real-time weather data such as temperature and current conditions.
    We will be able to reuse a lot of the code from the scrolling stock ticker. To
    create the scrolling ticker code, we do the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一个项目中指出的，我们的滚动股票行情应用的通用性使我们能够将其适应以显示除股票之外的各种类型的信息。在本节中，我们将利用这种适应性，通过集成
    OpenWeather API 和我们的 API 密钥，将我们的行情转换为动态天气显示，滚动实时天气数据，如温度和当前状况。我们将能够重用滚动股票行情中的大量代码。为了创建滚动行情代码，我们执行以下操作：
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` Python virtual
    environment, and create a new tab. We will start with our imports:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 Raspberry Pi 上启动 Thonny，激活 `ch2-env` Python 虚拟环境，并创建一个新标签。我们将从导入开始：
- en: '[PRE12]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Important note
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As we have already covered these imports with our scrolling stock ticker application,
    we do not need to cover them again.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在我们之前的滚动股票行情应用中涵盖了这些导入，所以我们不需要再次介绍它们。
- en: 'After our imports, we set our variables:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入之后，我们设置我们的变量：
- en: '[PRE13]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In this code block, we do the following:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码块中，我们执行以下操作：
- en: We start by assigning the `api_key` variable to our OpenWeather API key.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将 `api_key` 变量分配给我们的 OpenWeather API 密钥。
- en: We set the `location` variable to the desired location for which we want to
    retrieve weather information. For our example, this is `'Toronto'`.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `location` 变量设置为想要获取天气信息的所需位置。在我们的例子中，这是 `'Toronto'`。
- en: We then set the `base_url` variable to the OpenWeather API endpoint.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `base_url` 变量设置为 OpenWeather API 端点。
- en: We create a dictionary called `params` with the parameters for the API request,
    including the location, API key, and desired units.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `params` 的字典，其中包含了API请求的参数，包括位置、API密钥和所需的单位。
- en: A `GET` request is sent to the OpenWeather API using `requests.get()`, with
    `url` and `params` as arguments.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `requests.get()` 发送一个 `GET` 请求到 OpenWeather API，其中 `url` 和 `params` 作为参数。
- en: We then create an instance of the `SenseHat` class and assign it to the `sense`
    variable to interact with the Sense HAT (or emulator).
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个 `SenseHat` 类的实例，并将其分配给 `sense` 变量以与 Sense HAT（或模拟器）交互。
- en: We set the rotation of the Sense HAT display to 270 degrees using `sense.set_rotation(270)`.
    This is so that it matches the orientation of the Raspberry Pi in our custom case.
    We could comment this line out for the emulator.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `sense.set_rotation(270)` 将 Sense HAT 显示的旋转设置为 270 度。这样做是为了使其与我们的定制外壳中的
    Raspberry Pi 的方向相匹配。对于模拟器，我们可以取消注释这一行。
- en: We set `last_call_time` to the current time minus 30 seconds.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `last_call_time` 设置为当前时间减去 30 秒。
- en: We then add `last_weather_info`, which is a variable that stores the previous
    weather information.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们添加 `last_weather_info`，这是一个存储先前天气信息的变量。
- en: 'Below our variable declarations, we implement an infinite loop to continuously
    display the weather ticker information; however, to comply with API rate limits
    of 60 requests per minute and 1,000,000 requests per month, we introduce a time
    delay of 30 seconds between each web service call. We type the following code
    below our variable declarations:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的变量声明下方，我们实现了一个无限循环，以持续显示天气行情信息；然而，为了遵守每分钟 60 次和每月 1,000,000 次的 API 速率限制，我们在每次网络服务调用之间引入了
    30 秒的时间延迟。我们在变量声明下方输入以下代码：
- en: '[PRE14]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As in our scrolling stock ticker application, the heart of our code is wrapped
    in a `while True` loop, which ensures continuous execution of the main code:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就像在我们的滚动股票行情应用中一样，我们的代码核心被包裹在一个 `while True` 循环中，这确保了主代码的持续执行：
- en: We set the `current_time` variable to the current time using `time.time()`.
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `time.time()` 将 `current_time` 变量设置为当前时间。
- en: Our code then checks whether the difference between `current_time` and `last_call_time`
    is greater than or equal to 30 seconds.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的代码检查 `current_time` 和 `last_call_time` 之间的差异是否大于或等于 30 秒。
- en: 'If `True`, the following happens:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果为 `True`，则发生以下情况：
- en: A `GET` request is sent to the OpenWeather API using `requests.get()`, with
    `base_url` and `params` as arguments.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `requests.get()` 发送一个 `GET` 请求到 OpenWeather API，其中 `base_url` 和 `params`
    作为参数。
- en: The response is parsed as JSON using `response.json()` and assigned to the `data`
    variable.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 响应被解析为 JSON 并使用 `response.json()` 分配给 `data` 变量。
- en: We extract the temperature and weather description from the parsed data and
    store it as `weather_info.`
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从解析的数据中提取温度和天气描述，并将其存储为`weather_info.`。
- en: The `last_weather_info` variable is updated to store the current `weather_info`
    value.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`last_weather_info`变量更新以存储当前的`weather_info`值。
- en: '`weather_info` is displayed on the Sense HAT’s dot-matrix display using `sense.show_message()`,
    with a scrolling speed of 0.05 seconds and white text color (`255,255,255`).'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`sense.show_message()`在Sense HAT的点阵显示屏上显示`weather_info`，滚动速度为0.05秒，文字颜色为白色（`255,255,255`）。
- en: The `last_call_time` variable is updated to the current time (`current_time`)
    to mark the timestamp of the last API call.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`last_call_time`变量更新为当前时间（`current_time`），以标记上次API调用的时间戳。
- en: If `False`, the previous `last_weather_info` variable is displayed on the Sense
    HAT display with a scrolling speed of 0.05 seconds and white text color (`255,255,255`).
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`False`，则使用0.05秒的滚动速度和白色文字颜色（`255,255,255`）在Sense HAT显示屏上显示上一个`last_weather_info`变量。
- en: Our program then sleeps for 1 second using `time.sleep(1)` before the next iteration
    of the loop. This is done to regulate resource consumption and control the update
    frequency of the Sense HAT’s dot-matrix display.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 程序随后使用`time.sleep(1)`暂停1秒，然后进行循环的下一迭代。这样做是为了调节资源消耗和控制Sense HAT点阵显示屏的更新频率。
- en: We save our code as `weather-scroll.py` and then run it by clicking on the green
    run button, hitting *F5* on the keyboard, or clicking on the **Run** menu option
    at the top and then **Run** **current script**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为`weather-scroll.py`，然后通过点击绿色运行按钮、按键盘上的*F5*键或点击顶部菜单的**运行**选项然后**运行****当前脚本**来运行它。
- en: 'After we execute the code, we should observe weather information scrolling
    across the dot-matrix screen of the Sense HAT. If we are utilizing the emulator,
    a message will scroll across the simulated dot-matrix display. *Figure 2**.16*
    provides a visual representation of how this appears when using the emulator:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该观察到天气信息在Sense HAT的点阵屏幕上滚动。如果我们使用模拟器，一条信息将在模拟的点阵显示屏上滚动。*图2.16*提供了使用模拟器时这种显示的视觉表示：
- en: '![Figure 2.16 – Weather information scrolling across the simulated dot-matrix
    display](img/B21282_02_16.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图2.16 – 天气信息在模拟点阵显示屏上滚动](img/B21282_02_16.jpg)'
- en: Figure 2.16 – Weather information scrolling across the simulated dot-matrix
    display
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 – 天气信息在模拟点阵显示屏上滚动
- en: One key takeaway is the power of leveraging existing code to create new applications.
    Despite inherent differences between stock information and weather data, the process
    of obtaining information for both fields remain remarkably similar. With this
    realization, we unlock the potential to create a wide range of dynamic and engaging
    displays using the same underlying code structure.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的启示是利用现有代码创建新应用的力量。尽管股票信息和天气数据之间存在固有的差异，但获取这两个领域信息的过程却惊人地相似。有了这个认识，我们就可以利用相同的底层代码结构创建各种动态和吸引人的显示。
- en: 'Here are a few examples of other applications we could build:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们可以构建的其他应用的例子：
- en: '**News updates**: By modifying the code, we can integrate our device with news
    APIs to display real-time headlines or updates from popular news sources.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**新闻更新**：通过修改代码，我们可以将我们的设备与新闻API集成，以显示来自流行新闻来源的实时标题或更新。'
- en: '**Social media notifications**: By connecting our application to social media
    APIs, we can configure it to display notifications from popular platforms such
    as Twitter or Facebook.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交媒体通知**：通过将我们的应用程序连接到社交媒体API，我们可以配置它显示来自Twitter或Facebook等流行平台的通知。'
- en: '**Sports scores**: With the integration of sports data APIs, our stock ticker
    application can be transformed into a real-time sports scoreboard. It can display
    live scores, game updates, or upcoming game schedules.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体育比分**：通过集成体育数据API，我们的股票行情应用可以转变为实时体育比分板。它可以显示实时比分、比赛更新或即将到来的比赛日程。'
- en: '**Personalized reminders**: By extending the functionality of the code, we
    can program the stock ticker application to display personalized reminders or
    to-do lists.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个性化提醒**：通过扩展代码的功能，我们可以编程股票行情应用以显示个性化的提醒或待办事项列表。'
- en: In our next and final project for the chapter, we will replace our scrolling
    text displays with dot-matrix images and animations. This shift from scrolling
    text elevates the user experience and will make our projects more visually appealing.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的下一项和最后一项项目中，我们将用点阵图像和动画替换我们的滚动文本显示。这种从滚动文本到图像的转变提升了用户体验，并将使我们的项目更具视觉吸引力。
- en: Developing a GO-NO-GO application for decision-making
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发GO-NO-GO决策应用
- en: 'Consider the role of a youth baseball league convener, responsible for ensuring
    the safety of playing fields. Critical to this responsibility is making weather-based
    decisions. If the field is excessively wet, it can impact gameplay, potentially
    leading to game postponements or cancellations:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到一个青年棒球联赛的组织者角色，负责确保比赛场地的安全。这一责任的关键是做出基于天气的决定。如果场地过于潮湿，可能会影响比赛，可能导致比赛推迟或取消：
- en: '![Figure 2.17 – Should the game go on?](img/B21282_02_17.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图2.17 – 比赛是否应该继续？](img/B21282_02_17.jpg)'
- en: Figure 2.17 – Should the game go on?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 – 比赛是否应该继续？
- en: Another factor to consider is the age of the players. For younger players, playing
    in the rain raises concerns, as parents are often present and may express dissatisfaction
    with unfavorable weather conditions. On the other hand, older players, who typically
    travel to games independently, may be less affected by wet conditions.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要考虑的因素是球员的年龄。对于年轻球员来说，在雨中比赛会引发担忧，因为父母通常在场，可能会对不利的天气条件表示不满。另一方面，通常独立参加比赛的年长球员可能受潮湿条件的影响较小。
- en: These decision-making scenarios represent an opportunity to develop an IoT application
    that displays a visual indicator, such as a **GO** or **NO-GO** graphic, based
    on weather conditions and player age (*Figure 2**.17*). Imagine a setup with Raspberry
    Pi and Sense HATs for each baseball diamond, where the Sense HAT display provides
    real-time guidance on whether the game should proceed as scheduled, be postponed,
    or be canceled altogether. This IoT application enables efficient decision-making
    and enhances the overall experience and safety of the youth baseball league.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这些决策场景代表了一个开发物联网应用的机会，该应用可以根据天气条件和球员年龄显示视觉指示器，如**GO**或**NO-GO**图形（*图2**.17*）。想象一下，每个棒球场地都配备一个Raspberry
    Pi和Sense HAT的设置，Sense HAT显示屏提供实时指导，以确定比赛是否应该按计划进行，是否应该推迟，或者完全取消。这个物联网应用使决策更加高效，并提升了青年棒球联赛的整体体验和安全。
- en: In our simplified example, we will focus on incorporating basic decision-making
    into our IoT application. Based on the age of the players and the presence of
    rain, the Sense HAT will show either a green checkmark or an animated red X sign.
    While we could introduce additional complexity, the primary objective of this
    exercise is to demonstrate how decision-making can be integrated into an IoT application.
    By incorporating these visual indicators, we empower real-time decision-making.
    Instead of relying solely on the convener, our IoT application takes charge by
    providing immediate guidance on whether games should proceed or be postponed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的简化示例中，我们将专注于将基本的决策集成到我们的物联网应用中。根据球员的年龄和雨水的存在，Sense HAT将显示绿色勾选标记或动画红色X标志。虽然我们可以引入额外的复杂性，但这个练习的主要目标是展示决策如何集成到物联网应用中。通过引入这些视觉指示器，我们赋予了实时决策能力。我们的物联网应用不再仅仅依赖于组织者，而是通过提供即时的指导来负责决定比赛是否应该继续或推迟。
- en: We will start by writing Sense HAT code for indication. For GO, we will show
    a simple green checkmark against a black background. For NO-GO, we will display
    a flashing red X. We will run our application using the Sense HAT emulator as
    it is easier to display screenshots for this book; however, it is strongly encouraged
    to use the Sense HAT as this makes our application a true IoT device.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写Sense HAT的指示代码。对于GO，我们将显示一个简单的绿色勾选标记在黑色背景上。对于NO-GO，我们将显示闪烁的红色X。我们将使用Sense
    HAT模拟器运行我们的应用程序，因为对于本书来说，显示截图更容易；然而，强烈建议使用Sense HAT，因为这使我们的应用程序成为一个真正的物联网设备。
- en: We will start by writing code to display a green checkmark.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写代码来显示绿色勾选标记。
- en: Creating a checkmark on our Sense HAT
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的Sense HAT上创建勾选标记
- en: In this section, we will create code that displays a green checkmark against
    a black background on the Sense HAT emulator. To enhance code implementation and
    organization, we will encapsulate the functionality within a Python class. This
    approach simplifies the integration process and promotes code reusability, allowing
    us to easily incorporate the green checkmark display into our IoT application
    project.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建代码，在Sense HAT模拟器上显示绿色勾选标记在黑色背景上。为了增强代码实现和组织，我们将功能封装在一个Python类中。这种方法简化了集成过程并促进了代码的可重用性，使我们能够轻松地将绿色勾选标记显示集成到我们的物联网应用项目中。
- en: 'Prior to writing the code for the GO-NO-GO application, we will create a project
    directory named `GO-NO-GO` on our Raspberry Pi. This dedicated folder will serve
    as a centralized location for organizing and managing files and resources associated
    with our project. To create the checkmark code, we do the following:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写GO-NO-GO应用程序的代码之前，我们将在Raspberry Pi上创建一个名为`GO-NO-GO`的项目目录。这个专用文件夹将作为组织和管理与我们的项目相关的文件和资源的集中位置。为了创建勾选标记代码，我们执行以下操作：
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` virtual environment,
    and create a new tab. Inside the tab, we write the following code:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Raspberry Pi上启动Thonny，激活`ch2-env`虚拟环境，并创建一个新标签页。在标签页内，我们编写以下代码：
- en: '[PRE15]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our code, we do the following:'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: We start by importing the `SenseHat` class from the `sense_hat` module (use
    `sense_emu` for the emulator)
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`sense_hat`模块导入`SenseHat`类（使用`sense_emu`进行模拟）
- en: We then define a `GreenCheck` class for displaying a green checkmark on the
    Sense HAT
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个`GreenCheck`类，用于在Sense HAT上显示绿色勾选标记。
- en: We set color values for black and green as RGB tuples.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将黑色和绿色的颜色值设置为RGB元组。
- en: We then define a list of pixel values representing the checkmark shape.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义一个表示勾选标记形状的像素值列表。
- en: The `GreenCheck` class is initialized with an optional rotation parameter, which
    defaults to `0`.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`GreenCheck`类使用可选的旋转参数初始化，默认值为`0`。'
- en: Inside the `__init__` method, we create a Sense HAT instance and set the rotation
    to the value of `rotation`.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`__init__`方法中，我们创建了一个Sense HAT实例，并将旋转设置为`rotation`的值。
- en: We define a `display` method that sets the Sense HAT’s pixels to the checkmark
    pixel values.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个`display`方法，将Sense HAT的像素设置为勾选标记的像素值。
- en: We use `if __name__ == "__main__"` to check whether the code is being run directly
    (not imported).
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`if __name__ == "__main__"`来检查代码是否直接运行（不是导入）。
- en: 'If `True`, we do the following:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`True`，我们执行以下操作：
- en: We create an instance of the `GreenCheck` class named `greenCheck` with a rotation
    value of `270`.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`greenCheck`的`GreenCheck`类实例，旋转值为`270`。
- en: We call the `display()` method to show a green checkmark on the Sense HAT.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用`display()`方法，在Sense HAT上显示一个绿色的勾选标记。
- en: We save our code as `green_checkmark.py` in the `GO-NO-GO` folder and then run
    it by clicking on the green run button, hitting *F5* on the keyboard, or clicking
    on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的代码保存为`green_checkmark.py`在`GO-NO-GO`文件夹中，然后通过点击绿色运行按钮，按键盘上的*F5*，或者在顶部菜单中选择**运行**然后**运行当前脚本**来运行它。
- en: 'After we execute the code, we should see a green checkmark against a black
    background on our Sense HAT emulator:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该在我们的Sense HAT模拟器上看到黑色背景上的绿色勾选标记：
- en: '![Figure 2.18 – Green checkmark against black background on Sense HAT’s dot-matrix
    display](img/B21282_02_18.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![图2.18 – Sense HAT点阵显示上的黑色背景上的绿色勾选标记](img/B21282_02_18.jpg)'
- en: Figure 2.18 – Green checkmark against black background on Sense HAT’s dot-matrix
    display
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 – Sense HAT点阵显示上的黑色背景上的绿色勾选标记
- en: With the completion of the green checkmark code, we will now shift our focus
    toward creating a NO-GO animation (flashing red X) for our application.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 完成绿色勾选标记代码后，我们现在将注意力转向为我们的应用程序创建NO-GO动画（闪烁红色X）。
- en: Creating a NO-GO animation on our Sense HAT
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在Sense HAT上创建NO-GO动画
- en: 'The NO-GO animation we have designed consists of a flashing effect on the Sense
    HAT emulator display, alternating between a red X sign on a black background and
    a full red display. To create code for the flashing X sign, we do the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的NO-GO动画在Sense HAT模拟器显示上产生闪烁效果，交替显示黑色背景上的红色X标志和全红色显示。为了创建闪烁X标志的代码，我们执行以下操作：
- en: 'We launch Thonny on our Raspberry Pi, activate the `ch2-env` Python virtual
    environment, and create a new tab. Inside the tab, we start by importing the packages
    we need:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在Raspberry Pi上启动Thonny，激活`ch2-env` Python虚拟环境，并创建一个新标签页。在标签页内，我们首先导入所需的包：
- en: '[PRE16]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once we have our packages defined, we then start to wrap our code up in a Python
    class:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们定义了包，我们接下来开始将我们的代码封装在一个Python类中：
- en: '[PRE17]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our code, we do the following:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: We start by defining a `RedXAnimation` class.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义一个`RedXAnimation`类。
- en: We then set color values for black and red as RGB tuples.
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将黑色和红色的颜色值设置为RGB元组。
- en: We define `frame1` as a list of pixel values representing a red X sign on a
    black background.
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`frame1`定义为表示黑色背景上红色X标志的像素值列表。
- en: We define `frame2` as a list of pixel values representing a full red display.
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`frame2`定义为表示全红色显示的像素值列表。
- en: 'From here, we write code for the initialize method in the class:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们为类的初始化方法编写代码：
- en: '[PRE18]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In our code, we do the following:'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: We use the `__init__` method to initialize the `RedXAnimation` object with an
    optional `rotation` parameter (defaulted to `0`).
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `__init__` 方法以可选的 `rotation` 参数（默认为 `0`）初始化 `RedXAnimation` 对象。
- en: Inside `__init__`, a `SenseHat` instance is created, and the rotation is set
    based on the provided `rotation` value.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__init__` 内部，创建了一个 `SenseHat` 实例，并根据提供的 `rotation` 值设置旋转。
- en: 'The `display_animation()` method will cycle through the 2 frames for 59 seconds.
    We do this to align with future client code:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`display_animation()` 方法将循环显示2帧59秒。我们这样做是为了与未来的客户端代码保持一致：'
- en: '[PRE19]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our code, the following happens:'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况发生：
- en: Our `display_animation()` method takes a duration parameter.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的 `display_animation()` 方法接受一个持续时间参数。
- en: We set the number of frames to `2.`
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将帧数设置为 `2.`。
- en: We calculate the duration for each frame by dividing the total duration by the
    number of frames.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将总持续时间除以帧数来计算每帧的持续时间。
- en: We set the `start_time` variable to the current time using `time.time()`.
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `time.time()` 将 `start_time` 变量设置为当前时间。
- en: We calculate the `end_time` value by adding 59 seconds to the `start_time` variable.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过将59秒加到 `start_time` 变量上来计算 `end_time` 值。
- en: 'We create a loop that runs until the current time exceeds the `end_time` value:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个循环，直到当前时间超过 `end_time` 值：
- en: Our code iterates over each frame in the list `[``self.frame1, self.frame2]`.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码遍历列表 `[self.frame1, self.frame2]` 中的每一帧。
- en: We set the Sense HAT display pixels to the current frame using `self.sense.set_pixels(frame)`.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `self.sense.set_pixels(frame)` 将Sense HAT显示屏像素设置为当前帧。
- en: We then pause the execution for the frame duration using `time.sleep(frame_duration)`.
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用 `time.sleep(frame_duration)` 暂停执行以帧的持续时间。
- en: 'We use the `if __name__ == "__main__":` block to ensure that the test code
    is executed only when the script is run directly (not imported as a module):'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `if __name__ == "__main__":` 块来确保测试代码仅在脚本直接运行时执行（不是作为模块导入）：
- en: '[PRE20]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In our code, the following happens:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，以下情况发生：
- en: An instance of the `RedXAnimation` class is created with a rotation value of
    270 degrees, assigned to the `animation` variable.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个旋转值为270度的 `RedXAnimation` 类实例，并将其分配给 `animation` 变量。
- en: The `display_animation()` method of the `animation` object is called, specifying
    a duration of 1 second.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `animation` 对象的 `display_animation()` 方法，指定持续时间为1秒。
- en: We save our code as `flashing_x.py` in the `GO-NO-GO` folder and then run it
    by clicking on the green run button, hitting *F5* on the keyboard, or clicking
    on the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的代码保存为 `flashing_x.py` 在 `GO-NO-GO` 文件夹中，然后通过点击绿色运行按钮，按键盘上的 *F5* 或者在顶部菜单中选择
    **运行** 然后选择 **运行当前脚本** 来运行它。
- en: 'After executing the code, we should observe an animation of a red X sign against
    a black background turn into a full screen of red and back again. In *Figure 2**.19*,
    we can see what this would look like on the emulator:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码后，我们应该观察到红色X标志在黑色背景上变为全屏红色，然后再回到原来的状态。在 *图2.19* 中，我们可以看到在模拟器上这会是什么样子：
- en: '![Figure 2.19 – NO-GO animation in red screen mode](img/B21282_02_19.jpg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图2.19 – 红屏模式的NO-GO动画](img/B21282_02_19.jpg)'
- en: Figure 2.19 – NO-GO animation in red screen mode
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 – 红屏模式的NO-GO动画
- en: The NO-GO animation we have created in this section provides a highly effective
    visual indicator on the Sense HAT display. By alternating between a red X sign
    on a black background and a full red display, this animation conveys unfavorable
    conditions that would necessitate the cancellation of a game.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本节中创建的NO-GO动画在Sense HAT显示屏上提供了一个非常有效的视觉指示器。通过在黑色背景上的红色X标志和全红色显示之间交替，这个动画传达了需要取消比赛的不利条件。
- en: Setting the geolocation for other cities
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为其他城市设置地理定位
- en: For finding a city’s geolocation information such as latitude and longitude,
    websites such as *GPS Coordinates* ([https://gps-coordinates.org/](https://gps-coordinates.org/))
    and *Latitude and Longitude Finder* ([https://www.latlong.net/](https://www.latlong.net/))
    are useful. They allow us to input an address or place and receive its precise
    coordinates.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了找到城市的地理定位信息，如纬度和经度，像 *GPS Coordinates* ([https://gps-coordinates.org/](https://gps-coordinates.org/))
    和 *Latitude and Longitude Finder* ([https://www.latlong.net/](https://www.latlong.net/))
    这样的网站非常有用。它们允许我们输入一个地址或地点，并接收其精确的坐标。
- en: To finish off our application, we will now write the web service and logic layer,
    and we will incorporate our green checkmark and red X sign animation.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的应用程序，我们现在将编写网络服务和逻辑层，并将包含我们的绿色勾选和红色X标志动画。
- en: Writing GO-NO-GO client code
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写GO-NO-GO客户端代码
- en: 'Now, it’s time to dive into the exciting phase (subjective, of course) of writing
    code to determine whether a game should be a GO or NO-GO based on weather conditions
    and the age of the players. Our approach will be straightforward: if it’s raining
    and the players are under 16 years of age, it’s a NO-GO; otherwise, it’s a GO.
    While we can certainly implement more complex logic, including **Machine Learning**
    (**ML**) if there are multiple parameters to consider, for simplicity, we’ll focus
    on this basic decision-making process. We do so with the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候进入编写代码的激动人心阶段（当然，这是主观的）了，以确定游戏应该是GO还是NO-GO，基于天气条件和玩家的年龄。我们的方法将非常直接：如果下雨且玩家年龄低于16岁，则为NO-GO；否则，为GO。虽然我们可以当然实现更复杂的逻辑，包括**机器学习**（**ML**），如果需要考虑多个参数，但为了简单起见，我们将专注于这个基本的决策过程。我们这样做如下：
- en: 'To create the client code, we launch Thonny on our Raspberry Pi, activate our
    `ch2-env` Python virtual environment, and create a new tab. Inside the tab, we
    start by importing the packages we need:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建客户端代码，我们在Raspberry Pi上启动Thonny，激活我们的`ch2-env`Python虚拟环境，并创建一个新标签。在标签内，我们首先导入所需的包：
- en: '[PRE21]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We’ve covered the first three packages already. For the two modules, we do
    the following:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经介绍了前三个包。对于这两个模块，我们做以下操作：
- en: We import the `GreenCheck` class from the `green_checkmark` module to display
    a green checkmark for the `RedXAnimation` class from the `flashing_x` module to
    display a flashing red X sign animation when the decision is **NO-GO**.
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从`green_checkmark`模块导入`GreenCheck`类，以显示绿色勾选，从`flashing_x`模块导入以显示红色X标志动画，当决策为**NO-GO**时。
- en: 'With our packages and modules in place, we now set our variables:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的包和模块就绪后，我们现在设置我们的变量：
- en: '[PRE22]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In our code, we do the following:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们做以下操作：
- en: We set `latitude` to `'42.346268'` and `longitude` to `'-71.095764'` for our
    baseball diamond. For example, this is the GPS coordinates for Fenway Park in
    Boston, Massachusetts, US.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`latitude`设置为`'42.346268'`，将`longitude`设置为`'-71.095764'`，用于我们的棒球场。例如，这是美国马萨诸塞州波士顿芬威公园的GPS坐标。
- en: We create a `GreenCheck` object named `go` with a rotation value of 270 degrees.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`go`的`GreenCheck`对象，旋转值为270度。
- en: We create a `RedXAnimation` object named `no_go` with a rotation value of 270
    degrees.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个名为`no_go`的`RedXAnimation`对象，旋转值为270度。
- en: We set our `timer` value to 1 second.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将`timer`值设置为1秒。
- en: We set the age of our players to 12.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将玩家的年龄设置为12岁。
- en: Our code sets the `base_url` value to `"https://api.openweathermap.org/data/2.5/weather"`.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码将`base_url`值设置为`"https://api.openweathermap.org/data/2.5/weather"`。
- en: Next, we add our OpenWeather `api_key` value.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们添加我们的OpenWeather `api_key`值。
- en: We then define a `params` dictionary we will use with our web service call (`latitude`,
    `longitude`, `api_key`, and `units`).
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个`params`字典，我们将用它来调用我们的网络服务（`latitude`、`longitude`、`api_key`和`units`）。
- en: 'We use an infinite loop to check the weather conditions every 60 seconds and
    update the display on our Sense HAT accordingly:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用无限循环每60秒检查一次天气条件，并相应地更新Sense HAT上的显示：
- en: '[PRE23]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In our code, we set up an infinite loop using `while True`:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们使用`while True`设置了一个无限循环：
- en: We make a `GET` request to the OpenWeather API using `requests.get()` and store
    the response in `response`.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`requests.get()`向OpenWeather API发起一个`GET`请求，并将响应存储在`response`中。
- en: 'If the response status code is `200`, we do the following:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应状态码是`200`，我们做以下操作：
- en: We parse the JSON response into a Python dictionary using `response.json()`
    and assign it to `data`.
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`response.json()`将JSON响应解析为Python字典，并将其分配给`data`。
- en: We then retrieve the current temperature from `data['main']['temp']` and store
    it in `temperature`.
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从`data['main']['temp']`检索当前温度并将其存储在`temperature`中。
- en: We retrieve a weather description from `data['weather'][0]['main']` and store
    it in `description`.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`data['weather'][0]['main']`检索天气描述并将其存储在`description`中。
- en: We then print the current temperature and weather description. If the weather
    description is `'Thunderstorm'` or (`'Rain'` and `age < 16`), we print `"NO-GO!"`
    to the Shell, display the NO-GO animation using `no_go.display_animation(duration=1)`,
    and set the `timer` variable to 1 second. This is to make the total time before
    calling the web service 60 seconds, as the animation will go on for 59 seconds.
    Otherwise, we print `"GO!"` to the Shell and display the green checkmark animation
    using `go.display()` and then set the `timer` variable to 60 seconds.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们打印当前的温度和天气描述。如果天气描述是 `'Thunderstorm'` 或 (`'Rain'` 且 `age < 16`)，我们将向 Shell
    打印 `"NO-GO!"`，使用 `no_go.display_animation(duration=1)` 显示 NO-GO 动画，并将 `timer`
    变量设置为 1 秒。这是为了使调用 web 服务前的总时间为 60 秒，因为动画将持续 59 秒。否则，我们将向 Shell 打印 `"GO!"`，使用 `go.display()`
    显示绿色勾选动画，然后设置 `timer` 变量为 60 秒。
- en: If the response status code is not `200`, we print an error message.
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应状态码不是 `200`，我们将打印错误信息。
- en: We pause the execution for the value of `timer` seconds using `time.sleep(timer)`.
    This will result in a 60-second delay between calls to the OpenWeather web service.
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `time.sleep(timer)` 暂停执行 `timer` 秒。这将导致在调用 OpenWeather web 服务之间产生 60 秒的延迟。
- en: We save our code as `go-no-go.py` in the `GO-NO-GO` folder and then run it by
    clicking on the green run button, hitting *F5* on the keyboard, or clicking on
    the **Run** menu option at the top and then **Run** **current script**.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将代码保存为 `go-no-go.py` 文件，存放在 `GO-NO-GO` 文件夹中，然后通过点击绿色运行按钮、按键盘上的 *F5* 键，或者在顶部菜单中选择
    **运行** 选项，然后选择 **运行** **当前脚本** 来运行它。
- en: 'Upon running the code, we will observe the dot-matrix screen of our Sense HAT
    (or emulator) displaying either a green checkmark or a flashing red X sign, indicating
    a GO or NO-GO condition for a game at Fenway Park in Boston. As illustrated in
    *Figure 2**.20*, the current status is a NO-GO for the game involving our players
    (under 16 years of age) due to the presence of thunderstorms:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行代码后，我们将观察到我们的 Sense HAT（或模拟器）的点阵屏幕显示绿色勾选或闪烁的红色 X，指示波士顿芬威公园比赛的 GO 或 NO-GO 条件。如
    *图 2**.20 所示，当前状态是由于雷暴的存在，涉及我们球员（16岁以下）的比赛为 NO-GO：
- en: '![Figure 2.20 – Screenshot of the GO-NO-GO application using the Sense HAT
    emulator](img/B21282_02_20.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.20 – 使用 Sense HAT 模拟器的 GO-NO-GO 应用程序截图](img/B21282_02_20.jpg)'
- en: Figure 2.20 – Screenshot of the GO-NO-GO application using the Sense HAT emulator
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.20 – 使用 Sense HAT 模拟器的 GO-NO-GO 应用程序截图
- en: As mentioned earlier, the flexibility of our code allows for easy expansion
    of the decision-making logic. In addition to weather data, we can extend our application
    to consider other factors such as wind speed, humidity, or any on-site sensor
    readings. By integrating sensors placed directly at the baseball diamond, we can
    gather real-time data on soil moisture levels or other measurements of interest.
    This sensor information can then be broadcasted to the internet, enabling us to
    seamlessly integrate it into our application.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们代码的灵活性允许我们轻松扩展决策逻辑。除了天气数据外，我们还可以扩展我们的应用程序，考虑其他因素，如风速、湿度或任何现场传感器读数。通过集成直接放置在棒球场上的传感器，我们可以收集土壤湿度水平或其他感兴趣测量值的实时数据。然后，我们可以将这些传感器信息广播到互联网上，使我们能够无缝地将它集成到我们的应用程序中。
- en: To make our application more dynamic, we can incorporate scheduling information
    to determine the age of players scheduled to play at a specific baseball diamond
    at any given time. By extracting this information from a spreadsheet or an online
    repository, we can automate the process of obtaining player age data and other
    game-related information such as whether the game is a playoff game. This allows
    our application to dynamically adjust its decision-making process, ensuring a
    more accurate GO or NO-GO decision.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序更加动态，我们可以结合调度信息来确定在特定棒球场上任何给定时间安排比赛的球员的年龄。通过从电子表格或在线存储库中提取此信息，我们可以自动化获取球员年龄数据和其他与比赛相关的信息（如比赛是否为季后赛）的过程。这使得我们的应用程序能够动态调整其决策过程，确保更准确的
    GO 或 NO-GO 决定。
- en: Building other GO-NO-GO applications
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建其他 GO-NO-GO 应用程序
- en: 'The GO-NO-GO application marks the last project in the book we will build using
    the Sense HAT. As we have demonstrated, the combination of the Raspberry Pi and
    Sense HAT makes for a powerful IoT device. It’s not hard to imagine how we could
    easily change our baseball GO-NO-GO application for other scenarios. The following
    are a few examples of other GO-NO-GO applications we could build:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: GO-NO-GO应用程序标志着我们将使用Sense HAT构建的最后一本书中的项目。正如我们所展示的，Raspberry Pi和Sense HAT的结合构成了一个强大的物联网设备。不难想象，我们如何轻松地将我们的棒球GO-NO-GO应用程序更改为其他场景。以下是我们可以构建的其他GO-NO-GO应用程序的几个示例：
- en: '**Flight status checker**: By integrating with a flight tracking API, we could
    build an application that can display a GO or NO-GO status for a specific flight.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**航班状态检查器**：通过集成航班跟踪API，我们可以构建一个应用程序，该程序可以显示特定航班的GO或NO-GO状态。'
- en: '**Traffic condition monitor**: Utilizing a traffic data API, we could build
    an application that can assess current traffic conditions on a specific route
    or at a particular location.'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交通状况监控器**：利用交通数据API，我们可以构建一个应用程序，该程序可以评估特定路线或特定地点的当前交通状况。'
- en: '**Event availability indicator**: Integrating with an event ticketing API,
    we could build an application that can determine the availability of tickets for
    a desired event.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动可用性指示器**：通过集成活动票务API，我们可以构建一个应用程序，该程序可以确定所需活动的门票可用性。'
- en: '**Public transportation tracker**: By connecting to a public transportation
    API, we could build an application that can provide real-time updates on the status
    of buses, trains, or other forms of public transportation.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共交通追踪器**：通过连接到公共交通API，我们可以构建一个应用程序，该程序可以提供公交车、火车或其他公共交通工具的实时状态更新。'
- en: The GO-NO-GO IoT application is but a glimpse into our vast potential in utilizing
    web services with IoT. With the Raspberry Pi and Sense HAT, our potential expands
    to diverse IoT applications, monitoring various data and fostering innovation
    beyond weather-related scenarios.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: GO-NO-GO物联网应用程序只是我们利用Web服务和物联网的巨大潜力的一个缩影。有了Raspberry Pi和Sense HAT，我们的潜力扩展到各种物联网应用，监控各种数据，并在与天气相关的场景之外促进创新。
- en: Summary
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored the world of web services development using Raspberry
    Pi and Sense HAT. We began by learning about web services and wrote web services
    code. With our newfound knowledge, we created our first IoT application: a scrolling
    stock ticker. By connecting to the Alpha Vantage web service, we retrieved real-time
    stock information and displayed it in a continuous scrolling format on the Sense
    HAT’s dot-matrix display. This project demonstrated the ease of connecting to
    web services to obtain useful information.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用Raspberry Pi和Sense HAT进行Web服务开发的领域。我们首先了解了Web服务，并编写了Web服务代码。凭借我们的新知识，我们创建了我们的第一个物联网应用程序：一个滚动股票行情。通过连接到Alpha
    Vantage Web服务，我们检索了实时股票信息，并在Sense HAT的点阵显示屏上以连续滚动格式显示。这个项目展示了连接到Web服务以获取有用信息的简便性。
- en: Integrating web services with devices such as the Raspberry Pi is a skill crucial
    in today’s tech industry. By handling data from sources such as Alpha Vantage
    and OpenWeather and displaying it on the Sense HAT, we’ve bridged theory with
    practical application. This knowledge enhances our project capabilities and professional
    skills, positioning us well in the IoT and data-driven domains.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 将Web服务与Raspberry Pi等设备集成是当今科技行业的一项关键技能。通过处理来自Alpha Vantage和OpenWeather等来源的数据，并在Sense
    HAT上显示，我们将理论与实践相结合。这种知识增强了我们的项目能力和专业技能，使我们能够在物联网和数据驱动领域占据有利位置。
- en: We then ventured into building a weather display application. By leveraging
    the OpenWeather API, we obtained live weather information and transformed it into
    a scrolling message on the Sense HAT. We then took our development to the next
    step and used it to create a decision-making GO-NO-GO IoT application. In the
    GO-NO-GO application, we used weather conditions and player age as criteria to
    determine whether a baseball game should proceed (GO) or be canceled (NO-GO).
    We did so by displaying visual indicators such as a green checkmark or a flashing
    red X sign on the Sense HAT.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们尝试构建一个天气显示应用程序。通过利用OpenWeather API，我们获得了实时天气信息，并将其转换成Sense HAT上的滚动信息。然后，我们将我们的开发推进到下一步，并使用它来创建一个决策GO-NO-GO物联网应用程序。在GO-NO-GO应用程序中，我们使用天气条件和球员年龄作为标准，以确定棒球比赛是否应该继续（GO）或取消（NO-GO）。我们通过在Sense
    HAT上显示视觉指示器，如绿色勾号或闪烁的红色X标志来实现这一点。
- en: In the next chapter, we will explore IoT applications that involve physical
    interactions – specifically, the integration of motors. By incorporating motor
    control into our projects, we can create dynamic and interactive experiences that
    bridge the gap between the digital and physical worlds.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨涉及物理交互的物联网应用——特别是，电机的集成。通过将电机控制纳入我们的项目，我们可以创造动态和交互式的体验，从而弥合数字世界和物理世界之间的差距。
