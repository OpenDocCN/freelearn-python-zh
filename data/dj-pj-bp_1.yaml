- en: Chapter 1. Blueblog – a Blogging Platform
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。Blueblog-博客平台
- en: We are going to start with a simple blogging platform in Django. In recent years,
    Django has emerged as one of the clear leaders in web frameworks. When most people
    decide to start using a web framework, their searches lead them to either **Ruby
    on Rails** (**RoR**) or Django. Both are mature, stable, and extensively used.
    It appears that the decision to use one or the other depends mostly on which programming
    language you're familiar with. Rubyists go with RoR, Pythonistas go with Django.
    In terms of features, both can be used to achieve the same results, although they
    have different approaches to how things are done.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的Django博客平台开始。近年来，Django已经成为Web框架中的明星领导者之一。当大多数人决定开始使用Web框架时，他们的搜索结果要么是**Ruby
    on Rails**（**RoR**），要么是Django。两者都是成熟、稳定且被广泛使用的。似乎使用其中一个的决定主要取决于你熟悉哪种编程语言。Ruby程序员选择RoR，Python程序员选择Django。在功能方面，两者都可以用来实现相同的结果，尽管它们对待事物的方式有所不同。
- en: One of the most popular blogging platforms these days is Medium, widely used
    by a number of high profile bloggers. Its popularity stems from its elegant theme,
    and simple-to-use interface. I'll walk you through creating a similar application
    in Django, with a few surprise features that most blogging platforms don't have.
    This will give you a taste of things to come, and show you just how versatile
    Django can be.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如今最受欢迎的博客平台之一是Medium，被许多知名博客作者广泛使用。它的流行源于其优雅的主题和简单易用的界面。我将带你创建一个类似的Django应用程序，其中包含大多数博客平台没有的一些惊喜功能。这将让你体验到即将到来的东西，并展示Django有多么多才多艺。
- en: 'Before starting any software development project, it''s a good idea to have
    a rough roadmap of what we would like to achieve. Here''s a list of features that
    our blogging platform will have:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始任何软件开发项目之前，最好先大致规划一下我们想要实现的目标。以下是我们的博客平台将具有的功能列表：
- en: User should be able to register an account and create their blogs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够注册账户并创建他们的博客
- en: Users should be able to tweak the settings of their blogs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够调整他们博客的设置
- en: There should be simple interface for users to create and edit blog posts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该有一个简单的界面来创建和编辑博客文章
- en: Users should be able to share their blog posts on other blogs on the platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户应该能够在平台上的其他博客上分享他们的博客文章
- en: I know this seems like a lot of work, but Django comes with a couple of `contrib`
    packages that speed up our work considerably.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道这似乎是很多工作，但Django带有一些`contrib`包，可以大大加快我们的工作速度。
- en: The contrib packages
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: contrib包
- en: 'The `contrib` packages are a part of Django that contain some very useful applications
    that the Django developers decided should be shipped with Django. The included
    applications provide an impressive set of features, including some that we''ll
    be using in this application:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`contrib`包是Django的一部分，其中包含一些非常有用的应用程序，Django开发人员决定应该随Django一起发布。这些包含的应用程序提供了令人印象深刻的功能集，包括我们将在此应用程序中使用的一些功能：'
- en: '**Admin** is a full featured CMS that can be used to manage the content of
    a Django site. The Admin application is an important reason for the popularity
    of Django. We''ll use this to provide an interface for site administrators to
    moderate and manage the data in our application'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理是一个功能齐全的CMS，可用于管理Django站点的内容。管理应用程序是Django流行的重要原因。我们将使用此功能为网站管理员提供界面，以便在我们的应用程序中进行数据的审查和管理
- en: '**Auth** provides user registration and authentication without requiring us
    to do any work. We''ll be using this module to allow users to sign up, sign in,
    and manage their profiles in our application'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Auth提供用户注册和身份验证，而无需我们做任何工作。我们将使用此模块允许用户在我们的应用程序中注册、登录和管理他们的个人资料
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are a lot more goodies in the `contrib` module. I suggest you take a look
    at the complete list at [https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages](https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`contrib`模块中还有很多好东西。我建议你查看完整列表[https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages](https://docs.djangoproject.com/en/stable/ref/contrib/#contrib-packages)。'
- en: I usually end up using at least three of the `contrib` packages in all my Django
    projects. They provide often-required features like user registration and management,
    and free you to work on the core parts of your project, providing a solid foundation
    to build upon.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常在所有我的Django项目中至少使用三个`contrib`包。它们提供了通常需要的功能，如用户注册和管理，并使你能够专注于项目的核心部分，为你提供一个坚实的基础来构建。
- en: Setting up our development environment
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: For this first chapter, I'll go into some details about setting up the development
    environment. For later chapters, I'll only be providing minimal instructions.
    For further details about how I setup the development environment and why, take
    a look at [Appendix](apa.html "Appendix A. Development Environment Setup Details
    and Debugging Techniques"), *Development Environment Setup Details and Debugging
    Techniques*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这第一章，我将详细介绍如何设置开发环境。对于后面的章节，我只会提供最少的说明。有关我如何设置开发环境以及原因的更多详细信息，请参阅[附录](apa.html
    "附录A.开发环境设置详细信息和调试技术")，*开发环境设置详细信息和调试技术*。
- en: Let's start by creating the directory structure for our project, setting up
    the virtual environment and configuring some base Django settings that need to
    be set up in every project. Let's call our blogging platform BlueBlog.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为我们的项目创建目录结构开始，设置虚拟环境并配置一些基本的Django设置，这些设置需要在每个项目中设置。让我们称我们的博客平台为BlueBlog。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed explanations of the steps you're about to see are given in [Appendix](apa.html
    "Appendix A. Development Environment Setup Details and Debugging Techniques"),
    *Development Environment Setup Details and Debugging Techniques*. Please refer
    to that if you're unsure about why we're doing something or what a particular
    command does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有关即将看到的步骤的详细说明，请参阅[附录](apa.html "附录A.开发环境设置详细信息和调试技术")，*开发环境设置详细信息和调试技术*。如果您对我们为什么要做某事或特定命令的作用感到不确定，请参考该文档。
- en: To start a new project, you need to first open up your terminal program. In
    Mac OS X, it is the built-in terminal. In Linux, the terminal is named separately
    for each distribution, but you should not have trouble finding it; try searching
    your program list for the word terminal and something relevant should show up.
    In Windows, the terminal program is called the command line. You'll need to start
    the relevant program depending on your operating system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始一个新项目，您需要首先打开您的终端程序。在Mac OS X中，它是内置终端。在Linux中，终端根据每个发行版单独命名，但您不应该有找到它的麻烦；尝试在程序列表中搜索单词终端，应该会显示相关内容。在Windows中，终端程序称为命令行。您需要根据您的操作系统启动相关程序。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using the Windows operating system, you will need to slightly modify
    the commands shown in the book. Please refer to the *Developing on Windows* section
    of [Appendix](apa.html "Appendix A. Development Environment Setup Details and
    Debugging Techniques"), *Development Environment Setup Details and Debugging Techniques*
    for details.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Windows操作系统，您需要稍微修改书中显示的命令。请参考[附录](apa.html "附录 A. 开发环境设置详细信息和调试技术")中的*在Windows上开发*部分，了解详情。
- en: 'Open the relevant terminal program for your operating system and start by creating
    the directory structure for our project; `cd` (ing) into the root project directory
    using the commands shown below:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您操作系统的相关终端程序，并通过以下命令创建我们项目的目录结构；使用以下命令`cd`（进入）到根项目目录：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next let''s create the virtual environment, install Django, and start our project:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们创建虚拟环境，安装Django，并启动我们的项目：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: With that out of the way, we're ready to start developing our blogging platform.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 搞定这些之后，我们就可以开始开发我们的博客平台了。
- en: Database settings
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库设置
- en: 'Open up the settings found at `$PROJECT_DIR/src/blueblog/settings.py` in your
    favorite editor and make sure that the `DATABASES` settings variable matches this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在您喜欢的编辑器中打开`$PROJECT_DIR/src/blueblog/settings.py`中的设置，并确保`DATABASES`设置变量与以下内容匹配：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In order to initialize the database file, run the following commands:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化数据库文件，请运行以下命令：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Static files settings
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态文件设置
- en: The last step in setting up our development environment, is configuring the
    `staticfiles` `contrib` application. The staticfiles application provides a number
    of features that make it easy to manage the static files (css, images, JavaScript)
    of your projects. While our usage will be minimal, you should look at the Django
    documentation for staticfiles in further detail, since it is used quite heavily
    in most real world Django projects. You can find the documentation at [https://docs.djangoproject.com/en/stable/howto/static-files/](https://docs.djangoproject.com/en/stable/howto/static-files/).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 设置开发环境的最后一步是配置`staticfiles` `contrib`应用程序。staticfiles应用程序提供了许多功能，使得管理项目的静态文件（css、图片、JavaScript）变得容易。虽然我们的使用将是最小化的，但您应该仔细查看Django文档中关于staticfiles的详细信息，因为它在大多数真实世界的Django项目中被广泛使用。您可以在[https://docs.djangoproject.com/en/stable/howto/static-files/](https://docs.djangoproject.com/en/stable/howto/static-files/)找到文档。
- en: In order to set up the staticfiles application we have to configure a few settings
    in the `settings.py` file. First, make sure that `django.contrib.staticfiles`
    is added to the `INSTALLED_APPS`. Django should have done that by default.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置staticfiles应用程序，我们必须在`settings.py`文件中配置一些设置。首先确保`django.contrib.staticfiles`已添加到`INSTALLED_APPS`中。Django应该默认已经做了这个。
- en: Next, set `STATIC_URL` to whatever URL you want your static files to be served
    from. I usually leave this to the default value, `/static/`. This is the URL that
    Django will put in your templates when you use the static template tag to get
    the path to a static file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将`STATIC_URL`设置为您希望静态文件从中提供的任何URL。我通常将其保留为默认值`/static/`。这是Django在您使用静态模板标签获取静态文件路径时将放入您的模板中的URL。
- en: A base template
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个基础模板
- en: 'Next let''s setup a base template that all the other templates in our application
    will inherit from. I prefer to have templates that are used by more than one application
    of a project in a directory named templates in the project source folder. To set
    that up, add `os.path.join(BASE_DIR, ''templates'')` to the `DIRS` array of the
    `TEMPLATES` config dictionary in the settings file, and then create a directory
    named templates in `$PROJECT_ROOT/src`. Next, using your favorite text editor,
    create a file named `base.html` in the new folder with the following content:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们设置一个基础模板，所有应用程序中的其他模板都将从中继承。我喜欢将项目源文件夹中多个应用程序使用的模板放在名为templates的目录中。为了设置这一点，在设置文件的`TEMPLATES`配置字典的`DIRS`数组中添加`os.path.join(BASE_DIR,
    'templates')`，然后在`$PROJECT_ROOT/src`中创建一个名为templates的目录。接下来，使用您喜欢的文本编辑器，在新文件夹中创建一个名为`base.html`的文件，内容如下：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Much like Python classes inheriting from other classes, Django templates can
    also inherit from other templates. And just like Python classes can have functions
    overridden by their subclasses, Django templates can also define blocks that children
    templates can override. Our `base.html` template provides one block for inheriting
    templates to override, called **content**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python类继承自其他类一样，Django模板也可以继承自其他模板。就像Python类的函数可以被子类覆盖一样，Django模板也可以定义子模板可以覆盖的块。我们的`base.html`模板提供了一个供继承模板覆盖的块，称为**content**。
- en: The reason for using template inheritance is code reuse. We should put HTML
    that we want to be visible on every page of our site, such as headers, footers,
    copyright notices, meta tags, and so on, in the base template. Then, any template
    inheriting from it will automatically get all that common HTML included automatically,
    and we will only need to override the HTML code for the block we want to customize.
    You'll see this principal of creating and overriding blocks in base templates
    used throughout the projects in this book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模板继承的原因是代码重用。我们应该将我们希望在网站的每个页面上可见的HTML，如标题、页脚、版权声明、元标记等，放在基础模板中。然后，任何继承自它的模板将自动获得所有这些常见的HTML，我们只需要覆盖我们想要自定义的块的HTML代码。你将看到这种在本书中的项目中使用创建和覆盖基础模板中的块的原则。
- en: User accounts
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户帐户
- en: With the database setup out of the way, let's start creating our application.
    If you remember, the first thing on our list of features is to allow users to
    register accounts on our site. As I've mentioned before, we'll be using the auth
    package from the Django contrib packages to provide user account features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库设置完成后，让我们开始创建我们的应用程序。如果你记得的话，我们功能列表中的第一件事是允许用户在我们的网站上注册帐户。正如我之前提到的，我们将使用Django
    contrib包中的auth包来提供用户帐户功能。
- en: In order to use the auth package, we'll need to add it our `INSTALLED_APPS`
    list in the settings file (found at `$PROJECT_ROOT/src/blueblog/settings.py`).
    In the settings file, find the line defining `INSTALLED_APPS` and make sure that
    the string `django.contrib.auth` is part of the list. It should be by default,
    but for some reason if it's not there, add it manually.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用auth包，我们需要在设置文件（位于`$PROJECT_ROOT/src/blueblog/settings.py`）中的`INSTALLED_APPS`列表中添加它。在设置文件中，找到定义`INSTALLED_APPS`的行，并确保字符串`django.contrib.auth`是列表的一部分。默认情况下应该是这样的，但如果不是，请手动添加。
- en: You'll see that Django has included the auth package and couple of other contrib
    applications to the list by default. A new Django project includes these applications
    by default because almost all Django projects end up using these.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到Django默认情况下包含了auth包和其他一些contrib应用程序到列表中。一个新的Django项目默认包含这些应用程序，因为几乎所有的Django项目最终都会使用它们。
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you need to add the auth application to the list, remember to use quotes
    to surround the application name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将auth应用程序添加到列表中，请记住使用引号括起应用程序名称。
- en: We also need to make sure that the `MIDDLEWARE_CLASSES` list contains `django.contrib.sessions.middleware.SessionMiddleware`,
    `django.contrib.auth.middleware.AuthenticationMiddleware`, and `django.contrib.auth.middleware.SessionAuthenticationMiddleware`.
    These middleware classes give us access to the logged in user in our views, and
    also make sure that if I change the password for my account, I'm logged out from
    all other devices that I previously logged on to.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要确保`MIDDLEWARE_CLASSES`列表包含`django.contrib.sessions.middleware.SessionMiddleware`、`django.contrib.auth.middleware.AuthenticationMiddleware`和`django.contrib.auth.middleware.SessionAuthenticationMiddleware`。这些中间件类让我们在视图中访问已登录的用户，并确保如果我更改了我的帐户密码，我将从先前登录的所有其他设备中注销。
- en: As you learn more about the various contrib applications and their purpose,
    you can start removing any that you know you won't need in your project. Now,
    let's add the URLs, views and templates that allow the users to register with
    our application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对各种contrib应用程序及其用途的了解越来越多，你可以开始删除你知道在项目中不需要的任何应用程序。现在，让我们添加允许用户在我们的应用程序中注册的URL、视图和模板。
- en: A user accounts app
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户帐户应用程序
- en: 'In order to create the various views, URLs, and templates related to user accounts,
    we''ll start a new application. To do so, type the following in your command line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建与用户帐户相关的各种视图、URL和模板，我们将开始一个新的应用程序。要这样做，在命令行中输入以下内容：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should create a new `accounts` folder inside the `src` folder. We'll add
    code that deals with user accounts in files found inside this folder. To let Django
    know that we want to use this application in our project, add the application
    name (accounts) to the `INSTALLED_APPS` setting variable; making sure to surround
    it in quotes.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`src`文件夹内创建一个新的`accounts`文件夹。我们将在这个文件夹内的文件中添加处理用户帐户的代码。为了让Django知道我们想要在项目中使用这个应用程序，将应用程序名称（accounts）添加到`INSTALLED_APPS`设置变量中；确保用引号括起来。
- en: Account registration
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帐户注册
- en: 'The first feature we will work on is user registration. Let''s start by writing
    the code for the registration view inside `accounts/views.py`. Make sure that
    the contents of `views.py` match what is shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要处理的第一个功能是用户注册。让我们从在`accounts/views.py`中编写注册视图的代码开始。确保`views.py`的内容与这里显示的内容匹配：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I''ll explain what each line of this code is doing in a bit. But first, I''d
    like you to get to a state where you can register a new user and see for yourself
    how the flow works. Next, we''ll create the template for this view. In order to
    create the template, you first need to create a new folder called `templates`
    inside the `accounts` folder. The name of the folder is important, since Django
    automatically searches for templates in folders of that name. To create this folder,
    just type the following command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在稍后解释这段代码的每一行都做了什么。但首先，我希望你能达到一个状态，可以注册一个新用户并亲自看看流程是如何工作的。接下来，我们将为这个视图创建模板。为了创建模板，你首先需要在`accounts`文件夹内创建一个名为`templates`的新文件夹。文件夹的名称很重要，因为Django会自动在具有该名称的文件夹中搜索模板。要创建这个文件夹，只需输入以下命令：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, create a new file called `user_registration.html` inside the `templates`
    folder and type in the code shown below:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`templates`文件夹内创建一个名为`user_registration.html`的新文件，并输入下面显示的代码：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, remove the existing code in `blueblog/urls.py` and replace it with
    this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除`blueblog/urls.py`中的现有代码，并替换为以下内容：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'That''s all the code we need to get user registration in our project! Let''s
    do a quick demonstration. Run the development server by typing the following command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在项目中需要的所有代码来实现用户注册！让我们进行一个快速演示。通过输入以下命令来运行开发服务器：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In your browser, visit `http://127.0.0.1:8000/new-user/` and you'll see a user
    registration form. Fill that in, and click submit. You'll be taken to a blank
    page on successful registration. If there are some errors the form will be shown
    again with the appropriate error messages. Let's verify that our new account was
    indeed created in our database.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，访问`http://127.0.0.1:8000/new-user/`，您将看到一个用户注册表单。填写表单并点击提交。成功注册后，您将被带到一个空白页面。如果有错误，表单将再次显示，并显示适当的错误消息。让我们验证一下我们的新账户是否确实在数据库中创建了。
- en: 'For the next step, we will need to have an administrator account. The Django
    auth contrib application can assign permissions to user accounts. The user with
    the highest level of permission is called the **super user**. The super user account
    has free reign over the application and can perform any administrator actions.
    To create a super user account, run this command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将需要一个管理员账户。Django auth contrib应用程序可以为用户账户分配权限。具有最高权限级别的用户被称为**超级用户**。超级用户账户可以自由地管理应用程序并执行任何管理员操作。要创建超级用户账户，请运行以下命令：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since you already have the `runserver` command running in your terminal, you
    will need to quit it first by pressing *Ctrl* + *C* in the terminal. You can then
    run the `createsuperuser` command in the same terminal. After running the `createsuperuser`
    command, you'll need to start the `runserver` command again to browse the site.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您已经在终端中运行了`runserver`命令，您需要先按下终端中的*Ctrl* + *C*来退出。然后您可以在同一个终端中运行`createsuperuser`命令。运行`createsuperuser`命令后，您需要再次启动`runserver`命令来浏览网站。
- en: If you want to keep the `runserver` command running and run the `createsuperuser`
    command in a new terminal window, you will need to make sure you activate the
    virtual environment for this application by running the same source `blueblogEnv/bin/activate`
    command that we ran earlier when we created our new project.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想保持`runserver`命令运行，并在新的终端窗口中运行`createsuperuser`命令，您需要确保通过运行与我们创建新项目时相同的`source
    blueblogEnv/bin/activate`命令来激活此应用程序的虚拟环境。
- en: After you have created the account visit `http://127.0.0.1:8000/admin/` and
    log in with the admin account. You will see a link titled **Users**. Click that
    and you should see a list of users registered in our app. It will include the
    user you just created.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完账户后，访问`http://127.0.0.1:8000/admin/`并使用管理员账户登录。您将看到一个名为**Users**的链接。点击该链接，您应该会看到我们应用程序中注册的用户列表。其中将包括您刚刚创建的用户。
- en: Congrats! In most other frameworks, getting to this point with a working user
    registration feature would take a lot more effort. Django, with it's batteries
    included approach, allows us to do the same with a minimum of effort.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！在大多数其他框架中，要实现一个可用的用户注册功能，需要付出更多的努力。Django以其一应俱全的方式，使我们能够以最少的努力实现相同的功能。
- en: Next, I'll explain what each line of code that you wrote does.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将解释您编写的每行代码的作用。
- en: Generic views
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用视图
- en: 'Here''s the code for the user registration view again:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用户注册视图的代码：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our view is pretty short for something that does such a lot of work. That's
    because instead of writing code from scratch to handle all the work, we use one
    of the most useful features of Django, generic views. Generic views are base classes
    included with Django that provide functionality commonly required by a lot of
    web apps. The power of generic views comes from the ability to customize them
    to a great degree with ease.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图对于做了这么多工作来说非常简短。这是因为我们使用了Django最有用的功能之一，即通用视图，而不是从头开始编写处理所有工作的代码。通用视图是Django提供的基类，提供了许多Web应用程序通常需要的功能。通用视图的强大之处在于能够轻松地对其进行大量定制。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about Django generic views in the documentation available
    at [https://docs.djangoproject.com/en/stable/topics/class-based-views/](https://docs.djangoproject.com/en/stable/topics/class-based-views/).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/stable/topics/class-based-views/](https://docs.djangoproject.com/en/stable/topics/class-based-views/)上的文档中阅读更多关于Django通用视图的信息。
- en: Here, we're using the `CreateView` generic view. This generic view can display
    a `ModelForm` using a template and on submission can either redisplay the page
    with errors if the form data was invalid or call the `save` method on the form
    and redirect the user to a configurable URL. The `CreateView` can be configured
    in a number of ways.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`CreateView`通用视图。这个通用视图可以使用模板显示`ModelForm`，并在提交时，如果表单数据无效，可以重新显示页面并显示错误，或者调用表单的`save`方法并将用户重定向到可配置的URL。`CreateView`可以以多种方式进行配置。
- en: If you want a `ModelForm` to be created automatically from some Django model,
    just set the `model` attribute to the `model` class, and the form will be generated
    automatically from the fields of the model. If you want the form only show certain
    fields from the model, use the `fields` attribute to list the fields you want,
    exactly like you'd do when using a `ModelForm`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望从某个Django模型自动生成`ModelForm`，只需将`model`属性设置为`model`类，表单将自动从模型的字段生成。如果您希望表单只显示模型的某些字段，请使用`fields`属性列出您想要的字段，就像使用`ModelForm`时所做的那样。
- en: In our case, instead of having a `ModelForm` generated automatically, we're
    providing one of our own; `UserCreationForm`. We do this by setting the `form_class`
    attribute on the view. This form, which is part of the auth contrib app, provides
    the fields and a `save` method that can be used to create a new user. As we start
    developing more complicated applications in later chapter, you'll see that this
    theme of composing solutions from small reusable parts provided by Django is a
    common practice in Django web app development, and in my opinion is one of the
    best features of the framework.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们不是自动生成`ModelForm`，而是提供了我们自己的`UserCreationForm`。我们通过在视图上设置`form_class`属性来实现这一点。这个表单是auth
    contrib应用的一部分，它提供了字段和一个`save`方法，可以用来创建一个新用户。随着我们在后面的章节中开始开发更复杂的应用程序，您会发现这种从Django提供的小型可重用部分组合解决方案的主题是Django
    Web应用程序开发中的常见做法，我认为这是框架中最好的特性之一。
- en: Finally, we define a `get_success_url` function that does a simple reverse URL
    and returns the generated URL. The `CreateView` calls this function to get URL
    to redirect the user to when a valid form is submitted and saved successfully.
    To get something up and running quickly, we left out a real success page and just
    redirected the user to a blank page. We'll fix this later.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了一个`get_success_url`函数，它执行简单的反向URL并返回生成的URL。`CreateView`调用此函数以获取在提交有效表单并成功保存时将用户重定向到的URL。为了快速启动并运行某些东西，我们省略了一个真正的成功页面，只是将用户重定向到一个空白页面。我们以后会修复这个问题。
- en: Template and URLs
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模板和URL
- en: The template, which extends the base template we created earlier simply displays
    the form passed to it by the `CreateView` using the `form.as_p` method, which
    you might have seen in the simple Django projects you may have worked on before.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 模板扩展了我们之前创建的基本模板，简单地使用`CreateView`传递给它的表单，使用`form.as_p`方法显示表单，您可能在之前的简单Django项目中见过。
- en: The `urls.py` file is a bit more interesting. You should be familiar with most
    of it, the parts where we include the admin site URLs and the part where we assign
    our view a URL. It's the usage of `TemplateView` that I want to explain here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`urls.py`文件更有趣一些。您应该熟悉其中的大部分内容，我们包含管理站点URL的部分以及我们为视图分配URL的部分。我想在这里解释一下`TemplateView`的用法。'
- en: Like the `CreateView`, the `TemplateView` is another generic view provided to
    us by Django. As the name suggests, this view can render and display a template
    to the user. It has a number of customization options. The most important one
    is `template_name`, which tells it which template to render and display to the
    user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 像`CreateView`一样，`TemplateView`是Django提供给我们的另一个通用视图。顾名思义，这个视图可以向用户呈现和显示模板。它有许多自定义选项。最重要的是`template_name`，它告诉它要呈现和显示给用户的模板是哪一个。
- en: We could have created another view class that subclassed the `TemplateView`,
    and customized it by setting attributes and overriding functions like we did for
    our registration view. But I wanted to show you another method of using a generic
    view in Django. If you only need to customize some basic parameters of a generic
    view; in this case we only wanted to set the `template_name` parameter of the
    view, you can just pass the values as `key=value` pairs as function keyword arguments
    to the `as_view` method of the class when including it in the `urls.py` file.
    Here, we pass the template name which the view renders when the user access it's
    URL. Since we just needed a placeholder URL to redirect the user to, we simply
    use the blank `base.html` template.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以创建另一个视图类，它是`TemplateView`的子类，并通过设置属性和覆盖函数来自定义它，就像我们为注册视图所做的那样。但我想向您展示Django中使用通用视图的另一种方法。如果您只需要自定义通用视图的一些基本参数；在这种情况下，我们只想设置视图的`template_name`参数，您可以将值作为函数关键字参数传递给类的`as_view`方法，这样只需要传递`key=value`对。在`urls.py`文件中包含它时。在这里，我们传递模板名称，当用户访问它的URL时，视图呈现的模板。由于我们只需要一个占位符URL来重定向用户，我们只需使用空白的`base.html`模板。
- en: Tip
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This technique of customizing generic views by passing key/value pairs only
    makes sense when you're interested in customizing very basic attributes, like
    we do here. In case you want more complicated customizations, I advice you subclass
    the view, otherwise you will quickly get messy code that is difficult to maintain.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递键/值对来自定义通用视图的技术只有在您有兴趣自定义非常基本的属性时才有意义，就像我们在这里做的那样。如果您想要更复杂的自定义，我建议您子类化视图，否则您将很快得到难以维护的混乱代码。
- en: Login and logout
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 登录和注销
- en: With registration out of the way, let's write code to provide users with the
    ability to log in and log out. To start, the user needs some way to go to the
    login and registration pages from any page on the site. To do this, we'll need
    to add header links to our template. This is the perfect opportunity to demonstrate
    how template inheritance can lead to much cleaner and less code in our templates.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注册完成后，让我们编写代码为用户提供登录和注销的功能。首先，用户需要一种方式从站点上的任何页面转到登录和注册页面。为此，我们需要在我们的模板中添加页眉链接。这是展示模板继承如何可以在我们的模板中导致更清洁和更少代码的绝佳机会。
- en: 'Add the following lines right after the `body` tag in our `base.html` file:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`base.html`文件的`body`标签后面添加以下行：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you open the home page for our site now (at `http://127.0.0.1:8000/`), you
    should see that we now have three links on what was previously a blank page. It
    should look similar to the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在打开我们站点的主页（在`http://127.0.0.1:8000/`），您应该看到我们之前空白页面上的三个链接。它应该类似于以下截图：
- en: '![Login and logout](img/00698_01_01.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![登录和注销](img/00698_01_01.jpg)'
- en: Click on the **Register Account** link. You'll see the registration form we
    had before, and the same three links again. Note how we only added those links
    to the `base.html` template. But since the user registration template extends
    the base template, it got those links without any effort on our part. This is
    where template inheritance really shines.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 单击**注册账户**链接。您将看到我们之前的注册表单，以及相同的三个链接。请注意我们只将这些链接添加到`base.html`模板中。但由于用户注册模板扩展了基本模板，所以它在我们的努力下获得了这些链接。这就是模板继承真正发挥作用的地方。
- en: You might have noticed that the `href` for the login/logout links is empty.
    Let's start with the login part.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到登录/注销链接的`href`为空。让我们从登录部分开始。
- en: The login view
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录视图
- en: 'Let''s define the URL first. In `blueblog/urls.py` import the login view from
    the auth app:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义URL。在`blueblog/urls.py`中从auth应用程序导入登录视图：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, add this to the `urlpatterns` list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将其添加到`urlpatterns`列表中：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then create a new file inside `accounts/templates` called `login.html`. Put
    in the following content:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`accounts/templates`中创建一个名为`login.html`的新文件。输入以下内容：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Finally, open up `blueblog/settings.py` and add the following line to the end
    of the file:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开`blueblog/settings.py`并在文件末尾添加以下行：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's go over what we've done here. First, notice that instead of creating our
    own code to handle the login feature, we used the view provided by the auth app.
    We import it using `from django.contrib.auth.views import login`. Next, we associate
    it with the login/URL. If you remember the user registration part, we passed the
    template name to the home page view as a keyword parameter in the `as_view()`
    function. That approach is used for class-based views. For old-style view functions,
    we can pass a dictionary to the `url` function that is passed as keyword arguments
    to the view. Here, we use the template we created in `login.html`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里所做的事情。首先，请注意，我们没有创建自己的代码来处理登录功能，而是使用了auth应用程序提供的视图。我们使用`from django.contrib.auth.views
    import login`导入它。接下来，我们将其与登录/URL关联起来。如果您还记得用户注册部分，我们将模板名称作为关键字参数传递给`as_view()`函数中的主页视图。这种方法用于基于类的视图。对于旧式的视图函数，我们可以将一个字典传递给`url`函数，作为关键字参数传递给视图。在这里，我们使用了我们在`login.html`中创建的模板。
- en: If you look at the documentation for the login view ([https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login](https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login)),
    you'll see that on successfully logging in, it redirects the user to `settings.LOGIN_REDIRECT_URL`.
    By default, this setting has a value of `/accounts/profile/`. Since we don't have
    such a URL defined, we change the setting to point to our home page URL instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看登录视图的文档（[https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login](https://docs.djangoproject.com/en/stable/topics/auth/default/#django.contrib.auth.views.login)），您会发现成功登录后，它会将用户重定向到`settings.LOGIN_REDIRECT_URL`。默认情况下，此设置的值为`/accounts/profile/`。由于我们没有定义这样的URL，我们将更改设置以指向我们的主页URL。
- en: Next, let's define the logout view.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义登出视图。
- en: The logout view
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登出视图
- en: 'In `blueblog/urls.py` import the logout view using `from django.contrib.auth.views
    import logout` and add the following to the `urlpatterns` list:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blueblog/urls.py`中使用`from django.contrib.auth.views import logout`导入登出视图，并将以下内容添加到`urlpatterns`列表中：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And that's it. The logout view doesn't need a template; it just needs to be
    configured with a URL to redirect the user to after login them out. We just redirect
    the user back to the login page.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。登出视图不需要模板；它只需要配置一个URL，以在登出后将用户重定向到该URL。我们只需将用户重定向回登录页面。
- en: Navigation links
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导航链接
- en: 'Having added the login/logout view, we need to make the links we added in our
    navigation menu earlier take the user to those views. Change the list of links
    we had in `templates/base.html` to the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了登录/登出视图之后，我们需要让之前在导航菜单中添加的链接带用户到这些视图。将`templates/base.html`中的链接列表更改为以下内容：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will show the **Login and Register Account** links to the user if they
    aren't already logged in. If they are logged in, which we check using the `request.user.is_authenticated`
    function, they are only shown the **Logout** link. You can test all of these links
    yourself and see how little code was needed to make such a major feature of our
    site work. This is all possible because of the contrib applications that Django
    provides.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未登录，这将向用户显示**登录和注册账户**链接。如果他们已经登录，我们使用`request.user.is_authenticated`函数进行检查，只会显示**登出**链接。您可以自行测试所有这些链接，并查看需要多少代码才能使我们网站的一个重要功能运行。这一切都是因为Django提供的contrib应用程序。
- en: The blog
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客
- en: 'With the user registration out of the way, let''s get started with the blogging
    side of the application. We''ll create a new application for the blog, so in the
    console, type in the following:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 用户注册已经完成，让我们开始处理应用程序的博客部分。我们将为博客创建一个新应用程序，在控制台中输入以下内容：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Add the blog application to the list of `INSTALLED_APPS` in our `settings.py`
    file. With the app created and installed, let's start with the models we'll be
    using.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将博客应用程序添加到`settings.py`文件中的`INSTALLED_APPS`列表中。应用程序创建并安装后，让我们开始使用我们将使用的模型。
- en: Models
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: 'In `blog/models.py`, type the code shown below:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog/models.py`中，输入下面显示的代码：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After typing in this code, run the following commands to create the database
    tables for these models:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入此代码后，运行以下命令为这些模型创建数据库表：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will create the database tables necessary to support our new models. The
    models are pretty basic. One field type that you might not have used before is
    the **SlugField**. A slug is a piece of text that is used to uniquely identify
    something. In our case, we use two slug fields to identify both our blog and our
    blog post. Since the fields are non-editable, we'll have to write the code to
    give them some values ourselves. We'll look into that later.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建支持我们新模型所需的数据库表。模型非常基本。您可能以前没有使用过的一个字段类型是**SlugField**。Slug是用于唯一标识某物的一段文本。在我们的情况下，我们使用两个slug字段来标识我们的博客和博客文章。由于这些字段是不可编辑的，我们将不得不编写代码为它们赋一些值。我们稍后会研究这个问题。
- en: Creating a blog view
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建博客视图
- en: 'Let''s create a view where the user can setup his blog. Let''s make the form
    that the user will use to create a new blog. Create a new file `blog/forms.py`
    and enter the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个视图，用户可以在其中设置他的博客。让我们创建一个用户将用来创建新博客的表单。创建一个新文件`blog/forms.py`，并输入以下内容：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This creates a model form that allows edits to only the **title** field of our
    `Blog` model. Let's create a template and view to go along with this form.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个模型表单，允许仅对我们的`Blog`模型的**标题**字段进行编辑。让我们创建一个模板和视图来配合这个表单。
- en: 'Create a file called `blog/templates/blog_settings.html` and type in the following
    HTML code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`blog/templates/blog_settings.html`的文件，并输入以下HTML代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you may have noticed, I've used the `url` tag on the blog-settings named
    URL, but haven't created that URL pattern yet. We'll do that after we create the
    view, but just remember the name for later and make sure our URL gets the same
    name.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我在博客设置命名的URL上使用了`url`标签，但尚未创建该URL模式。在创建视图后，我们将这样做，但请记住名称，确保我们的URL得到相同的名称。
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There is no right order in which to create your view, template and URLs. It's
    up to you to decide whichever you are more comfortable with.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 创建视图、模板和URL的顺序没有固定的规定。你可以自行决定哪种方式更适合你。
- en: 'In your `blog/views.py` file, add the following code to create the view:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`blog/views.py`文件中，添加以下代码来创建视图：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Modify `blueblog/urls.py`. Add this to the top of the file `from blog.views
    import NewBlogView` and add this to the `urlpatterns` list:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`blueblog/urls.py`。在文件顶部添加`from blog.views import NewBlogView`，并将其添加到`urlpatterns`列表中：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As a final step, we need some way for the user to access our new view. Change
    the header block in `base.html` to look like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们需要一些方式让用户访问我们的新视图。将`base.html`中的标题块更改为以下内容：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To test our latest feature, open up the home page at `http://127.0.0.1:8000`
    and click the **Create New Blog** link. It will present a form where you can enter
    the blog title and save your new blog. The page should look similar to the following
    screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的最新功能，打开`http://127.0.0.1:8000`上的主页，然后点击**创建新博客**链接。它将呈现一个表单，您可以在其中输入博客标题并保存您的新博客。页面应该类似于以下截图：
- en: '![Creating a blog view](img/00698_01_02.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![创建博客视图](img/00698_01_02.jpg)'
- en: Most of the code we have added is pretty basic. The interesting part is the
    `NewBlogView`. Let's look at how it works. First of all, notice that we subclass
    it from the `CreateView` generic view. The create view allows us to easily display
    and process a form that will create a new object of the given model. To configure
    it, we can either set the `model` and `fields` attribute of the view, which the
    create view will then use to generate a model form, or we can manually create
    a model form and assign it to the view, like we've done here.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的大部分代码都很基本。有趣的部分是`NewBlogView`。让我们看看它是如何工作的。首先，注意我们是从`CreateView`通用视图中继承的。创建视图允许我们轻松地显示和处理一个将创建给定模型的新对象的表单。要配置它，我们可以设置视图的`model`和`fields`属性，然后创建视图将使用它们生成模型表单，或者我们可以手动创建模型表单并将其分配给视图，就像我们在这里做的那样。
- en: We also configure the template that will be used to display the form. We then
    define the `form_valid` function, which the create view calls when the form is
    submitted with valid data. In our implementation, we call the model forms `save`
    method with the `commit` keyword parameter set to `False`. This tells the form
    to create a new object of our model with the data it was passed, but not to save
    the created object to the database. Then we set the owner of the new blog object
    to the logged in user and set its slug to a slugified version of the title entered
    by the user. slugify is one of the many utility functions that Django provides.
    Once we've modified the blog object per our requirement, we save it and return
    an `HttpResponseRedirect` from the `form_valid` function. This response is returned
    to the browser which then takes the user to the home page.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还配置了用于显示表单的模板。然后我们定义`form_valid`函数，当表单提交有效数据时，创建视图将调用该函数。在我们的实现中，我们调用模型表单的`save`方法，并将`commit`关键字参数设置为`False`。这告诉表单使用传递的数据创建我们模型的新对象，但不保存创建的对象到数据库。然后我们将新博客对象的所有者设置为登录的用户，并将其slug设置为用户输入的标题的slugified版本。slugify是Django提供的众多实用函数之一。一旦我们根据我们的要求修改了博客对象，我们保存它并从`form_valid`函数返回`HttpResponseRedirect`。这个响应返回给浏览器，然后将用户带到主页。
- en: Until now, we've made do with a blank page with just a navigation bar as our
    home page. But it has a serious problem. Start by creating a new blog by following
    the link in the navigation bar. On successfully creating a new blog, we are redirected
    back to the home page, where we are again greeted with a link to create another
    blog. But this isn't the behavior we want. Ideally, our users should be limited
    to one blog per account.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的主页只是一个带有导航栏的空白页面。但它有一个严重的问题。首先通过导航栏中的链接创建一个新的博客。成功创建新博客后，我们将被重定向回主页，再次看到一个链接来创建另一个博客。但这不是我们想要的行为。理想情况下，我们的用户应该限制为每个帐户一个博客。
- en: 'Let''s fix this. First, we''ll restrict the blog creation view to only allow
    users to create a blog if they don''t already have one. Import `HttpResponseForbidden`
    and the `Blog` model in `blog/views.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解决这个问题。首先，我们将限制博客创建视图，只允许用户在没有博客的情况下创建博客。在`blog/views.py`中导入`HttpResponseForbidden`和`Blog`模型：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add a `dispatch` method to the `NewBlogView` class with the following code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NewBlogView`类中添加一个`dispatch`方法，其中包含以下代码：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `dispatch` method is one of the most useful methods to override on generic
    views. It is the first method that is called when the view URL is hit, and decides
    based on the request type whether to call the `get` or `post` methods on the view
    class to process the request. Thus, if you ever want to have some code that is
    run on all request types (GET, POST, HEAD, PUT, and so on), dispatch is the best
    method to override.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch`方法是要在通用视图上覆盖的最有用的方法之一。当视图URL被访问时，它是第一个被调用的方法，并根据请求类型决定是否调用视图类上的`get`或`post`方法来处理请求。因此，如果您想要在所有请求类型（GET、POST、HEAD、PUT等）上运行一些代码，`dispatch`是要覆盖的最佳方法。'
- en: In this case, we make sure that the user doesn't already have a blog object
    associated with their account. If they do, we return the `Not Allowed` response
    by using the `HttpResponseForbidden` response class. Try it out. You shouldn't
    even be able to access the new blog page now if you have already created a blog
    before and should see an error instead.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们确保用户没有与其帐户关联的博客对象。如果有，我们将使用`HttpResponseForbidden`响应类返回`Not Allowed`响应。试一下。如果您之前已经创建了博客，现在甚至不能访问新的博客页面，而应该看到一个错误。
- en: 'One last thing. Try accessing the URL `http://127.0.0.1:8000/blog/new/` after
    logging out. Notice how you''ll get an `AnonymousUser` object is not iterable
    error. This is because even though you''re not logged in as a registered user,
    the code for the view still assumes that you are. Also, you should not be able
    to access the new blog page without logging in first. To fix this, first put these
    two import lines at the top of `blog/views.py`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事。在注销后尝试访问URL`http://127.0.0.1:8000/blog/new/`。注意您将收到`AnonymousUser`对象不可迭代的错误。这是因为即使您没有以注册用户的身份登录，视图的代码仍然假定您是。此外，您应该无法在未登录的情况下访问新博客页面。为了解决这个问题，首先将这两个导入行放在`blog/views.py`的顶部：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then change the definition line of the dispatch method to match the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然后更改dispatch方法的定义行以匹配以下内容：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If you try to access the page now without logging in first, you should see
    a `Page not found (404)` Django error page. If you look at the URL for that page,
    you''ll see that Django is trying to serve the `/accounts/login/` URL. That''s
    the default behavior for the `login_required` decorator. To fix this we need to
    change the value of the `LOGIN_URL` variable in our settings file. Put this in
    `blueblog/settings.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在尝试在未登录的情况下访问页面，您应该会看到`Page not found (404)`的Django错误页面。如果您查看该页面的URL，您将看到Django正在尝试提供`/accounts/login/`的URL。这是`login_required`装饰器的默认行为。为了解决这个问题，我们需要更改设置文件中`LOGIN_URL`变量的值。将其放在`blueblog/settings.py`中：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Try accessing `http://localhost:8000/blog/new/` now and you will be redirected
    to the login page. If you put in the correct username/password combination, you
    will be logged in and taken to the page you were trying to access before, the
    **Create New Blog** page. This functionality is provided to us for free because
    we use the built-in login view of Django.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试访问`http://localhost:8000/blog/new/`，您将被重定向到登录页面。如果输入正确的用户名/密码组合，您将登录并被带到您之前尝试访问的页面，**创建新博客**页面。这个功能是免费提供给我们的，因为我们使用了Django的内置登录视图。
- en: We'll discuss the `method_decorator` and the `login_required` decorator in later
    chapters. If you want more info on these now, look at their documentation in the
    Django docs. It does an excellent job of explaining both.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中讨论`method_decorator`和`login_required`装饰器。如果您现在想要更多关于这些的信息，请查看Django文档中它们的文档。它在解释这两者方面做得非常出色。
- en: You will find the documentation for `login_required` at [https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator](https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator).
    For the `method_decorator`, you can look at [https://docs.djangoproject.com/en/stable/topics/class-based-views/intro/#decorating-the-class](https://docs.djangoproject.com/en/stable/topics/class-based-views/intro/#decorating-the-class).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator](https://docs.djangoproject.com/en/stable/topics/auth/default/#the-login-required-decorator)找到`login_required`的文档。对于`method_decorator`，您可以查看[https://docs.djangoproject.com/en/stable/topics/class-based-views/intro/#decorating-the-class](https://docs.djangoproject.com/en/stable/topics/class-based-views/intro/#decorating-the-class)。
- en: The home page
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主页
- en: 'It''s high time that we created a proper home page for our users instead of
    showing a blank page with some navigation links. Also, it seems very unprofessional
    to show users the **Create New Blog** link when it leads to an error page. Let''s
    fix all these issues by creating a home page view that contains a bit of intelligence.
    We''ll put the code for our home page view in the blog application. Technically
    it can go anywhere, but I personally like to put such views in either the main
    application of the project (the blog in this case) or create a new application
    for such common views. In your `blog/views.py` file, import the `TemplateView`
    generic view `from django.views.generic import TemplateView` and put the following
    code for the view:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候为我们的用户创建一个合适的主页，而不是显示一个空白页面和一些导航链接。此外，当**创建新博客**链接导致错误页面时，向用户显示它似乎非常不专业。让我们通过创建一个包含一些智能的主页视图来解决所有这些问题。我们将在博客应用程序中放置我们的主页视图的代码。从技术上讲，它可以放在任何地方，但我个人喜欢将这样的视图放在项目的主要应用程序（在这种情况下是博客）或创建一个新的应用程序来放置这样的常见视图。在您的`blog/views.py`文件中，从`django.views.generic`中导入`TemplateView`通用视图，并放入以下视图的代码：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Tie this new view to the home page URL by importing it in `blueblog/urls.py`
    using `from blog.views import HomeView` and changing the existing root URL config
    from `url(r'^$', TemplateView.as_view(template_name='base.html'), name='home'),`
    to `url(r'^$', HomeView.as_view(), name='home'),`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在`blueblog/urls.py`中导入它`from blog.views import HomeView`，并将现有的根URL配置从`url(r'^$',
    TemplateView.as_view(template_name='base.html'), name='home'),`更改为`url(r'^$',
    HomeView.as_view(), name='home'),`，将此新视图绑定到主页URL。
- en: Since the `TemplateView` class is no longer required, you can remove it from
    the imports. You should already have a good idea of what we're doing here. The
    only new thing is the `TemplateView` and it's `get_context_data` method. The `TemplateView`
    is another one of Djangos built-in generic views. We configure it by providing
    a template file name and the view renders that template by passing it the dictionary
    returned by our `get_context_data` function as the context. Here, we are setting
    the `has_blog` context variable to `True` if the user has an existing blog associated
    with his account.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不再需要`TemplateView`类，您可以从导入中将其删除。您应该已经对我们在这里做什么有了一个很好的想法。唯一新的东西是`TemplateView`及其`get_context_data`方法。`TemplateView`是Django内置的另一个通用视图。我们通过提供模板文件名来配置它，并且视图通过将我们的`get_context_data`函数返回的字典作为上下文传递给模板来呈现该模板。在这里，如果用户有与其帐户关联的现有博客，我们将`has_blog`上下文变量设置为`True`。
- en: 'With our view done, we''ll need to make a few changes to our `base.html` template
    and add a new `home.html` template. For the `base.html` template, change the code
    in the header block to match:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点已经完成，我们需要对`base.html`模板进行一些更改，并添加一个新的`home.html`模板。对于`base.html`模板，更改头部块中的代码以匹配：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We''ve removed the **Create New Blog** link and replaced it with another block
    called `logged_in_nav`. The idea is that each page that inherits from the base
    template can add navigation links here to be shown to a logged in user. Finally,
    create a new file called `blog/templates/home.html` and add the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了**创建新博客**链接，并用另一个名为`logged_in_nav`的块进行了替换。这个想法是每个从基本模板继承的页面都可以在这里添加导航链接，以显示给已登录的用户。最后，创建一个名为`blog/templates/home.html`的新文件，并添加以下代码：
- en: '[PRE35]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Just like we discussed, the home page template overrides the `logged_in_nav`
    block to add a link to create a new blog if the user doesn't have an existing
    blog, or to edit the settings for the existing blog. You can test that all of
    our changes work by visiting the home page with a user that has a blog already
    created, and a new user without a blog. You'll see that link to create a new blog
    only shows up if the user hasn't already created one.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们讨论的那样，主页模板覆盖了`logged_in_nav`块，以添加一个链接来创建一个新的博客（如果用户没有现有的博客），或者编辑现有博客的设置。您可以通过访问主页来测试我们所有的更改，看看已经创建了博客的用户和没有博客的新用户。您会看到只有在用户还没有创建博客时，才会显示创建新博客的链接。
- en: Next, let's work on the settings view.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理设置视图。
- en: The blog settings view
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 博客设置视图
- en: 'Put the code for the view in `blog/views.py`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 将视图的代码放在`blog/views.py`中：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'You''ll need to import `UpdateView` from `django.views.generic`. Also, update
    the `get_context_data` method of the `HomeView` in the same file to match this
    one:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要从`django.views.generic`中导入`UpdateView`。还要更新同一文件中`HomeView`的`get_context_data`方法，使其与此匹配。
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Change the `blog/templates/blog_settings.html` to look like the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 将`blog/templates/blog_settings.html`更改为以下内容：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The only change we've done is to remove the URL we defined explicitly in the
    form action before. This way, the form will always submit to whatever URL it is
    served from. This is important as we'll see later.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们唯一做的改变是删除了之前在表单动作中明确定义的URL。这样，表单将始终提交到提供它的URL。这一点很重要，我们以后会看到。
- en: 'Update `blog/templates/home.html` as shown in the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下代码更新`blog/templates/home.html`：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Finally, import the `UpdateBlogView` in `blueblog/urls.py` and add the following
    to the `urlpatterns`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`blueblog/urls.py`中导入`UpdateBlogView`，并将以下内容添加到`urlpatterns`。
- en: '[PRE40]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it. Visit the home page with the user you used to create the blog in
    the last section and this time you'll see a link to edit your blog instead of
    creating a new one. The interesting thing to look at here in the `UpdateView`
    subclass; `UpdateBlogView`. We only defined the form class, the template name,
    the success URL and the model to get a complete working update view. With these
    things configured, and our URLs set up so that the primary key of the object we
    want to edit is passed to our view as the keyword argument named `pk`, the `UpdateView`
    displays a form tied to the instance of the model we want to edit. In the home
    view, we add the users blog to the context and use it in the home template to
    generate a URL for the update view.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。使用您在上一节中用来创建博客的用户访问主页，这次您会看到一个链接来编辑您的博客，而不是创建一个新的。在这里要看的有趣的地方是`UpdateView`子类；`UpdateBlogView`。我们只定义了表单类、模板名称、成功的URL和模型，就得到了一个完整的可工作的更新视图。通过配置这些东西，并且我们的URL设置使得我们要编辑的对象的主键作为关键字参数`pk`传递给我们的视图，`UpdateView`会显示一个与我们要编辑的模型实例相关联的表单。在主页视图中，我们将用户的博客添加到上下文中，并在主页模板中使用它来生成一个用于更新视图的URL。
- en: In the form, we needed to change the action attribute of the form so that on
    submit, it posted to the current page. Since we use the same template in both
    the create and update views, we need the form to submit to whatever URL it is
    rendered from. As you'll see in the upcoming projects as well, it is a common
    practice in Django to use the same template with similar views. And the way Django
    generic views are structured makes it easier to do.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中，我们需要更改表单的动作属性，以便在提交时，它会发布到当前页面。由于我们在创建和更新视图中使用相同的模板，我们需要表单提交到渲染自身的任何URL。正如您将在即将到来的项目中看到的那样，在Django中使用相同模板与类似视图是一种常见的做法。而Django通用视图的结构使这更容易实现。
- en: Creating and editing blog posts
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和编辑博客文章
- en: 'Let''s create the views that users can use to create and edit blog posts. Let''s
    start with creating a new blog post. We already created the model earlier, so
    let''s start with the form and template we''ll use. In `blog/forms.py`, create
    this form:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建用户可以使用来创建和编辑博客文章的视图。让我们从创建新博客文章开始。我们之前已经创建了模型，所以让我们从我们将使用的表单和模板开始。在`blog/forms.py`中，创建这个表单：
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'You''ll need to import the `BlogPost` model as well. For the template, create
    a new file `blog/templates/blog_post.html`, and add the following content:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要导入`BlogPost`模型。对于模板，创建一个名为`blog/templates/blog_post.html`的新文件，并添加以下内容：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In `blog/views.py`, import the `BlogPostForm` and `BlogPost` model and then
    create the `NewBlogPostView`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog/views.py`中，导入`BlogPostForm`和`BlogPost`模型，然后创建`NewBlogPostView`：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `blueblog/urls.py`, import the preceding view and add the following URL
    pattern:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blueblog/urls.py`中，导入前面的视图，并添加以下URL模式：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And finally, change the homepage template `blog/template/home.html` to link
    to our new page:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将主页模板`blog/template/home.html`更改为链接到我们的新页面：
- en: '[PRE45]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: All of this code should be pretty familiar to you by now. We've used model forms
    and generic views to get the functionality we need, and all we needed to do was
    configure some stuff. We haven't written one line of code to create the relevant
    form fields, validate the user input, and to handle the various error and success
    scenarios.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有这些代码对你来说应该都很熟悉。我们使用了模型表单和通用视图来获得我们需要的功能，而我们需要做的只是配置一些东西。我们没有写一行代码来创建相关的表单字段，验证用户输入，并处理各种错误和成功的情况。
- en: You can test out our new view by using the **Create New Blog Post** link in
    the navigation on the home page.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在主页上导航中使用**创建新博客文章**链接来测试我们的新视图。
- en: Editing blog posts
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑博客文章
- en: 'As we did before with the `Blog` model, we''ll create an edit view for the
    blog post using the same template as the create view. But first, we need to add
    a way for the user to see his blog posts with links to the edit page. To keep
    things simple, let''s add this list to our home page view. In the **HomeView**,
    edit the `get_context_data` method to match the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前对`Blog`模型所做的一样，我们将使用相同的模板为博客文章创建一个编辑视图。但首先，我们需要为用户添加一种查看他的博客文章并链接到编辑页面的方式。为了保持简单，让我们将此列表添加到我们的主页视图中。在**HomeView**中，编辑`get_context_data`方法以匹配以下内容：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At the end of `blog/templates/home.html;` after the `logged_in_nav` block ends,
    add the following code to override the content block and show the blog posts:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blog/templates/home.html`的末尾，在`logged_in_nav`块结束后，添加以下代码来覆盖内容块并显示博客文章：
- en: '[PRE47]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If you visit the home page now, you''ll see a list of posts that the user has
    made. Let''s create the functionality to edit the posts. Create the following
    view in `blog/views.py`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在访问主页，您将看到用户发布的帖子列表。让我们创建编辑帖子的功能。在`blog/views.py`中创建以下视图：
- en: '[PRE48]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Import this view into your `blueblog/urls.py` file and add the following pattern:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将此视图导入到您的`blueblog/urls.py`文件中，并添加以下模式：
- en: '[PRE49]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Edit the list of blog posts we created earlier in the home page template to
    add the URL for editing a post:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑我们之前在主页模板中创建的博客文章列表，以添加编辑帖子的URL：
- en: '[PRE50]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If you open the home page now, you''ll see that you can click on the **Edit
    Post** link and that it takes you to the editing page for the blog post. One last
    thing we need to fix is the title of the edit blog post page. You may have noticed
    that even when editing, the title said **Create New Blog Post**. In order to fix
    this, replace the `h1` tag inside `blog/templates/blog_post.html` with the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在打开主页，您会看到可以单击**编辑帖子**链接，并且它会带您到博客文章的编辑页面。我们需要修复的最后一件事是编辑博客文章页面的标题。您可能已经注意到，即使在编辑时，标题也会显示**创建新博客文章**。为了解决这个问题，请将`blog/templates/blog_post.html`中的`h1`标签替换为以下内容：
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The context passed to the template by the `UpdateView` includes a variable called
    `object`. This is the instance that the user is currently editing. We check for
    the existence of this variable in the template. If we find it, we know that we're
    editing an existing blog post. If not, we know it's a new blog post being created.
    We detect this and set the title accordingly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateView`通过模板传递给模板的上下文包括一个名为`object`的变量。这是用户当前正在编辑的实例。我们在模板中检查此变量的存在。如果找到它，我们知道正在编辑现有的博客文章。如果没有，我们知道正在创建新的博客文章。我们检测到这一点并相应地设置标题。'
- en: Viewing blog posts
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看博客文章
- en: 'To add a view to show blog posts, add the following view class to `blog/views.py`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加一个显示博客文章的视图，请在`blog/views.py`中添加以下视图类：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Remember to import `DetailView` generic view from `django.views.generic`. Next,
    create the `blog/templates/blog_post_details.html` template with the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 记得从`django.views.generic`中导入`DetailView`通用视图。接下来，使用以下代码创建`blog/templates/blog_post_details.html`模板：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Import the details view and add the following URL pattern to the `urls.py`
    file:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 导入详细视图，并将以下URL模式添加到`urls.py`文件中：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, change the list of blog posts in the home page template to link to
    the post details page from the post title:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在主页模板中更改博客文章列表，以从帖子标题链接到帖子详细页面：
- en: '[PRE55]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: On the home page, the blog post titles should now link to the details page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在主页上，博客文章标题现在应该链接到详细页面。
- en: Multiple users
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个用户
- en: Until now, we've only been playing with a single user account and making our
    site work for that one user. Let's get to the exciting part and add sharing posts
    to other users blogs. However, once multiple users get added to the mix, there
    is one thing we should look at before moving forward.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只使用了一个用户账户，并使我们的网站适用于该用户。让我们进入令人兴奋的部分，并将帖子分享到其他用户的博客中。但是，一旦多个用户加入到混合中，我们在继续之前应该看一下一件事。
- en: Security
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: To demonstrate the complete lack of security in our application, let's create
    a new user account. Log out using the header link and register a new account.
    Next, log in with that user. You should end up on the home page and should not
    see any blog posts in the list.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示我们应用程序中完全缺乏安全性，让我们创建一个新的用户账户。使用页眉链接注销并注册一个新账户。接下来，用该用户登录。您应该会进入主页，并且在列表中不应该看到任何博客文章。
- en: Now, type in the URL `http://127.0.0.1:8000/blog/post/1/update/`. You should
    see the blog post we created from our first user in the edit view. Change either
    the title or the body of the blog post and click save. You are redirected back
    to the home page and it appears that the save has succeeded. Log in back to the
    first account and you'll see that the title of the blog post has been updated.
    This is a serious security breach and must be fixed, otherwise, any user can edit
    the blog posts for any other user without any restrictions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在URL`http://127.0.0.1:8000/blog/post/1/update/`中输入。您应该会在编辑视图中看到我们从第一个用户创建的博客文章。更改博客文章的标题或正文，然后单击保存。您将被重定向回主页，并且似乎保存成功了。重新登录到第一个账户，您会看到博客文章的标题已更新。这是一个严重的安全漏洞，必须修复，否则任何用户都可以无限制地编辑其他用户的博客文章。
- en: 'The simple way in which we are able to solve this problem again demonstrates
    the power and simplicity of the Django framework. Add the following method to
    the `UpdateBlogPostView` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次解决这个问题的简单方式展示了Django框架的强大和简单。将以下方法添加到`UpdateBlogPostView`类中：
- en: '[PRE56]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That's it! Try opening `http://127.0.0.1:8000/blog/post/1/update/` again. This
    time instead of allowing you to edit the blog post of another user, you see a
    404 page.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！再次尝试打开`http://127.0.0.1:8000/blog/post/1/update/`。这次，您不会再看到允许您编辑另一个用户的博客文章，而是会看到一个404页面。
- en: 'What this small piece of code does can be understood after looking at how the
    `UpdateView` generic view works. The generic view calls a number of small methods,
    each of which does a specific job. Here''s a list of some of the methods that
    are defined by the `UpdateView` class:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`UpdateView`通用视图的工作方式后，可以理解这小段代码的作用。通用视图调用许多小方法，每个方法都有特定的工作。以下是`UpdateView`类定义的一些方法的列表：
- en: '`get_object`'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_object`'
- en: '`get_queryset`'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_queryset`'
- en: '`get_context_object_name`'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_context_object_name`'
- en: '`get_context_data`'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_context_data`'
- en: '`get_slug_field`'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get_slug_field`'
- en: The thing about having small methods like these is that in order to change the
    functionality of subclasses, we can override only one of these and fulfill our
    purpose, like we've done here. Read the Django documentation to figure out what
    these and many of the other methods used by the generic views do.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些小方法的好处是，为了改变子类的功能，我们可以只覆盖其中一个并实现我们的目的，就像我们在这里所做的那样。阅读Django文档，了解通用视图使用的这些方法和许多其他方法的作用。
- en: For our case, the `get_queryset` method, as the name suggests, gets the queryset
    within which the object to edit is searched for. We get the default `queryset`
    from the super method (which just returns a `self.model.objects.all()`) and return
    a version further filtered to only include blog posts owned by the currently logged
    in user. You should be familiar with relationship filters. If these are new to
    you, read the Django tutorial to familiarize yourself with the basics of filtering
    model querysets.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的情况，`get_queryset`方法，正如其名称所示，获取在其中搜索要编辑的对象的查询集。我们从超级方法中获取默认的`queryset`（它只返回`self.model.objects.all()`），并返回一个进一步过滤的版本，只包括当前登录用户拥有的博客文章。您应该熟悉关系过滤器。如果这些对您来说是新的，请阅读Django教程，熟悉模型查询集过滤的基础知识。
- en: The reason you now see a 404 if you try to access someone else's blog post is
    that when the `CreateView` tries to get the object to edit, it receives a queryset
    that only includes blog posts owned by the currently logged in user. Since we're
    trying to edit someone else's blog post, it's not included in that queryset. Not
    finding the object to edit, the `CreateView` returns a 404.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您尝试访问其他人的博客文章，您会看到404的原因是，当`CreateView`尝试获取要编辑的对象时，它收到的查询集只包括当前登录用户拥有的博客文章。由于我们试图编辑其他人的博客文章，它不包括在该查询集中。找不到要编辑的对象，`CreateView`返回404。
- en: Sharing blog post
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分享博客文章
- en: The blog post sharing feature allows users to select the blog of another user
    they would like to share their blog posts with. This would allow users to gain
    more readers by sharing their content on the blogs of more popular writers, and
    readers would get to read more relevant content in one place instead of needing
    to discover more blogs.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 博客文章分享功能允许用户选择要与其博客文章分享的另一个用户的博客。这将允许用户通过在更受欢迎的作家的博客上分享其内容来获得更多读者，读者将能够在一个地方阅读更相关的内容，而不需要发现更多的博客。
- en: 'The first step in making sharing possible is to add a field on the `BlogPost`
    model to indicate which blogs the post is shared with. Add this field to the `BlogPost`
    model in `blog/models.py`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使分享成为可能的第一步是在`BlogPost`模型上添加一个字段，指示帖子与哪些博客共享。将此字段添加到`blog/models.py`中的`BlogPost`模型：
- en: '[PRE57]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We are simply adding a basic Django many to many relationship field. If you'd
    like to review your knowledge of the features a many to many field provides, I
    advice you take a look at the Django tutorial again, specifically, the part that
    deals with M2M relationships.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是添加了一个基本的Django多对多关系字段。如果您想复习一下多对多字段提供的功能，我建议您再次查看Django教程，特别是处理M2M关系的部分。
- en: One thing to note about the new field is that we had to specify `related_name`
    explicitly. As you might know, whenever you associate a model with another using
    any relationship field (`ForeignKey`, `OneToMany`, `ManyToMany`) Django automatically
    adds an attribute to the other model that allows easy access to the linked model.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 关于新字段需要注意的一点是，我们必须明确指定`related_name`。您可能知道，每当您使用任何关系字段（`ForeignKey`，`OneToMany`，`ManyToMany`）将一个模型与另一个模型关联时，Django会自动向另一个模型添加一个属性，以便轻松访问链接的模型。
- en: Before we added the `shared_to` field, the `BlogPost` model already had a `ForeignKey`
    pointed at the `Blog` model. If you looked at the attributes available on the
    `Blog` model (using the shell), you would have found a `blogpost_set` attribute,
    which was a manager object that allowed access to `BlogPost` models that referenced
    that `Blog`. If we try to add the `ManyToMany` field without a `related_name`,
    Django would complain because the new relationship would also try to add a reverse
    relationship, also called `blogpost_set`. Because of this we need to give the
    reverse relationship another name.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加`shared_to`字段之前，`BlogPost`模型已经有一个指向`Blog`模型的`ForeignKey`。如果您查看了`Blog`模型上可用的属性（使用shell），您会发现一个`blogpost_set`属性，这是一个管理器对象，允许访问引用该`Blog`的`BlogPost`模型。如果我们尝试添加`ManyToMany`字段而没有`related_name`，Django会抱怨，因为新的关系还会尝试添加一个反向关系，也称为`blogpost_set`。因此，我们需要给反向关系取另一个名字。
- en: After defining the M2M relationship, you can now access blog posts shared with
    a blog model by using the `shared_posts` attributes `all()` method on the `Blog`
    model. We'll see an example of that later.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了M2M关系后，您现在可以通过在`Blog`模型上使用`shared_posts`属性的`all()`方法来访问与博客模型共享的博客文章。稍后我们将看到一个例子。
- en: 'After defining the new field, run the following commands to migrate your DB
    to create the new relationship:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新字段后，运行以下命令迁移您的数据库以创建新的关系：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, let''s create the view that allows the user to select a blog to share
    their post with. **Add** this to `blog/views.py`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个视图，允许用户选择要与其博客文章分享的博客。**将**此添加到`blog/views.py`：
- en: '[PRE59]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This view is a subclass of the template view. You should have a pretty good
    idea of how it works by now. The important bit to look at here is the code inside
    the `get_context_data` method. First, we get the blog post object using the `id`
    passed in the keyword arguments gathered from the parsed URL pattern. Next, we
    get a list of all blog objects this post has been shared with. We do this because
    we don't want to confuse the user by allowing sharing to a blog that the post
    is already shared with.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图是模板视图的子类。到目前为止，您应该对它的工作原理有一个很好的了解。这里要看的重要部分是`get_context_data`方法内的代码。首先，我们使用从解析的URL模式中收集的关键字参数中传递的`id`获取博客文章对象。接下来，我们获取此帖子已经与之共享的所有博客对象的列表。我们这样做是因为我们不希望混淆用户，允许他们分享已经与之共享的博客的帖子。
- en: The next line of code uses the Python built-in `map` method on the queryset
    of the blogs the post is shared with. `map` is one of the most useful methods
    when working with any kind of lists (or list-like objects) in Python. It takes
    as it's first argument a function that takes a single argument and returns one
    argument, and a list as it's second argument. `map` then calls the given function
    on each element in the input list and gathers the results in a final list that
    is returned. Here, we use a `lambda` to extract the ID of the blog objects that
    this post is already shared with.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码使用Python内置的`map`方法处理帖子共享的博客的查询集。`map`是在Python中处理任何类型的列表（或类似列表的对象）时最有用的方法之一。它的第一个参数是一个接受一个参数并返回一个参数的函数，第二个参数是一个列表。然后，`map`在输入列表中的每个元素上调用给定的函数，并收集结果到最终返回的列表中。在这里，我们使用`lambda`来提取此帖子已经共享的博客对象的ID。
- en: 'Finally, we can get the list of blog objects that this post can be shared with.
    We use the `exclude` method to not include the blog objects the post is already
    shared with. We pass this to the template in the context. Next, let''s take a
    look at the template that you need to create in `blog/templates/share_blog_post.html`:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以获取可以与此帖子共享的博客对象列表。我们使用`exclude`方法来排除已经共享帖子的博客对象。我们将这些传递给模板上下文。接下来，让我们看看您需要在`blog/templates/share_blog_post.html`中创建的模板：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'There''s nothing special in this template. Let''s move on to the two URLs and
    views that this refers to, since without those we can''t render this template.
    First, let''s look at `SharepostWithBlog`, which you need to create in `blog/views.py`.
    You will need to add this import line to the top of the file as well:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板中没有什么特别的。让我们继续讨论这些模板所指的两个URL和视图，因为没有这些，我们无法呈现这个模板。首先，让我们看看`SharepostWithBlog`，您需要在`blog/views.py`中创建它。您还需要在文件顶部添加此导入行：
- en: '[PRE61]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The code for the view is this:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的代码如下：
- en: '[PRE62]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Import this into `blueblog/urls.py` and add it with the following URL pattern:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将其导入到`blueblog/urls.py`中，并使用以下URL模式添加它：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Unlike all our previous views, this view doesn't fit nicely into any of the
    generic views that Django provides. But Django has a base generic view that makes
    our life easier than creating a function that handles the request.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们以前的所有视图不同，这个视图不太适合Django提供的任何通用视图中。但是Django有一个基本的通用视图，使我们的生活比创建处理请求的函数更容易。
- en: The `View` generic view is used whenever you need something completely custom
    to handle a request. Like all generic views, it has a dispatch method that you
    can override to intercept a request before any further processing is done. Here,
    we make sure that the user is logged in before allowing them to proceed.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要完全自定义处理请求时，可以使用`View`通用视图。与所有通用视图一样，它具有一个`dispatch`方法，您可以重写以在进一步处理请求之前拦截请求。在这里，我们确保用户在允许他们继续之前已登录。
- en: In a `View` subclass, you create methods with the same name as the request types
    you want to handle. Here, we create a `get` method as we only care about handling
    `GET` requests. The `View` class takes care of calling our method when the correct
    request method is used by the client. In our get method, we're doing a basic check
    to see if the user owns the blog post. If they do, we add the blog to the `shared_to
    ManyToMany` relationship of the `BlogPost` model.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在`View`子类中，您创建与您想要处理的请求类型相同名称的方法。在这里，我们创建一个`get`方法，因为我们只关心处理`GET`请求。`View`类负责在客户端使用正确的请求方法时调用我们的方法。在我们的get方法中，我们正在进行基本检查，以查看用户是否拥有博客帖子。如果是，我们将博客添加到`BlogPost`模型的`shared_to
    ManyToMany`关系中。
- en: 'The last view we need to create is one to allow the user to remove a blog post
    they have already shared. The code for that is shown here:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一个视图是允许用户删除他们已经共享的博客帖子。该视图的代码如下所示：
- en: '[PRE64]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Like the `SharePostWithBlog` view, this one subclasses the `View` generic view.
    The code is almost exactly the same as the previous view. The only difference
    is that in the previous view we used `blog_post.shared_to.add`, whereas in this
    view we use the `blog_post.shared_to.remove` method.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与`SharePostWithBlog`视图一样，这个视图是`View`通用视图的子类。代码几乎与先前的视图完全相同。唯一的区别是在先前的视图中，我们使用了`blog_post.shared_to.add`，而在这个视图中，我们使用了`blog_post.shared_to.remove`方法。
- en: 'Finally, import these two views into `blueblog/urls.py` and add the following
    patterns:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将这两个视图导入到`blueblog/urls.py`中，并添加以下模式：
- en: '[PRE65]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In order to show a link to the share this post page, edit the `home.html` template
    to change the entire code inside the `content` block to this:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在首页显示一个链接到分享此帖子页面，编辑`home.html`模板，将`content`块内的整个代码更改为以下内容：
- en: '[PRE66]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: And that's it. Now when you visit the home page, each blog post should have
    a **Share Post** link next to it. When you click it, you'll see a second page
    with links to share the blog post on other user blogs. Clicking the link should
    share your post and also show a corresponding remove link on the same page. Of
    course, in order to test this, you should create a second user account and add
    a blog using that account.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在当您访问主页时，每篇博客帖子旁边应该有一个**分享帖子**链接。单击它后，您将看到第二个页面，其中包含在其他用户博客上分享博客帖子的链接。单击该链接应该分享您的帖子，并在同一页面上显示相应的删除链接。当然，为了测试这一点，您应该创建第二个用户帐户，并使用该帐户添加一个博客。
- en: 'One last thing we should do is modify the `get_context_data` method of the
    **HomeView** to also include shared posts in the blog post list:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该做的最后一件事是修改**HomeView**的`get_context_data`方法，以便在博客帖子列表中也包括共享的帖子：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Add this to the bottom of the `content` block inside the `blog/templates/home.html`
    template:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将其添加到`blog/templates/home.html`模板的`content`块的底部：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'And that''s it, our first application is complete! If you open the home page
    now, you should see a **Share Post** link next to each blog post. Clicking this
    should open up another page where you can select which blog to share this post
    with. To test it you should create another blog with the other account we created
    earlier when we were looking at the security of our application. Once you have
    another blog configured, your share blog post page should look similar to this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们的第一个应用程序已经完成了！如果你现在打开主页，你应该会看到每篇博客文章旁边有一个**分享帖子**链接。点击这个链接应该会打开另一个页面，你可以在那里选择与哪个博客分享这篇文章。为了测试它，你应该使用我们之前创建的另一个账户创建另一个博客，当时我们正在查看我们应用程序的安全性。一旦你配置了另一个博客，你的分享博客文章页面应该看起来类似于这样：
- en: '![Sharing blog post](img/00698_01_03.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![分享博客文章](img/00698_01_03.jpg)'
- en: Clicking the title of the other blog should share the post and take you back
    to the home page. If you click the **Share Post** link again on the same post,
    you should now see a heading saying **Stop sharing with**, and the name of the
    blog you shared this post with.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 点击另一个博客的标题应该会分享这篇文章并带你回到主页。如果你再次点击同一篇文章的**分享帖子**链接，你现在应该会看到一个标题，上面写着**停止与...分享**，以及你与之分享这篇文章的博客的名称。
- en: If you log in to the other account now, you should see that the post is now
    shared there, and is listed under the **Shared Blog Posts** section.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在登录另一个账户，你应该会看到这篇文章现在已经分享到那里，并列在**分享的博客文章**部分下面。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we''ve seen how to start our application and set it up properly
    so that we can develop things rapidly. We''ve looked at using template inheritance
    to achieve code reuse and give our site common elements such as navigation bars.
    Here''s a list of topics we have covered so far:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何启动我们的应用程序并正确设置它，以便我们可以快速开发东西。我们研究了使用模板继承来实现代码重用，并为我们的网站提供导航栏等共同元素。以下是我们迄今为止涵盖的主题列表：
- en: Basic project layout and setup with sqlite3 database
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用sqlite3数据库的基本项目布局和设置
- en: Simple Django form and model form usage
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的Django表单和模型表单用法
- en: Django contrib apps
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django贡献应用程序
- en: Using `django.contrib.auth` to add user registration and authentication to an
    application
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`django.contrib.auth`为应用程序添加用户注册和身份验证
- en: Template inheritance
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板继承
- en: Generic views for editing and displaying database objects
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于编辑和显示数据库对象的通用视图
- en: Database migrations
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库迁移
- en: We'll use the lessons we've learned here throughout the rest of the chapters
    in this book.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会在本书的其余章节中运用我们在这里学到的教训。
