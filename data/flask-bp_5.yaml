- en: Chapter 5. Shutterbug, the Photo Stream API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。Shutterbug，照片流API
- en: In this chapter, we will build a (primarily) JSON-based API that allows us to
    view a reverse chronologically ordered list of photos that have been added—this
    has become quite popular in recent years due to Instagram and similar photo sharing
    applications. For the sake of simplicity, we will forgo the usual social aspect
    that many of these applications are typically built around; however, you are encouraged
    to combine the knowledge of the previous chapters with the information in this
    chapter to build such an application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个（主要是）基于JSON的API，允许我们查看按时间顺序倒序排列的已添加照片列表——由于Instagram和类似的照片分享应用程序，这在近年来变得非常流行。为简单起见，我们将放弃许多这些应用程序通常围绕的社交方面；但是，我们鼓励您将前几章的知识与本章的信息相结合，构建这样的应用程序。
- en: Shutterbug, the minimal API-only application that we are about to embark on,
    will allow a user to upload a photograph of their choosing via an authenticated,
    JSON-based API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Shutterbug，我们即将开始的最小API应用程序，将允许用户通过经过身份验证的基于JSON的API上传他们选择的照片。
- en: Additionally, we will use one of the lesser-known features of Flask (Werkzeug,
    really) to create a custom middleware that will allow us to intercept inbound
    requests and modify the global application environment for very simple API versioning.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将使用Flask（实际上是Werkzeug）的较少为人所知的功能之一，创建一个自定义中间件，允许我们拦截传入请求并修改全局应用程序环境，用于非常简单的API版本控制。
- en: Starting off
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'Once more, as we did in the previous chapters, let''s create a completely new
    directory and virtual environment for this application:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 和前几章一样，让我们为这个应用程序创建一个全新的目录和虚拟环境：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the following application layout to start:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下应用程序布局以开始：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application layout presented here is different from the typical Blueprint-based
    structure that we used in previous chapters; we will use the suggested layout
    for typical Flask-RESTful applications, which also suits the simplicity of the
    Shutterbug application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里呈现的应用程序布局与我们在前几章中使用的典型基于Blueprint的结构不同；我们将使用典型Flask-RESTful应用程序建议的布局，这也适合Shutterbug应用程序的简单性。
- en: The application factory
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序工厂
- en: 'We will use the application factory pattern again in this chapter; let''s add
    our skeleton `create_app` method to the `application/__init__.py` module and include
    our Flask-SQLAlchemy database initialization as well:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次使用应用程序工厂模式；让我们将我们的骨架`create_app`方法添加到`application/__init__.py`模块中，并包括我们的Flask-SQLAlchemy数据库初始化：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s include our barebones `run.py`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们包含我们的基本`run.py`：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This should give us the ability to run the application using the built-in Werkzeug
    application server via the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该使我们能够使用内置的Werkzeug应用程序服务器运行应用程序，代码如下：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Interlude – Werkzeug
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插曲——Werkzeug
- en: We've spoken about Werkzeug a few times during the course of this book but we
    haven't really explained what it is, why we use it, or why it's useful. To understand
    Werkzeug, we first need to know why it exists. For this, we will need to understand
    the origins of the Python Web Server Gateway Interface specification, most commonly
    abbreviated as WSGI.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书的过程中已经几次谈到了Werkzeug，但我们并没有真正解释它是什么，为什么我们使用它，或者它为什么有用。要理解Werkzeug，我们首先需要知道它存在的原因。为此，我们需要了解Python
    Web服务器网关接口规范的起源，通常缩写为WSGI。
- en: 'Today, choosing a Python web application framework is a relatively simple matter
    of preference: most developers choose a framework based on a previous experience,
    necessity (for example, one that is designed for an asynchronous request processing
    such as Tornado), or some other quantifiable or unquantifiable criteria.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，选择Python Web应用程序框架相对来说是一个相对简单的偏好问题：大多数开发人员根据以前的经验、必要性（例如，设计为异步请求处理的Tornado）或其他可量化或不可量化的标准选择框架。
- en: Several years ago, however, the choice of an application framework affected
    the web server that you could use. As all Python web application frameworks at
    the time implemented their own HTTP request processing in a slightly different
    manner, they were often only compatible with a subset of web servers. Developers,
    tired of this somewhat inconvenient status quo, put forth a proposal to unify
    the interaction of web servers with Python applications through a common specification,
    WSGI.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，几年前，应用程序框架的选择影响了您可以使用的Web服务器。由于当时所有Python Web应用程序框架以稍微不同的方式实现了它们自己的HTTP请求处理，它们通常只与Web服务器的子集兼容。开发人员厌倦了这种有点不方便的现状，提出了通过一个共同规范WSGI统一Web服务器与Python应用程序的交互的提案。
- en: The WSGI specification, once established, was adopted by all the major frameworks.
    Additionally, several so-called *utility* tools were created; they had the sole
    purpose of bridging the official WSGI specification, which can be somewhat unfriendly
    to work with for new developers, with a more robust intermediate API that aided
    the development of modern web applications. Moreover, these utility libraries
    could then be used as the foundation for more feature-complete and robust application
    frameworks.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了WSGI规范，所有主要框架都采用了它。此外，还创建了一些所谓的*实用*工具；它们的唯一目的是将官方WSGI规范与更健壮的中间API进行桥接，这有助于开发现代Web应用程序。此外，这些实用程序库可以作为更完整和健壮的应用程序框架的基础。
- en: As you may have guessed by now, Werkzeug is one of these WSGI utility libraries.
    When combined with Jinja, the templating language, and some convenient defaults
    for configuration, routing, and other basic web application necessities, we have
    Flask.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可能已经猜到，Werkzeug是这些WSGI实用程序库之一。当与模板语言Jinja和一些方便的默认配置、路由和其他基本Web应用程序必需品结合使用时，我们就有了Flask。
- en: Flask is what we primarily deal with in this book, but a fairly large part of
    the hard work abstracted away from you is contained in Werkzeug. While it largely
    goes unnoticed, it is possible to interact with it directly in order to intercept
    and modify portions of a request before Flask has the chance to process it. We'll
    explore some of these possibilities later on in the chapter when we implement
    a custom Werkzeug middleware for optionally versioning JSON API requests.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Flask是我们在本书中主要处理的内容，但是从Werkzeug中抽象出来的大部分工作都包含在其中。虽然它很大程度上不被注意到，但是可以直接与它交互，以拦截和修改请求的部分，然后Flask有机会处理它。在本章中，当我们为JSON
    API请求实现自定义Werkzeug中间件时，我们将探索其中的一些可能性。
- en: Simple APIs with Flask-RESTful
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Flask-RESTful创建简单的API
- en: One of the great joys of using Flask is the seemingly infinite extensibility
    and composability that it offers. As it's a rather thin layer that sits atop Werkzeug
    and Jinja, it does not impose much on the developer in terms of constraints.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Flask的一个巨大乐趣是它提供了看似无限的可扩展性和可组合性。由于它是一个相当薄的层，位于Werkzeug和Jinja之上，因此在约束方面对开发人员的要求并不多。
- en: 'Due to this flexibility, we have extensions such as Flask-RESTful at our disposal,
    which make creating JSON-based APIs a joy. First, let''s install the package:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种灵活性，我们可以利用Flask-RESTful等扩展，使得创建基于JSON的API变得轻松愉快。首先，让我们安装这个包：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let''s initialize the extension in our application factory in the usual
    fashion:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们以通常的方式在我们的应用工厂中初始化这个扩展：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The primary building block of the Flask-RESTful extension is the concept of
    a resource. A resource is, for all intents and purposes, a `Flask` method view
    with some very useful defaults set for content-type negotiation. If you haven''t
    encountered the concept of a `MethodView` in Flask until now, don''t fret! They''re
    quite straightforward and provide you with a relatively simple interface to separate
    the RESTful resources by allowing you to define methods on a class that maps directly
    to the basic HTTP verbs: `GET`, `PUT`, `POST`, `PATCH`, and `DELETE`. The Flask-RESTful
    resource, in turn, extends the `MethodView` class and thus allows for the same
    style of verb-based route handling.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-RESTful扩展的主要构建块是资源的概念。资源在本质上是一个带有一些非常有用的默认设置的`Flask`方法视图，用于内容类型协商。如果直到现在你还没有遇到过Flask中`MethodView`的概念，不要担心！它们非常简单，并且通过允许您在类上定义方法，直接映射到基本的HTTP动词：`GET`、`PUT`、`POST`、`PATCH`和`DELETE`，为您提供了一个相对简单的接口来分离RESTful资源。Flask-RESTful资源又扩展了`MethodView`类，因此允许使用相同的基于动词的路由处理风格。
- en: 'More concretely, it means that the Flask-RESTful API nouns can be written in
    the following way. We will first add our photo resource view handlers to `application/resources/photos.py`:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，这意味着Flask-RESTful API名词可以以以下方式编写。我们将首先将我们的照片资源视图处理程序添加到`application/resources/photos.py`中：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the preceding two `Resource` subclasses, we defined a subset of the HTTP
    verbs that are possible to handle; we are not required to define handlers for
    all the possible verbs. If, for example, our application were to receive a PATCH
    request to one of the preceding resources, Flask would return an HTTP/1.1 405
    Method Not Allowed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的两个`Resource`子类中，我们定义了可以处理的HTTP动词的一个子集；我们并不需要为所有可能的动词定义处理程序。例如，如果我们的应用程序接收到一个PATCH请求到前面的资源中的一个，Flask会返回HTTP/1.1
    405 Method Not Allowed。
- en: 'Then, we will import these view handlers to our application factory in `application/__init__.py`
    in order to bind these two classes to our Flask-RESTful API object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将这些视图处理程序导入到我们的应用工厂中，在`application/__init__.py`中，以便将这两个类绑定到我们的Flask-RESTful
    API对象：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have bound the resources to the API object before we call `api.init_app(app)`.
    If we initialize before we bind the resources, the routes will not exist on the
    Flask application object.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在调用`api.init_app(app)`之前，我们已经将资源绑定到了API对象。如果我们在绑定资源之前初始化，路由将不存在于Flask应用程序对象上。
- en: We can confirm that the routes we defined are mapped to the application object
    by starting an interactive Python session and checking the `url_map` attribute
    of our Flask application.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过启动交互式Python会话并检查Flask应用程序的`url_map`属性来确认我们定义的路由是否映射到应用程序对象。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Start the session from the parent of the application folder so that the `PYTHONPATH`
    is set correctly:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用程序文件夹的父文件夹开始会话，以便正确设置`PYTHONPATH`：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding output lists a Werkzeug `Map` object, which contains three `Rule`
    objects, each of which lists a URI, the HTTP verbs that are valid against this
    URI, and a normalized identifier (as view handlers can be functions as well as
    `MethodView` subclasses in addition to a few other options) that indicates which
    view handler will be invoked.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出列出了一个Werkzeug `Map`对象，其中包含三个`Rule`对象，每个对象列出了一个URI，对该URI有效的HTTP动词，以及一个标准化标识符（视图处理程序可以是函数，也可以是`MethodView`子类，还有其他几个选项），指示将调用哪个视图处理程序。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Flask will automatically handle the HEAD and OPTIONS verbs for all the defined
    endpoints and also add a default `/static/<filename>` route for the static file
    handling. This default static route can be disabled, if necessary, by setting
    the `static_folder` argument to the `Flask` object initialization in our application
    factory to `None`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Flask将自动处理所有已定义端点的HEAD和OPTIONS动词，并为静态文件处理添加一个默认的`/static/<filename>`路由。如果需要，可以通过在应用程序工厂中对`Flask`对象初始化设置`static_folder`参数为`None`来禁用此默认静态路由：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s do the same thing for our skeleton user view resource handlers, which
    we will declare in `application/resources/users.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对我们的骨架用户视图资源处理程序做同样的事情，我们将在`application/resources/users.py`中声明：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we could have put the `post` method handler on the `SingleUser` resource
    definition but instead, we split it out to its own resource. This is not strictly
    necessary but will make things a bit easier to follow for our application and
    only cost us a few extra lines of code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们本可以将`post`方法处理程序放在`SingleUser`资源定义中，但相反，我们将其拆分为自己的资源。这并非绝对必要，但会使我们的应用程序更容易跟踪，并且只会花费我们额外的几行代码。
- en: 'Similar to what we did with our photo views, we''ll add them to our Flask-RESTful
    API object in our application factory:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在照片视图中所做的类似，我们将把它们添加到我们的Flask-RESTful API对象中的应用工厂中：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Improved password handling with hybrid attributes
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用混合属性改进密码处理
- en: Our `User` model will be quite similar to the one that we used in the previous
    chapter and will use a class attribute `getter`/`setter` for the `password` attribute.
    This will ensure a consistent application of the Bcrypt key derivation function
    to the raw user password regardless of whether we set the value at the time of
    object creation or manually set the attribute of an already created object.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`User`模型将与我们在上一章中使用的模型非常相似，并且将使用类属性`getter`/`setter`来处理`password`属性。这将确保无论我们是在对象创建时设置值还是手动设置已创建对象的属性，都能一致地应用Bcrypt密钥派生函数到原始用户密码。
- en: This consists of using the `hybrid_property` descriptor from SQLAlchemy, which
    allows us to define properties that act differently when accessed at the class-level
    (for example, `User.password`, where we want the SQL expression for the password
    field of the user model to be returned) versus instance-level (for example, `User().password`,
    where we want the actual encrypted password string of a user object to be returned
    instead of the SQL expression).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括使用SQLAlchemy的`hybrid_property`描述符，它允许我们定义在类级别访问时（例如`User.password`，我们希望返回用户模型的密码字段的SQL表达式）与实例级别访问时（例如`User().password`，我们希望返回用户对象的实际加密密码字符串而不是SQL表达式）行为不同的属性。
- en: We will define the password class attribute as `_password`, which will ensure
    that we avoid any nasty attribute/method name collisions, so that we can define
    the hybrid `getter` and `setter` methods correctly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把密码类属性定义为`_password`，这将确保我们避免任何不愉快的属性/方法名称冲突，以便我们可以正确地定义混合的`getter`和`setter`方法。
- en: 'As our application will be relatively simple in terms of data modeling, we
    can use a single module for our models in `application/models.py`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用在数据建模方面相对简单，我们可以在`application/models.py`中使用单个模块来处理我们的模型：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the same module, we can then declare our `Photo` model, which will be charged
    with maintaining all the metadata related to an image but not the image itself:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个模块中，我们可以声明我们的`Photo`模型，它将负责维护与图像相关的所有元数据，但不包括图像本身：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: API authentication
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API身份验证
- en: 'For most applications and APIs, the concepts of authentication and authorization
    are central to nontrivial operations:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序和API，身份验证和授权的概念对于非平凡操作至关重要：
- en: '**Authentication**: This asserts the veracity of the credentials provided and
    also ensures that they belong to a known entity; in simple terms, this means ensuring
    that the username and password provided to an application belong to a valid user.
    Once verified, the application assumes that the requests performed with these
    credentials are being performed on behalf of the given user.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：这断言所提供的凭据的真实性，并确保它们属于已知实体；简单来说，这意味着确保提供给应用程序的用户名和密码属于有效用户。一旦验证，应用程序就会假定使用这些凭据执行的请求是代表给定用户执行的。'
- en: '**Authorization**: These are the permissible actions of an authenticated (or
    unauthenticated) entity in the bounds of the application. In most situations,
    authorization presupposes that a pre-existing authentication step was performed.
    An entity may be authenticated but not authorized to access certain resources:
    if you enter your card and PIN in an ATM (thus authenticating yourself), you can
    view your own accounts, but attempting to view the accounts of another person
    will (hopefully!) result in a refusal as you are not authorized to access that
    information.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：这是经过身份验证的实体在应用程序范围内的可允许操作。在大多数情况下，授权预设了已经进行了预先身份验证步骤。实体可能已经经过身份验证，但没有被授权访问某些资源：如果您在ATM机上输入您的卡和PIN码（因此进行了身份验证），您可以查看自己的账户，但尝试查看另一个人的账户将会（希望！）导致拒绝，因为您没有被授权访问那些信息。'
- en: For Shutterbug, we are only concerned with authentication. If we were to add
    various features that included, say, the ability to create private groups of users
    that have access to a shared pool of photos, then systematized authorization would
    be required to determine which users can access which subsets of resources.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Shutterbug，我们只关心身份验证。如果我们要添加各种功能，比如能够创建可以访问共享照片池的私人用户组，那么就需要系统化的授权来确定哪些用户可以访问哪些资源的子集。
- en: Authentication protocols
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 身份验证协议
- en: 'Many developers will already be familiar with several authentication protocols:
    the usual identifier/password combination that is standard across most web applications
    in existence and OAuth for many modern APIs (for example, Twitter, Facebook, GitHub,
    and others). For our own application, we will use the incredibly simple HTTP Basic
    authentication protocol.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员可能已经熟悉了几种身份验证协议：通常的标识符/密码组合是现有大多数网络应用程序的标准，而OAuth是许多现代API的标准（例如Twitter、Facebook、GitHub等）。对于我们自己的应用程序，我们将使用非常简单的HTTP基本身份验证协议。
- en: While HTTP Basic is not the most flexible nor secure (it provides no encryption
    whatsoever, actually), it is reasonable to implement this protocol for simple
    applications, demos, and prototype APIs. In the early days of Twitter, it was
    actually the only method by which you could authenticate with their API! Moreover,
    when transmitting data over HTTPS, which we should do in any production-level
    environment, we are assured that the plaintext request that includes our user
    identifier and password is encrypted from any malicious third parties that may
    be listening in.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP基本身份验证并不是最灵活也不是最安全的（实际上它根本不提供任何加密），但对于简单的应用程序、演示和原型API来说，实施这种协议是合理的。在Twitter早期，这实际上是您可以使用的唯一方法来验证其API！此外，在通过HTTPS传输数据时，我们应该在任何生产级环境中这样做，我们可以确保包含用户标识和密码的明文请求受到加密，以防止任何可能监听的恶意第三方。
- en: 'The implementation of the HTTP Basic authentication is not overly complex,
    but it''s most definitely something that we can offload to an extension. Let''s
    go ahead and install Flask-HTTPAuth to our environment, which consists of creating
    an instance of the extension:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP基本身份验证的实现并不是过于复杂的，但绝对是我们可以转嫁给扩展的东西。让我们继续将Flask-HTTPAuth安装到我们的环境中，这包括创建扩展的实例：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And set up the extension in our `application/__init__.py`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 并在我们的`application/__init__.py`中设置扩展：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Flask-HTTPAuth includes various decorators to declare handlers/callbacks in
    order to perform parts of the authentication process. We''ll implement the one
    that gives us the most control over how the authentication is performed and put
    this in a new module in `application/authentication.py`. In addition to the verification
    of the credentials, we will attach the SQLAlchemy user object to the Flask context
    local `g` on successful authentication so that we can utilize this data in other
    parts of the request processing and response generation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Flask-HTTPAuth包括各种装饰器来声明处理程序/回调，以执行身份验证过程的各个部分。我们将实现一个可以最大程度控制身份验证方式的处理程序，并将其放在`application/authentication.py`中的新模块中。除了验证凭据外，我们还将在成功验证时将SQLAlchemy用户对象附加到Flask上下文本地`g`，以便我们可以在请求处理和响应生成的其他部分中利用这些数据：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `auth.verify_password` decorator allows us to specify a function that accepts
    a username and password, both of which are extracted out of the Authorization
    header that is sent with the request. We will then use this information to query
    our database for a user with the same username, and upon successfully finding
    one, we will ensure that the provided password hashes to the same value that we
    stored for this user. If the password does not match or the username does not
    exist, we will return False and Flask-HTTPAuth will return a 401 Unauthorized
    header to the requesting client.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth.verify_password`装饰器允许我们指定一个接受用户名和密码的函数，这两者都从发送请求的Authorization头中提取出来。然后，我们将使用这些信息来查询具有相同用户名的用户的数据库，并在成功找到一个用户后，我们将确保提供的密码散列到与我们为该用户存储的相同值。如果密码不匹配或用户名不存在，我们将返回False，Flask-HTTPAuth将向请求客户端返回401未经授权的标头。'
- en: 'Now, to actually use the HTTP Basic authentication, we need to add the `auth.login_required`
    decorator to the view handlers that will require authentication. We know that
    all user operations (except creating a new user) will require an authenticated
    request, so let''s implement this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要实际使用HTTP基本身份验证，我们需要将`auth.login_required`装饰器添加到需要身份验证的视图处理程序中。我们知道除了创建新用户之外，所有用户操作都需要经过身份验证的请求，所以让我们实现这一点：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Due to the fact that the self argument for a method of a Resource object refers
    to the Resource instance and not the method, we cannot use regular view decorators
    on the individual methods of the view. Rather, we must use the `method_decorators`
    class attribute, which will apply the declared functions (in order!) to the view
    method that has been invoked to handle the request.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Resource对象的方法的self参数指的是Resource实例而不是方法，我们不能在视图的各个方法上使用常规视图装饰器。相反，我们必须使用`method_decorators`类属性，它将按顺序应用已声明的函数到已调用的视图方法上，以处理请求。
- en: Getting users
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户
- en: 'Now that we''ve figured out the authentication portion of the application,
    let''s implement the API endpoints to create a new user and fetch the existing
    user data. We can flesh out the `get()` method of the `SingleUser` resource class
    as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经弄清楚了应用程序的身份验证部分，让我们实现API端点以创建新用户和获取现有用户数据。我们可以如下完善`SingleUser`资源类的`get()`方法：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There are quite a few new things happening in the preceding method, so let''s
    deconstruct it. First, we will check that the `user_id` specified in the request
    (for example, `GET /users/1`) is the same as the currently authenticated user:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中发生了很多新的事情，让我们来分解一下。首先，我们将检查请求中指定的`user_id`（例如，`GET /users/1`）是否与当前经过身份验证的用户相同：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While this may seem redundant at the moment, it plays a dual role in allowing
    simpler future modifications to the authorization scheme in addition to adhering
    to a somewhat more RESTful approach. Here, a resource is uniquely specified by
    its URI, which is constructed in part by the unique primary key identifier of
    a user object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然目前这可能看起来有些多余，但它在允许将来更简单地修改授权方案的同时，还扮演了遵循更符合RESTful方法的双重角色。在这里，资源是由其URI唯一指定的，部分由用户对象的唯一主键标识符构成。
- en: 'After the authorization check, we will pull the relevant user out of the database
    by querying it via the `user_id` parameter passed as a named URI parameter:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 经过授权检查后，我们将通过查询传递为命名URI参数的`user_id`参数，从数据库中提取相关用户：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If no such user is found, then we will abort the current request with an HTTP
    404 Not Found and specify a message in order to make the reason for the non-20x
    response more clear.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到这样的用户，那么我们将使用HTTP 404 Not Found中止当前请求，并指定消息以使非20x响应的原因更清晰。
- en: 'Finally, we will construct a dictionary of the user data that we want to return
    as a response. We clearly don''t want to return the hashed password or other sensitive
    information, so we will explicitly specify which fields we want to be serialized
    in the response:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将构建一个用户数据的字典，作为响应返回。我们显然不希望返回散列密码或其他敏感信息，因此我们将明确指定我们希望在响应中序列化的字段：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Thanks to Flask-RESTful, we do not need to explicitly convert our dictionary
    to a JSON string: The response representation is `application/json` by default.
    There''s one small catch, however: the JSON encoder that Flask-RESTful uses as
    a default does not know how to convert Python `datetime` objects to their RFC822
    string representations. This can be fixed by specifying the `application/json`
    MIME type representation handler and ensuring that we use the `flask.json` encoder
    instead of the default `json` module from the Python standard library.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Flask-RESTful，我们不需要显式地将我们的字典转换为JSON字符串：响应表示默认为`application/json`。然而，有一个小问题：Flask-RESTful使用的默认JSON编码器不知道如何将Python
    `datetime`对象转换为它们的RFC822字符串表示。这可以通过指定`application/json` MIME类型表示处理程序并确保我们使用`flask.json`编码器而不是Python标准库中的默认`json`模块来解决。
- en: 'We can add the following to our `application/__init__.py` module:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`application/__init__.py`模块中添加以下内容：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Creating new users
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新用户
- en: 'The analog to fetch the existing users from the API is, of course, to create
    new users. While typical web applications do this with a signup process that has
    you fill out various form fields, creating a new user via our API requires that
    the information be submitted to the server via a POST request, validated, and
    then a new user is inserted in the database. The implementation of these steps
    should be put in the `post()` method of our `CreateUser` resource:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从API中获取现有用户的类比当然是创建新用户。而典型的Web应用程序通过填写各种表单字段来完成这一过程，通过我们的API创建新用户需要将信息通过POST请求提交到服务器进行验证，然后将新用户插入数据库。这些步骤的实现应该放在我们的`CreateUser`资源的`post()`方法中：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `request.json` file is populated with the POST data if, and only if, the
    content-type of the request is set to `application/json`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求的内容类型设置为`application/json`，则`request.json`文件将填充POST数据。
- en: 'There''s nothing too surprising in the preceding method implementation: we
    fetched the POST data from `request.json`, created a `User` object (Very insecurely!
    You can see a bit later on in this chapter for a better alternative.) from it,
    attempted to add it to the database and catch the exception raised if a user of
    the same username or e-mail address already exists, and then serialized an HTTP
    201 Created response with a `Location` header that includes the URI of the newly
    created user.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法实现中没有什么太意外的：我们从`request.json`中获取了POST数据，创建了一个`User`对象（非常不安全！您可以在本章稍后看到更好的替代方法），尝试将其添加到数据库中并捕获异常，如果同一用户名或电子邮件地址的用户已经存在，然后序列化一个HTTP
    201 Created响应，其中包含新创建用户的URI的`Location`头。
- en: Input validation
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 输入验证
- en: While Flask includes a relatively simple way of accessing the POST'ed data via
    the `flask.request` proxy object, it does not contain any functionality to validate
    that the data is formatted as we expect it to be. This is okay! Flask attempts
    to be as agnostic as possible with regards to the data storage and manipulation,
    leaving this to the developer. Luckily for us, Flask-RESTful includes the `reqparse`
    module that can be used for the data validation and its usage is very similar
    in spirit to the popular `argparse` library used for CLI argument parsing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Flask包含一个相对简单的方式来通过`flask.request`代理对象访问POST的数据，但它不包含任何功能来验证数据是否按我们期望的格式进行格式化。这没关系！Flask试图尽可能地与数据存储和操作无关，将这些工作留给开发人员。幸运的是，Flask-RESTful包括`reqparse`模块，可以用于数据验证，其使用在精神上与用于CLI参数解析的流行`argparse`库非常相似。
- en: 'We will set up our new user data parser/validator in our `application/resources/users.py`
    module and declare our fields and their types and whether they are required in
    the POST data to be considered as valid requests or not:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`application/resources/users.py`模块中设置我们的新用户数据解析器/验证器，并声明我们的字段及其类型以及在POST数据中是否为有效请求所需的字段：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have the `new_user_parser` setup in our module, we can modify the
    `CreateUser.post()` method to utilize this instead:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在模块中设置了`new_user_parser`，我们可以修改`CreateUser.post()`方法来使用它：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `new_user_parser.parse_args(strict=True)` invocation will attempt to match
    the declared types and requirements for the fields that we defined via `add_argument`
    earlier and will internally `abort()` with an HTTP 400 error in case any fields
    do not pass validation or there are additional fields in the request that we have
    not explicitly accounted for. (Thanks to the `strict=True` option.)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_user_parser.parse_args(strict=True)`的调用将尝试匹配我们之前通过`add_argument`定义的字段的声明类型和要求，并且在请求中存在任何字段未通过验证或者有额外字段没有明确考虑到的情况下，将内部调用`abort()`并返回HTTP
    400错误（感谢`strict=True`选项）。'
- en: The use of `reqparse` to validate the POST'ed data can be more cumbersome than
    the direct assignment that we had previously, but is more secure by an order of
    magnitude. With the direct assignment technique a malicious user might send arbitrary
    data in the hope of overriding fields that they should not have access to. For
    example, our database could contain the internal only `subscription_exipires_on
    datetime` field and a nefarious user could then submit a POST request containing
    a value for this field set to the far future. Definitely something that we'd like
    to avoid!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`reqparse`来验证POST的数据可能比我们之前直接赋值更加繁琐，但是安全性更高。通过直接赋值技术，恶意用户可能会发送任意数据，希望覆盖他们不应该访问的字段。例如，我们的数据库可能包含内部字段`subscription_exipires_on
    datetime`，一个恶意用户可能会提交一个包含这个字段值设置为遥远未来的POST请求。这绝对是我们想要避免的事情！
- en: API testing
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API测试
- en: Let's apply some of the knowledge that we gained in the previous chapters with
    regards to functional and integration testing with `pytest`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们应用一些我们在之前章节中学到的关于使用`pytest`进行功能和集成测试的知识。
- en: 'Our first step (after the requisite pip install `pytest-flask`, of course)
    is to add a `conftest.py` file as we did in the previous chapters, which is sibling
    to our `application/` folder:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步（在必要的pip安装`pytest-flask`之后）是像我们在之前的章节中所做的那样添加一个`conftest.py`文件，它是我们`application/`文件夹的同级文件夹。
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The preceding `conftest.py` file contains the basic test fixtures that we will
    need in order to write our API tests properly; there should be no surprises here.
    We will then add our `test_settings.py` file, which is sibling to the newly created
    `conftest.py`, and populate it with the application configuration values that
    we want for our test runs:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`conftest.py`文件包含了我们编写API测试所需的基本测试装置；这里不应该有任何意外。然后我们将添加我们的`test_settings.py`文件，它是新创建的`conftest.py`的同级文件，并填充它与我们想要在测试运行中使用的应用程序配置值：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once this is in place, we can begin writing our test functions and assertions
    in `tests/test_users.py`. Our first test will ensure that we can create a new
    user via the API and the URI of the newly created resource is returned to us in
    the `Location` header:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些都就位，我们就可以开始在`tests/test_users.py`中编写我们的测试函数和断言。我们的第一个测试将确保我们可以通过API创建一个新用户，并且新创建的资源的URI将在`Location`标头中返回给我们：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we''ve established that a user can be created, the next logical step is
    to test that an error is returned if a client attempts to create a user with invalid
    or missing parameters:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定可以创建用户，下一个逻辑步骤是测试如果客户端尝试使用无效或缺少的参数创建用户，则会返回错误：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As a sanity check for our HTTP Basic authentication implementation, let''s
    also add a test to fetch a single user record, which requires the request to be
    authenticated:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 作为对我们的HTTP基本身份验证实现的健全性检查，让我们还添加一个测试来获取单个用户记录，这需要对请求进行身份验证：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The associated test for an unauthenticated request for a single user record
    is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 未经身份验证的请求获取单个用户记录的相关测试如下：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can also test that our very simple authorization implementation functions
    as expected (Recall that we only allow authenticated users to view their own information
    and not that of any other users in the system.) with a test that creates two users
    and attempts to access each other''s data via authenticated requests:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试我们非常简单的授权实现是否按预期运行（回想一下，我们只允许经过身份验证的用户查看自己的信息，而不是系统中其他任何用户的信息。）通过创建两个用户并尝试通过经过身份验证的请求访问彼此的数据来进行测试：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Interlude – Werkzeug middlewares
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插曲 - Werkzeug中间件
- en: For certain tasks, we sometimes need the ability to modify the inbound request
    data and/or environment before the request is routed to a handler function or
    method. In many situations, the easiest way to achieve this would be to register
    a function with the `before_request` decorator; this is often used to set `request-global`
    values on the `g` object or create a database connection.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些任务，我们有时需要在将请求路由到处理程序函数或方法之前修改传入请求数据和/或环境的能力。在许多情况下，实现这一点的最简单方法是使用`before_request`装饰器注册一个函数；这通常用于在`g`对象上设置`request-global`值或创建数据库连接。
- en: While this should suffice for a large portion of the most common use cases,
    sometimes it's more convenient to drop down below the Flask application object
    (when the request proxy object is constructed) but above the HTTP server. For
    this, we have the concept of middlewares. Additionally, a properly written middleware
    will be portable across other compatible WSGI implementations; there's nothing
    stopping you (barring any application-specific oddities) from using a middleware
    originally written for a Django application in our current Flask application.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这应该足够涵盖大部分最常见的用例，但有时在Flask应用程序对象下方（构造请求代理对象时）但在HTTP服务器上方更方便。为此，我们有中间件的概念。此外，一个正确编写的中间件将在其他兼容的WSGI实现中可移植；除了应用程序特定的怪癖外，没有什么能阻止您在我们当前的Flask应用程序中使用最初为Django应用程序编写的中间件。
- en: 'Middlewares are relatively simple things: they are essentially any callable
    (classes, instances, functions, or methods that can be invoked in a manner similar
    to a function) that return the proper response format so that the other middlewares
    in the chain can be invoked correctly.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件相对简单：它们本质上是任何可调用的东西（类、实例、函数或方法，可以以类似于函数的方式调用），以便返回正确的响应格式，以便链中的其他中间件可以正确调用。
- en: One example of a middleware that is useful for our current API-based application
    is one that allows us to extract an optional version number from the request URIs
    and store this information in the environment so that it can be used at various
    points during the request processing. For example, a request to `/v0.1a/users/2`
    will be routed to the handler for `/users/2` and `v0.1a` will be accessible via
    `request.environ['API_VERSION']` in the Flask application itself.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们当前基于API的应用程序有用的中间件的一个例子是，它允许我们从请求URI中提取可选的版本号，并将此信息存储在环境中，以便在请求处理过程中的各个点使用。例如，对`/v0.1a/users/2`的请求将被路由到`/users/2`的处理程序，并且`v0.1a`将通过`request.environ['API_VERSION']`在Flask应用程序本身中可访问。
- en: 'In a new module in `application/middlewares.py`, we can implement it as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在`application/middlewares.py`中的新模块中，我们可以实现如下：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will bind this middleware to the application object in our factory:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在工厂中将此中间件绑定到应用程序对象：
- en: '[PRE35]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When adding multiple WSGI middlewares, their order can sometimes matter. Be
    sure to keep this in mind when adding middlewares that can modify the WSGI environment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加多个WSGI中间件时，它们的顺序有时很重要。在添加可能修改WSGI环境的中间件时，请务必记住这一点。
- en: 'Once bound, the middleware is inserted into the request processing before Flask
    receives the request even though we clearly instantiated a Flask application object.
    Accessing the `API_VERSION` value in your application is a simple matter of querying
    the key bound to the request environment:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦绑定，中间件将在Flask接收请求之前插入请求处理，即使我们明确实例化了一个Flask应用程序对象。在应用程序中访问`API_VERSION`值只是简单地查询绑定到请求环境的键：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The parsing of the API version numbers could also be extended to examining the
    HTTP headers (custom or otherwise) in addition to the URL-based version extraction
    that we have provided here; a case could be made for the convenience of either.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: API版本号的解析也可以扩展到检查HTTP头（自定义或其他），除了我们在此提供的基于URL的版本提取；可以为任一方便性提出论点。
- en: Back to Shutterbug – uploading photos
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 回到Shutterbug - 上传照片
- en: 'Now that we have a minimal but functional API to create and fetch users, we
    need a similar one to upload photos. First, we will use the same resource pattern
    that we used previously in addition to defining a `RequestParser` instance to
    validate the user submitted data regarding the photos:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个最小但功能齐全的API来创建和获取用户，我们需要一个类似的API来上传照片。首先，我们将使用与之前相同的资源模式，另外定义一个`RequestParser`实例来验证有关照片的用户提交数据：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that in the preceding `UploadPhoto` resource, we are accessing `request.files`
    to extract the binary data that was POST'ed to the endpoint. We then parsed out
    the extension, generated a unique random string to act as the filename, and finally
    saved the file to a known `UPLOAD_FOLDER` that we configured in our application
    configuration.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的`UploadPhoto`资源中，我们正在访问`request.files`以提取通过POST发送到端点的二进制数据。然后，我们解析出扩展名，生成一个唯一的随机字符串作为文件名，最后将文件保存到我们在应用程序配置中配置的已知`UPLOAD_FOLDER`中。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we used the `werkzeug.utils.secure_filename` function to sanitize
    the extension of the uploaded image in order to ensure that it is not vulnerable
    to path traversal or other filesystem-based exploits that are common when dealing
    with user uploaded binary data.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用`werkzeug.utils.secure_filename`函数来净化上传图像的扩展名，以确保它不容易受到路径遍历或其他基于文件系统的利用的影响，这在处理用户上传的二进制数据时很常见。
- en: There are many other verifications and sanitization steps (for example, ensuring
    that the MIME type of the file matches the extension and binary data that was
    actually uploaded, limiting the size/dimensions of the image) that should be performed
    when accepting untrusted data that will be persisted to a filesystem, but we omit
    them for the sake of brevity. Data validation techniques and best practices could
    fill an entire book in themselves.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受将持久化到文件系统的不受信任数据时，应该执行许多其他验证和净化步骤（例如，确保文件的MIME类型与实际上传的扩展名和二进制数据匹配，限制图像的大小/尺寸），但出于简洁起见，我们省略了它们。数据验证技术和最佳实践本身就可以填满一整本书。
- en: The local filesystem path that we end up persisting the image to is then added
    to our photo SQLAlchemy record along with the optional comment that may have accompanied
    the photo upload. The whole lot is then added to the session and committed to
    the database before returning a 201 response with the location of the newly created
    asset in the headers. There are some simple error conditions that we avoid handling
    in this so that we can focus on the core concepts presented and their implementation
    is left as an exercise for the reader.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终将图像持久化到的本地文件系统路径与可能陪伴照片上传的可选评论一起添加到我们的照片SQLAlchemy记录中。然后将整个记录添加到会话中，并提交到数据库，然后在标头中返回新创建的资产的位置的201响应。在这里，我们避免处理一些简单的错误条件，以便我们可以专注于所呈现的核心概念，并将它们的实现留给读者作为练习。
- en: 'Before taking any of the new photo upload functionalities out for a spin, make
    sure to bind the resource to the API object in our application factory:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试任何新的照片上传功能之前，请确保将资源绑定到我们应用程序工厂中的API对象：
- en: '[PRE38]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: File uploads in distributed systems
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 分布式系统中的文件上传
- en: We have greatly simplified the treatment of file uploads in modern web applications.
    Of course, simplicity often has several downsides.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经大大简化了现代Web应用程序中文件上传的处理。当然，简单通常有一些缺点。
- en: The most glaring of these is that in the preceding implementation, we are restricted
    to a single application server. If multiple application servers existed, ensuring
    that the uploaded files remain synchronized across these multiple servers then
    becomes a major operational concern. While there are many solutions to this particular
    problem (for example, distributed filesystem protocols such as NFS, uploading
    the assets to remote storage such as Amazon's **Simple Storage Service** (**S3**),
    and so on), they all require additional thought and consideration to evaluate
    their pros and cons and significant changes to your application's structure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其中最明显的是，在前面的实现中，我们受限于单个应用服务器。如果存在多个应用服务器，则确保上传的文件在这些多个服务器之间保持同步将成为一个重大的运营问题。虽然有许多解决这个特定问题的解决方案（例如，分布式文件系统协议，如NFS，将资产上传到远程存储，如Amazon的**简单存储服务**（**S3**）等），但它们都需要额外的思考和考虑来评估它们的利弊以及对应用程序结构的重大更改。
- en: Testing the photo uploads
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试照片上传
- en: 'As we''re on somewhat of a testing roll, let''s keep this ball rolling by writing
    some simple tests in order to validate the behavior of our `UploadPhoto` resource
    in `tests/test_photos.py`. First, let''s try to upload some binary data with an
    unauthenticated request:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在进行一些测试，让我们通过在`tests/test_photos.py`中编写一些简单的测试来保持这个过程。首先，让我们尝试使用未经身份验证的请求上传一些二进制数据：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, let''s check the obvious success path with a properly authenticated request:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们通过正确验证的请求来检查明显的成功路径：
- en: '[PRE40]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, let''s ensure that when we submit the (optional) comment, it is persisted
    to the database:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们确保在提交（可选）评论时，它被持久化到数据库中：
- en: '[PRE41]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Fetching the user's photos
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取用户的照片
- en: Other than the ability to upload photos, the meat of the Shutterbug application
    lies in the ability to fetch a list, in a reverse chronological order, of photos
    that were uploaded by the authenticated user. For this, we will flesh out the
    `ListPhoto` resource in `application/resources/photos.py`. As we want the ability
    to paginate this list of returned photos, we will also create a new instance of
    `RequestParser` to handle the common page/limit query arguments. Additionally,
    we will use the marshalling feature of Flask-RESTful to serialize the returned
    `Photo` objects that are returned from SQLAlchemy so that they can then be converted
    to JSON and sent over the wire to the requesting client.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上传照片的能力之外，Shutterbug应用程序的核心在于能够以逆向时间顺序获取经过认证用户上传的照片列表。为此，我们将完善`application/resources/photos.py`中的`ListPhoto`资源。由于我们希望能够对返回的照片列表进行分页，我们还将创建一个新的`RequestParser`实例来处理常见的页面/限制查询参数。此外，我们将使用Flask-RESTful的编组功能来序列化从SQLAlchemy返回的`Photo`对象，以便将它们转换为JSON并发送到请求的客户端。
- en: Note
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Marshalling** is something that web applications (and most other kinds of
    applications!) do all the time even if you might have never heard of the word.
    Simply, you take the data in some form of an in-memory representation, such as
    a Python dictionary or list, and convert it to a format that is more suitable
    for transmission. In the case of our application, this transformation is to JSON
    and the transmission occurs over HTTP to the client that made the request.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**编组**是Web应用程序（以及大多数其他类型的应用程序！）经常做的事情，即使你可能从未听说过这个词。简单地说，你将数据转换成更适合传输的格式，比如Python字典或列表，然后将其转换为JSON格式，并通过HTTP传输给发出请求的客户端。'
- en: '[PRE42]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that in the preceding `ListPhoto.get()` handler, we calculated an offset
    value based on the page and limit that are provided by the request parameters.
    The page and limit are independent of the size of our dataset and easy to understand
    for clients that are consuming the API. SQLAlchemy (and most database APIs, for
    that matter), only understand offset and limit. The conversion formula is a well-known
    one and is applicable to any sorted dataset.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的`ListPhoto.get()`处理程序中，我们根据请求参数提供的页面和限制计算了一个偏移值。页面和限制与我们的数据集大小无关，并且易于理解，适用于消费API的客户端。SQLAlchemy（以及大多数数据库API）只理解偏移和限制。转换公式是众所周知的，并适用于任何排序的数据集。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter began somewhat differently than the previous ones. Our objective
    was to create a JSON-based API instead of a typical web application that produced
    HTML and consumed submitted HTML form data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的开始有些不同于之前的章节。我们的目标是创建一个基于JSON的API，而不是一个典型的生成HTML并消费提交的HTML表单数据的Web应用程序。
- en: We first took a bit of a sidestep to explain the existence and usefulness of
    Werkzeug and then created a basic API with a Flask extension called Flask-RESTful.
    Next, we made sure that our API could be protected by requiring authentication
    and explained the subtle but fundamental difference between authentication and
    authorization.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先稍微偏离一下，解释了Werkzeug的存在和用处，然后使用名为Flask-RESTful的Flask扩展创建了一个基本的API。接下来，我们确保我们的API可以通过要求身份验证来保护，并解释了身份验证和授权之间微妙但根本的区别。
- en: We then looked at how we could implement validation rules for our API in order
    to ensure that clients could create valid resources (for example, new users, upload
    photos, and so on). We implemented several functional and integration-level unit
    tests using the `py.test` framework.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们看了如何实现API的验证规则，以确保客户端可以创建有效的资源（例如新用户、上传照片等）。我们使用`py.test`框架实现了几个功能和集成级别的单元测试。
- en: We finished off the chapter by implementing the most important feature, photo
    uploads. We ensured that this feature functioned as expected with a few more test
    cases and then implemented the reverse chronological view of the photos necessary
    for a consumer of the API to display the uploaded images to the user. Along the
    way, we discussed the concept of Werkzeug middlewares, a powerful but often overlooked
    way of introspecting and (possibly) modifying a request before Flask has had a
    chance to process it.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现最重要的功能——照片上传，完成了本章。我们确保这个功能按预期运行，并实现了照片的逆向时间顺序视图，这对API的消费者来说是必要的，以便向用户显示上传的图片。在此过程中，我们讨论了Werkzeug中间件的概念，这是一种强大但经常被忽视的方式，可以在Flask处理请求之前审查和（可能）修改请求。
- en: In the next chapter, we will explore the usage and creation of command line
    tools that will allow us to interface and manage our web applications via CLI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨使用和创建命令行工具，这将允许我们通过CLI接口和管理我们的Web应用程序。
