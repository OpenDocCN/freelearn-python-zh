- en: Chapter 5. When to Use Object-oriented Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。何时使用面向对象编程
- en: In previous chapters, we've covered many of the defining features of object-oriented
    programming. We now know the principles and paradigms of object-oriented design,
    and we've covered the syntax of object-oriented programming in Python.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们已经涵盖了面向对象编程的许多定义特性。我们现在知道了面向对象设计的原则和范例，并且我们已经涵盖了Python中面向对象编程的语法。
- en: 'Yet, we don''t know exactly how and when to utilize these principles and syntax
    in practice. In this chapter, we''ll discuss some useful applications of the knowledge
    we''ve gained, picking up some new topics along the way:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们并不知道如何以及何时在实践中利用这些原则和语法。在本章中，我们将讨论我们所获得的知识的一些有用应用，并在此过程中学习一些新的主题：
- en: How to recognize objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何识别对象
- en: Data and behaviors, once again
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据和行为，再次
- en: Wrapping data in behavior using properties
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用属性将数据包装在行为中
- en: Restricting data using behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行为限制数据
- en: The Don't Repeat Yourself principle
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要重复自己的原则
- en: Recognizing repeated code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别重复的代码
- en: Treat objects as objects
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象视为对象
- en: This may seem obvious; you should generally give separate objects in your problem
    domain a special class in your code. We've seen examples of this in the case studies
    in previous chapters; first, we identify objects in the problem and then model
    their data and behaviors.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来很明显；你通常应该在你的代码中为问题域中的单独对象提供一个特殊的类。我们在前几章的案例研究中看到了这样的例子；首先，我们确定问题中的对象，然后对其数据和行为进行建模。
- en: Identifying objects is a very important task in object-oriented analysis and
    programming. But it isn't always as easy as counting the nouns in a short paragraph,
    as we've been doing. Remember, objects are things that have both data and behavior.
    If we are working only with data, we are often better off storing it in a list,
    set, dictionary, or some other Python data structure (which we'll be covering
    thoroughly in [Chapter 6](ch06.html "Chapter 6. Python Data Structures"), *Python
    Data Structures*). On the other hand, if we are working only with behavior, but
    no stored data, a simple function is more suitable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象分析和编程中，识别对象是一项非常重要的任务。但这并不总是像我们一直在做的那样简单，只需数一下短段落中的名词。记住，对象是既有数据又有行为的东西。如果我们只处理数据，通常最好将其存储在列表、集合、字典或其他Python数据结构中（我们将在[第6章](ch06.html
    "第6章。Python数据结构")中全面介绍）。另一方面，如果我们只处理行为，而没有存储数据，一个简单的函数更合适。
- en: An object, however, has both data and behavior. Proficient Python programmers
    use built-in data structures unless (or until) there is an obvious need to define
    a class. There is no reason to add an extra level of abstraction if it doesn't
    help organize our code. On the other hand, the "obvious" need is not always self-evident.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对象既有数据又有行为。熟练的Python程序员使用内置数据结构，除非（或直到）明显需要定义一个类。如果它不帮助组织我们的代码，就没有理由添加额外的抽象层。另一方面，“明显”的需求并不总是不言自明的。
- en: 'We can often start our Python programs by storing data in a few variables.
    As the program expands, we will later find that we are passing the same set of
    related variables to a set of functions. This is the time to think about grouping
    both variables and functions into a class. If we are designing a program to model
    polygons in two-dimensional space, we might start with each polygon being represented
    as a list of points. The points would be modeled as two-tuples (*x*, *y*) describing
    where that point is located. This is all data, stored in a set of nested data
    structures (specifically, a list of tuples):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常可以通过将数据存储在几个变量中来启动我们的Python程序。随着程序的扩展，我们将会发现我们正在将相同的一组相关变量传递给一组函数。这是思考将变量和函数分组到一个类中的时候。如果我们设计一个在二维空间中模拟多边形的程序，我们可能会从每个多边形被表示为点列表开始。点将被建模为描述该点位置的两元组（*x*，*y*）。这是所有数据，存储在一组嵌套的数据结构中（具体来说，是一个元组列表）：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, if we want to calculate the distance around the perimeter of the polygon,
    we simply need to sum the distances between the two points. To do this, we also
    need a function to calculate the distance between two points. Here are two such
    functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想要计算多边形周长的距离，我们只需要计算两点之间的距离。为此，我们还需要一个函数来计算两点之间的距离。以下是两个这样的函数：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, as object-oriented programmers, we clearly recognize that a `polygon`
    class could encapsulate the list of points (data) and the `perimeter` function
    (behavior). Further, a `point` class, such as we defined in [Chapter 2](ch02.html
    "Chapter 2. Objects in Python"), *Objects in Python*, might encapsulate the `x`
    and `y` coordinates and the `distance` method. The question is: is it valuable
    to do this?'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为面向对象的程序员，我们清楚地意识到`polygon`类可以封装点列表（数据）和`perimeter`函数（行为）。此外，`point`类，就像我们在[第2章](ch02.html
    "第2章。Python中的对象")中定义的那样，*Python中的对象*，可以封装`x`和`y`坐标以及`distance`方法。问题是：这样做有价值吗？
- en: For the previous code, maybe yes, maybe no. With our recent experience in object-oriented
    principles, we can write an object-oriented version in record time. Let's compare
    them
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以前的代码，也许是，也许不是。有了我们最近在面向对象原则方面的经验，我们可以以创纪录的速度编写一个面向对象的版本。让我们比较一下它们
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see from the highlighted sections, there is twice as much code here
    as there was in our earlier version, although we could argue that the `add_point`
    method is not strictly necessary.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从突出显示的部分所看到的，这里的代码量是我们之前版本的两倍，尽管我们可以争辩说`add_point`方法并不是严格必要的。
- en: 'Now, to understand the differences a little better, let''s compare the two
    APIs in use. Here''s how to calculate the perimeter of a square using the object-oriented
    code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了更好地理解这两个API的区别，让我们比较一下两种使用情况。这是如何使用面向对象的代码来计算正方形的周长：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'That''s fairly succinct and easy to read, you might think, but let''s compare
    it to the function-based code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这相当简洁易读，但让我们将其与基于函数的代码进行比较：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Hmm, maybe the object-oriented API isn''t so compact! That said, I''d argue
    that it was easier to *read* than the functional example: How do we know what
    the list of tuples is supposed to represent in the second version? How do we remember
    what kind of object (a list of two-tuples? That''s not intuitive!) we''re supposed
    to pass into the `perimeter` function? We would need a lot of documentation to
    explain how these functions should be used.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，也许面向对象的API并不那么紧凑！也就是说，我认为它比函数示例更容易*阅读*：在第二个版本中，我们怎么知道元组列表应该表示什么？我们怎么记得我们应该传递什么样的对象（一个包含两个元组的列表？这不直观！）到`perimeter`函数中？我们需要大量的文档来解释这些函数应该如何使用。
- en: In contrast, the object-oriented code is relatively self-documenting, we just
    have to look at the list of methods and their parameters to know what the object
    does and how to use it. By the time we wrote all the documentation for the functional
    version, it would probably be longer than the object-oriented code.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，面向对象的代码相对自我说明，我们只需要查看方法列表及其参数就能知道对象的功能和如何使用它。当我们为函数版本编写所有文档时，它可能会比面向对象的代码更长。
- en: Finally, code length is not a good indicator of code complexity. Some programmers
    get hung up on complicated "one liners" that do an incredible amount of work in
    one line of code. This can be a fun exercise, but the result is often unreadable,
    even to the original author the following day. Minimizing the amount of code can
    often make a program easier to read, but do not blindly assume this is the case.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，代码长度并不是代码复杂性的良好指标。一些程序员会陷入复杂的“一行代码”中，这一行代码可以完成大量工作。这可能是一个有趣的练习，但结果通常是难以阅读的，即使对于原始作者来说，第二天也是如此。最小化代码量通常可以使程序更易读，但不要盲目地假设这是正确的。
- en: 'Luckily, this trade-off isn''t necessary. We can make the object-oriented `Polygon`
    API as easy to use as the functional implementation. All we have to do is alter
    our `Polygon` class so that it can be constructed with multiple points. Let''s
    give it an initializer that accepts a list of `Point` objects. In fact, let''s
    allow it to accept tuples too, and we can construct the `Point` objects ourselves,
    if needed:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这种权衡是不必要的。我们可以使面向对象的`Polygon` API像函数实现一样易于使用。我们只需要修改我们的`Polygon`类，使其可以用多个点构造。让我们给它一个接受`Point`对象列表的初始化器。事实上，让我们也允许它接受元组，并且如果需要，我们可以自己构造`Point`对象：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This initializer goes through the list and ensures that any tuples are converted
    to points. If the object is not a tuple, we leave it as is, assuming that it is
    either a `Point` object already, or an unknown duck-typed object that can act
    like a `Point` object.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始化器遍历列表，并确保任何元组都转换为点。如果对象不是元组，我们将其保留，假设它要么已经是`Point`对象，要么是一个未知的鸭子类型对象，可以像`Point`对象一样工作。
- en: Still, there's no clear winner between the object-oriented and more data-oriented
    versions of this code. They both do the same thing. If we have new functions that
    accept a polygon argument, such as `area(polygon)` or `point_in_polygon(polygon,
    x, y)`, the benefits of the object-oriented code become increasingly obvious.
    Likewise, if we add other attributes to the polygon, such as `color` or `texture`,
    it makes more and more sense to encapsulate that data into a single class.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在面向对象和更数据导向的代码版本之间并没有明显的赢家。它们都做同样的事情。如果我们有新的函数接受一个多边形参数，比如`area(polygon)`或`point_in_polygon(polygon,
    x, y)`，面向对象的代码的好处就变得越来越明显。同样，如果我们为多边形添加其他属性，比如`color`或`texture`，将这些数据封装到一个单一的类中就变得更有意义。
- en: The distinction is a design decision, but in general, the more complicated a
    set of data is, the more likely it is to have multiple functions specific to that
    data, and the more useful it is to use a class with attributes and methods instead.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种区别是一个设计决策，但一般来说，数据集越复杂，就越有可能有多个特定于该数据的函数，使用具有属性和方法的类就越有用。
- en: When making this decision, it also pays to consider how the class will be used.
    If we're only trying to calculate the perimeter of one polygon in the context
    of a much greater problem, using a function will probably be quickest to code
    and easier to use "one time only". On the other hand, if our program needs to
    manipulate numerous polygons in a wide variety of ways (calculate perimeter, area,
    intersection with other polygons, move or scale them, and so on), we have most
    certainly identified an object; one that needs to be extremely versatile.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这个决定时，还要考虑类将如何使用。如果我们只是试图在更大的问题背景下计算一个多边形的周长，使用函数可能是编码最快、使用最方便的“一次性”方法。另一方面，如果我们的程序需要以各种方式操作多个多边形（计算周长、面积、与其他多边形的交集、移动或缩放它们等），我们肯定已经确定了一个需要非常灵活的对象。
- en: Additionally, pay attention to the interaction between objects. Look for inheritance
    relationships; inheritance is impossible to model elegantly without classes, so
    make sure to use them. Look for the other types of relationships we discussed
    in [Chapter 1](ch01.html "Chapter 1. Object-oriented Design"), *Object-oriented
    Design*, association and composition. Composition can, technically, be modeled
    using only data structures; for example, we can have a list of dictionaries holding
    tuple values, but it is often less complicated to create a few classes of objects,
    especially if there is behavior associated with the data.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，要注意对象之间的交互。寻找继承关系；继承是不可能优雅地建模而不使用类的，所以一定要使用它们。寻找我们在[第1章](ch01.html "第1章。面向对象设计")中讨论的其他类型的关系，*面向对象设计*，关联和组合。组合在技术上可以使用只有数据结构来建模；例如，我们可以有一个包含元组值的字典列表，但通常更容易创建一些对象类，特别是如果与数据相关联有行为。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't rush to use an object just because you can use an object, but *never*
    neglect to create a class when you need to use a class.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 不要因为可以使用对象就匆忙使用对象，但是*永远*不要忽视需要使用类时创建类。
- en: Adding behavior to class data with properties
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用属性为类数据添加行为
- en: Throughout this book, we've been focusing on the separation of behavior and
    data. This is very important in object-oriented programming, but we're about to
    see that, in Python, the distinction can be uncannily blurry. Python is very good
    at blurring distinctions; it doesn't exactly help us to "think outside the box".
    Rather, it teaches us to stop thinking about the box.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在关注行为和数据的分离。这在面向对象编程中非常重要，但我们将看到，在Python中，这种区别可能会变得模糊不清。Python非常擅长模糊区别；它并不完全帮助我们“打破常规思维”。相反，它教会我们停止思考常规思维。
- en: 'Before we get into the details, let''s discuss some bad object-oriented theory.
    Many object-oriented languages (Java is the most notorious) teach us to never
    access attributes directly. They insist that we write attribute access like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入细节之前，让我们讨论一些糟糕的面向对象理论。许多面向对象的语言（Java是最臭名昭著的）教导我们永远不要直接访问属性。他们坚持要求我们像这样编写属性访问：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The variables are prefixed with an underscore to suggest that they are private
    (other languages would actually force them to be private). Then the get and set
    methods provide access to each variable. This class would be used in practice
    as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变量前缀带有下划线，以表明它们是私有的（其他语言实际上会强制它们为私有）。然后，get和set方法提供对每个变量的访问。这个类在实践中将被使用如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is not nearly as readable as the direct access version that Python favors:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不像Python偏爱的直接访问版本那样易读：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So why would anyone insist upon the method-based syntax? Their reasoning is
    that someday we may want to add extra code when a value is set or retrieved. For
    example, we could decide to cache a value and return the cached value, or we might
    want to validate that the value is a suitable input.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么有人会坚持基于方法的语法呢？他们的理由是，有一天我们可能希望在设置或检索值时添加额外的代码。例如，我们可以决定缓存一个值并返回缓存的值，或者我们可能希望验证该值是否是合适的输入。
- en: 'In code, we could decide to change the `set_name()` method as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们可以决定更改`set_name()`方法如下：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, in Java and similar languages, if we had written our original code to
    do direct attribute access, and then later changed it to a method like the preceding
    one, we''d have a problem: anyone who had written code that accessed the attribute
    directly would now have to access the method. If they don''t change the access
    style from attribute access to a function call, their code will be broken. The
    mantra in these languages is that we should never make public members private.
    This doesn''t make much sense in Python since there isn''t any real concept of
    private members!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在Java和类似的语言中，如果我们最初编写我们的原始代码以直接访问属性，然后稍后将其更改为像前面的方法一样的方法，我们会有问题：任何访问属性的代码现在都必须访问方法。如果他们不将访问样式从属性访问更改为函数调用，他们的代码将会出错。在这些语言中的口头禅是我们永远不应该将公共成员变为私有。这在Python中并没有太多意义，因为它没有真正的私有成员的概念！
- en: 'Python gives us the `property` keyword to make methods look like attributes.
    We can therefore write our code to use direct member access, and if we unexpectedly
    need to alter the implementation to do some calculation when getting or setting
    that attribute''s value, we can do so without changing the interface. Let''s see
    how it looks:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Python给我们提供了`property`关键字，使方法看起来像属性。因此，我们可以编写我们的代码以使用直接成员访问，如果我们意外地需要更改实现以在获取或设置属性值时进行一些计算，我们可以这样做而不改变接口。让我们看看它是什么样子的：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If we had started with the earlier non-method-based class, which set the `name`
    attribute directly, we could later change the code to look like the preceding
    one. We first change the `name` attribute into a (semi-) private `_name` attribute.
    Then we add two more (semi-) private methods to get and set that variable, doing
    our validation when we set it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一开始使用的是早期的非基于方法的类，直接设置了`name`属性，我们可以稍后将代码更改为前面的样子。我们首先将`name`属性更改为（半）私有的`_name`属性。然后我们添加另外两个（半）私有方法来获取和设置该变量，在设置时进行验证。
- en: 'Finally, we have the `property` declaration at the bottom. This is the magic.
    It creates a new attribute on the `Color` class called `name`, which now replaces
    the previous `name` attribute. It sets this attribute to be a property, which
    calls the two methods we just created whenever the property is accessed or changed.
    This new version of the `Color` class can be used exactly the same way as the
    previous version, yet it now does validation when we set the `name` attribute:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在底部有`property`声明。这就是魔法。它在`Color`类上创建了一个名为`name`的新属性，现在替换了先前的`name`属性。它将此属性设置为属性，每当访问或更改属性时，它都会调用我们刚刚创建的两个方法。这个新版本的`Color`类可以像以前的版本一样使用，但是现在在设置`name`属性时进行验证：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, if we'd previously written code to access the `name` attribute, and then
    changed it to use our `property` object, the previous code would still work, unless
    it was sending an empty `property` value, which is the behavior we wanted to forbid
    in the first place. Success!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们以前编写了访问`name`属性的代码，然后将其更改为使用我们的`property`对象，先前的代码仍将起作用，除非它发送了一个空的`property`值，这正是我们想要在第一次禁止的行为。成功！
- en: Bear in mind that even with the `name` property, the previous code is not 100
    percent safe. People can still access the `_name` attribute directly and set it
    to an empty string if they want to. But if they access a variable we've explicitly
    marked with an underscore to suggest it is private, they're the ones that have
    to deal with the consequences, not us.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，即使使用`name`属性，先前的代码也不是100％安全的。人们仍然可以直接访问`_name`属性，并将其设置为空字符串。但是，如果他们访问我们明确标记为下划线的变量以表明它是私有的，那么他们就必须处理后果，而不是我们。
- en: Properties in detail
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性详细信息
- en: Think of the `property` function as returning an object that proxies any requests
    to set or access the attribute value through the methods we have specified. The
    `property` keyword is like a constructor for such an object, and that object is
    set as the public facing member for the given attribute.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将`property`函数视为返回一个对象，该对象通过我们指定的方法代理对属性值的设置或访问的任何请求。`property`关键字就像是这样一个对象的构造函数，并且该对象被设置为给定属性的公共成员。
- en: 'This `property` constructor can actually accept two additional arguments, a
    deletion function and a docstring for the property. The `delete` function is rarely
    supplied in practice, but it can be useful for logging that a value has been deleted,
    or possibly to veto deleting if we have reason to do so. The docstring is just
    a string describing what the property does, no different from the docstrings we
    discussed in [Chapter 2](ch02.html "Chapter 2. Objects in Python"), *Objects in
    Python*. If we do not supply this parameter, the docstring will instead be copied
    from the docstring for the first argument: the getter method. Here is a silly
    example that simply states whenever any of the methods are called:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`property`构造函数实际上可以接受两个额外的参数，一个删除函数和一个属性的文档字符串。`delete`函数在实践中很少被提供，但它可以用于记录已删除的值，或者可能否决删除，如果我们有理由这样做的话。文档字符串只是描述属性的字符串，与我们在[第2章](ch02.html
    "第2章。Python中的对象")中讨论的文档字符串没有什么不同，*Python中的对象*。如果我们不提供此参数，文档字符串将从第一个参数的文档字符串中复制：获取方法。这是一个愚蠢的例子，只是在任何方法被调用时简单地说明：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we actually use this class, it does indeed print out the correct strings
    when we ask it to:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实际使用这个类，当我们要求它时，它确实打印出正确的字符串：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Further, if we look at the help file for the `Silly` class (by issuing `help(silly)`
    at the interpreter prompt), it shows us the custom docstring for our `silly` attribute:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们查看`Silly`类的帮助文件（通过在解释器提示符处发出`help(silly)`），它会显示我们的`silly`属性的自定义文档字符串：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once again, everything is working as we planned. In practice, properties are
    normally only defined with the first two parameters: the getter and setter functions.
    If we want to supply a docstring for a property, we can define it on the getter
    function; the property proxy will copy it into its own docstring. The deletion
    function is often left empty because object attributes are rarely deleted. If
    a coder does try to delete a property that doesn''t have a deletion function specified,
    it will raise an exception. Therefore, if there is a legitimate reason to delete
    our property, we should supply that function.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，一切都按我们计划的那样运行。实际上，属性通常只使用前两个参数定义：获取和设置函数。如果我们想为属性提供文档字符串，我们可以在获取函数上定义它；属性代理将把它复制到自己的文档字符串中。删除函数通常为空，因为对象属性很少被删除。如果程序员尝试删除没有指定删除函数的属性，它将引发异常。因此，如果有正当理由删除我们的属性，我们应该提供该函数。
- en: Decorators – another way to create properties
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器 - 创建属性的另一种方式
- en: If you've never used Python decorators before, you might want to skip this section
    and come back to it after we've discussed the decorator pattern in [Chapter 10](ch10.html
    "Chapter 10. Python Design Patterns I"), *Python Design Patterns I*. However,
    you don't need to understand what's going on to use the decorator syntax to make
    property methods more readable.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未使用过Python装饰器，您可能希望跳过本节，在我们讨论[第10章](ch10.html "第10章。Python设计模式I")中的装饰器模式之后再回来。然而，您不需要理解正在发生什么，就可以使用装饰器语法使属性方法更易读。
- en: 'The property function can be used with the decorator syntax to turn a get function
    into a property:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 属性函数可以与装饰器语法一起使用，将获取函数转换为属性：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This applies the `property` function as a decorator, and is equivalent to the
    previous `foo = property(foo)` syntax. The main difference, from a readability
    perspective, is that we get to mark the `foo` function as a property at the top
    of the method, instead of after it is defined, where it can be easily overlooked.
    It also means we don't have to create private methods with underscore prefixes
    just to define a property.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`property`函数应用为装饰器，并且等同于之前的`foo = property(foo)`语法。从可读性的角度来看，主要区别在于我们可以在方法的顶部将`foo`函数标记为属性，而不是在定义之后，那样很容易被忽视。这也意味着我们不必创建带有下划线前缀的私有方法来定义属性。
- en: 'Going one step further, we can specify a setter function for the new property
    as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 更进一步，我们可以指定一个新属性的设置函数如下：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This syntax looks pretty odd, although the intent is obvious. First, we decorate
    the `foo` method as a getter. Then, we decorate a second method with exactly the
    same name by applying the `setter` attribute of the originally decorated `foo`
    method! The `property` function returns an object; this object always comes with
    its own `setter` attribute, which can then be applied as a decorator to other
    functions. Using the same name for the get and set methods is not required, but
    it does help group the multiple methods that access one property together.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法看起来很奇怪，尽管意图是明显的。首先，我们将`foo`方法装饰为获取器。然后，我们通过应用最初装饰的`foo`方法的`setter`属性，装饰第二个同名方法！`property`函数返回一个对象；这个对象总是带有自己的`setter`属性，然后可以应用为其他函数的装饰器。使用相同的名称来命名获取和设置方法并不是必需的，但它确实有助于将访问一个属性的多个方法分组在一起。
- en: We can also specify a deletion function with `@foo.deleter`. We cannot specify
    a docstring using `property` decorators, so we need to rely on the property copying
    the docstring from the initial getter method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`@foo.deleter`指定删除函数。我们不能使用`property`装饰器指定文档字符串，因此我们需要依赖属性从初始获取方法复制文档字符串。
- en: 'Here''s our previous `Silly` class rewritten to use `property` as a decorator:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前的`Silly`类重写，使用`property`作为装饰器：
- en: '[PRE17]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This class operates *exactly* the same as our earlier version, including the
    help text. You can use whichever syntax you feel is more readable and elegant.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的操作*完全*与我们之前的版本相同，包括帮助文本。您可以使用您认为更可读和优雅的任何语法。
- en: Deciding when to use properties
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定何时使用属性
- en: With the property built-in clouding the division between behavior and data,
    it can be confusing to know which one to choose. The example use case we saw earlier
    is one of the most common uses of properties; we have some data on a class that
    we later want to add behavior to. There are also other factors to take into account
    when deciding to use a property.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 随着内置属性模糊了行为和数据之间的界限，很难知道该选择哪一个。我们之前看到的示例用例是属性最常见的用法之一；我们在类上有一些数据，然后希望添加行为。在决定使用属性时，还有其他因素需要考虑。
- en: Technically, in Python, data, properties, and methods are all attributes on
    a class. The fact that a method is callable does not distinguish it from other
    types of attributes; indeed, we'll see in [Chapter 7](ch07.html "Chapter 7. Python
    Object-oriented Shortcuts"), *Python Object-oriented Shortcuts*, that it is possible
    to create normal objects that can be called like functions. We'll also discover
    that functions and methods are themselves normal objects.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，数据、属性和方法在类上都是属性。方法可调用的事实并不能将其与其他类型的属性区分开；事实上，我们将在[第7章](ch07.html "第7章。Python面向对象的快捷方式")中看到，*Python面向对象的快捷方式*，可以创建可以像函数一样被调用的普通对象。我们还将发现函数和方法本身也是普通对象。
- en: The fact that methods are just callable attributes, and properties are just
    customizable attributes can help us make this decision. Methods should typically
    represent actions; things that can be done to, or performed by, the object. When
    you call a method, even with only one argument, it should *do* something. Method
    names are generally verbs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法只是可调用的属性，属性只是可定制的属性，这一事实可以帮助我们做出这个决定。方法通常应该表示动作；可以对对象进行的或由对象执行的事情。当调用一个方法时，即使只有一个参数，它也应该*做*一些事情。方法名称通常是动词。
- en: Once confirming that an attribute is not an action, we need to decide between
    standard data attributes and properties. In general, always use a standard attribute
    until you need to control access to that property in some way. In either case,
    your attribute is usually a noun. The only difference between an attribute and
    a property is that we can invoke custom actions automatically when a property
    is retrieved, set, or deleted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 确认属性不是一个动作后，我们需要在标准数据属性和属性之间做出决定。通常情况下，除非需要以某种方式控制对该属性的访问，否则始终使用标准属性。在任何情况下，您的属性通常是一个名词。属性和属性之间唯一的区别在于，当检索、设置或删除属性时，我们可以自动调用自定义操作。
- en: Let's look at a more realistic example. A common need for custom behavior is
    caching a value that is difficult to calculate or expensive to look up (requiring,
    for example, a network request or database query). The goal is to store the value
    locally to avoid repeated calls to the expensive calculation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更现实的例子。自定义行为的常见需求是缓存难以计算或昂贵的查找（例如需要网络请求或数据库查询）的值。目标是将值存储在本地，以避免重复调用昂贵的计算。
- en: 'We can do this with a custom getter on the property. The first time the value
    is retrieved, we perform the lookup or calculation. Then we could locally cache
    the value as a private attribute on our object (or in dedicated caching software),
    and the next time the value is requested, we return the stored data. Here''s how
    we might cache a web page:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过属性上的自定义getter来实现这一点。第一次检索值时，我们执行查找或计算。然后我们可以将值作为对象的私有属性（或专用缓存软件中）进行本地缓存，下次请求值时，我们返回存储的数据。以下是我们如何缓存网页：
- en: '[PRE18]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can test this code to see that the page is only retrieved once:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试这段代码，以确保页面只被检索一次：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I was on an awful satellite connection when I originally tested this code and
    it took 20 seconds the first time I loaded the content. The second time, I got
    the result in 2 seconds (which is really just the amount of time it took to type
    the lines into the interpreter).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当我最初测试这段代码时，我使用的是糟糕的卫星连接，第一次加载内容花了20秒。第二次，我在2秒内得到了结果（这实际上只是我在解释器中输入这些行所花费的时间）。
- en: 'Custom getters are also useful for attributes that need to be calculated on
    the fly, based on other object attributes. For example, we might want to calculate
    the average for a list of integers:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义getter对于需要根据其他对象属性动态计算的属性也很有用。例如，我们可能想要计算整数列表的平均值：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This very simple class inherits from `list`, so we get list-like behavior for
    free. We just add a property to the class, and presto, our list can have an average:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的类继承自`list`，因此我们可以免费获得类似列表的行为。我们只需向类添加一个属性，然后，我们的列表就可以有一个平均值：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Of course, we could have made this a method instead, but then we should call
    it `calculate_average()`, since methods represent actions. But a property called
    `average` is more suitable, both easier to type, and easier to read.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以将其制作成一个方法，但那么我们应该将其命名为`calculate_average()`，因为方法表示动作。但是名为`average`的属性更合适，既更容易输入，也更容易阅读。
- en: Custom setters are useful for validation, as we've already seen, but they can
    also be used to proxy a value to another location. For example, we could add a
    content setter to the `WebPage` class that automatically logs into our web server
    and uploads a new page whenever the value is set.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义setter对于验证是有用的，正如我们已经看到的，但它们也可以用于将值代理到另一个位置。例如，我们可以为`WebPage`类添加一个内容setter，以便在设置值时自动登录到我们的Web服务器并上传新页面。
- en: Manager objects
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理对象
- en: 'We''ve been focused on objects and their attributes and methods. Now, we''ll
    take a look at designing higher-level objects: the kinds of objects that manage
    other objects. The objects that tie everything together.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直专注于对象及其属性和方法。现在，我们将看看如何设计更高级的对象：管理其他对象的对象。将一切联系在一起的对象。
- en: The difference between these objects and most of the examples we've seen so
    far is that our examples tend to represent concrete ideas. Management objects
    are more like office managers; they don't do the actual "visible" work out on
    the floor, but without them, there would be no communication between departments
    and nobody would know what they are supposed to do (although, this can be true
    anyway if the organization is badly managed!). Analogously, the attributes on
    a management class tend to refer to other objects that do the "visible" work;
    the behaviors on such a class delegate to those other classes at the right time,
    and pass messages between them.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象与我们迄今为止看到的大多数示例的不同之处在于，我们的示例倾向于代表具体的想法。管理对象更像办公室经理；他们不在现场做实际的“可见”工作，但没有他们，部门之间就没有沟通，也没有人知道他们应该做什么（尽管，如果组织管理不善，这也可能是真的！）。类上的属性倾向于引用其他执行“可见”工作的对象；这样一个类上的行为在适当的时候委托给这些其他类，并在它们之间传递消息。
- en: 'As an example, we''ll write a program that does a find and replace action for
    text files stored in a compressed ZIP file. We''ll need objects to represent the
    ZIP file and each individual text file (luckily, we don''t have to write these
    classes, they''re available in the Python standard library). The manager object
    will be responsible for ensuring three steps occur in order:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将编写一个程序，对存储在压缩ZIP文件中的文本文件执行查找和替换操作。我们需要创建对象来表示ZIP文件和每个单独的文本文件（幸运的是，我们不必编写这些类，它们在Python标准库中可用）。管理对象将负责确保按顺序执行三个步骤：
- en: Unzipping the compressed file.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解压缩压缩文件。
- en: Performing the find and replace action.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行查找和替换操作。
- en: Zipping up the new files.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 压缩新文件。
- en: 'The class is initialized with the `.zip` filename and search and replace strings.
    We create a temporary directory to store the unzipped files in, so that the folder
    stays clean. The Python 3.4 `pathlib` library helps out with file and directory
    manipulation. We''ll learn more about that in [Chapter 8](ch08.html "Chapter 8. Strings
    and Serialization"), *Strings and Serialization*, but the interface should be
    pretty clear in the following example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 该类使用“.zip”文件名和搜索和替换字符串进行初始化。我们创建一个临时目录来存储解压后的文件，以保持文件夹的清洁。Python 3.4的“pathlib”库在文件和目录操作方面提供帮助。我们将在[第8章](ch08.html
    "第8章。字符串和序列化")中了解更多相关信息，但在下面的示例中，接口应该是相当清晰的：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we create an overall "manager" method for each of the three steps. This
    method delegates responsibility to other methods. Obviously, we could do all three
    steps in one method, or indeed, in one script without ever creating an object.
    There are several advantages to separating the three steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为三个步骤创建一个整体的“管理器”方法。这个方法将责任委托给其他方法。显然，我们可以在一个方法中完成所有三个步骤，或者在一个脚本中完成所有三个步骤而不创建对象。将三个步骤分开有几个优点：
- en: '**Readability**: The code for each step is in a self-contained unit that is
    easy to read and understand. The method names describe what the method does, and
    less additional documentation is required to understand what is going on.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可读性**：每个步骤的代码都是一个独立的单元，易于阅读和理解。方法名称描述了方法的功能，不需要太多额外的文档来理解发生了什么。'
- en: '**Extensibility**: If a subclass wanted to use compressed TAR files instead
    of ZIP files, it could override the `zip` and `unzip` methods without having to
    duplicate the `find_replace` method.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：如果子类想要使用压缩的TAR文件而不是ZIP文件，它可以重写“zip”和“unzip”方法，而无需复制“find_replace”方法。'
- en: '**Partitioning**: An external class could create an instance of this class
    and call the `find_replace` method directly on some folder without having to `zip`
    the content.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分区**：外部类可以创建此类的实例，并直接在某个文件夹上调用“find_replace”方法，而无需对内容进行“zip”。'
- en: 'The delegation method is the first in the following code; the rest of the methods
    are included for completeness:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 委托方法是以下代码中的第一个；其他方法包括在内是为了完整性：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: For brevity, the code for zipping and unzipping files is sparsely documented.
    Our current focus is on object-oriented design; if you are interested in the inner
    details of the `zipfile` module, refer to the documentation in the standard library,
    either online or by typing `import zipfile ; help(zipfile)` into your interactive
    interpreter. Note that this example only searches the top-level files in a ZIP
    file; if there are any folders in the unzipped content, they will not be scanned,
    nor will any files inside those folders.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为简洁起见，压缩和解压文件的代码文档很少。我们目前的重点是面向对象的设计；如果您对“zipfile”模块的内部细节感兴趣，请参考标准库中的文档，可以在线查看，也可以在交互式解释器中键入“import
    zipfile；help(zipfile)”来查看。请注意，此示例仅搜索ZIP文件中的顶层文件；如果解压后的内容中有任何文件夹，它们将不会被扫描，也不会扫描这些文件夹中的任何文件。
- en: 'The last two lines in the example allow us to run the program from the command
    line by passing the `zip` filename, search string, and replace string as arguments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后两行允许我们通过传递“zip”文件名、搜索字符串和替换字符串作为参数从命令行运行程序：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Of course, this object does not have to be created from the command line; it
    could be imported from another module (to perform batch ZIP file processing) or
    accessed as part of a GUI interface or even a higher-level management object that
    knows where to get ZIP files (for example, to retrieve them from an FTP server
    or back them up to an external disk).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个对象不一定要从命令行创建；它可以从另一个模块中导入（用于执行批量ZIP文件处理），或者作为GUI界面的一部分访问，甚至可以作为一个高级管理对象的一部分，该对象知道从哪里获取ZIP文件（例如，从FTP服务器检索它们或将它们备份到外部磁盘）。
- en: As programs become more and more complex, the objects being modeled become less
    and less like physical objects. Properties are other abstract objects and methods
    are actions that change the state of those abstract objects. But at the heart
    of every object, no matter how complex, is a set of concrete properties and well-defined
    behaviors.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随着程序变得越来越复杂，被建模的对象变得越来越不像物理对象。属性是其他抽象对象，方法是改变这些抽象对象状态的动作。但是，无论多么复杂，每个对象的核心都是一组具体的属性和明确定义的行为。
- en: Removing duplicate code
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除重复的代码
- en: Often the code in management style classes such as `ZipReplace` is quite generic
    and can be applied in a variety of ways. It is possible to use either composition
    or inheritance to help keep this code in one place, thus eliminating duplicate
    code. Before we look at any examples of this, let's discuss a tiny bit of theory.
    Specifically, why is duplicate code a bad thing?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 管理风格类中的代码，比如`ZipReplace`，通常是非常通用的，可以以多种方式应用。可以使用组合或继承来帮助将代码放在一个地方，从而消除重复代码。在我们看任何示例之前，让我们讨论一点理论。具体来说，为什么重复的代码是一件坏事？
- en: There are several reasons, but they all boil down to readability and maintainability.
    When we're writing a new piece of code that is similar to an earlier piece, the
    easiest thing to do is copy the old code and change whatever needs to be changed
    (variable names, logic, comments) to make it work in the new location. Alternatively,
    if we're writing new code that seems similar, but not identical to code elsewhere
    in the project, it is often easier to write fresh code with similar behavior,
    rather than figure out how to extract the overlapping functionality.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因，但它们都归结为可读性和可维护性。当我们编写一个与早期代码类似的新代码时，最容易的方法是复制旧代码，并更改需要更改的内容（变量名、逻辑、注释），使其在新位置上运行。或者，如果我们正在编写似乎类似但不完全相同于项目中其他地方的代码，通常更容易编写具有类似行为的新代码，而不是弄清楚如何提取重叠的功能。
- en: But as soon as someone has to read and understand the code and they come across
    duplicate blocks, they are faced with a dilemma. Code that might have made sense
    suddenly has to be understood. How is one section different from the other? How
    are they the same? Under what conditions is one section called? When do we call
    the other? You might argue that you're the only one reading your code, but if
    you don't touch that code for eight months it will be as incomprehensible to you
    as it is to a fresh coder. When we're trying to read two similar pieces of code,
    we have to understand why they're different, as well as how they're different.
    This wastes the reader's time; code should always be written to be readable first.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦有人阅读和理解代码，并且遇到重复的代码块，他们就会面临两难境地。可能有意义的代码突然需要被理解。一个部分与另一个部分有何不同？它们又有何相同之处？在什么条件下调用一个部分？我们什么时候调用另一个部分？你可能会说你是唯一阅读你的代码的人，但是如果你八个月不碰那段代码，它对你来说将会和对一个新手编程者一样难以理解。当我们试图阅读两个相似的代码片段时，我们必须理解它们为何不同，以及它们如何不同。这浪费了读者的时间；代码应该始终以可读性为首要考虑因素。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I once had to try to understand someone's code that had three identical copies
    of the same 300 lines of very poorly written code. I had been working with the
    code for a month before I finally comprehended that the three "identical" versions
    were actually performing slightly different tax calculations. Some of the subtle
    differences were intentional, but there were also obvious areas where someone
    had updated a calculation in one function without updating the other two. The
    number of subtle, incomprehensible bugs in the code could not be counted. I eventually
    replaced all 900 lines with an easy-to-read function of 20 lines or so.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我曾经不得不尝试理解某人的代码，其中有三个相同的副本，每个副本都有300行非常糟糕的代码。在我终于理解这三个“相同”的版本实际上执行略有不同的税收计算之前，我已经与这段代码一起工作了一个月。一些微妙的差异是有意的，但也有明显的地方，某人在一个函数中更新了一个计算而没有更新其他两个函数。代码中微妙而难以理解的错误数不胜数。最终，我用大约20行易于阅读的函数替换了所有900行。
- en: Reading such duplicate code can be tiresome, but code maintenance is even more
    tormenting. As the preceding story suggests, keeping two similar pieces of code
    up to date can be a nightmare. We have to remember to update both sections whenever
    we update one of them, and we have to remember how the multiple sections differ
    so we can modify our changes when we are editing each of them. If we forget to
    update both sections, we will end up with extremely annoying bugs that usually
    manifest themselves as, "but I fixed that already, why is it still happening?"
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这样的重复代码可能很烦人，但代码维护更加痛苦。正如前面的故事所示，保持两个相似的代码片段更新可能是一场噩梦。每当我们更新其中一个部分时，我们必须记住同时更新两个部分，并且必须记住多个部分的不同之处，以便在编辑每个部分时修改我们的更改。如果我们忘记更新两个部分，我们最终会遇到极其恼人的错误，通常表现为“但我已经修复过了，为什么还会发生？”
- en: The result is that people who are reading or maintaining our code have to spend
    astronomical amounts of time understanding and testing it compared to if we had
    written the code in a nonrepetitive manner in the first place. It's even more
    frustrating when we are the ones doing the maintenance; we find ourselves saying,
    "why didn't I do this right the first time?" The time we save by copy-pasting
    existing code is lost the very first time we have to maintain it. Code is both
    read and modified many more times and much more often than it is written. Comprehensible
    code should always be paramount.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，阅读或维护我们的代码的人必须花费天文数字般的时间来理解和测试它，与我们一开始就以非重复的方式编写代码相比。当我们自己进行维护时，这甚至更加令人沮丧；我们会发现自己说：“为什么我第一次就没做对呢？”通过复制粘贴现有代码节省的时间在第一次进行维护时就丢失了。代码被阅读和修改的次数比编写的次数要多得多，而且频率也更高。可理解的代码应该始终是最重要的。
- en: This is why programmers, especially Python programmers (who tend to value elegant
    code more than average), follow what is known as the **Don't Repeat Yourself**
    (**DRY**) principle. DRY code is maintainable code. My advice to beginning programmers
    is to never use the copy and paste feature of their editor. To intermediate programmers,
    I suggest they think thrice before they hit *Ctrl* + *C*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么程序员，尤其是Python程序员（他们倾向于比平均水平更重视优雅的代码），遵循所谓的“不要重复自己”（DRY）原则。DRY代码是可维护的代码。我给初学者的建议是永远不要使用编辑器的复制粘贴功能。对于中级程序员，我建议他们在按下*Ctrl*
    + *C*之前三思。
- en: But what should we do instead of code duplication? The simplest solution is
    often to move the code into a function that accepts parameters to account for
    whatever parts are different. This isn't a terribly object-oriented solution,
    but it is frequently optimal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们应该怎么做，而不是重复编码？最简单的解决方案通常是将代码移入一个函数中，该函数接受参数以考虑不同的部分。这并不是一个非常面向对象的解决方案，但通常是最佳的。
- en: For example, if we have two pieces of code that unzip a ZIP file into two different
    directories, we can easily write a function that accepts a parameter for the directory
    to which it should be unzipped instead. This may make the function itself slightly
    more difficult to read, but a good function name and docstring can easily make
    up for that, and any code that invokes the function will be easier to read.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有两段代码，它们将ZIP文件解压缩到两个不同的目录中，我们可以很容易地编写一个函数，该函数接受一个参数，用于指定应将其解压缩到的目录。这可能会使函数本身稍微难以阅读，但一个好的函数名称和文档字符串很容易弥补这一点，任何调用该函数的代码都将更容易阅读。
- en: 'That''s certainly enough theory! The moral of the story is: always make the
    effort to refactor your code to be easier to read instead of writing bad code
    that is only easier to write.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就足够的理论了！故事的寓意是：始终努力重构代码，使其更易于阅读，而不是编写只是更易于编写的糟糕代码。
- en: In practice
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实践中
- en: Let's explore two ways we can reuse existing code. After writing our code to
    replace strings in a ZIP file full of text files, we are later contracted to scale
    all the images in a ZIP file to 640 x 480\. Looks like we could use a very similar
    paradigm to what we used in `ZipReplace`. The first impulse might be to save a
    copy of that file and change the `find_replace` method to `scale_image` or something
    similar.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨两种重用现有代码的方法。在编写代码以替换ZIP文件中的文本文件中的字符串后，我们后来又被承包商要求将ZIP文件中的所有图像缩放到640 x 480。看起来我们可以使用与`ZipReplace`中使用的非常相似的范例。第一个冲动可能是保存该文件的副本，并将`find_replace`方法更改为`scale_image`或类似的内容。
- en: But, that's uncool. What if someday we want to change the `unzip` and `zip`
    methods to also open TAR files? Or maybe we want to use a guaranteed unique directory
    name for temporary files. In either case, we'd have to change it in two different
    places!
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，这样做并不酷。如果有一天我们想要将`unzip`和`zip`方法更改为也能打开TAR文件呢？或者也许我们想要为临时文件使用一个保证唯一的目录名称。在任何一种情况下，我们都必须在两个不同的地方进行更改！
- en: 'We''ll start by demonstrating an inheritance-based solution to this problem.
    First we''ll modify our original `ZipReplace` class into a superclass for processing
    generic ZIP files:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先演示基于继承的解决方案来解决这个问题。首先，我们将修改我们原来的`ZipReplace`类，将其改为一个用于处理通用ZIP文件的超类：
- en: '[PRE25]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We changed the `filename` property to `zipname` to avoid confusion with the
    `filename` local variables inside the various methods. This helps make the code
    more readable even though it isn't actually a change in design.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`filename`属性更改为`zipname`，以避免与各种方法内的`filename`局部变量混淆。尽管这实际上并不是一种设计上的改变，但这有助于使代码更易读。
- en: We also dropped the two parameters to `__init__` (`search_string` and `replace_string`)
    that were specific to `ZipReplace`. Then we renamed the `zip_find_replace` method
    to `process_zip` and made it call an (as yet undefined) `process_files` method
    instead of `find_replace`; these name changes help demonstrate the more generalized
    nature of our new class. Notice that we have removed the `find_replace` method
    altogether; that code is specific to `ZipReplace` and has no business here.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还删除了`__init__`中的两个参数（`search_string`和`replace_string`），这些参数是特定于`ZipReplace`的。然后我们将`zip_find_replace`方法重命名为`process_zip`，并让它调用一个（尚未定义的）`process_files`方法，而不是`find_replace`；这些名称更改有助于展示我们新类的更一般化特性。请注意，我们已经完全删除了`find_replace`方法；该代码是特定于`ZipReplace`，在这里没有任何业务。
- en: This new `ZipProcessor` class doesn't actually define a `process_files` method;
    so if we ran it directly, it would raise an exception. Because it isn't meant
    to run directly, we removed the main call at the bottom of the original script.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的`ZipProcessor`类实际上并没有定义`process_files`方法；因此，如果我们直接运行它，它将引发异常。因为它不是直接运行的，我们在原始脚本的底部删除了主调用。
- en: 'Now, before we move on to our image processing app, let''s fix up our original
    `zipsearch` class to make use of this parent class:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们继续进行图像处理应用程序之前，让我们修复原始的`zipsearch`类，以利用这个父类：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This code is a bit shorter than the original version, since it inherits its
    ZIP processing abilities from the parent class. We first import the base class
    we just wrote and make `ZipReplace` extend that class. Then we use `super()` to
    initialize the parent class. The `find_replace` method is still here, but we renamed
    it to `process_files` so the parent class can call it from its management interface.
    Because this name isn't as descriptive as the old one, we added a docstring to
    describe what it is doing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码比原始版本要短一些，因为它继承了它的ZIP处理能力。我们首先导入我们刚刚编写的基类，并使`ZipReplace`扩展该类。然后我们使用`super()`来初始化父类。`find_replace`方法仍然在这里，但我们将其重命名为`process_files`，以便父类可以从其管理接口调用它。因为这个名称不像旧名称那样描述性强，我们添加了一个文档字符串来描述它正在做什么。
- en: Now, that was quite a bit of work, considering that all we have now is a program
    that is functionally not different from the one we started with! But having done
    that work, it is now much easier for us to write other classes that operate on
    files in a ZIP archive, such as the (hypothetically requested) photo scaler. Further,
    if we ever want to improve or bug fix the zip functionality, we can do it for
    all classes by changing only the one `ZipProcessor` base class. Maintenance will
    be much more effective.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑到我们现在所做的工作量相当大，而我们所拥有的程序在功能上与我们开始时的程序并无不同！但是经过这样的工作，我们现在更容易编写其他操作ZIP存档文件的类，比如（假设请求的）照片缩放器。此外，如果我们想要改进或修复ZIP功能，我们只需更改一个`ZipProcessor`基类，就可以对所有类进行操作。维护将更加有效。
- en: 'See how simple it is now to create a photo scaling class that takes advantage
    of the `ZipProcessor` functionality. (Note: this class requires the third-party
    `pillow` library to get the `PIL` module. You can install it with `pip install
    pillow`.)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看看现在创建一个利用“ZipProcessor”功能的照片缩放类是多么简单。（注意：这个类需要第三方的“pillow”库来获取“PIL”模块。你可以用“pip
    install pillow”来安装它。）
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Look how simple this class is! All that work we did earlier paid off. All we
    do is open each file (assuming that it is an image; it will unceremoniously crash
    if a file cannot be opened), scale it, and save it back. The `ZipProcessor` class
    takes care of the zipping and unzipping without any extra work on our part.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个类是多么简单！我们之前做的所有工作都得到了回报。我们只需要打开每个文件（假设它是一个图像；如果无法打开文件，它将会崩溃），对其进行缩放，然后保存。`ZipProcessor`类会在我们不做任何额外工作的情况下处理压缩和解压缩。
- en: Case study
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: For this case study, we'll try to delve further into the question, "when should
    I choose an object versus a built-in type?" We'll be modeling a `Document` class
    that might be used in a text editor or word processor. What objects, functions,
    or properties should it have?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例研究，我们将尝试进一步探讨这个问题，“何时应该选择对象而不是内置类型？”我们将建模一个可能在文本编辑器或文字处理器中使用的“文档”类。它应该有什么对象、函数或属性？
- en: We might start with a `str` for the `Document` contents, but in Python, strings
    aren't mutable (able to be changed). Once a `str` is defined, it is forever. We
    can't insert a character into it or remove one without creating a brand new string
    object. That would be leaving a lot of `str` objects taking up memory until Python's
    garbage collector sees fit to clean up behind us.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会从`str`开始，用于“文档”内容，但在Python中，字符串是不可变的。一旦定义了一个`str`，它就永远存在。我们无法在其中插入字符或删除字符，而不创建一个全新的字符串对象。这将导致大量的`str`对象占用内存，直到Python的垃圾收集器决定在我们身后清理它们。
- en: So, instead of a string, we'll use a list of characters, which we can modify
    at will. In addition, a `Document` class would need to know the current cursor
    position within the list, and should probably also store a filename for the document.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将使用字符列表而不是字符串，这样我们可以随意修改它。此外，“文档”类需要知道列表中的当前光标位置，并且可能还应该存储文档的文件名。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Real text editors use a binary-tree based data structure called a `rope` to
    model their document contents. This book's title isn't "advanced data structures",
    so if you're interested in learning more about this fascinating topic, you may
    want to search the web for the rope data structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的文本编辑器使用基于二叉树的数据结构称为“绳索”来模拟它们的文档内容。这本书的标题不是“高级数据结构”，所以如果你对这个迷人的主题感兴趣，你可能想在网上搜索绳索数据结构。
- en: Now, what methods should it have? There are a lot of things we might want to
    do to a text document, including inserting, deleting, and selecting characters,
    cut, copy, paste, the selection, and saving or closing the document. It looks
    like there are copious amounts of both data and behavior, so it makes sense to
    put all this stuff into its own `Document` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它应该有什么方法？我们可能想对文本文档做很多事情，包括插入、删除和选择字符，剪切、复制、粘贴、选择和保存或关闭文档。看起来有大量的数据和行为，所以把所有这些东西放到自己的“文档”类中是有道理的。
- en: 'A pertinent question is: should this class be composed of a bunch of basic
    Python objects such as `str` filenames, `int` cursor positions, and a `list` of
    characters? Or should some or all of those things be specially defined objects
    in their own right? What about individual lines and characters, do they need to
    have classes of their own?'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的问题是：这个类应该由一堆基本的Python对象组成，比如`str`文件名、`int`光标位置和字符的`list`？还是这些东西中的一些或全部应该是专门定义的对象？那么单独的行和字符呢，它们需要有自己的类吗？
- en: 'We''ll answer these questions as we go, but let''s start with the simplest
    possible `Document` class first and see what it can do:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在进行时回答这些问题，但让我们先从最简单的“文档”类开始，看看它能做什么：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This simple class allows us full control over editing a basic document. Have
    a look at it in action:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的类允许我们完全控制编辑基本文档。看看它的运行情况：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Looks like it's working. We could connect a keyboard's letter and arrow keys
    to these methods and the document would track everything just fine.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来它正在工作。我们可以把键盘的字母和箭头键连接到这些方法，文档会很好地跟踪一切。
- en: 'But what if we want to connect more than just arrow keys. What if we want to
    connect the *Home* and *End* keys as well? We could add more methods to the `Document`
    class that search forward or backwards for newline characters (in Python, a newline
    character, or `\n` represents the end of one line and the beginning of a new one)
    in the string and jump to them, but if we did that for every possible movement
    action (move by words, move by sentences, *Page Up*, *Page Down*, end of line,
    beginning of whitespace, and more), the class would be huge. Maybe it would be
    better to put those methods on a separate object. So, let us turn the cursor attribute
    into an object that is aware of its position and can manipulate that position.
    We can move the forward and back methods to that class, and add a couple more
    for the *Home* and *End* keys:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们想连接的不仅仅是箭头键。如果我们还想连接“Home”和“End”键怎么办？我们可以在“文档”类中添加更多的方法，用于在字符串中向前或向后搜索换行符（在Python中，换行符或`\n`表示一行的结束和新行的开始），但如果我们为每个可能的移动操作（按单词移动、按句子移动、*Page
    Up*、*Page Down*、行尾、空白开始等）都这样做，这个类会很庞大。也许把这些方法放在一个单独的对象上会更好。因此，让我们把光标属性转换为一个对象，它知道自己的位置并可以操纵该位置。我们可以将向前和向后的方法移到该类中，并为“Home”和“End”键添加几个方法：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This class takes the document as an initialization parameter so the methods
    have access to the content of the document's character list. It then provides
    simple methods for moving backwards and forwards, as before, and for moving to
    the `home` and `end` positions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将文档作为初始化参数，因此方法可以访问文档字符列表的内容。然后，它提供了简单的方法来向前和向后移动，以及移动到“home”和“end”位置。
- en: Tip
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: This code is not very safe. You can very easily move past the ending position,
    and if you try to go home on an empty file, it will crash. These examples are
    kept short to make them readable, but that doesn't mean they are defensive! You
    can improve the error checking of this code as an exercise; it might be a great
    opportunity to expand your exception handling skills.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码并不是很安全。你很容易就能超出结束位置，如果你试图在一个空文件上回家，它会崩溃。这些例子被保持短小是为了让它们易读，但这并不意味着它们是防御性的！你可以通过练习来改进这段代码的错误检查；这可能是一个扩展你异常处理技能的绝佳机会。
- en: 'The `Document` class itself is hardly changed, except for removing the two
    methods that were moved to the `Cursor` class:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Document` 类本身几乎没有改变，除了移动到 `Cursor` 类的两个方法：'
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We simply updated anything that accessed the old cursor integer to use the
    new object instead. We can test that the `home` method is really moving to the
    newline character:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需更新任何访问旧光标整数的内容，以使用新对象。我们可以测试 `home` 方法是否真的移动到换行符：
- en: '[PRE32]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, since we''ve been using that string `join` function a lot (to concatenate
    the characters so we can see the actual document contents), we can add a property
    to the `Document` class to give us the complete string:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们一直在使用字符串 `join` 函数（将字符连接起来以便查看实际文档内容），我们可以在 `Document` 类中添加一个属性来给出完整的字符串：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This makes our testing a little simpler:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的测试变得更简单：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This framework is simple (though it might be a bit time consuming!) to extend
    to create and edit a complete plaintext document. Now, let's extend it to work
    for rich text; text that can have **bold**, underlined, or *italic* characters.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个框架很简单（尽管可能有点耗时！）扩展到创建和编辑完整的纯文本文档。现在，让我们扩展它以便适用于富文本；可以有**粗体**、下划线或*斜体*字符的文本。
- en: There are two ways we could process this; the first is to insert "fake" characters
    into our character list that act like instructions, such as "bold characters until
    you find a stop bold character". The second is to add information to each character
    indicating what formatting it should have. While the former method is probably
    more common, we'll implement the latter solution. To do that, we're obviously
    going to need a class for characters. This class will have an attribute representing
    the character, as well as three Boolean attributes representing whether it is
    bold, italic, or underlined.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有两种方法来处理这个问题；第一种是在我们的字符列表中插入“假”字符，它们像指令一样起作用，比如“粗体字符直到找到一个停止粗体字符”。第二种是为每个字符添加指示其格式的信息。虽然前一种方法可能更常见，但我们将实现后一种解决方案。为此，我们显然需要一个字符类。这个类将有一个表示字符的属性，以及三个布尔属性，表示它是否是粗体、斜体或下划线。
- en: Hmm, wait! Is this `Character` class going to have any methods? If not, maybe
    we should use one of the many Python data structures instead; a tuple or named
    tuple would probably be sufficient. Are there any actions that we would want to
    do to, or invoke on a character?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，等等！这个 `Character` 类会有任何方法吗？如果没有，也许我们应该使用 Python 的许多数据结构之一；元组或命名元组可能就足够了。有没有我们想对字符执行的操作？
- en: Well, clearly, we might want to do things with characters, such as delete or
    copy them, but those are things that need to be handled at the `Document` level,
    since they are really modifying the list of characters. Are there things that
    need to be done to individual characters?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们可能想对字符执行一些操作，比如删除或复制它们，但这些是需要在 `Document` 级别处理的事情，因为它们实际上是在修改字符列表。有没有需要对单个字符执行的操作？
- en: Actually, now that we're thinking about what a `Character` class actually is...
    what is it? Would it be safe to say that a `Character` class is a string? Maybe
    we should use an inheritance relationship here? Then we can take advantage of
    the numerous methods that `str` instances come with.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，既然我们在思考 `Character` 类实际上是什么...它是什么？能不能说 `Character` 类是一个字符串？也许我们应该在这里使用继承关系？然后我们就可以利用
    `str` 实例带来的众多方法。
- en: What sorts of methods are we talking about? There's `startswith`, `strip`, `find`,
    `lower`, and many more. Most of these methods expect to be working on strings
    that contain more than one character. In contrast, if `Character` were to subclass
    `str`, we'd probably be wise to override `__init__` to raise an exception if a
    multi-character string were supplied. Since all those methods we'd get for free
    wouldn't really apply to our `Character` class, it seems we needn't use inheritance,
    after all.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在谈论什么样的方法？有 `startswith`、`strip`、`find`、`lower` 等等。这些方法中的大多数都希望在包含多个字符的字符串上工作。相比之下，如果
    `Character` 是 `str` 的子类，我们可能最好重写 `__init__` 来在提供多字符字符串时引发异常。由于我们免费获得的所有这些方法实际上并不适用于我们的
    `Character` 类，看来我们毋需使用继承。
- en: 'This brings us back to our original question; should `Character` even be a
    class? There is a very important special method on the `object` class that we
    can take advantage of to represent our characters. This method, called `__str__`
    (two underscores, like `__init_`_), is used in string manipulation functions like
    `print` and the `str` constructor to convert any class to a string. The default
    implementation does some boring stuff like printing the name of the module and
    class and its address in memory. But if we override it, we can make it print whatever
    we like. For our implementation, we could make it prefix characters with special
    characters to represent whether they are bold, italic, or underlined. So, we will
    create a class to represent a character, and here it is:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们回到了最初的问题；`Character` 是否应该是一个类？`object` 类上有一个非常重要的特殊方法，我们可以利用它来表示我们的字符。这个方法叫做
    `__str__`（两个下划线，像 `__init__` 一样），它在字符串操作函数中使用，比如 `print` 和 `str` 构造函数，将任何类转换为字符串。默认实现做了一些无聊的事情，比如打印模块和类的名称以及它在内存中的地址。但如果我们重写它，我们可以让它打印任何我们喜欢的东西。对于我们的实现，我们可以让它用特殊字符前缀字符，表示它们是否是粗体、斜体或下划线。因此，我们将创建一个表示字符的类，就是这样：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This class allows us to create characters and prefix them with a special character
    when the `str()` function is applied to them. Nothing too exciting there. We only
    have to make a few minor modifications to the `Document` and `Cursor` classes
    to work with this class. In the `Document` class, we add these two lines at the
    beginning of the `insert` method:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类允许我们创建字符，并在应用`str()`函数时在它们前面加上一个特殊字符。没有太多激动人心的地方。我们只需要对`Document`和`Cursor`类进行一些小的修改，以便与这个类一起工作。在`Document`类中，我们在`insert`方法的开头添加了这两行：
- en: '[PRE36]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is a rather strange bit of code. Its basic purpose is to check whether
    the character being passed in is a `Character` or a `str`. If it is a string,
    it is wrapped in a `Character` class so all objects in the list are `Character`
    objects. However, it is entirely possible that someone using our code would want
    to use a class that is neither `Character` nor string, using duck typing. If the
    object has a character attribute, we assume it is a "`Character`-like" object.
    But if it does not, we assume it is a "`str`-like" object and wrap it in `Character`.
    This helps the program take advantage of duck typing as well as polymorphism;
    as long as an object has a character attribute, it can be used in the `Document`
    class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一段相当奇怪的代码。它的基本目的是检查传入的字符是`Character`还是`str`。如果是字符串，它将被包装在`Character`类中，以便列表中的所有对象都是`Character`对象。然而，完全有可能有人使用我们的代码想要使用既不是`Character`也不是字符串的类，使用鸭子类型。如果对象有一个字符属性，我们就假设它是一个“`Character`-like”对象。但如果没有，我们就假设它是一个“`str`-like”对象，并将其包装在`Character`中。这有助于程序利用鸭子类型和多态性；只要对象有一个字符属性，它就可以在`Document`类中使用。
- en: 'This generic check could be very useful, for example, if we wanted to make
    a programmer''s editor with syntax highlighting: we''d need extra data on the
    character, such as what type of syntax token the character belongs to. Note that
    if we are doing a lot of this kind of comparison, it''s probably better to implement
    `Character` as an abstract base class with an appropriate `__subclasshook__`,
    as discussed in [Chapter 3](ch03.html "Chapter 3. When Objects Are Alike"), *When
    Objects Are Alike*.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个通用检查可能非常有用，例如，如果我们想要制作一个带有语法高亮的程序员编辑器：我们需要关于字符的额外数据，比如字符属于什么类型的语法标记。请注意，如果我们要做很多这种比较，最好实现`Character`作为一个抽象基类，并使用适当的`__subclasshook__`，如[第3章](ch03.html
    "第3章。当对象相似时")中讨论的那样，*当对象相似时*。
- en: 'In addition, we need to modify the string property on `Document` to accept
    the new `Character` values. All we need to do is call `str()` on each character
    before we join it:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要修改`Document`上的字符串属性，以接受新的`Character`值。我们只需要在连接之前对每个字符调用`str()`即可：
- en: '[PRE37]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This code uses a generator expression, which we'll discuss in [Chapter 9](ch09.html
    "Chapter 9. The Iterator Pattern"), *The Iterator Pattern*. It's a shortcut to
    perform a specific action on all the objects in a sequence.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了一个生成器表达式，我们将在[第9章](ch09.html "第9章。迭代器模式")中讨论，*迭代器模式*。这是一个快捷方式，可以对序列中的所有对象执行特定的操作。
- en: 'Finally, we also need to check `Character.character`, instead of just the string
    character we were storing before, in the `home` and `end` functions when we''re
    looking to see whether it matches a newline character:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还需要检查`Character.character`，而不仅仅是我们之前存储的字符串字符，在`home`和`end`函数中，我们要查看它是否匹配换行符：
- en: '[PRE38]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This completes the formatting of characters. We can test it to see that it
    works:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了字符的格式化。我们可以测试一下，看看它是否有效：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As expected, whenever we print the string, each bold character is preceded by
    a `*` character, each italic character by a `/` character, and each underlined
    character by a `_` character. All our functions seem to work, and we can modify
    characters in the list after the fact. We have a working rich text document object
    that could be plugged into a proper user interface and hooked up with a keyboard
    for input and a screen for output. Naturally, we'd want to display real bold,
    italic, and underlined characters on the screen, instead of using our `__str__`
    method, but it was sufficient for the basic testing we demanded of it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，每当我们打印字符串时，每个粗体字符前面都有一个`*`字符，每个斜体字符前面都有一个`/`字符，每个下划线字符前面都有一个`_`字符。我们所有的函数似乎都能工作，而且我们可以在事后修改列表中的字符。我们有一个可以插入到适当的用户界面中并与键盘进行输入和屏幕进行输出的工作的富文本文档对象。当然，我们希望在屏幕上显示真正的粗体、斜体和下划线字符，而不是使用我们的`__str__`方法，但它对我们所要求的基本测试来说已经足够了。
- en: Exercises
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've looked at various ways that objects, data, and methods can interact with
    each other in an object-oriented Python program. As usual, your first thoughts
    should be how you can apply these principles to your own work. Do you have any
    messy scripts lying around that could be rewritten using an object-oriented manager?
    Look through some of your old code and look for methods that are not actions.
    If the name isn't a verb, try rewriting it as a property.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过了在面向对象的Python程序中对象、数据和方法之间可以相互交互的各种方式。和往常一样，你的第一个想法应该是如何将这些原则应用到你自己的工作中。你有没有一些混乱的脚本散落在那里，可以用面向对象的管理器重写？浏览一下你的旧代码，寻找一些不是动作的方法。如果名称不是动词，试着将其重写为属性。
- en: Think about code you've written in any language. Does it break the DRY principle?
    Is there any duplicate code? Did you copy and paste code? Did you write two versions
    of similar pieces of code because you didn't feel like understanding the original
    code? Go back over some of your recent code now and see whether you can refactor
    the duplicate code using inheritance or composition. Try to pick a project you're
    still interested in maintaining; not code so old that you never want to touch
    it again. It helps keep your interest up when you do the improvements!
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 想想你用任何语言编写的代码。它是否违反了DRY原则？是否有重复的代码？你有没有复制和粘贴代码？你是否写了两个类似代码的版本，因为你不想理解原始代码？现在回顾一下你最近的一些代码，看看是否可以使用继承或组合重构重复的代码。尝试选择一个你仍然有兴趣维护的项目；不要选择那些你再也不想碰的代码。这有助于你在进行改进时保持兴趣！
- en: Now, look back over some of the examples we saw in this chapter. Start with
    the cached web page example that uses a property to cache the retrieved data.
    An obvious problem with this example is that the cache is never refreshed. Add
    a timeout to the property's getter, and only return the cached page if the page
    has been requested before the timeout has expired. You can use the `time` module
    (`time.time() - an_old_time` returns the number of seconds that have elapsed since
    `an_old_time`) to determine whether the cache has expired.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下我们在本章中看到的一些例子。从使用属性缓存检索数据的缓存网页示例开始。这个例子的一个明显问题是缓存从未刷新过。在属性的getter中添加一个超时，只有在页面在超时到期之前已被请求时才返回缓存的页面。你可以使用`time`模块（`time.time()
    - an_old_time`返回自`an_old_time`以来经过的秒数）来确定缓存是否已过期。
- en: Now look at the inheritance-based `ZipProcessor`. It might be reasonable to
    use composition instead of inheritance here. Instead of extending the class in
    the `ZipReplace` and `ScaleZip` classes, you could pass instances of those classes
    into the `ZipProcessor` constructor and call them to do the processing part. Implement
    this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看基于继承的`ZipProcessor`。在这里使用组合而不是继承可能是合理的。在`ZipReplace`和`ScaleZip`类中，你可以将这些类的实例传递到`ZipProcessor`构造函数中，并调用它们来进行处理。实现这一点。
- en: Which version do you find easier to use? Which is more elegant? What is easier
    to read? These are subjective questions; the answer varies for each of us. Knowing
    the answer, however, is important; if you find you prefer inheritance over composition,
    you have to pay attention that you don't overuse inheritance in your daily coding.
    If you prefer composition, make sure you don't miss opportunities to create an
    elegant inheritance-based solution.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你觉得哪个版本更容易使用？哪个更优雅？哪个更容易阅读？这些都是主观问题；答案因人而异。然而，知道答案很重要；如果你发现你更喜欢继承而不是组合，你就要注意不要在日常编码中过度使用继承。如果你更喜欢组合，确保你不要错过创建优雅基于继承的解决方案的机会。
- en: Finally, add some error handlers to the various classes we created in the case
    study. They should ensure single characters are entered, that you don't try to
    move the cursor past the end or beginning of the file, that you don't delete a
    character that doesn't exist, and that you don't save a file without a filename.
    Try to think of as many edge cases as you can, and account for them (thinking
    about edge cases is about 90 percent of a professional programmer's job!) Consider
    different ways to handle them; should you raise an exception when the user tries
    to move past the end of the file, or just stay on the last character?
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们在案例研究中创建的各种类中添加一些错误处理程序。它们应该确保只输入单个字符，不要尝试将光标移动到文件的末尾或开头，不要删除不存在的字符，也不要保存没有文件名的文件。尽量考虑尽可能多的边缘情况，并对其进行处理（考虑边缘情况大约占专业程序员工作的90％！）考虑不同的处理方式；当用户尝试移动到文件末尾时，你应该引发异常，还是只停留在最后一个字符？
- en: Pay attention, in your daily coding, to the copy and paste commands. Every time
    you use them in your editor, consider whether it would be a good idea to improve
    your program's organization so that you only have one version of the code you
    are about to copy.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常编码中，注意复制和粘贴命令。每次在编辑器中使用它们时，考虑是否改进程序的组织结构，以便你只有一个即将复制的代码版本。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behavior, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality and
    inheritance and composition can be applied to reduce code duplication.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于识别对象，特别是那些不是立即显而易见的对象；管理和控制对象。对象应该既有数据又有行为，但属性可以用来模糊这两者之间的区别。DRY原则是代码质量的重要指标，继承和组合可以应用于减少代码重复。
- en: In the next chapter, we'll cover several of the built-in Python data structures
    and objects, focusing on their object-oriented properties and how they can be
    extended or adapted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍几种内置的Python数据结构和对象，重点关注它们的面向对象特性以及如何扩展或调整它们。
