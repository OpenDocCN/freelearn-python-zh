- en: Programming in ROS - Commands and Tools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ROS中进行编程 - 命令和工具
- en: This chapter focuses on running ROS within GoPiGo3\. In the previous chapter,
    we did the same for a remote laptop, and in the next chapter, we will teach you
    how to make both a robot and your laptop work together as a single ROS environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍在GoPiGo3上运行ROS。在前一章中，我们在远程笔记本电脑上做了同样的事情，在下一章中，我们将教你如何使机器人和你的笔记本电脑作为一个单一的ROS环境协同工作。
- en: 'In this chapter, you will finally learn how to use ROS in the depth required
    for the advanced chapters later on, which deal with robot navigation and machine
    learning. ROS can be hard to use at the beginning due to the following factors:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将最终学习如何使用ROS，这对于后面章节中涉及到的机器人导航和机器学习的高级内容是必需的。ROS由于以下因素在开始时可能难以使用：
- en: It is command-line-based.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是基于命令行的。
- en: It handles asynchronous events.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它处理异步事件。
- en: It is a distributed computing environment.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个分布式计算环境。
- en: Paradoxically, these are the three features that make it really powerful for
    programming robots. The  effort you've invested will be worth it, as you will
    soon discover.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 矛盾的是，这三个特性使得它对于机器人编程非常强大。你所投入的努力将值得，因为你很快就会发现的。
- en: 'By working through this chapter, you will become familiar with ROS''s command-line
    interaction and understand the scope of several types of ROS command. You will
    get used to working with the most frequently used communication pattern in ROS:
    publish-subscribe. To access real-time robot data while ROS is running, you will
    be introduced to the *rqt* GUI tools, which ease the work of developing and debugging
    an application. Additionally, ROS parameters will be introduced to give you an
    overview of their power to manage robot configuration at a high level.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习本章，你将熟悉ROS的命令行交互，并了解几种类型ROS命令的范围。你将习惯于使用ROS中最常用的通信模式：发布-订阅。为了在ROS运行时访问实时机器人数据，你将介绍*rqt*
    GUI工具，这些工具简化了应用程序的开发和调试工作。此外，还将介绍ROS参数，以给你一个关于它们在高级别管理机器人配置的强大功能的概述。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Setting up the physical robot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置物理机器人
- en: A quick introduction to ROS programming
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS编程的快速入门
- en: How to write a ROS package (**case study 1**)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写ROS包（**案例研究1**）
- en: An overview of ROS commands
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS命令概述
- en: Creating and running publisher and subscriber nodes
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和运行发布者和订阅者节点
- en: Automating the execution of nodes with roslaunch
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用roslaunch自动化节点执行
- en: ROS GUI development tools (**case study 2**)
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS GUI开发工具（**案例研究2**）
- en: How to use ROS parameters
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用ROS参数
- en: 'We will provide explanations of these concepts based on two practical case
    studies:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将基于两个实际案例研究对这些概念进行解释：
- en: '**Case study 1**: Publishing and reading distance sensors'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例研究1**：发布和读取距离传感器'
- en: '**Case study 2**: Acquiring and visualizing images from the Pi camera'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**案例研究2**：从Pi相机获取并可视化图像'
- en: 'There is a third case study dealing with robot control and simulation – **case
    study 3**: robot drives (motors and encoders) – which as a practical example will
    support the concepts that will be covered in [Chapter 7](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml),
    *Robot Control and Simulation.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个第三案例研究涉及机器人控制和仿真——**案例研究3**：机器人驱动（电机和编码器）——作为一个实际例子，它将支持在[第7章](0653ab6b-8710-41e7-9c01-5024865e3e27.xhtml)，*机器人控制和仿真*中将要介绍的概念。
- en: So, we have three case studies and, as a result of both this chapter and the
    next chapter, we will have our first complete version of the ROS package for GoPiGo3\.
    This will be the foundation on which smart robot behaviors will be built in the
    remaining chapters of the book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个案例研究，并且由于本章和下一章的内容，我们将拥有GoPiGo3的第一个完整版本的ROS包。这将是本书剩余章节中构建智能机器人行为的基础。
- en: Technical requirements
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter are available at [https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter6_ROS_programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter6_ROS_programming).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可在以下链接找到：[https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter6_ROS_programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming/tree/master/Chapter6_ROS_programming)。
- en: 'When you have completed the Raspberry Pi setup, as explained in the *Setting
    up a physical robot *section, clone the book repository ([https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming](https://github.com/PacktPublishing/Hands-On-ROS-for-Robotics-Programming))
    in your home folder:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成Raspberry Pi的设置，如*设置物理机器人*部分所述，克隆书库到您的家目录中：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Remember this location in order to keep a check of your work because, in this
    chapter, our intention is that you create all the code by yourself. Alternatively,
    if you decide to use the provided code, you will just need to copy the `Chapter6_ROS_programming` folder to
    the ROS workspace as usual:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这个位置，以便检查您的工作，因为在本章中，我们的目的是让您自己编写所有代码。或者，如果您决定使用提供的代码，您只需像往常一样将`Chapter6_ROS_programming`文件夹复制到ROS工作空间即可：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The ROS workspace in the robot is initialized in the next section.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将初始化机器人的ROS工作空间。
- en: Setting up a physical robot
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置物理机器人
- en: As mentioned in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*, we will now start working with a physical robot. Therefore,
    the first thing to do is to prepare the software you need to be running in the
    Raspberry Pi. This section will guide you through the process step by step.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第3章](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml)中提到的，*ROS入门*，我们现在将开始使用物理机器人。因此，首先要做的是准备在Raspberry
    Pi上运行的软件。本节将逐步引导您完成这个过程。
- en: Downloading and setting up Ubuntu Mate 18.04
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下载和设置Ubuntu Mate 18.04
- en: '**Mate** is, at the time of writing, the recommended Ubuntu desktop to run
    under Raspberry Pi. It is a complete Ubuntu distribution with a nice desktop interface.
    Follow these steps to make it run in your GoPiGo3:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**Mate**在撰写本文时，是推荐在Raspberry Pi下运行的Ubuntu桌面。它是一个完整的Ubuntu发行版，拥有一个漂亮的桌面界面。按照以下步骤在GoPiGo3上运行它：'
- en: 'Download the image from [https://ubuntu-mate.org/download/](https://ubuntu-mate.org/download/),
    selecting the Raspberry Pi version (recommended): AArch32 (ARMv7). Burn the image
    onto a micro SD card. Afterward, place it in the slot in the Raspberry Pi, plug
    in a mouse and keyboard, connect to an HDMI screen, and then power on the board.'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从[https://ubuntu-mate.org/download/](https://ubuntu-mate.org/download/)下载图片，选择推荐的Raspberry
    Pi版本（AArch32 (ARMv7)）：将镜像烧录到微型SD卡上。之后，将其放入Raspberry Pi的插槽中，连接鼠标和键盘，连接到HDMI屏幕，然后打开板子电源。
- en: The first time you initiate it, a setup assistant will guide you through the
    process of configuring the operating system. In this book, we assume that the
    Ubuntu user is named `pi`. Change the code as necessary if you use another username.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次启动时，设置助手将引导您完成配置操作系统的过程。在本书中，我们假设Ubuntu用户名为`pi`。如果您使用的是其他用户名，请相应地更改代码。
- en: Make sure that you connect to the local WiFi by selecting a network from the
    list that is deployed when clicking on the wireless icon in the upper-right corner
    of the screen. It is strongly recommended that you add a second mobile WiFi network
    preferably like the one that your smartphone provides. This will avoid the need
    to connect to the HDMI screen, keyboard, and mouse when you move the robot away
    from home in the future.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您通过从屏幕右上角的无线图标点击时出现的列表中选择网络来连接到本地WiFi。强烈建议您添加第二个移动WiFi网络，最好是智能手机提供的那个。这样，在将来将机器人移出家中时，您就不需要连接到HDMI屏幕、键盘和鼠标。
- en: The following instructions are optional and are believed to provide a friendlier
    way to access the Raspberry Pi.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明是可选的，并被认为是访问Raspberry Pi的一个更友好的方式。
- en: Access customization
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问定制
- en: 'For more friendly access to your system, it is recommended that you allow your
    Ubuntu user to access `sudo` without a password:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更方便地访问您的系统，建议您允许Ubuntu用户无需密码即可访问`sudo`：
- en: 'In a terminal, type the following:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中输入以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, add this line at the end of the file:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在文件末尾添加此行：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Save your changes and exit so that they take effect.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的更改并退出，以便它们生效。
- en: Updating your system and installing basic utilities
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新系统并安装基本工具
- en: 'By running the following command, first you will update the Ubuntu repositories
    in your system; afterward, the system packages will be upgraded:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令，首先您将更新系统中的Ubuntu仓库；之后，系统包将被升级：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You will need a `git` package in order to clone the repositories of code. If
    this is not on your system, then you can install it using the following command:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个`git`软件包来克隆代码库。如果系统中没有这个软件包，你可以使用以下命令安装它：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will also add another useful package, `tree`, in order to get information
    from the filesystem:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加另一个有用的软件包`tree`，以便从文件系统中获取信息：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `tree` package is a utility that enables you to view the content of a folder
    and its subfolders at the same time, representing it visually via a tree structure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`tree`软件包是一个实用程序，它允许你同时查看文件夹及其子文件夹的内容，并通过树状结构可视地表示它。'
- en: Enabling SSH access
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用SSH访问
- en: 'It is common to have issues with the SSH server that comes preinstalled with
    Ubuntu:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ubuntu预装中遇到SSH服务器问题是很常见的：
- en: 'To avoid any problems, remove the OpenSSH package and install it again:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免任何问题，请移除`OpenSSH`软件包并重新安装：
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Enable the service so that it starts on boot:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用服务以便在启动时启动：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Confirm that the SSH server is up and running:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认SSH服务器正在运行：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: At this stage, you should be able to log in from this host to any other SSH-enabled
    Ubuntu server, such as your laptop.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该能够从这个主机登录到任何启用了SSH的Ubuntu服务器，例如你的笔记本电脑。
- en: Setting up a VNC server (x11vnc)
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置VNC服务器（x11vnc）
- en: 'OpenSSH allows us to log in remotely to our Raspberry Pi using a terminal.
    We will also equip our robot with another remote way of connection, that is, by
    accessing its desktop. In order to do this, we will use `x11vnc`, a package that
    implements a remote desktop using **Virtual Network Computing** (**VNC**):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: OpenSSH允许我们通过终端远程登录到我们的树莓派。我们还将为我们的机器人配备另一种远程连接方式，即通过访问其桌面。为此，我们将使用`x11vnc`，这是一个实现远程桌面使用**虚拟网络计算**（**VNC**）的软件包：
- en: 'Update the Ubuntu repositories and install:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新Ubuntu软件仓库并安装：
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now create a password to connect with a client:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个密码以连接到客户端：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Type in a password and remember it. The password is stored in `/home/pi/.vnc`
    assuming that the current user is `pi`. Then, start the `x11vnc` server:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入一个密码并记住它。假设当前用户是`pi`，密码将存储在`/home/pi/.vnc`中。然后，启动`x11vnc`服务器：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you want to start the server without needing a password, just remove the
    option from the command:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要在不需要密码的情况下启动服务器，只需从命令中移除该选项：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now you are ready to connect with a client using a VNC client such as RealVNC ([https://www.realvnc.com/download/viewer/](https://www.realvnc.com/download/viewer/)).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你准备好使用VNC客户端（如RealVNC）连接到客户端了。[https://www.realvnc.com/download/viewer/](https://www.realvnc.com/download/viewer/)
- en: Setting up autostart on boot
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在启动时设置自动启动
- en: 'We want `x11vnc` to start automatically when we reboot or power on the Pi.
    Hence, create a script named `x11vnc.service` at location` /lib/systemd/system/`,
    perform the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望`x11vnc`在重启或开机时自动启动。因此，在`/lib/systemd/system/`位置创建一个名为`x11vnc.service`的脚本，执行以下操作：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'While editing, add the following lines:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑时，添加以下行：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, enable and start the newly created service:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，启用并启动新创建的服务：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: To connect with the RealVNC viewer from a remote PC, enter the IP address of
    the Raspberry Pi followed by the display number, that is, `<IP address>:<display
    number>`. If no display is specified, then it takes `0` as default. Hence, the `0`
    value will be assigned to the first server you launch (which is your unique server).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要从远程PC使用RealVNC查看器连接，请输入树莓派的IP地址后跟显示编号，即`<IP地址>:<显示编号>`。如果没有指定显示，则默认为`0`。因此，`0`值将被分配给你启动的第一个服务器（即你的唯一服务器）。
- en: As you are running VNC with the default port, `5900`, you do not need to specify
    it for the connection. If this is not the case, you should specify the custom
    port in the connection string.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用默认端口`5900`运行VNC，因此你不需要为连接指定它。如果不是这种情况，你应该在连接字符串中指定自定义端口。
- en: Forcing the HDMI output and screen layout
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制HDMI输出和屏幕布局
- en: 'For debugging purposes, it is useful to make sure that you can always access
    the Ubuntu Mate desktop from a screen, even though the system does not start with
    it. In order to achieve this, you have to modify the configuration options of
    the Raspberry Pi:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，确保你可以始终从屏幕访问Ubuntu Mate桌面是有用的，即使系统没有启动它。为了实现这一点，你必须修改树莓派的配置选项：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The content of the file will be accessible on the screen. Uncomment the following
    lines, setting the shown values:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文件内容将在屏幕上显示。取消以下行的注释，设置显示的值：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last two lines enforce the following display: at 1440 x 900 at 60 Hz. If
    you want to increase this to full HD resolution (1080 px), then you can do so
    as follows, depending on the refresh rate:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行强制执行以下显示：在1440 x 900分辨率下，60 Hz。如果您想将其增加到全高清分辨率（1080像素），则可以根据刷新率这样做：
- en: 'For a 50 Hz monitor, use the following:'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于50 Hz的显示器，使用以下设置：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For a 60 Hz monitor, use the following:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于60 Hz的显示器，使用以下设置：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These commands make it easy to get 1080 px.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令使获取1080像素变得容易。
- en: The Geany IDE
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Geany IDE
- en: 'Ubuntu Mate comes with a lightweight editor called **Pluma**. While it is good
    for editing, it does not include a terminal window or other common characteristics
    that are found in a typical development environment. For this reason, we will
    install **Geany**, a lightweight IDE suitable for running on a Raspberry Pi that
    supports common programming languages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Ubuntu Mate自带一个名为**Pluma**的轻量级编辑器。虽然它适合编辑，但不包括终端窗口或其他在典型开发环境中常见的特性。因此，我们将安装**Geany**，这是一个轻量级IDE，适合在Raspberry
    Pi上运行，并支持常见的编程语言：
- en: '[PRE21]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We will be mainly using Python, so Geany is perfect for us.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要使用Python，因此Geany对我们来说非常合适。
- en: Installing drivers for the GoPiGo3 and DI Sensors
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装GoPiGo3和DI传感器的驱动程序
- en: 'Now we will prepare the system to work with GoPiGo3\. Dexter Industries supplies
    automated scripts to accomplish all the installations tasks:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将准备系统以与GoPiGo3一起工作。Dexter Industries提供了自动化脚本来完成所有安装任务：
- en: The GoPiGo3 library, with the following script [https://dexterindustries.com/update_gopigo3](https://dexterindustries.com/update_gopigo3)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GoPiGo3库，以下脚本[https://dexterindustries.com/update_gopigo3](https://dexterindustries.com/update_gopigo3)
- en: The DI Sensors library, with the following script [https://dexterindustries.com/update_sensors](https://dexterindustries.com/update_sensors)
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI传感器库，以下脚本[https://dexterindustries.com/update_sensors](https://dexterindustries.com/update_sensors)
- en: 'The relevant steps are provided in the official documentation at [https://dexterindustries.com/update_gopigo3](https://gopigo3.readthedocs.io/en/master/quickstart.html#program-your-gopigo3).
    In short, you only have to open a terminal and execute following two commands,
    one after another:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相关步骤在官方文档中提供，请参阅[https://dexterindustries.com/update_gopigo3](https://gopigo3.readthedocs.io/en/master/quickstart.html#program-your-gopigo3)。简而言之，您只需打开一个终端并依次执行以下两个命令：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The installation process takes several minutes, so be patient. When finished,
    you will see the following new icons on your desktop:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 安装过程需要几分钟，所以请耐心等待。完成后，您将在桌面上看到以下新图标：
- en: '![](img/b738f345-95fb-4067-8e5e-050fa293c275.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b738f345-95fb-4067-8e5e-050fa293c275.png)'
- en: 'These additional utilities are as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些附加实用程序如下：
- en: '**Advanced Communication Options**: This icon is used to enable Bluetooth and/or
    infrared receivers.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级通信选项**：此图标用于启用蓝牙和/或红外接收器。'
- en: '**Line Follower Calibration**: This icon is used to adjust sensor sensibility
    to the current illumination conditions.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线跟踪校准**：此图标用于调整传感器对当前光照条件的灵敏度。'
- en: '**gopigo3_control_panel**: This icon is used to drive the robot with a simple
    panel shown on the screen.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gopigo3_control_panel**：此图标用于通过屏幕上显示的简单面板来驱动机器人。'
- en: '**Test and Troubleshoot**: This utility generates a log file for your robot
    that can be sent to the manufacturer so that it can provide technical support.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试和故障排除**：此实用程序为您的机器人生成日志文件，可以发送给制造商，以便它提供技术支持。'
- en: 'As an example, double-click on the **Test and Troubleshoot** icon. It will
    generate a log file of your robot that should look like the following globally:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，双击**测试和故障排除**图标。它将生成您的机器人的日志文件，该文件应如下所示：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, your operating system is ready to run any GoPiGo3 code, that
    is, the Python scripts that we used in [Chapter 2](7a2b1b82-c666-42df-9f10-9777eabe82df.xhtml), *Unit
    Testing of GoPiGo3*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的操作系统已准备好运行任何GoPiGo3代码，即我们在[第2章](7a2b1b82-c666-42df-9f10-9777eabe82df.xhtml)，*GoPiGo3单元测试*中使用的Python脚本。
- en: Setting up the Pi Camera
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Pi摄像头
- en: 'The setup is done in steps 1-2\. First, we will enable access to the camera
    hardware from the Raspberry Pi, and second, we will install the Python module
    to handle the camera:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 设置分为步骤1-2。首先，我们将从Raspberry Pi启用对摄像头硬件的访问，其次，我们将安装Python模块来处理摄像头：
- en: 'First, we need to edit the `/boot/config.txt` file:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要编辑`/boot/config.txt`文件：
- en: '[PRE24]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we add these two lines at the end:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在末尾添加这两行：
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, you can get the same result by adding these lines from the command
    line:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您也可以通过在命令行中添加以下这些行来达到相同的结果：
- en: '[PRE26]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, install the Python module as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式安装Python模块：
- en: '[PRE27]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To check that the camera works properly, create this Python script and name
    it `captureFile.py` (you can find it inside the `piCamera` folder in the code
    for this chapter):'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查相机是否正常工作，创建这个 Python 脚本，并将其命名为 `captureFile.py` （你可以在本章代码的 `piCamera` 文件夹中找到它）：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Give execution permissions and run the Python module:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给 Python 模块执行权限并运行：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The camera will be active for 2 seconds. Check that the red LED on the camera
    board is on. This is a visual sign that it is acquiring images. After this period,
    the LED will switch off and you should find – in the same path as the script –
    a new file called `test.jpg`. If you open it, you should see what the camera was
    viewing at the end of those 2 seconds; this is performed by: `camera.capture(test.jpg)`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 相机将激活 2 秒。检查相机板上的红色 LED 是否亮着。这是它在获取图像的视觉信号。在此期间过后，LED 将关闭，你应该在脚本相同的路径下找到一个名为 `test.jpg`
    的新文件。如果你打开它，你应该能看到相机在最后那 2 秒钟看到的景象；这是通过：`camera.capture(test.jpg)` 实现的。
- en: The last step in getting ready with the Raspberry Pi is to install ROS.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好 Raspberry Pi 的最后一步是安装 ROS。
- en: Installing ROS Melodic
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 ROS Melodic
- en: 'The instructions on the ROS Melodic installation page ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))
    are pretty clear and straightforward. We include them here for the sake of completeness:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ROS Melodic 安装页面 ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))
    上的说明非常清晰和直接。我们在这里包括它们是为了完整性：
- en: 'First, add the ROS source repositories:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，添加 ROS 源仓库：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, set up your keys:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，设置你的密钥：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If you don't get a validated key, then it might have been changed (for security
    reasons). If that's the case, then go to the official installation page ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu)),
    search for the line, and then replace it with the new one.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有得到一个验证过的密钥，那么它可能已经被更改（出于安全原因）。如果是这种情况，那么请访问官方安装页面 ([http://wiki.ros.org/melodic/Installation/Ubuntu](http://wiki.ros.org/melodic/Installation/Ubuntu))，搜索该行，然后用新的一行替换它。
- en: 'Next, update your sources:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新你的源：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Install the desktop version of ROS so that you can take advantage of the Mate
    desktop environment. This will allow you to use ROS GUI tools (such as rqt or RViz):'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 ROS 的桌面版本，以便你可以利用 Mate 桌面环境。这将允许你使用 ROS 图形界面工具（如 rqt 或 RViz）：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Initialize `rosdep`. This is the component that enables you to easily install
    system dependencies for your source code to compile. It also requires you to run
    some core components in ROS:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化 `rosdep`。这是使你能够轻松安装源代码编译的系统依赖项的组件。它还要求你运行 ROS 的一些核心组件：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Set up the ROS environment for your interactive shell session:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为你的交互式 shell 会话设置 ROS 环境：
- en: '[PRE35]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To avoid having to run this command each time, you can open a new terminal
    and include it in your `.bashrc` file:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免每次都必须运行此命令，你可以打开一个新的终端，并将其包含在你的 `.bashrc` 文件中：
- en: '[PRE36]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now all that remains is to configure the Pi Camera. Let's do that next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是配置 Pi 相机。让我们接下来这么做。
- en: Installing a Pi Camera ROS package
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Pi Camera ROS 软件包
- en: As part of the ROS installation, we should include software that will allow
    you to access the Pi Camera from ROS. The most used package is that from Ubiquity
    Robotics, and it is hosted on GitHub at [https://github.com/UbiquityRobotics/raspicam_node](https://github.com/UbiquityRobotics/raspicam_node).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 ROS 安装的一部分，我们应该包括允许你从 ROS 访问 Pi 相机的软件。最常用的软件包来自 Ubiquity Robotics，它托管在 GitHub
    上，地址为 [https://github.com/UbiquityRobotics/raspicam_node](https://github.com/UbiquityRobotics/raspicam_node)。
- en: To install the package, we first need to have a ROS workspace and to have mastered
    some practical concepts for cloning and creating ROS packages. This installation
    will be accomplished later on in the chapter; you will find it in the *Case study
    2 – ROS GUI development tools – the Pi Camera* *globally*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装软件包，我们首先需要一个 ROS 工作空间，并且需要掌握一些关于克隆和创建 ROS 软件包的实用概念。这个安装将在本章稍后完成；你将在 *案例研究
    2 – ROS GUI 开发工具 – Pi 相机* 中找到它，*全局*。
- en: Hence, let's proceed now to create a workspace and add the first package inside
    it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在继续创建一个工作空间并在其中添加第一个软件包。
- en: A quick introduction to ROS programming
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS 编程的快速介绍
- en: This section is devoted to explaining an easy ROS example with GoPiGo3\. By
    doing this, we can put our robot to work quickly so that, in later sections, we
    can deal with ROS commands and tools in a practical way, applying such commands
    and understanding what they do.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本节致力于解释一个简单的GoPiGo3 ROS示例。通过这样做，我们可以快速让我们的机器人开始工作，以便在后面的章节中，我们可以以实用的方式处理ROS命令和工具，应用这些命令并理解它们的作用。
- en: This very simple example is based on the distance sensor in GoPiGo3\. It consists
    of publishing sensor readings and accessing them from other ROS nodes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个非常简单的例子是基于GoPiGo3的距离传感器。它包括发布传感器读数和从其他ROS节点访问它们。
- en: Setting up the workspace
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置工作空间
- en: 'To start using contributed ROS packages or to create your own, you will need
    to have a workspace in which to put the code. The step-by-step procedure to accomplish
    such a task is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用贡献的ROS软件包或创建自己的软件包，你需要有一个工作空间来放置代码。完成此类任务的逐步过程如下：
- en: 'From a bash terminal, create a folder and initialize the workspace:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从bash终端创建一个文件夹并初始化工作空间：
- en: '[PRE37]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The initialization is as simple as creating a symlink to a file definition
    located in the ROS installation folder. If you list files in the `src` folder,
    then you will see the new `CMakeLists.txt` file pointing to `/opt/ros/melodic/share/catkin/cmake/toplevel.cmake`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化就像创建一个指向ROS安装文件夹中文件定义的符号链接一样简单。如果您列出`src`文件夹中的文件，您将看到指向`/opt/ros/melodic/share/catkin/cmake/toplevel.cmake`的新`CMakeLists.txt`文件：
- en: '[PRE38]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Next, build the workspace:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，构建工作空间：
- en: '[PRE39]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then, add it to your ROS environment:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将其添加到你的ROS环境中：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Alternatively, you can automate the execution of this command by including
    it at the end of your `.bashrc` file. To do so, execute the following command,
    and, afterward, run the file so that its contents take effect in the system:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者，您可以通过在`.bashrc`文件末尾包含此命令来自动执行此命令。为此，执行以下命令，然后运行文件，以便其内容在系统中生效：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'At this point, you should have the following two lines at the end of the file
    (the first one is for the ROS global environment, while the second is for your
    private workspace):'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，文件末尾应该有以下两行（第一行是ROS全局环境，第二行是您的私有工作空间）：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Everything is now ready to include the ROS packages we need. In the following
    section, we will add two of them: one cloning an existing repository and another
    one creating a package from scratch.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切准备就绪，可以包含我们需要的ROS软件包。在下一节中，我们将添加其中两个：一个克隆现有仓库，另一个从头创建软件包。
- en: Cloning a ROS package
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克隆ROS软件包
- en: 'For the cloning option, we are going to use a basic GoPiGo3 ROS package that is
    publicly available in GitHub from [https://github.com/ros-gopigo/gopigo3_node](https://github.com/ros-gopigo/gopigo3_node).
    Change to the `src` folder, which is the location where we will place all ROS
    packages, and then clone the source code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于克隆选项，我们将使用一个基本的GoPiGo3 ROS软件包，该软件包在GitHub上公开可用，地址为[https://github.com/ros-gopigo/gopigo3_node](https://github.com/ros-gopigo/gopigo3_node)。切换到`src`文件夹，这是我们放置所有ROS软件包的位置，然后克隆源代码：
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Every time you add a new package, you have to rebuild the workspace so that
    ROS is aware of its existence and can add it to the execution environment. Hence,
    run the following commands:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每次添加新的软件包时，你必须重新构建工作空间，以便ROS知道其存在并将其添加到执行环境。因此，运行以下命令：
- en: '[PRE44]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, you will see a number of lines indicating the progress in % and what the
    current building step is doing. If everything is okay, the last line displays
    100% complete and returns the control to the command line. This means that you
    have just successfully installed the `gopigo3_node` package.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你会看到一系列表示进度的百分比和当前构建步骤正在做什么的行。如果一切正常，最后一行显示100%完成并返回到命令行。这意味着你刚刚成功安装了`gopigo3_node`软件包。
- en: Our first execution of a ROS node
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们第一次执行ROS节点
- en: 'Since ROS will be running on the Raspberry Pi, you will have to remotely connect
    to it. In order to do so, open a VNC connection to GoPiGo. Then, open a terminal
    in its desktop and install Terminator (the same utility we used in [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting
    Started with ROS*) to have as many terminals as you need in the same window:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于ROS将在树莓派上运行，因此你需要远程连接到它。为此，打开GoPiGo的VNC连接。然后，在其桌面上打开一个终端并安装Terminator（我们在[第3章](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml)，*ROS入门*)中使用的相同实用程序，以便在同一窗口中拥有尽可能多的终端：
- en: '[PRE45]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Move to the location of the newly added ROS package and list the files inside:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 移动到新添加的ROS软件包的位置，并列出其中的文件：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You will see several Python files for controlling GoPiGo3 sensors and drives.
    Assuming that you have installed the GoPiGo3 and DI Sensors libraries, as explained
    in the *Setting up a physical robot *section, open Terminator and divide the window
    into at least three terminals. We are going to execute the `distance_sensor.py` file
    under ROS. For that, we will need to issue three commands as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到几个用于控制 GoPiGo3 传感器和驱动器的 Python 文件。假设您已经按照*设置物理机器人*部分中的说明安装了 GoPiGo3 和 DI
    传感器库，打开 Terminator 并将窗口分成至少三个终端。我们将执行 ROS 下的`distance_sensor.py`文件。为此，我们需要发出以下三个命令：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The following is globally what each command performs:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是全球每个命令执行的内容：
- en: '`T1` launches the roscore process. This is necessary for all subsequent processes
    that can communicate in ROS.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T1`启动 roscore 进程。这对于所有后续的 ROS 通信过程都是必要的。'
- en: '`T2` executes the `distance_sensor` node, which takes the readings and publishes
    them under the `/distance_sensor/distance` topic.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T2`执行`distance_sensor`节点，该节点读取数据并将其发布到`/distance_sensor/distance`主题。'
- en: '`T3` listens to published data in real time and prints a new message each time
    a reading is acquired.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`T3`实时监听发布的数据，并在每次获取读取时打印一条新消息。'
- en: 'In the following screenshot, you can see what each terminal shows. Each reading
    of the sensor delivers a message that has several fields. Later on, in the *Case
    study 1 – writing a ROS package – distance sensor* section, we will explain how
    this message is created. For now, it is enough that you know that the `range`
    field, boxed in red, is the sensor measurement in a meters:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以查看每个终端显示的内容。每次读取传感器都会传递一个包含多个字段的消息。在后面的*案例研究 1 – 编写 ROS 包 – 距离传感器*部分，我们将解释这个消息是如何创建的。现在，您只需要知道红色方框内的`range`字段是传感器以米为单位的测量值：
- en: '![](img/cd92f53f-4cd4-4a06-acaf-b52e18252b40.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd92f53f-4cd4-4a06-acaf-b52e18252b40.png)'
- en: 'To take just the last measurement, simply run the following command, where
    the number after *-n* indicates how many messages you want to print, which, in
    our case, is 1:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只想获取最后的测量值，只需运行以下命令，其中`-n`后面的数字表示您想要打印的消息数量，在我们的例子中是 1：
- en: '[PRE48]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The next step will be to create your own ROS package. The code we are going
    to write makes the same package as the `distance_sensor.py` script but uses the `EasyDistanceSensor` class
    (from the `di_sensors.easy_distance_sensor` library) instead of the full `DistanceSensor` version
    (from the `di_sensors.distance_sensor` library), which was used by the script
    in the package that we cloned previously.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是创建您自己的 ROS 包。我们将编写的代码将创建与`distance_sensor.py`脚本相同的包，但使用`EasyDistanceSensor`类（来自`di_sensors.easy_distance_sensor`库）而不是完整的`DistanceSensor`版本（来自`di_sensors.distance_sensor`库），后者是我们之前克隆的包中使用的脚本。
- en: Case study 1 – writing a ROS distance-sensor package
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 1 – 编写 ROS 距离传感器包
- en: 'In this section, you will create a ROS package from scratch and produce the
    code to provide minimal ROS functionality with GoPiGo3, that is, reading its distance
    sensor. Be aware that the code you previously cloned at this location is the working
    solution for what your code is expected to do:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将从零开始创建一个 ROS 包，并生成代码以提供 GoPiGo3 的最小 ROS 功能，即读取其距离传感器。请注意，您之前在此位置克隆的代码是您代码预期要执行的工作解决方案：
- en: '[PRE49]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We encourage you to try to build the ROS package by yourself, following the
    explanations that are provided next in this chapter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您尝试根据本章后面提供的解释自己构建 ROS 包。
- en: Creating a new package
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新包
- en: 'First, let''s set up a folder in the workspace where we will place the package
    files:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在工作空间中设置一个文件夹，我们将放置包文件：
- en: 'Move to the `src` location in the `catkin_ws worspace` folder:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工作目录移动到`catkin_ws`工作空间文件夹中的`src`位置：
- en: '[PRE50]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Create a package called `mygopigo`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`mygopigo`的包：
- en: '[PRE51]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This command creates two files of the package definition `CMakeLists.txt` and
    `package.xml`, which were already introduced in the previous chapter. As there
    is a new package, you should rebuild the workspace:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令创建了两个包定义文件`CMakeLists.txt`和`package.xml`，这些文件在上一章中已经介绍过。由于有一个新的包，您应该重新构建工作空间：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If, at some point, you wish to change the project name, then you need to complete
    these three steps:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在某个时候您想更改项目名称，那么您需要完成以下三个步骤：
- en: Edit in the `<name>mygopigo</name>` tag in package.xml.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<name>mygopigo</name>`标签中编辑 package.xml。
- en: Edit the line project (`mygopigo`) in CMakeLists.txt, where the project has
    to be the same as the `package.xml` <name> tag.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`CMakeLists.txt`文件中的`project (`mygopigo`)行，其中项目名称必须与`package.xml`的`<name>`标签相同。
- en: Rebuild the workspace.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新构建工作空间。
- en: The folder under which the files of the package are stored can be named however
    you like – it does not have to be the same as the package name.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 存储包文件的文件夹可以命名为您喜欢的任何名称 – 它不必与包名相同。
- en: Producing your source code
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成您的源代码
- en: 'The `mygopigo` folder is ready so that we can create the package structure
    and place the files:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`mygopigo`文件夹已准备好，以便我们可以创建包结构并放置文件：'
- en: 'Create the `src` folder inside the package – note that this is a convention
    we use to standardize where the code is placed in repositories:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在包内创建`src`文件夹 – 注意这是我们用来标准化代码在存储库中位置的约定：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `roscd` ROS command is equivalent to the Linux bash `cd` command. Its advantage
    is that you only have to specify the package name in order to move to the package''s
    folder, which is `~/catkin_ws/src/mygopigo/`. Then, create a Python file to acquire
    data from the distance sensor:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`roscd` ROS命令与Linux bash的`cd`命令等效。它的优点是您只需指定包名即可移动到包的文件夹，即`~/catkin_ws/src/mygopigo/`。然后，创建一个Python文件以从距离传感器获取数据：'
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Copy and paste the following lines globally inside the file:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中全局复制并粘贴以下行：
- en: '[PRE55]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is the unit test file for the distance sensor that we reviewed in the previous
    chapter. We will explain how to convert it into a ROS-integrated script.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在上一章中审查的距离传感器的单元测试文件。我们将解释如何将其转换为ROS集成脚本。
- en: ROS requires that source code be in files with the following execution permission: `$
    chmod +x distance-sensor.py`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: ROS要求源代码存储在具有以下执行权限的文件中：`$ chmod +x distance-sensor.py`.
- en: 'To run, just invoke it from the command line:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行，只需从命令行调用它：
- en: '[PRE56]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This will print the measured distance in centimeters every 0.1 seconds. At this
    point, the code is still pure Python.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在每0.1秒打印一次测量的距离（以厘米为单位）。此时，代码仍然是纯Python。
- en: 'We will now explain what changes need to be carried out so that it can be integrated
    into ROS:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解释需要进行哪些更改才能将其集成到ROS中：
- en: 'First, import the modules required by ROS:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入ROS所需的模块：
- en: '[PRE57]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `rospy` library is the Python client and `sensor_msgs.msg` defines message
    types for handling data from sensors within ROS. In our particular case, we only
    need the `Range` type message, which is what we will need for the distance sensor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`rospy`库是Python客户端，`sensor_msgs.msg`定义了处理ROS中传感器数据的消息类型。在我们的特定情况下，我们只需要`Range`类型消息，这就是我们需要用于距离传感器的。'
- en: 'Python''s `time` library is no longer required since `rospy` provides methods
    to handle time features in ROS. Hence, you may remove the line:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`rospy`提供了处理ROS中时间特性的方法，Python的`time`库不再需要。因此，您可以删除该行：
- en: '[PRE58]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next, we put the code under the `main()` function definition:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将代码放在`main()`函数定义下：
- en: '[PRE59]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We launch a ROS node called `distance_sensor`, define a publisher called `pub_distance`,
    set the characteristics of the sensor in the `msg_range message`, and specify
    the rate we want to read the sensor at, which is 1 Hz. We complete the code of
    the main function by running an infinite loop that takes a reading of the sensor
    in each iteration:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动一个名为`distance_sensor`的ROS节点，定义一个名为`pub_distance`的发布者，在`msg_range`消息中设置传感器的特性，并指定我们想要读取传感器的速率，即1
    Hz。我们通过运行一个每次迭代读取传感器读数的不停循环来完成主函数的代码：
- en: '[PRE60]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In each iteration, this code saves the sensor data in the `msg_range` instance,
    publishes the message to the `/distance_sensor/distance` topic, and runtime-delays
    the next reading to respect the specified rate. Finally, we tell Python to run
    the `main()` function:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次迭代中，此代码将传感器数据保存到`msg_range`实例中，将消息发布到`/distance_sensor/distance`主题，并在下一个读取之前运行时延迟以尊重指定的速率。最后，我们告诉Python运行`main()`函数：
- en: '[PRE61]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In the following subsections, we will cover more information about these pieces
    of code in detail.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将详细介绍这些代码片段的更多信息。
- en: Including the required libraries – rospy and msgs.msg
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 包含所需的库 – rospy 和 msgs.msg
- en: 'The following two lines import the required ROS libraries:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两行导入所需的ROS库：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'These libraries are explained as follows:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这些库的解释如下：
- en: '`rospy` ([http://wiki.ros.org/rospy](http://wiki.ros.org/rospy)): This is the
    official Python client for ROS. It implements  API methods so that you can integrate
    ROS nodes coded in Python.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rospy` ([http://wiki.ros.org/rospy](http://wiki.ros.org/rospy))：这是ROS的官方Python客户端。它实现了API方法，以便您可以将用Python编写的ROS节点集成。'
- en: '`sensor_msgs` ([http://wiki.ros.org/sensor_msgs](http://wiki.ros.org/sensor_msgs)):
    This is the ROS package that lets you handle different types of ROS message depending
    on the sensors and drives of your robot; for example, `BatteryState`, `FluidPressure`,
    and `LaserScan`. In the case of the distance sensor, we use the `Range` type.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sensor_msgs` ([http://wiki.ros.org/sensor_msgs](http://wiki.ros.org/sensor_msgs))：这是
    ROS 包，允许您根据机器人的传感器和驱动程序处理不同类型的 ROS 消息；例如，`BatteryState`、`FluidPressure` 和 `LaserScan`。在距离传感器的例子中，我们使用
    `Range` 类型。'
- en: Assigning a node name to the script
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为脚本分配节点名称
- en: 'This task is accomplished using the `init_node` method of the `rospy` library:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此任务是通过使用 `rospy` 库的 `init_node` 方法完成的：
- en: '[PRE63]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using the `distance_sensor` name, we will reference the distance sensor node
    anywhere in ROS.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `distance_sensor` 名称，我们可以在 ROS 的任何地方引用距离传感器节点。
- en: Defining the publisher
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义发布者
- en: 'The publisher is a function – again, a `rospy` method that permits you to assign
    to the `pub_distance` variable the result of the measurement, which, in our case,
    is of the `Range` type:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者是函数——再次强调，这是一个 `rospy` 方法，允许您将测量结果赋值给 `pub_distance` 变量，在我们的例子中，它是 `Range`
    类型：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The value between the quotation marks is the topic name, `~distance`. The prepended
    symbol, `~`, is equivalent to `<name of node>/`, which, in our case, is `distance_sensor`.
    Following this, the namespace topic will be as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 引号之间的值是主题名称，`~distance`。前置符号 `~` 等同于 `<name of node>/`，在我们的例子中是 `distance_sensor`。随后，命名空间主题将如下所示：
- en: '[PRE65]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The `queue_size` parameter specifies how many messages ROS keeps in memory to
    ensure that the subscriber nodes read them. A value of `10` is a good default.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_size` 参数指定 ROS 在内存中保留多少条消息以确保订阅节点可以读取它们。默认值 `10` 是一个很好的选择。'
- en: Setting up the msg_range object
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 msg_range 对象
- en: 'The distance sensor uses the message type defined in the `Range` class of the
    `sensor_msgs.msg` library, whose structure is as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 距离传感器使用在 `sensor_msgs.msg` 库中定义的消息类型，该类型在 `Range` 类中，其结构如下：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'These are the fields that will be part of any message involving the data flow
    from the sensor, and its syntax is explained in detail in the documentation ([http://docs.ros.org/api/sensor_msgs/html/msg/Range.html](http://docs.ros.org/api/sensor_msgs/html/msg/Range.html)).
    All the fields are specific characteristics of the sensor except for the measurement
    itself, `range`. Hence, the following snippet gives a particular definition for
    our distance sensor:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段将构成任何涉及传感器数据流的消息的一部分，其语法在文档中有详细说明（[http://docs.ros.org/api/sensor_msgs/html/msg/Range.html](http://docs.ros.org/api/sensor_msgs/html/msg/Range.html)）。所有字段都是传感器的特定特征，除了测量值本身
    `range`。因此，以下代码片段为我们的距离传感器提供了一个特定的定义：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, the first line initiates the `msg_range` variable to be of the `Range()` type.
    In the `header.frame_id` field, we indicate the physical magnitude we are going
    to measure, which is `distance`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，第一行初始化 `msg_range` 变量为 `Range()` 类型。在 `header.frame_id` 字段中，我们指明将要测量的物理量，即
    `distance`。
- en: The `radiation` type is set to `INFRARED` (there is no option to set this to `LASER`,
    but specifying it as `INFRARED` is more adequate than the other option, `ULTRASOUND`,
    for which you would have a wide field of view instead of a straight ray). `LASER`
    is directional, as is `INFRARED`, so it is better to use this type.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `radiation` 类型设置为 `INFRARED`（没有选项将其设置为 `LASER`，但将指定为 `INFRARED` 比其他选项 `ULTRASOUND`
    更为合适，后者会提供一个宽视野而不是直线）。`LASER` 和 `INFRARED` 都是定向的，因此使用此类型更好。
- en: The last two lines specify the maximum (3 meters) and minimum (2 centimeters)
    distances the sensor can measure.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两行指定了传感器可以测量的最大距离（3米）和最小距离（2厘米）。
- en: Changing units to the International System of Units
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单位转换为国际单位制
- en: 'Adopting the **International System of Units** (**SI**) is the ROS convention
    stated in its specification ([https://www.ros.org/reps/rep-0103.html](https://www.ros.org/reps/rep-0103.html)).
    Since the `read()` method provides measurements in centimeters, we only have to
    divide by 100 to obtain the distance in meters and feed this to the system according
    to the ROS standard:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 采用**国际单位制**（**SI**）是 ROS 规范中声明的规范（[https://www.ros.org/reps/rep-0103.html](https://www.ros.org/reps/rep-0103.html)）。由于
    `read()` 方法提供的是厘米单位的测量值，我们只需将其除以 100 即可得到米单位的距离，并按照 ROS 标准将其馈送到系统中：
- en: '[PRE68]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This value will be inserted afterward into the `msg_range` object, which we
    will cover next.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此值将在之后插入到 `msg_range` 对象中，我们将在下一部分进行介绍。
- en: Adding a measured distance and timestamp to the msg_range object
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向 msg_range 对象添加测量距离和时间戳
- en: 'In the `msg_range.range` field, we allocate the measured distance, and in the
    other field –  `msg_range.header.stamp` – we allocate the current timestamp:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在`msg_range.range`字段中，我们分配测量的距离，在另一个字段`msg_range.header.stamp`中，我们分配当前的时间戳：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The timestamp is obtained from the `Time.now()` method of the `rospy` library.
    In this way, we have a full record of the measurement.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 时间戳是从`rospy`库的`Time.now()`方法获得的。这样，我们就有了完整的测量记录。
- en: Setting the reading frequency
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置读取频率
- en: 'Using the `Rate` method, we can set the reading frequency to 1 Hz (this is
    equal to 1 sample per second; in SI units) as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Rate`方法，我们可以将读取频率设置为1 Hz（这等于每秒1个样本；在SI单位中），如下所示：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We do this by defining a ROS parameter at the same time whose name is as follows
    (remember the meaning of the `~` symbol):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过定义一个名为以下内容的ROS参数同时完成此操作（记住`~`符号的含义）：
- en: '[PRE71]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: With this setup, the sensor will be read once per second.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此设置，传感器将每秒读取一次。
- en: Running an infinite loop
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行无限循环
- en: 'We run the infinite loop using a specific ROS method from `rospy`:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`rospy`中的特定ROS方法来运行无限循环：
- en: '[PRE72]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Its syntax is self-explanatory, that is, it will run unless ROS is shutdown.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 其语法是自我解释的，也就是说，除非关闭ROS，否则它将运行。
- en: Publishing each new event
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布每个新事件
- en: 'We publish a new `msg_range` message each time a measure is available by using
    the `pub_distance` publisher defined previously:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用之前定义的`pub_distance`发布者，每次测量可用时发布一个新的`msg_range`消息：
- en: '[PRE73]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Waiting until the next reading
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待下一次读取
- en: 'To ensure we respect the acquisition rate of 1 Hz, we apply the `sleep` method
    to the `rate` object that we defined above (for which we set a frequency of 1
    Hz, that is, one cycle per second):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们尊重1 Hz的采集率，我们将`sleep`方法应用于我们上面定义的`rate`对象（我们为其设置了1 Hz的频率，即每秒一个周期）：
- en: '[PRE74]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Bear in mind that this does not block ROS execution (it just blocks the script
    of this node), that is, just the code of this `distance_sensor` node. If there
    were other nodes in the environment, then they would have their own independent
    execution threads. If you were using a native asynchronous language such as JavaScript,
    then you could also run asynchronous code within the node and also avoid the blockage
    in the execution of the script, that is, your node could be executing other lines
    while waiting for the next sensor reading
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这不会阻塞ROS执行（它只是阻塞了此节点的脚本），也就是说，只是这个`distance_sensor`节点的代码。如果有其他节点在环境中，那么它们将有自己的独立执行线程。如果你使用的是原生异步语言，如JavaScript，那么你还可以在节点内运行异步代码，并避免脚本执行中的阻塞，也就是说，你的节点可以在等待下一次传感器读取时执行其他行。
- en: If you are curious about this, you can investigate the ROS client library, `rosnodejs` ([https://www.npmjs.com/package/rosnodejs](https://www.npmjs.com/package/rosnodejs)),
    which allows you to write nodes in the JavaScript language. At this point, remember
    that one of the cool characteristics of ROS is that you can mix the same ROS graph
    nodes written in Python with nodes written in JavaScript or in any of the other
    ROS client libraries ([http://wiki.ros.org/Client%20Libraries](http://wiki.ros.org/Client%20Libraries)).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对此感兴趣，可以调查ROS客户端库`rosnodejs`([https://www.npmjs.com/package/rosnodejs](https://www.npmjs.com/package/rosnodejs))，它允许你使用JavaScript语言编写节点。在此阶段，请记住，ROS的一个酷特性是你可以混合使用Python编写的相同ROS图节点与使用JavaScript或其他ROS客户端库编写的节点([http://wiki.ros.org/Client%20Libraries](http://wiki.ros.org/Client%20Libraries))。
- en: Launching the ROS execution environment
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动ROS执行环境
- en: 'Now that we have understood how the Python script integrates with ROS, we will
    execute it in one terminal as part of the ROS runtime environment using the following
    steps:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Python脚本如何与ROS集成，我们将使用以下步骤在终端中作为ROS运行时环境的一部分执行它：
- en: 'Prepare your divided Terminator window again for better visibility, and then
    run each of the following commands in independent terminals:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次准备好你的分割Terminator窗口以提高可见性，然后在独立的终端中运行以下每个命令：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The first one launches the ROS master node. The second one is the script we
    have just explained, while the third allows us to watch messages published under
    the `/distance_sensor/distance` topic in real time. This is what you should see:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个启动ROS主节点。第二个是我们刚刚解释的脚本，而第三个允许我们实时查看`/distance_sensor/distance`主题下发布的信息。这是你应该看到的内容：
- en: '![](img/89d44587-8ad5-4888-aaec-aaf266d05997.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89d44587-8ad5-4888-aaec-aaf266d05997.png)'
- en: 'Then, draw the ROS graph to get a visual insight into how nodes and topics
    are wired:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，绘制ROS图以获得节点和主题如何连接的视觉洞察：
- en: '[PRE76]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'A new window pops up showing the current ROS graph:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新窗口弹出，显示当前的 ROS 图：
- en: '![](img/53110697-034d-4eb7-af1b-37cdbc51f858.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53110697-034d-4eb7-af1b-37cdbc51f858.png)'
- en: 'Here, you can see that it reproduces what we are doing in the three terminals:
    we execute the `/easyDistance_sensor` node, which is publishing sensor data at
    the `/easyDistance_sensor/distance` topic, and then we show the readings with
    a topic subscription node, `/rostopic_2797_156571927410`.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到它重现了我们正在三个终端中做的事情：我们执行了`/easyDistance_sensor`节点，该节点在`/easyDistance_sensor/distance`主题上发布传感器数据，然后我们使用主题订阅节点`/rostopic_2797_156571927410`显示读取值。
- en: After going through this example, we will use it to illustrate the various ROS
    commands and tools that you have available.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过这个例子之后，我们将使用它来展示您可用的各种 ROS 命令和工具。
- en: Working with ROS commands
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ROS 命令
- en: 'In the first part of this section, we will cover three categories: commands
    to be used inside bash (shell), ROS execution commands, and information commands.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的第一个部分，我们将涵盖三个类别：要在 bash（shell）内部使用的命令、ROS 执行命令和信息命令。
- en: Shell commands
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Shell 命令
- en: Shell commands are bundled into a ROS core package, `rosbash` ([http://wiki.ros.org/rosbash](http://wiki.ros.org/rosbash)).
    Let's move on to see what each one provides.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 命令被捆绑到 ROS 核心包`rosbash`([http://wiki.ros.org/rosbash](http://wiki.ros.org/rosbash))中。让我们继续看看每个提供的内容。
- en: Changing the current location
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更改当前位置
- en: 'First, we will cover `roscd`, which is equivalent to the Linux bash `cd` command.
    Its advantage is that you only have to specify the package name in order to move
    to the location of the package:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将介绍`roscd`，它等同于 Linux bash 的`cd`命令。它的优点是您只需指定包名即可移动到包的位置：
- en: '[PRE77]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This will take you to the **`~/catkin_ws/src/mygopigo/` **folder. You can also
    navigate through the package folder structure by appending the relative path of
    the desired location. For example, to move to the `src` folder of the `mygopigo` package,
    use the following command:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带您进入**`~/catkin_ws/src/mygopigo/`**文件夹。您也可以通过附加目标位置的相对路径来在包文件夹结构中导航。例如，要移动到`mygopigo`包的`src`文件夹，请使用以下命令：
- en: '[PRE78]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`roscd` is equivalent to the Linux `cd` command. It will change the prompt
    to the directory of any ROS package in your system by referencing its path with
    the package name. No matter what the actual path is, ROS will automatically drive
    you there.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`roscd`等同于 Linux 的`cd`命令。它将通过引用包名的路径来更改提示符，以指向系统中的任何 ROS 包的目录。无论实际路径是什么，ROS
    都会自动带您去那里。'
- en: Listing files and folders inside a package
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出包内的文件和文件夹
- en: 'Next, we have `rosls`, which is the equivalent of Linux `ls`. To list the source
    code of your package wherever you are, simply write the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有`rosls`，它是 Linux 的`ls`的等价物。要列出您所在位置的包的源代码，只需写下以下内容：
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`rosls` allows you to easily list files and folders inside any ROS package in
    your system by referencing its path with the package name. No matter what the
    actual path is, ROS will automatically take you there.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`rosls`允许您通过引用包名和路径轻松列出系统内任何 ROS 包中的文件和文件夹。无论实际路径是什么，ROS 都会自动带您去那里。'
- en: Editing any file inside a package
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编辑包内的任何文件
- en: 'Finally, we have `rosed`, which opens a terminal editor, such as `nano`, so
    that you can modify any file in the package:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`rosed`，它打开一个终端编辑器，例如`nano`，以便您可以修改包中的任何文件：
- en: '[PRE80]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'For `rosed` to work properly, you have to specify an editor:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`rosed`正常工作，您必须指定一个编辑器：
- en: '[PRE81]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'To make it part of your configuration, add the preceding line to the end of
    your `.bashrc` file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要将其添加到您的配置中，请将前面的行添加到您的`.bashrc`文件末尾：
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '`rosed` is equivalent to launching the Linux terminal editor, which is `nano`.  It
    will allow you to edit any file inside a ROS package by simply telling it the
    package name, no matter which subfolder the file is actually in.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`rosed`等同于启动 Linux 终端编辑器，即`nano`。它将允许您通过简单地告诉它包名来编辑 ROS 包内的任何文件，无论文件实际位于哪个子文件夹中。'
- en: 'This command is a convenient way to modify a file when you are connected remotely
    to the robot and you only have a terminal to interact with. If you are on a desktop
    session, you can even use a desktop IDE if you wish:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当您远程连接到机器人且只有一个终端与之交互时，这个命令是修改文件的一个方便方式。如果您在桌面会话中，您甚至可以使用桌面 IDE：
- en: '[PRE83]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this case, you are calling the editor on the fly and superseding the default
    set in `.bashrc`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您正在即时调用编辑器并覆盖`.bashrc`中设置的默认值。
- en: Execution commands
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行命令
- en: In [Chapter 3](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml), *Getting Started
    with ROS*, we already introduced the `roscore` and `rosrun` commands for running
    our first project.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](f3ecc0de-28c4-4140-9a9c-ed351c68d121.xhtml)“ROS入门”，我们已经介绍了用于运行我们第一个项目的`roscore`和`rosrun`命令。
- en: The central process of the ROS environment
  id: totrans-322
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ROS环境的中心过程
- en: '`roscore` is the first process you have to launch so that the ROS environment
    works.`roscore` allows nodes to communicate between themselves. It has no parameters,
    so write this line in a terminal:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '`roscore`是你必须启动的第一个进程，以便ROS环境工作。`roscore`允许节点之间相互通信。它没有参数，所以请在终端中写下这一行：'
- en: '[PRE84]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`roscore` launches the master node, which is the central process of your ROS
    environment and keeps all nodes that are actually running connected.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`roscore`启动主节点，这是你的ROS环境的中心进程，并保持所有实际运行的节点连接。'
- en: Executing a single node
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行单个节点
- en: '`rosrun` allows you to manually launch a node from a package. The syntax is
    quite simple:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`rosrun`允许你从包中手动启动一个节点。语法相当简单：'
- en: '[PRE85]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The script includes a declaration of a node. In the case of our `distance-sensor.py` example,
    this is accomplished in the following line:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本包括一个节点的声明。在我们的`distance-sensor.py`示例中，这是在以下行中完成的：
- en: '[PRE86]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, to launch the node, write this command in another terminal:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了启动节点，请在另一个终端中写下这个命令：
- en: '[PRE87]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'After these two commands, you already have a ROS functional environment that
    provides sensor readings. The node also prints the current measure in the terminal
    process, transformed into millimeters (there is no need to open another terminal
    to listen to the topic). The usage of millimeters is just for visualization purposes.
    The ROS message keeps its distance units as meters, which you can check by subscribing
    to the topic in another terminal:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个命令之后，你已经拥有了一个提供传感器读数的ROS功能环境。节点还会在终端进程中打印当前的测量值，转换为毫米（无需打开另一个终端来监听主题）。使用毫米只是为了可视化目的。ROS消息保持其距离单位为米，你可以通过在另一个终端订阅主题来检查：
- en: '[PRE88]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`rosrun` allows you to launch a single node from a package. It is a command
    for performing manual node execution within your ROS environment.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`rosrun`允许你从包中启动单个节点。这是在ROS环境中执行手动节点执行的命令。'
- en: Finally, we have `roslaunch`. This is the most relevant execution command since
    it allows you to describe a robot with an XML file. You can declare its nodes
    and link each one with the scripts that execute it. We will view this command
    in more detail in the *Automating the execution of a node using roslaunch* section.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有`roslaunch`。这是最相关的执行命令，因为它允许你使用XML文件描述一个机器人。你可以声明其节点并将每个节点与其执行的脚本链接起来。我们将在“使用roslaunch自动化节点执行”部分更详细地查看这个命令。
- en: Information commands
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 信息命令
- en: This category groups several commands that allow you to extract information
    from ROS environment as well as interactively modify some values. All of the commands
    are prepended with `ros-`. Simply writing the command in the terminal, supplies help
    with the different options regarding how to use each of them. A brief description
    and an example for each command are provided next.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别包含几个命令，允许你从ROS环境中提取信息以及交互式地修改一些值。所有命令都以`ros-`开头。只需在终端中写下命令，就可以提供有关如何使用每个命令的不同选项的帮助。接下来将提供每个命令的简要描述和示例。
- en: Exploring topics
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索主题
- en: '`rostopic` provides information about published topics:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`rostopic`提供有关发布的主题的信息：'
- en: '[PRE89]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This lists all the topics that are currently alive. From the list, you can
    access the real-time feed of any of them:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表包含了所有当前活跃的主题。从列表中，你可以访问其中任何一个的实时流：
- en: '[PRE90]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Exploring nodes
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索节点
- en: '`rosnode`provides information about nodes that are alive:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`rosnode`提供有关活跃节点的信息：'
- en: '[PRE91]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This lists all the nodes of the current ROS graph. From the list, you can access
    information about any of them:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表包含了当前ROS图中所有的节点。从列表中，你可以访问其中任何一个的信息：
- en: '[PRE92]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, `info` will provide you with useful information about the `distance_sensor` node.
    Do not confuse this with the name of the Python script where the node is declared, `distance-sensor.py`.
    The `rosnode` command always refers to the name of the node.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`info`将为你提供关于`distance_sensor`节点的有用信息。不要将其与声明节点的Python脚本名称`distance-sensor.py`混淆。`rosnode`命令始终指的是节点的名称。
- en: The rosmsg command
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rosmsg命令
- en: '`rosmsg`provides information about the types of message used by topics during
    runtime. To give you a practical example, we select the `distance_sensor/distance` topic
    and get the following information about it:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`rosmsg`提供有关运行时由主题使用的消息类型的详细信息。为了给您一个实际例子，我们选择了`distance_sensor/distance`主题，并获得了以下关于它的信息：'
- en: '[PRE93]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This command tells us that the topic has a message type of `sensor_msgs/Range`.
    Then, `rosmsg` informs us of the message structure:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令告诉我们该主题的消息类型为`sensor_msgs/Range`。然后，`rosmsg`通知我们消息结构：
- en: '[PRE94]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The output of this command is what we showed and explained in the *Setting up
    the msg_range object* subsection of the *Case study 1 – writing a ROS package –
    distance sensor* section. In the next chapter, we will provide extended explanations
    about the new message types we will be using in the GoPiGo3 ROS package.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令的输出是我们展示了并在*案例研究1 – 编写ROS软件包 – 距离传感器*部分的*设置msg_range对象*子部分中解释的内容。在下一章中，我们将提供关于我们将要在GoPiGo3
    ROS软件包中使用的新消息类型的扩展说明。
- en: The rosbag command
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: rosbag命令
- en: 'This command allows you to save a session and play it back on demand. Let''s
    look at how to do that:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令允许您保存会话并在需要时回放。让我们看看如何做到这一点：
- en: '[PRE95]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Press *Ctrl* + *C* in the T2 terminal when you want to end the recording. Type `rosbag
    info <bag filename>` into `T2` to get information about the recorded file (the
    default name for the file is composed by the sequence `date-time-topic_name`,
    and it is given the `.bag` extension):'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在T2终端中结束录制时，请按*Ctrl* + *C*。在`T2`中输入`rosbag info <bag filename>`以获取有关记录文件的详细信息（文件的默认名称由`date-time-topic_name`序列组成，并赋予`.bag`扩展名）：
- en: '[PRE96]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Bear in mind that the bag file is placed in the location from which you launched
    the recording session in the `T2` terminal.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，bag文件位于您在`T2`终端启动记录会话的位置。
- en: The recorded bag file allows to reproduce the topic history whenever we want,
    just as we do when we play a recorded song. One example of a typical situation
    where you would use this is to replay the robot behavior without the robot itself,
    using ROS on your laptop. This method eases debugging of the application and enables
    you to drastically reduce the number of times you need to run the software in
    the actual robot.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 记录的bag文件允许我们在任何时候重现主题历史，就像我们播放记录的歌曲一样。一个典型的使用场景示例是，在没有机器人本身的情况下，使用笔记本电脑上的ROS回放机器人行为。这种方法简化了应用程序的调试，并使您能够显著减少在真实机器人上运行软件的次数。
- en: 'First, let''s play it back in the Raspberry Pi by running the following set
    of commands, which include the visualization of the ROS graph (the `rqt_graph` command)
    and the measured distance over time (the `rqt_plot` command):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在Raspberry Pi上通过运行以下命令集来回放，这些命令包括ROS图的可视化（`rqt_graph`命令）以及随时间测量的距离（`rqt_plot`命令）：
- en: '[PRE97]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In this snippet, we have introduced a new command, `rqt_plot`, that will be
    explained later in the *Case study 2– ROS GUI development tools – the Pi camera* section.
    Briefly, it plots a selected ROS topic over time.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们介绍了一个新的命令`rqt_plot`，它将在*案例研究2- ROS GUI开发工具- Pi相机*部分中稍后解释。简而言之，它随时间绘制所选的ROS主题。
- en: 'Now you can playback the session on the laptop bylaunching the same set of
    commands. You will get the following result for `rqt_plot`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过启动相同的命令集在笔记本电脑上回放会话。对于`rqt_plot`，您将得到以下结果：
- en: '![](img/6093c672-283b-4a00-a5e9-8d2a0c59231b.png)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6093c672-283b-4a00-a5e9-8d2a0c59231b.png)'
- en: From the point of view of ROS, the result is exactly the same as if you were
    running the actual launch file in GoPiGo3\. The difference, with respect to the
    figures, is due to the fact that you have ROS Kinetic on your laptop, while the
    robot has the Melodic version (which is more recent).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 从ROS的角度来看，结果与您在GoPiGo3中运行实际的launch文件时完全相同。与图表相比，差异是由于您在笔记本电脑上安装了ROS Kinetic版本，而机器人有Melodic版本（这是更新的版本）。
- en: Packages and the catkin workspace
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件包和catkin工作空间
- en: 'Some commands in this section have already been used when configuring your
    ROS environment. Let''s briefly review them now:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的一些命令已在配置您的ROS环境时使用过。现在让我们简要回顾一下：
- en: '`catkin_init_workspace`initializes a new workspace, as you did at the beginning
    of this chapter.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catkin_init_workspace`初始化一个新的工作空间，就像您在本章开头所做的那样。'
- en: '`catkin_create_pkg`creates a new package.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catkin_create_pkg`创建一个新的软件包。'
- en: '`catkin_make` builds a workspace and should be invoked each time you add a
    package or remove one.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catkin_make`构建一个工作空间，每次您添加或删除一个软件包时都应该调用它。'
- en: 'These are the essential commands. Nevertheless, there are some additional commands
    that are worth mentioning:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基本命令。尽管如此，还有一些额外的命令值得提及：
- en: '`catkin_find`lists the working folders of your ROS environment.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`catkin_find`列出你的ROS环境的工作文件夹。'
- en: '`rospack`provides information about a ROS package, be it from the core, contributed,
    or made by yourself. If you want to know which ROS packages are installed when
    dealing with GoPiGo, you can do so with this command:'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rospack`提供有关ROS包的信息，无论是核心、贡献的还是你自己制作的。如果你想了解处理GoPiGo时安装了哪些ROS包，可以使用此命令：'
- en: '[PRE98]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The only caution you should have is that all of them should have the letters `gopigo` within
    their name so that `grep` can filter them without missing any.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 你唯一需要注意的警告是，它们的名字中都应该包含字母`gopigo`，这样`grep`就可以过滤它们而不会遗漏任何一个。
- en: In this section, we have provided an overview of the most frequent commands.
    Take all the time that you need to feel comfortable using them as you will be
    continuously using them when working with ROS. In the next section, we will extend
    our knowledge of the publish-subscribe pattern by explaining the syntax of the
    subscriber node, which is the node that will read messages from the selected topic.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们提供了最常用命令的概述。请花所有需要的时间来熟悉它们，因为当你与ROS一起工作时，你将不断使用它们。在下一节中，我们将通过解释订阅者节点的语法来扩展我们对发布-订阅模式的了解，该节点将读取所选主题的消息。
- en: Creating and running publisher and subscriber nodes
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和运行发布者和订阅者节点
- en: 'If you have understood how the requirement, `distance-sensor.py`, publisher
    script works, then the following subscriber script should be pretty straightforward
    to follow:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经理解了`distance-sensor.py`发布者脚本的工作原理，那么以下订阅者脚本应该很容易理解：
- en: '[PRE99]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This snippet corresponds to the `distance-sensor_subscriber.py` file in the
    `./pkg_mygopigo/src` folder of the code for this chapter. The main difference
    in the subscriber script is that, since we are listening to a topic, we do not
    need to specify a rate of execution. We simply loop forever with the following
    line:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码对应于本章代码`./pkg_mygopigo/src`文件夹中的`distance-sensor_subscriber.py`文件。订阅者脚本中的主要区别在于，由于我们正在监听一个主题，我们不需要指定执行速率。我们只需使用以下行无限循环：
- en: '[PRE100]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Whenever a message is received in the topic, a callback function will be executed:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 每当在主题中接收到消息时，都会执行一个回调函数：
- en: '[PRE101]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'In this case, this callback function is defined to print the measured distance
    in millimeters:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这个回调函数被定义为打印以毫米为单位的测量距离：
- en: '[PRE102]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Execute the script within ROS by using several terminals in the Terminator window:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在Terminator窗口中使用多个终端在ROS中执行脚本：
- en: '[PRE103]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Take a look at the terminal window, as follows:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下终端窗口，如下所示：
- en: '![](img/81801fe8-0f93-436c-bae6-90c564c73ed0.png)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/81801fe8-0f93-436c-bae6-90c564c73ed0.png)'
- en: 'The following is globally the ROS graph:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是全球ROS图：
- en: '![](img/4d8030c9-7fce-4e2b-b257-c32b88a7a8a4.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d8030c9-7fce-4e2b-b257-c32b88a7a8a4.png)'
- en: There are two nodes listening to the same topic. One is the subscriber script
    we have explained with the `/distance_subscriber` node, and the other is the node
    created by the `rostopic echo` command.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个节点在监听同一个主题。一个是使用`/distance_subscriber`节点解释的订阅者脚本，另一个是`rostopic echo`命令创建的节点。
- en: So far, you have manually launched each ROS node. In the next section, you will
    learn how to do it programmatically to run the robot software as an automated
    task.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经手动启动了每个ROS节点。在下一节中，你将学习如何以编程方式执行，以将机器人软件作为自动化任务运行。
- en: Automating the execution of nodes using roslaunch
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`roslaunch`自动化节点的执行
- en: 'Once you have decided which nodes you want to run as part of your robot, you
    can automate the launch process for all scripts by using the `roslaunch` command.
    Its syntax is as follows:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你决定将哪些节点作为你机器人的部分运行，你可以通过使用`roslaunch`命令来自动化所有脚本的启动过程。它的语法如下：
- en: '[PRE104]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'For our example, this is pretty simple as there is only one node. The launch
    file is in the repository at `./pkg_mygopigo/launch/easyDistance.launch` and its
    syntax is based on XML:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的例子来说，这很简单，因为只有一个节点。启动文件在`./pkg_mygopigo/launch/easyDistance.launch`仓库中，其语法基于XML：
- en: '[PRE105]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The `<launch>` tag delineates the robot description. Then, you include one `<node>` tag
    for each node you want to launch. In our case, there is only one: the `distance_sensor` node.
    The description of its attributes is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '`<launch>`标签界定机器人描述。然后，为每个你想要启动的节点包含一个`<node>`标签。在我们的例子中，只有一个：`distance_sensor`节点。其属性的描述如下：'
- en: '`name`: The designation to identify the node. This supersedes the given name in
    the line of the script:'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：用于识别节点的名称。这取代了脚本行中给出的名称：'
- en: '[PRE106]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'We set a different name in this launch file, `easyDistance_sensor`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在此启动文件中我们设置了不同的名称，`easyDistance_sensor`：
- en: '`pkg`: This is the name of the package, which is `mygopigo`.'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pkg`：这是包的名称，是`mygopigo`。'
- en: '`type`: This is a reference to the script that launches the node, `easyDistance.py`.'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：这是启动节点的脚本的引用，`easyDistance.py`。'
- en: '`output`: We specify the screen (the default is the log that directs the output
    to `$ROS_HOME/log`).'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`output`：我们指定屏幕（默认是输出到`$ROS_HOME/log`的日志）。'
- en: 'Once you understand the XML launch file, repeat the process of raising up the
    robot, but, this time, use the automated way:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了XML启动文件，重复提升机器人的过程，但这次使用自动方式：
- en: '[PRE107]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '`roslaunch` implicitly initiates `roscore`. You should see the same output
    as when you run it manually with `rosrun`. Obviously, `roslaunch` is really useful
    when you have to launch many nodes at the same time. We will see examples of this
    later.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`roslaunch`隐式启动`roscore`。你应该看到与手动使用`rosrun`运行时的相同输出。显然，`roslaunch`在需要同时启动多个节点时非常有用。我们将在稍后看到这方面的示例。'
- en: 'Execute the script within ROS by using several terminals under the Terminator window:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Terminator窗口下的几个终端中执行脚本，在ROS中执行脚本：
- en: '[PRE108]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Take a look at the following terminal window:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下终端窗口：
- en: '![](img/f3760ca9-60e7-4f59-acc7-a4fa33d2a883.png)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f3760ca9-60e7-4f59-acc7-a4fa33d2a883.png)'
- en: 'Here is the ROS graph:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是ROS图：
- en: '![](img/a51490a0-db4f-4816-92f0-cbdf9d454f52.png)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a51490a0-db4f-4816-92f0-cbdf9d454f52.png)'
- en: You will find exactly the same result as in the previous section. Let's now
    look at the ROS visual tools that ease our life as a software robotics developer.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 你将发现与上一节完全相同的结果。现在让我们看看ROS可视化工具，这些工具可以简化我们作为软件机器人开发者的生活。
- en: Case study 2 – ROS GUI development tools – the Pi Camera
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究2 – ROS GUI开发工具 – Pi Camera
- en: 'As we mentioned at the end of the *Installing ROS Melodic* section, in order
    to be able to use the camera, we first need to install its ROS package. Since
    the binaries are not available for ROS Melodic (only for Kinetic), we need to
    build the package from the source, and this is a perfect example in that you will
    know how to do it with any other package. Let''s do this with the following steps:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*安装ROS Melodic*部分结束时提到的，为了能够使用相机，我们首先需要安装其ROS包。由于二进制文件对ROS Melodic不可用（仅对Kinetic可用），我们需要从源代码构建包，这是一个完美的例子，你将知道如何对任何其他包这样做。让我们按照以下步骤进行：
- en: 'Go to your `catkin` workspace and download the source code:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往你的`catkin`工作空间并下载源代码：
- en: '[PRE109]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'There are some dependencies to be installed for ROS. To carry out this task,
    we are going to create the `30-ubiquity.list` file:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于ROS，需要安装一些依赖项。为了执行此任务，我们将创建`30-ubiquity.list`文件：
- en: '[PRE110]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Afterward, run the ROS dependencies update as follows:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，按照以下方式运行ROS依赖项更新：
- en: '[PRE111]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Now install the ROS dependencies:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在安装ROS依赖项：
- en: '[PRE112]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Compile the new package as follows:'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按以下方式编译新包：
- en: '[PRE113]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: If you were using `catkin_make` without any option, the build process would 
    traverse all the packages in the workspace. So, this snippet shows you how to
    compile a single package while ignoring the rest. The second line allows you to
    switch back to enable building all the packages the next item you need to compile
    the workspace.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`catkin_make`没有任何选项，构建过程将遍历工作空间中的所有包。因此，此代码片段显示了如何在忽略其余包的情况下编译单个包。第二行允许你在需要编译工作空间中的下一个包时切换回启用构建所有包。
- en: 'To run the Pi Camera node, simply launch the following command:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行Pi Camera节点，只需启动以下命令：
- en: '[PRE114]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'If you own the previous Pi Camera version, `V1`, use the following instead:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你拥有之前的Pi Camera版本，`V1`，请使用以下替代方案：
- en: '[PRE115]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Then, in another terminal, run the image viewer utility that comes with the
    package to check that the camera is working properly:'
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在另一个终端中运行随包提供的图像查看器实用程序，以检查相机是否正常工作：
- en: '[PRE116]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'You should see a new window similar to the following:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到一个类似以下的新窗口：
- en: '![](img/f324979f-5367-46df-8fe9-2b27319c96bd.png)'
  id: totrans-439
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f324979f-5367-46df-8fe9-2b27319c96bd.png)'
- en: If you move the robot, you will find that the image also changes, so you are
    watching a live camera stream. Now we are ready to proceed with practical explanations
    for the ROS GUI development tools, which is the scope of this section.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你移动机器人，你会发现图像也会改变，所以你正在观看实时相机流。现在我们准备进行本节范围的ROS GUI开发工具的实际解释。
- en: Analyzing the ROS graph using rqt_graph
  id: totrans-441
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用rqt_graph分析ROS图
- en: 'By issuing this command, you can visualize the current ROS graph:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 通过发出此命令，你可以可视化当前的 ROS 图形：
- en: '[PRE117]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'It will show the following diagram:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 它将显示以下图表：
- en: '![](img/c09ca960-8abf-4fa1-89c9-5e9610c89ca9.png)'
  id: totrans-445
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c09ca960-8abf-4fa1-89c9-5e9610c89ca9.png)'
- en: '`raspicam_node` is the root node of the package that interfaces with the physical
    Pi Camera. It publishes images in the `/raspicam_node/image/compressed` topic.
    The other node, `imv_view`, from the process in the `T2` terminal, launches a
    window where you can watch the live stream (as shown in the preceding section).'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`raspicam_node` 是与物理 Pi Camera 接口的包的根节点。它在 `/raspicam_node/image/compressed`
    主题中发布图像。另一个节点 `imv_view` 来自 `T2` 终端的进程，它启动一个窗口，你可以在这里观看实时流（如前节所示）。'
- en: 'Finally, inspecting the topic''s `raspicam_node` provides the following:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，检查主题的 `raspicam_node` 提供以下信息：
- en: '[PRE118]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: You can find in the list the node that the `imv_view` node is subscribed to,
    which is `/raspicam_node/image/compressed`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在列表中找到 `imv_view` 节点订阅的节点，即 `/raspicam_node/image/compressed`。
- en: Displaying image data using rqt_image_view
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 rqt_image_view 显示图像数据
- en: 'This plugin allows you to visualize image data that is published in a ROS topic.
    Kill the previous two terminals and launch the following new ones:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件允许你可视化在 ROS 主题中发布的图像数据。关闭前两个终端，并启动以下新的终端：
- en: '[PRE119]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'In the upper-left drop-down list, select the topic of the image that you want
    to visualize. It needs to be in compressed format as it is published by `raspicam_node`.
    The following screenshot shows the result:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在左上角的下拉列表中，选择你想要可视化的图像主题。由于它是由 `raspicam_node` 发布的，所以它需要以压缩格式存在。以下截图显示了结果：
- en: '![](img/34696f23-cd46-48b4-ad83-36d3d1e675a0.png)'
  id: totrans-454
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34696f23-cd46-48b4-ad83-36d3d1e675a0.png)'
- en: In the event you have several topics with image data, the plugin allows you
    to interactively select what feed to watch and also change between them on demand.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有几个包含图像数据的主题，此插件允许你交互式地选择要观看的源，并在需要时在它们之间切换。
- en: Graphing time series of sensor data with rqt_plot
  id: totrans-456
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 rqt_plot 绘制传感器数据的时间序列图
- en: 'This is a plugin to visualize two-dimensional data. As we want to see two-dimensional
    data, let''s briefly switch to the distance sensor case study so that we can view
    the measured distance over time. The process is straightforward: launch the robot,
    list the topics, and then launch the plugin:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于可视化二维数据的插件。由于我们想看到二维数据，让我们简要切换到距离传感器案例研究，以便我们可以查看随时间测量的距离。过程很简单：启动机器人，列出主题，然后启动插件：
- en: '[PRE120]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'In the upper-left box, write the name of the topic you want to visualize, that
    is, `/distance_sensor/distance` as per `T2`. A window will pop up showing the
    distance to the obstacle over time:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 在左上方的框中，写下你想要可视化的主题名称，即按照 `T2`，`/distance_sensor/distance`。一个窗口将弹出，显示随时间变化的障碍物距离：
- en: '![](img/6c5007ce-e548-48c7-a300-68aba2c0d44f.png)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c5007ce-e548-48c7-a300-68aba2c0d44f.png)'
- en: The green line, `msg_range.range`, is the actual measurement. The other fields
    of the `msg_range` object (this is the content of `topic/distance_sensor/distance`)
    display the maximum and minimum values of all the measurements: `msg_range.max_range`
    and `msg_range.min_range`, respectively.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 绿线 `msg_range.range` 是实际测量值。`msg_range` 对象的其他字段（这是 `topic/distance_sensor/distance`
    的内容）显示所有测量的最大值和最小值：`msg_range.max_range` 和 `msg_range.min_range`。
- en: Playing a recorded ROS session with rqt_bag
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 rqt_bag 播放记录的 ROS 会话
- en: 'The `rqt_bag` plugin plays a bag file, which is the same as the `rosbag` command
    explained in the *ROS commands* section. Here, the advantage is that you have
    interactive control of the playback: you can jump to any instant, play single
    time steps, rewind to the beginning, and so on. Let''s examine this with the distance
    sensor case study first, and then with the Pi Camera.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`rqt_bag` 插件播放一个 bag 文件，这与在 *ROS 命令* 部分解释的 `rosbag` 命令相同。在这里，优势在于你可以对播放进行交互式控制：你可以跳转到任何瞬间，播放单个时间步，回放到开始，等等。让我们首先通过距离传感器案例研究来检验这一点，然后是
    Pi Camera。'
- en: Distance sensor
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离传感器
- en: 'You can perform the playback wherever you want, using the robot or the laptop.
    As with `rosbag`, you will need prior access to a `roscore` process, then you
    can issue `rqt_bag`:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何地方执行回放，使用机器人或笔记本电脑。与 `rosbag` 一样，你需要先访问 `roscore` 进程，然后可以发出 `rqt_bag`：
- en: '[PRE121]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'A new window pops up. Select the bag file to play, that is, `2019-08-15-20-36-36_distanceSensor.bag`, right-click
    on the windows, and then mark the `/distance_sensor/distance` topic to be published.
    Run the same set of commands as when you used `rosbag`:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的窗口弹出。选择要播放的文件包，即`2019-08-15-20-36-36_distanceSensor.bag`，在窗口上右键单击，然后标记`/distance_sensor/distance`主题以发布。运行与使用`rosbag`时相同的命令集：
- en: '[PRE122]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In the following screenshot, you can check that the result is the same:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，你可以检查结果是否相同：
- en: '![](img/ecc4d4cb-1789-4fa3-9735-abb2fe0a8467.png)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ecc4d4cb-1789-4fa3-9735-abb2fe0a8467.png)'
- en: Now we will play the image stream from the Pi Camera case study.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将播放Pi Camera案例研究中的图像流。
- en: The Pi Camera
  id: totrans-472
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pi相机
- en: 'First, we need to record a session with the robot:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要记录机器人的一个会话：
- en: '[PRE123]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Check the information about the recorded file:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 检查录制文件的详细信息：
- en: '[PRE124]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'You can perform the playback wherever you want, using the robot or the laptop.
    In this case, the image data is bulkier. So, it is much better to play the session
    on the laptop. Launch the processes as before:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何地方播放回放，使用机器人或笔记本电脑。在这种情况下，图像数据更庞大。因此，在笔记本电脑上播放会话会更好。按照之前的方式启动进程：
- en: '[PRE125]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In the launched `rqt_bag` plugin, select the bag file to play, which is `2019-08-15-20-44-53_raspicamImage.bag`,
    right-click on the windows, and then mark the `/raspicam_node/image/compressed`
    topic to be published. Afterward, run the following set of commands:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动的`rqt_bag`插件中，选择要播放的文件包，即`2019-08-15-20-44-53_raspicamImage.bag`，在窗口上右键单击，然后标记`/raspicam_node/image/compressed`主题以发布。之后，运行以下命令集：
- en: '[PRE126]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'In the upper-left drop-down list of `rqt_image_view`, select the topic of the
    image that you want to visualize. It needs to be in compressed format as it is published
    by `raspicam_node`. In the following screenshot, you can check that the result
    is the same:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在`rqt_image_view`的左上角下拉列表中选择你想要可视化的图像主题。它需要以压缩格式发布，因为它是由`raspicam_node`发布的。在下面的屏幕截图中，你可以检查结果是否相同：
- en: '![](img/11f0baf0-73ae-4571-b9f6-c5924762d91d.png)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11f0baf0-73ae-4571-b9f6-c5924762d91d.png)'
- en: While playing the *bag* file, you can check that the image stream is very fluent
    thanks to the fact that your laptop has a powerful GPU compared to what the Raspberry
    Pi provides. So, it is clear that, when you are dealing with computer vision tasks,
    you will take advantage of this visualization capability of robot sessions within
    your laptop.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在播放文件包时，你可以检查由于你的笔记本电脑与Raspberry Pi相比拥有更强大的GPU，图像流非常流畅。因此，很明显，当你处理计算机视觉任务时，你将利用笔记本电脑中机器人会话的这种可视化能力。
- en: Customizing robot features using ROS parameters
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ROS参数自定义机器人功能
- en: 'ROS parameters store the global configuration of the robot. This is a convenient
    way in which to define your application so that you can abstract the functionality
    to a high level and make it available for the end user. We are going to illustrate
    how ROS parameters work by using a `rqt` plugin that allows for dynamically reconfiguring
    of some of them. It is as it sounds; you can modify robot characteristics on the
    fly:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: ROS参数存储机器人的全局配置。这是一种定义你的应用程序的便捷方式，这样你可以将功能抽象到高级别，并使其对最终用户可用。我们将通过使用允许动态重新配置其中一些参数的`rqt`插件来展示ROS参数的工作原理。正如其名，你可以实时修改机器人的特性：
- en: 'Launch `raspicam_node` and then the `rqt` plugins:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动`raspicam_node`然后启动`rqt`插件：
- en: '[PRE127]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Your desktop should show the following two windows:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 你的桌面应该显示以下两个窗口：
- en: '![](img/e4624f05-067b-4e2b-b110-4f568f7c7533.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e4624f05-067b-4e2b-b110-4f568f7c7533.png)'
- en: 'Check the parameters on the right-hand side and focus on the brightness (the
    box marked in red). Modify its value from `51` to `81` and then check the result:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查右侧的参数，并关注亮度（红色标记的框）。将它的值从`51`修改到`81`，然后检查结果：
- en: '![](img/4128ffb6-35cd-40f7-bc82-09489fc000e3.png)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4128ffb6-35cd-40f7-bc82-09489fc000e3.png)'
- en: Wow! You can dynamically modify the configuration of the robot without needing
    to restart it.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！你可以在不重新启动机器人的情况下动态修改机器人的配置。
- en: 'You also have the `rosbash` command, which allows you to inspect the parameters.
    List them with the following line:'
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还有`rosbash`命令，它允许你检查参数。使用以下行列出它们：
- en: '[PRE128]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Additionally, get the state of the one we have dynamically modified:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，获取我们动态修改的状态：
- en: '[PRE129]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: If you have arrived at this point and understand the concepts in the practical
    exercises, you now know almost everything that you need to work with ROS from
    now on.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经到达这个阶段并且理解了实际练习中的概念，你现在几乎知道你需要用ROS做的一切。
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have established the basis for programming in ROS. You
    have built your own package with a simple GoPiGo3 functionality: reading a distance
    sensor in order to work on programming concepts. You have also learned how to
    read Pi Camera images and make them available to ROS for further processing, which
    is the starting point for performing computer vision tasks.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们为ROS编程奠定了基础。您已经构建了自己的包，并添加了简单的GoPiGo3功能：读取距离传感器，以便于编程概念的学习。您还学习了如何读取Pi
    Camera图像并将它们提供给ROS进行进一步处理，这是执行计算机视觉任务的起点。
- en: 'In the next chapter, you will put the two ROS worlds together: the robot and
    your laptop. This way, once you have the GoPiGo3 package running in the robot,
    you will have the power to undertake all computing and processing tasks from your
    powerful laptop.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将把两个ROS世界结合起来：机器人和您的笔记本电脑。这样，一旦您在机器人上运行了GoPiGo3包，您将能够从您强大的笔记本电脑上执行所有计算和处理任务。
- en: Questions
  id: totrans-501
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between ROS topics and ROS messages?
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ROS主题和ROS消息之间的区别是什么？
- en: A) Both stand for the data transmitted from one node to the other.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: A) 它们都代表从一个节点传输到另一个节点的数据。
- en: B) A topic is how you identify a transmission channel and a message is one sample
    of the content that flows through that channel.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: B) 主题是您识别传输通道的方式，而消息是通过该通道流动的内容的一个样本。
- en: C) Any topic name has to be unique, while several topics can transmit the same
    message.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: C) 任何主题名称都必须是唯一的，而多个主题可以传输相同的信息。
- en: Which command would use to record a ROS session?
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将使用哪个命令来记录ROS会话？
- en: A) `rosbag`
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: A) `rosbag`
- en: B) `rosrecord`
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: B) `rosrecord`
- en: C) `roswrite`
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: C) `roswrite`
- en: Can a ROS node have a publisher and a subscriber at the same time?
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个ROS节点可以在同一时间既是发布者又是订阅者吗？
- en: A) Yes, if the topic subscriber is the same as the topic publisher.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: A) 是的，如果主题订阅者与主题发布者相同。
- en: 'B) No, because it would imply a programming conflict: a node with a publisher
    loops at a constant rate, that is, `rate.sleep()`, while a node with a subscriber
    only runs an iteration if it receives a message, that is, `rospy.spin()`.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: B) 不可以，因为这会意味着编程冲突：一个具有发布者的节点以恒定速率循环，即`rate.sleep()`，而一个具有订阅者的节点只有在接收到消息时才运行一个迭代，即`rospy.spin()`。
- en: C) Yes, and the node is driven by the subscriber, that is, the node broadcasts
    a new message each time it receives a message from the topic it is subscribed
    to.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: C) 是的，并且节点是由订阅者驱动的，也就是说，节点每次从它订阅的主题接收到消息时都会广播一个新的消息。
- en: How many `roslaunch` commands can you run in the same ROS session?
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个ROS会话中，您可以运行多少个`roslaunch`命令？
- en: A) As many as you need; `roslaunch` is a description file that tells ROS what
    nodes to launch when the command is called.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: A) 您需要的数量；`roslaunch`是一个描述文件，它告诉ROS在调用命令时启动哪些节点。
- en: B) Just one, because `roslaunch` implicitly runs a `roscore` process, and you
    can only have one ROS master node in the session.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: B) 只有一个，因为`roslaunch`隐式运行一个`roscore`进程，并且会话中只能有一个ROS主节点。
- en: C) If you need two sets of nodes, it is recommended that you launch each of
    them manually when you need to add each to the execution environment. Then, start
    a `roscore` process and later execute a `rosrun` for every new node you need.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: C) 如果您需要两组节点，建议您在需要将每个节点添加到执行环境时手动启动它们。然后，启动一个`roscore`进程，之后为每个新节点执行一个`rosrun`。
- en: Is there a programmatic way to visualize an image that is published in a ROS
    topic?
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有没有一种程序化的方法可以可视化在ROS主题中发布的图像？
- en: A) Yes, using `rqt_plot`
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: A) 是的，使用`rqt_plot`
- en: B) Yes, using `rqt_image_view`
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: B) 是的，使用`rqt_image_view`
- en: C) Yes, using `rqt_image_view`, but it is necessary that the image is in a compressed
    format
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: C) 是的，使用`rqt_image_view`，但图像必须是压缩格式。
- en: Further reading
  id: totrans-522
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To go deeper into the concepts we have explained in this chapter, you can follow
    the following references and tutorials:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解本章中我们解释的概念，您可以参考以下参考资料和教程：
- en: ROS technical overview: [http://wiki.ros.org/ROS/Technical%20Overview](http://wiki.ros.org/ROS/Technical%20Overview)
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS技术概述：[http://wiki.ros.org/ROS/Technical%20Overview](http://wiki.ros.org/ROS/Technical%20Overview)
- en: ROS cheatsheet: [https://kapeli.com/cheat_sheets/ROS.docset/Contents/Resources/Documents/index](https://kapeli.com/cheat_sheets/ROS.docset/Contents/Resources/Documents/index)
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS速查表：[https://kapeli.com/cheat_sheets/ROS.docset/Contents/Resources/Documents/index](https://kapeli.com/cheat_sheets/ROS.docset/Contents/Resources/Documents/index)
- en: ROS command line – the `rosbash` commands: [http://wiki.ros.org/rosbash](http://wiki.ros.org/rosbash)
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS命令行 – `rosbash`命令：[http://wiki.ros.org/rosbash](http://wiki.ros.org/rosbash)
- en: Master node – the `roscore` command and process: [http://wiki.ros.org/roscore](http://wiki.ros.org/roscore)
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主节点 – `roscore` 命令和进程：[http://wiki.ros.org/roscore](http://wiki.ros.org/roscore)
- en: ROS topics – the `rostopic` command description: [http://wiki.ros.org/rostopic](http://wiki.ros.org/rostopic)
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 主题 – `rostopic` 命令说明：[http://wiki.ros.org/rostopic](http://wiki.ros.org/rostopic)
- en: ROS nodes – the  `rosnode` command description: [http://wiki.ros.org/rosnode](http://wiki.ros.org/rosnode)
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 节点 – `rosnode` 命令说明：[http://wiki.ros.org/rosnode](http://wiki.ros.org/rosnode)
- en: Messages – the `rosmsg` command description: [http://wiki.ros.org/rosmsg](http://wiki.ros.org/rosmsg)
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息 – `rosmsg` 命令说明：[http://wiki.ros.org/rosmsg](http://wiki.ros.org/rosmsg)
- en: ROS parameters – the `rosparam` command description: [http://wiki.ros.org/rosparam](http://wiki.ros.org/rosparam)
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS 参数 – `rosparam` 命令说明：[http://wiki.ros.org/rosparam](http://wiki.ros.org/rosparam)
- en: Record sessions – the `rosbag` command description: [http://wiki.ros.org/rosbag](http://wiki.ros.org/rosbag)
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录会话 – `rosbag` 命令说明：[http://wiki.ros.org/rosbag](http://wiki.ros.org/rosbag)
- en: Recording and playing back data with `rosbag`: [http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data](http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data)
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `rosbag` 记录和回放数据：[http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data](http://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data)
- en: Catkin command-line tools: [https://catkin-tools.readthedocs.io](https://catkin-tools.readthedocs.io)
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Catkin 命令行工具：[https://catkin-tools.readthedocs.io](https://catkin-tools.readthedocs.io)
- en: The Pi Camera official documentation: [https://picamera.readthedocs.io](https://picamera.readthedocs.io)
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pi Camera 官方文档：[https://picamera.readthedocs.io](https://picamera.readthedocs.io)
- en: ROS `rqt` GUI tools: [http://wiki.ros.org/rqt](http://wiki.ros.org/rqt)
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ROS `rqt` 图形界面工具：[http://wiki.ros.org/rqt](http://wiki.ros.org/rqt)
- en: The `rqt_graph` plugin: [http://wiki.ros.org/rqt_graph](http://wiki.ros.org/rqt_graph)
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rqt_graph` 插件：[http://wiki.ros.org/rqt_graph](http://wiki.ros.org/rqt_graph)'
- en: The `rqt_image_view` plugin: [http://wiki.ros.org/rqt_image_view](http://wiki.ros.org/rqt_image_view)
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rqt_image_view` 插件：[http://wiki.ros.org/rqt_image_view](http://wiki.ros.org/rqt_image_view)'
- en: The `rqt_plot` plugin: [http://wiki.ros.org/rqt_plot](http://wiki.ros.org/rqt_plot)
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rqt_plot` 插件：[http://wiki.ros.org/rqt_plot](http://wiki.ros.org/rqt_plot)'
- en: The `rqt_bag` plugin: [http://wiki.ros.org/rqt_bag](http://wiki.ros.org/rqt_bag)
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rqt_bag` 插件：[http://wiki.ros.org/rqt_bag](http://wiki.ros.org/rqt_bag)'
- en: 'Using `rqt` tools for analysis – `rqt_console`, `rqt_graph`, and `urdf_to_graphviz`:
    [http](https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html)[s://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html](https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html)'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `rqt` 工具进行分析 – `rqt_console`、`rqt_graph` 和 `urdf_to_graphviz`：[http://](https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html)[s://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html](https://industrial-training-master.readthedocs.io/en/melodic/_source/session6/Using-rqt-tools-for-analysis.html)
