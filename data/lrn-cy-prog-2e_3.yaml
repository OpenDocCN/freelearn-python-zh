- en: Chapter 3. Extending Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章：扩展应用程序
- en: As mentioned in previous chapters, I want to show you how to interact or extend
    existing code using Cython. So, let's get right to doing that. Cython was originally
    designed to make raw Python computation faster. So, the initial proof of concept
    for Cython was to enable programmers to take existing Python code and use Cython's
    `cdef` keyword to require native typing to bypass the Python runtime for heavy
    computation. The culmination of this is increased performance in the time it takes
    to perform calculations and lower memory usage. It's even possible to write type-safe
    wrappers to existing Python libraries for fully typed Python code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，我想向你展示如何使用 Cython 与现有代码交互或扩展。所以，让我们直接开始做吧。Cython 最初是为了使原始 Python 计算更快而设计的。因此，Cython
    的初始概念验证是允许程序员使用 Cython 的 `cdef` 关键字将现有 Python 代码转换为原生类型，以绕过 Python 运行时进行重计算。这一成果是计算时间的性能提升和内存使用降低。甚至可以编写类型安全的包装器来为完全类型化的
    Python 代码扩展现有 Python 库。
- en: In this chapter, we will first see an example of typing Python code. Next, I
    will demonstrate the Cython `cdef` class, which allow us to wrap native C/C++
    types into garbage collected Python classes. We will also see how to extend the
    native application **Tmux** with Python code by creating a pure Python command
    object, which is directly embedded into the native code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先看到一个编写 Python 代码的示例。接下来，我将演示 Cython 的 `cdef` 类，它允许我们将原生 C/C++ 类型包装成垃圾回收的
    Python 类。我们还将看到如何通过创建纯 Python 命令对象来扩展原生应用程序 **Tmux**，该对象直接嵌入到原生代码中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Cython pure Python code
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 纯 Python 代码
- en: Compiling pure Python code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译纯 Python 代码
- en: Python garbage collector
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 垃圾回收器
- en: Extending Tmux
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展 Tmux
- en: Embedding Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入 Python
- en: Cythonzing struct cmd_entry
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 化 struct cmd_entry
- en: Implementing a Tmux command
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个 Tmux 命令
- en: Cython pure Python code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 纯 Python 代码
- en: 'Let''s view a mathematical application that is actually taken from the Cython
    documentation. I wrote this equivalent in pure Python so that we can compare the
    speed. If you open the `primes` example for this chapter, you will see two programs—the
    Cython `primes.pyx` example, and my pure Python port. They both look almost the
    same:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一个实际上来自 Cython 文档的数学应用。我将其等效地用纯 Python 编写，以便我们可以比较速度。如果你打开本章的 `primes`
    示例，你会看到两个程序——Cython 的 `primes.pyx` 示例和我的纯 Python 版本。它们看起来几乎相同：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This really is a direct Python port of that Cython code. Both call `primes
    (10000)`, but the evaluation time is very different between them in terms of performance:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是将 Cython 代码直接转换为 Python。两者都调用 `primes (10000)`，但它们在性能方面的评估时间差异很大：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that the pure Python version was almost five times slower in doing
    the exact same job. Moreover, nearly every line of code is the same. Cython can
    do this because we have explicitly expressed the C types, hence there is no type
    conversion or folding, and we don't even have to use the Python runtime. I want
    to draw attention to the kind of speedups you can get with just simple code without
    calling into other native libraries. This is what makes Cython so prevalent in
    SAGE.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，纯 Python 版本在执行相同任务时几乎慢了五倍。此外，几乎每一行代码都是相同的。Cython 可以做到这一点，因为我们已经明确地表达了
    C 类型，因此没有类型转换或折叠，我们甚至不需要使用 Python 运行时。我想强调的是，仅通过简单的代码而不调用其他原生库就能获得的速度提升。这就是为什么
    Cython 在 SAGE 中如此普遍。
- en: Compiling pure Python code
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译纯 Python 代码
- en: 'Another use for Cython is to compile Python code. For example, if we go back
    to the `primes` example, we can do the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 的另一个用途是编译 Python 代码。例如，如果我们回到 `primes` 示例，我们可以做以下操作：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we can compare the three different versions of the same program: the
    Cython version using `cdef` for native types, the pure Python version running
    as a Python script, and finally, the Cython-compiled pure Python version, which
    results in an executable binary of Python code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以比较同一程序的三个不同版本：使用 `cdef` 为原生类型编写的 Cython 版本，作为 Python 脚本运行的纯 Python 版本，以及最终，由
    Cython 编译的纯 Python 版本，它生成 Python 代码的可执行二进制文件：
- en: 'First, the Cython version using native types:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，使用原生类型的 Cython 版本：
- en: '[PRE3]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, the executable pure Python version:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，可执行的纯 Python 版本：
- en: '[PRE4]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And finally, the Python script version:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，Python 脚本版本：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The pure Python version runs the slowest, the compiled Python version runs a
    little bit faster, and finally, the natively-typed Cython version runs the fastest.
    I think it just draws attention to how well Cython can give you some dynamic language
    optimizations in several different ways.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 纯 Python 版本运行速度最慢，编译后的 Python 版本运行速度略快，最后，原生类型化的 Cython 版本运行速度最快。我认为这仅仅突出了 Cython
    以几种不同的方式为你提供一些动态语言优化的能力。
- en: Notice that when compiling the Python version to a binary, I specified `–embed`
    on invoking the Cython compiler. This tells the compiler to **--embed** a main
    method for us and to run as you would expect a normal Python script to run.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将 Python 版本编译成二进制文件时，我在调用 Cython 编译器时指定了 `–embed`。这告诉编译器为我们嵌入一个主方法，并按预期运行正常的
    Python 脚本。
- en: Avoid Makefiles – pyximport
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免使用 Makefile – pyximport
- en: From the previous example, you can see that it was code which didn't depend
    on any outside libraries. To make such code useful, wouldn't it be nice if we
    could bypass the Makefile and the invocation of compilers? It turns out that,
    in cases where we do not require linking against other native libraries, we can
    directly import our `.pyx` files into Python programs. You are required, however,
    to have Cython installed as a dependency.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，你可以看到这是不依赖于任何外部库的代码。要使这样的代码有用，如果我们可以绕过 Makefile 和编译器的调用，那岂不是很好？实际上，在不需要链接其他原生库的情况下，我们可以直接将
    `.pyx` 文件导入到 Python 程序中。然而，你仍然需要将 Cython 作为依赖项安装。
- en: 'Going back to [Chapter 1](ch01.html "Chapter 1. Cython Won''t Bite"), *Cython
    Won''t Bite*, we can simply import our `helloworld.pyx` by importing `pyximport`
    first:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[第1章](ch01.html "第1章。Cython 不会咬人")，“Cython 不会咬人”，我们可以通过首先导入 `pyximport` 来简单地导入我们的
    `helloworld.pyx`：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Behind the scenes, Cython is invoking all the compiler work for you so that
    you don't have to. But this leads to interesting ideas, such as that you could
    simply add Cython code to any Python project so long as Cython is a dependency.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Cython 会为你调用所有的编译工作，这样你就不必亲自做了。但这引发了一些有趣的想法，比如你只需将 Cython 代码添加到任何 Python
    项目中，只要 Cython 是一个依赖项即可。
- en: Python garbage collector
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 垃圾回收器
- en: 'When wrapping up native structs, for example, it can be very tempting to follow
    standard C/C++ idioms and require the Python programmer to call, allocate, and
    release manually on different objects. This is very tedious and not very Pythonic.
    Cython allows us to create `cdef` classes, which have extra hooks for initialization
    and deallocation that we can use to control all memory management of structs.
    These hooks are triggered automatically by the Python garbage collector, making
    everything nice and simple. Consider the following simple `struct`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当包装原生 `struct` 时，例如，可能会非常诱人遵循标准的 C/C++ 习惯用法，并要求 Python 程序员手动调用、分配和释放不同的对象。这非常繁琐，而且不太符合
    Python 风格。Cython 允许我们创建 `cdef` 类，这些类有额外的初始化和析构钩子，我们可以使用这些钩子来控制 `struct` 的所有内存管理。这些钩子会自动由
    Python 垃圾回收器触发，使一切变得简单。考虑以下简单的 `struct`：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can then write the Cython declaration of the C `struct` into `PyData.pxd`
    as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 C `struct` 的 Cython 声明写入 `PyData.pxd`，如下所示：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now that we have defined the `struct`, we can wrap up the `struct` into a class:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了 `struct`，我们可以将 `struct` 包装成一个类：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Wrapping up data into a class like this will require us to allocate and deallocate
    memory at the right moments. Thankfully, Cython exposes almost all of the `libc`
    as imports:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据包装成这样的类将需要我们在正确的时间分配和释放内存。幸运的是，Cython 几乎暴露了所有的 `libc` 作为导入：
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now that we can allocate memory and free it, all that is left is to understand
    the lifecycle of classes and where to hook into. Cython classes provide two special
    methods: `__cinit__` and `__dealloc__`. The `__cinit__` provides a way of instantiating
    native code, so for our case, we will allocate memory to the native C struct,
    and as you can guess on deallocate this is the destroy hook from the garbage collector
    and gives us a chance to free any allocated resources:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够分配和释放内存，剩下要做的只是理解类的生命周期以及在哪里进行钩子。Cython 类提供了两个特殊方法：`__cinit__` 和 `__dealloc__`。`__cinit__`
    提供了一种实例化原生代码的方式，因此在我们的例子中，我们将内存分配给原生 C `struct`，正如你可以猜到的，在析构时这是垃圾回收器的销毁钩子，并给我们一个机会来释放任何已分配的资源：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It''s important to note that `__cinit__` doesn''t override Python `__init__`,
    and more importantly, `__cinit__` is not designed to call into any Python code
    at this point as it does not guarantee full initialization of the class. An init
    method might look as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`__cinit__`不会覆盖Python的`__init__`，更重要的是，`__cinit__`在此点并不设计为调用任何Python代码，因为它不能保证类的完全初始化。一个初始化方法可能如下所示：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that we were able to type the arguments on these functions to ensure that
    we don''t try and put a Python object into the `struct`, which would fail. What
    is impressive here is that this class behaves as if it was just a normal Python
    class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们能够在这类函数上输入参数以确保我们不会尝试将Python对象放入`struct`中，这将会失败。这里令人印象深刻的是，这个类表现得就像是一个普通的Python类：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you put a simple `print` statement on the `__dealloc__` hook and run the
    program, you will see all destructors are executed, as you would expect. It means
    we have just leveraged the Python garbage collector on top of native code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将一个简单的`print`语句放在`__dealloc__`钩子上并运行程序，你会看到所有析构函数都按预期执行。这意味着我们刚刚在原生代码上利用了Python垃圾回收器。
- en: Extending Tmux
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Tmux
- en: '**Tmux** is a terminal multiplexer inspired by GNU Screen ([http://tmux.github.io/](http://tmux.github.io/)),
    but it supports much simpler and better configuration. More importantly, the implementation
    is much cleaner and easier to maintain, and it also uses `libevent` and very well-written
    C code.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tmux**是一个受GNU Screen ([http://tmux.github.io/](http://tmux.github.io/))启发的终端多路复用器，但它支持更简单、更好的配置。更重要的是，它的实现更干净、更容易维护，并且它还使用了`libevent`和非常优秀的C代码。'
- en: 'I want to show you how you can extend Tmux with new built-in commands by writing
    Python code instead of C. Overall, there are several parts to this project, as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向你展示如何通过编写Python代码而不是C代码来扩展Tmux的新内置命令。总的来说，这个项目有几个部分，如下所示：
- en: Hack the autotool's build system to compile in Cython
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改autotool的构建系统以编译Cython
- en: Create PXD declarations to the relevant declarations such as `struct cmd_entry`
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为相关声明，如`struct cmd_entry`创建PXD声明
- en: Embed Python into Tmux
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python嵌入到Tmux中
- en: Add the Python command to the global Tmux `cmd_table`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Python命令添加到全局Tmux `cmd_table`
- en: 'Let''s take a quick look at the Tmux source, and in particular any of the `cmd-*.c`
    files that contain command declarations and implementations. Consider, for example,
    that `cmd-kill-window.c` is the command entry. This tells Tmux the name of the
    command, its alias, and how it may or may not accept arguments; finally, it accepts
    a function pointer to the actual command code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看Tmux的源代码，特别是包含命令声明和实现的任何`cmd-*.c`文件。例如，`cmd-kill-window.c`是命令入口。这告诉Tmux命令的名称、别名以及它是否接受参数；最后，它接受一个指向实际命令代码的函数指针：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: So, if we are able to implement and initialize our own `struct` containing this
    information, we can run our `cdef` code. Next, we need to look at how Tmux picks
    up this command definition and how it gets executed.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们能够实现并初始化包含这些信息的自己的`struct`，我们就可以运行我们的`cdef`代码。接下来，我们需要查看Tmux如何获取这个命令定义以及它是如何执行的。
- en: 'If we look at `tmux.h`, we find the prototypes for everything that we need
    to manipulate:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`tmux.h`，我们会找到我们需要操作的所有内容的原型：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, we need to add a prototype here for our `cmd_entry` definition. Next, we
    need to look at `cmd.c`; this is where the command table is initialized so that
    it can be looked up later on to execute commands:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要为我们的`cmd_entry`定义在这里添加一个原型。接下来，我们需要查看`cmd.c`；这是命令表初始化的地方，以便稍后可以查找以执行命令：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now that the command table is initialized, where does the code get executed?
    If we look at the `cmd_entry` definition in the `tmux.h` header, we can see the
    following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在命令表已经初始化，代码在哪里执行呢？如果我们查看`tmux.h`头文件中的`cmd_entry`定义，我们可以看到以下内容：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `execc` hook is the function pointer we really care about, so if you `grep`
    the sources, you should find the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`execc`钩子是我们真正关心的函数指针，所以如果你`grep`源代码，你应该会找到以下内容：'
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You might notice that in the official Tmux Git, this hook is simply named `exec`.
    I renamed this to `execc` because `exec` is a reserved word in Python—we need
    to avoid things like that. To begin with, let's get some code compiled. First,
    we need to get the build system to play ball.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到在官方的Tmux Git中，这个钩子简单地命名为`exec`。我将其重命名为`execc`，因为`exec`是Python中的保留字——我们需要避免这种情况。首先，让我们编译一些代码。首先，我们需要让构建系统发挥作用。
- en: Tmux build system
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tmux构建系统
- en: 'Tmux uses autotools, so we can reuse the snippets from [Chapter 2](ch02.html
    "Chapter 2. Understanding Cython"), *Understanding Cython*, to add in Python support.
    We can add the `–enable-python` switch into `configure.ac` as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Tmux使用autotools，因此我们可以重用[第2章](ch02.html "第2章。理解Cython")，*理解Cython*中的片段，以添加Python支持。我们可以在`configure.ac`中添加`–enable-python`开关，如下所示：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This gives us the `./configure –-enable-python` option. Next, we need to look
    at the `Makefile.am` file. Let''s call our Cython file `cmdpython.pyx`. Note that
    Cython doesn''t like awkward characters such as "`-`" in the filename, as explained
    in [Chapter 2](ch02.html "Chapter 2. Understanding Cython"), *Understanding Cython*.
    If we are to make Python support a conditional option at build time, we should
    add the following to `Makefile.am`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了`./configure –-enable-python`选项。接下来，我们需要查看`Makefile.am`文件。让我们将我们的Cython文件命名为`cmdpython.pyx`。请注意，Cython不喜欢文件名中的尴尬字符，如`-`，如[第2章](ch02.html
    "第2章。理解Cython")中所述。如果我们想在构建时使Python支持条件选项，我们应该将以下内容添加到`Makefile.am`中：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have to make sure that it is needed and compiled first. Remember that if
    we create `public` declarations, Cython generates a header for us. We will simply
    add our public header to `tmux.h` to keep headers very simple. Then, to make sure
    Cython files get picked up by automake and is compiled properly according to the
    correct dependency management at build time, we need to add the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须确保它首先被需要并编译。记住，如果我们创建`public`声明，Cython会为我们生成一个头文件。我们只需将我们的公共头文件添加到`tmux.h`中，以保持头文件非常简单。然后，为了确保Cython文件在构建时被automake识别并正确编译，根据正确的依赖管理，我们需要添加以下内容：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This adds in the suffix rule to make sure the `*.pyx` files are Cythoned and
    then told to compile the resulting `.c` file just as any normal C file. This snippet
    plays well if you happen to use `AM_SILENT_RULES([yes])` in your autotools project,
    which formats the echo message correctly. Lastly, we need to make sure we add
    the necessary `CFLAGS` and `LIBS` options to the compiler from `AC_SUBST` in the
    configure script:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了后缀规则，以确保`*.pyx`文件被Cython化，然后像任何正常的C文件一样编译生成的`.c`文件。如果你在autotools项目中恰好使用了`AM_SILENT_RULES([yes])`，这个片段运行得很好，因为它正确地格式化了echo消息。最后，我们需要确保在配置脚本中的`AC_SUBST`中添加必要的`CFLAGS`和`LIBS`选项到编译器：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now you should have everything ready in the build system, but we have to regenerate
    the autotools stuff now because of the changes made. Simply run `./autogen.sh`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的构建系统应该已经准备好了，但由于所做的更改，我们必须现在重新生成autotools的内容。只需运行`./autogen.sh`。
- en: Embedding Python
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌入Python
- en: 'Now that we have files being compiled, we need to initialize Python. Our module.
    Tmux is a forked server that clients connect to, so try not to think of it as
    a single-threaded system. It''s a client *and* a server, so all commands are executed
    on the server. Now, let''s find where the event loop is started in the server,
    and initialize and finalize the server here so that it''s done correctly. Looking
    at `int server_start(int lockfd, char *lockfile)`, we can add the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有文件正在编译，我们需要初始化Python。我们的模块。Tmux是一个分叉的服务器，客户端连接到，所以尽量不要把它看作一个单线程系统。它是一个客户端*和*服务器，所以所有命令都在服务器上执行。现在，让我们找到服务器中事件循环开始的地方，并在服务器这里初始化和最终化，以确保正确完成。查看`int
    server_start(int lockfd, char *lockfile)`，我们可以添加以下内容：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Python is now embedded into the Tmux server. Notice that instead of using simply
    `Py_Initialize`, I used `Py_InitializeEx (0)`. This replicates the same behavior,
    but doesn't start up normal Python signal handlers. Tmux has its own signal handlers,
    so I don't want to override them. It's probably a good idea when extending established
    applications such as this to use `Py_InitializeEx (0)`, since they generally implement
    their own signal handling. Using this stops Python from trying to handle signals
    that would conflict.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python现在被嵌入到Tmux服务器中。注意，我使用的是`Py_InitializeEx (0)`而不是简单地使用`Py_Initialize`。这复制了相同的行为，但不会启动正常的Python信号处理器。Tmux有自己的信号处理器，所以我不想覆盖它们。当扩展像这样的现有应用程序时，使用`Py_InitializeEx
    (0)`可能是一个好主意，因为它们通常实现自己的信号处理。使用这个选项可以阻止Python尝试处理会冲突的信号。
- en: Cythonizing struct cmd_entry
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython化struct cmd_entry
- en: 'Next, let''s consider creating a `cythonfile.pxd` file for the necessary `cdef`
    declarations of Tmux that we need to be aware of. We need to look at the `struct
    cmd_entry` declaration, and work backwards from this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑创建一个`cythonfile.pxd`文件，用于Tmux必要的`cdef`声明，我们需要了解的。我们需要查看`struct cmd_entry`声明，并从这个声明反向工作：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As you can see, `cmd_entry` depends on several other types, so we need to work
    backwards a little bit. If you're going to be lazy and live dangerously, you can
    get away with it sometimes if you don't care about accessing the data correctly
    by casting any pointers such as `void *`. But if you're a seasoned C programmer,
    you know this is fairly dangerous and should be avoided. You can see this type
    depends on `struct cmd *`, `struct cmd_q *`, and `struct args *`. We would ideally
    want to access these at some point, so it's a good idea to work backwards and
    implement them one at a time, since the rest are just native C types, which Cython
    understands.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`cmd_entry`依赖于几个其他类型，因此我们需要稍微回溯一下。如果您想偷懒并冒险，如果您不关心通过类型转换任何指针（如`void *`）来正确访问数据，有时您可以侥幸逃脱。但如果你是一个经验丰富的C程序员，你知道这是相当危险的，应该避免。您可以看到这个类型依赖于`struct
    cmd *`、`struct cmd_q *`和`struct args *`。我们理想情况下想在某个时刻访问这些，所以逐个实现它们是个好主意，因为其余的都是原生C类型，Cython可以理解。
- en: 'Implementing the `enum` should be by far the simplest:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现`enum`应该是迄今为止最简单的：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, turn it into the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其转换为以下形式：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now that we have the return value for the `exec` hook, we need to look at `struct
    cmd` next and implement it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`exec`钩子的返回值，接下来我们需要查看`struct cmd`并实现它：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Take a look at `TAILQ_ENTRY`. This is simply a preprocessor macro that is a
    **BSD libc** extension to turn any type into its own linked list. We can ignore
    this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`TAILQ_ENTRY`。这是一个简单的预处理宏，是**BSD libc**的扩展，可以将任何类型转换为它自己的链表。我们可以忽略它：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that this `struct` depends on the `struct cmd_entry` and `struct args`
    definitions, which we haven''t implemented yet. Don''t worry about this yet; just
    put them in for now. Next, let''s implement `struct args`, since it''s simple:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`struct`依赖于`struct cmd_entry`和`struct args`的定义，我们还没有实现。现在不用担心这个问题；暂时先放它们在这里。接下来，让我们实现`struct
    args`，因为它很简单：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Note that it uses `bitstr_t` and a variable-length array list. I choose to
    ignore `bitstr_t` because I think it''s a system-dependent header that is fairly
    tricky to implement. Let''s simply cast these as `char *` and `char **` to get
    things working:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，它使用了`bitstr_t`和可变长度的数组列表。我选择忽略`bitstr_t`，因为它是一个系统依赖的头文件，实现起来相当棘手。让我们简单地将它们转换为`char
    *`和`char **`以使事情运行起来：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now that the `args` structure is Cythonized, let''s implement `struct cmd_q`,
    which is a little trickier:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经将`args`结构Cython化，让我们实现`struct cmd_q`，这稍微有点棘手：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There are quite a few more structs that this depends on, but we will not see
    them here. Let''s try and cast these for now; for example, `struct client *`.
    We can cast this as `void *`, and then `struct cmd_q_items` simply as `int`, even
    though it isn''t correct. As long as we are not going to try and access these
    fields, we will be okay. But remember that if we were to use Cython `sizeof`,
    we could run into memory corruption with different sizes allocated by C and by
    Cython. We can work down the other types such as `struct cmd_q_item *` and cast
    them as `void *` again. Finally, we come to `time_t`, where we can reuse `libc.stdlib
    cimport` time from Cython. This is a really good exercise to implement Cython
    declarations for C applications; it really exercises your code analysis. When
    going through really long structures, remember that we can get things going by
    just casting them as `void`. Be careful about the `struct` alignment and typing
    if you care about the data types in your Cython API:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他结构依赖于它，但在这里我们不会看到它们。让我们现在尝试将这些转换为`void *`；例如，`struct client *`。我们可以将其转换为`void
    *`，然后`struct cmd_q_items`简单地转换为`int`，即使这不正确。只要我们不打算尝试访问这些字段，我们就会没事。但请记住，如果我们使用Cython的`sizeof`，我们可能会遇到由C和Cython分配的不同大小的内存损坏。我们可以继续处理其他类型，如`struct
    cmd_q_item *`，并将它们再次转换为`void *`。最后，我们来到`time_t`，我们可以重用Cython的`libc.stdlib cimport`
    time。这是一个很好的练习，为C应用程序实现Cython声明；它真正锻炼了你的代码分析能力。在处理非常长的结构时，请记住，我们可以通过将它们转换为`void`来使事情运转起来。如果你关心你的Cython
    API中的数据类型，请小心处理`struct`的对齐和类型：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That was a fairly deep dive into a lot of project-specific internals, but I
    hope you get the idea—we really didn''t do anything terribly scary. We even cheated
    and casted things that we really don''t care about. With all these auxiliary types
    implemented, we can finally implement the type we care about, namely, `struct
    cmd_entry`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对许多项目特定内部结构的深入探讨，但我希望您能理解——我们实际上并没有做什么特别可怕的事情。我们甚至作弊了，将我们实际上并不关心的东西进行了类型转换。在实现了所有这些辅助类型之后，我们最终可以实施我们关心的类型，即`struct
    cmd_entry`：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this `cmdpython.pxd` file, we can now implement our Tmux command!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个`cmdpython.pxd`文件，我们现在可以实现我们的Tmux命令！
- en: Implementing a Tmux command
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Tmux命令
- en: 'One caveat with Cython is that we cannot statically initialize structs like
    we can in C, so we need to make a hook so that we can initialize `cmd_entry` on
    Python startup:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Cython有一个注意事项是我们不能像在C中那样静态初始化结构体，因此我们需要创建一个钩子，以便在Python启动时初始化`cmd_entry`：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With this, we now have a public declaration of `cmd_entry_python`, which we
    will initialize in a startup hook as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，我们现在有了`cmd_entry_python`的公共声明，我们将在启动钩子中初始化它，如下所示：
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Remember that because we declared this in the top level, we know it''s on the
    heap and don''t need to declare any memory to the structure, which is very handy
    for us. You''ve seen struct access before; the function suite should look familiar.
    But let me draw attention to a few things here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，因为我们是在顶层声明的，所以我们知道它位于堆上，不需要向结构体声明任何内存，这对我们来说非常方便。你之前已经见过结构体的访问方式；函数套件应该看起来很熟悉。但让我在这里强调几点：
- en: We declared `public` to make sure we can call it.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们声明`public`是为了确保我们可以调用它。
- en: The execution hook is simply a `cdef` Cython function.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行钩子只是一个`cdef` Cython函数。
- en: Finally, you might notice the `gil`. I will explain what this is used for in
    [Chapter 5](ch05.html "Chapter 5. Advanced Cython"), *Advanced Cython*.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你可能注意到了`gil`。我将在[第5章](ch05.html "第5章。高级Cython") *高级Cython* 中解释这个用于什么。
- en: 'Now, let''s see a simple execution hook:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个简单的执行钩子：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There is not much left to do to hook this into Tmux now. It simply needs to
    be added to `cmd_table` and the startup hook needs to be added to the server initialization.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将这个钩子连接到Tmux没有太多剩余的工作要做。只需将其添加到`cmd_table`，并将启动钩子添加到服务器初始化中。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I added something in the `log_debug` function to the PXD; if you look
    into Tmux, this is a `VA_ARGS` function. Cython doesn't understand these yet,
    but we can hack it just to get it going by simply casting it as a function that
    takes a string. As long as we don't try and use it like any `printf`, we should
    be fine.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在`log_debug`函数中向PXD添加了一些内容；如果你查看Tmux，这是一个`VA_ARGS`函数。Cython目前还不理解这些，但我们可以通过将其转换为接受字符串的函数来简单地“黑客”它，让它运行起来。只要我们不尝试像使用任何`printf`一样使用它，我们应该就没事了。
- en: Hooking everything together
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将一切连接起来
- en: 'We now have to fiddle with Tmux just a tiny bit more, but it''s fairly painless,
    and once we are done we are free to be creative. Fundamentally, we should call
    the `cmd_entry` initialization hook in `server.c` just before we forget about
    it:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要对Tmux进行一点小小的调整，但这并不痛苦，一旦完成，我们就可以自由地发挥创意。从根本上说，我们应该在忘记之前在`server.c`中调用`cmd_entry`初始化钩子：
- en: '[PRE37]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now that this is done, we need to make sure we add the `cmd_entry_python` extern
    declaration to `tmux.h`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成，我们需要确保将`cmd_entry_python`外部声明添加到`tmux.h`中：
- en: '[PRE38]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, add this to `cmd_table`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将其添加到`cmd_table`：
- en: '[PRE39]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that this is done, I think we''re good to go—let''s test out this baby.
    Compile Tmux with the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经完成，我认为我们可以开始了——让我们测试一下这个小家伙。用以下方式编译Tmux：
- en: '[PRE40]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can look into `tmux-server-*.log` to see our debug message:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看`tmux-server-*.log`来查看我们的调试信息：
- en: '[PRE41]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I hope you can now see how easily you can extend this to do something of your
    own choosing, such as using Python libraries to call directly into your music
    player, and it would all be integrated with Tmux.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你现在可以看到，你可以很容易地将其扩展到做你自己的选择，比如使用Python库直接调用你的音乐播放器，并且所有这些都将与Tmux集成在一起。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: There are many different techniques and ideas demonstrated in this chapter,
    but it should serve as a strong reference on common techniques. We saw the speedups
    in using native types to bypass the runtime, and compiled Python code into its
    own binary. The `pyximport` statement shows us we can bypass compilation and simply
    import `.pyx` files as if it was normal Python. Finally, I ended the chapter with
    a step-by-step demonstration of my process in embedding Python into Tmux. In the
    next chapter, we will see debugging in action using `gdb`, and some caveats in
    using Cython.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章展示了许多不同的技术和想法，但它应该作为常见技术的强大参考。我们看到了使用本地类型绕过运行时的加速，并将编译的Python代码编译成自己的二进制文件。`pyximport`语句显示我们可以绕过编译，简单地导入`.pyx`文件，就像它是普通的Python文件一样。最后，我在本章的结尾通过逐步演示我的过程，展示了如何将Python嵌入到Tmux中。在下一章中，我们将看到使用`gdb`进行调试的实际操作，以及使用Cython的一些注意事项。
