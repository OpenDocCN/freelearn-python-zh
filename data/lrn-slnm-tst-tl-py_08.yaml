- en: Chapter 8. Page Objects and Data-driven Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。页面对象和数据驱动测试
- en: This chapter introduces two important design patterns that are useful in creating
    scalable and maintainable test automation framework designs. We will explore how
    to use the data-driven approach to create data-driven Selenium tests using Python
    libraries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了两个在创建可扩展和可维护的测试自动化框架设计中有用的设计模式。我们将探讨如何使用数据驱动方法，通过使用Python库创建数据驱动Selenium测试。
- en: In the second part of this chapter, you will learn about using the page object
    pattern to create highly maintainable and robust tests by separating locators
    and other low-level calls from the test cases into a layer of abstraction, which
    resembles the functionality of the application similar to what the user experiences
    within the browser window.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第二部分，你将了解如何使用页面对象模式通过将定位器和其他低级调用从测试用例中分离到一个抽象层，从而创建高度可维护和健壮的测试，这个抽象层类似于应用程序的功能，类似于用户在浏览器窗口中体验到的功能。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: What data-driven testing is
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是数据驱动测试
- en: How to use the **Data-driven testing** (**ddt**) library along with the `unittest`
    library to create data-driven tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用**数据驱动测试**（**ddt**）库与`unittest`库一起创建数据驱动测试
- en: How to read data from external sources for data-driven testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从外部源读取数据用于数据驱动测试
- en: What the page object pattern is and how it helps in creating a maintainable
    test suite
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 页面对象模式是什么以及它如何帮助创建可维护的测试套件
- en: How to implement the page object pattern for the sample application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现示例应用程序的页面对象模式
- en: Data-driven testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据驱动测试
- en: By using the data-driven testing approach, we can use a single test to verify
    different sets of test cases or test data by driving the test with input and expected
    values from an external data source instead of using the hardcoded values every
    time a test is run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用数据驱动测试方法，我们可以通过从外部数据源驱动测试，使用输入值和预期值，而不是每次运行测试时都使用硬编码的值，来使用单个测试验证不同的测试用例集或测试数据。
- en: 'This becomes useful when we have similar tests that consist of the same steps
    but differ in the input data and expected value or the application state. Here
    is an example of a set of login test cases with different combinations:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一些类似的测试，这些测试包含相同的步骤，但在输入数据、预期值或应用程序状态上有所不同时，这变得很有用。以下是一组具有不同组合的登录测试用例的示例：
- en: '| Description | Test data | Expected output |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 描述 | 测试数据 | 预期输出 |'
- en: '| --- | --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Valid username and password | A pair of valid usernames and passwords | The
    user should log in to the application with a success message |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 有效的用户名和密码 | 一对有效的用户名和密码 | 用户应使用成功消息登录到应用程序 |'
- en: '| Invalid username and password | An invalid username and password | The user
    should be displayed the login error |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 无效的用户名和密码 | 无效的用户名和密码 | 应向用户显示登录错误 |'
- en: '| Valid username and invalid password | A valid username and an invalid password
    | The user should be displayed the login error |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 有效的用户名和无效的密码 | 有效的用户名和无效的密码 | 应向用户显示登录错误 |'
- en: We can create a single script that can handle the test data and the conditions
    from the preceding table.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个可以处理测试数据和前面表格中条件的单个脚本。
- en: By using the data-driven testing approach, we separate the test data from the
    test logic by replacing the hardcoded test data with variables using the data
    from external sources such as CSV or a spreadsheet file. This also helps in creating
    reusable tests that can run with different sets of data, which can be kept outside
    of the test.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用数据驱动测试方法，我们将测试数据与测试逻辑分离，通过使用来自外部源（如CSV或电子表格文件）的数据替换硬编码的测试数据，从而使用变量。这也帮助创建可重用的测试，这些测试可以与不同的数据集一起运行，这些数据集可以保存在测试之外。
- en: Data-driven testing also helps in increasing the test coverage as we can handle
    multiple test conditions while minimizing the amount of test code we need to write
    and maintain.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 数据驱动测试还有助于提高测试覆盖率，因为我们可以在最小化需要编写和维护的测试代码量的同时处理多个测试条件。
- en: In this section, we will implement the data-driven testing approach to some
    of the tests that we created in the earlier chapters, using the `ddt` library
    in Python.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用Python中的`ddt`库实现数据驱动测试方法，应用于我们在前面章节中创建的一些测试。
- en: Using ddt for data-driven tests
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ddt进行数据驱动测试
- en: The `ddt` library provides the ability to parameterize the test cases written
    using the `unittest` library in Python. We can provide a set of data using `ddt`
    to a test case for data-driven tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`ddt` 库提供了在 Python 中使用 `unittest` 库编写的测试用例参数化的能力。我们可以使用 `ddt` 向测试用例提供一组数据，以进行数据驱动测试。'
- en: The `ddt` library provides a set of class and method decorators that we can
    use to create data-driven tests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`ddt` 库提供了一组类和方法装饰器，我们可以使用它们来创建数据驱动测试。'
- en: Installing ddt
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 ddt
- en: 'We can download and install `ddt` using the following command line:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令行下载和安装 `ddt`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: That's it! You can find more about `ddt` at [https://pypi.python.org/pypi/ddt](https://pypi.python.org/pypi/ddt).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！你可以在 [https://pypi.python.org/pypi/ddt](https://pypi.python.org/pypi/ddt)
    上找到更多关于 `ddt` 的信息。
- en: Creating a simple data-driven test with ddt in unittest
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 unittest 中使用 ddt 创建简单的数据驱动测试
- en: We will use the search test case on the sample application and convert it into
    a data-driven test by removing the hardcoded values to search for different products
    and categories.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例应用程序上使用搜索测试用例，并通过删除用于搜索不同产品和类别的硬编码值将其转换为数据驱动测试。
- en: To create a data-driven test we need to use the `@ddt` decorator for the test
    class and use the `@data` decorator on the data-driven test methods.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数据驱动测试，我们需要在测试类中使用 `@ddt` 装饰器，并在数据驱动测试方法中使用 `@data` 装饰器。
- en: The `@data` decorator takes as many arguments as we have values that we want
    to feed to the test. These could be single values or lists, tuples, and dictionaries.
    For lists, we need to use the `@unpack` decorator, which unpacks tuples or lists
    into multiple arguments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`@data` 装饰器接受与我们想要提供给测试的值一样多的参数。这些可以是单个值或列表、元组和字典。对于列表，我们需要使用 `@unpack` 装饰器，它将元组或列表解包成多个参数。'
- en: 'Let''s implement the search test, which accepts a pair of arguments for different
    search terms and expected result count as shown in the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现搜索测试，它接受一对参数，用于不同的搜索词和预期结果计数，如下所示代码所示：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this test, we are passing a list of tuples using the `@data` decorator.
    The `@unpack` decorator is used to unpack these tuples into multiple arguments.
    The `test_search()` method accepts the `search_value` and `expected_count` arguments,
    which will be mapped to the tuple values by `ddt`, as shown:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用 `@data` 装饰器传递一个元组列表。使用 `@unpack` 装饰器将这些元组解包成多个参数。`test_search()`
    方法接受 `search_value` 和 `expected_count` 参数，这些参数将通过 `ddt` 映射到元组值，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When we run the test, `ddt` will generate new test methods giving them meaningful
    names by converting the data values to valid Python identifiers. For example,
    for the preceding test, `ddt` will generate new test methods with names as shown
    in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行测试时，`ddt` 将生成新的测试方法，并通过将数据值转换为有效的 Python 标识符来赋予它们有意义的名称。例如，对于前面的测试，`ddt`
    将生成具有以下截图所示名称的新测试方法：
- en: '![Creating a simple data-driven test with ddt in unittest](img/3506OS_08_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![在 unittest 中使用 ddt 创建简单的数据驱动测试](img/3506OS_08_01.jpg)'
- en: Using external data sources for data-driven tests
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用外部数据源进行数据驱动测试
- en: In the previous example, we supplied the test data in the test code. However,
    you will find situations where you already have test data defined in external
    sources such as text files, spreadsheets, or databases. It is also a good idea
    to separate the test data from the code and put it in an external source for easy
    maintenance and avoid changes to the test code each time you want to update the
    values.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们在测试代码中提供了测试数据。然而，你可能会遇到已经在外部源中定义了测试数据的情况，例如文本文件、电子表格或数据库。将测试数据与代码分离，并将其放在外部源中也是一个好主意，这样可以方便维护，并避免每次更新值时都要更改测试代码。
- en: Let's explore how we can read the test data from the **Comma separated values**
    (**CSV**) files or Excel spreadsheets and supply it to `ddt`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨如何从 **逗号分隔值** （**CSV**） 文件或电子表格中读取测试数据，并将其提供给 `ddt`。
- en: Reading values from CSV
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 CSV 读取值
- en: 'We will use the previous test case and move the data that we supplied to the
    `@data` decorator into a separate CSV file called `testdata.csv` instead of keeping
    it in the script. This data will be stored in a tabular format as shown in the
    following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前的测试用例，并将提供给 `@data` 装饰器的数据移动到一个单独的 CSV 文件中，称为 `testdata.csv`，而不是将其保留在脚本中。这些数据将以如下截图所示的表格格式存储：
- en: '![Reading values from CSV](img/3506OS_08_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![从 CSV 读取值](img/3506OS_08_02.jpg)'
- en: 'Next, we will implement the `get_data()` method, which accepts the path and
    name of the CSV file. This method uses the `csv` library to read the values from
    the file and returns a list of these values. We will use the `get_data()` method
    in the `@data` decorator as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现 `get_data()` 方法，该方法接受 CSV 文件的路径和名称。此方法使用 `csv` 库从文件中读取值，并返回这些值的列表。我们将在
    `@data` 装饰器中使用 `get_data()` 方法，如以下代码所示：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When this test is executed, `@data` will call the `get_data()` method, which
    will read the supplied file and return the list of values back to `@data`. These
    values are unpacked and the test methods are generated for each row.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行此测试时，`@data` 将调用 `get_data()` 方法，该方法将读取提供的文件，并将从 `@data` 返回的值列表返回。这些值将被解包，并为每一行生成测试方法。
- en: Reading values from Excel
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Excel 读取值
- en: 'Maintaining test data in the Excel spreadsheet is another common practice.
    It also helps nontechnical users to define new tests by simply adding a row of
    data in a spreadsheet. Consider the following screenshot as an example of maintaining
    the data in an Excel spreadsheet:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Excel 电子表格中维护测试数据是另一种常见做法。它还有助于非技术用户通过在电子表格中添加一行数据来简单地定义新的测试。以下截图是维护 Excel
    电子表格中数据的示例：
- en: '![Reading values from Excel](img/3506OS_08_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![从 Excel 读取值](img/3506OS_08_03.jpg)'
- en: 'Reading values from the Excel spreadsheet will need another library called
    `xlrd`, which can be installed with the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Excel 电子表格中读取值需要另一个名为 `xlrd` 的库，可以使用以下命令进行安装：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `xlrd` library provides read access to the workbook, sheet, and cells in
    order to read the data. It does not write to a spreadsheet. For writing the data,
    we can use the `xlwt` library. We can also use `openpyxl` for reading and writing
    data in a spreadsheet. Find more information at [http://www.python-excel.org/](http://www.python-excel.org/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`xlrd` 库提供了对工作簿、工作表和单元格的读取访问权限，以便读取数据。它不会写入电子表格。对于写入数据，我们可以使用 `xlwt` 库。我们还可以使用
    `openpyxl` 在电子表格中读取和写入数据。更多信息请访问 [http://www.python-excel.org/](http://www.python-excel.org/)。'
- en: 'Let''s modify the `get_data()` method from the previous example to read data
    from a spreadsheet into a list and modify the test as shown in the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改上一个示例中的 `get_data()` 方法，以便从电子表格中读取数据到列表中，并按以下代码修改测试：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to the previous example for CSV files, when this test is executed `@data`
    will call the `get_data()` method, which will read the supplied file and return
    the list of values back to `@data` from a spreadsheet. These values are unpacked
    and the test methods are generated for each row.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前 CSV 文件的示例类似，当执行此测试时，`@data` 将调用 `get_data()` 方法，该方法将读取提供的文件，并将从电子表格中返回的值列表返回给
    `@data`。这些值将被解包，并为每一行生成测试方法。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Reading values from a database**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**从数据库读取值**'
- en: If you need to read values from a database, you just need to modify the `get_data()`
    method and use the appropriate libraries to connect to the database and read values
    using SQL queries back into a list.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要从数据库中读取值，只需修改 `get_data()` 方法并使用适当的库连接到数据库，然后使用 SQL 查询将值读取回列表中。
- en: The page objects pattern
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 页面对象模式
- en: Until now, we were writing Selenium WebDriver tests directly into Python classes
    using `unittest`. We were specifying locators and test case steps into these classes.
    This code is good to start; however, as we progress on, adding more and more tests
    to our tests suite, it will become difficult to maintain. This will make tests
    brittle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们直接使用 `unittest` 将 Selenium WebDriver 测试写入 Python 类中。我们在这些类中指定定位器和测试用例步骤。这段代码是一个好的开始；然而，随着我们继续向测试套件中添加越来越多的测试，它将变得难以维护。这将使测试变得脆弱。
- en: Developing maintainable and reusable test code is important for sustainable
    test automation and the test code should be treated as production code and similar
    standards and patterns should to be applied while developing the test code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 开发可维护和可重用的测试代码对于可持续的测试自动化至关重要，测试代码应被视为生产代码，并且在开发测试代码时应应用类似的标准和模式。
- en: To overcome these problems, we can use various design patterns and principles
    such as **Don't Repeat Yourself** (**DRY**), and code refactoring techniques while
    creating the tests. If you're a developer, you might already be using these techniques.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服这些问题，我们可以在创建测试时使用各种设计模式和原则，例如**不要重复自己**（**DRY**）和代码重构技术。如果你是一名开发者，你可能已经在使用这些技术了。
- en: The page object pattern is one of the highly used patterns among the Selenium
    user community to structure the tests, making them separate from low-level actions,
    and providing a high-level abstraction. You can compare the page object pattern
    to the facade pattern, which enables creating a simplified interface for complex
    code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象模式是Selenium用户社区中高度使用的模式之一，用于构建测试，使它们与低级动作分离，并提供高级抽象。你可以将页面对象模式与外观模式进行比较，它允许为复杂代码创建简化的接口。
- en: The page object pattern offers creating an object representing each web page
    from the application under test. We can define classes for each page, modeling
    all attributes and actions for that page. This creates a layer of separation between
    the test code and technical implementation of pages and application functionality
    that we will be testing, by hiding the locators, low-level methods dealing with
    elements, and business functionality. Instead, the page objects will provide a
    high-level API for tests to deal with the page functionality.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 页面对象模式提供了从正在测试的应用程序创建代表每个网页的对象。我们可以为每个页面定义类，模拟该页面的所有属性和动作。这创建了一个测试代码与我们将要测试的页面和应用程序功能的技术实现之间的分离层，通过隐藏定位器、处理元素的低级方法和业务功能。相反，页面对象将为测试提供一个高级API来处理页面功能。
- en: 'Tests should use these page objects at a high level, where any change in attributes
    or actions in the underlying page should not break the test. Using the page object
    pattern provides the following benefits:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 测试应使用这些页面对象在高级别，其中底层页面中属性或动作的任何更改都不应破坏测试。使用页面对象模式提供了以下好处：
- en: Creating a high-level abstraction that helps minimize changes when the underlying
    page is modified by developers. So, you will change only the page object and the
    calling tests will be unaffected.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个高级抽象，有助于在底层页面被开发者修改时最小化更改。因此，你只需更改页面对象，而调用测试将不受影响。
- en: Creating reusable code that can be shared across multiple test cases.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可跨多个测试案例共享的可重用代码。
- en: Tests are more readable, flexible, and maintainable.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试更易于阅读、灵活且易于维护。
- en: 'Let''s start refactoring the test that we created in the earlier chapter and
    implement the page objects that provide a high-level abstraction for the application
    that we are testing. In this example, we will create the following structure for
    the selected pages in the sample application. We will start implementing a base
    page object, which will be used by all other pages as a template. The base object
    will also provide regions that are blocks of functionality available for all other
    pages; for example, the search feature is available on all pages of the application.
    We will create a search region object that will be available for all the pages
    inherited from the base page. We will implement a class for the home page, which
    represents the home page of the application; search results page, which shows
    the list of products matching with the search criteria; and a product page, which
    provides attributes and actions related to a product. We will create a structure
    as shown in the following diagram:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始重构我们在早期章节中创建的测试，并实现为正在测试的应用程序提供高级抽象的页面对象。在这个例子中，我们将为示例应用程序中选定的页面创建以下结构。我们将开始实现一个基本页面对象，它将被所有其他页面用作模板。基本对象还将提供所有其他页面可用的功能区域；例如，搜索功能在应用程序的所有页面上都可用。我们将创建一个搜索区域对象，它将适用于从基本页面继承的所有页面。我们将实现一个代表应用程序主页的类，搜索结果页面，它显示与搜索标准匹配的产品列表；以及一个产品页面，它提供与产品相关的属性和动作。我们将创建如以下图表所示的结构：
- en: '![The page objects pattern](img/3506OS_08_04.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![页面对象模式](img/3506OS_08_04.jpg)'
- en: Organizing tests
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织测试
- en: 'Before we start implementing page objects for the sample application we are
    testing, let''s implement a `BaseTestCase` class, which will provide us with the
    `setUp()` and `tearDown()` methods so that we don''t need to write these for each
    test class we create. We can also put reusable code in this class. Create `basetestcase.py`
    and implement the `BaseTestCase` class as shown in the following code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始为正在测试的示例应用程序实现页面对象之前，让我们实现一个`BaseTestCase`类，它将为我们提供`setUp()`和`tearDown()`方法，这样我们就不需要为每个创建的测试类编写这些方法。我们还可以将可重用代码放在这个类中。创建`basetestcase.py`并实现如以下代码所示的`BaseTestCase`类：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The BasePage object
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础页面对象
- en: 'The `BasePage` object will act as a parent object for all the page objects
    that we will create in our test suite. The base page provides common code that
    the page object can use. Let''s create `base.py` and implement `BasePage` as shown
    in the following code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`BasePage`对象将作为我们将在测试套件中创建的所有页面对象的父对象。基本页面提供了页面对象可以使用的基本代码。让我们创建`base.py`文件并实现`BasePage`，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We added an abstract method called `_validate_page()`, which will be implemented
    by the page objects inheriting from `BasePage` to validate that the page they
    represent is loaded in the browser before the test can use attributes or actions.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个名为`_validate_page()`的抽象方法，该方法将由继承自`BasePage`的页面对象实现，以验证在测试使用属性或操作之前，它们所代表的页面是否已在浏览器中加载。
- en: We also created a property called `search` that returns the `SearchRegion` object.
    This is similar to a page object. However, `SearchRegion` represents the search
    box displayed on all the pages of the application. So, adding to each page object
    we are sharing this from the `BasePage` class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个名为`search`的属性，它返回`SearchRegion`对象。这类似于页面对象。然而，`SearchRegion`代表应用程序所有页面显示的搜索框。因此，我们将从`BasePage`类中共享此内容添加到每个页面对象中。
- en: We also implemented `InvalidPageException`, which is used in the `_validate_page()`
    method. If it fails to validate the page, `InvalidPageExecption` will be raised.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还实现了`InvalidPageException`，该异常用于`_validate_page()`方法。如果验证页面失败，将引发`InvalidPageExecption`。
- en: Implementing page objects
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现页面对象
- en: Now, let's start implementing page objects for each page that we're going to
    deal with in our test.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现我们将要处理的每个页面的页面对象。
- en: 'First we will define `HomePage`. Create `homepage.py` and implement the `HomePage`
    class as shown in the following code:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将定义`HomePage`。创建`homepage.py`文件并实现`HomePage`类，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'One of the practices that we will follow is to separate the locator strings
    from the place where they are being used. We will create a private variable to
    store locators using the `_` prefix. For example, the `_home_page_slideshow_locator`
    variable stores the locator for the slideshow component displayed on the home
    page of the application. We will use this to validate whether the browser is indeed
    showing the home page, as follows:'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将遵循的一种做法是将定位器字符串与其使用的地方分开。我们将创建一个使用`_`前缀的私有变量来存储定位器。例如，`_home_page_slideshow_locator`变量存储了显示在应用程序主页上的幻灯片组件的定位器。我们将使用它来验证浏览器是否确实显示了主页，如下所示：
- en: '[PRE9]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We also implemented the `_validate_page()` method in the `HomePage` class. This
    method validates whether the home page is loaded in the browser using the element
    used to display a slideshow on the home page.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还在`HomePage`类中实现了`_validate_page()`方法。此方法验证是否使用用于在主页上显示幻灯片的元素在浏览器中加载了主页。
- en: 'Next, we will implement the `SearchRegion` class, which handle the search feature
    of the application. It provides the `searchFor()` method, which returns the `SearchResult`
    class representing the search results page. Create a new `search.py` file and
    implement both the classes as shown in the following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现`SearchRegion`类，该类处理应用程序的搜索功能。它提供了`searchFor()`方法，该方法返回表示搜索结果页面的`SearchResult`类。创建一个新的`search.py`文件并实现这两个类，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we will implement the `ProductPage` class, which has some attributes
    related to a product. We can access a product from the `SearchResults` class,
    which has a method to open the product details page for a given product. Create
    a `product.py` file and implement the `ProductPage` class as shown in the following
    code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将实现`ProductPage`类，该类包含一些与产品相关的属性。我们可以从`SearchResults`类中访问产品，该类有一个方法可以打开给定产品的产品详情页面。创建一个`product.py`文件并实现`ProductPage`类，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can further add actions on the product page to add a product to the shopping
    cart, or for comparison of products. Also, attributes that return the rating and
    other information related to the product are added back to the test.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在产品页面上添加操作，将产品添加到购物车，或者用于产品比较。此外，将返回评分和其他与产品相关的信息的属性添加回测试中。
- en: Creating a test with page objects
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用页面对象创建测试
- en: 'Let''s create a test that uses `BaseTestCase` and calls the page objects that
    we created to test the search feature of the application. This test creates an
    instance of the `HomePage` class and calls the `searchFor()` method, which returns
    an instance of `SearchResults`. Later, the test calls the `open_product_page()`
    method of the `SearchResults` class to open details for the specified product
    listed in the result. The test checks the attributes of a sample product. Create
    a `searchtest.py` file and implement the `SearchProductTest` test as shown in
    the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个使用`BaseTestCase`并调用我们创建的页面对象来测试应用程序搜索功能的测试。此测试创建`HomePage`类的实例并调用`searchFor()`方法，该方法返回`SearchResults`类的实例。随后，测试调用`SearchResults`类的`open_product_page()`方法来打开结果中列出的指定产品的详细信息。测试检查样本产品的属性。创建一个`searchtest.py`文件并实现如以下代码所示的`SearchProductTest`测试：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that we did not write the `setUp()` and `tearDown()` methods in this
    test. We inherited this test class from `BaseTestCase`, which implements these
    methods. We can overload these methods if we want to do test-specific setup or
    clean-up.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有在这个测试中编写`setUp()`和`tearDown()`方法。我们从这个实现这些方法的`BaseTestCase`继承了这个测试类。如果我们想进行特定于测试的设置或清理，我们可以重载这些方法。
- en: In this example, we implemented page objects for search workflow navigation.
    You can also implement similar page objects or regions for shopping cart, account
    registration, login, and so on.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们实现了用于搜索工作流程导航的页面对象。您也可以实现类似的页面对象或区域，用于购物车、账户注册、登录等。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we recognized the need to write data-driven tests and organize
    the test code using the page object pattern for reusability, scalability, and
    maintainability. The data-driven pattern provides us the ability to separate test
    data from test case, so we can reuse the test code to test multiple test data.
    We also looked at how to use the `ddt` library along with `unittest` to implement
    data-driven testing and read data from various external sources. You learned the
    page object pattern and how it benefits in building a maintainable test suite
    by implementing page objects for the sample application and creating a test that
    uses the page objects.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们认识到需要编写数据驱动测试，并使用页面对象模式来组织测试代码，以提高可重用性、可扩展性和可维护性。数据驱动模式使我们能够将测试数据与测试用例分离，因此我们可以重用测试代码来测试多个测试数据。我们还探讨了如何使用`ddt`库与`unittest`一起实现数据驱动测试，并从各种外部源读取数据。您学习了页面对象模式及其在通过为示例应用程序实现页面对象并创建使用页面对象的测试来构建可维护的测试套件方面的好处。
- en: In the next chapter you will learn some advanced techniques with Selenium WebDriver
    API, such as capturing screenshots and movies from test runs, performing mouse
    and keyboard actions, handling session cookies, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习一些使用Selenium WebDriver API的高级技术，例如从测试运行中捕获屏幕截图和视频、执行鼠标和键盘操作、处理会话cookie等。
