- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Integrating LoRa with the Internet
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将LoRa与互联网集成
- en: In this chapter, we will take the sensory information from our remotely placed
    LoRa sensory transmitter and publish it to the internet using our Raspberry Pi
    Pico W-equipped **LoRa** receiver. Our internet destination will be an MQTT instance
    on our CloudAMQP server. We will then connect a modified version of the analog-metered
    weather indicator we created in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048)
    to our MQTT server and use this data to position the needle and set the color
    of the LED indicator based on the humidity reading. This modification will entail
    swapping out the Raspberry Pi we installed on the analog-metered weather indicator
    for a Raspberry Pi Pico WH (also referred to as a Raspberry Pi Pico W with headers)
    and the single-color LED with an RGB LED.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从我们远程放置的LoRa传感器发射器获取传感信息，并使用配备Raspberry Pi Pico W的**LoRa**接收器将其发布到互联网。我们的互联网目的地将是CloudAMQP服务器上的MQTT实例。然后，我们将我们创建的修改过的模拟仪表天气指示器连接到MQTT服务器，并使用这些数据根据湿度读数定位指针和设置LED指示器的颜色。这种修改将涉及用Raspberry
    Pi Pico WH（也称为带引脚的Raspberry Pi Pico W）替换安装在模拟仪表天气指示器上的Raspberry Pi，以及将单色LED替换为RGB
    LED。
- en: By transitioning from a standard weather web service to utilizing a remote LoRa
    sensory transmitter that measures temperature and humidity, and subsequently converts
    this data into MQTT messages, we are effectively creating a customized weather
    web service – a service that is powered by LoRa technology for its data transmission
    needs and MQTT for internet communication.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从标准天气网络服务过渡到使用远程LoRa传感器发射器来测量温度和湿度，并将这些数据转换为MQTT消息，我们实际上创建了一个定制的天气网络服务——一个由LoRa技术提供数据传输需求，MQTT提供互联网通信的服务。
- en: We will conclude this chapter with a look at various other technologies for
    **Internet of Things** (**IoT**) communication, such as **LoRaWAN** and cellular
    technologies, and explore the benefits and drawbacks of each technology.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以探讨各种其他物联网（**IoT**）通信技术来结束本章，例如**LoRaWAN**和蜂窝技术，并探讨每种技术的优缺点。
- en: 'We will cover the following in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Connecting our LoRa receiver to the internet
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的LoRa接收器连接到互联网
- en: Creating a new weather indicator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的天气指示器
- en: Exploring other IoT communication protocols
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他物联网通信协议
- en: Let’s begin!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备Python编程的中间知识。
- en: 1 X Raspberry Pi Pico WH.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X Raspberry Pi Pico WH。
- en: 1 X LoRa sensory transmitter from [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140).
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X 来自[第9章](B21282_09.xhtml#_idTextAnchor140)的LoRa传感器发射器。
- en: 1 X LoRa receiver built with the Raspberry Pi Pico W from [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X 使用Raspberry Pi Pico W构建的LoRa接收器，见[第9章](B21282_09.xhtml#_idTextAnchor140)。
- en: A CloudAMQP account for the MQTT server instance.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于MQTT服务器实例的CloudAMQP账户。
- en: 1 X SG90 servo motor.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X SG90伺服电机。
- en: 1 X common anode RGB LED.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X 阳极RGB LED。
- en: 3 X 220 Ohm resistors.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 X 220欧姆电阻。
- en: 1 X 8 mm LED holder.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X 8 mm LED支架。
- en: 9 X M3 10 mm bolts.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 9 X M3 10 mm螺栓。
- en: 4 X M2 8 mm screws.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 X M2 8 mm螺钉。
- en: 1 X M5 20 mm bolt.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X M5 20 mm螺栓。
- en: 1 X M5 nut.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 X M5螺母。
- en: Epoxy glue for constructing the weather indicator faceplate.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建天气指示器面板的环氧胶。
- en: A hot glue gun.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一把热胶枪。
- en: A color printer to print out the faceplate graphic.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有彩色打印机以打印面板图形。
- en: A digital cutting machine such as a Silhouette Cameo. This is optional as the
    faceplate graphic may be cut out by hand. Silhouette Studio 3 file provided.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一台数字切割机，如Silhouette Cameo。这是可选的，因为面板图形可以手工切割。提供Silhouette Studio 3文件。
- en: Access to a 3D printer to print the weather indicator stand.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有访问3D打印机以打印天气指示器支架的能力。
- en: 'The code for this chapter may be found here: [https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10%20)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter10%20)
- en: Connecting our LoRa receiver to the internet
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的LoRa接收器连接到互联网
- en: 'Our first task is to revise the code on our CircuitPython-based LoRa receiver,
    enabling it to forward LoRa messages received by our CloudAMQP server. We’ll use
    Adafruit CircuitPython libraries for this update. Before building and programming
    our new weather indicator to process MQTT messages, we’ll test the MQTT functionality
    using the MQTT-Explorer app in Windows. We can see an outline of this chapter’s
    project in the following diagram:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的首要任务是修改基于CircuitPython的LoRa接收器的代码，使其能够转发由我们的CloudAMQP服务器接收到的LoRa消息。我们将使用Adafruit
    CircuitPython库进行此更新。在我们构建并编程新的天气指示器以处理MQTT消息之前，我们将使用Windows中的MQTT-Explorer应用程序测试MQTT功能。以下图表概述了本章的项目：
- en: '![Figure 10.1 – Controlling an analog-metered weather indicator with LoRa-transmitted
    sensory data](img/B21282_10_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – 使用LoRa传输的传感器数据控制模拟仪表的天气指示器](img/B21282_10_01.jpg)'
- en: Figure 10.1 – Controlling an analog-metered weather indicator with LoRa-transmitted
    sensory data
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 使用LoRa传输的传感器数据控制模拟仪表的天气指示器
- en: In *Figure 10**.1*, we can see that our Raspberry Pi Pico LoRa sensory transmitter
    from [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140) sends temperature and humidity
    data through LoRa to the LoRa receiver we also built in [*Chapter 9*](B21282_09.xhtml#_idTextAnchor140).
    We do not need to change the code for our transmitter as it performs what we need
    it to do. As mentioned, we will update the code for our LoRa receiver as we require
    it to connect to the internet and send MQTT messages.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10*.1中，我们可以看到我们的Raspberry Pi Pico LoRa传感器发射器从[*第9章*](B21282_09.xhtml#_idTextAnchor140)发送温度和湿度数据通过LoRa到我们也在[*第9章*](B21282_09.xhtml#_idTextAnchor140)中构建的LoRa接收器。我们不需要更改发射器的代码，因为它执行了我们需要的操作。正如提到的，我们将根据需要更新LoRa接收器的代码，以便它能够连接到互联网并发送MQTT消息。
- en: Once we establish that our MQTT code is working properly, we will build a new
    version of the weather indicator and program it to respond accordingly to the
    MQTT messages.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确认我们的MQTT代码工作正常，我们将构建天气指示器的新版本，并编程它以相应地响应MQTT消息。
- en: We will start by adding the CircuitPython MQTT library to our LoRa receiver.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先将CircuitPython MQTT库添加到我们的LoRa接收器中。
- en: Installing the CircuitPython library for MQTT
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装MQTT的CircuitPython库
- en: MQTT libraries for microcontrollers enable IoT devices to use the MQTT protocol,
    a messaging system optimized for low bandwidth and minimal device resources. These
    libraries, designed for various microcontroller platforms, enable connections
    to MQTT brokers, message publishing, and topic subscriptions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 微控制器MQTT库使物联网设备能够使用MQTT协议，这是一种针对低带宽和最小设备资源优化的消息系统。这些库为各种微控制器平台设计，使设备能够连接到MQTT代理，发布消息和订阅主题。
- en: Among these, the Adafruit MiniMQTT library is notable for CircuitPython devices.
    This library offers a straightforward API, suitable for boards such as the Raspberry
    Pi Pico W. It supports key MQTT features such as publish/subscribe and works with
    various MQTT brokers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些库中，Adafruit MiniMQTT库对于CircuitPython设备来说尤为突出。这个库提供了一个简单的API，适用于如Raspberry
    Pi Pico W这样的板子。它支持关键的MQTT功能，如发布/订阅，并与各种MQTT代理一起工作。
- en: 'To install the MiniMQTT library, we do the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装MiniMQTT库，我们执行以下操作：
- en: Using a web browser, we navigate to the URL [https://circuitpython.org/libraries](https://circuitpython.org/libraries).
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用网络浏览器，我们导航到URL [https://circuitpython.org/libraries](https://circuitpython.org/libraries)。
- en: As we are using CircuitPython 8, we download the `adafruit-circuitpython-bundle-8.x-mpy-20231205.zip`
    ZIP file and unzip it to a location on our computer.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们使用的是CircuitPython 8，我们下载`adafruit-circuitpython-bundle-8.x-mpy-20231205.zip`
    ZIP文件，并将其解压缩到我们的计算机上的某个位置。
- en: We want to install the library files in the `lib` folder on our Raspberry Pi
    Pico W and not the root directory. So, we need to double-click on the `lib` folder
    under the **CircuitPython** section in Thonny to open it.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望将库文件安装到我们的Raspberry Pi Pico W的`lib`文件夹中，而不是根目录。因此，我们需要在Thonny的**CircuitPython**部分下双击`lib`文件夹以打开它。
- en: 'The files we are interested in from the Adafruit library are in the `adafruit_minimqtt`
    folder. To install these files onto our Raspberry Pi Pico W from Thonny, we open
    the folder in the **Files** section in Thonny and right-click to get the following
    dialog:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们感兴趣的Adafruit库中的文件位于`adafruit_minimqtt`文件夹中。要将这些文件安装到我们的Raspberry Pi Pico W上（使用Thonny），我们在Thonny的**文件**部分打开文件夹，然后右键单击以获取以下对话框：
- en: '![Figure 10.2 – Uploading the MQTT library to the Raspberry Pi Pico](img/B21282_10_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 将MQTT库上传到Raspberry Pi Pico](img/B21282_10_02.jpg)'
- en: Figure 10.2 – Uploading the MQTT library to the Raspberry Pi Pico
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 将MQTT库上传到Raspberry Pi Pico
- en: 'After uploading the libraries to the Pico W, the file structure on our Pico
    should look like the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Pico W 上上传库后，我们的 Pico 上的文件结构应如下所示：
- en: '![Figure 10.3 – Pico W file structure after uploading Mini MQTT](img/B21282_10_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.3 – 上传 Mini MQTT 后的 Pico W 文件结构](img/B21282_10_03.jpg)'
- en: Figure 10.3 – Pico W file structure after uploading Mini MQTT
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 上传 Mini MQTT 后的 Pico W 文件结构
- en: With the Adafruit MQTT library set up on our Raspberry Pi Pico W, our next step
    is to configure a CloudAMQP instance to broker our MQTT messages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Raspberry Pi Pico W 上设置了 Adafruit MQTT 库后，我们的下一步是配置一个 CloudAMQP 实例来作为我们的
    MQTT 消息的代理。
- en: Let’s do that now.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即这样做。
- en: Creating a CloudAMQP instance for our application
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为我们的应用程序创建一个 CloudAMQP 实例
- en: Having already set up an account in [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107),
    we’re now prepared to create a CloudAMQP instance to act as the broker for MQTT
    messages from our Raspberry Pi Pico W. Following the steps outlined in the *Setting
    up a CloudAMQP instance* section of [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107),
    we create a new instance, call it `RemoteWeatherStation`, and record the details
    for use in our LoRa receiver code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 7 章*](B21282_07.xhtml#_idTextAnchor107) 中已经设置了一个账户，我们现在准备创建一个 CloudAMQP
    实例，作为从我们的 Raspberry Pi Pico W 发送的 MQTT 消息的代理。按照 [*第 7 章*](B21282_07.xhtml#_idTextAnchor107)
    中“设置 CloudAMQP 实例”部分的说明，我们创建了一个新实例，命名为 `RemoteWeatherStation`，并记录详细信息以供我们在 LoRa
    接收器代码中使用。
- en: We’ll utilize the WebSocket UI of our CloudAMQP instance to observe messages
    from our LoRa transmitter, enabling us to test our application thoroughly before
    constructing and implementing our new weather indicator.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用 CloudAMQP 实例的 WebSocket UI 来观察来自我们的 LoRa 发射器的消息，使我们能够在构建和实施新的天气指示器之前彻底测试我们的应用程序。
- en: Let’s go ahead and modify the code on our LoRa receiver by adding MQTT functionality
    so that it can publish MQTT messages to the `RemoteWeatherStation` instance.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续修改 LoRa 接收器上的代码，添加 MQTT 功能，使其能够向 `RemoteWeatherStation` 实例发布 MQTT 消息。
- en: Adding MQTT functionality to the LoRa receiver
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 LoRa 接收器添加 MQTT 功能
- en: With our CloudAMQP instance created, we will now enhance the code on our LoRa
    receiver to incorporate Wi-Fi and MQTT functionalities. This modification enables
    the receiver to effectively utilize LoRa to receive sensory data from our transmitter
    and then leverage Wi-Fi for internet connectivity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 CloudAMQP 实例后，我们现在将增强 LoRa 接收器上的代码，以包含 Wi-Fi 和 MQTT 功能。这种修改使接收器能够有效地利用 LoRa
    从我们的发射器接收传感数据，然后利用 Wi-Fi 进行互联网连接。
- en: Utilizing the MQTT protocol, the receiver can transmit this sensory data to
    our CloudAMQP server. This integration not only demonstrates the synergy between
    different communication technologies – LoRa for local, long-range transmission
    and MQTT over Wi-Fi for global reach – but also greatly expands the capabilities
    of our IoT ecosystem. Our LoRa receiver becomes a bridge, gathering sensory information
    locally and distributing it over the internet.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 利用 MQTT 协议，接收器可以将这些传感数据传输到我们的 CloudAMQP 服务器。这种集成不仅展示了不同通信技术之间的协同作用——LoRa 用于本地、长距离传输，而
    MQTT 通过 Wi-Fi 用于全球覆盖——而且极大地扩展了我们的物联网生态系统功能。我们的 LoRa 接收器成为一座桥梁，在本地收集传感信息，并通过互联网分发。
- en: 'To modify the LoRa receiver code, we do the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改 LoRa 接收器代码，我们执行以下操作：
- en: We connect our Raspberry Pi Pico W from our LoRa receiver to a USB port and
    launch Thonny using a computer and operating system of our choice.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的 Raspberry Pi Pico W 从 LoRa 接收器连接到 USB 端口，并使用我们选择的计算机和操作系统启动 Thonny。
- en: We then activate the CircuitPython environment on our Pico W by selecting it
    from the bottom right-hand side of the screen.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过选择屏幕右下角来激活我们的 Pico W 上的 CircuitPython 环境。
- en: 'In a new tab in the editor section (hit *Ctrl* + *N*), we start by entering
    our imports:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器部分的新标签页（按 *Ctrl* + *N*），我们首先输入我们的导入：
- en: '[PRE0]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In our code, we have the following:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: The `time` library is used for timing and delays in the code.
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`time` 库用于代码中的计时和延迟。'
- en: The `board` module provides access to the basic pin setup of the microcontroller.
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`board` 模块提供了对微控制器基本引脚设置的访问。'
- en: The `busio` module is used to create bus communication interfaces, essential
    for devices such as the RFM9x LoRa module.
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`busio` 模块用于创建总线通信接口，这对于像 RFM9x LoRa 模块这样的设备至关重要。'
- en: '`digitalio` is utilized for managing digital I/O pins.'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`digitalio` 用于管理数字 I/O 引脚。'
- en: The `adafruit_rfm9x` module is specifically for interfacing with the RFM95W
    LoRa radio modules installed on the LoRa receiver.
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`adafruit_rfm9x` 模块专门用于与安装在 LoRa 接收器上的 RFM95W LoRa 无线电模块进行接口。'
- en: The `wifi` module is included to handle Wi-Fi connections on the microcontroller.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含了 `wifi` 模块来处理微控制器上的 Wi-Fi 连接。
- en: '`socketpool` provides a way to manage network sockets, which are needed for
    internet communication. In our CircuitPython code, this module is essential for
    efficiently managing network sockets, which is crucial for MQTT communications
    via the `adafruit_minimqtt` library. It provides stable TCP/IP connections over
    Wi-Fi.'
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`socketpool` 提供了一种管理网络套接字的方法，这对于互联网通信是必需的。在我们的 CircuitPython 代码中，此模块对于高效管理网络套接字至关重要，这对于通过
    `adafruit_minimqtt` 库进行 MQTT 通信是必不可少的。它通过 Wi-Fi 提供稳定的 TCP/IP 连接。'
- en: '`adafruit_minimqtt` is imported to enable MQTT protocol communication, allowing
    the device to publish and subscribe to MQTT topics.'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 `adafruit_minimqtt` 以启用 MQTT 协议通信，允许设备发布和订阅 MQTT 主题。
- en: 'After our imports, we set our Wi-Fi network (SSID) and Wi-Fi password:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入之后，我们设置我们的 Wi-Fi 网络（SSID）和 Wi-Fi 密码：
- en: '[PRE1]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We then enter code to initialize the `GP5` GPIO pin as a digital output to
    control an LED connected to that pin on the microcontroller:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们进入代码以初始化 `GP5` GPIO 引脚作为数字输出，以控制连接到该引脚上的微控制器上的 LED：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We define the `flash_led()` method, which blinks an LED a specified number
    of times, with each blink lasting for the duration set in seconds:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了 `flash_led()` 方法，该方法闪烁 LED 指定次数，每次闪烁的持续时间由秒数设置：
- en: '[PRE3]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we define the `connect_to_wifi()` function. This function repeatedly
    tries to connect to Wi-Fi with the provided SSID and password, signaling a failed
    attempt by blinking an LED twice for 2 seconds each, followed by a 5-second pause
    before retrying. Upon successful connection, it exits the loop and blinks the
    LED four times, each for 1 second, to indicate a successful Wi-Fi connection:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义 `connect_to_wifi()` 函数。此函数反复尝试使用提供的 SSID 和密码连接到 Wi-Fi，通过闪烁 LED 两次，每次持续
    2 秒，然后暂停 5 秒再重试来表示失败的尝试。在成功连接后，它退出循环，并闪烁 LED 四次，每次持续 1 秒，以表示成功的 Wi-Fi 连接：
- en: '[PRE4]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then create the `pool` variable, an instance of `socketpool.SocketPool`,
    using the `wifi.radio` object, which manages and provides network socket connections
    for Wi-Fi communication:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建了一个名为 `pool` 的变量，它是 `socketpool.SocketPool` 的一个实例，使用 `wifi.radio` 对象，该对象管理和提供
    Wi-Fi 通信的网络套接字连接：
- en: '[PRE5]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, our code sets up the MQTT configuration, defining the server address
    (`MQTT_SERVER`), port number (`MQTT_PORT`), user credentials (`USERNAME` and `PASSWORD`),
    device identifier (`DEVICE_ID`), and MQTT topic (`MQTT_TOPIC`) for communication.
    We obtain these values from the CloudAMQP instance we set up for our application:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们的代码设置 MQTT 配置，定义服务器地址 (`MQTT_SERVER`)、端口号 (`MQTT_PORT`)、用户凭据 (`USERNAME`
    和 `PASSWORD`)、设备标识符 (`DEVICE_ID`) 和 MQTT 主题 (`MQTT_TOPIC`) 以进行通信。我们从为我们的应用程序设置的
    CloudAMQP 实例中获取这些值：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then configure the `GP18`, `GP19`, and `GP16` for SCK, MOSI, and MISO, respectively,
    and initialize digital I/O pins `GP17` and `GP14` for **chip select** (**CS**)
    and **reset** (**RST**) functions. The CS pin is used to select the LoRa module
    for communication, while the RST pin is employed to reset the module, ensuring
    it starts in a known state:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将 `GP18`、`GP19` 和 `GP16` 分别配置为 SCK、MOSI 和 MISO，并初始化数字 I/O 引脚 `GP17` 和 `GP14`
    以用于 **芯片选择** （**CS**） 和 **复位** （**RST**） 功能。CS 引脚用于选择 LoRa 模块进行通信，而 RST 引脚用于复位模块，确保它从已知状态开始：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We initialize the RFM9x LoRa radio module by creating an instance of `adafruit_rfm9x.RFM9x`
    with the previously configured SPI bus (`spi`), chip select (`cs`), and reset
    (`rst`) pins, and set the operating frequency to 915.0 MHz as our example is built
    for use in North America:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过创建一个 `adafruit_rfm9x.RFM9x` 实例来初始化 RFM9x LoRa 无线电模块，该实例使用先前配置的 SPI 总线 (`spi`)、芯片选择
    (`cs`) 和复位 (`rst`) 引脚，并将工作频率设置为 915.0 MHz，因为我们的示例是为北美使用而构建的：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We then set up an MQTT client by creating an instance of MQTT with the specified
    MQTT broker details (`MQTT_SERVER` and `MQTT_PORT`), user credentials (`USERNAME`
    and `PASSWORD`), and the previously created socket pool (`pool`) for network communication:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过创建 MQTT 实例并指定 MQTT 代理详情（`MQTT_SERVER` 和 `MQTT_PORT`）、用户凭据（`USERNAME`
    和 `PASSWORD`）以及先前创建的套接字池（`pool`）来设置 MQTT 客户端，用于网络通信：
- en: '[PRE9]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our code connects the MQTT client to the MQTT broker and prints a message indicating
    that the system is now ready to listen for incoming LoRa messages:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码将 MQTT 客户端连接到 MQTT 代理，并打印一条消息，表明系统现在已准备好监听传入的 LoRa 消息：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We create a continuous loop to check for incoming packets from the RFM9x LoRa
    module; upon receiving a packet, our code decodes the message to UTF-8 format,
    prints the received message, flashes the LED twice for 0.5 seconds each, then
    publishes the message to the specified MQTT topic and prints a confirmation of
    the sent MQTT message:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个连续循环来检查RFM9x LoRa模块的传入数据包；接收到数据包后，我们的代码将消息解码为UTF-8格式，打印接收到的消息，LED闪烁两次，每次0.5秒，然后将消息发布到指定的MQTT主题，并打印已发送MQTT消息的确认信息：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
    This will open the **Where to save** **to?** dialog.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择**文件** | **另存为...**。这将打开**保存位置**对话框。
- en: '![Figure 10.4 – Saving our file to our Raspberry Pi Pico W](img/B21282_10_04.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – 将文件保存到我们的Raspberry Pi Pico W](img/B21282_10_04.jpg)'
- en: Figure 10.4 – Saving our file to our Raspberry Pi Pico W
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – 将文件保存到我们的Raspberry Pi Pico W
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico W (CircuitPython device), we click on the corresponding
    button.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此对话框中，我们有机会选择文件存储的位置。要将文件保存在我们的Raspberry Pi Pico W（CircuitPython设备）上，我们点击相应的按钮。
- en: We then give the file the name `code.py` and click **Ok**.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将文件命名为`code.py`并点击**确定**。
- en: To run our code, we click on the green run button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的运行按钮，在键盘上按*F5*，或者在顶部的**运行**菜单选项中点击，然后选择**运行** **当前脚本**。
- en: If it is not already running, we power up and run the LoRa sensory transmitter.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果它尚未运行，我们打开电源并运行LoRa传感器发射器。
- en: We verify the correct functioning of our code by checking the receipt of MQTT
    messages in the MQTT-Explorer app in Windows.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过检查Windows中的MQTT-Explorer应用中MQTT消息的接收情况来验证代码的正确运行。
- en: We should also observe our LED flashes twice.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应观察我们的LED闪烁两次。
- en: By taking temperature and humidity readings from the LoRa sensory transmitter
    and relaying them to our MQTT server using our LoRa receiver, much like a baton
    pass in a relay race, we have effectively established our own weather information
    web service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从LoRa传感器发射器读取温度和湿度读数，并使用我们的LoRa接收器将它们中继到我们的MQTT服务器，就像接力赛中的接力一样，我们有效地建立了自己的天气信息网络服务。
- en: With our setup ready, we can now utilize the MQTT message data to operate our
    improved analog meter-style weather indicator. Our first step is to construct
    the device, followed by programming it to respond to incoming data.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置准备就绪后，我们现在可以利用MQTT消息数据来操作我们的改进的模拟仪表式天气指示器。我们的第一步是构建设备，然后编程它以响应传入的数据。
- en: Creating a new weather indicator
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的天气指示器
- en: In this section, we introduce an upgraded weather indicator, building on the
    version from [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048). This model features
    an RGB LED instead of a single-color LED. We will use it to indicate humidity
    by setting the color to red for low humidity, green for a humidity level between
    30 and 50 percent (considered a comfortable humidity level for people), and blue
    for a humidity above 50 percent. The device now uses the economical Raspberry
    Pi Pico WH as opposed to the more expensive Raspberry Pi 5\. A new addition is
    the reset button for the Raspberry Pi Pico WH, allowing us to reset the Pico if
    we need to.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍一个升级的天气指示器，基于[*第3章*](B21282_03.xhtml#_idTextAnchor048)中的版本。此型号使用RGB
    LED而不是单色LED。我们将使用它通过将颜色设置为红色来指示低湿度，绿色表示30%至50%的湿度水平（被认为是人们舒适的湿度水平），以及蓝色表示50%以上的湿度。设备现在使用经济的Raspberry
    Pi Pico WH，而不是更昂贵的Raspberry Pi 5。新增功能是Raspberry Pi Pico WH的复位按钮，允许我们在需要时重置Pico。
- en: 'The design of our upgraded weather indicator includes a new feature: a split
    stand specifically engineered for easier printing using a **Fused Deposition Modeling**
    (**FDM**) 3D printer. By dividing the stand into two separate parts, each piece
    can be printed flat. When printed flat, the layer lines in each section of the
    stand run perpendicular to the primary stress axis encountered during use. This
    perpendicular arrangement of the layers effectively distributes stress across
    the structure, making the stand more resilient and less prone to breakage or warping
    under load.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们升级的天气指示器设计包括一个新功能：一个专门为使用**熔融沉积建模**（**FDM**）3D打印机更容易打印的分割支架。通过将支架分成两个独立的部分，每个部分都可以平印。当平印时，支架每个部分的层线与使用过程中遇到的主要应力轴垂直。这种层垂直排列有效地在整个结构上分布应力，使支架更具弹性，更不易在负载下断裂或变形。
- en: We will start the construction of our new weather indicator by building the
    split stand.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始构建我们新的天气指示器，首先构建分裂支架。
- en: Building the split stand
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建分裂支架
- en: 'We may use any of the stands we have built so far in the book to mount our
    weather indicator faceplate. For our example, we introduce a split stand that
    may be printed using a standard FDM 3D printer or a liquid resin 3D printer. The
    parts of the split stand can be seen in the following figure:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用本书中构建的任何支架来安装我们的天气指示器面板。在我们的例子中，我们介绍了一种可以使用标准FDM 3D打印机或液体树脂3D打印机打印的分裂支架。分裂支架的部件如下所示：
- en: '![Figure 10.5 – Split stand printed with PLA and a FDM 3D printe](img/B21282_10_05.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 使用PLA和FDM 3D打印机打印的分裂支架](img/B21282_10_05.jpg)'
- en: Figure 10.5 – Split stand printed with PLA and a FDM 3D printer
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 使用PLA和FDM 3D打印机打印的分裂支架
- en: 'The parts of the split stand are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分裂支架的部件如下：
- en: '*A*: Right split stand'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*：右侧分裂支架'
- en: '*B*: Left split stand'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*：左侧分裂支架'
- en: '*C*: Base'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*：底座'
- en: '*D* (not shown): 9 X M3 10 mm bolts'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*（未显示）：9个M3 10毫米螺栓'
- en: '*E* (not shown): 4 X 12 mm rubber pads (optional)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*（未显示）：4个12毫米橡胶垫（可选）'
- en: The `.stl` files for our split stand are located in the `Build Files` folder
    of this chapter’s GitHub repository. All three parts shown in *Figure 10**.5*
    may be printed together on a standard Ender-3-sized print bed (220 mm by 220 mm
    by 250 mm).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分裂支架的`.stl`文件位于本章GitHub仓库的`Build Files`文件夹中。*图10.5*中显示的所有三个部件都可以在一个标准Ender-3尺寸的打印床上（220毫米×220毫米×250毫米）一起打印。
- en: When using an FDM printer, it’s important to slice the print file with support
    structures, especially since the outer ring of the split stand *floats* in space
    when printed flat. For the split stand, **Polylactic Acid** (**PLA**) material
    is the optimal choice due to its printing ease and reliable results.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用FDM打印机时，重要的是要带有支撑结构的切片打印文件，特别是当分裂支架的外环在打印成平面时在空间中*漂浮*。对于分裂支架，**聚乳酸**（**PLA**）材料是最佳选择，因为它易于打印且结果可靠。
- en: We can see how we may position the parts of the split stand on a print bed in
    the following figure.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到我们如何在打印床上定位分裂支架的部件。
- en: '![Figure 10.6 – Laying out the parts of the split stand for 3D printing on
    a print bed](img/B21282_10_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 在打印床上布局分裂支架的部件用于3D打印](img/B21282_10_06.jpg)'
- en: Figure 10.6 – Laying out the parts of the split stand for 3D printing on a print
    bed
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 在打印床上布局3D打印的分裂支架部分
- en: 'To construct the stand, we follow the steps shown in *Figure 10**.7*:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建支架，我们按照*图10.7*中显示的步骤进行：
- en: '![Figure 10.7 – Constructing the split stand](img/B21282_10_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图10.7 – 构建分裂支架](img/B21282_10_07.jpg)'
- en: Figure 10.7 – Constructing the split stand
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 – 构建分裂支架
- en: Utilizing an M3 tap, we carefully create screw threads on the right side of
    the split stand (*A* from *Figure 10**.5*). This step is optional as the holes
    should be large enough to allow M3 bolts to screw in without tapping.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 利用M3丝锥，我们在分裂支架的右侧（*图10.5*中的*A*）小心地创建螺纹。这一步是可选的，因为孔应该足够大，以便M3螺栓可以拧入而不需要攻丝。
- en: Using five M3 10 mm bolts, we secure the left split stand (*C* from *Figure
    10**.5*) to the right split stand (*A* from *Figure 10**.5*).
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用五个M3 10毫米螺栓，我们将左侧分裂支架（*图10.5*中的*C*）固定到右侧分裂支架（*图10.5*中的*A*）。
- en: Next, we attach four standard 12 mm rubber pads to the base’s bottom as feet,
    using epoxy glue for enhanced adhesion. This step, while not mandatory, adds stability
    as the stand can function without the rubber pads.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用环氧树脂胶水将四个标准12毫米橡胶垫粘贴到底座的底部作为脚，以增强粘附性。这一步虽然不是强制性的，但增加了稳定性，因为支架可以在没有橡胶垫的情况下工作。
- en: Using an M3 tap, we create screw threads in the base. This step is optional
    as the holes should be large enough to allow M3 bolts to screw in without tapping.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用M3丝锥，我们在底座上创建螺纹。这一步是可选的，因为孔应该足够大，以便M3螺栓可以拧入而不需要攻丝。
- en: Using four M3 bolts, we secure the assembled stand to the base (*C* from *Figure
    10**.5*).
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用四个M3螺栓，我们将组装好的支架固定到底座上（*图10.5*中的*C*）。
- en: The assembled split stand can be painted for aesthetic improvement. Once the
    split stand is finished, the next step is to assemble the faceplate of our weather
    indicator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 组装好的分裂支架可以喷漆以改善美观。一旦分裂支架完成，下一步就是组装我们的天气指示器的面板。
- en: Building the faceplate
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建面板
- en: The faceplate for our new enhanced weather indicator is very similar to the
    faceplate we built in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048). The exceptions
    are the use of a Raspberry Pi Pico WH over a Raspberry Pi 5 and an RBG LED, which
    will allow us to use various colors for our indicator.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的增强型天气指示器的面板与我们之前在 [*第3章*](B21282_03.xhtml#_idTextAnchor048) 中构建的面板非常相似。区别在于使用了Raspberry
    Pi Pico WH而不是Raspberry Pi 5，以及RGB LED，这将允许我们为指示器使用各种颜色。
- en: 'We can see the parts that make up the faceplate in the following figure:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下图中看到组成面板的部件：
- en: '![Figure 10.8 – Parts that make up the faceplate of our weather indicator](img/B21282_10_08.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图10.8 – 组成我们天气指示器面板的部件](img/B21282_10_08.jpg)'
- en: Figure 10.8 – Parts that make up the faceplate of our weather indicator
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 – 组成我们天气指示器面板的部件
- en: '*A*: Faceplate front.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*: 面板正面。'
- en: '*B*: Faceplate alignment tool.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*: 面板校准工具。'
- en: '*C*: Raspberry Pi Pico WH.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*: Raspberry Pi Pico WH。'
- en: '*D*: Faceplate front button. Used to reset the Raspberry Pi Pico WH.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*: 面板正面按钮。用于重置Raspberry Pi Pico WH。'
- en: '*E*: Hook.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*: 钩子。'
- en: '*F*: Faceplate back.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*F*: 面板背面。'
- en: '*G*: Faceplate graphic.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*G*: 面板图形。'
- en: '*H*: RGB LED with resistors and jumper wires (jump ahead to the upcoming section
    *Adding jumper wires up our RGB LED* for construction of this component).'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*H*: 带有电阻和跳线（跳转到即将到来的部分 *添加跳线到RGB LED* 以构建此组件）的RGB LED。'
- en: '*I*: SG90 servo motor.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*I*: SG90伺服电机。'
- en: '*J*: 8 mm LED holder.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*J*: 8 mm LED支架。'
- en: 'To build the faceplate for our new weather indicator, we follow the steps in
    the following diagram:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建我们新的天气指示器的面板，我们遵循以下图中的步骤：
- en: '![Figure 10.9 – Construction of the faceplate for our new weather indicator](img/B21282_10_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图10.9 – 我们新的天气指示器面板的构造](img/B21282_10_09.jpg)'
- en: Figure 10.9 – Construction of the faceplate for our new weather indicator
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 – 我们新的天气指示器面板的构造
- en: Using the alignment tool (*B* from *Figure 10**.8*) and epoxy glue, we align
    and glue the front of the faceplate (*A* from *Figure 10**.8*) to the back of
    the faceplate (*F* from *Figure 10**.8*).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用校准工具（*B* 来自 *图10.8*）和环氧树脂胶水，我们将面板正面（*A* 来自 *图10.8*）与面板背面（*F* 来自 *图10.8*）对齐并粘合。
- en: We glue the hook (*E* from *Figure 10**.8*) to the back of the faceplate (*F*
    from *Figure 10**.8*) into the slot provided.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将钩子（*E* 来自 *图10.8*）用胶水粘在面板背面（*F* 来自 *图10.8*）的槽中。
- en: We print the faceplate graphic (*G* from *Figure 10**.8*) on printable vinyl
    using a color printer. Next, we trim the graphic using a digital cutter, such
    as a Silhouette Cameo, or by hand and attach it to the faceplate’s front, ensuring
    proper alignment of the holes.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用彩色打印机将面板图形（*G* 来自 *图10.8*）打印在可打印的乙烯基上。接下来，我们使用数字切割机，如Silhouette Cameo，或手工裁剪图形，并将其粘贴到面板的前面，确保孔的适当对齐。
- en: We align the SG90 servo motor (*I* from *Figure 10**.8*) with its corresponding
    hole and secure it in place to the back of the faceplate (*F* from *Figure 10**.8*)
    with glue from a hot glue gun.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将SG90伺服电机（*I* 来自 *图10.8*）与相应的孔对齐，并用热胶枪的胶水将其固定在面板背面（*F* 来自 *图10.8*）上。
- en: We secure the Raspberry Pi Pico WH (*C* from *Figure 10**.8*) to the back of
    the faceplate (*F* from *Figure 10**.8*) with four M3 8 mm screws such that the
    pins are facing up and the USB port is facing out.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用四个M3 8 mm螺丝将Raspberry Pi Pico WH（*C* 来自 *图10.8*）固定在面板背面（*F* 来自 *图10.8*）上，使得引脚向上，USB端口向外。
- en: We push the RGB LED (*H* from *Figure 10**.8*) from the back of the faceplate
    to the front and secure it in place with the 8 mm LED holder (*J* from *Figure
    10**.8*).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将RGB LED（*H* 来自 *图10.8*）从面板背面推到前面，并用8 mm LED支架（*J* 来自 *图10.8*）固定在位。
- en: Having constructed the faceplate and stand, we can now fasten the faceplate
    to the stand using an M5 20 mm bolt and nut. Once this is done, we’re prepared
    to proceed with connecting the RGB LED and servo motor to the Raspberry Pi Pico
    WH.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了面板和底座之后，我们现在可以使用M5 20 mm螺栓和螺母将面板固定到底座上。完成此操作后，我们就准备好连接RGB LED和伺服电机到Raspberry
    Pi Pico WH了。
- en: Configuring the RGB LED indicator
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置RGB LED指示器
- en: For our application, we will use an RGB LED to represent the humidity reading
    we get from our remote LoRa transmitter. An RGB LED allows us to represent any
    color as it combines three LEDs (red, green, and blue) into one housing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们将使用RGB LED来表示我们从远程LoRa发射器获得的湿度读数。RGB LED允许我们将任何颜色表示出来，因为它将三个LED（红色、绿色和蓝色）组合到一个外壳中。
- en: Before we wire up and install our RGB LED, let’s get a little understanding
    of what RGB LEDs are.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们连接和安装RGB LED之前，让我们先了解一下RGB LED是什么。
- en: Understanding RGB LEDs
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解RGB LED
- en: 'RGB LEDs combine red, green, and blue light to produce various colors. Each
    color has a pin for control. There are two types: common cathode and common anode
    (*Figure 10**.10*). Common cathode LEDs have a single ground pin shared by all
    colors, requiring a positive voltage to the color pins for illumination. Common
    anode LEDs share a positive pin, needing a ground connection on the color pins
    to light up.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED通过组合红、绿、蓝三种光线来产生各种颜色。每种颜色都有一个用于控制的引脚。它们有两种类型：公共阴极和公共阳极（*图10.10*）。公共阴极LED具有一个所有颜色共用的单个接地引脚，需要向颜色引脚施加正电压以实现照明。公共阳极LED共享一个正引脚，需要在颜色引脚上连接接地才能点亮。
- en: '![Figure 10.10 – Two different types of RGB LEDs](img/B21282_10_10.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图10.10 – 两种不同类型的RGB LED](img/B21282_10_10.jpg)'
- en: Figure 10.10 – Two different types of RGB LEDs
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 – 两种不同类型的RGB LED
- en: The type determines how we connect and control them, with common cathode LEDs
    needing a high signal and common anode LEDs needing a low signal for activation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 类型决定了我们如何连接和控制它们，公共阴极LED需要高信号激活，而公共阳极LED需要低信号激活。
- en: Differentiating between common cathode and common anode RGB LEDs
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 区分公共阴极和公共阳极RGB LED
- en: To determine whether our RGB LED is a common anode or common cathode type, we
    use a multimeter set to diode test mode. First, we identify the longest leg of
    the LED, as this is usually the common connection. We then connect the multimeter
    red probe to the longest leg and the black probe to one of the other legs. If
    the LED lights up, the longest leg is the anode, indicating a common anode LED.
    If it doesn’t light up, we’ll switch the probes. A lit LED with the black probe
    on the longest leg means it’s a common cathode.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定我们的RGB LED是公共阳极还是公共阴极类型，我们使用设置在二极管测试模式下的万用表。首先，我们识别LED的最长腿，因为这通常是公共连接。然后，我们将万用表的红表笔连接到最长腿，黑表笔连接到其他腿中的一个。如果LED点亮，则最长腿是阳极，表示这是一个公共阳极LED。如果没有点亮，我们将交换表笔。黑表笔连接到最长腿时LED点亮，意味着它是一个公共阴极。
- en: For our application, we will be using a common anode RGB LED, and we will program
    it to change colors based on humidity levels. For low humidity levels, it will
    be red, indicating dry conditions. It will be green to indicate a humidity level
    between 30 and 50 percent and blue to represent humidity levels higher than 50
    percent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们将使用公共阳极RGB LED，并将它编程为根据湿度水平改变颜色。对于低湿度水平，它将显示红色，表示干燥条件。当湿度水平在30%到50%之间时，它将显示绿色，而当湿度水平高于50%时，它将显示蓝色。
- en: Adding jumper wires to our RGB LED
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将跳线连接到我们的RGB LED
- en: To prepare our RGB LED for connection with the Raspberry Pi Pico WH, we’ll solder
    female jumper wires to each of its leads. For the RGB LED’s protection, we’ll
    solder 220 Ohm resistors onto the red, green, and blue leads, positioning them
    between the LED’s legs and the jumper wires. In our example, we use a yellow wire
    for power, a red wire for the red LED, a green wire for the green LED, and a blue
    wire for the blue LED, as shown in the following figure.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的RGB LED连接到Raspberry Pi Pico WH，我们将在每个引脚上焊接雌性跳线。为了保护RGB LED，我们将在红色、绿色和蓝色引脚上焊接220欧姆电阻，将它们放置在LED的腿和跳线之间。在我们的例子中，我们使用黄色线作为电源线，红色线作为红色LED，绿色线作为绿色LED，蓝色线作为蓝色LED，如图所示。
- en: '![Figure 10.11 – Adding jumper wires to the RGB LED](img/B21282_10_11.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图10.11 – 将跳线连接到RGB LED](img/B21282_10_11.jpg)'
- en: Figure 10.11 – Adding jumper wires to the RGB LED
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 – 将跳线连接到RGB LED
- en: Applying heat shrink, as shown in Step *2* of *Figure 10**.11*, reinforces the
    solder connections by providing both physical strength and electrical insulation.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.11*的第*2*步中所示，应用热缩套管通过提供物理强度和电气绝缘来加强焊接连接。
- en: Connecting the RGB LED to our Raspberry Pi Pico WH
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将RGB LED连接到我们的Raspberry Pi Pico WH
- en: 'We will power our RGB LED with the 3V3 power port from our Raspberry Pi Pico
    WH. For wiring, use the following diagram:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Raspberry Pi Pico WH的3V3电源端口来供电我们的RGB LED。对于接线，请使用以下图示：
- en: '![Figure 10.12 – Wiring diagram for RGB LED and Raspberry Pi Pico WH](img/B21282_10_12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图10.12 – RGB LED和Raspberry Pi Pico WH的接线图](img/B21282_10_12.jpg)'
- en: Figure 10.12 – Wiring diagram for RGB LED and Raspberry Pi Pico WH
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 – RGB LED和Raspberry Pi Pico WH的接线图
- en: 'The connections are as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 连接方式如下：
- en: 3V3 power connects to the common anode.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3V3电源连接到公共阳极。
- en: Red connects to `GP15` using a 220 Ohm resistor.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色通过一个220欧姆电阻连接到`GP15`。
- en: Green connects to `GP13` using a 220 Ohm resistor.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绿色通过一个220欧姆电阻连接到`GP13`。
- en: Blue connects to `GP12` using a 220 Ohm resistor.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝色通过一个220欧姆电阻连接到`GP12`。
- en: With the RGB LED connected to the Raspberry Pi Pico WH, it is time to test it
    with code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将RGB LED连接到Raspberry Pi Pico WH后，现在是时候用代码测试它了。
- en: Testing our RGB LED circuit
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试我们的RGB LED电路
- en: To test out our RGB LED circuit, we will run code to turn on each of the three
    colors. We will write our code in MicroPython and use the Thonny IDE.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的RGB LED电路，我们将运行代码来打开三种颜色中的每一种。我们将用MicroPython编写代码并使用Thonny IDE。
- en: 'To test our RGB LED with code, we do the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要用代码测试我们的RGB LED，我们做以下操作：
- en: We connect our Raspberry Pi Pico WH to a USB port and launch Thonny. We may
    use our Raspberry Pi or another operating system for this. If MicroPython has
    not been installed, we follow the steps from the *Using a Raspberry Pi Pico W
    with MQTT* section in [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), to install
    it on our Raspberry Pi Pico WH.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Raspberry Pi Pico WH连接到USB端口并启动Thonny。我们可以使用Raspberry Pi或其他操作系统进行此操作。如果MicroPython尚未安装，我们按照[*第6章*](B21282_06.xhtml#_idTextAnchor091)中“使用Raspberry
    Pi Pico W与MQTT”部分的步骤，将其安装到我们的Raspberry Pi Pico WH上。
- en: We then activate the MicroPython environment on our Pico by selecting it from
    the bottom right-hand side of the screen.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在屏幕的右下角选择Pico来激活MicroPython环境。
- en: 'In a new tab in the editor section (hit *Ctrl* + *N*), we enter the following
    code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器部分的新标签页（按*Ctrl* + *N*），我们输入以下代码：
- en: '[PRE12]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To save the file, we click on **File** | **Save as...** from the drop-down
    menu. This will open the following dialog:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择**文件** | **另存为...**。这将打开以下对话框：
- en: '![Figure 10.13 – Saving a file to our Raspberry Pi Pico](img/B21282_10_13.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图10.13 – 将文件保存到我们的Raspberry Pi Pico](img/B21282_10_13.jpg)'
- en: Figure 10.13 – Saving a file to our Raspberry Pi Pico
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.13 – 将文件保存到我们的Raspberry Pi Pico
- en: In this dialog, we are given the option to choose where to store our file. To
    save it on our Raspberry Pi Pico WH, we click on the corresponding button.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此对话框中，我们有机会选择文件存储的位置。要将文件保存到我们的Raspberry Pi Pico WH，我们点击相应的按钮。
- en: We then give the file the name `main.py` and click `main.py` is special because
    the system automatically executes this file upon startup or reset, making it the
    default script that runs when the device powers up.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们给文件命名为`main.py`并点击，`main.py`是特殊的，因为系统在启动或重置时会自动执行此文件，使其成为设备启动时运行的默认脚本。
- en: 'Before we test out our code, let’s break it down:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试我们的代码之前，让我们将其分解：
- en: We start by importing the `Pin` class from the `machine` module and the `utime`
    module.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`machine`模块和`utime`模块导入`Pin`类。
- en: We then initialize GPIO pins GP15, GP13, and GP12 as output for red, green,
    and blue LEDs, respectively.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将GPIO引脚GP15、GP13和GP12初始化为输出，分别用于红色、绿色和蓝色LED。
- en: We then define the `set_color(r, g, b)` function to control the RGB LED color.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义`set_color(r, g, b)`函数来控制RGB LED的颜色。
- en: 'We define an infinite loop:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义一个无限循环：
- en: We set the LED to red for 1 second.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将LED设置为红色1秒钟。
- en: We then change the LED to green for 1 second.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将LED变为绿色1秒钟。
- en: Finally, we set the LED to blue for 1 second.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将LED设置为蓝色1秒钟。
- en: To run our code, we click on the green run button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色运行按钮，在键盘上按*F5*或点击顶部的**运行**菜单选项，然后选择**运行** **当前脚本**。
- en: We should observe the RGB LED on our weather indicator cycle turning red, then
    green, then blue.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到我们的天气指示器上的RGB LED循环变红，然后变绿，然后变蓝。
- en: With our RGB LED successfully wired and tested, it is time to hook up the servo
    motor to our Raspberry Pi Pico WH.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的RGB LED成功连接并测试后，现在是时候将伺服电机连接到我们的Raspberry Pi Pico WH了。
- en: Configuring the servo motor
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置伺服电机
- en: With our RGB LED installed and tested, it is now time to shift our focus to
    the servo motor on our weather indicator. Echoing our approach in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048),
    integrating a servo motor into our design offers an excellent means to bridge
    the analog and digital worlds; it enables us to create an analog-style meter where
    a needle, moved precisely by the servo, visually represents various data points.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的RGB LED安装并测试完毕后，现在是时候将我们的注意力转移到我们的天气指示器上的伺服电机。正如我们在[*第3章*](B21282_03.xhtml#_idTextAnchor048)中提到的那样，将伺服电机集成到我们的设计中提供了一种将模拟和数字世界连接起来的优秀方法；它使我们能够创建一个模拟风格的仪表，其中由伺服电机精确移动的指针可以直观地表示各种数据点。
- en: We will start by wiring up our servo motor before turning our attention to testing
    it through code.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先连接伺服电机，然后再通过代码进行测试。
- en: Wiring up our servo motor
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接伺服电机
- en: 'For our weather indicator, we will be incorporating an SG90 servo motor. The
    SG90 servo typically comes with three wires: the power wire (usually red), the
    ground wire (usually brown or black), and the signal wire (usually orange or yellow).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的天气指示器，我们将集成SG90伺服电机。SG90伺服电机通常带有三根电线：电源线（通常是红色）、地线（通常是棕色或黑色）和信号线（通常是橙色或黄色）。
- en: To wire our servo motor to our Raspberry Pi Pico WH, we will start by removing
    the wires from the connector housing just as we did in [*Chapter 3*](B21282_03.xhtml#_idTextAnchor048).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的伺服电机连接到Raspberry Pi Pico WH，我们首先从连接器外壳中拔出电线，就像我们在[*第3章*](B21282_03.xhtml#_idTextAnchor048)中所做的那样。
- en: '![Figure 10.14 – Removing wires from the connector of the SG90 servo](img/B21282_10_14.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图10.14 – 从SG90伺服电机的连接器中拔出电线](img/B21282_10_14.jpg)'
- en: Figure 10.14 – Removing wires from the connector of the SG90 servo
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.14 – 从SG90伺服电机的连接器中拔出电线
- en: Instead of reinserting the wires into the connector housing, we’ll directly
    connect them to the pins of the Raspberry Pi Pico WH.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会将电线重新插入连接器外壳，而是直接将它们连接到Raspberry Pi Pico WH的引脚上。
- en: We will power our servo motor with the VBUS power port from our Raspberry Pi
    Pico WH, as VBUS provides the necessary 5V power supply directly from the USB
    connection, which is ideal for the typical operating voltage of most servo motors
    such as the SG90.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Raspberry Pi Pico WH的VBUS电源端口为伺服电机供电，因为VBUS直接从USB连接提供必要的5V电源，这对于大多数伺服电机的典型工作电压（如SG90）来说非常理想。
- en: 'For wiring, use the following diagram:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布线，请使用以下图示：
- en: '![Figure 10.15 – Wiring the servo motor to the Raspberry Pi Pico WH](img/B21282_10_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图10.15 – 将伺服电机连接到Raspberry Pi Pico WH](img/B21282_10_15.jpg)'
- en: Figure 10.15 – Wiring the servo motor to the Raspberry Pi Pico WH
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.15 – 将伺服电机连接到Raspberry Pi Pico WH
- en: 'The connections are as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 连接方式如下：
- en: VBUS power connects to the positive wire of the servo.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VBUS电源连接到伺服电机的正极线。
- en: The signal wire connects to `GP14.`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 信号线连接到`GP14`。
- en: GND connects to a GND port on the Raspberry Pi Pico WH.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GND连接到Raspberry Pi Pico WH上的GND端口。
- en: Important note
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For simplicity, *Figure 10**.15* illustrates only the servo motor connected
    to the Raspberry Pi Pico WH. However, our actual circuit includes both the RGB
    LED and the servo motor.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，*图10*.*15*仅显示了连接到Raspberry Pi Pico WH的伺服电机。然而，我们的实际电路包括RGB LED和伺服电机。
- en: With the servo motor connected to the Raspberry Pi Pico WH, it is time to test
    it with code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将伺服电机连接到Raspberry Pi Pico WH后，是时候用代码测试它了。
- en: Testing our servo motor
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试伺服电机
- en: 'To verify the functionality of our servo motor circuit, we’ll execute a test
    code that cycles the motor through a full 180-degree range, ending at its minimum
    position. Once the motor reaches this minimum point, we will attach the arrow
    to our device. We will write our code in MicroPython and use the Thonny IDE. Our
    code will be organized into two files: `servo.py`, dedicated to managing the servo
    motor’s control, and `main.py`, which will serve as the primary execution script.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证我们的伺服电机电路的功能，我们将执行一个测试代码，使电机在180度范围内循环，最终停在最小位置。一旦电机达到这个最小点，我们将箭头连接到我们的设备上。我们将用MicroPython编写代码，并使用Thonny
    IDE。我们的代码将组织成两个文件：`servo.py`，用于管理伺服电机的控制，以及`main.py`，它将作为主要的执行脚本。
- en: 'To test our servo motor with code, we do the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要用代码测试我们的伺服电机，我们执行以下操作：
- en: We connect our Raspberry Pi Pico WH to a USB port on our computer and launch
    Thonny. We may use our Raspberry Pi or another operating system for this.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将Raspberry Pi Pico WH连接到计算机上的USB端口，并启动Thonny。我们可以使用Raspberry Pi或其他操作系统来做这件事。
- en: We then activate the MicroPython environment on our Pico by selecting it from
    the bottom right-hand side of the screen.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过在屏幕的右下角选择它来激活Pico上的MicroPython环境。
- en: 'We will start with the code to control the servo motor. In a new tab in the
    editor section (hit *Ctrl* + *N*), we enter the following code:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始编写控制伺服电机的代码。在编辑器部分的新标签页（按*Ctrl* + *N*），我们输入以下代码：
- en: '[PRE13]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In our code, we start by importing the necessary modules: `Pin` and `PWM` from
    `machine` for hardware control and `utime` for time-related functions.'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们首先导入必要的模块：`machine`中的`Pin`和`PWM`用于硬件控制，以及`utime`用于时间相关函数。
- en: 'We then define the `Servo` class to control a servo motor:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义`Servo`类来控制伺服电机：
- en: 'The `__init__()` method initializes the servo on a specified GPIO pin as a
    `set_position()` method sets the servo to a specified angle:'
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`__init__()`方法将伺服电机初始化为指定GPIO引脚上的`set_position()`方法，将伺服电机设置为指定角度：'
- en: We invert the angle to allow for reversed movement of the servo.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们反转角度以允许伺服电机的反向运动。
- en: We then convert this reversed angle to a corresponding PWM duty cycle.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后将这个反转的角度转换为相应的PWM占空比。
- en: We use the `duty_u16()` method to set the duty cycle, scaling it to a 16-bit
    value for PWM control.
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`duty_u16()`方法设置占空比，将其缩放到16位值以进行PWM控制。
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择**文件** | **另存为...**。
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以选择将文件存储在哪里。为了将其保存在我们的Raspberry Pi Pico WH上，我们点击相应的按钮。
- en: We then give the file the name `servo.py` and click **Ok**.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后将文件命名为`servo.py`并点击**确定**。
- en: 'To create our `main.py` file, we open a new editor tab in the editor section
    (hit *Ctrl* + *N*) and enter the following code:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们的`main.py`文件，我们在编辑器部分打开一个新的编辑器标签（按*Ctrl* + *N*），并输入以下代码：
- en: '[PRE14]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In our code, we have the following:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: We start by importing the `Servo` class from our newly created `servo` module
    and `utime` for timing functions.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从新创建的`servo`模块导入`Servo`类，以及`utime`用于计时功能。
- en: We then create an instance of the `Servo` class that we call `servo`, using
    GPIO pin GP`14`.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后创建一个名为`servo`的`Servo`类实例，使用GPIO引脚GP`14`。
- en: Our code moves the servo to 0 degrees and waits for 1 second.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码将伺服电机移动到0度，并等待1秒钟。
- en: Our code then adjusts the servo to 90 degrees and waits for another 1 second.
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码然后将伺服电机调整到90度，并等待另外1秒钟。
- en: We set the servo to 180 degrees, followed by a 1-second pause.
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将伺服电机设置为180度，然后暂停1秒钟。
- en: Finally, our code returns the servo to the initial position of 0 degrees.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们的代码将伺服电机返回到初始位置0度。
- en: To run our code, we click on the green run button, hit *F5* on the keyboard
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色运行按钮，在键盘上按*F5*，或者在顶部点击**运行**菜单选项，然后选择**运行****当前脚本**。
- en: We should observe our servo motor go through a range of motions before stopping
    at the minimum position. One notable improvement with using the Raspberry Pi Pico
    WH over the Raspberry Pi 5 for connecting servo motors is the absence of servo
    motor jittering. The servo motor exhibits less jitter when used with the Raspberry
    Pi Pico WH compared to the Raspberry Pi due to the Pico’s direct, hardware-level
    PWM control, which ensures more precise and stable signal delivery to the servo.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该观察到伺服电机在停止在最小位置之前会经过一系列的运动。与使用Raspberry Pi 5连接伺服电机相比，使用Raspberry Pi Pico
    WH的一个显著改进是伺服电机的抖动消失。与Raspberry Pi相比，当使用Raspberry Pi Pico WH时，伺服电机抖动更少，这是因为Pico的直接硬件级PWM控制确保了向伺服电机提供更精确和稳定的信号。
- en: It is at this point where we place the arrow on the servo motor. We place the
    arrow such that it is pointing toward the gloves on our graphic. The arrow should
    fit snuggly; however, a bit of sanding may be required to get it to fit.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就在这个时候，我们在伺服电机上放置箭头。我们将箭头放置得使其指向我们的图形中的手套。箭头应该紧密贴合；然而，可能需要一点打磨才能使其贴合。
- en: '![Figure 10.16 – Placing the needle at the zero position](img/B21282_10_16.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图10.16 – 将指针放置在零位置](img/B21282_10_16.jpg)'
- en: Figure 10.16 – Placing the needle at the zero position
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.16 – 将指针放置在零位置
- en: Having successfully wired and tested the RGB LED and servo motor with our Raspberry
    Pi Pico WH, we’re now ready to develop the code that will control our weather
    indicator, utilizing data extracted from MQTT messages.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功连接并测试了RGB LED和伺服电机与我们的Raspberry Pi Pico WH之后，我们现在准备好开发控制我们的天气指示器的代码，利用从MQTT消息中提取的数据。
- en: Programming our weather indicator
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程我们的天气指示器
- en: The development of our weather indicator is streamlined, as the components’
    direct placement on the faceplate allows for immediate code implementation and
    testing, eliminating the need for breadboarding. This also reduces the chance
    of error as we do not need to configure the circuit a second time.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的天气指示器开发流程简化了，因为组件直接放置在面板上，允许立即进行代码实现和测试，消除了需要搭建面包板的必要性。这也减少了出错的机会，因为我们不需要再次配置电路。
- en: The software architecture of our application is shown in the following figure.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用软件架构如下所示。
- en: '![Figure 10.17 – Weather display code layout](img/B21282_10_17.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图10.17 – 天气显示代码布局](img/B21282_10_17.jpg)'
- en: Figure 10.17 – Weather display code layout
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.17 – 天气显示代码布局
- en: Our code is organized into three files, each containing a distinct class. The
    `main.py` file houses the `WeatherDisplay` class, which retrieves and parses MQTT
    messages from our CloudAMQP instance. Based on the temperature value in these
    messages, the `WeatherDisplay` class adjusts the servo position (and thus the
    weather indicator’s needle) using the `Servo` class. It also interprets humidity
    data to control the RGB LED’s color via the `Indicator` class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码组织成三个文件，每个文件包含一个不同的类。`main.py`文件包含`WeatherDisplay`类，该类从我们的CloudAMQP实例检索并解析MQTT消息。根据这些消息中的温度值，`WeatherDisplay`类使用`Servo`类调整伺服位置（从而调整天气指示器的指针），并使用`Indicator`类解释湿度数据以控制RGB
    LED的颜色。
- en: 'To create our weather indicator code, we do the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的天气指示器代码，我们执行以下操作：
- en: We connect our Raspberry Pi Pico WH from our weather indicator to a USB port
    on our computer and launch Thonny. We may use our Raspberry Pi or another operating
    system for this.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的Raspberry Pi Pico WH从天气指示器连接到电脑的USB端口，并启动Thonny。我们可以使用Raspberry Pi或其他操作系统来完成这个操作。
- en: We then activate the MicroPython environment on our Pico WH by selecting it
    from the bottom right-hand side of the screen.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从屏幕的右下角选择MicroPython环境来激活我们的Pico WH。
- en: 'We will start with the code to control the RGB LED. This code will introduce
    the `Indicator` class, designed to manage the RGB LED’s color transition from
    red to green to blue, reflecting changes in humidity levels. In a new tab in the
    editor section (hit *Ctrl* + *N*), we enter the following code:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从控制RGB LED的代码开始。这段代码将介绍`Indicator`类，该类旨在管理RGB LED的颜色过渡，从红色到绿色再到蓝色，反映湿度级别的变化。在编辑器部分的新的标签页（按*Ctrl*
    + *N*），我们输入以下代码：
- en: '[PRE15]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In our code, we have the following:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们有以下内容：
- en: We start by importing the `Pin` class from the `machine` module and `utime`
    for handling time-based functions.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从`machine`模块导入`Pin`类，以及`utime`来处理基于时间的函数。
- en: We define the `Indicator` class and initialize it with three attributes representing
    red, green, and blue LEDs, set as output pins on GP15, GP13, and GP12, respectively.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义`Indicator`类，并用代表红色、绿色和蓝色LED的三个属性初始化它，分别设置为GP15、GP13和GP12的输出引脚。
- en: The `set_color()` method controls the state of each color in the RGB LED based
    on the input parameters. In this method, for a common anode RGB LED, a binary
    `0` activates a color (turns it on), while a `1` deactivates it (turns it off).
    The method is used to selectively turn on either the red, green, or blue component
    of the LED.
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`set_color()`方法根据输入参数控制RGB LED中每个颜色的状态。在这个方法中，对于常见的阳极RGB LED，二进制的`0`激活一个颜色（打开它），而`1`则使其不活跃（关闭它）。该方法用于选择性地打开LED的红色、绿色或蓝色组件。'
- en: 'We then create the `set_indicator()` method:'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们创建`set_indicator()`方法：
- en: Our code turns off all LEDs initially.
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码最初关闭所有LED。
- en: Our code turns on the red LED for values ≤ 30, the green LED for values between
    30 and 50, and the blue LED for values > 50.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码在值≤30时打开红色LED，在值介于30和50之间时打开绿色LED，在值>50时打开蓝色LED。
- en: In our `flash_led()` method, we flash all three LEDs (white light) for a specified
    number of times (`times`), with each flash lasting 0.5 seconds with a 0.5-second
    interval where LEDs are off.
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`flash_led()`方法中，我们闪烁所有三个LED（白光）指定次数（`times`），每次闪烁持续0.5秒，LED关闭间隔也是0.5秒。
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择**文件** | **另存为...**。
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有选择存储文件位置的选择。要将文件保存在我们的Raspberry Pi Pico WH上，我们点击相应的按钮。
- en: We then give the file the name `indicator.py` and click **Ok**.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将文件命名为`indicator.py`并点击**确定**。
- en: 'The second class in our code is a new version of the servo class. To create
    this class, we open a new tab in the editor section (hit *Ctrl* + *N*), and enter
    the following code:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们代码中的第二个类是伺服类的新版本。为了创建这个类，我们在编辑器部分打开一个新的标签页（按*Ctrl* + *N*），并输入以下代码：
- en: '[PRE16]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In our code, we start by importing the `Pin` and `PWM` modules from `machine`,
    and `utime` for time-related functions.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们首先从`machine`导入`Pin`和`PWM`模块，以及`utime`用于时间相关函数。
- en: 'We then define the `Servo` class to control servo motors:'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义`Servo`类来控制伺服电机：
- en: In the constructor (`__init__()`), we initialize a PWM object on the specified
    pin.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数（`__init__()`）中，我们在指定的引脚上初始化一个PWM对象。
- en: We set the PWM frequency to 50 Hz, a standard frequency suitable for servo motors.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将PWM频率设置为50 Hz，这是一个适合伺服电机的标准频率。
- en: 'We then create a `set_position()` method that does the following:'
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个`set_position()`方法，执行以下操作：
- en: Converts the input value into an integer.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入值转换为整数。
- en: Maps the input range (0-40) to a servo angle range (0-180 degrees) in reverse
    to align with the installation of our servo motor.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将输入范围（0-40）映射到伺服角度范围（0-180度）的反向，以与我们的伺服电机安装对齐。
- en: Ensures the calculated angle is within the valid range (0-180 degrees).
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保计算出的角度在有效范围内（0-180度）。
- en: Converts the angle to a duty cycle suitable for the servo.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将角度转换为适合伺服电机的占空比。
- en: Sets the PWM duty cycle to position the servo.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置PWM占空比以定位伺服电机。
- en: To save the file, we click on **File** | **Save as...** from the drop-down menu.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存文件，我们从下拉菜单中选择**文件** | **另存为...**：
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以选择将文件存储的位置。为了将其保存在我们的Raspberry Pi Pico WH上，我们点击相应的按钮。
- en: We then give the file the name `servo.py` and click **Ok**.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将文件命名为`servo.py`并点击**确定**。
- en: The `WeatherDisplay` class, located in the main execution file, is responsible
    for subscribing to the `WeatherInfo` MQTT topic and handling the messages received.
    For its operation, the `micropython-umqtt.simple` library is necessary. To install
    this library, refer to the *Improving on our IoT button with the Raspberry Pi
    Pico W* section in [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 位于主执行文件中的`WeatherDisplay`类负责订阅`WeatherInfo` MQTT主题并处理接收到的消息。为了其操作，需要`micropython-umqtt.simple`库。要安装此库，请参阅[*第7章*](B21282_07.xhtml#_idTextAnchor107)中的*改进我们的Raspberry
    Pi Pico W物联网按钮*部分。
- en: 'To create the `WeatherDisplay` class, we begin by entering the import statements
    in a new tab in the editor section (hit *Ctrl* + *N*):'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建`WeatherDisplay`类，我们首先在编辑器部分的新标签中输入导入语句（按*Ctrl* + *N*）：
- en: '[PRE17]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In our code, we do the following:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的代码中，我们执行以下操作：
- en: We import the `network` module for Wi-Fi connectivity functions.
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`network`模块，用于Wi-Fi连接功能。
- en: We import the `utime` module for time-related functions.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入`utime`模块，用于时间相关函数。
- en: Our code imports `MQTTClient` from `umqtt.simple` to handle MQTT communications.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码从`umqtt.simple`导入`MQTTClient`来处理MQTT通信。
- en: We import our `Servo` class from our newly created local module for servo motor
    control.
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从新创建的本地模块中导入我们的`Servo`类，用于伺服电机控制。
- en: We then import our `Indicator` class from our newly created local module for
    RGB LED indicator control.
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们从新创建的本地模块中导入我们的`Indicator`类，用于RGB LED指示器控制。
- en: 'We then define the class name and initialization method where we define our
    Wi-Fi and MQTT parameters:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们定义类名和初始化方法，其中我们定义我们的Wi-Fi和MQTT参数：
- en: '[PRE18]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `connect_wifi()` method establishes a connection between the Raspberry
    Pi Pico WH and the local Wi-Fi network. It continuously attempts to connect until
    successful, and upon establishing a connection, it indicates success by flashing
    the RGB LED in white four times:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`connect_wifi()`方法在Raspberry Pi Pico WH和本地Wi-Fi网络之间建立连接。它持续尝试连接，直到成功，并在建立连接后，通过四次闪烁白色RGB
    LED来指示成功：'
- en: '[PRE19]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We use the `connect_mqtt()` method to connect to our CloudAMQP instance and
    subscribe to the `WeatherInfo` topic (as set by the `mqtt_topic`) variable and
    set our callback function to `on_message_received()`:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`connect_mqtt()`方法连接到我们的CloudAMQP实例，并订阅`WeatherInfo`主题（由`mqtt_topic`变量设置），并将我们的回调函数设置为`on_message_received()`：
- en: '[PRE20]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `on_message_received()` function processes received MQTT messages by parsing
    temperature and humidity data and then updating the servo position and RGB LED
    indicator accordingly:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`on_message_received()`函数通过解析温度和湿度数据，然后相应地更新伺服位置和RGB LED指示器来处理接收到的MQTT消息：'
- en: '[PRE21]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `parse_message()` function extracts and returns temperature and humidity
    values from a decoded MQTT message, handling any exceptions and returning `None`
    values if parsing fails:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`parse_message()`函数从解码的MQTT消息中提取并返回温度和湿度值，处理任何异常，如果解析失败则返回`None`值：'
- en: '[PRE22]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `run` method, the final method defined in the `WeatherDisplay` class, initiates
    the Wi-Fi connection, connects to the MQTT client, and continuously checks for
    MQTT messages, handling any errors encountered during message reception:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run`方法是`WeatherDisplay`类中定义的最后一个方法，它初始化Wi-Fi连接，连接到MQTT客户端，并持续检查MQTT消息，处理在消息接收过程中遇到的任何错误：'
- en: '[PRE23]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After writing the `WeatherDisplay` class code, we instantiate it and call its
    `run()` method, initiating the weather display functionality, which includes establishing
    Wi-Fi and MQTT connections and processing incoming messages:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编写`WeatherDisplay`类代码后，我们实例化它并调用其`run()`方法，启动天气显示功能，这包括建立Wi-Fi和MQTT连接以及处理传入的消息：
- en: '[PRE24]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To save our file, we click on **File** | **Save as...** from the drop-down menu.
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要保存我们的文件，我们从下拉菜单中选择**文件** | **另存为...**。
- en: We are given the option to choose where to store our file. To save it on our
    Raspberry Pi Pico WH, we click on the corresponding button.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以选择将文件存储在哪里。要将它保存在我们的Raspberry Pi Pico WH上，我们点击相应的按钮。
- en: We then give the file the name `main.py` and click **Ok**.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将文件命名为`main.py`并点击**确定**。
- en: To run our code, we click on the green run button, hit *F5* on the keyboard,
    or click on the **Run** menu option at the top, and then select **Run** **current
    script**.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行我们的代码，我们点击绿色的运行按钮，在键盘上按*F5*，或者点击顶部菜单的**运行**选项，然后选择**运行****当前脚本**。
- en: We should observe the RGB LED flashing four times after connection to our Wi-Fi
    network.
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到在连接到我们的Wi-Fi网络后，RGB LED闪烁四次。
- en: We should observe that the arrow moves to a position indicating the temperature
    coming from the temperature sensor on our LoRa sensory transmitter.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到箭头移动到了一个位置，这个位置指示着来自我们LoRa传感器发射器上的温度传感器所测量的温度。
- en: We should observe that the color of the RGB LED is either red, green, or blue,
    indicating the humidity level measured by our LoRa sensory transmitter.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到RGB LED的颜色要么是红色、绿色或蓝色，这表示由我们的LoRa传感器发射器测量的湿度水平。
- en: '![Figure 10.18 – The three devices that make up our IoT weather service, starting
    from the left, are the LoRa sensory transmitter (Chapter 9), the LoRa receiver/internet
    gateway (Chapter 9), and the analog-metered weather indicator](img/B21282_10_18.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图10.18 – 构成我们物联网天气服务的三个设备，从左到右分别是LoRa传感器发射器（第9章）、LoRa接收器/互联网网关（第9章）和模拟仪表的天气指示器](img/B21282_10_18.jpg)'
- en: Figure 10.18 – The three devices that make up our IoT weather service, starting
    from the left, are the LoRa sensory transmitter ([*Chapter 9*](B21282_09.xhtml#_idTextAnchor140)),
    the LoRa receiver/internet gateway ([*Chapter 9*](B21282_09.xhtml#_idTextAnchor140)),
    and the analog-metered weather indicator
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.18 – 构成我们物联网天气服务的三个设备，从左到右分别是LoRa传感器发射器（[*第9章*](B21282_09.xhtml#_idTextAnchor140)），LoRa接收器/互联网网关（[*第9章*](B21282_09.xhtml#_idTextAnchor140)），以及模拟仪表的天气指示器
- en: With the completion of our project, we’ve successfully built an IoT weather
    service and display console, combining real-time data collection with an interactive
    display. This system utilizes MQTT for data transmission, servo motors for representing
    data physically, and an RGB LED for visual alerts.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的完成之后，我们成功构建了一个物联网天气服务和显示控制台，结合了实时数据收集和交互式显示。该系统利用MQTT进行数据传输，伺服电机用于物理表示数据，以及RGB
    LED用于视觉警报。
- en: Exploring other IoT communication protocols
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索其他物联网通信协议
- en: LoRaWAN, operating on the same sub-gigahertz radio frequencies as LoRa, is an
    advanced protocol for wireless communication that enables long-range transmissions
    with low power consumption. This shared frequency band is a key feature that allows
    both LoRaWAN and LoRa to transmit data over several kilometers, which is especially
    beneficial in areas where traditional connectivity is scarce.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与LoRa使用相同的亚千兆赫兹无线电频率，LoRaWAN是一种先进的无线通信协议，它能够实现低功耗的长距离传输。这个共享的频率带是LoRaWAN和LoRa能够传输数公里数据的关键特性，这在传统连接稀缺的地区尤其有益。
- en: In the context of IoT applications such as weather monitoring, LoRaWAN offers
    significant advantages. For example, a network of sensors collecting environmental
    data such as temperature and humidity could transmit this information over long
    distances to a central gateway connected to the internet, leveraging LoRa’s long-range
    capabilities. This gateway then relays the data to a cloud server for processing
    and analysis.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在物联网应用（如天气监测）的背景下，LoRaWAN提供了显著的优势。例如，一个收集环境数据（如温度和湿度）的传感器网络可以通过长距离传输这些信息到一个连接到互联网的中心网关，利用LoRa的长距离能力。然后，这个网关将数据中继到云端服务器进行处理和分析。
- en: However, for our weather indicator project, using the full LoRaWAN setup would
    be considered overkill. Our project utilizes a simpler setup involving two Raspberry
    Pi Pico microcontrollers – one equipped with LoRa for data transmission (Raspberry
    Pi Pico) and the other with Wi-Fi capability (Raspberry Pi Pico W). This setup
    effectively demonstrates the capabilities of LoRa for short-range IoT communication,
    capitalizing on the same long-range, low-power characteristics of the LoRa frequencies,
    but without the complexity and infrastructure requirements of a complete LoRaWAN
    network.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们的气象指示器项目，使用完整的LoRaWAN设置会被视为过度。我们的项目采用了一个更简单的设置，涉及两个Raspberry Pi Pico微控制器——一个配备LoRa进行数据传输（Raspberry
    Pi Pico）和另一个具有Wi-Fi功能（Raspberry Pi Pico W）。这种设置有效地展示了LoRa在短程物联网通信中的能力，利用了LoRa频率相同的远程、低功耗特性，但无需完整的LoRaWAN网络复杂性和基础设施要求。
- en: Cellular services can also be used for IoT communication, offering extensive
    coverage and higher data transfer speeds. Cellular IoT devices, such as those
    using 4G LTE or 5G networks, can transmit larger amounts of data over long distances.
    This makes cellular services suitable for more data-intensive applications or
    those requiring real-time, high-speed communication.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 蜂窝服务也可以用于物联网通信，提供广泛的覆盖范围和更高的数据传输速度。使用4G LTE或5G网络的蜂窝物联网设备可以在长距离传输大量数据。这使得蜂窝服务适合需要更多数据密集型应用或需要实时、高速通信的应用。
- en: While cellular IoT offers broader coverage and higher data throughput, it often
    comes with higher power consumption and complexity compared to LoRa-based solutions.
    Thus, for small-scale or low-power projects such as our weather indicator, the
    simplicity and efficiency of using LoRa modules with Raspberry Pi Pico microcontrollers
    provide a more suitable and cost-effective solution.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然蜂窝物联网提供了更广泛的覆盖范围和更高的数据吞吐量，但与基于LoRa的解决方案相比，它通常具有更高的功耗和复杂性。因此，对于我们的气象指示器等小型或低功耗项目，使用带有Raspberry
    Pi Pico微控制器的LoRa模块的简单性和效率提供了更合适且成本效益更高的解决方案。
- en: '**Sigfox** is a global network operator providing dedicated cellular connectivity
    for IoT and **Machine-to-Machine** (**M2M**) communications. It uses a unique
    technology for wireless transmission that allows for long-range, low-power communication.
    Sigfox operates in the sub-gigahertz frequency band and is designed for small
    data payload transmissions, typically up to 12 bytes per message. This limited
    data capacity makes it ideal for devices that need to send small, infrequent bursts
    of data, such as sensors in smart meters, agricultural monitors, and asset tracking
    systems. Sigfox’s network architecture is distinguished by its simplicity, efficiency,
    and cost-effectiveness, making it a popular choice for applications where low-cost
    and low-power operations are critical.'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sigfox** 是一家全球网络运营商，为物联网和**机器对机器**（**M2M**）通信提供专用蜂窝连接。它使用独特的无线传输技术，允许长距离、低功耗通信。Sigfox在亚吉赫兹频段运行，旨在进行小数据负载传输，通常每条消息最多12字节。这种有限的数据容量使其非常适合需要发送小量、不频繁数据爆发设备，如智能电表的传感器、农业监控器和资产跟踪系统。Sigfox的网络架构以其简单性、效率和经济性而著称，使其成为低成本和低功耗操作关键应用的热门选择。'
- en: 'LoRaWAN, cellular networks, and Sigfox are among the leading communication
    protocols used in IoT applications. Each has its unique features and use cases.
    Here’s a comparative table outlining their advantages and disadvantages:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: LoRaWAN、蜂窝网络和Sigfox是物联网应用中使用的领先通信协议之一。每个都有其独特的特性和用例。以下是一个比较表格，概述了它们的优缺点：
- en: '| **Protocol** | **Advantages** | **Disadvantages** |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **协议** | **优点** | **缺点** |'
- en: '| --- | --- | --- |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| LoRaWAN |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| LoRaWAN |'
- en: Long range (up to 15 km)
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长距离（高达15公里）
- en: Low power consumption
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低功耗
- en: Good penetration in urban environments
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城市环境渗透良好
- en: Open protocol with a growing ecosystem
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放式协议，生态系统不断增长
- en: '|'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Lower data rates
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据速率较低
- en: Limited bandwidth and duty cycle restrictions
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽和占空比限制
- en: Requires gateway for internet connectivity
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要网关进行互联网连接
- en: '|'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Cellular (4G/5G) |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| 蜂窝（4G/5G） |'
- en: High data throughput
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高数据吞吐量
- en: Wide coverage and reliability
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 广泛覆盖和可靠性
- en: Supports real-time communication
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持实时通信
- en: Well-established infrastructure
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施完善
- en: '|'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Higher power consumption
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功耗更高
- en: Subscription costs
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅费用
- en: Potentially overpowered for simple tasks
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于简单任务可能过于强大
- en: '|'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Sigfox |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| Sigfox |'
- en: Ultra-low power consumption
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极低功耗
- en: Long-range capabilities
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长距离能力
- en: Simple to deploy and maintain
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署和维护简单
- en: Ideal for small, infrequent data transmissions
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于小型、不频繁的数据传输
- en: '|'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Very limited data payload (12 bytes/message)
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非常有限的数据负载（每条消息12字节）
- en: Limited to 140 messages per day
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每天限制为140条消息
- en: Proprietary technology with limited flexibility
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限灵活性的专有技术
- en: '|'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| LoRa with Wi-Fi microcontroller |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 带有Wi-Fi微控制器的LoRa |'
- en: Long range (up to 15 km for LoRa)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长距离（LoRa可达15公里）
- en: Low power consumption for LoRa transmissions
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LoRa传输的低功耗
- en: Cost-effective solution for small-scale projects
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小型项目成本效益高的解决方案
- en: Flexible and easy integration with existing Wi-Fi networks
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与现有Wi-Fi网络灵活且易于集成
- en: '|'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Limited to the range of the Wi-Fi network for internet connectivity
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅限于Wi-Fi网络的范围进行互联网连接
- en: Tied to a single microcontroller and may not be used for mobile applications
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单个微控制器绑定，可能不适用于移动应用
- en: Requires additional hardware (Wi-Fi microcontroller) for internet connectivity
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要额外的硬件（Wi-Fi微控制器）进行互联网连接
- en: May require a more complex setup and coding compared to using a single protocol
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与使用单个协议相比，可能需要更复杂的设置和编码
- en: '|'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 10.1 – Comparing IoT communication protocols
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – 比较物联网通信协议
- en: 'Each protocol serves different IoT scenarios:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协议服务于不同的物联网场景：
- en: '**LoRaWAN**: Ideal for applications requiring long-range communication and
    low power usage, such as agricultural sensors or smart city applications.'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoRaWAN**：适用于需要长距离通信和低功耗的应用，如农业传感器或智能城市应用。'
- en: '**Cellular networks**: Suitable for high-data, real-time applications such
    as video surveillance, automotive applications, or any scenario requiring broad
    geographic coverage.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蜂窝网络**：适用于高数据量、实时应用，如视频监控、汽车应用或任何需要广泛地理覆盖的场景。'
- en: '**Sigfox**: Excels in scenarios where devices only need to send small amounts
    of data over long distances, such as utility metering or asset tracking.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sigfox**：在设备只需在长距离发送少量数据的情况下表现优异，如公用事业计量或资产跟踪。'
- en: '**LoRa with Wi-Fi microcontroller**: Best for small-scale, localized IoT projects
    requiring the long-range capability of LoRa and the internet connectivity provided
    by Wi-Fi, such as home automation, local environmental monitoring, or DIY IoT
    projects.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有Wi-Fi微控制器的LoRa**：最适合需要LoRa的远程能力和Wi-Fi提供的互联网连接的小型、本地物联网项目，如智能家居、本地环境监测或DIY物联网项目。'
- en: For small-scale or low-power projects such as our weather indicator, using LoRa
    modules with Raspberry Pi Pico microcontrollers presents a more suitable and cost-effective
    solution than the options mentioned. LoRa with microcontrollers balances range,
    data handling, and power efficiency without the need for more complex infrastructure.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像我们的天气指示器这样的小型或低功耗项目，使用带有Raspberry Pi Pico微控制器的LoRa模块比提到的选项提供更合适且成本效益更高的解决方案。LoRa与微控制器平衡了范围、数据处理和能效，无需更复杂的基础设施。
- en: Summary
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we integrated LoRa-based data transmission with internet connectivity
    using MQTT. We modified our CircuitPython-based LoRa receiver’s code, allowing
    it to send sensory data to the CloudAMQP server, transforming it into an internet
    gateway. The weather indicator was upgraded, replacing the Raspberry Pi 5 and
    single-color LED with a Raspberry Pi Pico WH and an RGB LED, which displayed temperature
    and humidity data via MQTT messages.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过MQTT集成了基于LoRa的数据传输和互联网连接。我们修改了基于CircuitPython的LoRa接收器的代码，使其能够将传感器数据发送到CloudAMQP服务器，将其转变为互联网网关。天气指示器得到了升级，用Raspberry
    Pi Pico WH和RGB LED替换了Raspberry Pi 5和单色LED，通过MQTT消息显示温度和湿度数据。
- en: Additionally, we constructed a new split stand for the indicator, designed for
    easy assembly and improved stability. We concluded the chapter by examining IoT
    communication protocols such as LoRaWAN, cellular networks, and Sigfox, assessing
    their suitability for different IoT applications.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还为指示器构建了一个新的分体支架，设计用于易于组装和改进稳定性。我们通过检查物联网通信协议，如LoRaWAN、蜂窝网络和Sigfox，评估它们对不同物联网应用的适用性来结束本章。
- en: We engaged in a hands-on exploration of integrating LoRa with internet connectivity
    via MQTT, a practical demonstration of how disparate technologies can work together
    in IoT applications. By upgrading the weather indicator, we not only learned about
    iterative design and troubleshooting but also gained insights into the decision-making
    process involved in IoT projects, such as choosing the Raspberry Pi Pico WH over
    the Raspberry Pi 5 for controlling servo motors.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过MQTT将LoRa与互联网连接进行了实际操作探索，展示了不同技术如何在物联网应用中协同工作。通过升级天气指示器，我们不仅学习了迭代设计和故障排除，还深入了解到了物联网项目中涉及到的决策过程，例如选择树莓派Pico
    WH而不是树莓派5来控制伺服电机。
- en: This chapter marks the end of the book’s third part, focused on IoT communications
    with an emphasis on LoRa. In the next chapter, we transition to robotics, where
    we’ll start on our journey to build an internet-connected robot car.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 本章标志着本书第三部分的结束，该部分专注于物联网通信，特别强调LoRa。在下一章中，我们将转向机器人技术，开始我们的旅程，构建一辆互联网连接的机器人汽车。
- en: 'Part 4: Building an IoT Robot Car'
  id: totrans-393
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四部分：构建物联网机器人汽车
- en: In this part, we use all the knowledge we’ve gained from the previous chapters
    to build an IoT robot car that is controlled through the internet. This project
    will be the most advanced and demonstrate the ultimate power of IoT technology,
    controlling anything from anywhere.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们利用前几章所获得的所有知识来构建一辆可以通过互联网控制的物联网机器人汽车。这个项目将是最高级的，并展示了物联网技术的终极力量，从任何地方控制任何事物。
- en: 'This part has the following chapters:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B21282_11.xhtml#_idTextAnchor173), *Introducing ROS*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B21282_11.xhtml#_idTextAnchor173)，*介绍ROS*'
- en: '[*Chapter 12*](B21282_12.xhtml#_idTextAnchor195), *Creating an IoT Joystick*'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B21282_12.xhtml#_idTextAnchor195)，*创建物联网摇杆*'
- en: '[*Chapter 13*](B21282_13.xhtml#_idTextAnchor209), *Introducing Advanced Robotic
    Eyes for Security (A.R.E.S.)*'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B21282_13.xhtml#_idTextAnchor209)，*介绍用于安全的先进机器人眼睛（A.R.E.S.）*'
- en: '[*Chapter 14*](B21282_14.xhtml#_idTextAnchor228), *Adding Computer Vision to
    A.R.E.S.*'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B21282_14.xhtml#_idTextAnchor228)，*为A.R.E.S.添加计算机视觉*'
