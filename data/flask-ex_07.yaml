- en: Chapter 7. Adding Google Maps to Our Crime Map Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。将Google地图添加到我们的犯罪地图项目
- en: In the previous chapter, we set up a database and discussed how to add and remove
    data from it through Flask. With a web application that can do input and output
    with long-term storage, we now have the building blocks needed for nearly all
    web applications and are limited only by the power of our imagination.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们设置了一个数据库，并讨论了如何通过Flask向其中添加和删除数据。现在有了一个可以进行长期存储的输入和输出的网络应用程序，我们现在拥有了几乎所有网络应用程序所需的基本组件，只受我们想象力的限制。
- en: In this chapter, we will add more features than the text-only interface from
    the previous chapter; we'll add embedded Google Maps that will allow a user to
    view and select geographic coordinates in an intuitive way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将比上一章的纯文本界面添加更多功能；我们将添加嵌入式Google地图，允许用户以直观的方式查看和选择地理坐标。
- en: Google Maps is written in JavaScript, and we'll need to write some JavaScript
    code to adapt Google Maps to our needs. As always, we'll do a whirlwind tutorial
    for readers who haven't ever used JavaScript before, but if you're interested
    in solidifying your all-inclusive web application knowledge, now is a good time
    to quickly go through a couple of JavaScript-specific tutorials. If you've never
    seen any JavaScript code before, an easy introduction that is similar to the HTML
    and CSS tutorials we provided links to before can be found at [http://www.w3schools.com/js/default.asp](http://www.w3schools.com/js/default.asp).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Google Maps是用JavaScript编写的，我们需要编写一些JavaScript代码来适应我们的需求。与往常一样，我们将为以前从未使用过JavaScript的读者做一个快速教程，但如果您有兴趣巩固您的全面网络应用知识，现在是快速浏览一些特定于JavaScript的教程的好时机。如果您以前从未见过任何JavaScript代码，可以在[http://www.w3schools.com/js/default.asp](http://www.w3schools.com/js/default.asp)找到一个类似于我们之前提供链接的HTML和CSS教程的简单介绍。
- en: 'Arguably, the most important part of a crime map is the map itself. We''ll
    use the Google Maps API, which is simple and powerful for developers and intuitive
    for users. As a first step, we''ll just add a basic map that loads to an area
    and zoom level that we choose. Once we''ve seen to this, we''ll add functionality
    to allow for markers. Markers will serve two purposes for our map: first, we''ll
    display a marker on the map in the location of every crime we have saved in our
    database; second, when the user clicks on the map, it''ll add a new marker and
    allow the user to submit a new crime report (eventually by adding a description
    and date in form fields).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可以说，犯罪地图最重要的部分是地图本身。我们将使用Google Maps API，这对开发人员来说简单而强大，对用户来说直观。作为第一步，我们将只添加一个基本地图，加载到我们选择的区域和缩放级别。一旦我们完成了这一步，我们将添加功能以允许标记。标记对我们的地图有两个目的：首先，我们将在地图上显示我们在数据库中保存的每起犯罪的位置；其次，当用户点击地图时，它将添加一个新的标记，并允许用户提交新的犯罪报告（最终通过在表单字段中添加描述和日期）。
- en: However, first we need to be able to run our application locally again for development
    and debugging. Having linked it to the database, this is a bit tricky; so, we'll
    look at how to solve this common problem.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先我们需要能够再次在本地运行我们的应用程序进行开发和调试。将其链接到数据库，这有点棘手；因此，我们将看看如何解决这个常见问题。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Running a database application locally
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地运行数据库应用程序
- en: Adding an embedded Google Map widget to our application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将嵌入式Google地图小部件添加到我们的应用程序
- en: Adding an input form for new crimes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新犯罪添加一个输入表单
- en: Displaying existing crimes on our map
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在地图上显示现有的犯罪
- en: Running a database application locally
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在本地运行数据库应用程序
- en: 'In order to develop and debug locally, we need to be able to run the application.
    However, at the moment, this is not possible as MySQL is only installed on our
    VPS. There are three main options to develop our database application locally:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在本地开发和调试，我们需要能够运行应用程序。然而，目前这是不可能的，因为MySQL只安装在我们的VPS上。有三种主要选项来在本地开发我们的数据库应用程序：
- en: Connecting to the database on our VPS even when running Flask on our local machine
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在本地机器上运行Flask，也要连接到我们VPS上的数据库
- en: Installing MySQL on our local machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地机器上安装MySQL
- en: Creating a "mock" of our database in memory using Python
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python在内存中创建我们数据库的“模拟”
- en: While any could work, we'll go with the third option. Connecting to our production
    database would cause us to be affected by latency if we develop in a location
    far from our VPS, and this would also mean that we'd run test code against our
    production database, which is never a good idea. The second option would limit
    the portability of our development environment, increase setup time if we switch
    to a new development environment, and in the worst case scenario, use up a significant
    amount of local resources.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然任何一个都可以工作，但我们将选择第三个选项。连接到我们的生产数据库会导致我们受到延迟的影响，如果我们在离我们的VPS很远的地方开发，这也意味着我们将对我们的生产数据库运行测试代码，这绝不是一个好主意。第二个选项将限制我们开发环境的可移植性，增加切换到新开发环境时的设置时间，并且在最坏的情况下，会消耗大量的本地资源。
- en: Creating a mock of our database
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建我们数据库的模拟
- en: If you try to run the `crimemap.py` file locally, the first error you will see
    is `ImportError` because of the `dbconfig.py` file that we don't have. In the
    previous chapter, we created this file directly on our VPS and didn't check it
    into git as it contained sensitive database credentials. We'll create a local
    copy of `dbconfig.py`, which indicates that our application should use a mock
    database. We'll update the `dbconfig.py` file on our VPS to indicate that the
    real database should be used when the app is run from there. We'll do this with
    a simple Boolean flag.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试在本地运行`crimemap.py`文件，您将看到的第一个错误是`ImportError`，因为我们没有`dbconfig.py`文件。在上一章中，我们直接在我们的VPS上创建了这个文件，并且没有将其检入git，因为它包含敏感的数据库凭据。我们将创建`dbconfig.py`的本地副本，这表明我们的应用程序应该使用模拟数据库。我们将在我们的VPS上更新`dbconfig.py`文件，以指示在那里运行应用程序时应使用真实的数据库。我们将使用一个简单的布尔标志来实现这一点。
- en: Adding a test flag
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个测试标志
- en: 'In your local `crimemap` directory, create a new `dbconfig.py` file and add
    a single line of code:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的本地`crimemap`目录中，创建一个新的`dbconfig.py`文件，并添加一行代码：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, SSH into your VPS and add the flag to the production configuration as
    well; although, here, the value should be set to `False`, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，SSH进入您的VPS，并将标志添加到生产配置中；尽管这里，值应设置为`False`，如下所示：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following to the top of the file:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下内容：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, type *Ctrl* + *X* followed by *Y* to save and quit the file
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，键入*Ctrl* + *X*，然后*Y*保存并退出文件
- en: Now, exit the SSH session. This will solve `ImportError` (the `dbconfig.py`
    file now exists on our VPS and locally), and our application is now aware of whether
    it is running in test or production.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，退出SSH会话。这将解决`ImportError`（`dbconfig.py`文件现在存在于我们的VPS和本地），并且我们的应用程序现在知道它是在测试还是生产环境中运行。
- en: Writing the mock code
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写模拟代码
- en: 'Our flag doesn''t actually do anything yet though, and we don''t want to trigger
    all the exceptions when we test our app. Instead, we''ll write a "mock" of our
    database code (the code in the `dbhelper.py` file) that''ll return basic static
    data or `None`. When our application runs, it will be able to call database functions
    normally, but there will be no actual database. Instead, we''ll have a few lines
    of Python to emulate a very basic database. Create the `mockdbhelper.py` file
    in your `crimemap` directory and add the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的标志目前实际上并没有做任何事情，我们也不想在测试应用程序时触发所有的异常。相反，我们将编写我们数据库代码的“模拟”（`dbhelper.py`文件中的代码），它将返回基本静态数据或`None`。当我们的应用程序运行时，它将能够正常调用数据库函数，但实际上并没有数据库。相反，我们将有几行Python来模拟一个非常基本的数据库。在您的`crimemap`目录中创建`mockdbhelper.py`文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can note, the methods we used for our basic database application all
    exist but don''t do anything. The `get_all_inputs()` method returns an empty list,
    which we can still pass to our template. Now, we just need to tell our app to
    use this instead of the real `DBHelper` class if we are in a testing environment.
    Add the following code to the end of the imports section in `crimemap.py`, making
    sure to remove the existing `import` for `DBHelper`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所注意到的，我们用于基本数据库应用程序的方法都存在，但并没有做任何事情。`get_all_inputs()`方法返回一个空列表，我们仍然可以将其传递给我们的模板。现在，我们只需要告诉我们的应用程序在测试环境中使用这个方法，而不是真正的`DBHelper`类。在`crimemap.py`的导入部分的末尾添加以下代码，确保删除现有的`import`
    for `DBHelper`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use our test flag in `dbconfig` to specify whether or not to import the real
    `DBHelper` (which relies on having a connection to MySQL) or to import the mock
    `DBHelper` (which does not need database connection). If we import the mock helper,
    we can change the name so that the rest of the code can continue to run without
    conditional checks for the test flag.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dbconfig`中的测试标志来指定是否导入真正的`DBHelper`（它依赖于与MySQL的连接）或导入模拟的`DBHelper`（它不需要数据库连接）。如果我们导入模拟助手，我们可以更改名称，以便代码的其余部分可以继续运行而无需对测试标志进行条件检查。
- en: Validating our expectations
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证我们的期望
- en: 'Now, you should be able to run the code locally, just as before we added a
    database dependency. In your terminal, run:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够像以前添加数据库依赖项之前一样在本地运行代码。在您的终端中运行：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Then, visit `localhost:5000` in your browser to take a look at your app loading.
    Check the output of the terminal to make sure that no exceptions are triggered
    (as would be the case if you attempted to run the real `DBHelper` code instead
    of the mock ones we just made). Although our application no longer "works", we
    can at least run it to test our code that doesn't involve the database. Then,
    when we deploy to production, everything should work exactly as in our tests,
    but with a real database plugged in.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在浏览器中访问`localhost:5000`，查看您的应用程序加载情况。检查终端的输出，确保没有触发异常（如果您尝试运行真正的`DBHelper`代码而不是我们刚刚制作的模拟代码，就会触发异常）。尽管我们的应用程序不再“工作”，但至少我们可以运行它来测试不涉及数据库的代码。然后，当我们部署到生产环境时，一切应该与我们的测试一样正常工作，但实际上插入了一个真正的数据库。
- en: Adding an embedded Google Maps widget to our application
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将嵌入式谷歌地图小部件添加到我们的应用程序
- en: Now, we want to add a map view to our app instead of the basic input box. Google
    Maps allows you to create a map without registration, but you will only be able
    to make a limited number of API calls. If you create this project, publish a link
    on the Web, and it goes viral, you stand a chance of hitting the limit (which
    is currently 2,500 map loads per day). If you think this will be a limiting factor,
    you can register for the maps API and have the option of paying Google for more
    capacity. However, the free version will be more than adequate for development
    and even production if your app isn't too popular.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要在我们的应用程序中添加地图视图，而不是基本输入框。谷歌地图允许您创建地图而无需注册，但您只能进行有限次数的API调用。如果您创建了这个项目，在网上发布了一个链接，并且它变得火爆，您有可能达到限制（目前每天最多2500次地图加载）。如果您认为这将是一个限制因素，您可以注册地图API，并有选择向谷歌支付更多容量。然而，免费版本对于开发甚至生产来说都足够了，如果您的应用程序不太受欢迎的话。
- en: Adding the map to our template
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将地图添加到我们的模板
- en: 'We want to display a map on the main page of our app, so this means editing
    the code in the `home.html` file in our `templates` directory. Remove all the
    existing code and replace it with the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在我们应用程序的主页上显示地图，这意味着编辑我们`templates`目录中的`home.html`文件中的代码。删除所有现有代码，并用以下代码替换：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Introducing JavaScript
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入JavaScript
- en: Let's take a look at what happened here. The first line told our user's browser
    that we're using HTML5\. Lines 4 to 6 include the map resources we need in our
    page. Note that this is between `<script>` tags, indicating that it's JavaScript.
    In this particular case, we did not actually write the JavaScript code – we simply
    linked to where it's hosted on Google's servers. Think of this a bit as a Python
    `import` statement, except we don't even have to install the package locally;
    it's simply "imported" at runtime by your user's browser.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这里发生了什么。第一行告诉我们的用户浏览器，我们正在使用HTML5。第4到6行包括我们页面中需要的地图资源。请注意，这是在`<script>`标签之间，表示这是JavaScript。在这种特殊情况下，我们实际上并没有编写JavaScript代码
    - 我们只是链接到它托管在谷歌服务器上的位置。把它想象成Python的`import`语句，除了我们甚至不需要在本地安装包；它只是在您的用户浏览器运行时“导入”。
- en: Directly following this is our setup script to display a basic map. Again, this
    is between `<script>` tags to indicate that it's JavaScript instead of HTML. This
    time, we actually wrote the JavaScript code ourselves though. The syntax is similar
    to Java in terms of brackets, braces, and `for` loops. Apart from this and its
    name, there is little relation between it and Java.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 紧随其后的是我们的设置脚本，用于显示基本地图。同样，这是在`<script>`标签之间，以表明这是JavaScript而不是HTML。尽管在括号、大括号和`for`循环方面，它的语法与Java类似，但除此之外，它与Java之间几乎没有关系。
- en: 'The first line of our JavaScript code is a function definition; similar to
    Python''s "`def`" we use the `function` keyword to define a new function named
    `initialise()`. We declared a variable with `var mapOptions =` and assigned a
    new JavaScript object to this variable that looks similar to a Python dictionary.
    We define a location with a latitude-longitude tuple-like object, which we have
    access to because of Lines 4 to 6, and the object also contains a "`zoom`" level.
    These options describe our initial map: which area should be displayed and at
    what zoom level.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript代码的第一行是一个函数定义；类似于Python的“`def`”，我们使用`function`关键字来定义一个名为`initialise()`的新函数。我们声明了一个变量`var
    mapOptions =`，并将一个类似于Python字典的新JavaScript对象分配给了这个变量。我们使用经纬度元组的方式定义了一个位置，这是因为我们可以访问到第4到6行的内容，该对象还包含一个“`zoom`”级别。这些选项描述了我们的初始地图：应该显示哪个区域以及以什么缩放级别。
- en: Finally, we created a new variable, `map`, and initialized a Google map object,
    passing in the ID of an HTML element (which we'll explain in more detail in the
    following section) and the map options we just defined. We then reached the end
    of our JavaScript code, so we closed the `<script>` tag.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建了一个新变量`map`，并初始化了一个Google地图对象，传入了一个HTML元素的ID（我们将在下一节中详细解释）和我们刚刚定义的地图选项。然后我们到达了JavaScript代码的末尾，所以我们关闭了`<script>`标签。
- en: The body of our HTML code
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们的HTML代码的主体
- en: Although our `<body>` section is only a couple of lines, it has some subtleties.
    The first line opens the `<body>` tag and also defines the `onload` parameter.
    This parameter takes the name of a JavaScript function that will be called automatically
    when the page is loaded. Note that the function name ("`initialize`", in our case,
    as this is the function we just wrote and want to be run automatically in order
    to create our map) is enclosed in inverted commas. This might be counterintuitive
    if you think of Python, in which inverted commas are used mainly for string literals.
    Think of it as passing the function *name* to the body block but note the fact
    that we still use the open-close brackets as part of the name.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的`<body>`部分只有几行，但其中有一些微妙之处。第一行打开了`<body>`标签，并定义了`onload`参数。此参数接受一个JavaScript函数的名称，该函数将在页面加载时自动调用。请注意，函数名称（在我们的例子中是“`initialize`”）被引号括起来。如果你想到Python，这可能有些反直觉，因为引号主要用于字符串字面量。将其视为将函数*名称*传递给body块，但请注意我们仍然使用开闭括号作为名称的一部分。
- en: The next line creates a `<div>` element. Normally, `<div>` does nothing except
    enclose more HTML, but this doesn't mean that an empty `<div>` block, as we have
    here, is pointless. Note the ID, `map-canvas`, that we give our `<div>`. This
    matches the name in our JavaScript code; that is, the JavaScript function will
    look for an HTML element called `map-canvas` (using `document.getElementById()`)
    and transform this into Google Maps widget. Therefore, it makes sense to use a
    `<div>` element as we want an empty element for our JavaScript code to use.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行创建了一个`<div>`元素。通常，`<div>`除了包含更多的HTML之外什么也不做，但这并不意味着空的`<div>`块，就像我们这里有的一样，是毫无意义的。请注意我们给`<div>`的ID，`map-canvas`。这与我们JavaScript代码中的名称相匹配；也就是说，JavaScript函数将查找一个名为`map-canvas`的HTML元素（使用`document.getElementById()`）并将其转换为Google地图小部件。因此，使用`<div>`元素是有意义的，因为我们希望JavaScript代码使用一个空元素。
- en: Finally, our `<div>` element also includes some inline CSS. We can define the
    width and height of our map (which is a requirement of the Google Maps API) using
    CSS's `height` and `width` attributes. In this case, we defined the map to a constant
    `height` value of `500` pixels and a `width` value of `80%` of the page. The percentage
    for the width is useful as the scrolling functionality is often overloaded with
    the zoom functionality. That is, if the user wants to scroll down on our page
    using a touchpad or mouse wheel and his or her cursor is over the map, the map
    will zoom in instead of the page scrolling down. The 20 percent "blank" space
    on the right-hand side, therefore, provides the user with somewhere to move the
    mouse to while scrolling. Similarly, for touchscreens, the user would "*pan*"
    around the map while trying to scroll, but can use this space to put his or her
    finger while scrolling.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们的`<div>`元素还包括一些内联CSS。我们可以使用CSS的`height`和`width`属性来定义地图的宽度和高度（这是Google Maps
    API的要求）。在这种情况下，我们将地图的`height`值定义为常量`500`像素，`width`值定义为页面的`80%`。宽度的百分比很有用，因为滚动功能通常会与缩放功能重叠。也就是说，如果用户想要在触摸板或鼠标滚轮上向下滚动页面，并且光标位于地图上，地图将放大而不是页面向下滚动。因此，右侧的20%的“空白”空间为用户提供了滚动时移动鼠标的位置。同样，对于触摸屏，用户在尝试滚动时会在地图周围“平移”，但可以利用这个空间来放置手指。
- en: Testing and debugging
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试和调试
- en: We should now be able to run our web app locally and see the embedded Google
    Map. If your app is not already running, use your terminal to start it up again
    and navigate to `localhost:5000` in your browser. As we don't store the code for
    Google Maps locally, this needs to be fetched from Google's servers, so we need
    our local machine to be online for this to work (similar to fetching the data
    we needed for our Headlines application).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该能够在本地运行我们的Web应用程序并查看嵌入的Google地图。如果您的应用程序尚未运行，请使用终端再次启动它，并在浏览器中导航到`localhost:5000`。由于我们不在本地存储Google地图的代码，因此需要从Google的服务器获取，因此我们的本地机器需要在线才能正常工作（类似于获取我们Headlines应用程序所需的数据）。
- en: Debugging JavaScript code is a bit tricky as any errors won't be registered
    by Flask and will therefore not be seen in your app output. If your web page is
    blank or does anything unexpected, the first place to look is your browser's developer
    console. This is a developer's tool that can be found in all the major browsers,
    normally by pressing *Ctrl* + *Shift* + *C* and navigating to the "**Console**"
    tab in the window or sidebar that appears. Here, you'll note any JavaScript errors
    or warnings that your code has triggered, so this tool is invaluable in debugging
    a web application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 调试JavaScript代码有点棘手，因为任何错误都不会被Flask注册，因此不会在应用程序输出中看到。如果您的网页是空白的或执行任何意外操作，首先要查看的地方是您的浏览器开发者控制台。这是开发人员的工具，在所有主要浏览器中都可以找到，通常通过按下*Ctrl*
    + *Shift* + *C*并导航到出现的窗口或侧边栏中的“**控制台**”选项卡。在这里，您将注意到代码触发的任何JavaScript错误或警告，因此此工具在调试Web应用程序中非常宝贵。
- en: 'Although the console should report line numbers along with errors, it can sometimes
    be difficult to track down exactly what is going wrong. JavaScript is a dynamically
    typed language and is infamous for having some pretty quirky and counterintuitive
    behavior. If necessary, you can also add JavaScript lines between the `<script>`
    tags in your HTML that do nothing but log in to the developer tools console. To
    do this, use the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管控制台应该报告错误以及行号，但有时确切地追踪出错的地方可能有些困难。JavaScript是一种动态类型的语言，以其一些相当古怪和反直觉的行为而臭名昭著。如果有必要，您还可以在HTML的`<script>`标签之间添加JavaScript行，这些行除了在开发人员工具控制台中记录外什么也不做。要做到这一点，请使用以下内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is similar to a Python `print` statement, and you can pass variables and
    most objects to see a string representation of them logged to the output. Use
    the `+` symbol to concatenate. For example, if you have a variable named "`a`"
    and you want to see its value at a specific point in code, you could add the following
    line:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于Python的`print`语句，您可以传递变量和大多数对象，以查看它们的字符串表示形式记录到输出中。使用`+`符号进行连接。例如，如果您有一个名为“`a`”的变量，并且想要在代码的特定点看到它的值，可以添加以下行：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For a more sophisticated approach to debugging, take a look at the **Debugger**
    tab of the developer tools window (or its equivalent in your browser) and play
    around with setting breakpoints in JavaScript. The developer tools are generally
    a powerful suite of tools and their full functionality is unfortunately beyond
    the scope of this book. The following screenshot shows the Mozilla Firefox developer
    console with a breakpoint set just before the map loads:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的调试方法，请查看开发人员工具窗口（或浏览器中的等效窗口）中的**调试器**选项卡，并尝试在JavaScript中设置断点。开发人员工具通常是一套功能强大的工具，很遗憾，其全部功能超出了本书的范围。以下屏幕截图显示了Mozilla
    Firefox开发人员控制台，在加载地图之前设置了断点：
- en: '![Testing and debugging](img/B04312_07_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![测试和调试](img/B04312_07_01.jpg)'
- en: 'Once all the bugs are squashed (or straight-away if you are meticulous and
    lucky), you should see a page in your browser containing an embedded Google Map
    centered on **Grahamstown**, South Africa. Play around with the zoom level and
    coordinates set by the `mapOptions` variable in your JavaScript code to get the
    initial map of your choice. Clicking and holding on the map will allow "panning"
    or moving around the world. Zooming is done by scrolling with your middle mouse
    wheel, using your touchpad, or "pinch zooming" on touchscreen. The result should
    look similar to the following screenshot:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有错误都被消除（或者如果您非常细心和幸运，可以立即看到），您应该在浏览器中看到一个包含嵌入的Google地图的页面，该地图以**格雷厄姆斯敦**，南非为中心。通过使用JavaScript代码中的`mapOptions`变量设置的缩放级别和坐标来获取您选择的初始地图。单击并在地图上按住将允许“平移”或在世界各地移动。通过使用您的中间鼠标滚轮滚动，使用触摸板或在触摸屏上进行“捏合缩放”来进行缩放。结果应该与以下屏幕截图类似：
- en: '![Testing and debugging](img/B04312_07_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![测试和调试](img/B04312_07_02.jpg)'
- en: Let's now move on to making our map more interactive and useful.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续使我们的地图更加交互和有用。
- en: Making our map interactive
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使我们的地图交互起来
- en: The first functionality we'll add to our app will allow the user to place a
    marker on the map. This will eventually allow the user to add a crime report by
    indicating where the crime took place, thus adding to our crowd-sourced database
    of crimes. We'll implement the marker functionality in JavaScript, as well, using
    a "listener".
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的应用程序添加的第一个功能允许用户在地图上放置一个标记。这将最终允许用户通过指示犯罪发生地点来添加犯罪报告，从而增加我们的众包犯罪数据库。我们还将在JavaScript中实现标记功能，使用“侦听器”。
- en: Adding markers
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加标记
- en: JavaScript is *event-driven*. Actions such as a mouse move or mouse click are
    events, and we can react to these events by setting up an event listener. The
    listener simply runs in the background, waiting for a specific event, and then
    triggers a specified action if it detects the event. We'll set up a listener for
    a mouse click, and if detected, we'll place a map marker at the location of the
    mouse when clicked.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是*事件驱动*的。诸如鼠标移动或鼠标单击之类的操作都是事件，我们可以通过设置事件侦听器来对这些事件做出反应。侦听器只是在后台运行，等待特定事件，然后在检测到事件时触发指定的操作。我们将为鼠标单击设置一个侦听器，如果检测到，我们将在单击时在鼠标位置放置一个地图标记。
- en: Using the Google Map API, this can be achieved in a few lines of code. First,
    we'll make our `map` variable global. Then, we'll create a `placeMarker()` function
    that will reference our `map` variable and place a marker on it when called. In
    our existing `initalise()` function, we'll add a click listener that will call
    the `placeMarker()` function when triggered.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Google地图API，可以用几行代码实现这一点。首先，我们将使我们的`map`变量全局化。然后，我们将创建一个`placeMarker()`函数，该函数将引用我们的`map`变量，并在调用时在其上放置一个标记。在我们现有的`initalise()`函数中，我们将添加一个点击侦听器，当触发时将调用`placeMarker()`函数。
- en: 'The full JavaScript code can be seen here with the modified lines highlighted:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的JavaScript代码可以在此处查看，修改的行已突出显示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note specifically the change from `var map = new google.maps.Map` to `map =
    new google.maps.Map`. We removed the `var` declaration, which means that we assigned
    our new map to our global `map` variable instead of creating a new local variable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意从`var map = new google.maps.Map`到`map = new google.maps.Map`的更改。我们删除了`var`声明，这意味着我们将新的地图分配给我们的全局`map`变量，而不是创建一个新的局部变量。
- en: The next line makes a call to `addListener()`, which might look a little odd.
    The `addListener()` function takes a `map`, `event`, and `function` to be called
    when the listener is triggered. As in Python, JavaScript has first-class functions,
    which means that we can pass functions as arguments to other functions. Unlike
    Python, we don't need to use the `lambda` keyword to create an anonymous function;
    we can simply declare the function we want to pass in place of the argument. In
    this case, we created an anonymous function that takes an `event` argument and
    in turn calls our `placeMarker()` function, passing it the `latLng` property of
    `event`. In our case, `event` is the mouse click that is picked up by the listener,
    and the `latLng` property is the location of the mouse click.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行调用了`addListener()`，这可能看起来有点奇怪。`addListener()`函数接受一个`map`、`event`和`function`，当监听器被触发时调用。与Python一样，JavaScript有一流的函数，这意味着我们可以将函数作为参数传递给其他函数。与Python不同的是，我们不需要使用`lambda`关键字来创建匿名函数；我们可以简单地声明我们想要传递的函数，而不是参数。在这种情况下，我们创建了一个匿名函数，它接受一个`event`参数，然后调用我们的`placeMarker()`函数，将`event`的`latLng`属性传递给它。在我们的情况下，`event`是监听器捕获的鼠标点击，`latLng`属性是鼠标点击的位置。
- en: In our `placeMarker()` function, we accepted a location and created a new `Marker`
    object, placing it at the passed-in location on our map (this is why we made the
    map global; now we can refer to it in this new function).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`placeMarker()`函数中，我们接受一个位置并创建一个新的`Marker`对象，将其放置在我们地图上传入的位置（这就是为什么我们将地图设为全局的；现在我们可以在这个新函数中引用它）。
- en: 'In summary, when the page loads, we will add a listener that hangs around in
    the background, waiting for a click. When a click is detected, the listener makes
    a call to `placeMarker()`, passing in the coordinates of the click it detected.
    The `placeMarker()` function then adds a marker at the specified coordinates,
    meaning that the user sees a marker appear on the map as he or she clicks on the
    map. Give it a try, using the console and debugger in your browser, as we did
    before, if things don''t go as expected. You should see a new marker placed on
    the map for every click and be able to generate maps that look similar to the
    following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，当页面加载时，我们将添加一个监听器，它会在后台等待点击。当检测到点击时，监听器会调用`placeMarker()`，传入它检测到的点击的坐标。`placeMarker()`函数然后在指定的坐标处添加一个标记，这意味着用户在点击地图时会看到一个标记出现在地图上。如果出现意外情况，请像之前一样在浏览器中使用控制台和调试器进行尝试。您应该看到每次点击地图都会放置一个新的标记，并且能够生成类似于以下截图的地图：
- en: '![Adding markers](img/B04312_07_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![添加标记](img/B04312_07_03.jpg)'
- en: Using a single marker
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用单个标记
- en: Creating a new marker for every click is not ideal. We actually want the user
    to be able to move the marker with each click instead of creating a new one. Adding
    more than one crime at a time would be overcomplicated and not overly useful.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为每次点击创建一个新标记并不理想。实际上，我们希望用户能够在每次点击时移动标记，而不是创建一个新的标记。一次添加多个犯罪将会变得过于复杂，也不是特别有用。
- en: To achieve this, create another global `marker` variable under the existing
    global `map` variable. Then, add a simple condition to the `placeMarker()` function
    that creates a new marker only if there isn't one already and moves the location
    of the existing one otherwise.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，在现有的全局`map`变量下创建另一个全局`marker`变量。然后，在`placeMarker()`函数中添加一个简单的条件，只有在没有标记时才创建一个新的标记，否则移动现有标记的位置。
- en: 'The full code, again with the modified lines highlighted, is shown as follows.
    Again, note that we removed `var` from the line where we created a new `marker`
    variable, thus using the global variable instead of creating a local one. With
    these changes, each click on the map should move the marker instead of creating
    a new one. Try it out:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码，再次突出显示修改的行，如下所示。再次注意，我们从创建新的`marker`变量的行中删除了`var`，因此使用全局变量而不是创建一个局部变量。有了这些改变，每次点击地图时都应该移动标记，而不是创建一个新的标记。试一试：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Adding an input form for new crimes
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为新犯罪添加输入表单
- en: We want the user to be able to specify more information than simply a location.
    The next step is to create a form that the user can use to add date, category,
    and description data to a crime submission. Each of these pieces of information
    will be stored in the database columns we created in the previous chapter. Creating
    web forms is a common enough task that there are many frameworks and plugins to
    help automate as much of the process as possible, as most forms need a pretty
    frontend, which includes error messages if the user puts in unexpected input,
    as well as backend logic to process the data and do a more thorough validation
    to prevent malformed or incorrect data from polluting the database.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够指定比简单位置更多的信息。下一步是创建一个表单，用户可以使用该表单向犯罪提交添加日期、类别和描述数据。这些信息中的每一个都将存储在我们在上一章中创建的数据库列中。创建网络表单是一个很常见的任务，有许多框架和插件可以帮助尽可能自动化这个过程，因为大多数表单都需要一个漂亮的前端，其中包括错误消息，如果用户输入了意外的输入，以及后端逻辑来处理数据并进行更彻底的验证，以防止格式不正确或不正确的数据污染数据库。
- en: However, in the spirit of learning, we'll now create the backend and frontend
    of a web form from scratch. In our next project, we'll take a look at how to do
    something similar using various tools to make the process less laborious.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了学习的目的，我们现在将从头开始创建一个网络表单的后端和前端。在我们的下一个项目中，我们将看看如何使用各种工具来做类似的事情，以使这个过程不那么费力。
- en: 'Our goal is to have a number of input fields to the right of our map, which
    allows the user to specify details about a witnessed or experienced crime and
    submit it to be included with our existing data. The form should have the following
    inputs:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是在地图的右侧有一些输入字段，允许用户指定关于目击或经历的犯罪的详细信息，并将其提交以包含在我们现有的数据中。表单应该有以下输入：
- en: '**Category**: A drop-down menu that allows the user to select which category
    the crime falls into'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类别**：一个下拉菜单，允许用户选择犯罪属于哪个类别'
- en: '**Date**: A calendar that allows the user to easily enter the date and time
    of the crime'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日期**：一个允许用户轻松输入犯罪日期和时间的日历'
- en: '**Description**: A larger text box that allows the user to describe the crime
    in free-form text'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：一个更大的文本框，允许用户以自由形式描述犯罪'
- en: '**Latitude and Longitude**: Text boxes that are automatically populated based
    on the location selected using the marker'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纬度和经度**：根据使用标记选择的位置自动填充的文本框'
- en: After filling the preceding fields, the user should be able to click on a **Submit**
    button and view the crime he or she just submitted appear on the map.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在填写前面的字段后，用户应该能够单击**提交**按钮，并查看刚刚提交的犯罪在地图上显示出来。
- en: The HTML code for the form
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表单的HTML代码
- en: The HTML code needed for our form is very similar to the forms created in our
    earlier project, but it has some new elements as well, namely `<textarea>` and
    `<label>` and an input with `type= "date"`. The `<textarea>` element is very similar
    to the standard text fields we noted before but appears as a larger square to
    encourage the user to enter more text. Label elements can define a `for` attribute
    to specify what we are labeling. The text between the opening and closing `label`
    tags is then shown close to the element to be labeled.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们表单所需的HTML代码与我们之前项目中创建的表单非常相似，但也有一些新元素，即`<textarea>`和`<label>`以及一个带有`type="date"`的输入。`<textarea>`元素与我们之前注意到的标准文本字段非常相似，但显示为更大的正方形，以鼓励用户输入更多文本。标签元素可以定义一个`for`属性来指定我们要标记的内容。在开放和关闭的`label`标签之间的文本将显示在要标记的元素附近。
- en: This is useful for our form as we can prompt the user about what data to enter
    in each field. The date field will provide a nice calendar drop-down menu to select
    a date. Unfortunately, it's a fairly recent addition to HTML and is not supported
    in all browsers. In unsupported browsers (including Firefox), this will be identical
    to a text input, so we'll look at how to handle dates input by the user at the
    end of this chapter.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的表单很有用，因为我们可以提示用户在每个字段中输入什么数据。日期字段将提供一个漂亮的日历下拉菜单来选择日期。不幸的是，这是HTML的一个相当新的添加，不是所有浏览器都支持。在不支持的浏览器（包括Firefox）中，这将与文本输入相同，因此我们将在本章末尾讨论如何处理用户输入的日期。
- en: 'Also, note that we put the form inside a `<div>` element to make it easier
    to style and position on the page (we''ll also do this later). The full `<body>`
    element of our HTML page now looks as follows (note that we added a heading and
    paragraph above the map, while the form is added below the map). Take a look at
    the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，我们将表单放在一个`<div>`元素中，以便更容易地在页面上进行样式和定位（我们稍后也会这样做）。我们的HTML页面的完整`<body>`元素现在如下所示（请注意，我们在地图上方添加了一个标题和段落，而表单是在地图下方添加的）。看一下以下代码：
- en: '[PRE11]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Refresh your page to see the form below the map. You''ll notice that it looks
    pretty terrible with different-sized fields and a horizontal layout, as in the
    following screenshot:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面以查看地图下方的表单。您会注意到它看起来非常糟糕，字段大小不同，布局水平，如下面的截图所示：
- en: '![The HTML code for the form](img/B04312_07_04.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![表单的HTML代码](img/B04312_07_04.jpg)'
- en: Let's add some CSS to fix this.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一些CSS来修复这个问题。
- en: Adding external CSS to our web application
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将外部CSS添加到我们的Web应用程序
- en: To make the form appear to the right of our map, we'll use CSS. We already have
    some CSS for our map, and we could add more CSS in a similar way. However, refer
    to our discussion of inline, internal, and external CSS from [Chapter 5](ch05.html
    "Chapter 5. Improving the User Experience of Our Headlines Project"), *Improving
    the User Experience of Our Headlines Project*, in the *Adding CSS to our Headlines
    application* section, and remember that having all CSS in a separate file is best
    practice. Therefore, we'll create a `style.css` file and consider how to link
    it to our Flask app.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使表单出现在地图的右侧，我们将使用CSS。我们已经为我们的地图添加了一些CSS，我们可以以类似的方式添加更多的CSS。但是，请参考我们在[第5章](ch05.html
    "第5章。改进我们的头条项目的用户体验")中对内联、内部和外部CSS的讨论，*改进我们的头条项目的用户体验*，在*向我们的头条应用程序添加CSS*部分，记住将所有CSS放在一个单独的文件中是最佳实践。因此，我们将创建一个“style.css”文件，并考虑如何将其链接到我们的Flask应用程序。
- en: Creating the CSS file in our directory structure
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的目录结构中创建CSS文件
- en: 'By default in Flask, our static files should be kept in a directory called
    `static`. We''ll want to keep various kinds of files in here eventually, such
    as images, JavaScript, and CSS, so we''ll create a subdirectory called `CSS` and
    create our `style.css` file inside this. Navigate to your project directory in
    your terminal and run the following to add this directory structure and file to
    our project:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flask中，默认情况下，我们的静态文件应该保存在一个名为“static”的目录中。我们最终会想在这里保存各种文件，如图像、JavaScript和CSS，因此我们将创建一个名为“CSS”的子目录，并在其中创建我们的“style.css”文件。在终端中导航到您的项目目录，并运行以下命令将此目录结构和文件添加到我们的项目中：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Adding CSS code
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加CSS代码
- en: 'Insert the following CSS code into this new file:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下CSS代码插入到这个新文件中：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'You''ll probably notice the similarities with the CSS code that we used for
    our Headlines project. However, there are still some important points to note:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到我们在头条项目中使用的CSS代码的相似之处。但是，仍然有一些重要的要点需要注意：
- en: We defined the `width` and `height` of any element with the ID of `map-canvas`
    here (in the second-last block), so we can remove the inline style from our `body.html`
    file.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在这里定义了具有ID“map-canvas”的任何元素的“宽度”和“高度”（在倒数第二个块中），因此我们可以从我们的“body.html”文件中删除内联样式。
- en: We used CSS's float functionality to display our form to the right of our map
    instead of below it. The map takes up `70%` of the `width` of the page, and the
    form takes up `25%` (with the last 5% left so that the map and form have some
    space between them. Our map floats to the left of the page, while the form floats
    to the right. Because they take up less than 100% of the width combined, they'll
    be displayed side by side in the browser.)
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用了CSS的浮动功能，将我们的表单显示在地图的右侧而不是下方。地图占页面宽度的`70%`，表单占`25%`（最后的5%留下了地图和表单之间的一些空间。我们的地图浮动到页面的左侧，而表单浮动到右侧。因为它们的宽度加起来不到100%，所以它们将在浏览器中并排显示。
- en: Configuring Flask to use CSS
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置Flask使用CSS
- en: 'Normally in HTML pages, we can link to external CSS files simply by giving
    a relative path to the stylesheet. As we''re using Flask, we need to configure
    our application to return the CSS file as a static one. By default, Flask serves
    files from a directory named `static` in the route of the project, which is why
    it''s important to place the CSS file here, as described earlier. Flask can generate
    a URL for the CSS file we need to link to using the `url_for` function. In the
    `home.html` template, add the following line to the top of the `<head>` section:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在HTML页面中，我们可以通过给出样式表的相对路径来链接到外部CSS文件。由于我们使用的是Flask，我们需要配置我们的应用程序将CSS文件作为静态文件返回。默认情况下，Flask从项目根目录中名为`static`的目录中提供文件，这就是为什么将CSS文件放在这里很重要，就像之前描述的那样。Flask可以使用`url_for`函数为我们需要链接到的CSS文件生成URL。在`home.html`模板中，在`<head>`部分的顶部添加以下行：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a link between our HTML and CSS. We used attributes to describe
    the link as being to a `text/css` file and that it is a stylesheet. We then gave
    its location with `href` using the `url_for()` function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了我们的HTML和CSS之间的链接。我们使用属性来描述链接为`text/css`文件，并且它是一个样式表。然后使用`url_for()`函数给出了它的位置。
- en: 'We also need to add a line of JavaScript code to populate the location input
    automatically whenever the marker on the map is created or moved. This is achieved
    by adding the lines highlighted in the following to the `placeMarker()` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一行JavaScript代码，以便在地图上的标记被创建或移动时自动填充位置输入。通过在`placeMarker()`函数中添加以下突出显示的行来实现这一点：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These lines simply find the latitude and longitude boxes (identified by their
    `id` attribute) and insert the location used to place the marker. When we `POST`
    the form to the server, we'll be able to read these values on the backend.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行只是找到纬度和经度框（通过它们的`id`属性标识）并插入用于放置标记的位置。当我们将表单`POST`到服务器时，我们将能够在后端读取这些值。
- en: 'Finally, remove the inline CSS that we added earlier as this functionality
    is now the responsibility of our external stylesheet. Take a look at the following
    line in the `home.html` file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除我们之前添加的内联CSS，因为这个功能现在是我们外部样式表的责任。查看`home.html`文件中的以下行：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding line can be modified to instead be as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的行可以修改为以下内容：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Viewing the result
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看结果
- en: Reload the page in your browser to view the result. Remember that CSS and JavaScript
    are often cached by your browser, so hit *Ctrl* + *R* for a hard refresh if you
    see unexpected behavior. If *Ctrl* + *R* does not work, try hitting *Ctrl* + *Shift*
    + *Delete* and select the **cache** option in the browser's menu and clear the
    browsing data before refreshing again.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载浏览器中的页面以查看结果。请记住，浏览器通常会缓存CSS和JavaScript，因此如果看到意外行为，请按*Ctrl* + *R*进行强制刷新。如果*Ctrl*
    + *R*不起作用，请尝试按*Ctrl* + *Shift* + *Delete*，然后在浏览器菜单中选择**缓存**选项并清除浏览数据，然后再次刷新。
- en: 'The styled map with the form should look similar to the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 带有表单的样式地图应该类似于以下屏幕截图：
- en: '![Viewing the result](img/B04312_07_05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![查看结果](img/B04312_07_05.jpg)'
- en: Note that clicking on the map now populates the latitude and longitude boxes
    with the coordinates of the marker.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在单击地图会用标记的坐标填充纬度和经度框。
- en: Publishing the result
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发布结果
- en: We have the form, the map, and some CSS, so now is a good time to push the result
    to our VPS so that we can see what it looks like on different devices or ask people
    for feedback.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有表单、地图和一些CSS，现在是将结果推送到我们的VPS的好时机，这样我们就可以看到它在不同设备上的外观，或者向人们征求反馈意见。
- en: 'To push our changes, fire up a terminal, change the directory to the root folder,
    and run the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送我们的更改，打开终端，将目录更改为根文件夹，然后运行以下命令：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, SSH into your VPS and pull the new code by running the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过运行以下命令，SSH进入您的VPS并拉取新代码：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Visit the IP of your VPS to check whether the page worked and looks right. As
    usual, look at `/var/log/apache2/error.log` if anything unexpected happens.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 访问您的VPS的IP，检查页面是否正常工作并且外观正确。如果发生意外情况，请查看`/var/log/apache2/error.log`。
- en: Linking the form to the backend
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将表单链接到后端
- en: It's all very well to have a pretty form to accept user input, but at the moment,
    we're just throwing away any submitted data. Instead of processing input in real
    time, as we did in our headlines application, we want to capture the input and
    store it in our database. Let's take a look at how to achieve this.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有漂亮的表单来接受用户输入是很好的，但目前，我们只是丢弃任何提交的数据。与我们在头条应用程序中实时处理输入不同，我们希望捕获输入并将其存储在我们的数据库中。让我们看看如何实现这一点。
- en: Setting up the URL to collect POST data
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置URL以收集POST数据
- en: 'As in our Headlines project, the first step is to set up a URL on our server
    to which the data can be posted. In the HTML form we created, we set this URL
    to be `/submitcrime`, so let''s create this as a route in our Flask app. In `crimemap.py`,
    add the following function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们的头条项目一样，第一步是在我们的服务器上设置一个URL，以便可以将数据发布到该URL。在我们创建的HTML表单中，我们将此URL设置为`/submitcrime`，因此让我们在Flask应用程序中创建这个路由。在`crimemap.py`中，添加以下函数：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we simply grabbed all the data the user entered and passed it to our database
    helper. We used the `DB.add_crime()` function in the preceding code, but this
    does not yet exist. We need it to really add the new data to our database for
    our real `DBHelper`, and we also need a stub of this function for `MockDBHelper`.
    Let's take a look at how to add these.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是获取用户输入的所有数据并将其传递给我们的数据库助手。在前面的代码中，我们使用了`DB.add_crime()`函数，但这个函数还不存在。我们需要它来真正将新数据添加到我们的数据库中，对于我们真正的`DBHelper`，我们还需要这个函数的存根。让我们看看如何添加这些。
- en: Adding the database methods
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加数据库方法
- en: 'In `MockDBHelper.py`, the function is simple. It needs to take the same arguments
    and then not do anything. Add the following to `mockdbhelper.py`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MockDBHelper.py`中，这个函数很简单。它需要接受相同的参数，然后不执行任何操作。将以下内容添加到`mockdbhelper.py`中：
- en: '[PRE21]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The real function needs to be added to `dbhelper.py` and is a bit more involved.
    It looks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 真实的功能需要添加到`dbhelper.py`中，而且涉及的内容更多。它看起来像这样：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is nothing we haven't seen before here. We used placeholder values and
    only populated them within the `cursor.execute()` statement to avoid SQL injection,
    and we closed our connection in a `finally` block to make sure it always happens.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们没有看到任何新东西。我们使用了占位符值，并且只在`cursor.execute()`语句中填充它们，以避免SQL注入，并且我们在`finally`块中关闭了连接，以确保它总是发生。
- en: Testing the code on the server
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在服务器上测试代码
- en: 'Here is another good point to commit all the changes to the repository and
    do a quick check for bugs. Once the new code runs on your VPS, try adding a crime
    to the database by visiting your IP address and filling in the form we made. On
    your VPS, you can check to make sure the data was successfully added by running
    the following commands. Note that this fires up a live SQL shell—a direct connection
    to your database that should be used with care. A mistyped command can result
    in data being irretrievably lost or corrupted. Run the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是提交所有更改到存储库并快速检查错误的好时机。一旦新代码在您的VPS上运行，尝试通过访问您的IP地址并填写我们制作的表单向数据库添加犯罪记录。在您的VPS上，您可以通过运行以下命令来检查数据是否成功添加。请注意，这将启动一个实时的SQL
    shell——直接连接到您的数据库，应谨慎使用。输入错误的命令可能导致数据不可挽回地丢失或损坏。运行以下命令：
- en: '[PRE23]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You''ll see that MySQL prints a nice ASCII table that shows a summary of the
    data in your database, as in the following screenshot (in this case, all the records
    and columns from the `crimes` table of the `crimemap` database are shown):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到MySQL打印了一个漂亮的ASCII表，显示了数据库中数据的摘要，如下面的屏幕截图所示（在这种情况下，显示了`crimemap`数据库的`crimes`表中的所有记录和列）：
- en: '![Testing the code on the server](img/B04312_07_06.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![在服务器上测试代码](img/B04312_07_06.jpg)'
- en: Displaying existing crimes on our map
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在地图上显示现有的犯罪记录
- en: Now, the user can add new crimes to our crime database, but we want the map
    to display crimes that are already added as well. To achieve this, whenever the
    page is loaded, our app needs to make a call to the database to get the latest
    crime data. We then need to pass this data to our template file, loop through
    each crime, and place a marker in the correct place on the map.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，用户可以向我们的犯罪数据库添加新的犯罪记录，但我们也希望地图显示已经添加的犯罪记录。为了实现这一点，每当页面加载时，我们的应用程序需要调用数据库以获取最新的犯罪数据。然后，我们需要将这些数据传递给我们的模板文件，循环遍历每个犯罪记录，并在地图上的正确位置放置一个标记。
- en: Now, our data is stored in a MySQL database. We will access it using Python
    on the server side, and we want to display it using JavaScript on the client side;
    so, we'll need to spend a bit of time on converting our data to the appropriate
    format. When we access the data through our Python `pymysql` driver, we will receive
    it as a tuple. To display the data using JavaScript, we want it in JSON. JSON,
    you might remember from our Headlines project, is JavaScript Object Notation,
    a structured data format that JavaScript can easily read and manipulate. As with
    our previous project, we'll take advantage of the fact that Python dictionaries
    are very similar to JSON. We'll create a Python dictionary from the tuple we get
    out of our database, convert this to a JSON string, and pass it to our template,
    which will use JavaScript to display the data as markers on our map.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的数据存储在MySQL数据库中。我们将在服务器端使用Python访问它，并希望在客户端使用JavaScript显示它；因此，我们需要花一些时间将我们的数据转换为适当的格式。当我们通过Python的`pymysql`驱动访问数据时，我们将收到一个元组。为了使用JavaScript显示数据，我们希望将其转换为JSON。你可能还记得我们在Headlines项目中提到过JSON，它是JavaScript对象表示法，是一种JavaScript可以轻松读取和操作的结构化数据格式。与我们之前的项目一样，我们将利用Python字典与JSON非常相似的事实。我们将从我们的数据库中获取的元组创建一个Python字典，将其转换为JSON字符串，并将其传递给我们的模板，模板将使用JavaScript将数据显示为地图上的标记。
- en: Getting data from SQL
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从SQL获取数据
- en: 'We''ll start in our `DBHelper` class—adding a method to return the fields we
    need for each crime in our database. Add the following method to your `dbhelper.py`
    file:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的`DBHelper`类开始——添加一个方法来返回我们在数据库中每个犯罪记录所需的字段。将以下方法添加到您的`dbhelper.py`文件中：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also, add the new `import` we need for the `datetime` module to the top of
    `dbhelper.py` via the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过以下方式将我们需要的`datetime`模块的新`import`添加到`dbhelper.py`的顶部：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We ignored the `id` and `updated_at` fields as the user is not interested in
    these using the `SELECT` operator to choose all our other fields. As we have no
    `WHERE` clause, this query will return all the crimes we have in our database.
    Once we have all the crimes, we could simply return them in their default representation
    of a tuple of tuples. However, this makes the maintenance of our application difficult.
    We don't want to have to remember that `latitude` is the first element of our
    tuple, `longitude` is the second, and so on. This would make developing the JavaScript
    part of our application a pain, as we'd have to keep referring back to our `DBHelper`
    to find out how exactly to grab, for example, just the `category` element of our
    data. If we wanted to make changes to our application in the future, it would
    probably require the same changes to be made here and in our JavaScript code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略了`id`和`updated_at`字段，因为用户对这些不感兴趣，使用`SELECT`操作符选择所有其他字段。由于我们没有`WHERE`子句，这个查询将返回我们数据库中的所有犯罪。一旦我们有了所有的犯罪，我们可以简单地以它们的默认表示形式返回它们，即元组的元组。然而，这会使我们的应用程序的维护变得困难。我们不想记住`latitude`是我们元组的第一个元素，`longitude`是第二个元素，依此类推。这将使得开发我们应用程序的JavaScript部分变得痛苦，因为我们不得不不断地参考我们的`DBHelper`，以了解如何准确地获取，例如，我们数据的`category`元素。如果我们将来想要对我们的应用程序进行更改，可能需要在这里和我们的JavaScript代码中进行相同的更改。
- en: 'Instead, we will create a dictionary from each of our records and return the
    dictionaries. This has two advantages: firstly, it''s much easier to develop as
    we can refer to the elements of our data by name instead of by index, and secondly,
    we can easily convert our dictionary to JSON to be used in our JavaScript code.
    For most of the items in our dictionary, we will simply use the database column
    name as a key and the data itself as the value. The exception is the date; our
    database driver returns this as a Python `datetime` object, but we want to display
    it as a string for our user, so we will format it as "yyyy-mm-dd" before storing
    it in our dictionary.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将从我们的每条记录中创建一个字典并返回这些字典。这有两个优点：首先，这样开发会更容易，因为我们可以通过名称而不是索引来引用我们数据的元素；其次，我们可以轻松地将我们的字典转换为JSON，以在我们的JavaScript代码中使用。对于我们字典中的大多数项目，我们将简单地使用数据库列名作为键，数据本身作为值。唯一的例外是日期；我们的数据库驱动程序将其返回为Python的`datetime`对象，但我们希望将其显示为一个字符串供用户使用，因此我们将在存储到字典中之前将其格式化为"yyyy-mm-dd"。
- en: We can add a stub of this method to our `MockDBHelper` so that we can continue
    to run our code locally without a database. In this case, instead of just returning
    a blank list, we'll return a mock crime, as well, in the same format that we'd
    expect from our real `DBHelper`. It's good practice to make any mock classes you
    create behave similarly to their real equivalents as this can help catch development
    errors while we're still testing locally.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的`MockDBHelper`中添加这个方法的存根，以便我们可以继续在本地运行我们的代码而不需要数据库。在这种情况下，我们不仅返回一个空列表，还会返回一个模拟犯罪，格式与我们真正的`DBHelper`所期望的相同。制作任何模拟类时，让你创建的模拟类的行为类似于它们的真实等价物是一个好的做法，因为这可以帮助我们在本地测试时捕捉开发错误。
- en: 'Add the following function to `mockdbhelper.py`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下函数添加到`mockdbhelper.py`中：
- en: '[PRE26]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Passing the data to our template
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据传递给我们的模板
- en: Now that we have the ability to retrieve the data we want from our database
    by calling a single function, let's look at how we will use it in our main Flask
    app and pass it on to our template file.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了通过调用单个函数从数据库中检索所需数据的能力，让我们看看我们将如何在我们的主要Flask应用程序中使用它，并将其传递到我们的模板文件中。
- en: 'Every time a user visits our home page, we want to get the crime data from
    the database and pass it to the template in JSON format to be displayed using
    JavaScript in our user''s browser. As most of the hard work is done in our `DBHelper`
    class, we can keep our `home()` function quite neat. The entire function looks
    as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户访问我们的主页时，我们希望从数据库中获取犯罪数据，并以JSON格式将其传递给模板，以便在用户的浏览器中使用JavaScript显示。由于大部分工作都是在我们的`DBHelper`类中完成的，我们可以保持我们的`home()`函数相当整洁。整个函数如下所示：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will use the `json.dumps()` function, which is the opposite of `json.loads()`
    that we used in the first project to create a JSON string for our dictionary (the
    letter "`s`" in `dumps` stands for "string") and then pass the JSON string on
    to our template so that it can use it to populate the map.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`json.dumps()`函数，这是我们在第一个项目中使用的`json.loads()`的相反操作，用于为我们的字典创建一个JSON字符串（`dumps`中的字母"`s`"代表"string"），然后将JSON字符串传递给我们的模板，以便它可以用它来填充地图。
- en: 'We also need to add an import for the JSON library. Near the top of `crimemap.py`,
    add the following line:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为JSON库添加一个导入。在`crimemap.py`的顶部附近，添加以下行：
- en: '[PRE28]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Using the data in our template
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的模板中使用数据
- en: Our template now has access to a JSON-formatted list of all the crimes in our
    database, and we can use this list to display markers on the map—one for each
    existing crime. We want to use the location data to choose where to place the
    marker, and then we want to embed `category`, `date`, and `description` as a label
    for our marker. This means that when the user moves his or her mouse over one
    of the markers, the information about the crime represented by this marker will
    be displayed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板现在可以访问我们数据库中所有犯罪的JSON格式化列表，并且我们可以使用这个列表在地图上显示标记——每个现有犯罪一个标记。我们希望使用位置数据来选择放置标记的位置，然后我们希望将`category`、`date`和`description`嵌入到我们的标记上作为标签。这意味着当用户将鼠标移动到标记中的一个时，将显示有关这个标记所代表的犯罪的信息。
- en: 'We need to add a new function to our JavaScript code in our `home.html` file.
    Under the `initialize()` function, add the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`home.html`文件中的JavaScript代码中添加一个新的函数。在`initialize()`函数下面，添加以下内容：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This function takes `crimes` an argument, loops through it, and creates a new
    marker on our map (which we can refer to now as we previously made it a global
    variable) for each crime in the list. We used the call to `google.maps.Marker()`
    to create the marker and pass in a dictionary of arguments (in this case, a `google.maps.LatLng()`
    "`position`", which we construct from our `latitude` and `longitude` parameters);
    a reference to our map, which is `map`; and a concatenation of our `date`, `category`,
    and `description`, separated by new line characters as the `title`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将`crimes`作为参数，循环遍历它，并为列表中的每个犯罪在我们的地图上创建一个新标记（我们现在可以引用它，因为我们之前将其作为全局变量）。我们使用调用`google.maps.Marker()`来创建标记，并传递参数字典（在本例中是`google.maps.LatLng()`
    "`position`"，我们从我们的`latitude`和`longitude`参数构造）；我们的地图的引用，即`map`；以及我们的`date`、`category`和`description`的连接，用换行字符分隔作为`title`。
- en: Tip
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Customizing Google Map markers**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**自定义Google地图标记**'
- en: The marker we placed can be customized pretty heavily. The full list of options
    we can pass in can be seen at [https://developers.google.com/maps/documentation/javascript/reference?hl=en#MarkerOptions](https://developers.google.com/maps/documentation/javascript/reference?hl=en#MarkerOptions).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们放置的标记可以进行相当大的定制。我们可以传递的所有选项的完整列表可以在[https://developers.google.com/maps/documentation/javascript/reference?hl=en#MarkerOptions](https://developers.google.com/maps/documentation/javascript/reference?hl=en#MarkerOptions)上看到。
- en: 'All that''s left is to make a call to our new function inside our `initialize()`
    function and pass in the JSON map list that we built in Python. The entire `initialize()`
    function is shown here with the new section highlighted:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要做的就是在我们的`initialize()`函数中调用我们的新函数，并传入我们在Python中构建的JSON地图列表。整个`initialize()`函数如下所示，其中突出显示了新部分：
- en: '[PRE30]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We simply called our `placeCrimes()` function and passed in the crimes. Note
    that we used the Jinja built-in `safe` function by using the `|` (pipe) symbol
    and passing in our `crimes` data. This is necessary as, by default, Jinja escapes
    most special characters, but we need our JSON string to be interpreted raw with
    all special characters as is.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是调用了我们的`placeCrimes()`函数并传入了犯罪。请注意，我们使用了Jinja内置的`safe`函数，通过使用`|`（管道）符号并传入我们的`crimes`数据。这是必要的，因为默认情况下，Jinja会转义大多数特殊字符，但我们需要我们的JSON字符串以原始形式解释，所有特殊字符都是原样的。
- en: However, by using the `safe` function, we tell Jinja that we know that our data
    is safe and at this stage, this is not necessarily the case. Just because we have
    no malicious intent, it does not mean that all our data is inherently safe. Remember,
    most of the pieces of data were submitted by our users, and our data is therefore
    definitely not safe. We'll take a look at the big security hole we've opened in
    our app right after we make sure that it works (with normal, expected usage) as
    intended.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，通过使用`safe`函数，我们告诉Jinja我们知道我们的数据是安全的，但在这个阶段，情况并非一定如此。仅仅因为我们没有恶意意图，并不意味着我们所有的数据都是绝对安全的。请记住，我们的大多数数据都是由用户提交的，因此我们的数据绝对不安全。在确保它按预期工作（正常预期使用）之后，我们将看一下我们在应用程序中打开的重大安全漏洞。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you're familiar with *nix shells, `|` or pipe should be pretty straightforward
    syntax. If not, think of it as a usual function with input and output. Instead
    of passing input as parameters in parentheses and using some form of a `return`
    function to get output, we will instead have our input on the left-hand side of
    the `|` symbol and the function name on the right-hand side (in this case, `safe`).
    The input gets piped through the function, and we are left with the output in
    place. This syntax can be very useful to chain lots of functions together, as
    each outer function is simply placed on the right-hand side after another `|`
    symbol.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉*nix shell，`|`或管道应该是非常简单的语法。如果不熟悉，请将其视为具有输入和输出的常规函数。我们不是通过括号中的参数传递输入，并使用某种形式的`return`函数来获取输出，而是将我们的输入放在`|`符号的左侧，并将函数名称放在右侧（在本例中为`safe`）。输入通过函数进行传递，我们得到输出。这种语法可以非常有用，可以将许多函数链接在一起，因为每个外部函数都简单地放在另一个`|`符号之后的右侧。
- en: Viewing the results
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看结果
- en: First, test out the code locally. This will make sure that everything still
    runs and will possibly catch some more subtle bugs as well. As we are using a
    mock for our database function, we won't have a lot of confidence that this works
    until we see it run on the VPS.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在本地测试代码。这将确保一切仍然运行，并可能会捕捉一些更微妙的错误。由于我们在数据库函数中使用了模拟，因此在VPS上运行之前，我们对此的工作没有太多信心。
- en: 'Once you run `python crimemap.py` in your terminal and visit `localhost:5000`
    in your browser, you should see the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行`python crimemap.py`并在浏览器中访问`localhost:5000`后，您应该会看到以下内容：
- en: '![Viewing the results](img/B04312_07_07.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![查看结果](img/B04312_07_07.jpg)'
- en: We can note a single marker with the details we specified in our `MockDBHelper`.
    In the screenshot, we moved our mouse over the marker to make the `title` appear
    with all the details of the crime.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到一个单一的标记，其中包含我们在`MockDBHelper`中指定的细节。在截图中，我们将鼠标移动到标记上，使`title`显示出犯罪的所有细节。
- en: 'Now it''s time to `commit` to `git` and push to our VPS. Run the following
    commands locally from your `crimemap` directory:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候`commit`到`git`并推送到我们的VPS了。从您的`crimemap`目录中在本地运行以下命令：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, SSH to your VPS to pull the new changes:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，SSH到您的VPS以拉取新更改：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If we visit the IP address of our VPS now, we should see the two crimes we
    added before we were able to display them. As we used the real `DBHelper` and
    our MySQL database for the production site, we should be able to add crimes using
    the form and see each crime added as a marker to the map in real time. Hopefully,
    you''ll get something similar to the following screenshot:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在访问VPS的IP地址，我们应该会看到我们在能够显示它们之前添加的两起犯罪。由于我们在生产站点上使用了真实的`DBHelper`和我们的MySQL数据库，因此我们应该能够使用表单添加犯罪，并实时将每起犯罪添加为地图上的标记。希望您会得到类似以下截图的结果：
- en: '![Viewing the results](img/B04312_07_08.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![查看结果](img/B04312_07_08.jpg)'
- en: 'If things don''t work out as expected, as always run the following on your
    VPS and take a look at the output while visiting the site:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事情不如预期那样顺利，像往常一样在您的VPS上运行以下命令，并在访问网站时查看输出：
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Also, use your browser's debugger by pressing *Ctrl* + *Shift* + *C* to catch
    any JavaScript errors that might have crept in.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，通过按下*Ctrl* + *Shift* + *C* 使用浏览器的调试器来捕获可能出现的任何JavaScript错误。
- en: Our crime map is now functional and can already be used to start tracking crime
    in a town and keep people informed. However, we'll still add some finishing touches
    in the next chapter before moving on to our final project.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的犯罪地图现在已经可以使用，可以开始跟踪城镇的犯罪并让人们保持知情。然而，在进行最终项目之前，我们还将在下一章中添加一些最后的修饰。
- en: Summary
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at how to create a mock database in Python so that
    we could develop our application without needing access to a real database. We
    also added a Google Maps widget to our application and allowed our users to easily
    submit a latitude and longitude by clicking on the map while being able to view
    the locations and descriptions of existing crimes as well.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在Python中创建一个模拟数据库，以便我们可以开发我们的应用程序而不需要访问真实的数据库。我们还向我们的应用程序添加了一个谷歌地图小部件，并允许用户通过单击地图轻松提交纬度和经度，同时能够查看现有犯罪的位置和描述。
- en: In the next chapter, we'll look at another injection vulnerability, XSS, and
    talk about how to protect against it as well as input validation in general.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看看另一个注入漏洞，XSS，并讨论如何保护以及输入验证。
