- en: Chapter 16. Djangos Cache Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。Django的缓存框架
- en: A fundamental trade-off in dynamic websites is, well, they're dynamic. Each
    time a user requests a page, the web server makes all sorts of calculations, from
    database queries to template rendering to business logic to creating the page
    that your site's visitors see. This is a lot more expensive, from a processing-overhead
    perspective, than your standard read-a-file-off-the-filesystem server arrangement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 动态网站的一个基本权衡是，它们是动态的。每当用户请求一个页面时，Web 服务器都会进行各种计算，从数据库查询到模板渲染到业务逻辑再到创建用户所看到的页面。从处理开销的角度来看，这比标准的从文件系统中读取文件的服务器安排要昂贵得多。
- en: For most web applications, this overhead isn't a big deal. Most web applications
    aren't www.washingtonpost.com or www.slashdot.org; they're simply small- to medium-sized
    sites with so-so traffic. But for medium-to high-traffic sites, it's essential
    to cut as much overhead as possible.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数 Web 应用程序来说，这种开销并不是什么大问题。大多数 Web 应用程序不是 www.washingtonpost.com 或 www.slashdot.org；它们只是一些流量一般的中小型站点。但对于中高流量的站点来说，尽量减少开销是至关重要的。
- en: 'That''s where caching comes in. To cache something is to save the result of
    an expensive calculation so that you don''t have to perform the calculation next
    time. Here''s some pseudocode explaining how this would work for a dynamically
    generated web page:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是缓存的作用。缓存某些东西就是保存昂贵计算的结果，这样你就不必在下一次执行计算。下面是一些伪代码，解释了这在动态生成的网页上是如何工作的：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Django comes with a robust cache system that lets you save dynamic pages so
    they don''t have to be calculated for each request. For convenience, Django offers
    different levels of cache granularity: You can cache the output of specific views,
    you can cache only the pieces that are difficult to produce, or you can cache
    your entire site.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Django 自带一个强大的缓存系统，可以让你保存动态页面，这样它们就不必为每个请求重新计算。为了方便起见，Django 提供了不同级别的缓存粒度：你可以缓存特定视图的输出，也可以只缓存难以生成的部分，或者缓存整个站点。
- en: Django also works well with downstream caches, such as Squid (for more information
    visit [http://www.squid-cache.org/](http://www.squid-cache.org/)) and browser-based
    caches. These are the types of caches that you don't directly control, but to
    which you can provide hints (via HTTP headers) about which parts of your site
    should be cached, and how.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Django 也可以很好地与下游缓存（如 Squid，更多信息请访问 [http://www.squid-cache.org/](http://www.squid-cache.org/)）和基于浏览器的缓存一起使用。这些是你无法直接控制的缓存类型，但你可以通过
    HTTP 头提供关于你的站点应该缓存哪些部分以及如何缓存的提示。
- en: Setting up the cache
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置缓存
- en: The cache system requires a small amount of setup. Namely, you have to tell
    it where your cached data should live; whether in a database, on the filesystem
    or directly in memory. This is an important decision that affects your cache's
    performance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存系统需要进行一些设置。主要是告诉它你的缓存数据应该存放在哪里；是在数据库中、在文件系统中还是直接在内存中。这是一个影响缓存性能的重要决定。
- en: Your cache preference goes in the `CACHES` setting in your settings file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你的缓存偏好设置在设置文件的 `CACHES` 设置中。
- en: Memcached
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Memcached
- en: The fastest, most efficient type of cache supported natively by Django, Memcached
    (for more information visit [http://memcached.org/](http://memcached.org/)) is
    an entirely memory-based cache server, originally developed to handle high loads
    at LiveJournal.com and subsequently open-sourced by Danga Interactive. It's used
    by sites such as Facebook and Wikipedia to reduce database access and dramatically
    increase site performance.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Django 原生支持的最快、最高效的缓存类型是 Memcached（更多信息请访问 [http://memcached.org/](http://memcached.org/)），它是一个完全基于内存的缓存服务器，最初是为了处理
    LiveJournal.com 上的高负载而开发的，并且后来由 Danga Interactive 开源。它被 Facebook 和 Wikipedia 等网站使用，以减少数据库访问并显著提高站点性能。
- en: Memcached runs as a daemon and is allotted a specified amount of RAM. All it
    does is provide a fast interface for adding, retrieving and deleting data in the
    cache. All data is stored directly in memory, so there's no overhead of database
    or filesystem usage.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached 作为守护进程运行，并被分配了指定的内存量。它所做的就是提供一个快速的接口，用于在缓存中添加、检索和删除数据。所有数据都直接存储在内存中，因此没有数据库或文件系统使用的开销。
- en: 'After installing Memcached itself, you''ll need to install a Memcached binding.
    There are several Python Memcached bindings available; the two most common are
    python-memcached ([ftp://ftp.tummy.com/pub/python-memcached/](ftp://ftp.tummy.com/pub/python-memcached/))
    and pylibmc ([http://sendapatch.se/projects/pylibmc/](http://sendapatch.se/projects/pylibmc/)).
    To use Memcached with Django:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完 Memcached 本身后，你需要安装一个 Memcached 绑定。有几个 Python Memcached 绑定可用；最常见的两个是 python-memcached（[ftp://ftp.tummy.com/pub/python-memcached/](ftp://ftp.tummy.com/pub/python-memcached/)）和
    pylibmc（[http://sendapatch.se/projects/pylibmc/](http://sendapatch.se/projects/pylibmc/)）。要在
    Django 中使用 Memcached：
- en: Set `BACKEND` to `django.core.cache.backends.memcached.MemcachedCache` or `django.core.cache.backends.memcached.PyLibMCCache`
    (depending on your chosen memcached binding)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `BACKEND` 设置为 `django.core.cache.backends.memcached.MemcachedCache` 或 `django.core.cache.backends.memcached.PyLibMCCache`（取决于你选择的
    memcached 绑定）
- en: Set `LOCATION` to `ip:port` values, where `ip` is the IP address of the Memcached
    daemon and `port` is the port on which Memcached is running, or to a `unix:path`
    value, where `path` is the path to a Memcached Unix socket file.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `LOCATION` 设置为 `ip:port` 值，其中 `ip` 是 Memcached 守护进程的 IP 地址，`port` 是 Memcached
    运行的端口，或者设置为 `unix:path` 值，其中 `path` 是 Memcached Unix socket 文件的路径。
- en: 'In this example, Memcached is running on localhost (`127.0.0.1`) port 11211,
    using the `python-memcached` binding:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Memcached 在本地主机（`127.0.0.1`）的端口 11211 上运行，使用 `python-memcached` 绑定：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In this example, Memcached is available through a local Unix socket file `/tmp/memcached.sock`
    using the `python-memcached` binding:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，Memcached 可以通过本地的 Unix socket 文件 `/tmp/memcached.sock` 使用 `python-memcached`
    绑定来访问：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One excellent feature of Memcached is its ability to share a cache over multiple
    servers. This means you can run Memcached daemons on multiple machines, and the
    program will treat the group of machines as a *single* cache, without the need
    to duplicate cache values on each machine. To take advantage of this feature,
    include all server addresses in `LOCATION`, either separated by semicolons or
    as a list.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached的一个优秀特性是它能够在多台服务器上共享缓存。这意味着您可以在多台机器上运行Memcached守护程序，并且程序将把这组机器视为*单个*缓存，而无需在每台机器上复制缓存值。要利用这个特性，在`LOCATION`中包含所有服务器地址，可以用分号分隔或作为列表。
- en: 'In this example, the cache is shared over Memcached instances running on IP
    address `172.19.26.240` and `172.19.26.242`, both on port 11211:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，缓存是在IP地址`172.19.26.240`和`172.19.26.242`上运行的Memcached实例之间共享的，端口都是11211：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following example, the cache is shared over Memcached instances running
    on the IP addresses `172.19.26.240` (port 11211), `172.19.26.242` (port 11212),
    and `172.19.26.244` (port 11213):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，缓存是在IP地址`172.19.26.240`（端口11211）、`172.19.26.242`（端口11212）和`172.19.26.244`（端口11213）上运行的Memcached实例之间共享的：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A final point about Memcached is that memory-based caching has a disadvantage:
    because the cached data is stored in memory, the data will be lost if your server
    crashes.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Memcached的最后一点是，基于内存的缓存有一个缺点：因为缓存数据存储在内存中，如果服务器崩溃，数据将丢失。
- en: Clearly, memory isn't intended for permanent data storage, so don't rely on
    memory-based caching as your only data storage. Without a doubt, none of the Django
    caching backends should be used for permanent storage-they're all intended to
    be solutions for caching, not storage-but we point this out here because memory-based
    caching is particularly temporary.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，内存并不适用于永久数据存储，因此不要仅依赖基于内存的缓存作为您唯一的数据存储。毫无疑问，Django缓存后端都不应该用于永久存储-它们都是用于缓存而不是存储的解决方案-但我们在这里指出这一点是因为基于内存的缓存特别是临时的。
- en: Database caching
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库缓存
- en: 'Django can store its cached data in your database. This works best if you''ve
    got a fast, well-indexed database server. To use a database table as your cache
    backend:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Django可以将其缓存数据存储在您的数据库中。如果您有一个快速、索引良好的数据库服务器，这将效果最佳。要将数据库表用作缓存后端：
- en: Set `BACKEND` to `django.core.cache.backends.db.DatabaseCache`
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`BACKEND`设置为`django.core.cache.backends.db.DatabaseCache`
- en: Set `LOCATION` to `tablename`, the name of the database table. This name can
    be whatever you want, as long as it's a valid table name that's not already being
    used in your database.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`LOCATION`设置为`tablename`，即数据库表的名称。这个名称可以是任何你想要的，只要它是一个有效的表名，而且在你的数据库中还没有被使用。
- en: 'In this example, the cache table''s name is `my_cache_table`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，缓存表的名称是`my_cache_table`：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating the cache table
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建缓存表
- en: 'Before using the database cache, you must create the cache table with this
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据库缓存之前，您必须使用这个命令创建缓存表：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This creates a table in your database that is in the proper format that Django's
    database-cache system expects. The name of the table is taken from `LOCATION`.
    If you are using multiple database caches, `createcachetable` creates one table
    for each cache. If you are using multiple databases, `createcachetable` observes
    the `allow_migrate()` method of your database routers (see below). Like `migrate`,
    `createcachetable` won't touch an existing table. It will only create missing
    tables.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的数据库中创建一个符合Django数据库缓存系统期望的正确格式的表。表的名称取自`LOCATION`。如果您使用多个数据库缓存，`createcachetable`会为每个缓存创建一个表。如果您使用多个数据库，`createcachetable`会观察数据库路由器的`allow_migrate()`方法（见下文）。与`migrate`一样，`createcachetable`不会触及现有表。它只会创建缺失的表。
- en: Multiple databases
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多个数据库
- en: If you use database caching with multiple databases, you'll also need to set
    up routing instructions for your database cache table. For the purposes of routing,
    the database cache table appears as a model named `CacheEntry`, in an application
    named `django_cache`. This model won't appear in the model cache, but the model
    details can be used for routing purposes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在使用多个数据库进行数据库缓存，还需要为数据库缓存表设置路由指令。对于路由的目的，数据库缓存表显示为一个名为`CacheEntry`的模型，在名为`django_cache`的应用程序中。这个模型不会出现在模型缓存中，但模型的详细信息可以用于路由目的。
- en: 'For example, the following router would direct all cache read operations to
    `cache_replica`, and all write operations to `cache_primary`. The cache table
    will only be synchronized onto `cache_primary`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下路由器将所有缓存读取操作定向到`cache_replica`，并将所有写操作定向到`cache_primary`。缓存表只会同步到`cache_primary`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you don't specify routing directions for the database cache model, the cache
    backend will use the `default` database. Of course, if you don't use the database
    cache backend, you don't need to worry about providing routing instructions for
    the database cache model.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为数据库缓存模型指定路由指令，缓存后端将使用`default`数据库。当然，如果您不使用数据库缓存后端，您就不需要担心为数据库缓存模型提供路由指令。
- en: Filesystem caching
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件系统缓存
- en: The file-based backend serializes and stores each cache value as a separate
    file. To use this backend set `BACKEND` to `'django.core.cache.backends.filebased.FileBasedCache'`
    and `LOCATION` to a suitable directory.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的后端将每个缓存值序列化并存储为单独的文件。要使用此后端，将`BACKEND`设置为`'django.core.cache.backends.filebased.FileBasedCache'`，并将`LOCATION`设置为适当的目录。
- en: 'For example, to store cached data in `/var/tmp/django_cache`, use this setting:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要将缓存数据存储在`/var/tmp/django_cache`中，使用以下设置：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If you''re on Windows, put the drive letter at the beginning of the path, like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Windows上，将驱动器号放在路径的开头，就像这样：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The directory path should be absolute-that is, it should start at the root of
    your filesystem. It doesn't matter whether you put a slash at the end of the setting.
    Make sure the directory pointed to by this setting exists and is readable and
    writable by the system user under which your web server runs. Continuing the above
    example, if your server runs as the user `apache`, make sure the directory `/var/tmp/django_cache`
    exists and is readable and writable by the user `apache`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 目录路径应该是绝对的-也就是说，它应该从文件系统的根目录开始。设置末尾是否加斜杠并不重要。确保此设置指向的目录存在，并且可以被运行您的网页服务器的系统用户读取和写入。继续上面的例子，如果您的服务器以用户`apache`运行，请确保目录`/var/tmp/django_cache`存在，并且可以被用户`apache`读取和写入。
- en: Local-memory caching
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本地内存缓存
- en: 'This is the default cache if another is not specified in your settings file.
    If you want the speed advantages of in-memory caching but don''t have the capability
    of running Memcached, consider the local-memory cache backend. To use it, set
    `BACKEND` to `django.core.cache.backends.locmem.LocMemCache`. For example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在设置文件中未指定其他缓存，则这是默认缓存。如果您想要内存缓存的速度优势，但又没有运行Memcached的能力，请考虑使用本地内存缓存后端。要使用它，请将`BACKEND`设置为`django.core.cache.backends.locmem.LocMemCache`。例如：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The cache `LOCATION` is used to identify individual memory stores. If you only
    have one `locmem` cache, you can omit the `LOCATION`; however, if you have more
    than one local memory cache, you will need to assign a name to at least one of
    them in order to keep them separate.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存`LOCATION`用于标识单个内存存储。如果您只有一个`locmem`缓存，可以省略`LOCATION`；但是，如果您有多个本地内存缓存，您将需要为其中至少一个分配一个名称，以便将它们分开。
- en: Note that each process will have its own private cache instance, which means
    no cross-process caching is possible. This obviously also means the local memory
    cache isn't particularly memory-efficient, so it's probably not a good choice
    for production environments. It's nice for development.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个进程将拥有自己的私有缓存实例，这意味着不可能进行跨进程缓存。这显然也意味着本地内存缓存不是特别内存高效，因此在生产环境中可能不是一个好选择。但对于开发来说是不错的选择。
- en: Dummy caching (for development)
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟缓存（用于开发）
- en: 'Finally, Django comes with a dummy cache that doesn''t actually cache-it just
    implements the cache interface without doing anything. This is useful if you have
    a production site that uses heavy-duty caching in various places but a development/test
    environment where you don''t want to cache and don''t want to have to change your
    code to special-case the latter. To activate dummy caching, set `BACKEND` like
    so:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Django附带了一个虚拟缓存，它实际上不缓存-它只是实现了缓存接口而不执行任何操作。如果您的生产站点在各个地方都使用了重度缓存，但在开发/测试环境中不想缓存并且不想改变代码以特殊处理后者，这将非常有用。要激活虚拟缓存，请将`BACKEND`设置如下：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using a custom cache backend
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义缓存后端
- en: 'While Django includes support for a number of cache backends out-of-the-box,
    sometimes you might want to use a customized cache backend. To use an external
    cache backend with Django, use the Python import path as the `BACKEND` of the
    `CACHES` setting, like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Django默认支持多种缓存后端，但有时您可能希望使用自定义的缓存后端。要在Django中使用外部缓存后端，请将Python导入路径作为`CACHES`设置的`BACKEND`，如下所示：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you're building your own backend, you can use the standard cache backends
    as reference implementations. You'll find the code in the `django/core/cache/backends/`
    directory of the Django source.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建自己的后端，可以使用标准缓存后端作为参考实现。您可以在Django源代码的`django/core/cache/backends/`目录中找到这些代码。
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Without a really compelling reason, such as a host that doesn't support them,
    you should stick to the cache backends included with Django. They've been well-tested
    and are easy to use.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有一个真正令人信服的理由，比如不支持它们的主机，否则您应该坚持使用Django提供的缓存后端。它们经过了充分测试，易于使用。
- en: Cache arguments
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存参数
- en: 'Each cache backend can be given additional arguments to control caching behavior.
    These arguments are provided as additional keys in the `CACHES` setting. Valid
    arguments are as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个缓存后端都可以提供额外的参数来控制缓存行为。这些参数作为`CACHES`设置中的额外键提供。有效参数如下：
- en: '`TIMEOUT`: The default timeout, in seconds, to use for the cache. This argument
    defaults to 300 seconds (5 minutes). You can set `TIMEOUT` to `None` so that,
    by default, cache keys never expire. A value of `0` causes keys to immediately
    expire (effectively don''t cache).'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TIMEOUT`：用于缓存的默认超时时间（以秒为单位）。此参数默认为300秒（5分钟）。您可以将`TIMEOUT`设置为`None`，以便默认情况下缓存键永不过期。值为`0`会导致键立即过期（实际上不缓存）。'
- en: '`OPTIONS`: Any options that should be passed to the cache backend. The list
    of valid options will vary with each backend, and cache backends backed by a third-party
    library will pass their options directly to the underlying cache library.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OPTIONS`：应传递给缓存后端的任何选项。有效选项的列表将随着每个后端的不同而变化，并且由第三方库支持的缓存后端将直接将它们的选项传递给底层缓存库。'
- en: 'Cache backends that implement their own culling strategy (that is, the `locmem`,
    `filesystem` and `database` backends) will honor the following options:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自己的清除策略的缓存后端（即`locmem`，`filesystem`和`database`后端）将遵守以下选项：
- en: '`MAX_ENTRIES`: The maximum number of entries allowed in the cache before old
    values are deleted. This argument defaults to `300`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MAX_ENTRIES`：在旧值被删除之前缓存中允许的最大条目数。此参数默认为`300`。'
- en: '`CULL_FREQUENCY`: The fraction of entries that are culled when `MAX_ENTRIES`
    is reached. The actual ratio is `1 / CULL_FREQUENCY`, so set `CULL_FREQUENCY`
    to `2` to cull half the entries when `MAX_ENTRIES` is reached. This argument should
    be an integer and defaults to `3`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CULL_FREQUENCY`：当达到`MAX_ENTRIES`时被删除的条目比例。实际比例是`1 / CULL_FREQUENCY`，因此将`CULL_FREQUENCY`设置为`2`，以在达到`MAX_ENTRIES`时删除一半的条目。此参数应为整数，默认为`3`。'
- en: A value of `0` for `CULL_FREQUENCY` means that the entire cache will be dumped
    when `MAX_ENTRIES` is reached. On some backends (`database` in particular) this
    makes culling *much* faster at the expense of more cache misses.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CULL_FREQUENCY`的值为`0`意味着当达到`MAX_ENTRIES`时整个缓存将被清除。在某些后端（特别是`database`）上，这样做会使清除*更*快，但会增加缓存未命中的次数。'
- en: '`KEY_PREFIX`: A string that will be automatically included (prepended by default)
    to all cache keys used by the Django server.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_PREFIX`：一个字符串，将自动包含（默认情况下是前置）到Django服务器使用的所有缓存键中。'
- en: '`VERSION`: The default version number for cache keys generated by the Django
    server.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VERSION`：Django服务器生成的缓存键的默认版本号。'
- en: '`KEY_FUNCTION`: A string containing a dotted path to a function that defines
    how to compose a prefix, version, and key into a final cache key.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`KEY_FUNCTION`：包含一个点路径到一个函数的字符串，该函数定义如何将前缀、版本和键组合成最终的缓存键。'
- en: 'In this example, a filesystem backend is being configured with a timeout of
    60 seconds, and a maximum capacity of 1000 items:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，文件系统后端被配置为超时60秒，并且最大容量为1000个项目：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The per-site cache
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个站点的缓存
- en: 'Once the cache is set up, the simplest way to use caching is to cache your
    entire site. You''ll need to add `''django.middleware.cache.UpdateCacheMiddleware''`
    and `''django.middleware.cache.FetchFromCacheMiddleware''` to your `MIDDLEWARE_CLASSES`
    setting, as in this example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设置缓存后，使用缓存的最简单方法是缓存整个站点。您需要将`'django.middleware.cache.UpdateCacheMiddleware'`和`'django.middleware.cache.FetchFromCacheMiddleware'`添加到您的`MIDDLEWARE_CLASSES`设置中，就像这个例子中一样：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'No, that''s not a typo: the update middleware must be first in the list, and
    the fetch middleware must be last. The details are a bit obscure, but see Order
    of MIDDLEWARE_CLASSES) in the next chapter if you''d like the full story.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是一个打字错误：更新中间件必须在列表中首先出现，获取中间件必须在最后出现。细节有点模糊，但是如果您想要完整的故事，请参阅下一章中的MIDDLEWARE_CLASSES顺序。
- en: 'Then, add the following required settings to your Django settings file:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将以下必需的设置添加到您的Django设置文件中：
- en: '`CACHE_MIDDLEWARE_ALIAS`: The cache alias to use for storage.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CACHE_MIDDLEWARE_ALIAS`：用于存储的缓存别名。'
- en: '`CACHE_MIDDLEWARE_SECONDS`: The number of seconds each page should be cached.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CACHE_MIDDLEWARE_SECONDS`：每个页面应该被缓存的秒数。'
- en: '`CACHE_MIDDLEWARE_KEY_PREFIX`-: If the cache is shared across multiple sites
    using the same Django installation, set this to the name of the site, or some
    other string that is unique to this Django instance, to prevent key collisions.
    Use an empty string if you don''t care.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CACHE_MIDDLEWARE_KEY_PREFIX`-：如果缓存跨多个使用相同Django安装的站点共享，则将其设置为站点的名称，或者是对此Django实例唯一的其他字符串，以防止键冲突。如果您不在乎，可以使用空字符串。'
- en: '`FetchFromCacheMiddleware` caches `GET` and `HEAD` responses with `status 200`,
    where the request and response headers allow. Responses to requests for the same
    URL with different query parameters are considered to be unique pages and are
    cached separately. This middleware expects that a `HEAD` request is answered with
    the same response headers as the corresponding `GET` request; in which case it
    can return a cached `GET` response for `HEAD` request. Additionally, `UpdateCacheMiddleware`
    automatically sets a few headers in each `HttpResponse`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`FetchFromCacheMiddleware`使用`status 200`缓存`GET`和`HEAD`响应，其中请求和响应头允许。对于具有不同查询参数的相同URL的请求的响应被认为是唯一的页面，并且被单独缓存。此中间件期望`HEAD`请求以与相应的`GET`请求相同的响应头进行响应；在这种情况下，它可以为`HEAD`请求返回缓存的`GET`响应。此外，`UpdateCacheMiddleware`自动在每个`HttpResponse`中设置一些头：'
- en: Sets the `Last-Modified` header to the current date/time when a fresh (not cached)
    version of the page is requested.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Last-Modified`头设置为请求新的（未缓存）页面时的当前日期/时间。
- en: Sets the `Expires` header to the current date/time plus the defined `CACHE_MIDDLEWARE_SECONDS`.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Expires`头设置为当前日期/时间加上定义的`CACHE_MIDDLEWARE_SECONDS`。
- en: Sets the `Cache-Control` header to give a max age for the page-again, from the
    `CACHE_MIDDLEWARE_SECONDS` setting.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Cache-Control`头设置为页面的最大年龄-同样，从`CACHE_MIDDLEWARE_SECONDS`设置。
- en: If a view sets its own cache expiry time (that is, it has a `max-age` section
    in its
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '如果视图设置了自己的缓存到期时间（即它在其`max-age`部分中有一个），则页面将被缓存直到到期时间，而不是`CACHE_MIDDLEWARE_SECONDS`。 '
- en: '`Cache-Control` header) then the page will be cached until the expiry time,
    rather than `CACHE_MIDDLEWARE_SECONDS`. Using the decorators in `django.views.decorators.cache`
    you can easily set a view''s expiry time (using the `cache_control` decorator)
    or disable caching for a view (using the `never_cache` decorator). See the using
    other headers section for more on these decorators.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache-Control`头）那么页面将被缓存直到到期时间，而不是`CACHE_MIDDLEWARE_SECONDS`。使用`django.views.decorators.cache`中的装饰器，您可以轻松地设置视图的到期时间（使用`cache_control`装饰器）或禁用视图的缓存（使用`never_cache`装饰器）。有关这些装饰器的更多信息，请参阅使用其他标头部分。'
- en: If `USE_I18N` is set to `True` then the generated cache key will include the
    name of the active language. This allows you to easily cache multilingual sites
    without having to create the cache key yourself.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`USE_I18N`设置为`True`，则生成的缓存键将包括活动语言的名称。这样，您可以轻松地缓存多语言站点，而无需自己创建缓存键。
- en: Cache keys also include the active language when `USE_L10N` is set to `True`
    and the current time zone when `USE_TZ` is set to `True`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当`USE_L10N`设置为`True`时，缓存键还包括活动语言，当`USE_TZ`设置为`True`时，还包括当前时区。
- en: The per-view cache
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 每个视图的缓存
- en: 'A more granular way to use the caching framework is by caching the output of
    individual views. `django.views.decorators.cache` defines a `cache_page` decorator
    that will automatically cache the view''s response for you. It''s easy to use:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用缓存框架的更细粒度的方法是通过缓存单个视图的输出。`django.views.decorators.cache`定义了一个`cache_page`装饰器，它将自动为您缓存视图的响应。使用起来很容易：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`cache_page` takes a single argument: the cache timeout, in seconds. In the
    above example, the result of the `my_view()` view will be cached for 15 minutes.
    (Note that I''ve written it as `60 * 15` for the purpose of readability. `60 *
    15` will be evaluated to `900`-that is, 15 minutes multiplied by 60 seconds per
    minute.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache_page`接受一个参数：缓存超时时间，以秒为单位。在上面的例子中，`my_view()`视图的结果将被缓存15分钟。（请注意，我已经将其写成`60
    * 15`，以便阅读。`60 * 15`将被计算为`900`-也就是说，15分钟乘以60秒每分钟。）'
- en: 'The per-view cache, like the per-site cache, is keyed off of the URL. If multiple
    URLs point at the same view, each URL will be cached separately. Continuing the
    `my_view` example, if your URLconf looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图的缓存，就像每个站点的缓存一样，是基于URL的。如果多个URL指向同一个视图，每个URL将被单独缓存。继续`my_view`的例子，如果您的URLconf如下所示：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: then requests to `/foo/1/` and `/foo/23/` will be cached separately, as you
    may expect. But once a particular URL (for example, `/foo/23/`) has been requested,
    subsequent requests to that URL will use the cache.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然后对`/foo/1/`和`/foo/23/`的请求将被分别缓存，正如你可能期望的那样。但一旦请求了特定的URL（例如`/foo/23/`），随后对该URL的请求将使用缓存。
- en: '`cache_page` can also take an optional keyword argument, `cache`, which directs
    the decorator to use a specific cache (from your `CACHES` setting) when caching
    view results.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache_page`还可以接受一个可选的关键字参数`cache`，它指示装饰器在缓存视图结果时使用特定的缓存（来自你的`CACHES`设置）。'
- en: 'By default, the `default` cache will be used, but you can specify any cache
    you want:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，将使用`default`缓存，但你可以指定任何你想要的缓存：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also override the cache prefix on a per-view basis. `cache_page` takes
    an optional keyword argument, `key_prefix`, which works in the same way as the
    `CACHE_MIDDLEWARE_KEY_PREFIX` setting for the middleware. It can be used like
    this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在每个视图的基础上覆盖缓存前缀。`cache_page`接受一个可选的关键字参数`key_prefix`，它的工作方式与中间件的`CACHE_MIDDLEWARE_KEY_PREFIX`设置相同。可以像这样使用：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `key_prefix` and `cache` arguments may be specified together. The `key_prefix`
    argument and the `KEY_PREFIX` specified under `CACHES` will be concatenated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`key_prefix`和`cache`参数可以一起指定。`key_prefix`参数和在`CACHES`下指定的`KEY_PREFIX`将被连接起来。'
- en: Specifying per-view Cache in the URLconf
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在URLconf中指定每个视图的缓存
- en: The examples in the previous section have hard-coded the fact that the view
    is cached, because `cache_page` alters the `my_view` function in place. This approach
    couples your view to the cache system, which is not ideal for several reasons.
    For instance, you might want to reuse the view functions on another, cache-less
    site, or you might want to distribute the views to people who might want to use
    them without being cached.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中的示例已经硬编码了视图被缓存的事实，因为`cache_page`会直接修改`my_view`函数。这种方法将你的视图与缓存系统耦合在一起，这对于几个原因来说都不理想。例如，你可能希望在另一个没有缓存的站点上重用视图函数，或者你可能希望将视图分发给可能希望在没有被缓存的情况下使用它们的人。
- en: 'The solution to these problems is to specify the per-view cache in the URLconf
    rather than next to the view functions themselves. Doing so is easy: simply wrap
    the view function with `cache_page` when you refer to it in the URLconf.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法是在URLconf中指定每个视图的缓存，而不是在视图函数旁边。这样做很容易：只需在URLconf中引用视图函数时用`cache_page`包装视图函数即可。
- en: 'Here''s the old URLconf from earlier:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前的旧URLconf：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here''s the same thing, with `my_view` wrapped in `cache_page`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相同的内容，`my_view`被包裹在`cache_page`中：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Template fragment caching
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板片段缓存
- en: If you're after even more control, you can also cache template fragments using
    the `cache` template tag. To give your template access to this tag, put
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要更多的控制，你也可以使用`cache`模板标签来缓存模板片段。为了让你的模板可以访问这个标签，放置
- en: '`{% load cache %}` near the top of your template. The `{% cache %}` template
    tag caches the contents of the block for a given amount of time.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板顶部附近使用`{% load cache %}`。`{% cache %}`模板标签会缓存给定时间内的块内容。
- en: 'It takes at least two arguments: the cache timeout, in seconds, and the name
    to give the cache fragment. The name will be taken as is, do not use a variable.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它至少需要两个参数：缓存超时（以秒为单位）和要给缓存片段的名称。名称将被直接使用，不要使用变量。
- en: 'For example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Sometimes you might want to cache multiple copies of a fragment depending on
    some dynamic data that appears inside the fragment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望根据片段内部出现的一些动态数据来缓存多个副本的片段。
- en: 'For example, you might want a separate cached copy of the sidebar used in the
    previous example for every user of your site. Do this by passing additional arguments
    to the `{% cache %}` template tag to uniquely identify the cache fragment:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能希望为站点的每个用户使用前面示例中使用的侧边栏的单独缓存副本。通过向`{% cache %}`模板标签传递额外的参数来唯一标识缓存片段来实现这一点：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It's perfectly fine to specify more than one argument to identify the fragment.
    Simply pass as many arguments to `{% cache %}` as you need. If `USE_I18N` is set
    to `True` the per-site middleware cache will respect the active language.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 指定多个参数来标识片段是完全可以的。只需向`{% cache %}`传递所需的参数即可。如果`USE_I18N`设置为`True`，则每个站点的中间件缓存将遵循活动语言。
- en: 'For the `cache` template tag you could use one of the translation-specific
    variables available in templates to achieve the same result:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`cache`模板标签，你可以使用模板中可用的翻译特定变量之一来实现相同的结果：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The cache timeout can be a template variable, as long as the template variable
    resolves to an integer value.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存超时可以是一个模板变量，只要模板变量解析为整数值即可。
- en: 'For example, if the template variable `my_timeout` is set to the value `600`,
    then the following two examples are equivalent:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果模板变量`my_timeout`设置为值`600`，那么以下两个示例是等价的：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This feature is useful in avoiding repetition in templates. You can set the
    timeout in a variable, in one place, and just reuse that value. By default, the
    cache tag will try to use the cache called `template_fragments`. If no such cache
    exists, it will fall back to using the default cache. You may select an alternate
    cache backend to use with the `using` keyword argument, which must be the last
    argument to the tag.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在模板中避免重复很有用。你可以在一个地方设置超时，然后只需重用该值。默认情况下，缓存标签将尝试使用名为`template_fragments`的缓存。如果没有这样的缓存存在，它将退回到使用默认缓存。你可以选择一个备用的缓存后端来与`using`关键字参数一起使用，这必须是标签的最后一个参数。
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It is considered an error to specify a cache name that is not configured.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 指定未配置的缓存名称被认为是一个错误。
- en: 'If you want to obtain the cache key used for a cached fragment, you can use
    `make_template_fragment_key`. `fragment_name` is the same as second argument to
    the `cache` template tag; `vary_on` is a list of all additional arguments passed
    to the tag. This function can be useful for invalidating or overwriting a cached
    item, for example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想获取用于缓存片段的缓存键，你可以使用`make_template_fragment_key`。`fragment_name`与`cache`模板标签的第二个参数相同；`vary_on`是传递给标签的所有额外参数的列表。这个函数对于使缓存项无效或覆盖缓存项可能很有用，例如：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The low-level cache API
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 低级别缓存API
- en: Sometimes, caching an entire rendered page doesn't gain you very much and is,
    in fact, inconvenient overkill. Perhaps, for instance, your site includes a view
    whose results depend on several expensive queries, the results of which change
    at different intervals. In this case, it would not be ideal to use the full-page
    caching that the per-site or per-view cache strategies offer, because you wouldn't
    want to cache the entire result (since some of the data changes often), but you'd
    still want to cache the results that rarely change.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，缓存整个渲染页面并不会带来太多好处，实际上，这种方式过度。例如，您的站点可能包括一个视图，其结果取决于几个昂贵的查询，这些查询的结果在不同的时间间隔内发生变化。在这种情况下，使用每个站点或每个视图缓存策略提供的全页缓存并不理想，因为您不希望缓存整个结果（因为某些数据经常更改），但仍然希望缓存很少更改的结果。
- en: 'For cases like this, Django exposes a simple, low-level cache API. You can
    use this API to store objects in the cache with any level of granularity you like.
    You can cache any Python object that can be pickled safely: strings, dictionaries,
    lists of model objects, and so forth. (Most common Python objects can be pickled;
    refer to the Python documentation for more information about pickling.)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的情况，Django公开了一个简单的低级缓存API。您可以使用此API以任何您喜欢的粒度存储对象。您可以缓存任何可以安全进行pickle的Python对象：字符串，字典，模型对象列表等（大多数常见的Python对象都可以进行pickle；有关pickling的更多信息，请参阅Python文档）。
- en: Accessing the cache
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问缓存
- en: 'You can access the caches configured in the `CACHES` setting through a dictionary-like
    object: `django.core.cache.caches`. Repeated requests for the same alias in the
    same thread will return the same object.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过类似字典的对象`django.core.cache.caches`访问`CACHES`设置中配置的缓存。在同一线程中对同一别名的重复请求将返回相同的对象。
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the named key does not exist, `InvalidCacheBackendError` will be raised.
    To provide thread-safety, a different instance of the cache backend will be returned
    for each thread.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命名键不存在，则将引发`InvalidCacheBackendError`。为了提供线程安全性，将为每个线程返回缓存后端的不同实例。
- en: 'As a shortcut, the default cache is available as `django.core.cache.cache`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 作为快捷方式，默认缓存可用为`django.core.cache.cache`：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This object is equivalent to `caches['default']`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象等同于`caches['default']`。
- en: Basic usage
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本用法
- en: 'The basic interface is `set(key, value, timeout)` and `get(key)`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 基本接口是`set（key，value，timeout）`和`get（key）`：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `timeout` argument is optional and defaults to the `timeout` argument of
    the appropriate backend in the `CACHES` setting (explained above). It''s the number
    of seconds the value should be stored in the cache. Passing in `None` for `timeout`
    will cache the value forever. A `timeout` of `0` won''t cache the value. If the
    object doesn''t exist in the cache, `cache.get()` returns `None`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeout`参数是可选的，默认为`CACHES`设置中适当后端的`timeout`参数（如上所述）。这是值应在缓存中存储的秒数。将`None`传递给`timeout`将永远缓存该值。`timeout`为`0`将不会缓存该值。如果对象在缓存中不存在，则`cache.get（）`将返回`None`：'
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We advise against storing the literal value `None` in the cache, because you
    won''t be able to distinguish between your stored `None` value and a cache miss
    signified by a return value of `None`. `cache.get()` can take a `default` argument.
    This specifies which value to return if the object doesn''t exist in the cache:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议不要将文字值`None`存储在缓存中，因为您无法区分存储的`None`值和由返回值`None`表示的缓存未命中。`cache.get（）`可以接受`default`参数。这指定如果对象在缓存中不存在时要返回的值：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To add a key only if it doesn''t already exist, use the `add()` method. It
    takes the same parameters as `set()`, but it will not attempt to update the cache
    if the key specified is already present:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅在键不存在时添加键，请使用`add（）`方法。它接受与`set（）`相同的参数，但如果指定的键已经存在，则不会尝试更新缓存：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If you need to know whether `add()` stored a value in the cache, you can check
    the return value. It will return `True` if the value was stored, `False` otherwise.
    There''s also a `get_many()` interface that only hits the cache once. `get_many()`
    returns a dictionary with all the keys you asked for that actually exist in the
    cache (and haven''t expired):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要知道`add（）`是否将值存储在缓存中，可以检查返回值。如果存储了该值，则返回`True`，否则返回`False`。还有一个`get_many（）`接口，只会命中一次缓存。`get_many（）`返回一个包含实际存在于缓存中的所有您请求的键的字典（并且尚未过期）：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To set multiple values more efficiently, use `set_many()` to pass a dictionary
    of key-value pairs:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要更有效地设置多个值，请使用`set_many（）`传递键值对的字典：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Like `cache.set()`, `set_many()` takes an optional `timeout` parameter. You
    can delete keys explicitly with `delete()`. This is an easy way of clearing the
    cache for a particular object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与`cache.set（）`类似，`set_many（）`接受一个可选的`timeout`参数。您可以使用`delete（）`显式删除键。这是清除特定对象的缓存的简单方法：
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you want to clear a bunch of keys at once, `delete_many()` can take a list
    of keys to be cleared:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要一次清除一堆键，`delete_many（）`可以接受要清除的键的列表：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Finally, if you want to delete all the keys in the cache, use `cache.clear()`.
    Be careful with this; `clear()` will remove everything from the cache, not just
    the keys set by your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果要删除缓存中的所有键，请使用`cache.clear（）`。请注意；`clear（）`将从缓存中删除所有内容，而不仅仅是应用程序设置的键。
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: You can also increment or decrement a key that already exists using the `incr()`
    or `decr()` methods, respectively. By default, the existing cache value will be
    incremented or decremented by 1\. Other increment/decrement values can be specified
    by providing an argument to the increment/decrement call.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`incr（）`或`decr（）`方法来增加或减少已经存在的键。默认情况下，现有的缓存值将增加或减少1。可以通过向增量/减量调用提供参数来指定其他增量/减量值。
- en: 'A `ValueError` will be raised if you attempt to increment or decrement a non-existent
    cache key.:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试增加或减少不存在的缓存键，则会引发`ValueError`。
- en: '[PRE38]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can close the connection to your cache with `close()` if implemented by
    the cache backend.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缓存后端实现了`close（）`，则可以使用`close（）`关闭与缓存的连接。
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that for caches that don't implement `close` methods `close()` is a no-op.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于不实现`close`方法的缓存，`close（）`是一个空操作。
- en: Cache key prefixing
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存键前缀
- en: If you are sharing a cache instance between servers, or between your production
    and development environments, it's possible for data cached by one server to be
    used by another server. If the format of cached data is different between servers,
    this can lead to some very hard to diagnose problems.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在服务器之间共享缓存实例，或在生产和开发环境之间共享缓存实例，那么一个服务器缓存的数据可能会被另一个服务器使用。如果缓存数据在服务器之间的格式不同，这可能会导致一些非常难以诊断的问题。
- en: To prevent this, Django provides the ability to prefix all cache keys used by
    a server. When a particular cache key is saved or retrieved, Django will automatically
    prefix the cache key with the value of the `KEY_PREFIX` cache setting. By ensuring
    each Django instance has a different `KEY_PREFIX`, you can ensure that there will
    be no collisions in cache values.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，Django提供了为服务器中使用的所有缓存键添加前缀的功能。当保存或检索特定缓存键时，Django将自动使用`KEY_PREFIX`缓存设置的值作为缓存键的前缀。通过确保每个Django实例具有不同的`KEY_PREFIX`，您可以确保缓存值不会发生冲突。
- en: Cache versioning
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存版本
- en: When you change a running code that uses cached values, you may need to purge
    any existing cached values. The easiest way to do this is to flush the entire
    cache, but this can lead to the loss of cache values that are still valid and
    useful. Django provides a better way to target individual cache values.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当您更改使用缓存值的运行代码时，您可能需要清除任何现有的缓存值。这样做的最简单方法是刷新整个缓存，但这可能会导致仍然有效和有用的缓存值的丢失。Django提供了一种更好的方法来定位单个缓存值。
- en: Django's cache framework has a system-wide version identifier, specified using
    the `VERSION` cache setting. The value of this setting is automatically combined
    with the cache prefix and the user-provided cache key to obtain the final cache
    key.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Django的缓存框架具有系统范围的版本标识符，使用`VERSION`缓存设置指定。此设置的值将自动与缓存前缀和用户提供的缓存键结合，以获取最终的缓存键。
- en: 'By default, any key request will automatically include the site default cache
    key version. However, the primitive cache functions all include a `version` argument,
    so you can specify a particular cache key version to set or get. For example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何键请求都将自动包括站点默认的缓存键版本。但是，原始缓存函数都包括一个`version`参数，因此您可以指定要设置或获取的特定缓存键版本。例如：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The version of a specific key can be incremented and decremented using the
    `incr_version()` and `decr_version()` methods. This enables specific keys to be
    bumped to a new version, leaving other keys unaffected. Continuing our previous
    example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 特定键的版本可以使用`incr_version()`和`decr_version()`方法进行增加和减少。这使得特定键可以升级到新版本，而不影响其他键。继续我们之前的例子：
- en: '[PRE41]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Cache key transformation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存键转换
- en: 'As described in the previous two sections, the cache key provided by a user
    is not used verbatim-it is combined with the cache prefix and key version to provide
    a final cache key. By default, the three parts are joined using colons to produce
    a final string:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两节所述，用户提供的缓存键不会直接使用-它与缓存前缀和键版本结合以提供最终的缓存键。默认情况下，这三个部分使用冒号连接以生成最终字符串：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you want to combine the parts in different ways, or apply other processing
    to the final key (for example, taking a hash digest of the key parts), you can
    provide a custom key function. The `KEY_FUNCTION` cache setting specifies a dotted-path
    to a function matching the prototype of `make_key()` above. If provided, this
    custom key function will be used instead of the default key combining function.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想以不同的方式组合部分，或对最终键应用其他处理（例如，对键部分进行哈希摘要），可以提供自定义键函数。`KEY_FUNCTION`缓存设置指定了与上面`make_key()`原型匹配的函数的点路径。如果提供了此自定义键函数，它将被用于替代默认的键组合函数。
- en: Cache key warnings
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存键警告
- en: Memcached, the most commonly-used production cache backend, does not allow cache
    keys longer than 250 characters or containing whitespace or control characters,
    and using such keys will cause an exception. To encourage cache-portable code
    and minimize unpleasant surprises, the other built-in cache backends issue a warning
    (`django.core.cache.backends.base.CacheKeyWarning`) if a key is used that would
    cause an error on memcached.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached，最常用的生产缓存后端，不允许缓存键超过250个字符或包含空格或控制字符，使用这样的键将导致异常。为了鼓励可移植的缓存代码并最小化不愉快的惊喜，其他内置缓存后端在使用可能导致在memcached上出错的键时会发出警告（`django.core.cache.backends.base.CacheKeyWarning`）。
- en: 'If you are using a production backend that can accept a wider range of keys
    (a custom backend, or one of the non-memcached built-in backends), and want to
    use this wider range without warnings, you can silence `CacheKeyWarning` with
    this code in the `management` module of one of your `INSTALLED_APPS`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用可以接受更广泛键范围的生产后端（自定义后端或非memcached内置后端之一），并且希望在没有警告的情况下使用此更广泛范围，您可以在一个`INSTALLED_APPS`的`management`模块中使用以下代码来消除`CacheKeyWarning`：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you want to instead provide custom key validation logic for one of the built-in
    backends, you can subclass it, override just the `validate_key` method, and follow
    the instructions for using a custom cache backend.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想为内置后端之一提供自定义键验证逻辑，可以对其进行子类化，仅覆盖`validate_key`方法，并按照使用自定义缓存后端的说明进行操作。
- en: 'For instance, to do this for the `locmem` backend, put this code in a module:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为`locmem`后端执行此操作，请将此代码放入一个模块中：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '... and use the dotted Python path to this class in the `BACKEND` portion of
    your `CACHES` setting.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '...并在`CACHES`设置的`BACKEND`部分使用此类的点Python路径。'
- en: Downstream caches
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下游缓存
- en: 'So far, this chapter has focused on caching your own data. But another type
    of caching is relevant to web development, too: caching performed by downstream
    caches. These are systems that cache pages for users even before the request reaches
    your website. Here are a few examples of downstream caches:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章重点介绍了缓存自己的数据。但是，与Web开发相关的另一种缓存也很重要：下游缓存执行的缓存。这些是在请求到达您的网站之前就为用户缓存页面的系统。以下是一些下游缓存的示例：
- en: Your ISP may cache certain pages, so if you requested a page from `http://example.com/`,
    your ISP would send you the page without having to access `example.com` directly.
    The maintainers of `example.com` have no knowledge of this caching; the ISP sits
    between `example.com` and your web browser, handling all of the caching transparently.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的ISP可能会缓存某些页面，因此，如果您从`http://example.com/`请求页面，则您的ISP将向您发送页面，而无需直接访问`example.com`。`example.com`的维护者对此缓存一无所知；ISP位于`example.com`和您的Web浏览器之间，透明地处理所有缓存。
- en: Your Django website may sit behind a *proxy cache*, such as Squid web Proxy
    Cache (for more information visit [http://www.squid-cache.org/](http://www.squid-cache.org/)),
    that caches pages for performance. In this case, each request first would be handled
    by the proxy, and it would be passed to your application only if needed.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的Django网站可能位于*代理缓存*之后，例如Squid Web代理缓存（有关更多信息，请访问[http://www.squid-cache.org/](http://www.squid-cache.org/)），该缓存可提高页面性能。在这种情况下，每个请求首先将由代理处理，只有在需要时才会传递给您的应用程序。
- en: Your web browser caches pages, too. If a web page sends out the appropriate
    headers, your browser will use the local cached copy for subsequent requests to
    that page, without even contacting the web page again to see whether it has changed.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的Web浏览器也会缓存页面。如果网页发送适当的头，则您的浏览器将对该页面的后续请求使用本地缓存副本，而无需再次联系网页以查看其是否已更改。
- en: 'Downstream caching is a nice efficiency boost, but there''s a danger to it:
    Many web pages'' contents differ based on authentication and a host of other variables,
    and cache systems that blindly save pages based purely on URLs could expose incorrect
    or sensitive data to subsequent visitors to those pages.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下游缓存是一个不错的效率提升，但也存在危险：许多网页的内容基于认证和一系列其他变量而异，盲目保存页面的缓存系统可能向随后访问这些页面的访问者公开不正确或敏感的数据。
- en: For example, say you operate a web email system, and the contents of the inbox
    page obviously depend on which user is logged in. If an ISP blindly cached your
    site, then the first user who logged in through that ISP would have their user-specific
    inbox page cached for subsequent visitors to the site. That's not cool.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您运营一个Web电子邮件系统，收件箱页面的内容显然取决于哪个用户已登录。如果ISP盲目缓存您的站点，那么通过该ISP首次登录的用户将使其特定于用户的收件箱页面缓存供站点的后续访问者使用。这不好。
- en: Fortunately, HTTP provides a solution to this problem. A number of HTTP headers
    exist to instruct downstream caches to differ their cache contents depending on
    designated variables, and to tell caching mechanisms not to cache particular pages.
    We'll look at some of these headers in the sections that follow.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，HTTP提供了解决这个问题的方法。存在许多HTTP头，用于指示下游缓存根据指定的变量延迟其缓存内容，并告诉缓存机制不要缓存特定页面。我们将在接下来的部分中查看其中一些头。
- en: Using vary headers
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用vary头
- en: The `Vary` header defines which request headers a cache mechanism should take
    into account when building its cache key. For example, if the contents of a web
    page depend on a user's language preference, the page is said to vary on language.
    By default, Django's cache system creates its cache keys using the requested fully-qualified
    URL-for example, `http://www.example.com/stories/2005/?order_by=author`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Vary`头定义了缓存机制在构建其缓存键时应考虑哪些请求头。例如，如果网页的内容取决于用户的语言首选项，则称该页面取决于语言。默认情况下，Django的缓存系统使用请求的完全限定URL创建其缓存键，例如`http://www.example.com/stories/2005/?order_by=author`。'
- en: This means every request to that URL will use the same cached version, regardless
    of user-agent differences such as cookies or language preferences. However, if
    this page produces different content based on some difference in request headers-such
    as a cookie, or a language, or a user-agent-you'll need to use the `Vary` header
    to tell caching mechanisms that the page output depends on those things.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着对该URL的每个请求都将使用相同的缓存版本，而不考虑用户代理的差异，例如cookie或语言首选项。但是，如果此页面根据请求头的某些差异（例如cookie、语言或用户代理）生成不同的内容，则需要使用`Vary`头来告诉缓存机制页面输出取决于这些内容。
- en: 'To do this in Django, use the convenient `django.views.decorators.vary.vary_on_headers()`
    view decorator, like so:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Django中执行此操作，请使用方便的`django.views.decorators.vary.vary_on_headers()`视图装饰器，如下所示：
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In this case, a caching mechanism (such as Django''s own cache middleware)
    will cache a separate version of the page for each unique user-agent. The advantage
    to using the `vary_on_headers` decorator rather than manually setting the `Vary`
    header (using something like `response[''Vary''] = ''user-agent''`) is that the
    decorator adds to the `Vary` header (which may already exist), rather than setting
    it from scratch and potentially overriding anything that was already in there.
    You can pass multiple headers to `vary_on_headers()`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，缓存机制（例如Django自己的缓存中间件）将为每个唯一的用户代理缓存页面的单独版本。使用`vary_on_headers`装饰器而不是手动设置`Vary`头（使用类似`response['Vary']
    = 'user-agent'`的东西）的优势在于，装饰器会添加到`Vary`头（如果已经存在），而不是从头开始设置它，并可能覆盖已经存在的任何内容。您可以将多个头传递给`vary_on_headers()`：
- en: '[PRE46]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This tells downstream caches to vary on both, which means each combination
    of user-agent and cookie will get its own cache value. For example, a request
    with the user-agent `Mozilla` and the cookie value `foo=bar` will be considered
    different from a request with the user-agent `Mozilla` and the cookie value `foo=ham`.
    Because varying on cookie is so common, there''s a `django.views.decorators.vary.vary_on_cookie()`
    decorator. These two views are equivalent:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉下游缓存在两者上变化，这意味着每个用户代理和cookie的组合都将获得自己的缓存值。例如，具有用户代理`Mozilla`和cookie值`foo=bar`的请求将被视为与具有用户代理`Mozilla`和cookie值`foo=ham`的请求不同。因为在cookie上变化是如此常见，所以有一个`django.views.decorators.vary.vary_on_cookie()`装饰器。这两个视图是等效的。
- en: '[PRE47]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The headers you pass to `vary_on_headers` are not case sensitive; `User-Agent`
    is the same thing as `user-agent`. You can also use a helper function, `django.utils.cache.patch_vary_headers()`,
    directly. This function sets, or adds to, the `Vary` header. For example:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您传递给`vary_on_headers`的标头不区分大小写；`User-Agent`与`user-agent`是相同的。您还可以直接使用辅助函数`django.utils.cache.patch_vary_headers()`。此函数设置或添加到`Vary`标头。例如：
- en: '[PRE48]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`patch_vary_headers` takes an `HttpResponse` instance as its first argument
    and a list/tuple of case-insensitive header names as its second argument. For
    more on `Vary` headers, see the official Vary specification (for more information
    visit [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44)).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`patch_vary_headers`将`HttpResponse`实例作为其第一个参数，并将不区分大小写的标头名称列表/元组作为其第二个参数。有关`Vary`标头的更多信息，请参阅官方Vary规范（有关更多信息，请访问[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.44)）。'
- en: 'Controlling cache: using other headers'
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制缓存：使用其他标头
- en: 'Other problems with caching are the privacy of data and the question of where
    data should be stored in a cascade of caches. A user usually faces two kinds of
    caches: their own browser cache (a private cache) and their provider''s cache
    (a public cache).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存的其他问题是数据的隐私和数据应该存储在缓存级联中的哪个位置的问题。用户通常面临两种缓存：自己的浏览器缓存（私有缓存）和其提供者的缓存（公共缓存）。
- en: A public cache is used by multiple users and controlled by someone else. This
    poses problems with sensitive data-you don't want, say, your bank account number
    stored in a public cache. So web applications need a way to tell caches which
    data is private and which is public.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 公共缓存由多个用户使用，并由其他人控制。这会带来敏感数据的问题-您不希望您的银行账号存储在公共缓存中。因此，Web应用程序需要一种告诉缓存哪些数据是私有的，哪些是公共的方法。
- en: 'The solution is to indicate a page''s cache should be private. To do this in
    Django, use the `cache_control` view decorator. Example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是指示页面的缓存应该是私有的。在Django中，使用`cache_control`视图装饰器。例如：
- en: '[PRE49]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This decorator takes care of sending out the appropriate HTTP header behind
    the scenes. Note that the cache control settings `private` and `public` are mutually
    exclusive. The decorator ensures that the public directive is removed if private
    should be set (and vice versa).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器负责在后台发送适当的HTTP标头。请注意，缓存控制设置`private`和`public`是互斥的。装饰器确保如果应该设置`private`，则删除公共指令（反之亦然）。
- en: 'An example use of the two directives would be a blog site that offers both
    private and public entries. Public entries may be cached on any shared cache.
    The following code uses `django.utils.cache.patch_cache_control()`, the manual
    way to modify the cache control header (it is internally called by the `cache_control`
    decorator):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 两个指令的一个示例用法是提供公共和私有条目的博客网站。公共条目可以在任何共享缓存上缓存。以下代码使用`django.utils.cache.patch_cache_control()`，手动修改缓存控制标头的方法（它由`cache_control`装饰器内部调用）：
- en: '[PRE50]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'There are a few other ways to control cache parameters. For example, HTTP allows
    applications to do the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他控制缓存参数的方法。例如，HTTP允许应用程序执行以下操作：
- en: Define the maximum time a page should be cached.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义页面应缓存的最长时间。
- en: Specify whether a cache should always check for newer versions, only delivering
    the cached content when there are no changes. (Some caches might deliver cached
    content even if the server page changed, simply because the cache copy isn't yet
    expired.)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定缓存是否应该始终检查更新版本，仅在没有更改时提供缓存内容。（某些缓存可能会在服务器页面更改时提供缓存内容，仅因为缓存副本尚未过期。）
- en: 'In Django, use the `cache_control` view decorator to specify these cache parameters.
    In this example, `cache_control` tells caches to revalidate the cache on every
    access and to store cached versions for, at most, 3,600 seconds:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，使用`cache_control`视图装饰器来指定这些缓存参数。在此示例中，`cache_control`告诉缓存在每次访问时重新验证缓存，并将缓存版本存储最多3600秒：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Any valid `Cache-Control` HTTP directive is valid in `cache_control()`. Here''s
    a full list:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`cache_control()`中的任何有效的`Cache-Control` HTTP指令在`cache_control()`中都是有效的。以下是完整列表：'
- en: '`public=True`'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public=True`'
- en: '`private=True`'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private=True`'
- en: '`no_cache=True`'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_cache=True`'
- en: '`no_transform=True`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`no_transform=True`'
- en: '`must_revalidate=True`'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`must_revalidate=True`'
- en: '`proxy_revalidate=True`'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy_revalidate=True`'
- en: '`max_age=num_seconds`'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_age=num_seconds`'
- en: '`s_maxage=num_seconds`'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s_maxage=num_seconds`'
- en: For explanation of Cache-Control HTTP directives, see the Cache-Control specification
    (for more information visit [http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)).
    (Note that the caching middleware already sets the cache header's `max-age` with
    the value of the `CACHE_MIDDLEWARE_SECONDS` setting. If you use a custom `max_age`
    in a `cache_control` decorator, the decorator will take precedence, and the header
    values will be merged correctly.)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Cache-Control HTTP指令的解释，请参阅Cache-Control规范（有关更多信息，请访问[http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.9)）。
    （请注意，缓存中间件已经使用`CACHE_MIDDLEWARE_SECONDS`设置的值设置了缓存标头的`max-age`。如果您在`cache_control`装饰器中使用自定义的`max_age`，装饰器将优先，并且标头值将被正确合并。）
- en: 'If you want to use headers to disable caching altogether, `django.views.decorators.cache.never_cache`
    is a view decorator that adds headers to ensure the response won''t be cached
    by browsers or other caches. Example:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要使用标头完全禁用缓存，`django.views.decorators.cache.never_cache`是一个视图装饰器，它添加标头以确保响应不会被浏览器或其他缓存缓存。例如：
- en: '[PRE52]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: What's next?
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: In the next chapter, we will be looking at Django's middleware.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看一下Django的中间件。
