- en: '14'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '14'
- en: 'Application Integration: Combination'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用集成：组合
- en: The Python language is designed to permit extensibility. We can create sophisticated
    programs by combining a number of smaller components. In this chapter, we’ll look
    at ways to combine modules and scripts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言被设计成允许扩展性。我们可以通过组合多个较小的组件来创建复杂的程序。在本章中，我们将探讨组合模块和脚本的方法。
- en: We’ll look at the complications that can arise from composite applications and
    the need to centralize some features, like command-line parsing. This will enable
    us to create uniform interfaces for a variety of closely related programs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨复合应用可能出现的复杂性以及集中一些功能（如命令行解析）的需求。这将使我们能够为各种密切相关程序创建统一的接口。
- en: We’ll extend some of the concepts from Chapter [7](ch011_split_000.xhtml#x1-3760007)
    and Chapter [8](ch012.xhtml#x1-4520008), and apply the idea of the Command design
    pattern to Python programs. By encapsulating features in class definitions, we’ll
    find it easier to combine and extend programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展第7章和第8章的一些概念，并将命令设计模式的思想应用到Python程序中。通过在类定义中封装特性，我们将发现组合和扩展程序更容易。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下菜谱：
- en: '[Combining two applications into one](ch018.xhtml#x1-7590001)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将两个应用组合成一个](ch018.xhtml#x1-7590001)'
- en: '[Combining many applications using the Command design pattern](ch018.xhtml#x1-7670002)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用命令设计模式组合多个应用](ch018.xhtml#x1-7670002)'
- en: '[Managing arguments and configuration in composite applications](ch018.xhtml#x1-7730003)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在复合应用中管理参数和配置](ch018.xhtml#x1-7730003)'
- en: '[Wrapping and combining CLI applications](ch018.xhtml#x1-7790004)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[包装和组合CLI应用](ch018.xhtml#x1-7790004)'
- en: '[Wrapping a program and checking the output](ch018.xhtml#x1-7850005)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[包装程序并检查输出](ch018.xhtml#x1-7850005)'
- en: We’ll start with a direct approach to combining multiple Python applications
    into a single, more sophisticated application. We’ll expand this to apply object-oriented
    design techniques and create an even more flexible composite. Then, we’ll apply
    uniform command-line argument parsing for composite applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从将多个Python应用组合成一个更复杂的单一应用的方法开始。我们将扩展这一方法，应用面向对象设计技术，创建一个更加灵活的复合体。然后，我们将为复合应用应用统一的命令行参数解析。
- en: 14.1 Combining two applications into one
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.1 将两个应用组合成一个
- en: For this recipe, we’ll look at two scripts that need to be combined. One script
    emits data from a Markov chain process, and the second script summarizes those
    results.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将查看两个需要组合的脚本。一个脚本从马尔可夫链过程中输出数据，第二个脚本总结这些结果。
- en: What’s important here is the Markov chain application is (intentionally) a bit
    mysterious. For the purposes of several recipes, we’ll treat this as opaque software,
    possibly written in another language.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，马尔可夫链应用（故意）有点神秘。为了几个菜谱的目的，我们将将其视为不透明的软件，可能是用另一种语言编写的。
- en: (The GitHub repository for this book has the Markov chain written in Pascal
    to be reasonably opaque.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: （本书的GitHub仓库中用Pascal编写了马尔可夫链，以便合理地保持其透明度。）
- en: 'For reference, here’s a depiction of the Markov chain state changes:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对马尔可夫链状态变化的描述：
- en: '![SSFGp””””””tuaro00000nacioi.....orclwn21610tteUt21668en21773(dte””””—faist0ila.lb1
    o(l1rpi1oshpine—otd0i).n1t3)”9 ” ](img/file78.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![SSFGp””””””tuaro00000nacioi.....orclwn21610tteUt21668en21773(dte””””—faist0ila.lb1
    o(l1rpi1oshpine—otd0i).n1t3)”9 ” ](img/file78.png)'
- en: 'Figure 14.1: Markov chain states'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：马尔可夫链状态
- en: The Start state will either succeed, fail, or generate a ”point” value. There
    are a number of values, each with distinct probabilities that sum to P = 0.667\.
    The GrowUntil state generates values that may match the point, not match the point,
    or indicate failure. In the cases of a non-match and non-failure, the chain transitions
    back to this state. The exact probability of a match depends on the starting-point
    value, which is why the state transition is labeled with three probabilities.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 初始状态将成功、失败或生成一个“点”值。有多个值，每个值都有不同的概率，总和为P = 0.667。GrowUntil状态生成可能匹配点、不匹配点或指示失败的值。在非匹配和非失败的情况下，链会转回到此状态。匹配的确切概率取决于起始点值，这就是为什么状态转换被标记为三个概率的原因。
- en: 'The generator application emits a TOML-format file with some configuration
    details and a collection of individual samples. The file looks like this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器应用会输出一个包含一些配置细节和一系列单独样本的TOML格式文件。文件看起来像这样：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A summary application reads all of these generated files to create some simple
    statistics to describe the raw data. This summary was originally done with Jupyter
    Notebook. While these can be executed with the jupyter execute command, an alternative
    approach is to save the notebook as a script and then execute the script.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要应用读取所有这些生成的文件，创建一些简单的统计数据来描述原始数据。这个总结最初是用Jupyter Notebook完成的。虽然这些可以通过jupyter
    execute命令执行，但另一种方法是保存notebook为脚本，然后执行该脚本。
- en: 'We want to be able to combine this generator and the summary applications to
    reduce the manual steps in using the generator. There are several common approaches
    to combining multiple applications:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够将这个生成器和摘要应用结合起来，以减少使用生成器时的手动步骤。结合多个应用有几种常见的方法：
- en: A shell script can run the generator application and then run the summary application.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个shell脚本可以运行生成器应用，然后运行摘要应用。
- en: A Python program can implement the high-level operation, using the runpy module
    to run each of the two applications.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Python程序可以实现高级操作，使用runpy模块运行这两个应用中的每一个。
- en: We can build a composite application from the essential components of each application.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从每个应用的基本组件构建一个组合应用。
- en: In this recipe, we’ll look at the third path of combining the essential components
    of each application by writing a new composite application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将查看通过编写一个新的组合应用来结合每个应用基本组件的第三条路径。
- en: 14.1.1 Getting ready
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.1 准备工作
- en: In the [Designing scripts for composition](ch017.xhtml#x1-7410005) and [Using
    logging for control and audit output](ch017.xhtml#x1-7470006) recipes in Chapter [13](ch017.xhtml#x1-71500013),
    we followed a design pattern that separated the input gathering, the essential
    processing, and the production of output. The objective of that design pattern
    was to gather the interesting pieces together to combine and recombine them into
    higher-level constructs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[13](ch017.xhtml#x1-71500013)章的[设计组合脚本](ch017.xhtml#x1-7410005)和[使用日志进行控制和审计输出](ch017.xhtml#x1-7470006)配方中，我们遵循了一个设计模式，该模式将输入收集、基本处理和输出生产分离。该设计模式的目标是将有趣的片段收集在一起，以组合和重新组合成更高级的结构。
- en: Note that we have a tiny mismatch between the two applications. We can borrow
    a phrase from database engineering (and also electrical engineering) and call
    this an ”impedance mismatch.”
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个应用之间存在微小的不匹配。我们可以从数据库工程（以及电气工程）借用一个短语，称之为“阻抗不匹配”。
- en: 'When building this composite application, the impedance mismatch is a cardinality
    problem. The data generator process is designed to run more frequently than the
    statistical summary process. We have a couple of choices for addressing issues
    such as this one:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建这个组合应用时，阻抗不匹配是一个基数问题。数据生成过程设计为比统计总结过程运行得更频繁。我们有几个选择来解决这个问题：
- en: 'Total redesign: We can rewrite the generator to an iterator as desired, producing
    multiple sets of samples.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全重设计：我们可以将生成器重写为迭代器，按需生成多组样本。
- en: 'Add the iterator: We can build the composite application to do bulk data generation
    processing. After all the data is produced, the composite application can then
    summarize it.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加迭代器：我们可以构建一个组合应用来执行批量数据生成处理。所有数据生成完毕后，组合应用可以对其进行总结。
- en: The choice between these design alternatives depends on the user stories for
    this application. It may also depend on the established base of users. For this
    recipe, the users would like to follow the Add the iterator design to create a
    composite process without touching the underlying generator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些设计选择之间进行选择取决于这个应用的用户故事。它也可能取决于已经建立的用户基础。对于这个配方，用户希望遵循添加迭代器设计来创建一个组合过程，而不触及底层的生成器。
- en: 'Looking inside the two module implementation choices, we see two distinct design
    patterns for top-level applications:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看两个模块实现选择时，我们看到顶级应用有两个不同的设计模式：
- en: 'The markov_gen module has the following main() function definition:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: markov_gen模块有以下main()函数定义：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The markov_summ module, on the other hand, is a script, exported from a notebook.
    A direct Command-Line Interface (CLI) is not part of this script, and some rewriting
    is required. See the [Designing scripts for composition](ch017.xhtml#x1-7410005)
    recipe in Chapter [13](ch017.xhtml#x1-71500013) for details on this.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，markov_summ模块是一个脚本，从notebook导出。这个脚本不包含直接命令行界面（CLI），需要进行一些重写。有关详细信息，请参阅第[13](ch017.xhtml#x1-71500013)章的[设计组合脚本](ch017.xhtml#x1-7410005)配方。
- en: 'To create a more useful script, we need to add a def main(): line and indent
    the entire script inside the body of this function. At the end of the indented
    main() function, the if __name__ == "__main__": block can be added. Without creating
    a function that can be imported, the script is very difficult to test and integrate.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '为了创建一个更有用的脚本，我们需要添加一个 def main(): 行，并将整个脚本缩进到这个函数体内。在缩进的 main() 函数的末尾，可以添加
    if __name__ == "__main__": 块。如果没有创建一个可以被导入的函数，脚本将非常难以测试和集成。'
- en: 14.1.2 How to do it...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.2 如何实现...
- en: 'Import the other modules required:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的其它模块：
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Import the modules with the constituent applications. This is generally done
    after all standard library modules:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用构成应用的应用导入模块。这通常在所有标准库模块之后完成：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create a new function to combine the existing functions from the other applications.
    We’re including the iteration in this function to meet the expectation of generating
    1,000 sample files. It looks like this:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的函数来组合来自其他应用程序的现有函数。我们包括迭代在这个函数中，以满足生成 1,000 个样本文件的需求。它看起来像这样：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The overall problem statement has two parameters, with fixed values: the users
    would like 1,000 iterations of 1,000 samples. This provides a large collection
    of large files to work with. We can define command-line arguments with these values
    as defaults:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体问题有两个参数，具有固定值：用户希望有 1,000 次迭代，每次 1,000 个样本。这提供了大量的大文件来工作。我们可以定义带有这些值的默认值的命令行参数：
- en: '[PRE5]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For more on how to use the argparse module, see the recipes in Chapter [6](ch010.xhtml#x1-3300006).
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更多关于如何使用 argparse 模块的信息，请参阅第 6 章[6](ch010.xhtml#x1-3300006)中的食谱。
- en: 'The final report is sent to standard output, sys.stdout, by the print() function
    in the markov_summ application. This isn’t ideal, so we’ll use a contextlib context
    manager to redirect the output to a file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最终报告通过 markov_summ 应用程序中的 print() 函数发送到标准输出，sys.stdout。这并不理想，因此我们将使用 contextlib
    上下文管理器将输出重定向到文件：
- en: '[PRE6]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The combined functionality is now a new module with a function, main(), that
    we can invoke from a block of code like the following:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在的组合功能是一个新的模块，其中包含一个 main() 函数，我们可以从以下代码块中调用它：
- en: '[PRE7]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This gives us a combined application written entirely in Python. We can write
    unit tests for this composite, as well as for each of the two steps that make
    up the overall application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们得到了一个完全用 Python 编写的组合应用程序。我们可以为这个复合体编写单元测试，以及为构成整个应用程序的两个步骤编写测试。
- en: 14.1.3 How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.3 它是如何工作的...
- en: The central feature of this design is importing useful functionality from existing,
    working, and tested modules. This avoids the problems with copy-and-paste programming.
    Copying code from one file and pasting it into another means that any change made
    to one is unlikely to be made to any of the copies. As the various copies of a
    function slowly diverge, problems fixed in one place surface in another. This
    phenomenon is sometimes called code rot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计的核心特性是从现有的、工作良好且经过测试的模块中导入有用的功能。这避免了复制粘贴编程的问题。从一个文件复制代码并将其粘贴到另一个文件意味着对其中一个所做的任何更改都不太可能应用到任何副本上。随着函数的各种副本逐渐分化，在一个地方修复的问题会在另一个地方出现。这种现象有时被称为代码腐化。
- en: 'The copy-and-paste approach is made more complicated when a class or function
    does several things. Too many features reduces the potential for reuse. We summarize
    this as the Inverse Power Law of Reuse – the reusability of a class or function,
    R(c), is related to the inverse of the number of features in that class or function,
    F(c):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类或函数执行多项操作时，复制粘贴的方法会变得更加复杂。过多的特性会降低重用潜力。我们将此总结为重用逆幂律——一个类或函数的重用性，R(c)，与该类或函数中特性数量的倒数，F(c)，相关：
- en: '![ 1 R (c) ∝ F-(c) ](img/file79.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![ 1 R (c) ∝ F-(c) ](img/file79.png)'
- en: The idea of counting features depends, of course, on the level of abstraction.
    It can help to consider the processing that maps inputs to outputs. Too many input-process-output
    mappings will limit reuse.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 计数特性的想法当然取决于抽象级别。考虑将输入映射到输出的处理过程可能会有所帮助。过多的输入-处理-输出映射将限制重用。
- en: The SOLID design principles provide guidance for keeping components small and
    narrowly focused. These principles apply to applications as well as components.
    In particular, the Single Responsibility Principle suggests that an application
    should do one thing. It’s better to have many small applications – like bricks
    – that can easily be combined than to have one large application that’s an imponderable
    big ball of mud.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID 设计原则为保持组件小而专注提供指导。这些原则适用于应用程序以及组件。特别是，单一职责原则建议应用程序应该只做一件事。拥有许多小型应用程序（如砖块）并容易组合，比拥有一个庞大而难以理解的应用程序要好。
- en: 14.1.4 There’s more...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.4 更多...
- en: 'We’ll look at two additional areas of rework of the application:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨应用程序的两个额外重工作业区域：
- en: 'Structure: Using the top-level main() function treats each component as an
    opaque container. When trying to create a composite application, we may need to
    refactor the component modules to look for better organization of the features.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构：使用顶级 main() 函数将每个组件视为一个不透明的容器。在尝试创建复合应用程序时，我们可能需要重构组件模块以寻找更好的功能组织。
- en: 'Logging: When multiple applications are combined, the combined logging can
    become complicated. To improve observability, we may need to refactor the logging.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志：当多个应用程序组合在一起时，组合的日志可能会变得复杂。为了提高可观察性，我们可能需要重构日志。
- en: We’ll go through these in turn.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次进行这些操作。
- en: Structure
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构
- en: In some cases, it becomes necessary to rearrange software to expose useful features.
    For example, the main() function inside the markov_gen.py module relies on a write_samples()
    function. This function creates a single file with the required number of samples,
    which are (outcome, chain) two-tuples.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，重新排列软件以展示有用功能变得必要。例如，位于 markov_gen.py 模块内的 main() 函数依赖于 write_samples()
    函数。此函数创建一个包含所需数量样本的单个文件，这些样本是 (结果, 链) 两个元组。
- en: The input to the summary processing is a sequence of these (outcome, chain)
    two-tuples. The composite application doesn’t really need to process 1,000 separate
    files. It needs to process 1,000 collections of 1,000 two-tuples.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要处理的输入是这些 (结果, 链) 两个元组的序列。复合应用程序实际上不需要处理 1,000 个单独的文件。它需要处理 1,000 个包含 1,000
    个两个元组的集合。
- en: Doing the refactoring to expose this detail will make this feature available
    for the composite application. This can make the composite easier to understand
    and maintain.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对此细节进行重构以展示此功能，将使复合应用程序可用。这可以使复合应用程序更容易理解和维护。
- en: Logging
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录日志
- en: In the [Using logging for control and audit output](ch017.xhtml#x1-7470006)
    recipe in Chapter [13](ch017.xhtml#x1-71500013), we looked at how to use the logging
    module for control, audit, and error outputs. When we build a composite application,
    we’ll have to combine the logging features from each of the original applications.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [13](ch017.xhtml#x1-71500013) 章的 [使用日志进行控制和审计输出](ch017.xhtml#x1-7470006)
    菜单中，我们探讨了如何使用日志模块进行控制、审计和错误输出。当我们构建复合应用程序时，我们必须结合来自每个原始应用程序的日志功能。
- en: 'The logging configuration for a composite application needs to be examined
    carefully. If we don’t ensure that the logging configuration is done only once
    in the top-level application, then combining applications can lead to multiple,
    conflicting logging configurations. There are two approaches that a composite
    application can follow:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 复合应用程序的日志配置需要仔细检查。如果我们不确保在顶级应用程序中只进行一次日志配置，那么合并应用程序可能会导致多个、冲突的日志配置。复合应用程序可以遵循两种方法：
- en: The composite application manages the logging configuration. This may mean overwriting
    all previously defined loggers. This is the default behavior and can be stated
    explicitly via incremental = false in a TOML configuration document.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合应用程序管理日志配置。这可能意味着覆盖所有先前定义的日志记录器。这是默认行为，可以通过在 TOML 配置文档中明确 incremental = false
    来表示。
- en: The composite application can preserve other application loggers and merely
    modify the configuration. This is not the default behavior and requires including
    incremental = true in the TOML configuration document.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合应用程序可以保留其他应用程序的日志记录器，仅修改配置。这不是默认行为，需要在 TOML 配置文档中包含 incremental = true。
- en: The use of incremental configuration can be helpful when combining Python applications
    that don’t properly isolate the logging configuration into the __name__ == "__main__"
    block of code. It’s often easier to refactor logging configuration to put it into
    the top-level block of code; this permits the composite application to more simply
    configure logging for all of the components.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合Python应用程序，而这些应用程序没有正确地将日志配置隔离到代码块`__name__ == "__main__"`中时，使用增量配置可能会有所帮助。通常更容易重构日志配置，将其放入顶级代码块中；这允许复合应用程序更简单地配置所有组件的日志。
- en: 14.1.5 See also
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1.5 参见
- en: In the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe in
    Chapter [13](ch017.xhtml#x1-71500013), we looked at the core design pattern for
    a composable application.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[13](ch017.xhtml#x1-71500013)章的[设计用于组合的脚本](ch017.xhtml#x1-7410005)菜谱中，我们探讨了可组合应用程序的核心设计模式。
- en: Books and articles on Clean Architecture and Hexagonal Architecture can be very
    helpful. Titles on design patterns are also helpful, such as [Mastering Python
    Design Patterns – Third Edition](https://www.packtpub.com/en-de/product/mastering-python-design-patterns-9781837639618).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于清洁架构和六边形架构的书籍和文章可能非常有帮助。关于设计模式的标题也有帮助，例如[精通Python设计模式 - 第三版](https://www.packtpub.com/en-de/product/mastering-python-design-patterns-9781837639618)。
- en: 14.2 Combining many applications using the Command design pattern
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.2 使用命令设计模式组合多个应用程序
- en: Many complex suites of applications follow a design pattern similar to the one
    used by the Git program. There’s a base command, git, with a number of subcommands.
    These include git pull, git commit, and git push.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 许多复杂的应用程序套件遵循与Git程序使用的设计模式类似的设计。有一个基本命令git，以及多个子命令。这些包括git pull、git commit和git push。
- en: What’s central to this design is the idea of a collection of individual commands
    under a common parent command. Each of the various features of Git can be thought
    of as a separate subclass definition that performs a given function.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的核心是这样一个想法：在共同的父命令下，有一系列单独的命令。Git的每个不同功能都可以被视为一个执行特定功能的单独子类定义。
- en: 14.2.1 Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.1 准备工作
- en: We’ll build a composite application from two commands. This is based on the
    [Combining two applications into one](ch018.xhtml#x1-7590001) recipe from earlier
    in this chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从两个命令构建一个复合应用程序。这是基于本章前面提到的[将两个应用程序合并为一个](ch018.xhtml#x1-7590001)菜谱。
- en: These features are based on modules with names such as markov_gen, markov_summ,
    and markov_analysis. The idea is that we can restructure separate modules into
    a single class hierarchy following the Command design pattern.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能基于名为markov_gen、markov_summ和markov_analysis等模块。我们的想法是将单独的模块重构为一个遵循命令设计模式的单个类层次结构。
- en: 'There are two key ingredients to this design pattern:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式有两个关键要素：
- en: A client class depends only on the methods of the abstract superclass, Command.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端类只依赖于抽象超类Command的方法。
- en: Each individual subclass of the Command superclass has an identical interface.
    We can substitute any one of them for any other.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令超类的每个子类都具有相同的接口。我们可以用任何一个替换另一个。
- en: An overall application script can then create and execute any one of the Command
    subclasses.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整体应用程序脚本可以创建和执行Command子类中的任何一个。
- en: Note that any feature that can be wrapped into a class is a candidate for this
    design. Consequently, some rework to create a single Facade class is sometimes
    required for sprawling, poorly designed applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何可以封装成类的功能都是这个设计的候选者。因此，有时需要重新设计以创建一个单一的Facade类，这对于设计不良、扩展过度的应用程序是必要的。
- en: 14.2.2 How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.2 如何做...
- en: We’ll start by creating a superclass for all of the related commands. We’ll
    then extend that superclass for the subcommands that are part of the overall application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为所有相关命令创建一个超类。然后我们将扩展这个超类以包括整体应用程序中的子命令。
- en: 'Here’s the Command superclass:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是Command超类：
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It helps to rely on argparse.Namespace to provide a very flexible collection
    of options and arguments to each subclass.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 依赖于argparse.Namespace来为每个子类提供一个非常灵活的选项和参数集合是有帮助的。
- en: We’ll use this also in the Managing arguments and configuration in composite
    applications recipe in this chapter.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在本章的“在复合应用程序中管理参数和配置”菜谱中使用这个方法。
- en: 'Create a subclass of the Command superclass for the Generate class. This will
    wrap the processing and output from the example module in the execute() method
    of this class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为Generate类创建Command超类的子类。这将在这个类的execute()方法中封装示例模块的处理和输出：
- en: '[PRE9]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a subclass of the Command superclass for the Summarize class. For this
    class, we’ve wrapped the file creation and file processing into the execute()
    method of the class:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Summarize 类创建 Command 超类的子类。对于这个类，我们将文件创建和文件处理封装到类的 execute() 方法中：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The overall composite processing can be performed by the following main() function:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 整体组合处理可以通过以下main()函数执行：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We’ve created two commands: one is an instance of the Generate class, and the
    other is an instance of the Summarize class. These commands can be executed to
    provide a combined feature that both generates and summarizes data.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个命令：一个是Generate类的实例，另一个是Summarize类的实例。这些命令可以执行以提供生成和总结数据的组合功能。
- en: 14.2.3 How it works...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.3 它是如何工作的...
- en: Creating interchangeable, polymorphic classes for the various subcommands is
    a handy way to provide an extensible design. The Command design pattern strongly
    encourages each individual subclass to have an identical signature. Doing this
    makes it easier for the command subclasses to be created and executed. Also, new
    commands can be added that fit this pattern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为各种子命令创建可互换的多态类是一种提供可扩展设计的便捷方式。Command设计模式强烈鼓励每个单独的子类具有相同的签名。这样做使得创建和执行命令子类变得容易。此外，还可以添加符合此模式的新命令。
- en: One of the SOLID design principles is the Liskov Substitution Principle (LSP).
    It suggests any of the subclasses of the Command abstract class can be used in
    place of the parent class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID设计原则之一是Liskov替换原则（LSP）。它建议可以使用Command抽象类的任何子类来代替父类。
- en: Each Command instance has a consistent interface. The use of the Command design
    pattern makes it easy to be sure that Command subclasses can be interchanged with
    each other. The overall main() script can create instances of the Generate or
    Summarize classes. The substitution principle means that either instance can be
    executed because the interfaces are the same. This flexibility makes it easy to
    parse the command-line options and create an instance of either of the available
    classes. We can extend this idea and create sequences of individual command instances.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Command实例都有一个一致的接口。使用Command设计模式使得确保Command子类可以相互替换变得容易。整体main()脚本可以创建 Generate
    或 Summarize 类的实例。替换原则意味着任何实例都可以执行，因为接口是相同的。这种灵活性使得解析命令行选项并创建可用类之一的实例变得容易。我们可以扩展这个想法，创建单个命令实例的序列。
- en: 14.2.4 There’s more...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.4 更多...
- en: 'One of the more common extensions to this design pattern is to provide for
    composite commands. In the [Combining two applications into one](ch018.xhtml#x1-7590001)
    recipe, we showed one way to create composites. This is another way, based on
    defining a new Command class that implements a combination of existing Command
    class instances:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式的更常见扩展之一是提供组合命令。在[将两个应用程序合并为一个](ch018.xhtml#x1-7590001)的菜谱中，我们展示了创建组合的一种方法。这是另一种方法，基于定义一个新的Command类，该类实现了现有Command类实例的组合：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This class will accept other Command classes via the *commands parameter. From
    the classes, it will build the individual class instances.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本类将通过 *commands 参数接受其他 Command 类。从这些类中，它将构建单个类实例。
- en: 'We might use this CmdSequence class like this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能像这样使用这个CmdSequence类：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This design exposes some implementation details. In particular, the two class
    names and the intermediate x.csv file are details that seem superfluous.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计暴露了一些实现细节。特别是，两个类名和中间的x.csv文件似乎是多余的细节。
- en: 'We can create a slightly nicer subclass of the CmdSequence argument if we focus
    specifically on the two commands being combined. This will have an __init__()
    method that follows the pattern of other Command subclasses:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们专注于要组合的两个命令，我们可以创建一个稍微更好的 CmdSequence 子类。这个子类将有一个 __init__() 方法，遵循其他 Command
    子类的模式：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This class definition incorporates two other classes into the already defined
    CmdSequence class structure. The super().__init__() expression invokes the parent
    class initialization with the Generate and Summarize classes as argument values.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义将两个其他类整合到已经定义的 CmdSequence 类结构中。super().__init__() 表达式调用父类初始化，并将 Generate
    和 Summarize 类作为参数值。
- en: This provides a composite application definition that conceals the details of
    how a file is used to pass data from the first step to a subsequent step. This
    is purely a feature of the composite integration and doesn’t lead to any changes
    in either of the original applications that form the composite.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一个复合应用程序定义，它隐藏了如何使用文件从第一步传递数据到后续步骤的细节。这纯粹是复合集成的一个特性，不会导致构成复合的原应用程序中的任何变化。
- en: 14.2.5 See also
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2.5 参见
- en: In the [Designing scripts for composition](ch017.xhtml#x1-7410005) and [Using
    logging for control and audit output](ch017.xhtml#x1-7470006) recipes in Chapter [13](ch017.xhtml#x1-71500013),
    we looked at the constituent parts of this composite application.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[13](ch017.xhtml#x1-71500013)章的[设计用于组合的脚本](ch017.xhtml#x1-7410005)和[使用日志进行控制和审计输出](ch017.xhtml#x1-7470006)配方中，我们研究了这个复合应用程序的组成部分。
- en: In the [Combining two applications into one](ch018.xhtml#x1-7590001) recipe
    earlier in this chapter, we looked at the constituent parts of this composite
    application. In most cases, we’ll need to combine elements of all of these recipes
    to create a useful application.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面的[将两个应用程序组合成一个](ch018.xhtml#x1-7590001)配方中，我们研究了这个复合应用程序的组成部分。在大多数情况下，我们需要结合这些配方中的所有元素来创建一个有用的应用程序。
- en: We’ll often need to follow the [Managing arguments and configuration in composite
    applications](ch018.xhtml#x1-7730003) recipe, which comes next in this chapter.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将经常需要遵循[在复合应用程序中管理参数和配置](ch018.xhtml#x1-7730003)配方，该配方在本章的下一部分。
- en: For other advanced design patterns, see [Mastering Python Design Patterns –
    Third Edition](https://www.packtpub.com/en-de/product/mastering-python-design-patterns-9781837639618).
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于其他高级设计模式，请参阅[精通Python设计模式 – 第三版](https://www.packtpub.com/en-de/product/mastering-python-design-patterns-9781837639618)。
- en: 14.3 Managing arguments and configuration in composite applications
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.3 在复合应用程序中管理参数和配置
- en: When we have a complex suite (or system) of individual applications, they may
    share common features. The coordination of common features among many applications
    can become awkward. As a concrete example, imagine defining the various one-letter
    abbreviated options for command-line arguments. We might want all of our applications
    to use the -v option for verbose output. Ensuring that there are no conflicts
    among all the applications might require keeping some kind of master list of all
    options.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个复杂的单个应用程序套件（或系统）时，它们可能共享一些共同特性。在许多应用程序之间协调共同特性可能会变得尴尬。作为一个具体的例子，想象定义各种单字母缩略选项用于命令行参数。我们可能希望所有应用程序都使用-v选项进行详细输出。确保所有应用程序之间没有冲突可能需要保留所有选项的某种主列表。
- en: This kind of common configuration should be kept in only one place. Ideally,
    it would be in a common module, used throughout a family of applications.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这种常见的配置应该只保留在一个地方。理想情况下，它将是一个通用模块，在整个应用程序系列中使用。
- en: Additionally, we often want to divorce the modules that perform useful work
    from the CLI. This lets us refactor the internal software design without changing
    the user’s understanding of how to use the application.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们通常希望将执行有用工作的模块与CLI分离。这让我们可以在不改变用户对如何使用应用程序的理解的情况下重构内部软件设计。
- en: In this recipe, we’ll look at ways to ensure that a suite of applications can
    be refactored without creating unexpected changes to the CLI.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨确保一系列应用程序可以重构而不会对CLI造成意外变化的方法。
- en: 14.3.1 Getting ready
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3.1 准备工作
- en: 'We’ll imagine an application suite built from three commands. This is based
    on the applications shown in the [Combining two applications into one](ch018.xhtml#x1-7590001)
    recipe earlier in this chapter. We’ll have a markov application with three subcommands:
    markov generate, markov summarize, and the combined application, markov gensumm.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想象一个由三个命令构建的应用程序套件。这是基于本章前面提到的[将两个应用程序组合成一个](ch018.xhtml#x1-7590001)配方中的应用程序。我们将有一个马尔可夫应用程序，具有三个子命令：马尔可夫 generate、马尔可夫 summarize以及组合应用程序，马尔可夫 gensumm。
- en: 'We’ll rely on the subcommand design from the Combining many applications using
    the Command design pattern recipe earlier in this chapter. This will provide a
    handy hierarchy of Command subclasses:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖于本章前面提到的使用命令设计模式配方组合多个应用程序的子命令设计。这将提供一个方便的命令子类层次结构：
- en: The Command class is an abstract superclass.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令类是一个抽象超类。
- en: The Generate subclass performs the chain-generating functions from Chapter [13](ch017.xhtml#x1-71500013)
    recipe the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成子类执行第 13 章配方中的链生成函数，即 [设计用于组合的脚本](ch017.xhtml#x1-7410005) 配方。
- en: The Summarize subclass performs summarizing functions from Chapter [13](ch017.xhtml#x1-71500013)
    recipe the Using logging for control and audit output recipe.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Summarize 子类执行第 13 章配方中的总结函数，即 [使用日志进行控制和审计输出](ch017.xhtml#x1-71500013) 配方。
- en: A GenSumm subclass can perform combined chain generation and summarization,
    following the ideas of the [Combining many applications using the Command design
    pattern](ch018.xhtml#x1-7670002) recipe.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GenSumm 子类可以执行结合链生成和总结，遵循 [使用命令设计模式组合多个应用](ch018.xhtml#x1-7670002) 配方的理念。
- en: In order to create a simple command-line application, we’ll need appropriate
    argument parsing. For more on argument parsing, see Chapter [6](ch010.xhtml#x1-3300006).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个简单的命令行应用程序，我们需要适当的参数解析。有关参数解析的更多信息，请参阅第 6 章 [6](ch010.xhtml#x1-3300006)。
- en: This argument parsing will rely on the subcommand-parsing capability of the
    built-in argparse module. We can create a common set of command options that apply
    to all subcommands. We can also create unique options for each of the distinct
    subcommands.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数解析将依赖于内置 argparse 模块的子命令解析能力。我们可以创建适用于所有子命令的通用命令选项集。我们还可以为每个不同的子命令创建独特选项。
- en: 14.3.2 How to do it...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3.2 如何做到...
- en: This recipe will start with a consideration of what the CLI commands need to
    look like. A first release often involves some prototypes or examples to be sure
    that the commands are truly useful to the user. After learning the user’s preferences,
    we can change how we implement the argument definitions in each of the Command
    subclasses.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将从考虑 CLI 命令的外观开始。第一个版本通常涉及一些原型或示例，以确保命令真正对用户有用。在了解用户的偏好后，我们可以更改在每个命令子类中实现参数定义的方式。
- en: 'Define the CLI. This is an exercise in User Experience (UX) design. While a
    great deal of UX design is focused on web and mobile device applications, the
    core principles are appropriate for CLI applications as well. Earlier, we noted
    that the root application will be called markov. It will have the following three
    subcommands:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 CLI。这是一个用户体验（UX）设计练习。虽然大量的 UX 设计集中在网页和移动设备应用上，但核心原则也适用于 CLI 应用。之前我们提到，根应用将被命名为
    markov。它将包含以下三个子命令：
- en: '[PRE15]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The gensumm command combines the generate and summarize commands into a single
    operation that does both.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: gensumm 命令将生成和总结命令合并为单个操作，执行两项功能。
- en: Define the root Python application. We’ll call it markov.py. It’s common to
    have a package __main__.py file that contains the application. It’s often simpler
    to use an OS alias to provide the UX name.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义根 Python 应用程序。我们将它命名为 markov.py。通常有一个包含应用的包 __main__.py 文件。使用操作系统别名提供 UX 名称通常更简单。
- en: 'We’ll import the class definitions from the [Combining many applications using
    the Command design pattern](ch018.xhtml#x1-7670002) recipe. This will include
    the Command superclass and the Generate, Summarize, and GenSumm subclasses. We’ll
    extend the Command class with an additional method, arguments(), to set the unique
    options in the argument parser for this command. This is a class method and is
    called on the class as a whole, not an instance of the class:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将从 [使用命令设计模式组合多个应用](ch018.xhtml#x1-7670002) 配方中导入类定义。这包括命令超类以及 Generate、Summarize
    和 GenSumm 子类。我们将通过添加一个额外的 arguments() 方法来扩展 Command 类，以设置此命令参数解析中的独特选项。这是一个类方法，在整个类上调用，而不是类的实例：
- en: '[PRE16]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here are the unique options for the generate subcommand. We won’t repeat the
    entire class definition, only the new arguments() method. This creates arguments
    that are unique to the markov generate subcommand:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是生成子命令的独特选项。我们不会重复整个类定义，只重复新的 arguments() 方法。这创建了仅适用于 markov 生成子命令的独特参数：
- en: '[PRE17]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is the new arguments() method of the Summarize subcommand:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是 Summarize 子命令的新 arguments() 方法：
- en: '[PRE18]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here is the new arguments() method for the composite command, GenSumm:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是复合命令 GenSumm 的新 arguments() 方法：
- en: '[PRE19]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create the overall argument parser. Use this to create a subparser builder.
    For each subcommand, create a subparser and add arguments that are unique to that
    command:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建整体参数解析器。使用它来创建子解析器构建器。对于每个子命令，创建一个子解析器并添加仅适用于该命令的独特参数：
- en: '[PRE20]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Parse the command-line values. In most cases, the argument definitions include
    validation rules. In this case, there’s an additional validation check to make
    sure a command was provided. Here are the final parsing and validating steps:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析命令行值。在大多数情况下，参数定义包括验证规则。在这种情况下，还有一个额外的验证检查以确保提供了一个命令。以下是最终的解析和验证步骤：
- en: '[PRE21]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The overall parser includes three subcommand parsers. One will handle the markov
    generate command, another handles markov summarize, and the third handles a combined
    markov gensumm. Each subcommand has slightly different combinations of options.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 整体解析器包括三个子命令解析器。一个将处理markov generate命令，另一个处理markov summarize，第三个处理combined markov
    gensumm。每个子命令都有略微不同的选项组合。
- en: The command option is set via the set_defaults() method. This also provides
    useful additional information about the command to be executed. In this case,
    we’ve provided the class that must be instantiated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 命令选项是通过set_defaults()方法设置的。这也为要执行的命令提供了有用的附加信息。在这种情况下，我们提供了必须实例化的类。
- en: 'The overall application is defined by the following main() function:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序由以下main()函数定义：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The resulting object will have an execute() method that does the real work of
    this command.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的对象将有一个execute()方法，它执行这个命令的实际工作。
- en: 14.3.3 How it works...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3.3 它是如何工作的...
- en: 'There are two parts to this recipe:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方有两个部分：
- en: Using the Command design pattern to define a related set of classes that are
    polymorphic. For more information on this, see the [Combining many applications
    using the Command design pattern](ch018.xhtml#x1-7670002) recipe.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Command设计模式定义一组相关的类，这些类是多态的。有关更多信息，请参阅[使用Command设计模式组合多个应用程序](ch018.xhtml#x1-7670002)配方。
- en: Using features of the argparse module to handle subcommands.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用argparse模块的功能来处理子命令。
- en: The argparse module feature that’s important here is the add_subparsers() method
    of a parser. This method returns an object to build each distinct subcommand parser.
    We assigned this object to the subparsers variable.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里重要的argparse模块功能是解析器的add_subparsers()方法。这个方法返回一个对象来构建每个不同的子命令解析器。我们将这个对象分配给了subparsers变量。
- en: We also used the set_defaults() method of a parser to add a command argument
    to each of the subparsers. This argument will be populated by the defaults defined
    for one of the subparsers. The value assigned by the set_defaults() method actually
    used will show which of the subcommands was invoked.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了解析器的set_defaults()方法为每个子解析器添加一个命令参数。这个参数将由一个子解析器定义的默认值填充。set_defaults()方法实际使用的赋值将显示调用了哪个子命令。
- en: 'Consider the following OS command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下操作系统命令：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This command will be parsed to create a Namespace object that looks like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将被解析以创建一个类似于以下内容的Namespace对象：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The command attribute in the Namespace object is the default value provided
    as part of the subcommand definition. The values for output and samples come from
    the -o and -g options.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Namespace对象中的command属性是作为子命令定义的一部分提供的默认值。输出和样本的值来自-o和-g选项。
- en: 14.3.4 There’s more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3.4 更多...
- en: 'The get_options() function has an explicit list of classes that it incorporates
    into the overall command. As shown, a number of lines of code are repeated, and
    this could be optimized. We can provide a data structure that replaces a number
    of lines of code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: get_options()函数有一个显式的类列表，它被整合到整体命令中。如所示，有大量的代码行被重复，这可以被优化。我们可以提供一个数据结构来替换大量的代码行：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This variation on the get_options() function uses a sequence of two-tuples to
    provide the command name and the relevant class to implement the command. Iterating
    through this list ensures that all of the various subclasses of the Command class
    are processed in a perfectly uniform manner.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对get_options()函数的变体使用一系列的二元组来提供命令名称和实现该命令的相关类。遍历这个列表确保Command类的所有各种子类都以完全统一的方式被处理。
- en: 14.3.5 See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3.5 参见
- en: See the [Designing scripts for composition](ch017.xhtml#x1-7410005) and [Using
    logging for control and audit output](ch017.xhtml#x1-7470006) recipes in Chapter [13](ch017.xhtml#x1-71500013)
    for the basics of building applications focused on being composable.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第[13](ch017.xhtml#x1-71500013)章中的[设计用于组合的脚本](ch017.xhtml#x1-7410005)和[使用日志进行控制和审计输出](ch017.xhtml#x1-7470006)配方，以了解专注于可组合性应用程序构建的基础。
- en: See the [Combining two applications into one](ch018.xhtml#x1-7590001) recipe
    from earlier in this chapter for the background on the components used in this
    recipe.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅本章前面提到的[将两个应用程序合并为一个](ch018.xhtml#x1-7590001)配方，以了解本配方中使用的组件的背景信息。
- en: See the [Using argparse to get command-line input](ch010.xhtml#x1-3490004) recipe
    in Chapter [6](ch010.xhtml#x1-3300006) for more on the background of argument
    parsing.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅第[6](ch010.xhtml#x1-3300006)章的[使用argparse获取命令行输入](ch010.xhtml#x1-3490004)配方，了解更多关于参数解析的背景信息。
- en: Other tools for creating CLIs include [click](https://click.palletsprojects.com/en/8.1.x/),
    [hydra](https://hydra.cc/docs/intro/), and [invoke](https://www.pyinvoke.org).
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他用于创建CLIs的工具包括[click](https://click.palletsprojects.com/en/8.1.x/)、[hydra](https://hydra.cc/docs/intro/)和[invoke](https://www.pyinvoke.org)。
- en: 14.4 Wrapping and combining CLI applications
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.4 包装和组合CLI应用程序
- en: One common kind of automation involves running several programs, some of which
    are not Python applications. This commonly arises when integrating multiple tools,
    which are often applications used to build applications or documents. Since the
    programs aren’t written in Python, it’s impossible to refactor each program to
    create a composite Python application. When using a non-Python application, we
    can’t follow the [Combining two applications into one](ch018.xhtml#x1-7590001)
    recipe shown earlier in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的自动化类型涉及运行多个程序，其中一些不是Python应用程序。这种情况通常出现在集成多个工具时，这些工具通常是用于构建应用程序或文档的应用程序。由于程序不是用Python编写的，因此不可能对每个程序进行重构以创建一个复合Python应用程序。当使用非Python应用程序时，我们无法遵循本章前面展示的[将两个应用程序合并为一个](ch018.xhtml#x1-7590001)的配方。
- en: 'Instead of aggregating the Python components, an alternative is to wrap the
    other programs in Python, creating a composite application. The use case is very
    similar to the use case for writing a shell script. The difference is that Python
    is used instead of a shell language. Using Python has some advantages:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代替聚合Python组件，另一种选择是将其他程序用Python包装起来，创建一个复合应用程序。这种用例与编写shell脚本的用例非常相似。区别在于使用Python而不是shell语言。使用Python有一些优点：
- en: Python has a rich collection of data structures. Most shell languages are limited
    to strings and arrays of strings.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python拥有丰富的数据结构集合。大多数shell语言仅限于字符串和字符串数组。
- en: Python has several outstanding unit test frameworks. Rigorous unit testing gives
    us confidence that the combined application will work as expected.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python有几个出色的单元测试框架。严格的单元测试使我们确信组合的应用程序将按预期工作。
- en: In this recipe, we’ll look at how we can run other applications from within
    Python.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何在Python内部运行其他应用程序。
- en: 14.4.1 Getting ready
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4.1 准备工作
- en: In the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe in
    Chapter [13](ch017.xhtml#x1-71500013), we identified an application that did some
    processing that led to the creation of a rather complex result. For the purposes
    of this recipe, we’ll assume that the application is not written in Python.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在第[13](ch017.xhtml#x1-71500013)章的[设计用于组合的脚本](ch017.xhtml#x1-7410005)配方中，我们确定了一个进行了一些处理并导致产生相当复杂结果的应用程序。为了本配方的目的，我们假设该应用程序不是用Python编写的。
- en: We’d like to run this program several thousand times, but we don’t want to copy
    and paste the necessary commands into a script. Also, because the shell is difficult
    to test and has so few data structures, we’d like to avoid using the shell.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望运行这个程序数千次，但不想将必要的命令复制粘贴到脚本中。此外，由于shell难以测试并且数据结构很少，我们希望避免使用shell。
- en: 'For this recipe, we’ll work with an application as if it were a native binary
    application, written in Rust, Go, or Pascal. There are two ways to explore this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将以一个原生二进制应用程序（用Rust、Go或Pascal编写）的方式与一个应用程序合作。有两种方法可以探索这一点：
- en: The markov_gen.pas file in this book’s Git repository can be used to build a
    working, native binary application. The Free Pascal Compiler project ( [https://www.freepascal.org](https://www.freepascal.org))
    has compilers for a large number of platforms.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书Git仓库中的markov_gen.pas文件可以用来构建一个工作原生的二进制应用程序。Free Pascal Compiler项目（[https://www.freepascal.org](https://www.freepascal.org)）为大量平台提供了编译器。
- en: Another common situation is the need to execute a Jupyter notebook using the
    jupyter execute command. We can’t directly import a notebook, but must execute
    it via a separate command.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个常见的情况是需要使用jupyter execute命令执行一个Jupyter笔记本。我们无法直接导入笔记本，但必须通过一个单独的命令来执行它。
- en: 'Another alternative that can help with exploring these design alternatives
    is to make a Python application behave like a binary executable by adding a shebang
    line as the first line in the file. In many cases, the following can be used as
    the first line of a Python script:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可以帮助探索这些设计选择的替代方案是让Python应用程序表现得像一个二进制可执行文件，通过在文件的第一行添加一个shebang行来实现。在许多情况下，以下内容可以用作Python脚本的第一行：
- en: '[PRE26]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For macOS and Linux, use the following to change the mode of the file to executable:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于macOS和Linux，使用以下命令更改文件的模式为可执行：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Working with a native binary application means that we can’t import a Python
    module that comprises the application. Instead, the application is run as a separate
    OS process. This limits interaction to command-line argument values and OS environment
    variables.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生二进制应用程序一起工作意味着我们无法导入包含应用程序的Python模块。相反，应用程序作为单独的OS进程运行。这限制了交互仅限于命令行参数值和OS环境变量。
- en: 'To run a native binary application, we use the subprocess module. There are
    two common design patterns for running another program from within Python:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行原生二进制应用程序，我们使用subprocess模块。在Python中运行另一个程序有两种常见的设计模式：
- en: The other program doesn’t produce any output, or we don’t want to gather the
    output in our Python program. The first situation is typical of OS utilities that
    return a status code when they succeed or fail. The second situation is typical
    of programs that update files and produce logs.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个程序不产生任何输出，或者我们不想在我们的Python程序中收集输出。第一种情况是典型的OS实用程序，当它们成功或失败时返回状态码。第二种情况是典型的更新文件并生成日志的程序。
- en: The other program produces the output; the Python wrapper needs to capture and
    process it. This may happen when the Python wrapper needs to take extra actions
    to clean up or retry in the event of failure.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个程序产生输出；Python包装器需要捕获并处理它。这可能发生在Python包装器需要采取额外措施来清理或重试失败的情况下。
- en: 'In this recipe, we’ll look at the first case: the output isn’t something we
    need to capture. In the [Wrapping a program and checking the output](ch018.xhtml#x1-7850005)
    recipe, we’ll look at the second case, where the output will be scrutinized by
    the Python wrapper program.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨第一个案例：输出不是我们需要捕获的内容。在[包装程序并检查输出](ch018.xhtml#x1-7850005)菜谱中，我们将探讨第二个案例，其中输出将由Python包装程序仔细检查。
- en: In many cases, one benefit of wrapping an existing application with Python is
    the ability to dramatically rethink the UX. This lets us redesign the CLI to better
    fit the user’s needs.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，使用Python包装现有应用程序的一个好处是能够彻底重新思考UX。这让我们能够重新设计CLI，使其更好地满足用户的需求。
- en: 'Let’s look at wrapping a program that’s normally started with the src/ch14/markov_gen
    command. Here’s an example:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何包装通常使用src/ch14/markov_gen命令启动的程序。以下是一个示例：
- en: '[PRE28]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output filename needs to be flexible so that we can run the program hundreds
    of times. This is often done by interpolating a sequence number into the filename.
    For example, f"data/ch14/samples_{n}.csv" would be used in Python to create unique
    filenames.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出文件名需要灵活，这样我们就可以运行程序数百次。这通常是通过将序列号插入文件名中实现的。例如，在Python中使用f"data/ch14/samples_{n}.csv"来创建唯一的文件名。
- en: 14.4.2 How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4.2 如何实现...
- en: 'In this recipe, we’ll start by creating a small demonstration application.
    This is a spike solution ( [https://wiki.c2.com/?SpikeSolution](https://wiki.c2.com/?SpikeSolution)).
    This will be used to be sure we understand how the other application works. Once
    we have the correct OS command, we can wrap this in a function call to make it
    easier to use:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将首先创建一个小型演示应用程序。这是一个峰值解决方案（[https://wiki.c2.com/?SpikeSolution](https://wiki.c2.com/?SpikeSolution)）。这将用来确保我们理解其他应用程序的工作方式。一旦我们有了正确的OS命令，我们就可以将其包装在函数调用中，使其更容易使用：
- en: 'Import the argparse and subprocess modules and the Path class. We’ll also need
    the sys module:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入argparse、subprocess模块和Path类。我们还需要sys模块：
- en: '[PRE29]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Write the core processing using the subprocess module to invoke the target
    application. This can be tested separately to ensure it can execute the application.
    In this case, subprocess.run() will execute the given command, and the check=True
    option will raise an exception if the status is non-zero. Here’s the spike solution
    that demonstrates the essential processing:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用subprocess模块调用目标应用程序来编写核心处理。这可以单独测试以确保它可以执行应用程序。在这种情况下，subprocess.run()将执行给定的命令，并且如果状态非零，check=True选项将引发异常。以下是一个演示基本处理的峰值解决方案：
- en: '[PRE30]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This minimal spike can be run to make sure things work before proceeding to
    refactor the spike into something more useful.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个最小峰值可以运行以确保一切正常，然后再对峰值进行重构，使其更有用。
- en: 'Wrap the spike solution in a function that reflects the desired behavior. The
    processing looks like this:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将峰值解决方案封装在一个反映所需行为的函数中。处理过程如下：
- en: '[PRE31]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Write a function to parse the command-line options. In this case, there are
    two positional parameters: a directory and a number of chain samples to generate.
    The function looks like this:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个解析命令行选项的函数。在这种情况下，有两个位置参数：一个目录和要生成的链样本数量。该函数如下所示：
- en: '[PRE32]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Write a main function to do the parsing and processing:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个主函数来进行解析和处理：
- en: '[PRE33]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We now have a function that’s testable using any of the Python unit-testing
    frameworks. This can give us real confidence that we have a reliable application
    built around an existing non-Python application.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个可以使用任何 Python 单元测试框架进行测试的函数。这可以让我们对基于现有非 Python 应用程序构建的可靠应用程序有真正的信心。
- en: 14.4.3 How it works...
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4.3 它是如何工作的...
- en: The subprocess module is how Python runs other programs. The run() function
    does a number of things for us.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: subprocess 模块是 Python 运行其他程序的方式。run() 函数为我们做了很多事情。
- en: 'In a POSIX (such as Linux or macOS) context, the steps are similar to the following
    sequence:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX（如 Linux 或 macOS）环境中，步骤类似于以下序列：
- en: Prepare the stdin, stdout, and stderr file descriptors for the child process.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备子进程的 stdin、stdout 和 stderr 文件描述符。
- en: Invoke a function like the os.execve() function to start the child process.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用一个类似于 os.execve() 函数的函数来启动子进程。
- en: Wait for the child process to finish and collect the final status.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待子进程完成并收集最终状态。
- en: An OS shell, such as bash, conceals these details from application developers
    and users. The subprocess.run() function, similarly, hides the details of creating
    and waiting for a child process.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统 shell（如 bash）隐藏了这些细节，不让应用程序开发者和用户知道。同样，subprocess.run() 函数也隐藏了创建和等待子进程的细节。
- en: Using the subprocess module to run a separate executable allows Python to integrate
    a wide variety of software components into a unified whole. Using Python offers
    a much richer collection of data structures than the shell, proper exception handling
    instead of checking the final status code, and a way to unit test.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 subprocess 模块运行独立的可执行文件，允许 Python 将各种软件组件集成到一个统一的整体中。使用 Python 提供的数据结构集合比
    shell 更丰富，提供了适当的异常处理而不是检查最终状态码，以及单元测试的方法。
- en: 14.4.4 There’s more...
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4.4 更多内容...
- en: We’ll add a simple clean-up feature to this script. The idea is that all of
    the output files should be created as an atomic operation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向这个脚本添加一个简单的清理功能。想法是所有输出文件都应该作为一个原子操作创建。
- en: 'In order to clean up, we’ll need to wrap the core processing in a try: block.
    We’ll write a second function, make_files_clean(), that uses the original make_files()
    function to include a clean-up feature. A new overall function, make_files_clean(),
    would look like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '为了清理，我们需要将核心处理封装在 try: 块中。我们将编写第二个函数，make_files_clean()，它使用原始的 make_files()
    函数来包含清理功能。新的整体函数 make_files_clean() 将如下所示：'
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The exception-handling block does two things. First, it removes any incomplete
    files from the current working directory. Second, it re-raises the original exception
    so that the failure will propagate to the client application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 异常处理块执行两项操作。首先，它从当前工作目录中删除任何不完整的文件。其次，它重新抛出原始异常，以便失败会传播到客户端应用程序。
- en: Any test cases for this application would need to make use of mock objects.
    See the [Mocking external resources](ch019_split_001.xhtml#x1-85500010) recipe
    in Chapter [15](ch019_split_000.xhtml#x1-79400015).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个应用程序的任何测试用例都需要使用模拟对象。请参阅第 [15](ch019_split_000.xhtml#x1-79400015) 章中的 [模拟外部资源](ch019_split_001.xhtml#x1-85500010)
    菜谱。
- en: 14.4.5 See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.4.5 参见
- en: This kind of automation is often combined with other Python processing. See
    the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe in Chapter [13](ch017.xhtml#x1-71500013).
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种自动化通常与其他 Python 处理结合使用。请参阅第 [13](ch017.xhtml#x1-71500013) 章中的 [设计用于组合的脚本](ch017.xhtml#x1-7410005)
    菜谱。
- en: The goal is often to create a composite application; see the [Managing arguments
    and configuration in composite applications](ch018.xhtml#x1-7730003) recipe earlier
    in this chapter.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标通常是创建一个组合应用程序；请参阅本章前面提到的 [在组合应用程序中管理参数和配置](ch018.xhtml#x1-7730003) 菜谱。
- en: For a variation on this recipe, see the [Wrapping a program and checking the
    output](ch018.xhtml#x1-7850005) recipe, which is up next in this chapter.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于这个配方的变体，请参阅本章接下来的 [包装程序并检查输出](ch018.xhtml#x1-7850005) 配方。
- en: 14.5 Wrapping a program and checking the output
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14.5 包装程序并检查输出
- en: One common kind of automation involves wrapping a program. The advantage of
    a Python wrapper is the ability to perform detailed aggregation and analysis of
    the output files. A Python program might transform, filter, or summarize the output
    from a subprocess.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的自动化类型涉及包装程序。Python 包装器的优点是能够对输出文件进行详细的聚合和分析。Python 程序可能对子进程的输出进行转换、过滤或总结。
- en: In this recipe, we’ll see how to run other applications from within Python,
    and collect and process the output.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将了解如何在 Python 中运行其他应用，并收集和处理输出。
- en: 14.5.1 Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5.1 准备工作
- en: In the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe in
    Chapter [13](ch017.xhtml#x1-71500013), we identified an application that did some
    processing, leading to the creation of a rather complex result. We’d like to run
    this program several hundred times, but we don’t want to copy and paste the necessary
    commands into a script. Also, because the shell is difficult to test and has so
    few data structures, we’d like to avoid using the shell.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [13](ch017.xhtml#x1-71500013) 章的 [设计脚本以进行组合](ch017.xhtml#x1-7410005) 配方中，我们确定了一个进行了一些处理的应用，导致创建了一个相当复杂的结果。我们希望运行这个程序几百次，但不想将必要的命令复制粘贴到脚本中。此外，由于
    shell 难以测试并且数据结构很少，我们希望避免使用 shell。
- en: 'For this recipe, we’ll work with a native binary application written in some
    compiled language like Ada, Fortran, or Pascal. This means that we can’t simply
    import the Python module that comprises the application. Instead, we’ll have to
    execute this application by running a separate OS process with the subprocess
    module. There are two common use cases for running another binary program from
    within Python:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用用某些编译语言（如 Ada、Fortran 或 Pascal）编写的本地二进制应用。这意味着我们无法简单地导入包含该应用的 Python
    模块。相反，我们将通过使用 subprocess 模块运行一个单独的操作系统进程来执行此应用。在 Python 中运行另一个二进制程序有两个常见的用例：
- en: Either there isn’t any output, or we don’t want to process the output file in
    our Python program.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要么没有输出，要么我们不希望在我们的 Python 程序中处理输出文件。
- en: We need to capture and possibly analyze the output to retrieve information or
    ascertain the level of success. We might need to transform, filter, or summarize
    the log output.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要捕获并可能分析输出以检索信息或确定成功的程度。我们可能需要转换、过滤或总结日志输出。
- en: 'In this recipe, we’ll look at the second case: the output must be captured
    and summarized. In the [Wrapping and combining CLI applications](ch018.xhtml#x1-7790004)
    recipe in this chapter, we looked at the first case, where the output is simply
    ignored.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨第二种情况：必须捕获和总结输出。在本章的 [包装和组合 CLI 应用](ch018.xhtml#x1-7790004) 配方中，我们探讨了第一种情况，即输出被简单地忽略。
- en: 'Here’s an example of running the markov_gen application:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个运行 markov_gen 应用的示例：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There were three lines of output written to the OS standard output file, all
    starting with #. These show the file being created, the number of samples, and
    the random number generator seed being used. This output is confirmation the data
    was correctly created.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '有三条输出行被写入到操作系统标准输出文件中，所有都是以 # 开头的。这些显示了正在创建的文件、样本数量以及正在使用的随机数生成器种子。这是数据正确创建的确认。'
- en: We want to capture the details of these lines from this application and summarize
    them. The total of all the generated samples should match the number of samples
    summarized, confirming that all of the data was processed.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从该应用中捕获这些行的详细信息并进行总结。所有生成的样本总数应与总结的样本数相匹配，以确认所有数据都已处理。
- en: 14.5.2 How to do it...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5.2 如何做...
- en: We’ll start by creating a spike solution ( [https://wiki.c2.com/?SpikeSolution](https://wiki.c2.com/?SpikeSolution))
    to confirm the command and arguments needed to run another application. We’ll
    transform the spike solution into a function that captures output for further
    analysis.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个尖峰解决方案（[https://wiki.c2.com/?SpikeSolution](https://wiki.c2.com/?SpikeSolution)）来确认运行另一个应用所需的命令和参数。我们将把这个尖峰解决方案转换成一个函数，以捕获输出以供进一步分析。
- en: 'Import the argparse and subprocess modules and the Path class. We’ll also need
    the sys module and the Any type hint:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 argparse 和 subprocess 模块以及 Path 类。我们还需要 sys 模块和 Any 类型提示：
- en: '[PRE36]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Write the core processing, using the subprocess module to invoke the target
    application. Here’s a spike solution that demonstrates the essential processing:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写核心处理，使用子进程模块调用目标应用程序。以下是一个演示基本处理的实验解决方案：
- en: '[PRE37]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This spike does two things: it builds a complicated command line for a subprocess
    and it also collects the output from the subprocess. A temporary file allows the
    subprocess module to run a process that creates a very large file.'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个实验做了两件事：它为子进程构建了一个复杂的命令行，并收集了子进程的输出。一个临时文件允许子进程模块运行创建一个非常大文件的进程。
- en: The idea is to create a script with this minimal spike and be sure things work
    before proceeding to refactor the spike into something more useful.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 策略是创建一个具有这种最小实验的脚本，确保一切正常后再进行重构，使其变得更有用。
- en: 'Refactor the spike to create a function that runs a command and collects the
    output. Here’s a command_output() function:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重构代码以创建一个运行命令并收集输出的函数。以下是一个`command_output()`函数的示例：
- en: '[PRE38]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Refactor the rest of the spike into a function to generate the commands. It
    makes sense for this function to be a generator so it can create a collection
    of similar commands.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实验的其余部分重构为生成命令的函数。这个函数作为生成器是有意义的，因为它可以创建一系列类似的命令。
- en: '[PRE39]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Define a function to parse the expected output from a command. We’ll decompose
    the parsing into a sequence of generators that create regular expression Match
    objects, extract the matched groups, and build a final dictionary reflecting the
    content. The function can look like this:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数来解析命令的预期输出。我们将解析分解为一系列生成器，这些生成器创建正则表达式匹配对象，提取匹配的组，并构建反映内容的最终字典。该函数可能看起来像这样：
- en: '[PRE40]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here’s the high-level function to extract useful information from the command
    output. The generator function looks like this:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是提取命令输出中有用信息的高级函数。生成器函数看起来像这样：
- en: '[PRE41]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This function will use a stack of generator expressions. For more background,
    see the [Using stacked generator expressions](ch013_split_000.xhtml#x1-5180003)recipe
    in Chapter [9](ch013_split_000.xhtml#x1-5020009). Since these are all generator
    expressions, each individual result is processed separately. This can allow large
    files to be digested as small summaries one at a time.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数将使用生成器表达式栈。有关更多背景信息，请参阅第[9](ch013_split_000.xhtml#x1-5020009)章中的[使用堆叠的生成器表达式](ch013_split_000.xhtml#x1-5180003)配方。由于这些都是生成器表达式，每个单独的结果都单独处理。这可以允许大文件一次消化为一个小摘要。
- en: 'Write a function to parse the command-line options. In this case, the target
    directory is a positional parameter, and the number of samples in each file and
    the number of files to generate are options. The function looks like this:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数来解析命令行选项。在这种情况下，目标目录是一个位置参数，每个文件中的样本数量和要生成的文件数量是选项。该函数看起来像这样：
- en: '[PRE42]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Combine the parsing and execution into a main function:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将解析和执行组合到一个主函数中：
- en: '[PRE43]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now we can run this new application and have it execute the underlying application
    and also gather the output, producing a helpful summary. We’ve built this using
    Python instead of a bash (or other shell) script. We can make use of Python’s
    data structures and unit testing.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行这个新应用程序，使其执行底层应用程序并收集输出，从而生成有用的摘要。我们使用Python而不是bash（或其他shell）脚本构建了它。我们可以利用Python的数据结构和单元测试。
- en: 14.5.3 How it works...
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5.3 它是如何工作的...
- en: The subprocess module is how Python programs run other programs available on
    a given computer. For more background, see the [Wrapping and combining CLI applications](ch018.xhtml#x1-7790004)
    recipe in this chapter.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程模块是Python程序如何在给定计算机上运行其他程序的方式。有关更多背景信息，请参阅本章中的[包装和组合CLI应用程序](ch018.xhtml#x1-7790004)配方。
- en: 'The subprocess module gives us access to one of the most important parts of
    the operating system: launching a subprocess and collecting the output. The underlying
    OS can direct output to the console, or files, or through ”pipes” to another process.
    The default behavior when launching a subprocess is to inherit the parent process
    definitions for the three standard files, stdin, stdout, and stderr. In this recipe,
    we’ve replaced the default stdout assignment with a file that permits us to gather
    (and analyze) output that would have gone to the console.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 子进程模块为我们提供了访问操作系统最重要的部分之一：启动子进程并收集输出。底层操作系统可以将输出直接定向到控制台、文件或通过“管道”到另一个进程。启动子进程时的默认行为是继承父进程定义的三个标准文件：stdin、stdout和stderr。在这个配方中，我们用文件替换了默认的stdout分配，使我们能够收集（并分析）本应输出到控制台的输出。
- en: 14.5.4 There’s more...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5.4 更多...
- en: Once we’ve wrapped the markov_gen binary application within a Python application,
    we have a number of alternatives available to us for improving the output.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将 markov_gen 二进制应用程序封装在 Python 应用程序中，我们就有了许多可供选择的方案来改进输出。
- en: Because we’ve wrapped the underlying application, we don’t need to change this
    code to change the results it produces. We can modify our wrapper program, leaving
    the original data generator intact.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经封装了底层应用程序，我们不需要更改此代码来更改其产生的结果。我们可以修改我们的包装程序，同时保持原始数据生成器不变。
- en: 'We can refactor the main() function to replace the print() functions with processing
    to create a more useful format. A possible rewrite would emit a CSV file with
    the detailed generator information:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 main() 函数重构，用处理过程替换 print() 函数，以创建更实用的格式。可能的重写将生成包含详细生成器信息的 CSV 文件：
- en: '[PRE44]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The list of files and numbers of samples can be used to partition the data for
    model training purposes.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 文件列表和样本数量可以用于为模型训练目的划分数据。
- en: We are able to build useful features separately by creating layers of features.
    Leaving the underlying application untouched can help us to perform regression
    tests to be sure the core statistical validity has not been harmed by adding new
    features.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建功能层来分别构建有用的功能。在不修改底层应用程序的情况下，可以帮助我们执行回归测试，以确保核心统计有效性没有被添加新功能所损害。
- en: 14.5.5 See also
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.5.5 参见
- en: See the [Wrapping and combining CLI applications](ch018.xhtml#x1-7790004) recipe
    from earlier in this chapter for another approach to this recipe.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见本章早些时候的 [Wrapping and combining CLI applications](ch018.xhtml#x1-7790004)
    菜单，了解另一种实现此菜单的方法。
- en: This kind of automation is often combined with other Python processing. See
    the [Designing scripts for composition](ch017.xhtml#x1-7410005) recipe in Chapter [13](ch017.xhtml#x1-71500013).
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种自动化通常与其他 Python 处理结合使用。请参阅第 [13](ch017.xhtml#x1-71500013) 章的 [Designing scripts
    for composition](ch017.xhtml#x1-7410005) 菜单。
- en: The goal is often to create a composite application; see the [Managing arguments
    and configuration in composite applications](ch018.xhtml#x1-7730003) recipe from
    earlier in this chapter.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标通常是创建一个组合应用程序；参见本章早些时候的 [Managing arguments and configuration in composite
    applications](ch018.xhtml#x1-7730003) 菜单。
- en: Many practical applications will work with more complex output formats. For
    information on processing complex line formats, see the [String parsing with regular
    expressions](ch005_split_000.xhtml#x1-350003) recipe in Chapter [1](ch005_split_000.xhtml#x1-170001)
    and the [Reading complex formats using regular expressions](ch015_split_001.xhtml#x1-6440005)
    recipe in Chapter [11](ch015_split_000.xhtml#x1-61500011). Much of Chapter [11](ch015_split_000.xhtml#x1-61500011),
    relates to the details of parsing input files.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多实际应用将支持更复杂的输出格式。有关处理复杂行格式的信息，请参阅第 [1](ch005_split_000.xhtml#x1-170001) 章的
    [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003) 菜单和第
    [11](ch015_split_000.xhtml#x1-61500011) 章的 [Reading complex formats using regular
    expressions](ch015_split_001.xhtml#x1-6440005) 菜单。第 [11](ch015_split_000.xhtml#x1-61500011)
    章的大部分内容与解析输入文件的细节相关。
- en: 'For more information on interprocess communication, see [The Linux Documentation
    Project: Interprocess Communication Mechanisms](https://tldp.org/LDP/tlk/ipc/ipc.html).'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '关于进程间通信的更多信息，请参阅 [The Linux Documentation Project: Interprocess Communication
    Mechanisms](https://tldp.org/LDP/tlk/ipc/ipc.html)。'
- en: Join our community Discord space
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)。
- en: '![PIC](img/file1.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
