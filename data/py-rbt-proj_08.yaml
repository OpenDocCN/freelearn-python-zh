- en: Making Your Own Area Scanner
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作你自己的区域扫描仪
- en: Motors are amazing things; they come in all shapes and sizes. Primarily, they
    can be considered the backbone of most robots. However, nothing is perfect in
    this world. There must be some drawbacks to these motors as well. By now, you
    might have figured out some by yourself. In the previous chapter, when we made
    the car turn, you might have seen that the angle of turn was never really the
    same. Also when the vehicle was given the command to go straight, it really would
    not do so. Rather it would try to run slight, toward one side.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 电机是令人惊叹的东西；它们有各种各样的形状和大小。首先，它们可以被认为是大多数机器人的骨架。然而，在这个世界上，没有什么是不完美的。这些电机也一定有一些缺点。到现在，你可能已经自己发现了一些。在上一章中，当我们让汽车转向时，你可能已经注意到转向的角度从未真正相同。同样，当车辆被下达直行的命令时，它实际上并不会这样做。相反，它会试图轻微地偏向一侧。
- en: Say hello to the first problem—precision. The motors are exceptionally simple
    to control, but the problem with these motors come when we have to rotate the
    motors only till a specific angle. If you need to rotate the motor of your robotic
    vehicle only by 90 degrees, then how would you do it? The first and foremost thing
    that might come to your mind would be to fiddle with the timings of the motors.
    You might be right here. But still, it would be impossible to make sure that it
    is exactly 90 degrees every single time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 问候第一个问题——精度。电机控制起来非常简单，但问题在于当我们只需要将电机旋转到特定角度时。如果你需要只旋转你的机器人车辆的电机90度，你将如何做？首先可能出现在你脑海中的事情可能是调整电机的定时。你可能在这里是正确的。但仍然，确保每次都是精确的90度是不可能的。
- en: But when we talk about robots, accuracy of even 1 degree may not be enough.
    Roboticists these days are looking forward to accuracy within the magnitude of
    two decimal digits. So, the precision we are talking about is close to 0.01 degrees.
    What do you think now? How do we achieve this level of accuracy with motors?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但是当我们谈到机器人时，即使是1度的精度可能也不够。现在的机器人学家正在期待达到两位数的精度。所以，我们所说的精度接近0.01度。你现在怎么想？我们如何通过电机达到这种精度？
- en: 'The answers to all these questions will be answered in this chapter through
    the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过以下主题回答所有这些问题：
- en: Servo motor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 伺服电机
- en: Lists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: LIDAR
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 激光雷达
- en: Servo motor
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伺服电机
- en: 'So, let me introduce you to *servo motor*. Servo motor is basically a motor
    with a few added components. Now to understand what those added components, let''s
    first go through this example. Let''s say that you want to go to London. Now to
    see how you have to go there and what would be the route to reach London, the
    first thing you need to know is that where exactly you are now. If you don''t
    know where you are currently, it is impossible to calculate a route. Similarly,
    if we want to reach a certain position of motor, we need to know where the shaft
    of the motor is standing right now. To do this, we use a **potentiometer**. A
    potentiometer is basically a variable resistor that essentially has a shaft that
    when rotated changes the value of resistance. A variable resistor looks like this:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我来向你介绍*伺服电机*。伺服电机基本上是一种带有一些附加组件的电机。现在，为了了解这些附加组件是什么，让我们先来看一个例子。假设你想要去伦敦。现在，为了了解你如何到达那里以及到达伦敦的路线，你需要知道的第一件事是，你现在确切的位置在哪里。如果你不知道你现在在哪里，就无法计算路线。同样，如果我们想要到达电机的一个特定位置，我们需要知道电机轴现在在哪里。为此，我们使用**电位计**。电位计基本上是一个可变电阻器，它本质上有一个轴，当旋转时，会改变电阻的值。可变电阻器看起来是这样的：
- en: '![](img/dfd5853e-ae1a-4d4d-8a54-506bc0b3c030.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfd5853e-ae1a-4d4d-8a54-506bc0b3c030.png)'
- en: 'When the value of resistor change, then the output voltage from the resistor
    will also change. The interesting thing is that if the input voltage to the potentiometer
    is well known, then the output voltage from it can be used to infer where the
    shaft is. Let''s see how:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当电阻器的值改变时，电阻器的输出电压也会改变。有趣的是，如果电位器的输入电压是已知的，那么可以从它的输出电压推断出轴的位置。让我们看看如何：
- en: '![](img/1f403a4d-2dcb-4f32-a0e6-1604a0ed5b5f.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1f403a4d-2dcb-4f32-a0e6-1604a0ed5b5f.png)'
- en: Now, let's say at a position of 0 degrees, the output voltage for the potentiometer
    is 4.8V; when we move it up to 90 degrees, the value changes to around 3.2V, and
    upon turning entirely 180 degrees, the voltage reduces to a mere 2V due to the
    change in resistance.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设在0度的位置，电位计的输出电压为4.8V；当我们将其移动到90度时，值变为大约3.2V，当完全旋转180度时，由于电阻的变化，电压降低到仅有2V。
- en: Without really looking at the shaft of the potentiometer, we can easily derive
    that if the voltage output from the resistor is 4.8V, then the shaft must be at
    a position of 0 degrees. Similarly, we can say that it is at 90 degrees if the
    voltage is 3.2V and at 180 degrees when the voltage is 2V.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不必真正查看电位计的轴，我们可以轻松地推导出，如果电阻的电压输出为4.8V，那么轴必须位于0度的位置。同样，如果我们说电压为3.2V时它位于90度，当电压为2V时它位于180度。
- en: 'Here, we have just plotted three points, but for any given point on the potentiometer,
    there would be a very specific resistance corresponding to it. Through this we
    can precisely calculate where the shaft of the potentiometer would be. Now, let''s
    put it in an interesting combination:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只画了三个点，但对于电位计上的任何给定点，都会有一个非常特定的电阻与之对应。通过这个我们可以精确地计算出电位计的轴将位于何处。现在，让我们将其放入一个有趣的组合中：
- en: '![](img/fbdce339-30f1-4811-96eb-d28b6b6a73eb.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fbdce339-30f1-4811-96eb-d28b6b6a73eb.png)'
- en: Now what we have is a motor coupled with potentiometer through multiple reducing
    gears that will reduce the speed of the motor and increase the torque. Further
    at the final gear, a shaft is mounted outward to the body coupled with a potentiometer.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所拥有的是一个通过多个减速齿轮与电位计耦合的电机，这将降低电机的速度并增加扭矩。进一步地，在最终齿轮上，一个轴向外安装到机身并与电位计耦合。
- en: So as you learned, the potentiometer will be able to sense at which angle the
    output shaft is pointing. The potentiometer is then connected to a control circuit
    that takes the reading from the potentiometer and further guides the motor on
    how much more to move to reach the goal position. Due to this closed loop arrangement
    in which the control circuit knows where the shaft is, it could calculate how
    much it has to move the motor to reach the goal position. Hence, this arrangement
    is able to turn the output shaft to any given position precisely.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 所以正如你所学的，电位计能够感知输出轴指向的角度。然后电位计连接到一个控制电路，该电路读取电位计的读数并进一步指导电机移动多少以达到目标位置。由于这种闭环安排，控制电路知道轴的位置，它可以计算出需要移动电机多少才能达到目标位置。因此，这种安排能够精确地将输出轴转到任何给定位置。
- en: 'This arrangement is typically known as a **servo motor**. Throughout the robotics
    industry, it is one of the most widely used hardware to control precise movements.
    Essentially, there are three wires going into the control circuit—VCC, ground,
    and signal. The signal line will receive the data from our Raspberry Pi, and upon
    receiving, it will do the necessary motor movement to make the shaft reach the
    desired position. An image of a servo motor is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安排通常被称为**伺服电机**。在整个机器人行业中，它是控制精确运动最广泛使用的硬件之一。本质上，有三个电线进入控制电路——VCC、地线和信号线。信号线将接收来自我们的Raspberry
    Pi的数据，并在接收后执行必要的电机运动，使轴达到期望的位置。以下是伺服电机的一张图片：
- en: '![](img/4d75bf50-43af-4b4a-9b3f-3153e8a11956.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d75bf50-43af-4b4a-9b3f-3153e8a11956.jpg)'
- en: These can start from being extremely inexpensive, around $4 to $5, but they
    can go up to thousands of dollars. But what really decides the pricing of these
    servo motors? There are several factors that we need to keep in mind while choosing
    a servo motor, but the most important of it is **torque**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可以从极其便宜的价格开始，大约4到5美元，但它们可以高达数千美元。但真正决定这些伺服电机价格的是什么？在选择伺服电机时，我们需要考虑几个因素，但其中最重要的是**扭矩**。
- en: 'Torque is a basically a turning force by which a motor can turn the output
    shaft. This is measured usually in kg·cm or N·m. Now what does this actually mean?  Let''s
    see the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 扭矩基本上是电机通过它来转动输出轴的旋转力。这通常以kg·cm或N·m来衡量。那么这实际上意味着什么呢？让我们看看以下图示：
- en: '![](img/485ed3d9-7dc5-4e3b-8437-c2efdd4944f2.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/485ed3d9-7dc5-4e3b-8437-c2efdd4944f2.png)'
- en: Let's say in the preceding diagram, we have a motor that has a torque of 10
    kg·cm and the rotor attached to it is of 1 cm. So, it should be able to pull up
    a weight of 10 kg perpendicularly up from the ground. However, when we change
    the radius of the rotor to 2 cm, then the weight that can be lifted gets halved. Similarly,
    if the radius increases to 10 cm, then the weight that can be lifted would only
    reduce to 1 kg. So basically, the weight that can be lifted would be torque/radius.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在前面的图中，我们有一个扭矩为10 kg·cm的电机，与之连接的转子直径为1 cm。因此，它应该能够垂直地从地面拉起10 kg的重物。然而，当我们改变转子的半径到2
    cm时，可以提升的重物重量减半。同样，如果半径增加到10 cm，那么可以提升的重物重量将减少到1 kg。所以基本上，可以提升的重物重量将是扭矩/半径。
- en: 'But for most of our purposes, we would not be using a mechanism as shown previously,
    so let''s look at the next diagram to see how the calculations can be made:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于我们大多数目的来说，我们不会使用之前展示的机制，所以让我们看看下一张图，看看如何进行计算：
- en: '![](img/c817a2bd-454a-4520-bcdd-2862d22b0067.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c817a2bd-454a-4520-bcdd-2862d22b0067.png)'
- en: Now, let's say we have a shaft of length **L** and a load at the extreme edge
    of the shaft. For ease of calculation purposes, we would consider the weight of
    shaft to be negligible. Now if the servo is having a torque of 100 kg·cm and the
    length of shaft (**L**) is 10 cm, then by simple calculation, the load that we
    can pick up would be 100/10 = 10 kg. Similarly, if the length increases to 100
    cm, the load that can be lifted would reduce to a mere 1 kg.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个长度为**L**的轴和一个位于轴端部的载荷。为了便于计算，我们会认为轴的重量可以忽略不计。现在，如果伺服电机的扭矩为100 kg·cm，轴的长度（**L**）为10
    cm，那么通过简单的计算，我们可以提起的载荷将是100/10 = 10 kg。同样，如果长度增加到100 cm，可以提起的载荷将减少到仅仅1 kg。
- en: OK then; we have had a good amount of exposure to servo motors. Now the question
    is how do we control a servo motor? As I mentioned, there are different types
    of servo motors that are available that can be addressed by various means. However,
    the most common one used for hobby purposes is a digital servo motor. These servo
    motors require **PWM**, and based on the duty cycle of PWM, the angle of the shaft
    changes. So, let's see how it happens.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经对伺服电机有了一定的了解。现在的问题是，我们如何控制伺服电机？正如我提到的，有不同类型的伺服电机，可以通过不同的方式来控制。然而，最常用于业余目的的是数字伺服电机。这些伺服电机需要**PWM**，根据PWM的占空比，轴的角度会发生变化。那么，让我们看看这是如何发生的。
- en: 'Typically, most of these servos have a frequency of 50 Hz. So basically the
    length of every pulse would be 1/50 = 0.02 seconds or in other words 20 ms. Further,
    the duty cycle that can be given to theses servo motors can be 2.5% to 12.5%,
    which basically means pulse width of 0.5 ms to 2.5 ms. Now let''s see how it works:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这些伺服电机大多数的频率为50 Hz。所以，基本上每个脉冲的长度将是1/50 = 0.02秒，换句话说，20毫秒。此外，可以提供给这些伺服电机的占空比可以是2.5%到12.5%，这意味着脉冲宽度为0.5毫秒到2.5毫秒。现在让我们看看它是如何工作的：
- en: '![](img/c1917712-bee6-4280-9311-2d5b5624cb46.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1917712-bee6-4280-9311-2d5b5624cb46.png)'
- en: As you can see, when given a duty cycle of 2.5%, the shaft gets down to the
    minimum position of 0 degrees, and when the duty cycle is increased to 7.5%, the
    shaft goes to the middle position of 90 degrees. Finally, when the duty cycle
    is increased to 12.5%, the shaft goes to the maximum position of 180 degrees.
    If you want any position in between, then you can simply choose the PWM corresponding
    to it, and it will change the position of servo to the desired angle.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当给定2.5%的占空比时，轴下降到0度的最小位置，当占空比增加到7.5%时，轴移动到中间位置90度。最后，当占空比增加到12.5%时，轴移动到最大位置180度。如果你想要任何介于两者之间的位置，那么你可以简单地选择相应的PWM，它将改变伺服电机的位置到期望的角度。
- en: But you may be thinking what if we want to take it beyond 180 degrees? Well,
    good question, but most of the digital servos only come with a range of 180 degrees
    of rotation. There are servos that can rotate completely its axis, that is, 360
    degrees; however, their addressing is slightly different. After this chapter,
    you can pretty much go ahead check out any digital servo motor's data sheet and
    control it the way you want.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但你可能想知道，如果我们想将其超过180度呢？嗯，这是个好问题，但大多数数字伺服电机只提供180度的旋转范围。有些伺服电机可以完全旋转其轴，即360度；然而，它们的地址方式略有不同。在本章之后，你可以查看任何数字伺服电机的数据表，并按照你想要的方式控制它。
- en: 'All right, enough of theory; it''s time to do some fun. So, let''s go ahead
    and set up the hardware and control a servo by our bare hands! Connect the servo
    to Raspberry Pi as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，理论就到这里；是时候做一些有趣的事情了。所以，让我们动手设置硬件，用手直接控制伺服电机！按照以下方式将伺服电机连接到树莓派：
- en: '![](img/e1b5626d-641a-4f72-bdde-fb0f92e6279c.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1b5626d-641a-4f72-bdde-fb0f92e6279c.png)'
- en: 'The color coding of the wires is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 线的颜色编码如下：
- en: '![](img/8b5740f1-e81a-4cbc-98d1-da2b7bd9c7b2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8b5740f1-e81a-4cbc-98d1-da2b7bd9c7b2.png)'
- en: 'Next, we need to upload the following code and see what happens:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要上传以下代码并看看会发生什么：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As soon as you run this program, you will see the shaft of the servo moving
    from left to right, making steps at 0 degrees, 45 degrees, 90 degrees, 135 degrees,
    and finally 180 degrees.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行这个程序，你会看到伺服电机的轴从左到右移动，以0度、45度、90度、135度和最终180度的步长进行移动。
- en: 'Let''s see what we have done in the program to achieve it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看在程序中我们做了什么来实现这一点：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With the line `pwm = GPIO.PWM(14, 50)`, we have defined that GPIO pin number
    `14` will be used for PWM and the frequency of PWM will be `50`. We have used
    the line `pwm.start(0)` in earlier chapters as well. It basically sets the PWM
    pin to `0` that is no duty cycle:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pwm = GPIO.PWM(14, 50)`这一行，我们定义了GPIO引脚号`14`将用于PWM，PWM的频率将是`50`。我们也在前面的章节中使用过`pwm.start(0)`这一行。它基本上是将PWM引脚设置为`0`，即没有占空比：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: No all the earlier program is in the `while` loop, that is, it will be executed
    over and over until the program is forced to quit. Now the line `pwm.ChangeDutyCycle(2.5)`
    sends a PWM of 2.5% duty cycle to the servo motor. This will simply turn the servo
    motor to 0 degree angle. Next, we use the good old `time.sleep(2)`, which we all
    know would halt the program that line for two seconds.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不是所有的早期程序都在`while`循环中，也就是说，它将反复执行，直到程序被强制退出。现在，`pwm.ChangeDutyCycle(2.5)`这一行向伺服电机发送了2.5%的占空比PWM。这将简单地使伺服电机旋转到0度角度。接下来，我们使用大家都很熟悉的`time.sleep(2)`，它会暂停程序，使该行暂停两秒钟。
- en: The same cycle is being repeated with different PWM values of 5%, which would
    turn the shaft to 45 degrees, 7.5% for 90 degrees, 10% for 135 degrees, 12.5 %
    for 180 degrees. It's a very simple program that would clear out our basics of
    the servo motor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的循环正在使用不同的PWM值5%重复，这将使轴旋转到45度，7.5%对应90度，10%对应135度，12.5%对应180度。这是一个非常简单的程序，将帮助我们了解伺服电机的基础知识。
- en: 'So by now, you have learned how to control servo motor and move it in the direction
    in which we want. Now, let''s go a step ahead and change the code slightly to
    make the servo run smoothly:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经学会了如何控制伺服电机，并使其按照我们想要的方向移动。现在，让我们更进一步，稍微修改一下代码，使伺服电机运行得更平滑：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'What happened when you uploaded this code in your Pi? You would have noted
    that the servo is swiping from left to right very smoothly and then right to left.
    We have done a very simple trick; let''s see what it is:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在你的Pi上上传这段代码时，你会注意到伺服电机从左到右非常平滑地滑动，然后又从右到左。我们做了一个非常简单的技巧；让我们看看它是什么：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, we are running a loop that will run till the time the value of `i<=12.5`,
    as we have defined earlier in the program the value of `i` has been set to `2.5`
    as default in the starting of the program. Thereafter every time the code runs,
    the duty cycle is set to the value of `I` , the program halts for 0.1 seconds
    and then the value of `i` is incremented by a value of `0.1`. This is increasing
    the duty cycle of the PWM. Once the value reaches 12.5, the loop exits.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在运行一个循环，它将一直运行到`i<=12.5`的值，正如我们在程序中之前定义的那样，`i`的值在程序开始时被设置为默认的`2.5`。之后，每次代码运行时，占空比被设置为`I`的值，程序暂停0.1秒，然后`i`的值增加0.1。这是增加PWM的占空比。一旦值达到12.5，循环就会退出。
- en: The entire PWM range we have is 2.5% to 12.5%, so we have a space of 10% to
    play with. Now if we map it to the angular rotation of the servo motor, then every
    percent of PWM corresponds to a change of 180/10 = 18 degrees. Similarly, every
    0.1% of the change would result in a change of 180/100 = 1.8 degrees. Hence, with
    every 0.1 seconds, we are adding duty cycle by 0.1%, or in other words, we are
    increasing the angle by 1.8 degrees. Hence, we find this action extremely smooth.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们拥有的整个PWM范围是2.5%到12.5%，因此我们有10%的空间可以操作。现在如果我们将其映射到伺服电机的角旋转，那么每个百分比的PWM对应于180/10
    = 18度的变化。同样，每0.1%的变化将导致1.8度的变化。因此，每0.1秒，我们通过增加0.1%的占空比，或者说，我们通过增加1.8度来增加角度。因此，我们发现这个动作非常平滑。
- en: We are doing the similar thing in the next portion of the program; however,
    we are doing it for the reverse motion.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在程序的下一部分做了类似的事情；然而，我们是在做反向运动。
- en: Lists
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表
- en: All right then, we are quite sure on how to use the servo and have a controlled
    motion as per our needs. Now it's time to move forward and understand another
    concept that we would be using greatly. It's named **arrays**. If you have programmed
    in any other language, you must be familiar with it. But we need to understand
    a few basics concepts of it, which will make our lives a lot easier. So, let's
    get started.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们非常确定如何使用伺服电机，并按照我们的需求进行有控制的运动。现在，是时候向前迈进，了解我们将大量使用的另一个概念了。它被称为**数组**。如果你在其他任何语言中编程过，你一定很熟悉它。但我们需要了解它的一些基本概念，这将使我们的生活变得更加容易。所以，让我们开始吧。
- en: 'First things, first. Arrays in Python are not named arrays, rather it is named
    as **lists**. List is basically a data structure that can store multiple elements
    at the same time. The only limitation being is that the elements must be of the
    same data type. Such as if you are storing integers, then all the values should
    be `int`. Similarly, if you are storing a character, then every element of the
    list should be `char`. To define a list, all you need to do is name the list such
    as we have done by doing `myList`; the name of the list could be anything next
    we need to tell the compiler that it is actually a list. To do that, we need to
    put values inside square brackets. It would look like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，最重要的是。在Python中，数组并不被称为数组，而是被称为**列表**。列表基本上是一种可以同时存储多个元素的数据结构。唯一的限制是元素必须是相同的数据类型。例如，如果你存储整数，那么所有的值都应该为`int`。同样，如果你存储字符，那么列表中的每个元素都应该为`char`。要定义一个列表，你所需要做的就是命名列表，就像我们通过`myList`所做的那样；列表的名称可以是任何名称，接下来我们需要告诉编译器它实际上是一个列表。要做到这一点，我们需要在方括号内放置值。它看起来会是这样：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One thing to keep in mind is that every value should be separated with commas. Whenever
    we want to address any single element of the list, we can simply use it by calling
    their index number. This is based on the position of the element in the list.
    The index value in Python list starts from 0\. So as per the preceding declaration
    at the index 0, the value would be `14`, and at the address 4, the value would
    be `9`. Now when we need to print these elements in between our program, we need
    to write the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事情是，每个值都应该用逗号分隔。每当我们想要通过调用它们的索引号来引用列表中的任何单个元素时，我们都可以简单地这样做。这是基于元素在列表中的位置。Python列表中的索引值从0开始。所以根据前面的声明，索引0的值将是`14`，索引4的值将是`9`。现在，当我们需要在程序中打印这些元素时，我们需要编写以下代码：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Once we write this, the program will print the value of the second value in
    the list. In our case, it would be `35`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们写下这段代码，程序将打印列表中第二个元素的值。在我们的例子中，它将是`35`。
- en: 'Now, this is one way to access the elements of the list; we can however access
    it in reverse order as well. So, let''s say you want to access the last item of
    the array. Then, we can write the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是访问列表元素的一种方法；我们也可以按反向顺序访问它。所以，假设你想访问数组的最后一个元素。然后，我们可以编写以下代码：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This code will return the value of the last element of the array. Now whenever
    we use the negative values in the lists, then it would start the indexing in the
    reverse order. So, let's say if we type in `print myList[-2]`, this will give
    us the value of the second last value in the array. One thing to remember in this
    whole schematic is that the numbering would start from 0, whereas when we start
    it in the reverse order, then the numbering would start from -1.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将返回数组中最后一个元素的值。现在，每当我们使用列表中的负值时，它将按反向顺序开始索引。所以，如果我们输入`print myList[-2]`，这将给出数组中倒数第二个元素的值。在这个整个方案中，有一点需要记住的是，编号将从0开始，而当我们从反向开始时，编号将从-1开始。
- en: Python is really interesting and quite simple if you know the right tools. The
    developers of Python have included some really helpful functions that can be used
    over lists. So, let's go and explore them a bit.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你了解正确的工具，Python真的很有趣，也很简单。Python的开发者包括一些非常有用的函数，这些函数可以用于列表。所以，让我们去探索它们吧。
- en: 'The first one is to add elements to the array. For this, we use a function
    named `append()`. What the `append()` function does is that it adds the value,
    which would want at the end of the array. So, write the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是向数组中添加元素。为此，我们使用一个名为`append()`的函数。`append()`函数的作用是在数组的末尾添加值。所以，写下以下代码：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What this would do is that it would add the element `45` at the end of `myList`.
    So now the list would be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会在`myList`的末尾添加元素`45`。所以现在列表将如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Easy, isn''t it ? But what if you want to add an element in between the list?
    Obviously, the developer won''t leave you dry. They have included a function for
    that as well; it''s named `insert(index, element)`. Now whenever you are using
    this function, you need to make sure that you mention the index where you want
    this element to be and second, the element that you want to put. So it looks something
    like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？但是，如果你想在列表中间添加一个元素怎么办？显然，开发者不会让你干瞪眼。他们已经包括了一个用于此目的的函数；它被命名为`insert(index,
    element)`。现在，每当你使用这个函数时，你需要确保你提到你想放置这个元素的位置的索引，其次，你想放置的元素。所以它看起来像这样：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When you have used this function, the array will look as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用这个函数时，数组将看起来如下：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Obviously, whenever the developer has given the function to add an element,
    then they would have certainly given a function to remove the elements as well.
    But the trick is that you can do it two ways. First, the common way. We simply
    select the index number and delete it. We are going to do it now:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每当开发者提供了一个添加元素的功能时，他们肯定也提供了一个删除元素的功能。但技巧在于你可以有两种方式来做这件事。首先，是常见的方式。我们简单地选择索引号并删除它。我们现在就要这么做：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now what this will do is that it would delete the second element of the array,
    so after doing this operation, the array will look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这将做的是删除数组的第二个元素，所以执行这个操作后，数组将看起来像这样：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'But now here comes the real trick; you can also delete the element by simply
    specifying the element. This is how it''s done:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在这里有一个真正的技巧；你也可以通过简单地指定元素来删除元素。这就是它的做法：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now the moment you do this, it will find wherever the element `9` is in your
    list and delete it from the positions. So you don't have to care about where the
    element is; this function will say, I will find you and I will kill you!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你这么做的时候，它会找到列表中元素`9`的位置并将其删除。所以你不必关心元素在哪里；这个函数会说，我会找到你，然后我会消灭你！
- en: Looking around
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 四处看看
- en: Okay then enough of movie quotes. We can talk about many other functions that
    we can use over lists, but what we have done is enough for now. We will see the
    rest of them as the need arise. But for now let's take the things a step further
    in robotics. You might have seen a rotating object on top of many autonomous cars.
    The production cars generally don't tend to have primarily due to its high price,
    but research purpose cars are always loaded with it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，那么就不再引用电影台词了。我们可以谈论许多其他我们可以在列表上使用的函数，但我们现在所做的是足够的。随着需要，我们将看到其余的。但现在让我们在机器人领域更进一步。你可能已经看到许多自动驾驶汽车顶部的旋转物体。量产汽车通常不太可能配备它，主要是因为它的价格高昂，但研究目的的汽车总是装备有它。
- en: So what is this device? It's named **LIDAR**; it is an acronym for **Light Detection
    and Ranging**. I know bad acronym. There is a reason for LIDAR to be very common.
    It gives distance reading of the areas around it in a very precise way. However,
    buying it for our projects would slightly overkill as a good one would cost you
    close $500 to $10,000\. If you still think that it's in your budget, then you
    would be very lucky! But for those who don't want to buy it. I have a good news
    for you. Today, we are going to build our own LIDAR scanner. So to make an area
    scanner, we need a servo over which we will mount our IR proximity sensor. Now
    to do this, we would need a slight makeshift arrangement. You can take a cardboard
    and fix it like we have done in the picture here, or otherwise, you can also use
    a right-angled aluminum and drill it to fix the components if you want it to do
    the pro way. The one thing to remember that the sensor must be facing exactly
    parallel to the ground and not up or down.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那这个设备是什么呢？它被称为**LIDAR**；它是**光探测与测距**的缩写。我知道这是一个糟糕的缩写。LIDAR之所以非常普遍，是有原因的。它以非常精确的方式为其周围区域提供距离读数。然而，如果我们为项目购买它，可能会有些过度，因为一个好的LIDAR可能要花费你接近500到10000美元。如果你仍然认为它在你的预算范围内，那么你将会非常幸运！但对于那些不想购买的人来说，我有一个好消息要告诉你。今天，我们将要自己制作一个LIDAR扫描仪。因此，为了制作一个区域扫描仪，我们需要一个伺服电机，我们将在这个伺服电机制作我们的红外接近传感器。现在为了做到这一点，我们需要一个稍微临时性的安排。你可以拿一张纸板，像我们在图片中展示的那样固定它，或者你也可以使用一个直角铝材并钻孔来固定组件，如果你想做得更专业的话。有一点要记住的是，传感器必须正好平行于地面，不能向上或向下。
- en: 'Once the mounting is done, then it''s time to connect the rest of the hardware.
    So go ahead and connect the hardware, as shown in the following diagram:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成安装，那么就是连接其余硬件的时候了。所以按照以下图示连接硬件：
- en: '![](img/c1c4d876-6972-43ca-9098-099e3572fbfd.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1c4d876-6972-43ca-9098-099e3572fbfd.png)'
- en: 'OK, so let''s see what this thing can do, so get ready and upload this code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，那么让我们看看这个设备能做什么，准备好并上传这段代码：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: What did the code do? If it ran fine, then it should return you the scanned
    readings entire 180 degree broken down into 10 even steps. Go ahead—try it out
    and then return to see what actually is happening.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 代码做了什么？如果它运行正常，那么它应该返回整个180度的扫描读数，分为10个均匀的步骤。试试看，然后回来看看实际上发生了什么。
- en: 'Now most of the code is elementary, and you must have also got an idea of what
    this code is actually doing. However, let''s get deeper into it and see the specifics:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大部分代码都是基础的，你也应该已经对这段代码的实际功能有了了解。然而，让我们更深入地探讨一下，看看具体细节：
- en: '[PRE16]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this part of the program, we have defined a function named `Distance()`.
    As you can see, it is simply getting the reading from the ADC in the step `D_value
    = adc0.get_last_result()`; thereafter, this is the value procured that is stored
    in a variable `D` is then computed in the line `D = (1.0/F-value/13.15)) - 0.35`
    to get the metric reading from the ADC reading. Finally, using the line `Return
    D`, we are returning the value `D` from the function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序的部分，我们定义了一个名为`Distance()`的函数。正如你所看到的，它只是从步骤`D_value = adc0.get_last_result()`中获取ADC的读数；然后，这是从变量`D`中获取的值，在`D
    = (1.0/F-value/13.15)) - 0.35`这一行中计算，以从ADC读数中获得公制读数。最后，使用`Return D`这一行，我们从函数中返回值`D`：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We have declared two lists: `distLR`, namely for distance for left to right
    swipe of the servo and `distRL` for the distance received in right to left swipe
    of the servo. You might be wondering how is it that there is nothing inside these
    brackets. It is completely normal to have an empty array declared. There is no
    need for them to have value initially:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了两个列表：`distLR`，用于伺服电机的从左到右滑动的距离，以及`distRL`，用于伺服电机的从右到左滑动的距离。你可能想知道为什么这些括号中没有内容。声明一个空数组是完全正常的。它们最初不需要有值：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now this is where the real action is happening. The `while` loop will be executed
    only till the time the value of `k` is less than or equal to `12.5`. In the next
    line `servo.ChangeDutyCycle(k)`, the value of the duty cycle will be whatever
    the value of `k` would be. Initially, the value of `k` would be `2.5` as we have
    already defined in the beginning of the program. Now we add another line `time
    sleep(.1)`, which will make the program halt for `.1` second. This is necessary;
    otherwise, the program would parse through this loop within milliseconds and the
    servo would not be able to cope up with it. Hence, this is a short delay. In the
    next line, we have `distLR.insert(I,Distance())`. This line of program is doing
    a lot of things. First, as we have named a `Distance()` function inside this line.
    As we defined, it would calculate the distance using the ADC and the IR proximity
    sensor. Thereafter, it would insert that distance value inside an the list `distLR`
    at the position `I`. Previously in our program, we have already assigned the value `i
    = 0`; hence, the distance value would be put up in the first position in the array.
    Once this entire process is done, then we move forward and increment the value
    by one in this line `k = k + 1`; thereafter, we do the same thing in `I = I +
    1`. Now finally, once this loop''s executed, the values of the list is printed
    using the line `print distLR`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在才是真正的动作发生的地方。`while`循环将只执行到`k`的值小于或等于`12.5`为止。在下一行`servo.ChangeDutyCycle(k)`中，占空比的值将是`k`的值。最初，`k`的值将是`2.5`，因为我们已经在程序开始时定义了它。现在我们添加另一行`time.sleep(.1)`，这将使程序暂停`.1`秒。这是必要的；否则，程序会在毫秒内解析这个循环，伺服电机将无法跟上。因此，这是一个短暂的延迟。在下一行，我们有`distLR.insert(I,Distance())`。这一行程序做了很多事情。首先，因为我们在这行中命名了一个`Distance()`函数。根据我们的定义，它将使用ADC和红外接近传感器计算距离。然后，它将这个距离值插入到列表`distLR`中的位置`I`。在我们程序的前面，我们已经将值`i
    = 0`赋值了；因此，距离值将被放置在数组的第一个位置。一旦完成这个过程，然后我们继续前进，并在这一行中将值增加`k = k + 1`；然后我们在`I =
    I + 1`中也做同样的事情。现在，一旦这个循环执行完毕，我们使用`print distLR`这一行打印列表的值：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this line, we are simply resetting the values of `i = 0` and `k = 0` for
    the next loop:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一行，我们只是简单地重置了`i = 0`和`k = 0`的值，以便下一次循环：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This may be slightly new for you.  Whenever we use a colon inside a bracket,
    that basically means that the entire elements of the array would be deleted:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对你来说有点新。当我们在一个括号内使用冒号时，这基本上意味着整个数组的所有元素都将被删除：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, the same thing is happening that we did for the left to right
    swipe; the only difference being is that we are saving it a new list named `distRL`,
    and the swipe starts from 12.5% duty cycle and ends at 2.5%:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，发生的事情与我们在从左到右滑动时所做的相同；唯一的区别是我们将其保存到一个名为`distRL`的新列表中，滑动从12.5%占空比开始，到2.5%结束：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we have printed all the values, we again reset the values of `i = 1`, `k
    = 2.5`, and `j = 12.5` so that our first loop can start seamlessly further to
    it we are also making sure that there is nothing left inside the list `distRL`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印完所有值后，我们再次重置`i = 1`、`k = 2.5`和`j = 12.5`的值，这样我们的第一个循环就可以无缝地继续下去。同时，我们也确保`distRL`列表中没有留下任何东西。
- en: So this is how our code was working, straight and simple!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们的代码就是这样工作的，简单直接！
- en: LIDAR on an autonomous vehicle
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动驾驶车辆上的激光雷达
- en: Remember the last time we made autonomous car. It was cool, and surely it might
    be something you can show off to your friends. However, now what we are about
    to make is surely cooler than anything we have ever done till now.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们上次制作的自动驾驶汽车吗？那很酷，而且肯定是你可以向朋友炫耀的东西。然而，我们现在要做的肯定比我们迄今为止所做的一切都要酷。
- en: We are going to put this area scanner over our robotic vehicle. But wait, didn't
    we scan the area earlier using the same sensor and turning the car to other sides.
    We did it and it worked fine, almost fine. I bet sometimes it wasn't as accurate
    as you thought it would be. But that's not the real problem. The main problem
    is that it was not seamless. It has to stop in between check for spaces and then
    move in either direction. What we are going to do now is something that is a step
    ahead. So before doing any more explanation, let's go ahead and make this new
    robotic vehicle and then you be the judge to decide whether it is cooler.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这个区域扫描仪安装到我们的机器人车辆上。但是等等，我们之前不是已经用同样的传感器扫描过区域，并将车转向其他方向了吗？我们确实这样做了，而且效果很好，几乎是完美的。我敢打赌，有时候它可能没有你想象的那样准确。但这不是真正的问题。主要问题是它不够流畅。它必须在检查空间时停下来，然后向任意方向移动。我们现在要做的是更进一步的事情。所以在做更多解释之前，让我们先制作这个新的机器人车辆，然后由你来评判它是否更酷。
- en: 'So, to make it, you need to mount the area scanner on the vehicle. It''s advisable
    that you set it up at the frontend of the vehicle and make sure that the arm of
    the servo is able to rotate 180 degrees. You can use the similar method that we
    did to fix the IR sensor on top of the servo. While you are doing all of this,
    try using cable ties to make sure the cables are not messy and also make sure
    to leave some slack for the movement of the shaft and the sensor on top of it.
    These cable ties can make your life really simple. Once we are all set up, you
    should connect the IR proximity using an ADS1115 to the Raspberry Pi and then
    connect the motor driver, as shown in the following diagram:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了制作它，你需要将区域扫描仪安装到车辆上。建议你在车辆的前端设置它，并确保伺服电机的臂能够旋转180度。你可以使用我们之前固定红外传感器的类似方法来固定它。在你做所有这些的时候，尝试使用电缆绑带来确保电缆不会乱糟糟的，并确保为轴和其上的传感器的移动留出一些余量。这些电缆绑带可以让你的生活变得非常简单。一旦我们全部设置好，你应该使用ADS1115将红外接近传感器连接到树莓派，然后按照以下图示连接电机驱动器：
- en: '![](img/3d96558c-f411-475b-90df-2aa078cc3fae.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d96558c-f411-475b-90df-2aa078cc3fae.png)'
- en: 'Once we are done go ahead and upload the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，请上传以下代码：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Phew! That was long wasn''t it? But trust me it might be long, but not tough.
    So let''s see what this code is doing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！这可不短啊，不是吗？但请相信我，虽然可能很长，但并不难。那么，让我们看看这段代码在做什么：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This stuff might look pretty new to you. Though it isn't. What we are doing
    is that we are defining which pin number will be operating at what PWM frequency.
    Also, we have named every GPIO pins that is being used for motor control. OK then,
    it is fine that we are doing all this, but why have we suddenly started to give
    PWM to motor drivers. Were we not happy giving a simple high pulse?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些东西可能对你来说看起来相当新颖。尽管不是。我们正在做的是定义哪个引脚编号将以什么PWM频率运行。此外，我们还为所有用于电机控制的GPIO引脚命名。那么，既然我们在做所有这些，为什么我们突然开始给电机驱动器提供PWM信号呢？我们不是对简单地提供高脉冲感到满意吗？
- en: 'The answer is very straightforward. With the use of PWM, we were able to change
    the brightness of an LED in previous chapters. Similarly, by changing the PWM
    output to the control pins of the motor driver, you cannot only define which direction
    to spin in. But also the speed at which it can spin. This is all done with PWM.
    So let''s say pin number `20` is getting a PWM at 50% duty cycle. So it basically
    means that the motor which is attached to it will get half the input voltage that
    the motor driver is receiving. So now we can not only control which direction
    we want the motor to spin but also at what speed we can do so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 答案非常直接。通过使用PWM，我们在前面的章节中能够改变LED的亮度。同样，通过改变电机驱动器的控制引脚的PWM输出，我们不仅可以定义旋转的方向，还可以定义旋转的速度。这一切都是通过PWM完成的。所以，假设引脚编号`20`正在以50%的占空比接收PWM信号。这意味着连接到它的电机将获得电机驱动器接收到的输入电压的一半。因此，现在我们不仅可以控制电机旋转的方向，还可以控制旋转的速度：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this statement, we have defined a function `direction(index)`. What this
    does is that it compares the value of index and based on it. The power will be
    given to the motors. So lets say that the index is 0\. In this case the wheel
    on the left side would move in reverse direction whereas the right wheel would
    move in the reverse direction this will turn the robot on its axis.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，我们定义了一个名为 `direction(index)` 的函数。这个函数的作用是比较索引的值，并根据它来给电机供电。比如说，索引是 0。在这种情况下，左侧的轮子会向相反方向移动，而右侧的轮子也会向相反方向移动，这将使机器人围绕其轴旋转。
- en: 'In the next statement, we have written an `elif` statement, so if the `else` statement
    is not true, then it will check for the rest `else if` statement in the body.
    There are four `elif` statements in the entire definition of `direction(index)`,
    which basically means that it will check for each one of it and do either of the
    activities based on the value of the argument. In this case, it is the index.
    Further, there is a final `else` statement, which would be done if none of the
    cases are true. So according to the statement, it will call a function of stop.
    That would stop the vehicle:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个语句中，我们编写了一个 `elif` 语句，所以如果 `else` 语句不成立，它将检查主体中的其余 `else if` 语句。在 `direction(index)`
    的整个定义中，有四个 `elif` 语句，这意味着它将检查每一个，并根据参数的值执行相应的活动。在这种情况下，它是索引。此外，还有一个最终的 `else`
    语句，如果所有情况都不成立，则会执行。因此，根据该语句，它将调用一个停止函数。这将使车辆停止：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This line is pretty interesting as we are using another fun part of the lists
    that we have used. So, with the `max()` method, we can find the largest value
    inside a list. So, in this line, we are simply finding the max value and putting
    it in a variable named `max_dist1`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行非常有趣，因为我们使用了列表的另一个有趣的部分。所以，使用 `max()` 方法，我们可以在列表中找到最大的值。因此，在这一行中，我们只是简单地找到最大值并将其放入名为
    `max_dist1` 的变量中：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The beauty of lists just doesn''t seem to end. In this line, we are using another
    method named `index()`; this method gives us the index of the value inside the
    list. So, we can know where the value exists in the list. Hence, in this line,
    we are proving the value of `max_dist1`. The method `index()` searches the index
    number and stores that value down into a variable named `max_dist1_index`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的美妙之处似乎永远不会结束。在这一行中，我们使用了另一种名为 `index()` 的方法；此方法为我们提供了列表中值的索引。因此，我们可以知道值在列表中的位置。因此，在这一行中，我们证明了
    `max_dist1` 的价值。`index()` 方法搜索索引号并将该值存储到名为 `max_dist1_index` 的变量中：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As we have already defined the function `Direction()`, now all we are doing
    is calling the function to decide which direction to go in. Prefect then, power
    up your vehicles and see how well they are driving and do not forget to shoot
    a video and post it online.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了函数 `Direction()`，现在我们所做的就是调用该函数以决定向哪个方向前进。然后，启动你的车辆并看看它们的驾驶表现如何，别忘了拍摄视频并上传到网上。
- en: Have fun!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 玩得开心！
- en: Summary
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Professional laser scanners are super expensive, so, in this chapter, we went
    on to build an alternative by ourselves and mounted it on our vehicle. In the
    next chapter, we will cover topics such as vision processing, and object detection,
    object tracking, which will enable us to do basic vision processing and to make
    the car move in the direction of a specific object such as a ball.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 专业激光扫描仪非常昂贵，因此，在本章中，我们决定自己构建一个替代品并将其安装到我们的车辆上。在下一章中，我们将涵盖诸如视觉处理、目标检测、目标跟踪等内容，这将使我们能够进行基本的视觉处理，并使汽车朝着特定物体（如球）的方向移动。
