- en: Appendix A. Miscellaneous Tips
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 A. 杂项技巧
- en: We are now into the final section of the book. Let's conclude by discussing
    concepts that do form a common theme in many GUI applications but did not appear
    in our applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在进入了本书的最后一部分。让我们通过讨论在许多 GUI 应用程序中形成一个共同主题但未出现在我们的应用程序中的概念来结束。
- en: Mission Briefing
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务简报
- en: 'The topics covered here include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这里涵盖的主题包括：
- en: Tracing Tkinter variables
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪 Tkinter 变量
- en: Widget traversal
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小部件遍历
- en: Validating user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Formatting widget data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化小部件数据
- en: More on fonts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于字体
- en: Working with Unicode characters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Unicode 字符一起工作
- en: Tkinter class hierarchy
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 类层次结构
- en: Custom-made mixins
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定制的混入
- en: Tips for code cleanup and program optimization
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码清理和程序优化的技巧
- en: Distributing the Tkinter application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发 Tkinter 应用程序
- en: Limitations of Tkinter
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 的局限性
- en: Tkinter alternatives
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 的替代方案
- en: Getting interactive help
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取交互式帮助
- en: Tkinter in Python 3.*x*
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.*x* 中的 Tkinter
- en: Tracing Tkinter variables
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪 Tkinter 变量
- en: When you specify a Tkinter variable as a `textvariable` for a widget `(textvariable
    = myvar)`, the widget automatically gets updated whenever the value of the variable
    changes. However, there might be times when, in addition to updating the widget,
    you need to do some extra processing at the time of reading or writing (or modifying)
    the variable.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定一个 Tkinter 变量作为小部件的 `textvariable` （`textvariable = myvar`）时，小部件会自动更新，每当变量的值发生变化时。然而，有时除了更新小部件外，你还需要在读取或写入（或修改）变量时进行一些额外的处理。
- en: Tkinter provides a method to attach a callback method that would be triggered
    every time the value of a variable is accessed. Thus, the callback acts as a **variable
    observer** . The callback method is named `trace_variable(self, mode, callback)`,
    or simply `trace(self, mode, callback)`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 提供了一种方法来附加一个回调方法，该方法会在每次访问变量的值时被触发。因此，回调充当 **变量观察者**。回调方法名为 `trace_variable(self,
    mode, callback)`，或简单地 `trace(self, mode, callback)`。
- en: The mode argument can take any one of `'r'`, `'w'`, `'u'` values, which stand
    for read, write, or undefined. Depending upon the mode specifications, the callback
    method is triggered if the variable is read or written.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模式参数可以取 `'r'`, `'w'`, `'u'` 中的任何一个值，分别代表读取、写入或未定义。根据模式指定，如果变量被读取或写入，则触发回调方法。
- en: 'The callback method gets three arguments by default. The arguments in order
    of their position are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 回调方法默认接收三个参数。参数的顺序是：
- en: Name of the Tkinter variable
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkinter 变量的名称
- en: The index of the variable, if the Tkinter variable is an array, else an empty
    string
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 Tkinter 变量是一个数组，则变量的索引，否则为空字符串
- en: The access modes (`'w'`, '`r'`, or '`u'`)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问模式 (`'w'`, '`r'`, 或 '`u'`)
- en: Note that the triggered callback function may also modify the value of the variable.
    This modification does not, however, trigger any additional callbacks.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，触发的回调函数也可能修改变量的值。然而，这种修改并不会触发任何额外的回调。
- en: 'Let''s see a small example of variable tracing in Tkinter, where writing into
    the Tkinter variable into an entry widget triggers a callback function (refer
    to the `8.01 trace variable.py` Python file available in the code bundle):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Tkinter 中变量跟踪的一个小例子，其中将 Tkinter 变量写入输入小部件会触发一个回调函数（请参阅代码包中可用的 `8.01 trace
    variable.py` Python 文件）：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下列代码的描述如下：
- en: This code creates a trace variable on the Tkinter variable `myvar` in the write
    (`"w"`) mode
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此代码在 Tkinter 变量 `myvar` 上创建了一个跟踪变量，模式为写入（`"w"`）
- en: The trace variable is attached to a callback method named `trace_when_myvar_written`
    (this means that every time the value of `myvar` is changed, the callback method
    will be triggered)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪变量附加到名为 `trace_when_myvar_written` 的回调方法（这意味着每次 `myvar` 的值发生变化时，回调方法都会被触发）
- en: Now, every time you write into the entry widget, it modifies the value of `myvar`.
    Because we have set a trace on `myvar`, it triggers the callback method, which
    in our example, simply prints the new value into the console.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次你向输入小部件写入内容时，它都会修改 `myvar` 的值。因为我们已经对 `myvar` 设置了跟踪，所以它触发了回调方法，在我们的例子中，这个方法只是简单地在新值中打印到控制台。
- en: 'The code creates a GUI window similar to the one shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码创建了一个类似于这里所示的 GUI 窗口：
- en: '![Tracing Tkinter variables](img/7941OT_08_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![跟踪 Tkinter 变量](img/7941OT_08_01.jpg)'
- en: 'It also produces a console output in IDLE, which shows like the following once
    you start typing in the GUI window:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它还在 IDLE 中产生控制台输出，一旦你在 GUI 窗口中开始输入，就会显示如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The trace on a variable is active until it is explicitly deleted. You can delete
    a trace using:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的跟踪是活跃的，直到它被显式删除。你可以使用以下方式删除跟踪：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Widget traversal
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小部件遍历
- en: When a GUI has more than one widget, a given widget can come under focus by
    an explicit mouse-click on the widget. Alternatively, the focus can be shifted
    to another given widget by pressing the *Tab* key on the keyboard in the order
    the widgets were created in the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当GUI有多个小部件时，给定的小部件可以通过在GUI上显式鼠标单击来获得焦点。或者，可以通过在键盘上按*Tab*键，按照程序中小部件创建的顺序将焦点转移到另一个给定的小部件。
- en: It is therefore vital to create widgets in the order we want the user to traverse
    through them, or else the user will have a tough time navigating between the widgets
    using the keyboard.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，按照我们希望用户遍历的顺序创建小部件至关重要，否则用户在使用键盘在各个小部件之间导航时将遇到困难。
- en: Different widgets are designed to behave differently to different keyboard strokes.
    Let's therefore spend some time trying to understand the rules of traversing through
    widgets using the keyboard.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的小部件被设计为对不同键盘按键有不同的行为。因此，让我们花些时间尝试理解使用键盘遍历小部件的规则。
- en: 'Let''s look at the code of the `8.02 widget traversal.py` Python file to understand
    the keyboard traversal behavior for different widgets. Once you run the mentioned
    `.py` file, it shows a window something like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`8.02 widget traversal.py` Python文件的代码，以了解不同小部件的键盘遍历行为。一旦运行提到的`.py`文件，它显示的窗口类似于以下内容：
- en: '![Widget traversal](img/7941OT_08_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![小部件遍历](img/7941OT_08_02.jpg)'
- en: The code is simple. It adds an entry widget, a few buttons, a few radio buttons,
    a text widget, and a scale widget. However, it also demonstrates some of the most
    important keyboard traversal behaviors for these widgets.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 代码很简单。它添加了一个输入小部件、几个按钮、几个单选按钮、一个文本小部件和一个缩放小部件。然而，它还演示了这些小部件的一些最重要的键盘遍历行为。
- en: 'Here are some important points to note (refer to `8.02 widget traversal.py`):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的要点需要注意（参考`8.02 widget traversal.py`）：
- en: The *Tab* key can be used to traverse forward, and *Shift* + *Tab* can be used
    to traverse backwards.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tab*键可以用来向前遍历，而*Shift* + *Tab*可以用来向后遍历。'
- en: The text widget cannot be traversed using the *Tab* key. This is because the
    text widget can contain tab characters as its content. Instead, the text widget
    can be traversed using *Ctrl* + *Tab*.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本小部件不能使用*Tab*键遍历。这是因为文本小部件可以包含制表符作为其内容。相反，可以使用*Ctrl* + *Tab*遍历文本小部件。
- en: Buttons on the widget can be pressed using the spacebar. Similarly, check buttons
    and radio buttons can also be toggled using the spacebar.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用空格键按下小部件上的按钮。同样，复选框和单选按钮也可以使用空格键切换。
- en: You can go up and down the items in a Listbox widget using the up and down arrows.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用上下箭头在列表框小部件中的条目上下移动。
- en: The Scale widget responds to both the left and right keys or up and down keys.
    Similarly, the Scrollbar widget responds to both the left/right or up/down keys,
    depending on their orientation.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放小部件对左右键或上下键都做出响应。同样，滚动条小部件根据其方向对左右/上下键做出响应。
- en: Most of the widgets (except Frame, Label, and Menus) get an outline by default
    when they have the focus set on them. This outline normally displays as a thin
    black border around the widget. You can even set the Frame and Label widgets to
    show this outline by specifying the `highlightthickness` option to a non-zero
    `Integer` value for these widgets.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数小部件（除了框架、标签和菜单）在将焦点设置在其上时默认获得轮廓。这个轮廓通常显示为围绕小部件的细黑边框。你甚至可以将框架和标签小部件设置为显示这个轮廓，通过为这些小部件指定非零的`Integer`值作为`highlightthickness`选项。
- en: We change the color of the outline using `highlightcolor= 'red'` in our code.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在代码中使用`highlightcolor= 'red'`更改轮廓的颜色。
- en: Frame, Label, and Menu are not included in the tab navigation path. However,
    they can be included in the navigation path by using the `takefocus = 1` option.
    You can explicitly exclude a widget from the tab navigation path by setting the
    `takefocus= 0` option.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 框架、标签和菜单不包括在标签导航路径中。然而，可以通过使用`takefocus = 1`选项将它们包含在导航路径中。你可以通过设置`takefocus=
    0`选项显式排除小部件从标签导航路径。
- en: The *Tab* key traverses widgets in the order they were created. It visits a
    parent widget first (unless it is excluded using `takefocus = 0`) followed by
    all its children widgets.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Tab*键按照小部件创建的顺序遍历小部件。它首先访问父小部件（除非使用`takefocus = 0`排除），然后是所有其子小部件。'
- en: You can use `widget.focus_force()` to force the input focus to the widget.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用`widget.focus_force()`强制输入焦点到小部件。
- en: Validating user input
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户输入
- en: Let's now discuss input data validation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论输入数据验证。
- en: Most of the applications we have developed in our book are point and click-based
    (drum machine, chess, drawing application), where validation of user input is
    not required.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在书中开发的大部分应用程序都是基于点击的（鼓机、棋类游戏、绘图应用程序），在这些应用中不需要验证用户输入。
- en: However, data validation is a *must* in programs like our phonebook application,
    where the user enters some data, and we store it in a database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在像我们的电话簿应用程序这样的程序中，数据验证是必须的，因为用户输入一些数据，我们将它们存储在数据库中。
- en: Ignoring the user input validation can be dangerous in such applications because
    input data can be misused for SQL injection. In general, any application where
    an user can enter textual data, is a good candidate for validating user input.
    In fact, it is almost considered a maxim not to trust user inputs.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此类应用程序中忽略用户输入验证可能是危险的，因为输入数据可能被误用于SQL注入。一般来说，任何用户可以输入文本数据的应用程序都是验证用户输入的良好候选者。事实上，几乎可以认为不信任用户输入是一条准则。
- en: A wrong user input may be intentional or accidental. In either case, if you
    fail to validate or sanitize the data, you may cause unexpected error in your
    program. In worst cases, user input can be used to inject harmful code that may
    be capable of crashing a program or wiping out an entire database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的用户输入可能是故意的或偶然的。在任何情况下，如果您未能验证或清理数据，您可能会在程序中引起意外的错误。在最坏的情况下，用户输入可能被用来注入有害代码，这些代码可能足以使程序崩溃或删除整个数据库。
- en: Widgets such as Listbox, Combobox, and Radiobuttons allow limited input options,
    and hence, cannot normally be misused to input wrong data. On the other hand,
    widgets such as Entry widget, Spinbox widget, and Text widget allow a large possibility
    of user inputs, and hence, need to be validated for correctness.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 列表框、组合框和单选按钮等控件允许有限的输入选项，因此通常不能被误用来输入错误的数据。另一方面，输入框控件、微调框控件和文本控件允许用户输入的可能性很大，因此需要验证其正确性。
- en: To enable validation on a widget, you need to specify an additional option of
    the form `validate = 'validationmode'` to the widget.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在控件上启用验证，您需要向控件指定一个额外的选项，形式为 `validate = 'validationmode'`。
- en: 'For example, if you want to enable validation on an entry widget, you begin
    by specifying the validate option as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您想在一个输入框控件上启用验证，您首先指定验证选项如下：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The validation can occur in one of the following **validation modes**:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 验证可以在以下 **验证模式** 之一中发生：
- en: '| Validation Mode | Explanation |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 验证模式 | 说明 |'
- en: '| --- | --- |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `none` | This is the default mode. No validation occurs if `validate` is
    set to `"none"` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 这是默认模式。如果将 `validate` 设置为 `"none"`，则不会发生验证 |'
- en: '| `focus` | When `validate` is set to `"focus"`, the `validate` command is
    called twice; once when the widget receives `focus` and once when the `focus`
    is lost |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `focus` | 当 `validate` 设置为 `"focus"` 时，`validate` 命令被调用两次；一次当控件获得 `focus`
    时，一次当 `focus` 失去时 |'
- en: '| `focusin` | The `validate` command is called when the widget receives `focus`
    |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `focusin` | 当控件获得 `focus` 时调用 `validate` 命令 |'
- en: '| `focusout` | The `validate` command is called when the widget loses `focus`
    |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `focusout` | 当控件失去 `focus` 时调用 `validate` 命令 |'
- en: '| `key` | The `validate` command is called when the entry is `edited` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `key` | 当输入被 `edited` 时调用 `validate` 命令 |'
- en: '| `all` | The `validate` command is called in all the above cases |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 在所有上述情况下调用 `validate` 命令 |'
- en: The code of the `8.03 validation mode demo.py` file demonstrates all these validation
    modes by attaching them to a single validation method. Note the different ways
    different Entry widgets respond to different events. Some Entry widgets call the
    validation method on focus events while others call the validation method at the
    time of entering key strokes into the widget, while still others use a combination
    of focus and key events.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`8.03 validation mode demo.py` 文件的代码通过将它们附加到单个验证方法上来演示所有这些验证模式。注意不同输入框控件对不同事件的响应方式。一些输入框控件在焦点事件上调用验证方法，而其他输入框控件在将按键输入到控件中时调用验证方法，还有一些输入框控件使用焦点和按键事件的组合。'
- en: 'Although we did set the validation mode to trigger the `validate` method, we
    need some sort of data to validate against our rules. This is passed to the `validate`
    method using **percent substitution**. For instance, we passed the mode as an
    argument to our `validate` method by performing a percent substitution on the
    `validate` command, as shown in the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们确实设置了验证模式以触发`validate`方法，但我们仍需要某种数据来与我们的规则进行验证。这是通过**百分比替换**传递给`validate`方法的。例如，我们通过在`validate`命令上执行百分比替换，将模式作为参数传递给我们的`validate`方法，如下所示：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We followed by passing the value of `v` as an argument to our validate method:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后将`v`的值作为参数传递给我们的验证方法：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In addition to `%V`, Tkinter recognizes the following percent substitutions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`%V`之外，Tkinter还识别以下百分比替换：
- en: '| Percent substitutions | Explanation |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 百分比替换 | 说明 |'
- en: '| --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `%d` | Type of action that occurred on the widget—`1` for insert, `0` for
    delete, and `-1` for focus, forced, or textvariable validation. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `%d` | 在小部件上发生的行为类型——`1`为插入，`0`为删除，`-1`为焦点、强制或textvariable验证。 |'
- en: '| `%i` | Index of `char` string inserted or deleted, if any, else it will be
    `-1`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `%i` | 如果有，则插入或删除的`char`字符串的索引，否则为`-1`。 |'
- en: '| `%P` | The value of the entry if the edit is allowed. If you are configuring
    the Entry widget to have a new textvariable, this will be the value of that textvariable.
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `%P` | 如果允许编辑，则输入的值。如果你正在配置Entry小部件以具有新的textvariable，这将是该textvariable的值。
    |'
- en: '| `%s` | The current value of entry, prior to editing. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `%s` | 编辑前的当前输入值。 |'
- en: '| `%S` | The text string being inserted/deleted, if any, `{}` otherwise. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `%S` | 如果有，则插入或删除的文本字符串，否则为`{}`。 |'
- en: '| `%v` | The type of validation currently set. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `%v` | 当前设置的验证类型。 |'
- en: '| `%V` | The type of validation that triggered the callback method (key, focusin,
    focusout, and forced). |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `%V` | 触发回调方法的验证类型（键、focusin、focusout和强制）。 |'
- en: '| `%W` | The name of the Entry widget. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `%W` | Entry小部件的名称。 |'
- en: These validations provide us with the necessary data we can use to validate
    the input.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些验证为我们提供了我们可以用来验证输入的必要数据。
- en: 'Let''s now pass all these data and just print them through a dummy `validate`
    method just to see the kind of data we can expect to get for carrying out our
    validations (refer to the code of `8.04 percent substitutions demo.py`):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将这些数据全部传递，并通过一个虚拟的`validate`方法打印出来，以便查看我们可以期望得到哪些数据来进行我们的验证（参考`8.04 percent
    substitutions demo.py`的代码）：
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Take particular note of data returned by `%P` and `%s`, because they pertain
    to the actual data entered by the user in the Entry widget.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意由`%P`和`%s`返回的数据，因为它们与用户在Entry小部件中实际输入的数据有关。
- en: In most cases, you will be checking either of these two data against your validation
    rules.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你将检查以下两种数据之一以符合你的验证规则。
- en: Now that we have a background of rules of data validation, let's see two practical
    examples that demonstrate input validation.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了数据验证的规则背景，让我们看看两个实际示例，这些示例展示了输入验证。
- en: Key Validation
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键验证
- en: 'Let''s assume that we have a form that asks for a user''s name. We want the
    user to input only alphabets or space characters in the name. Thus, any number
    or special character is not to be allowed, as shown in the following screenshot
    of the widget:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个要求用户输入姓名的表单。我们希望用户只输入字母或空格字符。因此，不允许数字或特殊字符，如下面的小部件截图所示：
- en: '![Key Validation](img/7941OT_08_03.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![关键验证](img/7941OT_08_03.jpg)'
- en: 'This is clearly a case of `''key''` validation mode, because we want to check
    if an entry is valid after every key press. The percent substitution that we need
    to check is `%S`, because it yields the text string being inserted or deleted
    in the Entry widget. Accordingly, the code that validates the entry widget is
    as follows (refer to `8.05 key validation.py`):'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一个`'key'`验证模式的案例，因为我们希望在每次按键后检查输入是否有效。我们需要检查的百分比替换是`%S`，因为它会返回在Entry小部件中插入或删除的文本字符串。因此，验证Entry小部件的代码如下（参考`8.05
    key validation.py`）：
- en: '[PRE6]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: We first register two options `validatecommand` (`vcmd`) and `invalidcommand`
    (`invcmd`).
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先注册了两个选项`validatecommand`（`vcmd`）和`invalidcommand`（`invcmd`）。
- en: In our example, `validatecommand` is registered to call the `validate_data`
    method, and the `invalidcommand` option is registered to call another method named
    `invalid_name`.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的例子中，`validatecommand`被注册为调用`validate_data`方法，而`invalidcommand`选项被注册为调用另一个名为`invalid_name`的方法。
- en: The `validatecommand` option specifies a method to be evaluated which would
    validate the input. The validation method must return a Boolean value, where a
    `True` signifies that the data entered is valid, and a `False` return value signifies
    that data is invalid.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`validatecommand` 选项指定了一个用于验证输入的方法。验证方法必须返回一个布尔值，其中 `True` 表示输入的数据有效，而 `False`
    返回值表示数据无效。'
- en: If the validate method returns `False` (invalid data), no data is added to the
    Entry widget and the script registered for `invalidcommand` is evaluated. In our
    case, a `False` validation would call the `invalid_name` method. The `invalidcommand`
    method is generally responsible for displaying error messages or setting back
    the focus to the Entry widget.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果验证方法返回 `False`（无效数据），则不会将数据添加到 Entry 小部件中，并且会评估为 `invalidcommand` 注册的脚本。在我们的例子中，一个
    `False` 的验证会调用 `invalid_name` 方法。`invalidcommand` 方法通常负责显示错误消息或将焦点设置回 Entry 小部件。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Let's look at the code `register(self, func, subst=None, needcleanup=1)`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码 `register(self, func, subst=None, needcleanup=1)`。
- en: The `register` method returns a newly created `Tcl` function. If this function
    is called, the Python function `func` is executed. If an optional function `subst`
    is provided it is executed before `func`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`register` 方法返回一个新创建的 `Tcl` 函数。如果调用此函数，则执行 Python 函数 `func`。如果提供了可选函数 `subst`，则它会在
    `func` 执行之前执行。'
- en: Focus Out Validation
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Focus Out Validation
- en: The previous example demonstrated validation in `'key'` mode. This means that
    the validation method was called after every key press to check if the entry was
    valid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例演示了 `'key'` 模式下的验证。这意味着验证方法在每次按键后都会被调用，以检查输入是否有效。
- en: However, there are situations when you might want to check the entire string
    entered into the widget, rather than checking individual key stroke entries.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，你可能希望检查小部件中输入的整个字符串，而不是检查单个按键输入。
- en: For example, if an Entry widget accepts a valid e-mail address, we would ideally
    like to check the validity after the user has entered the entire e-mail address,
    and not after every key stroke entry. This would qualify as validation in `'focusout'`
    mode.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 Entry 小部件接受有效的电子邮件地址，我们希望在用户输入整个电子邮件地址后检查其有效性，而不是在每次按键输入后检查。这可以视为 `'focusout'`
    模式下的验证。
- en: '![Focus Out Validation](img/7941OT_08_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![Focus Out Validation](img/7941OT_08_04.jpg)'
- en: 'Check out the code of `8.06 focus out validation.py` for a demonstration on
    e-mail validation in the `focusout` mode:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `8.06 focus out validation.py` 的代码，以了解在 `'focusout'` 模式下的电子邮件验证示例：
- en: '[PRE7]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的描述如下：
- en: 'The code has a lot of similarities to the previous validation example. However,
    note the following differences:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与之前的验证示例有很多相似之处。然而，请注意以下差异：
- en: The validate mode is set to `'focusout'` in contrast to the `'key'` mode in
    the previous example. This means that the validation would be done only when the
    Entry widget loses `focus`.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证模式设置为 `'focusout'`，与之前示例中的 `'key'` 模式不同。这意味着只有在 Entry 小部件失去焦点时才会进行验证。
- en: This program uses data provided by the `%P` percentage substitution, in contrast
    to `%S`, as used in the previous example. This is understandable as `%P` provides
    the value entered in the Entry widget, but `%S` provides the value of the last
    key stroke.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序使用 `%P` 百分比替换提供的数据，而不是之前示例中使用的 `%S`。这是可以理解的，因为 `%P` 提供了 Entry 小部件中输入的值，而
    `%S` 提供了最后按键的值。
- en: 'This program uses regular expressions to check if the entered value corresponds
    to a valid e-mail format. Validation usually relies on regular expressions and
    a whole lot of explanation to cover this topic, but it is out of the scope of
    this project and the book. For more information on regular expression modules,
    visit the following link:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该程序使用正则表达式检查输入的值是否对应有效的电子邮件格式。验证通常依赖于正则表达式和大量的解释来涵盖这个主题，但这超出了本项目和本书的范围。有关正则表达式模块的更多信息，请访问以下链接：
- en: '[http://docs.python.org/2/library/re.html](http://docs.python.org/2/library/re.html)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Python 2 库参考](http://docs.python.org/2/library/re.html)'
- en: This concludes our discussion on input validation in Tkinter. Hopefully, you
    should now be able to implement input validation to suit your custom needs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对 Tkinter 中输入验证的讨论。希望你现在能够实现满足你自定义需求的输入验证。
- en: Formatting widget data
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化小部件数据
- en: Several input data such as date, time, phone number, credit card number, website
    URL, IP number, and so on have an associated display format. For instance, date
    is better represented in a MM/DD/YYYY format.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 日期、时间、电话号码、信用卡号码、网站URL、IP地址等多种输入数据都有相关的显示格式。例如，日期最好以MM/DD/YYYY格式表示。
- en: Fortunately, it is easy to format the data in the required format as the user
    enters them in the widget (refer to `8.07 formatting entry widget to display date.py`).
    The mentioned Python file formats the user input automatically to insert forward
    slashes at the required places to display user-entered date in the MM/DD/YYYY
    format.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，当用户在组件中输入数据时，格式化所需格式的数据很容易（参考`8.07 formatting entry widget to display date.py`）。提到的Python文件会自动格式化用户输入，在需要的位置插入正斜杠，以便以MM/DD/YYYY格式显示用户输入的日期。
- en: '![Formatting widget data](img/7941OT_08_05.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![格式化组件数据](img/7941OT_08_05.jpg)'
- en: '[PRE8]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的描述如下：
- en: The Entry widget is bound to the key press event, where every new key press
    calls the related callback `format_date_entry_widget` method.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Entry组件绑定到按键事件，每次新的按键都会调用相关的回调`format_date_entry_widget`方法。
- en: First, the `format_date_entry_widget` method breaks down the entered text into
    an equivalent list by the name `entrylist`, also ignoring any slash `'/'` symbol
    if entered by the user.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，`format_date_entry_widget`方法将输入文本分解为名为`entrylist`的等效列表，同时忽略用户输入的任何斜杠`'/'`符号。
- en: It then iterates through the `self.slashpositions` list and inserts the slash
    symbol at all required positions in the `entrylist` argument. The net result of
    this is a list that has slash inserted at all the right places.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，它遍历`self.slashpositions`列表，并在`entrylist`参数的所有必需位置插入斜杠符号。最终结果是，在所有正确位置都插入了斜杠的列表。
- en: The next line converts this list into an equivalent string using `join()`, and
    then sets the value of our Entry widget to this string. This ensures that the
    Entry widget text is formatted into the aforementioned date format.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行使用`join()`将此列表转换为等效的字符串，然后将Entry组件的值设置为该字符串。这确保了Entry组件的文本格式化为上述日期格式。
- en: The remaining pieces of code simply control the cursor to ensure that the cursor
    advances by one position whenever it encounters a slash symbol. It also ensures
    that key presses, such as `'BackSpace'`, `'Right'`, `'Left'`, `'Up'`, and `'Down'`
    are handled properly.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余的代码仅控制光标，确保光标在遇到斜杠符号时前进一个位置。它还确保正确处理按键，如`'BackSpace'`、`'Right'`、`'Left'`、`'Up'`和`'Down'`。
- en: Note that this method does not validate the date value and the user may add
    any invalid date. The method defined here will simply format it by adding forward
    slash at third and sixth positions. Adding date validation to this example is
    left as an exercise for you to complete.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法不验证日期值，用户可以添加任何无效日期。这里定义的方法将简单地通过在第三位和第六位添加正斜杠来格式化它。将日期验证添加到此示例作为你的练习任务。
- en: This concludes our brief discussion on formatting data within widgets. Hopefully,
    you should now be able to create formatted widgets for a wide variety of input
    data that can be displayed better in a given format.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对在组件内格式化数据的简要讨论。希望你现在能够创建用于广泛输入数据的格式化组件，这些数据可以在给定的格式中更好地显示。
- en: More on fonts
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于字体
- en: Many Tkinter widgets let you specify custom font specifications either at the
    time of widget creation or later using the `configure()` option. For most cases,
    default fonts provide a standard look and feel. However, should you want to change
    font specifications, Tkinter lets you do so. There is one caveat though.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Tkinter组件允许你在组件创建时或稍后使用`configure()`选项指定自定义字体规范。在大多数情况下，默认字体提供了标准的视觉和感觉。然而，如果你想更改字体规范，Tkinter允许你这样做。但有一个注意事项。
- en: When you specify your own font, you need to make sure it looks good on all platforms
    where the program is intended to be deployed. This is because a font might look
    good and match well on a particular platform, but may look awful on another. Unless
    you know what you are doing, it is always advisable to stick to Tkinter's default
    fonts.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定自己的字体时，你需要确保它在程序打算部署的所有平台上看起来都很好。这是因为字体可能在某个特定平台上看起来很好，匹配得很好，但在另一个平台上可能看起来很糟糕。除非你了解自己在做什么，否则始终建议坚持使用Tkinter的默认字体。
- en: Most platforms have their own set of standard fonts that are used by the platform's
    native widgets. So, rather than trying to reinvent the wheel on what looks good
    on a given platform or what would be available for a given platform, Tkinter assigns
    these standard platform-specific fonts into its widget, thus providing a native
    look and feel on every platform.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数平台都有自己的标准字体集，这些字体由平台的本地小部件使用。因此，而不是试图在特定平台上重新发明轮子，或者为特定平台提供什么字体可用，Tkinter将这些标准平台特定字体分配给其小部件，从而在所有平台上提供本地外观和感觉。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Tkinter assigns nine fonts to nine different names, which you can therefore
    use in your programs. The font names are as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter将九种字体分配给九个不同的名称，因此您可以在程序中使用这些名称。字体名称如下：
- en: '`TkDefaultFont`'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkDefaultFont`'
- en: '`TkTextFont`'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkTextFont`'
- en: '`TkFixedFont`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkFixedFont`'
- en: '`TkMenuFont`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkMenuFont`'
- en: '`TkHeadingFont`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkHeadingFont`'
- en: '`TkCaptionFont`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkCaptionFont`'
- en: '`TkSmallCaptionFont`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkSmallCaptionFont`'
- en: '`TkIconFont`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkIconFont`'
- en: '`TkTooltipFont`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TkTooltipFont`'
- en: 'Accordingly, you can use them in your programs in the following way:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在程序中以以下方式使用它们：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using these kinds of fonts mark up, you can be assured that your font will look
    native across all platforms.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类型的字体标记，您可以确保您的字体在所有平台上看起来都是本地的。
- en: Finer Control over Font
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更精细的字体控制
- en: 'In addition to the above method on handling fonts, Tkinter provides a separate
    `Font` class implementation. The source code of this class is located at the following
    link: <`Python27_installtion_dir>\Lib\lib-tk\tkfont.py`.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述处理字体的方法外，Tkinter还提供了一个单独的`Font`类实现。该类的源代码位于以下链接：`<Python27_installtion_dir>\Lib\lib-tk\tkfont.py`。
- en: 'To use this module, you need to import `tkFont` into your namespace.(refer
    to `8.08 tkfont demo.py`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此模块，您需要将`tkFont`导入到您的命名空间中。（参考`8.08 tkfont demo.py`）：
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The console output of this program is as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的控制台输出如下：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As you can see, the `tkfont` module provides a much better fine-grained control
    over various aspects of fonts, which are otherwise inaccessible.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`tkfont`模块提供了对字体各个方面的更精细控制，这些方面在其他情况下是无法访问的。
- en: Font Selector
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字体选择器
- en: 'Now that we have seen the basic features available in the `tkfont` module,
    let''s use it to implement a font selector. The font selector would look like
    the one shown here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了`tkfont`模块中可用的基本功能，让我们用它来实现一个字体选择器。字体选择器看起来就像这里展示的那样：
- en: '![Font Selector](img/7941OT_08_06.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![字体选择器](img/7941OT_08_06.jpg)'
- en: 'The code for the font selector is as follows (refer to `8.09 font selector.py`):'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 字体选择器的代码如下（参考`8.09 font selector.py`）：
- en: '[PRE12]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的描述如下：
- en: We import `Tkinter` (for all widgets), `ttk` (for the Combobox widget), and
    `tkfont` for handling font-related aspects of the program
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们导入`Tkinter`（用于所有小部件）、`ttk`（用于组合框小部件）和`tkfont`来处理程序中与字体相关的方面。
- en: We create a class named `FontSelectorDemo` and use its `__init_` method to initialize
    al attributes that we intend to track in our program.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`FontSelectorDemo`的类，并使用其`__init__`方法初始化我们打算在程序中跟踪的所有属性。
- en: Finally, the `__init__` method calls another method named `gui_creator()`, which
    is be responsible for creating all the GUI elements of the program
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`__init__`方法调用另一个名为`gui_creator()`的方法，该方法负责创建程序的所有GUI元素。
- en: Creating the GUI
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GUI
- en: 'The code represented here is a highly abridged version of the actual code (refer
    to `8.09 font selector.py`). Here, we removed all the code that creates basic
    widgets, such as Label and Checkbuttons, in order to show only the font-related
    code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示的代码是实际代码的高度精简版（参考`8.09 font selector.py`）。在这里，我们移除了所有创建基本小部件（如标签和复选框）的代码，以便只展示与字体相关的代码：
- en: '[PRE13]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的描述如下：
- en: We have highlighted the code that creates two Combobox widgets; one for the
    **Font Family**, and the other for the **Font Size** selection.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们突出显示了创建两个组合框小部件的代码；一个用于**字体家族**选择，另一个用于**字体大小**选择。
- en: We use `tkfont.families()` to fetch the list of all the fonts installed on a
    computer. This is converted into a list format and sorted before it is inserted
    into the `fontList` Combobox widget.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`tkfont.families()`获取计算机上安装的所有字体的列表。该列表被转换为列表格式并排序后，插入到`fontList`组合框小部件中。
- en: Similarly, we add a font size range of values from `6` to `70` in the **Font
    Size** combobox.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，我们在**字体大小**组合框中添加了从`6`到`70`的字体大小范围。
- en: We also add four Checkbutton widgets to keep track of font styles **bold**,
    **italics**, **underline**, and **overstrike**. The code for this has not been
    shown previously, because we have created similar check buttons in some of our
    previous programs.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还添加了四个 Checkbutton 小部件来跟踪字体样式 **粗体**、**斜体**、**下划线** 和 **删除线**。这个代码之前没有展示过，因为我们已经在之前的程序中创建了一些类似的复选按钮。
- en: We then add a Text widget and insert a sample text into it. More importantly,
    we add a tag to the text named `fontspec`.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们添加一个 Text 小部件并将样本文本插入其中。更重要的是，我们在文本中添加了一个名为 `fontspec` 的标签。
- en: Finally, all our widgets have a command callback method connecting back to a
    common method named `on_value_change`. This method will be responsible for updating
    the display of the sample text at the time of changes in the values of any of
    the widgets.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们所有的小部件都有一个命令回调方法，该方法连接回一个名为 `on_value_change` 的公共方法。这个方法将负责在任何一个小部件的值发生变化时更新样本文本的显示。
- en: Updating Sample Text
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新样本文本
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的描述如下：
- en: This method is called at the time of a state change for any of the widgets
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当任何小部件的状态发生变化时，将调用此方法
- en: This method simply fetches all font data and configures our `currentfont` attribute
    with the updated font values
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法只是获取所有字体数据，并使用更新的字体值配置我们的 `currentfont` 属性
- en: Finally, it updates the text content tagged as `fontspec` with the values of
    the current font
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它更新了标记为 `fontspec` 的文本内容，并使用当前字体的值
- en: Working with Unicode characters
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Unicode 字符
- en: Computers only understand binary numbers. Therefore, all that you see on your
    computer, for example, texts, images, audio, video, and so on need to be expressed
    in terms of binary numbers.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机只理解二进制数字。因此，你在电脑上看到的所有内容，例如文本、图像、音频、视频等，都需要用二进制数字来表示。
- en: This is where encoding comes into play. An **encoding** is a set of standard
    rules that assign unique numeral values to each text character.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是编码发挥作用的地方。**编码** 是一组标准规则，为每个文本字符分配唯一的数值。
- en: Python 2.*x* default encoding is ASCII (American Standard Code for Information
    Interchange). The ASCII character encoding is a 7-bit encoding that can encode
    2 ^7 (128) characters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.*x* 的默认编码是 ASCII（美国信息交换标准代码）。ASCII 字符编码是一种 7 位编码，可以编码 2 ^7（128）个字符。
- en: Because ASCII encoding was developed in America, it encodes characters from
    the English alphabet, namely, the numbers 0-9, the letters a-z and A-Z, some common
    punctuation symbols, some teletype machine control codes, and a blank space.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ASCII 编码是在美国开发的，它编码了英语字母表中的字符，即数字 0-9、字母 a-z 和 A-Z、一些常见的标点符号、一些电传打字机控制代码以及一个空格。
- en: 'It is here that Unicode encoding comes to our rescue. The following are the
    key features of Unicode encoding:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这里，Unicode 编码来拯救我们。以下是 Unicode 编码的关键特性：
- en: It is a way to represent text without bytes
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一种表示文本而不使用字节数的方式
- en: It provides unique code point for each character of every language
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它为每种语言的每个字符提供唯一的代码点
- en: It defines more than a million code points, representing characters of all major
    scripts on the earth
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了超过一百万个代码点，代表地球上所有主要文字的字符
- en: Within Unicode, there are several **Unicode Transformation Formats** (**UTF**)
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unicode 中，有几个 **Unicode 转换格式**（**UTF**）
- en: UTF-8 is one of the most commonly used encodings, where **8** means that 8-bit
    numbers are used in the encoding
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-8 是最常用的编码之一，其中 **8** 表示在编码中使用 8 位数字。
- en: Python also supports UTF-16 encoding, but it's less frequently used, and UTF-32
    is not supported by Python 2.*x*
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 也支持 UTF-16 编码，但使用频率较低，Python 2.*x* 不支持 UTF-32
- en: 'Say you want to display a Hindi character on a Tkinter Label widget. You would
    intuitively try to run a code like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想在 Tkinter 标签小部件上显示一个印地文字符。你会直观地尝试运行以下代码：
- en: '[PRE15]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If you try to run the previous code, you will get an error message as follows:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试运行前面的代码，你会得到以下错误消息：
- en: '[PRE16]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This means that Python 2.*x*, by default, cannot handle non-ASCII characters.
    Python standard library supports over 100 encodings, but if you are trying to
    use anything other than ASCII encoding you have to explicitly declare the encoding.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 Python 2.*x* 默认不能处理非 ASCII 字符。Python 标准库支持超过 100 种编码，但如果你尝试使用除 ASCII 编码以外的任何编码，你必须明确声明编码。
- en: 'Fortunately, handling other encodings is very simple in Python. There are two
    ways in which you can deal with non-ASCII characters. They are described in the
    following sections:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Python 中处理其他编码非常简单。您可以通过以下两种方式处理非 ASCII 字符。它们将在以下章节中描述：
- en: Declaring line encoding
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明行编码
- en: 'The first way is to mark a string containing Unicode characters with the prefix
    `u` explicitly, as shown in the following code snippet (refer to `8.10 line encoding.py`):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法是在包含 Unicode 字符的字符串前显式标记前缀 `u`，如下面的代码片段所示（参考 `8.10 行编码.py`）：
- en: '[PRE17]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you try to run this program from IDLE, you get a warning message similar
    to the following one:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试从 IDLE 运行此程序时，您会收到类似于以下警告消息：
- en: '![Declaring line encoding](img/7941OT_08_07.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![声明行编码](img/7941OT_08_07.jpg)'
- en: Simply click on **Ok** to save this file as UTF-8 and run this program to display
    the Unicode label.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地点击**确定**以将此文件保存为 UTF-8 编码，并运行此程序以显示 Unicode 标签。
- en: Declaring file encoding
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明文件编码
- en: 'Alternatively, you can explicitly declare the entire file to have UTF-8 encoding
    by including a header declaration in your source file in the following format:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过在源文件中包含以下格式的头声明来显式声明整个文件具有 UTF-8 编码：
- en: '[PRE18]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'More precisely, the header declaration must match the regular expression:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 更精确地说，头声明必须匹配以下正则表达式：
- en: '[PRE19]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This declaration must be included in either the first or second line of your
    program. If you add some other declaration or comments in the first two lines,
    Python won't recognize this as a header declaration.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此声明必须包含在程序的第一行或第二行。如果您在第一行或第二行添加其他声明或注释，Python 不会将其识别为头声明。
- en: 'So, if you are dealing with UTF-8 characters, you will add the following header
    declaration in the first or second line of your Python program:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您正在处理 UTF-8 字符，您将在 Python 程序的第一行或第二行添加以下头声明：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Simply by adding this header declaration, your Python program can now recognize
    Unicode characters. So, our code can be rewritten as (refer to `8.11 file encoding.py`):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加此头声明，您的 Python 程序现在可以识别 Unicode 字符。因此，我们的代码可以重写为（参考 `8.11 文件编码.py`）：
- en: '[PRE21]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Both of the above code examples generate an interface similar to the one shown
    here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个代码示例生成的界面与下面所示类似：
- en: '![Declaring file encoding](img/7941OT_08_08.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![声明文件编码](img/7941OT_08_08.jpg)'
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default encoding in Python 3.*x* is Unicode (UTF-8). This means that you
    don't need an explicit Unicode declaration in Python 3.*x* to display non-ASCII
    characters.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.*x* 的默认编码是 Unicode（UTF-8）。这意味着在 Python 3.*x* 中，您不需要显式 Unicode 声明来显示非
    ASCII 字符。
- en: Tkinter class's hierarchy
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 类的层次结构
- en: As programmers, we hardly need to understand the class hierarchy of Tkinter.
    After all, we have been able to code all the applications so far without bothering
    about the overall class hierarchy.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 作为程序员，我们几乎不需要理解 Tkinter 的类层次结构。毕竟，我们到目前为止已经能够编写所有应用程序，而不必担心整体类层次结构。
- en: However, knowing about class hierarchy enables us to trace the origin of a method
    within the source code or source documentation of a method. A brief review of
    the class hierarchy will also help us prevent accidental overriding of methods
    in our programs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，了解类层次结构使我们能够追踪源代码或方法源文档中方法的起源。对类层次结构进行简要回顾也有助于我们防止在程序中意外覆盖方法。
- en: In order to understand the class hierarchy of Tkinter, let us take a look at
    the source code of Tkinter. On Windows installation, the source code of Tkinter
    is located at `C:\Python27\Lib\lib-tk\Tkinter.py`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Tkinter 的类层次结构，让我们看看 Tkinter 的源代码。在 Windows 安装中，Tkinter 的源代码位于 `C:\Python27\Lib\lib-tk\Tkinter.py`。
- en: 'When we open this file in a code editor and look at its list of class definitions,
    we can see the following structure:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在代码编辑器中打开此文件并查看其类定义列表时，我们可以看到以下结构：
- en: '![Tkinter class''s hierarchy](img/7941OT_08_09.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![Tkinter 类的层次结构](img/7941OT_08_09.jpg)'
- en: So, what do we notice here? We have class definitions for each of the core Tkinter
    widgets. In addition, we have class definitions for different geometry managers
    and different variable types defined within Tkinter. These class definitions are
    what you would normally expect to be there.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们在这里注意到什么？我们为每个核心 Tkinter 小部件定义了类。此外，我们还为 Tkinter 内部定义的不同几何管理器和不同变量类型定义了类。这些类定义正是您通常期望存在的。
- en: However, in addition to these, we notice some strange-looking class names, such
    as `BaseWidget, Misc, Tk,` `Toplevel, Widget`, and `Wm`. All these classes are
    circled in the above screenshot. So what services do these classes provide, and
    where do they fit in the larger scheme of things?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这些之外，我们注意到一些看起来很奇怪的类名，例如 `BaseWidget, Misc, Tk,` `Toplevel, Widget`, 和
    `Wm`。所有这些类在上面的截图中都圈出来了。那么这些类提供了什么服务，它们在更大的体系结构中处于什么位置？
- en: 'Let''s use the `inspect` module to look at the class hierarchy of Tkinter.
    We will first inspect the class hierarchy of the Frame widget as a representation
    of class hierarchies for all other widgets. We will also look at the class hierarchy
    of the `Tk` and `Toplevel` classes to estimate their role in the overall class
    hierarchy of Tkinter (refer to `8.12 tkinter class hierarchy.py`):'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `inspect` 模块来查看 Tkinter 的类层次结构。我们将首先检查 Frame 小部件的类层次结构，以代表所有其他小部件的类层次结构。我们还将查看
    `Tk` 和 `Toplevel` 类的类层次结构，以估计它们在 Tkinter 整体类层次结构中的角色（参考 `8.12 tkinter class hierarchy.py`）：
- en: '[PRE22]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the preceding program is as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序输出如下：
- en: '[PRE23]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的描述：
- en: The `getmro(classname)` function from the inspect module returns a tuple, consisting
    of all the ancestors of `classname` in the order specified by the **Method Resolution
    Order** (**MRO**). Method Resolution Order refers to the order in which base classes
    are searched when looking for a given method.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspect` 模块中的 `getmro(classname)` 函数返回一个元组，包含 `classname` 的所有祖先，按照 **方法解析顺序**（**MRO**）指定的顺序。方法解析顺序指的是在查找给定方法时搜索基类的顺序。'
- en: By inspecting the MRO and the source code, we come to know that the `Frame`
    class inherits from the `Widget` class, which in turn inherits from the `BaseWidget`
    class.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过检查 MRO 和源代码，我们得知 `Frame` 类继承自 `Widget` 类，而 `Widget` 类又继承自 `BaseWidget` 类。
- en: In addition, the `Frame` class also inherits from the `Misc` class, which is
    a generic **mixin** that provides a lot of functionality that we have used in
    our applications.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`Frame` 类还继承自 `Misc` 类，这是一个通用的 **混合类**，为我们提供了在应用程序中使用的大量功能。
- en: 'For a list of functionalities provided by the `Misc` class, run the following
    commands into your Python interactive shell:'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取 `Misc` 类提供的功能列表，请在您的 Python 交互式 shell 中运行以下命令：
- en: '[PRE24]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, all our widgets get properties from the geometry mixins—Pack, Grid,
    and Place.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们所有的部件都从几何混合类（Pack、Grid 和 Place）获取属性。
- en: Next, let us take a look at the `Tk` and `Toplevel` classes.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，让我们看一下 `Tk` 和 `Toplevel` 类。
- en: The `Tk` class represents the Toplevel widget of Tkinter, which represents the
    main window of an application. The `Toplevel` class provides several methods for
    constructing and managing a Toplevel widget with a given parent.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Tk` 类代表 Tkinter 的 Toplevel 小部件，它表示应用程序的主窗口。`Toplevel` 类提供了一些方法来构建和管理具有给定父级的小部件。'
- en: 'For a list of methods provided by the `Toplevel` and `Tk` classes, run the
    following commands into your Python interactive shell:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要获取 `Toplevel` 和 `Tk` 类提供的方法列表，请在您的 Python 交互式 shell 中运行以下命令：
- en: '[PRE25]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In addition to inheriting from the `Misc` mixin class, the `Toplevel` and `Tk`
    classes also inherit methods from the `Wm` mixin class.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了继承自 `Misc` 混合类之外，`Toplevel` 和 `Tk` 类还继承自 `Wm` 混合类。
- en: 'The `Wm` (window manager) mixin class provides a lot of functions to communicate
    with the window manager. For a list of functions provided by the `Wm` class, run
    the following command into your Python interactive shell:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wm`（窗口管理器）混合类提供了许多与窗口管理器通信的功能。要获取 `Wm` 类提供的功能列表，请在您的 Python 交互式 shell 中运行以下命令：'
- en: '[PRE26]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After translating the class hierarchy—as obtained from the previous program—into
    an image, we get a hierarchy image similar to the one shown in the following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 将从上一个程序中获得类层次结构转换为图像后，我们得到一个类似于以下图像的层次结构图像：
- en: '![Tkinter class''s hierarchy](img/7941OT_08_10.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![Tkinter 类的层次结构](img/7941OT_08_10.jpg)'
- en: In addition to the normal inheritance relation (shown in the preceding diagram
    by unspotted lines), Tkinter provides a list of mixins (or helper classes). A
    **mixin** is a class that is designed not to be used directly, but to be combined
    with other classes using multiple inheritances.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 除了正常继承关系（如前图所示的无标记线条所示），Tkinter 还提供了一系列混合类（或辅助类）。**混合类**是一种设计用来不直接使用，而是通过多重继承与其他类结合使用的类。
- en: 'Tkinter mixins can be broadly classified into two categories:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 混合类可以大致分为两类：
- en: Geometry mixins, which includes the Grid, Pack, and Place classes
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几何混合类，包括 Grid、Pack 和 Place 类
- en: 'Implementation mixins, which includes:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现混合类，包括：
- en: The `Misc` class, which is used by the root window and widget classes, provides
    several Tk and window-related services
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Misc` 类，该类被根窗口和窗口小部件类使用，提供了几个 Tk 和窗口相关服务'
- en: The `Wm` class, which is used by the root window and the Toplevel widget, provides
    several window manager services.
  id: totrans-261
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Wm` 类，该类被根窗口和 Toplevel 窗口小部件使用，提供了几个窗口管理服务。'
- en: Custom-made mixins
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义混合类
- en: 'We created a "bare bone" GUI framework in order to avoid repetition of the
    code that creates widgets. Similar to this concept, there is another way to avoid
    writing boilerplate code by using what are named **custom GUI mixins**. Take for
    example, the code of `8.13 creating custom mixins.py`. This program creates an
    interface similar to the one shown here:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个“裸骨”GUI 框架，以避免重复创建小部件的代码。类似于这个概念，还有一种方法可以通过使用所谓的**自定义 GUI 混合**来避免编写样板代码。以`8.13
    创建自定义混合.py`的代码为例。这个程序创建了一个类似于下面展示的界面：
- en: '![Custom-made mixins](img/7941OT_08_11.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![自定义混合类](img/7941OT_08_11.jpg)'
- en: 'Let''s look at the code of `8.13 creating custom mixins.py`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`8.13 创建自定义混合.py`的代码：
- en: '[PRE27]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The description of the preceding code is as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的描述如下：
- en: This program first creates functions for different widgets, such as Frame, Label,
    Button, and Entry. Each method can be named a mixin, because it takes care of
    both widget creation and its geometry management using the grid method. These
    are essentially convenience functions to help us avoid writing similar code for
    a similar set of widgets.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个程序首先为不同的窗口小部件创建函数，例如 Frame、Label、Button 和 Entry。每个方法都可以命名为混合类，因为它使用网格方法同时处理窗口小部件的创建和几何形状管理。这些本质上是为了帮助我们避免为类似的一组窗口小部件编写相似代码的便利函数。
- en: Now, in the main section of the program, we can create a widget in a single
    line of code without having to add a separate line for handling its geometry.
    The end result of this is fewer lines of code in our actual program. This strategy
    can reduce the size of your program by many lines if there are a large number
    of widgets in your program.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，在程序的主要部分，我们可以通过一行代码创建一个窗口小部件，而无需为处理其几何形状添加单独的一行。这样做的结果是，我们的实际程序中的代码行数更少。如果程序中有大量窗口小部件，这种策略可以减少程序的大小。
- en: Note
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: However, mixins are highly case specific. A mixin defined for one particular
    case scenario or application may not be applicable to another application. For
    instance, while defining the earlier mentioned mixins, we made a few assumptions,
    such as all our widgets will use the grid geometry manager, and similarly, buttons
    would stick to east and entries would stick to the west side. These assumptions
    may not hold for a different application.
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，混合类非常特定于案例。为特定案例场景或应用程序定义的混合类可能不适用于另一个应用程序。例如，在定义前面提到的混合类时，我们做了一些假设，比如我们所有的窗口小部件都将使用网格几何形状管理器，同样，按钮会粘附在东部，而输入框会粘附在西部。这些假设可能不适用于不同的应用程序。
- en: Tips for code cleanup and program optimization
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码清理和程序优化的技巧
- en: Let's now spend some time discussing the tips and tricks that will help improve
    the performance of our Python program. In a normal case scenario of GUI programming,
    this generally involves speeding up sections of program that contribute to improving
    the overall user experience.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们花些时间讨论一些技巧和窍门，这些技巧和窍门将有助于提高我们 Python 程序的性能。在正常的 GUI 编程案例中，这通常涉及加快对提高整体用户体验有贡献的程序部分。
- en: Program optimization is often obsessively taken as an exercise in reducing code
    execution time. For programs where timing is a crucial factor, this obsession
    is genuine. However, if you are developing a simple GUI application, a correct
    and consistent user experience is generally more important than mere fast user
    experience.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 程序优化通常被狂热地视为减少代码执行时间的练习。对于时间是一个关键因素的程序，这种狂热是真实的。然而，如果你正在开发一个简单的 GUI 应用程序，正确和一致的用户体验通常比仅仅快速的用户体验更重要。
- en: Trying to optimize a code even before it is functional is premature optimization
    and should be avoided. However, a GUI program with correct but considerably long
    response time probably needs to be optimized, and this is the subject of discussion
    of the following sections.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码尚未功能化之前就尝试优化代码是过早优化，应该避免。然而，一个响应时间正确但相当长的 GUI 程序可能需要优化，这是下文讨论的主题。
- en: Choose the right data structure
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择合适的数据结构
- en: Selecting the right data structure can have a profound impact on the performance
    of a program. If your program is to spend considerable time on lookups, use a
    dictionary, if feasible. When all you need is to traverse over a collection, prefer
    to choose a list over dictionaries, because dictionaries take more space.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 选择合适的数据结构可以对程序的性能产生深远的影响。如果你的程序在查找上要花费大量时间，如果可能的话，使用字典。当你只需要遍历集合时，更倾向于选择列表而不是字典，因为字典占用更多空间。
- en: When your data is immutable, prefer to choose tuples over lists, because tuples
    can be traversed faster than lists.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的数据是不可变的，更倾向于选择元组而不是列表，因为元组比列表更快地遍历。
- en: Working with Variables
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量操作
- en: The way you select variables in your program can considerably affect the speed
    of the execution of your program. For instance, if you do not need to change the
    content or attributes of a widget after its instantiation, do not create a class-wide
    instance of the widget.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你在程序中选择变量的方式可以显著影响程序执行的效率。例如，如果你在实例化小部件后不需要更改其内容或属性，那么不要创建小部件的全局实例。
- en: 'For example, if a Label widget is to remain static, use `Label(root, text=''Name'').pack(side=LEFT)`,
    instead of using the following snippet:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果Label小部件要保持静态，使用`Label(root, text='Name').pack(side=LEFT)`，而不是使用以下代码片段：
- en: '[PRE28]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, do not create local variables if you are not going to use them more
    than once. For example, use `mylabel.config (text= event.keysym)` instead of first
    creating a local variable `key` and then using it only once:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你不打算多次使用局部变量，那么不要创建局部变量。例如，使用`mylabel.config(text= event.keysym)`而不是首先创建一个局部变量`key`然后只使用一次：
- en: '[PRE29]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the local variable is to be used more than once, it may make sense to create
    a local variable.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果局部变量要被多次使用，可能有必要创建一个局部变量。
- en: Using Exceptions
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用异常
- en: Now here is a small caveat. In order to concentrate on illustrating core Tkinter
    concepts, we have deliberately ignored the clean exception handling in all our
    examples in this book.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个小的注意事项。为了集中说明Tkinter的核心概念，我们故意在本书的所有示例中忽略了干净的异常处理。
- en: We have implemented a "catch all errors" exception using simple try-except blocks
    in most of our projects. However, when programming your applications, you would
    ideally want to be as specific as possible about the exception you want to handle.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的大部分项目中，我们使用了简单的try-except块来实现一个“捕获所有错误”的异常。然而，当你在编写应用程序时，你最好尽可能具体地说明你想要处理的异常。
- en: Python follows the EAFP (easier to ask for forgiveness than permission) style
    of coding, as opposed to the LBYL (look before you leap) style followed by most
    other programming languages.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Python遵循EAFP（请求原谅比请求许可更容易）的编码风格，这与大多数其他编程语言遵循的LBYL（跳之前先看）风格相反。
- en: 'Thus, using exception handling similar to the following one is normally cleaner
    in Python than checking conditions using the if-then block:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在Python中使用类似于以下示例的异常处理通常比使用if-then块检查条件要干净：
- en: '[PRE30]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An example of an if-then block is shown in the following code snippet:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了if-then块的一个示例：
- en: '[PRE31]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Filter and map
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤和映射
- en: Python provides two built-in functions named `filter` and `map` to manipulate
    lists directly, rather than having to directly iterate over each item in the list.
    The `filter`, `map`, and `reduce` functions are faster than using loops, because
    a lot of the work is done by the underlying code written in C.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了两个内置函数`filter`和`map`，可以直接操作列表，而不是必须直接遍历列表中的每个项目。`filter`、`map`和`reduce`函数比使用循环更快，因为很多工作都是由底层用C语言编写的代码完成的。
- en: 'Filter: The `filter(function, list)` function returns a list (iterators in
    Python 3.*x*) that contains all the items for which the function returns a true
    value. For example:'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤：`filter(function, list)`函数返回一个列表（Python 3.*x*中的迭代器），其中包含所有函数返回true值的项。例如：
- en: '[PRE32]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is faster than running a conditional if-then check against the list.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这比在列表上运行条件if-then检查要快。
- en: 'Map: The `map(func, list)` function applies `func` to each item in the list
    and returns the values in a new list (returns iterators instead of lists in Python
    3.*x*). For example:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射：`map(func, list)`函数将`func`应用于列表中的每个项目，并返回一个新列表（Python 3.*x*中返回迭代器而不是列表）。例如：
- en: '[PRE33]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This again is faster than running the list through a loop, adding `5` to each
    element.
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这比通过循环遍历列表并给每个元素加5要快。
- en: Profiling
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: '**Profiling** involves generating detailed statistics to show how often and
    for how long various routines of a program execute. This helps is isolating offending
    parts of a program, and those parts probably need redesigning.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能分析**涉及生成详细统计信息，以显示程序中各种例程执行的频率和持续时间。这有助于隔离程序中的问题部分，这些部分可能需要重新设计。'
- en: Python 2.7.*x* provides a built-in module named `cProfile`, which enables generation
    of detailed statistics about a program. The module gives details such as the total
    program-running time, time taken to run each function, and the number of times
    each function is called. These statistics make it easy to determine the parts
    of code that need optimization.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.7.*x*提供了一个名为`cProfile`的内置模块，该模块可以生成有关程序的详细统计信息。该模块提供了诸如总程序运行时间、每个函数的运行时间和每个函数被调用的次数等详细信息。这些统计信息使得确定需要优化的代码部分变得容易。
- en: Note
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In particular, **cProfile** provides the following data for a function or script:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，**cProfile**为函数或脚本提供了以下数据：
- en: '**ncalls**: The number of times a function is called'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ncalls**：一个函数被调用的次数'
- en: '**tottime**: The time spent on a function, excluding time spent on calling
    other functions'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**tottime**：一个函数上花费的时间，不包括调用其他函数所花费的时间'
- en: '**percall**: `tottime` divided by ncalls'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**percall**：`tottime`除以`ncalls`'
- en: '**cumtime**: The time spent on a function, including calls to other functions'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**cumtime**：一个函数上花费的时间，包括调用其他函数'
- en: '**percall**: `cumtime` divided by `tottime`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**percall**：`cumtime`除以`tottime`'
- en: 'You can profile an individual function with the help of this:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用这个来分析一个单独的函数：
- en: '[PRE34]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You can then view the results of profiling using another module called `pstats`:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用另一个名为`pstats`的模块查看性能分析的结果：
- en: '[PRE35]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'More importantly, you can profile an entire script. Let''s say you want to
    profile a script named `myscript.py`. You simply navigate to the directory of
    the script using a command-line tool, and then type and run:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，你可以分析整个脚本。比如说，你想分析一个名为`myscript.py`的脚本。你只需使用命令行工具导航到脚本的目录，然后输入并运行：
- en: '[PRE36]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This produces an output similar to the following:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生类似于以下输出的结果：
- en: '[PRE37]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: After this, you can analyze the code to see the functions that take more time
    to execute. In our hypothetical example in the preceding output, we notice that
    the functions `findAudio` and `saveAudio` take the maximum time to execute. We
    can then analyze these two functions to see if they can be optimized.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以分析代码，以查看执行时间较长的函数。在我们的假设示例中，我们注意到`findAudio`和`saveAudio`函数执行时间最长。然后我们可以分析这两个函数，看看它们是否可以优化。
- en: In addition to the cProfile module, there are other modules, such as **PyCallGraph**
    and **objgraph** , and they provide visual graphs for profile data.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 除了cProfile模块之外，还有其他模块，例如**PyCallGraph**和**objgraph**，它们为性能分析数据提供可视化的图表。
- en: Other Optimization Tips
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他优化技巧
- en: 'Optimization is a vast topic and there is a lot that you can do. If you are
    interested in knowing more about code optimization, you might start with the official
    Python optimization tips at the following link:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 优化是一个广泛的话题，你可以做很多事情。如果你对代码优化感兴趣，你可能可以从以下链接的官方Python优化技巧开始：
- en: '[http://wiki.python.org/moin/PythonSpeed/PerformanceTips](http://wiki.python.org/moin/PythonSpeed/PerformanceTips)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wiki.python.org/moin/PythonSpeed/PerformanceTips](http://wiki.python.org/moin/PythonSpeed/PerformanceTips)'
- en: Distributing the Tkinter application
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分发Tkinter应用程序
- en: So, you have your new application ready and now you want to share it with the
    rest of the world. How do you do that?
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的新应用程序已经准备好了，现在你想与世界上其他人分享它。你该如何做呢？
- en: Of course, you need Python installation for your program to run. Windows does
    not come with preinstalled Python. Most modern Linux distributions and Mac OS
    X come preinstalled with Python, but you don't just need any version of Python.
    You need a version of Python that is compatible with the version on which the
    program was originally written.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要Python安装来运行你的程序。Windows没有预装Python。大多数现代Linux发行版和Mac OS X都预装了Python，但你需要的不仅仅是任何版本的Python。你需要一个与程序最初编写的版本兼容的Python版本。
- en: And then, if your program uses third-party modules, you need the appropriate
    module installed for the required Python version. Sure this is too much diversity
    to handle.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果你的程序使用第三方模块，你需要安装适当的模块以适应所需的Python版本。当然，这需要处理太多的多样性。
- en: Fortunately, we have tools, such as **Freeze** tools, which allows us to distribute
    Python programs as standalone applications.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有工具，例如**Freeze**工具，这使我们能够将Python程序作为独立应用程序分发。
- en: Given the diversity of platforms to be handled, there is a large number of Freeze
    tool options from which to choose. Therefore, a detailed discussion on any one
    of the tools is beyond the scope of this book.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 由于需要处理的平台多样性，有大量的 Freeze 工具选项可供选择。因此，对任何一种工具的详细讨论超出了本书的范围。
- en: We will list some of the most evolved freezing tools in the following sections.
    If you find a tool fitting into your distribution requirement, you can look at
    its documentation for more information.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将列出一些最先进的冻结工具。如果你找到一个符合你分发要求的工具，你可以查看其文档以获取更多信息。
- en: py2exe
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: py2exe
- en: If you only need to distribute your Python application on Windows, **py2exe**
    is perhaps the most hardened tool. It converts Python programs into executable
    Windows programs that can run without requiring a Python installation. More information,
    a download link, and tutorials are available at [http://www.py2exe.org/](http://www.py2exe.org/).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只需要在 Windows 上分发你的 Python 应用程序，**py2exe** 可能是最坚固的工具。它将 Python 程序转换为可执行 Windows
    程序，可以在不要求安装 Python 的情况下运行。更多信息、下载链接和教程可在 [http://www.py2exe.org/](http://www.py2exe.org/)
    查找。
- en: py2app
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: py2app
- en: '**py2app** performs the same tasks in Mac OS X that py2exe does for Windows.
    If you just need to distribute your Python application on Mac OS X, py2app is
    a time-tested tool. More information is available at [http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html](http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html).'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '**py2app** 在 Mac OS X 上执行的任务与 py2exe 在 Windows 上执行的任务相同。如果你只需要在 Mac OS X 上分发你的
    Python 应用程序，py2app 是一个经过时间考验的工具。更多信息请参阅 [http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html](http://svn.pythonmac.org/py2app/py2app/trunk/doc/index.html)。'
- en: PyInstaller
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyInstaller
- en: '**PyInstaller** has gained popularity as a freezing tool in the last few years
    partly because it supports a wide variety of platforms, such as Windows, Linux,
    Mac OS X, Solaris, and AIX.'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyInstaller** 在过去几年中作为冻结工具获得了人气，部分原因在于它支持广泛的平台，例如 Windows、Linux、Mac OS X、Solaris
    和 AIX。'
- en: In addition, executables created using PyInstaller are claimed to take less
    space than other freezing tools because it uses transparent compression. Another
    important feature of PyInstaller is its out of the box compatibility with a large
    number of third-party packages.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 PyInstaller 创建的可执行文件据称比其他冻结工具占用的空间更少，因为它使用了透明压缩。PyInstaller 的另一个重要特性是它与大量第三方软件包的即插即用兼容性。
- en: The full list of features, downloads, and documentation can be assessed at [http://www.pyinstaller.org/](http://www.pyinstaller.org/).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 功能列表、下载和文档的完整信息可以在 [http://www.pyinstaller.org/](http://www.pyinstaller.org/)
    查阅。
- en: Other Freezing Tools
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他冻结工具
- en: 'Other freezing tool include:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 其他冻结工具包括：
- en: 'Freeze: This tool ships with standard Python distribution. Freeze can be used
    to compile executables only on Unix systems. However, the program is overly simplistic,
    as it fails to handle even the common third-party libraries. More information
    is available at this link:'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冻结：此工具随标准 Python 发行版提供。冻结工具只能在 Unix 系统上编译可执行文件。然而，该程序过于简单，甚至无法处理常见的第三方库。更多信息请参阅此链接：
- en: '[http://wiki.python.org/moin/Freeze](http://wiki.python.org/moin/Freeze)'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://wiki.python.org/moin/Freeze](http://wiki.python.org/moin/Freeze)'
- en: 'cx_Freeze: This tool is similar to py2exe and py2app, but claims to be portable
    across all platforms on which that Python itself works. More information is available
    at this link:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cx_Freeze：这个工具与 py2exe 和 py2app 类似，但声称可以在 Python 本身工作的所有平台上进行移植。更多信息请参阅此链接：
- en: '[http://cx-freeze.sourceforge.net/index.html](http://cx-freeze.sourceforge.net/index.html)'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://cx-freeze.sourceforge.net/index.html](http://cx-freeze.sourceforge.net/index.html)'
- en: Tip
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're distributing a small program, a freeze tool might be just what you
    need. However, if you have a large program, say, with lots of external third-party
    library dependencies or dependencies not supported by any existing freezing tool,
    your application might be the right candidate for bundling the Python interpreter
    with your application.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你正在分发一个小程序，冻结工具可能正是你所需要的。然而，如果你有一个大型程序，比如有很多外部第三方库依赖项或现有冻结工具不支持依赖项，那么你的应用程序可能是将
    Python 解释器与你的应用程序捆绑的正确候选。
- en: Limitations of Tkinter
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 的局限性
- en: We have already explored the power of Tkinter. Perhaps the greatest power of
    Tkinter lies in its ease of use and a lightweight footprint.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了 Tkinter 的强大功能。也许 Tkinter 最大的优势在于其易用性和轻量级特性。
- en: However, ease of use and lightweightiness of Tkinter also result in some limitations.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Tkinter 的易用性和轻量级特性也导致了一些限制。
- en: Limited number of core widgets
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心小部件数量有限
- en: Tkinter provides only a small number of basic widgets, and lacks a collection
    of more modern widgets. It needs `ttk`, `Pmw`, `Tix`, and other extensions to
    provide some really useful widgets. Even with these extensions, Tkinter fails
    to match the range of widgets provided by other GUI tools, such as **wxPython**
    advanced widget set and **PyQt**.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter仅提供少量基本控件，并且缺乏现代控件的集合。它需要`ttk`、`Pmw`、`Tix`和其他扩展来提供一些真正有用的控件。即使有了这些扩展，Tkinter也无法与其他GUI工具提供的控件范围相匹配，例如**wxPython**的高级控件集和**PyQt**。
- en: For instance, wxPython's HtmlWindow widget lets the user display HTML content
    with ease. There have been attempts to provide similar extensions in Tkinter,
    but they are far from satisfactory. Similarly, there are other widgets from Advanced
    User Interface Library and mixins in wxPython, such as floating/docking frames,
    perspective loading and saving, and others, which Tkinter users can only hope
    to be included in future releases.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，wxPython的HtmlWindow控件可以轻松显示HTML内容。在Tkinter中也有尝试提供类似扩展，但它们远未令人满意。同样，wxPython中还有来自高级用户界面库和混入的其他控件，例如浮动/停靠框架、视角加载和保存等，Tkinter用户只能希望它们能在未来的版本中包含。
- en: Tkinter supporters often tend to refute this criticism by citing how easily
    you can construct new widgets from a collection of basic widgets.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的支持者经常倾向于通过引用如何轻松地从一组基本控件中构建新控件来反驳这种批评。
- en: No Support for printing
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无打印支持
- en: Tkinter is rightfully criticized for providing no support for printing features.
    Compare this to wxPython, which provides a complete printing solution in the form
    of a printing framework.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter因不提供打印功能而受到应有的批评。与之相比，wxPython提供了一个完整的打印解决方案，即打印框架。
- en: No support for newer image formats
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无新图像格式支持
- en: Tkinter natively does not support image formats such as JPEG and PNG. The `PhotoImage`
    class of Tkinter can read images only in GIF and PGM/PPM formats.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter原生不支持JPEG和PNG等图像格式。Tkinter的`PhotoImage`类只能读取GIF和PGM/PPM格式的图像。
- en: Although there are workarounds, such as using ImageTk and Image submodules from
    the PIL module, it would have been better if Tkinter natively supported the popular
    image formats.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有解决方案，例如使用PIL模块中的ImageTk和Image子模块，但如果Tkinter原生支持流行的图像格式会更好。
- en: Inactive development community
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不活跃的开发社区
- en: Tkinter is often criticized as having a relatively inactive development community.
    This is true to a large extent. The documentation of Tkinter has remained a work-in-progress
    for many years now.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter常被批评为拥有相对不活跃的开发社区。这在很大程度上是正确的。Tkinter的文档多年来一直处于不断完善中。
- en: A large number of Tkinter extensions appeared over the years, but most of them
    have not been under active development for a long time.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 年复一年，Tkinter出现了大量的扩展，但其中大多数已经很长时间没有活跃开发了。
- en: Tkinter supporters refute this with the logic that Tkinter is a stable and mature
    technology that does not need frequent revisions like some other GUI modules that
    are being newly developed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的支持者用逻辑来反驳这一点，即Tkinter是一种稳定且成熟的技术，不需要像一些新开发的GUI模块那样频繁修订。
- en: Alternatives to Tkinter
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter的替代品
- en: In addition to Tkinter, there are several other popular Python GUI toolkits.
    Most popular ones include wxPython, PyQt, **PySide**, and **PyGTK**. Here's a
    brief discussion on these toolkits.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Tkinter，还有其他几个流行的Python GUI工具包。最受欢迎的包括wxPython、PyQt、**PySide**和**PyGTK**。以下是关于这些工具包的简要讨论。
- en: wxPython
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: wxPython
- en: wxPython is aPython interface to **wxWidgets**, a popular open source GUI library.
    Code written in wxPython is portable across most major platforms such as Windows,
    Linux, and Mac OS X.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython是**wxWidgets**的Python接口，wxWidgets是一个流行的开源GUI库。用wxPython编写的代码可以在大多数主要平台（如Windows、Linux和Mac
    OS X）上移植。
- en: The wxPython interface is generally considered better than Tkinter at building
    more complex GUIs primarily because it has a large base of natively supported
    widgets. However, Tkinter supporters do contest this claim.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython界面通常被认为比Tkinter更适合构建更复杂的GUI，主要是因为它拥有大量原生支持的控件。然而，Tkinter的支持者对此观点提出异议。
- en: The wxWidgets interface is originally written in C++ programming language, and
    hence, wxPython inherits a large portion of the complexity that is typical of
    C++ programs. wxPython provides a very large base of classes, and it often takes
    more code to produce the same interface than it would take in Tkinter. However,
    in exchange for this complexity, wxPython provides a larger base of built-in widgets
    than Tkinter. Moreover, some people prefer the appearance of wxPython widgets
    over that rendered by Tkinter.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: wxWidgets接口最初是用C++编程语言编写的，因此wxPython继承了C++程序典型的很大一部分复杂性。wxPython提供了一个非常大的类库，通常需要更多的代码来生成与Tkinter相同的界面。然而，作为这种复杂性的交换，wxPython提供了比Tkinter更大的内置控件库。此外，有些人更喜欢wxPython小部件的外观，而不是Tkinter渲染的外观。
- en: Owing to its inherent complexity, wxPython has seen the emergence of several
    GUI builder toolkits, such as **wxGlade**, **wxFormBuilder**, **wxDesigner**,
    and so on.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其固有的复杂性，wxPython已经出现了几个GUI构建器工具包，例如**wxGlade**、**wxFormBuilder**、**wxDesigner**等。
- en: 'The wxPython installation comes with demo programs that can help you get started
    with the toolkit quickly. To download the toolkit or for more information on wxPython,
    visit the following link:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: wxPython安装程序包含演示程序，可以帮助您快速开始使用此工具包。要下载工具包或获取有关wxPython的更多信息，请访问以下链接：
- en: '[http://wxpython.org/](http://wxpython.org/)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wxpython.org/](http://wxpython.org/)'
- en: PyQt
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyQt
- en: PyQt is a Python interface of the cross-platform GUI toolkit Qt, a project currently
    developed and maintained by British firm Riverbank Computing.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt是跨平台GUI工具包Qt的Python接口，Qt是由英国公司Riverbank Computing开发和维护的项目。
- en: PyQt, with several hundred classes and thousands of functions is perhaps the
    most fully-featured GUI library that is currently available for GUI programming
    in Python. However, this feature load brings in a lot of complexity and a steep
    learning curve.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt，拥有数百个类和数千个函数，可能是目前用于Python GUI编程功能最全面的GUI库。然而，这种功能负载带来了很多复杂性，学习曲线陡峭。
- en: Qt (and hence pyQt) has a very rich set of supported widgets. In addition, it
    includes built-in support for network programming, SQL databases, threads, multimedia
    framework, regular expressions, XML, SVG, and much more. The designer feature
    of Qtletsus generates GUI code from a WYSIWYG (What You See Is What You Get) interface.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Qt（因此PyQt）支持非常丰富的控件集。此外，它还包括对网络编程、SQL数据库、线程、多媒体框架、正则表达式、XML、SVG等内置支持。Qt的设计器功能可以从WYSIWYG（所见即所得）界面生成GUI代码。
- en: PyQt is available under variety of licenses including **GNU**, **General Public
    License** (**GPL**), and commercial license. However, its greatest disadvantage
    is that unlike Qt, it is unavailable under the LGPL.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: PyQt可在多种许可下使用，包括**GNU**、**通用公共许可证**（**GPL**）和商业许可。然而，它的最大缺点是，与Qt不同，它不可在LGPL下使用。
- en: PySide
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PySide
- en: 'If you are looking for a LGPL version of Qt bindings for Python, you may want
    to explore PySide. PySide was originally released under the LGPL in August 2009
    by Nokia, the former owners of the **Qttoolkit** . It is now owned by Digia. More
    information on PySide can be obtained from the following link:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在寻找Python的LGPL版本Qt绑定，您可能想探索PySide。PySide最初于2009年8月由诺基亚（Qt工具包的前所有者）以LGPL的形式发布。现在它由Digia拥有。有关PySide的更多信息，请从以下链接获取：
- en: '[http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://qt-project.org/wiki/PySide](http://qt-project.org/wiki/PySide)'
- en: PyGTK
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PyGTK
- en: '**PyGTK** is a collection of Python bindings for the GTK + GUI library. PyGTK
    applications are cross-platform, and can run on Windows, Linux, MacOS X, and others.
    PyGTK is a free software and licensed under the LGPL. You can therefore use, modify,
    and distribute it with very little restrictions.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyGTK**是一组针对GTK + GUI库的Python绑定。PyGTK应用程序是跨平台的，可以在Windows、Linux、MacOS X和其他操作系统上运行。PyGTK是免费软件，并受LGPL许可。因此，您可以非常少地限制地使用、修改和分发它。'
- en: 'More information about PyGTK can be obtained at the following link:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接获取有关PyGTK的更多信息：
- en: '[http://www.pygtk.org/](http://www.pygtk.org/)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.pygtk.org/](http://www.pygtk.org/)'
- en: Other Options
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他选项
- en: Besides these most popular toolkits, there is a range of toolkits available
    for GUI programming in Python.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些最受欢迎的工具包之外，还有一系列适用于Python GUI编程的工具包可供选择。
- en: Java programmers who are comfortable with Java GUI libraries, such as swing
    and AWT, can seamlessly access these libraries by using **Jython** . Similarly
    C# programmers can use **IronPython** to access GUI construction features from
    the .NET framework.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 Java GUI 库（如 Swing 和 AWT）的 Java 程序员，他们可以通过使用 **Jython** 无缝访问这些库。同样，C# 程序员可以使用
    **IronPython** 从 .NET 框架中访问 GUI 构建功能。
- en: 'For a comprehensive list of other GUI tools available to a Python developer
    visit this link:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Python 开发者可用的其他 GUI 工具的完整列表，请访问此链接：
- en: '[http://wiki.python.org/moin/GuiProgramming](http://wiki.python.org/moin/GuiProgramming)'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://wiki.python.org/moin/GuiProgramming](http://wiki.python.org/moin/GuiProgramming)'
- en: Getting interactive help
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取交互式帮助
- en: This section is not just true about Tkinter, but for any Python object for which
    you need help.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分不仅适用于 Tkinter，也适用于任何你需要帮助的 Python 对象。
- en: 'Let''s say you need a reference on Tkinter Pack geometry manager, you can get
    interactive help in your Python interactive shell using the help command, as shown
    in the following command lines:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要关于 Tkinter Pack 布局管理器的参考资料，你可以在 Python 交互式 shell 中使用 help 命令获取交互式帮助，如下面的命令行所示：
- en: '[PRE38]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This provides a detailed help documentation on all the methods defined under
    the `Pack` class in Tkinter.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了关于 Tkinter 中 `Pack` 类下定义的所有方法的详细帮助文档。
- en: 'You can similarly view help for all other individual widgets. For instance,
    you can check comprehensive and authoritative help documentation for Label widget
    in the interactive shell by typing:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以类似地查看所有其他单独小部件的帮助。例如，你可以在交互式 shell 中输入以下内容来检查 Label 小部件的全面和权威帮助文档：
- en: '[PRE39]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This provides a list of:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一份列表：
- en: All methods defined in class `Label`
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类 `Label` 中定义的所有方法
- en: All standard and widget specific options for Label widget
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Label 小部件的所有标准和特定于小部件的选项
- en: All methods inherited from other classes
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他类继承的所有方法
- en: Finally, when in doubt about a method, look into the source file located at
    <`location-of-python-installation>\lib\lib-tk\Tkinter.py`.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你对某个方法有疑问，可以查看位于 `<location-of-python-installation>\lib\lib-tk\Tkinter.py>`
    的源文件。
- en: Tip
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The `lib-tk` directory is the home to some great Tkinter code that you can
    study. In particular, you may also want to take a look at the source code of:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`lib-tk` 目录是许多优秀的 Tkinter 代码的家园。特别是，你可能还想查看以下源代码：'
- en: 'turtle.py: A popular way to introduce programming to kids. It includes some
    cool animated effects'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: turtle.py：一种流行的向孩子介绍编程的方式。它包括一些酷炫的动画效果
- en: 'Tkdnd.py: An experiment code that lets you drag and drop items on the Tkinter
    window.'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tkdnd.py：一个实验性代码，允许你在 Tkinter 窗口中拖放项目。
- en: You might also find it useful to look at the source code implementation of various
    other modules, such as the color chooser, file dialogs, ttk module, and others.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可能发现查看其他模块（如颜色选择器、文件对话框、ttk 模块等）的源代码实现很有用。
- en: Tkinter in Python 3.*x*
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tkinter 在 Python 3.*x* 中
- en: In 2008, Guido van Rossum, the author of Python, forked the language into two
    branches—2.*x*, and 3.*x*. This was done to clean up and make the language more
    consistent.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2008 年，Python 的作者 Guido van Rossum 将语言分成了两个分支——2.*x* 和 3.*x*。这样做是为了清理和使语言更加一致。
- en: Python 3.*x* broke backward compatibility with the Python 2.*x*. For example,
    the print statement in Python 2.*x* was replaced by `print()` function that would
    now take arguments as parameters.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.*x* 与 Python 2.*x* 不再兼容。例如，Python 2.*x* 中的 print 语句已被 `print()` 函数取代，该函数现在将参数作为参数接收。
- en: We coded all our Tkinter programs in Python Version 2.7, because it has a richer
    set of third-party libraries than Python 3.*x*, which is still considered a developing
    version.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Python 版本 2.7 编写了所有的 Tkinter 程序，因为它比 Python 3.*x* 拥有更丰富的第三方库，而 Python 3.*x*
    仍然被视为一个开发中的版本。
- en: The core functionality of Tkinter remains the same between 2.*x*, and 3.*x*.
    The only significant change to Tkinter when moving from Python 2.*x* to Python
    3.*x* involves changing the way Tkinter modules are imported.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 在 2.*x* 和 3.*x* 之间的核心功能保持不变。从 Python 2.*x* 迁移到 Python 3.*x* 时，Tkinter
    的唯一重大变化是改变导入 Tkinter 模块的方式。
- en: '**Tkinter** has been renamed to **tkinter** in Python 3.*x* (capitalization
    has been removed). Note that in 3.*x*, the directory `lib-tk` was renamed to `tkinter`.
    Inside the directory, the file `Tkinter.py` was renamed to `__init__.py`, thus
    making tkinter an importable module.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tkinter** 在 Python 3.*x* 中已被重命名为 **tkinter**（已移除大小写）。请注意，在 3.*x* 中，目录 `lib-tk`
    已被重命名为 `tkinter`。在目录内部，文件 `Tkinter.py` 已被重命名为 `__init__.py`，从而使 tkinter 成为一个可导入的模块。'
- en: 'Accordingly, the biggest major difference lies in the way you import the Tkinter
    module into your current namespace:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最大的主要区别在于您将Tkinter模块导入当前命名空间的方式：
- en: '[PRE40]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Further, take a note of the following changes:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意以下变更：
- en: '| Python 2.x | Python 3.x |'
  id: totrans-416
  prefs: []
  type: TYPE_TB
  zh: '| Python 2.x | Python 3.x |'
- en: '| --- | --- |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `import ttk` | `import tkinter.ttk OR``from tkinter import ttk` |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `import ttk` | `import tkinter.ttk OR` `from tkinter import ttk` |'
- en: '| `import tkMessageBox` | `import tkinter.messagebox` |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| `import tkMessageBox` | `import tkinter.messagebox` |'
- en: '| `import tkColorChooser` | `import tkinter.colorchooser` |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `import tkColorChooser` | `import tkinter.colorchooser` |'
- en: '| `import tkFileDialog` | `import tkinter.filedialog` |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| `import tkFileDialog` | `import tkinter.filedialog` |'
- en: '| `import tkSimpleDialog` | `import tkinter.simpledialog` |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `import tkSimpleDialog` | `import tkinter.simpledialog` |'
- en: '| `import tkCommonDialog` | `import tkinter.commondialog` |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| `import tkCommonDialog` | `import tkinter.commondialog` |'
- en: '| `import tkFont` | `import tkinter.font` |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `import tkFont` | `import tkinter.font` |'
- en: '| `import ScrolledText` | `import tkinter.scrolledtext` |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| `import ScrolledText` | `import tkinter.scrolledtext` |'
- en: '| `import Tix` | `import tkinter.tix` |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| `import Tix` | `import tkinter.tix` |'
- en: Conclusion
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'To conclude, let''s summarize some of the key steps involved in designing an
    application:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们总结一下设计应用程序涉及的一些关键步骤：
- en: Depending on what you want to design, choose a suitable data structure to represent
    your needs logically.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据您想要设计的内容，选择一个合适的数据结构来逻辑地表示您的需求。
- en: If required, combine primitive data structures to form complex structures like,
    say, a list of dictionaries or a tuple of dictionaries.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，将原始数据结构组合成复杂结构，例如，一个字典列表或一个字典元组。
- en: Create classes for objects that constitute your application. Add attributes
    that need to be manipulated and methods to manipulate those attributes.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为构成您应用程序的对象创建类。添加需要操作的属性以及操作这些属性的方法。
- en: Manipulate attributes using different API provided by a rich set of Python standard
    and external libraries.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用丰富的Python标准库和外部库提供的不同API来操作属性。
- en: We tried to build several partly-functional applications in this book. And then
    we put up an explanation for the code. However, when you try to explain a software
    development process in a sequential text, you sometimes mislead your readers to
    imply that development of software programs is a linear process. This is hardly
    true.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中尝试构建了几个部分功能的应用程序。然后我们为代码提供了说明。然而，当您试图在顺序文本中解释软件开发过程时，您有时会误导读者，暗示软件开发程序是一个线性过程。这几乎是不正确的。
- en: Actual programming doesn't usually work this way. In fact, small-to-medium-sized
    programs are normally written in an incremental trial and error process where
    assumptions get changed and structures modified throughout the course of application
    development.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的编程通常不会这样进行。事实上，中小型程序通常是在增量试错过程中编写的，在这个过程中假设会改变，结构会修改，贯穿整个应用程序开发过程。
- en: 'Here is how you would develop a small to medium application:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您如何开发一个从小型到中型应用程序的方法：
- en: Start with a simple script.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个简单的脚本开始。
- en: Set a small achievable goal, implement it, and then think of adding the next
    feature to your program in an incremental fashion.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设定一个小的可实现目标，实现它，然后以增量方式考虑添加下一个功能到您的程序中。
- en: You may or may not introduce a class structure initially. If you are clear about
    the problem domain, you may introduce the class structure right from the very
    beginning.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可能一开始不需要引入类结构。如果您对问题域有清晰的认识，您可能从一开始就引入类结构。
- en: If you are not sure about the class structure initially, start with simple procedural
    code. As your program starts to grow, you will probably start getting lot of global
    variables. It is here that you will start getting a glimpse of the structural
    dimensions of your program. It is now time to refactor and restructure your program
    to introduce a class structure.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您一开始不确定类结构，从简单的过程式代码开始。随着您的程序开始增长，您可能会开始遇到很多全局变量。正是在这里，您将开始了解您程序的结构维度。现在是时候重构和重新结构化您的程序，引入类结构。
- en: Tip
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are writing a small program, the evolutionary **trial and error** strategy
    works well.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在编写一个小程序，进化的**试错**策略效果很好。
- en: If, however, you get into developing medium to large-scale applications, it
    is better to do some serious upfront planning before you sit down to write your
    code, because the cost of failure of a large program is way higher than what we
    can generally afford.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您开始开发中型到大型应用程序，在您坐下来编写代码之前进行一些严肃的前期规划会更好，因为大型程序失败的成本远远高于我们通常能承受的。
- en: An analogy would explain this better. You can build a small shed on a trial
    and error basis, but you would not attempt to build a skyscraper without some
    serious planning.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类比可以更好地解释这一点。你可以通过试错的方式搭建一个小棚屋，但如果没有一些严肃的规划，你不会尝试去建造一座摩天大楼。
- en: It is also important not to be unnecessarily bogged down by ever evolving jargons
    in the technical world. Programming is less about knowing a particular API or
    even a particular programming language. You can literally get to know the basic
    constructs of a programming language in a small sitting. Programming is rather
    a tool for finding solution to your immediate problems.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 也很重要的是不要被技术世界中不断演变的术语无谓地困扰。编程与其说是了解特定的API或特定的编程语言，不如说是找到一个解决你当前问题的工具。你实际上可以在短时间内了解编程语言的基本结构。编程更多的是一个寻找解决方案的工具。
- en: That brings us to the end of the book. I hope this book has taught you something
    about GUI programming with Python and Tkinter.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们来到了本书的结尾。我希望这本书已经教会了你关于使用Python和Tkinter进行GUI编程的一些知识。
- en: Beyond reading books, there is really no substitute for doing some original
    GUI programming. So, take up an original programming challenge and execute it
    for the fun of it.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阅读书籍之外，真正替代原创GUI编程的方法几乎没有。所以，接受一个原创的编程挑战，并为了乐趣去执行它。
- en: How you implement it is a matter of individual experiences and taste. Do what
    feels comfortable to you, but keep yourself open to the idea of continuous refactoring
    at every stage of development.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何实施它取决于个人的经验和品味。做让你感到舒适的事情，但保持自己在开发每个阶段都进行持续重构的想法开放。
