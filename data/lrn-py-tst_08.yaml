- en: Chapter 8. Integration and System Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 集成和系统测试
- en: 'With all of the tools, techniques, and practices we''ve discussed so far, we''ve
    still only been been thinking about testing units: the smallest, meaningfully
    testable pieces of code. It''s time to expand the focus, and start testing code
    that incorporates multiple units.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们已经讨论了所有的工具、技术和实践，但我们仍然只是在思考测试单元：代码中最小、有意义的可测试部分。现在是时候扩大关注范围，开始测试包含多个单元的代码。
- en: 'That means we need to:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要：
- en: Think about what integration testing and system testing actually are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思考集成测试和系统测试实际上是什么
- en: Learn how to identify testable multi-unit segments of a program
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何识别程序的可测试多单元段
- en: Use the tools we've learned in order to create tests for these segments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用我们学到的工具来为这些段创建测试
- en: Introduction to integration testing and system testing
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成测试和系统测试简介
- en: Integration testing is the process of checking whether the units of our program
    work together properly. At this stage, thanks to our unit tests, we can assume
    that each unit works as expected in isolation, and we're kicking the tests up
    to a new level of complexity. It's not practical to start the process with integration
    testing because, if the units don't work, the integration won't work either, and
    it will be harder to track down the problems. Once the units are solid, though,
    it's necessary to test that the things we build out of them also work. The interactions
    can be surprising.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试是检查我们程序中的单元是否正常工作的过程。在这个阶段，多亏了我们的单元测试，我们可以假设每个单元在独立的情况下都按预期工作，我们将测试提升到新的复杂度级别。由于如果单元不工作，集成也不会工作，而且追踪问题会更难，所以从集成测试开始这个过程是不切实际的。然而，一旦单元稳固，测试我们构建的东西是否也工作就是必要的。这些交互可能会令人惊讶。
- en: While you're doing integration testing, you'll be putting the units together
    into bigger and bigger collections, and testing these collections. When your integration
    tests expand to cover the entirety of your program, they become system tests.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你进行集成测试时，你将把单元组合成更大的集合，并测试这些集合。当你的集成测试扩展到覆盖整个程序时，它们就变成了系统测试。
- en: 'The trickiest part of integration testing is choosing which units to integrate
    into each test, so that you always have a solid base of code that you can believe
    in: a place to stand, while you pull in more code.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试中最棘手的部分是选择哪些单元要集成到每个测试中，这样你总是有一个可以信赖的稳固的代码基础：一个可以立足的地方，在你引入更多代码的同时。
- en: Deciding on an integration order
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定集成顺序
- en: 'We''re going to work through an exercise that will help you with the process
    of deciding where to put the boundaries of integration tests:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个练习来帮助你决定集成测试边界的放置过程：
- en: Using a piece of paper or a graphics program, write down names or representations
    for each of the units in the time planner project from [Chapter 7](ch07.html "Chapter 7. Test-driven
    Development Walk-through"), *Test-driven Development Walk-through*. Group the
    methods of each class together. Being part of the same class is an obvious relationship
    between units, and we'll take advantage of this. The `==` symbol here represents
    the Python `==` operator, which invokes the `__eq__` method on an object:![Deciding
    on an integration order](img/3211OS_08_01.jpg)
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一张纸或图形程序，为[第7章](ch07.html "第7章 测试驱动开发演练") *测试驱动开发演练*中的时间规划项目中的每个单元写下名称或表示。将每个类的方法定在一起。同一个类是单元之间的一种明显关系，我们将利用这一点。这里的`==`符号代表Python的`==`运算符，它在对象上调用`__eq__`方法：![确定集成顺序](img/3211OS_08_01.jpg)
- en: Now draw arrows between units that are supposed to directly interact with each
    other, from the caller to the callee. Laying everything out in an orderly fashion,
    as in step 1, can actually make this harder, so feel free to move the classes
    around to help the lines make sense:![Deciding on an integration order](img/3211OS_08_02.jpg)
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在应该直接相互交互的单元之间画箭头，从调用者到被调用者。像步骤1中那样有序地排列一切，实际上可能会使这个过程变得更难，所以请随意移动类以帮助线条有意义：![确定集成顺序](img/3211OS_08_02.jpg)
- en: Draw circles around each class and each pair of classes connected by at least
    one line:![Deciding on an integration order](img/3211OS_08_03.jpg)
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个类和至少通过一条线连接的每一对类周围画圆圈：![确定集成顺序](img/3211OS_08_03.jpg)
- en: Continue the process by drawing circles around overlapping pairs of circles,
    until there are only three circles left. Circle a pair of them, and then put one
    more big circle around the whole mess:![Deciding on an integration order](img/3211OS_08_04.jpg)
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在重叠的圆圈对周围画圆，继续这个过程，直到只剩下三个圆圈。圈出其中一对，然后在整个混乱中再画一个大圆圈：![确定积分顺序](img/3211OS_08_04.jpg)
- en: Now, to decide which integration tests to write first, we just have to look
    at the number of circles surrounding all parts of it. The more deeply nested the
    circle that contains every unit involved in an integration test is, the sooner
    we write that test.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了决定先编写哪些集成测试，我们只需看看围绕其所有部分的圆圈数量。包含每个参与集成测试的单元的圆圈嵌套得越深，我们就越早编写那个测试。
- en: What we just did is a way to visualize and solidify the process of building
    integration tests. While it's not critical to actually draw the lines and circles,
    it's useful to follow the process in your head. For larger projects, a lot can
    be gained from actually drawing the diagrams. When you see the diagram, the next
    correct step tends to jump right out at you—especially if you use multiple colors
    to render the diagram—where it might otherwise be hidden behind the complexity
    of the program.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才做的是一种可视化和巩固构建集成测试过程的方法。虽然实际上画线和圆圈并不是关键，但在脑海中跟随这个过程是有用的。对于较大的项目，实际绘制图表可以获得很多好处。当你看到图表时，下一步正确的步骤往往会立即跳出来——特别是如果你使用多种颜色来渲染图表——否则它可能隐藏在程序的复杂性背后。
- en: Automating integration tests and system tests
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化集成测试和系统测试
- en: The only real difference between an integration test and a unit test is that,
    in an integration test, you can break the code being tested into smaller meaningful
    chunks; in a unit test, however, if you divided the code any more, it wouldn't
    be meaningful. For this reason, the same tools that help you automate unit testing
    can be applied to integration testing. Since system testing is really the highest
    level of integration testing, the tools can be used for that as well.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试和单元测试之间唯一的真正区别是，在集成测试中，你可以将正在测试的代码分解成更小的有意义的块；然而，在单元测试中，如果你再细分代码，它就不再有意义了。因此，帮助你自动化单元测试的工具也可以应用于集成测试。由于系统测试实际上是最高级别的集成测试，因此这些工具也可以用于此。
- en: 'The role of `doctest` in integration testing tends to be fairly limited: doctest''s
    real strengths are in the early part of the development process. It''s easy for
    a testable specification to stray into integration testing—as said before, that''s
    fine as long as there are unit tests as well, but after that it''s likely that
    you''ll prefer `unittest` and Nose for writing your integration tests.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`在集成测试中的作用通常相当有限：doctest的真实优势在于开发过程的早期。一个可测试的规范很容易进入集成测试——正如之前所说，只要有单元测试，那就没问题，但之后你可能会更喜欢`unittest`和Nose来编写你的集成测试。'
- en: Integration tests need to be isolated from each other. Even though they contain
    multiple interacting units within themselves, you still benefit from knowing that
    nothing outside the test is affecting it. For this reason, `unittest` is a good
    choice for writing automated integration tests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试需要彼此隔离。尽管它们自身包含多个相互作用的单元，但你仍然会从知道测试之外没有东西影响它中受益。因此，`unittest`是编写自动化集成测试的好选择。
- en: Writing integration tests for the time planner
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为时间规划器编写集成测试
- en: The integration diagram only provides a partial ordering of the integration
    tests, and there are several tests that could be the first one we write. Looking
    at the diagram, we can see that the `Status` and `Activity` classes are at the
    end of a lot of arrows, but not at the beginning of any. This makes them particularly
    good places to start writing integration tests, because it means that they don't
    call on anything outside themselves to operate. Since there's nothing to distinguish
    one of them as a better place to start than the other, we can choose between them
    arbitrarily. Let's start with `Status`, and then do `Activity`. We're going to
    write tests that exercise the whole class. At this low level, the integration
    tests will look a lot like the unit tests for the same class, but we're not going
    to use mock objects to represent other instances of the same class. We will use
    real instances. We're testing whether the class correctly interacts with itself.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 集成图只提供了集成测试的部分顺序，并且有几个测试可能是我们首先编写的。从图中可以看出，`Status`和`Activity`类位于许多箭头的末端，但不是任何箭头的起点。这使得它们成为编写集成测试的特别好的起点，因为这意味着它们不需要调用自身之外的东西来操作。由于没有东西可以区分它们中哪一个更适合作为起点，我们可以任意选择。让我们从`Status`开始，然后进行`Activity`。我们将编写测试来测试整个类。在这个低级别上，集成测试将非常类似于同一类的单元测试，但我们不会使用模拟对象来表示同一类的其他实例。我们将使用真实实例。我们正在测试类是否正确地与自身交互。
- en: 'Here is the test code for `Status`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Status`的测试代码：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here is the test code for `Activity`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Activity`的测试代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Looking at our diagram, we can see that the next level out from either `Status`
    or `Activity` represents the integration of these classes with the `Schedule`
    class. Before we write this integration, we ought to write any tests that involve
    the `Schedule` class interacting with itself, without using mock objects:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们的图，我们可以看到从`Status`或`Activity`向外延伸的下一级代表了这些类与`Schedule`类的集成。在我们编写这个集成之前，我们应该编写任何涉及`Schedule`类与自身交互的测试，而不使用模拟对象：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now that the interactions within the `Schedule` class have been tested, we can
    write tests that integrate `Schedule` with either `Status` or `Activity`. Let's
    start with `Status`, then do `Activity`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Schedule`类内部的交互已经测试过了，我们可以编写集成`Schedule`与`Status`或`Activity`的测试。让我们从`Status`开始，然后进行`Activity`。
- en: 'Here are the tests for `Schedule` and `Status`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`Schedule`和`Status`的测试：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here are the tests for the interactions between real `Schedule` and `Activity`
    instances. Due to the similarity between `Activity` and `Status`, the tests are,
    not surprisingly, structured similarly:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对真实`Schedule`实例和`Activity`实例之间交互的测试。由于`Activity`和`Status`之间的相似性，测试结构不出所料地类似：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'All right, it''s finally time to put `Schedule`, `Status`, and `Activity` together
    in the same test:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在是时候将`Schedule`、`Status`和`Activity`一起放在同一个测试中了：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The next thing we need to pull in is the `File` class but, before we integrate
    it with the rest of the system, we need to integrate it with itself and check
    its internal interactions without using mock objects:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步我们需要引入的是`File`类，但在将其与其他系统集成之前，我们需要将其与自身集成并检查其内部交互，而不使用模拟对象：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we can write tests that integrate `Schedules` and `File`. Notice that,
    for this step, we still aren''t involving `Status` or `Activity`, because they''re
    outside the oval. We''ll use mock objects in place of them, for now:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以编写集成`Schedules`和`File`的测试。请注意，在这一步，我们仍然没有涉及`Status`或`Activity`，因为它们在椭圆之外。目前我们将使用模拟对象来代替它们：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ve built our way up to the outermost circle now, which means it''s time
    to write tests that involve the whole system with no mock objects anywhere:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建到了最外层圆圈，这意味着是时候编写涉及整个系统且没有任何模拟对象的测试了：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've just integrated our whole code base, progressively constructing larger
    tests until we had tests encompassing the whole system. The whole time, we were
    careful to test one thing at a time. Because we took care to go step-by-step,
    we always knew where the newly discovered bugs originated, and we were able to
    fix them easily.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚集成了整个代码库，逐步构建更大的测试，直到我们有了涵盖整个系统的测试。在整个过程中，我们一直小心翼翼地一次测试一件事。因为我们采取了逐步进行的做法，所以我们总是知道新发现的错误是从哪里开始的，并且我们能够轻松地修复它们。
- en: 'Speaking of which, if you were to run the tests for yourself while building
    this code structure, you would notice that some of them fail. All three of the
    failures point to the same problem: there''s something wrong with the persistence
    database. This error doesn''t show up in the unit tests for the `File` class,
    because it''s only visible on a larger scale, when the database is used to communicate
    information between units.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，如果你在构建这个代码结构的同时运行测试，你会注意到其中一些测试失败了。所有三个失败都指向同一个问题：持久化数据库有问题。这个错误没有在`File`类的单元测试中出现，因为它只有在更大范围内，当数据库用于在单元之间传递信息时才会出现。
- en: 'Here''s the error reported by the `test_file.py` tests:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`test_file.py`测试报告的错误：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The changes to the database aren't being committed to the file, and so they
    aren't visible outside the transaction where they were stored. Not testing the
    persistence code in separate transactions was not an oversight, but that's exactly
    the sort of mistake that we expect integration testing to catch.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库的更改没有被提交到文件中，因此它们在存储它们的交易之外是不可见的。没有在单独的交易中测试持久化代码并不是疏忽，但这正是我们期望集成测试能够捕捉到的错误类型。
- en: 'We can fix the problem by altering the `store_object` method of the `File`
    class in `persistence.py` as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过修改`persistence.py`中`File`类的`store_object`方法来解决这个问题：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Another point of interest is the interaction between `pickle` and mock objects.
    There are a lot of things that mock objects do well, but accepting pickling is
    not one of them. Fortunately, that''s relatively easy to work around is demonstrated
    in test integrating `Schedule` and `File`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得关注的点是`pickle`和模拟对象之间的交互。模拟对象有很多做得好的事情，但接受序列化并不是其中之一。幸运的是，这相对容易解决，这在集成测试`Schedule`和`File`中得到了演示：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The trick here is not really very tricky. We've just told the mock objects what
    return value to use for calls to the `__reduce__` method. It so happens that the
    pickle dumping functions call `__reduce__` to find out whether an object needs
    special handling when being pickled and unpickled. We told it that it did, and
    that it should call the `unpickle_mocked_task` function to reconstitute the mock
    object during unpickling. Now, our mock objects can be pickled and unpickled as
    well as the real objects can.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的技巧并不真正复杂。我们只是告诉模拟对象在调用`__reduce__`方法时使用什么返回值。碰巧，序列化函数调用`__reduce__`来找出在序列化和反序列化对象时是否需要特殊处理。我们告诉它需要，并且它应该在反序列化时调用`unpickle_mocked_task`函数来重新构成模拟对象。现在，我们的模拟对象可以像真实对象一样被序列化和反序列化。
- en: 'Another point of interest in the tests for `Schedule` and `File` is the `tearDown`
    test fixture method. The `tearDown` method will delete a database file, if it
    exists, but won''t complain if it doesn''t. The database is expected to be created
    within the test itself, and we don''t want to leave it lying around; however,
    if it''s not there, it''s not a test fixture error:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Schedule`和`File`的测试中，另一个值得关注的点是`tearDown`测试固定方法。如果存在数据库文件，`tearDown`方法将删除它，但如果不存在，它不会抱怨。预期数据库将在测试本身中创建，我们不希望它留在那里；然而，如果它不存在，这并不是测试固定错误：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A lot of the test code in this chapter might seem redundant to you. That's because,
    in some sense, it is. Some things are repeatedly checked in different tests. Why
    bother?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多测试代码可能在你看来显得冗余。这在某种程度上是正确的。有些事情在不同的测试中反复被检查。为什么还要费这个劲？
- en: The main reason for the redundancy is that each test is supposed to stand alone.
    We're not supposed to care what order they run in, or whether any other tests
    even exist. Each test is self-contained; thus, if it fails, we know exactly what
    needs to be fixed. Because each test is self-contained, some foundational things
    end up getting tested multiple times. In the case of this simple project, redundancy
    is even more pronounced than it would normally be.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 重复性的主要原因在于每个测试都应该独立存在。我们不应该关心它们的运行顺序，或者是否有其他测试存在。每个测试都是自包含的；因此，如果它失败了，我们就知道需要修复什么。因为每个测试都是自包含的，一些基础的东西最终会被多次测试。在这个简单的项目中，重复性比通常情况下更为明显。
- en: Whether it's blatant or subtle, though, the redundancy isn't a problem. The
    so-called **Don't Repeat Yourself** (**DRY**) principle doesn't particularly apply
    to tests. There's not much downside to having something tested multiple times.
    This is not to say that it's a good idea to copy and paste tests, because it's
    very much not. Don't be surprised or alarmed to see similarities between your
    tests, but don't use that as an excuse. Every test that checks a particular thing
    is a test that needs to be changed if you change that thing, so it's still best
    to minimize redundancy where you can.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论是明显的还是微妙的，冗余并不是问题。所谓的“不要重复自己”（DRY）原则并不特别适用于测试。多次测试某事物并没有多少缺点。这并不是说复制粘贴测试是个好主意，因为那绝对不是。看到你的测试之间存在相似之处不要感到惊讶或恐慌，但不要以此为借口。每个检查特定事物的测试，如果改变那个事物，都需要进行更改，所以仍然最好在可能的情况下最小化冗余。
- en: Check yourself – writing integration tests
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自我检查——编写集成测试
- en: 'Try answering the following questions to check about integration tests yourself:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试回答以下问题来自我检查集成测试：
- en: Which integration tests do you write first?
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你首先编写哪些集成测试？
- en: 'Answer: The ones in the smallest circles, especially if they don''t have any
    lines pointing from themselves to other circles. Put another way, write the most
    independent tests first.'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：那些在最小圆圈中的，尤其是如果它们没有任何指向其他圆圈的线条。换句话说，先编写最独立的测试。
- en: What happens when you have a large chunk of integrated code, but the next section
    you need to pull in doesn't have any integration tests at all?
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你有一大块已经集成的代码，但接下来需要集成的下一部分完全没有集成测试时，会发生什么？
- en: 'Answer: Start from the smallest circles involving that code, and build up step-by-step
    until you''re ready to integrate it with your earlier code.'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：从涉及该代码的最小圆圈开始，逐步构建，直到你准备好将其与之前的代码集成。
- en: What's the point of writing tests that check the integration of a chunk of code
    with itself?
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 写出测试来检查一大块代码与其自身的集成有什么意义呢？
- en: 'Answer: When we were doing unit testing, even other instances of the same class
    were mocked, as were other methods of the same instance when it was reasonable
    to do so; we were concerned that this code did what it was supposed to, without
    involving anything else. Now that we''re doing integration testing, we need to
    test the instances of the same class that interact correctly with each other,
    or with themselves when they''re allowed to retain a state from one operation
    to the next. The two kinds of tests cover different things, so it makes sense
    that we would need both.'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：当我们进行单元测试时，即使是同一类的其他实例也会被模拟，当合理时，同一实例的其他方法也会被模拟；我们关心的是，这段代码做了它应该做的事情，而没有涉及任何其他东西。现在我们进行集成测试，我们需要测试那些能够正确相互交互的同一类的实例，或者当它们被允许从一个操作保留状态到下一个操作时，与它们自己交互。这两种测试覆盖了不同的事情，所以我们需要两者都有是有意义的。
- en: What is a system test and how do system tests relate to integration tests?
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 系统测试是什么，系统测试如何与集成测试相关？
- en: 'Answer: A system test is the final stage of integration testing. It''s a test
    that involves the whole code base.'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案：系统测试是集成测试的最后阶段。这是一个涉及整个代码库的测试。
- en: Summary
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the process of building from a foundation
    of unit tests into a set of tests that cover the whole system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了从单元测试的基础构建到覆盖整个系统的测试集的过程。
- en: Specifically, we covered how to draw an integration diagram. We learned how
    to interpret an integration diagram to decide in what order to build the tests
    and also learned which tools to use and how to use them to write the integration
    tests.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们学习了如何绘制集成图。我们学习了如何解释集成图以决定测试的构建顺序，也学习了使用哪些工具以及如何使用它们来编写集成测试。
- en: Now that we've learned about integration testing, we're ready to introduce a
    number of other useful testing tools and strategies, which is the topic of the
    next chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了集成测试，我们准备介绍许多其他有用的测试工具和策略，这是下一章的主题。
