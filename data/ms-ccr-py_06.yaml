- en: Working with Processes in Python
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中处理进程
- en: This chapter is the first of three chapters on using concurrency through multiprocessing
    programming in Python. We have seen various examples of processes being used in
    concurrent and parallel programming. In this chapter, you will be introduced to
    the formal definition of a process, as well as the `multiprocessing` module in
    Python. This chapter will go through some of the most common ways of working with
    processes using the API of the `multiprocessing` module, such as the `Process` class,
    the `Pool` class, and interprocess communication tools such as the `Queue` class.
    This chapter will also look at the key differences between multithreading and
    multiprocessing in concurrent programming.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于在Python中使用多进程编程进行并发的三章中的第一章。我们已经看到了在并发和并行编程中使用进程的各种示例。在本章中，您将了解进程的正式定义，以及Python中的`multiprocessing`模块。本章将介绍使用`multiprocessing`模块的API与进程一起工作的一些最常见的方法，例如`Process`类，`Pool`类和诸如`Queue`类之类的进程间通信工具。本章还将研究并发编程中多线程和多进程之间的主要区别。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The concept of a process in the context of concurrent programming in computer
    science
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算机科学中并发编程的上下文中的进程概念
- en: The basic API of the `multiprocessing` module in Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中`multiprocessing`模块的基本API
- en: How to interact with processes and the advanced functionalities that the `multiprocessing`
    module provides
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何与进程交互以及`multiprocessing`模块提供的高级功能
- en: How the `multiprocessing` module supports interprocess communication
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块如何支持进程间通信'
- en: The key differences between multiprocessing and multithreading in concurrent
    programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发编程中多进程和多线程之间的主要区别
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: Install Python 3 on your computer
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算机上安装Python 3
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: Ensure that you can access the subfolder named `Chapter06`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您可以访问名为`Chapter06`的子文件夹
- en: Check out the following video to see the Code in Action: [http://bit.ly/2BtwlJw](http://bit.ly/2BtwlJw)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的运行情况：[http://bit.ly/2BtwlJw](http://bit.ly/2BtwlJw)
- en: The concept of a process
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程的概念
- en: In the field of computer science, a **process of execution** is an instance
    of a specific computer program or software that is being executed by the operating
    system. A process contains both the program code and its current activities and
    interactions with other entities. Depending on the operating system, the implementation
    of a process can be made up of multiple threads of execution that can execute
    instructions concurrently or in parallel.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，**执行过程**是操作系统正在执行的特定计算机程序或软件的实例。进程包含程序代码及其当前的活动和与其他实体的交互。根据操作系统的不同，进程的实现可以由多个执行线程组成，这些线程可以并发或并行执行指令。
- en: It is important to note that a process is not equivalent to a computer program.
    While a program is simply a static collection of instructions (program code),
    a process is instead the actual execution of those instructions. This also means
    that the same program could be run concurrently by spawning multiple processes.
    These processes execute the same code from the parent program.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，进程不等同于计算机程序。虽然程序只是一组静态指令（程序代码），但进程实际上是这些指令的实际执行。这也意味着相同的程序可以通过生成多个进程并发地运行。这些进程执行来自父程序的相同代码。
- en: For example, the internet browser Google Chrome usually manages a process called
    **Google Chrome Helper** for its main program in order to facilitate web browsing
    and other processes, to assist with various purposes. An easy way to see what
    different processes your system is running and managing involves using Task Manager
    for Windows, Activity Monitor for iOS, and System Monitor for Linux operating
    systems.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，互联网浏览器Google Chrome通常会管理一个名为**Google Chrome Helper**的进程，以便为其主程序提供网页浏览和其他进程的便利，以协助各种目的。查看系统正在运行和管理的不同进程的简单方法包括使用Windows的任务管理器，iOS的活动监视器和Linux操作系统的系统监视器。
- en: 'The following is a screenshot of my Activity Monitor. Multiple processes with
    the name Google Chrome Helper can be seen in the list. The PID column (which stands
    for **process ID**) reports the unique ID that each process has:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我的活动监视器的屏幕截图。在列表中可以看到多个名为Google Chrome Helper的进程。`PID`列（代表**进程ID**）报告了每个进程的唯一ID：
- en: '![](assets/3acd51e5-d3a6-475d-bd2d-ea66d49e35d8.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3acd51e5-d3a6-475d-bd2d-ea66d49e35d8.png)'
- en: Sample list of processes
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 进程的示例列表
- en: Processes versus threads
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程与线程
- en: 'One of the most common mistakes that programmers make when developing concurrent
    and parallel applications is to confuse the structure and functionalities of processes
    and threads. As we have seen from [Chapter 3](eed3a259-04e1-4778-809e-570f7e0b20ce.xhtml),
    *Working with Threads in Python*, a thread is the smallest unit of programming
    code, and is typically a component of a process. Furthermore, more than one thread
    can be implemented within the same process to access and share memory or other
    resources, while different processes do not interact in this way. This relationship
    is shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发并发和并行应用程序时，程序员经常犯的一个常见错误是混淆进程和线程的结构和功能。正如我们从[第3章](eed3a259-04e1-4778-809e-570f7e0b20ce.xhtml)中所看到的，*在Python中使用线程*，线程是编程代码的最小单位，通常是进程的组成部分。此外，可以在同一进程中实现多个线程以访问和共享内存或其他资源，而不同的进程不以这种方式进行交互。这种关系如下图所示：
- en: '![](assets/8da2ba25-b5b5-4225-beb9-e94d2eb3beec.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8da2ba25-b5b5-4225-beb9-e94d2eb3beec.png)'
- en: Diagram of two threads executing in one process
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程在一个进程中执行的图表
- en: 'Since a process is a larger programming unit than a thread, it is also more
    complicated and consists of more programming components. A process, therefore,
    also requires more resources, while a thread does not and is sometimes called
    a lightweight process. In a typical computer system process, there are a number
    of main resources, as shown in the following list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于进程是比线程更大的编程单元，因此它也更复杂，包含更多的编程组件。因此，进程也需要更多的资源，而线程则不需要，有时被称为轻量级进程。在典型的计算机系统进程中，有许多主要资源，如下列表所示：
- en: An image (or copy) of the code being executed from the parent program.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从父程序执行的代码的图像（或副本）。
- en: Memory associated with an instance of a program. This might include executable
    code, input and output for that specific process, a call stack to manage program-specific
    events, or a heap that contains generated computation data and is currently being
    used by the process during runtime.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与程序实例相关联的内存。这可能包括特定进程的可执行代码、输入和输出、用于管理程序特定事件的调用堆栈，或者包含生成的计算数据并在运行时由进程使用的堆。
- en: Descriptors for the resources allocated to that specific process by the operating
    system. We have seen an example of these—file descriptors—in [Chapter 4](451dc46f-ca5b-4c05-a743-04a826653e11.xhtml), *Using
    the with Statement in Threads*.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由操作系统分配给特定进程的资源的描述符。我们已经在第4章中看到了这些资源的示例——文件描述符——*在线程中使用with语句*。
- en: Security components of a specific process, namely the owner of the process and
    its permissions and allowed operations.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定进程的安全组件，即进程的所有者及其权限和允许的操作。
- en: The processor state, also known as the process context. The context data of
    a process is often located in processor registers, the memory used by the process,
    or in control registers used by the operating system to manage the process.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理器状态，也称为进程上下文。进程的上下文数据通常位于处理器寄存器、进程使用的内存或操作系统用于管理进程的控制寄存器中。
- en: Because each process has a state dedicated to it, processes hold more state
    information than threads; multiple threads within a process in turn share process
    states, memory, and other various resources. For similar reasons, processes only
    interact with each other through system-facilitated interprocess communication
    methods, while threads can communicate with one another easily through shared
    resources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个进程都有专门的状态，进程比线程保存更多的状态信息；进程内的多个线程又共享进程状态、内存和其他各种资源。出于类似的原因，进程只能通过系统提供的进程间通信方法与其他进程进行交互，而线程可以通过共享资源轻松地相互通信。
- en: Additionally, context-switching—the act of saving the state data of a process
    or a thread to interrupt the execution of a task and resume it at a later time—takes
    more time between different processes than between different threads within the
    same process. However, while we have seen that communication between threads requires
    careful memory synchronization to ensure correct data handling, since there is
    less communication between separate processes, little or no memory synchronization
    is needed for processes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，上下文切换——保存进程或线程的状态数据以中断任务的执行并在以后恢复它的行为——在不同进程之间所需的时间比在同一进程内的不同线程之间所需的时间更长。然而，尽管我们已经看到线程之间的通信需要仔细的内存同步以确保正确的数据处理，由于不同进程之间的通信较少，进程几乎不需要或不需要内存同步。
- en: Multiprocessing
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多处理
- en: A common concept in computer science is multitasking. When multitasking, an
    operating system simply switches between different processes at high speed to
    give the appearance that these processes are being executed simultaneously, even
    though it is usually the case that only one process is executing on one single
    **central processing unit** (**CPU**) at any given time. In contrast, multiprocessing
    is the method of using more than one CPU to execute a task.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中的一个常见概念是多任务处理。在多任务处理时，操作系统会以高速在不同进程之间切换，从而使这些进程看起来像是同时执行，尽管通常情况下只有一个进程在任何给定时间内在一个单独的中央处理单元（CPU）上执行。相比之下，多处理是使用多个CPU来执行任务的方法。
- en: While there are a number of different uses of the term multiprocessing, in the
    context of concurrency and parallelism multiprocessing refers to the execution
    of multiple concurrent processes in an operating system, in which each process
    is executed on a separate CPU, as opposed to a single process being executed at
    any given time. By the nature of processes, an operating system needs to have
    two or more CPUs in order to be able to implement multiprocessing tasks, as it
    needs to support many processors at the same time and allocate tasks between them
    appropriately.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然术语多处理有许多不同的用法，但在并发性和并行性的上下文中，多处理指的是在操作系统中执行多个并发进程，其中每个进程在单独的CPU上执行，而不是在任何给定时间内执行单个进程。由于进程的性质，操作系统需要有两个或更多个CPU才能实现多处理任务，因为它需要同时支持多个处理器并适当地分配任务。
- en: 'This relationship is shown in the following diagram:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此关系显示在以下图表中：
- en: '![](assets/269f5c8c-8758-47e1-86b2-b9838cf3a8b5.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/269f5c8c-8758-47e1-86b2-b9838cf3a8b5.png)'
- en: Example diagram of multiprocessing using two CPU cores
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 多处理使用两个CPU核心的示例图
- en: We have seen in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working
    with Threads in Python*, that multithreading shares a somewhat similar definition
    to multiprocessing. Multithreading means that only one processor is utilized,
    and the system switches between tasks within that processor (also known as **time
    slicing**), while multiprocessing generally denotes the actual concurrent/parallel
    execution of multiple processes using multiple processors.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第3章中看到，多线程与多处理有相似的定义。多线程意味着只有一个处理器被利用，并且系统在该处理器内的任务之间进行切换（也称为时间片切割），而多处理通常表示使用多个处理器实际并发/并行执行多个进程。
- en: 'Multiprocessing applications have enjoyed significant popularity in the field
    of concurrent and parallel programming. Some reasons for this are listed as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多进程应用在并发和并行编程领域享有显著的流行度。一些原因如下所列：
- en: '**Faster execution time**: As we know, when done correctly concurrency always
    provides additional speedups for your programs, provided that some parts of them
    can be executed independently.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的执行时间**：我们知道，正确的并发总是能够为程序提供额外的加速，前提是它们的某些部分可以独立执行。'
- en: '**Synchronization free**: Given the fact that separate processes do not share
    resources among themselves in a multiprocessing application, developers rarely
    need to spend their time coordinating the sharing and synchronization of these
    resources, unlike multithreaded applications, where efforts need to be made to
    make sure that data is being manipulated correctly.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无需同步**：由于在多进程应用中，独立的进程不会共享资源，开发人员很少需要花时间协调这些资源的共享和同步，不像多线程应用程序，需要努力确保数据被正确操作。'
- en: '**Safety from crashes**: As processes are independent from each other in terms
    of both computing procedures and input/output, the failure of one process will
    not affect the execution of another in a multiprocessing program, if handled correctly.
    This implies that programmers could afford to spawn a larger number of processes
    (that their system can still handle) and the chance of crashing the entire application
    would not increase.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**免于崩溃**：由于进程在计算过程和输入/输出方面是相互独立的，多进程程序中一个进程的失败不会影响另一个进程的执行，如果处理正确的话。这意味着程序员可以承担产生更多进程（系统仍然可以处理的）的风险，而整个应用程序崩溃的机会不会增加。'
- en: 'With that being said, there are also noteworthy disadvantages to using multiprocessing
    that we should consider, as shown in the following list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，使用多进程也有一些值得注意的缺点，如下列表所示：
- en: '**Multiple processors are needed**: Again, multiprocessing requires the operating
    system to have more than one CPU. Even though multiple processors are fairly common
    for computer systems nowadays, if yours does not have more than one, then the
    implementation of multiprocessing will not be possible.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需要多个处理器**：再次强调，多进程需要操作系统拥有多个CPU。尽管多处理器如今对计算机系统来说相当普遍，但如果你的系统没有多个处理器，那么多进程的实现将是不可能的。'
- en: '**Processing time and space**: As mentioned before, there are many complex
    components involved in implementing a process and its resources. It therefore
    takes significant computing time and power to spawn and manage processes in comparison
    to doing the same with threads.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理时间和空间：如前所述，实现一个进程及其资源涉及许多复杂的组件。因此，与使用线程相比，生成和管理进程需要大量的计算时间和计算能力。
- en: Introductory example in Python
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的入门示例
- en: 'To illustrate the concept of running multiple processes on one operating system,
    let''s look at a quick example in Python. Let''s take a look at the `Chapter06/example1.py` file,
    as shown in the following code:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明在一个操作系统上运行多个进程的概念，让我们看一个Python的快速示例。让我们看一下`Chapter06/example1.py`文件，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this file, we are going back to the counting-down example that we saw in [Chapter
    3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working with Threads in Python*,
    while we look at the concept of a thread. Our `count_down()` function takes in
    a string as a process identifier and a delay time range. It will then count down
    from 5 to 1 while sleeping between iterations for a number of seconds specified
    by the `delay` parameter. The function also prints out a message with the process
    identifier at each iteration.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们回到了在[第3章](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml)中看到的倒计时示例，*在Python中使用线程*，同时我们也看一下线程的概念。我们的`count_down()`函数接受一个字符串作为进程标识符和一个延迟时间范围。然后它将从5倒数到1，同时在每次迭代之间睡眠，睡眠时间由`delay`参数指定。该函数还在每次迭代时打印出带有进程标识符的消息。
- en: As we saw in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working
    with Threads in Python*, the point of this counting-down example is to show the
    concurrent nature of running separate tasks at the same time, this time through
    different processes by using the `Process` class from the `multiprocessing` module.
    In our main program, we initialize two processes at the same time to implement
    two separate time-based countdowns simultaneously. Similar to how two separate
    threads would do this, our two processes will carry out their own countdowns concurrently.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第3章](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml)中所看到的，*在Python中使用线程*，这个倒计时的例子的目的是展示同时运行不同进程的并发性质，这次是通过使用`multiprocessing`模块中的`Process`类来实现的。在我们的主程序中，我们同时初始化两个进程来同时实现两个独立的基于时间的倒计时。与两个独立的线程一样，我们的两个进程将同时进行它们自己的倒计时。
- en: 'After running the Python script, your output should be similar to the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Python脚本后，你的输出应该类似于以下内容：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Just as we expected, the output tells us that the two countdowns from the separate
    processes were executed concurrently; instead of finishing the first process'
    countdown and then starting the second's, the program ran the two countdowns at
    almost the same time. Even though processes are more expensive and contain more
    overhead than threads, multiprocessing also allows double the improvement in terms
    of speed for programs such as the preceding one.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，输出告诉我们，两个独立进程的倒计时是同时执行的；程序并不是先完成第一个进程的倒计时，然后再开始第二个进程的，而是几乎同时运行了两个倒计时。尽管进程比线程更昂贵，包含更多的开销，但多进程也允许程序的速度提高一倍，就像前面的例子一样。
- en: Remember that in multithreading we saw a phenomenon in which the order of the
    printed output changed between different runs of the program. Specifically, sometimes
    process B would get ahead of process A during the countdown and finish before
    process A, even though it was initialized later. This is, again, a direct result
    of implementing and starting two processes that execute the same function at almost
    the same time. By executing the script many times, you will see that it is quite
    likely for you to obtain changing output in terms of the order of the counting
    and the completion of the countdowns.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在多线程中，我们看到一个现象，即程序的不同运行之间打印输出的顺序发生了变化。具体来说，有时进程B在倒计时期间超过进程A并在进程A之前完成，尽管它是后初始化的。这又一次是由于几乎同时执行相同函数的两个进程的实现和启动的直接结果。通过多次执行脚本，您会发现在计数和倒计时完成的顺序方面，您很可能会获得不断变化的输出。
- en: An overview of the multiprocessing module
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多进程模块概述
- en: The `multiprocessing` module is one of the most commonly used implementations
    of multiprocessing programming in Python. It offers methods to spawn and interact
    with processes using an API similar to the `threading` module (as we saw with
    the `start()` and `join()` methods in the preceding example). According to its
    documentation website, the module allows both local and remote concurrency and
    effectively avoids the **global interpreter lock** (**GIL**) in Python (which
    we will discuss in more detail later in [Chapter 15](0e30892f-4bb1-4196-93c5-5df1d57428b8.xhtml),
    *The Global Interpreter Lock*) by using subprocesses instead of threads.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块是Python中最常用的多进程编程实现之一。它提供了一种类似于`threading`模块的API，用于生成和与进程交互（就像我们在前面的示例中看到的`start()`和`join()`方法）。根据其文档网站，该模块允许本地和远程并发，并通过使用子进程而不是线程有效地避免了Python中的全局解释器锁（GIL）（我们将在[第15章](0e30892f-4bb1-4196-93c5-5df1d57428b8.xhtml)中更详细地讨论这一点，*全局解释器锁*）。'
- en: The process class
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程类
- en: In the `multiprocessing` module, processes are typically spawned and managed
    through the `Process` class. Each `Process` object represents an activity that
    executes in a separate process. Conveniently, the `Process` class has equivalent
    methods and APIs that can be found in the `threading.Thread` class.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在`multiprocessing`模块中，进程通常通过`Process`类生成和管理。每个`Process`对象代表在单独进程中执行的活动。方便的是，`Process`类具有与`threading.Thread`类中的等效方法和API。
- en: 'Specifically, utilizing an object-oriented programming approach, the `Process`
    class from `multiprocessing` provides the following resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，利用面向对象的编程方法，`multiprocessing`中的`Process`类提供以下资源：
- en: '`run()`: This method is executed when a new process is initialized and started'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run()`：当初始化并启动新进程时执行此方法'
- en: '`start()`: This method starts the initialized calling `Process` object by calling
    the `run()` method'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start()`：此方法通过调用`run()`方法启动初始化的调用`Process`对象'
- en: '`join()`: This method waits for the calling `Process` object to terminate before
    continuing with the execution of the rest of the program'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`：此方法在继续执行程序的其余部分之前等待调用`Process`对象终止'
- en: '`isAlive()`: This method returns a Boolean value indicating whether the calling `Process`
    object is currently executing'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isAlive()`：此方法返回一个布尔值，指示调用的`Process`对象当前是否正在执行'
- en: '`name`: This attribute contains the name of the calling `Process` object'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：此属性包含调用`Process`对象的名称'
- en: '`pid`: This attribute contains the process ID of the calling `Process` object'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid`：此属性包含调用`Process`对象的进程ID'
- en: '`terminate()`: This method terminates the calling `Process` object'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`terminate()`：此方法终止调用的`Process`对象'
- en: As you can see from our previous example, while initializing a `Process` object,
    we can pass parameters to a function and execute it in a separate process by specifying
    the `target` (for the target function) and `args` (for target function arguments)
    parameters. Note that one could also override the default `Process()` constructor
    and implement one's own `run()` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可以从我们之前的示例中看到的，初始化`Process`对象时，我们可以通过指定`target`（目标函数）和`args`（目标函数参数）参数向函数传递参数，并在单独的进程中执行它。请注意，也可以重写默认的`Process()`构造函数并实现自己的`run()`函数。
- en: As it is a major player in the `multiprocessing` module and in concurrency in
    Python in general, we will look at the `Process` class again in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是`multiprocessing`模块和Python中并发的主要组成部分，我们将在下一节再次查看`Process`类。
- en: The Pool class
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池类
- en: In the `multiprocessing` module, the `Pool` class is mainly used to implement
    a pool of processes, each of which will carry out tasks submitted to a `Pool`
    object. Generally, the `Pool` class is more convenient than the `Process` class,
    especially if the results returned from your concurrent application should be
    ordered.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`multiprocessing`模块中，`Pool`类主要用于实现一组进程，每个进程将执行提交给`Pool`对象的任务。通常，`Pool`类比`Process`类更方便，特别是如果并发应用程序返回的结果应该是有序的。
- en: Specifically, we have seen that the order of completion for different items
    in a list is considerably likely to change when put through a function concurrently as
    the program runs over and over again. This leads to difficulty when reordering
    the outputs of the program with respect to the order of the inputs that produced
    them. One possible solution to this is to create tuples of processes and their
    outputs, and to sort them by process ID.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们已经看到，当通过函数并发地运行程序时，列表中不同项目的完成顺序很可能会发生变化。这导致在重新排序程序的输出时，难以根据产生它们的输入的顺序进行排序。其中一个可能的解决方案是创建进程和它们的输出的元组，并按进程ID对它们进行排序。
- en: 'This problem is addressed by the `Pool` class: the `Pool.map()` and `Pool.apply()`
    methods follow the convention of Python''s traditional `map()` and `apply()` methods,
    ensuring that the returned values are ordered in the same way that the input is.
    These methods, however, block the main program until a process has finished processing.
    The `Pool` class, therefore, also has the `map_async()` and `apply_async()` functions
    to better assist concurrency and parallelism.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool`类解决了这个问题：`Pool.map()`和`Pool.apply()`方法遵循Python传统`map()`和`apply()`方法的约定，确保返回的值按照输入的顺序排序。然而，这些方法会阻塞主程序，直到进程完成处理。因此，`Pool`类还具有`map_async()`和`apply_async()`函数，以更好地支持并发和并行。'
- en: Determining the current process, waiting, and terminating processes
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定当前进程、等待和终止进程
- en: The `Process` class provides a number of ways to easily interact with processes
    in a concurrent program. In this section, we will explore the options of managing
    different processes by determining the current process, waiting, and terminating
    processes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Process`类提供了一些在并发程序中轻松与进程交互的方法。在本节中，我们将探讨通过确定当前进程、等待和终止进程来管理不同进程的选项。'
- en: Determining the current process
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定当前进程
- en: Working with processes is at times considerably difficult, and significant debugging
    is therefore required. One of the methods of debugging a multiprocessing program
    is to identify the processes that encounter errors. As a refresher, in the previous
    countdown example we passed a `name` parameter to the `count_down()` function
    to determine where each process is during the countdown.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 处理进程有时会相当困难，因此需要进行重大调试。调试多进程程序的一种方法是识别遇到错误的进程。作为复习，在前面的倒计时示例中，我们向`count_down()`函数传递了一个`name`参数，以确定倒计时期间每个进程的位置。
- en: This is, however, unnecessary as each `Process` object has a `name` parameter
    (with a default value) that can be changed. Naming processes is a better way to
    keep track of running processes than passing an identifier to the target function
    itself (as we did earlier), especially in applications with different types of
    processes running at the same time. One powerful functionality that the `multiprocessing`
    module provides is the `current_process()` method, which will return the `Process`
    object that is currently running at any point of a program. This is another way
    to keep track of running processes effectively and effortlessly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是不必要的，因为每个`Process`对象都有一个`name`参数（带有默认值），可以进行更改。给进程命名是跟踪运行进程的更好方法，而不是将标识符传递给目标函数本身（就像我们之前做的那样），特别是在同时运行不同类型进程的应用程序中。`multiprocessing`模块提供的一个强大功能是`current_process()`方法，它将返回当前正在运行的`Process`对象。这是另一种有效而轻松地跟踪运行进程的方法。
- en: 'Let''s look at this in more detail using an example. Navigate to the `Chapter06/example2.py`
    file, as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子更详细地看一下。转到`Chapter06/example2.py`文件，如下所示的代码：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this example, we have two dummy functions, `f1()` and `f2()`, each of which
    prints out the name of the process that executes the function before and after
    sleeping for a specified period of time. In our main program, we initialize three
    separate processes. The first two we name `Worker 1` and `Worker 2` respectively,
    and the last we purposefully leave blank to give it the default value of its name
    (that is, `''Process-3''`). After running the script, you should have an output
    similar to the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有两个虚拟函数`f1()`和`f2()`，每个函数在睡眠一段指定的时间后打印执行该函数的进程的名称。在我们的主程序中，我们初始化了三个单独的进程。前两个我们分别命名为`Worker
    1`和`Worker 2`，最后一个我们故意留空，以给它的名称默认值（即`'Process-3'`）。运行脚本后，您应该会得到类似以下的输出：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can see that the `current_process()` successfully helped us access the correct
    process that ran each function, and the third process was assigned the name `Process-3`
    by default. Another way to keep track of the running processes in your program
    is to look at the individual process IDs using the `os` module. Let''s take a
    look at a modified example in the `Chapter06/example3.py` file, as shown in the
    following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`current_process()`成功帮助我们访问运行每个函数的正确进程，并且第三个进程默认分配了名称`Process-3`。在程序中跟踪运行进程的另一种方法是使用`os`模块查看各个进程的ID。让我们看一个修改后的例子，在`Chapter06/example3.py`文件中，如下所示的代码：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our main focus for this example is the `print_info()` function, which uses
    the `os.getpid()` and `os.getppid()` functions to identify the current process
    using its process ID. Specifically, `os.getpid()` returns the process ID of the
    current process, and `os.getppid()` (which is only available on Unix systems)
    returns the ID of the parent process. The following is my input after running
    the script:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这个例子的主要焦点是`print_info()`函数，它使用`os.getpid()`和`os.getppid()`函数来使用进程ID标识当前进程。具体来说，`os.getpid()`返回当前进程的进程ID，而`os.getppid()`（仅在Unix系统上可用）返回父进程的ID。在运行脚本后，以下是我的输入：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The process IDs might vary from system to system, but their relative relationship
    should be the same. Specifically for my output, we can see that, while the ID
    for the main Python program was `29010`, the ID of its parent process was `14806`.
    Using **Activity Monitor**, I crosschecked this ID and connected it to my Terminal
    and Bash profile, which makes sense since I ran this Python script from my Terminal.
    You can see the displayed results from Activity Monitor in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 进程ID可能因系统而异，但它们的相对关系应该是相同的。特别是对于我的输出，我们可以看到，主Python程序的ID是`29010`，其父进程的ID是`14806`。使用**Activity
    Monitor**，我交叉检查了这个ID，并将其连接到我的Terminal和Bash配置文件，这是有道理的，因为我是从我的Terminal运行这个Python脚本的。您可以在以下截图中看到Activity
    Monitor中显示的结果：
- en: '![](assets/392bb757-d08e-43ad-9287-211bd4750295.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/392bb757-d08e-43ad-9287-211bd4750295.png)'
- en: Screenshot of Activity Monitor being used to crosscheck PIDs
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Activity Monitor交叉检查PID的截图
- en: In addition to the main Python program, we also called `print_info()` inside
    the `f()` function, whose process ID was `29012`. We can also see that the parent
    process of the process running the `f()` function is actually our main process,
    whose ID was `29010`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主Python程序外，我们还在`f()`函数内调用了`print_info()`，其进程ID为`29012`。我们还可以看到运行`f()`函数的进程的父进程实际上是我们的主进程，其ID为`29010`。
- en: Waiting for processes
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待进程
- en: Oftentimes, we'd like to wait for all of our concurrent processes to finish
    executing before moving to a new section of the program. As mentioned before,
    the `Process` class from the `multiprocessing` module provides the `join()` method
    in order to implement a way to wait until a process has completed its task and
    exits.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望在移动到程序的新部分之前等待所有并发进程完成执行。如前所述，`multiprocessing`模块中的`Process`类提供了`join()`方法，以实现等待进程完成任务并退出的方法。
- en: However, sometimes developers want to implement processes that run in the background
    and do not block the main program from exiting. This specification is commonly
    used when there is no easy way for the main program to tell whether it is appropriate
    to interrupt the process at any given time, or when exiting the main program without
    completing the worker does not affect the end result.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时开发人员希望实现在后台运行并且不阻止主程序退出的进程。当主程序没有简单的方法告诉它是否适合在任何给定时间中断进程，或者在退出主程序而不完成工作进程不会影响最终结果时，通常会使用这个规范。
- en: 'These processes are called **daemon processes**. The `Process` class also provides
    an easy option to specify whether a process is a daemon through the `daemon` attribute,
    which takes a Boolean value. The default value for the `daemon` attribute is `False`,
    so setting it to `True` will turn a given process into a daemon. Let''s look at
    this in more detail using an example in the `Chapter06/example4.py` file, as shown
    in the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些进程被称为**守护进程**。`Process`类还提供了一个简单的选项来通过`daemon`属性指定进程是否是守护进程，该属性接受一个布尔值。`daemon`属性的默认值是`False`，因此将其设置为`True`将使给定进程成为守护进程。让我们通过`Chapter06/example4.py`文件中的示例更详细地了解一下，如下所示：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this example, we have a long-running function (represented by `f1()`, which
    has a sleep period of `4` seconds) and a faster function (represented by `f2()`, which
    has a sleep period of only `2` seconds). We also have two separate processes,
    as shown in the following list:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个长时间运行的函数（由`f1()`表示，其中有4秒的休眠时间）和一个更快的函数（由`f2()`表示，其中只有2秒的休眠时间）。我们还有两个单独的进程，如下列表所示：
- en: The `p1 `process, which is a daemon process assigned to run `f1()`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p1`进程是一个守护进程，负责运行`f1()`。'
- en: The `p2 `process, which is a regular process assigned to run `f2()`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`p2`进程是一个常规进程，负责运行`f2()`'
- en: 'In our main program, we start both processes without calling the `join()` method
    on either of them at the end of the program. Since `p1` is a long-running process,
    it will most likely not finish executing before `p2 `(which is the faster process
    of the two) finishes. We also know that `p1` is a daemon process, so our program
    should exit before it finishes executing. After running the Python script, your
    output should be similar to the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主程序中，我们启动了这两个进程，但在程序结束时没有调用`join()`方法。由于`p1`是一个长时间运行的进程，它很可能在`p2`（两者中更快的进程）完成之前不会执行完。我们也知道`p1`是一个守护进程，所以我们的程序应该在它执行完之前退出。运行Python脚本后，你的输出应该类似于以下代码：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Again, even though the process IDs might be different when you yourself run
    the script, the general format of the output should be the same. As we can see,
    the output is consistent with what we discussed: both `p1` and `p2` processes were
    initialized and started by our main program, and the program terminated after
    the nondaemon process exited without waiting for the daemon process to finish.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，即使当您自己运行脚本时，进程ID可能会有所不同，但输出的一般格式应该是相同的。正如我们所看到的，输出与我们讨论的内容一致：我们的主程序初始化并启动了`p1`和`p2`进程，并且在非守护进程退出后立即终止了程序，而不等待守护进程完成。
- en: The ability to terminate the main program without having to wait for specific
    tasks that the daemon is processing is indeed extremely useful. However, sometimes
    we might want to wait for daemon processes for a specified amount of time before
    exiting; this way, if the specifications of the program allow some waiting time
    for the process' execution, we could complete some potential daemon processes
    instead of terminating all of them prematurely.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不等待守护进程处理特定任务的情况下终止主程序的能力确实非常有用。然而，有时我们可能希望在退出之前等待守护进程一段指定的时间；这样，如果程序的规格允许等待进程执行一段时间，我们可以完成一些潜在的守护进程，而不是过早地终止它们。
- en: 'The combination of daemon processes and the `join()` method from the `multiprocessing`
    module can help us implement this architecture, especially given that, while the
    `join()` method blocks the program execution indefinitely (or at least until the
    task finishes), it is also possible to pass a timeout argument to specify the
    number of seconds to wait for the process before exiting. Let''s consider a modified
    version of the previous example in `Chapter06/example5.py`. With the same `f1()`
    and `f2()` functions, in the following script, we are changing the way we handle
    the daemon process in the main program:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 守护进程和`multiprocessing`模块中的`join()`方法的结合可以帮助我们实现这种架构，特别是考虑到，虽然`join()`方法会无限期地阻塞程序执行（或者至少直到任务完成），但也可以传递一个超时参数来指定在退出之前等待进程的秒数。让我们考虑`Chapter06/example5.py`中前一个例子的修改版本。使用相同的`f1()`和`f2()`函数，在下面的脚本中，我们改变了主程序中处理守护进程的方式：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Instead of terminating without waiting for the daemon process, in this example,
    we are calling the `join()` method on both processes: we allow one second for `p1` to
    finish while we block the main program until `p2` finishes. If `p1` has not finished
    executing after that one second, the main program simply continues executing the
    rest of the program and exits, at which time we will see that `p1`—or `Worker
    1`—is still alive. After running the Python script, your output should be similar
    to the following:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不是在等待守护进程而是调用了`join()`方法来等待两个进程：我们允许`p1`在一秒内完成，同时阻塞主程序直到`p2`完成。如果`p1`在一秒后仍未执行完，主程序将继续执行其余部分并退出，这时我们会看到`p1`—或`Worker
    1`—仍然活着。运行Python脚本后，你的输出应该类似于以下内容：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see that `p1` was indeed still alive by the time the program moved on after
    waiting for it for one second.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到`p1`在等待一秒后确实还活着。
- en: Terminating processes
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 终止进程
- en: The `terminate()` method from the `multiprocessing.Process` class offers a way
    to quickly terminate a process. When the method is called, exit handlers, finally
    causes, or similar resources that are specified in the `Process` class or an overridden
    class will not be executed. However, descendant processes of the terminated process
    will not be terminated. These processes are known as **orphaned processes**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing.Process`类中的`terminate()`方法提供了一种快速终止进程的方式。当调用该方法时，`Process`类或重写类中指定的退出处理程序、最终原因或类似资源将不会被执行。然而，终止进程的后代进程不会被终止。这些进程被称为**孤立进程**。'
- en: Although terminating processes is sometimes frowned upon, it is sometimes necessary
    because some processes interact with interprocess-communication resources, such
    as locks, semaphores, pipes, or queues, and forcibly stopping those processes
    is likely to cause those resources to become corrupted or unavailable to other
    processes. If, however, the processes in your program never interact with the
    aforementioned resources, the `terminate()` method is considerably useful, especially
    if a process appears to be unresponsive or deadlocked.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时终止进程会受到指责，但有时是必要的，因为某些进程与进程间通信资源（如锁、信号量、管道或队列）交互，强行停止这些进程可能导致这些资源变得损坏或对其他进程不可用。然而，如果程序中的进程从未与上述资源交互，`terminate()`方法是非常有用的，特别是如果一个进程看起来无响应或死锁。
- en: One thing to note when using the `terminate()` method is that, even though the
    `Process` object is effectively killed after calling the method, it is important
    that you call `join()` on the object as well. Since the `alive` status of `Process`
    objects is sometimes not immediately updated after the `terminate()` method, this
    practice gives the background system an opportunity to implement the update itself
    to reflect the termination of the processes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`terminate()`方法时需要注意的一点是，即使在调用该方法后`Process`对象被有效地终止，也很重要的是你也要在对象上调用`join()`。由于`Process`对象的`alive`状态有时在`terminate()`方法后不会立即更新，这种做法给了后台系统一个机会来实现更新以反映进程的终止。
- en: Interprocess communication
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程间通信
- en: While locks are one of the most common synchronization primitives that are used
    for communication among threads, pipes and queues are the main way of communicating
    between different processes. Specifically, they provide message-passing options
    to facilitate communication between processes—pipes for connections between two
    processes and queues for multiple producers and consumers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然锁是用于线程间通信的最常见的同步原语之一，但管道和队列是不同进程之间通信的主要方式。具体来说，它们提供了消息传递选项，以促进进程之间的通信——管道用于连接两个进程，队列用于多个生产者和消费者。
- en: In this section, we will be exploring the usage of queues, specifically the
    `Queue` class from the `multiprocessing` module. The implementation of the `Queue`
    class is, in fact, both thread-and process-safe, and we have already seen the
    use of queues in [Chapter 3](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml), *Working
    with Threads in Python*. All pickleable objects in Python can be passed through
    a `Queue` object; in this section, we will be using queues to pass messages back
    and forth between processes.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨队列的使用，特别是`multiprocessing`模块中的`Queue`类。`Queue`类的实现实际上既是线程安全的，也是进程安全的，我们已经在[第3章](b2db614b-1859-4a86-91d8-f9383c12f4e9.xhtml)中看到了队列的使用，*在Python中使用线程*。Python中的所有可pickle对象都可以通过`Queue`对象传递；在本节中，我们将使用队列在进程之间来回传递消息。
- en: 'Using a message queue for interprocess communication is preferred over having
    shared resources since, if certain processes mishandle and corrupt shared memory
    and resources while those resources are being shared, then there will be numerous
    undesirable and unpredictable consequences. If, however, a process failed to handle
    its message correctly, other items in the queue will remain intact. The following
    diagram represents the differences in architecture between using a message queue
    and shared resources (specifically memory) for interprocess communication:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息队列进行进程间通信比使用共享资源更可取，因为如果某些进程在共享资源时处理不当并损坏了共享内存和资源，那么将会产生许多不良和不可预测的后果。然而，如果一个进程未能正确处理其消息，队列中的其他项目将保持完好。以下图表示了使用消息队列和共享资源（特别是内存）进行进程间通信的架构之间的差异：
- en: '![](assets/3b772c12-bf68-40c0-8b74-7c116d85794a.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b772c12-bf68-40c0-8b74-7c116d85794a.png)'
- en: The architecture involved in using a message queue and shared resources for
    interprocess communication
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用消息队列和共享资源进行进程间通信的架构
- en: Message passing for a single worker
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单个工作进程的消息传递
- en: Before we dive into the example code in Python, first we need to discuss specifically
    how we use a `Queue` object in our multiprocessing application. Let's say that
    we have a `worker` class that performs heavy computations and does not require
    significant resource sharing and communication. Yet these worker instances still
    need to be able to receive information from time to time during their execution.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入讨论Python中的示例代码之前，首先我们需要具体讨论如何在我们的多进程应用程序中使用`Queue`对象。假设我们有一个执行大量计算且不需要大量资源共享和通信的`worker`类。然而，这些工作者实例仍然需要能够在执行过程中不时接收信息。
- en: 'This is where the use of a queue comes in: when we put all the workers in a
    queue. At the same time, we will also have a number of initialized processes,
    each of which will go through that queue and process one worker. If a process
    has finished executing a worker and there are still other workers in the queue,
    it will move on to another worker and execute it. Looking back at the earlier
    diagram, we can see that there are two separate processes that keep picking up
    and executing messages from a queue.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是队列的使用方式：当我们将所有工作者放入队列时。同时，我们还将有一些初始化的进程，每个进程都将遍历该队列并处理一个工作者。如果一个进程已经执行完一个工作者，并且队列中仍有其他工作者，它将继续执行另一个工作者。回顾之前的图表，我们可以看到有两个单独的进程不断地从队列中取出并执行消息。
- en: 'From a `Queue` object, we will be using two main methods, as shown in the following
    list:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Queue`对象中，我们将使用以下列表中显示的两种主要方法：
- en: '`get()`: This method returns the next item in the calling `Queue` object'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get()`: 这个方法返回调用的`Queue`对象中的下一个项目'
- en: '`put()`: This method adds the parameter passed to it as an additional item
    to the calling `Queue` object'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`put()`: 这个方法将传递给它的参数作为额外项目添加到调用的`Queue`对象中'
- en: 'Let''s look at an example script showing the use of a queue in Python. Navigate
    to and open the `Chapter06/example6.py` file, as shown in the following code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例脚本，展示了在Python中使用队列。转到并打开`Chapter06/example6.py`文件，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this script, we have a `MyWorker` class that takes in a number `x` parameter and
    performs a computation from it (for now, it will only print out the number). In
    our main function, we initialize a `Queue` object from the `multiprocessing` module
    and add a `MyWorker` object with the number `10` in it. We also have the `work()` function,
    which upon being called will get the first item from the queue and process it.
    Finally, we have a process whose task is to call the `work()` function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在此脚本中，我们有一个`MyWorker`类，它接受一个`x`参数并对其进行计算（目前只会打印出数字）。在我们的主函数中，我们从`multiprocessing`模块初始化了一个`Queue`对象，并添加了一个带有数字`10`的`MyWorker`对象。我们还有`work()`函数，当被调用时，将从队列中获取第一个项目并处理它。最后，我们有一个任务是调用`work()`函数的进程。
- en: 'The structure is designed to pass a message—in this case, a `MyWorker` object—to
    one single process. The main program then waits for the process to finish executing.
    After running the script, your output should be similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 该结构旨在将消息传递给一个单一进程，即一个`MyWorker`对象。然后主程序等待进程完成执行。运行脚本后，您的输出应类似于以下内容：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Message passing between several workers
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多个工作者之间的消息传递
- en: 'As mentioned earlier, our goal is to have a structure where there are several
    processes constantly executing workers from a queue, and if a process finishes
    executing one worker, then it will pick up another. To do this, we will be utilizing
    a subclass of `Queue` called `JoinableQueue`, which will provide the additional
    `task_done()` and `join()` methods, as described in the following list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的目标是有一个结构，其中有几个进程不断地执行队列中的工作者，并且如果一个进程完成执行一个工作者，那么它将继续执行另一个。为此，我们将利用`Queue`的一个子类`JoinableQueue`，它将提供额外的`task_done()`和`join()`方法，如下列表所述：
- en: '`task_done()`: This method tells the program that the calling `JoinableQueue`
    object is complete'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`task_done()`: 这个方法告诉程序调用的`JoinableQueue`对象已经完成'
- en: '`join()`: This method blocks until all items in the calling `JoinableQueue`
    object have been processed'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`join()`: 这个方法阻塞，直到调用的`JoinableQueue`对象中的所有项目都已被处理'
- en: Now the goal here, again, is to have a `JoinableQueue` object holding all the
    tasks that are to be executed—we will call this the task queue—and a number of
    processes. As long as there are items (messages) in the task queue, the processes
    will take their turn to execute those items. We will also have a `Queue` object
    to store all the results returned from the processes—we will call this the result
    queue.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这里的目标是有一个`JoinableQueue`对象，其中包含所有要执行的任务，我们将其称为任务队列，并且有一些进程。只要任务队列中有项目（消息），进程就会轮流执行这些项目。我们还将有一个`Queue`对象来存储从进程返回的所有结果，我们将其称为结果队列。
- en: 'Navigate to the `Chapter06/example7.py` file and take a look at the `Consumer`
    class and the `Task` class, as shown in the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`Chapter06/example7.py`文件，并查看`Consumer`类和`Task`类，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `Consumer` class, which is an overridden subclass of the `multiprocessing.Process`
    class, is our processor logic, which takes in a task queue and a result queue.
    When started, each `Consumer` object will get the next item in its task queue,
    execute it, and finally call `task_done()` and put the returned result to its
    result queue. Each item in the task queue is in turn represented by the `Task`
    class, whose main functionality is to prime-check its `x `parameter. As one instance
    of the `Consumer` class interacts with one instance of the `Task` class, it will
    also print out a help message for us to easily keep track of which consumer is
    executing which task.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`Consumer`类是`multiprocessing.Process`类的一个重写子类，是我们的处理逻辑，它接受一个任务队列和一个结果队列。每个`Consumer`对象启动时，将获取其任务队列中的下一个项目，执行它，最后调用`task_done()`并将返回的结果放入其结果队列。任务队列中的每个项目依次由`Task`类表示，其主要功能是对其`x`参数进行素数检查。当`Consumer`类的一个实例与`Task`类的一个实例交互时，它还会打印出一个帮助消息，以便我们轻松跟踪哪个消费者正在执行哪个任务。'
- en: 'Let''s move on and consider our main program, as shown in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续考虑我们的主程序，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we said earlier, we create a task queue and a result queue in our main program.
    We also create a list of `Consumer` objects and start all of them; the number
    of processes created corresponds to the number of CPUs available in our system.
    Next, from a list of inputs that requires heavy computation from the `Task` class,
    we initialize a `Task` object with each input and put them all in the task queue.
    At this point our processes—our `Consumer` objects—will start executing these
    tasks.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说，我们在主程序中创建了一个任务队列和一个结果队列。我们还创建了一个`Consumer`对象的列表，并启动了它们所有；创建的进程数量与系统中可用的CPU数量相对应。接下来，从一个需要从`Task`类中进行大量计算的输入列表中，我们用每个输入初始化一个`Task`对象，并将它们全部放入任务队列。此时，我们的进程——我们的`Consumer`对象——将开始执行这些任务。
- en: 'Finally, at the end of our main program, we call `join()` on our task queue
    to ensure that all items have been executed and print out the result by looping
    through our result queue. After running the script, your output should be similar
    to the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的主程序的末尾，我们调用`join()`在我们的任务队列上，以确保所有项目都已执行，并通过循环遍历我们的结果队列打印出结果。运行脚本后，你的输出应该类似于以下内容：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Everything seems to be working, but if we look closely at the messages our processes
    have printed out, we will notice that most of the tasks were executed by either
    `Consumer-2` or `Consumer-3`, and that `Consumer-4` executed only one task while
    `Consumer-1` failed to execute any. What happened here?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一切似乎都在运行，但是如果我们仔细看一下我们的进程打印出来的消息，我们会注意到大多数任务是由`Consumer-2`或`Consumer-3`执行的，而`Consumer-4`只执行了一个任务，而`Consumer-1`则未执行任何任务。这里发生了什么？
- en: Essentially, when one of our consumers—let's say `Consumer-3`—finished executing
    a task, it tried to look for another task to execute immediately after. Most of
    the time, it would get priority over other consumers, since it was already being
    run by the main program. So while `Consumer-2` and `Consumer-3` were constantly
    finishing their tasks' executions and picking up other tasks to execute, `Consumer-4`
    was only able to "squeeze" itself in once, and `Consumer-1` failed to do this
    altogether.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当我们的一个消费者——比如`Consumer-3`——完成执行一个任务后，它会立即尝试寻找另一个任务来执行。大多数情况下，它会优先于其他消费者，因为它已经被主程序运行。因此，虽然`Consumer-2`和`Consumer-3`不断完成它们的任务执行并拾取其他任务来执行，`Consumer-4`只能“挤”自己进来一次，而`Consumer-1`则根本无法做到这一点。
- en: 'When running the script over and over again, you will notice a similar trend:
    only one or two consumers executed most of the tasks, while others failed to do
    this. This situation is undesirable for us, since the program is not utilizing
    all of the available processes that were created at the beginning of the program.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当一遍又一遍地运行脚本时，你会注意到一个类似的趋势：大多数任务只由一个或两个消费者执行，而其他消费者未能做到这一点。对我们来说，这种情况是不可取的，因为程序没有利用在程序开始时创建的所有可用进程。
- en: To address this issue, a technique has been developed, to stop consumers from
    immediately taking the next item from the task queue, called **poison pill**.
    The idea is that, after setting up the real tasks in the task queue, we also add
    in dummy tasks that contain "stop" values and that will have the current consumer
    hold and allow other consumers to get the next item in the task queue first; hence
    the name "poison pill."
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，已经开发了一种技术，用于阻止消费者立即从任务队列中取下下一个项目，称为**毒丸**。其想法是，在设置任务队列中的真实任务之后，我们还添加包含“停止”值的虚拟任务，并且当前消费者将保持并允许其他消费者先获取任务队列中的下一个项目；因此得名“毒丸”。
- en: 'To implement this technique, we need to add in our `tasks` value in the main
    program''s special objects, one per consumer. Additionally, in our `Consumer`
    class, the implementation of the logic to handle these special objects is also
    required. Let''s take a look at the `example8.py` file (a modified version of
    the previous example, containing the implementation of the poison pill technique),
    specifically in the `Consumer` class and the main program, as shown in the following
    code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一技术，我们需要在主程序的特殊对象中添加我们的`tasks`值，每个消费者一个。此外，在我们的`Consumer`类中，还需要实现处理这些特殊对象的逻辑。让我们看一下`example8.py`文件（前一个示例的修改版本，包含毒丸技术的实现），特别是`Consumer`类和主程序，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Task` class remains the same as our previous example. We can see that
    our poison pill is the `None` value: in the main program, we add in `None` values
    of a number equal to the number of consumers we have spawned to the task queue;
    in the `Consumer` class, if the current task to be executed holds the value `None`,
    then the class object will print out a message indicating the poison pill, call
    `task_done()`, and exit.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`类与我们之前的示例相同。我们可以看到我们的毒丸是`None`值：在主程序中，我们向任务队列中添加了与我们生成的消费者数量相等的`None`值；在`Consumer`类中，如果要执行的当前任务包含值`None`，那么该类对象将打印出指示毒丸的消息，调用`task_done()`并退出。'
- en: 'Run the script; your output should be similar to the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本；你的输出应该类似于以下内容：
- en: '[PRE16]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, as well as seeing the poison pill messages being printed out, the
    output also shows a significantly better distribution in terms of which consumer
    executed which task.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，除了看到毒丸消息被打印出来之外，输出还显示了在哪个消费者执行了哪个任务方面的显着改善分布。
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the field of computer science, a process is an instance of a specific computer
    program or software that is being executed by the operating system. A process
    contains both the program code and its current activities and interactions with
    other entities. More than one thread can be implemented within the same process
    to access and share memory or other resources, while different processes do not
    interact in this way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学领域，进程是操作系统正在执行的特定计算机程序或软件的实例。进程包含程序代码及其当前活动和与其他实体的交互。在同一个进程中可以实现多个线程来访问和共享内存或其他资源，而不同的进程不以这种方式进行交互。
- en: In the context of concurrency and parallelism, multiprocessing refers to the
    execution of multiple concurrent processes from an operating system, in which
    each process is executed on a separate CPU, as opposed to a single process being
    executed at any given time. The `multiprocessing` module in Python provides a
    powerful and flexible API to spawn and manage processes for a multiprocessing
    application. It also allows complex techniques for interprocess communication
    via the `Queue` class.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在并发和并行的背景下，多进程指的是从操作系统中执行多个并发进程，其中每个进程在单独的CPU上执行，而不是在任何给定时间执行单个进程。Python中的`multiprocessing`模块提供了一个强大而灵活的API，用于生成和管理多进程应用程序。它还允许通过`Queue`类进行复杂的进程间通信技术。
- en: In the next chapter, we will be discussing a more advanced function of Python—reduction
    operations—and how it is supported in multiprocessing programming.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论Python的更高级功能——归约操作——以及它在多进程编程中的支持。
- en: Questions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a process? What are the core differences between a process and a thread?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是进程？进程和线程之间的核心区别是什么？
- en: What is multiprocessing? What are the core differences between multiprocessing
    and multithreading?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是多进程？多进程和多线程之间的核心区别是什么？
- en: What are the API options provided by the `multiprocessing` module?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块提供了哪些API选项？'
- en: What are the core differences between the `Process` class and the `Pool` class
    from the `multiprocessing` module?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Process`类和`Pool`类在`multiprocessing`模块中的核心区别是什么？'
- en: What are the options to determine the current process in a Python program?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python程序中确定当前进程的选项有哪些？
- en: What are daemon processes? What are their purposes in terms of waiting for processes
    in a multiprocessing program?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在多进程程序中，守护进程是什么？它们在等待进程方面有什么目的？
- en: How do you terminate a process? Why is it sometimes acceptable to terminate
    processes?
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何终止一个进程？为什么有时终止进程是可以接受的？
- en: What is one of the ways to facilitate interprocess communication in Python?
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中促进进程间通信的一种方式是什么？
- en: Further reading
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: '*Python Parallel Programming Cookbook*, by Giancarlo Zaccone, Packt Publishing
    Ltd (2015).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python并行编程食谱*，作者Giancarlo Zaccone，Packt Publishing Ltd（2015年）。'
- en: '"Learning Concurrency in Python: Build highly efficient, robust, and concurrent
    applications", Elliot Forbes (2017).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “学习Python并发：构建高效、健壮和并发的应用程序”，Elliot Forbes（2017年）。
- en: Python Module of The Week. "Communication Between Processes" ([pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)).
    This contains functions that you can use to identify the current process.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python本周模块。“进程间通信”（[pymotw.com/2/multiprocessing/communication.html](https://pymotw.com/2/multiprocessing/communication.html)）。这包含了您可以用来识别当前进程的函数。
