- en: Part 3. Testing, Debugging, Deploying, and Maintaining
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分。测试、调试、部署和维护
- en: '*[The Logging and Warning Modules](ch14.html "Chapter 14. The Logging and Warning
    Modules")*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 日志和警告模块
- en: '*[Designing for Testability](ch15.html "Chapter 15. Designing for Testability")*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设计
- en: '*[Coping with the Command Line](ch16.html "Chapter 16. Coping With the Command
    Line")*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 应对命令行
- en: '*[Module and Package Design](ch17.html "Chapter 17. The Module and Package
    Design")*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和包设计
- en: '*[Quality and Documentation](ch18.html "Chapter 18. Quality and Documentation")*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 质量和文档
- en: Testing, Debugging, Deploying, and Maintaining
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试、调试、部署和维护
- en: 'Application development involves a number of skills beyond object-oriented
    designing and programming in Python. We''ll take a look at some additional topics
    that help us move from merely programming towards solving the user''s problems:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发涉及许多技能，超出了在Python中进行面向对象设计和编程。我们将看一些额外的主题，帮助我们从仅仅编程向解决用户问题迈进：
- en: '[Chapter 14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The
    Logging and Warning Modules*, will look at using the `logging` and `warnings`
    modules to create audit information as well as debugging. We''ll take a significant
    step beyond using the `print()` function. The `logging` module provides us with
    a number of features that allow us to produce audit, debug, and informational
    messages in a simple and uniform way. Because this is so highly configurable,
    we can provide useful debugging as well as verbose processing options.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第14章](ch14.html "第14章。日志和警告模块")*日志和警告模块*将介绍如何使用`logging`和`warnings`模块来创建审计信息以及调试。我们将迈出一个重要的步骤，超越使用`print()`函数。`logging`模块为我们提供了许多功能，使我们能够以简单和统一的方式生成审计、调试和信息消息。由于这是高度可配置的，我们可以提供有用的调试以及冗长的处理选项。'
- en: We'll look at designing for testability and how we use `unittest` and `doctest`
    in [Chapter 15](ch15.html "Chapter 15. Designing for Testability"), *Designing
    for Testability*. Automated testing should be considered absolutely essential.
    No programming should be considered complete until there are automated unit tests
    that provide ample evidence to show us that the code works.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将研究测试设计以及我们如何在[第15章](ch15.html "第15章。测试设计")*测试设计*中使用`unittest`和`doctest`。自动化测试应被视为绝对必要。在没有自动化单元测试提供充分证据表明代码有效之前，编程不应被视为完成。
- en: The command-line interface to our programs provides us with options and arguments.
    This applies mostly to small, text-oriented programs as well as long-running application
    servers. However, even a GUI application may use command-line options for configuration.
    [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping with
    the Command Line*, will look at using the `argparse` module to parse options and
    arguments. We'll take this a step further and use the **Command** design pattern
    to create program components that can be combined and expanded without resorting
    to writing shell scripts.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的程序的命令行界面为我们提供了选项和参数。这主要适用于小型、面向文本的程序以及长时间运行的应用程序服务器。然而，即使是GUI应用程序也可以使用命令行选项进行配置。[第16章](ch16.html
    "第16章。应对命令行")*应对命令行*将介绍如何使用`argparse`模块来解析选项和参数。我们将进一步采用**命令**设计模式来创建可以组合和扩展的程序组件，而无需编写shell脚本。
- en: In [Chapter 17](ch17.html "Chapter 17. The Module and Package Design"), *The
    Module and Package Design*, we'll look at the module and package design. This
    is a higher-level set of considerations than the class design topics we've been
    looking at so far. Module and class design repeat strategies of Wrap, Extend,
    or Invent. Rather than looking at related data and operations, we're looking at
    related classes in a module and related modules in a package.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第17章](ch17.html "第17章。模块和包设计")*模块和包设计*中，我们将研究模块和包设计。这是一个比我们迄今为止所看到的类设计主题更高级别的考虑。模块和类设计重复了Wrap、Extend或Invent的策略。我们不是在看相关数据和操作，而是在看模块中相关的类和包中相关的模块。
- en: In [Chapter 18](ch18.html "Chapter 18. Quality and Documentation"), *Quality
    and Documentation*, we'll look at how we can document our design to create the
    trust that our software is correct and is properly implemented.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第18章](ch18.html "第18章。质量和文档")*质量和文档*中，我们将看一下如何记录我们的设计，以建立我们的软件是正确的并且是正确实现的信任。
- en: This part emphasizes ways to improve the quality of our software using these
    additional modules. Unlike the topics of [Part 1](pt01.html "Part 1. Pythonic
    Classes via Special Methods"), *Pythonic Classes via Special Methods* and [Part
    2](pt02.html "Part 2. Persistence and Serialization"), *Persistence and Serialization*
    these tools and techniques aren't narrowly focused on solving a particular problem.
    These topics are more broadly applicable to mastering object-oriented Python.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分强调使用这些附加模块来提高软件质量的方法。与[第一部分](pt01.html "第一部分。通过特殊方法创建Pythonic类")中的*通过特殊方法创建Pythonic类*和[第二部分](pt02.html
    "第二部分。持久性和序列化")中的*持久性和序列化*不同，这些工具和技术并不狭隘地专注于解决特定问题。这些主题更广泛地适用于掌握面向对象的Python。
- en: Chapter 14. The Logging and Warning Modules
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。日志和警告模块
- en: There are some essential logging techniques that we can use both for debugging
    as well as operational support of an application. In particular, a good log can
    help demonstrate that an application meets its security and auditability requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些基本的日志技术，我们可以用于调试以及应用程序的操作支持。特别是，一个良好的日志可以帮助证明应用程序满足其安全性和可审计性要求。
- en: There are times when we'll have multiple logs with different kinds of information.
    We might separate security, audit, and debugging into separate logs. In some cases,
    we might want a unified log. We'll look at a few examples of doing this.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们会有多个具有不同类型信息的日志。我们可能会将安全、审计和调试分开成单独的日志。在某些情况下，我们可能需要一个统一的日志。我们将看一些做这件事的例子。
- en: Our users may want verbose output to confirm that the program works correctly.
    This is different from the debugging output; end users are examining how the program
    solves their problem. They might, for example, want to change their inputs or
    process your program's outputs differently. Setting the verbosity level produces
    a log focused on the needs of users.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户可能希望获得详细的输出，以确认程序的正确运行。这与调试输出不同；最终用户正在检查程序如何解决他们的问题。例如，他们可能希望更改他们的输入或以不同方式处理您程序的输出。设置详细程度会产生一个满足用户需求的日志。
- en: The `warnings` module can provide helpful information for developers as well
    as users. In the case of developers, we may use warnings to show you that an API
    has been deprecated. In the case of users, we might want to show you that the
    results are questionable but not—strictly speaking—erroneous. There might be questionable
    assumptions or possibly confusing default values that should be pointed out to
    users.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`warnings`模块可以为开发人员和用户提供有用的信息。对于开发人员，我们可以使用警告来告诉您某个API已被弃用。对于用户，我们可能想告诉您结果是有问题的，但严格来说并不是错误的。可能存在有问题的假设或可能令用户困惑的默认值，应该向用户指出。'
- en: 'Software maintainers will need to enable logging to perform useful debugging.
    We rarely want *blanket* debugging output: the resulting log might be unreadably
    dense. We often need focused debugging to track down a specific problem so that
    we can revise the unit test cases and fix the software.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 软件维护人员需要启用日志记录以进行有用的调试。我们很少希望*全面*调试输出：结果日志可能会难以阅读。我们经常需要有针对性的调试来追踪特定问题，以便我们可以修改单元测试用例并修复软件。
- en: In the case of trying to solve problems with a program that crashes, we might
    want to create a small circular queue to capture the last few events. We may be
    able to use this to isolate problems without having to filter through giant logfiles.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试解决程序崩溃问题时，我们可能希望创建一个小的循环队列来捕获最近的几个事件。我们可以使用这个来隔离问题，而不必筛选大型日志文件。
- en: Creating a basic log
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个基本日志
- en: 'There are two necessary steps to logging:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录有两个必要的步骤：
- en: Get a `logging.Logger` instance with the `logging.getLogger()` function.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`logging.getLogger()`函数获取一个`logging.Logger`实例。
- en: Create messages with that `Logger`. There are a number of methods with names
    such as `warn()`, `info()`, `debug()`, `error(),` and `fatal()` that create messages
    with different levels of importance.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用该`Logger`创建消息。有许多方法，如`warn()`、`info()`、`debug()`、`error()`和`fatal()`，可以创建具有不同重要性级别的消息。
- en: These two steps are not sufficient to give us any output, however. There's a
    third step that we take only when we need to see the output. Some logging is for
    debugging purposes, and seeing a log isn't always required. The optional step
    is to configure the `logging` module's handlers, filters, and formatters. We can
    use the `logging.basicConfig()` function for this.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两个步骤还不足以给我们任何输出。还有第三步，只有在需要查看输出时才会执行。有些日志记录是为了调试目的，不一定总是需要查看日志。可选的步骤是配置`logging`模块的处理程序、过滤器和格式化程序。我们可以使用`logging.basicConfig()`函数来实现这一点。
- en: It's technically possibly to even skip the first step. We can use the default
    logger that's part of the `logging` module's top-level functions. We showed you
    this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins – Cross-cutting
    Aspects"), *Decorators and Mixins – Cross-cutting Aspects*, because the focus
    was on decoration, not logging. We advise you against using the default root logger.
    We'll need a little background to see why it's good to avoid using the root logger.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以跳过第一步。我们可以使用`logging`模块顶层函数中的默认记录器。我们在[第8章](ch08.html "第8章。装饰器和混入-横切面")中展示了这一点，*装饰器和混入-横切面*，因为重点是装饰，而不是记录。我们建议您不要使用默认的根记录器。我们需要一些背景知识才能理解为什么最好避免使用根记录器。
- en: Instances of `Logger` are identified by name. The names are `.`-separated strings
    that form a hierarchy. There's a root logger with a name of `""`—the empty string.
    All other `Loggers` are children of this root `Logger`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logger`的实例由名称标识。这些名称是由`.`分隔的字符串，形成一个层次结构。有一个名称为`""`的根记录器-空字符串。所有其他`Loggers`都是这个根`Logger`的子记录器。'
- en: Because of this tree of named `Loggers`, we'll generally use the root `Logger`
    to configure the entire tree. We'll also use it when an appropriately named `Logger`
    can't be found. We'll only sow confusion if we also use the root `Logger` as the
    first class log for a particular module.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个命名为`Loggers`的树，我们通常使用根`Logger`来配置整个树。当找不到适当命名的`Logger`时，我们也会使用它。如果我们还使用根`Logger`作为特定模块的第一类日志，那么只会造成混乱。
- en: 'In addition to a name, `Logger` can be configured with a list of handlers that
    determines where the messages are written and a list of `Filters` to determine
    which kinds of messages are passed or rejected. A logger is the essential API
    for logging: we use a logger to create `LogRecords`. These records are then routed
    to `Filters` and `Handlers`, where the passed records are formatted and eventually
    wind up getting stored in a local file or transmitted over a network.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除了名称外，`Logger`还可以配置一个处理程序列表，确定消息写入的位置，以及一个`Filters`列表，确定传递或拒绝哪种类型的消息。记录器是记录日志的基本API：我们使用记录器来创建`LogRecords`。然后这些记录被路由到`Filters`和`Handlers`，通过的记录被格式化，最终被存储在本地文件或通过网络传输。
- en: 'The best practice is to have a distinct logger for each of our classes or modules.
    As `Logger` names are `.`-separated strings, the `Logger` names can parallel class
    or module names; our application''s hierarchy of component definitions will have
    a parallel hierarchy of loggers. We might have a class that starts like the following
    code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是为我们的每个类或模块创建一个独立的记录器。由于`Logger`名称是由`.`分隔的字符串，`Logger`名称可以与类或模块名称平行；我们应用程序的组件定义层次结构将有一个平行的记录器层次结构。我们可能有一个类似以下代码的类：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will ensure the `Logger` object used for this class will have a name that
    matches the qualified name of the class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保用于此类的`Logger`对象将具有与类的限定名称相匹配的名称。
- en: Creating a shared class-level logger
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个共享的类级别的记录器
- en: 'As we noted in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins – Cross-cutting
    Aspects"), *Decorators and Mixins – Cross-cutting Aspects*, creating a class-level
    logger is made slightly cleaner by defining a decorator that creates the logger
    outside the class definition itself. Here''s the decorator that we defined:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第8章](ch08.html "第8章。装饰器和混合 - 横切面方面")中指出的，*装饰器和混合 - 横切面方面*，通过定义一个在类定义本身之外创建记录器的装饰器，可以使创建类级别的记录器变得更加清晰。这是我们定义的装饰器：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This creates `logger` as a feature of the class, shared by all the instances.
    Now, we can define a class like the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建`logger`作为类的一个特性，由所有实例共享。现在，我们可以定义一个类，如以下代码：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will assure us that the class has the logger with the expected name. We
    can then use `self.logger` in the various methods with the confidence that it
    will be a valid instance of `logging.Logger`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向我们保证该类具有预期名称的记录器。然后，我们可以在各种方法中使用`self.logger`，并确信它将是`logging.Logger`的有效实例。
- en: When we create an instance of `Player`, we're going to exercise the logger.
    By default, we won't see anything. The initial configuration for the `logging`
    module doesn't include a handler or a level that produces any output. We'll need
    to change the `logging` configuration to see anything.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`Player`的实例时，我们将激活记录器。默认情况下，我们看不到任何东西。`logging`模块的初始配置不包括产生任何输出的处理程序或级别。我们需要更改`logging`配置才能看到任何内容。
- en: The most important benefit of the way the `logging` module works is that we
    can include logging features in our classes and modules without worrying about
    the overall configuration. The default behavior will be silent and introduce very
    little overhead. For this reason, we can always include logging features in every
    class that we define.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块工作的最重要的好处是，我们可以在我们的类和模块中包含日志记录功能，而不必担心整体配置。默认行为将是静默的，并且引入的开销非常小。因此，我们可以在我们定义的每个类中始终包含日志记录功能。'
- en: Configuring the loggers
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置记录器
- en: 'There are two configuration details that we need to provide to see the output
    in our logs:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供两个配置细节才能看到我们日志中的输出：
- en: The logger we're using needs to be associated with a handler that produces conspicuous
    output
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们正在使用的记录器需要与产生显着输出的处理程序相关联
- en: The handler needs a logging level that will pass our logging messages
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理程序需要一个将传递我们的日志消息的日志级别
- en: The `logging` package has a variety of configuration methods. We'll show you
    `logging.basicConfig()` here. We'll take a look at `logging.config.dictConfig()`
    separately.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`包有各种配置方法。我们将在这里展示`logging.basicConfig()`。我们将单独查看`logging.config.dictConfig()`。'
- en: 'The `logging.basicConfig()` method permits a few parameters to create a single
    `logging.handlers.StreamHandler` for logging the output. In many cases, this is
    all we need:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging.basicConfig()`方法允许使用一些参数创建一个单一的`logging.handlers.StreamHandler`来记录输出。在许多情况下，这就是我们所需要的：'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will configure a `StreamHandler` instance that will write to `sys.stderr`.
    It will pass messages that have a level that is greater than or equal to the given
    level. By using `logging.DEBUG`, we're assured of seeing all the messages. The
    default level is `logging.WARN`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置一个`StreamHandler`实例，它将写入`sys.stderr`。它将传递具有大于或等于给定级别的消息。通过使用`logging.DEBUG`，我们确保看到所有消息。默认级别是`logging.WARN`。
- en: 'After performing this configuration, we''ll see our debugging messages:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此配置后，我们将看到我们的调试消息：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The default format shows us the level (`DEBUG`), the name of the logger (`Player`),
    and the string that we produced. There are more attributes in `LogRecord` that
    can be shown. Often, this default format is acceptable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 默认格式显示了级别（`DEBUG`），记录器的名称（`Player`）和我们生成的字符串。`LogRecord`中还有更多的属性可以显示。通常，这种默认格式是可以接受的。
- en: Starting up and shutting down the logging system
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启动和关闭日志系统
- en: The `logging` module is defined in a way that avoids manually managing the global
    state information. The global state is handled within the `logging` module. We
    can write applications in separate parts and be well assured that those components
    will cooperate properly through the `logging` interface. We can, for example,
    include `logging` in some modules and omit it entirely from other modules without
    worrying about the compatibility or configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块以一种避免手动管理全局状态信息的方式定义。全局状态在`logging`模块内部处理。我们可以将应用程序写成单独的部分，并确信这些组件将通过`logging`接口正确合作。例如，我们可以在一些模块中包含`logging`，而在其他模块中完全省略它，而不必担心兼容性或配置。'
- en: Most importantly, we can include logging requests throughout an application
    and never configure any handlers. The top-level main script can omit `import logging`
    entirely. In this case, there will be no errors or problems from the logging code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们可以在整个应用程序中包含日志记录请求，而无需配置任何处理程序。顶层主脚本可以完全省略`import logging`。在这种情况下，日志记录代码不会出现任何错误或问题。
- en: Because of the decentralized nature of logging, it's easy to configure it just
    once at the top level of an application. We should only configure `logging` inside
    the `if __name__ == "__main__":` portion of an application. We'll look at this
    in more detail in [Chapter 16](ch16.html "Chapter 16. Coping With the Command
    Line"), *Coping with the Command Line*.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录的分散性质，很容易在应用程序的顶层仅配置一次。我们应该只在应用程序的`if __name__ == "__main__":`部分内部配置`logging`。我们将在[第16章](ch16.html
    "第16章。处理命令行")中更详细地讨论这个问题，*处理命令行*。
- en: Many of our logging handlers involve buffering. For the most part, the buffers
    will flush in the normal course of events. While we can ignore how logging shuts
    down, it's slightly more reliable to use `logging.shutdown()` to be sure that
    all the buffers are flushed to the devices.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的许多日志处理程序涉及缓冲。在大多数情况下，缓冲区将在正常事件过程中刷新。虽然我们可以忽略日志记录如何关闭，但使用`logging.shutdown()`稍微更可靠，以确保所有缓冲区都刷新到设备。
- en: 'When handling top-level errors and exceptions, we have two explicit techniques
    to ensure all buffers are written. One technique is to use a `finally` clause
    on a `try:` block:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 处理顶层错误和异常时，我们有两种明确的技术来确保所有缓冲区都被写入。一种技术是在`try:`块上使用`finally`子句：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This example shows us how we configure `logging` as early as possible and shut
    down `logging` as late as possible. This ensures as much of the application as
    possible is properly bracketed by properly configured loggers. This includes an
    exception logger; in some applications, the `main()` function handles all exceptions,
    making the except clause here redundant.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了如何尽早配置`logging`，并尽可能晚地关闭`logging`。这确保了尽可能多的应用程序被正确配置的记录器所包围。这包括一个异常记录器；在一些应用程序中，`main()`函数处理所有异常，使得这里的except子句多余。
- en: 'Another approach is to include an `atexit` handler to shut down `logging`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是包含一个`atexit`处理程序来关闭`logging`：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This version shows us how to use the `atexit` handler to invoke `logging.shutdown()`.
    When the application exits, the given function will be called. If the exceptions
    are properly handled inside the `main()` function, the `try:` block can be replaced
    with much simpler `status= main(); sys.exit(status)`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本向我们展示了如何使用`atexit`处理程序来调用`logging.shutdown()`。当应用程序退出时，给定的函数将被调用。如果异常在`main()`函数内得到了正确处理，`try:`块可以被更简单的`status=
    main(); sys.exit(status)`所替代。
- en: There's a third technique that uses a context manager to control logging. We'll
    look at that alternative in [Chapter 16](ch16.html "Chapter 16. Coping With the
    Command Line"), *Coping with the Command Line*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种技术，使用上下文管理器来控制日志记录。我们将在[第16章](ch16.html "第16章。处理命令行")中看到这种替代方法，*处理命令行*。
- en: Naming the loggers
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名记录器
- en: 'There are four common use cases for using `logging.getLogger()` to name our
    `Loggers`. We often pick names to parallel our application''s architecture:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`logging.getLogger()`为我们的`Loggers`命名有四种常见用例。我们经常选择与我们应用程序架构相对应的名称：
- en: '**Module names**: We might have a module global `Logger` instance for modules
    that contain a large number of small functions or classes for which a large number
    of objects are created. When we extend `tuple`, for example, we don''t want a
    reference to `Logger` in each instance. We''ll often do this globally, and usually
    this logger creation is kept close to the front of the module. In this example,
    right after the imports:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模块名称**：对于包含大量小函数或创建大量对象的类的模块，我们可能会有一个模块全局的`Logger`实例。例如，当我们扩展`tuple`时，我们不希望每个实例中都有对`Logger`的引用。我们经常会在全局范围内这样做，通常这个记录器的创建会保持在模块的前面。在这个例子中，就在导入之后：'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Object instances**: This is shown previously, when we created `Logger` in
    the `__init__()` method. This `Logger` will be unique to the instance; using only
    a qualified class name might be misleading, because there will be multiple instances
    of the class. A better design is to include a unique instance identifier in the
    logger''s name:'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象实例**：这是之前显示的，当我们在`__init__()`方法中创建`Logger`时。这个`Logger`将是实例唯一的；仅使用合格的类名可能会产生误导，因为类的实例会有多个。更好的设计是在记录器的名称中包含一个唯一的实例标识符：'
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**Class names**: This is shown previously, when we defined a simple decorator.
    We can use `__class__.__qualname__` as the `Logger` name and assign `Logger` to
    the class as a whole. It will be shared by all instances of the class.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类名称**：这是之前显示的，当我们定义一个简单的装饰器时。我们可以使用`__class__.__qualname__`作为`Logger`的名称，并将`Logger`分配给整个类。它将被类的所有实例共享。'
- en: '**Function names**: For small functions that are used frequently, we''ll often
    use a module-level log, shown previously. For larger functions that are rarely
    used, we might create a log within the function:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数名称**：对于经常使用的小函数，我们经常会使用模块级别的日志，如前面所示。对于很少使用的大型函数，我们可能会在函数内部创建一个日志：'
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The idea here is to be sure that our `Logger` names match our software architecture.
    This provides us with the most transparent logging, simplifying debugging.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是确保我们的`Logger`名称与软件架构匹配。这为我们提供了最透明的日志记录，简化了调试。
- en: 'In some cases, however, we might have a more complex collection of `Loggers`.
    We might have several distinct types of informational messages from a class. Two
    common examples are financial audit logs and security access logs. We might want
    several parallel hierarchies of `Loggers`: one with names that start with `audit.`
    and another with names that start with `security.`. A class might have the more
    specialized `Loggers` with names such as `audit.module.Class` or `security.module.Class`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，我们可能会有一个更复杂的`Loggers`集合。我们可能有来自一个类的几种不同类型的信息消息。两个常见的例子是财务审计日志和安全访问日志。我们可能希望有几个并行的`Loggers`层次结构：一个以`audit.`开头的名称，另一个以`security.`开头的名称。一个类可能有更专业的`Loggers`，名称如`audit.module.Class`或`security.module.Class`：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Having multiple logger objects available in a class allows us to finely control
    the kinds of output. We can configure each `Logger` to have different `handlers`.
    We'll use the more advanced configurations in the following section to direct
    the output to different destinations.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中有多个日志记录器对象可用，这使我们能够精细地控制输出的类型。我们可以配置每个`Logger`具有不同的`handlers`。我们将在下一节中使用更高级的配置来将输出定向到不同的目的地。
- en: Extending the logger levels
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展日志记录级别
- en: The `logging` module has five predefined levels of importance. Each level has
    a global variable (or two) with the level number. The level of importance represents
    a spectrum of optionality from debugging messages (rarely important enough to
    show) to critical or fatal errors (always important).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块有五个预定义的重要级别。每个级别都有一个全局变量（或两个）与级别数字对应。重要性级别代表了从调试消息（很少重要到足够显示）到关键或致命错误（总是重要）的可选性范围。'
- en: '| Logging module variable | Value |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Logging模块变量 | 值 |'
- en: '| --- | --- |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `DEBUG` | `10` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `DEBUG` | `10` |'
- en: '| `INFO` | `20` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `INFO` | `20` |'
- en: '| `WARNING or WARN` | `30` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `WARNING or WARN` | `30` |'
- en: '| `ERROR` | `40` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `ERROR` | `40` |'
- en: '| `CRITICAL or FATAL` | `50` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `CRITICAL or FATAL` | `50` |'
- en: We can add additional levels for even more nuanced control over what messages
    are passed or rejected. For example, some applications support multiple levels
    of verbosity. Similarly, some applications include multiple levels of debugging
    details.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加额外的级别，以更精细地控制传递或拒绝哪些消息。例如，一些应用程序支持多个详细级别。同样，一些应用程序包括多个调试详细级别。
- en: For ordinary silent output, we might set the logging level to `logging.WARNING`
    so that only warnings and errors are shown. For the first level of verbosity,
    we can set the level of `logging.INFO` to see informational messages. For the
    second level of verbosity, we might want to add a level with a value of 15 and
    set the root logger to include this new level.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于普通的静默输出，我们可以将日志级别设置为`logging.WARNING`，这样只会显示警告和错误。对于第一个冗长级别，我们可以将日志级别设置为`logging.INFO`以查看信息消息。对于第二个冗长级别，我们可能希望添加一个值为15的级别，并将根记录器设置为包括这个新级别。
- en: 'We can use this to define our new level of verbose messages:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个来定义我们的新的冗长消息级别：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can use our new levels via the `Logger.log( )` method, which takes the level
    number as an argument:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`Logger.log()`方法使用我们的新级别，该方法将级别编号作为参数：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: While there's little overhead to add levels such as this, they can be overused.
    The subtlety is that a level conflates multiple concepts—visibility and erroneous
    behavior—into a single numeric code. The levels should be confined to a simple
    visibility or error spectrum. Anything more complex must be done via the `Logger`
    names or the actual `Filter` objects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然添加这样的级别几乎没有额外开销，但它们可能会被滥用。微妙之处在于级别将多个概念——可见性和错误行为——合并为一个单一的数字代码。级别应该局限于简单的可见性或错误范围。任何更复杂的操作必须通过`Logger`名称或实际的`Filter`对象来完成。
- en: Defining handlers for multiple destinations
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为多个目的地定义处理程序
- en: 'We have several use cases to send the log output to multiple destinations,
    which are shown in the following bullet list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种用例可以将日志输出发送到多个目的地，这些用例显示在以下项目列表中：
- en: We might want duplicate logs to improve the reliability of operations.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能希望复制日志以提高操作的可靠性。
- en: We might be using the sophisticated `Filter` objects to create distinct subsets
    of messages.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会使用复杂的`Filter`对象来创建不同的消息子集。
- en: We might have different levels for each destination. We can use this to separate
    debugging messages from informational messages.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会为每个目的地定义不同的级别。我们可以使用这个来将调试消息与信息消息分开。
- en: We might have different handlers based on the `Logger` names to represent different
    foci.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能会根据`Logger`名称使用不同的处理程序来表示不同的焦点。
- en: Of course, we can also combine these to create quite complex scenarios. In order
    to create multiple destinations, we must create multiple `Handlers`. Each `Handler`
    might contain a customized `Formatter`; it can contain an optional level, and
    an optional list of filters that can be applied.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以将它们组合起来创建相当复杂的场景。为了创建多个目的地，我们必须创建多个`Handlers`。每个`Handler`可能包含一个定制的`Formatter`；它可以包含一个可选级别和一个可选的过滤器列表，可以应用。
- en: Once we have multiple `Handlers`, we can bind `Loggers` to the desired `Handlers`.
    The `Loggers` form a proper hierarchy; this means we can bind `Loggers` to `Handlers`
    using high-level or low-level names. As `Handlers` have a level filter, we can
    have multiple handlers that will show us different groups of messages based on
    the level. Also, we can explicitly use the `Filter` objects if we need even more
    sophisticated filtering.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了多个`Handlers`，我们就可以将`Loggers`绑定到所需的`Handlers`。`Loggers`形成一个适当的层次结构；这意味着我们可以使用高级或低级名称将`Loggers`绑定到`Handlers`。由于`Handlers`具有级别过滤器，我们可以有多个处理程序，根据级别显示不同组的消息。此外，如果需要更复杂的过滤，我们还可以明确使用`Filter`对象。
- en: While we can configure this through the `logging` module API, it's often more
    clear to define most of the logging details in a configuration file. One elegant
    way to handle this is to use the YAML notation for a configuration dictionary.
    We can then load the dictionary with a relatively straightforward use of `logging.config.dictConfig(yaml.load(somefile))`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以通过`logging`模块API进行配置，但通常更清晰的做法是在配置文件中定义大部分日志记录细节。处理这个问题的一种优雅方式是使用配置字典的YAML表示法。然后，我们可以使用相对简单的`logging.config.dictConfig(yaml.load(somefile))`来加载字典。
- en: The YAML notation is somewhat more compact than the notation accepted by `configparser`.
    The documentation for `logging.config` in *Python Standard Library* uses YAML
    examples because of their clarity. We'll follow this pattern.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: YAML表示法比`configparser`接受的表示法更紧凑。*Python标准库*中的`logging.config`文档使用YAML示例，因为它们更清晰。我们将遵循这种模式。
- en: 'Here''s an example of a configuration file with two handlers and two families
    of loggers:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个配置文件示例，其中包含两个处理程序和两个日志记录器系列：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We defined two handlers: `console` and `audit_file`. The `console` is `StreamHandler`
    that is sent to `sys.stderr`. Note that we have to use a URI-style syntax of `ext://sys.stderr`
    to name an *external* Python resource. In this context, external means external
    to the configuration file. The default assumption is that the value is a simple
    string, not a reference to an object. The `audit_file` is `FileHandler` that will
    write to a given file. By default, files are opened with a mode of `a` to append.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个处理程序：`console`和`audit_file`。`console`是一个`StreamHandler`，它被发送到`sys.stderr`。请注意，我们必须使用`ext://sys.stderr`的URI样式语法来命名*外部*Python资源。在这种情况下，外部意味着配置文件之外的外部。默认假设是值是一个简单的字符串，而不是对对象的引用。`audit_file`是一个`FileHandler`，将写入给定的文件。默认情况下，文件以`a`模式打开以进行追加。
- en: We also defined the formatter, named `basic`, to produce the log format that
    we get from `basicConfig()`. If we don't use this, our messages will use a slightly
    different default format that only has the message text.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了格式化程序，名为`basic`，以生成我们从`basicConfig()`中获得的日志格式。如果我们不使用这个，我们的消息将使用略有不同的默认格式，只包含消息文本。
- en: 'Finally, we defined two top-level loggers: `verbose` and `audit`. The `verbose`
    instance will be used by all the loggers that have a top-level name of `verbose`.
    We can then use a `Logger` name such as `verbose.example.SomeClass` to create
    an instance that is a child of `verbose`. Each logger has a list of handlers;
    in this case, there''s just one element in each list. Additionally, we''ve specified
    the logging level for each logger.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了两个顶级记录器：`verbose`和`audit`。`verbose`实例将被所有具有`verbose`顶级名称的记录器使用。然后，我们可以使用`verbose.example.SomeClass`这样的`Logger`名称来创建一个是`verbose`子级的实例。每个记录器都有一个处理程序列表；在这种情况下，每个列表中只有一个元素。此外，我们还为每个记录器指定了日志级别。
- en: 'Here''s how we can load this configuration file:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何加载这个配置文件的方法：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We parsed the YAML text into `dict` and then used the `dictConfig()` function
    to configure the logging with the given dictionary. Here are some examples of
    getting loggers and writing messages:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将YAML文本解析为`dict`，然后使用`dictConfig()`函数使用给定的字典配置日志记录。以下是获取记录器和编写消息的一些示例：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We created two `Logger` objects, one under the `verbose` family tree and the
    other under the `audit` family tree. When we write to the `verbose` logger, we'll
    see the output on the console. When we write to the `audit` logger, however, we'll
    see nothing on the console; the record will go to the file that is named in the
    configuration.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个`Logger`对象，一个在`verbose`家族树下，另一个在`audit`家族树下。当我们写入`verbose`日志记录时，我们将在控制台上看到输出。然而，当我们写入`audit`日志记录时，我们在控制台上将看不到任何内容；记录将会被发送到配置中命名的文件中。
- en: When we look at the `logging.handlers` module, we see a large number of handlers
    that we can leverage. By default, the `logging` module uses older-looking `%`
    style formatting specifications. These are not like the format specifications
    for the `str.format()` method. When we defined our formatter parameters, we used
    the `{` style formatting, which is consistent with `str.format()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`logging.handlers`模块时，我们会看到许多处理程序可以利用。默认情况下，`logging`模块使用旧式的`%`样式格式规范。这些与`str.format()`方法的格式规范不同。当我们定义格式化参数时，我们使用了`{`样式格式化，这与`str.format()`一致。
- en: Managing the propagation rules
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理传播规则
- en: The default behavior for `Loggers` is for a logging record to propagate from
    the named `Logger` up through all parent-level `Loggers` to the root `Logger`.
    We may have lower-level `Loggers` that have special behaviors and a root `Logger`
    that defines the default behavior for all `Loggers`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Loggers`的默认行为是使日志记录从命名的`Logger`通过所有父级`Loggers`传播到根`Logger`。我们可能有具有特殊行为的低级别`Loggers`和定义所有`Loggers`的默认行为的根`Logger`。'
- en: 'Because logging records propagate, a root-level logger will *also* handle any
    log records from the lower-level `Loggers` that we define. If child loggers produce
    output and allow propagation, this will lead to duplicated output: first from
    the child and then from the parent. If we want to avoid duplication when child
    loggers produce output, we must turn the propagation off for the lower-level logger.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于日志记录会传播，根级别记录器还将处理我们定义的低级别`Loggers`的任何日志记录。如果子记录器产生输出并允许传播，这将导致重复的输出：首先是子记录器，然后是父记录器。如果我们希望在子记录器产生输出时避免重复，我们必须关闭低级别记录器的传播。
- en: Our previous example does not configure a root-level `Logger`. If some part
    of our application creates the logger with a name that doesn't start with `audit.`
    or `verbose.`, then that additional logger won't be associated with `Handler`.
    Either we need more top-level names or we need to configure a catch-all, root-level
    logger.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前的示例没有配置根级别`Logger`。如果我们应用程序的某个部分创建了名称不以`audit.`或`verbose.`开头的记录器，则该附加记录器将不会与`Handler`关联。要么我们需要更多的顶级名称，要么我们需要配置一个捕获所有的根级别记录器。
- en: 'If we add a root-level logger to capture all these other names, then we have
    to be careful about the propagation rules. Here''s a modification to the configuration
    file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加一个根级别记录器来捕获所有这些其他名称，那么我们必须小心传播规则。以下是对配置文件的修改：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We turned the propagation off for the two lower-level loggers: `verbose` and
    `audit`. We added a new root-level logger. As this logger has no name, this is
    done as a separate top-level dictionary named `root:` in parallel with the `loggers:`
    entry.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们关闭了两个低级别日志记录器`verbose`和`audit`的传播。我们添加了一个新的根级别日志记录器。由于此记录器没有名称，因此这是作为一个单独的顶级字典`root:`与`loggers:`条目并列完成的。
- en: If we didn't turn the propagation off in the two lower-level loggers, each `verbose`
    or `audit` record would have been handled twice. In the case of an audit log,
    the double handling may actually be desirable. The audit data would go to the
    console as well as the audit file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有关闭两个低级别记录器的传播，每个`verbose`或`audit`记录都会被处理两次。在审计日志的情况下，双重处理实际上可能是可取的。审计数据将会同时发送到控制台和审计文件。
- en: What's important about the `logging` module is that we don't have to make any
    application changes to refine and control the logging. We can do almost anything
    required through the configuration file. As YAML is a relatively elegant notation,
    we can encode a lot of capability very simply.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块的重要之处在于，我们不必对应用程序进行任何更改来完善和控制日志记录。我们几乎可以通过配置文件实现所需的任何操作。由于YAML是一种相对优雅的表示法，我们可以非常简单地编码许多功能。'
- en: Configuration gotcha
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置陷阱
- en: The `basicConfig()` method of logging is careful about preserving any loggers
    created before the configuration is made. The `logging.config.dictConfig()` method,
    however, has the default behavior of disabling any loggers created prior to configuration.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 日志的`basicConfig()`方法会小心地保留在配置之前创建的任何记录器。然而，`logging.config.dictConfig()`方法的默认行为是禁用在配置之前创建的任何记录器。
- en: When assembling a large and complex application, we may have module-level loggers
    that are created during the `import` process. The modules imported by the main
    script can potentially create loggers before `logging.config` is created. Also,
    any global objects or class definitions might have loggers created prior to the
    configuration.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在组装一个大型复杂的应用程序时，我们可能会在`import`过程中创建模块级别的记录器。主脚本导入的模块可能在创建`logging.config`之前创建记录器。此外，任何全局对象或类定义可能在配置之前创建记录器。
- en: 'We often have to add a line such as this to our configuration file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常不得不在我们的配置文件中添加这样一行：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will ensure all the loggers created prior to the configuration will still
    propagate to the root logger created by the configuration.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在配置之前创建的所有记录器仍然传播到配置创建的根记录器。
- en: Specializing logging for control, debug, audit, and security
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 专门为控制、调试、审计和安全而记录日志
- en: 'There are many kinds of logging; we''ll focus on these four varieties:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多种类的日志记录；我们将专注于这四种：
- en: '**Errors and Control**: Basic error and control of an application leads to
    a main log that helps users confirm that the program really is doing what it''s
    supposed to do. This would include enough error information with which the users
    can correct their problems and rerun the application. If a user enables verbose
    logging, it will amplify this main error and control the log with additional user-friendly
    details.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误和控制**：应用程序的基本错误和控制会导致一个主要的日志，帮助用户确认程序确实在做它应该做的事情。这将包括足够的错误信息，用户可以根据这些信息纠正问题并重新运行应用程序。如果用户启用了详细日志记录，它将通过附加用户友好的细节放大这个主要的错误和控制日志。'
- en: '**Debugging**: This is used by developers and maintainers; it can include rather
    complex implementation details. We''ll rarely want to enable *blanket* debugging,
    but will often enable debugging for specific modules or classes.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试**：这是由开发人员和维护人员使用的；它可能包括相当复杂的实现细节。我们很少希望启用*全面*的调试，但通常会为特定模块或类启用调试。'
- en: '**Audit**: This is a formal confirmation that tracks the transformations applied
    to data so we can be sure that processing was done correctly.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**审计**：这是一个正式的确认，跟踪应用于数据的转换，以便我们可以确保处理是正确的。'
- en: '**Security**: This can be used to show us who has been authenticated; it can
    help confirm that the authorization rules are being followed. It can also be used
    to detect some kinds of attacks that involve repeated password failures.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：这可以用来显示谁已经经过身份验证；它可以帮助确认授权规则是否被遵循。它还可以用于检测涉及重复密码失败的某些攻击。'
- en: 'We often have different formatting and handling requirements for each of these
    kinds of logs. Also, some of these are enabled and disabled dynamically. The main
    error and control log is often built from the non-DEBUG messages. We might have
    an application with a structure like the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常对这些种类的日志有不同的格式和处理要求。此外，其中一些是动态启用和禁用的。主要的错误和控制日志通常是由非DEBUG消息构建的。我们可能有一个结构如下代码的应用程序：
- en: '[PRE18]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We created a logger with a name that matches the class qualified name (`Main`).
    We've written informational messages to this logger to show you that our application
    started normally and finished normally. In this case, we used `Counter` to accumulate
    some balance information that can be used to confirm that the right amount of
    data was processed.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个与类的限定名称（`Main`）匹配的记录器。我们已经向这个记录器写入了信息消息，以向您展示我们的应用程序正常启动和正常完成。在这种情况下，我们使用`Counter`来累积一些可以用来确认处理了正确数据量的余额信息。
- en: 'In some cases, we''ll have more formal balance information displayed at the
    end of the processing. We might do something like this to provide a slightly easier-to-read
    display:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会在处理结束时显示更正式的余额信息。我们可能会这样做，以提供一个稍微易于阅读的显示：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This version will show us the keys and values on separate lines in the log.
    The errors and control log often uses the simplest formats; it might show us just
    the message text with little or no additional context. A logging `Formatter` object
    like this might be used:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本将在日志中将键和值显示在单独的行上。错误和控制日志通常使用最简单的格式；它可能只显示消息文本，几乎没有额外的上下文。可以使用这样的记录`Formatter`对象：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This configures `formatter` to show us the level name (`INFO`, `WARNING`, `ERROR`,
    `CRITICAL`) along with the message text. This eliminates a number of details,
    providing just the essential facts for the benefit of the users. We've called
    the formatter `control`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将配置`格式化程序`以显示级别名称（`INFO`、`WARNING`、`ERROR`、`CRITICAL`）以及消息文本。这消除了许多细节，只提供了用户所需的基本事实。我们称这个格式化程序为`控制`。
- en: 'In the following code, we have associated the control formatter with the console
    handler:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们已将控制格式化程序与控制处理程序关联起来：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will use `control` `formatter` with the `console` `handler`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`控制` `格式化程序`与`控制` `处理程序`。
- en: Creating a debugging log
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建调试日志
- en: A debugging log is usually enabled by a developer to monitor a program under
    development. It's often narrowly focused on specific features, modules, or classes.
    Consequently, we'll often enable and disable loggers by name. A configuration
    file might set the level of a few loggers to `DEBUG`, leaving others at `INFO,`
    or possibly even a `WARNING` level.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 调试日志通常由开发人员启用，用于监视正在开发的程序。它通常专注于特定的功能、模块或类。因此，我们通常会通过名称启用和禁用记录器。配置文件可能将一些记录器的级别设置为`DEBUG`，将其他记录器设置为`INFO`，或者甚至是`WARNING`级别。
- en: 'We''ll often design debugging information into our classes. Indeed, we might
    use the debugging ability as a specific quality feature for a class design. This
    may mean introducing a rich set of logging requests. For example, we might have
    a complex calculation for which the class state is essential information:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会在我们的类中设计调试信息。事实上，我们可能会将调试能力作为类设计的一个特定质量特征。这可能意味着引入一系列丰富的记录请求。例如，我们可能有一个复杂的计算，其中类状态是必要的信息：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this class definition, we created a `_state()` method that exposes the relevant
    internal state. This method is only used to support debugging. We've avoided using
    `self.__dict__` because this often has too much information to be helpful. We
    can then audit the changes to this state information in several places in our
    method functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类定义中，我们创建了一个“_state()”方法，它公开了相关的内部状态。这个方法只用于支持调试。我们避免使用“self.__dict__”，因为这通常包含的信息太多，不够有帮助。然后我们可以在方法函数中的几个地方审计对这个状态信息的更改。
- en: 'Debugging output is often selectively enabled by editing the configuration
    file to enable and disable debugging in certain places. We might make a change
    such as this to the logging configuration file:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 调试输出通常是通过编辑配置文件来选择性地启用的，以在某些地方启用和禁用调试。我们可能会对日志配置文件进行如下更改：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We identified the logger for a particular class based on the qualified name
    for the class. This example assumes there's a handler named `console` already
    defined. Also, we've turned off the propagation to prevent the debugging messages
    from being duplicated into the root logger.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据类的限定名称确定了特定类的记录器。这个例子假设已经定义了一个名为“console”的处理程序。此外，我们关闭了传播，以防止调试消息被复制到根记录器中。
- en: Implicit in this design is the idea that debugging is not something we want
    to simply enable from the command line via a simplistic `-D` option or a `--DEBUG`
    option. To perform effective debugging, we'll often want to enable selected loggers
    via a configuration file. We'll look at command-line issues in [Chapter 16,](ch16.html
    "Chapter 16. Coping With the Command Line") *Coping with the Command Line*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设计中隐含的是，调试不是我们希望仅通过简单的“-D”选项或“--DEBUG”选项从命令行启用的东西。为了进行有效的调试，我们经常希望通过配置文件启用选定的记录器。我们将在[第16章](ch16.html
    "第16章。处理命令行") *处理命令行*中讨论命令行问题。
- en: Creating audit and security logs
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建审计和安全日志
- en: 'Audit and security logs are often duplicated between two handlers: the main
    control handler plus a file handler that is used for audit and security reviews.
    This means we''ll do the following things:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 审计和安全日志经常在两个处理程序之间重复：主控制处理程序加上一个用于审计和安全审查的文件处理程序。这意味着我们将做以下事情：
- en: Define additional loggers for the audit and security
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为审计和安全定义额外的记录器
- en: Define multiple handlers for these loggers
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为这些记录器定义多个处理程序
- en: Optionally, define additional formats for the audit handler
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，为审计处理程序定义额外的格式
- en: As shown previously, we'll often create separate hierarchies of the `audit`
    or `security` logs. Creating separate hierarchies of loggers is considerably simpler
    than trying to introduce audit or security via a new logging level. Adding new
    levels is challenging because the messages are essentially `INFO` messages; they
    don't belong on the `WARNING` side of `INFO` because they're not errors, nor do
    they belong on the `DEBUG` side of `INFO` because they're not optional.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所示，我们经常会创建“审计”或“安全”日志的单独层次结构。创建单独的记录器层次结构比尝试通过新的日志级别引入审计或安全要简单得多。添加新级别是具有挑战性的，因为这些消息本质上是“INFO”消息；它们不属于“INFO”一侧的“WARNING”，因为它们不是错误，也不属于“INFO”一侧的“DEBUG”，因为它们不是可选的。
- en: 'Here''s a decorator that can be used to build a class that includes auditing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个装饰器，可以用来构建包括审计的类：
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This creates two loggers. One logger has a name simply based on the qualified
    name of the class. The other logger uses the qualified name, but with a prefix
    that puts it in the `audit` hierarchy. Here''s how we can use this decorator:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了两个记录器。一个记录器的名称仅基于类的限定名称。另一个记录器使用限定名称，但带有一个前缀，将其放在“审计”层次结构中。以下是我们如何使用这个装饰器：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We created a class that will produce records on a logger in the `audit` hierarchy.
    We can configure logging to handle this additional hierarchy of loggers. We''ll
    look at the two handlers that we need:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个类，它将在“审计”层次结构中的记录器上生成记录。我们可以配置日志记录以处理这些额外的记录器层次结构。我们将看看我们需要的两个处理程序：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `console` handler has the user-oriented log entries that use the `basic`
    format. The `audit_file` handler uses a more complex formatter named `detailed`.
    Here are the two `formatters` referenced by these `handlers`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: “console”处理程序具有使用“basic”格式的面向用户的日志条目。 “audit_file”处理程序使用名为“详细”的更复杂的格式化程序。以下是这些“处理程序”引用的两个“格式化程序”：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `basic` format shows us just three attributes of the message. The `detailed`
    format rules are somewhat complex because the date formatting is done separate
    from the rest of the message formatting. The `datetime` module uses the `%` style
    formatting. We used the `{` style formatting for the overall message. Here are
    the two `Logger` definitions:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: “basic”格式只显示消息的三个属性。 “详细”格式规则有些复杂，因为日期格式化是单独完成的。 “datetime”模块使用“%”样式格式化。我们使用“{”样式格式化整体消息。以下是两个“Logger”定义：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We defined a logger for the `audit` hierarchy. All the children of `audit` will
    write their messages to both `console Handler` as well as `audit_file Handler`.
    The root logger will define all the other loggers to use the console only. We'll
    now see two forms of the audit messages.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为“审计”层次结构定义了一个记录器。所有“审计”的子记录器都会将它们的消息写入“console Handler”和“audit_file Handler”。根记录器将定义所有其他记录器仅使用控制台。现在我们将看到审计消息的两种形式。
- en: 'The console might contain lines like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台可能包含这样的行：
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The audit file might look like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 审计文件可能如下所示：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This duplication provides us with the audit information in the context of the
    main console log, plus a focused audit trail in a separate log that can be saved
    for later analysis.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重复使我们能够在主控制台日志的上下文中获得审计信息，以及在单独的日志中获得专注的审计跟踪，可以保存以供以后分析。
- en: Using the warnings module
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用警告模块
- en: 'Object-oriented development often involves performing a significant refactoring
    of a class or module. It''s difficult to get the API exactly right the very first
    time we write an application. Indeed, the design time required to get the API
    exactly right might get wasted: Python''s flexibility permits us great latitude
    in making changes as we learn more about the problem domain and the user''s requirements.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的开发通常涉及对类或模块进行重大重构。第一次编写应用程序时，很难完全正确地获得API。事实上，为了完全正确地获得API所需的设计时间可能会被浪费：Python的灵活性允许我们在更多了解问题领域和用户需求时进行更改。
- en: 'One of the tools that we can use to support the design evolution is the `warnings`
    module. There are two clear use cases for `warnings` and one fuzzy use case:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 支持设计演变的工具之一是`warnings`模块。`warnings`有两个明确的用例和一个模糊的用例：
- en: To alert developers of the API changes, usually features that are deprecated
    or pending deprecation. The deprecation and pending deprecation warnings are silent
    by default. These messages are not silent when running the `unittest` module;
    this helps us ensure that we're making proper use of upgraded library packages.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警告开发人员API更改，通常是弃用或即将弃用的功能。弃用和即将弃用的警告默认是静默的。运行`unittest`模块时，这些消息不会静默；这有助于我们确保我们正确使用了升级的库包。
- en: 'To alert the users about a configuration problem. For example, there might
    be several alternative implementations of a module: when the preferred implementation
    is not available, we might want to provide a warning that an optimal implementation
    is not being used.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提醒用户配置问题。例如，可能有几种模块的替代实现：当首选实现不可用时，我们可能希望提供警告，表明未使用最佳实现。
- en: We might push the edge of the envelope by alerting users that the results of
    the computation may have other problems. There's a blurry spectrum of ways in
    which our applications can behave.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能通过警告用户计算结果可能存在其他问题来推动应用的边界。我们的应用程序可能以多种方式表现出来。
- en: For the first two use cases, we'll often use Python's `warnings` module to show
    you that there are correctable problems. For the third blurry use case, we might
    use the `logger.warn()` method to alert the user about the potential issues. We
    shouldn't rely on the `warnings` module for this, because the default behavior
    is to show a warning just once.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前两种用例，我们通常会使用Python的`warnings`模块来向您显示可纠正的问题。对于第三种模糊的用例，我们可能会使用`logger.warn()`方法来警告用户可能存在的问题。我们不应该依赖`warnings`模块，因为默认行为是只显示一次警告。
- en: 'We may see any of the following behaviors in an application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能在应用程序中看到以下任何行为：
- en: Ideally, our application finishes normally and everything works. The results
    are unambiguously valid.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理想情况下，我们的应用程序正常完成并且一切正常。结果是明确有效的。
- en: An application produces warning messages but finishes normally; the warning
    messages mean that the results are not trustworthy. Any output files will be readable,
    but the quality or completeness may be questionable. This is potentially confusing
    to the users; we'll wander around in the morass of these specific kinds of ambiguities
    showing possible software problems with a warning section, in the following section.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序产生警告消息，但正常完成；警告消息意味着结果不可信。任何输出文件都将可读，但质量或完整性可能有问题。这可能会让用户感到困惑；我们将在下一节中漫游在这些特定模糊性的泥沼中，显示可能的软件问题与警告部分。
- en: An application may produce error messages but still come to an orderly conclusion.
    It is clear that the results are unambiguously erroneous and shouldn't be used
    for anything other than debugging. The `logging` module allows us to further subdivide
    this world of errors. A program that produces an error may still come to an orderly
    conclusion. We often use the `CRITICAL` (or `FATAL`) error message to indicate
    that the Python program may not have terminated properly and any output files
    are probably damaged. We often reserve the `CRITICAL` message for a top-level
    `try:` block.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可能产生错误消息，但仍然得出有序的结论。很明显，结果是明显错误的，不应该用于除调试之外的任何其他用途。`logging`模块允许我们进一步细分错误。产生错误的程序可能仍然得出有序的结论。我们经常使用`CRITICAL`（或`FATAL`）错误消息来指示Python程序可能没有正确终止，任何输出文件可能已损坏。我们经常将`CRITICAL`消息保留给顶层的`try:`块。
- en: An application might crash at the OS level. In this case, there may be no messages
    from Python's exception handling or logging. This, too, is very clear as there
    are no usable results.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序可能在操作系统级别崩溃。在这种情况下，Python的异常处理或日志中可能没有消息。这也很明显，因为没有可用的结果。
- en: This second sense of *questionable results* is not a good design. Using warnings—either
    via the `warnings` module or the `WARN` messages from `logging`—doesn't really
    help the users.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*可疑结果*的第二种意义并不是一个好的设计。使用警告——无论是通过`warnings`模块还是`logging`中的`WARN`消息——并不能真正帮助用户。'
- en: Showing API changes with a warning
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示警告的API更改
- en: 'When we change the API for one of our modules, packages, or classes, we can
    provide a handy marking via the `warnings` module. This will raise a warning in
    the method that is deprecated or is pending deprecation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改模块、包或类的API时，我们可以通过`warnings`模块提供一个方便的标记。这将在被弃用或即将被弃用的方法中引发警告：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When we do this, any part of the application that uses `Player.bet()` will
    receive `DeprecationWarning`. By default, this warning is silent. We can, however,
    adjust the `warnings` filter to see the message, as shown here:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，应用程序中使用`Player.bet()`的任何部分都将收到`DeprecationWarning`。默认情况下，此警告是静默的。但是，我们可以调整`warnings`过滤器以查看消息，如下所示：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This technique allows us to locate all of the places where our application must
    change because of an API change. If we have unit test cases with close to 100
    percent code coverage, this simple technique is likely to reveal all the uses
    of deprecated methods.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术使我们能够找到我们的应用程序必须因API更改而进行更改的所有位置。如果我们的单元测试用例覆盖了接近100％的代码，这种简单的技术很可能会揭示所有弃用方法的用法。
- en: 'Because this is so valuable for planning and managing software change, we have
    three ways to be sure that we see all of the warnings in our applications:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这对规划和管理软件更改非常有价值，我们有三种方法可以确保我们在应用程序中看到所有警告：
- en: The command-line `-Wd` option will set the action to `default` for all warnings.
    This will enable the normally silent deprecation warnings. When we run `python3.3
    -Wd`, we'll see all the deprecation warnings.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行`-Wd`选项将为所有警告设置操作为`default`。这将启用通常静默的弃用警告。当我们运行`python3.3 -Wd`时，我们将看到所有弃用警告。
- en: Using `unittest`, which always executes in the `warnings.simplefilter('default')`
    mode.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`unittest`，它总是以`warnings.simplefilter('default')`模式执行。
- en: Including `warnings.simplefilter('default')` in our application program. This
    will also apply the `default` action to all warnings; it's equivalent to the `-Wd`
    command-line option.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的应用程序中包括`warnings.simplefilter('default')`。这也将对所有警告应用`default`操作；这相当于`-Wd`命令行选项。
- en: Showing configuration problems with a warning
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示警告的配置问题
- en: We may have multiple implementations for a given class or module. We'll often
    use a configuration file parameter to decide which implementation is appropriate.
    See [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, for more information on this technique.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的类或模块，我们可能有多个实现。我们通常会使用配置文件参数来决定哪个实现是合适的。有关此技术的更多信息，请参见[第13章](ch13.html
    "第13章。配置文件和持久性")，“配置文件和持久性”。
- en: 'In some cases, however, an application may silently depend on whether or not
    other packages are part of the Python installation. One implementation may be
    optimal, and another implementation may be the fallback plan. A common technique
    is to try multiple `import` alternatives to locate a package that''s installed.
    We can produce warnings that show us the possible configuration difficulties.
    Here''s a way to manage this alternative implementation import:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，应用程序可能悄悄地依赖于其他软件包是否属于Python安装的一部分。一个实现可能是最佳的，另一个实现可能是备用计划。一个常见的技术是尝试多个`import`替代项来定位已安装的软件包。我们可以生成警告，显示可能的配置困难。以下是管理此替代实现导入的方法：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We tried one import for a module. If this fails, we'll try another import. We
    used an `if` statement to reduce the nesting of the exceptions. If there are more
    than two alternatives, nested exceptions can lead to a very complex-looking exception.
    By using extra `if` statements, we can flatten a long sequence of alternatives
    so that the exceptions aren't nested.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试导入一个模块。如果失败，我们将尝试另一个导入。我们使用`if`语句来减少异常的嵌套。如果有两个以上的选择，嵌套异常可能会导致异常看起来非常复杂。通过使用额外的`if`语句，我们可以使长序列的选择变得扁平，以便异常不会嵌套。
- en: We can better manage this warning message by changing the class of the message.
    In the preceding code, this will be `UserWarning`. These are shown by default,
    providing the users with some evidence that the configuration is not optimal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过更改消息的类来更好地管理此警告消息。在前面的代码中，这将是`UserWarning`。这些默认显示，为用户提供了一些证据表明配置不是最佳的。
- en: If we change the class to `ImportWarning`, it will be silent by default. This
    provides a normally silent operation in the cases where the choice of packages
    doesn't matter to the users. The typical developer's technique of running with
    the `-Wd` option will reveal the `ImportWarning` messages.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将类更改为`ImportWarning`，它将默认保持静默。这在用户对软件包的选择无关紧要的情况下提供了通常的静默操作。运行`-Wd`选项的典型开发人员技术将显示`ImportWarning`消息。
- en: 'To change the class of the warning, we change the call to `warnings.warn()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改警告的类，我们更改对`warnings.warn()`的调用：
- en: '[PRE34]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This changes the warning to a class that is silent by default. The message can
    still be visible to developers who should be using the `-Wd` option.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把警告更改为默认情况下保持静默的类。消息仍然可以对应该使用`-Wd`选项的开发人员可见。
- en: Showing possible software problems with a warning
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示可能的软件问题与警告
- en: 'The idea of warnings aimed at end users is a bit nebulous: did the application
    work or did it fail? What does a warning really mean? Is there something the user
    should do differently?'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 面向最终用户的警告的概念有点模糊：应用程序是工作还是失败了？警告真正意味着什么？用户应该做出不同的反应吗？
- en: Because of this potential ambiguity, warnings in the user interface aren't a
    great idea. To be truly usable, a program should either work correctly or should
    not work at all. When there's an error, the error message should include advice
    for the user's response to the problem. We shouldn't impose a burden on the user
    to judge the quality of the output and determine its fitness for purpose. We'll
    emphasize on this point.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于潜在的模棱两可性，用户界面中的警告不是一个好主意。为了真正可用，程序应该要么正确工作，要么根本不工作。当出现错误时，错误消息应包括用户对问题的响应建议。我们不应该让用户承担评估输出质量并确定其适用性的负担。我们将强调这一点。
- en: Tip
  id: totrans-213
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A program should either work correctly or should not work at all*.*
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '程序应该要么正确工作，要么根本不工作*。* '
- en: One potential unambiguous use for end user warnings is to alert the user that
    the output is incomplete. An application may have a problem completing a network
    connection, for example. The essential results are correct, but one of the data
    sources didn't work properly.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 端用户警告的一个潜在明确的用途是警告用户输出不完整。例如，应用程序可能在完成网络连接时出现问题。基本结果是正确的，但其中一个数据源未能正常工作。
- en: 'There are situations where the application is taking an action that is not
    what the user requested, and the output is valid and useful. In the case of a
    network problem, a default behavior was used instead of a behavior based on the
    network resources. Generally, replacing something faulty with something correct
    but not exactly what the user requested is a good candidate for a warning. This
    kind of warning is best done with `logging` at the WARN level, not with the `warnings`
    module. The warnings module produces one-time messages; we may want to provide
    more details to the user. Here''s how we might use a simple `Logger.warn()` message
    to describe the problem in the log:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，应用程序正在执行的操作与用户请求的操作不同，输出是有效且有用的。在网络问题的情况下，使用了默认行为而不是基于网络资源的行为。通常，用正确的东西替换有问题的东西，但不完全符合用户请求的行为是警告的一个很好的候选。这种警告最好使用“logging”在WARN级别进行，而不是使用“warnings”模块。警告模块产生一次性消息；我们可能需要向用户提供更多细节。以下是我们如何使用简单的“Logger.warn（）”消息在日志中描述问题：
- en: '[PRE35]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If a timeout occurs, a warning message is written to the log and the program
    keeps running. The content of the resource will be set to an empty list. The log
    message will be written every time. A `warnings` module warning is ordinarily
    shown only once from a given location in the program and is suppressed after that.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发生超时，将向日志写入警告消息，并且程序将继续运行。资源的内容将设置为空列表。每次都会写入日志消息。通常，“warnings”模块警告只会从程序中的给定位置显示一次，之后就会被抑制。
- en: Advanced logging – the last few messages and network destinations
  id: totrans-219
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级日志 - 最后几条消息和网络目的地
- en: 'We''ll look at two more advanced techniques that can help provide useful debugging
    information. The first of these is a *log tail*: this is a buffer of the last
    few log messages before some significant event. The idea is to have a small file
    that can be read to see the last few log messages before an application died.
    It''s a bit like having the OS `tail` command automatically applied to the full
    log output.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究另外两种高级技术，可以帮助提供有用的调试信息。其中之一是*日志尾巴*：这是在某个重要事件之前的最后几条日志消息的缓冲区。这个想法是有一个小文件，可以读取以查看应用程序死机之前的最后几条日志消息。这有点像自动应用于完整日志输出的操作系统“tail”命令。
- en: The second technique uses a feature of the logging framework to send log messages
    through a network to a centralized log-handling service. This can be used to consolidate
    logs from a number of parallel web servers. We need to create both senders and
    receivers for the logs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种技术使用日志框架的一个特性，将日志消息通过网络发送到集中的日志处理服务。这可以用于 consoli日志来自多个并行web服务器。我们需要为日志创建发送方和接收方。
- en: Building an automatic tail buffer
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建自动尾部缓冲区
- en: 'The log tail buffer is an extension to the `logging` framework. We''re going
    to extend `MemoryHandler` to slightly alter its behavior. The built-in behavior
    for `MemoryHandler` includes three use cases for writing: it will write to another
    `handler` when the capacity is reached; it will write any buffered messages when
    `logging` shuts down; most importantly, it will write the entire buffer when a
    message of a given level is logged.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 日志尾缓冲区是“logging”框架的扩展。我们将扩展“MemoryHandler”以略微改变其行为。内置的“MemoryHandler”行为包括三种写入用例：当达到容量时，它将写入另一个“handler”；当“logging”关闭时，它将写入任何缓冲消息；最重要的是，当记录了给定级别的消息时，它将写入整个缓冲区。
- en: We'll change the first use case slightly. Instead of writing when the buffer
    is full, we'll remove just the oldest message, leaving the others in the buffer.
    The other two use cases will be left alone. This will have the effect of dumping
    the last few messages before the shutdown as well as dumping the last few messages
    before an error.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将略微更改第一个用例。我们不会在缓冲区满时写入，而是只删除最旧的消息，保留缓冲区中的其他消息。其他两个用例将保持不变。这将导致在关闭之前倾倒最后几条消息，以及在错误之前倾倒最后几条消息。
- en: We'll often configure the memory handler to buffer messages until a message
    greater than or equal to the error level is logged. This will lead to dumping
    the buffer ending with the error.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常会配置内存处理程序，直到记录了大于或等于错误级别的消息之前，才会缓冲消息。这将导致以错误结束的倾倒缓冲区。
- en: To understand this example, it's important to locate your Python installation
    and review the `logging.handlers` module in detail.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这个示例，重要的是要找到您的Python安装位置，并详细查看“logging.handlers”模块。
- en: 'This extension to `MemoryHandler` will keep the last few messages, based on
    the defined capacity when the `TailHandler` class is created:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对“MemoryHandler”的扩展将保留最后几条消息，基于在创建“TailHandler”类时定义的容量：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: We extended `MemoryHandler` so that it will accumulate log messages up to the
    given capacity. When the capacity is reached, old messages will be removed as
    new messages are added. Note that we must lock the data structure to permit multithreaded
    logging.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了“MemoryHandler”，以便它将累积日志消息直到达到给定的容量。当达到容量时，旧消息将被删除，新消息将被添加。请注意，我们必须锁定数据结构以允许多线程记录。
- en: If a message with an appropriate level is received, then the entire structure
    is emitted to the target handler. Usually, the target is `FileHandler`, which
    writes to a tail file for debugging and support purposes.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收到具有适当级别的消息，则整个结构将被发送到目标处理程序。通常，目标是“FileHandler”，用于将日志写入尾文件以进行调试和支持。
- en: Additionally, when `logging` shuts down, the final few messages will also be
    written to the tail file. This should indicate a normal termination that doesn't
    require any debugging or support.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当“logging”关闭时，最后几条消息也将写入尾文件。这应该表明正常终止，不需要任何调试或支持。
- en: Generally, we'd send `DEBUG` level messages to this kind of handler so that
    we have a great deal of detail surrounding a crash situation. The configuration
    should specifically set the level to `DEBUG` rather than allowing the level to
    default.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会将“DEBUG”级别的消息发送到这种处理程序，以便在崩溃情况下获得大量细节。配置应明确将级别设置为“DEBUG”，而不是允许级别默认设置。
- en: 'Here''s a configuration that uses this `TailHandler`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此“TailHandler”的配置：
- en: '[PRE37]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The definition of `TailHandler` shows us several additional features of the
    `logging` configuration. It shows us class references as well as other elements
    of the configuration file.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: “TailHandler”的定义向我们展示了“logging”配置的几个附加特性。它向我们展示了类引用以及配置文件的其他元素。
- en: We referred to a customized class definition in the configuration. A label of
    `()` specifies that the value should be interpreted as a module and class name.
    In this case, it is an instance of our `__main__.TailHandler` class. A label of
    `class` instead of `()` uses a module and class that are part of the `logging`
    package.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置中引用了自定义类定义。标签“（）”指定该值应解释为模块和类名。在这种情况下，它是我们的“__main__.TailHandler”类的一个实例。而不是“（）”的“class”标签使用了“logging”包中的模块和类。
- en: We referred to another logger that's defined within the configuration. The text
    `cgf://handlers.console` in the preceding configuration file refers to the `console`
    handler defined within the `handlers` section of this configuration file. For
    demonstration purposes, we've had the tail target `StreamHandler` that uses `sys.stderr`.
    As noted previously, an alternative design might be to use a `FileHandler` that
    targets a debugging file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置中引用了另一个记录器。在前面的配置文件中，“cgf://handlers.console”文本指的是配置文件中“handlers”部分中定义的“console”处理程序。为了演示目的，我们使用了一个使用“sys.stderr”的“StreamHandler”作为tail目标。如前所述，另一种设计可能是使用一个将目标定位到调试文件的“FileHandler”。
- en: We created the `test` hierarchy of loggers that used our `tail` handler. The
    messages written to these loggers will be buffered and only shown on the error
    or shutdown.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了使用我们的“tail”处理程序的“test”日志记录器层次结构。写入这些记录器的消息将被缓冲，并且只在错误或关闭时显示。
- en: 'Here''s a demonstration script:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是演示脚本：
- en: '[PRE38]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We generated 20 messages prior to an error. Then, we generated 20 more messages
    before shutting down the logging and flushing the buffers. This will produce output
    like the following one:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在错误之前，我们生成了20条消息。然后，在关闭日志记录并刷新缓冲区之前，我们生成了20条消息。这将产生以下输出：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The intermediate messages were silently dropped by the `tail` handler. As the
    capacity was set to five, the last five messages prior to an error (or shutdown)
    are displayed.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 中间消息被“tail”处理程序静默丢弃。由于容量设置为五，因此在错误（或关闭）之前的最后五条消息将被显示。
- en: Sending logging messages to a remote process
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将日志消息发送到远程进程
- en: One high-performance design pattern is to have a cluster of processes that are
    being used to solve a single problem. We might have an application that is spread
    across multiple application servers or multiple database clients. For this kind
    of architecture, we often want a centralized log among all of the various processes.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一种高性能的设计模式是拥有一组进程，用于解决单个问题。我们可能有一个应用程序分布在多个应用程序服务器或多个数据库客户端上。对于这种类型的架构，我们经常希望在所有各种进程之间有一个集中的日志。
- en: One technique to create a unified log is to include accurate timestamps and
    then sort records from multiple logfiles into a single, unified log. This sorting
    and merging is extra processing that can be avoided by remotely logging from a
    number of concurrent producer processes to a single consumer process.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建统一日志的一种技术是包括准确的时间戳，然后将来自多个日志文件的记录排序到单个统一日志中。这种排序和合并是额外的处理，可以通过从多个并发生产者进程远程记录到单个消费者进程来避免。
- en: Our shared logging solution makes use of the shared queues from the `multiprocessing`
    module. For additional information on multiprocessing, see [Chapter 12](ch12.html
    "Chapter 12. Transmitting and Sharing Objects"), *Transmitting and Sharing Objects*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的共享日志解决方案利用了“multiprocessing”模块中的共享队列。有关多进程的更多信息，请参见[第12章](ch12.html "第12章。传输和共享对象")，“传输和共享对象”。
- en: 'There''s a three-step process to build a multiprocessing application:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 构建多进程应用程序的三个步骤：
- en: Firstly, we'll create the shared queue object so that the logging consumer can
    apply filters to the messages
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将创建共享队列对象，以便日志消费者可以对消息应用过滤器。
- en: Secondly, we'll create the consumer process that gets the logging records from
    the queue
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们将创建消费者进程，从队列中获取日志记录。
- en: Thirdly, we'll create the pool of source processes that do the real work of
    our application and produce logging records into the shared queue
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们将创建源进程池，这些进程将执行我们应用程序的实际工作，并将日志记录生成到共享队列中。
- en: The `ERROR` and `FATAL` messages could provide immediate notification via an
    SMS or e-mail to concerned users. The consumer can also handle the (relatively)
    slow processing associated with rotating logfiles.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: “ERROR”和“FATAL”消息可以通过短信或电子邮件立即通知相关用户。消费者还可以处理与旋转日志文件相关的（相对）较慢的处理。
- en: The overall parent application that creates the producers and consumers is roughly
    analogous to the Linux `init` program that starts the various OS-level processes.
    If we follow the `init` design pattern, then the parent application can monitor
    the various producer children to see if they crash, and it can either log the
    associated errors or even attempt to restart them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 创建生产者和消费者的整体父应用程序大致类似于启动各种操作系统级进程的Linux“init”程序。如果我们遵循“init”设计模式，那么父应用程序可以监视各种生产者子进程，以查看它们是否崩溃，并且可以记录相关错误，甚至尝试重新启动它们。
- en: 'Here''s the definition of a consumer process:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是消费者进程的定义：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This process is a subclass of `multiprocessing.Process`. We will start it with
    the `start()` method; the superclass will fork a subprocess that executes the
    `run()` method.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是“multiprocessing.Process”的子类。我们将使用“start（）”方法启动它；超类将fork一个执行“run（）”方法的子进程。
- en: While the process is running, it will get the log records from the queue and
    then route them to a logger instance. In this case, we're going to create a special
    logger named with a parent name of `combined.`; this will be given each record
    from a source process.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程运行时，它将从队列中获取日志记录，然后将它们路由到一个记录器实例。在这种情况下，我们将创建一个名为“combined.”的特殊记录器，这将为来自源进程的每条记录提供一个父名称。
- en: Additionally, we'll provide some counts based on the second word of each message.
    In this example, we've designed the applications so that the second word will
    be the process ID number from the message text. The counts will show us how many
    messages were processed correctly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将根据每条消息的第二个单词提供一些计数。在这个例子中，我们设计了应用程序，使得第二个单词将是消息文本中的进程ID号。这些计数将显示我们正确处理了多少条消息。
- en: 'Here''s a `logging` configuration file for this process:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用于此过程的`logging`配置文件：
- en: '[PRE41]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We defined a simple console `Logger` with a basic format. We also defined the
    top-level of a hierarchy of loggers with names that begin with `combined.`. These
    loggers will be used to display the combined output of the various producers.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个简单的控制台`Logger`，具有基本格式。我们还定义了以`combined.`开头的名称的日志记录器层次结构的顶层。这些记录器将用于显示各个生产者的组合输出。
- en: 'Here''s the logging producer:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这是日志生产者：
- en: '[PRE42]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The producer doesn't do much in the way of configuration. It simply gets a logger
    to use the qualified class name and an instance identifier (`self.proc_id`). It
    sets the list of handlers to be just `QueueHandler` wrapped around the destination
    a `Queue` instance. The level of this logger is set to `INFO`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者在配置方面并没有做太多。它只是获取一个用于限定类名和实例标识符（`self.proc_id`）的记录器。它设置要包裹在`Queue`实例周围的`QueueHandler`的处理程序列表。此记录器的级别设置为`INFO`。
- en: We made `handler_class` an attribute of the class definition because we plan
    to change it. For the first example, it will be `logging.handlers.QueueHandler`.
    For a later example, we'll change to another class.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`handler_class`作为类定义的属性，因为我们计划对其进行更改。对于第一个示例，它将是`logging.handlers.QueueHandler`。对于以后的示例，我们将更改为另一个类。
- en: The process to actually do this work uses the logger to create log messages.
    These messages will be enqueued for processing by the centralized consumer. In
    this case, the process simply floods the queue with 102 messages as quickly as
    possible.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 实际执行此工作的过程使用记录器创建日志消息。这些消息将被加入队列以供集中消费者处理。在这种情况下，该过程只是尽可能快地向队列中注入102条消息。
- en: 'Here''s how we can start the consumer and producers. We''ll show this in small
    groups of steps. First, we create the queue:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何启动消费者和生产者的方法。我们将分步显示。首先，我们创建队列：
- en: '[PRE43]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This queue is way too small to handle 10 producers blasting 102 messages in
    a fraction of a second. The idea of a small queue is to see what happens when
    messages are lost. Here''s how we start the consumer process:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个队列太小了，无法处理10个生产者在一秒钟内发送102条消息。小队列的想法是看看当消息丢失时会发生什么。这是我们启动消费者进程的方法：
- en: '[PRE44]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Here''s how we start an array of producer processes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何启动一系列生产者进程的方法：
- en: '[PRE45]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As expected, 10 concurrent producers will overflow the queue. Each producer
    will receive a number of queues full of exceptions to show us that the messages
    were lost.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，10个并发生产者将使队列溢出。每个生产者将收到一些异常的队列，以向我们显示消息已丢失。
- en: 'Here''s how we cleanly finish the processing:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何清理完成处理的方法：
- en: '[PRE46]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: First, we wait for each producer process to finish and then rejoin the parent
    process. Then, we put a sentinel object into the queue so that the consumer will
    terminate cleanly. Finally, we wait for the consumer process to finish and join
    the parent process.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们等待每个生产者进程完成，然后重新加入父进程。然后，我们将一个标记对象放入队列，以便消费者能够干净地终止。最后，我们等待消费者进程完成并重新加入父进程。
- en: Preventing queue overrun
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 防止队列溢出
- en: The default behavior of the logging module puts messages into the queue with
    the `Queue.put_nowait()` method. The advantage of this is that it allows the producers
    to run without the delays associated with logging. The disadvantage of this is
    that messages will get lost if the queue is too small to handle the worst-case
    burst of logging messages.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 日志模块的默认行为是使用`Queue.put_nowait()`方法将消息放入队列。这样做的好处是允许生产者在不受日志记录延迟的情况下运行。这样做的缺点是，如果队列太小无法处理最坏情况下的日志记录消息突发，消息将会丢失。
- en: 'We have two choices to gracefully handle this burst of messages:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种选择来优雅地处理这些消息的突发情况：
- en: We can switch from `Queue` to `SimpleQueue`. `SimpleQueue` has an indefinite
    size. As it has a slightly different API, we'll need to extend `QueueHandler`
    to use `Queue.put()` instead of `Queue.put_nowait()`.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从`Queue`切换到`SimpleQueue`。`SimpleQueue`的大小是不确定的。由于它具有稍微不同的API，我们需要扩展`QueueHandler`以使用`Queue.put()`而不是`Queue.put_nowait()`。
- en: We can slow down the producer in the rare case that the queue is full. This
    is a small change to `QueueHandler` to use `Queue.put()` instead of `Queue.put_nowait()`.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在罕见情况下，如果队列已满，我们可以减慢生产者的速度。这是对`QueueHandler`的一个小改动，使用`Queue.put()`而不是`Queue.put_nowait()`。
- en: 'Interestingly, the same API change works for both `Queue` and `SimpleQueue`.
    Here''s the change:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，相同的API更改对`Queue`和`SimpleQueue`都适用。这是更改：
- en: '[PRE47]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We replaced the body of the `enqueue()` method to use a different method of
    `Queue`. Now, we can use `SimpleQueue` or `Queue`. If we use `Queue`, it will
    wait when the queue is full, preventing the loss of logging messages. If we use
    `SimpleQueue`, the queue will silently expand to hold all the messages.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们替换了`enqueue()`方法的主体，以使用`Queue`的不同方法。现在，我们可以使用`SimpleQueue`或`Queue`。如果我们使用`Queue`，它将在队列满时等待，防止日志消息丢失。如果我们使用`SimpleQueue`，队列将悄悄地扩展以容纳所有消息。
- en: 'Here''s the revised producer class:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的生产者类：
- en: '[PRE48]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This class uses our new `WaitQueueHandler`. Otherwise, the producer is identical
    to the previous version.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类使用我们的新`WaitQueueHandler`。否则，生产者与之前的版本相同。
- en: The rest of the script to create `Queue` and start the consumer is identical.
    The producers are instances of `Log_Producer_2`, but otherwise, the script to
    start and join remains identical to the first example.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Queue`和启动消费者的其余脚本是相同的。生产者是`Log_Producer_2`的实例，但启动和加入的脚本与第一个示例相同。
- en: This variation runs more slowly, but never loses a message. We can improve the
    performance by creating a larger queue capacity. If we create a queue with a capacity
    of 1,020 messages, the performance is maximized for this example. Finding an optimal
    queue capacity requires careful experimentation.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化运行速度更慢，但永远不会丢失消息。我们可以通过创建更大的队列容量来提高性能。如果我们创建一个容量为1,020条消息的队列，那么对于这个示例来说，性能是最大化的。找到最佳队列容量需要仔细的实验。
- en: Summary
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We saw how to use the logging module with more advanced object-oriented design
    techniques. We created logs associated with modules, classes, instances, and functions.
    We used decorators to create logging as a consistent cross-cutting aspect across
    multiple class definitions.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用日志记录模块与更高级的面向对象设计技术。我们创建了与模块、类、实例和函数相关的日志。我们使用装饰器来创建日志记录，作为跨多个类定义的一致性横切方面。
- en: We saw how to use the `warnings` module to show you that there's a problem with
    the configuration or the deprecated methods. We can use warnings for other purposes,
    but we need to be cautious about the overuse of warnings and creating murky situations
    where it's not clear whether the application worked correctly or not.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用`warnings`模块来显示配置或弃用方法存在问题。我们可以使用警告来进行其他用途，但我们需要谨慎使用警告，并避免创建模糊的情况，以便不清楚应用程序是否正常工作。
- en: Design considerations and trade-offs
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: The `logging` module supports auditability and debugging ability as well as
    some security requirements. We can use logging as a simple way to keep records
    of the processing steps. By selectively enabling and disabling logging, we can
    support developers who are trying to learn what the code is really doing when
    processing real-world data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块支持可审计性和调试能力，以及一些安全要求。我们可以使用日志记录作为保留处理步骤记录的简单方式。通过选择性地启用和禁用日志记录，我们可以支持试图了解处理真实世界数据时代码实际操作的开发人员。'
- en: The `warnings` module supports debugging ability as well as maintainability
    features. We can use warnings to alert the developers about the API problems,
    configuration problems, and other potential sources of bugs.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`warnings`模块支持调试能力以及可维护性特性。我们可以使用警告来警告开发人员有关API问题、配置问题和其他潜在的错误来源。'
- en: 'When working with the `logging` module, we''ll often be creating large numbers
    of distinct loggers that feed a few `handlers`. We can use the hierarchical nature
    of the `Logger` names to introduce new or specialized collections of logging messages.
    There''s no reason why a class can''t have two loggers: one for audit and one
    for more general-purpose debugging.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`logging`模块时，我们经常会创建大量不同的日志记录器，这些记录器会向少数`handlers`提供信息。我们可以利用`Logger`名称的分层性质来引入新的或专门的日志消息集合。一个类可以有两个日志记录器：一个用于审计，一个用于更通用的调试，这并没有什么不可以。
- en: We can introduce new logging-level numbers, but this should be done reluctantly.
    The levels tend to conflate the developer focus (debug, info, warning) with user
    focus (info, error, fatal). There's a kind of spectrum of *optionality* from debug
    messages that are not required for fatal error messages, which should never be
    silenced. We might add a level for verbose information or possibly detailed debugging,
    but that's about all that should be done with levels.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以引入新的日志级别数字，但这应该是勉强的。级别往往会混淆开发人员关注的内容（调试、信息、警告）和用户关注的内容（信息、错误、致命）。从不需要对致命错误消息进行静默处理的调试消息到致命错误消息之间存在一种*可选性*的谱系。我们可以添加一个用于详细信息或可能的详细调试的级别，但这就是级别应该做的全部。
- en: The `logging` module allows us to provide a number of configuration files for
    different purposes. As developers, we may use a configuration file that sets the
    logging levels to `DEBUG` and enables specific loggers for modules under development.
    For final deployment, we can provide a configuration file that sets the logging
    levels to `INFO` and provides different handlers to support more formal audit
    or security review needs.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`logging`模块允许我们为不同的目的提供多个配置文件。作为开发人员，我们可以使用一个设置日志级别为`DEBUG`并启用特定模块下的日志记录器的配置文件。对于最终部署，我们可以提供一个将日志级别设置为`INFO`并提供不同处理程序以支持更正式审计或安全审查需求的配置文件。'
- en: 'We''ll include some thoughts from the *Zen of Python*:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将包括一些来自*Python之禅*的思考：
- en: Errors should never pass silently.Unless explicitly silenced.
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 错误永远不应该悄悄地传递。除非明确地被消除。
- en: The `warnings` and `logging` module directly support this idea.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`warnings`和`logging`模块直接支持这个想法。'
- en: These modules are oriented more towards the overall quality than towards the
    specific solution of a problem. They allow us to provide consistency via fairly
    simple programming. As our object-oriented designs become larger and more complex,
    we can focus more on the problem being solved without wasting time on the infrastructure
    considerations. Further, these modules allow us to tailor the output to provide
    information needed by the developer or user.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块更多地面向整体质量，而不是解决问题的具体解决方案。它们允许我们通过相当简单的编程提供一致性。随着我们的面向对象设计变得越来越大和复杂，我们可以更多地专注于解决的问题，而不是浪费时间在基础设施考虑上。此外，这些模块允许我们定制输出，以提供开发人员或用户所需的信息。
- en: Looking forward
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the following chapters, we take a look at designing for testability and how
    we use `unittest` and `doctest`. Automated testing is essential; no programming
    should be considered complete until there are automated unit tests that provide
    ample evidence to show us that the code works. We'll look at object-oriented design
    techniques that will make software easier to test.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将看看如何设计可测试性以及如何使用`unittest`和`doctest`。自动化测试是必不可少的；除非有自动化单元测试提供充分的证据表明代码有效，否则编程不应被认为是完成的。我们将研究使软件更易于测试的面向对象设计技术。
- en: Chapter 15. Designing for Testability
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第15章。可测试性设计
- en: 'High-quality programs have automated tests. We need to use everything at our
    disposal to be sure that our software works. The golden rule is this: *to be deliverable,
    the feature must have a unit test*.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 高质量的程序都有自动化测试。我们需要利用一切手段来确保我们的软件工作正常。黄金法则是：*要交付的特性必须有单元测试*。
- en: 'Without an automated unit test, the feature cannot be trusted to work and should
    not be used. According to Kent Beck, in *Extreme Programming Explained*:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 没有自动化单元测试，特性就不能被信任，也不应该被使用。根据肯特·贝克在《极限编程解释》中的说法：
- en: '"Any program feature without an automated test simply doesn''t exist."'
  id: totrans-308
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “任何没有自动化测试的程序特性都不存在。”
- en: 'There are two essential points regarding the automated testing of program features:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 关于程序特性的自动化测试有两个关键点：
- en: '**Automated**: This means that there''s no human judgment involved. The testing
    involves a script that compares actual responses to expected responses.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：这意味着没有人为判断。测试涉及一个脚本，比较实际响应和预期响应。'
- en: '**Features**: These are tested in isolation to be sure that they work separately.
    This is unit testing, where each "unit" has enough software to implement a given
    feature. Ideally, it''s a small unit such as a class. However, it can also be
    a larger unit such as a module or package.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性**：这些是被单独测试以确保它们单独工作的。这是单元测试，其中每个“单元”都有足够的软件来实现给定的特性。理想情况下，它是一个小单元，比如一个类。但是，它也可以是一个更大的单元，比如一个模块或包。'
- en: Python has two built-in testing frameworks, making it easy to write automated
    unit tests. We'll look at using both `doctest` and `unittest` for automating testing.
    We'll look at some of the design considerations required to make testing practical.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两个内置的测试框架，可以轻松编写自动化单元测试。我们将研究如何使用`doctest`和`unittest`进行自动化测试。我们将研究一些必要的设计考虑因素，以使测试变得实用。
- en: 'For more ideas, read about *Ottinger and Langr''s* **FIRST** properties of
    unit tests: **Fast**, **Isolated**, **Repeatable**, **Self-validating**, and **Timely**.
    For the most part, Repeatable and Self-validating require an automated test framework.
    Timely means that the test is written before the code under test. See [http://pragprog.com/magazines/2012-01/unit-tests-are-first](http://pragprog.com/magazines/2012-01/unit-tests-are-first).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多，请阅读*Ottinger和Langr*的**FIRST**单元测试属性：**快速**，**隔离**，**可重复**，**自我验证**和**及时**。在很大程度上，可重复和自我验证需要一个自动化测试框架。及时意味着测试是在被测试的代码之前编写的。请参阅[http://pragprog.com/magazines/2012-01/unit-tests-are-first](http://pragprog.com/magazines/2012-01/unit-tests-are-first)。
- en: Defining and isolating units for testing
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和隔离用于测试的单元
- en: As testing is essential, testability is an important design consideration. Our
    designs must also support testing and debugging because a class that merely appears
    to work is of no value. A class that has evidence that it works is much more valuable.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 由于测试是必不可少的，可测试性是一个重要的设计考虑因素。我们的设计也必须支持测试和调试，因为一个看似工作的类是没有价值的。一个有证据证明它工作的类更有价值。
- en: Ideally, we'd like a hierarchy of testing. At the foundation is unit testing.
    Here, we test each class or function in isolation to be sure that it meets the
    contractual obligations of the API. Each class or function is a single unit under
    test. Above this comes integration testing. Once we know that each class and function
    works individually, we can test groups and clusters of classes. We can test whole
    modules and whole packages, too. After the integration tests work, we can look
    at the automated testing of the complete application.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望有一个测试的层次结构。在基础层是单元测试。在这里，我们测试每个类或函数，以确保它满足API的契约义务。每个类或函数都是一个单独的被测试单元。在这之上是集成测试。一旦我们知道每个类和函数都单独工作，我们就可以测试类的组和集群。我们也可以测试整个模块和整个包。在集成测试工作之后，我们可以看看完整应用的自动化测试。
- en: This is not an exhaustive list of the types of tests. We can do performance
    testing or security vulnerability testing too. We'll focus, however, on automated
    unit testing because it is central to all applications. This hierarchy of testing
    reveals an important complexity. Test cases for an individual class or group of
    classes can be very narrowly defined. As we introduce more units into integration
    testing, the domain of inputs grows. When we attempt to test a whole application,
    the entire spectrum of human behavior becomes a candidate input; this includes
    shutting devices off mid-test, pulling out plugs, and pushing things off tables
    to see whether they still work after being dropped three feet onto a hardwood
    floor. The hugeness of the domain of behavior makes it difficult to *fully* automate
    application testing.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是测试类型的详尽列表。我们也可以进行性能测试或安全漏洞测试。然而，我们将专注于自动化单元测试，因为它对所有应用程序都至关重要。这种测试层次结构揭示了一个重要的复杂性。对于单个类或类组的测试用例可以非常狭义地定义。当我们将更多的单元引入集成测试时，输入的领域就会增长。当我们尝试测试整个应用程序时，整个人类行为的范围都成为候选输入；这包括在测试中关闭设备、拔掉插头，以及将东西从桌子上推下去，看看它们在从硬木地板上掉下三英尺后是否仍然工作。行为领域的巨大使得*完全*自动化应用程序测试变得困难。
- en: We'll focus on the things that are easiest to test automatically. Once the unit
    tests work, the larger, aggregate systems are more likely to work.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于那些最容易自动化测试的事物。一旦单元测试工作，更大的、聚合的系统更有可能工作。
- en: Minimizing the dependencies
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最小化依赖关系
- en: 'When we design a class, we must also consider the network of dependencies around
    that class: classes on which it depends and classes that depend on it. In order
    to simplify testing a class definition, we need to isolate it from the surrounding
    classes.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个类时，我们必须考虑该类周围的依赖网络：它所依赖的类和依赖它的类。为了简化对类定义的测试，我们需要将其与周围的类隔离开来。
- en: An example of this is the `Deck` class that depends on the `Card` class. We
    can easily test `Card` in isolation but, when we want to test a `Deck` class,
    we need to tease it away from the definition of `Card`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是`Deck`类依赖于`Card`类。我们可以很容易地单独测试`Card`，但是当我们想要测试`Deck`类时，我们需要将其从`Card`的定义中分离出来。
- en: 'Here''s one (of many) previous definitions of `Card` that we''ve looked at:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们之前看过的`Card`的一个（多个）先前定义：
- en: '[PRE49]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can see that each of these classes has a straightforward inheritance dependency.
    Each class can be tested in isolation because there are only two methods and four
    attributes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这些类中的每一个都有一个简单的继承依赖关系。每个类都可以独立测试，因为只有两个方法和四个属性。
- en: 'We can (mis-)design a `Deck` class to have some problematic dependencies:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以（误）设计一个`Deck`类，其中存在一些问题的依赖关系：
- en: '[PRE50]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This design has two deficiencies. First, it's intimately bound to the three
    classes in the `Card` class hierarchy. We can't isolate `Deck` from `Card` for
    a standalone unit test. Second, it is dependent on the random number generator,
    making it difficult to create a repeatable test.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计有两个缺陷。首先，它与`Card`类层次结构中的三个类紧密相关。我们无法将`Deck`与`Card`隔离以进行独立的单元测试。其次，它依赖于随机数生成器，这使得创建可重复的测试变得困难。
- en: On the one hand, `Card` is a pretty simple class. We could test this version
    of `Deck` with `Card` left in place. On the other hand, we might want to reuse
    `Deck` with poker cards or pinochle cards that have different behaviors from Blackjack
    cards.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，`Card`是一个非常简单的类。我们可以测试`Deck`的这个版本，同时保留`Card`。另一方面，我们可能希望重用具有不同行为的扑克牌或皮诺克尔牌的`Deck`，而不是黑杰克牌。
- en: The ideal situation is to make `Deck` independent of any particular `Card` implementation.
    If we do this well, then we can not only test `Deck` independently of any `Card`
    implementation, but we can also use any combination of `Card` and `Deck` definitions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况是使`Deck`独立于任何特定的`Card`实现。如果我们做得好，那么我们不仅可以独立于任何`Card`实现测试`Deck`，还可以使用任何`Card`和`Deck`定义的组合。
- en: 'Here''s our preferred method to separate one of the dependencies. We can use
    a factory function:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们首选的分离依赖项的方法。我们可以使用一个工厂函数：
- en: '[PRE51]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `card()` function will build proper subclasses of `Card` based on the requested
    rank. This allows the `Deck` class to use this function instead of directly building
    instances of the `Card` class. We separated the two class definitions by inserting
    an intermediate function.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`card()`函数将根据请求的等级构建`Card`的适当子类。这允许`Deck`类使用此函数，而不是直接构建`Card`类的实例。我们通过插入一个中间函数来分离这两个类定义。'
- en: We have other techniques to separate the `Card` class from the `Deck` class.
    We can refactor the factory function to be a method of `Deck`. We can also make
    the class names a separate binding via class-level attributes or even initialization
    method parameters.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有其他技术来将`Card`类与`Deck`类分离。我们可以重构工厂函数成为`Deck`的一个方法。我们还可以通过类级属性或初始化方法参数使类名成为一个单独的绑定。
- en: 'Here''s an example that avoids a factory function by using more complex bindings
    in the initialization method:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个避免使用工厂函数的示例，而是在初始化方法中使用更复杂的绑定：
- en: '[PRE52]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: While this initialization is wordy, the `Deck` class isn't intimately bound
    to the `Card` class hierarchy or a specific, random number generator. For testing
    purposes, we can provide a random number generator that has a known seed. We can
    also replace the various `Card` class definitions with other classes (such as
    `tuple`) that can simplify our testing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种初始化方式很啰嗦，但`Deck`类并没有与`Card`类层次结构或特定的随机数生成器紧密绑定。为了测试目的，我们可以提供一个具有已知种子的随机数生成器。我们还可以用其他类（如`tuple`）替换各种`Card`类定义，以简化我们的测试。
- en: In the next section, we'll focus on another variation of the `Deck` class. This
    will use the `card()` factory function. That factory function encapsulates the
    `Card` hierarchy bindings and the rules for separating card classes by rank into
    a single, testable location.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将专注于`Deck`类的另一种变体。这将使用`card()`工厂函数。该工厂函数封装了`Card`层次结构绑定和将卡类按等级分离的规则，使其成为一个可测试的位置。
- en: Creating simple unit tests
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建简单的单元测试
- en: We'll create some simple unit tests of the `Card` class hierarchy and the `card()`
    factory function.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一些`Card`类层次结构和`card()`工厂函数的简单单元测试。
- en: As the `Card` classes are so simple, there's no reason for overly sophisticated
    testing. It's always possible to err on the side of needless complication. An
    *unthinking* slog through a test-driven development process can make it seem as
    though we need to write a fairly large number of not very interesting unit tests
    for a class that only has a few attributes and methods.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Card`类非常简单，没有理由进行过于复杂的测试。总是有可能在不必要的复杂性方面出错。在测试驱动的开发过程中，盲目地进行开发似乎需要为一个只有少量属性和方法的类编写相当多而不是很有趣的单元测试。
- en: It's important to understand that test-driven development is *advice*, not a
    natural law such as the conservation of mass. Nor is it a ritual that must be
    followed without thinking.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，测试驱动的开发是*建议*，而不是质量守恒定律之类的自然法则。它也不是一个必须毫无思考地遵循的仪式。
- en: 'There are several schools of thought on naming test methods. We''ll emphasize
    a style of naming that includes describing a test condition and expected results.
    Here are three variations on this theme:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 关于命名测试方法有几种不同的观点。我们将强调一种包括描述测试条件和预期结果的命名风格。以下是这个主题的三种变体：
- en: We can use a two-part name separated by `_should_` such as `StateUnderTest_should_ExpectedBehavior`.
    We summarize the state and the response. We'll focus on names of this form.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用由`_should_`分隔的两部分名称，例如`StateUnderTest_should_ExpectedBehavior`。我们总结状态和响应。我们将专注于这种形式的名称。
- en: We can use a two-part name with `when_`, and `_should_` such as `when_StateUnderTest_should_ExpectedBehavior`.
    We still summarize the state and response, but we provide a little more syntax.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`when_`和`_should_`的两部分名称，例如`when_StateUnderTest_should_ExpectedBehavior`。我们仍然总结状态和响应，但我们提供了更多的语法。
- en: We can use a three-part name, `UnitOfWork_StateUnderTest_ExpectedBehavior`.
    This incorporates the unit under test, which may be helpful for reading test output
    logs.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用三部分名称，`UnitOfWork_StateUnderTest_ExpectedBehavior`。这包括正在测试的单元，这可能有助于阅读测试输出日志。
- en: For more information, read [http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html](http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html).
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请阅读[http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html](http://osherove.com/blog/2005/4/3/naming-standards-for-unit-tests.html)。
- en: It's possible to configure the `unittest` module to use different patterns for
    discovering test methods. We could change it to look for `when_`. To keep things
    simple, we'll rely on the built-in pattern of having test method names begin with
    `test`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可以配置`unittest`模块以使用不同的模式来发现测试方法。我们可以将其更改为查找`when_`。为了保持简单，我们将依赖于测试方法名称以`test`开头的内置模式。
- en: 'This, for example, is a test of the `Card` class:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是对`Card`类的一个测试：
- en: '[PRE53]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We defined a test `setUp()` method that creates an object of the class that
    is under test. We also defined two tests on this object. As there''s no real interaction
    here, there''s no *state under test* in the test names: they''re simple universal
    behaviors that should always work.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个测试`setUp()`方法，它创建了一个正在测试的类的对象。我们还对这个对象定义了两个测试。由于这里没有真正的交互，测试名称中没有*正在测试的状态*：它们是简单的通用行为，应该始终有效。
- en: Some ask if this kind of test is excessive because there's more test than application
    code. The answer is *no*; this is not excessive. There's no law that says that
    there should be more application code than test code. Indeed, it doesn't make
    sense to compare the volumes of test with application code. Most importantly,
    even a tiny class definition can still have bugs.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人问，这种测试是否过多，因为测试比应用程序代码更多。答案是否定的；这并不过多。没有法律规定应该有更多的应用程序代码而不是测试代码。事实上，比较测试和应用程序代码的数量是没有意义的。最重要的是，即使一个小的类定义仍然可能存在错误。
- en: 'Simply testing the values of attributes doesn''t seem to test the processing
    in this class. There are two perspectives on testing attribute values, as shown
    in this example:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地测试属性的值似乎并不能测试这个类中的处理。在测试属性值时有两种观点，如下例所示：
- en: The **black box** perspective means that we disregard the implementation. In
    this case, we need to test all of the attributes. The attributes could, for example,
    be properties, and they must be tested.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**黑盒**视角意味着我们忽略了实现。在这种情况下，我们需要测试所有属性。这些属性可能是属性，它们必须经过测试。'
- en: The **white box** perspective means that we can examine the implementation details.
    When performing this style of testing, we can be a little more circumspect in
    deciding which attributes we test. The `suit` attribute, for example, doesn't
    deserve much testing. The `hard` and `soft` attributes, however, do require testing.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**白盒**视角意味着我们可以检查实现细节。在进行这种风格的测试时，我们可以更加谨慎地决定测试哪些属性。例如，`suit`属性并不值得太多测试。然而，`hard`和`soft`属性确实需要测试。'
- en: For more information, see [http://en.wikipedia.org/wiki/White-box_testing](http://en.wikipedia.org/wiki/White-box_testing)
    and [http://en.wikipedia.org/wiki/Black-box_testing](http://en.wikipedia.org/wiki/Black-box_testing).
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅[http://en.wikipedia.org/wiki/White-box_testing](http://en.wikipedia.org/wiki/White-box_testing)和[http://en.wikipedia.org/wiki/Black-box_testing](http://en.wikipedia.org/wiki/Black-box_testing)。
- en: 'Of course, we need to test the rest of the `Card` class hierarchy. We''ll just
    show you the `AceCard` test case. The `FaceCard` test case should be clear after
    this example:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要测试`Card`类层次结构的其余部分。我们将只展示`AceCard`测试用例。在这个例子之后，`FaceCard`测试用例应该很清楚：
- en: '[PRE54]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This test case also sets up a particular `Card` instance so that we can test
    the string output. It checks the various attributes of this fixed card.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例还设置了一个特定的`Card`实例，以便我们可以测试字符串输出。它检查了这张固定卡的各种属性。
- en: Creating a test suite
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个测试套件
- en: 'It is often helpful to formally define a test suite. The `unittest` package
    is capable of discovering tests by default. When aggregating tests from multiple
    test modules, it''s sometimes better to create a test suite in every test module.
    If each module defines a `suite()` function, we can replace test discovery with
    importing the `suite()` functions from each module. Also, if we customize `TestRunner`,
    we must use a suite. We can execute our tests as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正式定义测试套件通常是有帮助的。`unittest`包默认可以发现测试。当从多个测试模块聚合测试时，有时最好在每个测试模块中创建一个测试套件。如果每个模块定义了一个`suite()`函数，我们可以用每个模块导入`suite()`函数来替换测试发现。此外，如果我们自定义了`TestRunner`，我们必须使用一个测试套件。我们可以按照以下方式执行我们的测试：
- en: '[PRE55]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We built a suite from our three `TestCases` class definitions and then provided
    that suite to a `unittest.TextTestRunner()` instance. We used the default `TestLoader`
    in `unittest`. This `TestLoader` examines a `TestCase` class to locate all the
    test methods. The value of `TestLoader.testMethodPrefix` is `test`, which is how
    test methods are identified within a class. Each method name is used by the loader
    to create a separate test object.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从三个`TestCases`类定义中构建了一个测试套件，然后将该套件提供给`unittest.TextTestRunner()`实例。我们使用了`unittest`中的默认`TestLoader`。这个`TestLoader`检查`TestCase`类以定位所有测试方法。`TestLoader.testMethodPrefix`的值是`test`，这是类中标识测试方法的方式。加载器使用每个方法名来创建一个单独的测试对象。
- en: 'Using `TestLoader` to build test instances from appropriately named methods
    of `TestCase` is one of the two ways to use `TestCases`. In a later section, we''ll
    look at creating instances of `TestCase` manually; we won''t rely on `TestLoader`
    for these examples. We can run this suite like the following code:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`TestLoader`从`TestCase`的适当命名方法构建测试实例是使用`TestCases`的两种方法之一。在后面的部分中，我们将看看如何手动创建`TestCase`的实例；我们不会依赖`TestLoader`来进行这些示例。我们可以像以下代码一样运行这个测试套件：
- en: '[PRE56]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We''ll see output like the following code:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下代码的输出：
- en: '[PRE57]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The `TestLoader` class created two tests from each `TestCase` class. This gives
    us a total of six tests. The test names are the method names that begin with `test`.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestLoader`类从每个`TestCase`类创建了两个测试。这给了我们总共六个测试。测试名称是以`test`开头的方法名称。'
- en: Clearly, we have a problem. Our tests provide an expected result that our class
    definitions don't meet. We've got more development work to do for the `Card` classes
    in order to pass this simple suite of unit tests. The fix should be clear and
    we'll leave it as an exercise for the reader.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们有一个问题。我们的测试提供了一个预期结果，而我们的类定义并不符合。为了通过这个简单的单元测试套件，我们需要为`Card`类做更多的开发工作。修复方法应该很清楚，我们将把它留给读者作为练习。
- en: Including edge and corner cases
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包括边界和角落的情况
- en: 'When we move to testing the `Deck` class as a whole, we''ll need to have some
    things confirmed: that it produces all of the required `Cards` class, and that
    it actually shuffles properly. We don''t really need to test that it deals properly
    because we''re depending on the `list` and `list.pop()` method; as these are first-class
    parts of Python, they don''t require additional testing.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们转向作为一个整体测试`Deck`类时，我们需要确认一些事情：它是否产生了所有必需的`Cards`类，以及它是否真正正确地洗牌。我们不需要测试它是否正确发牌，因为我们依赖于`list`和`list.pop()`方法；由于这些方法是Python的一流部分，它们不需要额外的测试。
- en: We'd like to test the `Deck` class construction and shuffling, independently
    of any specific `Card` class hierarchy. As noted previously, we can use a factory
    function to make the two `Deck` and `Card` definitions independent. Introducing
    a factory function introduces yet more testing. Not a bad thing, considering the
    bugs previously revealed in the `Card` class hierarchy.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要独立于任何特定的`Card`类层次结构来测试`Deck`类的构造和洗牌。正如前面所述，我们可以使用一个工厂函数使两个`Deck`和`Card`定义独立。引入工厂函数会引入更多的测试。考虑到以前在`Card`类层次结构中发现的错误，这并不是一件坏事。
- en: 'Here''s a test of the factory function:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个工厂函数的测试：
- en: '[PRE58]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We didn''t test all 13 ranks, as 2 through 10 should all be identical. Instead,
    we followed this advice from *Boris Beizer*:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有测试所有13个等级，因为2到10应该是相同的。相反，我们遵循了*Boris Beizer*的建议：
- en: '"Bugs lurk in corners and congregate at boundaries."'
  id: totrans-375
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “错误潜伏在角落里，聚集在边界上。”
- en: The test cases involve the edge values for each card range. Consequently, we
    have test cases for the values 1, 2, 10, 11, and 13, as well as illegal values
    of 0 and 14\. We bracketed each range with the least value, the maximum value,
    one below the least value, and one above the maximum value.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例涉及每个卡片范围的边界值。因此，我们对值1、2、10、11和13进行了测试，以及非法值0和14。我们用最小值、最大值、最小值下面的一个值和最大值上面的一个值来对每个范围进行了分组。
- en: When this is run, there will be problems reported by this test case too. One
    of the biggest problems will be an undefined exception, `LogicError`. This is
    simply a subclass of `Exception` that defines that the exception still isn't enough
    to get the test case to pass. The rest of the fix is left as an exercise for the
    reader.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行时，这个测试用例也会报告问题。最大的问题之一将是一个未定义的异常，`LogicError`。这只是`Exception`的一个子类，它定义了异常仍然不足以使测试用例通过。其余的修复工作留给读者作为练习。
- en: Mocking dependencies for testing
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模拟依赖进行测试
- en: 'In order to test `Deck`, we have two choices to handle the dependencies:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`Deck`，我们有两种选择来处理依赖关系：
- en: '**Mocking**: We can create a mock (or stand-in) class for the `Card` class
    and a mock `card()` factory function that produces the mock class. The advantage
    of using mock objects is that we create real confidence that the unit under test
    is free from workarounds in one class; this makes up for bugs in another class.
    A rare potential disadvantage is that we may have to debug the behavior of a super-complex
    mock class to be sure it''s a valid stand-in for a real class.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**：我们可以为`Card`类创建一个模拟（或替代）类，以及一个模拟的`card()`工厂函数，用于生成模拟类。使用模拟对象的优势在于，我们可以真正确信被测试的单元不受另一个类中的变通方法的影响；这可以弥补另一个类中的错误。一个很少见的潜在缺点是，我们可能需要调试超复杂模拟类的行为，以确保它是真实类的有效替代品。'
- en: '**Integrating**: If we have a degree of trust that the `Card` class hierarchy
    works, and the `card()` factory function works, we can leverage these to test
    `Deck`. This strays from the high road of pure unit testing, in which all dependencies
    are excised for test purposes. It can work out well in practice, however, as a
    class that passes all its unit tests can be as trustworthy as a mock class. In
    the cases of very complex, stateful APIs, an application class may be more trustworthy
    than a mock. The disadvantage of this is that a broken foundational class will
    cause a large number of testing failures in all the classes that depend on it.
    Also, it''s difficult to make detailed tests of API conformance with non-mock
    classes. Mock classes can track the call history, making it possible to track
    the number of times it was called and the arguments used.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：如果我们相信`Card`类层次结构有效，并且`card()`工厂函数有效，我们可以利用它们来测试`Deck`。这偏离了纯单元测试的高道路，在纯单元测试中，所有依赖关系都被剔除以进行测试。然而，实际上这可能效果很好，因为通过了所有单元测试的类可以和模拟类一样可信。在非常复杂的有状态API的情况下，应用类可能比模拟类更可信。这样做的缺点是，如果一个基础类出现问题，将导致所有依赖它的类出现大量测试失败。此外，很难对非模拟类进行API符合性的详细测试。模拟类可以跟踪调用历史，从而可以跟踪调用次数和使用的参数。'
- en: The `unittest` package includes the `unittest.mock` module that can be used
    to patch the existing classes for test purposes. It can also be used to provide
    complete mock class definitions.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`包括`unittest.mock`模块，可用于为测试目的修补现有类。它还可用于提供完整的模拟类定义。'
- en: 'When we design a class, we must consider the dependencies that must be mocked
    for unit testing. In the case of `Deck`, we have three dependencies to mock:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个类时，我们必须考虑必须为单元测试进行模拟的依赖关系。在`Deck`的情况下，我们有三个依赖关系需要模拟：
- en: '**The Card class**: This class is so simple that we could create a mock for
    this class without basing it on an existing implementation. As the `Deck` class
    behavior doesn''t depend on any specific feature of `Card`, our mock object can
    be simple.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Card类**：这个类非常简单，我们可以为这个类创建一个模拟，而不是基于现有实现。由于`Deck`类的行为不依赖于`Card`的任何特定特性，我们的模拟对象可以很简单。'
- en: '**The card() factory**: This function needs to be replaced with a mock that
    we can use to determine if `Deck` makes proper calls to this function.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**card()工厂函数**：这个函数需要被替换为一个模拟函数，以便我们可以确定`Deck`是否正确调用了这个函数。'
- en: '**The random.Random.shuffle() method**: To determine if the method was called
    with proper argument values, we can provide a mock that will track usage rather
    than actually doing any shuffling.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**random.Random.shuffle()方法**：为了确定方法是否使用了正确的参数值进行调用，我们可以提供一个模拟对象来跟踪使用情况，而不是实际进行任何洗牌。'
- en: 'Here''s a version of `Deck` that uses the `card()` factory function:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`card()`工厂函数的`Deck`版本：
- en: '[PRE59]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This definition has two dependencies that are specifically called out as arguments
    to the `__init__()` method. It requires a random number generator, `random`, and
    a card factory, `card_factory`. It has suitable default values so that it can
    be used in an application very simply. It can also be tested by providing mock
    objects instead of the default objects.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义有两个特别指定为`__init__()`方法参数的依赖项。它需要一个随机数生成器`random`和一个卡片工厂`card_factory`。它具有合适的默认值，因此可以在应用程序中非常简单地使用。它也可以通过提供模拟对象来进行测试，而不是使用默认对象。
- en: We've included a `deal()` method that makes a change to the object by popping
    a card. If the deck is empty, the `deal()` method will raise a `DeckEmpty` exception.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包含了一个`deal()`方法，通过弹出一张卡片对对象进行更改。如果牌组为空，`deal()`方法将引发一个`DeckEmpty`异常。
- en: 'Here''s a test case to show you that the deck is built properly:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个测试用例，用来展示牌组是否被正确构建：
- en: '[PRE60]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We created two mocks in the `setUp()` method of this test case. The mock card
    factory function, `test_card`, is a `Mock` function. The defined return value
    is a `mock.sentinel` object instead of a `Card` instance. The sentinel is a unique
    object that allows us to confirm that the right number of instances was created.
    It's distinct from all other Python objects, so we can distinguish functions without
    proper `return` statements that return `None`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试用例的`setUp()`方法中，我们创建了两个模拟对象。模拟卡片工厂函数`test_card`是一个`Mock`函数。定义的返回值是一个`mock.sentinel`对象，而不是一个`Card`实例。这个sentinel是一个独特的对象，可以让我们确认创建了正确数量的实例。它与所有其他Python对象都不同，因此我们可以区分没有正确的`return`语句返回`None`的函数。
- en: We created an instance of the `random.Random()` generator, but we replaced the
    `shuffle()` method with a mock function that returns `None`. This provides us
    with an appropriate return value for the method and allows us to determine that
    the `shuffle()` method was called with the proper argument values.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`random.Random()`生成器的实例，但我们用一个返回`None`的模拟函数替换了`shuffle()`方法。这为我们提供了一个适当的方法返回值，并允许我们确定`shuffle()`方法是否使用了正确的参数值进行调用。
- en: 'Our test creates a `Deck` class with our two mock objects. We can then make
    a number of assertions about this `Deck` instance, `d`:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试创建了一个`Deck`类，其中包含了两个模拟对象。然后我们可以对这个`Deck`实例`d`进行多个断言：
- en: 52 objects were created. These are expected to be 52 copies of `mock.sentinel`,
    showing us that only the factory function was used to create objects.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了52个对象。这些预期是52个`mock.sentinel`的副本，表明只有工厂函数被用来创建对象。
- en: The `shuffle()` method was called with the `Deck` instance as the argument.
    This shows us how a mock object tracks its calls. We can use `assert_called_with()`
    to confirm that the argument values were as required when `shuffle()` was called.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shuffle()`方法被调用时使用了`Deck`实例作为参数。这向我们展示了模拟对象如何跟踪它的调用。我们可以使用`assert_called_with()`来确认在调用`shuffle()`时参数值是否符合要求。'
- en: The factory function was called 52 times.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂函数被调用了52次。
- en: The factory function was called with a specific list of expected rank and suit
    values.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂函数被调用时使用了特定的预期等级和花色值列表。
- en: There is a small bug in the `Deck` class definition, so this test doesn't pass.
    The fix is left as an exercise for the reader.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '`Deck`类定义中有一个小错误，所以这个测试没有通过。修复留给读者作为练习。'
- en: Using more mocks to test more behaviors
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用更多的模拟对象来测试更多的行为
- en: The preceding mock objects were used to test how a `Deck` class was built. Having
    52 identical sentinels makes it difficult to confirm that a `Deck` deals properly.
    We'll define a different mock to test the deal feature.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模拟对象用于测试`Deck`类是如何构建的。有52个相同的sentinels使得确认`Deck`是否正确发牌变得困难。我们将定义一个不同的模拟对象来测试发牌功能。
- en: 'Here''s a second test case to ensure that the `Deck` class deals properly:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第二个测试用例，以确保`Deck`类正确发牌：
- en: '[PRE61]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This mock for the card factory function uses the `side_effect` argument to `Mock()`.
    When provided with an iterable, this returns another value of the iterable each
    time it's called.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这个卡片工厂函数的模拟使用了`side_effect`参数来创建`Mock()`。当提供一个可迭代对象时，它会在每次调用时返回可迭代对象的另一个值。
- en: We mocked the `shuffle()` method to be sure that the cards aren't actually rearranged.
    We want them to stay in their original order so that our tests have a predictable
    expected value.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟了`shuffle()`方法，以确保卡片实际上没有被重新排列。我们希望它们保持原始顺序，这样我们的测试就有可预测的预期值。
- en: The first test (`test_deck_1_should_deal`) accumulates the results of dealing
    52 cards into a variable, `dealt`. It then asserts that this variable has the
    52 expected values from the original mock card factory.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个测试（`test_deck_1_should_deal`）将52张卡片的发牌结果累积到一个变量`dealt`中。然后断言这个变量具有原始模拟卡片工厂的52个预期值。
- en: The second test (`test_empty_deck_should_exception`) deals all of the cards
    from a `Deck` instance. However, it makes one more API request. The assertion
    is that the `Deck.deal()` method will raise the proper exception after dealing
    all of the cards.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个测试（`test_empty_deck_should_exception`）从一个`Deck`实例中发出了所有的卡片。然而，它多做了一个API请求。断言是在发出所有卡片后，`Deck.deal()`方法将引发适当的异常。
- en: Because of the relative simplicity of the `Deck` class, it's possible to combine
    both `TestDeckBuild` and `TestDeckDeal` into a single, more sophisticated mock.
    While that's possible with this example, it's neither essential, nor necessarily
    desirable to refactor the test cases to make them simpler. Indeed, too much simplification
    of tests may miss out on API features.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Deck`类的相对简单，可以将`TestDeckBuild`和`TestDeckDeal`合并为一个更复杂的模拟。虽然这在这个例子中是可能的，但重构测试用例使其更简单既不是必要的，也不一定是可取的。事实上，对测试的过度简化可能会忽略API功能。
- en: Using doctest to define test cases
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用doctest定义测试用例
- en: The `doctest` module provides us with a simpler form of testing than the `unittest`
    module. There are many cases where a simple interaction can be shown in the docstring
    and the test can be automated via `doctest`. This will combine the documentation
    and test cases into one tidy package.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块为我们提供了比`unittest`模块更简单的测试形式。有许多情况下，可以在文档字符串中显示简单的交互，并且可以通过`doctest`自动化测试。这将把文档和测试用例合并成一个整洁的包。'
- en: The `doctest` cases are written into the docstring for a module, class, method,
    or function. A `doctest` case shows us the interactive Python prompt `>>>`, statements
    and responses. The `doctest` module contains an application that looks for these
    examples in docstrings. It runs the given examples and compares the expected results
    shown in the docstrings with the actual outputs.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`用例被写入模块、类、方法或函数的文档字符串中。`doctest`用例向我们展示了交互式Python提示符`>>>`、语句和响应。`doctest`模块包含一个应用程序，用于查找这些示例在文档字符串中。它运行给定的示例，并将文档字符串中显示的预期结果与实际输出进行比较。'
- en: For larger and more complex class definitions, this can be challenging. In some
    cases, we may find that simple, printable results are difficult to work with,
    and we need more sophisticated comparisons to be made available from `unittest`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大更复杂的类定义，这可能是具有挑战性的。在某些情况下，我们可能会发现简单的可打印结果难以处理，我们需要更复杂的比较从`unittest`中提供。
- en: With careful design of an API, we can create a class that can be used interactively.
    If it can be used interactively, then a `doctest` example can be built from that
    interaction.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 通过精心设计API，我们可以创建一个可以与之交互的类。如果可以与之交互，那么可以从该交互构建一个`doctest`示例。
- en: Indeed, two attributes of a well-designed class are that it can be used interactively
    and it has `doctest` examples in the documentation strings. Many built-in modules
    contain `doctest` examples of the API. Many other packages that we might choose
    to download will also include `doctest` examples.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，一个设计良好的类的两个属性是它可以与之交互，并且在文档字符串中有`doctest`示例。许多内置模块包含API的`doctest`示例。我们可能选择下载的许多其他软件包也将包含`doctest`示例。
- en: 'With a simple function, we can provide documentation such as the following:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个简单的函数，我们可以提供以下文档：
- en: '[PRE62]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We've defined a version of Ackermann's function that includes docstring comments
    that include five sample responses from interactive Python. The first sample output
    is the `import` statement, which should produce no output. The other four sample
    outputs show us the different values of the function.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了Ackermann函数的一个版本，其中包括文档字符串注释，其中包括来自交互式Python的五个示例响应。第一个示例输出是`import`语句，不应产生任何输出。其他四个示例输出向我们展示了函数的不同值。
- en: In this case, the results are all correct. There's no hidden bug left as an
    exercise for the reader. We can run these tests with the `doctest` module. When
    run as a program, the command-line argument is the file that should be tested.
    The `doctest` program locates all docstrings and looks for interactive Python
    examples in those strings. It's important to note that the `doctest` documentation
    provides details on the regular expressions used to locate the strings. In our
    example, we added a hard-to-see blank line after the last `doctest` example to
    help the `doctest` parser.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，结果都是正确的。没有留下任何隐藏的错误供读者练习。我们可以使用`doctest`模块运行这些测试。当作为程序运行时，命令行参数是应该被测试的文件。`doctest`程序会定位所有文档字符串，并查找这些字符串中的交互式Python示例。重要的是要注意，`doctest`文档提供了有关用于定位字符串的正则表达式的详细信息。在我们的例子中，我们在最后一个`doctest`示例之后添加了一个难以看到的空行，以帮助`doctest`解析器。
- en: 'We can run `doctest` from the command line:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从命令行运行`doctest`：
- en: '[PRE63]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If everything is correct, this is silent. We can make it show us some details
    by adding the `-v` option:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正确，这是无声的。我们可以通过添加`-v`选项来显示一些细节：
- en: '[PRE64]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This will provide us with the details of each docstring parsed and each test
    case gleaned from the docstrings.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供从文档字符串解析出的每个详细信息和从文档字符串中获取的每个测试用例。
- en: This will show us the various classes, functions, and methods without any tests
    as well as the components that have tests. This provides some confirmation that
    our tests were properly formatted in the docstrings.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示各种类、函数和方法以及没有测试的组件，以及具有测试的组件。这些可以确认我们的测试在文档字符串中被正确格式化。
- en: In some cases, we have output that will not match interactive Python easily.
    In these cases, we may need to supplement the docstring with some annotations
    that modify how the test cases and expected results are parsed.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们的输出不会轻松匹配交互式Python。在这些情况下，我们可能需要在文档字符串中添加一些注释，修改测试用例和预期结果的解析方式。
- en: 'There''s a special comment string that we can use for more complex outputs.
    We can append any one of the following two commands to enable (or disable) the
    various kinds of directives that are available. The following is the first command:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的注释字符串，我们可以用于更复杂的输出。我们可以附加以下两个命令中的任何一个来启用（或禁用）可用的各种指令。以下是第一个命令：
- en: '[PRE65]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The following is the second command:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二个命令：
- en: '[PRE66]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are a dozen modifications that we can make to how the expected results
    are handled. Most of them are rare situations regarding spacing and how actual
    and expected values should be compared.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 有十几种修改方法可以处理预期结果的方式。其中大多数是关于间距和应该如何比较实际值和预期值的罕见情况。
- en: 'The `doctest` documentation emphasizes on the **Exact Match Principle**:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`文档强调**精确匹配原则**：'
- en: '*"doctest is serious about requiring exact matches in expected output."*'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '*“doctest在要求期望输出的精确匹配方面是严肃的。”*'
- en: Tip
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If even a single character doesn't match, the test fails. You'll need to build
    flexibility into some of the expected outputs. If building in flexibility gets
    too complex, it's a hint that `unittest` might be a better choice.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 如果甚至有一个字符不匹配，测试就会失败。您需要在一些预期输出中构建灵活性。如果构建灵活性变得太复杂，这就暗示`unittest`可能是一个更好的选择。
- en: 'Here are some specific situations where expected and actual values of `doctest`
    won''t match easily:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些特定情况，`doctest`的预期值和实际值不容易匹配：
- en: The dictionary key order is not guaranteed by Python. Use a construct such as
    `sorted(some_dict.items())` instead of `some_dict`.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python不保证字典键的顺序。使用类似`sorted(some_dict.items())`而不是`some_dict`的构造。
- en: 'The method functions `id()` and `repr()` involve physical memory addresses;
    Python makes no guarantee that they will be consistent. If you show `id()` or
    `repr()`, use the `#doctest: +ELLIPSIS` directive and replace the ID or address
    with `...` in the sample output.'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '方法函数`id()`和`repr()`涉及物理内存地址；Python不能保证它们是一致的。如果显示`id()`或`repr()`，请使用`#doctest:
    +ELLIPSIS`指令，并在示例输出中用`...`替换ID或地址。'
- en: Floating-point results may not be consistent across platforms. Always show floating-point
    numbers with formatting or rounding to reduce the number of digits to digits that
    are meaningful. Use `"{:.4f}".format(value)` or `round(value,4)` to ensure that
    insignificant digits are ignored.
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点结果可能在不同的平台上不一致。始终使用格式化或四舍五入显示浮点数，以减少无意义的数字的数量。使用`"{:.4f}".format(value)`或`round(value,4)`来确保忽略不重要的数字。
- en: A set order is not guaranteed by Python. Use a construct such as `sorted(some_set)`
    instead of `some_set`.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python不保证集合的顺序。使用类似`sorted(some_set)`而不是`some_set`的构造。
- en: The current date or time, of course, cannot be used, as that won't be consistent.
    A test that involves time or date needs to force a specific date or time, generally
    by mocking `time` or `datetime`.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期或时间当然不能使用，因为那不会是一致的。涉及时间或日期的测试需要强制使用特定的日期或时间，通常是通过模拟`time`或`datetime`。
- en: Operating system details such as file sizes or timestamps are likely to vary
    and should not be used without ellipsis. Sometimes, it's possible to include a
    useful setup or teardown in the `doctest` script to manage OS resources. In other
    cases, mocking the `os` module is helpful.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统的详细信息，如文件大小或时间戳，可能会有所不同，不应该在没有省略号的情况下使用。有时，在`doctest`脚本中包含一个有用的设置或拆卸来管理OS资源是可能的。在其他情况下，模拟`os`模块是有帮助的。
- en: 'These considerations mean that our `doctest` module may contain some additional
    processing that''s not simply a part of the API. We may have done something such
    as this at the interactive Python prompt:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这些考虑意味着我们的`doctest`模块可能包含一些不仅仅是API一部分的额外处理。我们可能在交互式Python提示符下做了一些类似这样的事情：
- en: '[PRE67]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This shows us the full output from a particular implementation. We can''t simply
    copy-and-paste this into a docstring; the floating-point results might differ.
    We''ll need to do something resembling the following code:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了特定实现的完整输出。我们不能简单地将其复制粘贴到文档字符串中；浮点结果可能会有所不同。我们需要做一些类似以下代码的事情：
- en: '[PRE68]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This is rounded to a value that should not vary between implementations.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个值，不应该在不同的实现之间变化。
- en: Combining doctest and unittest
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合doctest和unittest
- en: There's a hook in the `doctest` module that will create a proper `unittest.TestSuite`
    from docstring comments. This allows us to use both `doctest` and `unittest` in
    a large application.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '`doctest`模块中有一个钩子，可以从文档字符串注释中创建一个适当的`unittest.TestSuite`。这使我们可以在一个大型应用程序中同时使用`doctest`和`unittest`。'
- en: 'What we''ll do is create an instance of `doctest.DocTestSuite()`. This will
    build a suite from a module''s docstrings. If we don''t specify a module, the
    module that is currently running is used to build the suite. We can use a module
    such as the following one:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的是创建一个`doctest.DocTestSuite()`的实例。这将从模块的文档字符串构建一个套件。如果我们不指定一个模块，那么当前正在运行的模块将用于构建套件。我们可以使用一个如下的模块：
- en: '[PRE69]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: We built a suite, `suite5`, from the `doctest` strings in the current module.
    We used `unittest` `TextTestRunner` on this suite. As an alternative, we can combine
    the `doctest` suite with other `TestCases` to create a larger, more complete suite.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从当前模块的`doctest`字符串构建了一个套件`suite5`。我们在这个套件上使用了`unittest`的`TextTestRunner`。作为替代，我们可以将`doctest`套件与其他`TestCases`组合，创建一个更大、更完整的套件。
- en: Creating a more complete test package
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个更完整的测试包
- en: 'For larger applications, each application module can have a parallel module
    that includes `TestCases` for that module. This can form two parallel package
    structures: a `src` structure with the application module and a `test` structure
    with the test modules. Here are two parallel directory trees that show us the
    collections of modules:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的应用程序，每个应用程序模块都可以有一个并行模块，其中包括该模块的`TestCases`。这可以形成两个并行的包结构：一个`src`结构，其中包含应用程序模块，一个`test`结构，其中包含测试模块。以下是两个并行目录树，显示了模块的集合：
- en: '[PRE70]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Clearly, the parallelism isn't exact. We don't usually have an automated unit
    test for `setup.py`. A well-designed `__main__.py` may not require a separate
    unit test, as it shouldn't have much code in it. We'll look at some ways to design
    `__main__.py` in [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"),
    *Coping with the Command Line*.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，并行性并不是精确的。我们通常不会为`setup.py`编写自动化单元测试。一个设计良好的`__main__.py`可能不需要单独的单元测试，因为它不应该包含太多代码。我们将看一些设计`__main__.py`的方法，在[第16章](ch16.html
    "第16章。处理命令行")中，*处理命令行*。
- en: 'We can create a top-level `test/all.py` module with a body that builds all
    of the tests into a single suite:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个顶级的`test/all.py`模块，其中包含一个构建所有测试的主体套件：
- en: '[PRE71]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: We built a single suite, `all_tests`, from the suites within the other test
    modules. This provides us with a handy script that will run all of the tests that
    are available as part of the distribution.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从其他测试模块中的套件构建了一个单一套件`all_tests`。这为我们提供了一个方便的脚本，可以运行作为分发的一部分可用的所有测试。
- en: 'There are ways to use the test discovery features of the `unittest` module
    to do this as well. We perform package-wide testing from the command line, with
    something resembling the following code:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 也有办法使用`unittest`模块的测试发现功能来做到这一点。我们可以从命令行执行包范围的测试，类似以下代码：
- en: '[PRE72]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will use the default test discovery features of `unittest` to locate `TestCases`
    in the given files. This has the disadvantage of relying on shell script features
    rather than pure Python features. The wild-card file specification can sometimes
    make development more complex because incomplete modules might get tested.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用`unittest`的默认测试发现功能来定位给定文件中的`TestCases`。这有一个缺点，即依赖于shell脚本功能而不是纯Python功能。通配符文件规范有时会使开发变得更加复杂，因为可能会测试不完整的模块。
- en: Using setup and teardown
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用设置和拆卸
- en: 'There are three levels of setup and teardown available for the `unittest` modules.
    Here are the three different kinds of testing scopes: method, class, and module.'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块有三个级别的设置和拆卸。以下是三种不同的测试范围：方法，类和模块。'
- en: '**Test case setUp() and tearDown() methods**: These methods ensure that each
    individual test method within a `TestCase` class has had a proper setup and teardown.
    Often, we''ll use the `setUp()` method to create the unit objects and any mock
    objects that are required. We don''t want to do something costly such as creating
    whole databases, as these methods are used before and after each test method.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例setUp()和tearDown()方法：这些方法确保`TestCase`类中的每个单独测试方法都有适当的设置和拆卸。通常，我们会使用`setUp()`方法来创建单元对象和所需的任何模拟对象。我们不希望做一些昂贵的事情，比如创建整个数据库，因为这些方法在每个测试方法之前和之后都会被使用。
- en: '**Test case setUpClass() and tearDownClass() methods**: These methods perform
    a one-time setup (and teardown) around all the tests in a `TestCase` class. These
    methods bracket the sequence of `setUp()-testMethod()-tearDown()` for each method.
    This can be a good place to create and destroy the test data or a test schema
    inside a database.'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试用例setUpClass()和tearDownClass()方法：这些方法在`TestCase`类中的所有测试周围执行一次性设置（和拆卸）。这些方法将每个方法的`setUp()-testMethod()-tearDown()`序列括在一起。这是一个创建和销毁测试数据或数据库中的测试模式的好地方。
- en: '**Module setUpModule() and tearDownModule() functions**: These standalone functions
    provide us with a one-time setup before all of the `TestCase` classes in a module.
    This is a good place to create and destroy a test database as a whole before running
    a series of `TestCase` classes.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块setUpModule()和tearDownModule()函数：这些独立的函数为模块中所有的`TestCase`类提供了一次性设置。这是在运行一系列`TestCase`类之前创建和销毁整个测试数据库的好地方。
- en: 'We rarely need to define all of these `setUp()` and `tearDown()` methods. There
    are several testing scenarios that are going to be part of our design for testability.
    The essential difference between these scenarios is the degree of integration
    involved. As noted previously, we have three tiers in our testing hierarchy: isolated
    unit tests, integration tests, and overall application tests. There are several
    ways in which these tiers of testing work with the various setup and teardown
    features:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少需要定义所有这些`setUp()`和`tearDown()`方法。有几种测试场景将成为我们的可测试性设计的一部分。这些场景之间的基本区别是涉及的集成程度。正如前面所述，我们的测试层次结构中有三个层次：孤立的单元测试、集成测试和整体应用程序测试。这些测试层次与各种设置和拆卸功能一起工作的方式有几种。
- en: '**No integration – no dependencies**: Some classes or functions have no external
    dependencies; they don''t rely on files, devices, other processes, or other hosts.
    Other classes have some external resources that can be mocked. When the cost and
    complexity of the `TestCase.setUp()` method are small, we can create the needed
    objects there. If the mock objects are particularly complex, a class-level `TestCase.setUpClass()`
    might be more appropriate to amortize the cost of recreating the mock objects
    over several test methods.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有集成-没有依赖：一些类或函数没有外部依赖；它们不依赖文件、设备、其他进程或其他主机。其他类有一些可以模拟的外部资源。当`TestCase.setUp()`方法的成本和复杂性较小时，我们可以在那里创建所需的对象。如果模拟对象特别复杂，类级`TestCase.setUpClass()`可能更适合分摊在多个测试方法中重新创建模拟对象的成本。
- en: '**Internal Integration – some dependencies**: Automated integration testing
    among classes or modules often involves more complex setup situations. We may
    have a complex class-level `setUpClass()` or even a module-level `setUpModule()`
    to prepare an environment for integration testing. When working with the database
    access layers in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects
    via Shelve"), *Storing and Retrieving Objects via Shelve*, and [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    Objects via SQLite*, we often perform integration testing that includes our class
    definitions as well as our access layer. This may involve seeding a test database
    or shelf with appropriate data for the tests.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部集成-一些依赖：类或模块之间的自动集成测试通常涉及更复杂的设置情况。我们可能有一个复杂的类级`setUpClass()`甚至是模块级`setUpModule()`来为集成测试准备环境。在[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中处理数据库访问层时，我们经常进行包括我们的类定义以及我们的访问层的集成测试。这可能涉及向测试数据库或架子中添加适当的数据进行测试。
- en: '**External Integration**: We may perform automated integration testing with
    larger and more complex pieces of an application. In these cases, we may need
    to spawn external processes or create databases and seed them with data. In this
    case, we may have `setUpModule()` to prepare an empty database for use by all
    of the `TestCase` classes in a module. When working with RESTful web services
    in [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*, or testing **Programming In The Large** (**PITL**) in [Chapter
    17](ch17.html "Chapter 17. The Module and Package Design"), *The Module and Package
    Design*, this approach could be helpful.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部集成**：我们可以对应用程序的更大更复杂的部分进行自动集成测试。在这些情况下，我们可能需要启动外部进程或创建数据库并填充数据。在这种情况下，我们可以使用`setUpModule()`来为模块中的所有`TestCase`类准备一个空数据库。在[第12章](ch12.html
    "第12章。传输和共享对象")中使用RESTful web服务，或者在[第17章](ch17.html "第17章。模块和包设计")中测试**大规模编程**（PITL），这种方法可能会有所帮助。'
- en: Note that the concept of unit testing does not define what the unit under test
    is. The *unit* can be a class, a module, a package, or even an integrated collection
    of software components. It merely needs to be isolated from its environment to
    be a unit under test.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，单元测试的概念并没有定义被测试的单元是什么。*单元*可以是一个类、一个模块、一个包，甚至是一个集成的软件组件集合。它只需要与其环境隔离开来，就可以成为被测试的单元。
- en: When designing automated integration tests, it's important to be aware of the
    components to be tested. We don't need to test Python libraries; they have their
    own tests. Similarly, we don't need to test the OS. An integration test must focus
    on testing the code we wrote, not the code we downloaded and installed.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计自动集成测试时，重要的是要意识到要测试的组件。我们不需要测试Python库；它们有自己的测试。同样，我们不需要测试操作系统。集成测试必须专注于测试我们编写的代码，而不是我们下载和安装的代码。
- en: Using setup and teardown with OS resources
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用操作系统资源进行设置和拆卸
- en: In many cases, a test case may require a particular OS environment. When working
    with external resources such as files, directories, or processes, we may need
    to create or initialize them before a test. We may also need to remove the resources
    before a test. We may need to tear down these resources at the end of the test.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，测试用例可能需要特定的操作系统环境。在处理文件、目录或进程等外部资源时，我们可能需要在测试之前创建或初始化它们。我们可能还需要在测试之前删除这些资源。我们可能需要在测试结束时拆除这些资源。
- en: 'Let''s assume that we have a function, `rounds_final()` that is supposed to
    process a given file. We need to test the function''s behavior in the rare case
    that the file doesn''t exist. It''s common to see `TestCases` with a structure
    such as the following one:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为`rounds_final()`的函数，它应该处理给定的文件。我们需要测试函数在文件不存在的罕见情况下的行为。通常会看到`TestCases`具有以下结构：
- en: '[PRE73]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We have to handle the possible exception of trying to remove a file that doesn't
    exist in the first place. This test case has a `setUp()` method that ensures that
    the required file is missing. Once `setuUp()`ensures that the file is truly gone,
    we can execute the `rounds_final()` function with an argument of the missing file,
    "`p3_c15_sample.csv`". We expect this to raise a `FileNotFoundError` error.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须处理尝试删除根本不存在的文件的可能异常。这个测试用例有一个`setUp()`方法，确保所需的文件确实丢失。一旦`setUp()`确保文件真的消失了，我们就可以执行带有缺失文件“`p3_c15_sample.csv`”参数的`rounds_final()`函数。我们期望这会引发`FileNotFoundError`错误。
- en: 'Note that raising `FileNotFoundError` is a default behavior of Python''s `open()`
    method. This may not require testing at all. This leads to an important question:
    *why test a built-in feature*? If we''re performing black-box testing, we need
    to exercise all features of the external interface, including the expected default
    behaviors. If we''re performing white-box testing, we may need to test the exception-handling
    `try:` statement within the body of the `rounds_final()` function.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，引发`FileNotFoundError`是Python的`open()`方法的默认行为。这可能根本不需要测试。这引出了一个重要的问题：*为什么要测试内置功能*？如果我们进行黑盒测试，我们需要测试外部接口的所有功能，包括预期的默认行为。如果我们进行白盒测试，我们可能需要测试`rounds_final()`函数正文中的异常处理`try:`语句。
- en: 'The `p3_c15_sample.csv` filename is repeated within the body of the test. Some
    people feel that the DRY rule should apply even to the test code. There''s a limit
    to how much of this kind of optimization is valuable while writing tests. Here''s
    the suggestion:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '`p3_c15_sample.csv` 文件名在测试的正文中重复出现。有些人认为DRY原则应该适用于测试代码。在编写测试时，这种优化的价值是有限的。以下是建议：'
- en: Tip
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's okay for test code to be brittle. If a small change to the application
    leads to test failures, this really is a good thing. Tests should value simplicity
    and clarity, not robustness, and reliability.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码变得脆弱是可以接受的。如果对应用程序的微小更改导致测试失败，这确实是一件好事。测试应该重视简单和清晰，而不是健壮性和可靠性。
- en: Using setup and teardown with databases
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据库进行设置和拆卸
- en: When working with a database and ORM layer, we often have to create test databases,
    files, directories, or server processes. We may need to tear down a test database
    after the tests pass, to be sure that the other tests can run. We may not want
    to tear down a database after failed tests; we may need to leave the database
    alone so that we can examine the resulting rows to diagnose the test failures.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用数据库和ORM层时，我们经常需要创建测试数据库、文件、目录或服务器进程。我们可能需要在测试通过后拆除测试数据库，以确保其他测试可以运行。我们可能不希望在测试失败后拆除数据库；我们可能需要保留数据库，以便我们可以检查结果行以诊断测试失败。
- en: It's important to manage the scope of testing in a complex, multilayered architecture.
    Looking back at [Chapter 11](ch11.html "Chapter 11. Storing and Retrieving Objects
    via SQLite"), *Storing and Retrieving Objects via SQLite*, we don't need to specifically
    test the SQLAlchemy ORM layer or the SQLite database. These components have their
    own test procedures outside our application tests. However, because of the way
    the ORM layer creates database definitions, SQL statements, and Python objects
    from our code, we can't easily mock SQLAlchemy and hope that we've used it properly.
    We need to test the way our application uses the ORM layer without digressing
    into testing the ORM layer itself.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的、多层次的架构中管理测试范围非常重要。回顾[第11章](ch11.html "第11章。通过SQLite存储和检索对象")，*通过SQLite存储和检索对象*，我们不需要专门测试SQLAlchemy
    ORM层或SQLite数据库。这些组件在我们的应用程序测试之外有自己的测试程序。但是，由于ORM层从我们的代码中创建数据库定义、SQL语句和Python对象的方式，我们不能轻易地模拟SQLAlchemy并希望我们正确地使用它。我们需要测试我们的应用程序如何使用ORM层，而不是陷入测试ORM层本身。
- en: One of the more complex test case setup situations will involve creating a database
    and then populating it with appropriate sample data for the given test. When working
    with SQL, this can involve running a fairly complex script of SQL DDL to create
    the necessary tables and then another script of SQL DML to populate those tables.
    The associated teardown will be another complex SQL DDL script.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个更复杂的测试用例设置情况将涉及创建一个数据库，然后为给定的测试用例填充适当的示例数据。在处理SQL时，这可能涉及运行相当复杂的SQL DDL脚本来创建必要的表，然后运行另一个SQL
    DML脚本来填充这些表。相关的拆卸将是另一个复杂的SQL DDL脚本。
- en: 'This kind of test case can become long-winded, so we''ll break it into three
    sections: a useful function to create a database and schema, the `setUpClass()`
    method, and the rest of the unit test.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试用例可能会变得冗长，所以我们将其分为三个部分：一个有用的函数来创建数据库和模式，`setUpClass()`方法，以及其余的单元测试。
- en: 'Here''s the create-database function:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建数据库的函数：
- en: '[PRE74]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This builds a fresh database by dropping all of the tables associated with the
    ORM classes and recreating the tables. The idea is to ensure a fresh, empty database
    that conforms to the current design, no matter how much that design has changed
    since the last time the unit tests were run.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过删除与ORM类相关的所有表并重新创建这些表来构建一个新的数据库。其目的是确保一个新的、空的数据库，符合当前的设计，无论这个设计自上次运行单元测试以来有多大的变化。
- en: In this example, we built a SQLite database using a file. We can use the *in-memory*
    SQLite database feature to make the test run somewhat more quickly. The downside
    of using an in-memory database is that we have no persistent database file that
    we can use to debug failed tests.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用文件构建了一个SQLite数据库。我们可以使用*内存*SQLite数据库功能使测试运行速度更快。使用内存数据库的缺点是我们没有持久的数据库文件，无法用于调试失败的测试。
- en: 'Here''s how we use this in a `TestCase` subclass:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在`TestCase`子类中使用的方式：
- en: '[PRE75]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: We defined `setUpClass()` so that a database is created before the tests from
    this class are run. This allows us to define a number of test methods that will
    share a common database configuration. Once the database has been built, we can
    create a session and add data.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`setUpClass()`，以便在运行这个类的测试之前创建一个数据库。这允许我们定义一些将共享一个公共数据库配置的测试方法。数据库建立后，我们可以创建一个会话并添加数据。
- en: We've put the session maker object into the class as a class-level attribute,
    `Test_Blog_Queries.Session = sessionmaker(bind=engine)`. This class-level object
    can then be used in `setUp()` and individual test methods.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将会话制造者对象放入类中作为一个类级属性，`Test_Blog_Queries.Session = sessionmaker(bind=engine)`。然后可以在`setUp()`和单独的测试方法中使用这个类级对象。
- en: 'Here is `setUp()` and two of the individual test methods:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`setUp()`和两个单独的测试方法：
- en: '[PRE76]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `setUp()` method creates a new, empty session object. This will ensure that
    every query must generate SQL and fetch data from the database.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`setUp()`方法创建一个新的空会话对象。这将确保每个查询都必须生成SQL并从数据库中获取数据。'
- en: The `query_eqTitle_should_return1Blog()` test will find the requested `Blog`
    instance and navigate to the `Post` instances via the `entries` relationship.
    The `filter()` portion of the request doesn't really test our application definitions;
    it exercises SQLAlchemy and SQLite. The `results[0].entries` test in the final
    assertion is a meaningful test of our class definitions.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_eqTitle_should_return1Blog()`测试将找到请求的`Blog`实例，并通过`entries`关系导航到`Post`实例。请求的`filter()`部分并不真正测试我们的应用程序定义；它是对SQLAlchemy和SQLite的练习。最终断言中的`results[0].entries`测试是对我们类定义的有意义的测试。'
- en: The `query_likeTitle_should_return2Blog()` test is almost entirely a test of
    SQLAlchemy and SQLite. It isn't really making a meaningful use of anything in
    our application except the presence of an attribute named `title` in `Blog`. These
    kinds of tests are often left over from creating initial technical spikes. They
    can help clarify an application API, even if they don't provide much value as
    a test case.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_likeTitle_should_return2Blog()`测试几乎完全是对SQLAlchemy和SQLite的测试。除了在`Blog`中存在名为`title`的属性之外，它并没有真正对我们的应用程序做出有意义的使用。这些测试通常是在创建初始技术性探索时留下的。即使它们作为测试用例并没有太多价值，它们可以帮助澄清应用程序API。'
- en: 'Here are two more test methods:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有两个测试方法：
- en: '[PRE77]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `query_eqW42_tag_should_return2Post()` test performs a more complex query
    to locate the posts that have a given tag. This exercises a number of relationships
    defined in the classes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`query_eqW42_tag_should_return2Post()`测试执行更复杂的查询，以定位具有给定标签的帖子。这涉及到类中定义的多个关系。'
- en: The `query_eqICW_tag_should_return1Post()` test, similarly, exercises a complex
    query. It tests the navigation from `Post` to owning `Blog` via `results[0].blog.title`.
    It also tests navigation from `Post` to an associated collection of `Tags` via
    `set(t.phrase for t in results[0].tags)`. We must use an explicit `set()` because
    the order of results in SQL is not guaranteed.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，`query_eqICW_tag_should_return1Post（）`测试涉及复杂的查询。它测试从`Post`到拥有`Blog`的导航，通过`results[0].blog.title`。它还测试从`Post`到`Tags`的关联集合的导航，通过`set(t.phrase
    for t in results[0].tags)`。我们必须使用显式的`set()`，因为在SQL中结果的顺序不能保证。
- en: What's important about this `Test_Blog_Queries` subclass of `TestCase` is that
    it creates a database schema and a specific set of defined rows via the `setUpClass()`
    method. This kind of test setup is helpful for database applications. It can become
    rather complex and is often supplemented by loading sample rows from files or
    JSON documents rather than coding the rows in Python.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test_Blog_Queries`的重要之处在于它通过`setUpClass（）`方法创建了数据库模式和一组特定的定义行。这种测试设置对于数据库应用程序很有帮助。它可能变得相当复杂，并且通常通过从文件或JSON文档加载示例行来补充，而不是在Python中编写行。'
- en: The TestCase class hierarchy
  id: totrans-506
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TestCase类层次结构
- en: 'Inheritance works among the `TestCase` classes. Ideally, each `TestCase` is
    unique. Pragmatically, there may be common features among cases. There are three
    common ways in which `TestCase` classes may overlap:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 继承在`TestCase`类之间起作用。理想情况下，每个`TestCase`都是唯一的。实际上，测试用例之间可能存在共同特征。`TestCase`类可能重叠的三种常见方式：
- en: '**Common setUp()**: We may have some data that is used in multiple `TestCases`.
    There''s no reason to repeat the data. A `TestCase` class that only defines `setUp()`
    or `tearDown()` with no test methods is legal, but it may lead to a confusing
    log because there are zero tests involved.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的setUp（）：我们可能有一些数据在多个`TestCases`中使用。没有理由重复数据。只定义`setUp（）`或`tearDown（）`而没有测试方法的`TestCase`类是合法的，但可能会导致混乱的日志，因为没有涉及任何测试。
- en: '**Common tearDown()**: It''s common to have a common cleanup for tests that
    involve OS resources. We might need to remove files and directories or kill subprocesses.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的tearDown（）：通常需要对涉及操作系统资源的测试进行常见的清理。我们可能需要删除文件和目录或者终止子进程。
- en: '**Common results checking**: For algorithmically complex tests, we may have
    a results checking method that verifies some properties of a result.'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的结果检查：对于算法复杂的测试，我们可能有一个结果检查方法来验证结果的一些属性。
- en: 'Looking back at [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties,
    and Descriptors"), *Attribute Access, Properties, and Descriptors*, for example,
    consider the `RateTimeDistance` class. This class fills in a missing value in
    a dictionary based on two other values:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第3章](ch03.html "第3章。属性访问、属性和描述符")，*属性访问、属性和描述符*，例如，考虑`RateTimeDistance`类。该类根据另外两个值填充字典中的缺失值：
- en: '[PRE78]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Each unit test method for this can include the following code:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单元测试方法可以包括以下代码：
- en: '[PRE79]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we use a number of `TestCase` subclasses, we can inherit this validity check
    as a separate method:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用多个`TestCase`子类，我们可以将此有效性检查作为单独的方法继承：
- en: '[PRE80]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This way, each test need only include `self.validate(object)` to be sure that
    all the tests provide a consistent definition of correctness.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，每个测试只需要包括`self.validate（object）`，以确保所有测试提供一致的正确定义。
- en: An important feature of the definition of the `unittest` module is that the
    test cases are proper classes with proper inheritance. We can design the `TestCase`
    class hierarchy with the same care and attention to detail that we apply to the
    application classes.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块定义的一个重要特性是测试用例是合适的类，具有合适的继承。我们可以像应用程序类一样，精心设计`TestCase`类层次结构。'
- en: Using externally defined expected results
  id: totrans-519
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用外部定义的预期结果
- en: For some applications, users can articulate processing rules that describe the
    software's behavior. In other cases, the job of an analyst or a designer transforms
    the user's desires into procedural descriptions of the software.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些应用程序，用户可以阐述描述软件行为的处理规则。在其他情况下，分析员或设计师的工作是将用户的愿望转化为软件的过程描述。
- en: In many cases, it's easier for users to provide concrete examples of expected
    results. For some business-oriented applications, the users may be more comfortable
    creating a spreadsheet that shows us sample inputs and expected results. Working
    from user-supplied, concrete sample data can simplify the developing software.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，用户更容易提供预期结果的具体示例。对于一些面向业务的应用程序，用户可能更习惯创建一个显示示例输入和预期结果的电子表格。从用户提供的具体示例数据中开发软件可以简化开发过程。
- en: '*Whenever possible, have real users produce concrete examples of correct results*.
    Creating procedural descriptions or software specifications is remarkably difficult.
    Creating concrete examples and generalizing from the examples to a software specification
    is less fraught with complexity and confusion. Further, it plays into a style
    of development where the test cases drive the development effort. Given a suite
    of test cases, we have a concrete definition of *done*. Tracking the software
    development project status leads to asking how many test cases we have today and
    how many of them pass.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽可能让真实用户产生正确结果的具体示例*。创建过程描述或软件规范非常困难。从示例创建具体示例并从示例概括到软件规范的过程不那么复杂和混乱。此外，它符合测试用例驱动开发的风格。给定一套测试用例，我们有一个*完成*的具体定义。跟踪软件开发项目状态会问今天有多少测试用例，其中有多少通过。'
- en: Given a spreadsheet of concrete examples, we need to turn each row into a `TestCase`
    instance. We can then build a suite from these objects.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具体示例的电子表格，我们需要将每一行转换为`TestCase`实例。然后我们可以从这些对象构建一个测试套件。
- en: 'For the previous examples in this chapter, we loaded the test cases from a
    `TestCase`-based class. We used `unittest.defaultTestLoader.loadTestsFromTestCase`
    to locate all the methods with a name that start with `test`. The loader creates
    a test object from each method and combines them into a test suite. In effect,
    each object built by the loader is a discrete object created by invoking the class
    constructor using the test case name: `SomeTestCase("test_method_name")`. The
    parameters to the `SomeTestCase__init__()` method will be the method names which
    were used to define the class. Each method is individually elaborated into a test
    case.'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前面例子中，我们从基于`TestCase`的类中加载了测试用例。我们使用`unittest.defaultTestLoader.loadTestsFromTestCase`来定位所有以`test`开头的方法。加载器从每个方法创建一个测试对象，并将它们组合成一个测试套件。实际上，加载器创建的每个对象都是通过使用测试用例名称调用类构造函数创建的离散对象：`SomeTestCase("test_method_name")`。传递给`SomeTestCase__init__()`方法的参数将是用于定义类的方法名称。每个方法都被单独详细说明为一个测试用例。
- en: For this example, we're going to use the other approach to build test case instances.
    We're going to define a class with a single test and load multiple instances of
    this `TestCase` class into a suite. When we do this, the `TestCase` class must
    define only one test and, by default, that method's name should be `runTest()`.
    We won't be using the loader to create the test objects; we'll be creating them
    directly from rows of externally supplied data.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用另一种方法来构建测试用例实例。我们将定义一个只有一个测试的类，并将多个这个`TestCase`类的实例加载到一个测试套件中。这样做时，`TestCase`类必须只定义一个测试，并且默认情况下，该方法的名称应该是`runTest()`。我们不会使用加载器来创建测试对象；我们将直接从外部提供的数据行创建它们。
- en: 'Let''s take a look at a concrete function that we need to test. This is from
    [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个我们需要测试的具体函数。这是来自[第3章](ch03.html "第3章。属性访问、属性和描述符")，“属性访问、属性和描述符”：
- en: '[PRE81]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This is a class that eagerly computes a number of attributes when it is initialized.
    The users of this simple function provided us with some test cases as a spreadsheet,
    from which we extracted the CSV file. For more information on CSV files, see [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. We need to
    transform each row into `TestCase`:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在初始化时急切计算多个属性的类。这个简单函数的用户向我们提供了一些测试用例，我们从中提取了CSV文件。有关CSV文件的更多信息，请参见[第9章](ch09.html
    "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")，“序列化和保存 - JSON、YAML、Pickle、CSV和XML”。我们需要将每一行转换为`TestCase`：
- en: '[PRE82]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Here''s the test case that we can use to create test instances from each row
    of the CSV file:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以用来从CSV文件的每一行创建测试实例的测试用例：
- en: '[PRE83]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The `float_or_none()` function is a common way to handle the CSV source data.
    It converts the text of a cell to a `float` value or `None`.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '`float_or_none()`函数是处理CSV源数据的常用方法。它将单元格的文本转换为`float`值或`None`。'
- en: 'The `Test_RTD` class does three things:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '`Test_RTD`类做了三件事：'
- en: 'The `__init__()` method parses a row of a spreadsheet into two dictionaries:
    the input values, `self.args` and the expected output values, `self.result`'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法将电子表格的一行解析为两个字典：输入值`self.args`和预期输出值`self.result`'
- en: The `setUp()` method creates a `RateTimeDistance` object and provides the input
    argument values
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setUp()`方法创建了一个`RateTimeDistance`对象并提供了输入参数值'
- en: The `runTest()` method can simply validate the output by checking the results
    against the user-supplied values
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`runTest()`方法可以通过检查结果与用户提供的值进行比较来简单验证输出'
- en: 'We also provided you with a `shortDescription()` method that returns a pithy
    summary of the test. This can help with any debugging. We can build a suite as
    follows:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为您提供了一个`shortDescription()`方法，返回测试的简要摘要。这可以帮助调试。我们可以按以下方式构建一个测试套件：
- en: '[PRE84]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We opened the CSV file and read each test case row of that file as a `dict`
    object. If the CSV column titles properly match the expectations of the `Test_RTD.__init__()`
    method, then each row becomes a test case object and can be added to the suite.
    If the CSV column titles don''t match, we''ll have a `KeyError` exception; we''ll
    have to fix the spreadsheet to match the `Test_RTD` class. We run the tests as
    follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了CSV文件，并将该文件的每个测试用例行读取为一个`dict`对象。如果CSV列标题与`Test_RTD.__init__()`方法的期望匹配，那么每行就成为一个测试用例对象，并可以添加到测试套件中。如果CSV列标题不匹配，我们将会有一个`KeyError`异常；我们需要修复电子表格以匹配`Test_RTD`类。我们按以下方式运行测试：
- en: '[PRE85]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output looks like this:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE86]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The user-supplied data has a small problem; the users provided a value that
    has been rounded off to only two places. Either the sample data needs to provide
    more digits, or our test assertions need to cope with the rounding.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的数据有一个小问题；用户提供了一个只舍入到两位小数的值。要么样本数据需要提供更多位数，要么我们的测试断言需要处理舍入。
- en: Getting users to supply precise example data may not work out well. If the users
    can't be more precise, then our test assertions need to include some rounding
    based on the user's input. This can be challenging because of the way spreadsheets
    display data as if it's a precise decimal value, when it's really a rounded and
    formatted floating-point approximation. In many cases, a blanket rounding assumption
    can be used rather than trying to parse the user's intent via reverse-engineering
    a spreadsheet.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 让用户提供精确的示例数据可能不会很好。如果用户不能更精确，那么我们的测试断言需要包括一些基于用户输入的四舍五入。这可能是有挑战性的，因为电子表格以一种精确的十进制值显示数据，而实际上是一个舍入和格式化的浮点近似值。在许多情况下，可以使用一个统一的舍入假设，而不是试图通过反向工程电子表格来解析用户的意图。
- en: Automated integration or performance testing
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动集成或性能测试
- en: We can use the `unittest` package to perform testing that isn't focused on a
    single, isolated class definition. As noted previously, we can use the `unittest`
    automation to test a unit that is an integration of multiple components. This
    kind of testing can only be performed on software that has passed unit tests on
    isolated components. There's no point in trying to debug a failed integration
    test when a component's unit test didn't work correctly.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`unittest`包执行不专注于单个孤立类定义的测试。如前所述，我们可以使用`unittest`自动化来测试由多个组件集成的单元。这种测试只能在已经通过孤立组件的单元测试的软件上执行。当组件的单元测试未正确工作时，尝试调试失败的集成测试是没有意义的。
- en: Performance testing can be done at several levels of integration. For a large
    application, performance testing with the entire build may not be completely helpful.
    One traditional view is that a program spends 90 percent of its time executing
    just 10 percent of the available code. Therefore, we don't often need to optimize
    an entire application; we only need to locate the small fraction of the program
    that represents the real performance bottleneck.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试可以在几个集成级别进行。对于大型应用程序，使用整个构建进行性能测试可能并不完全有帮助。一个传统观点是，程序花费90%的时间执行仅有10%的可用代码。因此，我们通常不需要优化整个应用程序；我们只需要找到代表真正性能瓶颈的程序的一小部分。
- en: In some cases, it's clear that we have a data structure that involves a search.
    We know that removing the search will lead to a tremendous improvement in the
    performance. As we saw in [Chapter 5](ch05.html "Chapter 5. Using Callables and
    Contexts"), *Using Callables and Contexts*, implementing memoization can lead
    to dramatic performance improvements by avoiding recalculation.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，很明显我们有一个涉及搜索的数据结构。我们知道去除搜索将极大地提高性能。正如我们在[第5章](ch05.html "第5章。使用可调用和上下文")中看到的，通过实现记忆化，可以通过避免重新计算来实现显著的性能改进。
- en: 'In order to perform proper performance testing, we need to follow a three-step
    work cycle:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行适当的性能测试，我们需要遵循一个三步工作循环：
- en: Use a combination of design reviews and code profiling to locate the parts of
    the application that are likely to be a performance problem. Python has two profiling
    modules in the standard library. Unless there are more complex requirements, `cProfile`
    will locate the part of the application that requires focus.
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设计审查和代码分析的组合来找到可能是性能问题的应用程序部分。Python标准库中有两个分析模块。除非有更复杂的要求，`cProfile`将定位需要关注的应用程序部分。
- en: Create an automated test scenario with `unittest` to demonstrate any actual
    performance problem. Collect the performance data with `timeit` or `time.perf_counter()`.
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`unittest`创建一个自动化测试场景，以展示任何实际的性能问题。使用`timeit`或`time.perf_counter()`收集性能数据。
- en: Optimize the code for the selected test case until the performance is acceptable.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化选定测试用例的代码，直到性能可接受。
- en: The point is to automate as much as possible and avoid vaguely tweaking things
    in the hope of an improvement in the performance. Most of the time, a central
    data structure or algorithm (or both) must be replaced, leading to extensive refactoring.
    Having automated unit tests makes wholesale refactoring practical.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是尽可能自动化，并避免模糊地调整事物，希望性能会有所改善。大多数情况下，必须替换中心数据结构或算法（或两者），从而进行大规模重构。自动化单元测试使大规模重构成为可能。
- en: An awkward situation can arise when a performance test lacks specific pass-fail
    criteria. It may be necessary to make something *faster* without a concrete definition
    of *fast enough*. It's always simpler when there are measurable performance objectives;
    formal, automated testing can be used to assert both that the results are correct
    and that the time taken to get those results is acceptable.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 当性能测试缺乏具体的通过-失败标准时，可能会出现尴尬的情况。可能需要使某些东西*更快*，而没有*足够快*的明确定义。当有可衡量的性能目标时，情况总是更简单；正式的自动化测试可用于断言结果既正确，获取这些结果所花费的时间也是可接受的。
- en: 'For performance testing, we might use something like the following code:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能测试，我们可能会使用以下类似的代码：
- en: '[PRE87]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: This use of `unittest` gives us an automated performance test. As the `timeit`
    module executes the given statement 1,000,000 times, this should minimize the
    variability in the measurement from the background work on the computer that does
    the testing.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`unittest`进行自动化性能测试。由于`timeit`模块执行给定语句100万次，这应该最大程度地减少来自进行测试的计算机后台工作的测量变异性。
- en: In the preceding example, each execution of the RTD constructor is required
    to take less than 1/100,000 of a second. A million executions should take less
    than 10 seconds.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，RTD构造函数的每次执行都需要少于1/100,000秒。一百万次执行应该少于10秒。
- en: Summary
  id: totrans-559
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at using `unittest` and `doctest` to create automated unit tests.
    We also looked at creating a test suite so that collections of tests can be packaged
    for reuse and aggregation into suites with larger scopes, without relying on the
    automated test discovery process.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了如何使用`unittest`和`doctest`创建自动化单元测试。我们还看了如何创建一个测试套件，以便可以将测试集合打包以便重用，并将其聚合到具有更大范围的套件中，而不依赖于自动化测试发现过程。
- en: We looked at how to create mock objects so that we can test software units in
    isolation. We also looked at the various kinds of setup and teardown features.
    These allow us to write tests with complex initial states or persistent results.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了如何创建模拟对象，以便我们可以独立测试软件单元。我们还看了各种设置和拆卸功能。这些允许我们编写具有复杂初始状态或持久结果的测试。
- en: 'The **FIRST** properties of unit tests fit well with both `doctest` and `unittest`.
    The FIRST properties are as follows:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的**FIRST**属性与`doctest`和`unittest`都很匹配。FIRST属性如下：
- en: '**Fast**: Unless we write egregiously bad tests, the performance of `doctest`
    and `unitest` should be very fast.'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速**：除非我们编写了极其糟糕的测试，否则`doctest`和`unitest`的性能应该非常快。'
- en: '**Isolated**: The `unittest` package offers us a mock module that we can use
    to isolate our class definitions. In addition, we can exercise some care in our
    design to ensure that our components are isolated from each other.'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：`unittest`包为我们提供了一个可以用来隔离类定义的模拟模块。此外，我们可以在设计中小心处理，以确保我们的组件彼此隔离。'
- en: '**Repeatable**: Using `doctest` and `unittest` for automated testing ensures
    repeatability.'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重复**：使用`doctest`和`unittest`进行自动化测试可以确保可重复性。'
- en: '**Self-validating**: Both `doctest` and `unittest` bind the test results with
    the test case condition, ensuring that no subjective judgment is involved in testing.'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自我验证**：`doctest`和`unittest`都将测试结果与测试用例条件绑定，确保测试中不涉及主观判断。'
- en: '**Timely**: We can write and run the test cases as soon as we have the skeleton
    of a class, function, or module. A class whose body has simply `pass` is sufficient
    to run the test script.'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**及时**：我们可以在类、函数或模块的框架出现后立即编写和运行测试用例。一个只有`pass`的类主体就足以运行测试脚本。'
- en: For the purposes of project management, a count of written tests and passed
    tests is sometimes a very useful status report.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 对于项目管理的目的，编写的测试数量和通过的测试数量有时是非常有用的状态报告。
- en: Design considerations and trade-offs
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: Test cases are a required to be deliverable when creating software. Any feature
    that is without an automated test might as well not exist. A feature certainly
    can't be trusted to be correct if there's no test. If it can't be trusted, it
    shouldn't be used.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建软件时，测试用例是必需的交付内容。任何没有自动化测试的功能实际上就是不存在。如果没有测试，就不能相信功能是正确的。如果不能信任，就不应该使用。
- en: The only real trade-off question is whether to use `doctest` or `unittest` or
    both. For simple programming, `doctest` may be perfectly suitable. For more complex
    situations, `unittest` will be necessary. For frameworks where the API documentation
    needs to include examples, a combination works out well.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一真正的权衡问题是是否使用`doctest`或`unittest`或两者兼用。对于简单的编程，`doctest`可能非常合适。对于更复杂的情况，将需要`unittest`。对于需要包含示例的API文档的框架，组合效果很好。
- en: In some cases, simply creating a module full of `TestCase` class definitions
    may be sufficient. The `TestLoader` class and test discovery features may be perfectly
    adequate to locate all of the tests.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，简单地创建一个充满`TestCase`类定义的模块可能就足够了。`TestLoader`类和测试发现功能可能完全足够定位所有测试。
- en: More generally, `unittest` involves using `TestLoader` to extract multiple test
    methods from each `TestCase` subclass. We package the test methods into a single
    class based on who they can share class-level `setUp()`, and possibly with the
    `setUpClass()` methods.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，`unittest`涉及使用`TestLoader`从每个`TestCase`子类中提取多个测试方法。我们将测试方法打包到一个单一的类中，根据它们可以共享类级别的`setUp()`，可能还有`setUpClass()`方法。
- en: We can also create the `TestCase` instances without `TestLoader`. In this case,
    the default method of `runTest()` is defined to have the test case assertions.
    We can create a suite from instances of this kind of class.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在没有`TestLoader`的情况下创建`TestCase`实例。在这种情况下，默认的`runTest()`方法被定义为具有测试用例断言。我们可以从这种类的实例创建一个测试套件。
- en: The most difficult part can be designing for testability. Removing dependencies
    so that units can be tested independently can sometimes feel like adding to the
    level of software design complexity. In most cases, the time expended to expose
    dependencies is time invested in creating more maintainable and more flexible
    software.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 最困难的部分可能是为可测试性进行设计。消除依赖关系，使单元可以独立测试，有时会感觉增加软件设计复杂性的程度。在大多数情况下，暴露依赖关系所花费的时间是投入到创建更易维护和更灵活的软件中的时间。
- en: 'The general rule is this: *an implicit dependency among classes is bad design*.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 一般规则是：*类之间的隐式依赖关系是糟糕的设计*。
- en: A testable design has explicit dependencies; these can easily be replaced with
    mock objects.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 可测试的设计具有明确的依赖关系；这些可以很容易地用模拟对象替换。
- en: Looking forward
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: The next chapter will look at writing complete applications that are started
    from the command line. We'll look at ways to handle startup options, environment
    variables, and configuration files in Python applications.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将讨论从命令行启动的编写完整应用程序。我们将探讨在Python应用程序中处理启动选项、环境变量和配置文件的方法。
- en: In [Chapter 17](ch17.html "Chapter 17. The Module and Package Design"), *The
    Module and Package Design*, we'll expand on application design. We'll add the
    ability to compose applications into larger applications as well as decompose
    applications into smaller pieces.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第17章](ch17.html "第17章。模块和包设计")中，*模块和包设计*，我们将扩展应用程序设计。我们将增加将应用程序组合成更大的应用程序以及将应用程序分解成更小部分的能力。
- en: Chapter 16. Coping With the Command Line
  id: totrans-581
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章。应对命令行
- en: 'Command-line startup options, environment variables, and configuration files
    are important to many applications, particularly the implementation of servers.
    There are a number of ways of dealing with program startup and object creation.
    We''ll look at two issues in this chapter: argument parsing and the overall architecture
    for an application.'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行启动选项、环境变量和配置文件对许多应用程序都很重要，特别是服务器的实现。处理程序启动和对象创建有许多方法。在本章中，我们将讨论两个问题：参数解析和应用程序的总体架构。
- en: This chapter will extend the configuration file handling from [Chapter 13](ch13.html
    "Chapter 13. Configuration Files and Persistence"), *Configuration Files and Persistence*,
    with yet more techniques for command-line programs and the top-level of a server.
    It will also extend some logging design features from [Chapter 14](ch14.html "Chapter 14. The
    Logging and Warning Modules"), *The Logging and Warning Modules*.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从[第13章](ch13.html "第13章。配置文件和持久性")中的配置文件和持久性中扩展配置文件处理技术，涉及命令行程序和服务器的顶层。它还将扩展[第14章](ch14.html
    "第14章。日志和警告模块")中的一些日志设计特性，*日志和警告模块*。
- en: In the next chapter, we'll extend these principles to continue looking at a
    kind of architectural design that we'll call *programming in the Large*. We'll
    use the **Command** design pattern to define software components that can be aggregated
    without resorting to shell scripts. This is particularly helpful when writing
    the background processing components used by application servers.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展这些原则，继续研究一种我们将称之为*大规模编程*的架构设计。我们将使用**命令**设计模式来定义可以聚合而不依赖外壳脚本的软件组件。这在编写应用服务器使用的后台处理组件时特别有帮助。
- en: The OS interface and the command line
  id: totrans-585
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统接口和命令行
- en: 'Generally, the shell starts applications with several pieces of information
    that constitute the OS API:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，外壳启动应用程序时会提供OS API的几个信息：
- en: The shell provides each application its collection of environment variables.
    In Python, these are accessed through `os.environ`.
  id: totrans-587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外壳为每个应用程序提供了其环境变量的集合。在Python中，可以通过`os.environ`来访问这些变量。
- en: The shell prepares three standard files. In Python, these are mapped to `sys.stdin`,
    `sys.stdout`, and `sys.stderr`. There are some other modules such as `fileinput`
    that can provide access to `sys.stdin`.
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外壳准备了三个标准文件。在Python中，这些文件映射到`sys.stdin`、`sys.stdout`和`sys.stderr`。还有一些其他模块，如`fileinput`，可以提供对`sys.stdin`的访问。
- en: The command line is parsed by the shell into words. Parts of the command line
    are available in `sys.argv`. Python will provide some of the original command
    line; we'll look at the details in the following sections. For POSIX operating
    systems, the shell may replace shell environment variables and glob wildcard filenames.
    In Windows, the simple `cmd.exe` shell will not glob filenames for us.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外壳将命令行解析为单词。命令行的部分在`sys.argv`中可用。Python将提供一些原始命令行；我们将在以下部分中查看细节。对于POSIX操作系统，外壳可能会替换外壳环境变量和通配符文件名。在Windows中，简单的`cmd.exe`外壳不会为我们进行通配符文件名。
- en: The OS also maintains context settings such as the current working directory,
    user ID, and group. These are available through the `os` module. They aren't provided
    as arguments on the command line.
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作系统还维护上下文设置，如当前工作目录、用户ID和组。这些可以通过`os`模块获得。它们不是作为命令行参数提供的。
- en: The OS expects an application to provide a numeric status code when terminating.
    If we want to return a specific numeric code, we can use `sys.exit()` in our applications.
    Python will return a zero if our program is terminated normally.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统期望应用程序在终止时提供一个数字状态码。如果我们想返回一个特定的数字代码，我们可以在我们的应用程序中使用`sys.exit()`。如果我们的程序正常终止，Python将返回零。
- en: The shell's operation is an important part of this OS API. Given a line of input,
    the shell performs a number of substitutions, depending on the (rather complex)
    quoting rules and substitution options. It then parses the resulting line into
    space-delimited words. The first word must be either a built-in shell command
    (such as `cd` or `set`), or it must be the name of a file. The shell searches
    its defined `PATH` for this file.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 外壳的操作是OS API的重要部分。给定一行输入，外壳执行多个替换，取决于（相当复杂的）引用规则和替换选项。然后将生成的行解析为以空格分隔的单词。第一个单词必须是内置的外壳命令（如`cd`或`set`），或者必须是文件的名称。外壳会在其定义的`PATH`中搜索这个文件。
- en: The file named on the first word of a command must have `execute (x)` permission.
    The shell command, `chmod +x somefile.py`, marks a file as executable. A filename
    that matches but isn't executable gets an *OS Permission Denied error*.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的第一个单词必须具有`执行（x）`权限。外壳命令`chmod +x somefile.py`将文件标记为可执行。与之匹配但不可执行的文件会得到一个*OS权限被拒绝错误*。
- en: The first bytes of an executable file have a magic number that is used by the
    shell to decide how to execute that file. Some magic numbers indicate that the
    file is a binary executable; the shell can fork a subshell and execute it. Other
    magic numbers, specifically `b'#!'`, indicate that the file is properly a text
    script and requires an interpreter. The rest of the first line of this kind of
    file is the name of the interpreter.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 可执行文件的前几个字节有一个魔术数字，外壳用它来决定如何执行该文件。一些魔术数字表示文件是一个二进制可执行文件；外壳可以分叉一个子外壳并执行它。其他魔术数字，特别是`b'#!'`，表示文件是一个文本脚本，需要一个解释器。这种文件的第一行的其余部分是解释器的名称。
- en: 'We often use a line like this:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用这样的一行：
- en: '[PRE88]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: If a Python file has permission to execute, and has this as the first line,
    then the shell will run the `env` program. The `env` program's argument (`python3.3`)
    will cause it to set up an environment and run the Python3.3 program with the
    Python file as the first positional argument.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个Python文件有执行权限，并且作为第一行，那么外壳将运行`env`程序。`env`程序的参数（`python3.3`）将导致它设置一个环境并运行Python3.3程序，Python文件作为第一个位置参数。
- en: 'In effect, the conceptual sequence of steps from the OS shell via an executable
    script to Python looks like the following steps:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，从OS外壳通过可执行脚本到Python的概念上的步骤序列如下：
- en: 'The shell parses the `ourapp.py -s someinput.csv` line. The first word is `ourapp.py`.
    This file is on the shell''s `PATH` and has the `x` executable permission. The
    shell opens the file and finds the `#!` bytes. The shell reads the rest of this
    line and finds a new command: `/usr/bin/env python3.3`'
  id: totrans-599
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外壳解析了`ourapp.py -s someinput.csv`这一行。第一个单词是`ourapp.py`。这个文件在外壳的`PATH`上，并且具有`x`可执行权限。外壳打开文件并找到`#!`字节。外壳读取这一行的其余部分，并找到一个新的命令：`/usr/bin/env
    python3.3`。
- en: The shell parses the new `/usr/bin/env` command, which is a binary executable.
    So, the shell starts this program. This program, in turn, starts `python3.3`.
    The sequence of words from the original command line is provided to Python as
    part of the OS API.
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 外壳解析了新的`/usr/bin/env`命令，这是一个二进制可执行文件。因此，外壳启动了这个程序。这个程序又启动了`python3.3`。原始命令行的单词序列作为OS
    API的一部分提供给Python。
- en: Python will parse this sequence of words from the original command line to extract
    any options that are prior to the first argument. These first options are used
    by Python. The first argument is the Python filename to be run. This filename
    argument and all of the remaining words on the line will be saved separately in
    `sys.argv`.
  id: totrans-601
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python将从原始命令行中解析这个单词序列，以提取在第一个参数之前的任何选项。这些第一个选项由Python使用。第一个参数是要运行的Python文件名。这个文件名参数和行上剩下的所有单词将分别保存在`sys.argv`中。
- en: Python does its normal startup based on the options that have been found. Depending
    on the `-s` option, the `site` module may be used to setup the import path, `sys.path`.
    If we used the `-m` option, Python will use the `runpy` module to start our application.
    The given script files may be (re)compiled to byte code.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python根据找到的选项进行正常的启动。根据`-s`选项，可能会使用`site`模块来设置导入路径`sys.path`。如果我们使用了`-m`选项，Python将使用`runpy`模块启动我们的应用程序。给定的脚本文件可能会（重新）编译为字节码。
- en: Our application can make use of `sys.argv` to parse options and arguments with
    the `argparse` module. Our application can use environment variables in `os.environ`.
    It can also parse configuration files; see [Chapter 13](ch13.html "Chapter 13. Configuration
    Files and Persistence"), *Configuration Files and Persistence*, for more on this
    topic.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的应用程序可以利用`sys.argv`来使用`argparse`模块解析选项和参数。我们的应用程序可以在`os.environ`中使用环境变量。它还可以解析配置文件；有关此主题的更多信息，请参见[第13章](ch13.html
    "第13章。配置文件和持久性")，*配置文件和持久性*。
- en: On lacking a filename, the Python interpreter will read from standard input.
    If the standard input is a console (called a TTY in Linux parlance), then Python
    will enter **Read-Execute-Print Loop (REPL)** and display the `>>>` prompt. While
    we use this mode as developers, we don't generally make use of this mode for a
    finished application.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少文件名，Python解释器将从标准输入读取。如果标准输入是控制台（在Linux术语中称为TTY），那么Python将进入**读取-执行-打印循环（REPL）**并显示`>>>`提示符。虽然我们作为开发人员使用这种模式，但我们通常不会将这种模式用于成品应用程序。
- en: Another possibility is that standard input is a redirected file; for example,
    `python <some_file` or `some_app | python`. Both are valid but potentially confusing.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是标准输入是一个重定向的文件；例如，`python <some_file`或`some_app | python`。这两种都是有效的，但可能会令人困惑。
- en: Arguments and options
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数和选项
- en: In order to run programs, the shell parses a command line into words. This sequence
    of words is made available to all programs that are started. Generally, the first
    word of this sequence is the shell's understanding of the command. The remaining
    words on the command line are understood to be options and arguments.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行程序，shell将命令行解析为单词。这个单词序列对所有启动的程序都是可用的。通常，这个序列的第一个单词是shell对命令的理解。命令行上剩下的单词被理解为选项和参数。
- en: 'There are a number of guidelines to handle options and arguments. The essential
    rules are these:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些处理选项和参数的指导方针。基本规则如下：
- en: 'Options come first. They are preceded by `-` or `--`. There are two formats:
    `-letter` and `--word`. There are two species of options: options with no arguments
    and options with arguments. Examples of options without arguments are to use `-V`
    to show a version or use `--version` to show the version. An examples of options
    with arguments is `-m module`, where the `-m` option must be followed by a module
    name.'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选项首先出现。它们之前有`-`或`--`。有两种格式：`-letter`和`--word`。有两种类型的选项：没有参数的选项和带参数的选项。没有参数的选项的示例是使用`-V`显示版本或使用`--version`显示版本。带参数选项的示例是`-m
    module`，其中`-m`选项必须跟着模块名。
- en: Short format (single-letter) options with no option arguments can be grouped
    behind a single `-`. We might use `-bqv` to combine the `-b -q -v` options for
    convenience.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有选项参数的短格式（单字母）选项可以在单个`-`后面分组。我们可以使用`-bqv`来组合`-b -q -v`选项以方便使用。
- en: 'Arguments come last. They don''t have a leading `-` or `--`. There are two
    common kinds of arguments:'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数放在最后。它们没有前导`-`或`--`。有两种常见的参数：
- en: 'For positional arguments, the position is semantically significant. We might
    have two positional arguments: an input filename and an output filename. The order
    matters because the output file will be modified. When files will be overridden,
    simply distinguishing by position needs to be done carefully to prevent confusion.'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于位置参数，位置在语义上是重要的。我们可能有两个位置参数：输入文件名和输出文件名。顺序很重要，因为输出文件将被修改。当文件将被覆盖时，通过位置进行简单区分需要小心以防止混淆。
- en: A list of arguments, all of which are semantically equivalent. We might have
    arguments that are all the names of input files. This fits nicely with the way
    the shell performs filename globbing. When we say `process.py *.html`, the `*.html`
    command is expanded by the shell to filenames that become the positional parameters.
    (This doesn't work in Windows, so the `glob` module must be used.)
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列参数的列表，它们在语义上是等价的。我们可能有所有输入文件名称的参数。这与shell执行文件名通配符的方式非常匹配。当我们说`process.py
    *.html`时，shell将`*.html`命令扩展为成为位置参数的文件名。（这在Windows中不起作用，因此必须使用`glob`模块。）
- en: There are still more details. For more information on command-line options,
    see [http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02).
    The Python command line has 12 or so options that can control some details of
    Python's behavior. See the *Python Setup and Usage* document for more information
    on what these options are. The positional argument to the Python command is the
    name of the script to be run; this will be our application's top-most file.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多细节。有关命令行选项的更多信息，请参见[http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html#tag_12_02)。Python命令行有大约12个选项，可以控制Python行为的一些细节。有关这些选项的更多信息，请参见*Python设置和用法*文档。Python命令的位置参数是要运行的脚本的名称；这将是我们应用程序的顶层文件。
- en: Parsing the command line with argparse
  id: totrans-615
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用argparse解析命令行
- en: The general approach to using `argparse` involves four steps.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`argparse`的一般方法包括四个步骤。
- en: Create `ArgumentParser`. We can provide you with overall information about the
    command-line interface here. This might include a description, format changes
    for the displayed options and arguments, and whether or not `-h` is the "help"
    option. Generally, we only need to provide the description; the rest of the options
    have sensible defaults.
  id: totrans-617
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`ArgumentParser`。我们可以在这里提供关于命令行界面的整体信息。这可能包括描述、显示选项和参数的格式更改，以及`-h`是否是“帮助”选项。通常，我们只需要提供描述；其余选项都有合理的默认值。
- en: Define the command-line options and arguments. This is done by adding arguments
    with the `ArgumentParser.add_argument()` method function.
  id: totrans-618
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义命令行选项和参数。这是通过使用`ArgumentParser.add_argument()`方法函数添加参数来完成的。
- en: Parse the `sys.argv` command line to create a namespace object that details
    the options, option arguments and overall command-line arguments.
  id: totrans-619
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析`sys.argv`命令行以创建一个详细描述选项、选项参数和整体命令行参数的命名空间对象。
- en: Use the resulting namespace object to configure the application and process
    the arguments. There are a number of alternative approaches to handle this gracefully.
    It may involve parsing configuration files, as well as command-line options. We'll
    look at several designs.
  id: totrans-620
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用生成的命名空间对象来配置应用程序并处理参数。有许多替代方法来优雅地处理这个问题。这可能涉及解析配置文件，以及命令行选项。我们将看几种设计。
- en: An important feature of `argparse` is that it provides us with a unified view
    of options and arguments. The principle difference between the two is the number
    of times they can occur. Options are—well—optional and can occur zero or one time.
    Arguments generally occur one or more times.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '`argparse`的一个重要特性是它为我们提供了对选项和参数的统一视图。两者之间的主要区别在于它们出现的次数。选项是可选的，可以出现零次或一次。参数通常出现一次或多次。'
- en: 'We can create a parser as easily as the following code:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面的代码一样轻松地创建一个解析器：
- en: '[PRE89]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We provided the description, as there''s no good default value for that. Here
    are some common patterns to define the command-line API for an application:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了描述，因为对于这个没有很好的默认值。以下是定义应用程序的命令行API的一些常见模式：
- en: '**A simple on-off option**: We''ll often see this as a `-v` or `--verbose`
    option'
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个简单的开关选项：我们经常会将其表示为`-v`或`--verbose`选项
- en: '**An option with an argument**: This might be a `-s '',''` or `–separator ''|''`
    option'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带参数的选项**：这可能是一个`-s '',''`或`–separator ''|''`选项'
- en: '**A positional argument**: This might be used when we have an input file and
    an output file as command-line arguments'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个位置参数**：当我们有一个输入文件和一个输出文件作为命令行参数时，可以使用这个选项'
- en: '**All other arguments**: We''d use these when we have a list of input files'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有其他参数**：当我们有一个输入文件列表时，我们会使用这些参数'
- en: '**--version**: This is a special option to display the version number and exit'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--version**：这是一个特殊选项，用于显示版本号并退出'
- en: '**--help**: This option will display the help and exit. This is a default,
    we don''t need to do anything to make this happen'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**--help**：此选项将显示帮助信息并退出。这是一个默认选项，我们不需要做任何事情来实现它'
- en: 'Once the arguments have been defined, we can parse them and use them. Here''s
    how we parse them:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦参数被定义，我们就可以解析它们并使用它们。以下是我们如何解析它们的方法：
- en: '[PRE90]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The `config` object is an `argparse.Namespace` object; the class is similar
    to `types.SimpleNamespace`. It will have a number of attributes, and we can easily
    add more attributes to this object.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '`config`对象是一个`argparse.Namespace`对象；该类类似于`types.SimpleNamespace`。它将具有许多属性，我们可以很容易地向该对象添加更多属性。'
- en: We'll look at each of these six common kinds of arguments individually. There
    are a lot of clever and sophisticated parsing options available in the `ArgumentParser`
    class. Most of them go beyond the simplistic guidelines commonly suggested for
    command-line argument processing. In general, we should avoid the kind of super-complex
    options that characterize programs such as `find`. When the options get terribly
    complex, we may have drifted into creating a domain-specific language on top of
    Python. Why not just use Python?
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分别查看这六种常见类型的参数。`ArgumentParser`类中提供了许多聪明和复杂的解析选项。其中大多数超出了常见的命令行参数处理的简单指南。一般来说，我们应该避免那种像`find`这样的程序所特有的超级复杂选项。当选项变得非常复杂时，我们可能已经开始在Python之上创建领域特定语言。为什么不直接使用Python呢？
- en: A simple on/off option
  id: totrans-635
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的开关选项
- en: 'We''ll define a simple on-off option with the one-letter short name, we can
    also provide a longer name; we should also provide an explicit action. We might
    want to provide a destination variable if we omit the longer name or the longer
    name is unpleasant as a Python variable:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个字母的短名称定义一个简单的开关选项，我们也可以提供一个更长的名称；我们还应该提供一个明确的动作。如果我们省略了更长的名称或更长的名称作为Python变量不好，我们可能需要提供一个目标变量：
- en: '[PRE91]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'This will define the long and short versions of the command-line option. If
    the option is present, it will set the `verbose` option to `True`. If the option
    is absent, the verbose option will default to `False`. Here are some common variations
    of this theme:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义命令行选项的长版本和短版本。如果选项存在，它将将`verbose`选项设置为`True`。如果选项不存在，verbose选项将默认为`False`。以下是这个主题的一些常见变化：
- en: We might change the action to `'store_false'` with a default of `True`.
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将动作更改为`'store_false'`，默认值为`True`。
- en: Sometimes, we'll have a default of `None` instead of `True` or `False`.
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们的默认值可能是`None`，而不是`True`或`False`。
- en: Sometimes, we'll use an action of `'store_const'` with an additional `const=`
    argument. This allows us to move beyond simple Boolean values and store things
    such as logging levels or other objects.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时，我们会使用`'store_const'`的动作，并陦加一个`const=`参数。这使我们能够超越简单的布尔值，并存储诸如日志级别或其他对象之类的东西。
- en: We might also have an action of `'count'`, which allows the option to get repeated,
    increasing the count. In this case, the default is often zero.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可能还会使用`'count'`的动作，这允许选项重复出现，增加计数。在这种情况下，默认值通常为零。
- en: 'If we''re using the logger, we might define a debugging option like the following
    code:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用记录器，我们可以定义一个调试选项，如下面的代码：
- en: '[PRE92]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We changed the action to `store_const`, which stores a constant value and provides
    a specific constant value of `logging.DEBUG`. This means that the resulting options
    object will directly provide the value needed to configure the root logger. We
    can then simply configure the logger using `config.logging_level` without any
    further mapping or conditional processing.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将操作更改为`store_const`，它存储一个常量值并提供`logging.DEBUG`的特定常量值。这意味着生成的选项对象将直接提供配置根记录器所需的值。然后我们可以简单地使用`config.logging_level`配置记录器，而无需进一步的映射或条件处理。
- en: An option with an argument
  id: totrans-646
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带参数的选项
- en: 'We''ll define an option that has an argument with the long and optional short
    name. We''ll provide an action that stores the value provided with the argument.
    We can also provide a type conversion, in case we want `float` or `int` values
    instead of a string:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个带有长名称和可选短名称的参数的选项。我们将提供一个存储提供的参数值的操作。我们还可以提供类型转换，以防我们想要`float`或`int`值而不是字符串：
- en: '[PRE93]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The first example will define two versions of the command-line syntax, both
    long and short. When parsing the command-line argument values, a string value
    must follow the option, and it must be from the available choices. The destination
    name, `betting_rule`, will receive the option's argument string.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个例子将定义命令行语法的两个版本，长的和短的。在解析命令行参数值时，一个字符串值必须跟在选项后面，并且必须来自可用的选择。目标名称`betting_rule`将接收选项的参数字符串。
- en: The second example also defines two versions of the command-line syntax; it
    includes a type conversion. When parsing argument values, this will store an integer
    value that follows the option. The long name, `stake`, will be the value in the
    options object created by the parser.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个例子还定义了命令行语法的两个版本；它包括类型转换。在解析参数值时，这将存储跟在选项后面的整数值。长名称`stake`将成为解析器创建的选项对象中的值。
- en: In some cases, there may be a list of values associated with the argument. In
    this case, we may provide a `nargs="+"` option to collect multiple values separated
    by spaces into a list.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能会有与参数相关联的值列表。在这种情况下，我们可以提供一个`nargs="+"`选项，以便将由空格分隔的多个值收集到一个列表中。
- en: Positional arguments
  id: totrans-652
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: 'We define positional arguments using a name with no "`-`" decoration. In the
    case where we have a fixed number of positional arguments, we''ll add them appropriately
    to the parser:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用没有"`-`"修饰的名称定义位置参数。在我们有固定数量的位置参数的情况下，我们将适当地将它们添加到解析器中：
- en: '[PRE94]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: When parsing argument values, the two positional argument strings will be stored
    into the final namespace object. We can use `config.input_filename` and `config.output_filename`
    to work with these argument values.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 在解析参数值时，两个位置参数字符串将被存储到最终的命名空间对象中。我们可以使用`config.input_filename`和`config.output_filename`来处理这些参数值。
- en: All other arguments
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有其他参数
- en: 'We define argument lists with a name that has no `-` decoration and a piece
    of advice in the `nargs`= parameter. If the rule is one-or-more argument values,
    we specify `nargs="+"`. If the rule is zero-or-more argument values, we specify
    `nargs="*"`. If the rule is *optional*, we specify `nargs="?"`. This will collect
    all other argument values into a single sequence in the resulting namespace:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用没有`-`修饰的名称和`nargs`参数中的一条建议来定义参数列表。如果规则是一个或多个参数值，我们指定`nargs="+"`。如果规则是零个或多个参数值，我们指定`nargs="*"`。如果规则是*可选的*，我们指定`nargs="?"`。这将把所有其他参数值收集到结果命名空间中的一个序列中：
- en: '[PRE95]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: When the list of filenames is optional, it generally means that `STDIN` or `STDOUT`
    will be used if no specific filenames are provided.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件名列表是可选的时，通常意味着如果没有提供特定的文件名，将使用`STDIN`或`STDOUT`。
- en: If we specify `nargs=`, then the result becomes a list. If we specify `nargs=1`,
    then the resulting object is a one-element list. If we omit `nargs`, then the
    result is just the single value that was provided.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们指定了`nargs=`，那么结果将变成一个列表。如果我们指定了`nargs=1`，那么结果对象将是一个单元素列表。如果我们省略了`nargs`，那么结果就是提供的单个值。
- en: 'Creating a list (even if it has only one element) is handy because we might
    want to process the arguments in this manner:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个列表（即使它只有一个元素）很方便，因为我们可能希望以这种方式处理参数：
- en: '[PRE96]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'In some cases, we may want to provide a sequence of input files that includes
    `STDIN`. The common convention for this is a filename of `-` as an argument. We''ll
    have to handle this within our application with something like the following code:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望提供一个包括`STDIN`的输入文件序列。这种情况的常见约定是将文件名`-`作为参数。我们将不得不在我们的应用程序中处理这个，使用以下代码之类的东西：
- en: '[PRE97]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This shows us a loop that will attempt to handle a number of filenames, potentially
    including `-` to show when to process standard input among a list of files. A
    `try:` block should probably be used around the `with` statement.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了一个循环，将尝试处理多个文件名，可能包括`-`以显示何时在文件列表中处理标准输入。`try:`块可能应该在`with`语句周围使用。
- en: --version display and exit
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --version 显示并退出
- en: 'An option to display the version number is so common that there''s a special
    shortcut to show us the version information:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 显示版本号的选项是如此常见，以至于有一个特殊的快捷方式来显示版本信息：
- en: '[PRE98]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This example assumes that we have a global module `__version__= "3.3.2"` somewhere
    in the file. This special `action="version"` will have the side effect of exiting
    the program after displaying the version information.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子假设我们在文件的某个地方有一个全局模块`__version__= "3.3.2"`。这个特殊的`action="version"`将在显示版本信息后退出程序。
- en: --help display and exit
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: --help 显示并退出
- en: An option to display help is a default feature of `argparse`. Another special
    case allows us to change the `help` option from the default setting of`-h` or
    `--help`. This requires two things. First, we must create the parser with `add_help=False`.
    This will turn off the built-in `-h`, `--help` feature. After doing that, we will
    add the argument that we want to use (for example, `'-?'`) with `action="help"`.
    This will display the help text and exit.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 显示帮助的选项是`argparse`的默认功能。另一个特殊情况允许我们更改`help`选项的默认设置为`-h`或`--help`。这需要两件事。首先，我们必须使用`add_help=False`创建解析器。这将关闭内置的`-h`，`--help`功能。之后，我们将添加我们想要使用的参数（例如`'-?'`），并使用`action="help"`。这将显示帮助文本并退出。
- en: Integrating command-line options and environment variables
  id: totrans-672
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成命令行选项和环境变量
- en: The general policy for environment variables is that they are configuration
    inputs, similar to command-line options and arguments. For the most part, we use
    environment variables for settings that rarely change. We'll often set them via
    the `.bashrc` or `.bash_profile` files so that the values apply every time we
    log in. We may set the environment variables more globally in an `/etc/bashrc`
    file so that they apply to all users. We can also set environment variables on
    the command line, but these settings only last as long as the session is logged
    in.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的一般政策是它们是配置输入，类似于命令行选项和参数。在大多数情况下，我们使用环境变量来设置很少更改的设置。我们经常通过`.bashrc`或`.bash_profile`文件设置它们，以便每次登录时都适用这些值。我们还可以在`/etc/bashrc`文件中更全局地设置环境变量，以便它们适用于所有用户。我们也可以在命令行上设置环境变量，但这些设置只在会话登录期间持续。
- en: In some cases, all of our configuration settings can be provided on the command
    line. In this case, the environment variables could be used as a kind of backup
    syntax for slowly changing variables.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们所有的配置设置都可以在命令行上提供。在这种情况下，环境变量可以用作慢慢变化的变量的备用语法。
- en: In other cases, the configuration values we provide may be segregated into settings
    provided by environment variables different from settings provided by command-line
    options. We may need to get some values from the environment and merge in values
    that come from the command line.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们提供的配置值可能被分隔成由环境变量提供的设置和由命令行选项提供的设置。我们可能需要从环境中获取一些值，并合并来自命令行的值。
- en: 'We can leverage environment variables to set the default values in a configuration
    object. We want to gather these values prior to parsing the command-line arguments.
    This way, command-line arguments can override environment variables. There are
    two common approaches to this:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用环境变量来设置配置对象中的默认值。我们希望在解析命令行参数之前收集这些值。这样，命令行参数可以覆盖环境变量。有两种常见的方法：
- en: '**Explicitly setting the values when defining the command-line options**: This
    has the advantage of making the default value show up in the help message. It
    only works for environment variables that overlap with command-line options. We
    might do something like this to use the `SIM_SAMPLES` environment variable to
    provide a default value that can be overridden:'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在定义命令行选项时明确设置值**：这样做的好处是默认值会显示在帮助消息中。这仅适用于与命令行选项重叠的环境变量。我们可以这样做，使用`SIM_SAMPLES`环境变量提供一个可以被覆盖的默认值：'
- en: '[PRE99]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '**Implicitly setting the values as part of the parsing process**: This makes
    it simple to merge environment variables with command-line options into a single
    configuration. We can populate a namespace with default values and then overwrite
    it with the parsed values from the command line. This provides us with three levels
    of option values: the default defined in the parser, an override value seeded
    into the namespace, and finally, any override value provided on the command line.'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐式设置值作为解析过程的一部分**：这样可以简单地将环境变量与命令行选项合并为单个配置。我们可以用默认值填充命名空间，然后用来自命令行解析的值覆盖它。这为我们提供了三个级别的选项值：解析器中定义的默认值，种子到命名空间的覆盖值，最后是命令行提供的任何覆盖值。'
- en: '[PRE100]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note
  id: totrans-681
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The argument parser can perform type conversions for values that are not simple
    strings. Gathering environment variables, however, doesn't automatically involve
    a type conversion. For options that have non-string values, we must perform the
    type conversion in our application.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 参数解析器可以执行非简单字符串的值的类型转换。然而，收集环境变量并不自动涉及类型转换。对于具有非字符串值的选项，我们必须在应用程序中执行类型转换。
- en: Providing more configurable defaults
  id: totrans-683
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供更多可配置的默认值
- en: 'We can incorporate configuration files along with environment variables and
    the command-line options. This gives us three ways to provide a configuration
    to an application program:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将配置文件与环境变量和命令行选项一起使用。这为我们提供了三种向应用程序提供配置的方式：
- en: A hierarchy of configuration files can provide defaults values. See [Chapter
    13](ch13.html "Chapter 13. Configuration Files and Persistence"), *Configuration
    Files and Persistence*, for examples on the ways to do this.
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件的层次结构可以提供默认值。参见[第13章](ch13.html "第13章 配置文件和持久性")，“配置文件和持久性”，有关如何执行此操作的示例。
- en: Environment variables can provide overrides to the configuration files. This
    may mean translating from an environment variable namespace to the configuration
    namespace.
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境变量可以提供对配置文件的覆盖。这可能意味着从环境变量命名空间转换为配置命名空间。
- en: The command-line options define the final overrides.
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行选项定义了最终的覆盖。
- en: Using all three may be too much of a good thing. Tracking down a setting can
    become murky if there are too many places to search. The final decision on the
    configuration often rests on staying consistent with the overall collection of
    applications and frameworks. We should strive to make our programming fit seamlessly
    with other components.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用这三种方式可能过于繁琐。如果有太多地方可以搜索，查找设置可能变得混乱。关于配置的最终决定通常取决于与整体应用程序和框架的一致性。我们应该努力使我们的编程与其他组件无缝配合。
- en: We'll look at two minor variations on this theme. The first example shows us
    how we can have environment variables that override configuration file settings.
    The second example shows us configuration files that override global environment
    variable settings.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看两个与此主题有关的小变化。第一个示例向我们展示了如何使用环境变量覆盖配置文件设置。第二个示例向我们展示了配置文件覆盖全局环境变量设置。
- en: Overriding configuration file settings with environment variables
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用环境变量覆盖配置文件设置
- en: 'We''ll use a three-stage process to incorporate environment variables and consider
    them more important than configuration file settings. First, we''ll build some
    default settings from the environment variables:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个三阶段过程来整合环境变量，并认为它们比配置文件设置更重要。首先，我们将从环境变量构建一些默认设置：
- en: '[PRE101]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Creating a mapping like this has the effect of rewriting the external environment
    variable names (`SOMEAPP_VARNAME`) into internal configuration names (`attribute_name`)
    that will match our application's configuration attributes. For environment variables
    that were not defined, we'll get `None` as the default value. We'll filter these
    out later.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这样的映射会将外部环境变量名称（`SOMEAPP_VARNAME`）重写为内部配置名称（`attribute_name`），这将与我们应用程序的配置属性匹配。对于未定义的环境变量，我们将得到`None`作为默认值。我们稍后会将这些过滤掉。
- en: 'Next, we''ll parse a hierarchy of configuration files to gather the background
    configuration:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将解析一系列配置文件的层次结构，以收集背景配置：
- en: '[PRE102]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We built a list of locations, in priority order from the most important (owned
    by the user) to the least important (part of the installation.) For each file
    that actually exists, we parsed the content to create a mapping from names to
    values. We relied on the YAML notation, as it's flexible and easy for people to
    work with.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按优先顺序构建了一个位置列表，从最重要的（用户拥有的）到最不重要的（安装的一部分）。对于每个实际存在的文件，我们解析内容以创建从名称到值的映射。我们依赖于YAML表示法，因为它灵活且易于人们使用。
- en: 'We can build instance of a `ChainMap` object from these sources:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这些来源构建`ChainMap`对象的实例：
- en: '[PRE103]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: We combined the various mappings into a single `ChainMap`. The environment variables
    are searched first. When values are present there, the values are looked up from
    the user's configuration file first and then other configurations, if the user
    configuration file didn't provide a value.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将各种映射组合成一个单一的`ChainMap`。首先搜索环境变量。当值存在时，首先从用户的配置文件中查找这些值，然后查找其他配置，如果用户配置文件没有提供值。
- en: 'We can use the following code to parse the command-line arguments and update
    these defaults:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码来解析命令行参数并更新这些默认值：
- en: '[PRE104]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We transformed our `ChainMap` of configuration file settings into an `argparse.Namespace`
    object. Then, we parsed the command-line options to update that namespace object.
    As the environment variables are first in `ChainMap`, they override any configuration
    files.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的配置文件设置的`ChainMap`转换为`argparse.Namespace`对象。然后，我们解析命令行选项以更新该命名空间对象。由于环境变量在`ChainMap`中排在第一位，它们会覆盖任何配置文件。
- en: Overriding environment variables with the configuration files
  id: totrans-703
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用配置文件覆盖环境变量
- en: 'Some applications use environment variables as the foundational defaults that
    can be overridden by configuration files. In this case, we will change the order
    to build `ChainMap`. In the previous example, we put the environment variables
    first. We can put `env_config` in `defaults.maps` last to make it the final fallback:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序使用环境变量作为可以被配置文件覆盖的基础默认值。在这种情况下，我们将改变构建`ChainMap`的顺序。在先前的示例中，我们首先放置了环境变量。我们可以将`env_config`放在`defaults.maps`的最后，使其成为最终的后备：
- en: '[PRE105]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Finally, we can use the following code to parse the command-line arguments
    and update these defaults:'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用以下代码来解析命令行参数并更新这些默认值：
- en: '[PRE106]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: We transform our `ChainMap` of configuration file settings into an `argparse.Namespace`
    object. Then, we parse the command-line options to update that namespace object.
    As the environment variables are last in `ChainMap`, they provide any values that
    are missing from the configuration files.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将我们的配置文件设置的`ChainMap`转换为`argparse.Namespace`对象。然后，我们解析命令行选项以更新该命名空间对象。由于环境变量在`ChainMap`中排在最后，它们提供了配置文件中缺失的任何值。
- en: Making the configuration aware of the None values
  id: totrans-709
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使配置了解`None`值
- en: This three-stage process to set the environment variables includes many common
    sources of parameters and configuration settings. We don't always need environment
    variables, configuration files, and command-line options. Some applications may
    only need a subset of these techniques.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量的这个三阶段过程包括许多常见的参数和配置设置来源。我们并不总是需要环境变量、配置文件和命令行选项。一些应用程序可能只需要这些技术的子集。
- en: 'We often need type conversions that will preserve the `None` values. Keeping
    the `None` values will ensure that we can tell when an environment variable was
    not set. Here''s a more sophisticated type conversion that is `None-aware`:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要类型转换，以保留`None`值。保留`None`值将确保我们可以知道环境变量未设置时。以下是一个更复杂的类型转换，它是`None-aware`的：
- en: '[PRE107]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'We can use this `nint()` conversion in the following context to gather the
    environment variables:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下上下文中使用`nint()`转换来收集环境变量：
- en: '[PRE108]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: If an environment variable is not set, a default of `None` will be used. If
    the environment variable is set, then the value will be converted to an integer.
    In later processing steps, we can depend on the `None` value to build a dictionary
    from only the proper values that are not `None`.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 如果环境变量未设置，将使用默认值`None`。如果环境变量已设置，则将值转换为整数。在后续处理步骤中，我们可以依赖`None`值来仅从正确的值构建字典，而不是`None`。
- en: Customizing the help output
  id: totrans-716
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义帮助输出
- en: 'Here''s some typical output that comes directly from the default `argparse.print_help()`
    code:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是直接来自默认`argparse.print_help()`代码的一些典型输出：
- en: '[PRE109]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The default help text is built from four things in our parser definition:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 默认帮助文本是从我们的解析器定义中的四个部分构建的：
- en: The usage line is a summary of the options. We can replace the default calculation
    with our own usage text that omits the less commonly used details.
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用行是选项的摘要。我们可以用我们自己的使用文本替换默认的计算，省略不常用的细节。
- en: This is followed by the description. By default, the text we provide is cleaned
    up a bit. In this example, we provided a shabby two-word description, so there's
    no obvious cleanup.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接着是描述。默认情况下，我们提供的文本会被清理一下。在这个例子中，我们提供了一个简陋的两个词的描述，所以没有明显的清理。
- en: Then, the arguments are shown. First the positional arguments and then the options,
    in the order that we defined them.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后显示参数。首先是位置参数，然后是选项，按照我们定义的顺序。
- en: After this, an optional epilog text is shown.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后显示可选的结语文本。
- en: 'In some cases, this kind of terse reminder is adequate. In other cases, however,
    we may need to provide more details. We have three tiers of support for more detailed
    help:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这种简洁的提醒是足够的。然而，在其他情况下，我们可能需要提供更多的细节。我们有三个支持更详细帮助的层次：
- en: '**Add help= to the argument definitions**: This is the place to start when
    customizing the help details'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在参数定义中添加help=**：这是定制帮助细节的起点'
- en: '**Use one of the other help formatter classes that create better-looking output**:
    This is done with the `formatter_class=` argument when building `ArgumentParser`.
    Note that `ArgumentDefaultsHelpFormatter` requires `help=` for an argument definition;
    it will add the default to the help text that we supply.'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用其他帮助格式化类之一，创建更美观的输出**：这是在构建`ArgumentParser`时使用`formatter_class=`参数完成的。请注意，`ArgumentDefaultsHelpFormatter`需要为参数定义添加`help=`；它将在我们提供的帮助文本中添加默认值。'
- en: '**Extend the ArgumentParser class and override the print_usage() and print_help()
    methods**: We can always write a new help formatter as well. If we have options
    so complex that this is required, perhaps we''ve gone too far.'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展ArgumentParser类并覆盖print_usage()和print_help()方法**：我们也可以编写一个新的帮助格式化程序。如果我们的选项太复杂，需要这样做，也许我们已经走得太远。'
- en: Our goal is to improve usability. Even if our programs work correctly, we can
    build trust by providing command-line support that makes our program easier to
    use.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是提高可用性。即使我们的程序工作正常，我们也可以通过提供命令行支持来建立信任，使我们的程序更易于使用。
- en: Creating a top-level main() function
  id: totrans-729
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个顶层main()函数
- en: 'In [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*, we suggested two application configuration
    design patterns:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第13章](ch13.html "第13章。配置文件和持久性")中，*配置文件和持久性*，我们提出了两种应用程序配置设计模式：
- en: '**The global property map**: In the previous examples, we implemented the global
    property map with a `Namespace` object created by `ArgumentParser`.'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局属性映射**：在前面的例子中，我们使用`ArgumentParser`创建的`Namespace`对象实现了全局属性映射。'
- en: '**Object construction**: The idea behind object construction was to build the
    required object instances from the configuration parameters, effectively demoting
    the global property map to a local property map inside the `main()` function and
    not saving the properties.'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象构建**：对象构建的想法是从配置参数构建所需的对象实例，有效地将全局属性映射降级为`main()`函数内的本地属性映射，并不保存属性。'
- en: What we showed you in the previous section was the use of a local `Namespace`
    object to collect all of the parameters. From this, we can build the necessary
    application objects that will do the real work of the application. The two design
    patterns aren't a dichotomy; they're complementary. We used `Namespace` to accumulate
    a consistent set of values and then built the various objects based on the values
    in that namespace.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们向您展示了使用本地`Namespace`对象收集所有参数。从这里，我们可以构建必要的应用程序对象，这些对象将完成应用程序的实际工作。这两种设计模式并不是二分法；它们是互补的。我们使用`Namespace`积累了一致的值集，然后基于该命名空间中的值构建了各种对象。
- en: 'This leads us to a design for a top-level function. Before looking at the implementation,
    we need to consider a proper name for this function; there are two ways to name
    the function:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 这引导我们设计一个顶层函数。在看实现之前，我们需要考虑一个合适的函数名称；有两种方法来命名函数：
- en: Name it `main()` because that's a common term for the starting point of the
    application as a whole
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其命名为`main()`，因为这是应用程序整体起点的常用术语
- en: Don't name it `main()` because `main()` is too vague to be meaningful in the
    long run
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要将其命名为`main()`，因为`main()`太模糊，从长远来看没有意义
- en: We think this is not a dichotomy either, and we should do two things. Define
    a top-level function with a name that's a `verb_noun()` phrase that describes
    the operation fairly. Add a line `main= verb_noun` to provide a `main()` function
    that helps other developers see how the application works.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为这也不是一个二分法，我们应该做两件事。定义一个名为`verb_noun()`的顶层函数，描述操作。添加一行`main= verb_noun`来提供一个`main()`函数，帮助其他开发人员了解应用程序的工作方式。
- en: This two-part implementation lets us change the definition of `main()` through
    extension. We can add functions and reassign the name `main`. Old function names
    are left in place as part of a stable, growing API.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这个两部分的实现让我们通过扩展来改变`main()`的定义。我们可以添加函数并重新分配名称`main`。旧的函数名称保留在原地，作为一个稳定的、不断增长的API的一部分。
- en: 'Here''s a top-level application script that builds objects from a configuration
    `Namespace` object:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个顶层应用程序脚本，它从配置`Namespace`对象构建对象。
- en: '[PRE110]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: This function depends on an externally supplied `Namespace` object with the
    configuration attributes. It's not named `main()` so that we can make future changes
    that would change the meaning of `main`.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数依赖于外部提供的带有配置属性的`Namespace`对象。它没有命名为`main()`，这样我们可以进行未来更改，改变`main`的含义。
- en: We built the various objects—`Table`, `Player`, `Simulate`—that are required.
    We configured these objects with the initial values based on the configuration
    parameters.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了各种对象——`Table`、`Player`、`Simulate`——这是必需的。我们根据配置参数的初始值配置了这些对象。
- en: 'We''ve actually done the real work. After all of the object construction, the
    actual work is a single, highlighted line: `wtr.writerows( simulate )`. 90 percent
    of the program''s time will be spent here, generating samples and writing them
    to the required file.'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上已经完成了真正的工作。在所有对象构造之后，实际工作是一行突出显示的代码：`wtr.writerows( simulate )`。程序的90%时间将在这里度过，生成样本并将其写入所需的文件。
- en: A similar pattern holds for GUI applications. They enter a main loop to process
    GUI events. The pattern also holds for servers that enter a main loop to process
    requests.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: GUI应用程序也适用类似的模式。它们进入一个主循环来处理GUI事件。这种模式也适用于进入主循环以处理请求的服务器。
- en: 'We''ve depended on having a configuration object passed in as an argument.
    This follows from our testing strategy of minimizing dependencies. This top-level
    `simulate_blackjack()` function doesn''t depend on the details of how the configuration
    was created. We can then use this function in an application script:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖于将配置对象作为参数传递。这符合我们最小化依赖关系的测试策略。这个顶层的`simulate_blackjack()`函数不依赖于配置是如何创建的细节。然后我们可以在应用程序脚本中使用这个函数：
- en: '[PRE111]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This represents a separation of concerns. We've nested the work of the application
    into two levels of enclosure.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了关注点的分离。我们将应用程序的工作嵌套到了两个封装级别中。
- en: The outer level of enclosure is defined by logging. We configured logging outside
    of all other application components to ensure that there are no conflicts among
    various top-level modules, classes, or functions attempting to configure logging.
    If any particular portion of the application attempts to configure logging, then
    making changes can lead to conflicts. In particular, when we look at combining
    applications into larger composite processing, we need to be sure that the two
    applications being combined don't make conflicting logging configurations.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 外层封装由日志定义。我们在所有其他应用程序组件之外配置日志，以确保各种顶层模块、类或函数之间没有冲突尝试配置日志。如果应用程序的特定部分尝试配置日志，那么进行更改可能会导致冲突。特别是当我们考虑将应用程序合并到更大的复合处理中时，我们需要确保两个被合并的应用程序不会产生冲突的日志配置。
- en: The inner level of enclosure is defined by the application's configuration.
    We don't want conflicts among separate application components. We'd like to allow
    our command-line API to evolve separately from our application. We'd like to be
    able to embed our application processing into separate environments, perhaps defined
    by `multiprocessing` or a RESTful web server.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 内层封装由应用程序的配置定义。我们不希望在单独的应用程序组件之间发生冲突。我们希望允许我们的命令行API与我们的应用程序分开发展。我们希望能够将应用程序处理嵌入到单独的环境中，可能由`multiprocessing`或RESTful
    web服务器定义。
- en: Ensuring DRY for the configuration
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保配置的DRY
- en: We have a potential DRY issue between our construction of the argument parser
    and the use of the arguments to configure the application. We built the arguments
    using some keys that are repeated.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建参数解析器和使用参数配置应用程序之间存在潜在的DRY问题。我们使用了一些重复的键来构建参数。
- en: 'We can eliminate this repetition by creating some global internal configurations.
    For example, we might define this global as shown:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一些全局内部配置来消除这种重复。例如，我们可以定义这个全局变量如下所示：
- en: '[PRE112]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'We can use it to create the argument parser:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来创建参数解析器：
- en: '[PRE113]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'We can use it to create the working objects:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用它来创建工作对象：
- en: '[PRE114]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'This eliminates the repetition. It allows us to add new class definitions and
    parameter key mappings in one place as the application evolves. It also allows
    us to abbreviate or otherwise rewrite the external API as shown here:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了重复。它允许我们在应用程序发展的过程中在一个地方添加新的类定义和参数键映射。它还允许我们缩写或以其他方式重写外部API，如下所示：
- en: '[PRE115]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: There are four of these kinds of mappings from the command-line (or configuration
    file) string to application class. Using these internal mappings simplifies the
    `simulate_blackjack()` function.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种从命令行（或配置文件）字符串到应用程序类的映射。使用这些内部映射简化了`simulate_blackjack()`函数。
- en: Managing nested configuration contexts
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理嵌套的配置上下文
- en: 'In a way, the presence of nested contexts means that top level scripts ought
    to look like the following code:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，嵌套上下文的存在意味着顶层脚本应该看起来像以下代码：
- en: '[PRE116]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'We add two context managers. For more information, see [Chapter 5](ch05.html
    "Chapter 5. Using Callables and Contexts"), *Using Callables and Contexts*. Here
    are two context managers:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个上下文管理器。有关更多信息，请参见[第5章](ch05.html "第5章。使用可调用和上下文")，*使用可调用和上下文*。这里有两个上下文管理器：
- en: '[PRE117]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The `Logging_Config` context manager configures the logging. It also ensures
    that logging is properly shut down when the application is finished.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '`Logging_Config`上下文管理器配置日志。它还确保在应用程序完成时正确关闭日志。'
- en: The `Application_Config` context manager can gather configuration from a number
    of files as well as command-line arguments. The use of a context manager isn't
    essential in this case. However, it leaves room for ready extension.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application_Config`上下文管理器可以从多个文件以及命令行参数中收集配置。在这种情况下，使用上下文管理器并非必要。然而，它为扩展留下了空间。'
- en: This design pattern may clarify the various concerns that surround the application
    startup and shutdown. While it may be a bit much for most applications, this design
    fits with the philosophy of Python context managers seems like it could be helpful
    as an application grows and expands.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式可能会澄清围绕应用程序启动和关闭的各种关注点。虽然对于大多数应用程序来说可能有点多，但这种设计符合Python上下文管理器的哲学，似乎在应用程序增长和扩展时会有所帮助。
- en: When we're confronted with an application that grows and expands, we often wind
    up doing larger-scale programming. For this, it's important to separate the changeable
    application processing from the less changeable processing context.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们面对一个不断增长和扩展的应用程序时，我们经常会进行大规模编程。因此，将可变的应用程序处理与不太可变的处理上下文分离开来非常重要。
- en: Programming In The Large
  id: totrans-770
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大规模编程
- en: 'Let''s add a feature to our Blackjack simulation: analysis of results. We have
    several paths to implement this added feature. There are two dimensions to our
    considerations, leading to a large number of combinations. One dimension of our
    consideration is how to design the new features:'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的二十一点模拟添加一个功能：结果分析。我们有几种方法来实现这个新增功能。我们的考虑有两个方面，导致了大量的组合。我们考虑的一个方面是如何设计新功能：
- en: Add a function
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个函数
- en: Use the Command design pattern
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令设计模式
- en: 'The other dimension is how to package the new features:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个方面是如何打包新功能：
- en: Write a new top-level script file. We would have new commands based on files
    with names such as `simulate.py` and `analyze.py`.
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个新的顶层脚本文件。我们会有基于文件的新命令，文件名类似`simulate.py`和`analyze.py`。
- en: Add a parameter to an application that allows one script to perform the simulation
    or analysis. We would have commands that look like `app.py simulate` and `app.py
    analyze`.
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向应用程序添加一个参数，允许一个脚本执行模拟或分析。我们会有类似`app.py simulate`和`app.py analyze`的命令。
- en: All four combinations are sensible ways to implement this. We'll focus on using
    the **command** design pattern. First, we'll revise our existing application to
    use the command design pattern. Then, we'll extend our application by adding features.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 这四种组合都是实现这一点的合理方式。我们将专注于使用**命令**设计模式。首先，我们将修改现有的应用程序以使用命令设计模式。然后，我们将通过添加功能来扩展我们的应用程序。
- en: Designing command classes
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计命令类
- en: Many applications involve an implicit Command design pattern. After all, we're
    *processing* data. To do this, there must be at least one active-voice verb that
    defines how the application transforms, creates, or consumes data. A very simple
    application may have only a single verb, implemented as a function. Using the
    Command class design pattern may not be helpful.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序涉及隐式的命令设计模式。毕竟，我们正在*处理*数据。为了做到这一点，必须至少有一个定义应用程序如何转换、创建或消耗数据的主动语态动词。一个非常简单的应用程序可能只有一个动词，实现为一个函数。使用命令类设计模式可能没有帮助。
- en: More complex applications will have multiple, related verbs. One of the key
    features of GUIs and web servers is that they can do multiple things, leading
    to multiple commands. In many cases, the GUI menu options define the domain of
    the verbs for an application.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的应用程序将具有多个相关的动词。GUI和Web服务器的关键特性之一是它们可以执行多个操作，从而导致多个命令。在许多情况下，GUI菜单选项定义了应用程序的动词域。
- en: In some cases, an application's design stems from a decomposition of a larger,
    more complex verb. We may factor the overall processing into several smaller command
    steps that are combined into the final application.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用程序的设计源自对更大、更复杂的动词的分解。我们可以将整体处理分解为几个较小的命令步骤，然后将它们组合成最终的应用程序。
- en: When we look at the evolution of an application, we often see a pattern where
    new functionality is accreted. In these cases, each new feature can become a kind
    of separate command subclass that is added to the application class hierarchy.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看应用程序的演变时，我们经常看到一种模式，即新功能的堆积。在这些情况下，每个新功能都可以成为应用程序类层次结构中添加的一种独立的命令子类。
- en: 'Here''s an abstract superclass for commands:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令的抽象超类：
- en: '[PRE118]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: We configure this `Command` class by setting the `config` property to a `types.SimpleNamespace`
    or `argparse.Namespace`, or even another `Command` instance. This will populate
    the instance variables from the `namespace` object.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`config`属性设置为`types.SimpleNamespace`或`argparse.Namespace`，甚至另一个`Command`实例来配置这个`Command`类。这将从`namespace`对象中填充实例变量。
- en: 'Once the object is configured, we can set it to doing the work of the command
    by calling the `run()` method. This class implements a relatively simple use case:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象被配置，我们可以通过调用`run()`方法来让它执行命令的工作。这个类实现了一个相对简单的用例：
- en: '[PRE119]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Here''s a concrete subclass that implements a Blackjack simulation:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现二十一点模拟的具体子类：
- en: '[PRE120]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'This class implements the essential top-level function that configures the
    various objects and then executes the simulation. We wrapped the `simulate_blackjack()`
    function shown previously to create a concrete extension of the `Command` class.
    This can be used in the main script like the following code:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类实现了配置各种对象然后执行模拟的基本顶层函数。我们将之前显示的`simulate_blackjack()`函数包装起来，以创建`Command`类的具体扩展。这可以在主脚本中像下面的代码一样使用：
- en: '[PRE121]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'While we could make this command into `Callable` and use `main()` instead of
    `main.run()`, the use of a callable can be confusing. We''re explicitly separating
    three design issues:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将这个命令变成`Callable`，并使用`main()`而不是`main.run()`，但使用可调用对象可能会令人困惑。我们明确地分离了三个设计问题：
- en: '**Construction**: We''ve specifically kept the initialization empty. In the
    later section, we''ll show you some examples of PITL, where we''ll build a larger
    composite command from smaller component commands.'
  id: totrans-793
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构造**：我们特意保持了初始化为空。在后面的部分，我们将向您展示一些PITL的示例，我们将从较小的组件命令构建一个更大的复合命令。'
- en: '**Configuration**: We''ve put the configuration in via a `property` setter,
    isolated from the construction and control.'
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：我们通过`property` setter设置了配置，与构造和控制隔离开来。'
- en: '**Control**: This is the real work of the command after it''s been built and
    configured.'
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制**：这是命令在构建和配置后的真正工作。'
- en: When we look at a callable or a function, the construction is part of the definition.
    The configuration and control are combined into the function call itself. We sacrifice
    a small bit of flexibility if we try to define a callable.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看一个可调用对象或函数时，构造是定义的一部分。配置和控制合并到函数调用本身中。如果我们尝试定义一个可调用对象，我们会牺牲一点灵活性。
- en: Adding the analysis command subclass
  id: totrans-797
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加分析命令子类
- en: We'll extend our application by adding the analysis feature. As we're using
    the Command design pattern, we can add yet another subclass for analysis.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加分析功能来扩展我们的应用程序。由于我们使用了命令设计模式，我们可以为分析添加另一个子类。
- en: 'Here''s our analysis feature:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的分析功能：
- en: '[PRE122]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: This is not too statistically meaningful, true, but the point is to show you
    a second command that uses the configuration namespace to do work related to our
    simulation. We used the `outputfile` configuration parameter to name the file
    that is read to perform some statistical analysis.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是太有统计意义，但重点是向您展示使用配置命名空间来执行与我们的模拟相关的工作的第二个命令。我们使用`outputfile`配置参数来命名要读取以执行一些统计分析的文件。
- en: Adding and packaging more features into an application
  id: totrans-802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向应用程序添加和打包更多功能
- en: Previously, we noted one common approach to supporting multiple features. Some
    applications use multiple top-level main programs in separate `.py` script files.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 先前，我们注意到支持多个功能的一种常见方法。一些应用程序使用多个顶级主程序，分别在单独的`.py`脚本文件中。
- en: When we want to combine commands that are in separate files, we're forced to
    write a shell script to create a higher-level, composite program. It doesn't seem
    optimal to introduce yet another tool and another language to do PITL.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要组合在不同文件中的命令时，我们被迫编写一个shell脚本来创建一个更高级的复合程序。引入另一个工具和另一种语言来进行PITL似乎并不是最佳选择。
- en: 'A slightly more flexible alternative to creating separate script files is using
    a positional parameter to select a specific top-level `Command` object. For our
    example, we''d like to select either the simulation or the analysis command. To
    do this, we would add a parameter to the command-line argument parsing the following
    code:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 创建单独的脚本文件的一个稍微更灵活的替代方法是使用位置参数来选择特定的顶级`Command`对象。对于我们的示例，我们想要选择模拟或分析命令。为此，我们将在命令行参数解析以下代码中添加一个参数：
- en: '[PRE123]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This would change the command-line API to add the top-level verb to the command
    line. We can easily map our argument values to class names:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 这将改变命令行API以向命令行添加顶级动词。我们可以轻松地将我们的参数值映射到类名：
- en: '[PRE124]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This allows us to create even higher-level composite features. For example,
    we might want to combine simulation and analysis into a single, overall program.
    Also, we'd like to do this without resorting to using the shell.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够创建更高级的复合功能。例如，我们可能希望将模拟和分析合并为单个整体程序。此外，我们希望这样做而不使用shell。
- en: Designing a higher-level composite command
  id: totrans-810
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计一个更高级的复合命令
- en: 'Here''s how we can design a composite command that''s built from other commands.
    We have two design strategies: object composition and class composition.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何设计一个由其他命令构建的复合命令。我们有两种设计策略：对象组合和类组合。
- en: 'If we use object composition, then our composite command is based on the built-in
    `list` or `tuple`. We can extend or wrap one of the existing sequences. We''ll
    create the composite `Command` object as a collection of instances of other `Command`
    objects. We might consider writing something like the following code:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用对象组合，那么我们的复合命令是基于内置的`list`或`tuple`。我们可以扩展或包装现有序列之一。我们将创建复合`Command`对象作为其他`Command`对象的实例集合。我们可能考虑编写以下代码：
- en: '[PRE125]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: This has the disadvantage that we haven't created a new class for our unique
    composite command. We created a generic composite and populated it with instances.
    If we want to create even higher-level compositions, we'll have to address this
    asymmetry between low-level `Command` classes and higher-level composite `Command`
    objects based on built-in sequence classes.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的缺点是我们没有为我们独特的复合命令创建一个新的类。我们创建了一个通用的复合命令，并用实例填充了它。如果我们想创建更高级的组合，我们将不得不解决低级`Command`类和基于内置序列类的更高级复合`Command`对象之间的不对称性。
- en: We'd prefer to have a composite command also be a subclass of command. If we
    use class composition, then we'll have a more consistent structure for our low-level
    commands and our higher-level composite commands.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更希望复合命令也是`command`的子类。如果我们使用类组合，那么我们将为我们的低级命令和更高级的复合命令拥有更一致的结构。
- en: 'Here''s a class that implements a sequence of other commands:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个实现其他命令序列的类：
- en: '[PRE126]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: We defined a class-level variable, `sequence`, to contain a sequence of command
    classes. During the object initialization, `__init__()` will construct an internal
    instance variable, `_sequence`, with objects of the named classes in `self.sequence`.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个类级变量`sequence`，用于包含一系列命令类。在对象初始化期间，`__init__()`将使用`self.sequence`中命名类的对象构造内部实例变量`_sequence`。
- en: When the configuration is set, it will be pushed into each constituent object.
    When the composite command is executed via `run()`, it is delegated to each component
    in the composite command.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 当配置设置时，它将被推送到每个组成对象中。当通过`run()`执行复合命令时，它将被委托给复合命令中的每个组件。
- en: 'Here''s a `Command` subclass built from two other `Command` subclasses:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由其他两个`Command`子类构建的`Command`子类：
- en: '[PRE127]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We can now create a class that is a sequence of individual steps. As this is
    a subclass of the `Command` class itself, it has the necessary polymorphic API.
    We can now create compositions with this class because it's compatible with all
    other subclasses of `Command`.
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个包含单个步骤序列的类。由于这是`Command`类本身的子类，它具有必要的多态API。我们现在可以使用这个类创建组合，因为它与`Command`的所有其他子类兼容。
- en: 'We can now make a very small modification to argument parsing to add this feature
    to the application:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以对参数解析进行非常小的修改，以将此功能添加到应用程序中：
- en: '[PRE128]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'We simply added another choice to the argument option values. We''ll also need
    to tweak the mapping from the argument option string to the class:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是在参数选项值中添加了另一个选择。我们还需要微调从参数选项字符串到类的映射：
- en: '[PRE129]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note that we shouldn't use a vague name such as `both` to combine two commands.
    If we avoid vagueness, we create opportunities to expand or revise our application.
    Using the Command design pattern makes it pleasant to add features. We can define
    composite commands, or we can decompose a larger command into smaller subcommands.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不应该使用模糊的名称，比如`both`来组合两个命令。如果我们避免模糊，我们就有机会扩展或修改我们的应用程序。使用命令设计模式使添加功能变得愉快。我们可以定义复合命令，或者我们可以将更大的命令分解为更小的子命令。
- en: Packaging and implementation may involve adding an option choice and mapping
    that choice to a class name. If we use a more sophisticated configuration file
    (see [Chapter 13](ch13.html "Chapter 13. Configuration Files and Persistence"),
    *Configuration Files and Persistence*), we can provide the class name directly
    in the configuration file and save the mapping from an option string to a class.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 打包和实现可能涉及添加选项选择并将该选择映射到类名。如果我们使用更复杂的配置文件（参见[第13章](ch13.html "第13章。配置文件和持久性")，“配置文件和持久性”），我们可以直接在配置文件中提供类名，并保存从选项字符串到类的映射。
- en: Additional composite command design patterns
  id: totrans-829
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他复合命令设计模式
- en: 'We can identify a number of composite design patterns. In the previous example,
    we designed a sequence composite. For inspiration, we can look at the bash shell
    composite operators: `;`, `&`, `|`, as well as `()` for grouping. Beyond these,
    we have `if`, `for`, and `while` loops within the shell.'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以识别出许多复合设计模式。在前面的例子中，我们设计了一个序列复合。为了获得灵感，我们可以看一下bash shell的复合运算符：`;`，`&`，`|`，以及`()`用于分组。除此之外，我们还有shell中的`if`，`for`和`while`循环。
- en: We looked at the sequence operator (`;`) in the `Command_Sequence` class definition.
    This concept of *sequence* is so ubiquitous that many programming languages (such
    as the shell and Python) don't require an explicit operator; the syntax simply
    uses end-of-line as an implied sequence operator.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Command_Sequence`类定义中看到了序列运算符（`;`）。这种*序列*的概念是如此普遍，以至于许多编程语言（如shell和Python）不需要显式的运算符；语法简单地使用行尾作为隐含的序列运算符。
- en: The shell's `&` operator creates two commands that run concurrently instead
    of sequentially. We can create a `Command_Concurrent` class definition with a
    `run()` method that uses `multiprocessing` to create two subprocesses and waits
    for both to finish.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: shell中的`&`运算符创建了两个同时运行而不是顺序运行的命令。我们可以创建一个`Command_Concurrent`类定义，其中包含一个使用`multiprocessing`创建两个子进程并等待两者都完成的`run()`方法。
- en: 'The `|` operator in the shell creates a pipeline: one command''s output buffer
    is another command''s input buffer; the commands run concurrently. In Python,
    we''d need to create a queue as well as two processes to read and write that queue.
    This is a more complex situation; it involves populating the queue objects into
    the configurations of each of the various children. [Chapter 12](ch12.html "Chapter 12. Transmitting
    and Sharing Objects"), *Transmitting and Sharing Objects*, has some examples of
    using `multiprocessing` with queues to pass objects among concurrent processes.'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: shell中的`|`运算符创建了一个管道：一个命令的输出缓冲区是另一个命令的输入缓冲区；这些命令同时运行。在Python中，我们需要创建一个队列以及两个进程来读取和写入该队列。这是一个更复杂的情况；它涉及将队列对象填充到各个子对象的配置中。[第12章](ch12.html
    "第12章。传输和共享对象")，“传输和共享对象”中有一些使用`multiprocessing`和队列在并发进程之间传递对象的示例。
- en: The `if` command in the shell has a number of use cases. However, there's no
    compelling reason to provide anything more than a native Python implementation
    via a method in a subclass of `Command`. Creating a complex `Command` class to
    mimic Python's `if-elif-else` processing isn't helpful. We can—and should—just
    use Python.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: shell中的`if`命令有许多用例。然而，没有必要提供比`Command`子类中的方法更多的东西。创建一个复杂的`Command`类来模仿Python的`if-elif-else`处理是没有帮助的。我们可以——也应该——只使用Python。
- en: The `while` and `for` commands in the shell, similarly, aren't the sort of things
    we need to define in a higher-level `Command` subclass. We can simply write this
    in a method in Python.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: shell中的`while`和`for`命令同样不是我们需要在更高级别的`Command`子类中定义的东西。我们可以在Python中的一个方法中简单地编写这个。
- en: 'Here''s an example of a *for-all* class definition that applies an existing
    command to all the values in a collection:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个应用现有命令到集合中所有值的*for-all*类定义的示例：
- en: '[PRE130]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We enumerated the three classes of betting in our simulation. For each of these
    classes, we tweaked the configuration, created a simulation, and executed that
    simulation.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列举了模拟中的三种投注类别。对于这些类别中的每一个，我们调整了配置，创建了一个模拟，并执行了该模拟。
- en: 'Note that this *for-all* class won''t work with the `Analyze_Command` class
    defined previously. We can''t simply create composites that reflect different
    scopes of work. The `Analyze_Command` class runs a single simulation, but the
    `ForAllBets_Simulate` class runs a collection of simulations. We have two choices
    to create compatible scopes of work: we could create an `Analyze_All` command
    or `ForAllBets_Sim_and_Analyze` command. The design decision depends on the needs
    of the users.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个*for-all*类与之前定义的`Analyze_Command`类不兼容。我们不能简单地创建反映不同工作范围的复合。`Analyze_Command`类运行单个模拟，但`ForAllBets_Simulate`类运行一系列模拟。我们有两种选择来创建兼容的工作范围：我们可以创建一个`Analyze_All`命令或`ForAllBets_Sim_and_Analyze`命令。设计决策取决于用户的需求。
- en: Integrating with other applications
  id: totrans-840
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他应用程序集成
- en: 'There are several ways in which we can use Python when integrating with other
    applications. It''s difficult to provide a comprehensive overview, as there are
    so many applications, each with unique, distinctive features. We can show you
    some broad design patterns:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在与其他应用程序集成时，我们可以使用Python的几种方法。由于有许多应用程序，每个应用程序都具有独特的特点，因此很难提供全面的概述。我们可以向您展示一些广泛的设计模式：
- en: 'Python may be the application''s scripting language. For many examples, here''s
    a list of applications that simply include Python as the primary method to add
    features: [https://wiki.python.org/moin/AppsWithPythonScripting](https://wiki.python.org/moin/AppsWithPythonScripting)'
  id: totrans-842
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python可能是应用的脚本语言。对于许多示例，这里有一个包含Python作为添加功能的主要方法的应用程序列表：[https://wiki.python.org/moin/AppsWithPythonScripting](https://wiki.python.org/moin/AppsWithPythonScripting)
- en: A Python module can implement the application's API. There are numerous applications
    that include Python modules that provide a binding to the application's API. Application
    developers working in one language will often provide API libraries for other
    languages, including Python.
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python模块可以实现应用程序的API。许多应用程序包括提供与应用程序API绑定的Python模块的Python模块。在一种语言中工作的应用程序开发人员通常会为其他语言提供API库，包括Python。
- en: We can use the `ctypes` module to implement another application's API directly
    in Python. This works out well in the case of an application library that is focused
    on C or C++.
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`ctypes`模块直接在Python中实现另一个应用程序的API。这在针对C或C ++的应用程序库的情况下效果很好。
- en: We can use `STDIN` and `STDOUT` to create a shell-level pipeline that connects
    us to another application. We might also want to look at the `fileinput` module
    when building shell-compatible applications.
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`STDIN`和`STDOUT`来创建一个与另一个应用程序连接的shell级管道。在构建与shell兼容的应用程序时，我们可能还需要查看`fileinput`模块。
- en: We can use the `subprocess` module to access an application's command-line interface.
    This may also involve connecting to an application's stdin and stdout to interact
    properly with it.
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`subprocess`模块来访问应用程序的命令行界面。这可能还涉及连接到应用程序的stdin和stdout以正确地与其交互。
- en: We can also write our own Python-compatible module in C or C++. In this case,
    we can implement the foreign application's API in C, offering classes or functions
    that a Python application can leverage. This may be a better performance than
    using the `ctypes` API. As this requires compiling C or C++, it's also a bit more
    tool intensive.
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以用C或C ++编写自己的Python兼容模块。在这种情况下，我们可以在C中实现外部应用程序的API，提供Python应用程序可以利用的类或函数。这可能比使用`ctypes`
    API性能更好。由于这需要编译C或C ++，因此工具更加密集。
- en: This level of flexibility means that we often use Python as the integration
    framework or glue to create a larger, composite application from smaller applications.
    When using Python for integration, we'll often have Python classes and objects
    that mirror the definitions in another application.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性意味着我们经常使用Python作为集成框架或粘合剂，从较小的应用程序创建更大的复合应用程序。在使用Python进行集成时，我们经常会有Python类和对象，这些类和对象与另一个应用程序中的定义相对应。
- en: There are some additional design considerations that we'll save for [Chapter
    17](ch17.html "Chapter 17. The Module and Package Design"), *The Modules and Package
    Design*. These are higher-level architectural design considerations, above and
    beyond coping with the command line.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的设计考虑，我们将在[第17章](ch17.html "第17章。模块和包设计")中保存，*模块和包设计*。这些是更高级别的架构设计考虑，超出了处理命令行的范围。
- en: Summary
  id: totrans-850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at how to use `argparse` and `os.environ` to gather command-line argument
    and configuration parameters. This builds on the techniques shown in [Chapter
    13](ch13.html "Chapter 13. Configuration Files and Persistence"), *Configuration
    Files and Persistence*.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了如何使用`argparse`和`os.environ`来收集命令行参数和配置参数。这是在[第13章](ch13.html "第13章。配置文件和持久性")中展示的技术的基础上构建的，*配置文件和持久性*。
- en: We can implement a number of common command-line features using `argparse`.
    This includes common features, such as showing the version number and exiting
    or showing the help text and exiting.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`argparse`实现许多常见的命令行功能。这包括常见功能，例如显示版本号并退出或显示帮助文本并退出。
- en: We looked at using the Command design pattern to create applications that can
    be expanded or refactored to offer new features. Our goal is to explicitly keep
    the body of the top-level main function as small as possible.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了使用命令设计模式来创建可以扩展或重构以提供新功能的应用程序。我们的目标是明确地使顶级主函数的主体尽可能小。
- en: Design considerations and trade-offs
  id: totrans-854
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: 'The command-line API is an important part of a finished application. While
    most of our design effort focuses on what the program does while it''s running,
    we do need to address two boundary states: startup and shutdown. An application
    must be easy to configure when we start it up. Also, it must shut down gracefully,
    properly flushing all of the output buffers and releasing all of the OS resources.'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行API是成品应用程序的重要部分。虽然我们的大部分设计工作集中在程序运行时的操作上，但我们确实需要解决两个边界状态：启动和关闭。启动应用程序时，必须易于配置。此外，必须优雅地关闭，正确地刷新所有输出缓冲区并释放所有操作系统资源。
- en: When working with a public-facing API, we have to address a variation on the
    problem of schema evolution. As our application evolves—and as our knowledge of
    the users evolves—we will modify the command-line API. This may mean that we'll
    have legacy features or legacy syntax. It may also mean that we need to break
    the compatibility with the legacy command-line design.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用面向公众的API时，我们必须解决模式演变问题的变化。随着我们的应用程序的发展以及我们对用户的了解的发展，我们将修改命令行API。这可能意味着我们将拥有遗留功能或遗留语法。这也可能意味着我们需要打破与遗留命令行设计的兼容性。
- en: In many cases, we'll need to be sure that the major version number is part of
    our application's name. We shouldn't write a top-level module named `someapp`.
    We should consider starting with `someapp1` so that the number is always part
    of the application name. We shouldn't change the command-line API by adding the
    version number as a new suffix; starting with `someapp1` anticipates a possible
    transition to `someapp2`.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们需要确保主版本号是应用程序名称的一部分。我们不应该编写名为`someapp`的顶级模块。我们应该考虑从`someapp1`开始，以便数字始终是应用程序名称的一部分。我们不应该通过添加版本号作为新后缀来更改命令行API；从`someapp1`开始，可以预期可能过渡到`someapp2`。
- en: Looking forward
  id: totrans-858
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next chapter, we'll expand some of these top-level design ideas and look
    at the module and package design. A small Python application can also be a module;
    it can be imported into a larger application. A complex Python application may
    be a package. It may include other application modules and it may be included
    into larger-scale applications.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将扩展一些这些顶层设计思想，并研究模块和包的设计。一个小的Python应用程序也可以是一个模块；它可以被导入到一个更大的应用程序中。一个复杂的Python应用程序可能是一个包。它可能包括其他应用程序模块，并且可能被包含到更大规模的应用程序中。
- en: Chapter 17. The Module and Package Design
  id: totrans-860
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章. 模块和包设计
- en: Python gives us several higher-level constructs to organize software. In [Part
    1](pt01.html "Part 1. Pythonic Classes via Special Methods"), *Pythonic Classes
    via Special Methods* we looked at advanced techniques to use class definitions
    to properly bind the structure and behavior together. In this chapter, we'll look
    at modules to encapsulate classes, functions, and global objects. Above the module
    grouping, we also have packages as a design pattern to group related modules together.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: Python为我们提供了几个更高级的构造来组织软件。在[第一部分](pt01.html "第1部分. 通过特殊方法创建Python类")中，*通过特殊方法创建Python类*，我们研究了使用类定义的高级技术，以正确地将结构和行为绑定在一起。在本章中，我们将研究模块来封装类、函数和全局对象。在模块分组之上，我们还有包作为一种设计模式，将相关模块组合在一起。
- en: Python makes it very easy to create simple modules. Any time we create a Python
    file, we're creating a module. As the scope of our designs gets larger and more
    sophisticated, the use of packages becomes more important to maintain a clear
    organization among the modules.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: Python非常容易创建简单的模块。每当我们创建一个Python文件时，我们就创建了一个模块。随着我们设计的范围变得更大和更复杂，使用包对于保持模块之间的清晰组织变得更加重要。
- en: We have some specialized modules as well. For a larger application, we may implement
    a `__main__` module. This module must be designed to expose the OS command-line
    interface to the application. It must also be defined in such a way that it doesn't
    block the simple reuse of the application to create larger, composite applications.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一些专门的模块。对于一个更大的应用程序，我们可以实现一个`__main__`模块。这个模块必须被设计为将操作系统命令行界面暴露给应用程序。它还必须以一种不会阻碍简单重用应用程序来创建更大的复合应用程序的方式进行定义。
- en: We also have some flexibility in how we install the modules. We can use the
    default working directory, an environment variable setting, `.pth` files, as well
    as the Python `lib/site-packages` directory. Each of these has advantages and
    disadvantages.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在安装模块时也有一些灵活性。我们可以使用默认的工作目录、环境变量设置、`.pth`文件，以及Python的`lib/site-packages`目录。每种方法都有优缺点。
- en: We're going to avoid the more complex problem of distributing Python code. There
    are a number of techniques to create a source distribution for a Python project.
    The various distribution technologies move outside object-oriented design. *Chapter
    30* of *Python Standard Library* addresses some of the physical file-packaging
    issues. The *Distributing Python Modules* document provides information on creating
    a code distribution.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将避免分发Python代码的更复杂问题。有许多技术可以为Python项目创建源代码分发。各种分发技术超出了面向对象的设计。《Python标准库》的第30章解决了一些物理文件打包问题。《分发Python模块》文档提供了有关创建代码分发的信息。
- en: Designing a module
  id: totrans-866
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个模块
- en: A module is the unit of the Python implementation and reuse. All Python programming
    is provided at the module level. The class is the foundation of object-oriented
    design and programming. The module—a collection of classes—is a higher-level grouping
    and is the unit of reuse in Python. We can't easily reuse a single class in isolation.
    A properly designed module can be reused.
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 模块是Python实现和重用的单位。所有的Python编程都是在模块级别提供的。类是面向对象设计和编程的基础。模块——一组类——是一个更高级别的分组，也是Python中重用的单位。我们不能轻松地单独重用一个类。一个经过正确设计的模块可以被重用。
- en: 'A Python module is a file. The filename extension must be `.py`. The filename
    in front of `.py` must be a valid Python name. Section 2.3 of *Python Language
    Reference* provides us with the complete definition of a name. One of the clauses
    in this definition is: *Within the ASCII range (U+0001..U+007F), the valid characters
    for identifiers are the uppercase and lowercase letters A through Z, the underscore
    _ and, except for the first character, the digits 0 through 9*.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块是一个文件。文件名的扩展名必须是`.py`。`.py`前面的文件名必须是一个有效的Python名称。《Python语言参考》的2.3节为我们提供了名称的完整定义。在这个定义中的一个条款是：*在ASCII范围内（U+0001..U+007F），标识符的有效字符是大写和小写字母A到Z、下划线_和除第一个字符外的数字0到9*。
- en: OS filenames permit more characters from the ASCII range than Python names;
    this extra OS complexity must be ignored. The filename (without `.py`) is the
    module name.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统文件名允许使用ASCII范围内的更多字符，而不是Python名称；必须忽略这种额外的操作系统复杂性。文件名（不带`.py`）就是模块名。
- en: Every time we create a `.py` file, we create a module. Often, we'll create a
    Python file without doing too much design work. In this chapter, we'll take a
    look at some of the design considerations to create a reusable module.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建一个`.py`文件，我们就创建了一个模块。通常，我们会创建一个Python文件，而不会做太多的设计工作。在本章中，我们将研究一些设计考虑因素，以创建可重用的模块。
- en: Tip
  id: totrans-871
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Python may also create `.pyc` and `.pyo` files for its own private purposes;
    it's best to simply ignore these files. Many brain calories have been wasted by
    programmers trying to exploit the `.pyc` file as a kind of compiled object-code
    that can be used instead of the `.py` file to somehow keep the source code a secret.
    We need to emphasize the *wasted* part of that. The `.pyc` files can be decompiled
    easily; they don't keep anything secret. If you need to prevent the reverse-engineering
    of your application, you might want to consider using a different language.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: Python也可能为自己的私有目的创建`.pyc`和`.pyo`文件；最好是简单地忽略这些文件。许多程序员试图利用`.pyc`文件作为一种编译的对象代码，以便代替`.py`文件，以某种方式保持源代码的机密性，这样做是浪费脑力。`.pyc`文件可以很容易地反编译；它们不会保持任何机密性。如果您需要防止应用程序的逆向工程，您可能需要考虑使用其他语言。
- en: Some module design patterns
  id: totrans-873
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些模块设计模式
- en: 'There are three commonly seen design patterns for Python modules:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块通常有三种常见的设计模式：
- en: '**Pure library modules**: These are meant to be imported. They contain definitions
    of classes, functions, and perhaps some assignment statements to create a few
    global variables. They do not do any real work so that they can be imported without
    any worry about the side effects of the import operation. There are two use cases
    that we''ll look at:'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纯库模块**：这些模块是用于导入的。它们包含类、函数的定义，也许还有一些赋值语句来创建一些全局变量。它们不执行任何真正的工作，因此可以被导入而不用担心导入操作的副作用。我们将看一下两种用例：'
- en: '**Whole module**: Some modules are designed to be imported as a whole, creating
    a module namespace that contains all of the items'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整个模块**：一些模块被设计为整体导入，创建包含所有项目的模块命名空间'
- en: '**Item collection**: Some modules are designed to have individual items imported
    instead of creating a module object'
  id: totrans-877
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**项目集合**：一些模块被设计成可以导入单独的项目，而不是创建一个模块对象'
- en: '**Main script modules**: These are meant to be executed from the command line.
    They contain much more than class and function definitions. They will include
    statements that will do the real work; they may have side effects; they cannot
    be meaningfully imported because of an astonishing side effect. If a main script
    module import is attempted, it will actually execute—doing work, possibly updating
    files, or doing whatever the module is designed to do when run.'
  id: totrans-878
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主脚本模块**：这些模块是用于从命令行执行的。它们包含的不仅仅是类和函数定义。它们将包括执行真正工作的语句；它们可能有副作用；它们不能被有意义地导入，因为有惊人的副作用。如果尝试导入主脚本模块，它实际上会执行——执行工作，可能更新文件，或者在运行时模块设计的任何其他操作。'
- en: '**Conditional script modules**: These modules have two use cases: they can
    be imported and they can also be run from the command line. These modules will
    have the main-import switch as described in *Python Standard Library*, section
    28.4, *__main__—top-level script environment*.'
  id: totrans-879
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**条件脚本模块**：这些模块有两种用例：它们可以被导入，也可以从命令行运行。这些模块将具有主导入开关，如*Python标准库*第28.4节所述，*__main__—顶层脚本环境*。'
- en: 'Here''s the simplified conditional script switch from the library documentation:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是库文档中简化的条件脚本开关：
- en: '[PRE131]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The `main()`function does the work of the script. This design supports two
    use cases: `run` and `import`. When the module is run from the command line, it
    evaluates `main()` and does the expected work. When the module is imported, the
    function will not be evaluated, and the import will simply provide definitions
    without doing any real work.'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`函数执行脚本的工作。这种设计支持两种用例：`run`和`import`。当模块从命令行运行时，它会评估`main()`并执行预期的工作。当模块被导入时，函数不会被评估，导入只会提供定义而不执行任何真正的工作。'
- en: 'We suggest something a bit more sophisticated, as shown in [Chapter 16](ch16.html
    "Chapter 16. Coping With the Command Line"), *Coping with the Command Line*:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用更复杂的方法，如[第16章](ch16.html "第16章。处理命令行")中所示，*处理命令行*：
- en: '[PRE132]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Our point is to echo the following essential design tip:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的观点是要重申以下重要的设计提示：
- en: Tip
  id: totrans-886
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Importing a module should have few side effects.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 导入模块应该有很少的副作用。
- en: Creating a few module-level variables is an acceptable side effect of an import.
    The real work—accessing network resources, printing output, updating files, and
    other kinds of side effects—should not happen when a module is getting imported.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一些模块级变量是导入的可接受副作用。真正的工作——访问网络资源、打印输出、更新文件和其他类型的副作用——在导入模块时不应该发生。
- en: A main script module without a `__name__ == "__main__"` section is often a bad
    idea because it can't be imported and reused. Beyond that, it's difficult for
    documentation tools to work with a main script module, and it's difficult to test.
    The documentation tools tend to import modules, causing work to be done unexpectedly.
    Similarly, testing requires care to avoid importing the module as part of a test
    setup.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`__name__ == "__main__"`部分的主脚本模块通常是一个坏主意，因为它不能被导入和重用。除此之外，文档工具很难处理主脚本模块，并且很难进行测试。文档工具倾向于导入模块，导致意外执行工作。同样，测试需要小心避免在测试设置的一部分导入模块。
- en: Module versus class
  id: totrans-890
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块与类
- en: 'There are numerous parallels between a module and a class definition:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和类定义之间有许多相似之处：
- en: A module and a class each have a Python name. Modules usually have a leading
    lowercase letter; classes usually have a leading uppercase letter.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和类都有一个Python名称。模块通常以小写字母开头；类通常以大写字母开头。
- en: A module and a class definition are namespaces that contain other objects.
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块和类定义是包含其他对象的命名空间。
- en: A module is a **singleton** object within a global namespace, `sys.modules`.
    A class definition is unique within a namespace, either the global namespace,
    `__main__` or some local namespace. A class isn't a proper **Singleton**; the
    definition can be replaced. Once imported, a module isn't imported again unless
    it's deleted.
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块是全局命名空间`sys.modules`中的**单例**对象。类定义在命名空间中是唯一的，可以是全局命名空间`__main__`或某个局部命名空间。类不是一个合适的**单例**；定义可以被替换。一旦被导入，模块就不会再次被导入，除非它被删除。
- en: The definition of the class or module is evaluated as a sequence of statements
    within a namespace.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类或模块的定义被作为一系列语句在一个命名空间中进行评估。
- en: A function defined in a module is analogous to a static method within a class
    definition.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中定义的函数类似于类定义中的静态方法。
- en: A class defined in a module is analogous to a class defined within another class.
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中定义的类类似于在另一个类中定义的类。
- en: 'There are two significant differences between a module and class:'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和类之间有两个重要的区别：
- en: We can't create an instance of a module; it's always a singleton. We can create
    multiple instances of a class.
  id: totrans-899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能创建模块的实例；它总是一个单例。我们可以创建多个类的实例。
- en: An assignment statement in a module creates a variable that's global within
    the module's namespace; it can be used inside the module without a qualifier.
    An assignment statement within a class definition creates a variable that's part
    of the class namespace it requires a qualifier to distinguish it from the global
    variables.
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块中的赋值语句创建了一个在模块命名空间中全局的变量；它可以在模块内部使用而不需要限定符。类定义中的赋值语句创建了一个属于类命名空间的变量，需要限定符来区分它与全局变量。
- en: Tip
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A module is like a class. Modules, packages, and classes can be used to encapsulate
    data and processing—attributes and operations—into a tidy object.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 模块就像一个类。模块、包和类可以用来封装数据和处理——属性和操作——成一个整洁的对象。
- en: The similarities between modules and classes mean that choosing between them
    is a design decision with trade-offs and alternatives. In most cases, the need
    for an *instance of* is the deciding factor. A module's singleton feature means
    that we'll use a module (or package) to contain class and function definitions
    that are expanded just once even if imported multiple times.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 模块和类之间的相似之处意味着在它们之间进行选择是一个具有权衡和替代方案的设计决策。在大多数情况下，对*实例*的需求是决定因素。模块的单例特性意味着我们将使用一个模块（或包）来包含只扩展一次的类和函数定义，即使被多次导入。
- en: However, there are some modules that might be very class-like. The `logging`
    module, for example, is often imported in multiple other modules. The singleton
    feature means that the logging configuration can be done once and will apply to
    all other modules.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些模块可能非常类似于类。例如，`logging`模块经常被多个其他模块导入。单例特性意味着日志配置只需进行一次，就会应用于所有其他模块。
- en: A configuration module, similarly, might be imported in several places. The
    singleton nature of a module ensures the configuration can be imported by any
    module but will be truly global.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，配置模块可能会在多个地方被导入。模块的单例特性确保了配置可以被任何模块导入，但确实是真正的全局的。
- en: When writing applications that work with a single connected database, a module
    with a number of functions will be similar to a singleton class. The database
    access layer can be imported throughout an application but will be a single, shared
    global object.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写与单个连接的数据库一起工作的应用程序时，具有多个函数的模块将类似于单例类。数据库访问层可以在整个应用程序中导入，但将是一个单一的、共享的全局对象。
- en: The expected content of a module
  id: totrans-907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块的预期内容
- en: Python modules have a typical organization. To an extent, this is defined by
    PEP 8, [http://www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/).
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: Python模块有一个典型的组织结构。在某种程度上，这是由PEP 8定义的，[http://www.python.org/dev/peps/pep-0008/](http://www.python.org/dev/peps/pep-0008/)。
- en: 'The first line of a module can be a `#!` comment; a typical version looks like
    the following code:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的第一行可以是`#!`注释；典型的版本看起来像以下代码：
- en: '[PRE133]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This is used to help OS tools such as `bash` locate the Python interpreter for
    an executable script file. For Windows, this line may be something like `#!C:\Python3\python.exe`.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于帮助`bash`等OS工具定位可执行脚本文件的Python解释器。对于Windows，这一行可能是`#!C:\Python3\python.exe`之类的。
- en: 'Older Python modules may include a coding comment to specify the encoding for
    the rest of the text. This may look like the following code:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的Python模块可能包括一个编码注释来指定其余文本的编码。这可能看起来像以下代码：
- en: '[PRE134]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: The coding comment is not generally needed for Python 3; the OS encoding information
    is adequate. Older Python implementations assumed the files were encoded in ASCII;
    a coding comment was required for files that were not in ASCII.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3通常不需要编码注释；操作系统编码信息就足够了。旧的Python实现假定文件是用ASCII编码的；对于不是ASCII编码的文件，需要编码注释。
- en: The next lines of a module should be a triple-quoted module docstring that defines
    the contents of the module file. As with other Python docstrings, the first paragraph
    of the text should be a summary. This should be followed by a more complete definition
    of the module's contents, purpose, and usage. This may include RST markup so that
    the documentation tools can produce elegant-looking results from the docstring.
    We'll address this in [Chapter 18](ch18.html "Chapter 18. Quality and Documentation"),
    *Quality and Documentation*.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的下一行应该是一个三引号的模块文档字符串，定义了模块文件的内容。与其他Python文档字符串一样，文本的第一段应该是一个摘要。这之后应该是对模块内容、目的和用法的更完整的定义。这可能包括RST标记，以便文档工具可以从文档字符串中产生优雅的结果。我们将在[第18章](ch18.html
    "第18章。质量和文档")中讨论这个问题，*质量和文档*。
- en: 'After the docstring, we can include any version''s control information. For
    example, we might have the following code:'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在文档字符串之后，我们可以包含任何版本的控制信息。例如，我们可能有以下代码：
- en: '[PRE135]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This is a global module that we might use elsewhere in our application to determine
    the version number of the module. This is after the docstring but before the body
    of the module. Below this comes the module's `import` statement. Conventionally,
    they're in a big block at the front of the module.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个全局模块，我们可能会在应用程序的其他地方使用它来确定模块的版本号。这是在文档字符串之后但在模块的主体之前。在这之后是模块的`import`语句。按照惯例，它们通常在模块的开头以一个大块的形式出现。
- en: After the `import` statements come the various class and function definitions
    of the module. These are presented in whatever order is required to ensure that
    they work correctly and make sense to someone who is reading the code.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`语句之后是模块的各种类和函数定义。这些按照需要的顺序呈现，以确保它们能够正确工作，并对阅读代码的人有意义。
- en: Tip
  id: totrans-920
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Java and C++ tend to focus on one class per file.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: Java和C++倾向于一个文件一个类。
- en: That's a silly limitation. It doesn't apply to Python, nor is it a natural law
    of the universe.
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个愚蠢的限制。它不适用于Python，也不是宇宙的自然法则。
- en: If the file has a lot of classes, we might find that the module is a bit hard
    to follow. If we find ourselves using big comment blocks to break a module into
    sections, this is a hint that what we're writing may be more complex than a single
    module. We certainly have multiple modules; we may have a package.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件有很多类，我们可能会发现模块有点难以理解。如果我们发现自己使用大量注释块来将模块分成几个部分，这表明我们所写的可能比单个模块更复杂。我们肯定有多个模块；我们可能有一个包。
- en: Another common feature of some modules is the creation of objects within the
    module's namespace. Stateful module variables, such as class-level attributes,
    are not a great idea. The lack of visibility of these variables is a potential
    area for confusion.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 一些模块的常见特征是在模块的命名空间内创建对象。类级别属性等有状态的模块变量并不是一个好主意。这些变量的可见性是一个潜在的混淆区域。
- en: Sometimes, global modules are handy. The `logging` module makes heavy use of
    this. Another example is the way the `random` module creates a default instance
    of the `Random` class. This allows a number of module-level functions to provide
    a simple API for random numbers. We're not forced to create an instance of `random.Random`.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，全局模块很方便。`logging`模块大量使用这一点。另一个例子是`random`模块创建`Random`类的默认实例的方式。这允许一些模块级函数提供一个简单的随机数API。我们不必创建`random.Random`的实例。
- en: Whole module versus module items
  id: totrans-926
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整个模块与模块项目
- en: There are two approaches to the contents of a library module. Some modules are
    an integrated whole, some are more like a collection of less-well-related items.
    When we've designed a module as a whole, it will often have a few classes or functions
    that are the public-facing API of the module. When we've designed a module as
    a collection of loosely related items, each individual class or function tends
    to stand alone.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 库模块的内容有两种方法。一些模块是一个整体，有些更像是一组不太相关的项目。当我们将模块设计为一个整体时，它通常会有一些类或函数，它们是模块的公共API。当我们将模块设计为一组松散相关的项目时，每个单独的类或函数往往是独立的。
- en: 'We often see this distinction in the way we import and use a module. We''ll
    look at three variations:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在导入和使用模块的方式中看到这种区别。我们将看到三种变化：
- en: Using the `import some_module` command
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`import some_module`命令
- en: The `some_module.py` module file is evaluated and the resulting objects are
    collected into a single namespace called `some_module`. This requires us to use
    qualified names for all of the objects in the module. We must use `some_module.this`
    and `some_module.that`. This use of qualified names makes the module an integrated
    whole.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '`some_module.py`模块文件被评估，并且生成的对象被收集到一个名为`some_module`的单一命名空间中。这要求我们对模块中的所有对象使用限定名称。我们必须使用`some_module.this`和`some_module.that`。这种使用限定名称的方式使模块成为一个整体。'
- en: Using the `from some_module import this` command
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`from some_module import this`命令
- en: The `some_module.py` module file is evaluated and only the named objects are
    created in the current local namespace. Often, this is the global namespace. We
    can now use `this` or `that` without the qualification. This use of unqualified
    names claims that the module seems like a collection of disjointed objects.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '`some_module.py`模块文件被评估，只有命名对象被创建在当前本地命名空间中。通常，这是全局命名空间。现在我们可以在不加限定的情况下使用`this`或`that`。这种使用不加限定的名称声称该模块看起来像是一组不相关的对象。'
- en: Using the `from math import sqrt, sin, cos` command
  id: totrans-933
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`from math import sqrt, sin, cos`命令
- en: This will provide us with a few math functions that we can use without qualification.
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为我们提供一些数学函数，我们可以在不加限定的情况下使用。
- en: Using the `from some_module import *` command
  id: totrans-935
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`from some_module import *`命令
- en: The default behavior is to make all non-private names part of the namespace
    perform the import. A private name begins with `_`. We can explicitly limit the
    number of names imported by a module by providing an `__all__` list within the
    module. This is a list of string object names; these are the names that are elaborated
    by the `import *` statement.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 默认行为是使所有非私有名称成为命名空间的一部分。私有名称以`_`开头。我们可以通过在模块中提供一个`__all__`列表来显式限制导入的名称数量。这是一个字符串对象名称的列表；这些名称是由`import
    *`语句扩展的名称。
- en: We can use the `__all__` variable to conceal the utility functions that are
    part of building the module but not part of the API that's provided to clients
    of the module.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`__all__`变量来隐藏构建模块的实用函数，但不是API的一部分，这些函数提供给模块的客户端。
- en: 'When we look back at our design for decks of cards, we could elect to keep
    the suits as an implementation detail that''s not imported by default. If we had
    a `cards.py` module, we could include the following code:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们回顾我们设计的卡牌组的设计时，我们可以选择将花色作为默认情况下不导入的实现细节。如果我们有一个`cards.py`模块，我们可以包含以下代码：
- en: '[PRE136]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The use of the `__all__` variable keeps the class definitions of the `Suit`
    and `Card` classes, the `card()`function, and the `suits` variable as implementation
    details that are not imported by default. For example, when we perform the following
    code:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__all__`变量使`Suit`和`Card`类的类定义，`card()`函数和`suits`变量作为默认情况下不导入的实现细节。例如，当我们执行以下代码时：
- en: '[PRE137]'
  id: totrans-941
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This statement will only create `Deck` and `Shoe` in an application script,
    as those are the only explicitly given names in the `__all__` variable.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语句只会在应用程序脚本中创建`Deck`和`Shoe`，因为它们是`__all__`变量中唯一明确给出的名称。
- en: 'When we execute the following command, it will import the module without putting
    any names into the global namespace:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行以下命令时，它将导入模块，但不会将任何名称放入全局命名空间：
- en: '[PRE138]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Even though it's not imported into the namespace, we can still access the qualified
    `cards.card()` method to create a `Card` class.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 即使它没有被导入到命名空间，我们仍然可以访问合格的`cards.card()`方法来创建一个`Card`类。
- en: There are advantages and disadvantages of each technique. A whole module requires
    using the module name as a qualifier; this makes the origin of an object explicit.
    Importing items from a module shortens their names, which can make complex programming
    more compact and easier to understand.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 每种技术都有优点和缺点。整个模块需要使用模块名称作为限定符；这使得对象的来源变得明确。从模块导入项目会缩短它们的名称，这可以使复杂的编程更紧凑和更易理解。
- en: Designing a package
  id: totrans-947
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个包
- en: 'One important consideration to design a package is *don''t*. The *Zen of Python*
    poem (also known as `import this`) includes this line:'
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 设计包的一个重要考虑是*不要*。*Python之禅*诗（也称为`import this`）包括这一行：
- en: '"Flat is better than nested"'
  id: totrans-949
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '"平铺胜于嵌套"'
- en: We can see this in the Python Standard Library. The structure of the library
    is relatively flat; there are few nested modules. Deeply nested packages can be
    overused. We should be skeptical of excessive nesting.
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Python标准库中看到这一点。库的结构相对平铺；嵌套模块很少。深度嵌套的包可能被过度使用。我们应该对过度嵌套持怀疑态度。
- en: A package is essentially a directory with an extra file, `__init__.py`. The
    directory name must be a proper Python name. OS names include a lot of characters
    that are not allowed in Python names.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 包本质上是一个带有额外文件`__init__.py`的目录。目录名称必须是一个合适的Python名称。操作系统名称包括许多Python名称中不允许的字符。
- en: 'We often see three design patterns for packages:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常看到三种包的设计模式：
- en: 'Simple packages are a directory with an empty `__init__.py` file. This package
    name becomes a qualifier for the internal module names. We''ll use the following
    code:'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的包是一个带有空的`__init__.py`文件的目录。这个包名称成为内部模块名称的限定符。我们将使用以下代码：
- en: '[PRE139]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'A module package can have an `__init__.py` file that is effectively a module
    definition. This can import other modules from the package directory. Or, it can
    stand as a part of a larger design that includes the top-level module and the
    qualified submodules. We''ll use the following code:'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块包可以有一个`__init__.py`文件，实际上是一个模块定义。这可以从包目录中导入其他模块。或者，它可以作为包括顶层模块和合格子模块的更大设计的一部分。我们将使用以下代码：
- en: '[PRE140]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Directories are where the `__init__.py` file selects among alternative implementations.
    We''ll use the following code:'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录是`__init__.py`文件在替代实现中进行选择的地方。我们将使用以下代码：
- en: '[PRE141]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: The first kind of package is relatively simple. We add an `__init__.py` file
    and we're done creating a package. The other two are a bit more involved; we'll
    look at these in detail.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种包相对简单。我们添加一个`__init__.py`文件，就创建了一个包。另外两种包稍微复杂一些；我们将详细看看这些。
- en: Designing a module-package hybrid
  id: totrans-960
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计模块包混合体
- en: In some cases, a design evolves into a module that is very complex—so complex
    that a single file becomes a bad idea. We might need to refactor this complex
    module into a package with several smaller modules.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，设计会演变成一个非常复杂的模块，以至于单个文件变得不合适。我们可能需要将这个复杂的模块重构为一个包，其中包含几个较小的模块。
- en: 'In this case, the package can be as simple as the following kind of structure.
    Here''s the `__init__.py` file from a package directory named `blackjack`:'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，包可以简单到以下结构。这是一个名为`blackjack`的包目录中的`__init__.py`文件：
- en: '[PRE142]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'This shows us how we can build a module-like package that is actually an assembly
    of parts imported from other subsidiary modules. An overall application can then
    do this:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了如何构建一个类似模块的包，实际上是从其他子模块导入的部分组装。然后整体应用程序可以这样做：
- en: '[PRE143]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'This snippet shows us how we can use `from blackjack import *` to create a
    number of class definitions that originate in a number of other packages. Specifically,
    there''s an overall `blackjack` package that has the following modules within
    it:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码向我们展示了如何使用`from blackjack import *`来创建许多类定义，这些类定义源自其他包中的模块。具体来说，有一个名为`blackjack`的整体包，其中包含以下模块：
- en: The `blackjack.cards` package contains the `Card`, `Deck`, and `Shoe` definitions
  id: totrans-967
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blackjack.cards`包含`Card`、`Deck`和`Shoe`的定义'
- en: The `blackjack.player` package contains various strategies for play
  id: totrans-968
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blackjack.player`包含各种玩法策略'
- en: The `blackjack.casino` package contains a number of classes that customize how
    casino rules vary
  id: totrans-969
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blackjack.casino`包含定制赌场规则的多个类'
- en: The `blackjack.simulator` package contains the top-level simulation tools
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blackjack.simulator`包含顶层模拟工具'
- en: The `betting` package is also used by the application to define various betting
    strategies that are not unique to Blackjack but apply to any casino game
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`betting`包也被应用程序用来定义不仅适用于21点游戏的各种投注策略'
- en: The architecture of this package may simplify upgrading our design. If each
    module is smaller and more focused, it's more readable and more understandable.
    It may be simpler to update each module in isolation.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包的架构可能简化我们的设计升级。如果每个模块都更小更专注，那么它更易读和更易理解。单独更新每个模块可能更简单。
- en: Designing a package with alternate implementations
  id: totrans-973
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计具有替代实现的包
- en: In some cases, we'll have a top-level `__init__.py` file that chooses between
    some alternative implementations within the package directory. The decision might
    be based on the platform, CPU architecture, or the availability of OS libraries.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们会有一个顶层`__init__.py`文件，它在包目录中选择一些替代实现。决定可能基于平台、CPU架构或操作系统库的可用性。
- en: 'There are two common design patterns and one less common design pattern for
    packages with alternative implementations:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有替代实现的包，有两种常见的设计模式和一种不太常见的设计模式：
- en: Examine `platform` or `sys` to determine the details of the implementation and
    decide what to import with an `if` statement.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查`platform`或`sys`以确定实现的细节，并决定使用`if`语句导入什么。
- en: Attempt `import` and use a `try` block exception handling to work out the configuration
    details.
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试`import`并使用`try`块异常处理来解决配置细节。
- en: As a less common alternative, an application may examine a configuration parameter
    to determine what should be imported. This is a bit more complex. We have an ordering
    issue between importing an application configuration and importing other application
    modules based on the configuration. It's far simpler to import without this potentially
    complex sequence of steps.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个不太常见的替代方案，应用程序可以检查配置参数以确定应该导入什么。这有点复杂。我们在导入应用程序配置和根据配置导入其他应用程序模块之间存在排序问题。直接导入而不需要这种潜在复杂的步骤序列要简单得多。
- en: 'Here''s `__init__.py` for a `some_algorithm` package, which chooses an implementation
    based on the platform information:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`some_algorithm`包的`__init__.py`，它根据平台信息选择一个实现：
- en: '[PRE144]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: This uses the `platform` module to determine the details of the platform's architecture.
    There is an ordering dependency here, but depending on a standard library module
    is superior to a more complex application configuration module.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用`platform`模块来确定平台架构的详细信息。这里存在一种排序依赖性，但依赖于标准库模块优于更复杂的应用程序配置模块。
- en: We will provide two modules within the `some_algorithm` package the `long_version`
    module provides an implementation appropriate for a 64-bit architecture; the `short_version`
    module provides an alternate implementation. The design must have module isomorphism;
    this is similar to class isomorphism. Both the modules must contain classes and
    functions with the same names and same APIs.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`some_algorithm`包中提供两个模块，`long_version`模块提供适用于64位架构的实现；`short_version`模块提供替代实现。设计必须具有模块同构性；这类似于类同构性。两个模块必须包含具有相同名称和相同API的类和函数。
- en: 'If both the files define a class named `SomeClass`, then we can write the following
    code in an application:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个文件都定义了一个名为`SomeClass`的类，那么我们可以在应用程序中编写以下代码：
- en: '[PRE145]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: We can import the `some_algorithm` package as if it were a module. The package
    locates an appropriate implementation and provides the needed class and function
    definitions.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以导入`some_algorithm`包，就像它是一个模块一样。该包会找到一个合适的实现，并提供所需的类和函数定义。
- en: The alternative to an `if` statement is to use a `try` statement to locate a
    candidate's implementation. This technique works well when there are different
    distributions. Often, a platform-specific distribution may include files that
    are unique to the platform.
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句的替代方案是使用`try`语句来定位候选实现。当存在不同的分发时，这种技术效果很好。通常，特定于平台的分发可能包含特定于该平台的文件。'
- en: In [Chapter 14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The
    Logging and Warning Modules*, we showed you this design pattern in the context
    of providing warnings in the event of a configuration error or problem. In some
    cases, tracking down variant configurations doesn't deserve a warning, because
    the variant configuration is a design feature.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第14章](ch14.html "第14章。日志和警告模块")中，《日志和警告模块》，我们向您展示了在配置错误或问题发生时提供警告的设计模式。在某些情况下，追踪变体配置并不值得警告，因为变体配置是一种设计特性。
- en: 'Here''s `__init__.py` for a `some_algorithm` package, which chooses an implementation
    based on the availability of the module files within the package:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`some_algorithm`包的`__init__.py`，它根据包内模块文件的可用性选择一个实现：
- en: '[PRE146]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: This depends on having two distinct distributions that will include either the
    `some_algorithm/long_version.py` file or the `some_algorithm/short_version.py`
    file. If the `some_algorithm.long_version` module is not found, then `short_version`
    will be imported.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于有两个不同的分发，其中一个将包括`some_algorithm/long_version.py`文件，另一个将包括`some_algorithm/short_version.py`文件。如果未找到`some_algorithm.long_version`模块，则将导入`short_version`。
- en: This doesn't scale to more than two or three alternative implementations. As
    the number of choices grows, the `except` blocks will become very deeply nested.
    The alternative is to wrap each `try` in `if` to create a flatter design.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 这不适用于超过两到三个替代实现。随着选择数量的增加，`except`块将变得非常深层嵌套。另一种选择是将每个`try`包装在`if`中，以创建一个更扁平的设计。
- en: Designing a main script and the __main__ module
  id: totrans-992
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计一个主脚本和`__main__`模块
- en: 'A top-level main script will execute our application. In some cases, we may
    have multiple main scripts because our application does several things. We have
    three general approaches to writing the top-level main script:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层主脚本将执行我们的应用程序。在某些情况下，我们可能有多个主脚本，因为我们的应用程序会做一些事情。我们有三种编写顶层主脚本的一般方法：
- en: For very small applications, we can run the application with `python3.3 some_script.py`.
    This is the style that we've shown you in most examples.
  id: totrans-994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于非常小的应用程序，我们可以使用`python3.3 some_script.py`运行应用程序。这是我们在大多数示例中向您展示的风格。
- en: For some larger applications, we'll have one or more files that we mark as executable
    with the OS `chmod +x` command. We can put these executable files into Python's
    `scripts` directory with our `setup.py` installation. We run these applications
    with `some_script.py` at the command line.
  id: totrans-995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些较大的应用程序，我们会有一个或多个文件，我们使用操作系统的`chmod +x`命令将其标记为可执行文件。我们可以将这些可执行文件放入Python的`scripts`目录，并与我们的`setup.py`安装一起使用。我们可以在命令行中使用`some_script.py`运行这些应用程序。
- en: For complex applications, we might add a `__main__.py` module in the application's
    package. To provide a tidy interface, the standard library offers the `runpy`
    module and the `-m` command-line option that will use this specially named module.
    We can run this with `python3.3 -m some_app`.
  id: totrans-996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于复杂的应用程序，我们可能会在应用程序包中添加一个`__main__.py`模块。为了提供一个整洁的接口，标准库提供了`runpy`模块和`-m`命令行选项，将使用这个特别命名的模块。我们可以使用`python3.3
    -m some_app`运行这个。
- en: We'll look at the last two options in detail.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论最后两个选项。
- en: Creating an executable script file
  id: totrans-998
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个可执行脚本文件
- en: 'To use an executable script file, we have a two-step implementation: make it
    executable and include a `#!` ("shebang") line. We will take a look at the details.'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用可执行脚本文件，我们有一个两步实现：使其可执行并包含一个`#!`（"shebang"）行。我们将看一下细节。
- en: 'We mark the script executable with `chmod +x some_script.py`. Then, we include
    a `#!` shebang line:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`chmod +x some_script.py`标记脚本为可执行。然后，我们包含一个`#!` shebang行。
- en: '[PRE147]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This line will direct the OS to use the named program to execute the script
    file. In this case, we used the `/usr/bin/env` program to locate the `python3.3`
    program to run the script. The Python3.3 program will be given the script file
    as its input.
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行将指示操作系统使用指定的程序来执行脚本文件。在这种情况下，我们使用`/usr/bin/env`程序来定位`python3.3`程序来运行脚本。Python3.3程序将被给定脚本文件作为其输入。
- en: Once the script file is marked executable—and includes the `#!` line—we can
    use `some_script.py` at the command line to run the script.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本文件被标记为可执行，并包含`#!`行，我们就可以在命令行上使用`some_script.py`来运行脚本。
- en: For a more complex application, this top-level script may import other modules
    and packages. It's important that these top-level executable script files should
    be as simple as possible. We have emphasized the design of top-level executable
    script files.
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的应用程序，这个顶层脚本可能会导入其他模块和包。这些顶层可执行脚本文件应尽可能简单。我们强调了顶层可执行脚本文件的设计。
- en: Tip
  id: totrans-1005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Keep the script module as small as possible.
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽量保持脚本模块尽可能小。
- en: A script module should have no new or distinctive code. It should always import
    existing code.
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本模块不应该有新的或独特的代码。它应该总是导入现有的代码。
- en: No program stands alone.
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有一个程序是独立的。
- en: 'Our design goals must always include the idea of composite, larger-scale programming.
    It''s awkward to have some parts of our program in the proper Python library but
    other parts in the scripts directory. A main script file should be as short as
    possible. Here''s our example:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设计目标必须始终包括复合、大规模编程的概念。在Python库中有一些部分，而在脚本目录中有其他部分，这是很尴尬的。主脚本文件应尽可能简短。这是我们的例子：
- en: '[PRE148]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: All of the relevant working code is imported from a module named `simulation`.
    There's no unique or distinctive new code introduced in this module.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 所有相关的工作代码都是从一个名为`simulation`的模块中导入的。在这个模块中没有引入任何独特或独特的新代码。
- en: Creating a __main__ module
  id: totrans-1012
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个__main__模块
- en: To work with the `runpy` interface, we have a simple implementation. We add
    a small `__main__.py` module to our application's top-level package. We have emphasized
    the design of this top-level executable script file.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`runpy`接口，我们有一个简单的实现。我们在应用程序的顶层包中添加了一个小的`__main__.py`模块。我们强调了这个顶层可执行脚本文件的设计。
- en: We should always permit refactoring an application to build a larger, more sophisticated
    composite application. If there's functionality buried in `__main__.py`, we need
    to pull this into a module with a clear, importable name so that it can be used
    by other applications.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终允许重构应用程序以构建更大、更复杂的复合应用程序。如果`__main__.py`中有功能隐藏，我们需要将其提取到一个具有清晰可导入名称的模块中，以便其他应用程序可以使用它。
- en: 'A `__main__.py` module should be something small like the following code:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`__main__.py`模块应该是一些小的东西，就像以下代码：
- en: '[PRE149]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: We've done the minimum to create the working contexts for our application. All
    of the real processing is imported from the package. Also, we've assumed that
    this `__main__.py` module will never be imported.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经做了最少的工作来为我们的应用程序创建工作环境。所有真正的处理都是从包中导入的。此外，我们假设这个`__main__.py`模块永远不会被导入。
- en: This is about all that should be in a `__main__` module. Our goal is to maximize
    the reuse potential of our application.
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`__main__`模块中应该有的全部内容。我们的目标是最大化应用程序的重用潜力。
- en: Programming in the large
  id: totrans-1019
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大规模编程
- en: Here's an example that shows us why we shouldn't put unique, working code into
    the `__main__.py` module. We'll show you a quick hypothetical example to extend
    existing packages.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，说明为什么我们不应该将独特的工作代码放入`__main__.py`模块中。我们将向您展示一个快速的假设性例子，以扩展现有的包。
- en: 'Imagine that we have a generic statistical package, named `stats`, with a top-level
    `__main__.py` module. This implements a command-line interface that will compute
    descriptive statistics of a given CSV file. This application has a command-line
    API as follows:'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们有一个名为`stats`的通用统计包，其中有一个顶层`__main__.py`模块。这个模块实现了一个命令行接口，用于计算给定CSV文件的描述性统计信息。这个应用程序有一个命令行API，如下所示：
- en: '[PRE150]'
  id: totrans-1022
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This command uses a `–c` option to specify which column to analyze. The input
    filename is provided as a positional argument on the command line.
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令使用`-c`选项来指定要分析的列。输入文件名作为命令行上的位置参数提供。
- en: Let's assume, further, that we have a terrible design problem. We've defined
    a high-level function, `analyze()`, in the `stats/__main__.py` module.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步假设，我们有一个糟糕的设计问题。我们在`stats/__main__.py`模块中定义了一个高级函数`analyze()`。
- en: 'Our goal is to combine this with our Blackjack simulation. As we have a design
    error, this won''t work out well. We might *think* we can do this:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将其与我们的Blackjack模拟结合起来。由于我们有一个设计错误，这不会很顺利。我们可能*认为*我们可以这样做：
- en: '[PRE151]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We tried to use `stats.analyze()`, assuming that the useful, high-level interface
    is part of the package, not part of `__main__.py`. This kind of simple composition
    was made needlessly difficult by defining a function in `__main__`.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用`stats.analyze()`，假设有用的高级接口是包的一部分，而不是`__main__.py`的一部分。这种简单的组合被`__main__`中定义的函数不必要地复杂化了。
- en: 'We want to avoid being forced to do this:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望避免被迫这样做：
- en: '[PRE152]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We shouldn't need to create composite Python applications via the command-line
    API. In order to create a sensible composition of the existing applications, we
    might be forced to refactor `stats/__main__.py` to remove any definitions from
    this module and push them up into the package as a whole.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该需要通过命令行API创建复合的Python应用程序。为了创建现有应用程序的合理组合，我们可能被迫重构`stats/__main__.py`，将该模块中的任何定义移除，并将其推送到整个包中。
- en: Designing long-running applications
  id: totrans-1031
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计长时间运行的应用程序
- en: A long-running application server will be reading requests from some kind of
    queue and formulating responses to those requests. In many cases, we leverage
    the HTTP protocol and build application servers into a web server framework. See
    [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*, for details on how to implement RESTful web services following
    the WSGI design pattern.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间运行的应用程序服务器将从某种队列中读取请求并对这些请求进行响应。在许多情况下，我们利用HTTP协议并将应用程序服务器构建到Web服务器框架中。有关如何按照WSGI设计模式实现RESTful
    Web服务的详细信息，请参见[第12章](ch12.html "第12章。传输和共享对象")。
- en: A desktop GUI application has a lot of features in common with a server. It
    reads events from a queue that includes mouse and keyboard actions. It handles
    each event and gives some kind of GUI response. In some cases, the response may
    be a small update to a text widget. In other cases, a file might get opened or
    closed, and the state of menu items may change.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 桌面GUI应用程序与服务器有许多共同特点。它从包括鼠标和键盘操作的队列中读取事件。它处理每个事件并给出某种GUI响应。在某些情况下，响应可能是对文本部件的小更新。在其他情况下，文件可能会被打开或关闭，菜单项的状态可能会改变。
- en: 'In both cases, the central feature of the application is a loop that runs forever,
    handling events or requests. Because these loops are simple, they''re often part
    of the framework. For a GUI application, we might have a loop like the following
    code:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，应用程序的核心特性是一个永远运行的循环，处理事件或请求。由于这些循环很简单，它们通常是框架的一部分。对于GUI应用程序，我们可能会有以下代码的循环：
- en: '[PRE153]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: For `Tkinter` applications, the top-level widget's `mainloop()` gets each GUI
    event and hands it to the appropriate framework component for handling. When the
    object handling events—the top-level widget, `root`, in the example—executes the
    `quit()` method, then the loop will be gracefully terminated.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Tkinter`应用程序，顶层部件的`mainloop()`接收每个GUI事件并将其交给适当的框架组件进行处理。当处理事件的对象——在本例中是顶层部件`root`——执行`quit()`方法时，循环将被优雅地终止。
- en: 'For a WSGI-based web server framework, we might have a loop like the following
    code:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于WSGI的Web服务器框架，我们可能会有以下代码的循环：
- en: '[PRE154]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: In this case, the server's `serve_forever()` method gets each request and hands
    it to the application—`debug` in this example—for handling. When the application
    executes the server's `shutdown()` method, the loop will be gracefully terminated.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，服务器的`serve_forever()`方法接收每个请求并将其交给应用程序——在本例中是`debug`——进行处理。当应用程序执行服务器的`shutdown()`方法时，循环将被优雅地终止。
- en: 'We often have some additional requirements that distinguish long-running applications:'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常有一些额外的要求，区分长时间运行的应用程序：
- en: '**Robust**: In one sense, this requirement is needless; all software should
    work. However, when dealing with external OS or network resources, there are timeouts
    and other errors that must be confronted successfully. An application framework
    that allows for plugins and extensions enjoys the possibility of an extension
    component harboring an error that the overall framework must handle gracefully.
    Python''s ordinary exception handling is perfectly adequate for writing robust
    servers.'
  id: totrans-1041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**健壮的**：在某种意义上，这种要求是多余的；所有软件都应该工作。然而，当处理外部操作系统或网络资源时，必须成功地应对超时和其他错误。允许插件和扩展的应用程序框架可能存在一个扩展组件隐藏错误的可能性，整体框架必须优雅地处理。Python的普通异常处理非常适合编写健壮的服务器。'
- en: '**Auditable**: A simple, centralized log is not always sufficient. In [Chapter
    14](ch14.html "Chapter 14. The Logging and Warning Modules"), *The Logging and
    Warning Modules*, we addressed techniques to create multiple logs to support the
    security or financial audit requirements.'
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可审计的**：一个简单的集中日志并不总是足够的。在[第14章](ch14.html "第14章。日志和警告模块")中，*日志和警告模块*，我们讨论了创建多个日志以支持安全或财务审计要求的技术。'
- en: '**Debuggable**: Ordinary unit testing and integration testing reduces the need
    for complex debugging tools. However, external resources and software plugins
    or extensions create complexities that may be difficult to handle without providing
    some debugging support. More sophisticated logging can be helpful.'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可调试的**：普通的单元测试和集成测试减少了对复杂调试工具的需求。然而，外部资源和软件插件或扩展创建了可能难以处理的复杂性，因此可能需要提供一些调试支持。更复杂的日志记录可能会有所帮助。'
- en: '**Configurable**: Except for simple technology spikes, we want to be able to
    enable or disable the application features. Enabling or disabling debugging logs,
    for example, is a common configuration change. In some cases, we want to make
    these changes without completely stopping and restarting an application. In [Chapter
    13](ch13.html "Chapter 13. Configuration Files and Persistence"), *Configuration
    Files and Persistence*, we looked at some techniques to configure an application.
    In [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*, we extended these techniques.'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可配置的**：除了简单的技术尖峰外，我们希望能够启用或禁用应用程序功能。例如，启用或禁用调试日志是一种常见的配置更改。在某些情况下，我们希望进行这些更改而不完全停止和重新启动应用程序。在[第13章](ch13.html
    "第13章。配置文件和持久性")中，*配置文件和持久性*，我们研究了一些配置应用程序的技术。在[第16章](ch16.html "第16章。处理命令行")中，*处理命令行*，我们扩展了这些技术。'
- en: '**Controllable**: A simplistic long-running server can simply be killed to
    restart it with a different configuration. In order to ensure that buffers are
    flushed properly and OS resources are released properly, it''s better to use a
    signal other than `SIGKILL` to force termination. Python has signal-handling capabilities
    available in the `signal` module.'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可控制的**：一个简单的长时间运行的服务器可以简单地被杀死以使用不同的配置重新启动。为了确保缓冲区被正确刷新并且操作系统资源被正确释放，最好使用除`SIGKILL`之外的信号来强制终止。Python在`signal`模块中提供了信号处理功能。'
- en: These last two requirements—dynamic configuration and clean shutdown—lead us
    to separate the primary event or request input from a secondary control input.
    This control input can provide additional requests for configuration or shutdown.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后两个要求——动态配置和干净的关闭——导致我们将主要事件或请求输入与次要的控制输入分开。这个控制输入可以提供额外的配置或关闭请求。
- en: 'We have a number of ways to provide asynchronous inputs through an additional
    channel:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有多种方法通过额外的通道提供异步输入：
- en: One of the simplest ways is to create a queue using the `multiprocessing` module.
    In this case, a simple administrative client can interact with this queue to control
    or interrogate the server or GUI. For more examples of `multiprocessing`, see
    [Chapter 12](ch12.html "Chapter 12. Transmitting and Sharing Objects"), *Transmitting
    and Sharing Objects*. We can transmit the control or status objects between the
    administrative client and the server.
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最简单的方法之一是使用`multiprocessing`模块创建一个队列。在这种情况下，一个简单的管理客户端可以与这个队列交互，以控制或询问服务器或GUI。有关`multiprocessing`的更多示例，请参见[第12章](ch12.html
    "第12章。传输和共享对象")*传输和共享对象*。我们可以在管理客户端和服务器之间传输控制或状态对象。
- en: Lower-level techniques are defined in *Chapter 18* of *Python Standard Library*.
    These modules can also be used to coordinate with a long-running server or GUI
    application. They're not as sophisticated as creating a queue or a pipe via `multiprocessing`.
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较低级别的技术在*Python标准库*的*第18章*中定义。这些模块也可以用于与长时间运行的服务器或GUI应用程序协调。它们不像通过`multiprocessing`创建队列或管道那样复杂。
- en: Generally, we're going to be most successful using the higher-level APIs available
    through `multiprocessing`. The lower-level techniques (`socket`, `signal`, `mmap`,
    `asyncore`, and `asynchat`) are relatively primitive and provide few features.
    They should be viewed as the internal support for higher-level modules such as
    `multiprocessing`.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们使用`multiprocessing`提供的高级API会更加成功。较低级别的技术（`socket`、`signal`、`mmap`、`asyncore`和`asynchat`）相对较为原始，并提供的功能较少。它们应该被视为高级模块（如`multiprocessing`）的内部支持。
- en: Organizing code into src, bin, and test
  id: totrans-1051
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码组织成src、bin和test
- en: As we noted in the previous section, there's no essential need for a complex
    directory structure. Simple Python applications can be built in a simple, flat
    directory. We can include the application modules, test modules, as well as `setup.py`
    and `README`. This is pleasantly simple and easy to work with.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一节中所指出的，没有必要复杂的目录结构。简单的Python应用程序可以在一个简单的、扁平的目录中构建。我们可以包括应用程序模块、测试模块，以及`setup.py`和`README`。这样做非常简单，易于操作。
- en: 'When the modules and packages get more complex, however, we''ll often need
    to be a bit more structured. For complex applications, one common approach is
    to segregate Python code into three bundles. To make the examples concrete, let''s
    assume that our application is called `my_app`. Here are the typical directories
    we might create:'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当模块和包变得更加复杂时，我们通常需要更加有结构化。对于复杂的应用程序，一个常见的方法是将Python代码分成三个包。为了使示例具体化，让我们假设我们的应用程序叫做`my_app`。这是我们可能创建的典型目录：
- en: '`my_app/my_app`: This directory has all of the working application code. All
    of the various modules and packages are here. A vaguely named `src` directory
    is uninformative. This `my_app` directory should include an empty `__init__.py`
    file so that the application also acts as a package.'
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_app/my_app`：这个目录包含了所有工作应用程序代码。所有各种模块和包都在这里。一个名为`src`的模糊命名的目录没有提供信息。这个`my_app`目录应该包括一个空的`__init__.py`文件，以便应用程序也可以作为一个包。'
- en: '`my_app/bin` or `my_spp/scripts`: This directory can have any scripts that
    form an OS-level command-line API. These scripts can be copied to the Python `scripts`
    directory by `setup.py`. As noted previously, these should be like the `__main__.py`
    module; they should be very short, and they can be thought of as OS filename aliases
    for Python code.'
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_app/bin`或`my_spp/scripts`：这个目录可以包含形成操作系统级命令行API的任何脚本。这些脚本可以通过`setup.py`复制到Python的`scripts`目录中。如前所述，这些脚本应该像`__main__.py`模块一样；它们应该非常简短，并且可以被视为Python代码的操作系统文件名别名。'
- en: '`my_app/test`: This directory can have the various `unittest` modules. This
    directory, too, should include an empty `__init__.py` file so that it acts as
    a package. It can also include `__main__.py` to run all of the tests in the entire
    package.'
  id: totrans-1056
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`my_app/test`：这个目录可以有各种`unittest`模块。这个目录也应该包括一个空的`__init__.py`文件，以便它可以作为一个包。它还可以包括`__main__.py`来运行整个包中的所有测试。'
- en: The top-level directory name, `my_app`, might be augmented with a version number
    to permit having versions without confusion. We might have `my_app-v1.1` as a
    top-level directory name. The application within that top-level directory must
    have a proper Python name, so we'd see `my_app-v1.1/my_app` as the path to the
    application.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级目录名称`my_app`可能会增加一个版本号，以允许不混淆地使用版本。我们可能会将`my_app-v1.1`作为顶级目录名称。该顶级目录中的应用程序必须有一个合适的Python名称，因此我们会看到`my_app-v1.1/my_app`作为应用程序的路径。
- en: The top-level directory should contain the `setup.py` file to install the application
    into Python's standard library structure. See *Distributing Python Modules* for
    more information. Additionally, of course, a `README` file would be placed in
    this directory.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级目录应该包含`setup.py`文件，以将应用程序安装到Python的标准库结构中。有关更多信息，请参见*分发Python模块*。此外，当然，`README`文件应该放在这个目录中。
- en: 'When the application modules and test modules are in separate directories,
    we need to refer to the application as an installed module when running tests.
    We can use the `PYTHONPATH` environment variable for this. We can run the test
    suite like the following code:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序模块和测试模块位于不同的目录中时，在运行测试时，我们需要将应用程序作为已安装的模块进行引用。我们可以使用`PYTHONPATH`环境变量来实现这一点。我们可以像以下代码一样运行测试套件：
- en: '[PRE155]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We set an environment variable on the same line where we execute a command.
    This may be surprising, but it's a first-class feature of the `bash` shell. This
    allows us to make a very localized override to the `PYTHONPATH` environment variable.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在执行命令的同一行上设置环境变量。这可能令人惊讶，但这是`bash` shell的一流特性。这使我们能够对`PYTHONPATH`环境变量进行非常局部的覆盖。
- en: Installing Python modules
  id: totrans-1062
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Python模块
- en: 'We have several techniques to install a Python module or package:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种技术来安装Python模块或包：
- en: We can write `setup.py` and use the distribution utilities module, `distutils`,
    to install the package into Python's `lib/site-packages` directory. See *Distributing
    Python Modules*.
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以编写`setup.py`并使用分发工具模块`distutils`将包安装到Python的`lib/site-packages`目录中。参见*分发Python模块*。
- en: We can set the `PYTHONPATH` environment variable to include our packages and
    modules. We can set this temporarily in a shell, or we can set it more permanently
    by editing our `~/.bash_profile` or the system's `/etc/profile`. We'll take a
    look at this in a little more depth in the later section.
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以设置`PYTHONPATH`环境变量以包括我们的包和模块。我们可以在shell中临时设置它，或者通过编辑我们的`~/.bash_profile`或系统的`/etc/profile`来更加永久地设置它。我们稍后将更深入地研究这个问题。
- en: We can include the `.pth` files to add directories to the import path. These
    files can be located in the local directory or `lib/site-packages` to provide
    an indirect reference to a module or package. See the `site` module documentation
    in *Python Standard Library* for more information.
  id: totrans-1066
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以包含`.pth`文件以将目录添加到导入路径。这些文件可以位于本地目录或`lib/site-packages`中，以提供对模块或包的间接引用。有关更多信息，请参阅*Python标准库*中的`site`模块文档。
- en: The local directory is a package as well. It's always first on the `sys.path`
    list. When working on a simple one-module Python application, this is very handy.
    When working on a more complex application, the current working directory may
    change as we edit different files, making it a poor choice.
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地目录也是一个包。它始终位于`sys.path`列表的第一位。在简单的单模块Python应用程序中，这非常方便。在更复杂的应用程序中，当前工作目录可能会随着编辑不同文件而更改，这使得它成为一个不好的选择。
- en: 'Setting the environment variable can be done transiently or persistently. We
    can set it in an interactive session with a command like the following code:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 设置环境变量可以是临时的或持久的。我们可以在交互式会话中使用以下代码来设置它：
- en: '[PRE156]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This sets `PYTHONPATH` to include the named directory when searching for a module.
    The module is effectively installed through this simple change to the environment.
    Nothing is written to Python's `lib/site-packages`.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`PYTHONPATH`设置为在搜索模块时包括指定目录。通过这种简单的环境更改，模块实际上被安装。没有写入Python的`lib/site-packages`。
- en: This is a transient setting that may be lost when we end the terminal session.
    The alternative is to update our `~/.bash_profile` to include a more permanent
    change to the environment. We simply append that `export` line to `.bash_profile`
    so that the package is used every time we log in.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个临时设置，当我们结束终端会话时可能会丢失。另一种选择是更新我们的`~/.bash_profile`以包含对环境的更加永久的更改。我们只需将`export`行附加到`.bash_profile`中，这样每次登录时都会使用该包。
- en: For users on a shared server, we might include the environment setting in `/etc/profile`
    so that they do not have to make changes to their `~/.bash_profile`. For users
    on individual workstations, offering `setup.py` based on `distutils` may be simpler
    than tweaking system settings.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 对于共享服务器上的用户，我们可以在`/etc/profile`中包含环境设置，这样他们就不必更改他们的`~/.bash_profile`。对于个人工作站上的用户，提供基于`distutils`的`setup.py`可能比调整系统设置更简单。
- en: For web applications, the Apache configuration may need to be updated to include
    access to the necessary Python modules. To support the rapid deployment of application
    changes, it's generally not necessary to use `setup.py` for a large, complex application.
    Instead, we often use a series of application directories and a simple `.pth`
    change or `PYTHONPATH` change to move to the new release.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序，Apache配置可能需要更新以包括对必要的Python模块的访问。为了支持应用程序变更的快速部署，通常不需要为大型复杂应用程序使用`setup.py`。相反，我们经常使用一系列应用程序目录和简单的`.pth`更改或`PYTHONPATH`更改来转移到新版本。
- en: 'We might have the following kind of directories owned by a fake user, `myapp`:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能拥有以下类型的目录，由一个虚拟用户`myapp`拥有：
- en: '[PRE157]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: This allows us to build a new release in parallel with an existing release.
    We can switch from Version 1.2 to Version 1.3 by changing `PYTHONPATH` to refer
    to `/Users/myapp/my_app-v1.3/my_app`.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够与现有版本并行构建新版本。我们可以通过将`PYTHONPATH`更改为引用`/Users/myapp/my_app-v1.3/my_app`来从版本1.2切换到版本1.3。
- en: Summary
  id: totrans-1077
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at a number of considerations to design modules and packages. The
    parallels between a module and singleton class are deep. When we design a module,
    the essential questions of the encapsulation of the structure and processing are
    as relevant as they are for class design.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了设计模块和包的许多考虑因素。模块和单例类之间的相似之处很深。当我们设计一个模块时，封装结构和处理的基本问题与类设计一样相关。
- en: When we design a package, we need to be skeptical of the need for deeply nested
    structures. We'll need to use packages when there are variant implementations;
    we looked at a number of ways to handle this variability. We may also need to
    define a package to combine a number of modules into a single module-like package.
    We looked at how `__init__.py` can import from within the package.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计一个包时，我们需要对深度嵌套结构的需求持怀疑态度。当存在变体实现时，我们需要使用包；我们研究了处理这种变化的多种方法。我们还可能需要定义一个包，将多个模块组合成一个类似模块的包。我们研究了`__init__.py`如何从包内导入。
- en: Design considerations and trade-offs
  id: totrans-1080
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: We have a deep hierarchy of packaging techniques. We can simply organize the
    functionality into defined functions. We can combine the defined functions and
    their related data into a class. We can combine related classes into a module.
    We can combine related modules into a package.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个深层次的打包技术层次结构。我们可以简单地将功能组织成定义的函数。我们可以将定义的函数及其相关数据组合成一个类。我们可以将相关类组合成一个模块。我们可以将相关模块组合成一个包。
- en: When we think of software as a language to capture knowledge and representation,
    we have to consider what a class or module *means*. A module is the unit of the
    Python software construction, distribution, use, and reuse. With rare exceptions,
    modules must be designed around the possibility of reuse.
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们把软件看作是捕捉知识和表示的语言时，我们必须考虑类或模块的*含义*。模块是Python软件构建、分发、使用和重用的单位。除了少数例外，模块必须围绕重用的可能性进行设计。
- en: In most cases, we'll use a class because we expect to have multiple objects
    that are instances of the class. Often—but not universally—a class will have stateful
    instance variables.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们会使用类，因为我们期望有多个类的实例对象。通常情况下，一个类会有有状态的实例变量。
- en: When we look at classes with only a single instance, it's not perfectly clear
    if a class is truly necessary. Standalone functions may be as meaningful as a
    single-instance class. In some instances, a module of separate functions may be
    an appropriate design because modules are inherently singletons.
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到只有一个实例的类时，不太清楚是否真的需要一个类。独立的函数可能和单实例类一样有意义。在某些情况下，一个由单独函数组成的模块可能是一个合适的设计，因为模块本质上是单例的。
- en: A stateful module—such as a stateful class—is the general expectation. A module
    is a namespace with local variables that can be modified.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态的模块——比如有状态的类——是一般的期望。模块是一个带有可以修改的局部变量的命名空间。
- en: While we can create immutable classes (using `__slots__`, extending `tuple`,
    or overriding the attribute setter methods), we can't easily create an immutable
    module. There doesn't seem to be a use case for an immutable module object.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以创建不可变的类（使用`__slots__`，扩展`tuple`，或者重写属性设置方法），但我们不能轻易地创建一个不可变的模块。似乎没有不可变模块对象的用例。
- en: A small application may be a single module. A larger application will often
    be a package. As with module design, packages should be designed for reuse. A
    larger application package should properly include a `__main__` module.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小应用可能是一个单一模块。一个更大的应用通常会是一个包。与模块设计一样，包应该被设计用于重用。一个更大的应用程序包应该正确地包含一个`__main__`模块。
- en: Looking forward
  id: totrans-1088
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 期待
- en: In the next chapter, we'll consolidate a number of our OO design techniques.
    We'll take a look at the overall quality of our design and implementation. One
    consideration is assuring others that our software is trustworthy. One aspect
    of trustworthy software is coherent, easy-to-use documentation.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将整合许多我们的OO设计技术。我们将审视我们设计和实现的整体质量。一个考虑是确保他人信任我们的软件。可信赖软件的一个方面是连贯、易于使用的文档。
- en: Chapter 18. Quality and Documentation
  id: totrans-1090
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章。质量和文档
- en: 'Good software doesn''t just happen; it''s crafted. A deliverable product includes
    readable, accurate documentation. We''ll look at two tools to produce the documentation
    from the code: `pydoc` and Sphinx. The Sphinx tool is enhanced if we write the
    documentation using a lightweight markup language. We''ll describe some features
    of **ReStructured Text** (**RST**) to help make our documentation more readable.'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的软件不是偶然发生的；它是精心制作的。可交付的产品包括可读的、准确的文档。我们将介绍两种从代码生成文档的工具：`pydoc`和Sphinx。如果我们使用一种轻量级标记语言编写文档，Sphinx工具将得到增强。我们将描述一些**ReStructured
    Text**（**RST**）的特性，以帮助我们的文档更易读。
- en: Documentation is an important quality aspect of software; it is one aspect of
    building trust. Test cases are another way to build trust. Using `doctest` to
    write test cases addresses both the quality aspects.
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 文档是软件的一个重要质量方面；它是建立信任的一个方面。测试用例是建立信任的另一种方式。使用`doctest`编写测试用例可以同时解决这两个质量方面的问题。
- en: We'll also take a brief look at literate programming techniques. The idea is
    to write a pleasant, easy-to-understand document that contains the entire body
    of the source code along with explanatory notes and design details. Literate programming
    isn't simple, but it can produce good code coupled with a resulting document that
    is very clear and complete.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将简要介绍文学编程技术。其思想是编写一个愉快、易于理解的文档，其中包含整个源代码主体以及解释性注释和设计细节。文学编程并不简单，但它可以产生良好的代码，同时产生一个非常清晰和完整的文档。
- en: Writing docstrings for the help() function
  id: totrans-1094
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为help()函数编写文档字符串
- en: Python provides numerous places to include the documentation. The definition
    of a package, module, class, or function has room for a string that includes a
    description of the object that is being defined. Throughout this book, we avoided
    showing you docstrings in each example because our focus is on the Python programming
    details, not the overall software product that is being delivered.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了许多包含文档的地方。包、模块、类或函数的定义都有一个字符串的位置，其中包含了正在定义的对象的描述。在本书中，我们避免在每个示例中展示文档字符串，因为我们的重点是Python编程细节，而不是正在交付的整体软件产品。
- en: 'As we move beyond advanced OO design and look at the overall deliverable product,
    docstrings become an important part of the deliverable. Docstrings can provide
    us with several key pieces of information:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们超越高级OO设计，看整体可交付产品时，文档字符串成为交付的重要部分。文档字符串可以为我们提供一些关键信息：
- en: 'The API: the parameters, return values, and exceptions raised.'
  id: totrans-1097
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API：参数、返回值和引发的异常。
- en: A description of what to expect.
  id: totrans-1098
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 期待的描述。
- en: Optionally, the `doctest` test results. For more information, see [Chapter 15](ch15.html
    "Chapter 15. Designing for Testability"), *Designing for Testability*.
  id: totrans-1099
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，`doctest`测试结果。更多信息，请参见[第15章](ch15.html "第15章。可测试性设计")，*可测试性设计*。
- en: We can, of course, write even more in a docstring. We can provide more details
    on the design, architecture, and requirements. At some point, these more abstract,
    higher-level considerations are not directly tied to the Python code. This higher-level
    design and the requirements don't properly belong to the code or the docstrings.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以在文档字符串中写更多内容。我们可以提供有关设计、架构和要求的更多细节。在某个时候，这些更抽象、更高层次的考虑并不直接与Python代码相关。这种更高层次的设计和要求并不适合于代码或文档字符串。
- en: The `help()` function extracts and displays the docstrings. It performs some
    minimal formatting on the text. The `help()` function is installed into the interactive
    Python environment by the `site` package. The function is actually defined in
    the `pydoc` package. In principle, we can import and extend this package to customize
    the `help()` output.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '`help()`函数提取并显示文档字符串。它对文本进行了一些最小的格式化。`help()`函数由`site`包安装到交互式Python环境中。该函数实际上是在`pydoc`包中定义的。原则上，我们可以导入并扩展此包以自定义`help()`输出。'
- en: Writing documentation that is suitable for `help()` is relatively simple. Here's
    a typical example of output from `help(round)`.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 编写适用于`help()`的文档相对简单。以下是`help(round)`的典型输出示例。
- en: '[PRE158]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'This shows us the required elements: the summary, the API, and the description.
    The API and the summary are the first line: `function( parameters ) -> results`.'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了所需的元素：摘要、API和描述。 API和摘要是第一行：`function( parameters ) -> results`。
- en: The description text defines what the function does. More complex functions
    may describe exceptions or edge cases that might be important or unique to this
    function. The `round()` function, for example, doesn't detail things, such as
    `TypeError`, that might get raised.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 描述文本定义了函数的功能。更复杂的函数可能描述了可能对这个函数重要或独特的异常或边缘情况。例如，`round()`函数并没有详细说明可能引发的`TypeError`等情况。
- en: A `help()` oriented docstring is expected to be pure text with no markup. We
    can add some RST markup but it isn't used by `help()`.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '`help()`导向的文档字符串预期是纯文本，没有标记。我们可以添加一些RST标记，但`help()`不会使用它。'
- en: To make `help()` work, we simply provide docstrings. As it's so simple, there's
    no reason not to do it. Every function or class needs a docstring so that `help()`
    shows us something useful.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`help()`起作用，我们只需提供文档字符串。因为它如此简单，没有理由不这样做。每个函数或类都需要一个文档字符串，以便`help()`显示出有用的内容。
- en: Using pydoc for documentation
  id: totrans-1108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pydoc进行文档编写
- en: We use the library module `pydoc` to produce HTML documentation from Python
    code. It turns out that we're using it when we evaluate the `help()` function
    in interactive Python. This function produces the *text mode* documentation with
    no markup.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用库模块`pydoc`从Python代码生成HTML文档。事实证明，当我们在交互式Python中评估`help()`函数时，我们正在使用它。此函数生成没有标记的*文本模式*文档。
- en: 'When we use `pydoc` to produce the documentation, we''ll use it in one of the
    following three ways:'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`pydoc`来生成文档时，我们将以以下三种方式之一使用它：
- en: Prepare text-mode documentation files and view them with command-line tools
    such as `more` or `less`
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备文本模式文档文件，并使用诸如`more`或`less`等命令行工具查看它们
- en: Prepare HTML documentation and save a file for browsing later
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备HTML文档并保存文件以供以后浏览
- en: Run an HTTP server and create the HTML files as needed for browsing immediately
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动HTTP服务器并根据需要创建HTML文件进行浏览
- en: 'We can run the following command-line tool to prepare the text-based documentation
    for a module:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行以下命令行工具来准备模块的基于文本的文档：
- en: '[PRE159]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'We can also use the following code:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下代码：
- en: '[PRE160]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Either command will create text documentation based on the Python code. The
    output will be displayed with programs such as `less` (on Linux or Mac OS X) or
    `more` (on Windows) that paginate the long stream of output.
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 任一命令都将基于Python代码创建文本文档。输出将显示在诸如`less`（在Linux或Mac OS X上）或`more`（在Windows上）等分页长输出流的程序中。
- en: Ordinarily, `pydoc` presumes that we're providing a module name to import. This
    means that the module must be on the Python path for ordinary import. As an alternative,
    we can specify a physical filename by including a path separator character `/`
    (on Linux or Mac OS X) or `\` (on Windows) and the `.py` filename extension. Something
    such as `pydoc ./mymodule.py` will work to pick a file that's not on the import
    path.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`pydoc`假设我们提供了要导入的模块名称。这意味着模块必须在Python路径上进行普通导入。作为替代，我们可以通过包括路径分隔符字符`/`（在Linux或Mac
    OS X上）或`\`（在Windows上）和`.py`文件扩展名来指定物理文件名。例如`pydoc ./mymodule.py`将可以选择一个不在导入路径上的文件。
- en: 'To view the HTML documentation, we use the `-w` option. This will write an
    HTML file into the local directory:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看HTML文档，我们使用`-w`选项。这将在本地目录中写入一个HTML文件：
- en: '[PRE161]'
  id: totrans-1121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'We can then open `somemodule.html` in a browser to read the documentation for
    the given module. The third option is to start a special-purpose web server to
    browse a package or module''s documentation. In addition to simply starting the
    server, we can combine starting the server and launching our default browser.
    Here''s a way to simply start a server on port 8080:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在浏览器中打开`somemodule.html`来阅读给定模块的文档。第三个选项是启动一个专用的Web服务器来浏览包或模块的文档。除了简单地启动服务器外，我们还可以结合启动服务器和启动默认浏览器。以下是一种简单启动端口8080上服务器的方法：
- en: '[PRE162]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This will start an HTTP server that looks at the code in the current directory.
    If the current directory is a proper package (that is, it has a `__init__.py`
    file), then there will be a nice top-level module index.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启动一个HTTP服务器，查看当前目录中的代码。如果当前目录是一个合适的包（即它有一个`__init__.py`文件），那么将会有一个很好的顶级模块索引。
- en: Once we've started a server, we can point a browser at `http://localhost:8080`
    to view the documentation. We can also use a rewrite rule to point a local Apache
    server at this `pydoc` server so that a team can share the documentation on a
    web server.
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们启动了服务器，我们可以将浏览器指向`http://localhost:8080`来查看文档。我们还可以使用重写规则将本地Apache服务器指向这个`pydoc`服务器，以便团队可以在Web服务器上共享文档。
- en: 'We can also start both a local server and a browser at the same time:'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以同时启动本地服务器和浏览器：
- en: '[PRE163]'
  id: totrans-1127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: This will locate an unused port, start a server, and then launch your default
    browser to point at the server. Note the use of the `python3.3` command; this
    doesn't work in the older releases of Python.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将找到一个未使用的端口，启动服务器，然后启动默认浏览器指向服务器。注意使用`python3.3`命令；这在旧版本的Python中不起作用。
- en: It's not easy to customize the output from `pydoc`. The various styles and colors
    are effectively hardcoded into the class definitions. Revising and expanding `pydoc`
    to use the external CSS styles would be an interesting exercise.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 定制`pydoc`的输出并不容易。各种样式和颜色实际上都是硬编码到类定义中的。修改和扩展`pydoc`以使用外部CSS样式将是一个有趣的练习。
- en: Better output via the RST markup
  id: totrans-1130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过RST标记提供更好的输出
- en: 'Our documentation can be much nicer if we use a more sophisticated toolset.
    There are several things that we''d like to be able to do, such as the following:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用更复杂的工具集，我们的文档可以更加美观。有几件事情我们希望能够做，比如以下：
- en: Fine-tune the presentation to include emphasis such as bold, italic, or color.
  id: totrans-1132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调呈现以包括加粗、斜体或颜色等强调。
- en: Provide the semantic markup for the parameters, return values, exceptions, and
    cross-references among Python objects.
  id: totrans-1133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为参数、返回值、异常和Python对象之间的交叉引用提供语义标记。
- en: Provide a link to view the source code.
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供查看源代码的链接。
- en: 'Filter the code that''s included or rejected. We can fine-tune this filtering
    to include or exclude a number of components and members: standard library modules,
    private members with a leading `__`, system members with a leading `__`, or superclass
    members.'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤包含或拒绝的代码。我们可以微调此过滤器，以包括或排除许多组件和成员：标准库模块、以`__`开头的私有成员、以`__`开头的系统成员或超类成员。
- en: Adjust the CSS to provide a different style for the resulting HTML pages.
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整CSS以为生成的HTML页面提供不同的样式。
- en: We can address the first two requirements through more sophisticated markup
    in our docstrings; we'll need to use the RST markup language. We'll need an additional
    tool to address the last three requirements.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过docstrings中更复杂的标记来满足前两个要求；我们需要使用RST标记语言。我们需要另一个工具来满足最后三个要求。
- en: Once we start using more sophisticated markup, we can branch out beyond HTML
    to include LaTeX for even better-looking documentation. This allows us to also
    produce PostScript or PDF output in addition to HTML from a single source.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们开始使用更复杂的标记，我们可以扩展到超出HTML，包括LaTeX以获得更美观的文档。这使我们还可以从单一源生成除HTML之外的PostScript或PDF输出。
- en: RST is a simple, lightweight markup. There are plenty of good tutorials and
    summaries associated with the Python `docutils` project. See [http://docutils.sourceforge.net](http://docutils.sourceforge.net)
    for details.
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
  zh: RST是一种简单、轻量级的标记语言。与Python `docutils`项目相关的教程和摘要有很多。详情请参见[http://docutils.sourceforge.net](http://docutils.sourceforge.net)。
- en: 'A quick overview is available here: [http://docutils.sourceforge.net/docs/user/rst/quickstart.html](http://docutils.sourceforge.net/docs/user/rst/quickstart.html).'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速概述：[http://docutils.sourceforge.net/docs/user/rst/quickstart.html](http://docutils.sourceforge.net/docs/user/rst/quickstart.html)。
- en: The point of the `docutils` toolset is that a very smart parser allows us to
    use very simple markup. HTML and XML rely on a relatively unsophisticated parser
    and put the burden on the human (or an editing tool) to create the complex markup.
    While XML and HTML allow for a wide variety of use cases, the `docutils` parser
    is more narrowly focused on the natural language text. Because of the narrow focus,
    `docutils` is able to deduce our intent based on the use of blank lines and some
    ASCII punctuation characters.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '`docutils`工具集的要点是，一个非常智能的解析器允许我们使用非常简单的标记。HTML和XML依赖于一个相对不太复杂的解析器，并将复杂的标记的负担放在人类（或编辑工具）身上。虽然XML和HTML允许各种用例，但`docutils`解析器更专注于自然语言文本。由于狭窄的焦点，`docutils`能够根据空行和一些ASCII标点字符推断我们的意图。'
- en: 'For our purposes, the `docutils` parser recognizes the following three fundamental
    things:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，`docutils`解析器识别以下三个基本事物：
- en: 'Blocks of text: paragraphs, headings, lists, block quotes, code samples, and
    the `doctest` blocks. These are all separated by blank lines.'
  id: totrans-1143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本块：段落、标题、列表、块引用、代码示例和`doctest`块。这些都是由空行分隔的。
- en: Inline markup can appear inside the text blocks. This involves the use of simple
    punctuation to mark the characters within the text block. There are two kinds
    of inline markup; we'll look at the details in the later section.
  id: totrans-1144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内联标记可以出现在文本块内。这涉及使用简单的标点符号来标记文本块内的字符。有两种内联标记；我们将在后面的部分详细讨论。
- en: Directives are also blocks of text, but they begin with `..` as the first two
    characters of the line. Directives are open-ended and can be extended to add features
    to docutils.
  id: totrans-1145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指令也是文本块，但它们以`..`作为行的前两个字符开始。指令是开放的，可以扩展以向docutils添加功能。
- en: Blocks of text
  id: totrans-1146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本块
- en: 'A block of text is simply a paragraph, set off from other paragraphs by a blank
    line. This is the fundamental unit of the RST markup. RST recognizes a number
    of kinds of paragraphs, based on the pattern that is followed. Here''s an example
    of a heading:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 文本块就是一个段落，由一个空行与其他段落分隔开。这是RST标记的基本单位。RST识别了许多种类的段落，基于遵循的模式。这是一个标题的例子：
- en: '[PRE164]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: This is recognized as a heading because it's *underlined* with a repeated string
    of special characters.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 这被识别为标题，因为它用一系列特殊字符*下划线*标记。
- en: The `docutils` parser deduces the hierarchy of title underlines based entirely
    on their usage. We must be consistent with our headings and their nesting. It
    helps to pick a standard and stick to it. It also helps to keep documents fairly
    *flat* without complex, nested headings. Three levels are often all that's needed;
    this means that we can use `====`, `----`, and `~~~~` for the three levels.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: '`docutils`解析器完全基于它们的使用推断标题下划线的层次结构。我们必须在标题和它们的嵌套上保持一致。选择一个标准并坚持下去是有帮助的。保持文档相对*平坦*而不是复杂的、嵌套的标题也是有帮助的。通常只需要三个级别；这意味着我们可以使用`====`、`----`和`~~~~`来表示三个级别。'
- en: 'A bullet list item begins with a special character; the content must also be
    indented. As Python uses a 4-space indent, this is common in RST as well. However,
    almost any consistent indent will work:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 项目符号列表项以特殊字符开头；内容也必须缩进。由于Python使用4个空格缩进，这在RST中也很常见。然而，几乎任何一致的缩进都可以工作：
- en: '[PRE165]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Note the blank line between paragraphs. For some kinds of simple bullet lists,
    the blank lines aren't required. In general, blank lines are a good idea.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意段落之间的空行。对于某些简单的项目符号列表，空行不是必需的。一般来说，空行是个好主意。
- en: 'A numeric list begins with a digit or letter and a roman numeral. To have numbers
    generated automatically, `#` can be used as the list item:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 数字列表以数字或字母和罗马数字开头。要自动生成数字，可以使用`#`作为列表项：
- en: '[PRE166]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: We can use the indent rules to create lists within lists. It can be complex,
    and the `docutils` RST parser will usually figure out what you meant.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用缩进规则在列表中创建列表。这可能会很复杂，`docutils` RST解析器通常会弄清楚你的意思。
- en: 'A block quote is simply indented text:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 块引用只是缩进的文本：
- en: '[PRE167]'
  id: totrans-1158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: Code samples are indicated with a `::` double colon; they are indented and they
    end with a blank line. While `::` can be at the end of a line or on a line by
    itself, putting `::` on a separate line makes it slightly easier to find code
    samples.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例用双冒号`::`表示；它们是缩进的，并以空行结束。虽然`::`可以在行尾或单独一行，但将`::`放在单独一行上会使查找代码示例稍微容易一些。
- en: 'Here''s a code sample:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个代码示例：
- en: '[PRE168]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: The `docutils` parser will also locate the `doctest` material and set it aside
    for special formatting, similar to a code block. They begin with `>>>` and end
    with a blank line.
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: '`docutils`解析器还会找到`doctest`材料并将其放在一边进行特殊格式化，类似于代码块。它们以`>>>`开头，并以空行结尾。'
- en: 'Here''s some sample output from `doctest`:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些`doctest`的示例输出：
- en: '[PRE169]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The blank line at the end of the test output is essential and is easily overlooked.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 测试输出末尾的空行是必不可少的，而且很容易被忽视。
- en: The RST inline markup
  id: totrans-1166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RST内联标记
- en: Within most blocks of text, we can include inline markup. We can't include inline
    markup in the code samples or `doctest` blocks. Note that we cannot nest inline
    markup, either.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数文本块中，我们可以包含内联标记。我们不能在代码示例或`doctest`块中包含内联标记。请注意，我们也不能嵌套内联标记。
- en: The RST inline markup includes a variety of common ASCII treatments of text.
    For example, we have `*emphasis*` and `**strong emphasis**`, which will usually
    produce italic and bold respectively. We might want to emphasize code segments
    within a block of text; we use [PRE170] to force a monospaced font.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: RST内联标记包括各种常见的ASCII文本处理。例如，我们有`*emphasis*`和`**strong emphasis**`，通常会分别产生斜体和粗体。我们可能想要强调文本块中的代码段；我们使用[PRE170]来强制使用等宽字体。
- en: 'We can also include cross-references as the inline markup. A trailing `_` indicates
    a reference, and it points away; a leading `_` indicates a target, and it points
    toward. For example, we might have ``some phrase`_` as a reference. We can then
    use `_`some phrase`` as the target for that reference. We don''t need to provide
    explicit targets for section titles: we can reference ``This Is A Heading`_` because
    all the section titles are already defined as targets. For the HTML output, this
    will generate the expected `<a>` tags. For the PDF output, in-text links will
    be generated.'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将交叉引用包含在内联标记中。尾部的`_`表示一个引用，并指向外部；前面的`_`表示一个目标，并指向内部。例如，我们可能有``some phrase`_`作为一个引用。然后我们可以使用`_`some
    phrase``作为该引用的目标。我们不需要为节标题提供显式目标：我们可以引用``This Is A Heading`_`，因为所有的节标题都已经定义为目标。对于HTML输出，这将生成预期的`<a>`标签。对于PDF输出，将生成文本链接。
- en: We cannot nest inline markup. There's little need for nested inline markup;
    using too many typographic tricks devolves to visual clutter. If our writing is
    so sensitive to typography, we should probably use LaTeX directly.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能嵌套内联标记。嵌套内联标记几乎没有必要；使用太多的排版技巧会导致视觉混乱。如果我们的写作对排版非常敏感，我们可能应该直接使用LaTeX。
- en: Inline markup can also have explicit role indicators. This is `:role:` followed
    by ``text``. Simple RST has relatively few roles. We might use `:code:`some code``
    to be more explicit about the presence of a code sample in the text. When we look
    at Sphinx, there are numerous role indicators. The use of explicit roles can provide
    a great deal of semantic information.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 内联标记也可以有显式的角色指示符。这是`:role:`后面跟着``text``。简单的RST具有相对较少的角色。我们可以使用`:code:`some code``来更明确地表示文本中存在代码示例。当我们使用Sphinx时，会有许多角色指示符。使用显式角色可以提供大量的语义信息。
- en: 'When doing things that have more complex math, we might use the LaTeX math
    typesetting capabilities. This uses the `:math:` role; it looks like this: `:math:`a=\pi
    r^2``.'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 在做一些更复杂的数学运算时，我们可能会使用LaTeX数学排版功能。这使用了`:math:`角色；它看起来像这样：`:math:`a=\pi r^2``。
- en: Roles are open-ended. We can provide a configuration to docutils that adds new
    roles.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 角色是开放式的。我们可以提供一个配置给docutils，以添加新的角色。
- en: RST directives
  id: totrans-1174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RST指令
- en: RST also includes directives. A directive is written in a block that starts
    with `..`; it may have content that's indented. It may also have parameters. RST
    has a large number of directives that we might use to create a more sophisticated
    document. For docstring preparation, we'll rarely use more than a few of the available
    directives. The directives are open-ended; tools such as Sphinx will add directives
    to produce more sophisticated documentation.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: RST还包括指令。指令是以`..`开头的块写的；它可能有缩进的内容。它也可能有参数。RST有大量的指令，我们可以使用它们来创建更复杂的文档。对于文档准备，我们很少会使用到可用指令的大部分。指令是开放式的；诸如Sphinx之类的工具将添加指令以生成更复杂的文档。
- en: 'Three commonly used directives are `image`, `csv-table`, and `math`. If we
    have an image that should be part of our document, we might include it in the
    following way:'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 三个常用的指令是`image`，`csv-table`和`math`。如果我们有一个应该包含在文档中的图像，我们可以这样包含它：
- en: '[PRE171]'
  id: totrans-1177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: We named the file `media/some_file.png`. We also provided it with a `width`
    parameter to ensure that our image fits our document page layout. There are a
    number of other parameters that we can use to adjust the presentation of an image.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文件命名为`media/some_file.png`。我们还提供了一个`width`参数，以确保我们的图像适合我们的文档页面布局。我们可以使用许多其他参数来调整图像的呈现方式。
- en: '`:align`: We can provide keywords such as `top`, `middle`, `bottom`, `left`,
    `center`, or `right`. This value will be provided to the `align` attribute of
    the HTML `<img>` tag.'
  id: totrans-1179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:align`: 我们可以提供关键字，如`top`，`middle`，`bottom`，`left`，`center`或`right`。这个值将提供给HTML
    `<img>`标签的`align`属性。'
- en: '`:alt`: This is the alternative text for the image. This value will be provided
    to the `alt` attribute of the HTML `<img>` tag.'
  id: totrans-1180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:alt`: 这是图像的替代文本。这个值将提供给HTML `<img>`标签的`alt`属性。'
- en: '`:height`: This is the height of the image.'
  id: totrans-1181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:height`: 这是图像的高度。'
- en: '`:scale`:This is a scale factor that can be provided instead of the height
    and width.'
  id: totrans-1182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:scale`: 这是一个比例因子，可以代替高度和宽度。'
- en: '`:width`: This is the width of the image.'
  id: totrans-1183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:width`: 这是图像的宽度。'
- en: '`:target`: This is a target hyperlink for the image. This can be a complete
    URI or an RST reference of the ``name`_` form.'
  id: totrans-1184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:target`: 这是图像的目标超链接。这可以是完整的URI，也可以是``name`_`形式的RST引用。'
- en: 'For the height and width, any of the length units available in CSS can be used.
    These include `em` (the height of the element''s font), `ex` (the height of the
    letter "x"), `px` (pixels), as well as absolute sizes: `in`, `cm`, `mm`, `pt`
    (point), and `pc` (pica).'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度和宽度，可以使用CSS中可用的任何长度单位。这些包括`em`（元素的字体高度），`ex`（字母“x”的高度），`px`（像素），以及绝对尺寸：`in`，`cm`，`mm`，`pt`（点），和`pc`（pica）。
- en: 'We can include a table in our document in the following manner:'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以以下方式在我们的文档中包含一个表格：
- en: '[PRE172]'
  id: totrans-1187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'This allows us to prepare data that will become a complex HTML table in a simple
    CSV notation. We can have a more complex formula using the `math` directive:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够准备数据，将其转换为简单的CSV符号，成为一个复杂的HTML表。我们可以使用`math`指令来使用更复杂的公式：
- en: '[PRE173]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: This allows us to write larger LaTeX math that will be a separate equation.
    These can be numbered and cross-referenced as well.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够编写更大的LaTeX数学公式，这将成为一个单独的方程。这些可以进行编号和交叉引用。
- en: Learning RST
  id: totrans-1191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 学习RST
- en: One way to build skills in RST is to install `docutils` and use the `rst2html.py`
    script to parse an RST document and convert it to HTML pages. A simple practice
    document can easily show us the various RST features.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 学习RST的一种方法是安装`docutils`并使用`rst2html.py`脚本解析RST文档并将其转换为HTML页面。一个简单的练习文档可以很容易地展示给我们各种RST特性。
- en: All of a project's requirements, architecture, and documentation can be written
    using RST and transformed into HTML or LaTeX. It's relatively inexpensive to write
    user stories in RST and drop those files into a directory that can be organized
    and reorganized as stories are groomed, put into development, and implemented.
    More complex tools may not be any more valuable than `docutils`.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个项目的所有需求、架构和文档都可以使用RST编写，并转换为HTML或LaTeX。在RST中编写用户故事并将这些文件放入一个可以组织和重组的目录中相对廉价。更复杂的工具可能并不比`docutils`更有价值。
- en: The advantage of using pure text files and the RST markup is that we can easily
    manage our documentation in parallel with our source code. We're not using a proprietary
    word processing file format. We're not using a wordy and long-winded HTML or XML
    markup that must be compressed to be practical. We're simply storing more text
    along with the source code.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯文本文件和RST标记的优势在于，我们可以轻松地与源代码并行管理我们的文档。我们不使用专有的文字处理文件格式。我们不使用冗长的HTML或XML标记，必须压缩才能实用。我们只是存储更多的文本以及源代码。
- en: If we're using RST to create the documentation, we can also use the `rst2latex.py`
    script to create a `.tex` file that we can run through a LaTeX toolset to create
    postscript or PDF documents. This requires a LaTeX toolset; usually, the **TeXLive**
    distribution is used for this. See [http://www.tug.org/texlive/](http://www.tug.org/texlive/)
    for a comprehensive set of tools to transform TeX into elegant, final documents.
    TeXLive includes the pdfTeX tool that can be used to convert the LaTeX output
    into a PDF file.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在使用RST创建文档，我们还可以使用`rst2latex.py`脚本创建一个`.tex`文件，然后可以通过LaTeX工具集运行它来创建postscript或PDF文档。这需要一个LaTeX工具集；通常，**TeXLive**发行版用于此。请参阅[http://www.tug.org/texlive/](http://www.tug.org/texlive/)，了解将TeX转换为优雅的最终文档的全面工具集。TeXLive包括pdfTeX工具，可用于将LaTeX输出转换为PDF文件。
- en: Writing effective docstrings
  id: totrans-1196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写有效的文档字符串
- en: 'When writing docstrings, we need to focus on the essential information that
    our audience needs. When we look at using a library module, what do we need to
    know? Whatever questions we ask, other programmers will often have similar questions.
    There are two boundaries that we should stay inside when we write docstrings:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写文档字符串时，我们需要专注于受众需要的基本信息。当我们使用一个库模块时，我们需要知道什么？无论我们问什么问题，其他程序员通常也会有类似的问题。当我们编写文档字符串时，我们应该留在两个边界内：
- en: It's best to avoid abstract overviews, high-level requirements, user stories,
    or background that is not tied directly to the code. We should focus the docstring
    on the code itself. We should provide the background in a separate document. A
    tool such as Sphinx can combine background material and code into a single document.
  id: totrans-1198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好避免抽象的概述、高层需求、用户故事或与代码直接无关的背景。我们应该把文档字符串的重点放在代码本身上。我们应该在单独的文档中提供背景信息。像Sphinx这样的工具可以将背景材料和代码合并到一个文档中。
- en: It's best to also avoid overly detailed *how it works* implementation trivia.
    The code is readily available, so there's no point in recapitulating the code
    in the documentation. If the code is too obscure, perhaps it should be rewritten
    to make it clearer.
  id: totrans-1199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最好也避免过于详细的*工作原理*实现细节。代码是readily available的，因此在文档中重复代码是没有意义的。如果代码太难理解，也许应该重新编写以使其更清晰。
- en: Perhaps the single most important thing that developers want is a working example
    of how to use the Python object. The RST `::` literal block is the backbone of
    these examples.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 也许开发人员最想要的是如何使用Python对象的工作示例。RST `::`文字块是这些示例的支柱。
- en: 'We''ll often write code samples in the following manner:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常以以下方式编写代码示例：
- en: '[PRE174]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The double colon, `::`, precedes an indented block. The indented block is recognized
    by the RST parser as code and will be literally passed through to the final document.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 双冒号`::`在缩进块之前。RST解析器识别缩进块为代码，并将其直接传递到最终文档。
- en: In addition to an example, the formal API is also important. We'll take a look
    at several API definition techniques in the later section. These rely on the RST
    *field list* syntax. It's very simple, which makes it very flexible.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 除了示例，正式的API也很重要。我们将在后面的部分看一下几种API定义技术。这些依赖于RST *field list*语法。它非常简单，这使得它非常灵活。
- en: 'Once we''re past the example and the API, there are a number of other things
    that compete for third place. What else we need to write depends on the context.
    There appear to be three cases:'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了示例和API，还有许多其他事情争夺第三名。我们需要写什么取决于上下文。似乎有三种情况：
- en: '**Files (including packages and modules)**: In these cases, we''re providing
    an overview or introduction to a collection of modules, classes, or function definitions.
    We need to provide a simple roadmap or overview of the various elements in the
    file. In the case where the module is relatively small, we might provide the doctest
    and code samples at this level.'
  id: totrans-1206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件（包括包和模块）**：在这些情况下，我们提供了对模块、类或函数定义集合的概述或介绍。我们需要提供文件中各个元素的简单路线图或概述。在模块相对较小的情况下，我们可能会在这个级别提供doctest和代码示例。'
- en: '**Classes (including method functions)**: This is where we often provide code
    samples and `doctest` blocks that explain the class API. Because a class may be
    stateful and may have a relatively complex API, we may need to provide rather
    lengthy documentation. Individual method functions will often have detailed documentation.'
  id: totrans-1207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类（包括方法函数）**：这通常是我们提供代码示例和`doctest`块来解释类API的地方。因为类可能是有状态的，可能有相对复杂的API，我们可能需要提供相当长的文档。单独的方法函数通常会有详细的文档。'
- en: '**Functions**: We may provide code samples and `doctest` blocks that explain
    the function. Because a function is often stateless, we may have a relatively
    simple API. In some cases, we may avoid more sophisticated RST markup and focus
    on the `help()` function''s documentation.'
  id: totrans-1208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数**：我们可能会提供代码示例和`doctest`块来解释函数。因为函数通常是无状态的，我们可能有一个相对简单的API。在某些情况下，我们可能会避免更复杂的RST标记，而专注于`help()`函数的文档。'
- en: We'll take a look at each of these broad, vague documentation contexts in some
    detail.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细研究这些广泛的、模糊的文档上下文。
- en: Writing file-level docstrings, including modules and packages
  id: totrans-1210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写文件级别的文档字符串，包括模块和包
- en: A package or a module's purpose is to contain a number of elements. A package
    contains modules as well as classes, global variables, and functions. A module
    contains classes, global variables, and functions. The top-level docstrings on
    these containers can act as road-maps to explain the general features of the package
    or module. The details are delegated to the individual classes or functions.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 包或模块的目的是包含一些元素。包含模块、类、全局变量和函数。模块包含类、全局变量和函数。这些容器的顶层文档字符串可以充当路线图，解释包或模块的一般特性。细节委托给各个类或函数。
- en: 'We might have a module docstring that looks like the following code:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个模块文档字符串，看起来像下面的代码：
- en: '[PRE175]'
  id: totrans-1213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Most of the text in this docstring provides a roadmap to the contents of this
    module. It describes the class hierarchies, making it slightly easier to locate
    a relevant class.
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档字符串中的大部分文本提供了对该模块内容的路线图。它描述了类层次结构，使得定位相关类稍微容易一些。
- en: The docstring includes a simple example of the `card()` factory function based
    on `doctest`. This advertises this function as an important feature of the module
    as a whole. It might make sense to provide the `doctest` explanation of the `Shoe`
    class, as that's perhaps the most important part of this module.
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串包括基于`doctest`的`card()`工厂函数的简单示例。这将该函数作为整个模块的重要特性进行宣传。也许有必要提供`Shoe`类的`doctest`解释，因为这可能是该模块最重要的部分。
- en: This docstring includes some inline RST markup to put class names into a monospaced
    font. The section titles are *underlined* with `===` and `---` lines. The RST
    parser can determine that the heading underlined with `===` is the parent of the
    headings underlined with `---`.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档字符串包括一些内联的RST标记，将类名放入等宽字体中。章节标题用`===`和`---`线*下划线*。RST解析器可以确定用`===`下划线划线划线划线的标题是用`---`下划线划线划线划线的标题的父标题。
- en: We'll look at using Sphinx to produce the documentation, in the later section.
    Sphinx will leverage the RST markup to produce great-looking HTML documentation.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的部分看一下使用Sphinx生成文档。Sphinx将利用RST标记生成漂亮的HTML文档。
- en: Writing API details in RST markup
  id: totrans-1218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用RST标记编写API细节
- en: 'One of the benefits of using the RST markup is that we can provide formal API
    documentation. The API parameters and return values are formatted using an RST
    *field list*. Generally, a field list has the following form:'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RST标记的好处之一是我们可以提供正式的API文档。API参数和返回值使用RST *field list*格式化。通常，字段列表的形式如下：
- en: '[PRE176]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: A field list is a sequence of field labels (as `:label:`) and a value associated
    with that label. The label is generally short, and the value can be as long as
    needed. Field lists are also used to provide parameters to directives.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 字段列表是一系列字段标签（如`:label:`）和与该标签相关联的值。标签通常很短，值可以很长。字段列表也用于为指令提供参数。
- en: 'When the field list''s text is present in an RST document, the docutils tools
    can create a nice-looking, table-like display. In PDF, it might look like the
    following code:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 当字段列表的文本出现在RST文档中时，docutils工具可以创建一个看起来不错的、类似表格的显示。在PDF中，它可能看起来像下面的代码：
- en: '[PRE177]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: We'll use an extended form of the RST field list syntax to write the API documentation.
    We'll extend the field name to become a multipart item. We'll add prefixes with
    keywords such as `param` or `type`. The prefix will be followed by the parameter's
    name.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用扩展的RST字段列表语法来编写API文档。我们将扩展字段名称以成为多部分项目。我们将添加带有关键字的前缀，如`param`或`type`。前缀后面跟着参数的名称。
- en: 'There are several field prefixes. We can use any of these: `param`, `parameter`,
    `arg`, `argument`, `key`, and `keyword`. For example, we might write the following
    code:'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个字段前缀。我们可以使用其中任何一个：`param`、`parameter`、`arg`、`argument`、`key`和`keyword`。例如，我们可能会写下以下代码：
- en: '[PRE178]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: We generally use `param` (or `parameter`) for the positional parameters and
    `key` (or `keyword`) for the keyword parameters. We advise you against using `arg`
    or `argument` to document Python code, as they don't fit the Python syntax categories.
    These prefixes could be used to document shell scripts or APIs in other languages.
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常使用`param`（或`parameter`）表示位置参数，使用`key`（或`keyword`）表示关键字参数。我们建议您不要使用`arg`或`argument`来记录Python代码，因为它们不符合Python语法类别。这些前缀可以用于记录其他语言的shell脚本或API。
- en: These field list definitions will be collected into an indented section. The
    Sphinx tool will also compare the names in the documentation with the names in
    the function argument list to be sure that they match.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段列表定义将被收集到一个缩进的部分中。Sphinx工具还将比较文档中的名称与函数参数列表中的名称，以确保它们匹配。
- en: 'We can also define the type of a parameter using `type` as a prefix:'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`type`作为前缀来定义参数的类型：
- en: '[PRE179]'
  id: totrans-1230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Because of Python''s flexibility, this can be a needless detail. In many cases,
    the argument value need only be numeric, and simple `:param somearg:` can include
    generic type information as part of the description. We showed you this style
    in the earlier example: `Numeric rank of the card`.'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python的灵活性，这可能是一个不必要的细节。在许多情况下，参数值只需要是数字，简单的`:param somearg:`可以在描述中包含通用类型信息。我们在之前的示例中展示了这种风格：`卡片的数字排名`。
- en: 'For functions that return a value, we should describe the result. We can summarize
    the return value with the field label of `returns` or `return`. We can also formally
    specify the type of the return value with `rtype`. We might write the following
    code:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回值的函数，我们应该描述结果。我们可以使用`returns`或`return`字段标签总结返回值。我们还可以使用`rtype`正式指定返回值的类型。我们可能会写下以下代码：
- en: '[PRE180]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'Additionally, we should also include information about exceptions that are
    unique to this function. We have four aliases for this field: `raises`, `raise`,
    `except`, and `exception`. We would write the following code:'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该包括关于此函数特有的异常信息。我们有四个别名：`raises`、`raise`、`except`和`exception`。我们会写下以下代码：
- en: '[PRE181]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We can also describe the attributes of a class. For this, we can use `var`,
    `ivar`, or `cvar`. We might write the following code:'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以描述类的属性。为此，我们可以使用`var`、`ivar`或`cvar`。我们可能会写下以下代码：
- en: '[PRE182]'
  id: totrans-1237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: We should use `ivar` for instance variables and `cvar` for class variables.
    However, there's no visible difference in the final HTML output.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用`ivar`表示实例变量，使用`cvar`表示类变量。然而，在最终的HTML输出中没有明显的区别。
- en: These field list constructs are used to prepare docstrings for classes, class
    methods, and standalone functions. We'll look at each case in the later section.
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: 这些字段列表结构用于准备类、类方法和独立函数的文档字符串。我们将在后面的部分中查看每种情况。
- en: Writing class and method function docstrings
  id: totrans-1240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写类和方法函数文档字符串
- en: A class will often contain a number of elements, including attributes and method
    functions. A stateful class may also have a relatively complex API. Objects will
    be created, undergo changes in state, and possibly be garbage-collected at the
    end of their lives. We might want to describe some (or all) of these state changes
    in the class docstring or the method function docstrings.
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类通常包含许多元素，包括属性和方法函数。一个有状态的类可能还具有相对复杂的API。对象将被创建，状态将发生变化，并且可能在生命周期结束时被垃圾回收。我们可能希望在类文档字符串或方法函数文档字符串中描述一些（或全部）这些状态变化。
- en: We'll use the field list technique to document the class variables in the overall
    class docstring. This will generally focus on using the `:ivar variable:`, `:cvar
    variable:`, and `:var variable:` field list items.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用字段列表技术来记录整体类文档字符串中的类变量。这将主要侧重于使用`:ivar variable:`、`:cvar variable:`和`:var
    variable:`字段列表项。
- en: 'Each individual method function will also use field lists to define the parameters
    and return the values and exceptions raised by each method function. Here''s how
    we might start to write a class with docstrings for the class and method functions:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的方法函数也将使用字段列表来定义参数、返回值和每个方法函数引发的异常。以下是我们可能开始编写包含类和方法函数文档字符串的类的方式：
- en: '[PRE183]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: When we include this kind of RST markup in the docstring, then a tool such as
    Sphinx can format very nice-looking HTML output. We've provided you with both
    class-level documentation of the instance variables as well as method-level documentation
    of the parameters to one of the method functions.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在文档字符串中包含这种RST标记时，像Sphinx这样的工具可以格式化非常漂亮的HTML输出。我们为您提供了实例变量的类级文档以及一个方法函数的参数的方法级文档。
- en: When we look at this with `help()`, the RST is visible. It's not too objectionable,
    as it's semantically meaningful and not very confusing. This points out a balance
    that we may need to strike between the `help()` text and the Sphinx documents.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`help()`查看时，RST是可见的。这并不是太令人反感，因为它在语义上是有意义的，而且并不太令人困惑。这指出了我们可能需要在`help()`文本和Sphinx文档之间取得平衡。
- en: Writing function docstrings
  id: totrans-1247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写函数文档字符串
- en: 'A function docstring can be formatted using field lists to define the parameters
    and return the values and raised exceptions. Here''s an example of a function
    that includes a docstring:'
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 函数文档字符串可以使用字段列表格式化，以定义参数、返回值和引发的异常。以下是包含文档字符串的函数的示例：
- en: '[PRE184]'
  id: totrans-1249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: This function docstring includes parameter definitions, return values, and the
    raised exceptions. There are four individual field list items that formalize the
    API. We've included a `doctest` sequence as well. When we document this module
    in Sphinx, we'll get very nice-looking HTML output. Additionally, we can use the
    `doctest` tool to confirm that the function matches the simple test case.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的文档字符串包括参数定义、返回值和引发的异常。有四个单独的字段列表项，形式化了API。我们已经包含了一个`doctest`序列。当我们在Sphinx中记录这个模块时，我们将得到非常漂亮的HTML输出。此外，我们可以使用`doctest`工具来确认函数是否与简单的测试用例匹配。
- en: More sophisticated markup techniques
  id: totrans-1251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更复杂的标记技术
- en: There are some additional markup techniques that can make a document easier
    to read. In particular, we often want useful cross-references between class definitions.
    We may also want cross-references between sections and topics within a document.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的标记技术可以使文档更容易阅读。特别是，我们经常希望在类定义之间有有用的交叉引用。我们可能还希望在文档内的章节和主题之间进行交叉引用。
- en: 'In *pure* RST (that is, without Sphinx), we need to provide proper URLs that
    reference different sections of our documents. We have three kinds of references:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 在*纯* RST（即没有Sphinx的情况下），我们需要提供正确的URL来引用文档的不同部分。我们有三种引用方式：
- en: '**Implicit references to section titles**: We can use ``Some Heading`_` to
    refer to the `Some Heading` section. This will work for all the headings that
    docutils recognizes.'
  id: totrans-1254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对章节标题的隐式引用**：我们可以使用``Some Heading`_`来引用`Some Heading`部分。这对docutils识别的所有标题都适用。'
- en: '**Explicit references to targets**: We can use `target_` to reference the location
    of `_target` in the document.'
  id: totrans-1255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对目标的明确引用**：我们可以使用`target_`来引用文档中`_target`的位置。'
- en: '**Inter-document references**: We have to create a full URL that explicitly
    references a section title. Docutils will translate section titles into all lowercase,
    replacing the punctuation with `-`. This allows us to create a reference to a
    section title in an external document like this: ``Design <file:build.py.html#design>`_`.'
  id: totrans-1256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档间引用**：我们必须创建一个完整的URL，明确引用文档中的一个章节标题。Docutils会将章节标题转换为全小写，并用`-`替换标点符号。这使我们能够创建对外部文档中的章节标题的引用，如下所示：``Design
    <file:build.py.html#design>`_`。'
- en: When we use Sphinx, we get even more inter-document, cross-reference capabilities.
    These capabilities allow us to avoid trying to write detailed URLs.
  id: totrans-1257
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用Sphinx时，我们甚至可以获得更多的文档间交叉引用能力。这些能力使我们能够避免尝试编写详细的URL。
- en: Using Sphinx to produce the documentation
  id: totrans-1258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Sphinx生成文档
- en: The Sphinx tool produces very good-looking documentation in a variety of formats.
    It can easily combine documentation from source code as well as external files
    with additional design notes, requirements, or background.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx工具可以以多种格式生成非常漂亮的文档。它可以轻松地将源代码的文档与额外的设计说明、需求或背景文件结合在一起。
- en: The Sphinx tool can be found at [http://sphinx-doc.org](http://sphinx-doc.org).
    The download can become complex because Sphinx depends on several other projects.
    It may be easier to first install `setuptools`, which includes the `easy_install`
    script, and then use this to install Sphinx. This can help us with the details
    of tracking down the additional projects that must be installed first.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx工具可以在[http://sphinx-doc.org](http://sphinx-doc.org)找到。下载可能会变得复杂，因为Sphinx依赖于其他几个项目。首先安装`setuptools`可能更容易，其中包括`easy_install`脚本，然后使用它来安装Sphinx。这可以帮助我们跟踪必须首先安装的其他项目的细节。
- en: See [https://pypi.python.org/pypi/setuptools](https://pypi.python.org/pypi/setuptools)
    for help on `setuptools`.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://pypi.python.org/pypi/setuptools](https://pypi.python.org/pypi/setuptools)获取有关`setuptools`的帮助。
- en: Some developers prefer to use `pip` for this kind of installation. See [https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip)
    for information on `pip`.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员更喜欢使用`pip`进行这种安装。请参阅[https://pypi.python.org/pypi/pip](https://pypi.python.org/pypi/pip)获取有关`pip`的信息。
- en: The Sphinx tutorial is outstanding. Start there and be sure that you can use
    `sphinx-quickstart` and `sphinx-build`. Often, running `sphinx-build` is handled
    via the `make` program, which slightly simplifies the command-line use of Sphinx.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx教程非常出色。从那里开始，确保你可以使用`sphinx-quickstart`和`sphinx-build`。通常，通过`make`程序来运行`sphinx-build`，这稍微简化了Sphinx的命令行使用。
- en: Using the Sphinx quickstart
  id: totrans-1264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Sphinx快速入门
- en: The handy feature of `sphinx-quickstart` is that it populates the rather complex
    `config.py` file via an interactive question-and-answer session.
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
  zh: '`sphinx-quickstart`的方便之处在于，它通过交互式问答会话填充了相当复杂的`config.py`文件。'
- en: Here's a part of one such session that shows how the dialog looks; we've highlighted
    a few responses where the defaults don't seem to be optimal.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个这样的会话的一部分，显示了对话的外观；我们已经突出显示了一些响应，在这些响应中，默认值似乎不是最佳的。
- en: 'For more complex projects, it''s simpler in the long run to separate the documentation
    from the working code. It''s often a good idea to create a `doc` directory within
    the overall project tree:'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的项目，将文档与工作代码分开在长远来看更简单。在整体项目树中创建一个`doc`目录通常是一个好主意：
- en: '[PRE185]'
  id: totrans-1268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'For very small documents, it''s fine to interleave the source and HTML. For
    larger documents, particularly documents where there may be a need to produce
    LaTeX and PDF, it''s handy to keep these files separate from the HTML version
    of the documentation:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常小的文档，将源代码和HTML交错使用是可以的。对于较大的文档，特别是可能需要生成LaTeX和PDF的文档，将这些文件与文档的HTML版本分开是很方便的：
- en: '[PRE186]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The next batch of questions identifies specific add-ons; it starts with the
    following note:'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 下一批问题确定了特定的附加组件；它以以下说明开始：
- en: '[PRE187]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: We'll suggest a set of add-ons that seem most useful for general Python development.
    For first-time users of Sphinx, this will be enough to get started and produce
    excellent documentation. Clearly, specific project needs and objectives will override
    these generic suggestions.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将建议一组最适用于一般Python开发的附加组件。对于第一次使用Sphinx的用户来说，这将足以开始并生成出色的文档。显然，特定项目的需求和目标将覆盖这些通用建议。
- en: 'We''ll almost always want to include the `autodoc` feature to produce the documentation
    from the docstrings. If we''re using Sphinx to produce the documentation outside
    the Python programming, perhaps we might turn `autodoc` off:'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是希望包括`autodoc`功能来从文档字符串生成文档。如果我们在Python编程之外使用Sphinx来生成文档，也许我们可以关闭`autodoc`：
- en: '[PRE188]'
  id: totrans-1275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'If we have `doctest` examples, we can have Sphinx run the doctest for us. For
    small projects, where most of the testing is done via `doctest`, this can be very
    handy. For larger projects, we''ll often have a unit test script that includes
    doctest. Performing the doctest via Sphinx as well as through the formal unit
    test is still a good idea:'
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有`doctest`示例，我们可以让Sphinx为我们运行doctest。对于小型项目，大部分测试是通过`doctest`完成的，这可能非常方便。对于较大的项目，我们通常会有一个包含doctest的单元测试脚本。通过Sphinx以及正式的单元测试执行doctest仍然是一个好主意：
- en: '[PRE189]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'A mature development effort may have many projects that are closely related;
    this might have multiple, related Sphinx documentation directories:'
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的开发工作可能有许多相关的项目；这可能有多个相关的Sphinx文档目录：
- en: '[PRE190]'
  id: totrans-1279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The `todo` extension allows us to include a `.. todo::` directive in our docstrings.
    We can then add a special `.. todolist::` directive to create an official to-do
    list in the documentation:'
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '`todo`扩展允许我们在文档字符串中包含一个`.. todo::`指令。然后我们可以添加一个特殊的`.. todolist::`指令来创建官方的待办事项列表在文档中：'
- en: '[PRE191]'
  id: totrans-1281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'The coverage report could be a handy quality assurance metric:'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖报告可能是一个方便的质量保证指标：
- en: '[PRE192]'
  id: totrans-1283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'For projects that involve any math, having a LaTeX toolset allows us to have
    the math nicely typeset as graphic images and included into HTML. It also leaves
    the raw math in the LaTeX output. MathJax is a web-based JavaScript library that
    also works in the following manner:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 对于涉及任何数学的项目，拥有LaTeX工具集使我们能够将数学漂亮地排版为图像，并包含到HTML中。它还保留了LaTeX输出中的原始数学。MathJax是一个基于Web的JavaScript库，也以以下方式工作：
- en: '[PRE193]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: 'For very complex projects, we might need to produce the variant documentation:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常复杂的项目，我们可能需要生成变体文档：
- en: '[PRE194]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'Most application documentations describe an API. We should include both the
    `autodoc` and `viewcode` features. The `viewcode` option allows the reader to
    view the source so they can understand the implementation in detail:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序文档描述了一个API。我们应该包括`autodoc`和`viewcode`功能。`viewcode`选项允许读者查看源代码，以便他们可以详细了解实现：
- en: '[PRE195]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The `autodoc` and `doctest` features mean that we can focus on writing docstrings
    within our code. We only need to write very small Sphinx documentation files to
    extract the docstring information. For some developers, the ability to focus on
    the code reduces the fear factor associated with writing the documentation.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '`autodoc`和`doctest`功能意味着我们可以专注于在我们的代码中编写文档字符串。我们只需要编写非常小的Sphinx文档文件来提取文档字符串信息。对于一些开发人员来说，专注于代码减少了与编写文档相关的恐惧因素。'
- en: Writing the Sphinx documentation
  id: totrans-1291
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写Sphinx文档
- en: 'There are two common starting points for software development projects:'
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发项目有两个常见的起始点：
- en: Some inception documentation has been created, and this should be preserved
  id: totrans-1293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经创建了一些起始文档，应该保留这些文档
- en: Nothing; inception starts from a blank slate
  id: totrans-1294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有；起始从空白状态开始
- en: In the cases where a project starts with some legacy documentation, this might
    include the requirements, user stories, or architectural notes. It may also include
    notes on organizational politics, out-of-date budgets and schedules, and other
    technically irrelevant material.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目以一些遗留文档开始的情况下，这可能包括需求、用户故事或架构说明。它还可能包括组织政治、过时的预算和时间表等技术上不相关的材料。
- en: Ideally, these inception documents are already text files. If not, they may
    be in some word processor format that can be saved as text. When we have text-oriented
    inception documents, it's relatively easy to add enough RST markup to show us
    the outline structure and organize these text files into a simple directory structure.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，这些起始文档已经是文本文件。如果不是，它们可能是以某种文字处理格式保存为文本的。当我们有面向文本的起始文档时，相对容易添加足够的RST标记来显示大纲结构，并将这些文本文件组织成一个简单的目录结构。
- en: There's little reason to preserve the content as a word-processing document.
    Once it's part of the technical content of a software development project, RST
    permits more flexible use of the inception information.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 没有理由将内容保留为文字处理文档。一旦它成为软件开发项目的技术内容的一部分，RST允许更灵活地使用起始信息。
- en: One of the difficult cases is a project where the inception documentation is
    a slideshow built using Keynote, PowerPoint, or a similar tool. These don't readily
    convert to text-centric RST, as the diagrams and images are first-class parts
    of the content. In these cases, it's sometimes best to export the presentation
    as an HTML document and put this into the Sphinx `doc/source/_static` directory.
    This will allow us to integrate the original material into Sphinx via simple RST
    links of the ``Inception <_static/inception_doc/index.html>`_` form.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 一个困难的情况是，起始文档是使用Keynote、PowerPoint或类似工具构建的幻灯片。这些不容易转换为以文本为中心的RST，因为图表和图像是内容的重要部分。在这些情况下，最好有时将演示文稿导出为HTML文档，并将其放入Sphinx
    `doc/source/_static`目录中。这将允许我们通过简单的RST链接将原始材料集成到Sphinx中，形式为``Inception <_static/inception_doc/index.html>`_`。
- en: 'When an interactive, web-based tool is used to manage the project or user stories,
    the inception and background documentation needs to be handled via simple URL
    references of this form: ``Background <http://someservice/path/to/page.html>`_`.'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用交互式的基于Web的工具来管理项目或用户故事时，起始和背景文档需要通过简单的URL引用来处理：``Background <http://someservice/path/to/page.html>`_`.
- en: It's often easiest to start with an outline of placeholders for the documentation
    that will accumulate as the software development proceeds. One structure that
    might be helpful is based on the 4+1 views of an architecture. The inception documents
    are often part of the scenarios or user stories in the 4+1 views. Sometimes, the
    inception documents are part of the development or physical deployment.
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最容易的方法是从文档的占位符大纲开始，随着软件开发的进行，文档将不断积累。可能有用的一个结构是基于体系结构的4+1视图。最初的文档通常是4+1视图中的场景或用户故事的一部分。有时，最初的文档是开发或物理部署的一部分。
- en: 'For more information, see this:'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅：
- en: '[http://en.wikipedia.org/wiki/4%2B1_architectural_view_model](http://en.wikipedia.org/wiki/4%2B1_architectural_view_model)'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/4%2B1_architectural_view_model](http://en.wikipedia.org/wiki/4%2B1_architectural_view_model)'
- en: 'We can create five top-level documents under our `index.html` root: `user_stories`,
    `logical`, `process`, `implementation`, and `physical`. Each of these must have
    an RST title but needs nothing more in the file.'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`index.html`根目录下创建五个顶级文档：`user_stories`、`logical`、`process`、`implementation`和`physical`。这些文档都必须有一个RST标题，但文件中不需要其他内容。
- en: 'We can then update the `.. toctree::` directive that''s generated in the Sphinx
    `index.rst` file by default:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以更新Sphinx `index.rst`文件中默认生成的`.. toctree::`指令：
- en: '[PRE196]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Once we have a top-level structure, we can use the `make` command to build
    our documentation:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了一个顶层结构，我们可以使用`make`命令来构建我们的文档：
- en: '[PRE197]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: This will run our doctests; if all the tests pass, it will create the HTML documentation.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行我们的doctests；如果所有测试都通过，它将创建HTML文档。
- en: Filling in the 4+1 views for documentation
  id: totrans-1309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填写文档的4+1视图
- en: As the development proceeds, the 4+1 views can be used to organize the details
    that accumulate. This is used for the information that belongs outside the narrow
    focus of docstrings.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 随着开发的进行，4+1视图可以用来组织积累的细节。这用于属于文档字符串狭窄焦点之外的信息。
- en: The `user_stories.rst` document is where we collect user stories, requirements,
    and other high-level background notes. This might evolve into a directory tree
    if the user stories become complex.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: '`user_stories.rst`文档是我们收集用户故事、需求和其他高层背景注释的地方。如果用户故事变得复杂，这可能会演变成一个目录树。'
- en: The `logical.rst` document will collect our initial OO designs for the class,
    module, and package. This should be the origin of our design thinking. It might
    contain alternatives, notes, mathematical backgrounds, proofs of correctness,
    and diagrams of the logical software design. For relatively simple projects—where
    the design is relatively clear—this may remain empty. For complex projects, this
    may describe some sophisticated analysis and design that serve as the background
    or justification for the implementation.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '`logical.rst`文档将收集我们的类、模块和包的初始OO设计。这应该是我们设计思想的起源。它可能包含备选方案、注释、数学背景、正确性证明以及逻辑软件设计的图表。对于相对简单的项目——设计相对清晰的项目——这可能保持为空。对于复杂的项目，这可能描述一些复杂的分析和设计，作为实施的背景或理由。'
- en: The final OO design will be the Python modules and classes that belong in the
    `implementation.rst` file. We'll take a look at this in a little more detail,
    as this will become our API documentation. This part will be based in a direct
    way on our Python code and the RST-markup docstrings.
  id: totrans-1313
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的OO设计将是属于`implementation.rst`文件的Python模块和类。我们将更详细地看一下这一点，因为这将成为我们的API文档。这部分将直接基于我们的Python代码和RST标记的文档字符串。
- en: The `process.rst` document can collect information about the dynamic, runtime
    behavior. This would include topics such as concurrency, distribution, and integration.
    It might also contain information on the performance and scalability. The network
    design and protocols used might be described here.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.rst`文档可以收集有关动态运行时行为的信息。这将包括诸如并发性、分布和集成等主题。它还可能包含有关性能和可伸缩性的信息。网络设计和使用的协议可能在这里描述。'
- en: For smaller applications, the material that should go into the process document
    isn't perfectly clear. This document may overlap with the logical design and the
    overall architectural information. When in doubt, we have to strive for clarity
    based on the audience's need for information. For some users, many small documents
    are helpful. For other users, a single large document is preferred.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较小的应用程序，应该放入过程文档的材料并不十分清晰。这个文档可能与逻辑设计和整体架构信息重叠。如果有疑问，我们必须努力实现基于受众对信息需求的清晰度。对于一些用户，许多小文档是有帮助的。对于其他用户，一个大型文档更受欢迎。
- en: 'The `physical.rst` file is where the deployment details can be recorded. A
    description of the configuration details would go here: the environment variables,
    the configuration file format details, the available logger names, and other information
    required for the administration and support. This might also include configuration
    information such as server names, IP addresses, account names, directory paths,
    and related notes. In some organizations, an administrator might feel that some
    of these details are not appropriate for general software documentation.'
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: '`physical.rst`文件是记录部署细节的地方。配置细节的描述将放在这里：环境变量、配置文件格式细节、可用的记录器名称以及管理和支持所需的其他信息。这可能还包括配置信息，如服务器名称、IP地址、帐户名称、目录路径和相关注释。在一些组织中，管理员可能认为其中一些细节不适合一般软件文档。'
- en: Writing the implementation document
  id: totrans-1317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写实施文档
- en: The `implementation.rst` document can be based on using `automodule` to create
    the documentation. Here's how an `implementation.rst` document might start.
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '`implementation.rst`文档可以基于使用`automodule`来创建文档。以下是`implementation.rst`文档可能开始的方式。'
- en: '[PRE198]'
  id: totrans-1319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'We used two kinds of RST headings: there''s a single top-level heading and
    two subheadings. RST deduces the relationship between the parent and the children.
    In this example, we''ve used "`===`" underlines for the parent heading (also the
    title) and "`---`" for the subheadings.'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两种RST标题：一个顶级标题和两个子标题。RST推断出父级和子级之间的关系。在这个例子中，我们使用"`===`"作为父标题（也是标题）的下划线，"`---`"作为子标题。
- en: We've provided you with an explicit reference to a document that was copied
    into the `_static` directory as `inception_doc`. We created a sophisticated RST
    link from the words *inception document* to the actual document's `index.html`
    file.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为您提供了对一个文档的显式引用，该文档被复制到`_static`目录中，名为`inception_doc`。我们从*inception document*这些词到实际文档的`index.html`文件创建了一个复杂的RST链接。
- en: 'Within the two subheadings, we used the Sphinx `.. automodule::` directive
    to extract the docstrings from two modules. We''ve provided you with three parameters
    to the automodule directives:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个子标题中，我们使用了Sphinx的`.. automodule::`指令从两个模块中提取文档字符串。我们为automodule指令提供了三个参数：
- en: '`:members:`: This includes all the members of the module. We can list explicit
    member classes and functions instead of listing all the members.'
  id: totrans-1323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:members:`：这包括模块的所有成员。我们可以列出显式成员类和函数，而不是列出所有成员。'
- en: '`:undoc-members:`: This includes members who lack proper docstrings. This is
    handy when starting development; we''ll still get some API information, but it
    will be minimal.'
  id: totrans-1324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:undoc-members:`：这包括缺乏适当文档字符串的成员。这在开始开发时很方便；我们仍然会得到一些API信息，但它将是最小的。'
- en: '`:undoc-members:`: This includes special-method name members, not included
    in the Sphinx documentation by default.'
  id: totrans-1325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:undoc-members:`：这包括特殊方法名成员，默认情况下不包含在Sphinx文档中。'
- en: This gives us a relatively complete view that is too complete sometimes. If
    we leave out all of these parameters, `:undoc-members:` and `:special-members:`,
    we'll get a smaller, more focused document.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个相对完整的视图，有时太完整了。如果我们省略所有这些参数，`:undoc-members:`和`:special-members:`，我们将得到一个更小、更集中的文档。
- en: Our `implementation.rst` file can evolve as our project evolves. We'll add the
    `automodule` references as the modules are completed.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`implementation.rst`文件可以随着项目的发展而发展。我们将在模块完成时添加`automodule`引用。
- en: The organization of the `.. automodule::` directives can provide us with a useful
    roadmap or overview of a complex collection of modules or packages. A little time
    spent organizing the presentation so that it shows us how the software components
    work together is more valuable than a great deal of verbiage. The point is not
    to create great narrative literature; the point is to provide guidance to the
    other developers.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '`.. automodule::`指令的组织可以为我们提供一个有用的路线图或对复杂模块或包集合的概述。花一点时间组织演示，以便向我们展示软件组件如何协同工作，比大量的废话更有价值。重点不是创造出色的叙述文学；重点是为其他开发人员提供指导。'
- en: Creating the Sphinx cross-references
  id: totrans-1329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建Sphinx交叉引用
- en: Sphinx expands the cross-reference techniques available via RST. The most important
    set of cross-reference capabilities is the ability to directly refer to specific
    Python code features. These make use of the inline RST markup using the `:role:`text``
    syntax. In this case, a large number of additional roles is part of Sphinx.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx通过RST扩展了可用的交叉引用技术。最重要的一组交叉引用能力是直接引用特定的Python代码特性。这些使用内联RST标记使用`:role:`text``语法。在这种情况下，大量额外的角色是Sphinx的一部分。
- en: 'We have the following kinds of cross-reference roles available:'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有以下类型的交叉引用角色可用：
- en: The `:py:mod:`some_module`` syntax will generate a link to the definition of
    this module or package.
  id: totrans-1332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:mod:`some_module``语法将生成一个链接到此模块或包的定义。'
- en: The `:py:func:`some_function`` syntax will generate a link to the definition
    of the function. A qualified name with `module.function` or `package.module.function`
    can be used.
  id: totrans-1333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:func:`some_function``语法将生成一个链接到函数的定义。可以使用`module.function`或`package.module.function`的限定名称。'
- en: 'The `:py:data:`variable`` and `:py:const:`variable`` syntax will generate a
    link to a module variable that''s defined with a `.. py:data:: variable` directive.
    A *constant* is simply a variable that should not be changed.'
  id: totrans-1334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:data:`variable``和`:py:const:`variable``语法将生成一个链接到使用`.. py:data:: variable`指令定义的模块变量。*常量*只是一个不应该被更改的变量。'
- en: The `:py:class:`some_class`` syntax will link to the class definition. Qualified
    names such as `module.class` can be used.
  id: totrans-1335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:class:`some_class``语法将链接到类定义。可以使用`module.class`等限定名称。'
- en: The `:py:meth:`class.method`` syntax will link to a method definition.
  id: totrans-1336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:meth:`class.method``语法将链接到方法定义。'
- en: 'The `:py:attr:`class.attribute`` syntax will link to an attribute that''s defined
    with a `.. py:attribute:: name` directive.'
  id: totrans-1337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:attr:`class.attribute``语法将链接到使用`.. py:attribute:: name`指令定义的属性。'
- en: The `:py:exc:`exception`` syntax will link to a defined exception.
  id: totrans-1338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`:py:exc:`exception``语法将链接到已定义的异常。'
- en: The `:py:obj:`some_object`` syntax can create a generic link to an object.
  id: totrans-1339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`：py：obj：`some_object``语法可以创建一个指向对象的通用链接。'
- en: If we use [PRE199] in our docstring, we'll get the class name in a monospaced
    font. If we use `:py:class:`SomeClass``, we get a proper link to the class definition,
    which is often far more helpful.
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在文档字符串中使用[PRE199]，我们将以等宽字体获得类名。如果我们使用`:py:class:`SomeClass``，我们将得到一个指向类定义的正确链接，这通常更有帮助。
- en: The `:py:` prefix on each role is there because Sphinx can be used to write
    the documentation about other languages in addition to Python. By using this `:py:`
    prefix on each role, Sphinx can provide proper syntax additions and highlighting.
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: 每个角色上的`:py:`前缀是因为Sphinx可以用来撰写关于其他语言的文档，而不仅仅是Python。通过在每个角色上使用这个`:py:`前缀，Sphinx可以提供适当的语法补充和高亮。
- en: 'Here''s a docstring that includes explicit cross-references to other classes
    and exceptions:'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含对其他类和异常的显式交叉引用的文档字符串：
- en: '[PRE200]'
  id: totrans-1343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: By using `:py:class:`Card`` instead of [PRE201], we're able to create explicit
    links between this comment block and the definition of the `Card` class. Similarly,
    we used `:py:exc:`TypeError`` to permit an explicit link to this exception's definition.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`:py:class:`Card``而不是[PRE201]，我们能够在这个注释块和`Card`类的定义之间创建明确的链接。同样，我们使用`:py:exc:`TypeError``来允许对这个异常的定义进行明确的链接。
- en: Additionally, we can define a link target via `.._some-name::` and reference
    that label from any document in the Sphinx documentation tree with `:ref:`some-name``.
    The name, `some-name`, must be globally unique. To ensure this, it's often good
    to define a kind of hierarchy so that the names are a kind of path from the document
    to the section to the topic.
  id: totrans-1345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以通过`.._some-name::`定义一个链接目标，并在Sphinx文档树中的任何文档中使用`:ref:`some-name``引用该标签。名称`some-name`必须是全局唯一的。为了确保这一点，通常最好定义一种层次结构，使得名称从文档到部分再到主题成为一种路径。
- en: Refactoring Sphinx files into directories
  id: totrans-1346
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Sphinx文件重构为目录
- en: 'For larger projects, we''ll need to use directories instead of simple files.
    In this case, we''ll perform the following steps to refactor a file into a directory:'
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更大的项目，我们需要使用目录而不是简单的文件。在这种情况下，我们将执行以下步骤将文件重构为目录：
- en: 'Add the directory: `implementation`, for example.'
  id: totrans-1348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将目录添加到`implementation`，例如。
- en: Move the original `implementation.rst` file to `implementation/index.rst`.
  id: totrans-1349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将原始的`implementation.rst`文件移动到`implementation/index.rst`。
- en: Change the original `index.rst` file. Switch the `.. toctree::` directive to
    reference `implementation/index` instead of `implementation`.
  id: totrans-1350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改原始的`index.rst`文件。将`.. toctree::`指令更改为引用`implementation/index`而不是`implementation`。
- en: We can then work within the `implementation` directory using the `.. toctree::`
    directive in the `implementation/index.rst` file to include other files that are
    in this directory.
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以在`implementation`目录中使用`implementation/index.rst`文件中的`.. toctree::`指令来包含该目录中的其他文件。
- en: When our documentation is split into simple directories of simple text files,
    we can edit small, focused files. Individual developers can make significant contributions
    without encountering any file-sharing conflicts that arise when trying to edit
    a large word-processing document.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的文档被分成简单的文本文件的简单目录时，我们可以编辑小而专注的文件。个别开发人员可以做出重大贡献，而不会遇到在尝试编辑大型文字处理文档时出现的文件共享冲突。
- en: Writing the documentation
  id: totrans-1353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写文档
- en: An important part of software quality comes from noting that the product is
    not simply *code* directed at a compiler or interpreter. As we noted in [Chapter
    15](ch15.html "Chapter 15. Designing for Testability"), *Designing for Testability*,
    code that cannot be trusted cannot be used. In that chapter, we suggested that
    testing was essential to establishing trust. We'd like to generalize that a bit.
    In addition to detailed testing, there are several other quality attributes that
    make the code usable, and trustworthiness is one of those attributes.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 软件质量的重要部分来自于意识到产品不仅仅是针对编译器或解释器的*代码*。正如我们在[第15章](ch15.html "第15章。可测试性设计")中所指出的，*可测试性设计*，不能信任的代码是不能使用的。在那一章中，我们建议测试是建立信任的关键。我们想要概括一下。除了详细的测试之外，还有几个其他的质量属性使得代码可用，可信任性就是其中之一。
- en: 'We trust code in the following scenarios:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下情况下信任代码：
- en: We understand the use cases
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们理解使用案例
- en: We understand the data model and processing model
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们理解数据模型和处理模型
- en: We understand the test cases
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们理解测试用例
- en: When we look at more technical quality attributes, we see that these are really
    about understanding. For example, debugging seems to mean that we can confirm
    our understanding of how the application works. Auditability also seems to mean
    that we can confirm our understanding of processing by viewing specific examples
    to show that they work as expected.
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看更多技术质量属性时，我们会发现这些实际上是关于理解的。例如，调试似乎意味着我们可以确认我们对应用程序工作原理的理解。可审计性也似乎意味着我们可以通过查看特定示例来确认我们对处理的理解，以展示它们按预期工作。
- en: 'Documentation creates trust. For more information on the software quality,
    start here: [http://en.wikipedia.org/wiki/Software_quality](http://en.wikipedia.org/wiki/Software_quality).
    There is a lot to learn about software quality; it''s a very large subject, and
    this is only one small aspect.'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 文档创建信任。有关软件质量的更多信息，请从这里开始：[http://en.wikipedia.org/wiki/Software_quality](http://en.wikipedia.org/wiki/Software_quality)。关于软件质量有很多东西要学习；这是一个非常庞大的主题，这只是其中一个小方面。
- en: Literate programming
  id: totrans-1361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文学编程
- en: The idea of separating *documentation* from *code* can be viewed as an artificial
    distinction. Historically, we wrote documentation outside the code because the
    programming languages were relatively opaque and biased toward efficient compilation
    rather than clear exposition. Different techniques have been tried to reduce the
    distance between the working code and documentation about the code. Embedding
    more sophisticated comments, for example, is a long-standing tradition. Python
    takes this a step further by including a formal docstring in packages, modules,
    classes, and functions.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 将*文档*与*代码*分开的想法可以被视为一种人为的区分。从历史上看，我们之所以在代码之外编写文档，是因为编程语言相对不透明，并且更倾向于高效编译而不是清晰的表达。已经尝试了不同的技术来减少工作代码和关于代码的文档之间的距离。例如，嵌入更复杂的注释是一个长期的传统。Python通过在包、模块、类和函数中包含正式的文档字符串进一步推进了这一步骤。
- en: The literate programming approach to software development was pioneered by *Don
    Knuth*. The idea is that a single source document can produce efficient code as
    well as good-looking documentation. For machine-oriented assembler languages,
    and languages such as C, there's an additional benefit of moving away from the
    source language—a notation that emphasizes translation—toward a document that
    emphasizes clear exposition. Additionally, some literate programming languages
    act as a higher-level programming language; this might be appropriate for C or
    Pascal, but it is decidedly unhelpful for Python.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中的文学编程方法是由*唐纳德·克努斯*首创的。其理念是单一的源文件可以生成高效的代码以及漂亮的文档。对于面向机器的汇编语言和C等语言，移向强调翻译的标记语言的另一个好处是，可以产生强调清晰表达的文档。此外，一些文学编程语言充当更高级的编程语言；这可能适用于C或Pascal，但对于Python来说并不是很有帮助。
- en: Literate programming is about promoting a deeper understanding of the code.
    In the case of Python, the source starts out very readable. Sophisticated literate
    programming isn't required to make a Python program understandable. Indeed, the
    main benefit of literate programming for Python is the idea of carrying deeper
    design and use case information in a form that is more readable than simple Unicode
    text.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 文学编程是为了促进对代码的更深入理解。对于Python来说，源代码本身就非常易读。对于Python来说，并不需要复杂的文学编程来使程序易懂。事实上，文学编程对于Python的主要好处在于以一种比简单的Unicode文本更易读的形式携带更深层次的设计和用例信息的理念。
- en: For more information, see [http://www.literateprogramming.com](http://www.literateprogramming.com)
    and [http://xml.coverpages.org/xmlLitProg.html](http://xml.coverpages.org/xmlLitProg.html).
    The book *Literate Programming* by *Donald Knuth* is the seminal title on this
    topic.
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参见[http://www.literateprogramming.com](http://www.literateprogramming.com)和[http://xml.coverpages.org/xmlLitProg.html](http://xml.coverpages.org/xmlLitProg.html)。唐纳德·克努斯的书籍*Literate
    Programming*是这个主题的开创性著作。
- en: Use cases for literate programming
  id: totrans-1366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文学编程的用例
- en: 'There are two essential goals when creating a literate program:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 创建文学程序时有两个基本目标：
- en: '**A working program**: This is the code, extracted from the source document(s)
    and prepared for the compiler or interpreter.'
  id: totrans-1368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一个工作程序**：这是从源文件中提取的代码，为编译器或解释器准备的。'
- en: '**Easy-to-read documentation**: This is the explanation plus the code plus
    any helpful markup prepared for the presentation. This document could be in HTML,
    ready to be viewed. Or it could be in RST, and we''d use docutils `rst2html.py`
    to convert it to HTML. Or, it could be in LaTeX and we run it through a LaTeX
    processor to create a PDF document.'
  id: totrans-1369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易读的文档**：这是解释加上代码加上任何为演示准备的有用标记。这个文档可以是HTML格式，准备好被查看。或者它可以是RST格式，我们可以使用docutils的`rst2html.py`将其转换为HTML。或者，它可以是LaTeX格式，我们可以通过LaTeX处理器将其转换为PDF文档。'
- en: The *working program* goal means that our literate programming document will
    cover the entire suite of the source code files. While this seems daunting, we
    have to remember that well-organized code snippets don't require a lot of complex
    hand-waving; in Python, code itself can be clear and meaningful.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '*工作程序*目标意味着我们的文学编程文档将涵盖整个源代码文件套件。虽然这看起来令人生畏，但我们必须记住，良好组织的代码片段不需要复杂的手势；在Python中，代码本身可以清晰而有意义。'
- en: The *easy-to-read documentation* goal means that we want to produce a document
    that uses something other than a single font. While most code is written in a
    monospaced font, it isn't the easiest on our eyes. The essential Unicode character
    set doesn't include helpful font variants such as bold or italic either. These
    additional display details (the font change, size change, and style change) have
    evolved over the centuries to make a document more readable.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '*易读的文档*目标意味着我们要生成一个使用单一字体以外的东西的文档。虽然大多数代码都是用等宽字体编写的，但这对我们的眼睛来说并不是最容易的。基本的Unicode字符集也不包括粗体或斜体等有用的字体变体。这些额外的显示细节（字体变化、大小变化和样式变化）经过几个世纪的发展，使文档更易读。'
- en: In many cases, our Python IDE will color-code the Python source. This is helpful
    too. The history of written communication includes a lot of features that can
    enhance readability, none of which are available in simple Python source using
    a single font.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们的Python IDE会对Python源代码进行颜色编码。这也是有帮助的。书面交流的历史包括许多可以增强可读性的特性，这些特性在简单的Python源代码中都是不可用的。
- en: Additionally, a document should be organized around the problem and the solution.
    In many languages, the code itself *cannot* follow a clear organization because
    it's constrained by purely technical considerations of syntax and the order of
    the compilation.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，文档应该围绕问题和解决方案进行组织。在许多语言中，代码本身*不能*遵循清晰的组织，因为它受到纯粹技术上的语法和编译顺序的限制。
- en: 'Our two goals boil down to two technical use cases:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的两个目标归结为两个技术用例：
- en: Convert an original source text into the code
  id: totrans-1375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始源文本转换为代码
- en: Covert an original source text into the final documentation
  id: totrans-1376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将原始源文本转换为最终文档
- en: We can—to an extent—refactor these two use cases in some profound ways. For
    example, we can extract the documentation from the code. This is what the `pydoc`
    module does, but it doesn't handle the markup very well.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在某种程度上以一些深刻的方式重构这两个用例。例如，我们可以从代码中提取文档。这就是`pydoc`模块所做的，但它并不很好地处理标记。
- en: Both versions, code and final document, can be made isomorphic. This is the
    approach taken by the PyLit project. The final documentation can be embedded entirely
    in Python code via docstrings as well as `#` comments. The code can be embedded
    entirely in RST documents using `::` literal blocks.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 代码和最终文档两者可以是同构的。这是PyLit项目采用的方法。最终文档可以完全嵌入到Python代码中，通过docstrings和`#`注释。代码可以完全嵌入到RST文档中，使用`::`文字块。
- en: Working with a literate programming tool
  id: totrans-1379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用文学编程工具
- en: Many **Literate Programming** (**LP**) tools are available. The essential ingredient
    —that varies from tool to tool—is the high-level markup language that separates
    the explanation from the code.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多**文学编程**（**LP**）工具可用。从工具到工具变化的基本要素是将解释与代码分开的高级标记语言。
- en: 'The source files that we write will contain the following three things:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们写的源文件将包含以下三件事：
- en: Text with markup that is the explanation and the description
  id: totrans-1382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有标记的文本是解释和描述
- en: Code
  id: totrans-1383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码
- en: High-level markup to separate the text (with markup) from the code
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级标记来分隔文本（带有标记）和代码
- en: Because of the flexibility of XML, this can be used as the high-level markup
    for literate programming. It's not easy to write, however. There are tools that
    work with a LaTeX-like markup based on the original Web (and later CWeb) tools.
    There are some tools that work with RST as the high-level markup.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 由于XML的灵活性，这可以用作文学编程的高级标记。然而，这并不容易写。有一些工具可以使用基于原始Web（以及后来的CWeb）工具的类似LaTeX的标记。也有一些工具可以使用RST作为高级标记。
- en: The essential step in choosing a tool, then, is to take a look at the high-level
    markup that is used. If we find that the markup is easy to write, we can comfortably
    use it to produce the source document.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 选择工具的关键步骤是看一下所使用的高级标记。如果我们发现标记很容易写，我们就可以放心地使用它来生成源文件。
- en: 'Python presents an interesting challenge. Because we have RST-based tools such
    as Sphinx, we can have very literate docstrings. This leads us to two tiers of
    documentation:'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: Python提出了一个有趣的挑战。因为我们有基于RST的工具，比如Sphinx，我们可以有非常文学的docstrings。这使我们有了两个层次的文档：
- en: Literate Programming explanations and the background that is outside the code.
    This should be the background material that's too general and not focused on the
    code itself.
  id: totrans-1388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文学编程的解释和背景在代码之外。这应该是太一般化，不集中在代码本身的背景材料。
- en: The reference and API documentation embedded inside the docstrings.
  id: totrans-1389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入在docstrings中的参考和API文档。
- en: 'This leads to a pleasant, evolutionary approach to literate programming:'
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了一种愉快的、渐进的文学编程方法：
- en: Initially, we can start by embedding the RST markup in our docstrings so that
    a Sphinx-produced document looks good and provides a tidy explanation for the
    implementation choices.
  id: totrans-1391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最初，我们可以通过将RST标记嵌入我们的docstrings中，使得Sphinx生成的文档看起来不错，并为实现选择提供整洁的解释。
- en: We can step beyond a narrow docstring focus to create the background documentation.
    This might include information on the design decisions, architecture, requirements,
    and user stories. In particular, descriptions of nonfunctional quality requirements
    belong outside the code.
  id: totrans-1392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以超越狭窄的docstring焦点，创建背景文档。这可能包括关于设计决策、架构、需求和用户故事的信息。特别是非功能性质量要求的描述应该在代码之外。
- en: Once we've started to formalize this higher-level design documentation, we can
    more easily pick an LP tool. This tool will then dictate how we combine the documentation
    and code into a single, overall documentation structure. We can use an LP tool
    to extract the code and produce the documentation. Some LP tools can be used to
    run the test suite too.
  id: totrans-1393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦我们开始正式化这个高级设计文档，我们就可以更容易地选择一个LP工具。然后，这个工具将决定我们如何将文档和代码结合成一个整体的文档结构。我们可以使用LP工具来提取代码并生成文档。一些LP工具也可以用来运行测试套件。
- en: Our goal is to create software that is not only well designed, but also trustworthy.
    As noted previously, we create trust in a number of ways, including providing
    a tidy, clear explanation of why our design is good.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建不仅设计良好，而且值得信赖的软件。正如之前所述，我们通过多种方式建立信任，包括提供整洁、清晰的解释为什么我们的设计是好的。
- en: 'If we use a tool such as PyLit, we might create RST files that look like the
    following code:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用PyLit这样的工具，我们可能会创建类似以下代码的RST文件：
- en: '[PRE202]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'This is a file written entirely in an RST markup. It contains some explanatory
    text, some formal math, and even some test cases. These provide us with additional
    details to support the relevant code sections. Because of the way PyLit works,
    we named the file `combo.py.txt`. There are three things we can do with this file:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个完全用RST标记编写的文件。它包含一些解释性文本，一些正式的数学，甚至一些测试用例。这些为我们提供了支持相关代码部分的额外细节。由于PyLit的工作方式，我们将文件命名为`combo.py.txt`。我们可以对这个文件做三件事：
- en: 'We can use PyLit to extract the code from this text file in the following manner:'
  id: totrans-1398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用PyLit以以下方式从这个文本文件中提取代码：
- en: '[PRE203]'
  id: totrans-1399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: This creates `combo.py` from `combo.py.txt`. This is a Python module that is
    ready to be used.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从`combo.py.txt`创建`combo.py`。这是一个准备好使用的Python模块。
- en: We can also use docutils to format this RST into an HTML page that provides
    the documentation and code in a form that we can read more easily than the original
    single-font text.
  id: totrans-1401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用docutils将这个RST格式化为HTML页面，以便我们更容易阅读比原始的单一字体文本。
- en: '[PRE204]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: This creates `combo.py.html` ready for browsing. The `mathjax` package will
    be used by docutils to typeset the mathematical portions, leading to very nice-looking
    output.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建`combo.py.html`，准备浏览。docutils将使用`mathjax`包来排版数学部分，从而产生非常漂亮的输出。
- en: We can, additionally, use PyLit to run `doctest` and confirm that this program
    really works.
  id: totrans-1404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们可以使用PyLit来运行`doctest`并确认这个程序确实有效。
- en: '[PRE205]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: This will extract the `doctest` blocks from the code and run them through the
    `doctest` tool. We'll see that the three tests (the import and the two function
    evaluations) all produce the expected results.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从代码中提取`doctest`块并通过`doctest`工具运行它们。我们会看到三个测试（导入和两个函数评估）都产生了预期的结果。
- en: 'The final web page produced by this would look something like the following
    screenshot:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 由此产生的最终网页将类似于以下的屏幕截图：
- en: '![Working with a literate programming tool](graphics/0971OS_18_01.jpg)'
  id: totrans-1408
  prefs: []
  type: TYPE_IMG
  zh: '![使用文学编程工具](graphics/0971OS_18_01.jpg)'
- en: Our goal is to create software that is trustworthy. A tidy, clear explanation
    of why our design is good is an important part of this trust. By writing the software
    and the documentation side-by-side in a single source text, we can be sure that
    our documentation is complete and provides a sensible review of the design decisions
    and the overall quality of the software. A simple tool can extract working code
    and documentation from a single source, making it easy for us to create the software
    and the documentation.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是创建可信赖的软件。对我们的设计为何好的整洁、清晰的解释是这种信任的重要部分。通过在单一源文本中并排编写软件和文档，我们可以确保我们的文档是完整的，并提供对设计决策和软件整体质量的合理审查。一个简单的工具可以从单一源中提取工作代码和文档，使我们能够轻松创建软件和文档。
- en: Summary
  id: totrans-1410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: 'We looked at the following four ways to create usable documentation:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了以下四种创建可用文档的方法：
- en: We can incorporate the information into the docstrings in our software
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将信息合并到软件的文档字符串中。
- en: We can use `pydoc` to extract the API reference information from our software.
  id: totrans-1413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`pydoc`从我们的软件中提取API参考信息。
- en: We can use Sphinx to create more sophisticated and elaborate documentation
  id: totrans-1414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Sphinx来创建更复杂和精心制作的文档
- en: Also, we can use a literate programming tool to create even deeper and more
    meaningful documentation
  id: totrans-1415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，我们可以使用文学编程工具来创建更深入和更有意义的文档
- en: Design considerations and trade-offs
  id: totrans-1416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: The docstring should be considered as essential as any other part of the Python
    source. This ensures that the `help()` function and `pydoc` will work correctly.
    As with unit test cases, this should be viewed as a mandatory element of the software.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串应被视为Python源代码的任何其他部分一样重要。这确保了`help()`函数和`pydoc`的正确工作。与单元测试用例一样，这应被视为软件的强制要素。
- en: The documentation created by Sphinx can be very good looking; it will tend to
    parallel the Python documentation. Our objective all along has been seamless integration
    with the other features of Python. Using Sphinx tends to introduce an additional
    directory structure for the documentation source and build.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: Sphinx创建的文档可能非常漂亮；它往往会与Python文档平行。我们一直以来的目标是与Python的其他功能无缝集成。使用Sphinx往往会为文档源和构建引入额外的目录结构。
- en: As we design our classes, the question of how to describe the design is almost
    as important as the resulting design itself. Software that can't be explained
    quickly and clearly will be viewed as untrustworthy.
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计我们的类时，如何描述设计的问题几乎和最终设计本身一样重要。不能快速和清晰地解释的软件将被视为不可信任。
- en: Taking the time to write an explanation may identify hidden complexities or
    irregularities. In these cases, we might not refactor a design to correct a bug
    or to improve the performance, but rather to make it easier to explain. The ability
    to explain is a quality factor that has tremendous value.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 花时间写解释可能会发现隐藏的复杂性或不规则性。在这些情况下，我们可能不是为了纠正错误或改进性能而重构设计，而是为了更容易解释。解释的能力是一种具有巨大价值的质量因素。
