- en: Chapter 2 – Strings and collections
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第2章 - 字符串和集合
- en: Python includes a rich selection of built-in collection types which are often
    completely sufficient for even quite intricate programs without resorting to defining
    our own data structures. We’ll give an overview of some of these fundamental collection
    types now – enough to allow us to write some interesting code – although we’ll
    be revisiting each of these collection types, together with a few additional ones,
    in later chapters.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python包括丰富的内置集合类型，这些类型通常足以满足复杂程序的需求，而无需定义自己的数据结构。我们将概述一些基本的集合类型，足以让我们编写一些有趣的代码，尽管我们将在后面的章节中重新讨论这些集合类型，以及一些额外的类型。
- en: 'Let’s start with these types:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这些类型开始：
- en: '`str` – immutable strings of Unicode code points'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str` - 不可变的Unicode代码点字符串'
- en: '`bytes` – immutable strings of bytes'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes` - 不可变的字节字符串'
- en: '`list` – mutable sequences of objects'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list` - 可变的对象序列'
- en: '`dict` – mutable mappings from keys to values'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict` - 可变的键值对映射'
- en: Along the way, we’ll also cover Python’s for-loops.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们还将介绍Python的for循环。
- en: '`str` – an immutable sequence of Unicode code points'
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`str` - 一个不可变的Unicode代码点序列'
- en: Strings in Python have the datatype `str` and we’ve been using them extensively
    already. A string is a sequence of Unicode code-points, and for the most part
    you can think of code-points as being like characters, although they aren’t strictly
    equivalent. The sequence of code-points in a Python string is immutable, so once
    you’ve constructed a string, you can’t modify its contents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的字符串具有数据类型`str`，我们已经广泛地使用了它们。字符串是Unicode代码点的序列，大部分情况下你可以将代码点看作字符，尽管它们并不严格等价。Python字符串中的代码点序列是不可变的，所以一旦你构造了一个字符串，就不能修改它的内容。
- en: String quoting styles
  id: totrans-10
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串引用样式
- en: 'Literal strings in Python are delimited by quotes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的字面字符串由引号括起来：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can use single quotation marks, as we have above. Or you can use double
    quotation marks, as shown below:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用单引号，就像我们上面所做的那样。或者你可以使用双引号，就像下面所示的那样：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You must, however, be consistent. For example, you can’t use a double quotation
    mark paired with a single quotation mark:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，你必须保持一致。例如，你不能使用双引号和单引号配对：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Supporting both quoting styles allows you to easily incorporate the other quote
    character into the literal string without resorting to ugly escape character gymnastics:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 支持两种引用样式使你可以轻松地将另一种引号字符合并到字面字符串中，而不必使用丑陋的转义字符技巧：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Notice that the REPL exploits the same quoting flexibility when echoing the
    strings back to us.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，REPL在将字符串回显给我们时利用了相同的引用灵活性。
- en: '* * *'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅境时刻
- en: '![](images/m02----zen-practicality-beats-purity.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m02----zen-practicality-beats-purity.png)'
- en: 'At first sight support for both quoting styles seems to violate an important
    principle of Pythonic style. From the Zen of Python:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，支持两种引用样式似乎违反了Python风格的一个重要原则。来自Python之禅：
- en: “There should be one – and preferably only one – obvious way to do it.”
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “应该有一种 - 最好只有一种 - 显而易见的方法来做到这一点。”
- en: 'In this case, however, another aphorism from the same source takes precedence:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这种情况下，同一来源的另一句格言占据了主导地位：
- en: ”…practicality beats purity,”
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “……实用性胜过纯粹性，”
- en: 'The utility of supporting two quoting styles is valued more highly than the
    alternative: a single quoting style combined with more frequent use of ugly escape
    sequences, which we’ll encounter shortly.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 支持两种引用样式的实用性比另一种选择更受重视：单一引用样式与更频繁使用丑陋的转义序列的结合，我们很快就会遇到。
- en: '* * *'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Concatenation of adjacent strings
  id: totrans-29
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 相邻字符串的连接
- en: 'Adjacent literal strings are concatenated by the Python compiler into a single
    string:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Python编译器将相邻的字面字符串连接成一个字符串：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although at first this seems rather pointless, it can be useful for nicely formatting
    code as we’ll see later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看这似乎毫无意义，但正如我们将在后面看到的那样，它可以用于很好地格式化代码。
- en: Multiline strings and newlines
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 多行字符串和换行符
- en: 'If you want a literal string containing newlines, you have two options: Use
    multiline strings, or use escape sequences. First, let’s look at multiline strings.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要创建包含换行符的字面字符串，有两种选择：使用多行字符串或使用转义序列。首先，让我们看看多行字符串。
- en: 'Multiline strings are delimited by three quote characters rather than one.
    Here’s an example using three double-quotes:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 多行字符串由三个引号字符而不是一个来界定。下面是一个使用三个双引号的例子：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice how, when the string is echoed back to us, the newlines are represented
    by the `\n` escape sequence.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当字符串被回显时，换行符由`\n`转义序列表示。
- en: 'We can also use three single-quotes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用三个单引号：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As an alternative to using multiline quoting, we can just embed the control
    characters ourselves:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 作为使用多行引用的替代方案，我们可以自己嵌入控制字符：
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To get a better sense of what we’re representing in this case, we can use the
    built-in `print()` function to see the string:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解我们在这种情况下所表示的内容，我们可以使用内置的`print()`函数来查看字符串：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you’re working on Windows, you might be thinking that newlines should be
    represented by the carriage-return, newline couplet `\r\n` rather than just the
    newline character, `\n`. There’s no need to do that with Python, since Python
    3 has a feature called *universal newline support* which translates from the simple
    `\n` to the native newline sequence for your platform on input and output. You
    can read more about Universal Newline Support in [PEP 278](http://www.python.org/dev/peps/pep-0278/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上工作，你可能会认为换行应该由回车换行对`\r\n`表示，而不仅仅是换行字符`\n`。在Python中不需要这样做，因为Python
    3具有一个称为*通用换行符支持*的功能，它可以将简单的`\n`转换为你的平台上的本机换行序列。你可以在[PEP 278](http://www.python.org/dev/peps/pep-0278/)中了解更多关于通用换行符支持的信息。
- en: 'We can use the escape sequences for other purposes, too, such as incorporating
    tabs with `\t` or using quote characters inside strings with `\"`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用转义序列进行其他用途，比如用`\t`来插入制表符，或者在字符串中使用`\"`来使用引号字符：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'or the other way around:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 或者反过来：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, Python is smarter than we are at using the most convenient
    quote delimiters, although Python will also resort to escape sequences when we
    use both types of quotes in a string:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，Python比我们更聪明地使用了最方便的引号分隔符，尽管当我们在字符串中使用两种类型的引号时，Python也会使用转义序列：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Because the backslash has special meaning, to place a backslash in a string
    we must escape the backslash with itself:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因为反斜杠具有特殊含义，所以要在字符串中放置一个反斜杠，我们必须用反斜杠本身来转义反斜杠：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To reassure ourselves that there really is only one backslash in that string,
    we can `print()` it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让自己确信该字符串中确实只有一个反斜杠，我们可以使用`print()`来打印它：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can read more about [escape sequences in the Python documentation](http://docs.python.org/3/reference/lexical_analysis.html#strings)
    .
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[Python文档](http://docs.python.org/3/reference/lexical_analysis.html#strings)中阅读更多关于转义序列的信息。
- en: Raw strings
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 原始字符串
- en: 'Sometimes, particularly when dealing with strings such as Windows filesystem
    paths or regular expression patterns ^([2](chap21.xhtml#fn-regex)) which use backslashes
    extensively, the requirement to double-up on backslashes can be ugly and error
    prone. Python comes to the rescue with its raw strings. Raw strings don’t support
    any escape sequences and are very much what-you-see-is-what-you-get. To create
    a raw string, precede the opening quote with a lower-case `r`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，特别是在处理诸如Windows文件系统路径或大量使用反斜杠的正则表达式模式^([2](chap21.xhtml#fn-regex))时，要求双重反斜杠可能会很丑陋和容易出错。Python通过原始字符串来解决这个问题。原始字符串不支持任何转义序列，非常直观。要创建原始字符串，请在开头引号前加上小写的`r`：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `str` constructor
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`str`构造函数'
- en: 'We can use the `str` constructor to create strings representations of other
    types, such as integers:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`str`构造函数来创建其他类型的字符串表示，比如整数：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'or floats:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或浮点数：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Strings as sequences
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串作为序列
- en: 'Strings in Python are what are called *sequence* types, which means they support
    certain common operations for querying ordered series of elements. For example,
    we can access individual characters using square brackets with an zero-based integer
    index:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的字符串是所谓的*序列*类型，这意味着它们支持查询有序元素序列的某些常见操作。例如，我们可以使用方括号和基于零的整数索引来访问单个字符：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In contrast to many other programming languages, there is no separate character
    type distinct from the string type. The indexing operation returns a full-blown
    string that just contains a single code point element, a fact we can demonstrate
    using Python’s built-in `type()` function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他编程语言相比，Python没有与字符串类型不同的单独的字符类型。索引操作返回一个包含单个代码点元素的完整字符串，这一点我们可以使用Python的内置`type()`函数来证明：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We’ll be looking at types and classes much more later in this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面更详细地讨论类型和类。
- en: String methods
  id: totrans-70
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串方法
- en: 'String objects also support a wide variety of operations implemented as methods.
    We can list those methods by using `help()` on the string type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象还支持作为方法实现的各种操作。我们可以使用`help()`来列出字符串类型的方法：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When you press enter, you should see a display like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当您按下回车时，您应该看到这样的显示：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On any platform you can browse through the help page by pressing the spacebar
    to advance one page at a time until you see the documentation for the `capitalize()`
    method, skipping over all the methods that begin and end with double underscores:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上，您可以通过按空格键以每次前进一页的方式浏览帮助页面，直到看到`capitalize()`方法的文档，跳过所有以双下划线开头和结尾的方法：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Press ‘q’ to quit the help browser, and we’ll try to use `capitalize()`. Let’s
    make a string that deserves capitalization – the name of a capital city no less!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按下'q'退出帮助浏览器，然后我们将尝试使用`capitalize()`。让我们创建一个值得大写的字符串 - 一个首都的名字！
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: To call methods on objects in Python we use the dot after the object name and
    before the method name. Methods are functions, so we must use the parentheses
    to indicate that the method should be called.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中调用对象的方法时，我们在对象名称之后和方法名称之前使用点。方法是函数，所以我们必须使用括号来指示应该调用方法。
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remember that strings are immutable, so the `capitalize()` method didn’t modify
    `c` in place. Rather, it returned a new string. We can verify this, by displaying
    `c`, which remains unchanged:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，字符串是不可变的，所以`capitalize()`方法没有直接修改`c`。相反，它返回了一个新的字符串。我们可以通过显示`c`来验证这一点，它保持不变：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You might like to spend a little time familiarizing yourself with the various
    useful methods provided by the string type by browsing the help.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想花点时间熟悉一下字符串类型提供的各种有用方法，可以通过浏览帮助来了解。
- en: Strings with Unicode
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带Unicode的字符串
- en: 'Strings are fully Unicode capable, so you can use them with international characters
    easily, even in literals, because the default source code encoding for Python
    3 is UTF-8\. For example, if you have access to Norwegian characters, you can
    simply enter this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串完全支持Unicode，因此您可以轻松地在国际字符中使用它们，甚至在文字中，因为Python 3的默认源代码编码是UTF-8。例如，如果您可以访问挪威字符，您可以简单地输入这个：
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Alternatively, you can use the hexadecimal representations of Unicode code
    points as an escape sequence prefixed by `\u`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或浮点数：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We’re sure you’ll agree, though, that this is somewhat more unwieldy.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，我们相信这有点不太方便。
- en: 'Similarly, you can use the `\x` escape sequence followed by a 2-character hexadecimal
    string to include one-byte Unicode code points in a string literal:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以使用`\x`转义序列，后跟一个2字符的十六进制字符串，以在字符串文字中包含一个字节的Unicode代码点：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can even an use an escaped octal string using a single backlash followed
    by three digits in the range zero to seven, although we confess we’ve never seen
    this used in practice, except inadvertently as a bug:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您甚至可以使用一个转义的八进制字符串，使用一个反斜杠后跟三个零到七之间的数字，尽管我们承认我们从未见过这种用法，除非无意中作为错误：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There are no such Unicode capabilities in the otherwise similar `bytes` type,
    which we’ll look at next.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在否则类似的`bytes`类型中没有这样的Unicode功能，我们将在下一节中介绍。
- en: '`bytes` – an immutable sequence of bytes'
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`bytes` - 一个不可变的字节序列'
- en: The `bytes` type is similar to the `str` type, except that rather than each
    instance being a sequence of Unicode code points, each instance is a sequence
    of, well, bytes. As such, `bytes` objects are used for raw binary data and fixed-width,
    single-byte character encodings, such as ASCII.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes`类型类似于`str`类型，不同之处在于每个实例不是Unicode代码点的序列，而是字节的序列。因此，`bytes`对象用于原始二进制数据和固定宽度的单字节字符编码，如ASCII。'
- en: Literal `bytes`
  id: totrans-97
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 文字`bytes`
- en: 'As with strings they have a simple, literal form delimited by either single
    or double quotes, although for literal `bytes` the opening quote must be preceded
    by a lower-case `b`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与字符串一样，它们有一个简单的文字形式，由单引号或双引号分隔，尽管对于文字`bytes`，开头引号必须由小写`b`前缀：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'There is also a `bytes` constructor, but it has fairly complex behavior and
    we defer coverage of it to the second book in this series, *The Python Journeyman*.
    At this point in our journey, it’s sufficient for us to recognize `bytes` literals
    and understand that they support many of the same operations as `str`, such as
    indexing and splitting:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`bytes`构造函数，但它有相当复杂的行为，我们将在本系列的第二本书*The Python Journeyman*中进行介绍。在我们的旅程中的这一点上，我们只需要认识到`bytes`文字并理解它们支持与`str`相同的许多操作，如索引和分割：
- en: '[PRE30]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You’ll see that the `split()` method returns a `list` of of `bytes` objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到`split()`方法返回一个`bytes`对象的`list`。
- en: Converting between `bytes` and `str`
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`bytes`和`str`之间转换
- en: To convert between `bytes` and `str` we must know the encoding of the byte sequence
    used to represent the string’s Unicode code points as bytes. Python supports a
    wide-variety of so-called *codecs* such as UTF-8, UTF-16, ASCII, Latin-1, Windows-1251,
    and so on – consult the Python documentation for a [current list of codecs](http://docs.python.org/3/library/codecs.html#standard-encodings)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`bytes`和`str`之间转换，我们必须知道用于表示字符串的Unicode代码点的字节序列的编码。Python支持各种所谓的*codecs*，如UTF-8、UTF-16、ASCII、Latin-1、Windows-1251等等-请参阅Python文档以获取[当前codecs列表](http://docs.python.org/3/library/codecs.html#standard-encodings)
- en: In Python we can *encode* a Unicode `str` into a `bytes` object, and going the
    other way we can *decode* a `bytes` object into a Unicode `str`. In either direction
    it’s up to us to specify the encoding. Python won’t — and generally speaking can’t
    –– do anything to prevent you erroneously decoding UTF-16 data stored in a `bytes`
    object using, say, a CP037 codec for handling strings on legacy IBM mainframes.
    If you’re lucky the decoding will fail with a `UnicodeError` at runtime; if you’re
    unlucky you’ll wind up with a `str` full of garbage that will go undetected by
    your program.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以将Unicode`str`*编码*为`bytes`对象，反之亦然，我们可以将`bytes`对象*解码*为Unicode`str`。在任何方向上，我们都必须指定编码。Python不会-通常也不能-阻止您使用CP037编解码`bytes`对象中存储的UTF-16数据，例如处理旧IBM主机上的字符串。如果你幸运的话，解码将在运行时失败并显示`UnicodeError`；如果你不幸的话，你将得到一个充满垃圾的`str`，这将不会被你的程序检测到。
- en: '![Encoding and decoding strings.](images/m02----encoding-decoding.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![编码和解码字符串。](images/m02----encoding-decoding.png)'
- en: Encoding and decoding strings.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 编码和解码字符串。
- en: 'Let’s kick off an interactive session looking at strings, with an interesting
    Unicode string which contains all the characters of the 29 letter Norwegian alphabet
    – a pangram:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个交互式会话，查看字符串，其中包含29个字母的挪威字母表-一个全字母句：
- en: '[PRE31]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We’ll now encode that using the UTF-8 codec into a `bytes` object using the
    `encode()` method of the `str` object:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将使用UTF-8编解码器将其编码为`bytes`对象，使用`str`对象的`encode()`方法：
- en: '[PRE32]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: See how each of the Norwegian letters has been rendered as a pair of bytes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 看看每个挪威字母是如何被渲染为一对字节的。
- en: 'We can reverse the process using the `decode()` method of the `bytes` object.
    Again, it is up to us to supply the correct encoding:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`bytes`对象的`decode()`方法来反转这个过程。同样，我们必须提供正确的编码：
- en: '[PRE33]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can check that the encoding/decoding round-trip gives us a result equal
    to what we started with:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查编码/解码往返是否给我们带来了与我们开始时相等的结果：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'and display it for good measure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 并显示它以好的方式：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: All this messing about with encodings may seem like unnecessary detail at this
    juncture – especially if you operate in an anglophone environment – but it’s crucial
    to understand since files and network resources such as HTTP responses are transmitted
    as byte streams, whereas we prefer to work with the convenience of Unicode strings.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个时刻，所有这些与编码有关的操作可能看起来像是不必要的细节-特别是如果您在一个英语环境中操作-但这是至关重要的，因为文件和网络资源（如HTTP响应）是作为字节流传输的，而我们更喜欢使用Unicode字符串的便利。
- en: '`list` – a sequence of objects'
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`list`-对象的序列'
- en: Python `list`s, such as those returned by the string `split()` method, are sequences
    of objects. Unlike strings `list`s are mutable, insofar as the elements within
    them can be replaced or removed, and new elements can be inserted or appended.
    `list`s are the workhorse of Python data structures.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Python `list`，例如字符串`split()`方法返回的那些，是对象的序列。与字符串不同，`list`是可变的，因为其中的元素可以被替换或移除，并且可以插入或追加新元素。`list`是Python数据结构的工作马。
- en: 'Literal lists are delimited by square brackets, and the items within the `list`
    are separated by commas. Here is a `list` of three numbers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 文字列表由方括号分隔，并且`list`中的项目由逗号分隔。这是一个包含三个数字的`list`：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And here is a `list` of three strings:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个包含三个字符串的`list`：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can retrieve elements by using square brackets with a zero-based index:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用零为基础的索引用方括号检索元素：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can replace elements by assigning to a specific element:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分配给特定元素来替换元素：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See how `list`s can be heterogeneous with respect to the type of the contained
    objects. We now have a `list` containing an `str`, an `int`, and another `str`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`list`在包含的对象的类型方面可以是异构的。我们现在有一个包含`str`、`int`和另一个`str`的`list`。
- en: 'It’s often useful to create an empty list, which we can do using empty square
    brackets:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空列表通常是有用的，我们可以使用空方括号来做到这一点：
- en: '[PRE40]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can modify the `list` in other ways. Let’s add some `float`s to the end
    of the `list` using the `append()` method:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以其他方式修改`list`。让我们使用`append()`方法在`list`的末尾添加一些`float`：
- en: '[PRE41]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There are many other useful methods for manipulating `list`s, which we’ll cover
    in a later chapter. Right now, we just need to be able to perform rudimentary
    `list` operations.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他有用的方法可以操作`list`，我们将在后面的章节中介绍。现在，我们只需要能够执行基本的`list`操作。
- en: 'There is also a `list` constructor, which can be used to create lists from
    other collections, such as strings:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`list`构造函数，可以用来从其他集合（如字符串）创建列表：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Although the significant whitespace rules in Python can, at first, seem very
    rigid, there is a lot of flexibility. For example, if you have unclosed brackets,
    braces, or parentheses at the end of a line, you can continue on the next line.
    This can be very useful for representing long literal collections, or improving
    the readability of even short collections:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python中的显著空格规则起初似乎非常严格，但实际上有很大的灵活性。例如，如果一行末尾有未关闭的括号、大括号或括号，可以继续到下一行。这对于表示长的字面集合或甚至改善短集合的可读性非常有用：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: See also how we’re allowed to use an additional comma after the last element,
    an handy feature that improves the maintainability of the code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，我们可以在最后一个元素后使用额外的逗号，这是一个方便的功能，可以提高代码的可维护性。
- en: '`dict` – associating keys with values'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`dict` - 将键与值关联起来'
- en: Dictionaries – embodied in the `dict` type – are completely fundamental to the
    way the Python language works, and are very widely used. A dictionary maps keys
    to values, and in some languages it is known as a map or associative array. Let’s
    look at how to create and use dictionaries in Python.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 字典 - 体现在`dict`类型中 - 对Python语言的工作方式非常基本，并且被广泛使用。字典将键映射到值，在某些语言中被称为映射或关联数组。让我们看看如何在Python中创建和使用字典。
- en: 'Literal dictionaries are created using curly braces containing key-value pairs.
    Each pair is separated by a comma, and each key is separated from its corresponding
    value by a colon. Here we use a dictionary to create a simple telephone directory:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用花括号创建字面上的字典，其中包含键值对。每对由逗号分隔，每个键与其对应的值由冒号分隔。在这里，我们使用字典创建一个简单的电话目录：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can retrieve items by key using the square brackets operator:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用方括号运算符按键检索项目：
- en: '[PRE45]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And we can update the value associated with a particular key by assigning through
    the square brackets:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过方括号进行赋值来更新与特定键关联的值：
- en: '[PRE46]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If we assign to a key that has not yet been added, a new entry is created:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为尚未添加的键赋值，将创建一个新条目：
- en: '[PRE47]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Be aware that the entries in the dictionary can’t be relied upon to be stored
    in any particular order, and in fact the order that Python chooses may even change
    between runs of the same program.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字典中的条目不能依赖于以任何特定顺序存储，并且实际上Python选择的顺序甚至可能在同一程序的多次运行之间发生变化。
- en: 'Similarly to lists, empty dictionaries can be created using empty curly braces:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 与列表类似，可以使用空的花括号创建空字典：
- en: '[PRE48]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This has been a *very* cursory look at dictionaries, but we’ll be revisiting
    them in much more detail in Chapter 5.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是对字典的一个非常粗略的介绍，但我们将在第5章中更详细地重新讨论它们。
- en: For-loops – iterating over series of items
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for循环 - 迭代一系列项目
- en: 'Now that we have the tools to make some interesting data structures, we’ll
    look at Python’s other type of loop construct, the for-loop. For-loops in Python
    correspond to what are called for-each loops in many other programming languages.
    They request items one-by-one from a collection – or more strictly from an iterable
    series (but more of that later) – and assign them in turn to the a variable we
    specify. Let’s create a `list` collection, and use a for-loop to iterate over
    it, remembering to indent the code within the for-loop by four spaces:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了制作一些有趣的数据结构的工具，我们将看看Python的另一种循环结构，即for循环。在Python中，for循环对应于许多其他编程语言中称为for-each循环的东西。它们从集合中逐个请求项目
    - 或更严格地说是从可迭代系列中（但稍后会详细介绍） - 并将它们依次分配给我们指定的变量。让我们创建一个`list`集合，并使用for循环对其进行迭代，记得将for循环内的代码缩进四个空格：
- en: '[PRE49]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So iterating over a `list` yields the items one-by-one. If you iterate over
    a dictionary, you get just the keys in seemingly random order, which can then
    be used within the for-loop body to retrieve the corresponding values. Let’s define
    a dictionary which maps color name strings to hexadecimal integer color codes
    stored as integers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对`list`进行迭代会逐个返回项目。如果对字典进行迭代，你会得到看似随机顺序的键，然后可以在for循环体内使用这些键来检索相应的值。让我们定义一个字典，将颜色名称字符串映射到存储为整数的十六进制整数颜色代码：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here we use the ability of the built-in `print()` function to accept multiple
    arguments, passing the key and the value for each color separately. See also how
    the color codes returned to us are in decimal.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内置的`print()`函数接受多个参数的能力，分别传递每种颜色的键和值。还要注意返回给我们的颜色代码是十进制的。
- en: Now, before we put some of what we’ve learned together into a useful program,
    practice exiting the Python REPL with `Ctrl-Z` on Windows or `Ctrl-D` on Mac or
    Linux.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们将学到的一些东西整合到一个有用的程序中之前，练习使用`Ctrl-Z`（Windows）或`Ctrl-D`（Mac或Linux）退出Python
    REPL。
- en: Putting it all together
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 把所有东西放在一起
- en: Let’s take a short detour to try out some of the tools we’ve introduced on a
    slightly larger example. Textbooks typically avoid such pragmatism, especially
    in the early chapters, but we think it’s fun to apply new ideas to practical situations.
    To avoid getting off the the wrong stylistic foot, we’ll need to introduce a few
    “black-box” components to get the job done, but you’ll learn about them in detail
    later, so don’t worry.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微偏离一下，尝试一下我们在稍大的示例中介绍的一些工具。教科书通常避免这种实用主义，特别是在早期章节，但我们认为将新的想法应用到实际情况中是有趣的。为了避免走样，我们需要引入一些“黑匣子”组件来完成工作，但你以后会详细了解它们，所以不用担心。
- en: 'We’re going to write a longer snippet at the REPL, and briefly introduce the
    `with` statement. Our code will fetch some text data for some classic literature
    from the web using a Python standard library function called `urlopen()`. Here’s
    the code entered at the REPL in full. We’ve annotated this code snippet with line
    numbers to facilitate referring to lines from the explanation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在REPL中编写一个更长的片段，并简要介绍`with`语句。我们的代码将使用Python标准库函数`urlopen()`从网络中获取一些经典文学的文本数据。以下是在REPL中输入的完整代码。我们已经用行号注释了这段代码片段，以便参考解释中的行：
- en: '[PRE51]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We’ll work through this code, explaining each line in turn.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐行解释这段代码，依次解释每一行。
- en: To get access to `urlopen()` we need to import the function from the `request`
    module, which itself resides within the standard library `urllib` package.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问`urlopen()`，我们需要从`request`模块中导入该函数，该模块本身位于标准库`urllib`包中。
- en: We’re going to call `urlopen()` with the URL to the story text. We use a Python
    construct called a with-block to manage the resource obtained from the URL, since
    fetching the resource from the web requires operating system sockets and suchlike.
    We’ll be talking more about `with` statements in a later chapter, but for now
    it’s enough to know that using a `with` statement with objects which use external
    resources is good practice to avoid so-called *resource leaks*. The `with` statement
    calls the `urlopen()` function and binds the response object to a variable named
    `story`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用URL调用`urlopen()`来获取故事文本。我们使用一个称为with块的Python构造来管理从URL获取的资源，因为从网络获取资源需要操作系统套接字等。我们将在后面的章节中更多地讨论`with`语句，但现在知道，对于使用外部资源的对象使用`with`语句是良好的做法，以避免所谓的*资源泄漏*。`with`语句调用`urlopen()`函数，并将响应对象绑定到名为`story`的变量。
- en: Notice that the `with` statement is terminated by a colon, which introduces
    a new block, so within the block we must indent four spaces. We create an empty
    `list` which ultimately will hold all of the words from the retrieved text.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，`with`语句以冒号结尾，引入了一个新的代码块，因此在代码块内部我们必须缩进四个空格。我们创建一个空的`list`，最终将保存从检索到的文本中提取出的所有单词。
- en: We open a for-loop which will iterate through the story. Recall that for-loops
    request items one-by-one from the expression on the right of the `in` keyword
    — in this case `story` — and assign them in turn to the the name on the left —
    in this case `line`. It so happens that that type of HTTP response object referred
    to by `story` yields successive lines of text from the response body when iterated
    over in this way, so the for-loop retrieves one line of text at a time from the
    story. The `for` statement is also terminated by a colon because it introduces
    the body of the for-loop, which is a new block and hence a further level of indentation.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开一个for循环，它将遍历整个故事。请记住，for循环会从`in`关键字右侧的表达式（在本例中是`story`）逐个请求项目，并依次将它们分配给左侧的名称（在本例中是`line`）。碰巧，由`story`引用的HTTP响应对象类型以这种方式迭代时会从响应主体中产生连续的文本行，因此for循环会逐行从故事中检索文本。`for`语句也以冒号结尾，因为它引入了for循环的主体，这是一个新的代码块，因此需要进一步缩进。
- en: For each line of text, we use the `split()` method to divide it into words on
    whitespace boundaries, resulting in a list of words we call `line_words`.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每一行文本，我们使用`split()`方法将其按空白边界分割成单词，得到一个我们称为`line_words`的单词列表。
- en: Now we use a second for-loop nested inside the first to iterate over this list
    of words.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们使用嵌套在第一个循环内部的第二个for循环来遍历这个单词列表。
- en: We `append()` each word in turn to the accumulating `story_words` list.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们依次将每个单词`append()`到累积的`story_words`列表中。
- en: Finally, we enter a blank line at the three dots prompt to close all open blocks
    — in this case the inner for-loop , the outer for-loop, and the with-block will
    all be terminated. The block will be executed, and after a short delay, Python
    now returns us to the regular triple-arrow prompt. At this point if Python gives
    you an error, such as a `SyntaxError` or `IndentationError`, you should go back,
    review what you entered, and carefully re-enter the code until Python accepts
    the whole block without complaint. If you get an `HTTPError`, then you were unable
    to fetch the resource over the Internet, and you should check your network connection
    or try again later, although it’s worth checking that you typed the URL correctly.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在三个点的提示下输入一个空行，以关闭所有打开的代码块——在本例中，内部for循环、外部for循环和with块都将被终止。代码块将被执行，稍后，Python现在将我们返回到常规的三角形提示符。此时，如果Python给出错误，比如`SyntaxError`或`IndentationError`，您应该回去，检查您输入的内容，并仔细重新输入代码，直到Python接受整个代码块而不抱怨。如果出现`HTTPError`，则表示无法通过互联网获取资源，您应该检查您的网络连接或稍后重试，尽管值得检查您是否正确输入了URL。
- en: 'We can look at the words we’ve collected by asking Python to evaluate the value
    of `story_words`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过要求Python评估`story_words`的值来查看我们收集到的单词：
- en: '[PRE52]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This sort of exploratory programming at the REPL is very common for Python,
    as it allows us to figure out what bits of code do before we decide to use them.
    In this case notice that each of the single-quoted words is prefixed by a lower-case
    letter `b` meaning that we have a list of `bytes` objects where we would have
    preferred a list of `str` objects. This is because the HTTP request transferred
    raw bytes to us over the network. To get a list of strings we should decode the
    byte stream in each line from UTF-8 into Unicode strings. We can do this by inserting
    a call to the `decode()` method of the bytes object, and then operating on the
    resulting Unicode string. The Python REPL supports a simple command history, and
    by careful use of the up and down arrow keys, we can re-enter our snippet, although
    there’s no need to re-import `urlopen`, so we can skip the first line:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中进行这种探索性编程对于Python来说非常常见，因为它允许我们在决定使用它们之前弄清楚代码的各个部分。在这种情况下，请注意每个用单引号引起来的单词前面都有一个小写字母`b`，这意味着我们有一个`bytes`对象的列表，而我们更希望有一个`str`对象的列表。这是因为HTTP请求通过网络向我们传输了原始字节。要获得一个字符串列表，我们应该将每行中的字节流从UTF-8解码为Unicode字符串。我们可以通过插入`decode()`方法的调用来做到这一点，然后对生成的Unicode字符串进行操作。Python
    REPL支持一个简单的命令历史记录，通过仔细使用上下箭头键，我们可以重新输入我们的片段，尽管没有必要重新导入`urlopen`，所以我们可以跳过第一行：
- en: '[PRE53]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'It is the fourth line here we have changed – you can just edit it using the
    left and right arrow keys to insert the requisite call to `decode()` when you
    get to that part of the command history. When we re-run the block and take a fresh
    look at `story_words`, we should see we have a list of strings:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们改变了第四行 - 当你到达命令历史的那部分时，你可以使用左右箭头键编辑它，插入对`decode()`的必要调用。当我们重新运行这个块并重新查看`story_words`时，我们应该看到我们有一个字符串列表：
- en: '[PRE54]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We’ve just about reached the limit of what’s comfortable to enter and revise
    at the Python REPL, so in the next chapter we’ll look at how to move this code
    into a file where it can be more easily worked with in a text editor.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎达到了在Python REPL中舒适输入和修改的极限，所以在下一章中，我们将看看如何将这段代码移到一个文件中，在那里可以更容易地在文本编辑器中处理。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 总结
- en: '`str` Unicode strings and `bytes` strings:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str` Unicode字符串和`bytes`字符串：'
- en: We looked at the various forms of quotes (single or double quotation marks)
    for quoting strings, useful for incorporating quote marks themselves into strings.
    Python is flexible over which quoting style you use, but you must be consistent
    when delimiting a particular string.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看了看引号的各种形式（单引号或双引号）来引用字符串，这对于将引号本身合并到字符串中非常有用。Python在你使用哪种引号风格上很灵活，但在界定特定字符串时必须保持一致。
- en: We demonstrated that so-called triple quotes, consisting of three consecutive
    quotation mark characters can be used to delimit a multi-line string. Traditionally,
    each quote character is itself a double-quotation mark, although single quotation
    marks can also be used.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们演示了所谓的三重引号，由三个连续的引号字符组成，可以用来界定多行字符串。传统上，每个引号字符本身都是双引号，尽管也可以使用单引号。
- en: We saw how adjacent string literals are implicitly concatenated.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们看到相邻的字符串文字会被隐式连接。
- en: Python has support for universal newlines, so no matter what platform you’re
    using it’s sufficient to use a single `\n` character, safe in the knowledge that
    is will be appropriately translated from and to the native newline during I/O.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python支持通用换行符，所以无论你使用什么平台，只需使用一个`\n`字符，就可以放心地知道它将在I/O期间被适当地从本机换行符转换和转换。
- en: Escape sequences provide an alternative means of incorporating newlines and
    other control characters into literal strings.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转义序列提供了将换行符和其他控制字符合并到文字字符串中的另一种方法。
- en: The backslashes used for escaping can be a hindrance for Windows filesystem
    paths or regular expressions, so raw strings with an `r` prefix can be used to
    suppress the escaping mechanism.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于转义的反斜杠可能会对Windows文件系统路径或正则表达式造成阻碍，因此可以使用带有`r`前缀的原始字符串来抑制转义机制。
- en: Other types, such as integers, can be converted to strings using the `str()`
    constructor.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型，比如整数，可以使用`str()`构造函数转换为字符串。
- en: Individual characters, returned as one character strings, can be retrieved using
    square brackets with integer zero-based indices.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用带有整数从零开始的索引的方括号检索单个字符，返回一个字符字符串。
- en: Strings support a rich variety of operations, such as splitting, through their
    methods.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串支持丰富多样的操作，比如通过它们的方法进行分割。
- en: In Python 3, literal strings can contain any Unicode character directly in the
    source, which is interpreted as UTF-8 by default.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python 3中，文字字符串可以直接包含任何Unicode字符，这在源代码中默认解释为UTF-8。
- en: The `bytes` type has many of the capabilities of strings, but it is a sequence
    as bytes rather than a sequence of Unicode code points.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes`类型具有许多字符串的功能，但它是字节序列而不是Unicode代码点序列。'
- en: '`bytes` literals are prefixed with a lowercase `b`.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes`文字以小写的`b`为前缀。'
- en: To convert between string and bytes instances we use the `encode()` method of
    `str` or the `decode()` method of `bytes`, in both cases passing the name of the
    codec, which we must know in advance.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在字符串和字节实例之间转换，我们使用`str`的`encode()`方法或`bytes`的`decode()`方法，在这两种情况下都要传递编解码器的名称，这是我们必须事先知道的。
- en: '`list`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表
- en: Lists are mutable, heterogeneous sequences of objects.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表是可变的、异构的对象序列。
- en: List literals are delimited by square brackets and the items are separated by
    commas.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表文字由方括号界定，项目之间用逗号分隔。
- en: Individual elements can be retrieved by indexing into a list with square brackets
    containing a zero-based integer index.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用包含从零开始的整数索引的方括号从列表中检索单个元素。
- en: In contrast to strings individual list elements can be replaced by assigning
    to the indexed item.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与字符串相反，可以通过对索引项赋值来替换单个列表元素。
- en: Lists can be grown by `append()`-ing to them, and can be constructed from other
    sequences using the `list()` constructor.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表可以通过`append()`来扩展，也可以使用`list()`构造函数从其他序列构造。
- en: '`dict`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`'
- en: Dictionaries associate keys with values.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典将键与值关联起来。
- en: Literal dictionaries are delimited by curly braces. The key-value pairs are
    separated from each other by commas, and each key is associated with its corresponding
    value with a colon.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字面上的字典由花括号括起来。键值对之间用逗号分隔，每个键与其相应的值用冒号关联。
- en: '`for` loops'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环'
- en: For-loops take items one-by-one from an iterable object such as a `list`, and
    bind the same name to the current item.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: For 循环逐个从可迭代对象（如 `list`）中取出项目，并将相同的名称绑定到当前项目。
- en: They correspond to what are called for-each loops in other languages.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们对应于其他语言中称为 for-each 循环的内容。
