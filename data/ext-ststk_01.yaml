- en: Chapter 1. Starting with the Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章：从基础知识开始
- en: The vast majority of Salt users see it as a configuration management platform.
    And in truth, it handles that very well. But it did not start off with that as
    a design goal. In its early days, Salt was a communication framework that was
    designed to be useful even to those who did not write code. But for those who
    were willing, it was also designed to be heavily extensible to those users who
    had some Python in their toolbelt.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Salt用户将其视为配置管理平台。事实上，它在这方面处理得非常好。但它的设计目标并非一开始就是如此。在其早期，Salt是一个通信框架，旨在对那些不编写代码的人来说也很有用。但对于那些愿意的人来说，它也被设计成对那些工具箱中有些Python知识的使用者高度可扩展。
- en: 'Before we get into writing modules, it will help to have a basic understanding
    of how the Salt module system works. In this chapter, you''ll learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写模块之前，了解Salt模块系统的工作原理会有所帮助。在本章中，你将学习以下内容：
- en: How the loader system works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载系统的工作原理
- en: How Salt uses Python
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salt如何使用Python
- en: Using plugins
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用插件
- en: As Salt was originally designed as a backbone that other software could use
    to communicate, its earliest purpose was to collect information from a large cluster
    of both physical and virtual machines, and return that data either to the user
    or to a database. Various programs, such as `ps`, `du`, and `netstat`, were used
    to collect that information. Because of that, each program was wrapped with a
    plugin, which contained various functions to call those programs, and parse the
    return data.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Salt最初被设计为一个其他软件可以用来通信的骨干，其最初目的是从大量物理和虚拟机器中收集信息，并将这些数据返回给用户或数据库。各种程序，如`ps`、`du`和`netstat`，被用来收集这些信息。因此，每个程序都被一个插件封装，其中包含调用这些程序和解析返回数据的各种功能。
- en: Those plugins were originally called modules. Later, when other types of module
    were added to Salt, the original modules began to be referred to as *execution
    modules*. This is because the execution modules would do the heavy lifting, and
    other types of module would generally wrap around them and extend their functionality.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些插件最初被称为模块。后来，当Salt中添加了其他类型的模块时，原始模块开始被称为*执行模块*。这是因为执行模块会承担繁重的工作，而其他类型的模块通常围绕它们扩展其功能。
- en: Loading modules
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加载模块
- en: Like many data centers, the one that Salt was created in had various servers
    that used different software packages to perform their work. One server would
    be running Nginx, while another would be running DNSMasq. It wouldn't make sense
    to enable the `nginx` module on the DHCP server, or a `dnsmasq` module on the
    web server. A number of popular programs solve this by allowing the user to configure
    which plugins will be loaded before starting the service.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像许多数据中心一样，Salt被创建的那个数据中心拥有各种服务器，它们使用不同的软件包来完成工作。一台服务器可能运行Nginx，而另一台服务器可能运行DNSMasq。在DHCP服务器上启用`nginx`模块或在Web服务器上启用`dnsmasq`模块是没有意义的。许多流行的程序通过允许用户在启动服务之前配置要加载的插件来解决这一问题。
- en: Salt had a different way of handling plugins. In a large infrastructure, individual
    configuration of servers can be costly in terms of time. And as configuration
    management was added to Salt, a core belief grew that configuration management
    platforms should require as little configuration themselves as possible. What
    is the point of using such a suite to save time if so much time is required to
    get it going in the first place?
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Salt处理插件的方式与其他不同。在一个大型基础设施中，单个服务器的配置可能非常耗时。随着配置管理被添加到Salt中，一个核心信念逐渐形成，即配置管理平台本身应该尽可能少地需要配置。如果一开始就需要花费大量时间来启动，那么使用这样的套件来节省时间又有什么意义呢？
- en: This is how the loader system came to be. Salt would always ship with a full
    set of modules, and Salt would automatically detect modules that would be available,
    and dynamically load them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是加载系统是如何产生的。Salt总是附带一套完整的模块，并且Salt会自动检测可用的模块，并动态加载它们。
- en: Execution modules are a type of plugin that performs most of the heavy lifting
    inside of Salt. These were the first to use the loader system, and for a short
    time there was no other type of module. As the functionality of Salt increased,
    it quickly became evident that other types of module would be needed. For instance,
    return output was originally just printed to the console. Then the output was
    changed to be easier to handle from shell scripts. Then the outputter system was
    added, so that output could be displayed in JSON, YAML, Python's `pprint`, and
    any other format that might be useful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 执行模块是一种插件，在 Salt 内部执行大部分繁重的工作。这些是第一个使用加载系统的，在一段时间内没有其他类型的模块。随着 Salt 功能的增加，很快就很明显需要其他类型的模块。例如，返回输出最初只是打印到控制台。然后输出被改为更容易从
    shell 脚本中处理。然后添加了输出器系统，以便可以在 JSON、YAML、Python 的 `pprint` 以及任何可能有用的其他格式中显示输出。
- en: Standard modules
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准模块
- en: In the beginning, there were some types of module that would always be loaded.
    The first of these was the `test` module, which required nothing more than Salt's
    own dependencies; in particular, it would only require Python.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，有一些类型的模块总是会加载。其中第一个是 `test` 模块，它只需要 Salt 自身的依赖项；特别是，它只需要 Python。
- en: Other modules were also designed for general use, requiring no more than Salt's
    own dependencies. The `file` module would perform various file-based operations.
    The `useradd` module would wrap the standard Unix `useradd` program. This was
    fine, so long as Salt was only used on Unix-like platforms. When users started
    running Salt on Windows, where those utilities were not readily available, things
    changed. This is where virtual modules really started to shine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其他模块也设计用于通用用途，不需要比 Salt 自身的依赖项更多。`file` 模块将执行各种基于文件的操作。`useradd` 模块将包装标准的 Unix
    `useradd` 程序。这很好，只要 Salt 只在 Unix-like 平台上使用。当用户开始在 Windows 上运行 Salt 时，这些实用工具并不容易获得，情况就改变了。这正是虚拟模块真正开始发光的地方。
- en: Virtual modules
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟模块
- en: 'Supporting Salt on various platforms, such as both Unix-like and Windows, presents
    the same problem as whether or not to make the `nginx` module available: if that
    platform is installed and available, make the module available. Otherwise, don''t.
    Salt handles the availability problem by implementing virtual modules.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在各种平台上支持 Salt，例如 Unix-like 和 Windows，与是否使 `nginx` 模块可用的问题类似：如果该平台已安装且可用，则使模块可用。否则，不要。Salt
    通过实现虚拟模块来处理可用性问题。
- en: The idea behind a virtual module is that it will contain a piece of code that
    will detect whether or not its dependencies are met, and if so, the module will
    be loaded and made available to Salt on that system. We'll get into the details
    of actually doing this in [Chapter 2](part0019_split_000.html#I3QM2-d9976ffc65994572ad672a3ef48f1135
    "Chapter 2. Writing Execution Modules"), *Writing Execution Modules*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟模块背后的想法是它将包含一段代码，用于检测其依赖项是否满足，如果满足，则该模块将被加载并使该系统上的 Salt 可用。我们将在[第 2 章](part0019_split_000.html#I3QM2-d9976ffc65994572ad672a3ef48f1135
    "第 2 章。编写执行模块")*编写执行模块*中详细介绍如何实际执行此操作。
- en: Lazy loading modules
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 惰性加载模块
- en: In the beginning, if a module was detected as being loadable, then it would
    be loaded as the Salt service was started. A number of modules may be loaded for
    a particular system, which the administrator never intends to use. It may be nice
    to have them, but in some cases it's better to only load them when they're needed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始时，如果检测到某个模块可加载，那么在 Salt 服务启动时就会加载该模块。对于特定系统，可能加载多个模块，管理员可能永远不会使用它们。虽然拥有它们可能不错，但在某些情况下，仅在需要时加载它们会更好。
- en: When the Salt service starts, the lazy loader will detect which modules may
    be used on a particular system, but it won't immediately load them into memory.
    Once a particular module is called, Salt will load it on demand, and then keep
    it in memory. On a system that typically only uses a small handful of modules,
    this can result in a much smaller footprint than before.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Salt 服务启动时，惰性加载器将检测特定系统上可能使用的模块，但它不会立即将它们加载到内存中。一旦调用特定模块，Salt 将按需加载它，并将其保留在内存中。在一个通常只使用少量模块的系统上，这可以比以前产生更小的内存占用。
- en: Extending the loader system
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展加载系统
- en: 'As we said before, the loader system was originally designed for one type of
    module: what we now call execution modules. Before long, other types of module
    were added, and that number continues to grow even today.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所说，加载系统最初是为一种类型的模块设计的：我们现在称之为执行模块。不久之后，添加了其他类型的模块，而且这个数量至今仍在增长。
- en: 'This book does not include every type of module, but it does cover quite a
    few. The following list is not comprehensive, but it will tell you much of what
    is available now, and possibly give you an idea of what other types of module
    to look at after you finish this book:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并不包括所有类型的模块，但它确实涵盖了相当多。以下列表并不全面，但它将告诉您现在可用的许多内容，并在您完成本书后可能给您提供一个关于其他类型模块的参考：
- en: '**Execution modules** do much of the heavy lifting inside of Salt. When a program
    needs to be called, an execution module will be written for it. When other modules
    need to use that program, they will call out to that module.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行模块**在 Salt 内部执行大部分繁重的工作。当需要调用一个程序时，将为它编写一个执行模块。当其他模块需要使用该程序时，它们将调用该模块。'
- en: '**Grain modules** are used to report information about Minions. **Virtual modules**
    often rely heavily on these. Configuration can also be defined in grains.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grain 模块**用于报告关于 minion 的信息。**虚拟模块**通常严重依赖这些模块。配置也可以在 grains 中定义。'
- en: '**Runner modules** were designed to add an element of scripting to Salt. Whereas
    execution modules run on Minions, a runner module would run on the Master, and
    call out to the Minions.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Runner 模块**被设计用来给 Salt 添加脚本元素。而执行模块在 minion 上运行，runner 模块则会在 Master 上运行，并调用
    minion。'
- en: '**Returner modules** give Minions a way to return data to something besides
    the Master, such as a database configured to store log data.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Returner 模块**为 minion 提供了一种将数据返回给 Master 以外的途径，例如配置为存储日志数据的数据库。'
- en: '**State modules** transform Salt from a remote execution framework into a configuration
    management engine.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**State 模块**将 Salt 从远程执行框架转变为配置管理引擎。'
- en: '**Renderer modules** allow Salt States to be defined using different file formats,
    as appropriate.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Renderer 模块**允许使用不同的文件格式（根据需要）定义 Salt States。'
- en: '**Pillar modules** extend grains, by providing a more centralized system of
    defining configuration.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pillar 模块**通过提供更集中的配置定义系统来扩展 grains。'
- en: '**SDB modules** provide a simple database lookup. They are usually referenced
    from configuration areas (including grains and pillars) to keep sensitive data
    from appearing in plaintext.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDB 模块**提供了一种简单的数据库查找功能。它们通常从配置区域（包括 grains 和 pillars）引用，以防止敏感数据以明文形式出现。'
- en: '**Outputter modules** affect how command-line data output is shown to the user.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Outputter 模块**影响命令行数据输出显示给用户的方式。'
- en: '**External file server modules** allow the files that Salt serves to be stored
    somewhere besides locally on the Master.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部文件服务器模块**允许 Salt 服务的文件存储在 Master 本地之外的地方。'
- en: '**Cloud modules** are used to manage virtual machines across different compute
    cloud providers.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云模块**用于管理不同计算云提供商的虚拟机。'
- en: '**Beacons** allow various pieces of software, from other Salt components to
    third-party applications, to report data to Salt.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信标**允许来自其他 Salt 组件或第三方应用程序的各种软件向 Salt 报告数据。'
- en: '**External authentication modules** allow users to access the Master without
    having to have a local account on it.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部身份验证模块**允许用户无需在 Master 上拥有本地账户即可访问 Master。'
- en: '**Wheel modules** provide an API for managing Master-side configuration files.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wheel 模块**提供了一种管理 Master 端配置文件的 API。'
- en: '**Proxy minion modules** allow devices that cannot run the Salt platform itself
    to be able to be treated as if they were still full-fledged Minions.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代理 minion 模块**允许无法运行 Salt 平台的设备能够被当作完整的 minion 来处理。'
- en: '**Engines** allow Salt to provide internal information and services to long-running
    external processes. In fact, it may be best to think of engines as programs in
    their own right, with a special connection to Salt.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引擎**允许 Salt 向长时间运行的外部进程提供内部信息和服务的功能。实际上，最好将引擎视为它们自己的程序，并且与 Salt 有特殊的连接。'
- en: '**The Master Tops system** allows States to be targeted without having to use
    the `top.sls` file.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Master Tops 系统**允许在不使用 `top.sls` 文件的情况下针对 States。'
- en: '**Roster modules** allow Salt SSH to target Minions without having to use the
    `/etc/salt/roster` file.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Roster 模块**允许 Salt SSH 在不使用 `/etc/salt/roster` 文件的情况下针对 minion。'
- en: '**Queue modules** provide a means of organizing function calls.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Queue 模块**提供了一种组织函数调用的方式。'
- en: The **pkgdb** and **pkgfile modules** allow the Salt Package Manager to store
    its local database and install Salt formulas into a location outside of the local
    hard drive.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pkgdb** 和 **pkgfile 模块**允许 Salt 软件包管理器存储其本地数据库并将 Salt 公式安装到本地硬盘以外的位置。'
- en: These modules were generally created as necessity dictated. All of them are
    written in Python. And while some can be pretty extensive, most are pretty simple
    to create. In fact, a number of modules that now ship with Salt were actually
    provided by users who had no previous Python experience.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块通常是按照必要性创建的。它们全部是用Python编写的。虽然其中一些可能相当复杂，但大多数创建起来都很简单。事实上，现在与Salt一起提供的许多模块实际上是由没有Python经验的用户提供的。
- en: Loading modules with Python
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python加载模块
- en: Python is well suited to building a loader system. Despite being classified
    as a very high-level language (and not a mid-level language like C), Python has
    a lot of control over how it manages its own internals. The existence of robust
    module introspection built into Python was very useful for Salt, as it made the
    arbitrary loading of virtual modules at runtime a very smooth operation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Python非常适合构建加载系统。尽管它被归类为一种非常高级的语言（而不是像C那样的中级语言），Python对其内部管理的控制能力很强。Python内置的强大模块内省功能对Salt非常有用，因为它使得在运行时任意加载虚拟模块变得非常顺畅。
- en: Each Salt module can support a function called `__virtual__()`. This is the
    function that detects whether or not a module will be made available to Salt on
    that system.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Salt模块都可以支持一个名为`__virtual__()`的函数。这是检测该模块是否将在该系统上提供给Salt的函数。
- en: When the `salt-minion` service loads, it will go through each module, looking
    for a `__virtual__()` function. If none is found, then the module is assumed to
    have all of its requirements already met, and it can be made available. If that
    function is found, then it will be used to detect whether the requirements for
    that module are met.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当`salt-minion`服务加载时，它将遍历每个模块，寻找`__virtual__()`函数。如果没有找到，则假定该模块的所有要求已经满足，并且它可以被提供。如果找到该函数，则将使用它来检测该模块的要求是否满足。
- en: If a module type uses the lazy loader, then modules that can be loaded will
    be set aside to be loaded when needed. Modules that do not meet the requirements
    will be discarded.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模块类型使用懒加载器，那么可以加载的模块将被放置一旁，在需要时加载。不符合要求的模块将被丢弃。
- en: Detecting grains
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测颗粒
- en: On a Minion, the most important things to load are probably the grains. Although
    grain modules are important (and are discussed in [Chapter 3](part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135
    "Chapter 3. Extending Salt Configuration"), *Extending Salt Configuration*), there
    are in fact a number of core grains that are loaded by Salt itself.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Minion上，最重要的可能是加载颗粒。尽管颗粒模块很重要（并在[第3章](part0023_split_000.html#LTSU2-d9976ffc65994572ad672a3ef48f1135
    "第3章。扩展Salt配置")中讨论，*扩展Salt配置*)，但实际上有许多核心颗粒是由Salt本身加载的。
- en: A number of these grains describe the hardware on the system. Others describe
    the operating system that Salt is running on. Grains such as `os` and `os _family`
    are set, and used later to determine which of the core modules will be loaded.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些颗粒描述了系统上的硬件。其他描述了Salt运行的操作系统。例如，`os`和`os_family`颗粒被设置，并在以后用于确定哪些核心模块将被加载。
- en: For example, if the `os_family` grain is set to `redhat`, then the execution
    module located at `salt/modules/yumpkg.py` will be loaded as the `pkg` module.
    If the `os_family` grain is set to `debian`, then `salt/modules/aptpkg.py` will
    be loaded as the `pkg` module.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`os_family`颗粒被设置为`redhat`，则位于`salt/modules/yumpkg.py`的执行模块将作为`pkg`模块被加载。如果`os_family`颗粒被设置为`debian`，则`salt/modules/aptpkg.py`将作为`pkg`模块被加载。
- en: Using other detection methods
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用其他检测方法
- en: Grains aren't the only mechanism used for determining whether a module should
    be loaded. Salt also ships with a number of utilities that can be used. The `salt.utils`
    library contains a number of functions that are often faster than grains, or have
    more functionality than a simple `name=value` (also known as a key-value pair)
    configuration can provide.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 颗粒并不是用于确定是否加载模块的唯一机制。Salt还提供了一些可以使用的实用工具。`salt.utils`库包含了一些函数，它们通常比颗粒更快，或者比简单的`name=value`（也称为键值对）配置提供更多的功能。
- en: One example is the `salt.utils.is_windows()` function that, as the name implies,
    reports whether Salt is being run inside of Windows. If Windows is detected, then
    `salt/modules/win_file.py` will be loaded as the `file` module. Otherwise, `salt/modules/file.py`
    will be loaded as the `file` module.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是`salt.utils.is_windows()`函数，正如其名称所暗示的，报告Salt是否在Windows内部运行。如果检测到Windows，则`salt/modules/win_file.py`将作为`file`模块被加载。否则，`salt/modules/file.py`将作为`file`模块被加载。
- en: Another very common example is the `salt.utils.which()` function, which reports
    whether a necessary shell command is available. For instance, this is used by
    `salt/modules/nginx.py` to detect whether the `nginx` command is available to
    Salt. If so, then the `nginx` module will be made available.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常常见的例子是`salt.utils.which()`函数，该函数报告是否有一个必要的shell命令可用。例如，这被`salt/modules/nginx.py`用于检测`nginx`命令是否对Salt可用。如果是的话，那么`nginx`模块将被提供。
- en: There are a number of other examples that we could get into, but there is not
    nearly enough room in this book for all of them. As it is, the most common ones
    are best demonstrated by example. Starting with [Chapter 2](part0019_split_000.html#I3QM2-d9976ffc65994572ad672a3ef48f1135
    "Chapter 2. Writing Execution Modules"), *Writing Execution Modules*, we will
    begin writing Salt modules that make use of the examples that we've already gone
    over, plus a wealth of others.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以探讨其他许多例子，但在这本书中，几乎无法为所有这些例子提供足够的空间。实际上，最常见的一些例子最好通过示例来展示。从[第二章](part0019_split_000.html#I3QM2-d9976ffc65994572ad672a3ef48f1135
    "第二章。编写执行模块")《编写执行模块》开始，我们将开始编写使用我们已讨论过的示例以及其他大量示例的Salt模块。
- en: Summary
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Salt is made possible by the existence of the loader system, which detects which
    modules are able to load, and then only what is available. Types of module that
    make use of the lazy loader will only be loaded on demand.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 盐的生成依赖于加载器系统的存在，该系统能够检测哪些模块能够被加载，然后只加载可用的部分。仅当需要时，才会加载使用懒加载的模块类型。
- en: Python is an integral part of Salt, allowing modules to be easily written and
    maintained. Salt ships with a library of functions that help support the loader
    system, and the modules that are loaded with it. These files live in various directories
    under the `salt/` directory in Salt's code base. For example, execution modules
    live in `salt/modules/`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Python是Salt的一个组成部分，使得模块的编写和维护变得容易。Salt附带了一个函数库，它帮助支持加载器系统以及与之一起加载的模块。这些文件位于Salt代码库下的`salt/`目录下的各个目录中。例如，执行模块位于`salt/modules/`。
- en: This chapter barely brushed the surface of what is possible with Salt, but it
    got some necessary concepts out of the way. From here on in, the focus will be
    all about writing and maintaining modules in Python.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅仅触及了Salt所能实现的可能性，但已经介绍了一些必要概念。从现在开始，重点将全部放在使用Python编写和维持模块上。
