- en: File I/O and Python Utilities
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件 I/O 和 Python 工具
- en: In this chapter, we are going to discuss file I/O, that is reading, writing
    and appending to file in detail. We are also going to discuss Python utilities
    that enable manipulating files and interacting with the operating system. Each
    topic has a different level of complexity that we will discuss using an example.
    Let's get started!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讨论文件 I/O，即读取、写入和追加到文件。我们还将讨论 Python 工具，这些工具可以用来操作文件并与操作系统交互。每个主题都有不同的复杂度，我们将通过示例来讨论。让我们开始吧！
- en: File I/O
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件 I/O
- en: 'We are discussing file I/O for two reasons:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论文件 I/O 的原因有两个：
- en: 'In the world of Linux operating systems, everything is a file. Interaction
    with peripherals on the Raspberry Pi is similar to reading from/writing to a file.
    For example: In [Chapter 4](56d43053-0d4d-47a4-bf28-c36fc00a7da2.xhtml), *Communication
    Interfaces*, we discussed serial port communication. You should be able to observe
    that serial port communication is like a file read/write operation.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 操作系统世界中，一切都是文件。与树莓派上的外围设备交互类似于从文件中读取/写入。例如：在 [第 4 章](56d43053-0d4d-47a4-bf28-c36fc00a7da2.xhtml)
    *通信接口* 中，我们讨论了串口通信。你应该能够观察到串口通信就像文件读写操作一样。
- en: 'We use file I/O in some form in every project. For example: Writing sensor
    data to a CSV file or reading pre-configured options for a web server, and so
    on.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在每一个项目中都会以某种形式使用文件 I/O。例如：将传感器数据写入 CSV 文件或读取为网络服务器预配置的选项，等等。
- en: 'Hence, we thought it would be useful to discuss file I/O in Python as its own
    chapter (detailed documentation available from here: [https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files))
    and discuss examples where it could play a role while developing applications
    on the Raspberry Pi Zero.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们认为讨论 Python 中的文件 I/O 作为单独的一章是有用的（详细文档可从这里获取：[https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files](https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files)）并讨论在树莓派零上开发应用程序时它可能发挥作用的示例。
- en: Reading from a file
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从文件中读取
- en: 'Let''s create a simple text file, `read_file.txt` with the following text:
    `I am learning Python Programming using the Raspberry Pi Zero` and save it to
    the code samples directory (or any location of your choice).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的文本文件，`read_file.txt`，内容如下：`我正在使用树莓派零学习 Python 编程`，并将其保存到代码示例目录（或您选择的任何位置）。
- en: 'To read from a file, we need to make use of the Python''s in-built function:
    `open` to open the file. Let''s take a quick look at a code snippet that demonstrates
    opening a text file to read its content and print it to the screen:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要从文件中读取内容，我们需要使用 Python 内置的函数：`open` 来打开文件。让我们快速查看一个代码片段，它演示了如何打开一个文本文件来读取其内容并将其打印到屏幕上：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s discuss this code snippet in detail:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这个代码片段：
- en: The first step in reading the contents of the text file is opening the file
    using the in-built function `open`. The file in question needs to be passed as
    an argument along with a flag `r` that indicates we are opening the file to read
    the contents (We will discuss other flag options as we discuss each reading/writing
    files.)
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文本文件内容的第一步是使用内置函数 `open` 打开文件。需要将文件作为参数传递，并附带一个标志 `r`，表示我们正在打开文件以读取内容（我们将在讨论每个读取/写入文件时讨论其他标志选项。）
- en: Upon opening the file, the `open` function returns a pointer (address to the
    file object) that is stored in the `file` variable.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开文件时，`open` 函数返回一个指针（文件对象的地址），该指针存储在 `file` 变量中。
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This file pointer is used to read the contents of the file and print it to
    the screen:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个文件指针用于读取文件内容并将其打印到屏幕：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After reading the contents of the file, the file is closed by calling the `close()` function.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在读取文件内容后，通过调用 `close()` 函数关闭文件。
- en: 'Run the preceding code snippet (available for download along with this chapter—`read_from_file.py`)
    using IDLE3 or the command-line terminal. The contents of the text file would
    be printed to the screen as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 IDLE3 或命令行终端运行前面的代码片段（与本章一起提供下载——`read_from_file.py`），文本文件的内容将按如下方式打印到屏幕上：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Reading lines
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取行
- en: 'Sometimes, it is necessary to read the contents of a file by line-by-file.
    In Python, there are two options to do this: `readline()` and `readlines()`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，有必要逐行读取文件内容。在 Python 中，有两种方法可以实现这一点：`readline()` 和 `readlines()`：
- en: '`readline()`: As the name suggests, this in-built function enables reading
    one line at a time. Let''s review this using an example:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readline()`: 如其名所示，这个内置函数允许一次读取一行。让我们用一个例子来回顾一下：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When the preceding code snippet is executed (available for download as `read_line_from_file.py` along
    with this chapter), the `read_line.txt` file is opened and a single line is returned
    by the `readline()` function. This line is stored in the variable data. Since
    the function is called twice in this program, the output is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段（作为 `read_line_from_file.py` 的一部分，与本章一起提供）时，`readline()` 函数打开 `read_line.txt`
    文件，并返回一个单独的行。这行被存储在变量 data 中。由于在这个程序中该函数被调用了两次，所以输出如下：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: A new line is returned every time the `readline` function is called and it returns
    an empty string when the end-of-file has reached.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `readline` 函数时，都会返回一个新行，当达到文件末尾时，它返回一个空字符串。
- en: '`readlines()`: This function reads the entire content of a file in lines and
    stores each it to a list:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readlines()`: 这个函数读取文件的全部内容，按行存储，并将每一行存储到一个列表中：'
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since the lines of the files is stored as a list, it could be retrieved by
    iterating through the list:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件行被存储为列表，可以通过遍历列表来检索：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code snippet is available for download along with this chapter
    as `read_lines_from_file.py`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段作为 `read_lines_from_file.py` 可以下载，与本章一起提供。
- en: Writing to a file
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 写入文件
- en: 'Perform the following steps in order to write to a file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤顺序写入文件：
- en: 'The first step in writing to a file is opening a file with the write flag:
    `w`. If the file name that was passed as an argument doesn''t exist, a new file
    is created:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向文件写入的第一步是使用写标志打开文件：`w`。如果传递给参数的文件名不存在，则会创建一个新文件：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the file is open, the next step is passing the string to be written as
    argument to the `write()` function:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件打开后，下一步是将要写入的字符串作为参数传递给 `write()` 函数：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s put the code together where we write a string to a text file, close
    it, re-open the file and print the contents of the file to the screen:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将代码组合起来，我们将字符串写入一个文本文件，关闭它，重新打开文件，并将文件内容打印到屏幕上：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code snippet is available for download along with this chapter
    (`write_to_file.py`).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码片段作为 `write_to_file.py` 的一部分，与本章一起提供。
- en: 'When the preceding code snippet is executed, the output is shown as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，输出如下所示：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Appending to a file
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向文件追加
- en: 'Whenever a file is opened using the write flag `w`, the contents of the file
    are deleted and opened afresh to write data. There is an alternative flag `a`
    that enables appending data to the end of the file. This flag also creates a new
    file if the file (that is passed as an argument to open) doesn''t exist. Let''s
    consider the code snippet below where we append a line to the text file `write_file.txt`
    from the previous section:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 每次使用写标志 `w` 打开文件时，文件的内容都会被删除，并重新打开以写入数据。有一个替代标志 `a`，它允许将数据追加到文件末尾。如果传递给 `open`
    函数的文件不存在，此标志也会创建一个新文件。让我们考虑下面的代码片段，其中我们将一行追加到前一个部分中的文本文件 `write_file.txt`：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the preceding code snippet is executed (available for download along with
    this chapter—`append_to_file.py`), the string `This is a line appended to the
    file` is appended to the end of the text of the file. The contents of the file
    will include the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段（作为 `append_to_file.py` 的一部分，与本章一起提供）时，字符串 `This is a line appended
    to the file` 被追加到文件的文本末尾。文件的内容将包括以下内容：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: seek
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: seek
- en: 'Once a file is opened, the file pointer that is used in file I/O moves from
    the beginning to the end of the file. It is possible to move the pointer to a
    specific position and read the data from that position. This is especially useful
    when we are interested in a specific line of a file. Let''s consider the text
    file `write_file.txt` from the previous example. The contents of the file include:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件被打开，用于文件输入/输出的文件指针将从文件开始移动到文件末尾。可以将指针移动到特定位置并从该位置读取数据。这在我们需要关注文件中的特定行时特别有用。让我们考虑前一个例子中的文本文件
    `write_file.txt`。文件的内容包括：
- en: '[PRE14]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s try to skip the first line and read only the second line using `seek`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用 `seek` 跳过第一行，只读取第二行：
- en: '[PRE15]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example (available for download along with this chapter as
    `seek_in_file.py`), the `seek` function is used to move the pointer to byte `53`
    that is the end of first line. Then the file''s contents are read and stored into
    the variable. When this code snippet is executed, the output is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例（与本章一起提供下载，文件名为`seek_in_file.py`）中，`seek`函数用于将指针移动到字节`53`，这是第一行的末尾。然后读取文件的内容并将其存储到变量中。当这个代码片段执行时，输出如下：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Thus, seek enables moving the file pointer to a specific position.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`seek`允许将文件指针移动到特定位置。
- en: Read n bytes
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取n个字节
- en: The `seek` function enables moving the pointer to a specific position and reading
    a byte or `n` bytes from that position. Let's re-visit reading `write_file.txt`
    and try to read the word `excited` in the sentence `I am excited to learn Python
    using Raspberry Pi Zero`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`seek`函数允许将指针移动到特定位置，并从该位置读取一个字节或`n`个字节。让我们重新阅读`write_file.txt`，并尝试从句子`I am
    excited to learn Python using Raspberry Pi Zero`中读取单词`excited`。'
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding code can be explained in the following steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码可以按以下步骤解释：
- en: In the first step, the file is opened using the `read` flag and the file pointer
    is set to the fifth byte (using `seek`)—the position of the letter `e` in the
    contents of the text file.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一步中，使用`read`标志打开文件，并将文件指针设置到第五字节（使用`seek`）——即文本文件内容中字母`e`的位置。
- en: 'Now, we read one byte from the file by passing it as an argument to the `read`
    function. When an integer is passed as an argument, the `read` function returns
    the corresponding number of bytes from the file. When no argument is passed, it
    reads the entire file. The `read` function returns an empty string if the file
    is empty:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们通过将文件作为`read`函数的参数传递来从文件中读取一个字节。当传递整数作为参数时，`read`函数返回文件中的相应字节数。当不传递参数时，它读取整个文件。如果文件为空，`read`函数返回空字符串：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the second part, we try to read the word `excited` from the text file. We
    rewind the position of the pointer back to the fifth byte. Then we read seven
    bytes from the file (length of the word `excited`).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二部分，我们尝试从文本文件中读取单词`excited`。我们将指针的位置回滚到第五字节。然后从文件中读取七个字节（单词`excited`的长度）。
- en: 'When the code snippet is executed (available for download along with this chapter
    as `seek_to_read.py`), the program should print the letter `e` and the word `excited`:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码片段执行时（与本章一起提供下载，文件名为`seek_to_read.py`），程序应打印字母`e`和单词`excited`：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: r+
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: r+
- en: We discussed reading and writing to files using the `r` and `w` flags. There
    is another called `r+`. This flag enables reading and writing to a file. Let's
    review an example that enables us to understand this flag.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了使用`r`和`w`标志对文件进行读写操作。还有一个叫做`r+`的标志。这个标志允许对文件进行读写操作。让我们回顾一个示例，以便我们能够理解这个标志。
- en: 'Let''s review the contents of `write_file.txt` once again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次回顾`write_file.txt`的内容：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let''s modify the second line to read: `This is a line that was modified`.
    The code sample is available for download along with this chapter as `seek_to_write.py`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改第二行，使其读取为：`This is a line that was modified`。代码示例与本章一起提供下载，文件名为`seek_to_write.py`。
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s review how this example works:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾这个示例是如何工作的：
- en: The first step in this example is opening the file using the `r+` flag. This
    enables reading and writing to the file.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本例中，第一步是使用`r+`标志打开文件。这允许对文件进行读写操作。
- en: The next step is moving to the 68th byte of the file
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将文件移动到第68字节。
- en: The `that was modified` string is written to the file at this position. The
    spaces at the end of the string are used to overwrite the original content of
    the second sentence.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`that was modified`字符串写入文件的这个位置。字符串末尾的空格用于覆盖第二句话的原始内容。
- en: Now, the file pointer is set to the beginning of the file and its contents are
    read.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，文件指针被设置到文件的开始，并读取其内容。
- en: 'When the preceding code snippet is executed, the modified file contents are
    printed to the screen as follows:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，修改后的文件内容将按以下方式打印到屏幕上：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is another `a+` flag that enables appending data to the end of the file
    and reading at the same time. We will leave this to the reader to figure out using
    the examples discussed so far.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个`a+`标志，它允许同时向文件末尾追加数据并读取。我们将把这个留给读者，让他们使用前面讨论的示例来找出答案。
- en: We have discussed different examples on reading and writing to files in Python.
    It can be overwhelming without sufficient experience in programming. We strongly
    recommend working through the different code samples provided in this chapter
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了在 Python 中读取和写入文件的不同示例。如果没有足够的编程经验，可能会感到不知所措。我们强烈建议通过本章提供的不同代码示例进行练习。
- en: Challenge to the reader
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读者挑战
- en: Use the `a+` flag to open the `write_file.txt` file (discussed in different
    examples) and append a line to the file. Set the file pointer using `seek` and
    print its contents. You may open the file only once in the program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `a+` 标志打开 `write_file.txt` 文件（在不同示例中讨论过），并向文件追加一行。使用 `seek` 设置文件指针并打印其内容。你可以在程序中只打开文件一次。
- en: The with keyword
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`with` 关键字'
- en: So far, we discussed different flags that could be used to open files in different
    modes. The examples we discussed followed a common pattern—open the file, perform
    read/write operations and close the file. There is an elegant way of interacting
    with files using the `with` keyword.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了可以用于以不同模式打开文件的不同的标志。我们讨论的示例遵循了一个常见的模式——打开文件，执行读写操作，然后关闭文件。使用 `with`
    关键字与文件交互有一种优雅的方式。
- en: 'If there are any errors during the execution of the code block that interacts
    with a file, the `with` keyword ensures that the file is closed and the associated
    resources are cleaned up on exiting the code block. As always, let''s review the
    `with` keyword with an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行与文件交互的代码块期间出现任何错误，`with` 关键字将确保在退出代码块时关闭文件并清理相关资源。一如既往，让我们通过一个示例来回顾 `with`
    关键字：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the preceding example (`with_keyword_example`), we skipped closing the file
    as the `with` keyword takes care of closing the file once the execution of the
    indented code block is complete. The `with` keyword also takes care of closing
    the file while leaving the code block due to an error. This ensures that the resources
    are cleaned up properly in any scenario. Going forward, we will be using the `with`
    keyword for file I/O.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例（`with_keyword_example`）中，我们跳过了关闭文件，因为 `with` 关键字会在缩进代码块执行完成后关闭文件。`with`
    关键字还会在代码块因错误而离开时关闭文件。这确保了在任何情况下都能正确清理资源。从现在开始，我们将使用 `with` 关键字进行文件 I/O。
- en: configparser
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: configparser
- en: Let's discuss some aspects of Python programming that is especially helpful
    while developing applications using the Raspberry Pi. One such tool is the `configparser`
    available in Python. The `configparser` module ([https://docs.python.org/3.4/library/configparser.html](https://docs.python.org/3.4/library/configparser.html))
    is used to read/write config files for applications.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些在开发树莓派应用程序时特别有帮助的 Python 编程方面。其中一个工具是 Python 中的 `configparser`。`configparser`
    模块（[https://docs.python.org/3.4/library/configparser.html](https://docs.python.org/3.4/library/configparser.html)）用于读取/写入应用程序的配置文件。
- en: In software development, config files are generally used to store constants
    such as access credentials, device ID, and so on In the context of a Raspberry
    Pi, `configparser` could be used to store the list of all GPIO pins in use, addresses
    of sensors interfaced via the I²C interface, and so on. Let's discuss three examples
    where we learn making use of the `configparser` module. In the first example we
    will create a `config` file using the `configparser`. In the second example, we
    will make use of the `configparser` to read the config values and in the third
    example, we will discuss modifying config files in the final example.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件开发中，配置文件通常用于存储常量，例如访问凭证、设备 ID 等。在树莓派的环境中，可以使用 `configparser` 来存储所有使用的 GPIO
    引脚列表、通过 I²C 接口连接的传感器的地址等。让我们讨论三个示例，了解如何利用 `configparser` 模块。在第一个示例中，我们将使用 `configparser`
    创建一个 `config` 文件。在第二个示例中，我们将使用 `configparser` 读取配置值；在第三个示例中，我们将讨论修改配置文件。
- en: '**Example 1**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 1**：'
- en: 'In the first example, let''s create a config file that stores information including
    device ID, GPIO pins in use, sensor interface address, debug switch, and access
    credentials:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，让我们创建一个配置文件，该文件存储有关设备 ID、使用的 GPIO 引脚、传感器接口地址、调试开关和访问凭证的信息：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s discuss the preceding code example (available for download along with
    this chapter as `config_parser_write.py`) in detail:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论前面的代码示例（与本章一起提供下载，作为 `config_parser_write.py`）：
- en: 'The first step is importing the `configparser` module and creating an instance
    of the `ConfigParser` class. This instance is going to be called `config_parser`:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是导入 `configparser` 模块并创建 `ConfigParser` 类的一个实例。这个实例将被命名为 `config_parser`：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, we open a config file called `raspi.cfg` using the `with` keyword. Since
    the file doesn't exist, a new config file is created.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们使用 `with` 关键字打开一个名为 `raspi.cfg` 的配置文件。由于文件不存在，将创建一个新的配置文件。
- en: The config file is going to consist of two sections namely `AppInfo` and `Credentials`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置文件将包含两个节，即 `AppInfo` 和 `Credentials`。
- en: 'The two sections could be created using the `add_section` method as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用 `add_section` 方法创建两个节，如下所示：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Each section is going to consist of different set of constants. Each constant
    could be added to the relevant section using the `set` method. The required arguments
    to the `set` method include the section name (under which the parameter/constant
    is going to be located), the name of the parameter/constant and its corresponding
    value. For example: The `id` parameter can be added to the `AppInfo` section and
    assigned a value of `123` as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个节将包含一组不同的常量。每个常量都可以使用 `set` 方法添加到相关节中。传递给 `set` 方法的参数包括节名（参数/常量将要位于的节），参数/常量的名称及其对应值。例如：可以将
    `id` 参数添加到 `AppInfo` 节，并赋予其值为 `123`，如下所示：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The final step is saving these config values to the file. This is accomplished
    using the `config_parser` method, `write`. The file is closed once the program
    exits the indented block under the `with` keyword:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是将这些配置值保存到文件中。这是通过使用 `config_parser` 方法的 `write` 实现的。一旦程序退出 `with` 关键字下的缩进块，文件就会被关闭：
- en: '[PRE28]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We strongly recommend trying the code snippets yourself and use these snippets
    as a reference. You will learn a lot by making mistakes and possibly arrive with
    a better solution than the one discussed here.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强烈建议您亲自尝试代码片段，并将这些片段作为参考。通过犯错，您可能会得到比这里讨论的更好的解决方案。
- en: 'When the preceding code snippet is executed, a config file called `raspi.cfg`
    is created. The contents of the config file would include the contents shown as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，会创建一个名为 `raspi.cfg` 的配置文件。配置文件的内容将包括以下所示的内容：
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Example 2**:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 2**：'
- en: 'Let''s discuss an example where we read config parameters from a config file
    created in the previous example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个示例，其中我们从前面示例中创建的配置文件中读取配置参数：
- en: '[PRE30]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: If the config files are created in the format shown, the `ConfigParser` class
    should be able to parse it. It is not really necessary to create config files
    using a Python program. We just wanted to show programmatic creation of config
    files as it is easier to programmatically create config files for multiple devices
    at the same time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果配置文件以所示格式创建，`ConfigParser` 类应该能够解析它。实际上并不一定需要使用 Python 程序创建配置文件。我们只是想展示程序化创建配置文件，因为同时为多个设备程序化创建配置文件更容易。
- en: 'The preceding example is available for download along with this chapter (`config_parser_read.py`).
    Let''s discuss how this code sample works:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例可以与本章一起下载（`config_parser_read.py`）。让我们讨论这个代码示例是如何工作的：
- en: The first step is initializing an instance of the `ConfigParser` class called
    `config_parser`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是初始化一个名为 `config_parser` 的 `ConfigParser` 类的实例。
- en: The second step is loading and reading the config file using the instance method
    `read`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二步是使用实例方法 `read` 加载和读取配置文件。
- en: 'Since we know the structure of the config file, let''s go ahead and read some
    constants available under the section `AppInfo`. The config file parameters can
    be read using the `get` method. The required arguments include the section under
    which the config parameter is located and the name of the parameter. For example:
    The config `id` parameter is located under the `AppInfo` section. Hence, the required
    arguments to the method include `AppInfo` and `id`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们知道配置文件的结构，让我们继续读取 `AppInfo` 部分下可用的某些常量。可以使用 `get` 方法读取配置文件参数。所需的参数包括配置参数所在的节以及参数的名称。例如：配置
    `id` 参数位于 `AppInfo` 节下。因此，传递给方法所需的参数包括 `AppInfo` 和 `id`：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that the config parameters are read into variables, let''s make use of
    it in our program. For example: Let''s test if the `debug_switch` variable (a
    switch to determine if the program is in debug mode) and print the other config
    parameters that were retrieved from the file:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在配置参数已经读入变量中，让我们在我们的程序中使用它。例如：让我们测试 `debug_switch` 变量（一个用于确定程序是否处于调试模式的开关）并打印从文件中检索到的其他配置参数：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Example 3**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**示例 3**：'
- en: Let's discuss an example where we would like to modify an existing config file.
    This is especially useful in situations where we need to update the firmware version
    number in the config file after performing a firmware update.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个例子，其中我们想要修改现有的配置文件。这在需要在对固件进行更新后更新配置文件中的固件版本号的情况下特别有用。
- en: 'The following code snippet is available for download as `config_parser_modify.py` along
    with this chapter:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段可以作为`config_parser_modify.py`下载，与本章一起：
- en: '[PRE33]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s discuss how this works:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论它是如何工作的：
- en: 'As always, the first step is initializing an instance of the `ConfigParser`
    class. The config file is loaded using the method `read`:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如往常一样，第一步是初始化`ConfigParser`类的实例。使用`read`方法加载配置文件：
- en: '[PRE34]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The required parameter is updated using the `set` method (discussed in a previous
    example):'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`set`方法（在先前的示例中讨论过）更新所需的参数：
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The updated config is saved to the config file using the `write` method:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`write`方法将更新的配置保存到配置文件中：
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Challenge to the reader
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向读者挑战
- en: Using example 3 as a reference, update the config parameter `debug_switch` to
    the value `False`. Repeat example 2 and see what happens.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以示例3为参考，将配置参数`debug_switch`更新为值`False`。重复示例2并查看发生了什么。
- en: Reading/writing to CSV files
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取/写入CSV文件
- en: In this section, we are going to discuss reading/writing to CSV files. This
    module ([https://docs.python.org/3.4/library/csv.html](https://docs.python.org/3.4/library/csv.html))
    is useful in data logging applications. Since we will be discussing data logging
    in the next chapter, let's review reading/writing to CSV files.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论读取/写入CSV文件。此模块（[https://docs.python.org/3.4/library/csv.html](https://docs.python.org/3.4/library/csv.html)）在数据记录应用中很有用。由于我们将在下一章讨论数据记录，让我们回顾一下读取/写入CSV文件。
- en: Writing to CSV files
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向CSV文件中写入
- en: 'Let''s consider a scenario where we are reading data from different sensors.
    This data needs to be recorded to a CSV file where each column corresponds to
    a reading from a specific sensor. We are going to discuss an example where we
    record the value `123`, `456`, and `789` in the first row of the CSV file and
    the second row is going to consist of values including `Red`, `Green`, and `Blue`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，其中我们从不同的传感器读取数据。这些数据需要记录到一个CSV文件中，其中每一列对应于特定传感器的读取值。我们将讨论一个例子，其中我们在CSV文件的第一行记录值`123`、`456`和`789`，而第二行将包括值`Red`、`Green`和`Blue`：
- en: 'The first step in writing to a CSV file is opening a CSV file using the `with`
    keyword:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向CSV文件写入的第一步是使用`with`关键字打开CSV文件：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is initializing an instance of the `writer` class of the CSV module:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是初始化CSV模块的`writer`类的实例：
- en: '[PRE38]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, each row is added to the file by creating a list that contains all the
    elements that need to be added to a row. For example: The first row can be added
    to the list as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每一行都是通过创建一个包含需要添加到行中的所有元素的列表来添加到文件中的。例如：第一行可以按如下方式添加到列表中：
- en: '[PRE39]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Putting it altogether, we have:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，我们得到：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When the above code snippet is executed (available for download as `csv_write.py`
    along with this chapter), a CSV file is created in the local directory with the
    following contents:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行上述代码片段（作为`csv_write.py`与本章一起下载）时，在本地目录中创建了一个包含以下内容的CSV文件：
- en: '[PRE41]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Reading from CSV files
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从CSV文件中读取
- en: 'Let''s discuss an example where we read the contents of the CSV file created
    in the previous section:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个例子，其中我们将读取上一节创建的CSV文件的正文：
- en: 'The first step in reading a CSV file is opening it in read mode:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取CSV文件的第一步是以读取模式打开它：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we initialize an instance of the `reader` class from the CSV module.
    The contents of the CSV file are loaded into the object `csv_reader`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们初始化CSV模块的`reader`类的实例。CSV文件的正文被加载到对象`csv_reader`中：
- en: '[PRE43]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now that the contents of the CSV file are loaded, each row of the CSV file
    could be retrieved as follows:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在CSV文件的正文已加载，可以按如下方式检索CSV文件的每一行：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Put it all together:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When the preceding code snippet is executed (available for download along with
    this chapter as `csv_read.py`), the contents of the file are printed row-by-row
    where each row is a list that contains the comma separated values:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段（与本章一起作为`csv_read.py`下载）时，文件的内容按行打印，其中每一行都是一个包含逗号分隔值的列表：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Python utilities
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python实用工具
- en: Python comes with several utilities that enables interacting with other files
    and the operating system itself. We have identified all those Python utilities
    that we have used in our past projects. Let's discuss the different modules and
    their uses as we might use them in the final project of this book.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Python 随带了一些工具，可以用来与其他文件和操作系统本身交互。我们已经确定了我们在过去的项目中使用过的所有 Python 工具。让我们讨论不同的模块及其用途，因为我们可能会在本书的最终项目中使用它们。
- en: The os module
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`os` 模块'
- en: As the name suggests, this module ([https://docs.python.org/3.1/library/os.html](https://docs.python.org/3.1/library/os.html))
    enables interacting with the operating system. Let's discuss some of its applications
    with examples.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，此模块（[https://docs.python.org/3.1/library/os.html](https://docs.python.org/3.1/library/os.html)）允许与操作系统交互。让我们通过示例讨论其一些应用。
- en: Checking a file's existence
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件的存在
- en: 'The `os` module could be used to check if a file exists in a specific directory.
    For example: We extensively made use of the `write_file.txt` file. Before opening
    this file to read or write, we could check the file''s existence:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `os` 模块检查特定目录中是否存在文件。例如：我们广泛使用了 `write_file.txt` 文件。在打开此文件进行读取或写入之前，我们可以检查文件的存在：
- en: '[PRE47]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code snippet, we make use of the `isfile()` function, available
    with the `os.path` module. When a file''s location is passed an argument to the
    function, it returns `True` if the file exists at that location. In this example,
    since the file `write_file.txt` exists in the code examples directory, the function
    returns `True`. Hence the message, `The file exists` is printed to the screen:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了 `os.path` 模块中可用的 `isfile()` 函数。当文件位置作为参数传递给函数时，如果文件位于该位置，则函数返回
    `True`。在这个例子中，由于 `write_file.txt` 文件位于代码示例目录中，函数返回 `True`。因此，屏幕上打印出“文件存在”的消息：
- en: '[PRE48]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Checking for a folder's existence
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查文件夹的存在
- en: 'Similar to `os.path.isfile()`, there is another function called `os.path.isdir()`.
    It returns `True` if a folder exists at a specific location. We have been reviewing
    all code samples from a folder called `code_samples` located on the Raspberry
    Pi''s desktop. It''s existence could be confirmed as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `os.path.isfile()` 类似，还有一个名为 `os.path.isdir()` 的函数。如果特定位置存在文件夹，它将返回 `True`。我们一直在审查位于树莓派桌面上名为
    `code_samples` 的文件夹中的所有代码示例。其存在可以通过以下方式确认：
- en: '[PRE49]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Deleting files
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除文件
- en: 'The `os` module also enables deleting files using the `remove()` function.
    Any file that is passed as an argument to the function is deleted. In the *File
    I/O* section, we discussed reading from files using the text file, `read_file.txt`.
    Let''s delete the file by passing it as an argument to the `remove()` function:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`os` 模块还通过 `remove()` 函数允许删除文件。任何作为函数参数传递的文件都将被删除。在 *文件输入/输出* 部分中，我们讨论了使用文本文件
    `read_file.txt` 从文件中读取。让我们通过将文件作为参数传递给 `remove()` 函数来删除该文件：'
- en: '[PRE50]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Killing a process
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杀死进程
- en: 'It is possible to kill an application running on the Raspberry Pi by passing
    process `pid` to the `kill()` function. In the previous chapter, we discussed
    the `light_scheduler` example that runs as a background process on the Raspberry
    Pi. To demonstrate killing a process, we are going to attempt killing that process.
    We need to determine the process `pid` of the `light_scheduler` process (you may
    pick an application that was started by you as a user and not do not touch root
    processes). The process `pid` could be retrieved from the command-line terminal
    using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将进程 `pid` 传递给 `kill()` 函数来杀死在树莓派上运行的应用程序。在上一章中，我们讨论了作为树莓派后台进程运行的 `light_scheduler`
    示例。为了演示杀死进程，我们将尝试杀死该进程。我们需要确定 `light_scheduler` 进程的进程 `pid`（你可以选择你作为用户启动的应用程序，不要触碰
    root 进程）。进程 `pid` 可以通过以下命令从命令行终端检索：
- en: '[PRE51]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'It spits out the processes currently running on the Raspberry Pi (shown in
    the following figure). The process `pid` for the `light_scheduler` application
    is 1815:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它会输出当前在树莓派上运行的进程（如下图所示）。`light_scheduler` 应用程序的进程 `pid` 为 1815：
- en: '![](img/image_06_001.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_06_001.png)'
- en: light_scheduler daemon's PID
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: light_scheduler 守护进程的 PID
- en: 'Assuming we know the process `pid` of the application that needs to be killed,
    let''s review killing the function using `kill()`. The arguments required to kill
    the function include the process `pid` and signal (`signal.SIGKILL`) that needs
    to be sent to the process to kill the application:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们知道需要被杀死的应用程序的进程 `pid`，让我们回顾一下使用 `kill()` 函数来杀死进程的方法。杀死进程所需的参数包括进程 `pid`
    和需要发送给进程以杀死应用程序的信号（`signal.SIGKILL`）：
- en: '[PRE52]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `signal` module ([https://docs.python.org/3/library/signal.html)](https://docs.python.org/2/library/signal.html))
    contains the constants that represents the signals that could be used to stop
    an application. In this code snippet, we make use of the `SIGKILL` signal. Try
    running the `ps` command (`ps aux`) and you will notice that the `light_scheduler`
    application has been killed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal`模块([https://docs.python.org/3/library/signal.html](https://docs.python.org/3/library/signal.html))包含表示可以用来停止应用程序的信号的常量。在这个代码片段中，我们使用了`SIGKILL`信号。尝试运行`ps`命令（`ps
    aux`），你会注意到`light_scheduler`应用程序已被终止。'
- en: Monitoring a process
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控进程
- en: In the previous example, we discussed killing an application using the `kill()`
    function. You might have noticed that we made use of something called the `try`/`except`
    keywords to attempt killing the application. We will discuss these keywords in
    detail in the next chapter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们讨论了使用`kill()`函数终止应用程序。你可能已经注意到，我们使用了`try`/`except`关键字来尝试终止应用程序。我们将在下一章详细讨论这些关键字。
- en: It is also possible to monitor whether an application is running using the `kill()`
    function using the `try`/`except` keywords. We will discuss monitoring processes
    using the `kill()` function after introducing the concept of trapping exceptions
    using `try`/`except` keywords.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`kill()`函数和`try`/`except`关键字来监控应用程序是否正在运行。在介绍使用`try`/`except`关键字捕获异常的概念之后，我们将讨论使用`kill()`函数监控进程。
- en: All examples discussed in the `os` module are available for download along with
    this chapter as `os_utils.py`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中讨论的所有`os`模块的示例都可以作为`os_utils.py`一起下载。
- en: The glob module
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`glob`模块'
- en: 'The `glob` module ([https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html))
    enables identifying files of a specific extension or files that have a specific
    pattern. For example, it is possible to list all Python files in a folder as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob`模块([https://docs.python.org/3/library/glob.html](https://docs.python.org/3/library/glob.html))允许识别具有特定扩展名或具有特定模式的文件。例如，可以列出文件夹中的所有Python文件，如下所示：'
- en: '[PRE53]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `glob()` function returns a list of files that contains the `.py` extension.
    A `for` loop is used to iterate through the list and print each file. When the
    preceding code snippet is executed, the output contains the list of all code samples
    belonging to this chapter (output truncated for representation):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`glob()`函数返回一个包含`.py`扩展名的文件列表。使用`for`循环遍历列表并打印每个文件。当执行前面的代码片段时，输出包含属于本章的所有代码示例的列表（输出已截断以供展示）：'
- en: '[PRE54]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This module is especially helpful with listing files that have a specific pattern.
    For example: Let''s consider a scenario where you would like to upload files that
    were created from different trials of an experiment. You are only interested in
    files that are of the following format: `file1xx.txt` where `x` stands for any
    digit between `0` and `9`. Those files could be sorted and listed as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块在列出具有特定模式的文件时特别有用。例如：让我们考虑一个场景，你想要上传由实验的不同试验创建的文件。你只对以下格式的文件感兴趣：`file1xx.txt`，其中`x`代表`0`到`9`之间的任何数字。这些文件可以按如下方式排序和列出：
- en: '[PRE55]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In the preceding example, `[0-9]` means that the file name could contain any
    digit between `0` and `9`. Since we are looking for files of the `file1xx.txt` format,
    the search pattern that is passed an argument to the `glob()` function is `file1[0-9][0-9].txt`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`[0-9]`表示文件名可以包含`0`到`9`之间的任何数字。由于我们正在寻找`file1xx.txt`格式的文件，传递给`glob()`函数的搜索模式是`file1[0-9][0-9].txt`。
- en: 'When the preceding code snippet is executed, the output contains all text files
    of the specified format:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行前面的代码片段时，输出包含指定格式的所有文本文件：
- en: '[PRE56]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We came across this article that explains the use of expressions for sorting
    files: [http://www.linuxjournal.com/content/bash-extended-globbing](http://www.linuxjournal.com/content/bash-extended-globbing).
    The same concept can be extended to searching for files using the `glob` module.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现了一篇解释使用表达式对文件进行排序的文章：[http://www.linuxjournal.com/content/bash-extended-globbing](http://www.linuxjournal.com/content/bash-extended-globbing)。同样的概念可以扩展到使用`glob`模块进行文件搜索。
- en: Challenge to the reader
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对读者的挑战
- en: 'The examples discussed with the `glob` module are available for download along
    with this chapter as `glob_example.py`. In one of the examples, we discussed listing
    files of a specific format. How would you go about listing files that are of the
    following format: `filexxxx.*`? (Here `x` represents any number between `0` and
    `9`. `*` represents any file extension.)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `glob` 模块一起讨论的示例作为 `glob_example.py` 可以下载。在其中一个示例中，我们讨论了列出特定格式的文件。你将如何列出以下格式的文件：`filexxxx.*`？（其中
    `x` 代表 `0` 到 `9` 之间的任何数字。`*` 代表任何文件扩展名。）
- en: The shutil module
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`shutil` 模块'
- en: 'The `shutil` module ([https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html))
    enables moving and copying files between folders using the `move()` and `copy()`
    methods. In the previous section, we listed all text files within the folder,
    `txt_files`. Let''s move these files to the current directory (where the code
    is being executed) using `move()`, make a copy of these files once again in `txt_files`
    and finally remove the text files from the current directory:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`shutil` 模块（[https://docs.python.org/3/library/shutil.html](https://docs.python.org/3/library/shutil.html)）通过
    `move()` 和 `copy()` 方法在文件夹之间移动和复制文件。在前一节中，我们列出了 `txt_files` 文件夹中的所有文本文件。让我们使用
    `move()` 将这些文件移动到当前目录（代码正在执行的目录）中，然后在 `txt_files` 中再次复制这些文件，最后从当前目录中删除文本文件：'
- en: '[PRE57]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the preceding example (available for download along with this chapter as
    `shutil_example.py`), the files are being moved as well as copied from the origin
    to the destination by specifying the source and the destination as the first and
    second arguments respectively.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例（作为 `shutil_example.py` 一起提供下载）中，通过指定源和目标作为第一个和第二个参数，文件正在从源移动到目标以及进行复制。
- en: The files to be moved (or copied) are identified using the `glob` module. Then,
    each file is moved or copied using their corresponding methods.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `glob` 模块识别要移动（或复制）的文件。然后，使用它们对应的方法移动或复制每个文件。
- en: The subprocess module
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子进程模块
- en: 'We briefly discussed this module in the previous chapter. The `subprocess`
    module ([https://docs.python.org/3.2/library/subprocess.html](https://docs.python.org/3.2/library/subprocess.html))
    enables launching another program from within a Python program. One of the commonly
    used functions from the `subprocess` module is `Popen`.Any process that needs
    to be launched from within the program needs to be passed as a list argument to
    the `Popen` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中简要介绍了这个模块。`subprocess` 模块（[https://docs.python.org/3.2/library/subprocess.html](https://docs.python.org/3.2/library/subprocess.html)）允许在
    Python 程序中启动另一个程序。`subprocess` 模块中常用的一个函数是 `Popen`。任何需要在程序中启动的过程都需要作为列表参数传递给 `Popen`
    函数：
- en: '[PRE58]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: In the preceding example, `tone.wav` (WAVE file that needs to be played) and
    the command that needs to be run are passed as a list argument to the function.
    There are several other commands from the `subprocess` module that serve a similar
    purpose. We leave it to your exploration.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`tone.wav`（需要播放的 WAVE 文件）和需要运行的命令作为列表参数传递给函数。`subprocess` 模块中还有其他几个具有类似功能的命令。我们将它们留给您去探索。
- en: The sys module
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`sys` 模块'
- en: 'The `sys` module ([https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html))
    allows interacting with the Python run-time interpreter. One of the functions
    of the `sys` module is parsing command-line arguments provided as inputs to the
    program. Let''s write a program that reads and prints the contents of the file
    that is passed as an argument to the program:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys` 模块（[https://docs.python.org/3/library/sys.html](https://docs.python.org/3/library/sys.html)）允许与
    Python 运行时解释器交互。`sys` 模块的一个功能是解析程序输入提供的命令行参数。让我们编写一个程序，读取并打印作为程序参数传递的文件的内容：'
- en: '[PRE59]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Try running the preceding example as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试按照以下方式运行前面的示例：
- en: '[PRE60]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The preceding example is available for download along with this chapter as `sys_example.py`.
    The list of command-line arguments passed while running the program are available
    as a `argv` list in the `sys` module. `argv[0]` is usually the name of the Python
    program and `argv[1]` is usually the first argument passed to the function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例作为 `sys_example.py` 一起提供下载。在运行程序时传递的命令行参数列表作为 `argv` 列表在 `sys` 模块中可用。`argv[0]`
    通常代表 Python 程序的名称，而 `argv[1]` 通常是将第一个参数传递给函数。
- en: 'When `sys_example.py` is executed with `read_lines.txt` as an argument, the
    program should print the contents of the text file:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `read_lines.txt` 作为参数执行 `sys_example.py` 时，程序应打印文本文件的内容：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed file I/O – reading and writing to files, different
    flags used to read, write, and append to files. We talked about moving file pointers
    to different points in a file to retrieve specific content or overwrite the contents
    of a file at a specific location. We discussed the `ConfigParser` module in Python
    and its application in storing/retrieving config parameters for applications along
    with reading and writing to CSV files.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了文件I/O——读取和写入文件，以及用于读取、写入和追加到文件的不同的标志。我们讨论了将文件指针移动到文件中的不同位置以检索特定内容或覆盖文件特定位置的文件内容。我们还讨论了Python中的`ConfigParser`模块及其在存储/检索应用程序配置参数以及在CSV文件中读取和写入中的应用。
- en: Finally, we discussed different Python utilities that have a potential use in
    our project. We will be extensively making use of file I/O and the discussed Python
    utilities in our final project. We strongly recommend familiarizing yourself with
    the concepts discussed in this chapter before moving onto the final projects discussed
    in this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了不同可能在我们的项目中使用的Python实用工具。在我们的最终项目中，我们将广泛使用文件I/O和讨论过的Python实用工具。我们强烈建议在继续阅读本书中讨论的最终项目之前，熟悉本章中讨论的概念。
- en: In the upcoming chapters, we will discuss uploading sensor data stored in CSV files
    to the cloud and logging errors encountered during the execution of an application.
    See you in the next chapter!
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论将存储在CSV文件中的传感器数据上传到云以及记录应用程序执行过程中遇到的错误。下一章见！
