- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Building RESTful APIs with FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FastAPI构建RESTful API
- en: In this chapter, we delve into the essentials of building **RESTful APIs**.
    RESTful APIs are the backbone of web services, enabling applications to communicate
    and exchange data efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨构建**RESTful API**的基本要素。RESTful API是网络服务的骨架，它使得应用程序能够高效地进行通信和数据交换。
- en: You will build a RESTful API for a Task Manager application. The application
    will interact with a CSV file, although the typical approach for such applications
    would be to use a database such as SQL or NoSQL. This approach is unconventional
    and not recommended for most scenarios due to scalability and performance limitations.
    However, in certain contexts, particularly in legacy systems or when dealing with
    large volumes of structured data files, managing data through CSV can be a practical
    solution.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 您将构建一个用于任务管理应用程序的RESTful API。该应用程序将与CSV文件交互，尽管对于此类应用程序，典型的做法是使用数据库，如SQL或NoSQL。这种方法是非传统的，并且由于可扩展性和性能限制，不建议在大多数场景中使用。然而，在某些情况下，特别是在遗留系统或处理大量结构化数据文件时，通过CSV管理数据可能是一个实用的解决方案。
- en: Our Task Manager API will allow users to **create, read, update, and delete**
    (**CRUD**) tasks, each represented as a record in a CSV file. This example will
    provide insights into handling data in non-standard formats within FastAPI.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务管理API将允许用户**创建、读取、更新和删除**（**CRUD**）任务，每个任务都表示为CSV文件中的一个记录。本例将提供在FastAPI中处理非标准格式数据的见解。
- en: We will see how to test the API’s endpoint. As your API grows, managing complex
    queries and filtering becomes essential. We’ll explore techniques to implement
    advanced query capabilities, enhancing the usability and flexibility of your API.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何测试API的端点。随着API的增长，管理复杂查询和过滤变得至关重要。我们将探讨实现高级查询功能的技术，增强API的可用性和灵活性。
- en: Furthermore, we’ll tackle the important aspect of versioning your API. Versioning
    is key to evolving your API over time without breaking existing clients. You’ll
    learn strategies to manage API versions, ensuring backward compatibility and smooth
    transitions for users.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将解决API版本化的重要问题。版本化是随着时间的推移演进API而不破坏现有客户端的关键。您将学习管理API版本的战略，确保向后兼容性和用户平滑过渡。
- en: Lastly, we’ll cover securing API with OAuth2, an industry-standard protocol
    for authorization. Security is paramount in API development, and you’ll gain practical
    experience in implementing authentication and protecting your endpoints.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将介绍使用OAuth2保护API，这是一种行业标准的授权协议。安全性在API开发中至关重要，您将获得实施身份验证和保护端点的实践经验。
- en: 'In this chapter, we’re going to cover the following recipes:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating CRUD operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建CRUD操作
- en: Creating RESTful endpoints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建RESTful端点
- en: Testing your RESTful API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试您的RESTful API
- en: Handling complex queries and filtering
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理复杂查询和过滤
- en: Versioning your API
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API版本化
- en: Securing your API with OAuth2
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OAuth2保护您的API
- en: Documenting your API with Swagger and Redoc
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Swagger和Redoc记录您的API
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To fully engage with this chapter in our *FastAPI Cookbook* and effectively
    build RESTful APIs, you’ll need to have the following technologies and tools installed
    and configured:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在*FastAPI食谱集*中充分参与本章的学习，并有效地构建RESTful API，您需要安装和配置以下技术和工具：
- en: '**Python**: Make sure you have a Python version higher than 3.9 in your environment.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Python**：请确保您的环境中安装了高于3.9版本的Python。'
- en: '**FastAPI**: This should be installed with all required dependencies. If you
    haven’t done it from the previous chapters, you can do so simply from your terminal
    with the following command:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FastAPI**：应安装所有必需的依赖项。如果您尚未从前面的章节中安装，您可以从终端简单地使用以下命令进行安装：'
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Pytest**: You can install this framework by running the following:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pytest**：您可以通过运行以下命令来安装此框架：'
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that it can be very useful to already have some knowledge of the Pytest
    framework to better follow the *Testing your RESTful* *API* recipe.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已经对Pytest框架有所了解可能会非常有用，以便更好地遵循*测试您的RESTful API*食谱。
- en: 'The code used in the chapter is available on GitHub at the address: [https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可在GitHub上找到，地址为：[https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03](https://github.com/PacktPublishing/FastAPI-Cookbook/tree/main/Chapter03)。
- en: Feel free to follow along or consult it in case you get stuck.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 随时可以跟随或查阅，以防遇到困难。
- en: Creating CRUD operations
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建CRUD操作
- en: This recipe will show you how to make the basic CRUD operations work with the
    CSV file that acts as a database.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向您展示如何使用作为数据库的 CSV 文件来实现基本的 CRUD 操作。
- en: We will begin by making a draft for a simple list of tasks in CSV format and
    we will put the operations in a separate Python module. By the end of the recipe,
    you will have all the operations ready to be used by the API’s endpoints.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始为简单的任务列表草拟一个 CSV 格式的草案，并将操作放在一个单独的 Python 模块中。到配方结束时，您将拥有所有准备通过 API 端点使用的操作。
- en: How to do it…
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let’s start by creating a project root directory called `task_manager_app`
    to host our code base for our application:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个名为 `task_manager_app` 的项目根目录，用于存放我们的应用程序代码库：
- en: 'Move into the root project folder and create a `tasks.csv` file, which we will
    use as a database and put a few tasks inside:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入根项目文件夹，创建一个 `tasks.csv` 文件，我们将将其用作数据库，并在其中放入一些任务：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, create a file called `models.py`, containing the Pydantic models that
    we will use internally for the code. It will look like the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 `models.py` 的文件，其中包含我们将用于内部代码的 Pydantic 模型。它看起来如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We created two separate classes for task objects because `id` won’t be used
    all along the code.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们创建了两个独立的任务对象类，因为 `id` 在整个代码中都不会使用。
- en: In a new file called `operations.py`, we will define the function that interacts
    with our database.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个名为 `operations.py` 的新文件中，我们将定义与我们的数据库交互的函数。
- en: We can start creating the CRUD operation
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以开始创建 CRUD 操作
- en: 'Create a function to retrieve all the tasks from a `.``csv` file:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个从 `.csv` 文件中检索所有任务的函数：
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, we need to create a function to read a specific task based on `id`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个基于 `id` 读取特定任务的函数：
- en: '[PRE5]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To write a task, we need a strategy to assign a new `id` to the task that will
    written into the database.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编写一个任务，我们需要一个策略来为新写入数据库的任务分配一个新的 `id`：
- en: A good strategy can be to implement a logic based on the IDs already present
    in the database, then write the task into our CSV file, and group both operations
    into a new function. We can split the create task operation into three functions.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个好的策略是实施一个基于数据库中已存在的 ID 的逻辑，然后将任务写入我们的 CSV 文件，并将这两个操作组合到一个新的函数中。我们可以将创建任务操作拆分为三个函数。
- en: 'First, let’s create the function that retrieves the new ID based on the existing
    ones in the database:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个基于数据库中现有 ID 的函数来检索新 ID：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we define the function to write the task with the ID in the CSV file:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义一个将任务写入 CSV 文件中具有 ID 的函数：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After that, we can leverage these last two functions to define the function
    that creates the task:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，我们可以利用这两个最后的功能来定义创建任务的函数：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, let’s create the function to modify the task:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个修改任务的函数：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, let’s create the function to remove the task with a specific `id`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个删除具有特定 `id` 的任务的函数：
- en: '[PRE10]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You’ve just created the basic CRUD operations. We are now ready to expose those
    operations through the API endpoints.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了基本的 CRUD 操作。我们现在准备通过 API 端点公开这些操作。
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The structure of your API is fundamental in RESTful design. It involves defining
    endpoints (URIs) and associating them with HTTP methods to perform the desired
    operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 API 结构在 RESTful 设计中至关重要。它涉及定义端点（URI）并将它们与 HTTP 方法关联以执行所需的操作。
- en: 'In our Task Management system, we’ll create endpoints to handle tasks, mirroring
    common CRUD operations. Here’s an overview:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的任务管理系统（Task Management system）中，我们将创建处理任务的端点，以反映常见的 CRUD 操作。以下是概述：
- en: '`List Tasks` (`GET /tasks`) retrieves a list of all tasks'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`列出任务` (`GET /tasks`) 获取所有任务的列表'
- en: '`Retrieve Task` (`GET /tasks/{task_id}`) gets details of a specific task'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`检索任务` (`GET /tasks/{task_id}`) 获取特定任务的详细信息'
- en: '`Create Task` (`POST /task`) adds a new task'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建任务` (`POST /task`) 添加一个新任务'
- en: '`Update Task` (`PUT /tasks/{task_id}`) modifies an existing task'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`更新任务` (`PUT /tasks/{task_id}`) 修改现有任务'
- en: '`Delete Task` (`DELETE /tasks/{task_id}`) removes a task'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`删除任务` (`DELETE /tasks/{task_id}`) 删除一个任务'
- en: Each endpoint represents a specific function in the API, clearly defined and
    purpose driven. FastAPI’s routing system allows us to map these operations to
    Python functions easily.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个端点代表 API 中的一个特定函数，定义明确且目的明确。FastAPI 的路由系统允许我们轻松地将这些操作映射到 Python 函数。
- en: Exercise
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: Try to write your unit tests for each one of the CRUD operations. If you follow
    along with the GitHub repository, you can find the tests in the `Chapter03/task_manager_rest_api/test_operations.py`
    file.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为每个 CRUD 操作编写单元测试。如果您跟随 GitHub 仓库，您可以在 `Chapter03/task_manager_rest_api/test_operations.py`
    文件中找到测试。
- en: Creating RESTful Endpoints
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 RESTful 端点
- en: Now, we will create the routes to expose each of the CRUD operations with a
    specific endpoint. In this recipe, we will see how FastAPI leverages Python type
    annotations to define expected request and response data types, streamlining the
    process of validation and serializing data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建路由来通过特定的端点公开每个 CRUD 操作。在这个菜谱中，我们将看到 FastAPI 如何利用 Python 类型注解来定义预期的请求和响应数据类型，从而简化验证和序列化数据的过程。
- en: Getting ready…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: Before starting the recipe, make sure you know how to set up your local environment
    and create a basic FastAPI server. You can review it in the *Creating a new FastAPI
    project* and *Understanding FastAPI basics* recipes in [*Chapter 1*](B21025_01.xhtml#_idTextAnchor020),
    *First Steps* *with FastAPI*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始菜谱之前，请确保您知道如何设置本地环境并创建一个基本的 FastAPI 服务器。您可以在 [*第 1 章*](B21025_01.xhtml#_idTextAnchor020)
    的 *创建新的 FastAPI 项目* 和 *理解 FastAPI 基础* 菜谱中查看它。
- en: Also, we will use the CRUD operations created in the previous recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用之前菜谱中创建的 CRUD 操作。
- en: How to do it…
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Let’s create a `main.py` file in the project root folder to code the server
    with the endpoints. FastAPI simplifies the implementation of different HTTP methods,
    aligning them with the corresponding CRUD operations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目根目录中创建一个 `main.py` 文件来编写带有端点的服务器。FastAPI 简化了不同 HTTP 方法的实现，使它们与相应的 CRUD
    操作相匹配。
- en: 'Let’s now write the endpoints for each operation:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为每个操作编写端点：
- en: 'Create the server with the endpoint to list all the tasks by using the `read_all_tasks`
    operation:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `read_all_tasks` 操作创建一个端点来列出所有任务的服务器：
- en: '[PRE11]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let’s write the endpoint to read a specific task based on `id`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个端点来根据 `id` 读取特定的任务：
- en: '[PRE12]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The endpoint to add a task will be as follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加任务的端点如下：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To update the task, we can modify each field (`description`, `status`, or `title`).
    To do this, we create a specific model to be used in the body called `UpdateTask`.
    The endpoint will look like this:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新任务，我们可以修改每个字段（`description`、`status` 或 `title`）。为此，我们创建一个用于正文的特定模型，称为 `UpdateTask`。端点将如下所示：
- en: '[PRE14]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, here is the endpoint to delete a task:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，这是删除任务的端点：
- en: '[PRE15]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You have just implemented the operations to interact with the CSV file used
    as a database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚实现了与用作数据库的 CSV 文件交互的操作。
- en: 'From a command terminal at the project root folder level, spin up the server
    with the `uvicorn` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目根目录级别的命令行中，使用 `uvicorn` 命令启动服务器：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the browser, go to `http://localhost:8000/docs` and you will see the endpoints
    of your RESTful API that you just made.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中，访问 `http://localhost:8000/docs`，您将看到您刚刚创建的 RESTful API 的端点。
- en: You can experiment by creating some tasks, then listing them, updating them,
    and deleting some of them directly with the interactive documentation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过创建一些任务，然后列出它们，更新它们，并直接通过交互式文档删除一些任务来实验。
- en: Testing your RESTful API
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您的 RESTful API
- en: Testing is a critical part of API development. In FastAPI, you can use various
    testing frameworks such as `pytest` to write tests for your API endpoints.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是 API 开发的一个关键部分。在 FastAPI 中，您可以使用各种测试框架，如 `pytest`，来编写 API 端点的测试。
- en: In this recipe, we are going to write unit tests for each of the endpoints we
    created earlier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将为之前创建的每个端点编写单元测试。
- en: Getting ready…
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作…
- en: 'If not done yet, ensure you have `pytest` installed in your environment by
    running:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未完成，请确保您已经通过运行以下命令在您的环境中安装了 `pytest`：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s a good practice in testing to use a dedicated database to avoid interaction
    with the production one. To accomplish this, we will create a test fixture that
    generates the database before each test.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，使用一个专门的数据库来避免与生产数据库交互是一个好的实践。为了实现这一点，我们将创建一个测试固定装置，在每次测试之前生成数据库。
- en: 'We will define this in a `conftest.py` module so that the fixture is applied
    to all tests under the project’s root folder. Let’s create the module in the project
    root folder and start by defining a list of test tasks and the name of the CSV
    file used for the tests:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `conftest.py` 模块中定义它，以便固定装置应用于项目根目录下的所有测试。让我们在项目根目录中创建该模块，并首先定义一个测试任务列表和用于测试的
    CSV 文件名称：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can now create a fixture that will be used for all the tests. This fixture
    will set up the test database before each test function execution.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个将用于所有测试的固定装置。这个固定装置将在每个测试函数执行之前设置测试数据库。
- en: 'We can achieve this by passing the `autouse=True` argument to the `pytest.fixture`
    decorator, which indicates that the feature will run before every single test:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`autouse=True`参数传递给`pytest.fixture`装饰器来实现这一点，这表示该功能将在每个测试之前运行：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the fixture is defined in a `conftest.py` module, each test module will
    automatically import it.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于固定装置定义在`conftest.py`模块中，每个测试模块将自动导入它。
- en: Now, we can proceed with creating the actual unit test functions for the endpoints
    created in the previous recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续创建之前配方中创建的端点的实际单元测试函数：
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: To test the endpoints, FastAPI provides a specific `TestClient` class that allows
    the testing of the endpoints without running the server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试端点，FastAPI提供了一个特定的`TestClient`类，允许在不运行服务器的情况下测试端点。
- en: 'In a new module called `test_main.py`, let’s define our test client:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为`test_main.py`的新模块中，让我们定义我们的测试客户端：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can create the tests for each endpoint as follows.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像以下这样为每个端点创建测试。
- en: 'Let’s start with the `GET /tasks` endpoint, which lists all the tasks in the
    database:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从`GET /tasks`端点开始，该端点列出数据库中的所有任务：
- en: '[PRE21]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We are asserting the response’s status code and the `json` body.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在断言响应的状态码和`json`正文。
- en: 'As easy as that, we can go on by creating the test for `GET /tasks/{task_id}`
    to read a task with a specific `id`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 就这么简单，我们可以通过创建`GET /tasks/{task_id}`的测试来继续，以读取具有特定`id`的任务：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Besides the `200` status code for an existing task, we also asserted the status
    code is equal to `404` when the task does not exist in the database.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了现有任务的`200`状态码外，我们还断言当任务不存在于数据库中时，状态码等于`404`。
- en: 'In a similar way, we can test the `POST /task` endpoint to add a new task into
    the database by asserting the new assigned `id` for the task:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以通过断言任务的新分配`id`来测试`POST /task`端点，以便将新任务添加到数据库中：
- en: '[PRE23]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The test for the `PUT /tasks/{task_id}` endpoint to modify a task will then
    be the following:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改任务的`PUT /tasks/{task_id}`端点的测试将是以下内容：
- en: '[PRE24]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we test the `DELETE /tasks/{task_id}` endpoint to delete a task:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们测试`DELETE /tasks/{task_id}`端点以删除任务：
- en: '[PRE25]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You’ve just written all the unit tests for each of the API endpoints.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经为每个API端点编写了所有单元测试。
- en: 'You can now run the tests from the project root folder by running in the terminal,
    or with the GUI support of your favorite editor:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以从项目根目录运行测试，在终端中运行或在您最喜欢的编辑器的GUI支持下运行：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Pytest will collect all the tests and run them. If everything is correctly done,
    you will see a message that says you got a 100% score in the output of the console
    if you have written the tests correctly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest将收集所有测试并运行它们。如果你正确编写了测试，你将在控制台输出中看到一条消息，表明你获得了100%的分数。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can check test fixtures in the Pytest documentation:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Pytest文档中检查测试固定装置：
- en: '*Pytest Fixtures* *Reference*: [https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml](https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Pytest Fixtures* *参考*: [https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml](https://docs.pytest.org/en/7.1.x/reference/fixtures.xhtml)'
- en: 'You can dig into FastAPI testing tools and the `TestClient` API in the official
    documentation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方文档中深入了解FastAPI测试工具和`TestClient` API：
- en: '*FastAPI* *Testing*: [https://fastapi.tiangolo.com/tutorial/testing/](https://fastapi.tiangolo.com/tutorial/testing/)'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI* *Testing*: [https://fastapi.tiangolo.com/tutorial/testing/](https://fastapi.tiangolo.com/tutorial/testing/)'
- en: '*FastAPI* *TestClient*: [https://fastapi.tiangolo.com/reference/testclient/](https://fastapi.tiangolo.com/reference/testclient/)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI* *TestClient*: [https://fastapi.tiangolo.com/reference/testclient/](https://fastapi.tiangolo.com/reference/testclient/)'
- en: Handling complex queries and filtering
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理复杂查询和过滤
- en: In any RESTful API, providing the functionality to filter data based on certain
    criteria is essential. In this recipe, we’ll enhance our Task Manager API to allow
    users to filter tasks based on different parameters and create a search endpoint.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何RESTful API中，提供基于某些标准过滤数据的功能是至关重要的。在这个配方中，我们将增强我们的任务管理API，允许用户根据不同的参数过滤任务并创建一个搜索端点。
- en: Getting ready…
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: The filtering functionality will be implemented in the existing `GET /tasks`
    endpoint to show how to overcharge an endpoint, while the search functionality
    will be shown on a brand-new endpoint. Make sure you have at least the CRUD operations
    already in place before continuing.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤功能将在现有的`GET /tasks`端点中实现，以展示如何超载端点，而搜索功能将在全新的端点中展示。在继续之前，请确保您已经实现了至少CRUD操作。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'We will start by overcharging `GET /tasks` endpoint with filters. We modify
    the endpoint to accept two query parameters: `status` and `title`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过过滤器对`GET /tasks`端点进行过度充电。我们修改端点以接受两个查询参数：`status`和`title`。
- en: 'The endpoint will then look like the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该端点将看起来如下所示：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The two parameters can be optionally specified to filter the tasks that match
    their value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数可以可选地指定以过滤匹配其值的任务。
- en: 'Next, we implement a search functionality. Beyond basic filtering, implementing
    a search functionality can significantly improve the usability of an API. We’ll
    add a search feature that allows users to find tasks based on a keyword present
    in the title or description in a new endpoint:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们实现搜索功能。除了基本的过滤外，实现搜索功能可以显著提高API的可用性。我们将在新的端点中添加一个搜索功能，允许用户根据标题或描述中的关键词查找任务：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the `search_tasks` endpoint, the function filters tasks to include only those
    where the keyword appears in either the title or the description.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`search_tasks`端点中，该函数会过滤任务，只包括标题或描述中包含关键词的任务。
- en: 'To start the server as usual, run this command from the command line:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要像往常一样启动服务器，请在命令行中运行此命令：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Then, go to the interactive documentation address at `http://localhost:8000/docs`,
    and you will see the new endpoint we’ve just made.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到交互式文档地址`http://localhost:8000/docs`，您将看到我们刚刚创建的新端点。
- en: Play around by specifying some keywords that could be in the title or the description
    of one of your tasks.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定可能出现在您任务标题或描述中的某些关键词来尝试一下。
- en: Versioning your API
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API版本控制
- en: '**API versioning** is essential in maintaining and evolving web services without
    disrupting the existing users. It allows developers to introduce changes, improvements,
    or even breaking changes while providing backward compatibility. In this recipe,
    we will implement versioning in our Task Manager API.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**API版本控制**对于维护和演进网络服务而不中断现有用户至关重要。它允许开发者在提供向后兼容性的同时引入更改、改进或甚至破坏性更改。在这个食谱中，我们将实现我们的任务管理API的版本控制。'
- en: Getting ready…
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: To follow the recipe, you will need to have endpoints already defined. If you
    don’t have them, you can first check the *Creating RESTful* *endpoints* recipe.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循食谱，您需要已经定义了端点。如果您还没有，可以先查看*创建RESTful* *端点*的食谱。
- en: How to do it...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: There are several strategies for API versioning. We will use the most common
    approach, URL path versioning, for our API.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API版本控制，有几种策略。我们将使用最常见的方法，即URL路径版本控制，来为我们的API使用。
- en: Let’s consider that we want to improve the task information by adding a new
    `str` field called `priority` that is set to `"lower"` by default. Let's do it
    through the following steps.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑我们想要通过添加一个名为`priority`的新`str`字段来改进任务信息，该字段默认设置为`"lower"`。让我们通过以下步骤来完成它。
- en: 'Let’s create a `TaskV2` object class in the `models.py` module:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`models.py`模块中创建一个名为`TaskV2`的对象类：
- en: '[PRE30]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `operations.py` module, let’s create a new function called `read_all_tasks_v2`,
    which reads all the tasks, and add the `priority` field:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`operations.py`模块中，让我们创建一个名为`read_all_tasks_v2`的新函数，该函数读取所有任务，并添加`priority`字段：
- en: '[PRE31]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We have now all we need to create version two of `read_all_tasks` function.
    We will do this in the `main.py` module:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了创建`read_all_tasks`函数第二个版本所需的一切。我们将在`main.py`模块中完成这项工作：
- en: '[PRE32]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You’ve just created version two of the endpoint. In this way, you can develop
    and improve your API with several versions of your endpoint.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚创建了端点的第二个版本。这样，您就可以通过端点的几个版本来开发和改进您的API。
- en: 'To test it, let''s modify our `tasks.csv` file by manually adding the new field
    to test the new endpoint:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试它，让我们通过手动将新字段添加到`tasks.csv`文件中来修改它，以测试新端点：
- en: '[PRE33]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Start the server once more from the command line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 再次从命令行启动服务器：
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, the interactive documentation at `http://localhost:8000/docs` will show
    the new `GET /v2/tasks` endpoint to list all the tasks in version 2 mode.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，交互式文档`http://localhost:8000/docs`将显示新的`GET /v2/tasks`端点，以列出所有以版本2模式运行的任务。
- en: Check that the endpoint lists the tasks with the new `priority` field and that
    the old `GET /tasks` is still working as expected.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 检查端点是否列出了带有新`priority`字段的任务，并且旧的`GET /tasks`是否仍然按预期工作。
- en: Exercise
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: You might have noticed that using a CSV file as a database might not be the
    most reliable solution. If the process crashes during an update or removal, you
    can lose all of the data. So, improve the API with a newer version of the endpoints
    that use operational functions that interact with an SQLite database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，使用CSV文件作为数据库可能不是最可靠的解决方案。如果在更新或删除过程中进程崩溃，你可能会丢失所有数据。因此，通过使用与SQLite数据库交互的操作函数的新版本端点来改进API。
- en: There’s more…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: When you version an API, you are essentially providing a way to differentiate
    between different releases or versions of your API, allowing clients to choose
    which version they want to interact with.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对API进行版本控制时，你实际上是在提供一个区分不同API发布或版本的方法，允许客户端选择他们想要交互的版本。
- en: 'Besides the URL-based approach that we used in the recipe, there are other
    common approaches to API versioning, such as the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在配方中使用的基于URL的方法之外，还有其他常见的API版本控制方法，例如以下内容：
- en: '**Query parameter versioning**: Version information is passed as a query parameter
    in the API request. For example, see the following:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询参数版本控制**：版本信息作为API请求中的查询参数传递。例如，参见以下内容：'
- en: '[PRE35]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This method keeps the base URL uniform across versions.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法保持了不同版本之间的基础URL统一。
- en: '**Header versioning**: The version is specified in a custom header of the HTTP
    request:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**头部版本控制**：版本信息在HTTP请求的自定义头部中指定：'
- en: '[PRE36]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This keeps the URL clean but requires clients to explicitly set the version
    in their requests.
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种方法保持了URL的简洁性，但要求客户端在他们的请求中显式设置版本。
- en: '**Consumer-based versioning**: This strategy allows customers to choose the
    version they need. The version available at their first interaction is saved with
    their details and used in all future interactions unless they make changes.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于消费者的版本控制**：这种策略允许客户选择他们需要的版本。他们在第一次交互时保存的版本将与他们的详细信息一起使用，并在所有未来的交互中使用，除非他们进行更改。'
- en: Furthermore, it can be relevant to use `MAJOR.MINOR.PATCH`). Changes in the
    `MAJOR` version indicate incompatible API changes, while `MINOR` and `PATCH` versions
    indicate backward-compatible changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用`MAJOR.MINOR.PATCH`格式。`MAJOR`版本的更改表示不兼容的API更改，而`MINOR`和`PATCH`版本的更改表示向后兼容的更改。
- en: Versioning allows API providers to introduce changes (such as adding new features,
    modifying existing behavior, or deprecating endpoints and sunset policies) without
    breaking existing client integrations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制允许API提供商在不破坏现有客户端集成的情况下引入更改（如添加新功能、修改现有行为或弃用端点和日落策略）。
- en: It also gives consumers control over when and how they adopt new versions, minimizing
    disruptions and maintaining stability in the API ecosystem.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它还让消费者控制何时以及如何采用新版本，最小化中断并保持API生态系统的稳定性。
- en: See also
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can have a look at an interesting article from the Postman blog on API
    versioning strategies:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看Postman博客上关于API版本控制策略的一篇有趣的文章：
- en: '*Postman Blog API* *Versioning*: [https://www.postman.com/api-platform/api-versioning/](https://www.postman.com/api-platform/api-versioning/)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Postman博客API* *版本控制*：[https://www.postman.com/api-platform/api-versioning/](https://www.postman.com/api-platform/api-versioning/)'
- en: Securing your API with OAuth2
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OAuth2保护您的API
- en: In web applications, securing endpoints from unauthorized users is crucial.
    **OAuth2** is a common authorization framework that enables applications to be
    accessed by user accounts with restricted permissions. It works by issuing tokens
    instead of credentials. This recipe will show how to use OAuth2 in our Task Manager
    API to protect endpoints.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web应用程序中，保护端点免受未经授权的用户访问至关重要。**OAuth2**是一个常见的授权框架，它允许应用程序通过具有受限权限的用户账户访问。它是通过发行令牌而不是凭据来工作的。本配方将展示如何在我们的任务管理器API中使用OAuth2来保护端点。
- en: Getting ready…
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: FastAPI provides support for OAuth2 with a password, including the use of external
    tokens. Data compliance regulations require that passwords are not stored in plain
    text. Instead, a usual method is to store the outcome of the hashing operation,
    which changes the plain text into a string that is not readable by humans and
    cannot be reversed.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI支持使用密码的OAuth2，包括使用外部令牌。数据合规性法规要求密码不以明文形式存储。相反，通常的方法是存储散列操作的输出，这会将明文转换为人类无法读取的字符串，并且无法逆转。
- en: Important note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: With the only purpose of showing the functionality, we will fake the hashing
    mechanism as well the token creation with trivial ones. For obvious security reasons,
    do not use it in a production environment.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 仅为了展示功能，我们将使用简单的机制来模拟散列机制以及令牌创建。出于明显的安全原因，请不要在生产环境中使用。
- en: How to do it…
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: Let’s start by creating a `security.py` module in the project root folder where
    we are going to implement all tools used to secure our service. Then let's create
    a secured endpoint as follows.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目根目录中创建一个 `security.py` 模块，我们将在这里实现所有用于保护我们服务的工具。然后，让我们创建一个如下所示的安全端点。
- en: 'First, let’s create a dictionary containing a list of users with their usernames
    and passwords:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个包含用户名和密码的用户列表的字典：
- en: '[PRE37]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Passwords should not be stored in plain text, but encrypted or hashed. To demonstrate
    the feature, we fake the hashing mechanism by inserting `"hashed"` before the
    password string:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 密码不应该以纯文本形式存储，而应该加密或散列。为了演示这个特性，我们通过在密码字符串前插入 `"hashed"` 来模拟散列机制：
- en: '[PRE38]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s create the classes to handle the users and a function to retrieve the
    user from the `dict` database we created:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建处理用户和从我们创建的 `dict` 数据库中检索用户的函数的类：
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using a similar logic to what we’ve just used for hashing, let’s make a fake
    token generator and a fake token resolver:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与我们刚才用于散列的类似逻辑，让我们创建一个模拟令牌生成器和模拟令牌解析器：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let’s create a function to retrieve the user from the token. To this,
    we will make use of the `Depends` class to use dependency injection provided by
    FastAPI (see [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)),
    with the `OAuthPasswordBearer` class to handle the token:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数来从令牌中检索用户。为此，我们将使用 `Depends` 类来利用FastAPI提供的依赖注入（见 [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)），使用
    `OAuthPasswordBearer` 类来处理令牌：
- en: '[PRE41]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`oauth2scheme` contains the `/token` URL endpoint that will be used by the
    interactive documentation to authenticate the browser.'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`oauth2scheme` 包含了将被交互式文档用于认证浏览器的 `/token` URL 端点。'
- en: Important note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We have used a dependency injection to retrieve the token from the `get_user_token`
    function with the `fastapi.Depends` object. A dependency injection pattern is
    not native to the Python language and it is strictly related to the FastAPI framework.
    In [*Chapter 8*](B21025_08.xhtml#_idTextAnchor262), *Advanced Features and Best
    Practices*, you will find a dedicated recipe about that called *Implementing*
    *dependency injection*.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用依赖注入从 `get_user_token` 函数中检索令牌，使用了 `fastapi.Depends` 对象。依赖注入模式不是Python语言的原生特性，它与FastAPI框架紧密相关。在[*第8章*](B21025_08.xhtml#_idTextAnchor262)
    *高级特性和最佳实践*中，你可以找到一个专门的配方，称为 *实现* *依赖注入*。
- en: 'Let’s create the endpoint in the `main.py` module:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `main.py` 模块中创建端点：
- en: '[PRE42]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We now have all we need to create a secured endpoint with OAuth2 authentication.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建带有OAuth2认证的安全端点所需的一切。
- en: 'The endpoint we are going to create will return information about the current
    user from the token provided. If the token does not have authorization, it will
    return a `400` exception:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要创建的端点将根据提供的令牌返回有关当前用户的信息。如果令牌没有授权，它将返回一个 `400` 异常：
- en: '[PRE43]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The endpoint we just created will be reachable only by allowed users.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们刚刚创建的端点将只能被允许的用户访问。
- en: 'Let''s now test our secured endpoint. From the command line terminal at the
    project root folder level, spin up the server by running:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来测试我们的安全端点。在项目根目录的命令行终端中，通过运行以下命令启动服务器：
- en: '[PRE44]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Then, open the browser, go to `http://localhost:8000/docs`, and you will notice
    the new `token` and `users/me` endpoints in the interactive documentation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开浏览器，访问 `http://localhost:8000/docs`，你将注意到交互式文档中的新 `token` 和 `users/me`
    端点。
- en: You might notice a little padlock icon on the `users/me` endpoint. If you click
    on it, you will see a form window that allows you to get the token and store it
    directly in your browser, so you don’t have to provide it each time you call the
    secured endpoint.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会在 `users/me` 端点注意到一个小锁形图标。如果你点击它，你会看到一个表单窗口，允许你获取令牌并将其直接存储在你的浏览器中，这样你就不必每次调用安全端点时都提供它。
- en: Exercise
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 练习
- en: You’ve just learned how to create a secured endpoint for your RESTful API. Now,
    try to secure some of the endpoints you created in the previous recipes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学习了如何为你的RESTful API创建一个安全端点。现在，尝试在之前配方中创建的一些端点上实现安全性。
- en: There’s more…
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: With OAuth2, we can define a **scope** parameter, which is used to specify the
    level of access that an access token grants to a client application when it is
    used to access a protected resource. Scopes can be used to define what actions
    or resources the client application is allowed to perform or access on behalf
    of the user.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OAuth2，我们可以定义一个**作用域**参数，该参数用于指定访问令牌在用于访问受保护资源时授予客户端应用的访问级别。作用域可以用来定义客户端应用代表用户可以执行或访问哪些操作或资源。
- en: When a client requests authorization from the resource owner (user), it includes
    one or more scopes in the authorization request. In FastAPI, these scopes are
    represented as `dict`, where keys represent the scope’s name and the value is
    a description.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端从资源所有者（用户）请求授权时，它会在授权请求中包含一个或多个作用域。在FastAPI中，这些作用域以`dict`的形式表示，其中键代表作用域的名称，值是描述。
- en: The authorization server then uses these scopes to determine the appropriate
    access controls and permissions to grant to the client application when issuing
    an access token.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 授权服务器随后使用这些作用域来确定在颁发访问令牌时授予客户端应用的适当访问控制和权限。
- en: 'It is not the purpose of this recipe to go into the details of implementing
    OAuth2 scopes in FastAPI. However, you can find practical examples on the official
    documentation page at the link: [https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的目的不是深入探讨在FastAPI中实现OAuth2作用域的细节。然而，您可以在官方文档页面找到实用示例，链接为：[https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/](https://fastapi.tiangolo.com/advanced/security/oauth2-scopes/)。
- en: See also
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You can check on how FastAPI integrates OAuth2 at the following link:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中查看FastAPI如何集成OAuth2：
- en: '*Simple OAuth2 with Password and* *Bearer*: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*简单的基于密码和Bearer的OAuth2*：https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/'
- en: 'Also, you can find more on dependency injection in FastAPI on the official
    documentation page:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以在官方文档页面找到更多关于FastAPI中依赖注入的信息：
- en: '*Dependencies*: [https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*依赖项*：[https://fastapi.tiangolo.com/tutorial/dependencies/](https://fastapi.tiangolo.com/tutorial/dependencies/)'
- en: Documenting your API with Swagger and Redoc
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger和Redoc记录API
- en: FastAPI automatically generates documentation for your API using **Swagger UI**
    and **Redoc**, when spinning the server.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动服务器时，FastAPI会自动使用**Swagger UI**和**Redoc**为您的API生成文档。
- en: This documentation is derived from your route functions and Pydantic models,
    making it incredibly beneficial for both development and consumption by frontend
    teams or API consumers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此文档是从您的路由函数和Pydantic模型中派生出来的，对开发团队或API消费者来说非常有用。
- en: In this recipe, we will see how to customize the documentation’s specific needs.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将看到如何根据特定需求自定义文档。
- en: Getting ready…
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: 'By default, FastAPI provides two documentation interfaces:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，FastAPI提供了两个文档接口：
- en: '`/docs` endpoint (e.g., `http://127.0.0.1:8000/docs`)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/docs` 端点（例如，`http://127.0.0.1:8000/docs`）'
- en: '`/redoc` endpoint (e.g., `http://127.0.0.1:8000/redoc`)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/redoc` 端点（例如，`http://127.0.0.1:8000/redoc`）'
- en: These interfaces offer dynamic documentation where users can see and test the
    API endpoints and their details. However, both pieces of documentation can be
    modified.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这些界面提供动态文档，用户可以查看和测试API端点和其详细信息。然而，这两份文档都可以进行修改。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: FastAPI allows the customization of Swagger UI. You can add metadata, customize
    the look, and add additional documentation through the `FastAPI` class parameters.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI允许自定义Swagger UI。您可以通过`FastAPI`类的参数添加元数据、自定义外观和添加额外的文档。
- en: 'You can enhance your API documentation by providing additional metadata such
    as `title`, `description`, and `version` to the `app` object in the `main.py`
    module:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`main.py`模块中的`app`对象提供额外的元数据，如`title`、`description`和`version`来增强您的API文档。
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This metadata will appear in both Swagger UI and Redoc documentation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这些元数据将出现在Swagger UI和Redoc文档中。
- en: You can push things further by completely customizing your Swagger UI in case
    you need to expose it to a third user under certain conditions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在某些条件下将Swagger UI暴露给第三方用户，您可以进一步自定义它。
- en: Let’s try to hide the `/token` endpoint from the documentation.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试隐藏文档中的`/token`端点。
- en: 'In this case, you can use the `utils`, module provided by FastAPI to retrieve
    the OpenAPI schema of the Swagger UI in a `dict` object as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您可以使用FastAPI提供的`utils`模块，以以下方式在`dict`对象中检索Swagger UI的OpenAPI模式：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: That’s all you need to customize your API documentation.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要自定义API文档的所有内容。
- en: If you spin up the server with the `uvicorn main:app` command and go to one
    of the two documentation pages, the `/token` endpoint won’t appear anymore.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`uvicorn main:app`命令启动服务器并访问两个文档页面之一，`/token`端点将不再出现。
- en: You are now able to customize your API documentation to elevate the way you
    present it to your customers.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以自定义API文档，以提升您向客户展示的方式。
- en: See also
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'You find out more about FastAPI generation for metadata, features, and OpenAPI
    integration on the official documentation pages:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档页面上了解更多关于FastAPI生成元数据、特性和OpenAPI集成的信息：
- en: '*Metadata and Docs* *URLs*: [https://fastapi.tiangolo.com/tutorial/metadata/](https://fastapi.tiangolo.com/tutorial/metadata/)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*元数据和文档* *URLs*: [https://fastapi.tiangolo.com/tutorial/metadata/](https://fastapi.tiangolo.com/tutorial/metadata/)'
- en: '*FastAPI* *Features*: [https://fastapi.tiangolo.com/features/](https://fastapi.tiangolo.com/features/)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*FastAPI* *特性*: [https://fastapi.tiangolo.com/features/](https://fastapi.tiangolo.com/features/)'
- en: '*Extending* *OpenAPI*: [https://fastapi.tiangolo.com/how-to/extending-openapi/](https://fastapi.tiangolo.com/how-to/extending-openapi/)'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*扩展* *OpenAPI*: [https://fastapi.tiangolo.com/how-to/extending-openapi/](https://fastapi.tiangolo.com/how-to/extending-openapi/)'
