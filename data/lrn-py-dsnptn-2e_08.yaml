- en: Chapter 8. The Template Method Pattern – Encapsulating Algorithm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 模板方法模式 – 封装算法
- en: In the previous chapter, we started with an introduction to the Command design
    pattern in which an object is used to encapsulate all the information needed to
    perform an action or trigger an event at a later time. We understood the concept
    of the Command design pattern with a UML diagram and also saw how it's applied
    in the real world with the help of the Python implementation. We discussed the
    pros and cons of Command patterns, explored more in the FAQ section, and summarized
    the discussion at the end of the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从一个介绍命令设计模式开始，其中使用一个对象来封装执行动作或触发事件所需的所有信息。我们通过UML图理解了命令设计模式的概念，并看到了如何通过Python实现将其应用于现实世界。我们讨论了命令模式的优缺点，在常见问题解答部分进行了更深入的探讨，并在章节末尾总结了讨论。
- en: In this chapter, we will talk about the Template design pattern, such as the
    Command pattern and Template pattern that falls under the hood of Behavioral patterns.
    We will get introduced to the Template design pattern and discuss how it is used
    in software application development. We will also work with a sample use case
    and implement it in Python v3.5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论模板设计模式，例如命令模式和属于行为模式之下的模板模式。我们将介绍模板设计模式，并讨论它在软件开发中的应用。我们还将处理一个示例用例，并在Python
    v3.5中实现它。
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下主题：
- en: An introduction to the Template Method design pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法设计模式的介绍
- en: The Template pattern and its UML diagram
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式及其UML图
- en: A real-world use case with the Python v3.5 code implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有Python v3.5代码实现的现实世界用例
- en: The Template pattern – pros and cons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式 – 优点和缺点
- en: The Hollywood principle, Template Method, and Template hook
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 好莱坞原则、模板方法和模板钩子
- en: Frequently asked questions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: At the end of this chapter, you will be able to analyze situations where the
    Template design pattern is applicable and efficiently use them to solve design-related
    problems. We will also summarize the entire discussion on the Template Method
    pattern as a takeaway.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将能够分析适用于模板设计模式的情况，并有效地使用它们来解决与设计相关的问题。我们还将总结关于模板方法模式的整个讨论作为总结。
- en: Defining the Template Method pattern
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模板方法模式
- en: As we saw in the previous chapter, Behavioral patterns focus on the responsibilities
    that an object has. It deals with the interaction among objects to achieve larger
    functionality. The Template Method pattern is a behavioral design pattern that
    defines the program skeleton or an algorithm in a method called the Template Method.
    For example, you could define the steps to prepare a beverage as an algorithm
    in a Template Method. The Template Method pattern also helps redefine or customize
    certain steps of the algorithm by deferring the implementation of some of these
    steps to subclasses. This means that the subclasses can redefine their own behavior.
    For example, in this case, subclasses can implement steps to prepare tea using
    the Template Method to prepare a beverage. It is important to note that the change
    in the steps (as done by the subclasses) don't impact the original algorithm's
    structure. Thus, the facility of overriding by subclasses in the Template Method
    pattern allows the creation of different behaviors or algorithms.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，行为模式关注对象所具有的职责。它处理对象之间的交互以实现更大的功能。模板方法模式是一种行为设计模式，它在一个称为模板方法的方法中定义了程序的骨架或算法。例如，你可以将准备饮料的步骤定义为一个模板方法中的算法。模板方法模式还通过将某些步骤的实现推迟到子类中来帮助重新定义或定制算法的某些步骤。这意味着子类可以重新定义它们自己的行为。例如，在这种情况下，子类可以使用模板方法来准备饮料，实现准备茶的步骤。需要注意的是，步骤的变化（由子类执行）不会影响原始算法的结构。因此，模板方法模式中子类覆盖的功能允许创建不同的行为或算法。
- en: To talk about the Template Method pattern in software development terminology,
    an abstract class is used to define the steps of the algorithm. These steps are
    also known as *primitive operations* in the context of the Template Method pattern.
    These steps are defined with abstract methods, and the Template Method defines
    the algorithm. The `ConcreteClass` (that subclasses the abstract class) implements
    subclass-specific steps of the algorithm.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要用软件开发术语来谈论模板方法模式，抽象类用于定义算法的步骤。这些步骤也被称为模板方法模式中的*原始操作*。这些步骤通过抽象方法定义，模板方法定义算法。`ConcreteClass`（继承自抽象类）实现了算法的子类特定步骤。
- en: 'The Template Method pattern is used in the following cases:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式在以下情况下使用：
- en: When multiple algorithms or classes implement similar or identical logic
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个算法或类实现类似或相同的逻辑时。
- en: The implementation of algorithms in subclasses helps reduce code duplication
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子类中实现算法有助于减少代码重复。
- en: Multiple algorithms can be defined by letting the subclasses implement the behavior
    through overriding
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过让子类通过覆盖实现行为，可以定义多个算法。
- en: 'Let''s understand the pattern with a very simple day-to-day example. Think
    of what all you do when you prepare tea or coffee. In the case of coffee, you
    perform the following steps to prepare the beverage:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常简单的日常例子来理解这个模式。想想你准备茶或咖啡时都做了些什么。在咖啡的情况下，你执行以下步骤来准备饮料：
- en: Boil water.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 煮水。
- en: Brew coffee beans.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 煮咖啡豆。
- en: Pour it in the coffee cup.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在咖啡杯中倒。
- en: Add sugar and milk to the cup.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在杯子中加入糖和牛奶。
- en: Stir, and the coffee is done.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搅拌，咖啡就煮好了。
- en: 'Now, if you want to prepare a cup of tea, you will perform the following steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你想泡一杯茶，你需要执行以下步骤：
- en: Boil water.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 煮水。
- en: Steep the tea bag.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浸泡茶包。
- en: Pour the tea in a cup.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在杯子中倒茶。
- en: Add lemon to the tea.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在茶中加柠檬。
- en: Stir, and the tea is done.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搅拌，茶就煮好了。
- en: If you analyze both the preparations, you will find that both the procedures
    are more or less the same. In this case, we can use the Template Method pattern
    effectively. How do we implement it? We define a `Beverage` class that has abstract
    methods common to preparing tea and coffee, such as `boilWater()`. We also define
    the `preparation()` Template Method that will call out the sequence of steps in
    preparing the beverage (the algorithm). We let the concrete classes, `PrepareCoffee`
    and `PrepareTea`, define the customized steps to achieve the goals of preparing
    coffee and tea. This is how the Template Method pattern avoids code duplication.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你分析这两种准备方法，你会发现两种程序或多或少是相同的。在这种情况下，我们可以有效地使用模板方法模式。我们如何实现它？我们定义一个`Beverage`类，它具有准备茶和咖啡的通用抽象方法，例如`boilWater()`。我们还定义了`preparation()`模板方法，它将调用准备饮料（算法）的步骤序列。我们让具体的类`PrepareCoffee`和`PrepareTea`定义定制步骤以实现准备咖啡和茶的目标。这就是模板方法模式如何避免代码重复。
- en: 'Another easy example is that of the compiler used by computer languages. A
    compiler essentially does two things: collects the source and compiles to the
    target object. Now, if we need to define a cross compiler for iOS devices, we
    can implement this with the help of the Template Method pattern. We will read
    about this example in detail later in the chapter.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的例子是计算机语言使用的编译器。编译器本质上做两件事：收集源代码并将其编译为目标对象。现在，如果我们需要为iOS设备定义一个交叉编译器，我们可以借助模板方法模式来实现。我们将在本章后面详细讨论这个例子。
- en: Understanding the Template Method design pattern
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解模板方法设计模式。
- en: 'In short, the main intentions of the Template Method pattern are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，模板方法模式的主要意图如下：
- en: Defining a skeleton of an algorithm with primitive operations
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义算法的骨架，使用原始操作。
- en: Redefining certain operations of the subclass without changing the algorithm's
    structure
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义子类的某些操作而不改变算法的结构。
- en: Achieving code reuse and avoiding duplicate efforts
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现代码重用，避免重复劳动。
- en: Leveraging common interfaces or implementations
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用公共接口或实现。
- en: 'The Template Method pattern works with the following terms—`AbstractClass`,
    `ConcreteClass`, Template Method, and `Client`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式与以下术语一起使用—`AbstractClass`、`ConcreteClass`、模板方法和`Client`：
- en: '`AbstractClass`: This declares an interface to define the steps of the algorithm'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractClass`：这声明了一个接口来定义算法的步骤。'
- en: '`ConcreteClass`: This defines subclass-specific step definitions'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteClass`：这定义了子类特定的步骤定义。'
- en: '`template_method()`: This defines the algorithm by calling the step methods'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template_method()`：这通过调用步骤方法来定义算法。'
- en: We talked about the example of a compiler earlier in the chapter. Consider that
    we want to develop our own cross compiler for an iOS device and run the program.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在章节中早些时候讨论了编译器的例子。假设我们想要为iOS设备开发自己的交叉编译器并运行程序。
- en: We first develop an abstract class (compiler) that defines the algorithm of
    a compiler. The operations done by the compiler are collecting the source of the
    code written in a program language and then compiling it to get the object code
    (binary format). We define these steps as the `collectSource()` and `compileToObject()`
    abstract methods and also define the `run()` method that is responsible for executing
    the program. The algorithm is defined by the `compileAndRun()` method, which internally
    calls the `collectSource()`, `compileToObject()`, and `run()` methods to define
    the algorithm of the compiler. The `iOSCompiler` concrete class now implements
    the abstract methods and compiles/runs the Swift code on the iOS device.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先开发一个抽象类（编译器），该类定义了编译器的算法。编译器执行的操作是收集程序语言中编写的代码源，并将其编译成目标代码（二进制格式）。我们定义这些步骤为`collectSource()`和`compileToObject()`抽象方法，并定义了负责执行程序的`run()`方法。算法由`compileAndRun()`方法定义，该方法内部调用`collectSource()`、`compileToObject()`和`run()`方法来定义编译器的算法。`iOSCompiler`具体类现在实现了抽象方法，并在iOS设备上编译/运行Swift代码。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Swift programming language is used to develop applications on the iOS platform.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 编程语言用于在iOS平台上开发应用程序。
- en: 'The following Python code implements the Template Method design pattern:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Python代码实现了模板方法设计模式：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code should look as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应如下所示：
- en: '![Understanding the Template Method design pattern](img/00026.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![理解模板方法设计模式](img/00026.jpeg)'
- en: A UML class diagram for the Template Method pattern
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板方法模式的 UML 类图
- en: Let's understand more about the Template method pattern with the help of a UML
    diagram.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助UML图来更深入地了解模板方法模式。
- en: 'As we discussed in the previous section, the Template method pattern has the
    following main participants: the abstract class, concrete class, Template method,
    and client. Let''s put these in a UML diagram and see how the classes look:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，模板方法模式有以下主要参与者：抽象类、具体类、模板方法和客户端。让我们将这些放入UML图中，看看类是如何看起来：
- en: '![A UML class diagram for the Template Method pattern](img/00027.jpeg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法模式的 UML 类图](img/00027.jpeg)'
- en: 'As we look at the UML diagram, you''ll realize that there are four main participants
    in this pattern:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 UML 图时，你会意识到这个模式中有四个主要参与者：
- en: '`AbstractClass`: This defines the operations or steps of an algorithm with
    the help of abstract methods. These steps are overridden by concrete subclasses.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AbstractClass`: 它使用抽象方法定义算法的操作或步骤。这些步骤被具体子类覆盖。'
- en: '`template_method()`: This defines the skeleton of the algorithm. Multiple steps
    as defined by abstract methods are called in the Template method to define the
    sequence or the algorithm itself.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`template_method()`: 这定义了算法的骨架。模板方法中调用由抽象方法定义的多个步骤，以定义序列或算法本身。'
- en: '`ConcreteClass`: This implements the steps (as defined by the abstract methods)
    to perform subclass-specific steps of the algorithm.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteClass`: 它实现了步骤（由抽象方法定义），以执行算法的子类特定步骤。'
- en: 'The following is a code example to understand the pattern with all the participants
    involved:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例，以了解所有参与者都参与的模板方法设计模式：
- en: '[PRE1]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the preceding code should look as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应如下所示：
- en: '![A UML class diagram for the Template Method pattern](img/00028.jpeg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![模板方法模式的 UML 类图](img/00028.jpeg)'
- en: The Template Method pattern in the real world
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式在现实世界中的应用
- en: Let's take a very easy-to-understand scenario to implement the Template method
    pattern. Imagine the case of a travel agency, say, Dev Travels. Now how do they
    typically work? They define various trips to various locations and come up with
    a holiday package for you. A package is essentially a trip that you, as a customer,
    undertakes. A trip has details such as the places visited, transportation used,
    and other factors that define the trip itinerary. This same trip can be customized
    differently based on the needs of the customers. This calls for the Template Method
    pattern, doesn't it?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个非常容易理解的场景来实现模板方法模式。想象一下旅行社的情况，比如Dev Travels。现在他们是怎样典型工作的呢？他们定义了去往不同地点的各种旅行，并为您提供假日套餐。套餐本质上是你作为客户所承担的旅行。旅行有诸如访问的地点、使用的交通方式以及其他定义旅行行程的因素。根据客户的需求，这个旅行可以有不同的定制。这不就是模板方法模式的需求吗？
- en: 'Design Considerations:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 设计考虑因素：
- en: For the preceding scenario, based on the UML diagram, we should create an `AbstractClass`
    interface that defines a trip
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于前面的场景，根据UML图，我们应该创建一个定义旅行的`AbstractClass`接口
- en: The trip should contain multiple abstract methods that define the transportation
    used, places visited on `day1`, `day2`, and `day3`, assuming that it's a three-day
    long weekend trip, and also define the return journey
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旅行应包含多个抽象方法，用于定义所使用的交通方式、`day1`、`day2`和`day3`期间访问的地点，假设这是一个为期三天的周末之旅，并定义返程
- en: The `itinerary()` Template Method will actually define the trip's itinerary
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itinerary()`模板方法实际上定义了旅行的行程'
- en: We should define `ConcreteClasses` that would help us customize trips differently
    based on the customer's needs
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们应该定义`ConcreteClasses`，这样我们就可以根据客户的需求定制不同的旅行
- en: 'Let''s develop an application in Python v3.5 and implement the preceding use
    case. We start with the abstract class, `Trip`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python 3.5中开发一个应用程序并实现前面的用例。我们从一个抽象类`Trip`开始：
- en: The abstract object is represented by the `Trip` class. It is an interface (Python's
    abstract base class) that defines the details such as the transportation used
    and places to visit on different days.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象对象由`Trip`类表示。它是一个接口（Python的抽象基类），定义了诸如使用的交通方式和不同日期要访问的地点等细节。
- en: The `setTransport` is an abstract method that should be implemented by `ConcreteClass`
    to set the mode of transportation.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setTransport`是一个抽象方法，应由`ConcreteClass`实现以设置交通方式。'
- en: The `day1()`, `day2()`, `day3()` abstract methods define the places visited
    on the given day.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day1()`、`day2()`、`day3()`抽象方法定义了给定日期访问的地点。'
- en: The `itinerary()` Template Method creates the complete itinerary (the algorithm,
    in this case, the trip). The sequence of the trip is to first define the transportation
    mode, then the places to visit on each day, and the `returnHome`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itinerary()`模板方法创建完整的行程（在这种情况下，即旅行）。旅行的顺序是首先定义交通方式，然后是每天要访问的地点，以及`returnHome`。'
- en: 'The following code implements the scenario of Dev Travels:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码实现了Dev Travels的场景：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have also developed certain classes that represent the concrete class:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还开发了一些代表具体类的类：
- en: In this case, we have two main concrete classes—`VeniceTrip` and `MaldivesTrip`—that
    implement the `Trip` interface
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个主要的实体类—`VeniceTrip`和`MaldivesTrip`—它们实现了`Trip`接口
- en: Concrete classes represent two different trips taken by the tourists based on
    their choice and interests
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具体类代表游客根据他们的选择和兴趣所采取的两种不同的旅行
- en: '`VeniceTrip` and `MaldivesTrip` both implement `setTransport()`, `day1()`,
    `day2()`, `day3()`, and `returnHome()`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VeniceTrip`和`MaldivesTrip`都实现了`setTransport()`、`day1()`、`day2()`、`day3()`和`returnHome()`'
- en: 'Let''s define the concrete classes in Python code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python代码中定义具体的类：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s talk about the travel agency and tourists who want to have an awesome
    vacation:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈旅行社和想要度过美好假期的游客：
- en: The `TravelAgency` class represents the `Client` object in this example
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TravelAgency`类代表本例中的`Client`对象'
- en: It defines the `arrange_trip()` method that provides customers with the choice
    of whether they want to have a historical trip or beach trip
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了`arrange_trip()`方法，为顾客提供选择是否想要历史之旅或海滩之旅的选项
- en: Based on the choice made by the tourist, an appropriate class is instantiated
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据游客的选择，实例化一个适当的类
- en: This object then calls the `itinerary()` Template Method and the trip is arranged
    for the tourists as per the choice of the customers
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此对象随后调用`itinerary()`模板方法，并根据客户的选择为游客安排旅行
- en: 'The following is the implementation for the Dev travel agency and how they
    arrange for the trip based on the customer''s choice:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对Dev旅行社的实现以及他们如何根据客户的选择安排旅行的示例：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code should look as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出应如下所示：
- en: '![The Template Method pattern in the real world](img/00029.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界中的模板方法模式](img/00029.jpeg)'
- en: 'If you decide to go on a historical trip, this will be the output of the code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定进行一次历史之旅，这将产生以下代码输出：
- en: '![The Template Method pattern in the real world](img/00030.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![现实世界中的模板方法模式](img/00030.jpeg)'
- en: The Template Method pattern – hooks
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式 – 钩子
- en: A hook is a method that is declared in the abstract class. It is generally given
    a default implementation. The idea behind hooks is to give a subclass the ability
    to *hook into* the algorithm whenever needed. It's not imperative for the subclass
    to use hooks and it can easily ignore this.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子是在抽象类中声明的方法。它通常有一个默认实现。钩子的理念是给予子类在需要时将自身钩入算法的能力。子类使用钩子不是强制的，并且可以轻松忽略它。
- en: For example, in the beverage example, we can add a simple hook to see if condiments
    need to be served along with tea or coffee based on the wish of the customer.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在饮料示例中，我们可以添加一个简单的钩子，根据客户的愿望查看是否需要提供茶或咖啡以及调料。
- en: Another example of hook can be in the case of the travel agency example. Now,
    if we have a few elderly tourists, they may not want to go out on all three days
    of the trip as they may get tired easily. In this case, we can develop a hook
    that will ensure `day2` is lightly loaded, which means that they can go to a few
    nearby places and be back with the plan of `day3`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个钩子的例子可以在旅行社示例中。现在，如果我们有一些老年游客，他们可能不想在旅行的三天中都外出，因为他们可能容易感到疲劳。在这种情况下，我们可以开发一个钩子，确保`day2`的行程较轻松，这意味着他们可以去一些附近的地方，并在`day3`的计划中返回。
- en: Basically, we use abstract methods when the subclass must provide the implementation,
    and hook is used when it is optional for the subclass to implement it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，当我们需要子类提供实现时，我们使用抽象方法，而当子类实现它是可选的时候，我们使用钩子。
- en: The Hollywood principle and the Template Method
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 好莱坞原则和模板方法
- en: The Hollywood principle is the design principle that is summarized by *Don't
    call us, we'll call you*. It comes from the Hollywood philosophy where the production
    houses call actors if there is any role for the actor.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 好莱坞原则是总结为*别给我们打电话，我们会给你打电话*的设计原则。它源自好莱坞哲学，即制片厂在演员有角色时才会给演员打电话。
- en: In the object-oriented world, we allow low-level components to hook themselves
    into the system with the Hollywood principle. However, the high-level components
    determine how the low-level systems are needed and when they are needed. In other
    words, high-level components treat low-level components as *Don't call us, we'll
    call you*.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的世界中，我们允许低级组件使用好莱坞原则将自己钩接到系统中。然而，高级组件决定低级系统何时以及需要什么。换句话说，高级组件将低级组件视为*别给我们打电话，我们会给你打电话*。
- en: This relates to the Template Method pattern in the sense that it's the high-level
    abstract class that arranges the steps to define the algorithm. Based on how the
    algorithm is, low-level classes are called on to define the concrete implementation
    for the steps.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这与模板方法模式相关，因为它是高级抽象类安排步骤以定义算法。根据算法的实际情况，低级类被调用以定义步骤的具体实现。
- en: The advantages and disadvantages of the Template Method pattern
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板方法模式的优势和缺点
- en: 'The Template Method pattern provides you with the following advantages:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式为你提供了以下优势：
- en: As we saw earlier in the chapter, there is no code duplication.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，没有代码重复。
- en: Code reuse happens with the Template Method pattern as it uses inheritance and
    not composition. Only a few methods need to be overridden.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法模式通过使用继承而不是组合来实现代码复用。只需要重写少数几个方法。
- en: Flexibility lets subclasses decide how to implement steps in an algorithm.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灵活性允许子类决定如何实现算法中的步骤。
- en: 'The disadvantages of Template Method patterns are as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法模式的缺点如下：
- en: Debugging and understanding the sequence of flow in the Template Method pattern
    can be confusing at times. You may end up implementing a method that shouldn't
    be implemented or not implementing an abstract method at all. Documentation and
    strict error handling has to be done by the programmer.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些时候，调试和理解模板方法模式中的流程顺序可能会令人困惑。您可能会实现一个不应该实现的方法，或者根本不实现一个抽象方法。文档和严格的错误处理必须由程序员来完成。
- en: Maintenance of the template framework can be a problem as changes at any level
    (low-level or high-level) can disturb the implementation. Hence, maintenance can
    be painful with the Template Method pattern.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板框架的维护可能是一个问题，因为任何级别的更改（低级或高级）都可能干扰实现。因此，使用模板方法模式进行维护可能会很痛苦。
- en: Frequently asked questions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Q1\. Should a low-level component be disallowed from calling a method in a higher-level
    component?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 是否应该禁止低级组件调用高级组件中的方法？
- en: 'A: No, a low-level component would definitely call the higher-level component
    through inheritance. However, what the programmer needs to make sure is that there
    is no circular dependency where the low-level and high-level components are dependent
    on each other.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 不，低级组件肯定会通过继承调用高级组件。然而，程序员需要确保没有循环依赖，即低级组件和高级组件相互依赖。'
- en: Q2\. Isn't the strategy pattern similar to the Template pattern?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 策略模式不类似于模板模式吗？
- en: 'A: The strategy pattern and Template pattern both encapsulate algorithms. Template
    depends on inheritance while strategy uses composition. The Template Method pattern
    is a compile-time algorithm selection by sub-classing while the strategy pattern
    is a runtime selection.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 策略模式和模板模式都封装了算法。模板模式依赖于继承，而策略模式使用组合。模板方法模式是通过子类化进行编译时算法选择，而策略模式是运行时选择。'
- en: Summary
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began the chapter by understanding the Template Method design pattern and
    how it is effectively used in software architecture.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解模板方法设计模式及其在软件架构中的有效应用开始本章。
- en: We also looked at how the Template Method design pattern is used to encapsulate
    the algorithm and provide the flexibility of implementing different behavior by
    overriding the methods in the subclasses.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用模板方法设计模式来封装算法，并通过覆盖子类中的方法提供实现不同行为的灵活性。
- en: You learned the pattern with a UML diagram and sample code implementation in
    Python v3.5 along with the explanation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过UML图和Python v3.5的示例代码实现以及解释学习了该模式。
- en: We also covered a section on FAQs that would help you get a better idea of the
    pattern and its possible advantages/disadvantages.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了一个关于常见问题解答的部分，这将帮助您更好地了解该模式和它的可能优点/缺点。
- en: We will now talk about a composite pattern in the next chapter—the MVC design
    pattern.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章讨论组合模式——MVC设计模式。
