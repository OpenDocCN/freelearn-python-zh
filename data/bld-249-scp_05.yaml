- en: Chapter 5. Acting on Frame Changes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。对帧变化进行操作
- en: Besides the many places we have encountered where Python can be used in Blender,
    we will now look at scripts that may be used to act on certain events. These scripts
    come in two flavors—**script links** and **space** **handlers**.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在Blender中遇到的所有可以使用Python的地方，我们现在将查看可能用于对某些事件进行操作的脚本。这些脚本有两种类型——**脚本链接**和**空间处理器**。
- en: '**Script links** are scripts that may be associated with Blender objects (`Meshes`,
    `Cameras`, and so on, but also `Scenes` and `World` objects) and that can be set
    up to run automatically on the following occasions:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本链接**是与Blender对象（`网格`、`摄像机`等，但还包括`场景`和`世界`对象）关联的脚本，并且可以设置在以下情况下自动运行：'
- en: Just before rendering a frame
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染帧之前
- en: Just after rendering a frame
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在渲染帧之后
- en: When a frame is changed
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当帧发生变化时
- en: When an object is updated
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象被更新时
- en: When the object data is updated
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象数据被更新时
- en: 'Scene objects may have script links associated with them that may be invoked
    on two additional occasions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 场景对象可能与其关联脚本链接，这些链接可能在以下两种情况下被调用：
- en: On loading a `.blend` file
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在加载`.blend`文件时
- en: On saving a `.blend` file
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存`.blend`文件时
- en: Space handlers are Python scripts that are invoked each time the 3D view window
    is redrawn or a key or mouse action is detected. Their primary use is to extend
    the capabilities of Blender's user interface.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 空间处理器是Python脚本，每次3D视图窗口重绘或检测到按键或鼠标动作时都会被调用。它们的主要用途是扩展Blender用户界面的功能。
- en: 'In this chapter, you will learn:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: What script links and space handlers are
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本链接和空间处理器是什么
- en: How to perform activities on each frame change in an animation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在动画的每一帧变化上执行活动
- en: How to associate additional information with an object
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将附加信息与对象关联
- en: How to make an object appear or disappear by changing its layout or changing
    its transparency
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过改变布局或改变透明度使对象出现或消失
- en: How to implement a scheme to associate a different mesh with an object on each
    frame
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一种方案，在每个帧上为对象关联不同的网格
- en: How to augment the functionality of the 3D View
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增强3D视图的功能
- en: Animating the visibility of objects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象的可见性动画
- en: An often recurring issue in making an animation is the wish to make an object
    disappear or fade away at a certain frame, either for the sake of the effect itself
    or to replace the object by another one to achieve some dramatic impact (such
    as an explosion or a bunny rabbit changing into a ball).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 制作动画时经常遇到的一个问题是希望在某个帧使对象消失或淡出，要么是为了效果本身，要么是为了用另一个对象替换它以达到某种戏剧性的影响（如爆炸或兔子变成球）。
- en: There are many ways to engineer these effects, and most of them are not specifically
    tied to script links reacting on a frame change (many can simply be keyed as well).
    Nevertheless, we will look at two techniques that may easily be adapted to all
    sorts of situations, even ones that are not easily keyed. For example, we demand
    some specific behavior of a parameter that is easy to formulate in an expression
    but awkward to catch in an IPO.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方法可以构建这些效果，其中大多数并不是专门针对脚本链接在帧变化时做出反应的（许多可以简单地键入）。尽管如此，我们将查看两种可以轻松适应各种情况的技术，甚至包括那些不易键入的情况。例如，我们要求某个参数具有某种特定的行为，这在表达式中很容易制定，但在IPO中却难以捕捉。
- en: Fading a material
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渐变材料
- en: Our first example will change the **diffuse** **color** of a material. It would
    be just as simple to change the transparency, but it is easier to see changes
    in diffuse color in illustrations.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个例子将改变材料的**漫反射****颜色**。改变透明度同样简单，但通过插图更容易看到漫反射颜色的变化。
- en: Our goal is to fade the diffuse color from black to white and back again, spaced
    over a period of two seconds. We therefore define a function `setcolor()` that
    takes a material and changes its diffuse color (the `rgbColor` attribute). It
    assumes a frame rate of 25 frames per second and, therefore, the first line fetches
    the current frame number and performs a *modulo* operation to determine what fraction
    of the current whole second is elapsed.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是将漫反射颜色从黑色渐变到白色，然后再返回黑色，整个过程持续两秒钟。因此，我们定义了一个名为`setcolor()`的函数，它接受一个材料并改变其漫反射颜色（`rgbColor`属性）。它假设每秒25帧的帧率，因此第一行获取当前帧号并执行一个*模除*操作以确定当前整个秒中已经过去的时间比例。
- en: 'The highlighted line in the following code snippet determines whether we are
    in an odd or even second. If we are in an even second, we ramp up the diffuse
    color to white so we just keep our computed fraction. If we are in an odd second,
    we tone down the diffuse color to black so we subtract the fraction from the maximum
    possible value (`25`). Finally, we scale our value to lie between `0` and `1`
    and assign it to all three color components to obtain a shade of gray:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码片段中，高亮行用于确定我们是否处于奇数或偶数秒。如果我们处于偶数秒，我们将漫反射颜色提升至白色，这样我们只需保留计算出的分数。如果我们处于奇数秒，我们将漫反射颜色降低至黑色，这样我们就从最大可能值（`25`）中减去分数。最后，我们将我们的值缩放到`0`到`1`之间，并将其分配给所有三个颜色分量，以获得一种灰色：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The script ends with an important check: `Blender.bylink` is `True` only if
    this script is called as a script handler and in that case `Blender.event` holds
    the event type. We only want to act on frame changes so that is what we check
    for here. If these conditions are satisfied, we pass `Blender.link` to our `setcolor()`
    function as it holds the object our `scriptlink` script is associated with—in
    this case that will be a `Material` object. (This script is available as `MaterialScriptLink.py`
    in `scriptlinks.blend`.)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本以一个重要的检查结束：`Blender.bylink`仅在作为脚本处理程序调用此脚本时为`True`，在这种情况下`Blender.event`包含事件类型。我们只想对帧变化采取行动，因此这就是我们在这里检查的内容。如果这些条件得到满足，我们将`Blender.link`传递给我们的`setcolor()`函数，因为它包含我们的`scriptlink`脚本关联的对象——在这种情况下，那将是一个`Material`对象。（此脚本作为`scriptlinks.blend`中的`MaterialScriptLink.py`提供。）
- en: The next thing on our list is to associate the script with the object whose
    material we want to change. We therefore select the object and in the **Buttons**
    **Window** we select the **Script** **panel**. In the **Scriptlinks** tab, we
    enable script links and select the **MaterialScriptLinks** button. (If there is
    no **MaterialScriptLinks** button then the selected object has no material assigned
    to it. Make sure it has.) There should now be a label **Select** **Script** **link**
    visible with a **New** button. Clicking on **New** will show a dropdown with available
    script links (files in the text editor). In this case, we will select `MaterialScriptLink.py`
    and we are done. We can now test our script link by changing the frame in the
    3D view (with the arrow keys). The color of our object should change with the
    changing frame number. (If the color doesn't seem to change, check whether solid
    or shaded viewing is on in the 3D view.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要做的事情是将脚本与我们要更改材质的对象关联起来。因此，我们选择该对象，在**按钮** **窗口**中，我们选择**脚本** **面板**。在**脚本链接**选项卡中，我们启用脚本链接并选择**材质脚本链接**按钮。（如果不存在**材质脚本链接**按钮，则所选对象没有分配任何材质。请确保它有。）现在应该有一个带有**新**按钮的标签**选择**
    **脚本** **链接**可见。点击**新**将显示一个下拉菜单，其中包含可用的脚本链接（文本编辑器中的文件）。在这种情况下，我们将选择`MaterialScriptLink.py`，我们就完成了。现在我们可以通过在3D视图中更改帧（使用箭头键）来测试我们的脚本链接。我们的对象颜色应该随着帧号的改变而改变。（如果颜色似乎没有改变，请检查3D视图中是否启用了实体或着色视图。）
- en: '![Fading a material](img/0400-05-01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![渐变材质](img/0400-05-01.jpg)'
- en: Changing layers
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变层
- en: If we want to change the **visibility** of an object, changing the layer(s)
    it is assigned to is a more general and powerful technique than changing material
    properties. Changing its assigned layer has, for instance, the advantage that
    we can make the object completely invisible for lamps that are configured to illuminate
    only certain layers and many aspects of an animation (for example, deflection
    of particles by force fields) may be limited to certain layers as well. Also,
    changing layers is not limited to objects with associated materials. You can just
    as easily change the layer of a `Lamp` or `Camera`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想改变一个对象的**可见性**，改变它所分配的层是一个比改变材质属性更通用且强大的技术。例如，改变其分配的层有这样一个优点：我们可以使对象对于配置为仅照亮某些层的灯具完全不可见，以及动画的许多方面（例如，粒子被力场偏转）也可能仅限于某些层。此外，改变层不仅限于具有相关材质的对象。我们同样可以轻松地改变`Lamp`或`Camera`的层。
- en: For our next example, we want to assign an object to layer 1 if the number of
    elapsed seconds is even and to layer 2 if the number of seconds is odd. The script
    to implement this is very similar to our material changing script. The real work
    is done by the function `setlayer()`. The first line calculates the layer the
    object should be on in the current frame and the next line (highlighted) assigns
    the list of layer indices (consisting of a single layer in this case) to the `layers`
    attribute of the object. The final two lines of the `setlayer()` function ensure
    that the layer's change is actually visible in Blender.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的下一个示例，我们希望如果经过的秒数是偶数，就将对象分配到层1，如果是奇数，就分配到层2。实现这个功能的脚本与我们更改材质的脚本非常相似。实际的工作是由`setlayer()`函数完成的。第一行计算对象在当前帧应该位于的层，下一行（突出显示）将包含单个层的层索引列表分配给对象的`layers`属性。`setlayer()`函数的最后两行确保层的更改在Blender中实际上是可见的。
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As in our previous script, the final lines of our script check whether we are
    called as a script link and on a frame change event, and if so, pass the associated
    object to the `setlayer()` function. (The script is available as `OddEvenScriptlink.py`
    in `scriptlinks.blend`.)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如同我们之前的脚本，我们脚本的最后几行检查我们是否作为脚本链接被调用，并且在一个帧改变事件发生时，如果是这样，就将相关对象传递给`setlayer()`函数。（脚本作为`OddEvenScriptlink.py`文件位于`scriptlinks.blend`中。）
- en: All that is left to do is to assign the script as a `scriptlink` to a selected
    object. Again, this is accomplished in the **Buttons** **Window** | **Script**
    **panel** by clicking on **Enabling** **Script** **Links** in the **Scriptlinks**
    tab (if necessary, it might still be selected because of our previous example.
    It is a global choice, that is, it is enabled or disabled for all objects). This
    time, we select the object `scriptlinks` instead of the material `scriptlinks`
    and click on **New** to select `OddEvenScriptlink.py` from the dropdown.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是将脚本作为`scriptlink`分配给选定的对象。同样，这通过在**按钮** **窗口** | **脚本** **面板**中点击**启用**
    **脚本** **链接**在**脚本链接**选项卡（如果需要，可能仍然被选中，因为我们之前的示例。这是一个全局选择，即它对所有对象都是启用的或禁用的）。这次，我们选择对象`scriptlinks`而不是材质`scriptlinks`，并点击**新建**从下拉菜单中选择`OddEvenScriptlink.py`。
- en: Countdown—animating a timer with script links
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 倒计时——使用脚本链接动画计时器
- en: One of the possibilities of using a script link that acts on frame changes is
    the ability to modify the actual mesh either by changing the vertices of a `Mesh`
    object or by associating a completely different mesh with a Blender object. This
    is not possible when using IPOs as these are limited to shape keys that interpolate
    between predefined shapes with the same mesh topology (the same number of vertices
    connected in the same way). The same is true for curves and text objects.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作用于帧改变的脚本链接的一种可能性是能够通过改变`Mesh`对象的顶点或与Blender对象关联一个完全不同的网格来修改实际的网格。当使用IPOs时这是不可能的，因为这些仅限于在具有相同网格拓扑（以相同方式连接相同数量的顶点）的预定义形状之间进行插值的形状键。对于曲线和文本对象也是如此。
- en: One application of that technique is to implement a `counter` object that will
    display the number of seconds since the start of the animation. This is accomplished
    by changing the text of a `Text3d` object by way of its `setText()` method. The
    `setcounter()` function in the following code does exactly that together with
    the necessary actions to update Blender's display. (The script is available as
    `CounterScriptLink.py` in `scriptlinks.blend`.)
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 该技术的应用之一是实现一个`counter`对象，它将显示动画开始以来的秒数。这是通过通过其`setText()`方法更改`Text3d`对象的文本来实现的。以下代码中的`setcounter()`函数正是这样做的，同时执行必要的操作来更新Blender的显示。（脚本作为`CounterScriptLink.py`文件位于`scriptlinks.blend`中。）
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This script may be associated as a script link with any `Text3d` object as shown
    before. However, if run with *Alt* *+* *P* from the text editor it will create
    a new `Text3d` object and will associate itself to this object as a script link.
    The highlighted lines show how we check for this just like in the previous scripts,
    but in this case we take some action when not called as a script link as well
    (the `else` clause). The final two highlighted lines show how we associate the
    script with the newly created object. First, we remove (clear) any script links
    with the same name that might have been associated earlier. This is done to prevent
    associating the same script link more than once, which is valid but hardly useful.
    Next, we add the script as a script link that will be called when a frame change
    occurs. The screenshot shows the 3D view with a frame from the animation together
    with the **Buttons** **window** (top-left) that lists the association of the script
    link with the object.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本可以像之前展示的那样与任何 `Text3d` 对象关联为脚本链接。然而，如果从文本编辑器以 *Alt* *+* *P* 运行，它将创建一个新的 `Text3d`
    对象，并将其作为脚本链接与该对象关联。突出显示的行显示了如何检查这一点，就像在之前的脚本中一样，但在这个情况下，如果未作为脚本链接调用，我们也会采取一些行动（`else`
    子句）。最后两个突出显示的行显示了如何将脚本与新创建的对象关联。首先，我们删除（清除）可能之前已关联的任何具有相同名称的脚本链接。这样做是为了防止将相同的脚本链接关联多次，虽然这是有效的，但几乎没有什么用处。接下来，我们将脚本添加为脚本链接，当帧发生变化时将被调用。截图显示了包含动画帧的
    3D 视图以及列出脚本链接与对象关联的**按钮**窗口（左上角）。
- en: '![Countdown—animating a timer with script links](img/0400-05-02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![倒计时——使用脚本链接动画计时器](img/0400-05-02.jpg)'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that although it is possible to *associate* a script link with a Blender
    object from within a Python script, script links must be *enabled* manually for
    them to actually run! (In the **ScriptLinks** tab.) There is no functionality
    in the Blender Python API to do this from a script.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管在 Python 脚本内部可以将脚本链接与 Blender 对象关联，但脚本链接必须手动**启用**才能实际运行！（在 **ScriptLinks**
    选项卡中。）Blender Python API 中没有从脚本执行此操作的功能。
- en: I'll keep an eye on you
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我会关注你
- en: Sometimes, when working with a complex object, it is difficult to keep track
    of a relevant feature as it may be obscured by other parts of the geometry. In
    such a situation, it would be nice to highlight certain vertices in a way that
    keeps them visible, no matter the orientation, and independent of the *edit* mode.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，当与复杂对象一起工作时，由于可能被几何形状的其他部分遮挡，很难跟踪相关功能。在这种情况下，以保持它们无论方向如何都可见的方式突出显示某些顶点会很好，并且独立于**编辑**模式。
- en: '**Space** **handlers** provide us with a way to perform actions each time the
    3D view window is redrawn or a key or mouse action is detected. These actions
    may include drawing inside the 3D view area as well, so we will be able to add
    **highlights** at any position we like.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**空间**处理程序为我们提供了一种方式，每次 3D 视图窗口重绘或检测到键或鼠标操作时执行操作。这些操作可能还包括在 3D 视图区域内绘制，因此我们可以在任何我们喜欢的位置添加**高亮**。'
- en: How do we determine which vertices we would like to highlight? Blender already
    provides us with a uniform way to group collections of vertices as vertex groups
    so all we have to do is let the user indicate which vertex group he would like
    to highlight. We then store the name of this selected vertex group as an object
    property. Object properties are designed to be used in the game engine but there
    is no reason why we shouldn't reuse them as a way to persistently store our choice
    of vertex group.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定我们想要突出显示哪些顶点？Blender 已经为我们提供了一种统一的方式来将顶点集合分组为顶点组，所以我们只需要让用户指出他想要突出显示的顶点组即可。然后我们将所选顶点组的名称存储为对象属性。对象属性旨在在游戏引擎中使用，但没有理由我们不能将它们作为持久存储我们顶点组选择的一种方式。
- en: 'So again, we have a script that will be called in two ways: as a space handler
    (that is, each time the 3D view window is redrawn to highlight our vertices) or
    by running it from the text editor with *Alt + P* to prompt the user to choose
    a vertex group to highlight.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们再次有一个脚本，它将以两种方式被调用：作为空间处理程序（即每次重绘 3D 视图窗口以突出显示我们的顶点）或通过从文本编辑器运行它，使用 *Alt
    + P* 提示用户选择要突出显示的顶点组。
- en: 'Code outline: AuraSpaceHandler.py'
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码概述：AuraSpaceHandler.py
- en: 'The following outline shows which steps we will take in each situation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的概述显示了在每种情况下我们将采取哪些步骤：
- en: Get active object and mesh.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取活动对象和网格。
- en: 'If running standalone:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果独立运行：
- en: Get list of vertex groups
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取顶点组列表
- en: Prompt user for choice
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示用户进行选择
- en: Store choice as property of object
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将存储选择为对象的属性
- en: 'Else:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则：
- en: Get the property that holds the vertex group
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取包含顶点组的属性
- en: Get a list of vertex coordinates
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取顶点坐标列表
- en: 'For each vertex:'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个顶点：
- en: draw a small disk
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制一个小圆盘
- en: 'The resulting code is available as `AuraSpaceHandler.py` in `scriptlinks.blend`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果代码作为`AuraSpaceHandler.py`在`scriptlinks.blend`中可用：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It starts with a line of comment that is essential, as it signals to Blender
    that this is a space handler script that can be associated with the 3D view (no
    other area can have space handlers associated at present) and should be called
    on a `redraw` event.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 它以一条注释行开始，这是至关重要的，因为它向Blender发出信号，表明这是一个可以与3D视图关联的空间处理器脚本（目前其他区域不能关联空间处理器）并且应该在`redraw`事件上调用。
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The script proper then proceeds to retrieve the active object from the current
    scene and gets the object's mesh if it is a `Mesh`. At the highlighted line, we
    check if we are running as space handler and if so, we fetch the property that
    we named `Highlight`. The data of this property is the name of the vertex group
    that we want to highlight. We proceed by getting a list of all vertices in this
    vertex group and by getting the matrix of the object. We need this because vertex
    locations are stored relative to the object's matrix. We then construct a list
    of vertex locations and pass this along with the name of the vertex group to the
    `drawAuras()` function that will take care of the actual drawing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后脚本继续从当前场景中检索活动对象，如果它是`Mesh`，则获取对象的网格。在突出显示的行，我们检查是否作为空间处理器运行，如果是，则检索我们命名为`Highlight`的属性。该属性的数据是我们想要突出显示的顶点组的名称。我们接着获取该顶点组中所有顶点的列表以及对象的矩阵。我们需要这个矩阵，因为顶点位置是相对于对象的矩阵存储的。然后我们构建一个顶点位置的列表，并将这个列表以及顶点组的名称传递给`drawAuras()`函数，该函数将负责实际的绘制。
- en: The second highlighted line marks the beginning of the code that will be executed
    when we run the script from the text editor. It creates a string consisting of
    the names of all vertex groups associated with the active object separated by
    pipe characters (`|`) and prepended by a suitable title. This string is passed
    to `PopMenu()` which will display the menu, and will either return with the user's
    choice or with `-1`, if nothing was chosen.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条突出显示的行标志着当我们从文本编辑器运行脚本时将要执行的代码的开始。它创建一个由与活动对象关联的所有顶点组名称组成的字符串，名称之间用管道字符（`|`）分隔，并前面有一个合适的标题。这个字符串传递给`PopMenu()`，它将显示菜单，并返回用户的选项或`-1`，如果没有选择任何内容。
- en: If there was a vertex group chosen, we try to retrieve the `Highlight` property.
    If this succeeds we set its data to the name of the chosen vertex group. If the
    property did not yet exist, we add a new one with the name `Highlight` and again
    with the name of the chosen vertex group as data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择了顶点组，我们尝试检索`Highlight`属性。如果成功，我们将其数据设置为所选顶点组的名称。如果该属性尚不存在，我们添加一个新的属性，名称为`Highlight`，并再次以所选顶点组的名称作为数据。
- en: Next we have to make sure that `scriptlinks` are enabled (**Buttons** **window**
    | **Scripts** **panel** | **Scriptlinks**. Click on **enable** **scriptlinks**
    if not yet selected.). Note that to Blender it makes no difference whether we
    are dealing with space handlers or script links as far as enabling them is concerned.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须确保`scriptlinks`已启用（**按钮** **窗口** | **脚本** **面板** | **脚本链接**。如果尚未选择，请点击**启用**
    **脚本链接**）。请注意，对于Blender来说，无论我们处理的是空间处理器还是脚本链接，只要启用它们，就没有区别。
- en: 'The final step in using our space handler is associating it with the 3D view.
    To do this toggle the entry `Draw: AuraSpaceHandler.py` in the view (**Space**
    **Handler** **Scripts** menu of the 3D view).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '使用我们的空间处理器最后的步骤是将它与3D视图关联起来。为此，在3D视图的视图（**空间** **处理器** **脚本**菜单中）切换`Draw: AuraSpaceHandler.py`条目。'
- en: '![Code outline: AuraSpaceHandler.py](img/0400-05-03.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![代码概要：AuraSpaceHandler.py](img/0400-05-03.jpg)'
- en: Using themes
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用主题
- en: 'The code we haven''t seen yet deals with the actual drawing of the highlights
    and the name of the vertex group to identify what we are highlighting. It starts
    off by determining the colors we will use for the highlights and the text by retrieving
    these from the current theme. This way the user can customize these colors in
    a convenient way from the **User** **Preferences** window:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未看到的代码处理的是实际绘制高亮显示和用于标识我们正在突出显示的顶点组的名称。它首先通过从当前主题中检索这些信息来确定我们将用于高亮显示和文本的颜色。这样，用户就可以从**用户**
    **首选项**窗口以方便的方式自定义这些颜色：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The first line will retrieve a list of **themes** that are present. The first
    one is the active theme. From this theme we retrieve the `VIEW3D` theme space
    and its `text_hi` attribute is a list of four integers representing a RGBA color.
    The list comprehension discards the alpha component and converts it to a list
    of three floats in the range [0, 1] that we will use as our text color. Likewise,
    we construct the color of the highlights from the `active` attribute.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将检索一个包含**主题**的列表。第一个是活动主题。从这个主题中，我们检索`VIEW3D`主题空间及其`text_hi`属性，它是一个表示RGBA颜色的四个整数的列表。列表推导式丢弃了alpha组件，并将其转换为范围在[0,
    1]内的三个浮点数的列表，我们将使用它作为我们的文本颜色。同样，我们构造高亮颜色来自`active`属性。
- en: 'Our next challenge is to draw a disk-shaped highlight at a specified location.
    As the size of the disk is quite small (it can be adjusted by altering the `size`
    variable), we can approximate it well enough by an octagonal shape. We store the
    list of x, y coordinates of such an octagon in the `diskvertices` list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的挑战是在指定位置绘制一个圆形高亮。由于圆盘的大小相当小（可以通过修改`size`变量进行调整），我们可以用八边形形状很好地近似它。我们将此类八边形的x，y坐标列表存储在`diskvertices`列表中：
- en: '[PRE6]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The actual drawing of the octagon depends heavily on the functions provided
    by Blender's `BGL` module (highlighted in the previous code). We start by stating
    that we will be drawing a polygon and then add a vertex for each tuple in the
    `diskvertices` list. The location passed to `drawDisk()` will be the center and
    the vertices will all lie on a circle with a radius equal to `size`. When we call
    the `glEnd()` function, the filled-in polygon will be drawn in the current color.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 实际绘制八边形严重依赖于Blender的`BGL`模块提供的函数（在之前的代码中突出显示）。我们首先声明我们将绘制一个多边形，然后为`diskvertices`列表中的每个元组添加一个顶点。传递给`drawDisk()`的位置将是中心，所有顶点都将位于半径等于`size`的圆上。当我们调用`glEnd()`函数时，填充的多边形将以当前颜色绘制。
- en: You might wonder how these drawing functions know how to translate locations
    in 3D to coordinates on the screen and there is indeed more here than meets the
    eye as we will see in the next section of code. The necessary function calls to
    inform the graphics system how to convert 3D coordinates to screen coordinates
    is not implemented in the `drawDisk()` function (preceding code snippet). This
    is because calculating this information for each disk separately would incur an
    unnecessary performance penalty as this information is the same for each disk
    we draw.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道这些绘图函数是如何知道如何将3D位置转换为屏幕坐标的，实际上这里的情况比表面看起来要复杂得多，我们将在下一节代码中看到。将3D坐标转换为屏幕坐标所需的功能调用并未在`drawDisk()`函数（前面的代码片段）中实现。这是因为为每个单独的圆盘计算这些信息将导致不必要的性能损失，因为每个我们绘制的圆盘的信息都是相同的。
- en: 'We therefore define a function, `drawAuras()`, which will take a list of locations
    and a `groupname` argument (a string). It will calculate the transformation parameters,
    call `drawDisk()` for each location in the list, and will then add the group name
    as an on-screen label at approximately just right of the center the highlights.
    Blender''s `Window` module provides us with the `GetPerspMatrix()` function that
    will retrieve the matrix that will correctly convert a point in 3D space to a
    point on the screen. This 4 by 4 matrix is a Python object that will have to be
    converted to a single list of floats that can be used by the graphics system.
    The highlighted lines in the following code take care of that. The next three
    lines reset the projection mode and tell the graphics system to use our suitably
    converted perspective matrix to calculate screen coordinates. Note that changing
    these projection modes and other graphics settings does not affect how Blender
    itself draws things on screen, as these settings are saved before calling our
    script handler and restored afterward:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个函数`drawAuras()`，它将接受一个位置列表和一个`groupname`参数（一个字符串）。它将计算变换参数，为列表中的每个位置调用`drawDisk()`，然后在高亮显示的右侧大约位置添加组名作为屏幕标签。Blender的`Window`模块为我们提供了`GetPerspMatrix()`函数，该函数将检索将3D空间中的点正确转换为屏幕上的点的矩阵。这个4x4矩阵是一个Python对象，必须将其转换为单个浮点数列表，以便由图形系统使用。以下代码中突出显示的行负责处理此事。接下来的三行重置投影模式，并告诉图形系统使用我们适当转换的透视矩阵来计算屏幕坐标。请注意，更改这些投影模式和其他图形设置不会影响Blender本身在屏幕上绘制的内容，因为这些设置在调用我们的脚本处理程序之前被保存，之后被恢复：
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the preliminary calculations out of the way we can set the color we will
    draw our disks in with the `glColor3f()` function. As we stored the color as a
    list of three floats and the `glColor3f()` function takes three separate arguments,
    we unpack this list with the asterisk operator. Next, we call `drawDisk()` for
    each item in `locations`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成初步计算后，我们可以使用`glColor3f()`函数设置我们将用其绘制的圆盘的颜色。因为我们存储颜色为一个包含三个浮点数的列表，而`glColor3f()`函数需要三个单独的参数，所以我们使用星号运算符解包这个列表。接下来，我们对`locations`中的每个项目调用`drawDisk()`。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Blender OpenGL functions:**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Blender OpenGL函数：**'
- en: The documentation of Blenders `BGL` module lists a large number of functions
    from the **OpenGL** library. Many of these functions come in a large number of
    variants that perform the same action but receive their arguments in different
    ways. For example, `BGL.glRasterPos3f()` is a close relation to `BGL.glRasterPos3fv()`
    that will take a list of three single-precision float values instead of three
    separate arguments. For more information, refer to the API documentation of the
    `Blender.BGL` and `Blender.Draw` modules and the OpenGL reference manual on [http://www.opengl.org/sdk/docs/man/](http://www.opengl.org/sdk/docs/man/).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Blender的`BGL`模块文档列出了来自**OpenGL**库的大量函数。其中许多函数有多种变体，执行相同的操作但以不同的方式接收参数。例如，`BGL.glRasterPos3f()`与`BGL.glRasterPos3fv()`密切相关，后者将接受一个包含三个单精度浮点值的列表而不是三个单独的参数。更多信息，请参阅`Blender.BGL`和`Blender.Draw`模块的API文档以及OpenGL参考手册[http://www.opengl.org/sdk/docs/man/](http://www.opengl.org/sdk/docs/man/)。
- en: If the number of highlights we have drawn is not zero, we set the drawing color
    to `textcolor` and then calculate the average coordinates of all the highlights.
    We then use the `glRasterPos3f()` function to set the starting position of the
    text that we want to draw to these average coordinates with some extra space added
    to the x-coordinate to offset the text a little to the right. Blender's `Draw.Text()`
    function will then draw the group name in a small font at the chosen location.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们绘制的突出显示的数量不是零，我们将绘图颜色设置为`textcolor`，然后计算所有突出显示的平均坐标。然后我们使用`glRasterPos3f()`函数将我们要绘制的文本的起始位置设置为这些平均坐标，并在x坐标上添加一些额外空间以使文本稍微向右偏移。Blender的`Draw.Text()`函数将在所选位置以小字体绘制组名。
- en: Revisiting mesh—making an impression
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视网格——留下印象
- en: Although **softbody** and **cloth** simulators that are available in Blender
    do an excellent job in many situations, sometimes you want to have more control
    over the way a mesh is deformed or simulate some specific behavior that is not
    quite covered by Blender's built-in simulators. This exercise shows how to calculate
    the deformation of a mesh that is touched, but not penetrated by another mesh.
    This is not meant to be physically accurate. The aim is to give believable results
    for solid things touching an easily deformable or gooey surface such as a finger
    taking a lick of butter or a wheel running through a soft shoulder.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Blender中可用的**软体**和**布料**模拟器在许多情况下都能出色地完成任务，但有时你可能希望对网格变形的方式有更多的控制，或者模拟一些Blender内置模拟器未涵盖的特定行为。本练习展示了如何计算一个网格在受到另一个网格接触但未穿透时的变形。这不是为了达到物理上的精确，目的是为了在固体物体接触一个容易变形或粘稠的表面（如手指舔黄油或车轮穿过柔软的路面）时，给出令人信服的结果。
- en: 'The following illustration gives some impression of what is possible. The tracks
    are created by animating a rolling car tire on a subdivided plane:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下插图展示了可能实现的效果。轨道是通过在一个细分平面上动画一个滚动汽车轮胎来创建的：
- en: '![Revisiting mesh—making an impression](img/0400-05-04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视网格——留下印象](img/0400-05-04.jpg)'
- en: In the following part, we will refer to the object mesh being deformed as the
    source and the object, or objects, doing the deforming as targets. In a sense,
    this is much like a constraint and we might have implemented these deformations
    as pycontraints. However, that wouldn't be feasible because constraints get evaluated
    each time the source or targets move; thereby causing the user interface to come
    to a grinding halt as calculating the intersections and the resulting deformation
    of meshes is computationally intensive. Therefore, we choose an approach where
    we calculate and cache the results each time the frame is changed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将被变形的对象网格称为源，执行变形的对象或对象称为目标。从某种意义上说，这就像一个约束，我们可能会将这些变形实现为pyconstraints。然而，这并不可行，因为约束会在源或目标移动时每次都进行评估；因此，当计算交点和网格的变形结果时，这会导致用户界面陷入停滞，因为计算量很大。因此，我们选择了一种方法，每次帧改变时都计算和缓存结果。
- en: 'Our script will have to serve several functions, it must:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本将需要执行几个功能，它必须：
- en: Calculate and cache the deformations on each frame change
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在每个帧改变时计算和缓存变形
- en: Change vertex coordinates when cached information is present
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在缓存信息时更改顶点坐标
- en: 'And when run standalone, the script should:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为独立脚本运行时，脚本应该：
- en: Save or restore the original mesh
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存或恢复原始网格
- en: Prompt the user for targets
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示用户选择目标
- en: Associate itself as a script link with the source object
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将自己作为脚本链接与源对象关联
- en: Possibly remove itself as a script link
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能会移除作为脚本链接的自己
- en: 'An important consideration in designing the script is how we will store or
    cache the original mesh and the intermediate, deformed meshes. Because we will
    not change the topology of the mesh (that is, the way vertices are connected to
    each other), but just the vertex coordinates, it will be sufficient to store just
    those coordinates. That leaves us with the question: where to store this information.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计脚本时，一个重要的考虑因素是我们将如何存储或缓存原始网格和中间变形网格。因为我们不会改变网格的拓扑结构（即顶点相互连接的方式），只是顶点坐标，所以只需存储这些坐标就足够了。这让我们面临一个问题：在哪里存储这些信息。
- en: 'If we do not want to write our own persistent storage solution, we have two
    options:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望编写自己的持久化存储解决方案，我们有两个选择：
- en: Use Blender's registry
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Blender的注册表
- en: Associate the data with the source object as a property
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据与源对象关联为属性
- en: Blender's **registry** is easy to use but we must have some method of associating
    the data with an object because it is possible that the user might want to associate
    more than one object with an impression calculation. We could use the name of
    the object as a key, but if the user would change that name, we would lose the
    reference with the stored information while the script link functionality would
    still be there. This would leave the user responsible for removing the stored
    data if the name of the object was changed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Blender的**注册表**易于使用，但我们必须有一种方法将数据与对象关联起来，因为用户可能希望将多个对象与印象计算关联起来。我们可以使用对象的名称作为键，但如果用户更改该名称，我们就会失去与存储信息的引用，而脚本链接功能仍然存在。这将使用户负责在对象名称更改时删除存储的数据。
- en: 'Associating all data as a **property** would not suffer from any renaming and
    the data would be cleared when the object is deleted, but the types of data that
    may be stored in a property are limited to an integer, a floating point value,
    or a string. There are ways to convert arbitrary data to strings by using Python''s
    standard `pickle` module, but, unfortunately, this scenario is thwarted by two
    problems:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有数据关联为**属性**不会受到任何重命名的影响，并且当对象被删除时，数据将被清除，但可以存储在属性中的数据类型仅限于整数、浮点值或字符串。可以通过使用Python的标准`pickle`模块将任意数据转换为字符串，但不幸的是，这个场景被两个问题所阻碍：
- en: Vertex coordinates in Blender are `Vector` instances and these do not support
    the pickle protocol
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender中的顶点坐标是`Vector`实例，这些实例不支持pickle协议
- en: The size of **string properties** is limited to 127 characters and that is far
    too small to store even a single frame of vertex coordinates for a moderately
    sized mesh
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符串属性**的大小限制为127个字符，这对于存储即使是中等大小的网格的单个顶点坐标帧来说也太小了。'
- en: 'Despite the drawbacks of using the registry, we will use it to devise two functions—one
    to store vertex coordinates for a given frame number and one to retrieve that
    data and apply it to the vertices of the mesh. First, we define a utility function
    `ckey()` that will return a key to use with the registry functions based on the
    name of the object whose mesh data we want to cache:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管使用注册表的缺点，我们仍将使用它来设计两个函数——一个用于存储给定帧号的顶点坐标，另一个用于检索该数据并将其应用于网格的顶点。首先，我们定义一个实用函数`ckey()`，它将根据我们想要缓存的网格数据的对象名称返回一个用于注册表函数的键：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Not all registries are the same**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**并非所有注册表都相同**'
- en: Do not confuse Blender's registry with the Windows registry. Both serve the
    similar purpose of providing a persistent storage for all sorts of data, but both
    are distinct entities. The actual data for Blender registry items that are written
    to disk resides in `.blender/scripts/bpydata/config/` by default and this location
    may be altered by setting the `datadir` property with `Blender.Set()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 不要混淆Blender的注册表与Windows注册表。它们都服务于类似的目的，即为各种数据提供持久存储，但它们是不同的实体。Blender注册表项的实际数据默认存储在`.blender/scripts/bpydata/config/`，并且可以通过设置`datadir`属性使用`Blender.Set()`来更改此位置。
- en: Our `storemesh()` function will take an object and a frame number as arguments.
    Its first action is to extract just the vertex coordinates from the mesh data
    associated with the object. Next, it retrieves any data stored in Blender's registry
    for the object that we are dealing with and we pass the extra `True` parameter
    to indicate that if there is no data present in memory, `GetKey()` should check
    for it on disk. If there is no data stored for our object whatsoever, `GetKey()`
    will return `None`, in which case we initialize our cache to an empty dictionary.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`storemesh()`函数将接受一个对象和一个帧号作为参数。它的第一个动作是从与对象关联的网格数据中提取仅顶点坐标。接下来，它检索我们正在处理的对象在Blender注册表中存储的任何数据，并且我们传递额外的`True`参数来指示如果内存中没有数据，`GetKey()`应在磁盘上检查它。如果我们的对象没有任何存储的数据，`GetKey()`将返回`None`，在这种情况下，我们将我们的缓存初始化为一个空字典。
- en: Subsequently, we store our mesh coordinates in this dictionary indexed by the
    frame number (highlighted in the next code snippet). We convert this integer frame
    number to a string to be used as the actual key because Blender's `SetKey()` function
    assumes all of the keys to be strings when saving registry data to disk, and will
    raise an exception if it encounters an integer. The final line calls `SetKey()`
    again with an extra `True` argument to indicate that we want the data to be stored
    to disk as well.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，我们将我们的网格坐标存储在这个字典中，以帧号作为索引（在下一代码片段中突出显示）。我们把这个整数帧号转换成字符串，用作实际的键，因为Blender的`SetKey()`函数在将注册表数据保存到磁盘时假定所有键都是字符串，如果遇到整数将引发异常。最后一行再次调用`SetKey()`，并带有额外的`True`参数来指示我们希望数据也存储到磁盘上。
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `retrievemesh()` function will take an object and a frame number as arguments.
    If it finds cached data for the given object and frame, it will assign the stored
    vertex coordinates to vertices in the mesh. We first define two new exceptions
    to indicate some specific error conditions `retrievemesh()` may encounter:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrievemesh()`函数将接受一个对象和一个帧号作为参数。如果它为给定对象和帧找到了缓存的数据，它将把存储的顶点坐标分配给网格中的顶点。我们首先定义两个新的异常来指示`retrievemesh()`可能遇到的一些特定错误条件：'
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`retrievemesh()` will raise the `NoSuchProperty` exception if the object has
    no associated cached mesh data and a `NoFrameCached` exception if the data is
    present but not for the indicated frame. The highlighted line in the next code
    deserves some attention. We fetch the associated mesh data of the object with
    `mesh=True`. This will yield a wrapped mesh, not a copy, so any vertex data we
    access or alter will refer to the actual data. Also, we encounter Python''s built-in
    `zip()` function that will take two lists and returns a list consisting of tuples
    of two elements, one from each list. It effectively lets us traverse two lists
    in parallel. In our case, these lists are a list of vertices and a list of coordinates
    and we simply convert these coordinates to vectors and assign them to the co-attribute
    of each vertex:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象没有关联的缓存网格数据，`retrievemesh()`将引发`NoSuchProperty`异常；如果数据存在但不是针对指示的帧，将引发`NoFrameCached`异常。下一代码中高亮显示的行值得注意。我们使用`mesh=True`获取对象的关联网格数据。这将产生一个包装的网格，而不是副本，因此我们访问或修改的任何顶点数据都将引用实际数据。此外，我们遇到了Python的内置`zip()`函数，它将接受两个列表并返回一个由两个元素的元组组成的列表，每个元素来自每个列表。它有效地让我们并行遍历两个列表。在我们的情况下，这些列表是顶点列表和坐标列表，我们只需将这些坐标转换为向量并将它们分配给每个顶点的co-属性：
- en: '[PRE11]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To complete our set of cache functions we define a function `clearcache()`
    that will attempt to remove the registry data associated with our object. The
    `try … except …` clause will ensure that the absence of stored data is silently
    ignored:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的缓存函数集，我们定义了一个`clearcache()`函数，该函数将尝试删除与我们的对象关联的注册数据。`try … except …`子句将确保存储数据的缺失被静默忽略：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The user interface
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户界面
- en: 'Our script will not only be used as a script link associated with an object
    but it will also be used standalone (by pressing *Alt + P* in the text editor
    for example) to provide the user with the means to identify a target that will
    make the impression to clear the cache, and to associate the script link with
    the active object. If used in this fashion, it will present the end user with
    a few pop-up menus, both shown in the screenshots. The first one shows the possible
    actions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本不仅将被用作与对象关联的脚本链接，而且还可以独立使用（例如，在文本编辑器中按*Alt + P*），为用户提供识别将清除缓存的目标以及将脚本链接与活动对象关联的手段。如果以这种方式使用，它将向最终用户展示几个弹出菜单，如截图所示。第一个显示了可能的操作：
- en: '![The user interface](img/0400-05-05.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面](img/0400-05-05.jpg)'
- en: 'The second screenshot shows the pop up offered to select an object from a list
    of `Mesh` objects that the user can choose to make an impression:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第二张截图显示了提供给用户从`Mesh`对象列表中选择对象的弹出菜单：
- en: '![The user interface](img/0400-05-06.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![用户界面](img/0400-05-06.jpg)'
- en: 'We first define a utility function that will be used by the pop-up menu that
    will present the user with a choice of `Mesh` objects to be used as a target to
    make an impression. `getmeshobjects()` will take a `scene` argument and will return
    a list of names of all `Mesh` objects. As depicted in the screenshot, the list
    of target objects includes the source object as well. Although this is legal,
    it is debatable whether this is very useful:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个效用函数，该函数将由弹出菜单使用，向用户提供选择用作印象目标的`Mesh`对象。`getmeshobjects()`函数将接受一个`scene`参数，并返回所有`Mesh`对象名称的列表。如图表所示，目标对象列表包括源对象。尽管这是合法的，但关于这非常有用性是有争议的：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The menu itself is implemented by the `targetmenu()` function defined as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单本身是通过以下定义的`targetmenu()`函数实现的：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It will fetch the list of all of the `Mesh` objects in the scene and present
    this list as a choice to the user by using Blender's `Draw.PupMenu()` function.
    If the user selects one of the menu entries (the return value will be positive
    and non-zero, see the highlighted line of the preceding code), it will store the
    name of this `Mesh` object as a property associated with our object. `impresstarget`
    is defined elsewhere as the name for the property. First, the code checks whether
    there already is such a property associated with the object by calling the `getProperty()`
    method and setting the properties data, if there is. If `getProperty()` raises
    an exception because the property does not yet exist, we then add the new property
    to the object and assign data to it with a single call to the `addProperty()`
    method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 它将获取场景中所有`网格`对象的列表，并通过使用Blender的`Draw.PupMenu()`函数将此列表作为选择展示给用户。如果用户选择菜单条目之一（返回值将是正数且非零，参见前述代码中的高亮行），它将存储此`网格`对象的名称作为与我们的对象关联的属性。`impresstarget`在别处定义为属性的名称。首先，代码通过调用`getProperty()`方法并设置属性数据来检查是否已经与对象关联了此类属性。如果`getProperty()`由于属性尚不存在而引发异常，我们随后将新属性添加到对象中，并通过对`addProperty()`方法的单一调用分配数据。
- en: 'The main user interface is defined in the top level of the script. It verifies
    that it is not running as a script link and then presents the user with a number
    of choices:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 主要用户界面在脚本的顶层定义。它验证它不是作为脚本链接运行的，然后向用户展示一系列选择：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Any valid choice will clear the cache (highlighted) and the subsequent checks
    perform the necessary actions associated with each individual choice: **Add/Replace
    scriptlink** will remove the script link, if it is already present, to prevent
    duplicates and then add it to the active object. It then presents the target menu
    to select a `Mesh` object to use to make an impression. As we already cleared
    the cache, the second choice, **Clear cache**, will do nothing specific, so we
    just pass. **Remove All** will try to remove the cache and attempt to dissociate
    itself as a script link and the final **New target** menu will present the target
    selection menu to allow the user to select a new target object without removing
    any cached results.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 任何有效的选择都将清除缓存（高亮显示）并且后续的检查将执行与每个单独选择相关的必要操作：**添加/替换脚本链接**将删除（如果已存在）脚本链接以防止重复，然后将其添加到活动对象中。然后显示目标菜单以选择用于制作印痕的`网格`对象。由于我们已经清除了缓存，第二个选择**清除缓存**将不会执行任何特定操作，所以我们只需跳过。**全部删除**将尝试删除缓存并尝试解除自身作为脚本链接的关联，最后的**新目标**菜单将显示目标选择菜单，允许用户选择新的目标对象而不删除任何缓存结果。
- en: 'If we *are* running as a script link we first check that we are acting on a
    `FrameChanged` event and then try to retrieve any stored vertex coordinates for
    the current frame (highlighted in the next code). If there is no previously stored
    data, we have to calculate the effects of the target object for this frame. We
    therefore get a list of target objects for the object under consideration by calling
    the utility function `gettargetobjects()` (for now, a list of just one object
    will be returned) and for each object we calculate the effect on our mesh by calling
    `impress()`. Then, we store these possibly changed vertex coordinates and update
    the display list so that the Blender GUI knows how to display our altered mesh:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们作为脚本链接运行，我们首先检查我们是否正在处理一个`FrameChanged`事件，然后尝试检索当前帧（在下述代码中高亮显示）存储的任何存储的顶点坐标。如果没有先前存储的数据，我们必须计算此帧的目标对象的效果。因此，我们通过调用实用函数`gettargetobjects()`（目前将返回一个仅包含一个对象的列表）来获取考虑中的对象的目标对象列表，并对每个对象通过调用`impress()`来计算对我们网格的影响。然后，我们存储这些可能已更改的顶点坐标并更新显示列表，以便Blender
    GUI知道如何显示我们修改后的网格：
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That leaves us with the actual calculation of the impression of a target object
    on our mesh.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了我们在我们的网格上计算目标对象印痕的实际计算。
- en: Calculating an impression
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算印痕
- en: 'When determining the effect of a target object making an impression, we will
    approach this as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当确定制作印痕的目标对象的效果时，我们将如下处理：
- en: 'For each vertex in the mesh receiving the impression:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接收印痕的网格中的每个顶点：
- en: 'Determine if it is located inside the target object and if so:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定它是否位于目标对象内部，如果是的话：
- en: Set the location of the vertex to the location of the closest vertex on the
    object making the impression
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将顶点的位置设置为制作印痕的对象上最近的顶点位置
- en: There are some important issues to address here. The location of a vertex in
    a mesh is stored relative to the object's transformation matrix. In other words,
    if we want to compare vertex coordinates in two different meshes, we have to transform
    each vertex by the transformation matrices of their respective objects before
    doing any comparison.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些重要的问题需要解决。网格中顶点的位置是相对于对象的变换矩阵存储的。换句话说，如果我们想要比较两个不同网格中的顶点坐标，我们必须在比较之前通过各自的变换矩阵变换每个顶点。
- en: Also, a `Blender.Mesh` object has a `pointInside()` method that will return
    `True` if a given point is inside the mesh. This will, however, only work reliably
    on closed meshes so the user has to verify that the objects that will make the
    impression are in fact closed. (They may have interior bubbles but their surfaces
    must not contain edges that are not shared by exactly two faces. These so-called
    non-manifold edges can be selected in *edge* *select* mode by selecting **Select
    | Non Manifold** in the 3D view or pressing *Ctrl + Shift + Alt + M*.)
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`Blender.Mesh`对象有一个`pointInside()`方法，如果给定点在网格内，它将返回`True`。然而，这仅在封闭网格上才能可靠地工作，因此用户必须验证将要形成印象的对象实际上是否是封闭的。（它们可能有内部气泡，但它们的表面不得包含不是恰好由两个面共享的边。这些所谓的非流形边可以在*边*
    *选择*模式下通过在3D视图中选择**选择 | 非流形**或按*Ctrl + Shift + Alt + M*来选择。）
- en: Finally, moving vertices to the closest vertex on the target object may be quite
    inaccurate when the target mesh is rather coarse. Performance wise, however, it
    is good to have relatively few points—as our algorithm is rather inefficient because
    by first determining whether a point is inside a mesh and then separately calculating
    the closest vertex duplicates a lot of calculations. However, as the performance
    is acceptable even for meshes consisting of hundreds of points, we stick with
    our approach, as it keeps our code simple and saves us having to write and test
    very intricate code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当目标网格相当粗糙时，将顶点移动到目标对象上的最近顶点可能非常不准确。然而，从性能的角度来看，拥有相对较少的点是有好处的——因为我们的算法相当低效，因为它首先确定一个点是否在网格内，然后单独计算最近的顶点副本重复了大量的计算。然而，由于性能对于由数百个点组成的网格也是可接受的，我们坚持我们的方法，因为它使我们的代码简单，并节省了我们编写和测试非常复杂的代码。
- en: 'The implementation starts with a function to return the distance to and the
    coordinates of the vertex closest to a given point `pt`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 实现从返回给定点`pt`最近的顶点的距离和坐标的函数开始：
- en: '[PRE17]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `impress()` function itself takes a source and a target object as arguments
    and will modify the mesh data of the source object if the target mesh makes an
    impression. The first thing that it does is retrieve the transformation matrices
    of the objects. As indicated before, these will be needed to transform the coordinates
    of the vertices so that they might be compared. We also retrieve the inverse matrix
    of the source object. This will be needed to transform coordinates back to the
    space of the source object.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`impress()`函数本身接受源对象和目标对象作为参数，如果目标网格形成印象，它将修改源对象的网格数据。它首先做的事情是检索对象的变换矩阵。如前所述，这些将用于变换顶点的坐标，以便进行比较。我们还检索源对象的逆矩阵。这将被需要以将坐标转换回源对象的空间。'
- en: The highlighted line retrieves the wrapped mesh data of the source object. We
    need wrapped data because we might want to change some of the vertex coordinates.
    The next two lines retrieve copies of the mesh data. We also need copies because
    the transformation we will perform may not affect the actual mesh data. Instead
    of copying we could have left out the `mesh=True` argument, which would have given
    us a reference to an `Nmesh` object instead of a `Mesh` object. However, `Nmesh`
    objects are not wrapped and are marked as deprecated. Also, they lack the `pointInside()`
    method we need, so we opt for copying the meshes ourselves.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行检索源对象的包裹网格数据。我们需要包裹数据，因为我们可能想要更改一些顶点坐标。接下来的两行检索网格数据的副本。我们也需要副本，因为我们将要执行的变化可能不会影响实际的网格数据。我们本可以省略`mesh=True`参数，这样就会得到一个`Nmesh`对象的引用而不是`Mesh`对象。然而，`Nmesh`对象不是包裹的，并且已被标记为弃用。此外，它们缺少我们需要的`pointInside()`方法，所以我们选择自己复制网格。
- en: 'Next, we transform these mesh copies by their respective object transform matrices.
    Using the `transform()` method of these meshes saves us from iterating over each
    vertex and multiplying the vertex coordinates by the transform matrix ourselves,
    and this method is probably a bit faster as well as `transform()` is completely
    implemented in C:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用各自的物体变换矩阵对这些网格副本进行变换。使用这些网格的`transform()`方法可以避免我们逐个顶点迭代并自己乘以变换矩阵，而且这个方法可能比手动计算更快，因为`transform()`方法完全是用C语言实现的：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The final part of the `impress()` function loops over all of the vertices in
    the transformed source mesh and checks if the vertex lies enclosed within the
    (transformed) target mesh. If they are, it determines which vertex on the target
    mesh is closest and sets the affected vertex in the original mesh to these coordinates.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`impress()`函数的最后一部分遍历变换后的源网格中的所有顶点，并检查顶点是否位于（变换后的）目标网格内部。如果是，它将确定目标网格上最近的顶点，并将原始网格中受影响的顶点设置为这些坐标。'
- en: This original mesh is not transformed, so we have to transform this closest
    point back to the object space of the source object by multiplying the coordinates
    with the inverse transformation matrix. Because transformation calculations are
    expensive, modifying the transformed mesh and transforming the complete mesh back
    at the end may take a considerate amount of time. Keeping a reference to the untransformed
    mesh and just transforming back individual points may, therefore, be preferable
    when only relatively few vertices are affected by the impression. The full script
    is available as `ImpressScriptLink.py` in `scriptlinks.blend`. The following illustration
    shows what is possible. Here we made a small animation of a ball (an icosphere)
    rolling along and descending into the mud (a subdivided plane).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个原始网格没有进行变换，因此我们必须通过乘以逆变换矩阵将这个最近点转换回源对象的物体空间。因为变换计算成本较高，修改变换后的网格并在最后将整个网格完全转换回来可能需要相当多的时间。因此，当只有相对少数顶点受到印象影响时，保留未变换网格的引用并仅变换个别点可能更可取。完整的脚本作为`ImpressScriptLink.py`在`scriptlinks.blend`中可用。以下插图显示了可能的情况。在这里，我们制作了一个球（一个二十面体球体）沿着并滚入泥中（一个细分平面）的小动画。
- en: '![Calculating an impression](img/0400-05-07.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![计算印象](img/0400-05-07.jpg)'
- en: When working with the script it is important to keep in mind that when the impression
    is calculated, none of the vertices of the mesh that receives the impression should
    be located inside the target before it moves. If that happens it is possible for
    a vertex to be swept along with the movement of the target, distorting the source
    mesh along the way. For example, to make the illustration of the wheel track in
    the mud, we animate a rolling wheel along a path, calculating the impressions
    it makes at every frame. In the first frame that we animate we should make sure
    that the wheel is not touching the floor plane that will be distorted because
    if a vertex of the floor plane is inside the wheel and close to the inner rim,
    it will be moved to the closest vertex on that rim. If the wheel rolls slowly,
    this vertex will stay close to that inner rim and will thereby be effectively
    glued to that moving inner rim, ripping up the floor plane in the process. The
    same disruptive process may occur if the target object is very small compared
    to the source mesh or moving very fast. In these circumstances a vertex may penetrate
    the target object so fast that the closest vertex will not be on the leading surface
    making the impression but somewhere else in the target which will result in vertices
    being pulled outward instead of pushed inward. In the illustration of the rolling
    tractor tire, we carefully positioned the tire at frame one to sit just to the
    right of the subdivided plane before we key framed the rolling motion towards
    the left. The picture shown is taken at frame 171 without any smoothing or materials
    applied to the plane.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用脚本时，重要的是要记住，当计算印象时，接收印象的网格的任何顶点都不应该在移动之前位于目标内部。如果发生这种情况，一个顶点可能会随着目标的移动而被卷走，从而在移动过程中扭曲源网格。例如，为了制作泥地中车轮轨迹的插图，我们沿着路径动画化一个滚动的车轮，计算它在每一帧上留下的印象。在我们动画的第一帧中，我们应该确保车轮没有接触到将被扭曲的地面平面，因为如果地面平面的一个顶点在车轮内部并且靠近内缘，它将被移动到那个内缘上最近的顶点。如果车轮滚动得慢，这个顶点将保持在那个内缘附近，从而有效地粘附在那个移动的内缘上，在这个过程中撕裂地面平面。如果目标对象与源网格相比非常小或者移动得非常快，也可能发生这种破坏性的过程。在这种情况下，一个顶点可能会以如此快的速度穿透目标对象，以至于最近的顶点不会在导致印象的前导表面上，而是在目标的另一个地方，这会导致顶点被向外拉而不是向内推。在滚动拖拉机轮胎的插图示例中，我们在对向左的滚动运动进行关键帧动画之前，小心地将轮胎定位在第一帧中，使其位于细分平面的右侧。所显示的图片是在第171帧拍摄的，没有对平面应用任何平滑或材质。
- en: '![Calculating an impression](img/0400-05-08.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![计算印象](img/0400-05-08.jpg)'
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned how to link change to the progress of the animation
    frames and how to associate state information with an object. We also saw how
    to change layers, for example to render an object invisible. Specifically we saw:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何将变化链接到动画帧的进度，以及如何将状态信息与对象关联。我们还看到了如何更改图层，例如使对象不可见。具体来说，我们看到了：
- en: What script links and space handlers are
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本链接和空间处理器是什么
- en: How to perform activities on each frame change in an animation
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在动画的每一帧变化时执行活动
- en: How to associate additional information with an object
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将附加信息与对象关联
- en: How to make an object appear or disappear by changing lay or changing its transparency
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过更改图层或更改其透明度使对象出现或消失
- en: How to implement a scheme to associate a different mesh with an object on each
    frame
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何实现一个方案，将不同的网格与每一帧上的对象关联
- en: How to augment the functionality of the 3DView
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何增强3DView的功能
- en: 'Next up: adding shape keys and IPOs.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来：添加形状键和IPOs。
