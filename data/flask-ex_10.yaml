- en: Chapter 10. Template Inheritance and WTForms in Waiter Caller Project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。在服务员呼叫项目中使用模板继承和WTForms
- en: In the previous chapter, we created a rudimentary user account system. However,
    we only made a very simple route access controlled—the one that simply showed
    the string "You are logged in". In this chapter, we'll add some more of the desired
    functionality, and allow logged-in users to add restaurant tables, see the URLs
    associated with these tables, and view attention requests from customers. One
    of the problems we'll come across is that of wanting to reuse the same elements
    for different pages of our application. You'll see how to solve this problem without
    code duplication by using Jinja's inheritance system. As mentioned in the previous
    chapter, we do not communicate very well with our user when mistakes, such as
    entering an incorrect password, are made. To address this, we'll take a look at
    another Flask extension, WTForms, and see how it can simplify creating and validating
    forms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个基本的用户账户系统。然而，我们只是做了一个非常简单的路由访问控制——只是简单地显示字符串“您已登录”。在本章中，我们将添加一些更多的期望功能，并允许已登录用户添加餐厅桌子，查看与这些桌子相关的URL，并查看顾客的关注请求。我们将遇到的一个问题是希望在我们的应用程序的不同页面上重用相同的元素。您将看到如何通过使用Jinja的继承系统来解决这个问题，而不会出现代码重复。正如在上一章中提到的，当出现错误时，比如输入了错误的密码，我们与用户的沟通并不是很好。为了解决这个问题，我们将看一下另一个Flask扩展，WTForms，并看看它如何简化创建和验证表单。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将涵盖以下主题：
- en: Adding account and dashboard pages to our application
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将账户和仪表板页面添加到我们的应用程序中
- en: Shortening URLs using the bitly API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用bitly API缩短URL
- en: Adding functionality for handling attention requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加处理关注请求的功能
- en: Adding user feedback through WTForms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过WTForms添加用户反馈
- en: Adding the Account and Dashboard pages
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加账户和仪表板页面
- en: 'We want to add two new pages to our application: ''Dashboard'', where all requests
    from the patrons of a particular restaurant can be seen, and ''Account'', where
    the restaurants can manage their tables and view the URLs that they need to make
    available on the tables.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在我们的应用程序中添加两个新页面：'仪表板'，在这里可以看到特定餐厅的所有顾客请求，以及'账户'，在这里餐厅可以管理他们的桌子并查看他们需要在桌子上提供的URL。
- en: We could simply create two new `.html` files in our `templates` directory and
    write the HTML from scratch. But we'll soon find that we need many of the same
    elements from our home page (at the very least, the parts that include and configure
    Bootstrap). Then we'll be tempted to just copy and paste the HTML from the home
    page and start working on our new page from there.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以简单地在我们的`templates`目录中创建两个新的`.html`文件，并从头开始编写HTML。但很快我们会发现，我们需要从我们的主页中使用许多相同的元素（至少包括和配置Bootstrap的部分）。然后我们会忍不住只是复制粘贴主页的HTML，并从那里开始处理我们的新页面。
- en: Introducing Jinja templates
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Jinja模板
- en: Copying and pasting code is usually a sign that something is wrong. In application
    code, it means that you haven't modularized your code well, and you need to create
    some more classes and probably add a couple of `import` statements to include
    the reused code wherever it is needed. Using Jinja, we can follow a very similar
    pattern, by using *template inheritance*. We'll first split our home page into
    two separate template files, `base.html` and `home.html`, with all the elements
    that we want to reuse in the base file. We can then have all three of our other
    pages (Home, Account, and Dashboard) inherit from the *base template*, and only
    write the code that differs across the three.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 复制和粘贴代码通常意味着有些地方出了问题。在应用程序代码中，这意味着您没有很好地模块化您的代码，并且需要创建一些更多的类，并可能添加一些`import`语句来包含重用的代码。使用Jinja，我们可以遵循一个非常相似的模式，通过使用*模板继承*。我们首先将我们的主页分成两个单独的模板文件，`base.html`和`home.html`，其中包含我们想要在基本文件中重用的所有元素。然后我们可以让我们的其他三个页面（主页、账户和仪表板）都继承自*基本模板*，并且只编写在这三个页面之间有所不同的代码。
- en: Jinja handles inheritance by using the concept of *blocks*. Each parent template
    can have named blocks, and a child that extends a parent can fill in these blocks
    with its own custom content. The Jinja inheritance system is quite powerful, and
    accounts for nested blocks and overwriting existing blocks. However, we're only
    going to scratch the surface of its functionality. We'll have our base template
    contain all the reusable code, and it'll contain one blank block named `content`
    and one named `navbar`. Each of our three pages will extend from the base template,
    providing their own version of the content block (for the main page content) and
    the navigation bar. We'll need to make the navigation bar dynamic, because the
    **Login** fields of the bar at the top of the page will only appear if the user
    isn't logged in.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja通过使用*blocks*的概念来处理继承。每个父模板都可以有命名块，而扩展父模板的子模板可以用自己的自定义内容填充这些块。Jinja继承系统非常强大，可以处理嵌套块和覆盖现有块。然而，我们只会浅尝其功能。我们的基本模板将包含所有可重用的代码，并包含一个名为`content`的空块和一个名为`navbar`的块。我们的三个页面将从基本模板扩展，提供它们自己版本的内容块（用于主页面内容）和导航栏。我们需要使导航栏动态化，因为页面顶部的**登录**字段只有在用户未登录时才会出现。
- en: Creating the base template
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建基本模板
- en: 'Create a new file called `base.html` in your `templates` directory, and insert
    the following code:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`templates`目录中创建一个名为`base.html`的新文件，并插入以下代码：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, we have all our header and our page footer code—elements
    that will be common across all our pages—in one file. We define two blocks, using
    the Jinja syntax, which is similar to the other Jinja statements that we have
    seen, namely:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们在一个文件中拥有所有的页眉和页脚代码——这些元素将在所有页面中共同存在。我们使用Jinja语法定义了两个块，这与我们之前看到的其他Jinja语句类似，即：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: And
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, `content` and `navbar` are the names of our blocks, and we
    can choose these freely, while `block` and `endblock` are Jinja keywords, and
    the `{% %}` symbols are used to indicate the Jinja statements as in earlier examples.
    This is in itself a completely valid Jinja template; even though the content block
    is empty, we can render the template directly from our Flask app, and we would
    see a page that simply pretended that the content block didn't exist.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`content`和`navbar`是我们块的名称，我们可以自由选择这些名称，而`block`和`endblock`是Jinja关键字，`{%
    %}`符号用于指示Jinja语句，就像之前的例子中一样。这本身就是一个完全有效的Jinja模板；即使内容块是空的，我们也可以直接从我们的Flask应用程序中呈现模板，我们会看到一个页面，它只是假装内容块不存在。
- en: We can also extend this template, though; that is, we can create children using
    it as the parent. Children have the option of *overwriting* any of the specified
    blocks simply by declaring them again. We declared `navbar` as a block as our
    home page will use the navigation bar that we wrote earlier—the one that includes
    a login form. Once logged in, however, our pages for dashboard and account will
    have exactly the same navigation bar—the one we define in our base template.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扩展这个模板；也就是说，我们可以使用它作为父模板创建子模板。子模板可以通过再次声明来*覆盖*任何指定的块。我们将`navbar`声明为一个块，因为我们的主页将使用我们之前编写的导航栏——包括登录表单。然而，一旦登录，我们的仪表板和账户页面将具有完全相同的导航栏——这是我们在基本模板中定义的导航栏。
- en: Creating the dashboard template
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建仪表板模板
- en: 'Our dashboard page will eventually show all customers'' requests for service
    so that a waiter can easily see which tables need attention. For now though, we''ll
    just create an outline of the page. Create a new file in your `templates` directory
    called `dashboard.html`, and add the following code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的仪表板页面最终将显示所有客户的服务请求，以便服务员可以轻松地看到哪些桌子需要关注。不过，现在我们只是创建页面的大纲。在您的`templates`目录中创建一个名为`dashboard.html`的新文件，并添加以下代码：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The most important line in the preceding code snippet is the first one—we use
    the Jinja `extends` keyword to indicate that this template should inherit all
    the code contained in another template. The keyword is followed by the filename
    of the template to inherit from, contained within inverted commas.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，最重要的一行是第一行——我们使用Jinja的`extends`关键字来指示这个模板应该继承另一个模板中包含的所有代码。关键字后面跟着要继承的模板的文件名，包含在引号中。
- en: Following that, we simply create the content block in exactly the same way we
    did in our base template. This time, instead of leaving it blank, we add some
    HTML to be displayed on our dashboard page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们只需以与基本模板相同的方式创建内容块。这一次，我们不是留空，而是添加一些HTML来显示在我们的仪表板页面上。
- en: Creating the account template
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建账户模板
- en: 'The account page will be the one where the user can add new tables, delete
    tables, or get the URL for the existing tables. Again, as we do not yet have any
    application code to represent a table, we''ll just create an outline of the page.
    Create a file called `account.html` in your `templates` directory, and add the
    following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 账户页面将是用户可以添加新表格、删除表格或获取现有表格的URL的页面。同样，由于我们还没有任何应用程序代码来表示表格，我们将只是创建页面的大纲。在您的`templates`目录中创建一个名为`account.html`的文件，并添加以下代码：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Creating the home template
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建主页模板
- en: The `home.html` template contains the entire code specific to our home page,
    and which isn't part of the base template. The code can be seen in the code bundle
    as `templates/home_1.html`, but is not included here as it is too long. Have a
    look at it and see how we define a new `navbar` block which contains the `login`
    form, and which overrides the default one provided in the base template. Similarly,
    it defines the content block, which replaces the empty content block that we defined
    in our base template. The end result hasn't changed—we'll still see exactly the
    same home page, but now the code is split between the `base.html` and `home.html`
    files, allowing us to reuse large parts of it for the new pages that we created
    previously.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`home.html`模板包含了我们主页的整个特定代码，它不是基本模板的一部分。代码可以在代码包中的`templates/home_1.html`中看到，但这里没有包含，因为它太长了。看一下它，看看我们如何定义一个包含`login`表单的新`navbar`块，并覆盖了基本模板中提供的默认块。同样，它定义了内容块，替换了我们在基本模板中定义的空内容块。最终结果并没有改变——我们仍然会看到完全相同的主页，但现在代码分为`base.html`和`home.html`文件，允许我们重用它的大部分内容，用于我们之前创建的新页面。'
- en: Adding the routing code
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加路由代码
- en: 'We need our Python code to return the new template files when `/account` and
    `/dashboard` are visited. Add the `dashboard()` function to your `waitercaller.py`
    file, and modify the account `function()` to read as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问`/account`和`/dashboard`时，我们需要我们的Python代码返回新的模板文件。在您的`waitercaller.py`文件中添加`dashboard()`函数，并修改账户`function()`如下：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Give the new pages a go! Start the application locally as before, by running:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试新页面！像以前一样在本地运行应用程序：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Navigate to `http://localhost:5000` to see the home page. Log in using the
    form, and now, instead of the bare message we had before, you should see a nicer
    looking skeleton of the **Account** page, as seen in the following image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 转到`http://localhost:5000`查看主页。使用表单登录，现在，您应该看到一个更漂亮的**账户**页面的骨架，如下图所示：
- en: '![Adding the routing code](img/B04312_10_01.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![添加路由代码](img/B04312_10_01.jpg)'
- en: 'Click on the **Dashboard** link in the navigation bar at the top, and you should
    see the skeleton for that page, too, as seen in the following image:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部的导航栏中点击**仪表板**链接，您也应该看到该页面的骨架，如下图所示：
- en: '![Adding the routing code](img/B04312_10_02.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![添加路由代码](img/B04312_10_02.jpg)'
- en: Creating restaurant tables
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建餐厅桌子
- en: 'Now we need to introduce the concept of a *table* to our application, and be
    able to represent this both in our database and in our application code. A table
    should have the following attributes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要向我们的应用程序引入*表*的概念，并且能够在我们的数据库和应用程序代码中表示它。一个表应该具有以下属性：
- en: An ID number that uniquely identifies that table across all users of our app
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一标识我们应用程序所有用户中的该表的ID号
- en: A name that is user-definable and unique within a specific user's tables
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用户可定义且在特定用户的表格中唯一的名称
- en: An owner so that we will know to which user a table belongs
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个所有者，以便我们知道表格属于哪个用户
- en: If we were following an **Object Oriented Programming** style religiously, we
    would create a `Table` class which had these properties. We would then also create
    a bunch of other classes for everything in our application. Following this approach,
    we would also create methods to serialize each of our objects into something that
    can be stored in our database, and more methods to *deserialize* them from the
    database back to objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们严格遵循面向对象编程的风格，我们将创建一个`Table`类，其中包含这些属性。然后，我们还将为应用程序中的所有内容创建一堆其他类。按照这种方法，我们还将创建方法来将我们的每个对象序列化为可以存储在数据库中的内容，并创建更多的方法来*反序列化*它们，从数据库中恢复为对象。
- en: For the sake of brevity, and because our model is simple enough, we'll be taking
    a shortcut that is sure to offend some, and simply use Python dictionaries to
    represent most of our objects. We'll see when we add MongoDB to our application
    that these dictionaries will be trivial to write to and read from the database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，并且因为我们的模型足够简单，我们将采取一种捷径，这肯定会冒犯一些人，简单地使用Python字典来表示我们大部分的对象。当我们将MongoDB添加到我们的应用程序时，我们将看到这些字典将很容易地写入和从数据库中读取。
- en: Writing the restaurant table code
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写餐厅表格代码
- en: Let's have a brief look at what our tables need to do. First, the user of our
    app will need to be able to add and remove new tables on the `account` page—both
    initially when an account is registered and later if changes need to be made.
    Secondly, the user should be able to view the URL associated with each table,
    so that these URLs can be printed and made available at the physical tables. When
    a new table is added, we'll need to create a mock database.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看一下我们的表需要做什么。首先，我们的应用用户需要能够在“账户”页面上添加和删除新表格，无论是最初注册账户时还是以后需要进行更改时。其次，用户应该能够查看与每个表格相关联的URL，以便这些URL可以被打印并在实际表格上提供。当添加新表格时，我们需要创建一个模拟数据库。
- en: We'll start by providing our users with an input box on the `account` page,
    where they can input the name or number of a new table in order to create it.
    When a new table is created, we'll create a unique ID number and use that to create
    a new URL. We'll then use the bitly API to create a shortened version of the URL—one
    that our users' patrons will be able to type into a smartphone more easily. We'll
    then store the table name, ID, and shortened URL in our mock database.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在“账户”页面上为用户提供一个输入框开始，他们可以在其中输入新表格的名称或编号以创建它。创建新表格时，我们将创建一个唯一的ID号，并使用它来创建一个新的URL。然后，我们将使用bitly
    API来创建URL的缩短版本，这样我们的用户的顾客将更容易地在智能手机上输入。然后，我们将在我们的模拟数据库中存储表格名称、ID和缩短的URL。
- en: Adding the create table form
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加创建表单
- en: 'In the `account.html` template, add the following directly beneath the line
    `<h2>Tables</h2>`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`account.html`模板中，在`<h2>Tables</h2>`下面直接添加以下内容：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is a very basic form with a single input for a new table name and a button
    to submit the form. If you load the application and navigate to the **Account**
    page, you should now see something like the following image:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常基本的表单，只有一个输入框用于输入新表格的名称和一个提交表单的按钮。如果您加载应用程序并导航到“账户”页面，您现在应该看到类似以下图片的东西：
- en: '![Adding the create table form](img/B04312_10_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![添加创建表单](img/B04312_10_03.jpg)'
- en: Adding the create table route
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加创建表路由
- en: Creating a table backend is not too complicated, but it has subtleties that
    are important to understand. First, our users can give the table any name they
    want. For most users, these names will probably just be incrementing numbers starting
    from 1 and ending at the number of tables in the restaurant, as this is a common
    way for restaurants to name their tables. Because many restaurant managers will
    be using our application, we can't assume that these names will be unique across
    all accounts. Most users of our application will probably have a table called
    `1`. Therefore, when a restaurant patron indicates that he or she is at Table
    1 and wants service, we have to be able to pick the correct Table 1 from potentially
    many restaurants. To solve this, each table in our database will have a unique
    ID that we'll use for table identification in the URLs, but we'll display the
    user-chosen name (for example, `1`) on the **Account** page to allow our users
    to easily manage their personal list of tables.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表格后端并不太复杂，但有一些重要的细节需要理解。首先，我们的用户可以给表格任何他们想要的名称。对于大多数用户，这些名称可能只是从1开始递增的数字，以餐厅中的表格数量结束，因为这是餐厅命名表格的常见方式。因为许多餐厅经理将使用我们的应用程序，我们不能假设这些名称在所有账户中是唯一的。我们应用程序的大多数用户可能会有一个名为“1”的表格。因此，当餐厅顾客表示他或她在1号桌上并需要服务时，我们必须能够从潜在的许多餐厅中选择正确的1号桌。为了解决这个问题，我们数据库中的每个表格都将有一个唯一的ID，我们将使用它来在URL中标识表格，但我们将在“账户”页面上显示用户选择的名称（例如“1”），以便我们的用户可以轻松管理他们的个人表格列表。
- en: When we insert a new item into our database, we'll get the unique ID of that
    item. But, because we want to use the ID as part of the URL, we get into a sort
    of chicken-or-egg-first situation where we need to insert the table into the database
    in order to get the ID, but we also need the ID in order to create the URL before
    we can properly insert the table into the database.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向数据库中插入新项目时，我们将获得该项目的唯一ID。但是，因为我们想要将ID作为URL的一部分使用，我们陷入了一种先有鸡还是先有蛋的情况，我们需要将表格插入数据库以获得ID，但我们也需要ID以便在正确地将表格插入数据库之前创建URL。
- en: To solve this problem, we have to insert a half-created table into our database
    to get the ID, then use the ID to create the URL, and then update the table we
    just created to associate it with the URL.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们必须将一个半创建的表格插入到我们的数据库中以获得ID，然后使用ID创建URL，然后更新我们刚刚创建的表格以将其与URL关联起来。
- en: 'Add the following route to your `waitercaller.py` file which does this (or
    rather, will do this once we''ve created the required functions in our database
    code):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下路由添加到`waitercaller.py`文件中，以执行此操作（或者说，一旦我们在数据库代码中创建了所需的函数，它将执行此操作）：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that we structure all the functionality of our application that is related
    to our account page under a `sub-route /account/`. We preface the function name
    for routes that belong to the account with `account_`. This helps us have clearer
    sections in our application code, which can become messy and unmaintainable as
    we add more and more routes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将与账户页面相关的应用程序功能结构化为`子路由/account/`。我们在属于账户的路由的函数名称前加上`account_`。这有助于我们在应用程序代码中拥有更清晰的部分，随着我们添加更多路由，代码可能会变得混乱和难以维护。
- en: We have to associate each table with an owner, so we use the `FlaskLogin current_user`
    functionality to get the currently logged-in user's ID. We're also going to use
    our `config.py` file to define the base URL to be associated with the tables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将每个表与所有者关联起来，因此我们使用`FlaskLogin current_user`功能来获取当前登录用户的ID。我们还将使用我们的`config.py`文件来定义要与表关联的基本URL。
- en: 'Add the following imports to `waitercaller.py` in order to use the `current_user`
    functionality and access our `config`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下导入添加到`waitercaller.py`中，以使用`current_user`功能并访问我们的`config`：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following to the `config.py` file (remember, this isn''t part of the
    Git repository, so this value is only used for local development):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到`config.py`文件中（请记住，这不是Git存储库的一部分，因此此值仅用于本地开发）：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding URL is exactly equivalent to `localhost:5000` that we've been
    using, as `127.0.0.1` is a special IP address that always points back to your
    own machine. However, we'll use an IP address in our `config` instead of `localhost`
    to maintain compatibility with the Bitly API that we'll use in the next section,
    Shortening URL's using the bitly API, of this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 上述URL与我们一直在使用的`localhost:5000`完全相同，因为`127.0.0.1`是一个特殊的IP地址，总是指向自己的机器。但是，我们将在`config`中使用IP地址而不是`localhost`，以保持与我们将在本章的下一节中使用的Bitly
    API的兼容性，即缩短URL。
- en: Adding the create table database code
  id: totrans-69
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加创建表数据库代码
- en: 'The mock database code for our tables is similar to that for our users and
    passwords. Create the following list of dictionaries at the top of the `mockdbhelper.py`
    file to store your tables:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表的模拟数据库代码类似于我们的用户和密码的模拟数据库代码。在`mockdbhelper.py`文件的顶部创建以下字典列表，用于存储您的表：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code also creates a single table, `1`, and assigns it to our mock
    user. Note that `1,` which is the value of the `_id` key, is the ID number that,
    for our production system, will be unique across all user accounts. The `1` that
    is the value of the `number` key is the user-chosen value that might be duplicated
    across different users of our system. Because we only have one test user, we'll
    simplify our mock code, and always use the same value for both the unique ID and
    the user-chosen number.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码还创建了一个单一的表`1`，并将其分配给我们的模拟用户。请注意，`1`是`_id`键的值，对于我们的生产系统，它将是所有用户帐户中唯一的ID号。`number`键的值为`1`是用户选择的值，可能会在系统的不同用户之间重复。因为我们只有一个测试用户，我们将简化我们的模拟代码，并始终为唯一ID和用户选择的数字使用相同的值。
- en: 'For our mock database, adding a table is simply appending a new dictionary
    that represents a table to our list of existing mock tables. Add the following
    method to the `mockdbhelper.py` file:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的模拟数据库，添加表就是简单地将代表表的新字典附加到现有的模拟表列表中。将以下方法添加到`mockdbhelper.py`文件中：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We return `number` from this function, which is the mock ID. In our test code,
    this is the same value that was input to this function. In our real code, this
    number will be the generated ID, and will be different from the input.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从此函数返回`number`，这是模拟ID。在我们的测试代码中，这是输入到此函数的相同值。在我们的真实代码中，这个数字将是生成的ID，并且将与输入不同。
- en: 'Finally, we need to add the `update_table()` method that will allow us to associate
    a URL with a table. Add the following method to `mockdbhelper.py`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加`update_table()`方法，这将允许我们将URL与表关联起来。将以下方法添加到`mockdbhelper.py`中：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our application code gives the preceding method both the table ID generated
    by the `add_table()` method and the URL to associate with the table. The `update_table()`
    method then finds the correct table and associates the URL with the table. Again,
    the for loop through a list might look inefficient as opposed to using a dictionary,
    but it's important for our mock database code to use the same ideas as the real
    database code that we'll write in the next chapter. As our real database will
    store a collection of tables, our mock code emulates this by storing them in a
    list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序代码为上述方法提供了由`add_table()`方法生成的表ID以及要与表关联的URL。然后，`update_table()`方法找到正确的表并将URL与表关联起来。再次强调，通过列表进行循环可能看起来效率低下，而不是使用字典，但对于我们的模拟数据库代码来说，使用与我们将在下一章中编写的真实数据库代码相同的思想是很重要的。因为我们的真实数据库将存储一系列表，我们的模拟代码通过将它们存储在列表中来模拟这一点。
- en: Adding the view table database code
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加查看表数据库代码
- en: We now have the functionality for adding new tables in place, but we can't see
    them yet. We want all the existing tables to be listed on the account page so
    that we can see which tables exist, have the ability to delete them, and view
    their URLs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经具备了添加新表的功能，但我们还看不到它们。我们希望在账户页面上列出所有现有的表，以便我们可以看到存在哪些表，有能力删除它们，并查看它们的URL。
- en: 'Adding the following method to `mockdbhelper.py` will allow us to access the
    existing tables of a specific user:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到`mockdbhelper.py`中，将允许我们访问特定用户的现有表：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Again, we simplify and have our test code ignore the `owner_id` argument and
    return all the tables (as we only have one test user). However, it's important
    that our mock methods take the same inputs and outputs as our real methods will,
    as we don't want our application code to be aware of whether it is running production
    or test code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 再次简化并让我们的测试代码忽略`owner_id`参数并返回所有表（因为我们只有一个测试用户）。但是，我们的模拟方法必须接受与我们真实方法相同的输入和输出，因为我们不希望我们的应用程序代码知道它是在运行生产代码还是测试代码。
- en: Modifying the account route to pass table data
  id: totrans-84
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改账户路由以传递表格数据
- en: 'We should get the latest information about the tables from the database and
    display these tables to the user each time our account page is loaded. Modify
    the `/account` route in `waitercaller.py` to look as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该从数据库中获取有关表的最新信息，并在每次加载我们的账户页面时向用户显示这些表。修改`waitercaller.py`中的`/account`路由如下：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This preceding method now gets the tables from the database and passes the data
    through to the template.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法现在从数据库获取表，并将数据传递给模板。
- en: Modifying the template to show the tables
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 修改模板以显示表格
- en: Our template now has access to the table data, so all we need to do is to loop
    through each table and display the relevant information. The terminology used
    could get a bit confusing at this point, as we will use an HTML table to display
    information about our virtual restaurant tables, even though the uses of the word
    table are unrelated. HTML tables are a way to display tabulated data, which in
    our case is data about the restaurant tables.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模板现在可以访问表格数据，所以我们只需要循环遍历每个表并显示相关信息。此时使用的术语可能会有点令人困惑，因为我们将使用HTML表来显示有关我们虚拟餐厅桌子的信息，即使表的用法是不相关的。HTML表是一种显示表格数据的方式，在我们的情况下是有关餐厅桌子的数据。
- en: 'In the `account.html` file, add the following code beneath the line `<h2>tables</h2>`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在`account.html`文件中，在`<h2>tables</h2>`行下面添加以下代码：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code creates a simple table of tables, displaying the table number
    (user chosen), the URL, and a delete button for each table. Each table is, in
    fact, a form that submits a request to delete that specific table. In order to
    do this, we also use a hidden input containing the unique ID of each table. This
    ID is passed along with the `delete` request so that our application code knows
    which table to delete from the database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个简单的表格，显示了表格编号（用户选择）、URL和每个表的删除按钮。实际上，每个表都是一个提交请求以删除特定表的表单。为了做到这一点，我们还使用了包含每个表的唯一ID的隐藏输入。此ID将随着`delete`请求一起传递，以便我们的应用程序代码知道从数据库中删除哪个表。
- en: Adding the delete table route to our backend code
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在后端代码中添加删除表路由
- en: 'Add the following route to your `waitercaller.py` file, which simply accepts
    the table ID that needs to be deleted and then asks the database to delete it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`waitercaller.py`文件中添加以下路由，它只接受需要删除的表ID，然后要求数据库删除它：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create the following method in `mockdbhelper.py`, which accepts a table ID
    and deletes that table:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mockdbhelper.py`中创建以下方法，它接受一个表ID并删除该表：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Similar to the update code that we wrote earlier, it's necessary to loop through
    the mock tables to find the one with the correct ID before we can delete it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前编写的更新代码类似，必须在删除之前循环遍历模拟表以找到具有正确ID的表。
- en: Testing the restaurant table code
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试餐厅桌子代码
- en: 'We''ve added quite a lot of code to our application. Since a lot of the different
    sections of code that we''ve added depend on each other, it has been difficult
    to actually run the code while writing it. However, now we have the functionality
    to create, view, and delete tables, so we can now give our application another
    test run. Fire up the application, log in, and navigate to the **Account** page.
    You should see the single mock table and be able to add more using the create
    table form. Play around by adding new tables and deleting the existing ones. When
    you add tables, they should get a URL associated with them based on their number
    (remember that for our production application, this number will be a long unique
    identifier instead of simply the number that we choose for our table). The interface
    should look like the following image:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的应用程序中添加了相当多的代码。由于我们添加的许多不同代码部分彼此依赖，因此在编写代码时实际运行代码是困难的。但是，现在我们有了创建、查看和删除表的功能，所以我们现在可以再次测试我们的应用程序。启动应用程序，登录，并导航到**账户**页面。您应该看到单个模拟表，并能够使用创建表单添加更多表。通过添加新表和删除现有表来进行操作。当您添加表时，它们应该根据其编号获得与它们相关联的URL（请记住，对于我们的生产应用程序，此编号将是一个长的唯一标识符，而不仅仅是我们为表选择的编号）。界面应该如下图所示：
- en: '![Testing the restaurant table code](img/B04312_10_04.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![测试餐厅桌子代码](img/B04312_10_04.jpg)'
- en: 'Also take another look at the mobile view for this page by resizing the browser
    window, making it narrow enough to trigger the layout switch. Note that because
    we''ve used Bootstrap''s responsive layout features, the **Delete** buttons shunt
    up closer to the URLs and the **Create** button moves beneath the text input,
    as in the following image:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 还要通过调整浏览器窗口的大小来再次查看此页面的移动视图，使其变窄以触发布局切换。请注意，由于我们使用了Bootstrap的响应式布局功能，**删除**按钮会靠近URL，**创建**按钮会移动到文本输入下方，如下图所示：
- en: '![Testing the restaurant table code](img/B04312_10_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![测试餐厅桌子代码](img/B04312_10_05.jpg)'
- en: This might not look quite as good as the full-sized view, but it'll certainly
    be helpful to our visitors who want to use our site from their phones, as they
    won't need to worry about zooming in or scrolling sideways to access all the functionality
    of our site.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不如全尺寸视图那么好，但对于我们的访问者来说肯定会很有帮助，他们想要从手机上使用我们的网站，因为他们不需要担心放大或横向滚动来访问我们网站的所有功能。
- en: Shortening URLs using the bitly API
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用bitly API缩短URL
- en: Our users will not want to type in the long URLs that we currently provide for
    calling a waiter to their table. We'll now look at using the bitly API to create
    shorter equivalents of the URLs that we've already created. The shorter URLs,
    which can be typed into address bars (especially on mobile devices) more easily,
    will then be shown as being associated with the corresponding tables instead of
    the longer ones we have now.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户不想输入我们目前提供的长URL来呼叫服务员到他们的桌子。我们现在将使用bitly API来创建我们已经创建的URL的更短的等价物。这些更短的URL可以更容易地输入到地址栏中（特别是在移动设备上），然后将显示为与当前更长的URL相关联的相应桌子。
- en: Introducing Bitly
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Bitly
- en: The premise behind Bitly—and many similar services—is simple. Given a URL of
    arbitrary length, the service returns a shorter URL of the form `bit.ly/XySDj72`.
    Bitly and similar services normally have very short root domains (bit.ly is five
    letters), and they simply maintain a database that links the short URLs they create
    to the longer ones input by the users. Because they use a combination of lower-
    and uppercase characters as well as digits to create the shortened URLs, there
    is no shortage of combinations to use, even while keeping the total length of
    the URL very short.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Bitly及许多类似服务背后的原理很简单。给定任意长度的URL，该服务返回形式为`bit.ly/XySDj72`的更短URL。Bitly和类似服务通常具有非常短的根域（bit.ly是五个字母），它们只是维护一个数据库，将用户输入的长URL链接到它们创建的短URL。因为它们使用大小写字母和数字的组合来创建缩短的URL，所以即使保持URL的总长度非常短，也不会缺乏组合。
- en: Using the bitly API
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bitly API
- en: As with the other APIs that we have used, bitly is free to use within certain
    limitations, but requires registration in order to get an API token. The bitly
    API is accessed over HTTPS and returns JSON responses (similar to what we've seen
    before). To interface with the API, we'll use a few lines of Python along with
    the `urllib2` and `json` standard libraries.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们使用过的其他API一样，bitly是免费使用的，但在一定的限制内需要注册才能获得API令牌。bitly API通过HTTPS访问，并返回JSON响应（与我们之前看到的类似）。为了与API进行交互，我们将使用几行Python代码以及`urllib2`和`json`标准库。
- en: Getting a bitly oauth token
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取bitly oauth令牌
- en: At the time of writing, bitly offers two ways of authenticating with their API.
    The first is to use an API token given to you when you register. The second way
    is to use an oauth token. As API tokens are being deprecated by bitly, we'll be
    using an oauth token.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，bitly提供了两种验证其API的方式。第一种是在注册时给你的API令牌。第二种方式是使用oauth令牌。由于bitly正在淘汰API令牌，我们将使用oauth令牌。
- en: The first step is to register an account on [bitly.com](http://bitly.com) and
    confirm your e-mail address. Simply head over to [bitly.com](http://bitly.com),
    hit the **Sign up** button, and give a username, e-mail address and password.
    Click the confirmation link that they send to the provided e-mail, and sign in
    to your bitly account.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是在[bitly.com](http://bitly.com)上注册一个帐户并确认您的电子邮件地址。只需转到[bitly.com](http://bitly.com)，点击**注册**按钮，然后提供用户名、电子邮件地址和密码。点击他们发送到提供的电子邮件的确认链接，并登录到您的bitly帐户。
- en: 'To register for an oauth token, go to [https://bitly.com/a/oauth_apps](https://bitly.com/a/oauth_apps)
    and enter your password again when prompted. You should now see your new oauth
    token displayed on the screen. Copy this, as we''ll need it in the Python code
    that we''re about to write. It should look something like this: `ad922578a7a1c6065a3bb91bd62b02e52199afdb`'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册oauth令牌，请转到[https://bitly.com/a/oauth_apps](https://bitly.com/a/oauth_apps)，并在提示时再次输入密码。现在您应该在屏幕上看到您的新oauth令牌。复制这个，因为我们将在接下来要编写的Python代码中需要它。它应该看起来像这样：`ad922578a7a1c6065a3bb91bd62b02e52199afdb`
- en: Creating the bitlyhelper file
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建bitlyhelper文件
- en: Following the pattern we've used throughout the building of this web application,
    we'll create a `BitlyHelper` class to shorten the URLs. Again, this is good practice,
    as it allows us to easily replace just this module with another link shortening
    service if we ever need to. Create a file named `bitlyhelper.py` in your `waitercaller`
    directory and add the following code, substituting your bitly oauth token as appropriate.
    The token in the following snippet is valid for this Waiter Caller application.
    You should substitute the token that you received by following the steps outlined
    above.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在构建这个Web应用程序的整个过程中使用的模式，我们将创建一个`BitlyHelper`类来缩短URL。同样，这是一个很好的做法，因为它允许我们在需要时轻松地用另一个链接缩短服务替换这个模块。在您的`waitercaller`目录中创建一个名为`bitlyhelper.py`的文件，并添加以下代码，根据需要替换您的bitly
    oauth令牌。以下代码片段中的令牌对于此Waiter Caller应用程序是有效的。您应该按照上述步骤获得的令牌进行替换。
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This class, `BitlyHelper`, provides a single method that takes in a long URL
    and returns a short one. There should be nothing about the last code snippet that
    is difficult to understand, as it only uses the ideas we've already seen while
    using JSON-based APIs over HTTP.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`BitlyHelper`类提供了一个方法，它接受一个长URL并返回一个短URL。关于最后一个代码片段没有什么难以理解的地方，因为它只是使用了我们在使用基于JSON的API通过HTTP时已经看到的想法。
- en: Using the bitly module
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用bitly模块
- en: 'To use our bitly code, we simply need to create a `BitlyHelper` object in our
    main application code, and then use it to create a short URL every time a new
    restaurant table is created. Modify the globals section of `waitercaller.py` as
    follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的bitly代码，我们只需要在我们的主应用程序代码中创建一个`BitlyHelper`对象，然后在每次创建新的餐厅桌子时使用它来创建一个短URL。修改`waitercaller.py`的全局部分如下：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And add the import for `BitlyHelper()` to the imports section of `waitercaller.py`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`BitlyHelper()`的导入添加到`waitercaller.py`的导入部分：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now modify the `createtable` method to read as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在修改`createtable`方法如下：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Fire up the app and go to the account page again. Create a new table, and you
    should see that the URL of the new table is a bitly URL. If you visit this URL
    in the browser, you'll see that it automatically redirects to something like `http://127.0.0.1/newrequest/2`
    (which, in turn, should throw a server error at this point).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序并再次转到账户页面。创建一个新表，你会看到新表的URL是一个bitly URL。如果你在浏览器中访问这个URL，你会发现它会自动重定向到类似`http://127.0.0.1/newrequest/2`的东西（这时应该会抛出服务器错误）。
- en: Now that we can associate a short URL with every new table created, we need
    to add the idea of a *request* to our application, so that when our users' patrons
    visit these URLs, we notify the restaurant of the request for attention.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将短网址与每个新创建的表关联起来，我们需要在我们的应用程序中添加*请求*的概念，这样当我们的用户的顾客访问这些网址时，我们就会通知餐厅需要关注的请求。
- en: Adding functionality to handle attention requests
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加处理关注请求的功能
- en: We need to deal with two aspects of attention requests. The first, as discussed
    earlier, is to create new requests when a user visits a URL. The second is to
    allow the waiters of the restaurant to view these requests and mark them as resolved.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要处理关注请求的两个方面。第一个，正如前面讨论的，是当用户访问URL时创建新的请求。第二个是允许餐厅的服务员查看这些请求并将它们标记为已解决。
- en: Writing the attention request code
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写关注请求代码
- en: 'When a user visits a URL, we should create an attention request and store it
    in the database. This attention request should contain:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户访问URL时，我们应该创建一个关注请求并将其存储在数据库中。这个关注请求应该包含：
- en: The time the request was made
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求发出的时间
- en: The table from which the request was made
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发出请求的桌子
- en: As before, we'll just use a Python dictionary to represent the *attention request
    object*. We need to have our application code create new attention requests and
    allow these requests to be added, retrieved, and deleted from the database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们将使用Python字典来表示*关注请求对象*。我们需要让我们的应用程序代码创建新的关注请求，并允许这些请求被添加、检索和从数据库中删除。
- en: Adding the attention request route
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加关注请求路由
- en: 'Add the following route to `waitercaller.py`:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`中添加以下路由：
- en: '[PRE23]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This route matches a dynamic table ID. Since our URLs use the globally unique
    table ID and not the user-chosen table number, we don't need to worry about which
    restaurant owns the table. We tell our database to create a new request, which
    contains the table ID and the current time. We then display a message to the patron,
    notifying him or her that the request was successfully made. Note that this is
    the only route for the application that our users' patrons will use. The rest
    of the routes are all intended to be used only by the restaurant managers or waiters
    themselves.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个路由匹配一个动态的表ID。由于我们的URL使用全局唯一的表ID而不是用户选择的表号，我们不需要担心哪个餐厅拥有这张桌子。我们告诉我们的数据库创建一个新的请求，其中包含表ID和当前时间。然后我们向顾客显示一条消息，通知他或她请求已成功发出。请注意，这是我们的用户的顾客将使用的应用程序的唯一路由。其余的路由都只用于餐厅经理或服务员自己使用。
- en: 'We also need the Python `datetime` module to get the current time. Add the
    following line to your imports section in `waitercaller.py`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要Python的`datetime`模块来获取当前时间。在`waitercaller.py`的导入部分添加以下行：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Adding the attention request database code
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加关注请求数据库代码
- en: 'The database code for the attention requests uses the same ideas as the code
    we recently added for dealing with restaurant tables. Add the following global
    at the top of `mockdbhelper.py`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 关注请求的数据库代码使用了与我们最近添加的处理餐厅桌子的代码相同的思想。在`mockdbhelper.py`的顶部添加以下全局变量：
- en: '[PRE25]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding global creates a single mock attention request for table number
    1 (an existing mock table) and sets the time of the request to be the time when
    we started the `waitercaller` app by running:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的全局变量为表号1（现有的模拟表）创建了一个单独的模拟关注请求，并将请求时间设置为我们启动`waitercaller`应用程序时的时间。
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Whenever we make changes to our app during development, the server restarts,
    and this time will also be updated to the current time whenever this happens.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们在开发过程中对我们的应用程序进行更改时，服务器都会重新启动，这时的时间也会更新为当前时间。
- en: 'We also need to add the import for the `datetime` module to the top of the
    `dbconfig.py` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在`dbconfig.py`文件的顶部添加`datetime`模块的导入：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the actual `add_request()` method, it is again important to distinguish
    between the table number (user chosen) and the table ID (globally unique across
    all our users). The URL used for creating the request made use of the globally
    unique ID, but the waiters will want to see the human readable table name next
    to the request notification. At the time of adding a request, we therefore find
    the table number associated with the table ID and include that as part of the
    stored request.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的`add_request()`方法，重要的是要区分表号（用户选择的）和表ID（在我们所有用户中全局唯一）。用于创建请求的URL使用了全局唯一ID，但服务员希望在请求通知旁边看到可读的表名。因此，在添加请求时，我们找到与表ID相关联的表号，并将其包含在存储的请求中。
- en: 'Add the following method to `mockdbhelper.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mockdbhelper.py`中添加以下方法：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Again, we use `table_id` as the unique ID for our dictionary that represents
    a request. As before, when we add a real database, we will generate a new request
    ID here, which will not be the same as our table ID.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们使用`table_id`作为表示请求的字典的唯一ID。和以前一样，当我们添加一个真正的数据库时，我们会在这里生成一个新的请求ID，这个ID不会和我们的表ID相同。
- en: Add the get and delete methods for attention requests
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加关注请求的获取和删除方法
- en: 'While we are editing the database code, add the following methods as well:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在编辑数据库代码的同时，也添加以下方法：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The first method gets all attention requests for a specific user and will be
    used to populate our dashboard page with all the unresolved requests that require
    attention from waiters. The second deletes a specific request and will be used
    (also from the dashboard page) when waiters mark a request as resolved.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个方法获取特定用户的所有关注请求，将用于在我们的仪表板页面上填充所有需要服务员关注的未解决请求。第二个删除特定的请求，并将用于（同样是从仪表板页面）当服务员标记请求为已解决时。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If our Waiter Caller application aimed to provide more advanced functionality,
    we might add a property to requests to mark them as resolved, instead of deleting
    them outright. If we wanted to provide an analysis on how many requests were being
    made, how long they took on an average to be resolved, and so on, then keeping
    the resolved requests would be essential. For our simple implementation, resolved
    requests are of no further use, and we simply delete them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的Waiter Caller应用旨在提供更高级的功能，我们可能会向请求添加一个属性，将它们标记为已解决，而不是直接删除它们。如果我们想要提供有关有多少请求正在进行，平均需要多长时间才能解决等分析，那么保留已解决的请求将是必不可少的。对于我们简单的实现来说，已解决的请求没有进一步的用处，我们只是删除它们。
- en: Modifying the dashboard route to use attention requests
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改仪表板路由以使用关注请求
- en: When the restaurant manager or waiter opens the dashboard of the app, they should
    see all current attention requests along with the time when the request was made
    (so that the patrons who have been waiting for longer can be prioritized). We
    have the time the request was logged, so we'll calculate the time elapsed since
    the request was made.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当餐厅经理或服务员打开应用程序的仪表板时，他们应该看到所有当前的关注请求以及请求被发出的时间（以便可以优先处理等待时间更长的顾客）。我们有请求被记录的时间，所以我们将计算自请求被发出以来经过的时间。
- en: 'Modify the `dashboard()` route in `waitercaller.py` to read as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`waitercaller.py`中的`dashboard()`路由如下所示：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The modified `dashboard()`route grabs all the attention requests that belong
    to the currently logged in user, using `current_user.get_id()` as before. We calculate
    a *delta time* for each request (the current time minus the request time) and
    add this as an attribute for each request in our requests list. Then we pass the
    updated list through to the template.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 修改后的`dashboard()`路由会获取属于当前登录用户的所有关注请求，使用`current_user.get_id()`和以前一样。我们为每个请求计算一个*时间差*（当前时间减去请求时间），并将其添加为我们请求列表中每个请求的属性。然后我们将更新后的列表传递到模板中。
- en: Modifying the template code to display attention requests
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改模板代码以显示关注请求
- en: We want our dashboard code to check if any attention requests exist and then
    to display each of these in a way similar to the way the tables are displayed
    on the account page. Every attention request should have a **Resolve** button
    to allow the waiter to indicate that he has dealt with the request.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的仪表板代码检查是否存在任何关注请求，然后以类似于账户页面上显示表格的方式显示每个请求。每个关注请求都应该有一个**解决**按钮，允许服务员指示他已处理该请求。
- en: If no attention requests exist, we should display the same message we had displayed
    on the dashboard page previously, indicating that all the patrons are currently
    satisfied.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在关注请求，我们应该显示与之前在仪表板页面上显示的相同消息，指示当前所有顾客都满意。
- en: 'Add the following code to the body of `dashboard.html`, removing the placeholder
    statement that we added previously:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`dashboard.html`的主体中，删除我们之前添加的占位符语句：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is very similar to the table code we saw for the `accounts`
    template. Instead of the **Delete** button, we have a **Resolve** button, which
    similarly uses a hidden text input containing the request ID to resolve the correct
    attention request.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与我们在`accounts`模板中看到的表格代码非常相似。我们没有**删除**按钮，而是有一个**解决**按钮，类似地使用包含请求ID的隐藏文本输入来解决正确的关注请求。
- en: Adding the resolve request application code
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加解决请求应用程序代码
- en: 'Let''s add the application code to handle resolving requests. Similar to the
    way we used the sub-route `/account` for all our account functionality, we use
    `/dashboard` in the form discussed earlier. Add the following route to `waitercaller.py`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加应用程序代码来处理解决请求。类似于我们在所有账户功能中使用子路由`/account`的方式，我们在`/dashboard`中使用了前面讨论过的形式。将以下路由添加到`waitercaller.py`中：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've already added the database code to remove an attention request, so here
    we simply need to call that code with the correct request ID, which we have from
    the hidden field in our template.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了数据库代码来删除关注请求，所以在这里我们只需要使用正确的请求ID调用该代码，我们可以从模板中的隐藏字段中获取。
- en: With that, most of the functionality of our application should be testable.
    Let's try it out!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们应用程序的大部分功能应该是可测试的。让我们试试看！
- en: Testing the attention request code
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试关注请求代码
- en: 'Fire up the app, and test out all the new functionality. First, navigate to
    the **Account** page and then, in a new tab, navigate to the URL listed for the
    test table (or add a new table and use the new URL to retest the earlier code
    as well). You should see the ''**Your request has been logged and a waiter will
    be with you shortly**'' message as in the following image:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 启动应用程序，测试所有新功能。首先，导航到**账户**页面，然后在新标签中导航到测试表格的URL（或添加新表格并使用新URL重新测试先前的代码）。您应该看到'**您的请求已被记录，服务员将很快与您联系**'的消息，如下图所示：
- en: '![Testing the attention request code](img/B04312_10_06.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![测试关注请求代码](img/B04312_10_06.jpg)'
- en: 'Now go back to the application and navigate to the **Dashboard** page. You
    should see the mock request as well as the new request you just created by visiting
    the URL, as seen in the following screenshot:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在返回应用程序并导航到**仪表板**页面。您应该看到模拟请求以及您刚刚通过访问URL创建的新请求，如下截图所示：
- en: '![Testing the attention request code](img/B04312_10_07.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![测试关注请求代码](img/B04312_10_07.jpg)'
- en: Refresh the page and note that the values in the '**Wait**' column get incremented
    appropriately (every refresh will recalculate the deltas in the application code).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新页面并注意'**等待**'列中的值适当增加（每次刷新都会重新计算应用程序代码中的时间差）。
- en: Auto-refreshing the dashboard page
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动刷新仪表板页面
- en: The waiters will not want to constantly refresh the dashboard in order to check
    for new requests and to update the wait times on the existing one. We'll add a
    meta HTML tag to tell the browser that the page should be refreshed at regular
    intervals. We'll add a generic placeholder for meta tags in our base template
    and then override it with the refresh tag in our `dashboard.html` template.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 服务员不希望不断刷新仪表板以检查新请求并更新现有请求的等待时间。我们将添加一个元HTML标签，告诉浏览器页面应定期刷新。我们将在基本模板中添加一个通用的元标签占位符，然后在我们的`dashboard.html`模板中用刷新标签覆盖它。
- en: 'In the `dashboard.html` file, add a Jinja block that contains the meta HTML
    tag above the content block:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`dashboard.html`文件中，添加一个包含元HTML标签的Jinja块，位于内容块上方：
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Meta HTML tags indicate messages that don't directly relate to the content that
    we are serving. They can also be used to add information about the author of a
    page or to give a list of keywords that search engines may use while indexing
    the page. In our case, we're specifying a meta tag that asks the browser to refresh
    every ten seconds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 元HTML标签指示与我们提供的内容没有直接关系的消息。它们也可以用来添加关于页面作者的信息，或者给出搜索引擎在索引页面时可能使用的关键词列表。在我们的情况下，我们正在指定一个要求浏览器每十秒刷新一次的元标签。
- en: 'In the `base.html` file, create an equivalent empty placeholder:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在`base.html`文件中，创建一个等效的空占位符：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now open the app in your browser again and navigate to the dashboard page. Every
    10 seconds, you should see the page refresh and the wait times update. If you
    create new attention requests, you'll see these appear after the automatic refresh
    as well.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在再次在浏览器中打开应用程序并导航到仪表板页面。每10秒，您应该看到页面刷新并等待时间更新。如果您创建新的关注请求，您还将在自动刷新后看到这些请求。
- en: Adding user feedback with WTForms
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WTForms添加用户反馈
- en: We now have a web application that is largely functional, but still fails to
    provide the user with helpful feedback, especially when it comes to submitting
    web forms. Let's look at how to make our application more intuitive by providing
    feedback when the user succeeds or fails to complete various actions.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个基本上功能齐全的Web应用程序，但在提交Web表单时仍未能为用户提供有用的反馈。让我们看看如何通过在用户成功或失败完成各种操作时提供反馈来使我们的应用程序更直观。
- en: 'To make our life easier, we''ll use another Flask add-on, WTForms, which lets
    us validate inputs by using prespecified patterns or by creating our own. We''ll
    use WTForms to implement all our web forms, namely:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们的生活更轻松，我们将使用另一个Flask附加组件WTForms，它让我们通过使用预定义模式或创建自己的模式来验证输入。我们将使用WTForms来实现所有我们的Web表单，即：
- en: The registration form
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表格
- en: The sign-in form
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录表格
- en: The create table form
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表格表单
- en: Introducing WTForms
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入WTForms
- en: You might have noticed that creating the registration form for new users to
    sign up for our web app was a bit cumbersome. We had to create the HTML form in
    our template file and then fetch all the input data when the form was submitted
    in our Python backend code. In order to do this, we had to use the same strings,
    such as `email` and `password`, in our HTML code (for the `name` attribute) and
    in our Python code (to load the data from the various fields into variables).
    These strings, `email` and `password`, are examples of what are sometimes called
    *magic strings*. It might seem obvious to us, while creating the application,
    that the strings have to be the same in both the files, but to another developer
    who might need to maintain the application in the future, or even to our future
    selves, this implicit link might be a lot less obvious and more confusing.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，为新用户创建注册表格以注册我们的Web应用程序有点麻烦。我们不得不在模板文件中创建HTML表单，然后在表单提交时在我们的Python后端代码中获取所有输入数据。为了做到这一点，我们不得不在我们的HTML代码（用于`name`属性）和我们的Python代码（将数据从各个字段加载到变量中）中使用相同的字符串，如`email`和`password`。这些字符串`email`和`password`是有时被称为*魔术字符串*的例子。对于我们来说，创建应用程序时，这些字符串必须在两个文件中相同可能是显而易见的，但对于将来可能需要维护应用程序的另一个开发人员，甚至对于我们自己的未来，这种隐含的联系可能会变得不那么明显和更加令人困惑。
- en: Furthermore, we had to use a fairly ugly `if` statement in our application code
    to make sure that the passwords matched. It turns out that we want to do much
    more validation on user input than just checking that the passwords match. We
    probably want to also validate that the e-mail address looks like an e-mail address,
    that the password isn't too short, and possibly more besides. As our user-input
    forms get longer, and the validation rules get more complicated, we can see that
    our application code would quickly get pretty messy if we carried on developing
    forms as we have been doing so far.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们不得不在应用程序代码中使用相当丑陋的`if`语句来确保密码匹配。事实证明，我们希望对用户输入进行更多验证，而不仅仅是检查密码是否匹配。我们可能还希望验证电子邮件地址是否看起来像电子邮件地址，密码是否不太短，以及可能还有其他验证。随着用户输入表单变得越来越长，验证规则变得更加复杂，我们可以看到，如果我们继续像迄今为止那样开发表单，我们的应用程序代码很快就会变得非常混乱。
- en: Finally, as mentioned earlier, our forms failed to provide the user with helpful
    feedback when things went wrong.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，正如前面提到的，当事情出错时，我们的表单未能为用户提供有用的反馈。
- en: WTForms solves all of these problems in a simple and intuitive way. We'll soon
    explain how to create Python classes to represent forms. These classes will contain
    validation rules, field types, field names, and feedback messages, all in the
    same place. Our Jinja templates and our application code can then use the *same
    object* to render the form (when the user views the page) and to process the input
    (when the user submits the form). Using WTForms therefore allows us to keep our
    code cleaner and to speed up development. We'll take a quick look at installing
    WTForms for Flask, before diving into how we can use it for improving our application.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: WTForms以一种简单直观的方式解决了所有这些问题。我们很快将解释如何创建代表表单的Python类。这些类将包含验证规则、字段类型、字段名称和反馈消息，所有这些都在同一个地方。然后我们的Jinja模板和应用程序代码可以使用*相同的对象*来呈现表单（当用户查看页面时）和处理输入（当用户提交表单时）。因此，使用WTForms可以使我们的代码更清晰，并加快开发速度。在深入了解如何使用它来改进我们的应用程序之前，我们将快速了解如何为Flask安装WTForms。
- en: Note that WTForms is a general Python web development add-on that works with
    many different Python web development frameworks (such as Flask, Django, and others)
    and template managers (such as Jinja2, Mako, and others). We'll install a Flask-specific
    extension that will install WTForms and make it easy to interface with our Flask
    application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，WTForms是一个通用的Python Web开发附加组件，可以与许多不同的Python Web开发框架（如Flask、Django等）和模板管理器（如Jinja2、Mako等）一起使用。我们将安装一个特定于Flask的扩展，该扩展将安装WTForms并使其易于与我们的Flask应用程序进行交互。
- en: Installing Flask-WTF
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Flask-WTF
- en: 'We need to install the WTForms add-on for Flask. This is done in the same way
    as our previous extensions. Simply run the following command (as always, remembering
    to do it both locally and on your VPS):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为Flask安装WTForms附加组件。这与我们之前的扩展相同。只需运行以下命令（如往常一样，请记住在本地和VPS上都要运行）：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Creating the registration form
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建注册表单
- en: 'Now let''s take a look at building forms. We''ll be building a few forms, so
    we''ll create a new Python file in our project to hold all of these. In your `waitercaller`
    directory, create a file called `forms.py` and add the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看看如何构建表单。我们将构建一些表单，因此我们将在项目中创建一个新的Python文件来保存所有这些内容。在您的`waitercaller`目录中，创建一个名为`forms.py`的文件，并添加以下代码：
- en: '[PRE36]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The class, `RegistrationForm`, inherits from `Form`, a generic form object that
    we find inside the `flask_wtf` extension. Everything else is from the `wtforms`
    module directly (and not from the Flask-specific extension). The form is built
    from a number of different fields—in our case, an `EmailField`, two `PasswordFields`,
    and a `Submit` field. All of these will be rendered as their HTML equivalents
    in our template. We assign each of these desired fields to variables.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 类`RegistrationForm`继承自`Form`，这是我们在`flask_wtf`扩展中找到的通用表单对象。其他所有内容都直接来自`wtforms`模块（而不是来自特定于Flask的扩展）。表单由许多不同的字段构建
    - 在我们的情况下，一个`EmailField`，两个`PasswordField`和一个`Submit`字段。所有这些都将在我们的模板中呈现为它们的HTML等效项。我们将每个所需字段分配给变量。
- en: 'We''ll use these variables to render the fields and to retrieve data from the
    fields. Each time we create a field, we pass in some arguments. The first is a
    string argument to name the form. The second argument is a list of Validators.
    **Validators** are sets of rules that we can use to differentiate between valid
    input and invalid input. WTForms provides all the validators that we need, but
    it''s also easy to write custom validators. We use the following validators:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些变量来呈现字段并从字段中检索数据。每次创建字段时，我们传入一些参数。第一个是一个字符串参数，用于命名表单。第二个参数是验证器列表。**验证器**是一组规则，我们可以使用它们来区分有效输入和无效输入。WTForms提供了我们需要的所有验证器，但编写自定义验证器也很容易。我们使用以下验证器：
- en: '`DataRequired`: This simply means that if the field is left blank, the form
    is invalid for all fields.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DataRequired`：这意味着如果字段为空，表单对所有字段都无效。'
- en: '`Email`: This uses a regular expression to ensure that the e-mail address is
    made up of alphanumeric characters, and has an @ symbol and a full-stop in their
    appropriate places. (Fun fact: this is a surprisingly complicated problem! See
    [http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html).)'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Email`：这使用正则表达式来确保电子邮件地址由字母数字字符组成，并且@符号和句点在适当的位置。（有趣的事实：这是一个令人惊讶地复杂的问题！请参阅[http://www.regular-expressions.info/email.html](http://www.regular-expressions.info/email.html)。）'
- en: '`EqualTo`: This ensures that the data entered in the field is the same as the
    data entered into another field.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EqualTo`：这确保在字段中输入的数据与输入到另一个字段中的数据相同。'
- en: '`Length`: This validator takes optional min and max arguments to define the
    number of characters the data should contain. We set this to a minimum of 8 to
    ensure that our users don''t pick very weak passwords.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Length`：此验证器采用可选的最小和最大参数来定义数据应包含的字符数。我们将其设置为最小8个以确保我们的用户不选择非常弱的密码。'
- en: Recall our discussion of the trade-offs between backend and frontend validation
    and note that these are all backend validation methods, completed server-side.
    Therefore, it is still worthwhile to add the `Email` validator even if the user's
    browser supports HTML5; the fact that it is an `email` field will prevent the
    user from submitting an invalid e-mail address (using a frontend validation check).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我们对后端和前端验证之间的权衡讨论，并注意这些都是后端验证方法，完成在服务器端。因此，即使用户的浏览器支持HTML5，仍然值得添加`Email`验证器；它是一个`email`字段将阻止用户提交无效的电子邮件地址（使用前端验证检查）。
- en: Another thing about validators is that we can add a message argument for each
    validator—not just for each field—and each field can have more than one validator.
    We'll see later how to display this message to the user if that specific validation
    check fails.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关于验证器的另一点是，我们可以为每个验证器添加一个消息参数，而不仅仅是为每个字段，每个字段可以有多个验证器。稍后我们将看到如何在特定的验证检查失败时向用户显示此消息。
- en: It's important to note that the variable names you choose for each form field
    (`email`, `password`, and `password2` in the registration form that we created
    previously) are more important than most variable names because the `name` and
    `id` attributes for the final HTML field will be taken from the variable names.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，您为每个表单字段选择的变量名（在我们之前创建的注册表单中为`email`，`password`和`password2`）比大多数变量名更重要，因为最终HTML字段的`name`和`id`属性将从变量名中获取。
- en: Rendering the registration form
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 渲染注册表单
- en: The next step is to use our form object for rendering an empty registration
    form when a user loads our home page. To do this, we have to modify both our application
    code (to create an instance of the registration form class and pass it to the
    template) and our frontend code (to render our fields from the variables of the
    class, instead of hardcoding them in HTML).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用我们的表单对象来呈现一个空的注册表单，当用户加载我们的主页时。为此，我们必须修改我们的应用程序代码（创建注册表单类的实例并将其传递给模板）和我们的前端代码（从类的变量中呈现我们的字段，而不是在HTML中硬编码它们）。
- en: Updating the application code
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新应用程序代码
- en: In our `waitercaller.py` file, we need to import the form we created, instantiate
    it, and pass it to our template.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`waitercaller.py`文件中，我们需要导入我们创建的表单，实例化它，并将其传递给我们的模板。
- en: 'Add an import for our registration form:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 添加我们的注册表单的导入：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now instantiate the form in our `home()` function and pass the form on to the
    template. The final `home()` function should read as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在我们的`home()`函数中实例化表单并将表单传递给模板。最终的`home()`函数应该如下所示：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Updating the template code
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新模板代码
- en: 'Now that our template has access to an instantiated `RegistrationForm` object,
    we can use Jinja to render the fields of our form. Update the registration form
    in `home.html` to read as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的模板可以访问一个实例化的`RegistrationForm`对象，我们可以使用Jinja来呈现我们表单的字段。更新`home.html`中的注册表单如下：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The Bootstrap boilerplate (the div tags specifying Bootstrap classes) remains
    unchanged, but now, instead of creating input fields in HTML, we call functions
    belonging to our `registrationform` variable that was passed in from the `home()`
    route. Each variable that we declared in our `RegistrationForm` class (`email`,
    `password`, `password2`, and `submit`) is available as a function to which we
    can pass additional HTML attributes as arguments. The `name` and `id` attributes
    will be set automatically based on the variable names we provided when we wrote
    the form, and we can add further attributes, such as `class` and `placeholder`
    by passing them in here. As before, we use '`form-control`' as the class of our
    inputs, and also specify the '`placeholder`' values to prompt the user to input
    information.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap样板（指定Bootstrap类的div标签）保持不变，但现在，我们不再在HTML中创建输入字段，而是调用属于从`home()`路由传入的`registrationform`变量的函数。我们在`RegistrationForm`类中声明的每个变量（`email`，`password`，`password2`和`submit`）都可以作为函数使用，我们可以将额外的HTML属性作为参数传递给这些函数。`name`和`id`属性将根据我们在编写表单时提供的变量名自动设置，我们还可以通过在这里传递它们来添加其他属性，例如`class`和`placeholder`。与以前一样，我们使用“`form-control`”作为输入的类，并指定“`placeholder`”值以提示用户输入信息。
- en: We also render the `csrf_token` field at the beginning of the new code. This
    is a very useful security default that WTForms provides. One of the more common
    web application vulnerabilities is called **Cross Site Request Forgery** (**CSRF**).
    Although a detailed description of this vulnerability falls outside the scope
    of this book, in short, it exploits the fact that cookies are implemented at the
    browser level rather than at a web page level. Because cookies are used for authentication,
    if you log into your one site that is vulnerable to CSRF, and then in a new tab,
    navigate to a malicious site that can exploit a CSRF vulnerability, the malicious
    site can carry out actions on the vulnerable site on your behalf. This is achieved
    by sending across the legitimate cookie (that you created when you logged into
    the vulnerable site), along with an action that requires authentication. In the
    worst case scenario, the vulnerable site is your online banking, and the malicious
    site carries out financial transactions on your behalf, without your knowledge,
    using the CSRF vulnerability. The CSRF token mitigates against this vulnerability
    by adding a hidden field to every form with a cryptographically secure set of
    randomly generated characters. Because the malicious site cannot access this hidden
    field (even though it can access our cookies), we know that a POST request that
    includes these characters originates from our site, and not a malicious third-party
    one. If you find this level of web application security interesting, read more
    about the CSRF vulnerability on the **Open Web Application Security Project**
    (**OWASP**) website ([https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF))).
    Either way, you should always include the CSRF field in all forms—in fact, the
    validation step will fail if you omit it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在新代码的开头呈现了`csrf_token`字段。这是WTForms提供的一个非常有用的安全默认值。其中一个更常见的Web应用程序漏洞称为**跨站请求伪造**（**CSRF**）。虽然对这种漏洞的详细描述超出了本书的范围，但简而言之，它利用了cookie是在浏览器级别而不是在网页级别实现的事实。因为cookie用于身份验证，如果您登录到一个容易受到CSRF攻击的站点，然后在新标签页中导航到一个可以利用CSRF漏洞的恶意站点，那么恶意站点可以代表您在易受攻击的站点上执行操作。这是通过发送合法的cookie（您在登录到易受攻击的站点时创建的）以及需要身份验证的操作来实现的。在最坏的情况下，易受攻击的站点是您的在线银行，而恶意站点会利用CSRF漏洞代表您执行财务交易，而您并不知情。CSRF令牌通过向每个表单添加一个隐藏字段，其中包含一组加密安全的随机生成的字符，来减轻这种漏洞。因为恶意站点无法访问这个隐藏字段（即使它可以访问我们的cookie），我们知道包含这些字符的POST请求来自我们的站点，而不是来自恶意的第三方站点。如果您对这种级别的Web应用程序安全感兴趣，请在**开放Web应用程序安全项目**（**OWASP**）网站上阅读有关CSRF漏洞的更多信息（[https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)））。无论如何，您应该始终在所有表单中包含CSRF字段，事实上，如果您省略它，验证步骤将失败。
- en: Testing the new form
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试新表单
- en: Because we used the same Id and name attributes for our form as we did before,
    our application code for handling the processing of data when the form is submitted
    will still work. Therefore, fire up the application and make sure that everything
    is still working at this point. If all has gone well, the home page of the application
    will look identical to when we last tested our application. You should also be
    able to use your browser's 'view source' function to check that the various form
    fields were converted into various HTML input types as expected.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们在表单中使用了与之前相同的Id和name属性，所以当表单提交时处理数据的应用程序代码仍然有效。因此，启动应用程序，确保在这一点上一切仍然正常工作。如果一切顺利，应用程序的主页将与我们上次测试应用程序时看到的完全相同。您还可以使用浏览器的“查看源代码”功能来检查各种表单字段是否按预期转换为各种HTML输入类型。
- en: Using WTForms in our application code
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的应用程序代码中使用WTForms
- en: The next step is to update our application code to use WTForms for catching
    data that has been input through the form. Now, instead of having to remember
    which "name" attributes we used, we can simply instantiate a new `RegistrationForm`
    object and populate it from the post data received backend. We can also easily
    run all our validation rules and get a list of errors for each field.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是更新我们的应用程序代码，使用WTForms来捕获通过表单输入的数据。现在，我们不必记住使用了哪些“name”属性，而是可以简单地实例化一个新的`RegistrationForm`对象，并从后端接收的post数据填充它。我们还可以轻松运行所有的验证规则，并获得每个字段的错误列表。
- en: 'In `waitercaller.py`, modify the `register()` function to read as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`中，修改`register()`函数如下：
- en: '[PRE40]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the preceding code, the first change is the first line of the function. We
    instantiate a new `RegistrationForm` and populate it by passing in the `request.form`
    object, from which we previously pulled each field individually. As mentioned
    before, it's great that we don't have to hardcode the field names now! We can
    instead access the user's input data through the forms properties, such as `form.email.data`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，第一个更改是函数的第一行。我们实例化了一个新的`RegistrationForm`，并通过传入`request.form`对象来填充它，以前我们是从中逐个提取每个字段的。如前所述，现在我们不必硬编码字段名称了！相反，我们可以通过表单属性访问用户的输入数据，比如`form.email.data`。
- en: The second line is also a big change. We can call `form.validate()` to run all
    our validation rules, and this will return `True` only if all the rules pass,
    else it will populate the form object with all the relevant failure messages.
    The last line of the function, therefore, will only get called if there are validation
    errors. In this case, we now re-render our home page template, passing across
    a fresh copy of the form (which now has a reference to the errors. We'll see how
    to display these in the next step).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行也是一个重大变化。我们可以调用`form.validate()`来运行所有的验证规则，只有当所有规则通过时它才会返回`True`，否则它将填充表单对象的所有相关失败消息。因此，函数的最后一行只有在有验证错误时才会被调用。在这种情况下，我们现在重新渲染我们的主页模板，传递一个新的表单副本（现在有一个指向错误的引用。我们将看到如何在下一步中显示这些错误）。
- en: If the e-mail address is found in our database, we now append an error message
    to the error messages for the e-mail field and re-render the template to pass
    this error back to the frontend.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的数据库中找到电子邮件地址，我们现在会向电子邮件字段的错误消息中追加一个错误消息，并重新渲染模板以将此错误传递回前端。
- en: Note that previously, our three return options were all simply redirected to
    the home page, made using the Flask `redirect()` function. Now we have replaced
    them all with `render_template()` calls, as we need to pass the new form (with
    the error messages added) along to the frontend.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以前，我们的三个返回选项都只是简单地重定向到主页，使用了Flask的`redirect()`函数。现在我们已经用`render_template()`调用替换了它们所有，因为我们需要将新的表单（带有添加的错误消息）传递到前端。
- en: Displaying errors to our user
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向用户显示错误
- en: The final step for our new registration form is to display any errors to the
    user so that the user can fix them and resubmit the form. To do this, we'll add
    some Jinja `if` statements to our template to check if any errors exist in the
    form object and display them if they do. Then we'll add some CSS to make these
    errors appear in red. Finally, we'll look at how we could do all of this more
    concisely (which we'd definitely want if we had more and larger forms).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 新注册表单的最后一步是向用户显示任何错误，以便用户可以修复它们并重新提交表单。为此，我们将在我们的模板中添加一些Jinja `if`语句，检查表单对象中是否存在任何错误，并在存在时显示它们。然后我们将添加一些CSS使这些错误显示为红色。最后，我们将看看如果我们有更多和更大的表单，我们如何更简洁地完成所有这些（如果我们有更多和更大的表单，我们肯定会希望如此）。
- en: Displaying the errors in our template
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在我们的模板中显示错误
- en: All we need to do to display the errors is add an `if` statement above each
    of our input fields, checking if there are any errors to display for that field
    (remember WTForms automatically populates the error lists for our form object
    when we run the `validate()` method). If we find errors to display for that field,
    we need to loop through all of them and display each one. Although, in our case,
    each field can only have a single error, remember that we can add more than one
    validator to each field, so it's definitely possible to have forms which have
    several errors for each field. We don't want the user to have to fix one error
    and resubmit, only to find out that there are still others—instead, the user would
    want to be informed of all errors after a single submission of the form.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示错误，我们只需要在每个输入字段上方添加一个`if`语句，检查是否有任何错误要显示在该字段上（记住WTForms在我们运行`validate()`方法时会自动填充表单对象的错误列表）。如果我们发现要显示在该字段上的错误，我们需要循环遍历所有错误并显示每一个。虽然在我们的情况下，每个字段只能有一个错误，但请记住我们可以为每个字段添加多个验证器，因此每个字段可能有多个错误。我们不希望用户修复一个错误并重新提交，然后发现仍然有其他错误，而是希望用户在一次提交表单后就被告知所有错误。
- en: 'Modify the registration form in `home.html` to read as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 修改`home.html`中的注册表单如下：
- en: '[PRE41]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that we display our errors by building a list (within the `<ul>` tags),
    and that we assign these lists the class attribute of `errors`. We don't have
    any CSS code yet to define what error lists should look like, so let's fix that
    quickly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通过构建列表（在`<ul>`标签内），并将这些列表分配给`errors`类属性来显示我们的错误。我们还没有任何CSS代码来定义错误列表的外观，所以让我们快速解决这个问题。
- en: Adding CSS for the errors
  id: totrans-246
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为错误添加CSS
- en: The CSS code for the errors is the only custom CSS code we'll be using in the
    project (the rest of our CSS is all free with Bootstrap). Therefore, it's fine
    to add our CSS directly into the `base.html` template file (we'll use it in our
    other templates as well), instead of creating a new external CSS file or editing
    the Bootstrap files.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的CSS代码是我们在项目中将使用的唯一自定义CSS代码（我们的其余CSS都是使用Bootstrap免费提供的）。因此，将我们的CSS直接添加到`base.html`模板文件中是可以的（我们将在其他模板中也使用它），而不是创建一个新的外部CSS文件或编辑Bootstrap文件。
- en: If you're curious, take a look at the `bootstrap.min.css` file inside the `static/css`
    directory and note that it's quite difficult to read and modify (it's all in a
    single line!). The reason for this is to make the page load faster—every space
    and newline character makes the file a little bit bigger, which means our users'
    browsers would take longer to download the CSS file that is needed to display
    the web page. This is why large CSS and JavaScript libraries (such as the Bootstrap
    ones) come with a *minified* version (this is what the 'min' in `bootstrap.min.css`
    stands for). If we wanted to add our new CSS code to the Bootstrap file, we'd
    probably add it to the non-minified version and then re-minify it to create the
    minified one that we'd use in production.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您感兴趣，请查看`static/css`目录中的`bootstrap.min.css`文件，并注意它非常难以阅读和修改（它全部都在一行中！）。这是为了使页面加载更快——每个空格和换行符都会使文件变得稍微更大，这意味着我们的用户的浏览器需要更长时间来下载显示网页所需的CSS文件。这就是为什么大型CSS和JavaScript库（如Bootstrap）都带有*minified*版本（这就是`bootstrap.min.css`中的'min'代表的含义）。如果我们想要将新的CSS代码添加到Bootstrap文件中，我们可能会将其添加到非minified版本中，然后重新minify它以创建我们在生产中使用的minified版本。
- en: 'Add the following style between the `<head>` tags of the `base.html` file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`base.html`文件的`<head>`标签之间添加以下样式：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first line in the preceding styling code means that it should only apply
    to `<ul>` elements which have a class of errors (that is, the feedback messages
    we just added to our home page). The next three lines remove the bullet point
    that lists use by default, remove the indent that lists use by default, and set
    the font color to red.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 上述样式代码中的第一行意味着它只适用于具有错误类的`<ul>`元素（即我们刚刚添加到主页的反馈消息）。接下来的三行删除了默认使用的列表项目符号，删除了默认使用的缩进，并将字体颜色设置为红色。
- en: Testing the final registration form
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试最终的注册表单
- en: Our registration form is now finished. It now uses WTForms, so it is cleaner
    and easier to maintain, and we don't have to rely on a developer knowing that
    the HTML `name` attribute has to match up with the Python code. Let's have a look
    to make sure everything still works and that our new error messages are displayed
    when we expect them to be and are not shown when we don't want them.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的注册表现在已经完成。现在它使用了WTForms，因此更清洁，更容易维护，我们不必依赖开发人员知道HTML的`name`属性必须与Python代码匹配。让我们来看看确保一切仍然正常工作，并且我们的新错误消息在我们期望它们显示时显示，并且在我们不希望它们显示时不显示。
- en: 'Run your application again and try to register a new account. Try out various
    combinations of errors, such as using an already registered e-mail address (remember
    that our test database is cleared every time we restart the application), using
    a password that is too short, using non-matching strings for the two `password`
    fields, or using an invalid e-mail address. If all has gone according to plan,
    your form with errors should look similar to the one below:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行应用程序，尝试注册一个新帐户。尝试各种错误组合，例如使用已注册的电子邮件地址（请记住，我们的测试数据库在每次重新启动应用程序时都会被清除），使用太短的密码，使用两个`password`字段的不匹配字符串，或使用无效的电子邮件地址。如果一切按计划进行，您的带有错误的表单应该看起来与下面的表单类似：
- en: '![Testing the final registration form](img/B04312_10_08.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![测试最终的注册表单](img/B04312_10_08.jpg)'
- en: There are a couple of interesting things to note about the last image. First,
    note that the e-mail address `g@1` is taken to be valid by the HTML5 input box
    (frontend validation), but not by the `Email()` validator (backend validation).
    This is why I could submit the form even though I'm using a browser that supports
    the HTML5 e-mail field, and was only told that the e-mail address was invalid
    after the data went to the backend. Second, note that after the form was submitted,
    the e-mail address was repopulated automatically, while the password fields are
    now blank. This is a useful default of most browsers. We are likely to want to
    submit similar information the second time round, after fixing the errors, but
    for security reasons, we always want to get rid of passwords as quickly as possible.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 关于最后一张图片有几件有趣的事情需要注意。首先，请注意HTML5输入框将电子邮件地址`g@1`视为有效（前端验证），但`Email()`验证器不认为它是有效的（后端验证）。这就是为什么我可以提交表单，即使我使用支持HTML5电子邮件字段的浏览器，只有在数据传输到后端后才被告知电子邮件地址无效。其次，请注意在提交表单后，电子邮件地址会自动重新填充，而密码字段现在为空。这是大多数浏览器的有用默认设置。我们可能希望在第二次提交类似的信息时，修复错误后，但出于安全原因，我们总是希望尽快摆脱密码。
- en: Note the '**Invalid email address**.' message in the preceding image. In our
    `forms.py` file, we only specified the error message for the case when the password
    was too short, but WTForms provides default messages for its built-in validators.
    Similarly, if you leave the password field blank, you'll see the message '**This
    field is required**'—another useful default that we did not have to write.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上图中的“**无效的电子邮件地址**”消息。在我们的`forms.py`文件中，我们只为密码太短的情况指定了错误消息，但WTForms为其内置验证器提供了默认消息。同样，如果您将密码字段留空，您将看到消息“**此字段为必填项**”——这是另一个有用的默认消息，我们不需要编写。
- en: 'That''s most of the heavy lifting done for form validation and user feedback.
    Now that you have a good conceptual grasp of how everything works, we''ll go over
    it quickly once:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这是表单验证和用户反馈的大部分工作。现在你已经对所有东西的工作原理有了很好的概念，我们将快速地再次概述一下：
- en: Displaying feedback when the user's registration is successful (at the moment,
    we rather pessimistically only seem to be confirmed with failure, but the user
    will want to know that an account has been successfully registered if everything
    goes well).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在用户注册成功时显示反馈（目前，我们似乎只确认失败，但用户会想知道如果一切顺利地注册了一个帐户）。
- en: Moving our login form to WTForms and adding feedback for when users fail to
    log in.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的登录表单移动到WTForms，并在用户登录失败时添加反馈。
- en: Moving our '`new table`' form to WTForms and adding feedback where necessary.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的“新表格”表单移动到WTForms，并在必要时添加反馈。
- en: Adding a successful registration notification
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加成功的注册通知
- en: Normally, we would show the user a new page after a successful registration,
    thanking them for registering and informing them that everything has been successful
    (see the next chapter for a more complete list of things we could improve on if
    we were writing this application for a production environment instead of using
    it as an educational project). To keep our application to as few pages as possible,
    and to prevent this book from growing too long, we'll show the user a JavaScript
    popup box instead. Generally, when creating user interfaces, we want to avoid
    as many popups as possible, as users find them irritating. However, they are occasionally
    necessary, so using one here will help keep our application simple and give us
    an opportunity to learn a bit more JavaScript.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会在成功注册后向用户显示一个新页面，感谢他们注册并告知他们一切都成功了（如果我们是为生产环境编写此应用程序，而不是将其用作教育项目，我们将在下一章中列出我们可以改进的更完整的事项列表）。为了使我们的应用程序尽可能少地使用页面，并防止本书变得太长，我们将向用户显示一个JavaScript弹出框。通常，在创建用户界面时，我们希望尽可能避免使用弹出框，因为用户会觉得它们很烦人。然而，有时是必要的，所以在这里使用一个将有助于使我们的应用程序简单，并给我们一个机会学习更多JavaScript。
- en: JavaScript is event-based. This means that we can write code that is triggered
    by user actions (such as a mouse click) or other events such as an '`onload`'
    event, which is triggered when a specific resource loads in the user's browser.
    Previously, in our Crime Map project, we used this to initialize the JavaScript
    Google Map widget after the `<body>` tag had loaded. Now we'll do something similar,
    but use this to display a JavaScript alert box instead. We'll also make our message
    dynamic and pass it to the frontend from the backend code.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是基于事件的。这意味着我们可以编写由用户操作（如鼠标点击）或其他事件（如`onload`事件，当特定资源在用户的浏览器中加载时触发）触发的代码。在我们的犯罪地图项目中，我们曾经使用它在`<body>`标签加载后初始化JavaScript
    Google地图小部件。现在我们将做类似的事情，但使用它来显示JavaScript警报框。我们还将使我们的消息动态化，并从后端代码传递到前端。
- en: Passing the message from the application code
  id: totrans-265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从应用程序代码传递消息
- en: 'The backend change for this is easy. Simply change the `register()` function
    to pass in the appropriate message if we process all the input data without any
    errors. In `waitercaller.py`, update the `register()` function to read as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这方面的后端更改很容易。只需将`register()`函数更改为在处理所有输入数据时传递适当的消息。在`waitercaller.py`中，更新`register()`函数如下：
- en: '[PRE43]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Using the message in the template code
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在模板代码中使用消息
- en: The change is slightly trickier to implement in our template because we don't
    actually have access to the `<body>` tag (where we want to specify the JavaScript
    alert) in our `home.html` template. Instead, our `<body>` is defined in our `base.html`
    skeleton template from which all our other templates inherit.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 更改在我们的模板中实现起来稍微棘手，因为我们实际上没有访问`<body>`标签（我们希望在其中指定JavaScript警报）在我们的`home.html`模板中。相反，我们的`<body>`是在我们的`base.html`骨架模板中定义的，所有其他模板都继承自它。
- en: To modify the `<body>` tag only in our `home.html` template, we need to make
    the `<body>` tag appear within an inheritable Jinja block, similar to our content
    block. To do this, we need to make changes to our `base.html` template and to
    our `home.html` template.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要仅在我们的`home.html`模板中修改`<body>`标签，我们需要使`<body>`标签出现在可继承的Jinja块内，类似于我们的内容块。为此，我们需要对我们的`base.html`模板和我们的`home.html`模板进行更改。
- en: 'In `base.html`, make the following change where the `<body>` tag is created:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在`base.html`中，当创建`<body>`标签时进行以下更改：
- en: '[PRE44]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now the `<body>` tag can be overwritten by child templates, as it appears inside
    a configurable block. In `home.html`, we''ll overwrite the `<body>` block directly
    after the first line, if an alert message is specified. Remember that if this
    message is not specified, the `home.html` template will simply inherit the default
    `<body>` tag from the `base.html` template. In `home.html`, add the following
    code directly after the first line:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`<body>`标签可以被子模板覆盖，因为它出现在一个可配置的块内。在`home.html`中，如果指定了警报消息，我们将在第一行后直接覆盖`<body>`块。请记住，如果没有指定此消息，`home.html`模板将简单地继承`base.html`模板的默认`<body>`标签。在`home.html`中，在第一行后直接添加以下代码：
- en: '[PRE45]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The only slightly tricky part is matching up all the quotation marks and brackets
    in the `onload` attribute. The entire `alert` function (the JavaScript we want
    to run) should appear within double quotation marks. The string inside the `alert`
    function (the message that is actually displayed to the user) should be inside
    single quotation marks. Finally, the `onloadmessage` variable should be inside
    double braces, so that we get the contents of the variable rather than the string
    of the variable name.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一稍微棘手的部分是匹配`onload`属性中的所有引号和括号。整个`alert`函数（我们要运行的JavaScript）应该出现在双引号内。`alert`函数内的字符串（实际显示给用户的消息）应该在单引号内。最后，`onloadmessage`变量应该在双括号内，这样我们可以得到变量的内容而不是变量名的字符串。
- en: Now, after a successful registration, the user will see an alert confirming
    that everything went well and that a login is possible, as seen in the following
    image. It would be better to add a new page to properly inform the user of the
    successful registration, but to keep our app simple (and so we could introduce
    the onload functionality, which is generally useful), we opted for a slightly
    messier way of communicating this.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在成功注册后，用户将看到一个确认一切顺利进行并且可以登录的警报，如下图所示。最好添加一个新页面，以便向用户正确地通知成功注册，但为了保持我们的应用程序简单（因此我们可以引入通常有用的onload功能），我们选择了一种稍微混乱的通信方式。
- en: '![Using the message in the template code](img/B04312_10_09.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![在模板代码中使用消息](img/B04312_10_09.jpg)'
- en: Modifying the login form
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改登录表单
- en: The changes necessary to move the login form to WTForms are very similar to
    the changes we made for the registration form, so we'll provide the code with
    minimal discussion. Refer to the code bundle if you are unsure where to insert
    the code or make changes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 将登录表单移动到WTForms所需的更改与我们为注册表单所做的更改非常相似，因此我们将提供最少讨论的代码。如果您不确定在哪里插入代码或进行更改，请参考代码包。
- en: Creating the new LoginForm in the application code
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在应用程序代码中创建新的LoginForm
- en: 'In `forms.py`, add the `LoginForm` class:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`forms.py`中，添加`LoginForm`类：
- en: '[PRE46]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we specify a custom message for the password field's `DataRequired` validator,
    as the error messages won't align with the fields as nicely as they did for the
    registration form. We also use the variable names `loginemail` and `loginpassword`,
    as these will become the HTML element `id` and `name` attributes, and it's preferable
    that they don't get overridden by the `login` and `password` fields in the registration
    form on the same page.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为密码字段的`DataRequired`验证器指定了自定义消息，因为错误消息与注册表单的字段不会像注册表单那样对齐。我们还使用变量名`loginemail`和`loginpassword`，因为这些将成为HTML元素的`id`和`name`属性，最好不要被同一页上注册表单中的`login`和`password`字段覆盖。
- en: 'In `waitercaller.py`, add the import for the login form:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`中，添加登录表单的导入：
- en: '[PRE47]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And rewrite the `login()` function as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 并将`login()`函数重写如下：
- en: '[PRE48]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It may seem that the "**Email or password invalid**" error is quite vague and
    could be more specific. It's true that the user may find it helpful to know where
    the mistake lies, as many people use many different e-mail addresses and different
    passwords. Thus, it would be convenient to know whether you, as a user, have entered
    the wrong e-mail and need to try to remember which e-mail address you signed up
    for, or if you have the correct e-mail address and have misremembered your anniversary
    or date of birth or whatever mnemonic you use to remember your password. However,
    the convenience is offset by yet another security issue. If we display "**Invalid
    password**" when the user enters a correct e-mail address but the incorrect password,
    this would allow a malicious attacker to try a large list of e-mail addresses
    against our website, and slowly build up a list of e-mail addresses that belong
    to our users. The attacker could then target these users in a phishing attack
    by using the knowledge that these users are our customers. This is yet another
    case that shows how developers have to be constantly vigilant against what information
    they might be allowing an attacker to infer, even if it's not directly provided.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: “**电子邮件或密码无效**”错误似乎相当模糊，可能需要更具体。用户可能会发现知道错误所在很有帮助，因为许多人使用许多不同的电子邮件地址和不同的密码。因此，知道您作为用户是输入了错误的电子邮件并需要尝试记住您注册的电子邮件地址，还是您输入了正确的电子邮件地址但是错误地记住了您的纪念日或出生日期或您用来记住密码的任何助记符，这将是方便的。然而，这种便利性又会带来另一个安全问题。如果用户输入了正确的电子邮件地址但是错误的密码，我们显示“**无效密码**”，这将允许恶意攻击者对我们的网站尝试大量的电子邮件地址，并慢慢建立属于我们用户的电子邮件地址列表。攻击者随后可以利用这些用户是我们的客户的知识，对这些用户进行网络钓鱼攻击。这是另一个案例，显示了开发人员必须不断警惕他们可能允许攻击者推断出的信息，即使这些信息并不是直接提供的。
- en: 'The last backend changes that we need to make are to initialize and pass in
    a new `LoginForm` object whenever we render the `home.html` template. These changes
    have to be made:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行的最后一个后端更改是在每次呈现`home.html`模板时初始化并传递一个新的`LoginForm`对象。必须进行以下更改：
- en: Once in the `home()` function
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦在`home()`函数中
- en: Three times in the `register()` function
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`register()`函数中三次
- en: 'Change the `home()` function to read as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 将`home()`函数更改为如下所示：
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Change the last two lines of the `register()` function to:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 将`register()`函数的最后两行更改为：
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And the `return` statement in the middle of the `register()` function to:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 并且在`register()`函数中间的`return`语句为：
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Using the new LoginForm in the template
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模板中使用新的LoginForm
- en: 'For the template changes, `home.html` should now use the following `login`
    form:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 对于模板更改，`home.html`现在应该使用以下`login`表单：
- en: '[PRE52]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Instead of displaying the errors above each field, as we did for the registration
    form, we'll just display all the errors above the login form. To do this, we can
    use the `loginform.errors` property, which is a dictionary mapping of each field
    to a list of its errors. The error displaying code is therefore slightly more
    verbose, as it has to loop through all the keys and values of this dictionary,
    and we use the `convenient |dictsort` Jinja notation to sort the dictionary before
    displaying the errors.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为注册表单所做的方式不同，我们不会在每个字段上方显示错误，而是只会在登录表单上方显示所有错误。为此，我们可以使用`loginform.errors`属性，它是每个字段到其错误列表的映射字典。因此，错误显示代码稍微更冗长，因为它必须循环遍历此字典的所有键和值，并且我们使用`convenient
    |dictsort` Jinja标记在显示错误之前对字典进行排序。
- en: Modifying the create table form
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改创建表单
- en: 'The last form change we need to make is to the create table form, for when
    an already logged-in user adds a new restaurant table to his or her account. The
    new form to be added to `forms.py` looks like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要进行的最后一个表单更改是创建表单表单，当已登录用户向其帐户添加新的餐厅桌子时。要添加到`forms.py`的新表单如下所示：
- en: '[PRE53]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This requires a new import in `forms.py` as well:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这也需要在`forms.py`中进行新的导入：
- en: '[PRE54]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `waitercaller.py`, we need to import the new form with:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在`waitercaller.py`中，我们需要导入新的表单：
- en: '[PRE55]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Update the `account_createtable()` function to:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`account_createtable()`函数为：
- en: '[PRE56]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'And the `account()` route to:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`account()`路由变为：'
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Finally, the form in the `account.html` template should be changed to:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`account.html`模板中的表单应该更改为：
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'At the moment, if the user leaves the field blank and hits the **Create** button,
    we can only ever have a single error displayed on the `create table` form, that
    is, ''**This field is required**'', which we can see in the following screenshot:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果用户将字段留空并点击**创建**按钮，我们在`创建表格`表单上只能显示一个错误，即“**此字段为必填项**”，如下截图所示：
- en: '![Modifying the create table form](img/B04312_10_10.jpg)'
  id: totrans-316
  prefs: []
  type: TYPE_IMG
  zh: '![修改创建表格表单](img/B04312_10_10.jpg)'
- en: With this in mind, it is debatable whether the for loop should loop through
    all the error messages. On the one hand, it is bad to 'future proof' too much,
    as you are left with a code base that contains a lot of unnecessary code that
    is over complicated. On the other hand, we may well add more error messages to
    the WTForm (such as if the user tries to create a table with a number that already
    exists), and therefore, it is arguably worthwhile to add the for loop.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，可以讨论的是for循环是否应该循环遍历所有错误消息。一方面，过度“未来证明”是不好的，因为你会留下一个包含大量不必要且过于复杂的代码的代码库。另一方面，我们可能会向WTForm添加更多的错误消息（例如，如果用户尝试使用已经存在的数字创建表），因此，可以说值得添加for循环。
- en: The one form left that we have not converted to WTForms is the `delete table`
    form. As this is only a single **Submit** button, it is left as an exercise (the
    CSRF protection would still be a worthwhile gain in moving this form to WTForms.).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有将WTForms转换为的最后一个表单是`删除表格`表单。由于这只是一个单独的**提交**按钮，因此留作练习（将此表单移至WTForms仍然是一个值得的收获）。
- en: Summary
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We've fleshed out our application's functionality, and it's now a lot more powerful.
    We added **Dashboard** and **Account** pages, and wrote all the application code,
    database code, and frontend code to handle our requirements.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完善了应用程序的功能，现在它更加强大。我们添加了**仪表板**和**账户**页面，并编写了处理我们需求的所有应用程序代码、数据库代码和前端代码。
- en: We looked at Jinja templates as a way to avoid duplicating the frontend code,
    and we also looked at how to use the bitly API to shorten links.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了Jinja模板作为避免重复前端代码的一种方法，还学习了如何使用bitly API来缩短链接。
- en: We then added WTForms, and saw how this could make our user feedback easier,
    our forms easier to validate, and our web application more secure. Our users are
    now kept up-to-date with information about their registration, login, and usage
    of the application.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们添加了WTForms，并看到这如何使我们的用户反馈更容易，我们的表单更容易验证，我们的Web应用程序更安全。我们的用户现在可以随时了解他们的注册、登录和应用程序的使用情况。
- en: In the next chapter, we'll add a real database to our code and then work on
    some finishing touches.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为我们的代码添加一个真正的数据库，然后进行一些最后的润色。
