- en: Chapter 4. Models
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 模型
- en: 'In [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views and Urlconfs*,
    we covered the fundamentals of building dynamic websites with Django: setting
    up views and URLconfs. As we explained, a view is responsible for doing some arbitrary
    logic, and then returning a response. In one of the examples, our arbitrary logic
    was to calculate the current date and time.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.xhtml "第2章 视图和URLconfs")*视图和URLconfs*中，我们介绍了使用Django构建动态网站的基础知识：设置视图和URLconfs。正如我们所解释的，视图负责执行一些任意逻辑，然后返回一个响应。在其中一个示例中，我们的任意逻辑是计算当前日期和时间。
- en: In modern web applications, the arbitrary logic often involves interacting with
    a database. Behind the scenes, a database-driven website connects to a database
    server, retrieves some data out of it, and displays that data on a web page. The
    site might also provide ways for site visitors to populate the database on their
    own.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web应用程序中，任意逻辑通常涉及与数据库的交互。在幕后，一个数据库驱动的网站连接到数据库服务器，从中检索一些数据，并在网页上显示这些数据。该网站还可能提供访问者自行填充数据库的方式。
- en: Many complex websites provide some combination of the two. [www.amazon.com](http://www.amazon.com),
    for instance, is a great example of a database-driven site. Each product page
    is essentially a query into Amazon's product database formatted as HTML, and when
    you post a customer review, it gets inserted into the database of reviews.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 许多复杂的网站提供了这两种方式的组合。例如，[www.amazon.com](http://www.amazon.com)就是一个数据库驱动的网站的绝佳例子。每个产品页面本质上都是对亚马逊产品数据库的查询，格式化为HTML，当您发布客户评论时，它会被插入到评论数据库中。
- en: 'Django is well suited for making database-driven websites because it comes
    with easy yet powerful tools for performing database queries using Python. This
    chapter explains that functionality: Django''s database layer.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Django非常适合制作数据库驱动的网站，因为它提供了使用Python执行数据库查询的简单而强大的工具。本章解释了这个功能：Django的数据库层。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While it's not strictly necessary to know basic relational database theory and
    SQL in order to use Django's database layer, it's highly recommended. An introduction
    to those concepts is beyond the scope of this book, but keep reading even if you're
    a database newbie. You'll probably be able to follow along and grasp concepts
    based on the context.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是必须要了解基本的关系数据库理论和SQL才能使用Django的数据库层，但强烈建议这样做。这本书不涉及这些概念的介绍，但即使你是数据库新手，继续阅读也是有可能跟上并理解基于上下文的概念。
- en: The "dumb" way to do database queries in views
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在视图中进行数据库查询的“愚蠢”方法
- en: 'Just as [Chapter 2](ch02.xhtml "Chapter 2. Views and URLconfs"), *Views and
    Urlconfs*, detailed a "dumb" way to produce output within a view (by hard-coding
    the text directly within the view), there''s a "dumb" way to retrieve data from
    a database in a view. It''s simple: just use any existing Python library to execute
    an SQL query and do something with the results. In this example view, we use the
    `MySQLdb` library to connect to a MySQL database, retrieve some records, and feed
    them to a template for display as a web page:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第2章](ch02.xhtml "第2章 视图和URLconfs")*视图和URLconfs*中详细介绍了在视图中生成输出的“愚蠢”方法（通过在视图中直接硬编码文本），在视图中从数据库中检索数据也有一个“愚蠢”的方法。很简单：只需使用任何现有的Python库来执行SQL查询并对结果进行处理。在这个示例视图中，我们使用`MySQLdb`库连接到MySQL数据库，检索一些记录，并将它们传递给模板以在网页上显示：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This approach works, but some problems should jump out at you immediately:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以工作，但是一些问题应该立即引起您的注意：
- en: We're hard-coding the database connection parameters. Ideally, these parameters
    would be stored in the Django configuration.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在硬编码数据库连接参数。理想情况下，这些参数应该存储在Django配置中。
- en: 'We''re having to write a fair bit of boilerplate code: creating a connection,
    creating a cursor, executing a statement, and closing the connection. Ideally,
    all we''d have to do is specify which results we wanted.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不写相当多的样板代码：创建连接，创建游标，执行语句，关闭连接。理想情况下，我们只需要指定我们想要的结果。
- en: It ties us to MySQL. If, down the road, we switch from MySQL to PostgreSQL,
    we'll most likely have to rewrite a large amount of our code. Ideally, the database
    server we're using would be abstracted, so that a database server change could
    be made in a single place. (This feature is particularly relevant if you're building
    an open-source Django application that you want to be used by as many people as
    possible.)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将我们与MySQL绑定。如果将来我们从MySQL切换到PostgreSQL，我们很可能需要重写大量代码。理想情况下，我们使用的数据库服务器应该被抽象化，这样数据库服务器的更改可以在一个地方进行。
    （如果您正在构建一个希望尽可能多的人使用的开源Django应用程序，这个功能尤其重要。）
- en: As you might expect, Django's database layer solves these problems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，Django的数据库层解决了这些问题。
- en: Configuring the database
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置数据库
- en: 'With all of that philosophy in mind, let''s start exploring Django''s database
    layer. First, let''s explore the initial configuration that was added to `settings.py`
    when we created the application:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些理念，让我们开始探索Django的数据库层。首先，让我们探索在创建应用程序时添加到`settings.py`的初始配置。
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default setup is pretty simple. Here's a rundown of each setting.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 默认设置非常简单。以下是每个设置的概述。
- en: '`ENGINE`: It tells Django which database engine to use. As we are using SQLite
    in the examples in this book, we will leave it to the default `django.db.backends.sqlite3`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENGINE`：它告诉Django使用哪个数据库引擎。在本书的示例中，我们使用SQLite，所以将其保留为默认的`django.db.backends.sqlite3`。'
- en: '`NAME`: It tells Django the name of your database. For example: `''NAME'':
    ''mydb'',`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`：它告诉Django你的数据库的名称。例如：`''NAME'': ''mydb'',`。'
- en: Since we're using SQLite, `startproject` created a full filesystem path to the
    database file for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是SQLite，`startproject`为我们创建了数据库文件的完整文件系统路径。
- en: This is it for the default setup-you don't need to change anything to run the
    code in this book, I have included this simply to give you an idea of how simple
    it is to configure databases in Django. For a detailed description on how to set
    up the various databases supported by Django, see [Chapter 21](ch21.xhtml "Chapter 21. Advanced
    Database Management"), *Advanced Database Management*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是默认设置-你不需要改变任何东西来运行本书中的代码，我包含这个只是为了让你了解在Django中配置数据库是多么简单。有关如何设置Django支持的各种数据库的详细描述，请参见[第21章](ch21.xhtml
    "第21章.高级数据库管理"), *高级数据库管理*。
- en: Your first app
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的第一个应用程序
- en: 'Now that you''ve verified that the connection is working, it''s time to create
    a **Django app-**-a bundle of Django code, including models and views, that live
    together in a single Python package and represent a full Django application. It''s
    worth explaining the terminology here, because this tends to trip up beginners.
    We''ve already created a project, in [Chapter 1](ch01.xhtml "Chapter 1. Introduction
    to Django and Getting Started"), *Introduction to Django and Getting Started*,
    so what''s the difference between a **project** and an **app**? The difference
    is that of configuration vs. code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经验证了连接是否正常工作，是时候创建一个**Django应用程序**了-一个包含模型和视图的Django代码包，它们一起存在于一个单独的Python包中，代表一个完整的Django应用程序。这里值得解释一下术语，因为这往往会让初学者困惑。我们已经在[第1章](ch01.xhtml
    "第1章. Django简介和入门")中创建了一个项目，*Django简介和入门*，那么**项目**和**应用程序**之间有什么区别呢？区别在于配置和代码：
- en: A project is an instance of a certain set of Django apps, plus the configuration
    for those apps. Technically, the only requirement of a project is that it supplies
    a settings file, which defines the database connection information, the list of
    installed apps, the `DIRS`, and so forth.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目是一组Django应用程序的实例，以及这些应用程序的配置。从技术上讲，项目的唯一要求是提供一个设置文件，其中定义了数据库连接信息、已安装应用程序的列表、`DIRS`等。
- en: An app is a portable set of Django functionality, usually including models and
    views, that live together in a single Python package.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序是一组可移植的Django功能，通常包括模型和视图，它们一起存在于一个单独的Python包中。
- en: For example, Django comes with a number of apps, such as the automatic admin
    interface. A key thing to note about these apps is that they're portable and reusable
    across multiple projects.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Django自带了许多应用程序，比如自动管理界面。关于这些应用程序的一个关键点是它们是可移植的，可以在多个项目中重复使用。
- en: There are very few hard-and-fast rules about how you fit your Django code into
    this scheme. If you're building a simple website, you may use only a single app.
    If you're building a complex website with several unrelated pieces such as an
    e-commerce system and a message board, you'll probably want to split those into
    separate apps so that you'll be able to reuse them individually in the future.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何将Django代码适应这个方案，几乎没有硬性规定。如果你正在构建一个简单的网站，可能只使用一个应用程序。如果你正在构建一个包括电子商务系统和留言板等多个不相关部分的复杂网站，你可能希望将它们拆分成单独的应用程序，以便将来可以单独重用它们。
- en: Indeed, you don't necessarily need to create apps at all, as evidenced by the
    example view functions we've created so far in this book. In those cases, we simply
    created a file called `views.py`, filled it with view functions, and pointed our
    URLconf at those functions. No apps were needed.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，你并不一定需要创建应用程序，正如我们在本书中迄今为止创建的示例视图函数所证明的那样。在这些情况下，我们只需创建一个名为`views.py`的文件，填充它以视图函数，并将我们的URLconf指向这些函数。不需要应用程序。
- en: 'However, there''s one requirement regarding the app convention: if you''re
    using Django''s database layer (models), you must create a Django app. Models
    must live within apps. Thus, in order to start writing our models, we''ll need
    to create a new app.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关于应用程序约定有一个要求：如果你正在使用Django的数据库层（模型），你必须创建一个Django应用程序。模型必须存在于应用程序中。因此，为了开始编写我们的模型，我们需要创建一个新的应用程序。
- en: 'Within the `mysite` project directory (this is the directory where your `manage.py`
    file is, not the `mysite` app directory), type this command to create a `books`
    app:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`mysite`项目目录中（这是你的`manage.py`文件所在的目录，而不是`mysite`应用程序目录），输入以下命令来创建一个`books`应用程序：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This command does not produce any output, but it does create a `books` directory
    within the `mysite` directory. Let''s look at the contents of that directory:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令不会产生任何输出，但它会在`mysite`目录中创建一个`books`目录。让我们看看该目录的内容：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These files will contain the models and views for this app. Have a look at `models.py`
    and `views.py` in your favorite text editor. Both files are empty, except for
    comments and an import in `models.py`. This is the blank slate for your Django
    app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件将包含此应用程序的模型和视图。在你喜欢的文本编辑器中查看`models.py`和`views.py`。这两个文件都是空的，除了注释和`models.py`中的导入。这是你的Django应用程序的空白板。
- en: Defining Models in Python
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Python中定义模型
- en: As we discussed earlier in [Chapter 1](ch01.xhtml "Chapter 1. Introduction to
    Django and Getting Started"), *Introduction to Django and Getting Started*, the
    M in MTV stands for Model. A Django model is a description of the data in your
    database, represented as Python code. It's your data layout-the equivalent of
    your SQL `CREATE TABLE` statements-except it's in Python instead of SQL, and it
    includes more than just database column definitions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第1章](ch01.xhtml "第1章. Django简介和入门")中讨论的那样，MTV中的M代表模型。Django模型是对数据库中数据的描述，表示为Python代码。它是你的数据布局-相当于你的SQL
    `CREATE TABLE`语句-只不过它是用Python而不是SQL编写的，并且包括的不仅仅是数据库列定义。
- en: Django uses a model to execute SQL code behind the scenes and return convenient
    Python data structures representing the rows in your database tables. Django also
    uses models to represent higher-level concepts that SQL can't necessarily handle.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用模型在后台执行SQL代码，并返回表示数据库表中行的方便的Python数据结构。Django还使用模型来表示SQL不能必然处理的更高级概念。
- en: 'If you''re familiar with databases, your immediate thought might be, "Isn''t
    it redundant to define data models in Python instead of in SQL?" Django works
    the way it does for several reasons:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉数据库，你可能会立刻想到，“在Python中定义数据模型而不是在SQL中定义，这不是多余的吗？” Django之所以采用这种方式有几个原因：
- en: Introspection requires overhead and is imperfect. In order to provide convenient
    data-access APIs, Django needs to know the database layout somehow, and there
    are two ways of accomplishing this. The first way would be to explicitly describe
    the data in Python, and the second way would be to introspect the database at
    runtime to determine the data models.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内省需要额外开销，而且并不完美。为了提供方便的数据访问API，Django需要以某种方式了解数据库布局，有两种方法可以实现这一点。第一种方法是在Python中明确描述数据，第二种方法是在运行时内省数据库以确定数据模型。
- en: This second way seems cleaner, because the metadata about your tables lives
    in only one place, but it introduces a few problems. First, introspecting a database
    at runtime obviously requires overhead. If the framework had to introspect the
    database each time it processed a request, or even only when the web server was
    initialized, this would incur an unacceptable level of overhead. (While some believe
    that level of overhead is acceptable, Django's developers aim to trim as much
    framework overhead as possible.) Second, some databases, notably older versions
    of MySQL, do not store sufficient metadata for accurate and complete introspection.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这第二种方法看起来更干净，因为关于你的表的元数据只存在一个地方，但它引入了一些问题。首先，在运行时内省数据库显然需要开销。如果框架每次处理请求时，甚至只在Web服务器初始化时都需要内省数据库，这将产生无法接受的开销。（虽然有些人认为这种开销是可以接受的，但Django的开发人员的目标是尽量减少框架的开销。）其次，一些数据库，特别是较旧版本的MySQL，没有存储足够的元数据来进行准确和完整的内省。
- en: Writing Python is fun, and keeping everything in Python limits the number of
    times your brain has to do a "context switch". It helps productivity if you keep
    yourself in a single programming environment/mentality for as long as possible.
    Having to write SQL, then Python, and then SQL again is disruptive.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Python很有趣，而且将所有东西都放在Python中可以减少你的大脑进行“上下文切换”的次数。如果你尽可能长时间地保持在一个编程环境/思维方式中，这有助于提高生产率。不得不先写SQL，然后写Python，再写SQL是会打断思维的。
- en: Having data models stored as code rather than in your database makes it easier
    to keep your models under version control. This way, you can easily keep track
    of changes to your data layouts.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据模型存储为代码而不是在数据库中，可以更容易地将模型纳入版本控制。这样，你可以轻松跟踪对数据布局的更改。
- en: SQL allows for only a certain level of metadata about a data layout. Most database
    systems, for example, do not provide a specialized data type for representing
    email addresses or URLs. Django models do. The advantage of higher-level data
    types is higher productivity and more reusable code.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL只允许对数据布局进行一定级别的元数据。例如，大多数数据库系统并没有提供专门的数据类型来表示电子邮件地址或URL。但Django模型有。更高级别的数据类型的优势在于更高的生产率和更可重用的代码。
- en: SQL is inconsistent across database platforms. If you're distributing a web
    application, for example, it's much more pragmatic to distribute a Python module
    that describes your data layout than separate sets of `CREATE TABLE` statements
    for MySQL, PostgreSQL, and SQLite.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL在不同的数据库平台上是不一致的。例如，如果你要分发一个网络应用程序，更实际的做法是分发一个描述数据布局的Python模块，而不是针对MySQL、PostgreSQL和SQLite分别创建`CREATE
    TABLE`语句的集合。
- en: A drawback of this approach, however, is that it's possible for the Python code
    to get out of sync with what's actually in the database. If you make changes to
    a Django model, you'll need to make the same changes inside your database to keep
    your database consistent with the model. I'll show you how to handle this problem
    when we discuss migrations later in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法的一个缺点是，Python代码可能与实际数据库中的内容不同步。如果你对Django模型进行更改，你需要在数据库内做相同的更改，以保持数据库与模型一致。在本章后面讨论迁移时，我将向你展示如何处理这个问题。
- en: Finally, you should note that Django includes a utility that can generate models
    by introspecting an existing database. This is useful for quickly getting up and
    running with legacy data. We'll cover this in [Chapter 21](ch21.xhtml "Chapter 21. Advanced
    Database Management"), *Advanced Database Management*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该注意到Django包括一个实用程序，可以通过内省现有数据库来生成模型。这对于快速启动和运行遗留数据非常有用。我们将在[第21章](ch21.xhtml
    "第21章.高级数据库管理")中介绍这个内容，*高级数据库管理*。
- en: Your first model
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你的第一个模型
- en: As an ongoing example in this chapter and the next chapter, I'll focus on a
    basic book/author/publisher data layout. I use this as our example because the
    conceptual relationships between books, authors, and publishers are well known,
    and this is a common data layout used in introductory SQL textbooks. You're also
    reading a book that was written by authors and produced by a publisher!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为本章和下一章的一个持续的例子，我将专注于一个基本的书籍/作者/出版商数据布局。我选择这个作为例子，因为书籍、作者和出版商之间的概念关系是众所周知的，这是初级SQL教科书中常用的数据布局。你也正在阅读一本由作者撰写并由出版商出版的书籍！
- en: 'I''ll suppose the following concepts, fields, and relationships:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设以下概念、字段和关系：
- en: An author has a first name, a last name, and an email address.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作者有名字、姓氏和电子邮件地址。
- en: A publisher has a name, a street address, a city, a state/province, a country,
    and a website.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出版商有一个名称、街道地址、城市、州/省、国家和网站。
- en: A book has a title and a publication date. It also has one or more authors (a
    many-to-many relationship with authors) and a single publisher (a one-to-many
    relationship-aka foreign key-to publishers).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本书有一个标题和出版日期。它还有一个或多个作者（与作者之间是多对多的关系）和一个出版商（一对多的关系，也就是外键到出版商）。
- en: 'The first step in using this database layout with Django is to express it as
    Python code. In the `models.py` file that was created by the `startapp` command,
    enter the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中使用这个数据库布局的第一步是将其表达为Python代码。在由`startapp`命令创建的`models.py`文件中输入以下内容：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Let's quickly examine this code to cover the basics. The first thing to notice
    is that each model is represented by a Python class that is a subclass of `django.db.models.Model`.
    The parent class, `Model`, contains all the machinery necessary to make these
    objects capable of interacting with a database-and that leaves our models responsible
    solely for defining their fields, in a nice and compact syntax.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速检查这段代码，以涵盖基础知识。首先要注意的是，每个模型都由一个Python类表示，该类是`django.db.models.Model`的子类。父类`Model`包含使这些对象能够与数据库交互所需的所有机制，这样我们的模型就只负责以一种简洁而紧凑的语法定义它们的字段。
- en: 'Believe it or not, this is all the code we need to write to have basic data
    access with Django. Each model generally corresponds to a single database table,
    and each attribute on a model generally corresponds to a column in that database
    table. The attribute name corresponds to the column''s name, and the type of field
    (example, `CharField`) corresponds to the database column type (example, `varchar`).
    For example, the `Publisher` model is equivalent to the following table (assuming
    PostgreSQL `CREATE TABLE` syntax):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 信不信由你，这就是我们需要编写的所有代码，就可以使用Django进行基本的数据访问。每个模型通常对应一个单独的数据库表，模型上的每个属性通常对应该数据库表中的一列。属性名称对应于列的名称，字段类型（例如，`CharField`）对应于数据库列类型（例如，`varchar`）。例如，`Publisher`模型等效于以下表（假设使用PostgreSQL的`CREATE
    TABLE`语法）：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Indeed, Django can generate that `CREATE TABLE` statement automatically, as
    we'll show you in a moment. The exception to the one-class-per-database-table
    rule is the case of many-to-many relationships. In our example models, `Book`
    has a `ManyToManyField` called `authors`. This designates that a book has one
    or many authors, but the `Book` database table doesn't get an `authors` column.
    Rather, Django creates an additional table-a many-to-many *join table*-that handles
    the mapping of books to authors.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Django可以自动生成`CREATE TABLE`语句，我们将在下一刻向您展示。一个类对应一个数据库表的唯一规则的例外是多对多关系的情况。在我们的示例模型中，`Book`有一个名为`authors`的`ManyToManyField`。这表示一本书有一个或多个作者，但`Book`数据库表不会得到一个`authors`列。相反，Django会创建一个额外的表-一个多对多的*连接表*-来处理书籍到作者的映射。
- en: For a full list of field types and model syntax options, see [Appendix B](apb.xhtml
    "Appendix B. Database API Reference"), *Database API Reference*. Finally, note
    we haven't explicitly defined a primary key in any of these models. Unless you
    instruct it otherwise, Django automatically gives every model an auto-incrementing
    integer primary key field called `id`. Each Django model is required to have a
    single-column primary key.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于字段类型和模型语法选项的完整列表，请参见[附录B](apb.xhtml "附录B.数据库API参考"), *数据库API参考*。最后，请注意，我们没有在任何这些模型中明确定义主键。除非您另有指示，否则Django会自动为每个模型提供一个自增的整数主键字段，称为`id`。每个Django模型都需要有一个单列主键。
- en: Installing the Model
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装模型
- en: 'We''ve written the code; now let''s create the tables in our database. In order
    to do that, the first step is to activate these models in our Django project.
    We do that by adding the `books` app to the list of installed apps in the settings
    file. Edit the `settings.py` file again, and look for the `INSTALLED_APPS` setting.
    `INSTALLED_APPS` tells Django which apps are activated for a given project. By
    default, it looks something like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经编写了代码；现在让我们在数据库中创建表。为了做到这一点，第一步是在我们的Django项目中激活这些模型。我们通过将`books`应用程序添加到设置文件中的已安装应用程序列表中来实现这一点。再次编辑`settings.py`文件，并查找`INSTALLED_APPS`设置。`INSTALLED_APPS`告诉Django为给定项目激活了哪些应用程序。默认情况下，它看起来像这样：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To register our `books` app, add `''books''` to `INSTALLED_APPS`, so the setting
    ends up looking like this (`''books''` refers to the "books" app we''re working
    on):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要注册我们的`books`应用程序，请将`'books'`添加到`INSTALLED_APPS`中，以便设置最终看起来像这样（`'books'`指的是我们正在使用的“books”应用程序）：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Each app in `INSTALLED_APPS` is represented by its full Python path-that is,
    the path of packages, separated by dots, leading to the app package. Now that
    the Django app has been activated in the settings file, we can create the database
    tables in our database. First, let''s validate the models by running this command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`INSTALLED_APPS`中的每个应用程序都由其完整的Python路径表示-即，由点分隔的导致应用程序包的路径。现在Django应用程序已在设置文件中激活，我们可以在数据库中创建数据库表。首先，让我们通过运行此命令来验证模型：'
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `check` command runs the Django system check framework-a set of static checks
    for validating Django projects. If all is well, you'll see the message `System
    check identified no issues (0 silenced)`. If you don't, make sure you typed in
    the model code correctly. The error output should give you helpful information
    about what was wrong with the code. Anytime you think you have problems with your
    models, run `python manage.py check`. It tends to catch all the common model problems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`check`命令运行Django系统检查框架-一组用于验证Django项目的静态检查。如果一切正常，您将看到消息`System check identified
    no issues (0 silenced)`。如果没有，请确保您正确输入了模型代码。错误输出应该为您提供有关代码错误的有用信息。每当您认为模型存在问题时，请运行`python
    manage.py check`。它往往会捕捉到所有常见的模型问题。'
- en: 'If your models are valid, run the following command to tell Django that you
    have made some changes to your models (in this case, you have made a new one):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模型有效，请运行以下命令告诉Django您对模型进行了一些更改（在本例中，您创建了一个新模型）：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see something similar to the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似以下内容的东西：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Migrations are how Django stores changes to your models (and thus your database
    schema)-they''re just files on disk. In this instance, you will find  file names
    `0001_initial.py` in the ''migrations'' folder of the `books` app. The `migrate`
    command will take your latest migration file and update your database schema automatically,
    but first, let''s see what SQL that migration would run. The `sqlmigrate` command
    takes migration names and returns their SQL:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 迁移是Django存储对模型的更改（因此是数据库模式）的方式-它们只是磁盘上的文件。在这种情况下，您将在`books`应用程序的`migrations`文件夹中找到名为`0001_initial.py`的文件。`migrate`命令将获取您的最新迁移文件并自动更新您的数据库模式，但首先让我们看看该迁移将运行的SQL。`sqlmigrate`命令获取迁移名称并返回它们的SQL：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You should see something similar to the following (reformatted for readability):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到类似以下的内容（为了可读性重新格式化）：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意以下内容：
- en: Table names are automatically generated by combining the name of the app (`books`)
    and the lowercase name of the model (`publisher`, `book`, and `author`). You can
    override this behavior, as detailed in [Appendix B](apb.xhtml "Appendix B. Database
    API Reference"), *Database API Reference*.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表名是通过组合应用程序的名称（`books`）和模型的小写名称（`publisher`，`book`和`author`）自动生成的。你可以覆盖这种行为，详细信息请参见[附录B](apb.xhtml
    "附录B.数据库API参考")，*数据库API参考*。
- en: As we mentioned earlier, Django adds a primary key for each table automatically-the
    `id` fields. You can override this, too. By convention, Django appends `"_id"`
    to the foreign key field name. As you might have guessed, you can override this
    behavior, too.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，Django会自动为每个表添加一个主键-`id`字段。你也可以覆盖这一点。按照惯例，Django会将`"_id"`附加到外键字段名称。你可能已经猜到，你也可以覆盖这种行为。
- en: The foreign key relationship is made explicit by a `REFERENCES` statement.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键关系通过`REFERENCES`语句明确表示。
- en: These `CREATE TABLE` statements are tailored to the database you're using, so
    database-specific field types such as `auto_increment` (MySQL), `serial` (PostgreSQL),
    or `integer primary key` (SQLite) are handled for you automatically. The same
    goes for quoting of column names (example, using double quotes or single quotes).
    This example output is in PostgreSQL syntax.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`CREATE TABLE`语句是针对你正在使用的数据库定制的，因此数据库特定的字段类型，如`auto_increment`（MySQL），`serial`（PostgreSQL）或`integer
    primary key`（SQLite）都会自动处理。列名的引用也是一样的（例如，使用双引号或单引号）。这个示例输出是以PostgreSQL语法为例。
- en: 'The `sqlmigrate` command doesn''t actually create the tables or otherwise touch
    your database-it just prints output to the screen so you can see what SQL Django
    would execute if you asked it. If you wanted to, you could copy and paste this
    SQL into your database client, however, Django provides an easier way of committing
    the SQL to the database: the `migrate` command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlmigrate`命令实际上并不会创建表或者对数据库进行任何操作，它只是在屏幕上打印输出，这样你就可以看到如果要求Django执行的SQL是什么。如果你愿意，你可以将这些SQL复制粘贴到你的数据库客户端中，然而，Django提供了一个更简单的方法将SQL提交到数据库：`migrate`命令：'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Run that command, and you''ll see something like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令，你会看到类似以下的内容：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In case you were wondering what all the extras are (commented out above), the
    first time you run migrate, Django will also create all the system tables that
    Django needs for the inbuilt apps. Migrations are Django's way of propagating
    changes you make to your models (adding a field, deleting a model, and so on.)
    into your database schema. They're designed to be mostly automatic, however, there
    are some caveats. For more information on migrations, see [Chapter 21](ch21.xhtml
    "Chapter 21. Advanced Database Management"), *Advanced Database Management*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道所有这些额外的内容是什么（在上面被注释掉的），第一次运行migrate时，Django还会创建Django内置应用所需的所有系统表。迁移是Django传播你对模型所做更改（添加字段、删除模型等）到数据库模式的方式。它们被设计为大部分是自动的，但是也有一些注意事项。有关迁移的更多信息，请参见[第21章](ch21.xhtml
    "第21章.高级数据库管理")，*高级数据库管理*。
- en: Basic data access
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本数据访问
- en: 'Once you''ve created a model, Django automatically provides a high-level Python
    API for working with those models. Try it out by running `python manage.py shell`
    and typing the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你创建了一个模型，Django会自动为这些模型提供一个高级别的Python API。通过运行`python manage.py shell`并输入以下内容来尝试一下：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These few lines of code accomplish quite a bit. Here are the highlights:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这几行代码完成了很多事情。以下是重点：
- en: First, we import our `Publisher` model class. This lets us interact with the
    database table that contains publishers.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们导入我们的`Publisher`模型类。这让我们可以与包含出版商的数据库表进行交互。
- en: We create a `Publisher` object by instantiating it with values for each field-`name`,
    `address`, and so on.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过为每个字段实例化一个`Publisher`对象来创建一个`Publisher`对象-`name`，`address`等等。
- en: To save the object to the database, call its `save()` method. Behind the scenes,
    Django executes an SQL `INSERT` statement here.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将对象保存到数据库中，请调用其`save()`方法。在幕后，Django在这里执行了一个SQL `INSERT`语句。
- en: To retrieve publishers from the database, use the attribute `Publisher.objects`,
    which you can think of as a set of all publishers. Fetch a list of all `Publisher`
    objects in the database with the statement `Publisher.objects.all()`. Behind the
    scenes, Django executes an SQL `SELECT` statement here.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要从数据库中检索出出版商，使用属性`Publisher.objects`，你可以将其视为所有出版商的集合。使用语句`Publisher.objects.all()`获取数据库中所有`Publisher`对象的列表。在幕后，Django在这里执行了一个SQL
    `SELECT`语句。
- en: 'One thing is worth mentioning, in case it wasn''t clear from this example.
    When you''re creating objects using the Django model API, Django doesn''t save
    the objects to the database until you call the `save()` method:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事值得一提，以防这个例子没有清楚地表明。当你使用Django模型API创建对象时，Django不会将对象保存到数据库，直到你调用`save()`方法：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you want to create an object and save it to the database in a single step,
    use the `objects.create()` method. This example is equivalent to the example above:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要在一步中创建一个对象并将其保存到数据库中，可以使用`objects.create()`方法。这个例子等同于上面的例子：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Naturally, you can do quite a lot with the Django database API-but first, let's
    take care of a small annoyance.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用Django数据库API做很多事情，但首先，让我们解决一个小烦恼。
- en: Adding model string representations
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加模型字符串表示
- en: 'When we printed out the list of publishers, all we got was this unhelpful display
    that makes it difficult to tell the `Publisher` objects apart:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印出出版商列表时，我们得到的只是这种不太有用的显示，这使得很难区分`Publisher`对象：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can fix this easily by adding a method called `__str__()` to our `Publisher`
    class. A `__str__()` method tells Python how to display a human-readable representation
    of an object. You can see this in action by adding a `__str__()` method to the
    three models:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在`Publisher`类中添加一个名为`__str__()`的方法来轻松解决这个问题。`__str__()`方法告诉Python如何显示对象的可读表示。通过为这三个模型添加`__str__()`方法，你可以看到它的作用。
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, a `__str__()` method can do whatever it needs to do in order
    to return a representation of an object. Here, the `__str__()` methods for `Publisher`
    and `Book` simply return the object''s name and title, respectively, but the `__str__()`
    for `Author` is slightly more complex-it pieces together the `first_name` and
    `last_name` fields, separated by a space. The only requirement for `__str__()`
    is that it return a string object. If `__str__()` doesn''t return a string object-if
    it returns, say, an integer-then Python will raise a `TypeError` with a message
    like:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`__str__()`方法可以根据需要执行任何操作，以返回对象的表示。在这里，`Publisher`和`Book`的`__str__()`方法分别返回对象的名称和标题，但`Author`的`__str__()`方法稍微复杂一些-它将`first_name`和`last_name`字段拼接在一起，用空格分隔。`__str__()`的唯一要求是返回一个字符串对象。如果`__str__()`没有返回一个字符串对象-如果它返回了一个整数-那么Python将引发一个类似于以下的`TypeError`消息：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the `__str__()` changes to take effect, exit out of the Python shell and
    enter it again with `python manage.py shell`. (This is the simplest way to make
    code changes take effect.) Now the list of `Publisher` objects is much easier
    to understand:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使`__str__()`的更改生效，请退出Python shell，然后使用`python manage.py shell`再次进入。 （这是使代码更改生效的最简单方法。）现在`Publisher`对象的列表更容易理解了：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Make sure any model you define has a `__str__()` method-not only for your own
    convenience when using the interactive interpreter, but also because Django uses
    the output of `__str__()` in several places when it needs to display objects.
    Finally, note that `__str__()` is a good example of adding behavior to models.
    A Django model describes more than the database table layout for an object; it
    also describes any functionality that object knows how to do. `__str__()` is one
    example of such functionality—a model knows how to display itself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您定义的任何模型都有一个`__str__()`方法-不仅是为了在使用交互式解释器时方便您自己，而且还因为Django在需要显示对象时使用`__str__()`的输出。最后，请注意，`__str__()`是向模型添加行为的一个很好的例子。Django模型描述了对象的数据库表布局，还描述了对象知道如何执行的任何功能。`__str__()`就是这种功能的一个例子-模型知道如何显示自己。
- en: Inserting and updating data
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入和更新数据
- en: 'You''ve already seen this done: to insert a row into your database, first create
    an instance of your model using keyword arguments, like so:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了这个操作：要向数据库插入一行数据，首先使用关键字参数创建模型的实例，如下所示：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we noted above, this act of instantiating a model class does not touch the
    database. The record isn''t saved into the database until you call `save()`, like
    this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们上面所指出的，实例化模型类的行为并不会触及数据库。直到您调用`save()`，记录才会保存到数据库中，就像这样：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In SQL, this can roughly be translated into the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL中，这大致可以翻译为以下内容：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because the `Publisher` model uses an auto-incrementing primary key `id`, the
    initial call to `save()` does one more thing: it calculates the primary key value
    for the record and sets it to the `id` attribute on the instance:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Publisher`模型使用自增主键`id`，对`save()`的初始调用还做了一件事：它计算了记录的主键值，并将其设置为实例的`id`属性：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Subsequent calls to `save()` will save the record in place, without creating
    a new record (that is, performing an SQL `UPDATE` statement instead of an `INSERT`):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对`save()`的后续调用将在原地保存记录，而不是创建新记录（即执行SQL的`UPDATE`语句而不是`INSERT`）：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding `save()` statement will result in roughly the following SQL:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`save()`语句将导致大致以下的SQL：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Yes, note that all of the fields will be updated, not just the ones that have
    been changed. Depending on your application, this may cause a race condition.
    See *Updating multiple objects in one statement* below to find out how to execute
    this (slightly different) query:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，请注意，所有字段都将被更新，而不仅仅是已更改的字段。根据您的应用程序，这可能会导致竞争条件。请参阅下面的*在一条语句中更新多个对象*，了解如何执行这个（略有不同）查询：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Selecting objects
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择对象
- en: 'Knowing how to create and update database records is essential, but chances
    are that the web applications you''ll build will be doing more querying of existing
    objects than creating new ones. We''ve already seen a way to retrieve every record
    for a given model:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何创建和更新数据库记录是至关重要的，但很有可能您构建的Web应用程序将更多地查询现有对象，而不是创建新对象。我们已经看到了检索给定模型的每条记录的方法：
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This roughly translates to this SQL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致对应于以下SQL：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Notice that Django doesn''t use `SELECT *` when looking up data and instead
    lists all fields explicitly. This is by design: in certain circumstances `SELECT
    *` can be slower, and (more important) listing fields more closely follows one
    tenet of the Zen of Python: *Explicit is better than implicit*. For more on the
    Zen of Python, try typing `import this` at a Python prompt.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Django在查找数据时不使用`SELECT *`，而是明确列出所有字段。这是有意设计的：在某些情况下，`SELECT *`可能会更慢，并且（更重要的是）列出字段更贴近Python之禅的一个原则：*明确胜于隐晦*。有关Python之禅的更多信息，请尝试在Python提示符下输入`import
    this`。
- en: 'Let''s take a close look at each part of this `Publisher.objects.all()` line:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看`Publisher.objects.all()`这行的每个部分：
- en: 'First, we have the model we defined, `Publisher`. No surprise here: when you
    want to look up data, you use the model for that data.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们有我们定义的模型`Publisher`。这里没有什么意外：当您想要查找数据时，您使用该数据的模型。
- en: Next, we have the `objects` attribute. This is called a **manager**. Managers
    are discussed in detail in [Chapter 9](ch09.xhtml "Chapter 9. Advanced Models"),
    *Advanced Models*. For now, all you need to know is that managers take care of
    all *table-level* operations on data including, most important, data lookup. All
    models automatically get an `objects` manager; you'll use it anytime you want
    to look up model instances.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有`objects`属性。这被称为**管理器**。管理器在[第9章](ch09.xhtml "第9章.高级模型")*高级模型*中有详细讨论。现在，您需要知道的是，管理器负责处理数据的所有*表级*操作，包括最重要的数据查找。所有模型都会自动获得一个`objects`管理器；每当您想要查找模型实例时，都会使用它。
- en: Finally, we have `all()`. This is a method on the `objects` manager that returns
    all the rows in the database. Though this object looks like a list, it's actually
    a **QuerySet**-an object that represents a specific set of rows from the database.
    [Appendix C](apc.xhtml "Appendix C. Generic View Reference"), *Generic View Reference*,
    deals with QuerySets in detail. For the rest of this chapter, we'll just treat
    them like the lists they emulate.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有`all()`。这是`objects`管理器上的一个方法，它返回数据库中的所有行。虽然这个对象看起来像一个列表，但它实际上是一个**QuerySet**-一个表示数据库中特定一组行的对象。[附录C](apc.xhtml
    "附录C. 通用视图参考")，*通用视图参考*，详细介绍了QuerySets。在本章的其余部分，我们将把它们当作它们模拟的列表来处理。
- en: Any database lookup is going to follow this general pattern-we'll call methods
    on the manager attached to the model we want to query against.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数据库查找都会遵循这个一般模式-我们将在我们想要查询的模型上调用附加的管理器的方法。
- en: Filtering data
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤数据
- en: 'Naturally, it''s rare to want to select everything from a database at once;
    in most cases, you''ll want to deal with a subset of your data. In the Django
    API, you can filter your data using the `filter()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，很少有人希望一次从数据库中选择所有内容；在大多数情况下，您将希望处理您数据的一个子集。在Django API中，您可以使用`filter()`方法过滤您的数据：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`filter()` takes keyword arguments that get translated into the appropriate
    SQL `WHERE` clauses. The preceding example would get translated into something
    like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`接受关键字参数，这些参数被转换为适当的SQL `WHERE`子句。前面的例子将被转换为类似于这样的东西：'
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can pass multiple arguments into `filter()` to narrow down things further:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将多个参数传递给`filter()`以进一步缩小范围：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Those multiple arguments get translated into SQL `AND` clauses. Thus, the example
    in the code snippet translates into the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多个参数被转换为SQL `AND`子句。因此，代码片段中的示例被转换为以下内容：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Notice that by default the lookups use the SQL `=` operator to do exact match
    lookups. Other lookup types are available:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，查找使用SQL `=`运算符进行精确匹配查找。其他查找类型也是可用的：
- en: '[PRE35]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'That''s a double underscore there between `name` and `contains`. Like Python
    itself, Django uses the double underscore to signal that something magic is happening-here,
    the `__contains` part gets translated by Django into a SQL `LIKE` statement:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在`name`和`contains`之间有一个双下划线。像Python本身一样，Django使用双下划线来表示发生了一些魔术-这里，`__contains`部分被Django转换为SQL
    `LIKE`语句：
- en: '[PRE36]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Many other types of lookups are available, including `icontains` (case-insensitive
    `LIKE`), `startswith` and `endswith`, and `range` (SQL `BETWEEN` queries). [Appendix
    C](apc.xhtml "Appendix C. Generic View Reference"), *Generic View Reference*,
    describes all of these lookup types in detail.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他类型的查找可用，包括`icontains`（不区分大小写的`LIKE`）、`startswith`和`endswith`，以及`range`（SQL
    `BETWEEN`查询）。[附录C](apc.xhtml "附录C. 通用视图参考")，*通用视图参考*，详细描述了所有这些查找类型。
- en: Retrieving single objects
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索单个对象
- en: 'The `filter()` examples above all returned a `QuerySet`, which you can treat
    like a list. Sometimes it''s more convenient to fetch only a single object, as
    opposed to a list. That''s what the `get()` method is for:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的所有`filter()`示例都返回了一个`QuerySet`，您可以像对待列表一样对待它。有时，只获取单个对象比获取列表更方便。这就是`get()`方法的用途：
- en: '[PRE37]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Instead of a list (rather, `QuerySet`), only a single object is returned. Because
    of that, a query resulting in multiple objects will cause an exception:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是返回一个列表（`QuerySet`），只返回一个单一对象。因此，导致多个对象的查询将引发异常：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A query that returns no objects also causes an exception:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 返回没有对象的查询也会引发异常：
- en: '[PRE39]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `DoesNotExist` exception is an attribute of the model''s class-`Publisher.DoesNotExist`.
    In your applications, you''ll want to trap these exceptions, like this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoesNotExist`异常是模型类`Publisher.DoesNotExist`的属性。在您的应用程序中，您将希望捕获这些异常，就像这样：'
- en: '[PRE40]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Ordering data
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排序数据
- en: 'As you play around with the previous examples, you might discover that the
    objects are being returned in a seemingly random order. You aren''t imagining
    things; so far we haven''t told the database how to order its results, so we''re
    simply getting back data in some arbitrary order chosen by the database. In your
    Django applications, you''ll probably want to order your results according to
    a certain value-say, alphabetically. To do this, use the `order_by()` method:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当您尝试之前的示例时，您可能会发现对象以看似随机的顺序返回。您没有想象的事情；到目前为止，我们还没有告诉数据库如何对其结果进行排序，因此我们只是以数据库选择的某种任意顺序返回数据。在您的Django应用程序中，您可能希望根据某个值-比如按字母顺序-对结果进行排序。要做到这一点，请使用`order_by()`方法：
- en: '[PRE41]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This doesn''t look much different from the earlier `all()` example, but the
    SQL now includes a specific ordering:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与之前的`all()`示例没有太大不同，但是现在的SQL包括了特定的排序：
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can order by any field you like:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按任何您喜欢的字段排序：
- en: '[PRE43]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To order by multiple fields (where the second field is used to disambiguate
    ordering in cases where the first is the same), use multiple arguments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要按多个字段排序（其中第二个字段用于消除第一个字段相同时的排序），请使用多个参数：
- en: '[PRE44]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'You can also specify reverse ordering by prefixing the field name with a "-"
    (that''s a minus character):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在字段名前加上“-”（减号）来指定反向排序：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'While this flexibility is useful, using `order_by()` all the time can be quite
    repetitive. Most of the time you''ll have a particular field you usually want
    to order by. In these cases, Django lets you specify a default ordering in the
    model:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种灵活性很有用，但是一直使用`order_by()`可能会相当重复。大多数情况下，您通常会有一个特定的字段，您希望按照它进行排序。在这些情况下，Django允许您在模型中指定默认排序：
- en: '[PRE46]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here, we''ve introduced a new concept: the `class Meta`, which is a class that''s
    embedded within the `Publisher` class definition (that is, it''s indented to be
    within `class Publisher`). You can use this `Meta` class on any model to specify
    various model-specific options. A full reference of `Meta` options is available
    in [Appendix B](apb.xhtml "Appendix B. Database API Reference"), *Database API
    Reference*, but for now, we''re concerned with the ordering option. If you specify
    this, it tells Django that unless an ordering is given explicitly with `order_by()`,
    all `Publisher` objects should be ordered by the `name` field whenever they''re
    retrieved with the Django database API.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们介绍了一个新概念：`class Meta`，它是嵌入在`Publisher`类定义中的类（也就是说，它是缩进在`class Publisher`内部的）。您可以在任何模型上使用这个`Meta`类来指定各种特定于模型的选项。`Meta`选项的完整参考可在[附录B](apb.xhtml
    "附录 B. 数据库 API 参考")中找到，但现在我们关注的是排序选项。如果您指定了这个选项，它告诉Django，除非使用`order_by()`明确给出排序，否则所有`Publisher`对象在使用Django数据库API检索时都应该按`name`字段排序。
- en: Chaining lookups
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接查找
- en: 'You''ve seen how you can filter data, and you''ve seen how you can order it.
    Often, of course, you''ll need to do both. In these cases, you simply chain the
    lookups together:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了如何过滤数据，也看到了如何对其进行排序。当然，通常情况下，您需要同时做这两件事。在这些情况下，您只需将查找链接在一起：
- en: '[PRE47]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you might expect, this translates to a SQL query with both a `WHERE` and
    an `ORDER BY`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所期望的，这会转换为一个同时具有`WHERE`和`ORDER BY`的SQL查询：
- en: '[PRE48]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Slicing data
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片数据
- en: 'Another common need is to look up only a fixed number of rows. Imagine you
    have thousands of publishers in your database, but you want to display only the
    first one. You can do this using Python''s standard list slicing syntax:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的需求是仅查找固定数量的行。想象一下，您的数据库中有成千上万的出版商，但您只想显示第一个。您可以使用Python的标准列表切片语法来实现：
- en: '[PRE49]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This translates roughly to:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致对应于：
- en: '[PRE50]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Similarly, you can retrieve a specific subset of data using Python''s range-slicing
    syntax:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您可以使用Python的范围切片语法检索特定的数据子集：
- en: '[PRE51]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This returns two objects, translating roughly to:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回两个对象，大致翻译为：
- en: '[PRE52]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Note that negative slicing is not supported:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不支持负切片：
- en: '[PRE53]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This is easy to get around, though. Just change the `order_by()` statement,
    like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这很容易解决。只需更改`order_by()`语句，就像这样：
- en: '[PRE54]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Updating multiple objects in one statement
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在一个语句中更新多个对象
- en: 'We pointed out in the *Inserting and updating data* section that the model
    `save()` method updates all columns in a row. Depending on your application, you
    may want to update only a subset of columns. For example, let''s say we want to
    update the Apress `Publisher` to change the name from `''Apress''` to `''Apress
    Publishing''`. Using `save()`, it would look something like this:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在*插入和更新数据*部分指出，模型`save()`方法会更新行中的所有列。根据您的应用程序，您可能只想更新部分列。例如，假设我们要更新Apress
    `Publisher`将名称从`'Apress'`更改为`'Apress Publishing'`。使用`save()`，它看起来会像这样：
- en: '[PRE55]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This roughly translates to the following SQL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致对应以下SQL：
- en: '[PRE56]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '(Note that this example assumes Apress has a publisher ID of `52`.) You can
    see in this example that Django''s `save()` method sets all of the column values,
    not just the `name` column. If you''re in an environment where other columns of
    the database might change due to some other process, it''s smarter to change only
    the column you need to change. To do this, use the `update()` method on `QuerySet`
    objects. Here''s an example:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: （请注意，此示例假定Apress的出版商ID为`52`。）您可以在此示例中看到，Django的`save()`方法设置了所有列的值，而不仅仅是`name`列。如果您处于其他列可能由于其他进程而发生变化的环境中，最好只更改您需要更改的列。要做到这一点，请在`QuerySet`对象上使用`update()`方法。以下是一个例子：
- en: '[PRE57]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The SQL translation here is much more efficient and has no chance of race conditions:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的SQL转换效率更高，没有竞争条件的机会：
- en: '[PRE58]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `update()` method works on any `QuerySet`, which means you can edit multiple
    records in bulk. Here''s how you might change the `country` from `''U.S.A.''`
    to `USA` in each `Publisher` record:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法适用于任何`QuerySet`，这意味着您可以批量编辑多条记录。以下是您可能如何更改每个`Publisher`记录中的`country`从`''U.S.A.''`更改为`USA`：'
- en: '[PRE59]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `update()` method has a return value-an integer representing how many records
    changed. In the above example, we got `2`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法有一个返回值-表示更改了多少条记录的整数。在上面的例子中，我们得到了`2`。'
- en: Deleting objects
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除对象
- en: 'To delete an object from your database, simply call the object''s `delete()`
    method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中删除对象，只需调用对象的`delete()`方法：
- en: '[PRE60]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'You can also delete objects in bulk by calling `delete()` on the result of
    any `QuerySet`. This is similar to the `update()` method we showed in the last
    section:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过在任何`QuerySet`的结果上调用`delete()`来批量删除对象。这类似于我们在上一节中展示的`update()`方法：
- en: '[PRE61]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Be careful deleting your data! As a precaution against deleting all of the
    data in a particular table, Django requires you to explicitly use `all()` if you
    want to delete everything in your table. For example, this won''t work:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 小心删除您的数据！为了防止删除特定表中的所有数据，Django要求您明确使用`all()`，如果要删除表中的所有内容。例如，这样是行不通的：
- en: '[PRE62]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'But it''ll work if you add the `all()` method:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果添加`all()`方法，它将起作用：
- en: '[PRE63]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If you''re just deleting a subset of your data, you don''t need to include
    `all()`. To repeat a previous example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只是删除数据的一个子集，您不需要包括`all()`。重复之前的例子：
- en: '[PRE64]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: What's next?
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Having read this chapter, you have enough knowledge of Django models to be able
    to write basic database applications. [Chapter 9](ch09.xhtml "Chapter 9. Advanced
    Models"), *Advanced Models*, will provide some information on more advanced usage
    of Django's database layer. Once you've defined your models, the next step is
    to populate your database with data. You might have legacy data, in which case
    [Chapter 21](ch21.xhtml "Chapter 21. Advanced Database Management"), *Advanced
    Database Management*, will give you advice about integrating with legacy databases.
    You might rely on site users to supply your data, in which case [Chapter 6](ch06.xhtml
    "Chapter 6. Forms"), *Forms*, will teach you how to process user-submitted form
    data. But in some cases, you or your team might need to enter data manually, in
    which case it would be helpful to have a web-based interface for entering and
    managing data. The next chapter covers Django's admin interface, which exists
    precisely for that reason.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您已经掌握了足够的Django模型知识，可以编写基本的数据库应用程序。[第9章](ch09.xhtml "第9章.高级模型")，“高级模型”，将提供有关Django数据库层更高级用法的一些信息。一旦您定义了模型，下一步就是向数据库填充数据。您可能有遗留数据，这种情况下[第21章](ch21.xhtml
    "第21章.高级数据库管理")，“高级数据库管理”，将为您提供有关与遗留数据库集成的建议。您可能依赖站点用户提供数据，这种情况下[第6章](ch06.xhtml
    "第6章.表单")，“表单”，将教您如何处理用户提交的表单数据。但在某些情况下，您或您的团队可能需要手动输入数据，这种情况下拥有一个基于Web的界面来输入和管理数据将非常有帮助。下一章将介绍Django的管理界面，它正是为了这个目的而存在的。
