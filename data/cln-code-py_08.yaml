- en: Unit Testing and Refactoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和重构
- en: 'The ideas explored in this chapter are fundamental pillars in the global context
    of the book, because of their importance towards our ultimate goal: to write better
    and more maintainable software.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨的思想是本书全局背景中的基本支柱，因为它们对我们的最终目标至关重要：编写更好、更易维护的软件。
- en: Unit tests (and any form of automatic tests, for that matter) are critical to
    software maintainability, and therefore are something that cannot be missing from
    any quality project. It is for that reason that this chapter is dedicated exclusively
    to aspects of automated testing as a key strategy, to safely modify the code,
    and iterate over it, in incrementally better versions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试（以及任何形式的自动测试）对于软件的可维护性至关重要，因此是任何优质项目中不可或缺的东西。正因为如此，本章专门致力于自动化测试作为一个关键策略，以安全地修改代码，并在逐步改进的版本中进行迭代。
- en: 'After this chapter, we will have gained more insight into the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章之后，我们将对以下内容有更深入的了解：
- en: Why automated tests are critical for projects that run under an agile software
    development methodology
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么自动化测试对于采用敏捷软件开发方法论的项目至关重要
- en: How unit tests work as a heuristic of the quality of the code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试作为代码质量的一种启发方式
- en: What frameworks and tools are available to develop automated tests and set up
    quality gates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于开发自动化测试和设置质量门限的框架和工具
- en: Taking advantage of unit tests to understand the domain problem better and document
    code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用单元测试更好地理解领域问题并记录代码
- en: Concepts related to unit testing, such as test-driven development
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与单元测试相关的概念，比如测试驱动开发
- en: Design principles and unit testing
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计原则和单元测试
- en: In this section, are first going to take a look at unit testing from a conceptual
    point of view. We will revisit some of the software engineering principles we
    discussed in the previous to get an idea of how this is related to clean code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先从概念角度来看一下单元测试。我们将重新审视我们在之前讨论过的一些软件工程原则，以了解这与清晰代码的关系。
- en: After that, we will discuss in more detail how to put these concepts into practice
    (at the code level), and what frameworks and tools we can make use of.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将更详细地讨论如何将这些概念付诸实践（在代码层面），以及我们可以利用哪些框架和工具。
- en: First we quickly define what unit testing is about. Unit tests are parts of
    the code in charge of validating other parts of the code. Normally, anyone would
    be tempted to say that unit tests, validate the "core" of the application, but
    such definition regards unit tests to a secondary place, which is not the way
    they are thought of in this book. Unit tests are core, and a critical component
    of the software and they should be treated with the same considerations as the
    business logic.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们快速定义一下单元测试的内容。单元测试是负责验证代码的其他部分的代码。通常，任何人都会倾向于说单元测试验证应用程序的“核心”，但这样的定义将单元测试视为次要的，这并不是本书中对单元测试的思考方式。单元测试是核心，是软件的关键组成部分，应该像业务逻辑一样受到同等的考虑。
- en: 'A unit tests is a piece of code that imports parts of the code with the business
    logic, and exercises its logic, asserting several scenarios with the idea to guarantee
    certain conditions. There are some traits that unit tests must have, such as:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一段代码，它导入代码的部分业务逻辑，并运行其逻辑，断言几种情景，以保证特定条件。单元测试必须具有一些特征，比如：
- en: 'Isolation: unit test should be completely independent from any other external
    agent, and they have to focus only on the business logic. For this reason, they
    do not connect to a database, they don''t perform HTTP requests, etc. Isolation
    also means that the tests are independent among themselves: they must be able
    to run in any order, without depending on any previous state.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隔离：单元测试应该完全独立于任何其他外部代理，并且它们必须只关注业务逻辑。因此，它们不连接到数据库，不执行HTTP请求等。隔离还意味着测试在彼此之间是独立的：它们必须能够以任何顺序运行，而不依赖于任何先前的状态。
- en: 'Performance: unit tests must run quickly. They are intended to be run multiple
    times, repeatedly.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能：单元测试必须运行快速。它们旨在多次重复运行。
- en: 'Self-validating: The execution of a unit tests determines its result. There
    should be no extra step required to interpret the unit test (much less manual).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自我验证：单元测试的执行决定了其结果。不需要额外的步骤来解释单元测试（更不用说手动了）。
- en: More concretely, in Python this means that we will have new `*.py` files where
    we are going to place our unit tests, and they are going to be called by some
    tool. These files will have `import` statements, to take what we need from our
    business logic (what we intend to test), and inside this file we program the tests
    themselves. Afterwards, a tool will collect our unit tests and run them, giving
    a result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在Python中，这意味着我们将有新的`*.py`文件，我们将在其中放置我们的单元测试，并且它们将被某个工具调用。这些文件将有`import`语句，以从我们的业务逻辑中获取我们需要的内容（我们打算测试的内容），并在这个文件中编写测试本身。之后，一个工具将收集我们的单元测试并运行它们，给出一个结果。
- en: This last part is what self-validation actually means. When the tool calls our
    files, a Python process will be launched, and our tests will be running on it.
    If the tests fail, the process will have exited with an error code (in a Unix
    environment, this can be any number different than `0`). The standard is that
    the tool runs the test, and prints a dot (`.`) for every successful test, an `F`
    if the test failed (the condition of the test was not satisfied), and an `E` if
    there was an exception.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一部分实际上就是自我验证的含义。当工具调用我们的文件时，将启动一个Python进程，并在其上运行我们的测试。如果测试失败，进程将以错误代码退出（在Unix环境中，这可以是任何不等于`0`的数字）。标准是工具运行测试，并为每个成功的测试打印一个点（`.`），如果测试失败，则打印一个`F`（测试条件未满足），如果出现异常，则打印一个`E`。
- en: A note about other forms of automated testing
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于其他形式的自动化测试的说明
- en: Unit tests are intended to verify very small units, for example a function,
    or a method. We want from our unit tests to reach a very detailed level of granularity,
    testing as much code as possible. To test a class we would not want to use a unit
    tests, but rather a test suite, which is a collection of unit tests. Each one
    of them will be testing something more specific, like a method of that class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试旨在验证非常小的单元，例如函数或方法。我们希望通过单元测试达到非常详细的粒度，尽可能测试更多的代码。为了测试一个类，我们不想使用单元测试，而是使用测试套件，这是一组单元测试。每一个单元测试将测试更具体的内容，比如该类的一个方法。
- en: This is not the only form of unit tests, and it cannot catch every possible
    error. There are also acceptance and integration tests, both out of the scope
    of this book.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是唯一的单元测试形式，也不能捕捉到每一个可能的错误。还有验收测试和集成测试，都超出了本书的范围。
- en: In an integration test, we will want to test multiple components at once. In
    this case we want to validate if collectively, they work as expected. In this
    case is acceptable (more than that, desirable) to have side-effects, and to forget
    about isolation, meaning that we will want to issue HTTP requests, connect to
    databases, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，我们希望一次测试多个组件。在这种情况下，我们希望验证它们是否集体按预期工作。在这种情况下，有副作用是可以接受的（甚至是可取的），并且可以忽略隔离，这意味着我们希望发出HTTP请求，连接到数据库等。
- en: An acceptance test is an automated form of testing that tries to validate the
    system from the perspective of an user, typically executing use cases.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试是一种自动化的测试形式，试图从用户的角度验证系统，通常执行用例。
- en: 'These two last forms of testing lose another nice trait with respect of unit
    tests: velocity. As you can imagine, they will take more time to run, therefore
    they will be run less frequently.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种测试方式失去了单元测试的另一个优点：速度。正如你可以想象的，它们将需要更多时间来运行，因此它们将运行得更少。
- en: 'In a good development environment, the programmer will have the entire test
    suite, and will run unit tests all the time, repeatedly, while he or she is making
    changes to the code, iterating, refactoring, and so on. Once the changes is ready,
    and the pull request is open, the continuous integration service will run the
    build for that branch, where the unit tests will run, as long as the integration
    or acceptance tests that might exist. Needless to say, the status of the build
    should be successful (green) before merging, but the important part is the difference
    between the kind of tests: we want to run unit tests all the  time, and less frequently
    those test that take longer. For this reason, we want to have a lot of small unit
    tests, and a few automated tests, strategically designed to cover as much as possible
    of where the unit tests could not reach (the database, for instance).'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个良好的开发环境中，程序员将拥有整个测试套件，并且在进行代码更改、迭代、重构等过程中，会一直运行单元测试。一旦更改准备就绪，并且拉取请求已经打开，持续集成服务将对该分支运行构建，其中将运行单元测试，以及可能存在的集成或验收测试。不用说，在合并之前，构建的状态应该是成功的（绿色），但重要的是测试类型之间的差异：我们希望一直运行单元测试，并且较少频繁地运行那些需要更长时间的测试。因此，我们希望有很多小的单元测试，以及一些自动化测试，策略性地设计来尽可能覆盖单元测试无法达到的地方（例如数据库）。
- en: Finally, a word to the wise. Remember that this book encourages pragmatism.
    Besides these definitions give, and the points made about unit tests in the beginning
    of the section, the reader has to keep in mind that the best solution according
    to your criteria and context, should predominate. Nobody knows your system better
    than you. Which means, if for some reason you have to write an unit tests that
    needs to launch a Docker container to test against a database, go for it. As we
    have repeatedly remembered throughout the book, ***practicality beats purity***.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，智者之言。请记住，本书鼓励实用主义。除了本书中给出的定义和关于单元测试的观点之外，读者必须牢记，根据您的标准和背景，最佳解决方案应该占主导地位。没有人比您更了解您的系统。这意味着，如果由于某种原因，您必须编写一个需要启动Docker容器来针对数据库进行测试的单元测试，那就去做吧。正如我们在整本书中反复提醒的那样，实用性胜过纯粹性。
- en: Unit testing and agile software development
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和敏捷软件开发
- en: In modern software development, we want to deliver value constantly, and as
    quickly as possible. The rationale behind these goals is that the earlier we get
    feedback, the less the impact, and the easier it will be to change. These are
    no new ideas at all; some of them resemble manufacturing principles from decades
    ago, and others (such as the idea of getting feedback from stakeholders as soon
    as possible and iterating upon it) you can find in essays such as *The Cathedral
    and the Bazaar* (abbreviated as *CatB*).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，我们希望不断地以尽可能快的速度交付价值。这些目标背后的理念是，我们获得反馈的越早，影响就越小，改变就越容易。这些并不是新的想法；其中一些类似于几十年前的制造原则，而其他一些（比如尽快从利益相关者那里获得反馈并对其进行迭代的想法）可以在《大教堂与集市》等文章中找到。
- en: Therefore, we want to be able to respond effectively to changes, and for that,
    the software we write will have to change. Like we mentioned in the previous chapters,
    we want our software to be adaptable, flexible, and extensible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们希望能够有效地应对变化，为此，我们编写的软件将不得不改变。就像我们在前几章中提到的，我们希望我们的软件是适应性强、灵活和可扩展的。
- en: The code alone (regardless of how well written and designed it is) cannot guarantee
    us that it's flexible enough to be changed. Let's say we design a piece of software
    following the SOLID principles, and in one part we actually have a set of components
    that comply with the open/closed principle, meaning that we can easily extend
    them without affecting too much existing code. Assume further that the code is
    written in a way that favors refactoring, so we could change it as required. What's
    to say that when we make these changes, we aren't introducing any bugs? How do
    we know that existing functionality is preserved? Would you feel confident enough
    releasing that to your users? Will they believe that the new version works just
    as expected?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 单单代码（无论它写得多么好和设计得多么好）不能保证它足够灵活以便进行更改。假设我们按照SOLID原则设计了一款软件，并且在某个部分实际上有一组符合开闭原则的组件，这意味着我们可以很容易地扩展它们而不会影响太多现有的代码。进一步假设代码是以有利于重构的方式编写的，因此我们可以根据需要进行更改。当我们进行这些更改时，有什么可以证明我们没有引入任何错误？我们怎么知道现有的功能被保留了？你会对向用户发布这个新版本感到有信心吗？他们会相信新版本的工作方式与预期一样吗？
- en: The answer to all of these questions is that we can't be sure unless we have
    a formal proof of it. And unit tests are just that, formal proof that the program
    works according to the specification.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有这些问题的答案是，除非我们有正式的证明，否则我们无法确定。而单元测试就是这样，它是程序按照规范工作的正式证明。
- en: Unit (or automated) tests, therefore, work as a safety net that gives us the
    confidence to work on our code. Armed with these tools, we can efficiently work
    on our code, and therefore this is what ultimately determines the velocity (or
    capacity) of the team working on the software product. The better the tests, the
    more likely it is we can deliver value quickly without being stopped by bugs every
    now and then.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，单元（或自动）测试作为一个安全网，给了我们在代码上工作的信心。有了这些工具，我们可以高效地工作在我们的代码上，因此这最终决定了团队在软件产品上的速度（或能力）。测试越好，我们就越有可能快速交付价值，而不会因为不时出现的错误而停滞不前。
- en: Unit testing and software design
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试和软件设计
- en: This is the other face of the coin when it comes to the relationship between
    the main code and unit testing. Besides the pragmatic reasons explored in the
    previous section, it comes down to the fact that good software is testable software.
    **Testability** (the quality attribute that determines how easy to test software
    is) is not just a nice to have, but a driver for clean code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及主代码和单元测试之间的关系时，这是另一面的问题。除了在前一节中探讨的实用原因之外，它归结为良好的软件是可测试的软件。**可测试性**（决定软件易于测试程度的质量属性）不仅仅是一种美好的东西，而是对清晰代码的驱动。
- en: Unit tests aren't just something complementary to the main code base, but rather
    something that has a direct impact and real influence on how the code is written.
    There are many levels of this, from the very beginning when we realize that the
    moment we want to add unit tests for some parts of our code, we have to change
    it (resulting in a better version of it), to its ultimate expression (explored
    near the end of this chapter) when the entire code (the design) is driven by the
    way it's going to be tested via **test-driven design**.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不仅仅是主代码库的补充，而是对代码编写方式有直接影响和真正影响的东西。从最初意识到我们想要为代码的某些部分添加单元测试时，我们必须对其进行更改（从而得到更好的版本），到其最终表达（在本章末尾附近探讨）时，整个代码（设计）是由它将如何通过**测试驱动设计**进行测试而驱动的。
- en: Starting off with a simple example, we will show you a small use case in which
    tests (and the need to test our code) lead to improvements in the way our code
    ends up being written.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个简单的例子开始，我们将向您展示一个小的用例，其中测试（以及测试我们的代码的需要）导致我们编写代码的方式得到改进。
- en: 'In the following example, we will simulate a process that requires sending
    metrics to an external system about the results obtained at each particular task
    (as always, details won''t make any difference as long as we focus on the code).
    We have a `Process` object that represents some task on the domain problem, and
    it uses a `metrics` client (an external dependency and therefore something we
    don''t control) to send the actual metrics to the external entity (that this could
    be sending data to `syslog`, or `statsd`, for instance):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将模拟一个需要向外部系统发送关于每个特定任务获得的结果的指标的过程（和往常一样，只要我们专注于代码，细节就不重要）。我们有一个代表领域问题上某个任务的`Process`对象，并且它使用一个`metrics`客户端（一个外部依赖，因此我们无法控制）来将实际的指标发送到外部实体（这可能是发送数据到`syslog`或`statsd`，例如）：
- en: '[PRE0]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the simulated version of the third-party client, we put the requirement
    that the parameters provided must be of type string. Therefore, if the `result`
    of the `run_process` method is not a string, we might expect it to fail, and indeed
    it does:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三方客户端的模拟版本中，我们规定提供的参数必须是字符串类型。因此，如果`run_process`方法的`result`不是字符串，我们可能期望它会失败，而事实上确实如此：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember that this validation is out of our hands and we cannot change the code,
    so we must provide the method with parameters of the correct type before proceeding.
    But since this is a bug we detected, we first want to write a unit test to make
    sure it will not happen again. We do this to actually prove that we fixed the
    issue, and to protect against this bug in the future, regardless of how many times
    the code is refactored.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这种验证不在我们的控制之内，我们无法改变代码，因此在继续之前，我们必须为方法提供正确类型的参数。但由于这是我们发现的一个错误，我们首先想要编写一个单元测试，以确保它不会再次发生。我们这样做实际上是为了证明我们修复了问题，并且保护免受这个错误的影响，无论代码被重构多少次。
- en: It would be possible to test the code as is by mocking the client of the `Process`
    object (we will see how to do so in the section about mock objects, when we explore
    the tools for unit testing), but doing so runs more code than is needed (notice
    how the part we want to test is  nested into the code). Moreover, it's good that
    the method is relatively small, because if it weren't, the test would have to
    run even more undesired parts that we might also need to mock. This is another
    example of good design (small, cohesive functions or methods), that relates to
    testability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟`Process`对象的`client`，我们可以测试代码，但这样做会运行比需要的更多的代码（注意我们想要测试的部分嵌套在代码中）。此外，方法相对较小是件好事，因为如果不是这样，测试将不得不运行更多不需要的部分，我们可能也需要模拟。这是另一个良好设计的例子（小而紧密的函数或方法），与可测试性相关。
- en: 'Finally, we decide not to go to much trouble and test just the part that we
    need to, so instead of interacting with the `client` directly on the `main` method,
    we delegate to a `wrapper` method, and the new class looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们决定不费太多力气，只测试我们需要的部分，所以我们不直接在`main`方法上与`client`交互，而是委托给一个`wrapper`方法，新的类看起来是这样的：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we opted for creating our own version of the `client` for metrics,
    that is, a wrapper around the third-party library one we used to have. To do this,
    we place a class that (with the same interface) will make the conversion of the
    types accordingly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们选择为指标创建我们自己的版本的`client`，也就是说，一个围绕我们以前使用的第三方库的包装器。为此，我们放置了一个类（具有相同的接口），将根据需要转换类型。
- en: This way of using composition resembles the adapter design pattern (we'll explore
    design patterns in the next chapter, so, for now, it's just an informative message),
    and since this is a new object in our domain, it can have its respective unit
    tests. Having this object will make things simpler to test, but more importantly,
    now that we look at it, we realize that this is probably the way the code should
    have been written in the first place. Trying to write a unit test for our code
    made us realize that we were missing an important abstraction entirely!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用组合的方式类似于适配器设计模式（我们将在下一章中探讨设计模式，所以现在只是一个信息性的消息），而且由于这是我们领域中的一个新对象，它可以有其相应的单元测试。拥有这个对象将使测试变得更简单，但更重要的是，现在我们看到，我们意识到这可能是代码应该一开始就应该编写的方式。尝试为我们的代码编写单元测试使我们意识到我们完全错过了一个重要的抽象！
- en: 'Now that we have separated the method as it should be, let''s write the actual
    unit test for it. The details about the `unittest` module used in this example
    will be explored in more detail in the part of the chapter where we explore testing
    tools and libraries, but for now reading the code will give us a first impression
    on how to test it, and it will make the previous concepts a little less abstract:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经将方法分离出来，让我们为其编写实际的单元测试。在本例中使用的`unittest`模块的详细信息将在我们探讨测试工具和库的章节中更详细地探讨，但现在阅读代码将给我们一个关于如何测试的第一印象，并且会使之前的概念变得不那么抽象：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`Mock` is a type that''s available in the `unittest.mock` module, which is
    a quite convenient object to ask about all sort of things. For example, in this
    case, we''re using it in place of the third-party library (mocked into the boundaries
    of the system, as commented on the next section) to check that it''s called as
    expected (and once again, we''re not testing the library itself, only that it
    is called correctly). Notice how we run a call like the one our `Process` object,
    but we expect the parameters to be converted to strings.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mock`是`unittest.mock`模块中可用的一种类型，它是一个非常方便的对象，可以询问各种事情。例如，在这种情况下，我们将其用于替代第三方库（模拟成系统边界，如下一节所述），以检查它是否按预期调用（再次强调，我们不测试库本身，只测试它是否被正确调用）。注意我们运行了一个类似于我们的`Process`对象的调用，但我们期望参数被转换为字符串。'
- en: Defining the boundaries of what to test
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义要测试的边界
- en: Testing requires effort. And if we are not careful when deciding what to test,
    we will never end testing, hence wasting a lot of effort without achieving much.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 测试需要付出努力。如果我们在决定要测试什么时不小心，我们将永远无法结束测试，因此浪费了大量的精力而没有取得多少成果。
- en: We should scope the testing to the boundaries of our code. If we don't, we would
    have to also test the dependencies (external/third-party libraries or modules)
    or our code, and then their respective dependencies, and so on and so forth in
    a never-ending journey. It's not our responsibility to test dependencies, so we
    can assume that these projects have tests of their own. It would be enough just
    to test that the correct calls to external dependencies are done with the correct
    parameters (and that might even be an acceptable use of patching), but we shouldn't
    put more effort in than that.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该将测试范围限定在我们的代码边界内。如果不这样做，我们将不得不测试依赖项（外部/第三方库或模块）或我们的代码，然后测试它们各自的依赖项，依此类推，永无止境。我们不负责测试依赖关系，因此我们可以假设这些项目有自己的测试。只需测试对外部依赖的正确调用是否使用了正确的参数（这甚至可能是对补丁的可接受使用），但我们不应该投入更多的精力。
- en: This is another instance where good software design pays off. If we have been
    careful in our design, and clearly defined the boundaries of our system (that
    is, we designed towards interfaces, instead of concrete implementations that will
    change, hence inverting the dependencies over external components to reduce temporal
    coupling), then it will be much more easier to mock these interfaces when writing
    unit tests.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一个良好软件设计的实例。如果我们在设计时小心谨慎，并清晰地定义了系统的边界（也就是说，我们设计时朝向接口，而不是会改变的具体实现，从而颠倒了对外部组件的依赖关系以减少时间耦合），那么在编写单元测试时，模拟这些接口将会更容易得多。
- en: In good unit testing, we want to patch on the boundaries of our system and focus
    on the core functionality to be exercised. We don't test external libraries (third-party
    tools installed via `pip`, for instance), but instead, we check that they are
    called correctly. When we explore `mock` objects later on in this chapter, we
    will review techniques and tools for performing these types of assertion.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在良好的单元测试中，我们希望在系统的边界上打补丁，并专注于要执行的核心功能。我们不测试外部库（例如通过`pip`安装的第三方工具），而是检查它们是否被正确调用。当我们在本章后面探讨`mock`对象时，我们将回顾执行这些类型的断言的技术和工具。
- en: Frameworks and tools for testing
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试框架和工具
- en: There are a lot of tools we can use for writing out unit tests, all of them
    with pros and cons and serving different purposes. But among all of them, there
    are two that will most likely cover almost every scenario, and therefore we limit
    this section to just them.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多工具可以用于编写单元测试，它们都有各自的优缺点并且服务于不同的目的。但在所有工具中，有两种最有可能覆盖几乎所有场景，因此我们将本节限制在这两种工具上。
- en: Along with testing frameworks and test running libraries, it's often common
    to find projects that configure code coverage, which they use as a quality metric.
    Since coverage (when used as a metric) is misleading, after seeing how to create
    unit tests we'll discuss why it's not to be taken lightly.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试框架和测试运行库之外，通常还可以找到配置代码覆盖率的项目，它们将其用作质量指标。由于覆盖率（作为指标使用时）是误导性的，因此在了解如何创建单元测试之后，我们将讨论为什么不应轻视它。
- en: Frameworks and libraries for unit testing
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试的框架和库
- en: In this section, we will discuss two frameworks for writing and running unit
    tests. The first one, `unittest`, is available in the standard library of Python,
    while the second one, `pytest`, has to be installed externally via `pip`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论两个编写和运行单元测试的框架。第一个是`unittest`，它在Python的标准库中可用，而第二个`pytest`必须通过`pip`外部安装。
- en: '`unittest`: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unittest`: [https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)'
- en: '`pytest`: [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`: [https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)'
- en: When it comes to covering testing scenarios for our code, `unittest` alone will
    most likely suffice, since it has plenty of helpers. However, for more complex
    systems on which we have multiple dependencies, connections to external systems,
    and probably the need to patch objects, and define fixtures parameterize test
    cases, then `pytest` looks like a more complete option.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到为我们的代码覆盖测试场景时，`unittest`可能就足够了，因为它有很多辅助功能。然而，对于我们有多个依赖项、连接到外部系统并且可能需要打补丁对象以及定义固定参数化测试用例的更复杂的系统，`pytest`看起来更完整。
- en: We will use a small program as an example to show you how could it be tested
    using both options which in the end will help us to get a better picture of how
    the two of them compare.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个小程序作为示例，以展示如何使用这两种选项进行测试，最终将帮助我们更好地了解它们之间的比较。
- en: 'The example demonstrating testing tools is a simplified version of a version
    control tool that supports code reviews in merge requests. We will start with
    the following criteria:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 演示测试工具的示例是一个支持合并请求中的代码审查的版本控制工具的简化版本。我们将从以下标准开始：
- en: A merge request is `rejected` if at least one person disagrees with the changes
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果至少有一个人不同意更改，合并请求将被拒绝
- en: If nobody has disagreed, and the merge request is good for at least two other
    developers, it's `approved`
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有人反对，并且至少有其他两个开发人员认为合并请求是好的，它就会被批准
- en: In any other case, its status is `pending`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在其他情况下，它的状态是`pending`
- en: 'And here is what the code might look like:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可能如下所示：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: unittest
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: unittest
- en: The `unittest` module is a great option with which to start writing unit tests
    because it provides a rich API to write all kinds of testing conditions, and since
    it's available in the standard library, it's quite versatile and convenient.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块是一个很好的选择，可以开始编写单元测试，因为它提供了丰富的API来编写各种测试条件，并且由于它在标准库中可用，因此它非常灵活和方便。'
- en: The `unittest` module is based on the concepts of JUnit (from Java), which in
    turn is also based on the original ideas of unit testing that come from Smalltalk,
    so it's object-oriented in nature. For this reason, tests are written through
    objects, where the checks are verified by methods, and it's common to group tests
    by scenarios in classes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块基于JUnit（来自Java）的概念，而JUnit又基于来自Smalltalk的单元测试的原始思想，因此它是面向对象的。因此，测试是通过对象编写的，其中检查由方法验证，并且通常通过类将测试分组到场景中。'
- en: To start writing unit tests, we have to create a test class that inherits from
    `unittest.TestCase`, and define the conditions we want to stress on its methods.
    These methods should start with `test_*`, and can internally use any of the methods
    inherited from `unittest.TestCase` to check conditions that must hold true.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写单元测试，我们必须创建一个从`unittest.TestCase`继承的测试类，并定义我们想要在其方法中强调的条件。这些方法应该以`test_*`开头，并且可以在内部使用从`unittest.TestCase`继承的任何方法来检查必须成立的条件。
- en: 'Some examples of conditions we might want to verify for our case are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要验证我们的情况的一些条件的示例包括：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The API for unit testing provides many useful methods for comparison, the most
    common one being `assertEquals(<actual>, <expected>[, message])`, which can be
    used to compare the result of the operation against the value we were expecting,
    optionally using a message that will be shown in the case of an error.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的API提供了许多有用的比较方法，其中最常见的是`assertEquals(<actual>, <expected>[, message])`，它可以用来比较操作的结果与我们期望的值，可选地使用在错误情况下显示的消息。
- en: Another useful testing method allows us to check whether a certain exception
    was raised or not. When something exceptional happens, we raise an exception in
    our code to prevent continuous processing under the wrong assumptions, and also
    to inform the caller that something is wrong with the call as it was performed.
    This is the part of the logic that ought to be tested, and that's what this method
    is for.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的测试方法允许我们检查是否引发了某个异常。当发生异常情况时，我们在代码中引发异常，以防止在错误的假设下进行持续处理，并且通知调用者调用的方式有问题。这是应该进行测试的逻辑的一部分，这就是这个方法的作用。
- en: Imagine that we are now extending our logic a little bit further to allow users
    to close their merge requests, and once this happens, we don't want any more votes
    to take place (it wouldn't make sense to evaluate a merge request once this was
    already closed). To prevent this from happening, we extend our code and we raise
    an exception on the unfortunate event when someone tries to cast a vote on a closed
    merge request.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们现在正在进一步扩展我们的逻辑，以允许用户关闭他们的合并请求，一旦发生这种情况，我们就不希望再进行更多的投票（在合并请求已经关闭后评估合并请求是没有意义的）。为了防止这种情况发生，我们扩展我们的代码，并在不幸的事件发生时引发异常，当有人试图对已关闭的合并请求进行投票时。
- en: 'After adding two new statuses (`OPEN` and `CLOSED`), and a new `close()` method,
    we modify the previous methods for the voting to handle this check first:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了两个新状态（`OPEN`和`CLOSED`）和一个新的`close()`方法之后，我们修改了之前的投票方法，以处理此检查：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we want to check that this validation indeed works. For this, we''re going
    to use the `asssertRaises` and `assertRaisesRegex` methods:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要检查这个验证是否有效。为此，我们将使用`asssertRaises`和`assertRaisesRegex`方法：
- en: '[PRE7]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The former will expect that the provided exception is raised when calling the
    callable in the second argument, with the arguments (`*args` and `**kwargs`) on
    the rest of the function, and if that's not the case it will fail, saying that
    the exception that was expected to be raised, wasn't. The latter does the same
    but it also checks that the exception that was raised, contains the message matching
    the regular expression that was provided as a parameter. Even if the exception
    is raised, but with a different message (not matching the regular expression),
    the test will fail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前者期望在调用第二个参数中的可调用对象时引发提供的异常，使用函数的其余部分的参数（`*args`和`**kwargs`），如果不是这种情况，它将失败，并表示预期引发的异常未被引发。后者也是如此，但它还检查引发的异常是否包含与提供的正则表达式匹配的消息。即使引发了异常，但消息不同（不匹配正则表达式），测试也会失败。
- en: Try to check for the error message, as not only will the exception, as an extra
    check, be more accurate and ensure that it is actually the exception we want that
    is being triggered, it will check whether another one of the same types got there
    by chance.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试检查错误消息，因为异常不仅会更准确地进行额外检查，确保实际上触发了我们想要的异常，还会检查是否另一个相同类型的异常偶然发生。
- en: Parametrized tests
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化测试
- en: Now, we would like to test how the threshold acceptance for the merge request
    works, just by providing data samples of what the `context` looks like without
    needing the entire `MergeRequest` object. We want to test the part of the `status`
    property that is after the line that checks if it's closed, but independently.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要测试合并请求的阈值接受如何工作，只需提供`context`的数据样本，而不需要整个`MergeRequest`对象。我们想要测试`status`属性的部分，即在检查它是否关闭之后的部分，但是独立地。
- en: 'The best way to achieve this is to separate that component into another class,
    use composition, and then move on to test this new abstraction with its own test
    suite:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一目标的最佳方法是将该组件分离为另一个类，使用组合，然后继续使用自己的测试套件测试这个新的抽象：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With these changes, we can run the tests again and verify that they pass, meaning
    that this small refactor didn''t break anything of the current functionality (unit
    tests ensure regression). With this, we can proceed with our goal to write tests
    that are specific to the new class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些变化，我们可以再次运行测试并验证它们是否通过，这意味着这次小的重构没有破坏当前功能（单元测试确保回归）。有了这一点，我们可以继续实现编写特定于新类的测试的目标：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, in the `setUp()` method, we define the data fixture to be used throughout
    the tests. In this case, it's not actually needed, because we could have put it
    directly on the method, but if we expect to run some code before any test is executed,
    this is the place to write it, because this method is called once before every
    test is run.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUp()`方法中，我们定义了要在整个测试中使用的数据装置。在这种情况下，实际上并不需要，因为我们可以直接放在方法中，但是如果我们希望在执行任何测试之前运行一些代码，这就是写入的地方，因为这个方法在每次运行测试之前都会被调用一次。
- en: By writing this new version of the code, the parameters under the code being
    tested are  clearer and more compact, and at each case, it will report the results.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写代码的新版本，被测试代码下的参数更清晰更紧凑，并且在每种情况下都会报告结果。
- en: 'To simulate that we''re running all of the parameters, the test iterates over
    all the data, and exercises the code with each instance. One interesting helper
    here is the use of `subTest`, which in this case we use to mark the test condition
    being called. If one of these iterations failed, `unittest` would report it with
    the corresponding value of the variables that were passed to the `subTest` (in
    this case, it was named `context`, but any series of keyword arguments would work
    just the same). For example, one error occurrence might look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟我们正在运行所有参数，测试会遍历所有数据，并对每个实例执行代码。这里一个有趣的辅助方法是使用`subTest`，在这种情况下，我们使用它来标记被调用的测试条件。如果其中一个迭代失败，`unittest`会报告相应的变量值，这些变量被传递给`subTest`（在这种情况下，它被命名为`context`，但任何一系列关键字参数都可以起到同样的作用）。例如，一个错误可能看起来像这样：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you choose to parameterize tests, try to provide the context of each instance
    of the parameters with as much information as possible to make debugging easier.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择参数化测试，请尽量提供每个参数实例的上下文信息，以便更容易进行调试。
- en: pytest
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: pytest
- en: Pytest is a great testing framework, and can be installed via `pip install pytest`.
    A difference with respect to `unittest` is that, while it's still possible to
    classify test scenarios in classes and create object-oriented models of our tests,
    this is not actually mandatory, and it's possible to write unit tests with less
    boilerplate by just checking the conditions we want to verify with the `assert`statement.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Pytest是一个很棒的测试框架，可以通过`pip install pytest`进行安装。与`unittest`相比的一个区别是，虽然仍然可以将测试场景分类为类，并创建我们测试的面向对象模型，但这并不是强制性的，也可以通过使用`assert`语句来写更少的样板代码进行单元测试。
- en: By default, making comparisons with an `assert` statement will be enough for `pytest`
    to identify a unit test and report its result accordingly. More advanced uses
    such as those seen in the previous section are also possible, but they require
    using specific functions from the package.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用`assert`语句进行比较就足以让`pytest`识别单元测试并相应地报告其结果。还可以使用包中的特定函数进行更高级的用法，但这需要使用特定的函数。
- en: A nice feature is that the command `pytests` will run all the tests that it
    can discover, even if they were written with `unittest`. This compatibility makes
    it easier to transition from `unittest` toward `pytest` gradually.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的特性是命令`pytests`将运行它能够发现的所有测试，即使它们是用`unittest`编写的。这种兼容性使得逐渐从`unittest`过渡到`pytest`变得更容易。
- en: Basic test cases with pytest
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pytest进行基本测试用例
- en: The conditions we tested in the previous section can be rewritten in simple
    functions with `pytest`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中测试的条件可以用`pytest`中的简单函数重写。
- en: 'Some examples with simple assertions are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一些简单断言的示例如下：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Boolean equality comparisons don''t require more than a simple `assert` statement,
    whereas other kinds of checks like the ones for the exceptions do require that
    we use some functions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔相等比较不需要更多的简单断言语句，而其他类型的检查，比如异常的检查需要我们使用一些函数：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, `pytest.raises` is the equivalent of `unittest.TestCase.assertRaises`,
    and it also accepts that it be called both as a method and as a context manager.
    If we want to check the message of the exception, instead of a different method
    (like `assertRaisesRegex`), the same function has to be used, but as a context
    manager, and by providing the `match` parameter with the expression we would like
    to identify.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`pytest.raises`相当于`unittest.TestCase.assertRaises`，它也接受作为方法和上下文管理器调用。如果我们想检查异常的消息，而不是使用不同的方法（如`assertRaisesRegex`），则必须使用相同的函数，但作为上下文管理器，并提供`match`参数与我们想要识别的表达式。
- en: '`pytest` will also wrap the original exception into a custom one that can be
    expected (by checking some of its attributes such as `.value`, for instance) in
    case we want to check for more conditions, but this use of the function covers
    the vast majority of cases.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`还会将原始异常包装成一个自定义异常，可以通过检查其属性（例如`.value`）来预期，以便在需要检查更多条件时使用，但这个函数的使用覆盖了绝大多数情况。'
- en: Parametrized tests
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化测试
- en: Running parametrized tests with `pytest` is better, not only because it provides
    a cleaner API, but also because each combination of the test with its parameters
    generates a new test case.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pytest`运行参数化测试更好，不仅因为它提供了更清晰的API，而且因为每个测试与其参数的组合都会生成一个新的测试用例。
- en: To work with this, we have to use the `pytest.mark.parametrize`decorator on
    our test. The first parameter of the decorator is a string indicating the names
    of the parameters to pass to the `test` function, and the second has to be iterable
    with the respective values for those parameters.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用这个，我们必须在我们的测试上使用`pytest.mark.parametrize`装饰器。装饰器的第一个参数是一个字符串，指示要传递给`test`函数的参数的名称，第二个参数必须是可迭代的，包含这些参数的相应值。
- en: 'Notice how the body of the testing function is reduced to one line (after removing
    the internal `for` loop, and its nested context manager), and the data for each
    test case is correctly isolated from the body of the function, making it easier
    to extend and maintain:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意测试函数的主体如何被简化为一行（在移除内部`for`循环和其嵌套的上下文管理器后），并且每个测试用例的数据都正确地与函数的主体隔离开来，这样更容易扩展和维护：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Use `@pytest.mark.parametrize` to eliminate repetition, keep the body of the
    test as cohesive as possible, and make the parameters (test inputs or scenarios)
    that the code must support explicitly.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`@pytest.mark.parametrize`来消除重复，尽可能使测试主体保持内聚，并明确指定代码必须支持的参数（测试输入或场景）。
- en: Fixtures
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fixture
- en: One of the great things about `pytest` is how it facilitates creating reusable
    features so that we can feed our tests with data or objects in order to test more
    effectively and without repetition.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest`的一个很棒的功能是它如何促进创建可重用的功能，这样我们可以有效地测试数据或对象，而不需要重复。'
- en: 'For example, we might want to create a `MergeRequest` object in a particular
    state, and use that object in multiple tests. We define our object as a fixture
    by creating a function and applying the `@pytest.fixture` decorator. The tests
    that want to use that fixture will have to have a parameter with the same name
    as the function that''s defined, and `pytest` will make sure that it''s provided:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，我们可能想要创建一个处于特定状态的`MergeRequest`对象，并在多个测试中使用该对象。我们通过创建一个函数并应用`@pytest.fixture`装饰器来将我们的对象定义为fixture。想要使用该fixture的测试将必须具有与定义的函数相同名称的参数，`pytest`将确保提供它： '
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember that tests affect the main code as well, so the principles of clean
    code apply to them as well. In this case, the **Don't Repeat Yourself** (**DRY**)
    principle that we explored in previous chapters appears once again, and we can
    achieve it with the help of `pytest` fixtures.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，测试也会影响主要代码，因此干净代码的原则也适用于它们。在这种情况下，我们在之前章节中探讨过的**不要重复自己**（**DRY**）原则再次出现，我们可以借助`pytest`的fixture来实现它。
- en: Besides creating multiple objects or exposing data that will be used throughout
    the test suite, it's also possible to use them to set up some conditions, for
    example, to globally patch some functions that we don't want to be called, or
    when we want patch objects to be used instead.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建多个对象或公开将在整个测试套件中使用的数据之外，还可以使用它们来设置一些条件，例如全局修补一些不希望被调用的函数，或者当我们希望使用修补对象时。
- en: Code coverage
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Tests runners support coverage plugins (to be installed via `pip`) that will
    provide useful information about what lines in the code have been executed while
    the tests were running. This information is of great help so that we know which
    parts of the code need to be covered by tests, as well identifying improvements
    to be made (both in the production code and in the tests). One of the most widely
    used libraries for this is `coverage` ([https://pypi.org/project/coverage/](https://pypi.org/project/coverage/)).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 测试运行器支持覆盖插件（通过`pip`安装）将提供有关测试运行时执行了代码的哪些行的有用信息。这些信息对我们非常有帮助，以便我们知道代码的哪些部分需要被测试覆盖，并确定需要进行的改进（无论是在生产代码中还是在测试中）。其中最广泛使用的库之一是`coverage`（[https://pypi.org/project/coverage/](https://pypi.org/project/coverage/)）。
- en: While they are of great help (and we highly recommend that you use them and
    configure your project to run coverage in the CI when tests are run), they can
    also be misleading; particularly in Python, we can get a false impression if we
    don't pay close attention to the coverage report.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它们非常有帮助（我们强烈建议您使用它们并配置您的项目在运行测试时在CI中运行覆盖），但它们也可能会产生误导；特别是在Python中，如果我们不仔细阅读覆盖报告，就会产生错误的印象。
- en: Setting up rest coverage
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置其余覆盖
- en: In the case of `pytest`, we have to install the `pytest-cov` package (at the
    time of this writing, version `2.5.1` is used in this book). Once installed, when
    the tests are run, we have to tell the `pytest` runner that `pytest-cov` will
    also run, and which package (or packages) should be covered (among other parameters
    and configurations).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`pytest`的情况下，我们必须安装`pytest-cov`软件包（在撰写本书时，本书使用的是版本`2.5.1`）。安装后，当运行测试时，我们必须告诉`pytest`运行器也将运行`pytest-cov`，以及应该覆盖哪个软件包（以及其他参数和配置）。
- en: This package supports multiple configurations, like different sorts of output
    formats, and it's easy to integrate it with any CI tool, but among all these features
    a highly recommended option is to set the flag that will tell us which lines haven't
    been covered by tests yet, because this is what's going to help us diagnose our
    code and allow us to start writing more tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 该软件包支持多种配置，如不同类型的输出格式，并且很容易将其与任何CI工具集成，但在所有这些功能中，一个强烈推荐的选项是设置标志，告诉我们哪些行尚未被测试覆盖，因为这将帮助我们诊断我们的代码，并允许我们开始编写更多的测试。
- en: 'To show you an example of what this would look like, use the following command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向您展示这是什么样子，使用以下命令：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This will produce an output similar to the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生类似以下的输出：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, it's telling us that there is a line that doesn't have unit tests so that
    we can take a look and see how to write a unit test for it. This is a common scenario
    where we realize that to cover those missing lines, we need to refactor the code
    by creating smaller methods. As a result, our code will look much better, as in
    the example we saw at the beginning of this chapter.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，它告诉我们有一行没有单元测试，因此我们可以查看并了解如何为其编写单元测试。这是一个常见的情况，我们意识到为了覆盖这些缺失的行，我们需要通过创建更小的方法来重构代码。结果，我们的代码看起来会好得多，就像我们在本章开头看到的例子一样。
- en: The problem lies in the inverse situation—can we trust the high coverage? Does
    it mean our code is correct? Unfortunately, having good test coverage is necessary
    but in sufficient condition for clean code. Not having tests for parts of the
    code is clearly something bad. Having tests is actually very good (and we can
    say this for the tests that do exist), and actually asserts real conditions that
    they are a guarantee of quality for that part of the code. However, we cannot
    say that is all that is required; despite having a high level of coverage, even
    more tests are required.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于相反的情况——我们能相信高覆盖率吗？这是否意味着我们的代码是正确的？不幸的是，拥有良好的测试覆盖率是必要的，但不足以保证代码的清洁。对代码的某些部分没有测试显然是不好的。拥有测试实际上是非常好的（我们可以说对于已经存在的测试），并且实际上断言了它们是代码质量的保证。然而，我们不能说这就是所有需要的；尽管覆盖率很高，但仍需要更多的测试。
- en: These are the caveats of test coverage, which we will mention in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是测试覆盖率的注意事项，我们将在下一节中提到。
- en: Caveats of test coverage
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试覆盖的注意事项
- en: Python is interpreted and, at a very high-level, coverage tools take advantage
    of this to identify the lines that were interpreted (run) while the tests were
    running. It will then report this at the end. The fact that a line was interpreted
    does not mean that it was properly tested, and this is why we should be careful
    about reading the final coverage report and trusting what it says.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Python是解释性的，而覆盖工具利用这一点来识别在测试运行时被解释（运行）的行。然后它会在最后报告这一点。一行被解释并不意味着它被正确测试了，这就是为什么我们应该仔细阅读最终的覆盖报告并信任它所说的内容。
- en: This is actually true for any language. The fact that a line was exercised does
    not mean at all that it was stressed with all its possible combinations. The fact
    that all branches run successfully with the provided data only means that the
    code supported that combination, but it doesn't tell us anything about any other
    possible combinations of parameters that would make the program crash.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上对于任何语言都是正确的。执行了一行代码并不意味着它已经经历了所有可能的组合。所有分支在提供的数据下成功运行只意味着代码支持了该组合，但这并不能告诉我们任何其他可能导致程序崩溃的参数组合。
- en: Use coverage as a tool to find blind spots in the code, but not as a metric
    or target goal.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用覆盖作为发现代码中盲点的工具，而不是作为度量标准或目标。
- en: Mock objects
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟对象
- en: There are cases where our code is not the only thing that will be present in
    the context of our tests. After all, the systems we design and build have to do
    something real, and that usually means connecting to external services (databases,
    storage services, external APIs, cloud services, and so on). Because they need
    to have those side-effects, they're inevitable. As much as we abstract our code,
    program towards interfaces, and isolate code from external factors in order to
    minimize side-effects, they will be present in our tests, and we need an effective
    way to handle that.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，我们的代码不是在测试环境中唯一存在的东西。毕竟，我们设计和构建的系统必须做一些真实的事情，这通常意味着连接到外部服务（数据库、存储服务、外部API、云服务等）。因为它们需要具有这些副作用，它们是不可避免的。尽管我们抽象我们的代码，朝着接口编程，并且隔离代码以最小化副作用，但它们会出现在我们的测试中，我们需要一种有效的方式来处理它们。
- en: '`Mock` objects are one of the best tactics to defend against undesired side-effects.
    Our code might need to perform an HTTP request or send a notification email, but
    we surely don''t want that to happen in our unit tests. Besides, unit tests should
    run quickly, as we want to run them quite often (all the time, actually), and
    this means we cannot afford latency. Therefore, real unit tests don''t use any
    actual service—they don''t connect to any database, they don''t issue HTTP requests,
    and basically, they do nothing other than exercise the logic of the production
    code.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`模拟`对象是防止不良副作用的最佳策略之一。我们的代码可能需要执行HTTP请求或发送通知电子邮件，但我们肯定不希望这些事件发生在我们的单元测试中。此外，单元测试应该运行得很快，因为我们希望经常运行它们（实际上是一直），这意味着我们不能承受延迟。因此，真正的单元测试不使用任何实际服务——它们不连接到任何数据库，不发出HTTP请求，基本上除了执行生产代码的逻辑之外什么都不做。'
- en: We need tests that do such things, but they aren't units. Integration tests
    are supposed to test functionality with a broader perspective, almost mimicking
    the behavior of a user. But they aren't fast. Because they connect to external
    systems and services, they take longer to run and are more expensive. In general,
    we would like to have lots of unit tests that run really quickly in order to run
    them all the time, and have integration tests run less often (for instance, on
    any new merge request).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行这些操作的测试，但它们不是单元测试。集成测试应该以更广泛的视角测试功能，几乎模仿用户的行为。但它们不快。因为它们连接到外部系统和服务，所以运行时间更长，成本更高。通常，我们希望有大量的单元测试能够快速运行，以便一直运行它们，而集成测试则较少运行（例如，在任何新的合并请求上）。
- en: While mock objects are useful, abusing their use ranges between a code smell
    or an anti-pattern is the first caveat we would like to mention before going into
    the details of it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然模拟对象很有用，但滥用它们的使用范围介于代码异味和反模式之间是我们在深入讨论之前想要提到的第一个警告。
- en: A fair warning about patching and mocks
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于修补和模拟的公平警告
- en: We said before that unit tests help us write better code, because the moment
    we want to start testing parts of the code, we usually have to write them to be
    testable, which often means they are also cohesive, granular, and small. These
    are all good traits to have in a software component.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前说过，单元测试帮助我们编写更好的代码，因为我们想要开始测试代码的部分时，通常必须编写可测试的代码，这通常意味着它们也是内聚的、细粒度的和小的。这些都是软件组件中具有的良好特性。
- en: Another interesting gain is that testing will help us notice code smells in
    parts where we thought our code was correct. One of the main warnings that our
    code has code smells is whether we find ourselves trying to monkey-patch (or mock)
    a lot of different things just to cover a simple test case.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的收获是，测试将帮助我们注意到代码中存在代码异味的地方。我们的代码存在代码异味的主要警告之一是，我们发现自己试图monkey-patch（或模拟）许多不同的东西，只是为了覆盖一个简单的测试用例。
- en: The `unittest` module provides a tool for patching our objects at `unittest.mock.patch`.
    Patching means that the original code (given by a string denoting its location
    at import time), will be replaced by something else, other than its original code,
    being the default a mock object. This replaces the code at run-time, and has the
    disadvantage that we are losing contact with the original code that was there
    in the first place, making our tests a little more shallow. It also carries performance
    considerations, because of the overhead that imposes modifying objects in the
    interpreter at run-time, and it's something that might end up update if we refactor
    our code and move things around.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`unittest`模块提供了一个在`unittest.mock.patch`中修补对象的工具。修补意味着原始代码（由导入时指定其位置的字符串给出）将被其他东西替换，而不是其原始代码，默认情况下是模拟对象。这会在运行时替换代码，并且有一个缺点，即我们失去了原始代码的联系，使我们的测试变得更加肤浅。它还带来了性能考虑，因为在运行时修改对象会带来开销，并且如果我们重构代码并移动事物，这可能会导致更新。'
- en: Using monkey-patching or mocks in our tests might be acceptable, and by itself
    it doesn't represent an issue. On the other hand, abuse in monkey-patching is
    indeed a flag that something has to be improved in our code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试中使用monkey-patching或模拟可能是可以接受的，而且本身并不代表一个问题。另一方面，滥用monkey-patching确实是一个标志，表明我们的代码需要改进。
- en: Using mock objects
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟对象
- en: In unit testing terminology, there are several types of object that fall into
    the category named **test doubles**. A test double is a type of object that will
    take the place of a real one in our test suite for different kinds of reasons
    (maybe we don't need the actual production code, but just a dummy object would
    work, or maybe we can't use it because it requires access to services or it has
    side-effects that we don't want in our unit tests, and so on).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试术语中，有几种对象属于名为**测试替身**的类别。测试替身是一种对象，它将以不同种类的原因在我们的测试套件中代替真实对象（也许我们不需要实际的生产代码，而只需要一个虚拟对象，或者我们不能使用它，因为它需要访问服务或者它具有我们不希望在单元测试中出现的副作用等）。
- en: There are different types of test double, such as dummy objects, stubs, spies,
    or mocks. Mocks are the most general type of object, and since they're quite flexible
    and versatile, they are appropriate for all cases without needing to go into much
    detail about the rest of them. It is for this reason that the standard library
    also includes an object of this kind, and it is common in most Python programs.
    That's the one we are going to be using here: `unittest.mock.Mock`.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有不同类型的测试替身，例如虚拟对象、存根、间谍或模拟。模拟是最一般的对象类型，由于它们非常灵活和多功能，因此适用于所有情况，而无需详细了解其他情况。正因为如此，标准库还包括了这种类型的对象，并且在大多数Python程序中都很常见。这就是我们将在这里使用的：`unittest.mock.Mock`。
- en: A **mock** is a type of object created to a specification (usually resembling
    the object of a production class) and some configured responses (that is, we can
    tell the mock what it should return upon certain calls, and what its behavior
    should be). The `Mock` object will then record, as part of its internal status,
    how it was called (with what parameters, how many times, and so on), and we can
    use that information to verify the behavior of our application at a later stage.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**模拟**是一种根据规范创建的对象类型（通常类似于生产类的对象）和一些配置的响应（也就是说，我们可以告诉模拟在某些调用时应该返回什么，并且它的行为应该是什么）。然后，“模拟”对象将记录其内部状态的一部分，例如它是如何被调用的（使用了什么参数，多少次等），我们可以使用该信息在以后的阶段验证我们应用程序的行为。'
- en: In the case of Python, the `Mock` object that's available from the standard
    library provides a nice API to make all sorts of behavioral assertions, such as
    checking how many times the mock was called, with what parameters, and so on.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python的情况下，标准库中提供的“Mock”对象提供了一个很好的API，可以进行各种行为断言，例如检查模拟调用了多少次，使用了什么参数等。
- en: Types of mocks
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟的类型
- en: The standard library provides `Mock` and `MagicMock` objects in the `unittest.mock`
    module. The former is a test double that can be configured to return any value
    and will keep track of the calls that were made to it. The latter does the same,
    but it also supports magic methods. This means that, if we have written idiomatic
    code that uses magic methods (and parts of the code we are testing will rely on
    that), it's likely that we will have to use a `MagicMock` instance instead of
    just a `Mock`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库在`unittest.mock`模块中提供了`Mock`和`MagicMock`对象。前者是一个可以配置为返回任何值并将跟踪对其进行的调用的测试替身。后者也是如此，但它还支持魔术方法。这意味着，如果我们编写了使用魔术方法的成语代码（并且我们正在测试的代码的某些部分将依赖于它），那么我们可能必须使用`MagicMock`实例而不仅仅是`Mock`。
- en: 'Trying to use `Mock` when our code needs to call magic methods will result
    in an error. See the following code for an example of this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的代码需要调用魔术方法时，尝试使用`Mock`将导致错误。请参阅以下代码，以了解此示例：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We want to test this function; however, another test needs to call the `author_by_id` function.
    For some reason, since we''re not testing that function, any value provided to
    that function (and returned) will be good:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想测试这个函数；但是，另一个测试需要调用`author_by_id`函数。由于某种原因，因为我们没有测试该函数，提供给该函数（并返回）的任何值都将是好的：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As anticipated, this will not work:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，这不起作用：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Using `MagicMock` instead will work. We can even configure the magic method
    of this type of mock to return something we need in order to control the execution
    of our test:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`MagicMock`将起作用。我们甚至可以配置此类型模拟的魔术方法，以返回我们需要的内容，以便控制我们测试的执行：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A use case for test doubles
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试替身的用例
- en: 'To see a possible use of mocks, we need to add a new component to our application
    that will be in charge of notifying the merge request of the `status` of the `build`.
    When a `build` is finished, this object will be called with the ID of the merge
    request and the `status` of the `build`, and it will update the `status` of the
    merge request with this information by sending an HTTP `POST` request to a particular
    fixed endpoint:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到模拟的可能用途，我们需要向我们的应用程序添加一个新组件，该组件将负责通知“构建”“状态”的合并请求。当“构建”完成时，将使用合并请求的ID和“构建”的“状态”调用此对象，并通过向特定的固定端点发送HTTP“POST”请求来使用此信息更新合并请求的“状态”：
- en: '[PRE21]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This class has many side-effects, but one of them is an important external dependency
    which is hard to surmount. If we try to write a test over it without modifying
    anything, it will fail with a connection error as soon as it tries to perform
    the HTTP connection.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有很多副作用，但其中一个是一个重要的难以克服的外部依赖。如果我们试图在不修改任何内容的情况下对其进行测试，那么它将在尝试执行HTTP连接时立即失败并出现连接错误。
- en: As a testing goal, we just want to make sure that the information is composed
    correctly, and that library requests are being called with the appropriate parameters.
    Since this is an external dependency, we don't test requests; just checking that
    it's called correctly will be enough.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为测试目标，我们只想确保信息被正确组成，并且库请求是使用适当的参数进行调用的。由于这是一个外部依赖项，我们不测试请求；只需检查它是否被正确调用就足够了。
- en: Another problem we will face when trying to compare data being sent to the library
    is that the class is calculating the current timestamp, which is impossible to
    predict in a unit test. Patching `datetime` directly is not possible, because
    the module is written in C. There are some external libraries that can do that
    (`freezegun`, for example), but they come with a performance penalty, and for
    this example would be overkill. Therefore, we opt to wrapping the functionality
    we want in a static method that we will be able to patch.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试比较发送到库的数据时，我们将面临另一个问题，即该类正在计算当前时间戳，这在单元测试中是不可能预测的。直接修补`datetime`是不可能的，因为该模块是用C编写的。有一些外部库可以做到这一点（例如`freezegun`），但它们会带来性能损耗，并且对于这个例子来说会过度。因此，我们选择将我们想要的功能封装在一个静态方法中，以便我们可以修补它。
- en: 'Now that we have established the points that need to be replaced in the code,
    let''s write the unit test:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了代码中需要替换的要点，让我们编写单元测试：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we use `mock.patch` as a decorator to replace the `requests` module.
    The result of this function will create a `mock` object that will be passed as
    a parameter to the test (named `mock_requests` in this example). Then, we use
    this function again, but this time as a context manager to change the return value
    of the method of the class that computes the date of the `build`, replacing the
    value with one we control, that we will use in the assertion.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`mock.patch`作为装饰器来替换`requests`模块。这个函数的结果将创建一个`mock`对象，将作为参数传递给测试（在这个例子中命名为`mock_requests`）。然后，我们再次使用这个函数，但这次作为上下文管理器，来改变计算“构建”日期的类的方法的返回值，用我们控制的值替换它，我们将在断言中使用。
- en: Once we have all of this in place, we can call the class method with some parameters,
    and then we can use the `mock` object to check how it was called. In this case,
    we are using the method to see if `requests.post` was indeed called with the parameters
    as we wanted them to be composed.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把所有这些都放在那里，我们就可以用一些参数调用类方法，然后我们可以使用`mock`对象来检查它是如何被调用的。在这种情况下，我们使用这个方法来查看`requests.post`是否确实以我们想要的参数被调用。
- en: This is a nice feature of mocks—not only do they put some boundaries around
    all external components (in this case to prevent actually sending some notifications
    or issuing HTTP requests), but they also provide a useful API to verify the calls
    and their parameters.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模拟的一个很好的特性——它们不仅限制了所有外部组件的范围（在这种情况下，以防止实际发送一些通知或发出HTTP请求），而且还提供了一个有用的API来验证调用及其参数。
- en: While, in this case, we were able to test the code by setting the respective
    `mock` objects in place, it's also true that we had to patch quite a lot in proportion
    to the total lines of code for the main functionality. There is no rule about
    the ratio of pure productive code being tested versus how many parts of that code
    we have to mock, but certainly, by using common sense, we can see that,  if we
    had to patch quite a lot of things in the same parts, something is not clearly
    abstracted, and it looks like a code smell.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们能够通过设置相应的“模拟”对象来测试代码，但事实上，与主要功能的总代码行数相比，我们不得不进行相当多的补丁。关于被测试的纯生产代码与我们必须模拟的代码部分之间的比例没有明确的规则，但是通过运用常识，我们可以看到，如果我们不得不在相同的部分进行相当多的补丁，那么某些东西并没有被清晰地抽象出来，看起来像是代码异味。
- en: In the next section, we will explore how to refactor code to overcome this issue.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何重构代码来解决这个问题。
- en: Refactoring
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构
- en: '**Refactoring** is a critical activity in software maintenance, yet something
    that can''t be done (at least correctly) without having unit tests. Every now
    and then, we need to support a new feature or use our software in unintended ways.
    We need to realize that the only way to accommodate such requirements is by first
    refactoring our code, make it more generic. Only then can we move forward.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**重构**是软件维护中的一个关键活动，但如果没有单元测试，就不能做到（至少是正确的）。我们时不时需要支持一个新功能或以意想不到的方式使用我们的软件。我们需要意识到，满足这些要求的唯一方法是首先重构我们的代码，使其更通用。只有这样，我们才能继续前进。'
- en: Typically, when refactoring our code, we want to improve its structure and make
    it better, sometimes more generic, more readable, or more flexible. The challenge
    is to achieve these goals while at the same time preserving the exact same functionality
    it had prior to the modifications that were made. This means that, in the eyes
    of the clients of those components we're refactoring, it might as well be the
    case that nothing had happened at all.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在重构我们的代码时，我们希望改进其结构，使其更好，有时更通用，更可读，或更灵活。挑战在于在实现这些目标的同时保持与修改之前完全相同的功能。这意味着，在我们重构的组件的客户眼中，可能根本没有发生任何事情。
- en: This constraint of having to support the same functionalities as before but
    with a different version of the code implies that we need to run regression tests
    on code that was modified. The only cost-effective way of running regression tests
    is if those tests are automatic. The most cost-effective version of automatic
    tests is unit tests.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 必须支持与之前相同的功能，但使用不同版本的代码这一约束意味着我们需要对修改过的代码运行回归测试。运行回归测试的唯一经济有效的方法是自动化。自动化测试的最经济有效的版本是单元测试。
- en: Evolving our code
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进我们的代码
- en: In the previous example, we were able to separate out the side-effects from
    our code to make it testable by patching those parts of the code that depended
    on things we couldn't control on the unit test. This is a good approach since,
    after all, the `mock.patch` function comes in handy for these sorts of task and
    replaces the objects we tell it to, giving us back a `Mock` object.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们能够将代码的副作用与我们无法在单元测试中控制的部分分离出来，通过对依赖于这些部分的代码进行补丁，使其可测试。这是一个很好的方法，因为毕竟，`mock.patch`函数对于这些任务来说非常方便，可以替换我们告诉它的对象，给我们一个`Mock`对象。
- en: The downside of that is that we have to provide the path of the object we are
    going to mock, including the module, as a string. This is a bit fragile, because
    if we refactor our code (let's say we rename the file or move it to some other
    location), all the places with the patch will have to be updated, or the test
    will break.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的缺点是，我们必须提供我们将要模拟的对象的路径，包括模块，作为一个字符串。这有点脆弱，因为如果我们重构我们的代码（比如说我们重命名文件或将其移动到其他位置），所有的补丁位置都必须更新，否则测试将会失败。
- en: In the example, the fact that the `notify()` method directly depends on an implementation
    detail (the `requests` module) is a design issue, that is, it is taking its toll
    on the unit tests as well with the aforementioned fragility that is implied.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`notify()`方法直接依赖于一个实现细节（`requests`模块），这是一个设计问题，也就是说，它也对单元测试产生了上述的脆弱性。
- en: 'We still need to replace those methods with doubles (mocks), but if we refactor
    the code, we can do it in a better way. Let''s separate these methods into smaller
    ones, and most importantly inject the dependency rather than keep it fixed. The
    code now applies the dependency inversion principle,and it expects to work with
    something that supports an interface (in this example, implicit one) such as the
    one the `requests` module provides:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要用双重对象（模拟）替换这些方法，但如果我们重构代码，我们可以以更好的方式来做。让我们将这些方法分开成更小的方法，最重要的是注入依赖，而不是固定它。现在代码应用了依赖反转原则，并且期望与支持接口的东西一起工作（在这个例子中是隐式的），比如`requests`模块提供的接口：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We separate the methods (not notify is now compose + deliver), make `compose_payload()`
    a new method (so that we can replace, without the need to patch the class), and
    require the `transport` dependency to be injected. Now that `transport` is a dependency,
    it is much easier to change that object for any double we want.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将方法分开（不再是notify，而是compose + deliver），创建了一个新的`compose_payload()`方法（这样我们可以替换，而不需要打补丁类），并要求注入`transport`依赖。现在`transport`是一个依赖项，更容易更改该对象为我们想要的任何双重对象。
- en: 'It is even possible to expose a fixture of this object with the doubles replaced
    as required:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 甚至可以暴露这个对象的一个fixture，并根据需要替换双重对象：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Production code isn't the only thing that evolves
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产代码并不是唯一在演变的东西
- en: We keep saying that unit tests are as important as production code. And if we
    are careful enough with production code as to create the best possible abstraction,
    why wouldn't we do the same for unit tests?
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在说单元测试和生产代码一样重要。如果我们对生产代码足够小心以创建最佳的抽象，为什么我们不为单元测试做同样的事呢？
- en: If the code for unit tests is as important as the main code, then it's definitely
    wise to design it with extensibility in mind and make it as maintainable as possible.
    After all, this is the code that will have to be maintained by an engineer other
    than its original author, so it has to be readable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试的代码和主要代码一样重要，那么设计时一定要考虑可扩展性，并尽可能使其易于维护。毕竟，这段代码将由原作者以外的工程师来维护，因此必须易读。
- en: The reason why we pay so much attention to make the code's flexibility is that
    we know requirements change and evolve over time, and eventually as domain business
    rules change, our code will have to change as well to support these new requirements.
    Since the production code changed to support new requirements, in turn, the testing
    code will have to change as well to support the newer version of the production
    code.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如此重视代码的灵活性的原因是，我们知道需求会随着时间的推移而改变和演变，最终随着领域业务规则的变化，我们的代码也将不得不改变以支持这些新需求。由于生产代码已经改变以支持新需求，测试代码也将不得不改变以支持生产代码的新版本。
- en: In one of the first examples we used, we created a series of tests for the merge
    request object, trying different combinations and checking the status at which
    the merge request was left. This is a good first approach, but we can do better
    than that.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最初的示例中，我们为合并请求对象创建了一系列测试，尝试不同的组合并检查合并请求的状态。这是一个很好的第一步，但我们可以做得更好。
- en: Once we understand the problem better, we can start creating better abstractions.
    With this, the first idea that comes to mind is that we can create a higher-level
    abstraction that checks for particular conditions. For example, if we have an
    object that is a test suite that specifically targets the `MergeRequest` class,
    we know its functionality will be limited to the behavior of this class (because
    it should comply to the SRP), and therefore we could create specific testing methods
    on this testing class. These will only make sense for this class, but that will
    be helpful in reducing a lot of boilerplate code.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更好地理解了问题，我们就可以开始创建更好的抽象。首先想到的是，我们可以创建一个检查特定条件的更高级抽象。例如，如果我们有一个专门针对`MergeRequest`类的测试套件对象，我们知道其功能将局限于这个类的行为（因为它应该符合SRP），因此我们可以在这个测试类上创建特定的测试方法。这些方法只对这个类有意义，但可以帮助减少大量样板代码。
- en: 'Instead of repeating assertions that follow the exact same structure, we can
    create a method that encapsulates this and reuse it across all of the tests:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个封装这一结构的断言的方法，并在所有测试中重复使用它，而不是重复断言：
- en: '[PRE26]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If something changes with how we check the status of a merge request (or let's
    say we want to add extra checks), there is only one place (the `assert_approved()`
    method) that will have to be modified. More importantly, by creating these higher-level
    abstractions, the code that started as merely unit tests starts to evolve into
    what could end up being a testing framework with its own API or domain language,
    making testing more declarative.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如果合并请求的状态检查发生变化（或者我们想要添加额外的检查），只有一个地方（`assert_approved()`方法）需要修改。更重要的是，通过创建这些更高级的抽象，最初只是单元测试的代码开始演变成可能最终成为具有自己API或领域语言的测试框架，使测试更具有声明性。
- en: More about unit testing
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于单元测试
- en: With the concepts we have revisited so far, we know how to test our code, think
    about our design in terms of how it is going to be tested, and configure the tools
    in our project to run the automated tests that will give us some degree of confidence
    over the quality of the software we have written.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们迄今为止重新审视的概念，我们知道如何测试我们的代码，考虑我们的设计将如何进行测试，并配置项目中的工具来运行自动化测试，这将使我们对所编写软件的质量有一定程度的信心。
- en: If our confidence in the code is determined by the unit tests written on it,
    how do we know that they are enough? How could we be sure that we have been through
    enough on the test scenarios and that we are not missing some tests? Who says
    that these tests are correct? Meaning, who tests the tests?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对代码的信心是由编写在其上的单元测试所决定的，那么我们如何知道它们足够了？我们怎么能确定我们已经在测试场景上经历了足够多的测试，而且没有漏掉一些测试？谁说这些测试是正确的？也就是说，谁来测试这些测试？
- en: The first part of the question, about being thorough on the tests we wrote,
    is answered by going beyond in our testing efforts through property-based testing.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们编写的测试是否彻底的问题的第一部分，通过基于属性的测试来超越我们的测试努力来回答。
- en: The second part of the question might have multiple answers from different points
    of view, but we are going to briefly mention mutation testing as a means of determining
    that our tests are indeed correct. In this sense, we are thinking that the unit
    tests check our main productive code, and this works as a control for the unit
    tests as well.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的第二部分可能会有不同的观点给出多个答案，但我们将简要提到变异测试作为确定我们的测试确实是正确的手段。在这方面，我们认为单元测试检查我们的主要生产代码，这也对单元测试起到了控制作用。
- en: Property-based testing
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于属性的测试
- en: Property-based testing consists of generating data for tests cases with the
    goal of finding scenarios that will make the code fail, which weren't covered
    by our previous unit tests.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的测试包括生成测试用例的数据，目的是找到会使代码失败的情景，而这些情景在我们之前的单元测试中没有涵盖。
- en: The main library for this is `hypothesis` which, configured along with our unit
    tests, will help us find problematic data that will make our code fail.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个主要的库是`hypothesis`，它与我们的单元测试一起配置，将帮助我们找到会使我们的代码失败的问题数据。
- en: We can imagine that what this library does is find counter examples for our
    code. We write our production code (and unit tests for it!), and we claim it's
    correct. Now, with this library, we define some `hypothesis` that must hold for
    our code, and if there are some cases where our assertions don't hold, the `hypothesis`
    will provide a set of data that causes the error.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象这个库的作用是找到我们代码的反例。我们编写我们的生产代码（以及针对它的单元测试！），并声称它是正确的。现在，通过这个库，我们定义了一些必须满足我们代码的`hypothesis`，如果有一些情况下我们的断言不成立，`hypothesis`将提供一组导致错误的数据。
- en: The best thing about unit tests is that they make us think harder about our
    production code. The best thing about the `hypothesis` is that it makes us think
    harder about our unit tests.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试最好的一点是它让我们更加深入地思考我们的生产代码。`hypothesis`最好的一点是它让我们更加深入地思考我们的单元测试。
- en: Mutation testing
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变异测试
- en: We know that tests are the formal verification method we have to ensure that
    our code is correct. And what makes sure that the test is correct? The production
    code, you might think, and yes, in a way this is correct, we can think of the
    main code as a counter balance for our tests.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道测试是我们确保代码正确的正式验证方法。那么是什么确保测试是正确的呢？你可能会想到生产代码，是的，在某种程度上这是正确的，我们可以将主要代码视为对我们测试的一个平衡。
- en: The point in writing unit tests is that we are protecting ourselves against
    bugs, and testing for failure scenarios we really don't want to happen in production.
    It's good that the tests pass, but it would be bad if they pass for the wrong
    reasons. That is, we can use unit tests as an automatic regression tool—if someone
    introduces a bug in the code, later on, we expect at least one of our tests to
    catch it and fail. If this doesn't happen, either there is a test missing, or
    the ones we had are not doing the right checks.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 编写单元测试的重点在于我们正在保护自己免受错误的侵害，并测试我们真的不希望在生产中发生的失败场景。测试通过是好事，但如果它们通过了错误的原因就不好了。也就是说，我们可以将单元测试用作自动回归工具——如果有人在代码中引入了错误，我们期望我们的至少一个测试能够捕捉到并失败。如果这没有发生，要么是缺少了一个测试，要么是我们已有的测试没有进行正确的检查。
- en: This is the idea behind mutation testing. With a mutation testing tool, the
    code will be modified to new versions (called mutants), that are variations of
    the original code but with some of its logic altered (for example, operators are
    swapped, conditions are inverted, and so on). A good test suite should catch these
    mutants and kill them, in which case it means we can rely on the tests. If some
    mutants survive the experiment, it's usually a bad sign. Of course, this is not
    entirely precise, so there are intermediate states we might want to ignore.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是变异测试的理念。使用变异测试工具，代码将被修改为新版本（称为变异体），这些变异体是原始代码的变体，但其中一些逻辑被改变了（例如，操作符被交换，条件被倒置等）。一个良好的测试套件应该能够捕捉到这些变异体并将其消灭，这意味着我们可以依赖这些测试。如果一些变异体在实验中幸存下来，通常这是一个不好的迹象。当然，这并不是完全精确的，所以有一些中间状态我们可能想要忽略。
- en: 'To quickly show you how this works and to allow you to get a practical idea
    of this, we are going to use a different version of the code that computes the
    status of a merge request based on the number of approvals and rejections. This
    time, we have changed the code for a simple version that, based on these numbers,
    returns the result. We have moved the enumeration with the constants for the statuses
    to a separate module so that it now looks more compact:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了快速向您展示这是如何工作的，并让您对此有一个实际的想法，我们将使用一个不同版本的代码来计算合并请求的状态，这是基于批准和拒绝的数量。这一次，我们已经改变了代码，改为一个简单版本，根据这些数字返回结果。我们已经将包含状态常量的枚举移到一个单独的模块中，所以现在看起来更加紧凑：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And now will we add a simple unit test, checking one of the conditions and
    its expected `result`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加一个简单的单元测试，检查其中一个条件及其预期的“结果”：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, we will install `mutpy`, a mutation testing tool for Python, with `pip
    install mutpy`, and tell it to run the mutation testing for this module with these
    tests:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将安装`mutpy`，一个用于Python的变异测试工具，使用`pip install mutpy`，并告诉它使用这些测试运行此模块的变异测试：
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result is going to look something similar to this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将会看起来类似于这样：
- en: '[PRE30]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is a good sign. Let''s take a particular instance to analyze what happened.
    One of the lines on the output shows the following mutant:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好迹象。让我们拿一个特定的实例来分析发生了什么。输出中的一行显示了以下变异体：
- en: '[PRE31]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that this mutant consists of the original version with the operator changed
    in line `11` (`>` for `<`), and the result is telling us that this mutant was
    killed by the tests. This means that with this version of the code (let's imagine
    that someone by mistakes makes this change), then the result of the function would
    have been `APPROVED`, and since the test expects it to be `REJECTED`, it fails,
    which is a good sign (the test caught the bug that was introduced).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个变异体由原始版本和第11行中操作符改变（`>`改为`<`）组成，结果告诉我们这个变异体被测试杀死了。这意味着使用这个代码版本（假设有人错误地进行了这个更改），函数的结果将是`APPROVED`，而测试期望它是`REJECTED`，所以测试失败，这是一个好迹象（测试捕捉到了引入的错误）。
- en: Mutation testing is a good way to assure the quality of the unit tests, but
    it requires some effort and careful analysis. By using this tool in complex environments,
    we will have to take some time analyzing each scenario. It is also true that it
    is expensive to run these tests because it requires multiples runs of different
    versions of the code, which might take up too many resources and may take longer
    to complete. However, it would be even more expensive to have to make these checks
    manually and will require much more effort. Not doing these checks at all might
    be even riskier, because we would be jeopardizing the quality of the tests.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 变异测试是确保单元测试质量的一种好方法，但它需要一些努力和仔细的分析。在复杂的环境中使用这个工具，我们将不得不花一些时间分析每个场景。同样，运行这些测试是昂贵的，因为它需要运行不同版本的代码，这可能会占用太多资源并且可能需要更长的时间来完成。然而，手动进行这些检查会更加昂贵，并且需要更多的努力。不进行这些检查可能会更加危险，因为我们会危及测试的质量。
- en: A brief introduction to test-driven development
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试驱动开发简介
- en: There are entire books dedicated only to TDD, so it would not be realistic to
    try and cover this topic comprehensively in this book. However, it's such an important
    topic that it has to be mentioned.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些专门讲述TDD的书籍，所以在这本书中全面涵盖这个话题是不现实的。然而，这是一个非常重要的话题，必须提到。
- en: The idea behind TDD is that tests should be written before production code in
    a way that the production code is only written to respond to tests that are failing
    due to that missing implementation of the functionality.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: TDD的理念是在编写生产代码之前编写测试，以便生产代码只是为了响应由于功能缺失而失败的测试而编写的。
- en: There are multiple reasons why we would like to write the tests first and then
    the code. From a pragmatic point of view, we would be covering our production
    code quite accurately. Since all of the production code was written to respond
    to a unit test, it would be highly unlikely that there are tests missing for functionality
    (that doesn't mean that there is 100% of coverage of course, but at least all
    main functions, methods, or components will have their respective tests, even
    if they aren't completely covered).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望先编写测试，然后编写代码的原因有多个。从实用的角度来看，我们会相当准确地覆盖我们的生产代码。由于所有的生产代码都是为了响应单元测试而编写的，很少会有功能缺失的测试（当然这并不意味着有100%的覆盖率，但至少所有的主要函数、方法或组件都会有各自的测试，即使它们并不完全覆盖）。
- en: The workflow is simple and at a high-level consist of three steps. First, we
    write a unit test that describes something we need to be implemented. When we
    run this test, it will fail, because that functionality has not been implemented
    yet. Then, we move onto implementing the minimal required code that satisfies
    that condition, and we run the test again. This time, the test should pass. Now,
    we can improve (refactor) the code.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程很简单，高层次上包括三个步骤。首先，我们编写一个描述需要实现的单元测试。当我们运行这个测试时，它会失败，因为这个功能还没有被实现。然后，我们开始实现满足条件的最小代码，并再次运行测试。这次，测试应该通过。现在，我们可以改进（重构）代码。
- en: This cycle has been popularized as the famous **red-green-refactor**, meaning
    that in the beginning, the tests fail (red), then we make them pass (green), and
    then we proceed to refactor the code and iterate it.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环被称为著名的**红-绿-重构**，意思是一开始测试失败（红色），然后我们让它们通过（绿色），然后我们进行重构并迭代。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Unit testing is a really interesting and deep topic, but more importantly, it
    is a critical part of the clean code. Ultimately, unit tests are what determine
    the quality of the code. Unit tests often act as a mirror for the code—when the
    code is easy to test, it's clear and correctly designed, and this will be reflected
    in the unit tests.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是一个非常有趣和深刻的话题，但更重要的是，它是清晰代码的关键部分。最终，单元测试决定了代码的质量。单元测试通常作为代码的镜子——当代码易于测试时，它是清晰和正确设计的，这将反映在单元测试中。
- en: The code for the unit tests is as important as production code. All principles
    that apply to production code also apply to unit tests. This means that they should
    be designed and maintained with the same effort and thoughtfulness. If we don't
    care about our unit tests, they will start to have problems and become defective
    (or problematic), and as a result of that, useless. If this happens, and they
    are hard to maintain, they become a liability which makes things even worse, because
    people will tend to ignore them or disable them entirely. This is the worst scenario
    because once this happens, the entire production code is in jeopardy. Moving forward
    blindly (without unit tests) is a recipe for disaster.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的代码和生产代码一样重要。所有适用于生产代码的原则也适用于单元测试。这意味着它们应该以同样的努力和深思熟虑来设计和维护。如果我们不关心我们的单元测试，它们将开始出现问题并变得有缺陷（或有问题），结果就是无用的。如果发生这种情况，它们很难维护，就会成为一个负担，这会使情况变得更糟，因为人们会倾向于忽视它们或完全禁用它们。这是最糟糕的情况，因为一旦发生这种情况，整个生产代码就会受到威胁。盲目前进（没有单元测试）是一种灾难。
- en: Luckily, Python provides many tools for unit testing, both in the standard library
    and available through `pip`. They are of great help, and investing a time in configuring
    them really pays off in the long run.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Python提供了许多用于单元测试的工具，无论是在标准库中还是通过`pip`可用。它们非常有帮助，花时间配置它们确实会在长远来看得到回报。
- en: We have seen how unit tests work as the formal specification of the program,
    and the proof that a piece of software works according to the specification, and
    we also learned that when it comes to discovering new testing scenarios, there
    is always room for improvement, and that we can always create more tests. In this
    sense, expanding our unit tests with different approaches (like property-based
    testing or mutation testing) is a good investment.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到单元测试作为程序的正式规范以及软件按照规范工作的证明，我们也了解到在发现新的测试场景时，总是有改进的空间，我们总是可以创建更多的测试。在这个意义上，用不同的方法（比如基于属性的测试或变异测试）扩展我们的单元测试是一个很好的投资。
- en: References
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以参考的信息列表：
- en: The `unittest` module of the Python standard library contains comprehensive
    documentation on how to start building a test suite ([https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html))
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python标准库的`unittest`模块包含了如何开始构建测试套件的全面文档（[https://docs.python.org/3/library/unittest.html](https://docs.python.org/3/library/unittest.html)）
- en: Hypothesis official documentation ([https://hypothesis.readthedocs.io/en/latest/](https://hypothesis.readthedocs.io/en/latest/))
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hypothesis官方文档（[https://hypothesis.readthedocs.io/en/latest/](https://hypothesis.readthedocs.io/en/latest/)）
- en: '`pytest` official documentation ([https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/))'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pytest`官方文档（[https://docs.pytest.org/en/latest/](https://docs.pytest.org/en/latest/)）'
- en: '*The Cathedral and the Bazaar: Musings on Linux and Open Source by an Accidental
    Revolutionary* (*CatB*), written by Eric S. Raymond (publisher O''Reilly Media,
    1999)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《大教堂与集市：关于Linux和开源的思考》（*CatB*），作者Eric S. Raymond（出版商O'Reilly Media，1999）
