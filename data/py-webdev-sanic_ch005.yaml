- en: 4 Ingesting HTTP Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 摄入HTTP数据
- en: The next building block in application development involves **data**. Without
    data, the Web has little utility. I do not mean to get too philosophical here,
    but it is axiomatic that the purpose of the Internet is the facilitation of the
    transfer of data and knowledge from one location to another. It is therefore critical
    to our development as web professionals to learn how data can be transferred not
    just *from* our applications (which we deal with in *Chapter 5,* *Handling and
    Responding Views*), but also *to* our applications (which is the purpose of this
    chapter). The simplest applications we can build simply provide data. But to become
    interactive web applications participating in the global exchange of knowledge,
    even simple applications must be capable of extracting data from web requests.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发中的下一个构建块涉及**数据**。没有数据，Web几乎没有实用性。我并不想在这里过于哲学化，但一个公理是，互联网的目的是促进数据从一地到另一地的传输。因此，对我们作为网络专业人士的发展来说，了解数据如何从我们的应用程序（我们在*第5章*，“处理和响应用户视图”中处理）传输出去，以及如何传输到我们的应用程序（这是本章的目的）至关重要。我们可以构建的最简单的应用程序只是提供数据。但为了成为参与全球知识交流的交互式Web应用程序，即使是简单的应用程序也必须能够从Web请求中提取数据。
- en: A web application that receives no data is like a screencast. Viewers can come
    to watch the presentation, but the presenter has no *personal* connection to the
    people watching. During the COVID-19 global pandemic, I was fortunate enough to
    still be able to participate in several Python conventions. Much applause is due
    the volunteers that pushed forward to present the community with a continuation
    of the sharing and learning atmosphere that exists with technology conferences.
    However, I would be remiss to point out that as a presenter, I had zero connection
    to my audience. It was not until after the presentation was done that I even knew
    how many people watched my content.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 没有接收数据的Web应用程序就像屏幕录制。观众可以来观看演示，但演讲者与观看的人没有任何*个人*联系。在COVID-19全球大流行期间，我很幸运还能参加几个Python会议。许多掌声应归功于那些推动前进、向社区提供技术会议中存在的分享和学习氛围的志愿者。然而，我必须指出，作为一个演讲者，我甚至不知道有多少人观看了我的内容。
- en: This model can be useful to disperse information to those that need to intake
    information from it. However, the transaction is entirely one-sided. My presentations
    could not adjust based upon cues from the audience, and even during chat or Q&A
    sessions, there was an interpersonal experience that was missing. In much the
    same way, a web application that receives no data operates under a similar principal.
    The server has no knowledge about who is listening and cannot alter its behavior
    or content based upon user input. These types of applications are purely for dissemination
    of data and resources only.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模型可以用来向需要从中获取信息的人传播信息。然而，这种交易完全是单方面的。我的演示无法根据观众的线索进行调整，即使在聊天或问答环节，也缺少了人际交往的经验。同样，没有接收数据的Web应用程序在类似的原则下运行。服务器不知道谁在收听，无法根据用户输入改变其行为或内容。这类应用程序纯粹是为了传播数据和资源。
- en: Web APIs of this kind generally only have `GET` methods since they exist entirely
    to spit back information. They can be useful for relaying information about weather,
    flight details, or other centralized repositories of information that many people
    might want to access.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的Web API通常只有`GET`方法，因为它们完全是为了返回信息而存在的。它们可以用于传递有关天气、航班详情或其他许多人都可能希望访问的信息集中存储库的信息。
- en: To build a truly interactive API, we need it to operate not like a screencast,
    but more like a video chat. Both sides of the conversation will participate in
    the passing of information back and forth. And it is this bi-directional communication
    that we will explore in this chapter.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个真正交互式的API，我们需要它不像屏幕录制那样操作，而更像视频聊天。对话的双方都将参与信息的来回传递。正是这种双向通信，我们将在本章中探讨。
- en: 'If you will recall from our earlier discussions, there are three main sections
    in the raw HTTP request: **the first line**, **the HTTP headers**, and **the body**.
    So far, we have focused on intaking HTTP requests as they relate to the HTTP method
    and the path: information that both appear in that first line of the HTTP request.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得我们之前的讨论，原始HTTP请求中有三个主要部分：**第一行**、**HTTP头信息**和**正文**。到目前为止，我们一直专注于与HTTP方法和路径相关的HTTP请求的接收：这些信息都出现在HTTP请求的第一行中。
- en: 'In this chapter, we will learn about how we can get data from the client from
    all three sections. Data can be passed to a web server in query arguments, headers,
    and of course the body itself. Therefore, in this chapter we will explore:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何从客户端的所有三个部分获取数据。数据可以通过查询参数、头信息和当然还有正文本身传递给Web服务器。因此，在本章中，我们将探讨：
- en: Extracting data from cookies and headers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从cookies和头信息中提取数据
- en: Using data from query arguments, uploaded files, and JSON data
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用查询参数、上传的文件和JSON数据中的数据
- en: Validating the data is received as expected
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证接收到的数据是否符合预期
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter you should have the same tools available as in the previous
    Chapters at your disposal in order to be able to follow along with the examples
    (IDE, modern Python, and curl). You can access source code for this chapter on
    GitHub: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你应该拥有与之前章节相同的工具，以便能够跟随示例（IDE、现代Python和curl）。你可以通过GitHub访问本章的源代码：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/04)。
- en: Reading cookies and headers
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取cookies和头信息
- en: As we have seen throughout the earlier chapters of this book, when any HTTP
    client sends a request to a web server, it includes one or more headers that are
    in a key/value pair. These headers are meant to be part of a meta-conversation
    between the client and the server. And since a HTTP connection is a two-sided
    transaction with both a request and a response, we must keep in mind that there
    is a distinction between request headers and response headers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本书的前几章中看到的那样，当任何HTTP客户端向Web服务器发送请求时，它包括一个或多个键/值对形式的头信息。这些头信息旨在成为客户端和服务器之间元对话的一部分。由于HTTP连接是一个双向交易，包括请求和响应，我们必须记住请求头和响应头之间的区别。
- en: This chapter still focuses on the HTTP request only. Therefore, we will only
    be covering material as related to request headers. This is worth pointing out
    because there are some headers that are commonly found in both the request and
    the response. One such example is *Content-Type*, which can be used by both HTTP
    requests and HTTP responses. So, for example, keep in mind when we talk about
    *Content-Type* in this section, it relates to HTTP requests only. There is a time
    and a place for discussing response headers. Feel free to skip ahead, or to read
    this section in conjunction with *Chapter 5, Handling and Responding Views* where
    we will discuss the other side of the same coin.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仍然只关注HTTP请求。因此，我们只涵盖与请求头相关的材料。这一点值得指出，因为有些头信息在请求和响应中都常见。一个这样的例子是*Content-Type*，它既可用于HTTP请求，也可用于HTTP响应。所以，例如，当我们在本节中讨论*Content-Type*时，它仅与HTTP请求相关。讨论响应头的时间和地点是存在的。你可以自由地跳过，或者与*第5章，处理和响应视图*一起阅读这一节，我们将讨论同一枚硬币的另一面。
- en: Headers are flexible
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头信息是灵活的
- en: HTTP headers are not magic. There is no predefined, finite list of header names.
    Furthermore, deviating from what is considered *standard* will have no impact
    on your application. Remember back when we discussed HTTP methods, we said that
    you could invent your own methods? Well, you have that control and ability to
    create your own *headers* as well.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头信息并非魔法。不存在预定义的、有限的头名称列表。此外，偏离被认为是*标准*的内容对您的应用程序没有任何影响。记得我们之前讨论HTTP方法时，我们说你可以发明自己的方法吗？好吧，你也有这样的控制和能力来创建自己的*头信息*。
- en: 'This practice is actually encouraged and commonplace. Are you familiar with
    **Cloudflare**? In short, Cloudflare is a popular tool used as a proxy for web
    applications. We will discuss proxies further in *Chapter 8, Running a Server*.
    The idea is simple: Cloudflare runs a web server, a request comes into their server,
    they do *something* to it, and then bundle that up and send the request on to
    your server. When they do that, they include their own set of non-standard headers.
    For example, they will forward the request to you with `CF-Connection-IP` and
    `CF-IPCountry` headers to give you some helpful information about the IP address
    and the location of its origin.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法实际上是受到鼓励并且很常见的。你熟悉**Cloudflare**吗？简而言之，Cloudflare是一个流行的工具，用作Web应用的代理。我们将在*第8章，运行服务器*中进一步讨论代理。这个想法很简单：Cloudflare运行一个Web服务器，一个请求进入他们的服务器，他们对它进行一些操作，然后将请求捆绑起来并发送到你的服务器。当他们这样做时，他们会包含他们自己的一套非标准头。例如，他们将通过`CF-Connection-IP`和`CF-IPCountry`头将请求转发给你，以提供一些关于IP地址及其来源位置的有用信息。
- en: 'Let’s imagine that we are building an API to be used by a farmer’s market.
    They want to setup a web API that will help coordinate among the various participants
    in the market: farmers, restaurant owners, and consumers. The first endpoint we
    want to build will be used to provide information about the market stalls for
    a given day:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们正在构建一个用于农民市场的API。他们希望设置一个Web API，以帮助协调市场中的各种参与者：农民、餐馆老板和消费者。我们想要构建的第一个端点将用于提供有关某一天市场摊位的信息：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The response content from this endpoint does not require authentication (more
    on that later), but really ought to be tailored to each of the types of users.
    A farmer might want to know how many stalls are available. Consumers and restaurant
    owners instead might be more interested in knowing the kinds of products that
    will be available. We, therefore, have identified at least two different use cases
    for the same endpoint.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 来自此端点的响应内容不需要身份验证（关于这一点将在后面讨论），但确实应该针对每种用户类型进行定制。农民可能想知道有多少摊位可用。而消费者和餐馆老板可能更感兴趣的是了解将有哪些产品可供选择。因此，我们已经为同一端点确定了至少两种不同的使用场景。
- en: 'One option might be to split this single endpoint into two: `/stalls/<market_date:ymd>/availability`
    `/stalls/<market_date:ymd>/products`'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择可能是将这个单一端点拆分为两个：`/stalls/<market_date:ymd>/availability` 和 `/stalls/<market_date:ymd>/products`
- en: However, this does add some complexity to the overall API design. Furthermore,
    `availability` and `products` as used in this context are not really resources
    in and of themselves. To give them their own endpoint sort of muddies the water
    of the structure of our API so far.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实给整体API设计增加了一些复杂性。此外，在这个上下文中使用的`availability`和`products`并不是真正的资源。给它们自己的端点可能会弄乱我们API到目前为止的结构。
- en: What we are really saying is that we have a single resource—the collection of
    market stalls for a given day of the year—and we simply want to present those
    resources in different ways based upon the participant type. It really is only
    one endpoint with two different ways of displaying the same information.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要表达的是，我们有一个单一的资源——一年中某一天的市场摊位集合——我们只想根据参与者类型以不同的方式展示这些资源。这实际上只有一个端点，但有两种不同的方式来展示相同的信息。
- en: 'Perhaps instead of two different endpoints, a second option might be to use
    query parameters (more on those later in this Chapter in the section on *Query
    arguments*). That would look like this: `/stalls/<market_date:ymd>?participant=farmer`
    and `/stalls/<market_date:ymd>?participant=consumer`. This also sort of breaks
    the paradigm of query parameters—or at least the way I like to use them—which
    are typically meant to be used for filtering and sorting results.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的另一种选择是使用查询参数（关于这些内容将在本章的*查询参数*部分进一步讨论）。这看起来可能是这样的：`/stalls/<market_date:ymd>?participant=farmer`
    和 `/stalls/<market_date:ymd>?participant=consumer`。这也多少打破了查询参数的范式——至少是我喜欢使用它们的方式——它们通常被用来过滤和排序结果。
- en: 'Instead, we will opt for creating a custom header for our use case: `Participant-Type:
    farmer`. We will also create an Enum to help us validate and limit the acceptable
    participants:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '相反，我们将选择为我们的用例创建一个自定义头：`Participant-Type: farmer`。我们还将创建一个枚举来帮助我们验证和限制可接受的参与者：'
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: When the request comes in, the handler will try and read the header expecting
    there to be a valid `ParticipantType` object. If there is no `Participant-Type`
    header, or the passed value is an unknown type, we will simply fall back to `ParticipantType.UNKNOWN`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求到来时，处理器将尝试读取头信息，期望存在一个有效的 `ParticipantType` 对象。如果没有 `Participant-Type` 头信息，或者传递的值是一个未知类型，我们将简单地回退到
    `ParticipantType.UNKNOWN`。
- en: '**IMPORTANT NOTE**'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As you can see in this example, the `request.headers.get("participant-type")`
    is in lower case. It really does not matter. It could be upper case, lower case,
    or a mix. All headers will be read as case-insensitive keys. So, even though the
    `request.headers` object is a `dict`, it is a special kind of dictionary that
    does not care about case. It is a convention only to use lowercase letters when
    retrieving headers from Sanic. Feel free to do what makes sense to you. I would,
    however, just caution you to try and stay consistent throughout a project. It
    can be confusing if sometimes you see `headers.get("Content-Type")` and other
    times `headers.get("content-type")`.
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如您在这个示例中可以看到的，`request.headers.get("participant-type")` 是小写的。这实际上并不重要。它可以是大写、小写，或者混合使用。所有头信息都将被读取为不区分大小写的键。因此，尽管
    `request.headers` 对象是一个 `dict`，但它是一种特殊的字典，它不关心大小写。从 Sanic 获取头信息时，只使用小写字母是一种约定。请随意做您认为合理的事情。然而，我还是要提醒您，在整个项目中尽量保持一致性。如果在某些时候您看到
    `headers.get("Content-Type")`，而在其他时候看到 `headers.get("content-type")`，可能会让人感到困惑。
- en: '**TIP**'
  id: totrans-32
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Enums are great. You should really use them everywhere you can. While using
    them for validation like here may not be their most obvious use case, they are
    super helpful when needing to pass around some types of constants. Imagine needing
    to remember deep inside the bowels of your application: is it *restaurant-owner*,
    *restaurant_owner*, or *restaurant*? Using enums helps reduce bugs, provides a
    single place to maintain and update, and can provide you with code completion
    if your IDE supports it. You will see me use enums in a variety of ways in this
    book. Next to `asyncio`, the standard library `enum` package might just be one
    of my favorites.'
  id: totrans-34
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 枚举很棒。您真的应该在可能的地方都使用它们。虽然在这里使用枚举进行验证可能不是它们最明显的用例，但它们在需要传递某些类型的常量时非常有帮助。想象一下，在应用程序的深处需要记住：是
    *restaurant-owner*、*restaurant_owner* 还是 *restaurant*？使用枚举可以帮助减少错误，提供了一个单一的地方来维护和更新，如果您的
    IDE 支持，还可以提供代码补全。您将在本书中看到我以各种方式使用枚举。除了 `asyncio` 之外，标准库中的 `enum` 包可能是我最喜欢的之一。
- en: Getting back to our example, we will now try and hit our endpoint with a few
    different examples to see how it responds with different headers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的示例，我们现在将尝试使用几个不同的示例来调用我们的端点，看看它如何响应不同的头信息。
- en: 'We will access the information with a known type pretending to be a farmer:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用已知类型假装成农民来访问信息：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, we will leave out the header to see how the endpoint will respond to the
    absence of any type:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将省略头信息，看看端点将如何响应任何类型的缺失：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, we will hit the endpoint with some type we have not anticipated:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用我们没有预料到的一种类型来调用端点：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have successfully implemented a custom HTTP header that can be used by our
    endpoint to decide how it will display and customize the output. This may be getting
    ahead of ourselves since we will cover middleware in *Chapter 6, Outside the response
    cycle*, but what if we want to reuse the `Participant-Type` header on other endpoints?
    Here is a quick showcase to make this universal to our entire application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功实现了一个自定义 HTTP 头信息，我们的端点可以使用它来决定如何显示和定制输出。虽然我们将在 *第 6 章，响应周期之外* 覆盖中间件，但如果我们想在其他端点上重用
    `Participant-Type` 头信息怎么办？这里有一个快速展示，使整个应用程序都能使用这个功能。
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By evaluating the header inside middleware, we can now place `participant_type`
    on the request object for easy access.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在中间件中评估头信息，我们现在可以将 `participant_type` 放在请求对象上，以便于访问。
- en: 'The last thing that I would like to point out about this development example
    is the mindset towards testability. Notice how we identified three different potential
    uses of the endpoint: a known type, a lack of a type, and an unknown type. We
    will talk about testing in *Chapter 9*, *Best practices to improve your web applications*.
    As we continue working through this book, however, it is good to be reminded not
    only of how to work with Sanic, but the types of things we should be thinking
    about when we uncover a problem. Thinking ahead about how the application could
    be used helped us understand the types of use cases we might want to test for,
    and therefore the types of use cases that our application needs to handle.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想指出关于这个开发示例的最后一个要点是关于可测试性的心态。注意我们如何确定了端点的三种不同潜在用途：已知类型、缺少类型和未知类型。我们将在*第9章，最佳实践以改进你的Web应用程序*中讨论测试。然而，当我们继续阅读这本书时，提醒自己不仅要了解如何使用Sanic，还要在发现问题时我们应该思考的类型。提前考虑应用程序的用途有助于我们理解我们可能想要测试的类型，因此也理解我们的应用程序需要处理的使用案例。
- en: '**TIP**'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It is also worth pointing out that the `request.ctx` object is there for you
    to attach any information you want to it. This is really powerful to help pass
    information around and to abstract some logic to middleware as shown above. Keep
    in mind that this lasts only as long as the request lasts. After there is a response,
    anything on that `request.ctx` will be disposed of. There is also similar context
    for the entire lifespan of the application, and the lifespan of a single client
    connection. These are respectively: `app.ctx` and `request.conn_info.ctx`. Please
    see *Chapter 6, Outside the response cycle* for more information on these `ctx`
    objects.'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有一点值得指出的是，`request.ctx`对象可供你附加任何你想要的信息。这真的很强大，可以帮助传递信息，并将一些逻辑抽象为中间件，如上所示。请记住，这仅持续到请求结束。一旦有响应，`request.ctx`上的任何内容都将被销毁。对于整个应用程序的生命周期和单个客户端连接的生命周期，也存在类似的环境。这些分别是：`app.ctx`和`request.conn_info.ctx`。请参阅*第6章，响应周期之外*以获取有关这些`ctx`对象的更多信息。
- en: Even though it is entirely possible to create your own set of headers—and indeed,
    I highly encourage it—there does exist a set of common headers that are standard
    among clients and servers. In the next sections, we will explore what some of
    those are.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然完全可以创建自己的头信息集——实际上，我强烈鼓励这样做——但确实存在一套在客户端和服务器之间标准化的常见头信息。在接下来的几节中，我们将探讨其中的一些内容。
- en: Common headers
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 常见头信息
- en: There is a set of predefined standard headers in RFC 2731, section 5\. [https://datatracker.ietf.org/doc/html/rfc7231#section-5](https://datatracker.ietf.org/doc/html/rfc7231#section-5).
    If you are so inclined, put the book down and go read that section. We’ll be waiting
    for you. If not, let’s try and pull out some highlights and some of the more important
    request headers that you should probably know about.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在RFC 2731的第5节中有一组预定义的标准头信息。[https://datatracker.ietf.org/doc/html/rfc7231#section-5](https://datatracker.ietf.org/doc/html/rfc7231#section-5)。如果你有兴趣，放下这本书去阅读那一节。我们会等你回来。如果没有，让我们尝试提取一些亮点和一些你可能需要了解的重要请求头信息。
- en: Authentication headers
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 认证头
- en: 'One of the primary mechanisms for authenticating web requests is through the
    use of headers. The other basic method is with cookies (which is technically also
    a header, but more on that later in the *Getting information from cookies (yum!)*
    section.) While there are certainly different types of authentication schemes
    (basic auth, JWT, and session tokens to name a few), they generally share the
    same construct: the use of the Authorization header.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 验证Web请求的主要机制之一是通过使用头信息。另一种基本方法是使用cookies（技术上讲，cookies也是一种头信息，但关于这一点将在*从cookies获取信息（yum!）*部分中进一步说明。）虽然确实存在不同类型的认证方案（基本认证、JWT和会话令牌等），但它们通常具有相同的结构：使用授权头。
- en: You may have just noticed something peculiar. We are talking about *authentication*,
    at least, that’s what the title of this section is called. But, we just said that
    the primary *authentication* header is called *Authorization*. How can this be?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能刚刚注意到了一些奇怪的地方。我们在谈论*认证*，至少，这是本节标题的名称。但是，我们刚才说主要的*认证*头信息被称为*授权*。这怎么可能呢？
- en: 'We will cover more details about this in *Chapter 7, Dealing with Security
    Concerns* when we discuss access control more thoroughly, but it is worth mentioning
    the distinction, and the fundamental questions that these two related concepts
    are trying to answer:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更深入地讨论访问控制时，我们将在*第7章，处理安全关注点*中详细介绍这方面的更多细节，但提到这种区别以及这两个相关概念试图回答的基本问题是很值得的：
- en: '**Authentication**: Do I know who this person is?'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：我认识这个人吗？'
- en: '**Authorization**: Should I let them in?'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：我应该让他们进入吗？'
- en: A failure to authenticate results in a *401 Unauthorized* error message and
    a failure of authorization is a *403 Forbidden* error message. It is an unfortunate
    quirk of the history of the Internet that these terms are befuddled, and that
    they developed as they did. They are confusing and inconsistent.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 认证失败会导致*401未授权*错误消息，而授权失败则是一个*403禁止*错误消息。遗憾的是，互联网的历史中存在一个怪癖，这些术语被混淆了，并且它们以这种方式发展起来。它们是令人困惑且不一致的。
- en: 'So, even though the header is called *Authorization*, and even though its failure
    should lead to an *Unauthorized* response, we are still exclusively talking about
    authentication and answering the question: *Do I know who this person is?*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管标题被称为*授权*，并且尽管其失败应该导致*未授权*响应，但我们仍然在专门讨论认证并回答问题：*我认识这个人吗？*
- en: 'Because Sanic does not take a stance about how you should build your application,
    we obviously have a lot of freedom in choosing how we want to consume the *Authorization*
    request header. Three main strategies come to mind here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Sanic没有关于您应该如何构建应用程序的立场，我们显然在如何选择消费*授权*请求头方面有很大的自由。以下有三种主要策略：
- en: '**Decorators**'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**'
- en: '**Middleware**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件**'
- en: '**Blueprints**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图**'
- en: 'Let’s look at these individually:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一看看这些：
- en: Decorators
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 装饰器
- en: 'Let’s first look at an example using decorators:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过一个装饰器的例子来看一下：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The core of this example is the inner `decorated_function`. This basically
    is saying: before running our actual handler (which is `f`), run `check_authentication`.
    This allows us the opportunity to execute code inside *the route* but before we
    get to the actual defined handler.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中的核心是内部的`decorated_function`。这基本上是在说：在我们实际的处理程序（即`f`）运行之前，先运行`check_authentication`。这让我们有机会在*路由*中执行代码，但在我们到达实际定义的处理程序之前。
- en: 'This decorator pattern is extremely common in Sanic. Not only for running checks,
    but also to inject arguments into our handler. If you are not using some form
    of decorators in your application, you are leaving some real power on the table.
    It is a useful way to duplicate logic across endpoints, and I highly recommend
    you get familiar and comfortable with using them. There is a very helpful starter
    example that can be found in the Sanic User guide: [https://sanicframework.org/en/guide/best-practices/decorators.html](https://sanicframework.org/en/guide/best-practices/decorators.html).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种装饰器模式在Sanic中非常常见。不仅用于运行检查，还用于将参数注入我们的处理程序。如果您在应用程序中没有使用某种形式的装饰器，您就放弃了真正的力量。这是一种在端点之间复制逻辑的有用方式，我强烈建议您熟悉并习惯使用它们。在Sanic用户指南中可以找到一个非常有帮助的入门示例：[https://sanicframework.org/en/guide/best-practices/decorators.html](https://sanicframework.org/en/guide/best-practices/decorators.html)。
- en: '**TIP**'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notice the `handler=None` and the last return line?
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意到`handler=None`和最后一行返回吗？
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: def `authenticated(handler=None):`
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: def `authenticated(handler=None):`
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`...`'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`...`'
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**return** `decorator(handler)` **if** `handler` **else** `decorator`'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**返回** `decorator(handler)` **如果** `handler` **否则** `decorator`'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The reason we do this is because we are allowing for our decorator to be used
    in one of two ways: either via `@authenticated` or `@authenticated()`. You will
    have to decide which one (or whether both) is appropriate for your needs.'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们这样做的原因是我们允许我们的装饰器以两种方式之一使用：要么通过`@authenticated`，要么通过`@authenticated()`。您必须决定哪一种（或是否两者都）适合您的需求。
- en: Middleware
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 中间件
- en: 'Now that we have seen how this works with decorators, how can we achieve the
    same logic with middleware? In the next example, we will try and achieve the same
    functionality that the decorator example provided, except using middleware:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了装饰器是如何工作的，我们如何使用中间件实现相同的逻辑呢？在下一个例子中，我们将尝试实现装饰器示例提供的相同功能，但使用中间件：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The downside of this method is that we just now locked up our *entire* API!
    What about our `/stalls/<market_date:ymd>` endpoint, or even endpoints that are
    meant for logging in? One way to fix this is to check if the request has a matched
    `Route` instance (it should, unless we are responding to a *404 Not Found*), and
    if it does, make sure it is not one of the exempt routes. We can see an example
    of how to do that here by cross-referencing the name of the matched route with
    an express list of exempt endpoints:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，我们刚刚锁定了我们的*整个*API！我们的`/stalls/<market_date:ymd>`端点怎么办，或者甚至是用于登录的端点？一种修复方法是检查请求是否有匹配的`Route`实例（它应该有，除非我们正在响应*404
    Not Found*），如果有，确保它不是豁免路由之一。我们可以在下面通过交叉引用匹配路由的名称与一个明确的豁免端点列表来查看如何做到这一点：
- en: '[PRE8]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This time, in the middleware we are taking a look at the route’s name to see
    if it is one of the routes that we know should be safe.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在中间件中，我们查看路由的名称，看看它是否是我们知道应该安全的路由之一。
- en: '**IMPORTANT NOTE**'
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As a quick aside—since we have not seen it before—all routes will have a *name*.
    You can of course name them manually:'
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为一个简短的补充——因为我们之前没有见过——所有的路由都将有一个*名称*。当然，您可以手动命名它们：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: More likely than not, we can just let Sanic name our routes. It will by default
    use the handler function’s name, and then append it to our application name (and
    any blueprints) with dot notation. That is why we see `MyApp.login` and `MyApp.market_stalls`.
    They are presuming our application is called `MyApp`, and the handlers for our
    exempt endpoints are `login` and `market_stalls`, respectively.
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 很可能，我们只需让Sanic为我们命名路由。它将默认使用处理函数的名称，然后使用点符号将其附加到我们的应用程序名称（以及任何蓝图）上。这就是为什么我们看到`MyApp.login`和`MyApp.market_stalls`。它们假设我们的应用程序名为`MyApp`，我们豁免端点的处理函数分别是`login`和`market_stalls`。
- en: '*“Hang on a minute?! You want me to keep a list of names of exempt endpoints?
    That sounds like a nightmare to maintain!”* True. If you are handling only two
    items like this simple use case, it is probably manageable enough. But once we
    start really building out an application, this might start to get super unwieldy.
    Feel free to decide which of the two patterns makes more sense. Using decorators
    is much more explicit and clear. However, it does lead to more code repetition.
    The middleware alternative is much simpler to implement, and easier to audit to
    make sure that we are not forgetting to protect any routes. Its downside, however,
    is that it hides some functionality and would be harder to maintain if the list
    of *safe* endpoints grows. If you are in doubt about which makes sense for your
    needs, I would suggest the more explicit authentication decorators. This does,
    however, show that there usually are different ways to tackle the same problems.
    Coming back to the point of *Chapter 1*, *Introduction to Sanic and async frameworks*,
    if one of these solutions seems more *obviously* correct, then that likely is
    the one that you should use.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*“等等？！你想要我保持豁免端点名称的列表？这听起来像是一场噩梦，难以维护！”* 真的。如果您只处理像这种简单用例的两个项目，这可能足够管理。但一旦我们真正开始构建应用程序，这可能会变得非常难以控制。请随意决定哪种模式更有意义。使用装饰器更加明确和清晰。然而，它会导致更多的代码重复。中间件替代方案更容易实现，并且更容易审计以确保我们没有忘记保护任何路由。然而，它的缺点是，它隐藏了一些功能，如果安全端点的列表增长，维护起来会更困难。如果您对哪种适合您的需求有疑问，我建议使用更明确的认证装饰器。然而，这确实表明通常有不同解决相同问题的方法。回到*第一章*，*Sanic和异步框架的介绍*，如果这些解决方案中的一个看起来更*明显*正确，那么这很可能是您应该使用的方案。'
- en: Blueprints
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 蓝图
- en: 'And this is where our third solution comes in: our friend Blueprints again.
    This time, we are going to continue using middleware, but we are only going to
    apply the middleware to Blueprints that contain the protected endpoints.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的第三个解决方案出现的地方：我们的朋友蓝图再次出现。这次，我们将继续使用中间件，但我们只将中间件应用于包含受保护端点的蓝图。
- en: '[PRE10]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since we are placing the middleware on the `“protected” Blueprint`, it will
    only run on the routes that are attached to it. This leaves everything else open.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将中间件放置在`“protected” Blueprint`上，它将只在该蓝图附加的路由上运行。这留下了其他所有内容都是开放的。
- en: Context headers
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文头信息
- en: These headers provide you with some information about the web browser where
    the request originated. Generally, they are useful in analytics and logging to
    provide some information about how your application is being used. We will examine
    some of the more common contextual headers.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标题为您提供了有关请求来源的网页浏览器的某些信息。通常，它们在分析和日志记录中非常有用，可以提供有关您的应用程序如何被使用的某些信息。我们将检查一些更常见的上下文标题。
- en: '**Referer** This header contains the name of the page that directed the user
    to the current request. It is really helpful if you want to know from which page
    on your application an API request came from. If your API is not meant to be used
    by a browser, perhaps it is less important. Yes, it is misspelled. The Internet
    is not perfect. And now for a bit of trivia knowledge: RFC 1945 was published
    in 1996 as a specification of the HTTP/1.0 protocol. The team that published it
    included none other than Tim Berners-Lee (aka, the inventor of the World Wide
    Web). Section 10.13 introduced the `Referer` header, but it was inadvertently
    misspelled in the specification! Subsequent specifications and implementations
    have adopted this misspelling, and it has stuck with us for almost 30 years. If
    nothing else, it is a certain warning about the use of spell check. [https://datatracker.ietf.org/doc/html/rfc1945#section-10.13](https://datatracker.ietf.org/doc/html/rfc1945#section-10.13)'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用者** 这个标题包含将用户引导到当前请求的页面的名称。如果您想知道API请求是从您的应用程序的哪个页面发起的，这将非常有帮助。如果您的API不是为浏览器设计的，这可能就不那么重要了。是的，它拼写错误了。互联网并不完美。现在，让我们来一点趣闻知识：RFC
    1945于1996年作为HTTP/1.0协议的规范发布。发布它的团队中包括了蒂姆·伯纳斯-李（即万维网的发明者）。第10.13节介绍了`Referer`标题，但在规范中不小心拼错了！随后的规范和实现都采用了这个拼写错误，并且它已经伴随着我们近30年了。如果不是其他的话，这确实是对使用拼写检查器的一个警告。[https://datatracker.ietf.org/doc/html/rfc1945#section-10.13](https://datatracker.ietf.org/doc/html/rfc1945#section-10.13)'
- en: '**Origin** This header is similar to `Referer`. While the `Referer` will generally
    include the full path of where the request originated, the `Origin` header is
    just the URL usually in the form: `<scheme>://<hostname>:<port>` without the path.
    We will look into how we can use it to protect our application from CORS attacks
    in *Chapter 7*, *Dealing with Security Concerns*.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**来源** 这个标题与`Referer`类似。虽然`Referer`通常会包括请求来源的完整路径，但`Origin`标题只是URL，通常形式为`<scheme>://<hostname>:<port>`，不包含路径。我们将在*第7章*，*处理安全关注点*中探讨我们如何使用它来保护我们的应用程序免受CORS攻击。'
- en: '**User-Agent** This header is almost always sent by every HTTP client. It identifies
    the type of application that is accessing your API. Commonly it is a browser,
    but it could also be `curl`, a Python library, or a tool like Postman or Insomnia.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户代理** 这个标题几乎总是由每个HTTP客户端发送。它标识了访问您的API的应用程序类型。通常它是一个浏览器，但也可能是`curl`、Python库或Postman或Insomnia等工具。'
- en: '**Host** Back in *Chapter 3*, *Routing and Intaking HTTP Requests* we saw how
    we could do host-based routing with *virtual hosts*. This is accomplished by reading
    the `Host` header. While `Origin` is the domain where the request is coming from,
    `Host` is where it is going to. Usually, we know this information ahead of time.
    Except, sometimes we have either a dynamic host (like a wildcard subdomain), or
    multiple domain pointing to one application.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主机** 在*第3章*，*路由和接收HTTP请求*中，我们看到了如何使用*虚拟主机*进行基于主机的路由。这是通过读取`Host`标题来实现的。虽然`Origin`是请求来源的域名，但`Host`是它将要到达的地方。通常，我们事先就知道这些信息。但是，有时我们可能有一个动态主机（如通配符子域名），或者多个域名指向一个应用程序。'
- en: '**Forwarded headers** This encompasses both `Forwarded` and a bunch of `X-Forwarded-*
    headers`. Generally, when you see a header that starts with `X-` it means that
    it is a header that has come into common practice and usage, but its implementation
    is not necessarily standard.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**转发标题** 这包括`Forwarded`和许多以`X-Forwarded-*`开头的标题。通常，当你看到一个以`X-`开头的标题时，这意味着它已经成为常见的实践和使用的标题，但其实现并不一定是标准的。'
- en: What are these headers? They contain details about the web request and are used
    by the intermediary proxies (like Nginx or Cloudflare) to pass along relevant
    details about the request. The most common is `X-Forwarded-For`. This is a list
    of all of the IP addresses from the originating request to the current server
    that handled the request (this is not the same as a traceroute). This is incredibly
    helpful and important when trying to identify a request by IP address.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这些头部是什么？它们包含有关 Web 请求的详细信息，并由中间代理（如 Nginx 或 Cloudflare）传递有关请求的相关详细信息。最常见的是 `X-Forwarded-For`。这是一个从原始请求到当前处理请求的服务器的所有
    IP 地址列表（这与 tracert 不同）。这在尝试通过 IP 地址识别请求时非常有用且非常重要。
- en: '**IMPORTANT NOTE**'
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As with *all* headers and input data, you should *NEVER* assume that incoming
    user data is accurate and harmless. It is very simple for someone to spoof headers.
    Just as always, we need to be cautious when reading headers and not just take
    them at face value.
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与 *所有* 头部和输入数据一样，您绝对不应该假设传入的用户数据是准确和无害的。有人伪造头部非常简单。就像始终一样，我们在读取头部时需要谨慎，而不仅仅是接受它们字面上的意思。
- en: Sanic extracts some header data for us
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sanic 为我们提取一些头部数据
- en: Sanic will automatically extract some information about the request from headers
    and place them on easily accessible attributes on the `Request` object. It makes
    them very helpful to get when needed. Below is a reference for some of the common
    attributes you might encounter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 会自动从头部提取有关请求的信息，并将它们放置在 `Request` 对象上易于访问的属性中。这使得它们在需要时非常有用。以下是您可能会遇到的一些常见属性的参考。
- en: '| **Request Property** | **HTTP Header used to generate** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **请求属性** | **用于生成 HTTP 头部的属性** |'
- en: '| `request.accept` | Accept |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `request.accept` | 接受 |'
- en: '| `request.forwarded` | Forwarded |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `request.forwarded` | 转发 |'
- en: '| `request.host` | Host |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `request.host` | 主机 |'
- en: '| `request.id` | X-Request-ID (can be configured |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `request.id` | X-Request-ID（可以配置） |'
- en: '| `request.remote_addr` | Forwarded, or X-Forwarded-For (depends upon more
    configuration covered in *Chapter 11* , *A Complete Real-World Example* ) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `request.remote_addr` | 转发，或 X-Forwarded-For（取决于第 11 章 *完整真实世界示例* 中涵盖的更多配置）
    |'
- en: '| `request.token` | Authorization |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `request.token` | 授权 |'
- en: Table 4.1 - Extracted header data
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 - 提取的头部数据
- en: '**TIP**'
  id: totrans-118
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-119
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It sometimes may be confusing to know when to use `request.ip` and when to use
    `request.remote_addr`. The former property will always be set and will always
    return the IP address of the client that is connecting to it. This might not actually
    be what you want. If your application is behind a proxy server, and you need to
    rely upon `X-Forwarded-For`, then most likely the attribute you want is `request.remote_addr`.
  id: totrans-120
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有时可能难以确定何时使用 `request.ip` 和何时使用 `request.remote_addr`。前者属性始终会被设置，并且始终返回连接到它的客户端的
    IP 地址。这可能并不是你想要的。如果你的应用程序位于代理服务器后面，并且你需要依赖于 `X-Forwarded-For`，那么你想要的属性很可能是 `request.remote_addr`。
- en: Headers as multi-dict
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 头部作为多字典
- en: 'Headers are stored in Sanic as a multi-dict. This is a special data type that
    will operate both as a one-to-one key-to-value dictionary, and a one-to-many key-to-value
    dictionary. To illustrate the point, here are what those would typically look
    like:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 头部在 Sanic 中以多字典的形式存储。这是一种特殊的数据类型，它将同时作为一对一键值字典和一对多键值字典操作。为了说明这一点，以下是它们通常看起来像什么：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Header object in Sanic functions as both of those simultaneously. Moreover,
    it looks at the keys as case insensitive. Did you notice in the last example that
    the keys are different cases? Using standard dictionaries, the following would
    be False.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 中的 Header 对象同时充当这两个角色。此外，它将键视为不区分大小写。你注意到在最后一个例子中键的大小写不同吗？使用标准字典，以下将是
    False。
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: However, because the HTTP specification allows for HTTP headers to be case-insensitive,
    the Sanic `Header` object is also case-insensitive. But how does it handle the
    issue between one-to-one and one-to-many?
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 HTTP 规范允许 HTTP 头部不区分大小写，Sanic 的 `Header` 对象也不区分大小写。但它如何处理一对一和多对一的问题？
- en: Again, the HTTP specification allows for multiple identical headers to be concatenated
    without overriding one another. Sanic opts for this special data type to be standards
    compliant. If you do nothing special and merely treat the `Header` object as a
    regular Python `dict` in your application, it will work just fine. You might not
    ever even notice that it is not a regular dictionary. However, you will only ever
    access the first value passed to it for each header. If you need to support multiple
    values for the same header, you are able to access the full *list* of values.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，HTTP规范允许将多个相同的头信息连接起来，而不会相互覆盖。Sanic选择这种特殊的数据类型以确保符合标准。如果你不做任何特殊处理，只是将`Header`对象当作一个普通的Python
    `dict`在你的应用程序中使用，它将正常工作。你可能甚至永远不会注意到它不是一个普通的字典。然而，你将只能访问每个头信息传递给它的第一个值。如果你需要支持相同头信息的多个值，你可以访问所有值的完整`列表`。
- en: 'Consider the following example:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例：
- en: '[PRE13]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s now hit this endpoint with multiple `Fruit` headers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们用多个`Fruit`头信息来访问这个端点。
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using either square brackets or `.get()` method provides us with `apples` because
    that was the first `Fruit` header that was sent. A more explicit usage would be
    to use `.getone()`. Alternatively, we can use `.getall()` to return the full list
    of `Fruit` header values. Again, case does *not* matter for header keys. For values,
    however, it does. Notice how in our example `Fruit` became `fruit`, but `Bananas`
    did not change case at all.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方括号或`.get()`方法可以提供`apples`，因为这是第一个发送的`Fruit`头信息。更明确的使用方法是使用`.getone()`。或者，我们可以使用`.getall()`来返回完整的`Fruit`头信息值列表。再次强调，对于头键，大小写**不**重要。然而，对于值，大小写是重要的。注意在我们的示例中`Fruit`变成了`fruit`，但`Bananas`的大小写完全没有改变。
- en: Getting information from cookies (yum!)
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从饼干中获取信息（美味！）
- en: Building a web application without cookies is like ending a meal without cookies.
    Sure, it could be done. But why would you want to? Given a choice, pick the cookies.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 建立一个没有饼干的Web应用程序就像没有饼干的餐后一样。当然，这是可以做到的。但为什么你要这样做呢？如果可以选择，请选择饼干。
- en: Jokes aside, cookies are obviously an extremely important topic to consider.
    They are the backbone of many of the rich user experiences of web applications.
    Cookies also are inherently full of potential security pitfalls. The security
    issues are generally more of a concern when we talk about setting cookies (*Chapter
    5*, *Handling and Responding Views*), and securing our web applications (*Chapter
    7*, *Dealing with Security Concerns*). Here, we are mainly interested in how to
    access cookies so that we can read the data from them.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑，饼干显然是一个需要考虑的极其重要的话题。它们是许多丰富的Web应用程序用户体验的支柱。饼干本身也充满了潜在的安全陷阱。当我们谈论设置饼干（*第五章，处理和响应视图*）以及保护我们的Web应用程序（*第七章，处理安全关注*）时，安全问题通常更为关注。在这里，我们主要感兴趣的是如何访问饼干，以便我们可以从中读取数据。
- en: 'A web cookie is a specialized HTTP header: `Cookie`. This header contains a
    structured set of data defined by RFC 6265, § 5.4\. [https://tools.ietf.org/html/rfc6265#section-5.4](https://tools.ietf.org/html/rfc6265#section-5.4).
    The incoming cookie from a request is treated in Sanic like a regular dictionary.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Web饼干是一个特殊的HTTP头信息：`Cookie`。这个头信息包含由RFC 6265，§ 5.4定义的结构化数据集。[https://tools.ietf.org/html/rfc6265#section-5.4](https://tools.ietf.org/html/rfc6265#section-5.4)。来自请求的传入饼干在Sanic中被当作一个普通的字典处理。
- en: In order to get an explicit look at how cookies are structured, setup a debug
    handler like this
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了更明确地了解饼干的结构，设置一个像这样的调试处理程序
- en: '[PRE15]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we will send some cookies using curl:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用curl发送一些饼干：
- en: '[PRE16]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, the data is just a simple key/value dictionary. Accessing cookies
    should therefore be very straightforward. Like other forms of data, it is, of
    course, advisable to treat them with suspect. These values are not immune to tampering
    and can easily be spoofed. Nonetheless, they are an important part of the web,
    especially if your application needs to support a frontend UI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，数据只是一个简单的键/值字典。因此，访问饼干应该非常直接。像其他形式的数据一样，当然建议对这些数据进行怀疑处理。这些值并非不可篡改，并且很容易被伪造。尽管如此，它们是网络的重要组成部分，特别是如果你的应用程序需要支持前端UI。
- en: While using cookies will be an invaluable source of data for your applications,
    the primary method for users to pass information will come in other forms. Next
    up, we look at those other methods for passing data from web client to web server.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用饼干将成为你应用程序中数据的一个无价来源，但用户传递信息的主要方法将来自其他形式。接下来，我们将探讨从Web客户端到Web服务器的其他数据传递方法。
- en: Reading forms, query arguments, files, JSON, and more
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取表单、查询参数、文件、JSON等
- en: 'Now that we know about pulling input from the path and from the headers, we
    will turn our attention to more classic types of passing input values. Typically,
    we think of request data as being those bits of information that come from the
    request body. Before we turn to the request body, however, we still have one more
    item in the first line of the HTTP request to examine: **Query arguments**.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了从路径和头部获取输入的方法，我们将把注意力转向更多经典类型的传递输入值。通常，我们认为请求数据是从请求体中来的那些信息片段。在我们转向请求体之前，HTTP请求的第一行还有一个项目需要检查：**查询参数**。
- en: Query arguments
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询参数
- en: 'As a reminder, the first line of a HTTP request looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，HTTP请求的第一行看起来是这样的：
- en: '[PRE17]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you have previous web experience, you may know that a URL can have a section
    of arbitrary parameters separated from the rest of the path by a question mark
    (`?`). These are known as query arguments (or parameters), follow in the form
    `key=value`, and are concatenated with an ampersand (`&`). Sometimes they are
    called parameters, sometimes arguments. We will call them arguments here, since
    this is what Sanic opts for to be able to distinguish them from path parameters.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有过网络经验，你可能知道URL可以有一个由问号(`?`)与路径的其余部分分开的任意参数部分。这些被称为查询参数（或参数），以`key=value`的形式连接，并用与号(`&`)连接。有时它们被称为参数，有时称为参数。在这里，我们将称它们为参数，因为这是Sanic选择的方法，以便能够将它们与路径参数区分开来。
- en: 'Query arguments are very simple to use, and we can get access to them on our
    request instance:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 查询参数非常简单易用，我们可以在我们的请求实例中访问它们：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**IMPORTANT INFO**'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要信息**'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'You may have noticed my `curl` command included `\?` instead of just `?`. This
    is a necessary pattern in some command line applications since `?` itself could
    have a different meaning. It just as well could have been wrapped in quotes: `curl
    "localhost:7777?fruit=apples"`, but I prefer to leave off the quotes and opt for
    the character escaping.'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能已经注意到我的`curl`命令中包含了`\?`而不是仅仅`?`。在某些命令行应用程序中，这是一个必要的模式，因为`?`本身可能有不同的含义。它也可以用引号括起来：`curl
    "localhost:7777?fruit=apples"`，但我更喜欢去掉引号，选择字符转义。
- en: Usage seems simple enough, right? Well, not so fast. The obvious next question
    is what happens when the key is repeated? Or, what happens when we want to past
    an array of data?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用看起来很简单，对吧？嗯，等等。接下来的明显问题是当键重复时会发生什么？或者，当我们想要传递一个数据数组时会发生什么？
- en: 'There is *no* single standard way to pass array data on the Internet inside
    query arguments. Several methods do exist:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网上通过查询参数传递数组数据并没有一种单一的标准方法。存在几种方法：
- en: '`?fruit[]=apples&fruit[]=bananas`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?fruit[]=apples&fruit[]=bananas`'
- en: '`?fruit=apples,bananas`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?fruit=apples,bananas`'
- en: '`?fruit=[apples,bananas]`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?fruit=[apples,bananas]`'
- en: '`?fruit=apples&fruit=bananas`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?fruit=apples&fruit=bananas`'
- en: The first three approaches were rejected by Sanic, which has instead opted to
    implement the fourth option. A quick look at the three rejected models will explain
    why the chosen model makes sense, and how we can use it going forward.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic 最初拒绝了前三种方法，而是选择了第四种方案。快速浏览一下这三种被拒绝的模型，可以解释为什么选择这种模型是有道理的，以及我们如何继续使用它。
- en: First, `fruit[]` is a strange construct that is not obvious to newcomers, and
    actually is a hijacking and alteration of the key. Yuck, no thank you.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`fruit[]`是一个对新手来说不太明显的结构，实际上是对键的劫持和修改。呃，不，谢谢。
- en: Second, `fruit=apples,bananas` seems nice, but what if we wanted to just pass
    a string `apples,bananas` and not actually separate them? Hmm, this does not seem
    possible. Pass.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，`fruit=apples,bananas`看起来不错，但如果我们只想传递一个字符串`apples,bananas`而不真正分开它们怎么办？嗯，这似乎是不可能的。传递。
- en: Third, `fruit=[apples,bananas]` seems better, but it is again somewhat awkward
    and not intuitive. It also suffers the same ambiguity problem. Is `apples,bananas`
    a single string, or two items?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 第三，`fruit=[apples,bananas]`看起来更好，但仍然有些尴尬且不直观。它也面临着相同的歧义问题。`apples,bananas`是一个字符串，还是两个项目？
- en: Furthermore, the second and third options suffer another problem about how to
    handle duplicate keys. Take the first? The last? Merge? Error? Again, there is
    no consensus and different servers handle this differently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，第二种和第三种方案还面临如何处理重复键的问题。选择第一个？最后一个？合并？错误？再次，没有共识，不同的服务器处理方式不同。
- en: 'The most reasonable approach seems to be the fourth, which can handle all of
    these problems. Keep it simple: we have a key and a value. Nothing more. If there
    are duplicate keys, we treat it as a list append. There are no surprising losses
    of data, no errors, and data integrity is maintained.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最合理的方法似乎是第四种，它可以处理所有这些问题。保持简单：我们有一个键和一个值。没有更多。如果有重复的键，我们将其视为列表追加。没有数据丢失的惊喜，没有错误，数据完整性得到保持。
- en: 'In our last example, we printed to the console the value of `request.args`.
    Here is the output:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最后的例子中，我们打印了 `request.args` 的值。这里是输出：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Wait?! A `list`? I thought it was a single value: `apples`. At least that is
    what the response gave us. Query arguments are a special dictionary that contains
    lists, but has a unique `.get()` that will fetch only the first value from that
    list. If you want all of the elements, use `.getlist().`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 等等？！一个 `list`？我以为它是一个单一值：“`apples`”。至少响应是这样的。查询参数是一个特殊的字典，它包含列表，但有一个独特的 `.get()`，它将只从该列表中获取第一个值。如果你想获取所有元素，请使用
    `.getlist().`
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When we hit this endpoint now, we can see what these values are:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在访问这个端点时，我们可以看到这些值：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another point worth mentioning is that `request.args` is not the only way to
    look at these key/value pairs. We also have `request.query_args`, which is just
    a list of tuples of all the pairs that were passed. The above request would look
    something like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点是，`request.args` 并不是查看这些键/值对的唯一方式。我们还有 `request.query_args`，它只是所有传递的键值对的元组列表。上面的请求看起来可能像这样：
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A data structure such as this can, of course, easily be turned into a standard
    dictionary if desired. Just be careful because you will lose out on duplicate
    key data; being left only with the last of each duplicated key:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的数据结构当然可以很容易地转换成标准的字典，如果需要的话。但请小心，因为你会丢失重复键的数据；只剩下每个重复键的最后一个：
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Forms and files
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 表单和文件
- en: By learning how we can pull data from the query arguments, we have inadvertently
    also learned how to get both form data and uploaded file data! That is because
    query arguments, forms, and files all operate identically. To prove it, we will
    setup a couple of endpoints like we have before and see what happens.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过学习如何从查询参数中提取数据，我们无意中也就学会了如何获取表单数据和上传的文件数据！这是因为查询参数、表单和文件都操作相同。为了证明这一点，我们将设置几个端点，就像之前做的那样，看看会发生什么。
- en: '[PRE24]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Next, we will test the form handler.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将测试表单处理器。
- en: '[PRE25]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Just like before, we see that it looks like a dict with a list. Well, that’s
    because it is. But it will still behave like request.args. We can use .get() for
    a the first item, and .getlist() for all of them in a list.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们看到它看起来像是一个带有列表的字典。嗯，那是因为它就是这样。但它仍然会像 `request.args` 一样表现。我们可以使用 `.get()`
    来获取第一个项目，对于列表中的所有项目，我们可以使用 `.getlist()`。
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: And, of course, we will see the same result with files.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也会看到相同的结果。
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We might want to take a closer look at this one to see what it is doing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想更仔细地看看这个，看看它在做什么。
- en: 'When you upload a file to Sanic, it will convert that into a File object. The
    `File` object is really just a namedtuple containing the basic information about
    the file. If we do a `print(request.files.get("po"))`, we should see an object
    that looks like this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将文件上传到 Sanic 时，它将将其转换为 File 对象。`File` 对象实际上只是一个包含有关文件的基本信息的 `namedtuple`。如果我们执行
    `print(request.files.get("po"))`，我们应该看到一个看起来像这样的对象：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**TIP**'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Are you unfamiliar with namedtuples? They are a really great tool for modelling
    concise objects. I highly recommend using them since they behave as tuples, but
    have the convenience of having dot notation to access specific properties. They
    are great in place of dictionaries, as long as you do not need to modify their
    contents. This is why Sanic uses them here as file objects. It is a convenient
    small structure that is easy for us as developers to work with, while keeping
    some safety around the data so that it is not accidentally corrupted.
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你不熟悉 `namedtuple` 吗？它们是建模简洁对象的一个非常好的工具。我强烈推荐使用它们，因为它们的行为就像元组一样，但具有使用点符号访问特定属性的便利性。只要不需要修改它们的内容，它们就可以作为字典的替代品。这就是为什么
    Sanic 在这里使用它们作为文件对象的原因。它是一个方便的小结构，我们作为开发者很容易与之合作，同时保持数据的一些安全性，以免意外损坏。
- en: Consuming JSON data
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费 JSON 数据
- en: Arguably the most important type of request data is JSON. Modern web applications
    have embraced and clung to serializing and transmitting data with JSON because
    of its simplicity. It supports basic types of scalar values, is easy for humans
    to read, and easy to implement and widely supported in many programming languages.
    It is no wonder that it is the default methodology.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 争议性地，最重要的请求数据类型是 JSON。现代网络应用因为其简单性而拥抱并坚持使用 JSON 来序列化和传输数据。它支持基本类型的标量值，对人类来说易于阅读，易于实现，并且在许多编程语言中得到广泛支持。难怪它是默认的方法。
- en: 'It should therefore come as no surprise that Sanic makes it very easy:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Sanic 使之变得非常容易：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We have now seen all of the typical ways to access data in a single request.
    Next up, we will learn about how data could alternatively be streamed to Sanic
    in multiple chunks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了在单个请求中访问数据的所有典型方式。接下来，我们将学习如何将数据以多个块的形式流式传输到 Sanic。
- en: Getting streaming data
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取流式数据
- en: The term **streaming** has become somewhat of a buzzword. Many people even outside
    the tech industry use it all the time. The word—and more specifically the actual
    technological concept that it represents—has become an important part of society
    as consumption of media content continues its march to the cloud. What exactly
    is streaming? For those that are not entirely clear what this term means, we will
    take a brief moment to understand it before moving on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: “流式”这个词已经成为一个有点儿时髦的术语。许多人在技术行业之外也经常使用它。这个词——以及它所代表的实际技术概念——随着媒体内容消费持续向云端迁移，已经成为社会的一个重要组成部分。那么，流式究竟是什么？对于那些对这个词的含义不完全清楚的人来说，我们将在继续前进之前简要地了解一下它。
- en: 'Streaming is the act of sending data in multiple, consecutive chunks from one
    side of an open connection to the other. One of the core foundations of the HTTP
    model is that there is a request followed by a response after a connection is
    established between the client and server. The client sends a complete HTTP request
    message and then waits for the server to send back a complete HTTP response message.
    It looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 流式是指从连接的一侧向另一侧发送多个连续的数据块。HTTP 模型的核心基础之一是，在客户端和服务器之间建立连接后，会有一个请求，然后是响应。客户端发送一个完整的
    HTTP 请求消息，然后等待服务器发送一个完整的 HTTP 响应消息。它看起来是这样的：
- en: '![Figure 4.1 - Normal HTTP request/response cycle](img/file1.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 - 正常的 HTTP 请求/响应周期](img/file1.png)'
- en: Figure 4.1 - Normal HTTP request/response cycle
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 - 正常的 HTTP 请求/响应周期
- en: I like to think of these as *finite* transactions. Both the request and the
    response have a definite and known endpoint. These finite requests are what we
    have been looking at up until now. A request comes in, the server does something
    to process it, and a response goes out. What is important to note is that both
    the request and the response are sent in whole in a single block.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢把它们看作是*有限*的交易。请求和响应都有一个明确且已知的终点。这些有限的请求就是我们迄今为止一直在关注的。一个请求到来，服务器对其进行处理，然后发送一个响应。需要注意的是，请求和响应都是作为一个整体在一个单独的块中发送的。
- en: 'One header that we did not discuss earlier is the `Content-Length` header.
    This header can be found on both requests and responses. The actual specification
    on when it *should* be sent versus when it *must* be sent is really beyond the
    scope of this discussion. Sanic will take care of providing this for us when necessary.
    I bring it up here because this header is exactly what it purports to be: the
    length of the content in a HTTP message. This tells the recipient that there is
    a message of a certain length that is being transmitted. And, it is important
    here because the known length of a message cannot necessarily be computed when
    the request headers are sent.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有讨论的一个头信息是 `Content-Length` 头信息。这个头信息可以在请求和响应中找到。关于何时*应该*发送以及何时*必须*发送的实际规范超出了本次讨论的范围。当需要时，Sanic
    会为我们处理这个问题。我提到它是因为这个头信息正是它所声称的那样：HTTP 消息中内容的长度。这告诉接收方正在传输一个特定长度的消息。而且，在这里它很重要，因为当请求头信息发送时，消息的已知长度不一定能被计算出来。
- en: 'What happens if there is a large amount of data to be sent that might overwhelm
    a single connection, or the data being sent is not 100% available when the connection
    opens? Streaming is a methodology for one side of the connection to tell the other
    that it is transmitting some bytes, but it is not yet done. The connection should
    be held open so that more data can be sent. The way that this interaction happens
    is by replacing the `Content-Length` header with a `Transfer-Encoding: chunked`
    header. This is the way that one side of the connection can tell the other that
    it should continue to receive data until notified that the stream of data is closed.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '如果有大量数据需要发送，可能会超过单个连接的承载能力，或者当连接打开时发送的数据不是100%可用，会发生什么情况？流式传输是一种方法，连接的一侧通知另一侧它正在传输一些字节，但尚未完成。应该保持连接打开，以便发送更多数据。这种交互发生的方式是通过用`Transfer-Encoding:
    chunked`头替换`Content-Length`头。这是连接的一侧通知另一侧它应该继续接收数据，直到收到数据流关闭通知的方式。'
- en: When most laypeople hear the term *streaming*, the immediate thought goes to
    streaming media, like movies or music. They might describe the concept as the
    consumption of the media before it is fully downloaded. And, this is correct.
    Streaming is the sending of data in multiple *chunks* instead of sending it all
    at once. This is extremely efficient and can reduce overall resource overhead.
    When supported, it allows the receiving side to start processing that data if
    it desires instead of blocking and waiting for it to be complete. So, when you
    go to watch your favorite movie, you can start watching it without waiting for
    the entire file to be downloaded.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当大多数非专业人士听到“流式传输”这个词时，他们首先想到的是流式媒体，如电影或音乐。他们可能会将这个概念描述为在完全下载之前消费媒体。这是正确的。流式传输是将数据分成多个
    *块* 发送，而不是一次性发送。这非常高效，可以减少整体资源开销。如果支持，它允许接收方在需要时开始处理这些数据，而不是阻塞并等待其完成。所以，当你去看你最喜欢的电影时，你可以在整个文件下载完毕之前开始观看。
- en: 'Streaming does not, however, only apply to media, and also is not only done
    by a server. There are two basic flavors we are concerned about: request streaming
    and response streaming. Here is what those flows look like:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，流式传输不仅适用于媒体，而且不仅由服务器执行。我们关注两种基本类型：请求流式传输和响应流式传输。以下是这些流程的示例：
- en: '![Figure 4.2 - HTTP streaming request](img/file2.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 - HTTP 流式请求](img/file2.png)'
- en: Figure 4.2 - HTTP streaming request
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 - HTTP 流式请求
- en: In *Figure 4.2,* we see what a streaming request looks like. Once the HTTP connection
    is opened, the client starts sending data. But, it does not send the message all
    at once. Instead, it breaks the message up into chunks, sending each chunk of
    bytes on its own.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 4.2* 中，我们看到流式请求的样子。一旦 HTTP 连接打开，客户端开始发送数据。但是，它不会一次性发送消息。相反，它将消息分成块，单独发送每个字节的块。
- en: '![Figure 4.3 - HTTP streaming response](img/file3.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3 - HTTP 流式响应](img/file3.png)'
- en: Figure 4.3 - HTTP streaming response
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 - HTTP 流式响应
- en: The streaming response in *Figure 4.3* is basically the reverse of the streaming
    request. The request is sent in its entirety, but the server decides to send the
    response in chunks until it is complete. When someone talks about streaming media,
    they are referring to the response stream. We will look more at this option in
    *Chapter 5*, *Handling and Responding Views* when we talk about different types
    of responses.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.3* 中的流式响应基本上是流式请求的相反。请求是完整发送的，但服务器决定分块发送响应，直到完成。当人们谈论流式媒体时，他们指的是响应流。我们将在
    *第 5 章*，*处理和响应视图* 中更详细地探讨这个选项，当我们讨论不同类型的响应时。'
- en: We currently are concerned with learning about request streaming as depicted
    in *Figure 4.2*. It should definitely be noted that between the two, this is by
    far the lesser utilized feature. When you search for *streaming HTTP* on the internet,
    you are likely to find less information on it. Nonetheless, it can be a powerful
    tool in the right situation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前关注的是学习 *图 4.2* 中展示的请求流式传输。必须明确指出，在这两者之间，这无疑是使用较少的功能。当你在网上搜索 *流式 HTTP* 时，你可能会找到关于它的信息较少。尽管如此，在正确的情况下，它仍然是一个强大的工具。
- en: 'So, first we will ask, when should we think about using request streaming?
    One potential use case is if a client wants to *warm up* the HTTP connection.
    Let’s say you are building a stock trading platform. Latency between the frontend
    UI and the backend server is critically important. The difference in milliseconds
    having potential financial impacts. Your task is to get the data from the frontend
    as fast as possible. The solution is to initiate the `POST` request as soon as
    the user clicks on the input box. Simultaneously, the frontend UI opens the HTTP
    connection with a `Transfer-Encoding: chunked` header signaling that more data
    is coming. So, while the user is typing their values, we have already performed
    the operations and suffered any overhead that is related to the opening of a connection.
    The server now is on alert waiting for data to come as soon as the user hits the
    *Enter* button.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '那么，首先我们要问，何时应该考虑使用请求流？一个潜在的使用场景是如果客户端想要*预热*HTTP连接。假设你正在构建一个股票交易平台。前端UI和后端服务器之间的延迟至关重要。毫秒级的差异可能对金融产生影响。你的任务是尽可能快地从前端获取数据。解决方案是在用户点击输入框时立即发起`POST`请求。同时，前端UI通过带有`Transfer-Encoding:
    chunked`头的HTTP连接打开，表示还有更多数据要来。因此，当用户输入值时，我们已执行操作并承受了与打开连接相关的任何开销。现在服务器处于警觉状态，等待用户按下*Enter*键后立即接收数据。'
- en: What might this endpoint look like?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个端点可能看起来是什么样子？
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Let’s point out a few important parts one at a time.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一次指出几个重要的部分。
- en: 'We need to tell Sanic that we are going to be streaming the response here.
    There are two options: passing `stream=True` in the route definition, or using
    the `@stream` decorator. They work the same, so it is more a matter of personal
    choice.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要告诉Sanic我们将在这里进行响应流。有两种选择：在路由定义中传递`stream=True`，或使用`@stream`装饰器。它们的工作方式相同，所以这更多是一个个人选择的问题。
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There should be some sort of a loop that continues to read from the stream until
    it is complete. How do we know it is complete? There will be an empty read from
    the stream. If you skip the `if body is None` line, you could end up crashing
    your server as it gets stuck in an infinite loop.The data when read is a `bytes`
    string, so you may want to convert that to a regular `str` as we do here.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该有一个某种循环，继续从流中读取，直到它完成。我们如何知道它已经完成？将会有一个从流中读取空数据的情况。如果你跳过了`if body is None`行，你的服务器可能会陷入无限循环。当读取数据时，它是一个`bytes`字符串，所以你可能想将其转换为常规的`str`，就像我们在这里做的那样。
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It is important to note that in this example, we are reading the body completely
    down before continuing on with processing the request. Another alternative might
    be to take those bytes and write them to something else that can consume and act
    upon them immediately. In just a moment we will see an example that does this.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要的是要注意，在这个例子中，我们在继续处理请求之前完全读取了主体。另一种选择可能是将这些字节写入可以立即消费并对其采取行动的其他东西。我们很快就会看到一个这样的例子。
- en: You need to decode the body yourself. On regular requests, if you send JSON
    data, Sanic will decode it for you. But here, all we have are the raw bytes (converted
    to a string). If we need further processing, we should do it ourselves. We use
    `ujson.loads` in our example, which ships with Sanic as a speedy way to convert
    the JSON to a Python `dict`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要自己解码主体。在常规请求中，如果你发送JSON数据，Sanic会为你解码。但在这里，我们只有原始字节（转换为字符串）。如果我们需要进一步处理，我们应该自己处理。在我们的例子中，我们使用`ujson.loads`，这是Sanic附带的一个快速将JSON转换为Python
    `dict`的方法。
- en: Our example works because we are expecting a single *delayed* input from the
    client. The other important place you might use this is with file uploads. If
    you are expecting large file uploads, you may want to start reading and writing
    the bytes as soon as they are received.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的例子之所以有效，是因为我们预期客户端会发送单个*延迟*输入。你可能还会在其他地方使用这种方法，比如文件上传。如果你预期会有大文件上传，你可能希望一收到字节就立即开始读取和写入。
- en: 'The following is an example to do that:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We should notice that the loop here looks very similar to the last one. The
    concept is the same: loop until there is nothing left to read. The difference
    is that instead of writing the data to a local variable, we are using the `aiofiles`
    library to asynchronously write bytes to the file.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意到这里的循环看起来与上一个非常相似。概念是相同的：循环直到没有更多内容可读。区别在于，我们不是将数据写入局部变量，而是使用`aiofiles`库异步地将字节写入文件。
- en: Why would you want to do this? The biggest reason would be efficiency and memory
    utilization. If you use the regular `request.files` accessor to read file data,
    then you are effectively reading the entire contents before doing anything with
    them. This could be a lot of memory usage if there are large files at play. By
    reading and writing in chunks, we keep the buffers small.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您为什么要这样做呢？最大的原因可能是效率和内存利用。如果您使用常规的`request.files`访问器来读取文件数据，那么您实际上在处理它们之前会读取整个内容。如果涉及大文件，这可能会导致大量的内存使用。通过分块读取和写入，我们保持缓冲区的大小。
- en: 'This chapter has focused entirely upon different methods of reading data. We
    know we can access it from the body, files, form data, streams, and query arguments.
    All of these mechanisms on their own lack one critical component: validation.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章完全专注于读取数据的不同方法。我们知道我们可以从正文、文件、表单数据、流和查询参数中访问它。所有这些机制本身都缺少一个关键组件：验证。
- en: Validating data
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据验证
- en: What we are about to get into next is the first glimpse of security related
    topics in this book. We cover some more concepts later in *Chapter 7*, *Dealing
    with Security Concerns*. This is, however, not a security book. There is unfortunately
    too much material to be able cover it all in this book. There are too many risks
    and too many potential mitigation measures for our one chapter dedicated to security.
    We will, therefore, instead touch upon the concepts in general for those that
    are unfamiliar, and then show some ways to combat the issue in Sanic.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们要探讨的是本书中关于安全相关主题的第一部分。我们将在*第7章*，*处理安全关注点*中介绍更多概念。然而，这并不是一本关于安全的书。不幸的是，内容太多，无法在这本书中全部涵盖。针对安全这一章节，风险和潜在的缓解措施太多。因此，我们将针对那些不熟悉这些概念的人进行一般性讨论，然后展示一些在Sanic中解决该问题的方法。
- en: The first of those topics is data validation. If you have been around the web,
    then you know what I am saying and the *why* is obvious to you. You are concerned
    with SQL injection attacks, or XSS attacks. You know the potential threats posed
    by blindly accepting data and acting upon it. I trust that you already know this
    is a big no-no, and are here to learn *how* to implement standard practices in
    Sanic. If the concept of data validation is completely foreign to you, I suggest
    you spend some time searching other online materials about the security issues
    posed by attacks like those mentioned above.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题中的第一个是数据验证。如果您在网络上有所涉猎，那么您就知道我在说什么，原因对您来说也很明显。您担心SQL注入攻击或XSS攻击。您知道盲目接受数据并据此采取行动可能带来的潜在威胁。我相信您已经知道这是绝对不允许的，并且您来这里是为了学习如何在Sanic中实施标准实践。如果您对数据验证的概念完全陌生，我建议您花些时间搜索其他在线材料，了解上述攻击带来的安全问题。
- en: 'Web API security is not a singular approach. Data validation is only a small
    part of a much larger plan that you will need to protect your application, resources,
    and users. Our focus in this section will primarily be upon the most common scenario
    in modern web applications: making sure that JSON data conforms to expectations.
    These techniques alone will not make your application secure from attacks. See
    *Chapter 7*, *Dealing with Security Concerns* for more on this. Our goal here
    is much more modest: when we expect a number, we get a number, when expect a UUID,
    we get a UUID.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Web API安全不是单一的方法。数据验证只是保护您的应用程序、资源和用户所需更大计划的一部分。本节的重点将主要放在现代Web应用程序中最常见的场景上：确保JSON数据符合预期。仅这些技术本身并不能使您的应用程序免受攻击。有关更多信息，请参阅*第7章*，*处理安全关注点*。我们的目标更为谦逊：当我们期望一个数字时，我们得到一个数字；当我们期望一个UUID时，我们得到一个UUID。
- en: If you recall in *Chapter 3*, *Routing and Intaking HTTP Requests*, we actually
    had our first brush with data validation. We were trying to make sure that the
    data received was one of a known list of ice cream flavors. We are going to expand
    this concept here. There are *many* libraries out there that do this for us. Some
    popular choices include marshmallow, attrs, and pydantic. Before we try and leverage
    an existing package, we are going to try to build our own validation library using
    Python’s dataclasses.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得*第3章*，*路由和接收HTTP请求*，我们实际上第一次接触到了数据验证。我们试图确保接收到的数据是已知冰淇淋口味列表中的一个。我们将在这里扩展这个概念。现在有很多库可以为我们完成这项工作。一些流行的选择包括marshmallow、attrs和pydantic。在我们尝试利用现有的包之前，我们将尝试使用Python的数据类构建自己的验证库。
- en: 'It is good to remember why we are doing this. Sanic, as we know, tries hard
    to not make decisions for developers. Data validation is one of the most critical
    components of an application, and it can vary wildly from one use case to the
    next. Therefore, the core Sanic project does not have a single method for doing
    this and leaves the choice to you: the developer. Of course, there are a number
    of plugins out there that add validation, but we are going to take a crack at
    building one ourselves that will fit our needs. Ultimately, I hope this inspires
    some ideas in your own projects for you to take principles and apply them to your
    own unique situations. This next section will deviate from Sanic, and is more
    about Python programming in general. Ultimately, however, I think it is illustrative
    to see how Sanic tries to get out of your way to allow you to implement your own
    solutions and business logic, and only involve itself where needed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们为什么要这样做是很好的。正如我们所知，Sanic努力不替开发者做决定。数据验证是应用程序中最关键的部分之一，它可以从一个用例到另一个用例有很大的变化。因此，Sanic核心项目没有为这一行为提供单一的方法，而是将选择权留给了你：开发者。当然，市面上有许多插件可以添加验证，但我们将尝试自己构建一个符合我们需求的插件。最终，我希望这能激发你自己在项目中的灵感，将原则应用到你自己独特的情境中。接下来的这一部分将偏离Sanic，更多地关于Python编程的一般性。然而，最终我认为看到Sanic如何试图为你让路，让你实现自己的解决方案和业务逻辑，并且只在需要时介入，是有启发性的。
- en: With that said, let’s get started.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们开始吧。
- en: 'Step one: getting started and making a decorator'
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第一步：开始并创建一个装饰器
- en: 'The first thing we need to do is create a framework that we are going to work
    in. To accomplish our goals, we are going to rely heavily upon decorators. This
    is a fantastic approach because it lets us create per route definitions, but also
    easily repeat our logic across the application as needed. What we are after is
    something that looks like this:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个我们将要工作的框架。为了实现我们的目标，我们将严重依赖装饰器。这是一个绝佳的方法，因为它让我们可以创建针对每个路由的定义，但也可以根据需要轻松地在整个应用程序中重复我们的逻辑。我们追求的是类似以下这样的东西：
- en: '[PRE34]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This looks like a super clean interface. What will this achieve?
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个看起来界面非常干净。这将实现什么？
- en: 'No repetition: Rather than explicitly telling the `validate` function what
    to do, we are going to use some Python tricks to read `body: BookStallBody` from
    the handler signature.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '不重复：而不是明确告诉`validate`函数要做什么，我们将使用一些Python技巧从处理器签名中读取`body: BookStallBody`。'
- en: 'Dependency injection: Out `validate` function will need to inject a `body`
    argument. This means that we should have a clean data structure with exactly the
    information that we want and cast as the types of data we expect them to be. If
    something is missing, it should raise an exception and cause a failure response.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入：我们的`validate`函数将需要注入一个`body`参数。这意味着我们应该有一个干净的数据结构，其中包含我们想要的确切信息，并将其转换为预期的数据类型。如果缺少某些信息，应该抛出异常并导致失败响应。
- en: 'Type annotations: By annotating the `body` argument, we will have helpful features
    from `mypy` and our IDE to make sure our code is clean, consistent, and bug-free.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型注解：通过注解`body`参数，我们将从`mypy`和我们的IDE中获得有用的功能，以确保我们的代码干净、一致且无错误。
- en: 'To begin, we want to make a decorator that will be capable of being callable,
    or not callable. This will give us both `@validate` and `@validate()`, which will
    make our experience more flexible and easier as we expand our usage. We already
    saw an example of this earlier in *Chapter 3*, *Routing and Intaking HTTP Requests*.
    Let’s see what the minimal decorator looks like:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要创建一个既可以调用也可以不调用的装饰器。这将使我们既能使用`@validate`也能使用`@validate()`，这将使我们的体验更加灵活，更容易随着我们使用范围的扩大而扩展。我们之前在*第三章*，*路由和接收HTTP请求*中已经看到了一个例子。让我们看看最小化装饰器的样子：
- en: '[PRE35]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: With this in place, we have a minimally viable decorator. Obviously, it does
    not do anything useful yet, but we can begin to build our validation logic off
    of this.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一来，我们就有一个最小可行的装饰器。显然，它目前还没有做任何有用的事情，但我们可以从这个基础上开始构建我们的验证逻辑。
- en: 'Step two: reading the handler signature'
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第二步：阅读处理器签名
- en: 'The next thing we want to do is determine which parts of the request we want
    to validate. We are going to start off with the JSON body. In our target implementation,
    we want to control this with the handler signature. We do, however, have an alternative
    approach. We could try for this for example:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要确定我们想要验证请求的哪些部分。我们将从JSON体开始。在我们的目标实现中，我们希望通过处理器签名来控制这一点。然而，我们有一个替代方案。例如，我们可以尝试这样做：
- en: '[PRE36]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Arguably, this is a *much* easier decorator to build. In this version, we are
    explicitly telling the `validate` function that we want it to look in the request
    body and validate against a model called `BookStallBody`. But, if we also want
    type annotations, we end up with duplicated code since we need to put the model
    in a typed function argument. We are not going to let the difficulty scare us
    away! After all, we know this decorator will be used all over our application.
    Building a better version up front will help us down the road as we reuse and
    expand the implementation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不可否认，这是一个**更简单**的装饰器来构建。在这个版本中，我们明确告诉`validate`函数，我们希望它在请求体中查找并验证一个名为`BookStallBody`的模型。但是，如果我们还想使用类型注解，由于我们需要将模型放入类型化函数参数中，我们最终会得到重复的代码。我们不会让困难吓倒我们！毕竟，我们知道这个装饰器将在我们的整个应用程序中到处使用。提前构建一个更好的版本将有助于我们在重用和扩展实现时走得更远。
- en: So, how do we get the model and the location information? We are going to use
    Python’s `typing` module that comes with the standard library. We need to be very
    careful here. When dealing with decorators, we need to remember there are different
    layers that get executed at different times. Since we are evaluating the handler,
    we only want to do this *once*. If we set this up wrong, we might end up executing
    the setup code on *every single request*! We will try to avoid that.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何获取模型和位置信息呢？我们将使用Python标准库中的`typing`模块。在这里，我们需要非常小心。在处理装饰器时，我们需要记住，有不同层次的代码在不同的时间执行。由于我们正在评估处理器，我们只想这样做**一次**。如果我们设置错误，我们可能会在**每个请求**上执行设置代码！我们将尽力避免这种情况。
- en: 'Here is where we are at now:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们到了这里：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We inspect the handler and loop over the parameters that are defined inside
    of it. If there is a parameter that is called `body`, then we grab its annotation
    and save it for later use.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查处理器，遍历其中定义的参数。如果有一个名为`body`的参数，我们就获取它的注解并保存以供以后使用。
- en: 'One potential downside to this approach is we are boxing ourselves in by *only*
    allowing our validations to be on a parameter called `body`. What if we had a
    URL that needed to be: `/path/to/<body>`? Or, we just plain want to call the variable
    something else? Let’s make the decorator slightly more flexible.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的潜在缺点之一是我们通过**只**允许我们的验证在名为`body`的参数上进行，把自己局限住了。如果我们有一个需要这样的URL：`/path/to/<body>`，或者我们只是想给变量起一个不同的名字呢？让我们让这个装饰器稍微灵活一些。
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: There, by moving the name of the body argument to `body_arg`, we have the flexibility
    to rename it if we want to.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将body参数的名称移动到`body_arg`，我们就有灵活性在需要时重命名它。
- en: 'Step three: modeling'
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第三步：建模
- en: The next critical piece is our model. This could be a place where we add in
    a pre-built library; for example, one of the packages mentioned earlier. I, of
    course, suggest you take a look at them. There are many devoted contributors that
    have spent a lot of time building, testing, and supporting these packages that
    will cover far more use cases than our simple example. But, since we are still
    learning here, we will continue on building our own validation logic on top of
    dataclasses.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个关键部分是我们的模型。这可能是一个添加预构建库的地方；例如，前面提到的包之一。我当然建议你看看它们。有许多贡献者投入了大量时间构建、测试和支持这些包，它们将覆盖比我们的简单示例多得多的用例。但是，由于我们还在学习，我们将继续在dataclasses之上构建自己的验证逻辑。
- en: Let’s create a basic payload that we might expect on our endpoint.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的有效负载，这是我们可能在端点上期望的。
- en: '[PRE39]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Okay, so there is not too much new here. We are defining some models using Python’s
    dataclasses. I encourage you to go look them up if you are unfamiliar with them.
    In brief, they are type-annotated data structures that will be super easy for
    us to work with. One problem with them is that the type annotations are *not*
    enforced at runtime. Even though we say that `BookStallBody.vendor_id` is a `UUID`,
    Python will happily inject a boolean or any other kind of value there. This is
    where the `ValidatorModel` comes in. We are going to add some simple logic to
    the `dataclass` to make sure it is populating with the correct data type.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这里没有太多新内容。我们正在使用Python的dataclasses定义一些模型。如果你不熟悉它们，我鼓励你去查找它们。简而言之，它们是带有类型注解的数据结构，我们将很容易与之合作。它们的一个问题是类型注解在运行时**不**被强制执行。尽管我们说`BookStallBody.vendor_id`是一个`UUID`，Python仍然会愉快地注入布尔值或其他类型的值。这就是`ValidatorModel`发挥作用的地方。我们将向`dataclass`添加一些简单的逻辑，以确保它使用正确的数据类型填充。
- en: 'Another nice trick added to this simple structure is that we are defining `ProductType`
    as an `Enum`. By defining `_generate_next_value_,` we are forcing the values of
    each enum to be a lowercase string value of the key. As an example:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的结构中添加的一个很好的技巧是，我们将`ProductType`定义为`Enum`。通过定义`_generate_next_value_`，我们强制每个枚举的值都是键的小写字符串值。例如：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**TIP**'
  id: totrans-264
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Whenever your application is dealing with an ID of any kind, you should try
    and avoid passing it the sequential ID record from your database. Many common
    databases increment the row number every time you insert a record. If your API
    relies upon that ID, you are inadvertently broadcasting information about the
    state of your application to the world. Stick with UUIDs or some other form that
    will add some obscurity for client facing applications. Do not let your database
    IDs leave your server.
  id: totrans-266
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当你的应用程序处理任何类型的ID时，你应该尽量避免从数据库传递序列ID记录。许多常见的数据库在插入记录时都会增加行号。如果你的API依赖于这个ID，你无意中向世界广播了关于应用程序状态的信息。坚持使用UUID或其他形式，这将为客户面向的应用程序增加一些神秘感。不要让你的数据库ID离开你的服务器。
- en: 'Step four: model hydration'
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第四步：模型初始化
- en: 'Ultimately, we want to be able to send a JSON request to our endpoint that
    looks like this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，我们希望能够向我们的端点发送一个看起来像这样的JSON请求：
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Therefore, our goal is to turn this nested structure into Python objects. Dataclasses
    can get us part of the way there. What is missing is the specific type-casting,
    and nesting. This is what our `ValidatorModel` class will provide for us:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的目标是把这个嵌套结构转换成Python对象。数据类可以帮我们走一段路。缺少的是具体的类型转换和嵌套。这正是我们的`ValidatorModel`类将为我们提供的：
- en: '[PRE42]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'It may look like a lot going on here, but it is really quite simple. After
    a model instance is created, we loop through all of its fields. There are really
    now two options: either the field annotation is another dataclass, or it’s something
    else. If it is something else, then we just want to make sure that we cast it
    to the new type.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能有很多事情要做，但实际上非常简单。在创建了一个模型实例之后，我们遍历它的所有字段。实际上现在有两种选择：要么字段注解是另一个数据类，要么它是其他东西。如果是其他东西，那么我们只想确保将其转换为新的类型。
- en: If we are dealing with a dataclass, then we have two more options we need to
    determine. Either it is a single item or a list of items. If it is a list, then
    we simply need to make sure we loop over all values and try to hydrate each individual
    item.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在处理一个数据类，那么我们还有两个选项需要确定。要么它是一个单独的项目，要么是一个项目的列表。如果是列表，那么我们只需确保我们遍历所有值并尝试为每个单独的项目进行初始化。
- en: Admittedly, this will not cover all use cases. But since we are creating our
    own solution, we only care that it covers the cases we need, and that it is relatively
    simple to maintain if we need to add more complexity in the future.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 承认，这不会涵盖所有用例。但既然我们正在创建自己的解决方案，我们只关心它是否涵盖了我们需要的情况，并且如果未来需要添加更多复杂性，它是否相对简单易维护。
- en: This solution will do that for us.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案会为我们做到这一点。
- en: 'Step five: performing validations'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 第五步：执行验证
- en: Now that our models are capable of handling nested logic and converting all
    of our values to their desired types, we need to hook it back up to our decorator.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们模型能够处理嵌套逻辑并将所有值转换为所需的类型，我们需要将其重新连接到我们的装饰器上。
- en: 'Here is where we stand now:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们所处的位置：
- en: '[PRE43]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The important changes are these lines:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的更改如下：
- en: '[PRE44]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This will convert our raw JSON request data into usable (and well annotated)
    data structures. If there is a failure on a data type, an exception should be
    raised. So, what would that look like?
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将我们的原始JSON请求数据转换为可用的（并且注释良好的）数据结构。如果数据类型失败，应抛出异常。那么，那会是什么样子呢？
- en: '[PRE45]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: If our dataclass models cannot cast a value into the expected type, then it
    should raise a `ValueError` or a `TypeError`. We want to catch either one of them
    and convert it into our own `ValidationError` for two reason. First, by subclassing
    `SanicException`, we can give the exception a `status_code` and when that exception
    is raised, Sanic will automatically know to return a `400` response. *Chapter
    9*, *Best Practices to Improve your Web Applications* discusses more about exception
    handling, which is another important consideration. For now, just know that Sanic
    will give us some exception handling out of the box in both debug, and regular
    mode.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的数据类模型无法将值转换为预期的类型，那么它应该引发一个`ValueError`或`TypeError`。我们希望捕获这两个中的一个，并将其转换为我们的`ValidationError`，原因有两个。首先，通过从`SanicException`派生，我们可以给异常一个`status_code`，当这个异常被引发时，Sanic将自动知道返回一个`400`响应。*第9章*，*提高你的Web应用程序的最佳实践*讨论了更多关于异常处理的内容，这是另一个重要的考虑因素。现在，只需知道Sanic在调试和常规模式下都会为我们提供一些异常处理。
- en: Taking it to the next level with third-party packages
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用第三方包将问题提升到下一个层次
- en: The input validation from the last section was admittedly a bit thin. It works
    well for our very limited use cases, but lacks some of the richness that can be
    achieved from a proper package. If your projects in the future require some customized
    validation logic, then, by all means use what was started to launch your project.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个部分中的输入验证确实有点薄弱。它对我们的非常有限的使用案例工作得很好，但缺乏从合适的包中实现的一些丰富性。如果你的未来项目需要一些定制的验证逻辑，那么，无论如何，使用启动你的项目所开始的内容。
- en: We are, however, going to switch our mode here. Instead of using plain vanilla
    dataclasses and our custom `ValidatorModel`, we are going to use a third-party
    package. We will keep the rest of what we built, so we are not entirely grabbing
    an off-the-shelf solution.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们在这里将改变模式。我们不会使用普通的vanilla数据类和我们的自定义`ValidatorModel`，而是将使用第三方包。我们将保留我们构建的大部分内容，所以我们并不是完全采用现成的解决方案。
- en: Let’s see what it would be like if we used Pydantic.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们使用Pydantic会是什么样子。
- en: Validation with Pydantic
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用Pydantic进行验证
- en: Pydantic is a popular package for creating models in Python. It generally plays
    very nicely with type annotations, and even has a drop-in replacement for dataclasses.
    Therefore, we can take our previous example, change the `dataclass` import line,
    and remove `ValidatorModel` and we upgraded our capabilities!
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic是一个流行的Python创建模型包。它通常与类型注解配合得很好，甚至有dataclasses的即插即用替代品。因此，我们可以使用之前的示例，更改`dataclass`导入行，并移除`ValidatorModel`，我们就提升了我们的能力！
- en: 'We change our models to use the `Pydantic dataclass`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将我们的模型更改为使用`Pydantic数据类`：
- en: '[PRE46]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Remove the `ValidatorModel`, since it is no longer needed.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除`ValidatorModel`，因为它不再需要。
- en: '[PRE47]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The only other change is to make sure that `do_validation` will raise the appropriate
    error message (more on exception handling in *Chapter 6*, *Outside the Response
    Cycle*)
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的另一个改变是确保`do_validation`将引发适当的错误消息（更多关于异常处理的内容请参阅*第6章*，*响应周期之外*）
- en: '[PRE48]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: It is an almost identical solution. Please take a look at the full example in
    the GitHub repository. We now have the full power of a proper library to handle
    much more complicated validation logic. Perhaps we should build out our decorator
    just a bit more to handle other types of input validation.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这几乎是一个相同的解决方案。请查看GitHub仓库中的完整示例。我们现在有了处理更复杂验证逻辑的完整库的力量。也许我们应该稍微扩展我们的装饰器，以处理其他类型的输入验证。
- en: First a model for what our expected query parameters will look like.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是一个模型，展示我们预期的查询参数将如何看起来。
- en: '[PRE49]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we extend the decorator to handle both body and query parameters:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将装饰器扩展以处理正文和查询参数：
- en: '[PRE50]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this example, instead of only looking for the body argument, we are also
    looking for query. The implementation between them looks remarkably similar. We
    can now reuse our decorator in other situations:'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不仅寻找正文参数，还寻找查询参数。它们之间的实现看起来非常相似。我们现在可以在其他情况下重用我们的装饰器：
- en: '[PRE51]'
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now it is time for a little experiment. We started off by validating against
    the request JSON. This was validated and injected as the `body` argument. We then
    saw that it was super easy to extend this to `query` arguments with the query
    argument. Your challenge now is to put the book down and see if you can make a
    similar implementation for both regular forms and for file upload validation.
    Take a look at the approaches here, and also reference the `request.files` and
    `request.form` objects we talked about earlier in the book.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进行一个小实验的时候了。我们首先验证了请求JSON。这被验证并作为`body`参数注入。然后我们看到扩展到`query`参数非常简单。你现在的挑战是放下这本书，看看你是否可以为常规表单和文件上传验证做出类似的实现。看看这里的方法，并参考我们在书中早些时候提到的`request.files`和`request.form`对象。
- en: Summary
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: It is a fairly safe assumption that all web APIs need some input from users
    at some point. Even APIs that are read-only often might allow for filtering, searching,
    or paginating data. Therefore, to become proficient at building web applications
    in general, and Sanic applicaitons specifically, you must learn the data tools
    at your disposal.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 可以相当安全地假设所有Web API在某个时候都需要从用户那里获取一些输入。即使是只读API，也常常可能允许过滤、搜索或分页数据。因此，要成为构建Web应用程序的专家，特别是Sanic应用程序的专家，你必须学会使用你手中的数据工具。
- en: In this chapter, we covered a great deal of material. We learned about how to
    pull data from headers, cookies, and the request body. When using headers, form
    data, query arguments, and file data, we saw that these objects could operate
    as regular dictionaries, or dictionaries of lists to be both compliant with HTTP
    standards and also usable for most regular use cases. We also saw that the request
    body itself could be sent as a single chunk, or in multiple chunks.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。我们学习了如何从头部、cookie和请求体中提取数据。当使用头部、表单数据、查询参数和文件数据时，我们发现这些对象可以作为常规字典操作，或者作为列表的字典，以符合HTTP标准，同时也适用于大多数常规用例。我们还看到请求体本身可以作为一个单独的数据块发送，也可以分多个数据块发送。
- en: However, perhaps the biggest takeaway is that reading data cannot and does not
    take a single path. As a reminder, Sanic provides the tools to build the most
    obvious solution for your needs. Whereas many other projects could fill a similar
    discussion with the minutiae of how to implement form data retrieval in their
    specific API, much of our focus was on how to build solutions *with* Sanic, not
    *from* Sanic. It is a framework that tries not to get in the way.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能最大的收获是读取数据不能，也不应该只走一条路径。提醒一下，Sanic提供了构建最明显解决方案的工具。与其他许多项目可能会用如何在其特定API中实现表单数据检索的细节来填充类似的讨论不同，我们的大部分重点是如何与Sanic一起构建解决方案，而不是从Sanic中构建。这是一个试图不阻碍的框架。
- en: For example, we saw that it was super simple to add both custom and off-the-shelf
    validation logic. Sanic did not tell us how to do it. Instead, it provided some
    conveniences to help make our business logic easier to build. Decorator logic
    gave us the flexibility to have reusable code across the application. Exception
    definitions can automatically catch and handle responses. Building applications
    with Sanic is much more about building well-structured Python applications.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们看到添加自定义和现成的验证逻辑非常简单。Sanic没有告诉我们如何做。相反，它提供了一些便利，以帮助使我们的业务逻辑更容易构建。装饰器逻辑给了我们在整个应用程序中拥有可重用代码的灵活性。异常定义可以自动捕获和处理响应。使用Sanic构建应用程序更多的是构建结构良好的Python应用程序。
- en: Once information is gathered and validated, it is time to do something with
    it. This is the purpose of the next chapter where we explore how to handle and
    ultimately respond to web requests.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收集并验证了信息，就需要对其进行处理。这是下一章的目的，我们将探讨如何处理和最终响应Web请求。
