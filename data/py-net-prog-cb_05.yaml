- en: Chapter 5. E-mail Protocols, FTP, and CGI Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：电子邮件协议、FTP和CGI编程
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Listing the files in a remote FTP server
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程FTP服务器上列出文件
- en: Uploading a local file to a remote FTP server
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地文件上传到远程FTP服务器
- en: E-mailing your current working directory as a compressed ZIP file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将当前工作目录作为压缩ZIP文件发送电子邮件
- en: Downloading your Google e-mail with POP3
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用POP3下载您的Google电子邮件
- en: Checking your remote e-mail with IMAP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用IMAP检查您的远程电子邮件
- en: Sending an e-mail with an attachment via the Gmail SMTP server
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Gmail SMTP服务器发送带附件的电子邮件
- en: Writing a guestbook for your (Python-based) web server with CGI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用CGI为您的（基于Python的）Web服务器编写留言簿
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter explores the FTP, e-mail, and CGI communications protocol with
    a Python recipe. Python is a very efficient and friendly language. Using Python,
    you can easily code simple FTP actions such as a file download and upload.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过Python配方探讨了FTP、电子邮件和CGI通信协议。Python是一种非常高效且友好的语言。使用Python，您可以轻松编写简单的FTP操作，如文件下载和上传。
- en: There are some interesting recipes in this chapter, such as manipulating your
    Google e-mail, also known as the Gmail account, from your Python script. You can
    use these recipes to check, download, and send e-mails with IMAP, POP3, and SMTP
    protocols. In another recipe, a web server with CGI also demonstrates the basic
    CGI action, such as writing a guest comment form in your web application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中有些有趣的配方，例如使用Python脚本操作您的Google电子邮件，也称为Gmail账户。您可以使用这些配方通过IMAP、POP3和SMTP协议检查、下载和发送电子邮件。在另一个配方中，带有CGI的Web服务器还演示了基本CGI操作，例如在您的Web应用程序中编写访客留言表单。
- en: Listing the files in a remote FTP server
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在远程FTP服务器上列出文件
- en: You would like to list the files available on the official Linux kernel's FTP
    site, [ftp.kernel.org](http://ftp.kernel.org). You can select any other FTP site
    to try this recipe.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您想列出官方Linux内核FTP站点 [ftp.kernel.org](http://ftp.kernel.org) 上可用的文件。您可以选择任何其他FTP站点来尝试此配方。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If you work on a real FTP site with a user account, you need a username and
    password. However, in this instance, you don't need a username (and password)
    with Linux kernel's FTP site as you can log in anonymously.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个具有用户账户的真实FTP站点上工作，您需要一个用户名和密码。然而，在这种情况下，您不需要用户名（和密码），因为您可以使用Linux内核的FTP站点匿名登录。
- en: How to do it...
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can use the `ftplib` library to fetch files from our selected FTP site. A
    detailed documentation of this library can be found at [http://docs.python.org/2/library/ftplib.html](http://docs.python.org/2/library/ftplib.html).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `ftplib` 库从我们选择的FTP站点获取文件。有关此库的详细文档，请参阅 [http://docs.python.org/2/library/ftplib.html](http://docs.python.org/2/library/ftplib.html)。
- en: Let us see how we can fetch some files with `ftplib`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `ftplib` 获取一些文件。
- en: 'Listing 5.1 gives a simple FTP connection test as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.1提供了一个简单的FTP连接测试，如下所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This recipe will list the files and folders present in the FTP path, `ftp.kernel.org/pub`.
    If you run this script, you can see the following output:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将列出FTP路径 `ftp.kernel.org/pub` 中存在的文件和文件夹。如果您运行此脚本，您将看到以下输出：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe uses `ftplib` to create an FTP client session with [ftp.kernel.org](http://ftp.kernel.org).
    The `test_ftp_connection()` function takes the FTP path, username, and e-mail
    address for connecting to the FTP server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方使用 `ftplib` 创建与 [ftp.kernel.org](http://ftp.kernel.org) 的FTP客户端会话。`test_ftp_connection()`
    函数接受FTP路径、用户名和电子邮件地址以连接到FTP服务器。
- en: An FTP client session can be created by calling the `FTP()`function of `ftplib`
    with the preceding connection's credentials. This returns a client handle which
    then can be used to run the usual ftp commands, such as the command to change
    the working directory or `cwd()`. The `dir()`method returns the directory listing.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用 `ftplib` 的 `FTP()` 函数并使用前面的连接凭证来创建FTP客户端会话。这返回一个客户端句柄，然后可以使用它来运行常用的ftp命令，例如更改工作目录的命令或
    `cwd()`。`dir()` 方法返回目录列表。
- en: It is good idea to quit the FTP session by calling `ftp.quit()`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `ftp.quit()` 退出FTP会话是个好主意。
- en: Uploading a local file to a remote FTP server
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将本地文件上传到远程FTP服务器
- en: You would like to upload a file to an FTP server.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将文件上传到FTP服务器。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let us set up a local FTP server. In Unix/Linux, you can install the **wu-ftpd**
    package using the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个本地FTP服务器。在Unix/Linux中，您可以使用以下命令安装 **wu-ftpd** 软件包：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On a Windows machine, you can install the FileZilla FTP server, which can be
    downloaded from [https://filezilla-project.org/download.php?type=server](https://filezilla-project.org/download.php?type=server).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上，您可以安装FileZilla FTP服务器，可以从[https://filezilla-project.org/download.php?type=server](https://filezilla-project.org/download.php?type=server)下载。
- en: You should create an FTP user account following the FTP server package's user
    manual.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该根据FTP服务器包的用户手册创建一个FTP用户账户。
- en: You would also like to upload a file to an ftp server. You can specify the server
    address, login credentials, and filename as the input argument of your script.
    You should create a local file called `readme.txt` with any text in it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还希望将文件上传到FTP服务器。您可以将服务器地址、登录凭证和文件名作为脚本输入参数指定。您应该创建一个名为`readme.txt`的本地文件，并在其中输入任何文本。
- en: How to do it...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Using the following script, let's set up a local FTP server. In Unix/Linux,
    you can install the wu-ftpd package. Then, you can upload a file to the logged-in
    user's home directory. You can specify the server address, login credentials,
    and filename as the input argument of your script.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下脚本，让我们设置一个本地FTP服务器。在Unix/Linux系统中，您可以安装wu-ftpd包。然后，您可以上传文件到已登录用户的家目录。您可以将服务器地址、登录凭证和文件名作为脚本输入参数指定。
- en: 'Listing 5.2 gives the FTP Upload Example as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2给出了FTP上传示例，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you set up a local FTP server and run the following script, this script will
    log in to the FTP server and then will upload a file. If a filename argument is
    not supplied from command line by default, it will upload the `readme.txt` file.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您设置了一个本地FTP服务器并运行以下脚本，此脚本将登录到FTP服务器，然后上传文件。如果没有从命令行默认提供文件名参数，它将上传`readme.txt`文件。
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we assume that a local FTP server is running. Alternatively,
    you can connect to a remote FTP server. The `ftp_upload()` method uses the `FTP()`function
    of Python's `ftplib` to create an FTP connection object. With the `login()` method,
    it logs in to the server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们假设本地FTP服务器正在运行。或者，您也可以连接到远程FTP服务器。`ftp_upload()`方法使用Python的`ftplib`模块的`FTP()`函数创建FTP连接对象。使用`login()`方法，它将登录到服务器。
- en: After a successful login, the `ftp` object sends the STOR command with either
    the `storlines()` or `storbinary()` method. The first method is used for sending
    ASCII text files such as HTML or text files. The latter method is used for binary
    data such as zipped archive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，`ftp`对象使用`storlines()`或`storbinary()`方法发送STOR命令。第一种方法用于发送ASCII文本文件，如HTML或文本文件。后者方法用于二进制数据，如压缩存档。
- en: It's a good idea to wrap these FTP methods with `try-catch` error-handling blocks,
    which is not shown here for the sake of brevity.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些FTP方法包装在`try-catch`错误处理块中是一个好主意，这里为了简洁没有展示。
- en: E-mailing your current working directory as a compressed ZIP file
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将当前工作目录作为压缩的ZIP文件发送电子邮件
- en: It might be interesting to send the current working directory contents as a
    compressed ZIP archive. You can use this recipe to quickly share your files with
    your friends.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 将当前工作目录的内容作为压缩的ZIP存档发送可能很有趣。您可以使用这个方法快速与您的朋友分享文件。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'If you don''t have any mail server installed on your machine, you need to install
    a local mail server such as `postfix`. On a Debian/Ubuntu system, this can be
    installed with default settings using `apt-get`, as shown in the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的机器上没有安装任何邮件服务器，您需要安装一个本地邮件服务器，如`postfix`。在Debian/Ubuntu系统中，可以使用`apt-get`默认设置安装，如下所示：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let us first compress the current directory and then create an e-mail message.
    We can send the e-mail message via an external SMTP host, or we can use a local
    e-mail server to do this. Like other recipes, let us get the sender and recipient
    information from parsing the command-line inputs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先压缩当前目录，然后创建一个电子邮件消息。我们可以通过外部SMTP主机发送电子邮件消息，或者我们可以使用本地电子邮件服务器来完成这个任务。像其他菜谱一样，让我们从解析命令行输入中获取发件人和收件人信息。
- en: 'Listing 5.3 shows how to convert an e-mail folder into a compressed ZIP file
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.3展示了如何将电子邮件文件夹转换为压缩的ZIP文件，如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running this recipe shows the following output. The extra output is shown because
    we enabled the e-mail debug level.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此菜谱将显示以下输出。额外的输出显示是因为我们启用了电子邮件调试级别。
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We have used Python''s `zipfile`, `smtplib` and an `email` module to achieve
    our objective of e-mailing a folder as a zipped archive. This is done using the
    `email_dir_zipped()` method. This method takes two arguments: the sender and recipient''s
    e-mail addresses to create the e-mail message.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了Python的`zipfile`、`smtplib`和`email`模块，通过`email_dir_zipped()`方法实现了将文件夹作为压缩存档发送电子邮件的目标。此方法接受两个参数：发件人和收件人的电子邮件地址以创建电子邮件消息。
- en: In order to create a ZIP archive, we create a temporary file with the `tempfile`
    module's `TemporaryFile()` class. We supply a filename prefix, `mail`, and suffix,
    `.zip`. Then, we initialize the ZIP archive object with the `ZipFile()` class
    by passing the temporary file as its argument. Later, we add files of the current
    directory with the ZIP object's `write()` method call.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建ZIP存档，我们使用`tempfile`模块的`TemporaryFile()`类创建一个临时文件。我们提供一个文件名前缀`mail`和后缀`.zip`。然后，我们通过传递临时文件作为参数，使用`ZipFile()`类初始化ZIP存档对象。稍后，我们使用ZIP对象的`write()`方法调用添加当前目录下的文件。
- en: To send an e-mail, we create a multipart MIME message with the `MIMEmultipart()`
    class from the `email.mime.multipart` module. Like our usual e-mail message, the
    subject, recipient, and sender information is added in the e-mail header.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，我们使用`email.mime.multipart`模块中的`MIMEMultipart()`类创建一个多部分MIME消息。像我们通常的电子邮件消息一样，主题、收件人和发件人信息被添加到电子邮件头中。
- en: We create the e-mail attachment with the `MIMEBase()` method. Here, we first
    specify the application/ZIP header and call `set_payload()` on this message object.
    Then, in order to encode the message correctly, the `encode_base64()` method from
    encoder's module is used. It is also helpful to use the `add_header()` method
    to construct the attachment header. Now, our attachment is ready to be included
    in the main e-mail message with an `attach()` method call.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`MIMEBase()`方法创建电子邮件附件。在这里，我们首先指定application/ZIP头信息，并在该消息对象上调用`set_payload()`。然后，为了正确编码消息，使用编码器模块中的`encode_base64()`方法。使用`add_header()`方法构建附件头信息也是很有帮助的。现在，我们的附件已经准备好通过`attach()`方法调用包含在主电子邮件消息中。
- en: Sending an e-mail requires you to call the `SMTP()` class instance of `smtplib`.
    There is a `sendmail()` method that will utilize the routine provided by the OS
    to actually send the e-mail message correctly. Its details are hidden under the
    hood. However, you can see a detailed interaction by enabling the debug option
    as shown in this recipe.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 发送电子邮件需要您调用`smtplib`的`SMTP()`类实例。有一个`sendmail()`方法将利用操作系统提供的例程正确地发送电子邮件消息。其细节隐藏在幕后。然而，您可以通过启用调试选项来查看详细的交互，如本菜谱所示。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Further information about the Python libraries can be found at the URL [http://docs.python.org/2/library/smtplib.html](http://docs.python.org/2/library/smtplib.html)
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Python库的更多信息可以在以下URL找到：[http://docs.python.org/2/library/smtplib.html](http://docs.python.org/2/library/smtplib.html)
- en: Downloading your Google e-mail with POP3
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用POP3下载您的谷歌电子邮件
- en: You would like to download your Google (or virtually any other e-mail provider's)
    e-mail via the POP3 protocol.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望通过POP3协议下载您的谷歌（或几乎任何其他电子邮件提供商的）电子邮件。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To run this recipe, you should have an e-mail account with Google or any other
    service provider.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此菜谱，您应该有一个谷歌或任何其他服务提供商的电子邮件账户。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Here, we attempt to download the first e-mail message from a user's Google e-mail
    account. The username is supplied from a command line, but the password is kept
    secret and not passed from the command line. This is rather entered while the
    script is running and kept hidden from display.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试从用户的谷歌电子邮件账户中下载第一封电子邮件。用户名从命令行提供，但密码是保密的，不会通过命令行传递。而是在脚本运行时输入，并保持从显示中隐藏。
- en: 'Listing 5.4 shows how to download our Google e-mail via `POP3` as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.4展示了如何通过`POP3`下载我们的谷歌电子邮件，如下所示：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you run this script, you will see an output similar to the following one.
    The message is truncated for the sake of privacy.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此脚本，您将看到类似以下的一个输出。出于隐私考虑，消息已被截断。
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: This recipe downloads a user's first Google message via POP3\. The `download_email()`
    method creates a `mailbox` object with Python, the `POP3_SSL()` class of `poplib`.
    We passed the Google POP3 server and port address to the class constructor. The
    `mailbox` object then sets up a user account with the `user()` method call. The
    password is collected from the user securely using the `getpass` module's `getpass()`
    method and then passed to the `mailbox` object. The mailbox's `list()` method
    gives us the e-mail messages as a Python list.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方通过 POP3 下载用户的第一封 Google 邮件。`download_email()` 方法使用 Python 和 `poplib` 的 `POP3_SSL()`
    类创建一个 `mailbox` 对象。我们将 Google POP3 服务器和端口号传递给类构造函数。然后，`mailbox` 对象通过调用 `user()`
    方法设置用户账户。密码通过使用 `getpass` 模块的 `getpass()` 方法安全地从用户那里收集，然后传递给 `mailbox` 对象。`mailbox`
    的 `list()` 方法以 Python 列表的形式给出电子邮件。
- en: This script first displays the number of e-mail messages stored in the mailbox
    and retrieves the first message with the `retr()` method call. Finally, it's safe
    to call the `quit()` method on the mailbox to clean up the connection.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本首先显示邮箱中存储的电子邮件数量，并使用 `retr()` 方法调用检索第一封消息。最后，在邮箱上调用 `quit()` 方法来清理连接是安全的。
- en: Checking your remote e-mail with IMAP
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 IMAP 检查您的远程电子邮件
- en: Instead of using POP3, you can also use IMAP to retrieve the e-mail message
    from your Google account. In this case, the message won't be deleted after retrieval.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用 POP3，您还可以使用 IMAP 从您的 Google 账户检索电子邮件消息。在这种情况下，检索后消息不会被删除。
- en: Getting ready
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To run this recipe, you should have an e-mail account with Google or any other
    service provider.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此配方，您应该有一个 Google 或其他服务提供商的电子邮件账户。
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let us connect to your Google e-mail account and read the first e-mail message.
    If you don't delete it, the first e-mail message would be the welcome message
    from Google.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们连接到您的 Google 电子邮件账户并读取第一封电子邮件消息。如果您不删除它，第一封电子邮件消息将是 Google 的欢迎消息。
- en: 'Listing 5.5 shows us how to check Google e-mail with IMAP as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 展示了如何使用 IMAP 检查 Google 邮件的方法：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you run this script, this will show the following output. In order to remove
    the private part of the data, we truncated some user data.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此脚本，这将显示以下输出。为了移除数据的私人部分，我们截断了一些用户数据。
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding script takes a Google username from the command line and calls
    the `check_email()` function. This function creates an IMAP mailbox with the `IMAP4_SSL()`
    class of `imaplib`, which is initialized with Google's IMAP server and default
    port.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本从命令行获取 Google 用户名并调用 `check_email()` 函数。此函数使用 `imaplib` 的 `IMAP4_SSL()`
    类创建一个 IMAP 邮箱，该类使用 Google 的 IMAP 服务器和默认端口进行初始化。
- en: Then, this function logs in to the mailbox with a password, which is captured
    by the `getpass()` method of the `getpass` module. The inbox folder is selected
    by calling the `select()` method on the `mailbox` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，此函数使用 `getpass` 模块的 `getpass()` 方法捕获的密码登录邮箱。通过在 `mailbox` 对象上调用 `select()`
    方法选择收件箱文件夹。
- en: The `mailbox` object has many useful methods. Two of them are `search()` and
    `fetch()` that are used to get the first e-mail message. Finally, it's safer to
    call the `close()` and `logout()` method on the `mailbox` object to end the IMAP
    connection.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`mailbox` 对象有许多有用的方法。其中两个是 `search()` 和 `fetch()`，它们用于获取第一封电子邮件。最后，在 `mailbox`
    对象上调用 `close()` 和 `logout()` 方法来结束 IMAP 连接会更安全。'
- en: Sending an e-mail with an attachment via Gmail SMTP server
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Gmail SMTP 服务器发送带附件的电子邮件
- en: You would like to send an e-mail message from your Google e-mail account to
    another account. You also need to attach a file with this message.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您想从您的 Google 电子邮件账户向另一个账户发送电子邮件。您还需要将文件附加到这条消息上。
- en: Getting ready
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To run this recipe, you should have an e-mail account with Google or any other
    service provider.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此配方，您应该有一个 Google 或其他服务提供商的电子邮件账户。
- en: How to do it...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can create an e-mail message and attach Python's `python-logo.gif` file with
    the e-mail message. Then, this message is sent from a Google account to a different
    account.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个电子邮件消息，并将 Python 的 `python-logo.gif` 文件附加到电子邮件消息中。然后，这条消息从一个 Google
    账户发送到另一个账户。
- en: 'Listing 4.6 shows us how to send an e-mail from your Google account:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 展示了如何从您的 Google 账户发送电子邮件的方法：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Running the following script outputs the success of sending an e-mail to any
    e-mail address if you provide your Google account details correctly. After running
    this script, you can check your recipient e-mail account to verify that the e-mail
    is actually sent.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下脚本，如果你正确提供了你的Google账户详细信息，将输出发送电子邮件到任何电子邮件地址的成功信息。运行此脚本后，你可以检查收件人的电子邮件账户以验证电子邮件是否已实际发送。
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, an e-mail message is created in the `send_email()` function.
    This function is supplied with a Google account from where the e-mail message
    will be sent. The message header object, `msg`, is created by calling the `MIMEMultipart()`
    class and then subject, recipient, and sender information is added on it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，在 `send_email()` 函数中创建了一个电子邮件消息。此函数提供了一个Google账户，电子邮件消息将从该账户发送。通过调用 `MIMEMultipart()`
    类创建消息头对象 `msg`，然后在其上添加主题、收件人和发件人信息。
- en: Python's regular expression-handling module is used to filter the `.gif` image
    on the current path. The image attachment object, `img`, is then created with
    the `MIMEImage()` method from the `email.mime.image` module. A correct image header
    is added to this object and finally, the image is attached with the `msg` object
    created earlier. We can attach multiple image files within a `for` loop as shown
    in this recipe. We can also attach a plain text attachment in a similar way.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Python的正则表达式处理模块用于过滤当前路径上的 `.gif` 图像。然后，使用 `email.mime.image` 模块的 `MIMEImage()`
    方法创建图像附件对象 `img`。向此对象添加正确的图像头，最后，使用之前创建的 `msg` 对象将图像附加。我们可以在 `for` 循环中附加多个图像文件，如本食谱所示。我们也可以以类似的方式附加纯文本附件。
- en: To send the e-mail message, we create an SMTP session. We call some testing
    method on this session object, such as `ehlo()` or `starttls()`. Then, log in
    to the Google SMTP server with a username and password and a `sendmail()` method
    is called to send the e-mail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件消息，我们创建一个SMTP会话。我们在这个会话对象上调用一些测试方法，例如 `ehlo()` 或 `starttls()`。然后，使用用户名和密码登录到Google
    SMTP服务器，并调用 `sendmail()` 方法发送电子邮件。
- en: Writing a guestbook for your (Python-based) web server with CGI
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的（基于Python的）Web服务器编写CGI guestbook
- en: '**Common Gateway Interface** (**CGI**) is a standard in web programming by
    which custom scripts can be used to produce web server output. You would like
    to catch the HTML form input from a user''s browser, redirect it to another page,
    and acknowledge a user action.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**通用网关接口** (**CGI**) 是Web编程中的一个标准，通过它可以使用自定义脚本生成Web服务器输出。你希望捕获用户浏览器中的HTML表单输入，将其重定向到另一个页面，并确认用户操作。'
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We first need to run a web server that supports CGI scripts. We placed our Python
    CGI script inside a `cgi-bin/` subdirectory and then visited the HTML page that
    contains the feedback form. Upon submitting this form, our web server will send
    the form data to the CGI script, and we'll see the output produced by this script.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要运行一个支持CGI脚本的Web服务器。我们将我们的Python CGI脚本放在一个 `cgi-bin/` 子目录中，然后访问包含反馈表单的HTML页面。提交此表单后，我们的Web服务器将表单数据发送到CGI脚本，我们将看到该脚本产生的输出。
- en: 'Listing 5.7 shows us how the Python web server supports CGI:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7显示了Python Web服务器如何支持CGI：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The following screenshot shows CGI enabled web server is serving contents:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了启用CGI的Web服务器正在提供内容：
- en: '![How to do it...](img/3463OS_05_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_05_01.jpg)'
- en: 'If you run this recipe, you will see the following output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个食谱，你将看到以下输出：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you need to visit `http://localhost:8800/5_7_send_feedback.html` from your
    browser.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要从你的浏览器访问 `http://localhost:8800/5_7_send_feedback.html`。
- en: 'You will see an input form. We assume that you provide the following input
    to this form:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个输入表单。我们假设你向此表单提供以下输入：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following screenshot shows the entering user comment in a web form:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在Web表单中输入的用户评论：
- en: '![How to do it...](img/3463OS_05_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_05_02.jpg)'
- en: 'Then, your browser will be redirected to `http://localhost:8800/cgi-bin/5_7_get_feedback.py`
    where you can see the following output:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的浏览器将被重定向到 `http://localhost:8800/cgi-bin/5_7_get_feedback.py`，在那里你可以看到以下输出：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The user comment is shown in the browser:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 用户评论在浏览器中显示：
- en: '![How to do it...](img/3463OS_05_03.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_05_03.jpg)'
- en: How it works...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have used a basic HTTP server setup that can handle CGI requests. Python
    provides these interfaces in the `BaseHTTPServer` and `CGIHTTPserver` modules.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个基本的HTTP服务器设置，它可以处理CGI请求。Python在 `BaseHTTPServer` 和 `CGIHTTPserver` 模块中提供了这些接口。
- en: The handler is configured to use the `/cgi-bin` path to launch the CGI scripts.
    No other path can be used to run the CGI scripts.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 处理器配置为使用 `/cgi-bin` 路径来启动 CGI 脚本。不能使用其他路径来运行 CGI 脚本。
- en: 'The HTML feedback form located on `5_7_send_feedback.html` shows a very basic
    HTML form containing the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 位于 `5_7_send_feedback.html` 的 HTML 反馈表单显示了一个非常基础的 HTML 表单，其中包含以下代码：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Note that the form method is `POST` and action is set to the `/cgi-bin/5_7_get_feedback.py`
    file. The contents of this file are as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表单方法为 `POST`，并且操作设置为 `/cgi-bin/5_7_get_feedback.py` 文件。该文件的内容如下：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this CGI script, the `FieldStorage()` method is called from `cgilib`. This
    returns a form object to process the HTML form inputs. Two inputs are parsed here
    (`name` and `comment`) using the `getvalue()` method. Finally, the script acknowledges
    the user input by echoing a line back saying that the user *x* has sent a comment.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 CGI 脚本中，从 `cgilib` 调用了 `FieldStorage()` 方法。这返回一个表单对象以处理 HTML 表单输入。这里解析了两个输入（`name`
    和 `comment`），使用的是 `getvalue()` 方法。最后，脚本通过回显一行信息来确认用户输入，表示用户 *x* 已发送评论。
