- en: Chapter 2. Discuss – a Hacker News Clone
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Discuss - 一个Hacker News克隆
- en: In this chapter, we'll be creating a web app similar to Hacker News or Reddit,
    where users can share and discuss links to web content. We'll call the application
    *Discuss*. To keep things simple, we'll be emulating the minimalistic look of
    Hacker News, which is text only and has a very simple interface. Reddit, on the
    other hand, is much more visually rich and has a lot of extra features that we
    won't be adding to our site.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个类似Hacker News或Reddit的Web应用程序，用户可以分享和讨论网络内容的链接。我们将称该应用程序为*Discuss*。为了保持简单，我们将模拟Hacker
    News的极简外观，它只有文本，界面非常简单。另一方面，Reddit的外观要丰富得多，并且有许多额外的功能，我们不会将这些功能添加到我们的网站上。
- en: 'Here''s an outline of what we''ll be covering in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章我们将涵盖的大纲：
- en: Allowing users to submit their own content
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户提交他们自己的内容
- en: Allowing users to vote on content submitted by other users
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许用户对其他用户提交的内容进行投票
- en: Ranking the user-submitted content based on simple algorithms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于简单算法对用户提交的内容进行排名
- en: Preventing spammers from abusing our site using captchas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止垃圾邮件发送者滥用我们的网站使用验证码
- en: Chapter code packs
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 章节代码包
- en: If you have developed a few Django applications, you'll probably know that for
    most applications, a lot of the code and configurations that you do when starting
    out is the same. You set up the database in the same way, maybe changing the **Database**
    (**DB**) name and user/pass pairs, you set up your media, static URL, and root
    paths, and then you add user authentication using the built-in `auth contrib`
    application and the provided views, only creating minimal templates that are good
    enough to get the job done in the start.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经开发了一些Django应用程序，您可能会知道，对于大多数应用程序，当您开始时所做的大部分代码和配置都是相同的。您以相同的方式设置数据库，也许会更改**数据库**（**DB**）名称和用户/密码对，设置媒体、静态URL和根路径，然后使用内置的`auth
    contrib`应用程序和提供的视图添加用户身份验证，只创建足够简单的模板，以便在开始时完成工作。
- en: Walking you through the basic setup at the start of every chapter would be very
    boring—both for you to read and for me to write. Instead, I've provided what I
    call **Code Packs**. These are `zip` files that contain the Django application
    already set up so that we can jump straight to the interesting parts of the code
    instead of having to go through the tedious setup process again and again.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一章的开始，为您介绍基本设置将会非常无聊，无论是对您来说阅读还是对我来说写作都是如此。相反，我提供了我称之为**代码包**。这些是`zip`文件，其中包含已经设置好的Django应用程序，这样我们就可以直接跳到代码的有趣部分，而不必一遍又一遍地进行繁琐的设置过程。
- en: Don't worry, I won't skip any new Django features that we haven't looked at
    yet. Each code pack contains code that has already been explained to you in previous
    chapters. For instance, the code pack for this chapter contains a Django application
    that has the user registration, login, and logout views, templates, and URLs already
    set up. This is the stuff that we have already looked at in detail in the previous
    chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我不会跳过我们尚未看过的新Django功能。每个代码包都包含已在以前的章节中向您解释过的代码。例如，本章的代码包包含一个Django应用程序，其中已经设置好了用户注册、登录和注销视图、模板和URL。这是我们在上一章中已经详细讨论过的内容。
- en: 'To use these code packs, you will need to download them, unzip them in the
    project root folder, and create a virtual environment for them. Then, you''ll
    need to run the following command to have Django installed in your new virtual
    environment:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些代码包，您需要下载它们，解压缩到项目根目录中，并为它们创建一个虚拟环境。然后，您需要运行以下命令，在您的新虚拟环境中安装Django：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once you've done all these steps, you'll be ready to start working on the fun
    parts of the application. For all the following chapters, I've given you the link
    to the code pack and I assume that you have already extracted and set up a virtual
    environment for it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些步骤后，您将准备好开始处理应用程序的有趣部分。在接下来的所有章节中，我已经为您提供了代码包的链接，并假设您已经提取并设置了虚拟环境。
- en: Tip
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are not sure how to use the code packs, there is `Readme.txt` in each
    ZIP file. You should read this to figure out how to get started using the code
    pack.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定如何使用代码包，每个ZIP文件中都有一个`Readme.txt`。您应该阅读这个文件，以了解如何开始使用代码包。
- en: Requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 要求
- en: For any complex application, it is always a good idea to know what features
    we need to work on before we jump into coding. Let's look at what we want to create
    in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何复杂的应用程序，在我们开始编码之前知道我们需要处理的功能总是一个好主意。让我们看看我们希望在本章中创建的内容。
- en: We want to have a Django-based link sharing and discussion site like Hacker
    News. The site should have user accounts, allow users to share links, have a page
    where these links are listed in some defined order, and allow users to vote and
    comment on those links.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望拥有一个基于Django的链接分享和讨论网站，就像Hacker News一样。该网站应该有用户帐户，允许用户分享链接，有一个页面列出这些链接，允许用户投票和评论这些链接。
- en: Additionally, we'd like to have safeguards against spammers and malicious users
    who would degrade the content quality of our site if left unchecked.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望对滥发垃圾邮件和恶意用户采取防范措施，如果不加以控制，他们会降低我们网站的内容质量。
- en: 'In a list form, here are the features that we want our application to provide:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以列表形式，这是我们希望我们的应用程序提供的功能：
- en: User registration and authentication (already provided in the code pack)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户注册和身份验证（已在代码包中提供）
- en: Link submission by users
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提交的链接
- en: Voting on links submitted by other users
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其他用户提交的链接进行投票
- en: Commenting on the submissions and replying to comments by other users
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对提交进行评论并回复其他用户的评论
- en: An algorithm to rank the submitted links in some defined order that depends
    on a number of factors including the votes for that link, number of comments,
    and age of the submission
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种算法，根据一些因素对提交的链接进行排名，包括该链接的投票数、评论数和提交的时间
- en: A way to disallow spammers from creating scripts that can automatically flood
    our site with submissions
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止垃圾邮件发送者创建脚本，可以自动向我们的网站提交洪水般的内容
- en: Starting out
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: 'By now you should have the application ready to test if you''ve followed the
    instructions given at the start of the chapter. Let''s see what it looks like
    at the moment. Start the application by running the following command in your
    terminal from the application folder. You''ll need to make sure that your virtual
    environment is activated before you can run this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，如果您按照本章开头给出的说明进行操作，您应该已经准备好测试应用程序了。让我们看看目前的情况。通过从应用程序文件夹中的终端运行以下命令来启动应用程序。在运行此命令之前，您需要确保您的虚拟环境已激活：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `http://127.0.0.1:8000` in your browser and you should see the following
    basic page:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://127.0.0.1:8000`，你应该会看到以下基本页面：
- en: '![Starting out](img/00698_02_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![开始](img/00698_02_01.jpg)'
- en: As you can see, we have links for **Login** and **Create New Account**. You
    should go ahead and create a new account. Log in with this account and you'll
    see the two links replaced with a **Logout** link. This is the basic application
    setup that we'll use moving forward. You should make sure that you are able to
    use the application at this point, as all further development will be built on
    top of this.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有**登录**和**创建新帐户**的链接。您应该继续创建一个新帐户。使用此帐户登录，您将看到两个链接被**注销**链接替换。这是我们将来要使用的基本应用程序设置。您应该确保您能够在这一点上使用应用程序，因为所有进一步的开发都将建立在此基础之上。
- en: Link submission
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链接提交
- en: 'Let''s look at what features we want to be related with link submissions. This
    is just a part of the features list that we saw at the start of the chapter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们想要与链接提交相关的功能。这只是我们在本章开头看到的功能列表的一部分：
- en: Link submission by users
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提交的链接
- en: Voting on links submitted by other users
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对其他用户提交的链接进行投票
- en: Commenting on the submissions and replying to comments by other users
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对提交进行评论并回复其他用户的评论
- en: Let's think about what models we'll need to implement this. First, we need a
    model to hold information about a single submission, such as the title, URL, who
    submitted the link, and at what time. Next, we need a way to track votes on submissions
    by users. This can be implemented by a `ManyToMany` field from the submission
    model to the `User` model. This way, whenever a user votes for a submission, we
    just add them to the set of related objects and remove them if they decide to
    take back their vote.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下我们需要实现这个的模型。首先，我们需要一个模型来保存有关单个提交的信息，比如标题、URL、谁提交了链接以及何时提交的信息。接下来，我们需要一种方式来跟踪用户对提交的投票。这可以通过从提交模型到`User`模型的`ManyToMany`字段来实现。这样，每当用户对提交进行投票时，我们只需将他们添加到相关对象的集合中，如果他们决定撤回他们的投票，我们就将他们移除。
- en: Commenting as a feature is separate from link submissions because it can be
    implemented as a separate model that links to the submission model with `ForeignKey`.
    We'll look at commenting in the next section. For now, we'll concentrate on link
    submissions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 评论作为一个功能是独立于链接提交的，因为它可以作为一个链接到提交模型的单独模型来实现。我们将在下一节中讨论评论。现在，我们将集中在链接提交上。
- en: 'To start out, let''s create a new application in our project for link submission-related
    features. Run the following command in your CLI:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在我们的项目中为链接提交相关的功能创建一个新的应用程序。在CLI中运行以下命令：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Then, add our newly created app to the `INSTALLED_APPS` settings variable. Now
    we're ready to write code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将我们新创建的应用程序添加到`INSTALLED_APPS`设置变量中。现在我们准备好编写代码了。
- en: 'Let''s start with the models. Here''s the code for `Link model`. This code
    should be in `links/models.py`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从模型开始。这是`Link model`的代码。这段代码应该在`links/models.py`中：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that we had to set `related_name` for the `upvotes` field. If we hadn't
    done this, we would get an error from Django when we try to run our application.
    Django would have complained about having two relationships to the `User` model
    from the `Link` model, both trying to create a reverse relationship named `link`.
    To fix this, we explicitly named the reverse relationship from the `User` model
    to the `Link` model via the `upvotes` field. The `User` model should now have
    an attribute called `votes`, which can be used to get a list of submissions that
    the user has voted on.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们必须为`upvotes`字段设置`related_name`。如果我们没有这样做，当我们尝试运行我们的应用程序时，我们将从Django那里得到一个错误。Django会抱怨在`Link`模型中有两个与`User`模型的关系，都试图创建一个名为`link`的反向关系。为了解决这个问题，我们通过`upvotes`字段明确地命名了从`User`模型到`Link`模型的反向关系。`User`模型现在应该有一个名为`votes`的属性，可以用来获取用户已经投票的提交的列表。
- en: 'Once you''ve saved this code, you''ll need to make and run migrations in order
    for Django to create database tables for the new model. To do so, type the following
    commands:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 保存了这段代码后，您需要进行迁移并运行迁移，以便Django为新模型创建数据库表。为此，请输入以下命令：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s work on the templates and views. We''ll customize the generic
    `CreateView` that we''ve seen in the previous chapter for the view. Put this code
    in `links/views.py`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来处理模板和视图。我们将为视图定制我们在上一章中看到的通用`CreateView`。将这段代码放在`links/views.py`中：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should look familiar to the `CreateView` subclasses that we have already
    created in the previous chapter. However, look closer! This time, we don't define
    a custom form class. Instead, we just point to the model—`Link` in this case—and
    `CreateView` automagically creates a model form for us. This is the power of built-in
    Django generic views. They give you multiple options to get what you want, depending
    on how much customization you need to do.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该看起来很熟悉，对于我们在上一章中已经创建的`CreateView`子类。然而，仔细看！这一次，我们不定义一个自定义表单类。相反，我们只是指向模型——在这种情况下是`Link`——`CreateView`会自动为我们创建一个模型表单。这就是内置的Django通用视图的强大之处。它们为您提供多种选项，以便根据您需要进行多少定制来获得您想要的内容。
- en: We define the `model` and `fields` attributes. The `model` attribute is self-explanatory.
    The `fields` attribute has the same meaning here as it has in a `ModelForm` subclass.
    It tells Django which fields we want to be made editable. In our `link` model,
    the title and submission URL are the only two fields that we want the user to
    control, so we put these in the fields list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`model`和`fields`属性。`model`属性不言自明。`fields`属性在这里的含义与`ModelForm`子类中的含义相同。它告诉Django我们希望进行编辑的字段。在我们的`link`模型中，标题和提交URL是我们希望用户控制的唯二字段，因此我们将它们放入字段列表中。
- en: Another important thing to look at here is the `form_valid` function. Note that
    it doesn't have any calls to `super`. Unlike our previous code, where we always
    called the parent class method for methods that we had overridden, we do no such
    thing here. That's because `form_valid` of `CreateView` calls the `save()` method
    of the form. This will try to save the new link object without giving us the chance
    to set its `submitted_by` field. As the `submitted_by` field is required and can't
    be `null`, the object won't be saved and we'll have to deal with a database exception.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还要注意的一件重要的事情是`form_valid`函数。请注意，它没有任何对`super`的调用。与我们以前的代码不同，在那里我们总是调用父类方法来覆盖的方法，但在这里我们不这样做。这是因为`CreateView`的`form_valid`调用了表单的`save()`方法。这将尝试保存新的链接对象，而不给我们设置其`submitted_by`字段的机会。由于`submitted_by`字段是必需的，不能为`null`，因此对象将不会被保存，我们将不得不处理数据库异常。
- en: 'So instead, we chose to not call the `form_valid` method on the parent class
    and wrote the code for it ourselves. To do so, I needed to know what the base
    method did. So I looked up the documentation for it at [https://docs.djangoproject.com/en/1.9/ref/class-based-views/mixins-editing/#django.views.generic.edit.ModelFormMixin.form_valid](https://docs.djangoproject.com/en/1.9/ref/class-based-views/mixins-editing/#django.views.generic.edit.ModelFormMixin.form_valid):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们选择不调用父类的`form_valid`方法，而是自己编写了代码。为此，我需要知道基本方法的作用。因此，我查阅了它的文档[https://docs.djangoproject.com/en/1.9/ref/class-based-views/mixins-editing/#django.views.generic.edit.ModelFormMixin.form_valid](https://docs.djangoproject.com/en/1.9/ref/class-based-views/mixins-editing/#django.views.generic.edit.ModelFormMixin.form_valid)：
- en: '*"Saves the form instance, sets the current object for the view, and redirects
    to get_success_url()."*'
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"保存表单实例，为视图设置当前对象，并重定向到get_success_url()."*'
- en: If you look at our code for the `form_valid` function, you will see that we
    do exactly the same thing. If you're ever faced with a similar situation, the
    Django documentation is the best resource to clear things up. It has some of the
    best documentation that I have ever encountered in any of the open source projects
    that I have used.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看我们的`form_valid`函数的代码，您会发现我们做了完全相同的事情。如果您遇到类似情况，Django文档是澄清事情的最佳资源。它拥有我使用过的所有开源项目中遇到的最好的文档之一。
- en: 'Finally, we need the template and URL configuration for the link submission
    feature. Create a new folder called `templates` in the `links` directory and save
    this code in a file called `new_submission.html`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要链接提交功能的模板和URL配置。在`links`目录中创建一个名为`templates`的新文件夹，并将此代码保存在名为`new_submission.html`的文件中：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In `discuss/urls.py`, import the new view:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在`discuss/urls.py`中，导入新视图：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a new URL configuration for this view:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为此视图创建新的URL配置：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'That''s it. All the code that we need to get a basic link submission process
    up is written. However, to be able to test it out, we''ll need to give the user
    some way of accessing this new view. The navigation bar in our `base.html` template
    seems like a good place to put the link in for this. Change the code for the `nav`
    HTML tag in `base.html` in the `templates` directory in the project root to match
    the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。我们需要编写的所有代码以实现基本的链接提交流程都已经完成。但是，为了能够测试它，我们需要为用户提供一些访问这个新视图的方式。在我们的`base.html`模板中的导航栏似乎是放置此链接的好地方。更改项目根目录中`templates`目录中`base.html`中`nav`
    HTML标签的代码以匹配以下代码：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To test it out, run the development server and open the home page. You'll see
    a **Submit New Link** option in the navigation menu on the top. Click on it and
    you'll see a page similar to the following one. Fill in the data and click on
    submit. If the data that you've filled in doesn't have any errors, you should
    be redirected to the home page.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试它，运行开发服务器并打开主页。您将在顶部导航菜单中看到**提交新链接**选项。单击它，您将看到一个类似以下页面的页面。填写数据并单击提交。如果您填写的数据没有错误，您应该会被重定向到主页。
- en: '![Link submission](img/00698_02_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![链接提交](img/00698_02_02.jpg)'
- en: While this works, this isn't the best user experience. Redirecting the user
    to the home page without giving them any feedback on whether their link was submitted
    is not good. Let's fix this next. We'll create a details page for the submissions
    and if the user was successful in submitting a new link, we'll take them to the
    details page.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但这并不是最好的用户体验。在不给用户任何关于他们的链接是否提交成功的反馈的情况下将用户重定向到主页是不好的。让我们下一步来修复这个问题。我们将为提交创建一个详细页面，如果用户成功提交了新链接，我们将把他们带到详细页面。
- en: 'Let''s start with the view. We''ll use the `DetailView` generic view provided
    by Django. In your `links/views.py` file, import `DetailView`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从视图开始。我们将使用Django提供的`DetailView`通用视图。在您的`links/views.py`文件中，导入`DetailView`：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Subclass it for our submission detail view:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的提交详细视图创建子类：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create the `submission_detail.html` template in the `links/templates` directory
    and put in the following Django template code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在`links/templates`目录中创建`submission_detail.html`模板，并放入以下Django模板代码：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Configure the URL for this view in `discuss/urls.py` by first importing it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先导入它，在`discuss/urls.py`中为此视图配置URL：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, add a URL pattern for it to the `urlpatterns` list:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其添加到`urlpatterns`列表的URL模式中：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we''ll need to edit the `NewSubmissionView` `get_success_url` method
    to redirect the user to our new detail view on successfully creating a new submission:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编辑`NewSubmissionView`的`get_success_url`方法，在成功创建新提交时将用户重定向到我们的新详细视图：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s it. Now when you create a new submission, you should see the following
    detail page for your new submission:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。现在当你创建一个新的提交时，你应该会看到你的新提交的详细页面：
- en: '![Link submission](img/00698_02_03.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![链接提交](img/00698_02_03.jpg)'
- en: Now that link submission is done, let's look at implementing the comments feature.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在链接提交已经完成，让我们来看看实现评论功能。
- en: Comments
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评论
- en: We want our logged in users to be able to comment on submissions. We'd also
    like users to reply to comments by other users. To achieve this, our `comment`
    model needs to be able to track the submission it was made on and also have a
    link to its parent comment (if it was made in reply to some other user's comment).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们已登录的用户能够对提交进行评论。我们也希望用户能够回复其他用户的评论。为了实现这一点，我们的`comment`模型需要能够跟踪它所在的提交，并且还需要有一个链接到它的父评论（如果它是在回复其他用户的评论时创建的）。
- en: 'If you have ever used forums on the Internet, the way our comments section
    works should seem familiar. One complaint that I''ve always had with all these
    forums is that they allow this hierarchy of comments to go on forever. Then you
    end up with 10-level deep comments that extend off the screen:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在互联网上使用过论坛，我们的评论部分的工作方式应该很熟悉。我对所有这些论坛的抱怨是它们允许这种层次结构的评论永无止境地延续下去。然后你最终会看到10级深的评论，延伸到屏幕之外：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: While there are a number of ways to solve this, the simplest probably is to
    cut off nested replies beyond a certain level. In our case, no comments can be
    replies to `Comment 2`. Instead, they must all be in reply to `Comment 1` or the
    parent submission. This will make the implementation easier as we'll see later.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有许多解决这个问题的方法，最简单的可能是在一定级别之后切断嵌套回复。在我们的情况下，没有评论可以回复`评论2`。相反，它们必须全部回复`评论1`或父提交。这将使实现更容易，我们稍后会看到。
- en: From our discussion so far, we know that our comment model will need foreign
    keys to our submission models and also to itself in order to refer to parent comments.
    This self reference, or a recursive relationship as Django documentation calls
    it, is something that I have used maybe once in the five years (and more) I have
    been creating web apps in Django. It's not something that is needed very often
    but sometimes it results in elegant solutions, like the one you'll see here.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止的讨论，我们知道我们的评论模型将需要外键到我们的提交模型，还需要自己引用自己以便引用父评论。这种自我引用，或者正如Django文档所称的递归关系，是我在使用Django创建Web应用的五年（甚至更长）中可能只用过一次的东西。这并不是经常需要的东西，但有时会产生优雅的解决方案，就像你将在这里看到的。
- en: 'To keep things simple, we''ll first implement commenting on link submissions
    and later add code to handle replying to comments. Let''s start with the model.
    Add the following to `links/models.py`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，我们将首先实现对链接提交的评论，然后再添加处理对评论的回复的代码。让我们从模型开始。将以下内容添加到`links/models.py`中：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `in_reply_to` field here is the recursive foreign key that allows us to
    create a hierarchy of comments and replies to them. As you can see, creating a
    recursive foreign key is achieved by giving the model name `self` instead of the
    model name like you would usually do with a normal foreign key.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`in_reply_to`字段是递归外键，允许我们创建评论和回复的层次结构。正如你所看到的，创建递归外键是通过给模型名称`self`而不是像通常情况下使用模型名称来实现的。
- en: 'Create and run the migrations to add this model to our database:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 创建并运行迁移以将此模型添加到我们的数据库中：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, let''s think about the view and template. As we''re only implementing
    commenting on submissions for now, it makes sense that the form to create a new
    comment also be visible on the submission details page. Let''s create the form
    first. Create a new `links/forms.py` file and add the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑视图和模板。由于我们现在只实现对提交的评论，因此在提交详细页面上也能看到创建新评论的表单是有意义的。让我们首先创建表单。创建一个新的`links/forms.py`文件，并添加以下代码：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will just create a simple model form for the `Comment` model and add one
    extra field that we''ll use to keep track of which link the comment needs to be
    associated with. To make the form available to our submission details template,
    import the form in `links/views.py` by adding the following to the top of the
    file:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为`Comment`模型创建一个简单的模型表单，并添加一个额外的字段，用于跟踪评论需要关联的链接。为了使表单可用于我们的提交详细模板，通过在文件顶部添加以下内容将表单导入`links/views.py`中：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We''ll also add code to show comments for a submission on the details page
    now. So we need to import the `Comment` model in the views file. Right after the
    line importing the form, add another line of code importing the model:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加代码来显示提交的评论在详细页面上。因此，我们需要在视图文件中导入`Comment`模型。在导入表单的行之后，添加另一行代码导入模型：
- en: '[PRE21]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To be able to display the comments associated with a submission and the form
    to create a new submission, we''ll need to make these two things available in
    the template context of the submission details page. To do so, add a `get_context_data`
    method to `SubmissionDetailView`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够显示与提交相关的评论以及创建新提交的表单，我们需要在提交详细页面的模板上下文中使这两个内容可用。为此，在`SubmissionDetailView`中添加一个`get_context_data`方法：
- en: '[PRE22]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll look at the initial attribute that we are passing to `CommentModelForm`
    in a while. We''ll also need to create a view where the new comment form is submitted.
    Here''s the code that you''ll need to add it to `links/views.py`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在一会儿传递给`CommentModelForm`的初始属性。我们还需要创建一个视图，用于提交新评论表单。以下是你需要添加到`links/views.py`中的代码：
- en: '[PRE23]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Even though we show the form on the submission detail page, in case the user
    inputs incorrect data when submitting the form, such as pressing the submit button
    with an empty body, we need a template that can show the form again along with
    the errors. Create the `comment.html` template in `links/templates`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们在提交详细页面上显示表单，但是如果用户在提交表单时输入不正确的数据，比如按下带有空主体的提交按钮，我们需要一个模板，可以再次显示表单以及错误。在`links/templates`中创建`comment.html`模板：
- en: '[PRE24]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You should already know what most of the code for the `CreateView` subclass
    does. One thing that is new is the `get_inital` method. We'll look at it in detail
    later. For now, let's get the comments feature up and running.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该已经了解`CreateView`子类的大部分代码是做什么的。新的一点是`get_inital`方法。我们稍后会详细看一下。现在，让我们让评论功能运行起来。
- en: 'Let''s add our new view to `discuss/urls.py`. First, import the view:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将新视图添加到`discuss/urls.py`中。首先，导入视图：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add it to the URL patterns:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将其添加到URL模式中：
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, change `links/templates/submission_detail.html` to the following:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将`links/templates/submission_detail.html`更改为以下内容：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you noticed the form action URL in our template, you'll see that we have
    added the `link_pk` GET parameter to it. If you refer back to the code that you
    wrote for `NewCommentView`, you'll see that we use this parameter value in the
    `get_context_data` and `get_inital` functions to get the `Link` object that the
    user is commenting on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注意到我们模板中的表单操作URL，您将看到我们已将`link_pk` GET参数添加到其中。如果您回顾一下您为`NewCommentView`编写的代码，您将看到我们在`get_context_data`和`get_inital`函数中使用此参数值来获取用户正在评论的`Link`对象。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: I'm saving describing what the `get_initial` method does until the next section
    when we get to adding replies to comments.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我将保存`get_initial`方法的描述，直到下一节，当我们开始添加对评论的回复时。
- en: 'Let''s look at what we''ve made till now. Start the application using the `runserver`
    command, open the home page in your browser, and then log in. As we don''t yet
    have any way to access old submissions, we''ll need to create a new submission.
    Do that and you''ll see the new detail page. It should look similar to the following
    screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们到目前为止做了什么。使用`runserver`命令启动应用程序，在浏览器中打开主页，然后登录。由于我们还没有任何访问旧提交的方式，我们需要创建一个新的提交。这样做，您将看到新的详细页面。它应该类似于以下截图：
- en: '![Comments](img/00698_02_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![评论](img/00698_02_04.jpg)'
- en: 'Add a comment and it should appear on the same page. Here''s a screenshot with
    a few comments added:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 添加评论，它应该出现在同一页上。以下是添加了一些评论的截图：
- en: '![Comments](img/00698_02_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![评论](img/00698_02_05.jpg)'
- en: 'If you leave the body empty and press the **Comment** button, you should see
    the comment template that you created earlier with an error message:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将正文留空并按下**评论**按钮，您应该会看到您之前创建的评论模板，并带有错误消息：
- en: '![Comments](img/00698_02_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![评论](img/00698_02_06.jpg)'
- en: 'With basic commenting on submission working, let''s look at how we''ll implement
    replying to comments. As we''ve already seen, our comment model has a field to
    indicate that it was made in reply to another comment. So all we have to do in
    order to store a comment as a reply to another comment is correctly set the `in_reply_to`
    field. Let''s first modify our model form for the `Comment` model to accept in
    addition to a `link_pk`, a `parent_comment_pk` as well to indicate which (if any)
    comment is the new comment a reply to. Add this field to `CommentModelForm` right
    after the `link_pk` field:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有了基本的提交评论功能，让我们看看如何实现对评论的回复。正如我们已经看到的，我们的评论模型有一个字段来指示它是作为对另一条评论的回复而发表的。因此，为了将评论存储为对另一条评论的回复，我们所要做的就是正确设置`in_reply_to`字段。让我们首先修改我们的`Comment`模型表单，以接受除了`link_pk`之外，还有一个`parent_comment_pk`，以指示新评论是否是对哪条（如果有的话）评论的回复。在`CommentModelForm`中添加这个字段，就在`link_pk`字段之后：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we need a place to show a form to the user to post his reply. We could show
    one form per comment on the submission details page, but that would end up making
    the page look very cluttered for any submission with more than a few comments.
    In a real-world project, we'd probably use JavaScript to generate a form dynamically
    when the user clicks on the reply link next to a comment and submits this. However,
    right now we are more focused on the Django backend and thus we'll come up with
    another way that doesn't involve a lot of frontend work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要一个地方向用户显示一个表单，以便他发表回复。我们可以在提交详情页面上显示每条评论一个表单，但对于有多条评论的提交，这样做会使页面看起来非常凌乱。在实际项目中，我们可能会使用JavaScript在用户点击评论旁边的回复链接并提交时动态生成一个表单。然而，现在我们更专注于Django后端，因此我们将想出另一种不涉及大量前端工作的方法。
- en: 'A third way, which we''ll be using here, is to have a little link next to each
    comment that takes the user to a separate page where they can record their reply.
    Here''s the view for that page. Put this in `links/views.py`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种方式，我们将在这里使用，是在每条评论旁边放一个小链接，让用户转到一个单独的页面，在那里他们可以记录他们的回复。以下是该页面的视图。将其放在`links/views.py`中：
- en: '[PRE29]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By now, having used it multiple times, you should be comfortable with `CreateView`.
    The only new part here is the `get_initial` method, which we also used in `NewCommentView`
    previously. In Django, each form can have some initial data. This is data that
    is shown when the form is **Unbound**. The boundness of a form is an important
    concept. It took me a while to wrap my head around it, but it is quite simple.
    In Django, a form has essentially two functions. It can be displayed in the HTML
    code for a web page or it can validate some data.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您应该已经多次使用了`CreateView`，对它应该感到舒适。这里唯一新的部分是`get_initial`方法，我们之前在`NewCommentView`中也使用过。在Django中，每个表单都可以有一些初始数据。这是在表单未绑定时显示的数据。表单的绑定性是一个重要的概念。我花了一段时间才理解它，但它非常简单。在Django中，表单基本上有两个功能。它可以在网页的HTML代码中显示，或者可以验证一些数据。
- en: 'A form is bound if you passed in some data for it to validate when you initialized
    an instance of the form class. Let''s say you have a `form` class called `SomeForm`
    with two fields, name and city. Say you initialize an object of the form without
    any data:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在初始化表单类的实例时传入了一些数据来验证它，那么表单就是绑定的。假设您有一个名为`SomeForm`的`form`类，其中有两个字段，名称和城市。假设您初始化了一个没有任何数据的表单对象：
- en: '[PRE30]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You have created an unbound instance of the form. The form doesn''t have any
    data associated with it and so can''t validate anything. However, it can still
    be displayed on a web page by calling `{{ form.as_p }}` in the template (provided
    it was passed to the template via the context). It will render as a form with
    two empty fields: `name` and `city`.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经创建了一个未绑定的表单实例。表单没有与之关联的任何数据，因此无法验证任何内容。但是，可以通过在模板中调用`{{ form.as_p }}`来在网页上显示它（前提是它通过上下文传递到模板）。它将呈现为一个具有两个空字段的表单：`name`和`city`。
- en: 'Now let''s say you pass in some data when initializing the form:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设您在初始化表单时传入了一些数据：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This creates a bound instance of the form. You can call `is_valid()` on this
    form object and it will validate the passed data. You can also render the form
    in an HTML template, just like before. However, this time, it will render the
    form with both the fields having the values that you passed here. If, for some
    reason, the values that you passed didn't validate (for example, if you left the
    value for the city field empty), the form will display the appropriate error message
    next to the field with the invalid data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个绑定的表单实例。您可以在此表单对象上调用`is_valid()`，它将验证传递的数据。您还可以像以前一样在HTML模板中呈现表单。但是，这次，它将使用您在此处传递的值呈现具有两个字段值的表单。如果由于某种原因，您传递的值未经验证（例如，如果您将城市字段的值留空），则表单将在包含无效数据的字段旁边显示适当的错误消息。
- en: 'This is the concept of bound and unbound forms. Now let''s look at what the
    initial data in a form is for. You can pass initial data to a form when initializing
    an instance by passing it in the initial keyword parameter:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是绑定和未绑定表单的概念。现在让我们看看表单中的初始数据是用来做什么的。您可以通过将其传递给初始关键字参数来在初始化实例时将初始数据传递给表单：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The form is still unbound as you did not pass in the data attribute (which is
    the first non-keyword argument to the constructor) but if you render it now, the
    name field will have the value `'Jibran'` while the city field will still be empty.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 表单仍然是未绑定的，因为您没有传入数据属性（这是构造函数的第一个非关键字参数），但是如果现在呈现它，名称字段将具有值`'Jibran'`，而城市字段仍将为空。
- en: The confusion that I faced when I first learned of the initial data was why
    it was required. I could just pass the same data dictionary as the data parameter
    and the form would still only receive a value for one field. The problem with
    this is that when you initialize a form with some data, it will automatically
    try to validate that data. Assuming that the city field is a required field, if
    you then try to render the form in a web page, it will display an error next to
    the city field saying that this is a required field. The initial data parameter
    allows you to supply values for form fields without triggering validation on that
    data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当我第一次了解初始数据时遇到的困惑是为什么需要它。我可以只传递与数据参数相同的数据字典，表单仍然只会收到一个字段的值。这样做的问题在于，当您使用一些数据初始化表单时，它将自动尝试验证该数据。假设城市字段是必填字段，如果您尝试在网页上呈现表单，它将在城市字段旁边显示一个错误，指出这是一个必填字段。初始数据参数允许您为表单字段提供值，而不触发该数据的验证。
- en: In our case, `CreateView` calls the `get_initial` method to get the dictionary
    to use it as the initial data for the form. We use the submission ID and parent
    comment ID that we will pass in the URL parameters to create the initial values
    for the `link_pk` and `parent_comment_pk` form fields. This way, when our form
    is rendered on the HTML web page, it will already have values for these two fields.
    Looking at the `form_valid` method, we then extract these two values from the
    form's `cleaned_data` attribute and use it to get the submission and parent comment
    to associate the reply with.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`CreateView`调用`get_initial`方法以获取用作表单初始数据的字典。我们使用将在URL参数中传递的提交ID和父评论ID来创建`link_pk`和`parent_comment_pk`表单字段的初始值。这样，当我们的表单在HTML网页上呈现时，它将已经具有这两个字段的值。查看`form_valid`方法，然后从表单的`cleaned_data`属性中提取这两个值，并用它来获取提交和父评论以关联回复。
- en: 'The `get_context_data` method just adds the parent comment object to the context.
    We use it in the template to tell the user which comment they are replying to.
    Let''s look at the template, which you need to create in `links/templates/comment_reply.html`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_context_data`方法只是将父评论对象添加到上下文中。我们在模板中使用它来告诉用户他们正在回复哪条评论。让我们来看看模板，您需要在`links/templates/comment_reply.html`中创建它：'
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Nothing fancy here. Note how we use the `parent_comment` object that we passed
    in the `get_context_data` method of the view. It's good UI practice to make sure
    that the user is always given relevant information about the action that they
    are about to take.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么花哨的。请注意我们如何在视图的`get_context_data`方法中使用了`parent_comment`对象。确保用户始终获得有关他们即将采取的操作的相关信息是良好的UI实践。
- en: 'Import our new view in `discuss/urls.py`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`discuss/urls.py`中导入我们的新视图：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add this pattern to the URL patterns list:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 将此模式添加到URL模式列表中：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lastly, we need to give the user a link to get to this page. As we discussed
    before, we''ll be putting a link called **Reply** next to each comment on the
    submission detail page. To do so, note the following line in `links/templates/submission_detail.html`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要给用户一个链接来到达这个页面。正如我们之前讨论的那样，在提交详细信息页面的每条评论旁边放置一个名为**回复**的链接。为此，请注意`links/templates/submission_detail.html`中的以下行：
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Change it to the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE37]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we pass in the submission ID and parent comment ID using GET params
    when creating the URL. We did this with the comment form on the submission page
    as well. This is a common technique you'll use a lot when creating Django apps.
    These are the same URL parameters that we used in the comment reply view to populate
    the initial data for the form and access the parent comment object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在创建URL时使用GET参数传递提交ID和父评论ID。我们在提交页面上的评论表单中也是这样做的。这是在创建Django应用程序时经常使用的常见技术。这些是我们在评论回复视图中使用的相同URL参数，用于填充表单的初始数据并访问父评论对象。
- en: 'Let''s try it out. Click on **Reply** on one of the comments on the submission
    detail page. If you''ve closed the old submission details page, you can create
    a new submission and add some comments to it. By clicking on the `Reply` link,
    you''ll see a new page with a form for the comment body. Enter some text here
    and click on the `Submit` button. Remember the text that you entered. We''ll be
    looking for this next in the upcoming few steps. In my testing, I entered **Reply
    to Comment 1**. Let''s see what our submission details page looks with our new
    reply comment:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试一试。在提交详细页面的评论中，点击**回复**。如果您关闭了旧的提交详细页面，您可以创建一个新的提交并添加一些评论。点击`回复`链接，您将看到一个新页面，上面有评论正文的表单。在这里输入一些文本，然后点击`提交`按钮。记住您输入的文本。我们将在接下来的几个步骤中寻找它。在我的测试中，我输入了**回复评论1**。让我们看看我们的提交详细页面是如何显示我们的新回复评论的：
- en: '![Comments](img/00698_02_07.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![评论](img/00698_02_07.jpg)'
- en: 'It seems like it worked. However, if you look closely, you''ll notice that
    the reply we made (in my case, the **Reply to Comment 1** text) is shown at the
    end of the comments list. It should be shown after **Comment 1** and ideally indented
    a bit to the right as well to indicate the hierarchy. Let''s fix this. First,
    in the `get_context_data` method of `SubmissionDetailView` in the `links/views.py`
    file, note this line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来好像起作用了。但是，如果您仔细看，您会注意到我们做的回复（在我的情况下，**回复评论1**文本）显示在评论列表的末尾。它应该显示在**评论1**之后，并且最好向右缩进一点，以表示层次结构。让我们来修复这个问题。首先，在`links/views.py`文件的`SubmissionDetailView`的`get_context_data`方法中，注意这一行：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Change it to the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 将其更改为以下内容：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What we''ve done here is include only the comments that don''t have a parent
    comment. We do this by getting only comments that have the `in_reply_to` field
    set to `NULL`. If you save this change and refresh the submission detail page,
    you''ll notice that your reply comment will be gone. Let''s bring it back. Modify
    `link/templates/submission_detail.html` and change the paragraph that shows the
    comments (the one with the `for` loop over the comments list) to match the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的是只包括没有父评论的评论。我们通过只获取`in_reply_to`字段设置为`NULL`的评论来实现这一点。如果您保存此更改并刷新提交详细页面，您会注意到您的回复评论已经消失了。让我们把它带回来。修改`link/templates/submission_detail.html`并更改显示评论的段落（循环遍历评论列表的段落）以匹配以下内容：
- en: '[PRE40]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The new part here is between the `if` tag. First, we use the reverse relationship
    that is created by the foreign key to itself to see if this comment has any other
    comments pointing to it. We know that the only comments pointing to this comment
    would be replies to this comment. If there are, we then create a new list and
    print the body for each of the replies. As we''ve already decided that we only
    allow replies to the first level of comments, we don''t create any links to let
    users reply to the replies. Once you''ve save these changes, let''s see what our
    submission details page looks now:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新部分在`if`标签之间。首先，我们使用由外键自身创建的反向关系来查看此评论是否有任何其他指向它的评论。我们知道指向这条评论的唯一评论将是对这条评论的回复。如果有的话，我们将创建一个新列表，并打印每个回复的正文。由于我们已经决定只允许对第一级评论进行回复，我们不会创建任何链接让用户回复这些回复。一旦您保存了这些更改，让我们看看我们的提交详细页面现在是什么样子的：
- en: '![Comments](img/00698_02_08.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![评论](img/00698_02_08.jpg)'
- en: That's more like it! We now have a complete link submission and commenting system.
    Awesome! Let's move on to the other features now.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这更像是！我们现在有了一个完整的链接提交和评论系统。太棒了！现在让我们继续其他功能。
- en: Voting
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 投票
- en: We need to allow users to vote on submissions. To keep things simple, we'll
    only allow `upvotes`. A user can indicate that they like a submission. There is
    no way to indicate disapproval. This keeps the code and UI simple. We also want
    to ensure that one user can `upvote` a submission only once and they can remove
    their `upvotes` if they change their minds or upvoted a submission by mistake.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要允许用户对提交进行投票。为了保持简单，我们只允许`upvotes`。用户可以表示他们喜欢一个提交。没有办法表示不赞成。这样可以保持代码和用户界面的简单。我们还希望确保一个用户只能对一个提交进行一次`upvote`，并且如果他们改变主意或者错误地对一个提交进行了`upvote`，他们可以取消他们的`upvotes`。
- en: If you take another look at the `Link` model, you'll see we already have an
    `upvotes` field, which is a **Machine to machine** (**M2M**) with the `User` model.
    This is the only database entry we'll need to allow and keep track of `upvotes`
    by users. In order to upvote a submission, users will click on a link next to
    the submission. Until now, we were able to make do without a page to list all
    submissions. It's a good idea to create one now so that we can access and upvote
    the various submissions. We can't keep creating new submissions every time we
    want to test something.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您再看一下`Link`模型，您会看到我们已经有了一个`upvotes`字段，它是与`User`模型的**机器到机器**（**M2M**）关联。这是我们需要允许并跟踪用户的`upvotes`的唯一数据库条目。为了给提交投票，用户将点击提交旁边的一个链接。到目前为止，我们能够在没有列出所有提交的页面的情况下进行。现在创建一个是个好主意，这样我们就可以访问和投票各种提交。我们不能每次想测试某些东西时都创建新的提交。
- en: 'First, create this view in `links/views.py`. Remember to import `TemplateView`
    from `django.views.generic` first:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在`links/views.py`中创建此视图。首先从`django.views.generic`导入`TemplateView`：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, change the template at `template/home.html` to the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将模板更改为`template/home.html`如下：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Import our new `HomeView` at the top of `discuss/urls.py` and note the home
    URL configuration in `discuss/urls.py`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在`discuss/urls.py`的顶部导入我们的新`HomeView`，并注意`discuss/urls.py`中的主页URL配置：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Change the preceding code to this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的代码更改为：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, let''s provide our users with a handy link to the home page in the
    navigation bar. In the `base.html` template (in the `templates` directory in the
    project root), add this as the first list element of the navigation list outside
    of the user authentication if condition:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在导航栏中为我们的用户提供一个方便的链接到主页。在`base.html`模板（在项目根目录的`templates`目录中）中，将这个作为导航列表的第一个列表元素添加到用户认证条件之外：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'That''s it. There''s nothing new in this code. It''s pretty easy to understand
    and you should have a clear idea of what''s happening here by now. Let''s look
    at the end result. If you now open the home page of our app by browsing to `http://127.0.0.1:8000`
    in your browser, you should see something similar to the following screenshot.
    Of course, your page will not be the same as this as you will have added your
    own test content:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样。这段代码中没有什么新东西。它很容易理解，你现在应该对这里发生的事情有一个清晰的想法。让我们看看最终结果。如果你现在通过浏览器打开我们应用的主页，浏览到`http://127.0.0.1:8000`，你应该会看到类似以下截图的内容。当然，你的页面不会和这个一样，因为你会添加自己的测试内容：
- en: '![Voting](img/00698_02_09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![投票](img/00698_02_09.jpg)'
- en: You'll see a list of submissions. If you click on any, you'll have a new tab
    open with the link for that submission. You'll also see a **Comments** link next
    to each submission. Clicking on this takes you to the submission detail page.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个提交列表。如果你点击任何一个，你会在新标签页中看到该提交的链接。你还会看到每个提交旁边有一个**评论**链接。点击这个链接会带你到提交的详细页面。
- en: Let's talk a bit about how we're going to implement the upvoting feature. The
    M2M `upvotes` field that we created in the `Link` model should give you a hint.
    Whenever a user `upvotes` a submission, we add them to this relationship. As an
    M2M relationship ensures that if we add the same object multiple times it doesn't
    create a new record, we easily ensure that one user can vote on a submission only
    once.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微谈谈我们将如何实现投票功能。我们在`Link`模型中创建的M2M `upvotes`字段应该给你一些提示。每当用户给一个提交投票，我们就将他们添加到这个关系中。由于M2M关系确保如果我们多次添加相同的对象，它不会创建一个新记录，我们很容易确保一个用户只能对一个提交投票一次。
- en: Let's create a view that adds the logged in user to the upvoters list of a submission
    and then takes them back to the home page. We'll also add a link to each submission
    on the home page that lets the user upvote the submission with this new view.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个视图，将已登录用户添加到提交的投票者列表中，然后将他们带回到主页。我们还将在主页上为每个提交添加一个链接，让用户使用这个新视图对提交进行投票。
- en: 'In `links/views.py`, import the `View` generic view class from `django.views.generic`,
    and then create this view:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在`links/views.py`中，从`django.views.generic`中导入`View`通用视图类，然后创建这个视图：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, import this new view in `discuss/urls.py` and add it to the URL patterns
    :'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`discuss/urls.py`中导入这个新视图，并将其添加到URL模式中：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `templates/home.html`, add the **Upvote** link above the submission title
    link:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templates/home.html`中，在提交标题链接上方添加**投票**链接：
- en: '[PRE48]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Open up the home page and you''ll see an **Upvote** link next to each submission
    title. Clicking on the link should bring you back to the home page. It should
    look similar to the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 打开主页，你会看到每个提交标题旁边有一个**投票**链接。点击链接应该会带你回到主页。它应该看起来类似以下截图：
- en: '![Voting](img/00698_02_10.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![投票](img/00698_02_10.jpg)'
- en: 'If you upvote a link, it immediately brings you back to the home page without
    any indication that your upvote was recorded. The fix for this is simple. Change
    the Upvote link HTML line that you just added to the home page template to the
    following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你给一个链接投票，它会立即带你回到主页，而没有任何提示表明你的投票已经记录下来。这个问题的解决方法很简单。将刚刚添加到主页模板的**投票**链接HTML行更改为以下内容：
- en: '[PRE49]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'If you open up the home page again, you''ll see a simple **Upvoted** text next
    to submissions that you''ve already upvoted instead of the link that you saw before.
    We should also allow the user to remove his upvote from a submission. First, create
    a new view for this in `links/views.py`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次打开主页，你会看到已经投票的提交旁边有一个简单的**已投票**文本，而不是之前看到的链接。我们还应该允许用户取消对提交的投票。首先，在`links/views.py`中创建一个新的视图：
- en: '[PRE50]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is almost the same as the view we created to record a new upvote. The
    only difference is that here we use the remove method of the related manager.
    Next, we''ll need to add this to the URLs file at `discuss/urls.py`. Import our
    new view here and add the following URL configuration:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们创建的用于记录新投票的视图相同。唯一的区别是这里我们使用相关管理器的移除方法。接下来，我们需要将其添加到`discuss/urls.py`的URL文件中。在这里导入我们的新视图，并添加以下URL配置：
- en: '[PRE51]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, let''s change the **Upvoted** label that we added to the home page
    before to be a link to remove the upvote. In your `templates/home.html` file,
    note these lines:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将之前在主页上添加的**已投票**标签更改为一个链接，以取消投票。在你的`templates/home.html`文件中，注意以下几行：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Change them to the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们更改为以下内容：
- en: '[PRE53]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: That's it! Now when you visit the home page, you'll see the **Remove Upvote**
    link for all the submissions that you have already upvoted. By clicking on the
    link, you'll be redirected back to the home page with your upvote removed. You
    should see the **Upvote** link for that submission again as you can upvote it
    again.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在当你访问主页时，你会看到所有你已经投票的提交旁边的**取消投票**链接。点击链接，你将被重定向回主页，你的投票将被取消。你应该再次看到该提交的**投票**链接，因为你可以再次投票。
- en: Ranking submission
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交排名
- en: 'The next feature on our list is ranking the submissions using an intelligent
    algorithm. Let''s take a look at what our feature description requires:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列表中的下一个功能是使用智能算法对提交进行排名。让我们看看我们的功能描述需要什么：
- en: Tip
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: An algorithm to rank the submitted links in some defined order that depends
    on a number of factors including the votes for that link, the number of comments
    and the age of the submission
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一种算法，用于根据一些因素的数量，包括该链接的投票数、评论数和提交的年龄，以某种定义的顺序对提交的链接进行排名
- en: 'We have all this information in our database. We need to create an algorithm
    that will use all these pieces of information to give each submission a rank.
    Then, we''ll just sort the submission using this ranking and show them in the
    sorted order. To keep things simple, let''s use the following algorithm:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的数据库中有所有这些信息。我们需要创建一个算法，利用所有这些信息给每个提交一个排名。然后，我们只需使用这个排名对提交进行排序，并按排序顺序显示它们。为了保持简单，让我们使用以下算法：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Seems simple enough, except for maybe the number of days since submission calculations.
    However, the `datetime` module in the Python standard library makes this a breeze
    for us. In Python, if you subtract two `datetime` objects, you get a `timedelta`
    object. This object represents the time difference between the two `datetime`
    objects. It has an attribute called `days` that—as is obvious by the name—holds
    the number of days between the two dates. We'll subtract the date that we get
    from `datetime.datetime.now()` from the `submitted_on` field of the submission
    and use the `days` attribute of the resulting `timedelta` object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很简单，除了可能是自提交以来的天数计算。然而，Python标准库中的`datetime`模块让我们轻而易举地做到了这一点。在Python中，如果你减去两个`datetime`对象，你会得到一个`timedelta`对象。这个对象表示两个`datetime`对象之间的时间差。它有一个名为`days`的属性，这个属性保存了两个日期之间的天数。我们将从`datetime.datetime.now()`得到的日期减去提交的`submitted_on`字段，并使用结果`timedelta`对象的`days`属性。
- en: 'Let''s plug this algorithm into our home view so that our submissions are listed
    by their ranks. Change `HomeView` in `links/views.py` to match the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个算法插入到我们的主页视图中，这样我们的提交将按照它们的排名列出。将`links/views.py`中的`HomeView`更改为以下代码：
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You will also need to import the `timezone` module from Django utilities using
    the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要使用以下方式从Django实用程序中导入`timezone`模块：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This is needed because Django uses something called `timezone` aware `datetimes`.
    For more details on this, read the Django documentation for `timezone` awareness
    at [https://docs.djangoproject.com/en/stable/topics/i18n/timezones/#naive-and-aware-datetime-objects](https://docs.djangoproject.com/en/stable/topics/i18n/timezones/#naive-and-aware-datetime-objects).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为Django使用了所谓的`timezone`感知`datetimes`。有关此内容的更多详细信息，请阅读Django关于`timezone`感知的文档[https://docs.djangoproject.com/en/stable/topics/i18n/timezones/#naive-and-aware-datetime-objects](https://docs.djangoproject.com/en/stable/topics/i18n/timezones/#naive-and-aware-datetime-objects)。
- en: This new code might look a bit complicated but trust me, it's pretty simple.
    Let's look at it one line at a time. The first thing we do is get the current
    date time using the `timezone.now()` function. Next, we get all the submissions
    that we want to show on the home page and start looping over them.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段新代码可能看起来有点复杂，但相信我，它非常简单。让我们一行一行地看一下。我们首先使用`timezone.now()`函数获取当前日期时间。接下来，我们获取我们想要在主页上显示的所有提交，并开始循环遍历它们。
- en: In the loop, we first calculate the number of votes and comments on the submission
    using the `count()` method that you have seen before on Django `querysets`. The
    only different thing here is that we use it on the queryset returned by the `RelatedManager`
    object for the many-to-many upvotes field and the reverse relationship to the
    comments model.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中，我们首先使用`count()`方法计算提交的投票数和评论数，这是您之前在Django `querysets`上看到的。这里唯一不同的是，我们将其用于`RelatedManager`对象返回的查询集，用于多对多的upvotes字段和与评论模型的反向关系。
- en: As explained before, we then calculate the number of days since the submission
    was submitted to our site using the Python date arithmetic. Finally, we calculate
    and assign the rank for the submission to the object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们然后使用Python日期算术计算自提交以来的天数。最后，我们计算并分配提交的排名给对象。
- en: After the loop ends, each of our `Link` objects has a rank attribute that holds
    the final ranking for it. We then use the Python built-in `sorted` function to
    sort this list. When you're working with lists, which is quite often in Python
    and Django, the sorted function is something you will end up using many times.
    You should familiarize yourself with its syntax and features by reading the documentation
    at [https://docs.python.org/3/library/functions.html#sorted](https://docs.python.org/3/library/functions.html#sorted).
    Trust me, it's well worth the time to read this documentation slowly and understand
    it completely. I have used the `sorted` built-in function more times than I can
    remember. It's indispensable.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结束后，我们的每个`Link`对象都有一个`rank`属性，保存了它的最终排名。然后我们使用Python内置的`sorted`函数对这个列表进行排序。当你在Python和Django中经常使用列表时，`sorted`函数是你会经常使用的东西。你应该通过阅读文档来熟悉它的语法和特性[https://docs.python.org/3/library/functions.html#sorted](https://docs.python.org/3/library/functions.html#sorted)。相信我，慢慢阅读这份文档并完全理解它是非常值得的。我使用`sorted`内置函数的次数已经数不清了。它是不可或缺的。
- en: Finally, we assign the sorted submissions list to the `submissions` context
    variable. As we are already using this variable in the home page template, we
    do not need to change anything else beyond `HomeView`. If you open the home page
    now, you'll see that the sorting order of the submissions has changed and now
    reflects our new algorithm.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将排序后的提交列表分配给`submissions`上下文变量。因为我们已经在主页模板中使用了这个变量，所以我们不需要改变`HomeView`之外的任何东西。如果你现在打开主页，你会看到提交的排序顺序已经改变，现在反映了我们的新算法。
- en: This is a good place to reflect upon the benefits of the modularity provided
    by the Model-View-Template architecture used by Django. As you can see, we added
    quite a significant feature, but we never had to change the URLs or templates
    for the home page. As these are individual modules, we only changed the view code
    and everything else still worked with our new and improved sorting order.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的地方，可以反映Django使用的模型-视图-模板架构提供的模块化的好处。正如你所看到的，我们添加了一个相当重要的功能，但我们从未改变过主页的URL或模板。因为这些是独立的模块，我们只改变了视图代码，其他一切仍然可以与我们的新的和改进的排序顺序一起工作。
- en: Spam protection
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 垃圾邮件保护
- en: The last feature that we want to have in our application is spam protection.
    We want users to be able to post content on our site, but we want to prevent abuse
    by spammers. Spamming, as you probably know, refers to malicious Internet users
    posting inappropriate or irrelevant content to a site. Often, spammers use scripts
    created specifically to target sites that allow user-submitted content, such as
    our web app. While we can't stop spammers easily from submitting spam content
    to our site manually, we can make sure that they are not able to use scripts to
    generate a lot of spam with just a click of the mouse. Usually, if spammers can't
    use their scripts on websites, they move on to easier targets.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要在我们的应用程序中拥有的最后一个功能是垃圾邮件保护。我们希望用户能够在我们的网站上发布内容，但我们希望防止垃圾邮件滥用。垃圾邮件，你可能知道，是指恶意的互联网用户在网站上发布不当或无关的内容。通常，垃圾邮件发送者使用专门针对允许用户提交内容的网站创建的脚本，比如我们的网页应用程序。虽然我们不能轻易地阻止垃圾邮件发送者手动向我们的网站提交垃圾邮件内容，但我们可以确保他们无法使用脚本一键生成大量垃圾邮件。通常情况下，如果垃圾邮件发送者无法在网站上使用他们的脚本，他们会转向更容易的目标。
- en: The important concept that I want you to learn from this feature isn't how to
    implement spam protection. That's something you need to decide based on the requirements
    of your own project. What I'll be showing here is how to use open source Django
    applications created by other developers to add features to your own Django projects.
    This is an important concept that you should be familiar with. Most of the time,
    if you're looking for ways to solve an issue while developing your web app, a
    search of the Internet turns up a number of open source applications that were
    developed by other programmers to solve the same issue. You get applications solving
    all sizes of issues—from the smallest providing features such as a new type of
    form field (for example, a calendar form field that uses a JavaScript calendar)
    to large applications providing complete Django-based forums that you can integrate
    with your Django website easily and provide users with an easy-to-use and good-looking
    forum.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我想让你从这个功能中学到的重要概念不是如何实现垃圾邮件保护。这是你根据自己项目的需求来决定的事情。我将在这里展示如何使用其他开发人员创建的开源Django应用程序来为您自己的Django项目添加功能。这是一个你应该熟悉的重要概念。大多数情况下，如果你在开发网页应用程序时寻找解决问题的方法，搜索互联网会找到许多其他程序员开发的开源应用程序，用于解决相同的问题。你可以找到解决各种问题的应用程序，从提供新类型的表单字段（例如，使用JavaScript日历的日历表单字段）到提供完整的基于Django的论坛应用程序，你可以轻松集成到你的Django网站中，并为用户提供易于使用和外观良好的论坛。
- en: We'll be using the `ReCaptcha` service from Google to provide us with a mechanism
    to stop spammers. You can learn more about the service at [https://www.google.com/recaptcha](https://www.google.com/recaptcha).
    You will also need to register for an account here and create an API key. It will
    ask for a label, which I set to **Discuss Django Blueprints**, and a domain, which
    I set to `127.0.0.1`. The `owners` field should have your e-mail address there.
    Once you submit this form, you'll be presented with a screen that shows you your
    public and private keys. Keep this page open as we'll use these values in a bit.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用谷歌的`ReCaptcha`服务来为我们提供一个阻止垃圾邮件的机制。你可以在[https://www.google.com/recaptcha](https://www.google.com/recaptcha)了解更多关于这项服务。你还需要在这里注册一个账户并创建一个API密钥。它会要求一个标签，我设置为**讨论Django蓝图**，一个域，我设置为`127.0.0.1`。`所有者`字段应该有你的电子邮件地址。一旦你提交了这个表单，你将看到一个屏幕，显示你的公钥和私钥。保持这个页面打开，因为我们一会儿会用到这些值。
- en: 'Next, we need to find a Django application that allows us to use the ReCaptcha
    service. A Google search led me to [https://github.com/praekelt/django-recaptcha](https://github.com/praekelt/django-recaptcha).
    It seems like a well-maintained and simple solution to our problem. In order to
    use it, we first have to install it in our virtual environment. On your command
    line, make sure that you have the virtual environment active. Then, install this
    package using the following `pip` command:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要找到一个Django应用程序，允许我们使用ReCaptcha服务。谷歌搜索引导我到[https://github.com/praekelt/django-recaptcha](https://github.com/praekelt/django-recaptcha)。这似乎是一个维护良好且简单的解决方案。为了使用它，我们首先必须在我们的虚拟环境中安装它。在命令行上，确保你的虚拟环境是激活的。然后，使用以下`pip`命令安装这个软件包：
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This will install the package. Next, add `captcha` to the list of `INSTALLED_A`PPS
    in your `discuss/settings.py` file. Also, add the `RECAPTCHA_PUBLIC_KEY` and `RECAPTCHA_PRIVATE_KEY`
    variables to the settings file. Set their values to the appropriate keys that
    you were given on the Google ReCaptcha API keys page that I asked you to keep
    open before. **Site Key** is the public key and **Secret Key** is the private
    key. Finally, in your `settings.py` file, set the following variable:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装该软件包。接下来，在`discuss/settings.py`文件中将`captcha`添加到`INSTALLED_APPS`列表中。还要在设置文件中添加`RECAPTCHA_PUBLIC_KEY`和`RECAPTCHA_PRIVATE_KEY`变量。将它们的值设置为我之前要求你保持打开的Google
    ReCaptcha API密钥页面上给你的适当密钥。**站点密钥**是公钥，**秘密密钥**是私钥。最后，在你的`settings.py`文件中，设置以下变量：
- en: '[PRE58]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The setup is ready. We''re ready to use `ReCaptcha` in our forms. For demonstration,
    I''ll only add it to the comment form that you can see on the submission detail
    page. Open up `links/forms.py` and add this import to the top:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 设置完成了。我们准备在我们的表单中使用`ReCaptcha`。为了演示，我只会将它添加到你在提交详细页面上看到的评论表单中。打开`links/forms.py`并在顶部添加这个导入：
- en: '[PRE59]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, add this field to `CommentModelForm`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将这个字段添加到`CommentModelForm`中：
- en: '[PRE60]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'That''s it! You have successfully added Google `ReCaptcha` to your website!
    Let''s try it out. Open up the details page for any submission and now, right
    below the body field that we had previously for the comment, you''ll see the Google
    `ReCaptcha` box as well:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！你已经成功地将Google的`ReCaptcha`添加到你的网站上！让我们试试看。打开任何提交的详细页面，现在，在我们之前用于评论的正文字段下面，你会看到Google的`ReCaptcha`框：
- en: '![Spam protection](img/00698_02_11.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![垃圾邮件保护](img/00698_02_11.jpg)'
- en: Now, if you submit the form without selecting the **I am not a robot checkbox**,
    you'll be taken to the comment form page with an error message saying that the
    captcha field is required. You won't be able to submit your comment until you
    select this box.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您在不选择**我不是机器人复选框**的情况下提交表单，您将被带到评论表单页面，并显示错误消息，指出需要填写验证码字段。在选择此框之前，您将无法提交评论。
- en: There are two takeaways from adding the `ReCaptcha` to our site. Firstly, notice
    how easy it was for us to add a relatively complicated feature using the open
    source code contributed by another programmer. Secondly, notice how—because of
    the modularity that Django provides and the separation between the template and
    code—all we had to do to include the `ReCaptcha` widget was add it to the form.
    We didn't even need to change the view code or template. It all worked.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从将“ReCaptcha”添加到我们的网站中，我们可以得出两个要点。首先，请注意，我们使用另一位程序员贡献的开源代码轻松地添加了一个相对复杂的功能。其次，请注意，由于Django提供的模块化和模板与代码之间的分离，我们只需将“ReCaptcha”小部件添加到表单中即可。我们甚至不需要更改视图代码或模板。一切都很顺利。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a pretty interesting chapter. You learned a lot more about the built-in
    generic view provided by Django and looked in detail into `ModelForms` and how
    we could customize them. We figured out some benefits of the modular MVC pattern
    that Django follows and third-party open source Django applications and how we
    can include them in our projects.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有趣的章节。您学到了更多关于Django提供的内置通用视图，并详细了解了“ModelForms”以及我们如何自定义它们。我们找出了Django遵循的模块化MVC模式和第三方开源Django应用程序的一些好处，以及我们如何将它们包含在我们的项目中。
- en: You also learned a great deal about how to pass data to our forms even when
    they are placed on separate pages and how to create a form that is displayed on
    two pages (the comment form) while making sure that the data is synchronized between
    both.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学到了如何在我们的表单上传递数据，即使它们放在不同的页面上，以及如何创建一个显示在两个页面上的表单（评论表单），同时确保数据在两者之间同步。
- en: All in all, the application that we ended up creating was both fun to program
    and a complete product.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，我们最终创建的应用程序既有趣又是一个完整的产品。
