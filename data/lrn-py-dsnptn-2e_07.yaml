- en: Chapter 7. The Command Pattern – Encapsulating Invocation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 命令模式 – 封装调用
- en: In the previous chapter, we started with an introduction to behavioral design
    patterns. You learned the concept of `Observers` and discussed the Observer design
    pattern. We understood the concept of the Observer design pattern with a UML diagram
    and also learned how it's applied in the real world with the help of Python implementations.
    We discussed the pros and cons of the Observer pattern. You also learned about
    the Observer pattern with an FAQ section and summarized the discussion at the
    end of the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始介绍行为设计模式。你学习了`观察者`的概念，并讨论了观察者设计模式。我们通过UML图理解了观察者设计模式，并借助Python实现学习了它在现实世界中的应用。我们讨论了观察者模式的优缺点。你还在本章的常见问题解答部分学习了观察者模式，并在章节末尾总结了讨论内容。
- en: In this chapter, we will talk about the Command design pattern. Like the Observer
    pattern, the Command pattern falls under the hood of Behavioral patterns. We will
    get introduced to the Command design pattern and discuss how it is used in software
    application development. We will work with a sample use case and implement it
    in Python v3.5.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论命令设计模式。与观察者模式一样，命令模式属于行为模式范畴。我们将介绍命令设计模式，并讨论它在软件开发中的应用。我们将通过一个示例用例并使用Python
    3.5实现它。
- en: 'In this chapter, we will cover the following topics in brief:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将简要介绍以下内容：
- en: An introduction to Command design patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令设计模式的简介
- en: The Command pattern and its UML diagram
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式及其UML图
- en: A real-world use case with the Python v3.5 code implementation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python 3.5代码实现的现实世界用例
- en: The Command pattern's pros and cons
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式的优缺点
- en: Frequently asked questions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见问题解答
- en: Introducing the Command pattern
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍命令模式
- en: 'As we saw in the previous chapter, Behavioral patterns focus on the responsibilities
    that an object has. It deals with the interaction among objects to achieve larger
    functionality. The Command pattern is a behavioral design pattern in which an
    object is used to encapsulate all the information needed to perform an action
    or trigger an event at a later time. This information includes the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，行为模式关注对象所拥有的职责。它处理对象之间的交互以实现更大的功能。命令模式是一种行为设计模式，其中使用一个对象来封装执行动作或触发事件所需的所有信息，以便在稍后时间执行。这些信息包括以下内容：
- en: The method name
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名称
- en: An object that owns the method
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有方法的对象
- en: Values for method parameters
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法参数的值
- en: Let's understand the pattern with a very simple software example. Consider the
    case of an installation wizard. A typical wizard may contain multiple phases or
    screens that capture a user's preferences. While the user browses through the
    wizard, s/he makes certain choices. Wizards are typically implemented with the
    Command pattern. A wizard is first launched with an object called the `Command`
    object. The preferences or choices made by the user in multiple phases of the
    wizard are then stored in the `Command` object. When the user clicks on the **Finish**
    button on the last screen of the wizard, the `Command` object runs an `execute()`
    method, which considers all the stored choices and runs the appropriate installation
    procedure. Thus, all the information regarding the choices are encapsulated in
    an object that can be used later to take an action.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个非常简单的软件示例来理解这个模式。考虑安装向导的情况。一个典型的向导可能包含多个阶段或屏幕，用于捕获用户的偏好。当用户浏览向导时，他们会做出某些选择。向导通常使用命令模式实现。向导首先由一个名为`Command`的对象启动。用户在向导的多个阶段做出的偏好或选择随后被存储在`Command`对象中。当用户在向导的最后屏幕上点击**完成**按钮时，`Command`对象运行一个`execute()`方法，该方法考虑所有存储的选择并运行适当的安装程序。因此，所有关于选择的信息都被封装在一个对象中，可以在以后采取行动时使用。
- en: Another easy example is that of the printer spooler. A spooler can be implemented
    as a `Command` object that stores information such as the page type (*A5*-*A1*),
    portrait/landscape, collated/non-collated. When the user prints something (say,
    an image), the spooler runs the `execute()` method on the `Command` object and
    the image is printed with the set preferences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单的例子是打印机打印队列。打印队列可以作为存储诸如页面类型（*A5*-*A1*）、纵向/横向、整理/未整理等信息的一个`Command`对象实现。当用户打印某些内容（例如，一张图片）时，打印队列在`Command`对象上运行`execute()`方法，并按照设定的偏好打印图片。
- en: Understanding the Command design pattern
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解命令设计模式
- en: 'The Command pattern works with the following terms—`Command`, `Receiver`, `Invoker`,
    and `Client`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式与以下术语一起工作—`Command`、`Receiver`、`Invoker`和`Client`：
- en: A `Command` object knows about the `Receiver` objects and invokes a method of
    the `Receiver` object.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`Command`对象了解`Receiver`对象并调用`Receiver`对象的方法。
- en: Values for parameters of the receiver method are stored in the `Command` object
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收者方法参数的值存储在`Command`对象中
- en: The invoker knows how to execute a command
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoker`知道如何执行一个命令'
- en: The client creates a `Command` object and sets its receiver
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端创建一个`Command`对象并设置其接收者
- en: 'The main intentions of the Command pattern are as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式的主要意图如下：
- en: Encapsulating a request as an object
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求封装为对象
- en: Allowing the parameterization of clients with different requests
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许客户端使用不同的请求进行参数化
- en: Allowing to save the requests in a queue (we will talk about this later in the
    chapter)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许将请求保存到队列中（我们将在本章后面讨论这个问题）
- en: Providing an object-oriented callback
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供面向对象的回调
- en: 'The Command pattern can be used in the following multiple scenarios:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式可以在以下多个场景中使用：
- en: Parameterizing objects depending on the action to be performed
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据要执行的操作参数化对象
- en: Adding actions to a queue and executing requests at different points
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在队列中添加动作并在不同的点执行请求
- en: Creating a structure for high-level operations that are based on smaller operations
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为基于较小操作的高级操作创建结构
- en: 'The following Python code implements the Command design pattern. We talked
    about the example of the wizard earlier in the chapter. Consider that we want
    to develop a wizard for installation or, popularly, installer. Typically, an installation
    implies the copying or moving of files in the filesystem based on the choices
    that a user makes. In the following example, in the client code, we start by creating
    the `Wizard` object and use the `preferences()` method that stores the choices
    made by the user during various screens of the wizard. On the wizard, when **Finish**
    button is clicked, the `execute()` method is called. The `execute()` method picks
    up the preference and starts the installation:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Python 代码实现了命令设计模式。我们在本章前面讨论了巫师的例子。假设我们想要开发一个用于安装或通常所说的安装程序。通常，安装意味着根据用户的选择在文件系统中复制或移动文件。在下面的例子中，在客户端代码中，我们首先创建`Wizard`对象并使用`preferences()`方法，该方法存储用户在巫师的各种屏幕上做出的选择。在巫师中，当点击**完成**按钮时，调用`execute()`方法。`execute()`方法获取偏好设置并开始安装：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![Understanding the Command design pattern](img/00023.jpeg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![理解命令设计模式](img/00023.jpeg)'
- en: A UML class diagram for the Command pattern
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令模式的 UML 类图
- en: Let's now understand more about the Command pattern with the help of the following
    UML diagram.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助以下 UML 图更深入地了解命令模式。
- en: 'As we discussed in the previous paragraph, the Command pattern has these main
    participants: the `Command`, `ConcreteCommand`, `Receiver`, `Invoker`, and `Client`.
    Let''s put these in a UML diagram and see how the classes look:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一段所述，命令模式有这些主要参与者：`Command`、`ConcreteCommand`、`Receiver`、`Invoker`和`Client`。让我们将这些放入
    UML 图中，看看类是如何看起来：
- en: '![A UML class diagram for the Command pattern](img/00024.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![命令模式的 UML 类图](img/00024.jpeg)'
- en: 'As we look at the UML diagram, you''ll realize that there are five main participants
    in this pattern:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看 UML 图时，你会意识到这个模式中有五个主要参与者：
- en: '`Command`: This declares an interface to execute an operation'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`：这个声明了一个执行操作的接口'
- en: '`ConcreteCommand`: This defines a binding between the `Receiver` object and
    action'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteCommand`：这个定义了`Receiver`对象和动作之间的绑定'
- en: '`Client`: This creates a `ConcreteCommand` object and sets its receiver'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Client`：这个创建一个`ConcreteCommand`对象并设置其接收者'
- en: '`Invoker`: This asks `ConcreteCommand` to carry out the request'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Invoker`：这个请求`ConcreteCommand`执行请求'
- en: '`Receiver`: This knows how to perform the operations associated with carrying
    out the request'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Receiver`：这个知道如何执行与执行请求相关的操作'
- en: 'The flow is straightforward. The client asks for a command to be executed.
    The invoker takes the command, encapsulates it, and places it in a queue. The
    `ConcreteCommand` class is in charge of the requested command and asks the receiver
    to perform the given action. The following code example is to understand the pattern
    with all the participants involved:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 流程很简单。客户端请求执行一个命令。调用者接收命令，封装它，并将其放入队列。`ConcreteCommand`类负责请求的命令，并要求接收者执行给定的操作。以下代码示例用于理解所有参与者都参与的模式：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Implementing the Command pattern in the real world
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在现实世界中实现命令模式
- en: We will take up an example of the stock exchange (much talked about in the Internet
    world) to demonstrate the implementation of the Command pattern. What happens
    in a stock exchange? You, as a user of the stock exchange, create orders to buy
    or sell stocks. Typically, you don't buy or sell them; it's the agent or broker
    who plays the intermediary between you and the stock exchange. The agent is responsible
    for taking your request to the stock exchange and getting the work done. Imagine
    that you want to sell a stock on Monday morning when the exchange opens up. You
    can still make the request to sell stock on Sunday night to your agent even though
    the exchange is not yet open. The agent then queues this request to be executed
    on Monday morning when the exchange is open for the trading. This presents a classical
    case for the Command pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以股票交易所（在互联网世界中广为人知）为例，演示命令模式的实现。在股票交易所中会发生什么？作为股票交易所的用户，你创建买卖股票的订单。通常，你不会直接买卖股票；这是代理或经纪人作为你在股票交易所之间的中介。代理负责将你的请求带到股票交易所并完成工作。想象一下，你想在周一早上交易所开盘时卖出股票。即使交易所还没有开盘，你仍然可以在周日晚上向你的代理提出卖出股票的请求。然后代理将这个请求排队，以便在交易所开盘进行交易时执行。这是一个经典的命令模式案例。
- en: Design considerations
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计考虑因素
- en: Based on the UML diagram, you learned that the Command pattern has four main
    participants—`Command`, `ConcreteCommand`, `Invoker`, and `Receiver`. For the
    preceding scenario, we should create an `Order` interface that defines the order
    that a client places. We should define `ConcreteCommand` classes to buy or sell
    a stock. A class also needs to be defined for the stock exchange. We should define
    the `Receiver` class that will actually execute the trade and the agent (known
    as the invoker) that invokes the order and gets it executed by the receiver.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据UML图，你了解到命令模式有四个主要参与者——`Command`、`ConcreteCommand`、`Invoker`和`Receiver`。对于前面的场景，我们应该创建一个`Order`接口来定义客户放置的订单。我们应该定义用于买卖股票的`ConcreteCommand`类。还需要定义一个代表证券交易所的类。我们应该定义一个将实际执行交易和代理（也称为调用者）的`Receiver`类，该代理调用订单并通过接收者执行它。
- en: 'Let''s develop an application in Python v3.5 and implement the preceding use
    case. We start with the `Command` object, `Order`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Python 3.5中开发一个应用程序并实现前面的用例。我们首先从`Command`对象`Order`开始：
- en: The `Command` object is represented by the `Order` class
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Command`对象由`Order`类表示'
- en: '`Order` provides you with an interface (Python''s abstract base class) so that
    `ConcreteCommand` can implement the behavior'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Order`提供了一个接口（Python的抽象基类），以便`ConcreteCommand`可以实现行为'
- en: The `execute()` method is the abstract method that needs to be defined by the
    `ConcreteCommand` classes to execute the `Order` class
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute()`方法是`ConcreteCommand`类需要定义的抽象方法，用于执行`Order`类'
- en: 'The following code represents the abstract class `Order` and the abstract method
    `execute()`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码表示抽象类`Order`和抽象方法`execute()`：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have also developed certain classes that represent `ConcreteCommand`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还开发了一些代表`ConcreteCommand`的类：
- en: 'In this case, we have two main concrete classes: `BuyStockOrder` and `SellStockOrder`
    that implement the `Order` interface'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有两个主要的具体类：`BuyStockOrder`和`SellStockOrder`，它们实现了`Order`接口
- en: Both the `ConcreteCommand` classes use the object of the stock trading system
    so that they can define appropriate actions for the trading system
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个`ConcreteCommand`类都使用股票交易系统的对象，以便它们可以为交易系统定义适当的操作
- en: The `execute()` method of each of these `ConcreteCommand` classes uses the stock
    trade object to execute the actions to buy and sell
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些`ConcreteCommand`类的每个`execute()`方法都使用股票交易对象来执行买卖操作
- en: 'Let''s now look at concrete classes that implement the interface:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看实现该接口的具体类：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, let''s talk about the stock trading system and how it''s implemented:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们谈谈股票交易系统及其实现方式：
- en: The `StockTrade` class represents the `Receiver` object in this example
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个例子中，`StockTrade`类代表`Receiver`对象
- en: It defines multiple methods (actions) to execute the orders placed by `ConcreteCommand`
    objects
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它定义了多个方法（动作）来执行`ConcreteCommand`对象放置的订单
- en: The `buy()` and `sell()` methods are defined by the receiver which are called
    by `BuyStockOrder` and `SellStockOrder` respectively to buy or sell the stock
    in the exchange
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buy()`和`sell()`方法由接收者定义，分别由`BuyStockOrder`和`SellStockOrder`调用以在交易所买卖股票'
- en: 'Let''s take a look at the `StockTrade` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`StockTrade`类：
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Another part of the implementation is the invoker:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的另一个部分是调用者：
- en: The `Agent` class represents the invoker.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent`类代表调用者。'
- en: Agent is the intermediary between the client and `StockExchange` and executes
    the orders placed by the client.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent`是客户端和`StockExchange`之间的中介，执行客户端放置的订单。'
- en: Agent defines a data member, `__orderQueue` (a list), that acts as a queue.
    Any new orders placed by the client are added to the queue.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent`定义了一个数据成员`__orderQueue`（一个列表），它充当队列。任何由客户端放置的新订单都会添加到队列中。'
- en: The `placeOrder()` method of Agent is responsible for queuing the orders and
    also executing the orders.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent`的`placeOrder()`方法负责排队订单并执行订单。'
- en: 'The following code depicts the `Agent` class which performs the role of `Invoker`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码描述了执行`Invoker`角色的`Agent`类：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let us now put all the above classes into perspective and look at how the client
    is implemented:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所有上述类放在一起，看看客户端是如何实现的：
- en: The client first sets its receiver, the `StockTrade` class
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端首先设置其接收者，即`StockTrade`类
- en: It creates orders to buy and sell stocks with `BuyStockOrder` and `SellStockOrder`
    (`ConcreteCommand`) that executes the action on `StockTrade`
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`BuyStockOrder`和`SellStockOrder`（`ConcreteCommand`）创建买卖股票的订单，这些订单在`StockTrade`上执行动作
- en: The invoker object is created by instantiating the `Agent` class
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过实例化`Agent`类创建调用者对象
- en: The `placeOrder()` method of `Agent` is used to get the orders that the client
    places
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Agent`的`placeOrder()`方法用于获取客户端放置的订单'
- en: 'The following is the code for the client is implemented:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为客户端实现的代码：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output of the preceding code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是前面代码的输出：
- en: '![Design considerations](img/00025.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![设计考虑因素](img/00025.jpeg)'
- en: 'There are multiple ways in which the Command pattern is used in software applications.
    We will discuss two specific implementations that are very relevant to the cloud
    applications:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式在软件应用中有多种使用方式。我们将讨论两个与云应用非常相关的特定实现：
- en: 'Redo or rollback operations:'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重做或回滚操作：
- en: While implementing the rollback or redo operations, developers can do two different
    things.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实现回滚或重做操作时，开发者可以执行两种不同的操作。
- en: These are to create a snapshot in the filesystem or memory, and when asked for
    a rollback, revert to this snapshot.
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些是为了在文件系统或内存中创建一个快照，当需要回滚时，可以恢复到这个快照。
- en: With the Command pattern, you can store the sequence of commands, and when asked
    for a redo, rerun the same set of actions.
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用命令模式，你可以存储命令序列，当需要重做时，重新执行相同的动作集。
- en: 'Asynchronous task execution:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步任务执行：
- en: In distributed systems, we often need the facility to perform the asynchronous
    execution of tasks so that the core service is never blocked in case of more requests.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分布式系统中，我们经常需要执行异步任务的功能，这样核心服务在更多请求的情况下永远不会被阻塞。
- en: In the Command pattern, the invoker object can maintain a queue of requests
    and send these tasks to the `Receiver` object so that they can be acted on independent
    of the main application thread.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在命令模式中，调用者对象可以维护一个请求队列，并将这些任务发送到`Receiver`对象，以便它们可以在主应用程序线程之外独立执行。
- en: Advantages and disadvantages of Command patterns
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式的优缺点
- en: 'The Command pattern has the following advantages:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 命令模式有以下优点：
- en: It decouples the classes that invoke the operation from the object that knows
    how to execute the operation
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它将调用操作的对象与知道如何执行操作的对象解耦
- en: It allows you to create a sequence of commands by providing a queue system
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过提供队列系统允许你创建命令序列
- en: Extensions to add a new command is easy and can be done without changing the
    existing code
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加新命令的扩展很容易，并且可以在不更改现有代码的情况下完成
- en: You can also define a rollback system with the Command pattern, for example,
    in the Wizard example, we could write a rollback method
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以使用命令模式定义一个回滚系统，例如，在向导示例中，我们可以编写一个回滚方法
- en: 'The following are the disadvantages of the Command pattern:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是指令模式的缺点：
- en: There are a high number of classes and objects working together to achieve a
    goal. Application developers need to be careful developing these classes correctly.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有许多类和对象协同工作以实现一个目标。应用开发者需要小心地正确开发这些类。
- en: Every individual command is a `ConcreteCommand` class that increases the volume
    of classes for implementation and maintenance.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个单独的命令都是一个`ConcreteCommand`类，这增加了实现和维护的类数量。
- en: Frequently asked questions
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见问题
- en: Q1\. Can there be no `Receiver` and `ConcreteCommand` implement execute method?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Q1\. 是否可以没有`Receiver`和`ConcreteCommand`实现`execute`方法？
- en: 'A: Yes, it is definitely possible to do so. Many software applications use
    the Command pattern in this way too. The only thing to note here is the interaction
    between the invoker and receiver. If the receiver is not defined, the level of
    decoupling goes down; moreover, the facility to parameterize commands is lost.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 当然，这样做是完全可能的。许多软件应用也以这种方式使用命令模式。这里需要注意的是调用者和接收者之间的交互。如果接收者未定义，解耦程度会降低；此外，参数化命令的功能也会丢失。'
- en: Q2\. What data structure do I use to implement the queue mechanism in the invoker
    object?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Q2\. 我在调用者对象中实现队列机制时使用什么数据结构？
- en: 'A: In the stock exchange example that we studied earlier in the chapter, we
    used a list to implement the queue. However, the Command pattern talks about a
    stack implementation that is really helpful in the case of redo or rollback development.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'A: 在本章前面我们研究的股票交易所示例中，我们使用列表来实现队列。然而，命令模式讨论的是堆栈实现，这在重做或回滚开发的情况下非常有帮助。'
- en: Summary
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began the chapter by understanding the Command design pattern and how it
    is effectively used in software architecture.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从理解命令设计模式及其在软件架构中的有效应用开始本章。
- en: We looked at how Command design patterns are used to encapsulate all the information
    needed to trigger an event or action at a later point in time.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了如何使用命令设计模式来封装触发事件或动作所需的所有信息，以便在稍后的时间点执行。
- en: You also learned the pattern with a UML diagram and sample code implementation
    in Python v3.5 along with the explanation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您还通过UML图和Python v3.5的示例代码实现以及解释学习了该模式。
- en: We also covered an FAQ section that would help you get more ideas on the pattern
    and its possible advantages/disadvantages.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还涵盖了一个常见问题解答部分，这将帮助您获得更多关于该模式及其可能的优势/劣势的想法。
- en: We will now take up other behavioral design patterns in the chapters to come.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中探讨其他行为设计模式。
