- en: Testing and Deploying Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和部署服务
- en: '[Chapter 17](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml), *Handling Service
    Transactions*, ended with an untested receipt of over-the-wire CRUD operations
    being implemented for the data objects, originating with the Artisan and Central
    Office applications. Since proving (and demonstrating) these capabilities is going
    to be needed for both quality assurance and story approval purposes, and since
    there was no structured or useful repeatable testing of that code, in this chapter,
    we will take a detailed look at the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[第17章](b21d33e8-90c4-4a67-af0e-9fc0211d8e3a.xhtml)，*处理服务事务*，以未经测试的通过网络实现对数据对象的CRUD操作的接收结束，这些操作源自工匠和中央办公室应用程序。由于证明（和展示）这些功能将需要进行质量保证和故事批准，而且由于该代码没有结构化或有用的可重复测试，在本章中，我们将详细讨论以下主题：'
- en: Identifying and dealing with the challenges of testing service applications
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和处理测试服务应用程序的挑战
- en: What is involved in packaging and deploying the service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打包和部署服务涉及什么
- en: An approach for demonstrating the service's functionality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示服务功能的方法
- en: Additionally, since the functional development of `hms_sys` is very nearly complete,
    some thoughts and examinations of what's still remaining to be done in `hms_sys`
    for it to be useful to end users, and some possible future enhancements to it,
    will be undertaken.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于`hms_sys`的功能开发几乎已经完成，我们将对`hms_sys`中仍然需要完成的工作以使其对最终用户有用以及对其进行可能的未来增强进行一些思考和研究。
- en: The challenges of testing services
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务的挑战
- en: Testing services, while not difficult, can be substantially more elaborate than
    the relatively basic unit testing that's been shown up to this point. Each point
    in the general `hms_sys` data flow from an Artisan to the Gateway, for example,
    has specific and individual testing concerns, but the flow as a whole should,
    ideally, be as well, so that an end-to-end process verification can be performed
    on demand.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 测试服务虽然不难，但可能比到目前为止展示的相对基本的单元测试要复杂得多。例如，从工匠到网关的一般`hms_sys`数据流中的每个点都有特定和个别的测试问题，但整个流程应该尽可能完整，以便可以根据需要执行端到端的流程验证。
- en: 'The end-to-end flow could be pictured like this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端的流程可能如下图所示：
- en: '![](assets/202a9763-12ff-4f2e-8304-7997d092d30a.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/202a9763-12ff-4f2e-8304-7997d092d30a.png)'
- en: 'From start to finish, a test plan for this data flow would need to address,
    at a minimum, the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 从头到尾，对这个数据流的测试计划需要至少解决以下问题：
- en: Creating the `message-data` in a fashion that it could be used to verify the
    process at its end
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以一种可以用来验证最终过程的方式创建`message-data`
- en: Creating the `DaemonMessage` (though probably not testing that it was created
    accurately—there should already be unit tests that take care of testing that)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`DaemonMessage`（尽管可能不测试它是否准确创建了——应该已经有单元测试来测试这一点）
- en: Sending the resulting **message**
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送结果**消息**
- en: Verifying that the results of the **Artisan Gateway service** receiving the
    message are as expected, by comparison with the original `message-data`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过与原始`message-data`进行比较，验证**工匠网关服务**接收消息的结果是否符合预期
- en: 'Depending on specifics of how the service operates, there are steps that happen
    between the transmission and receipt of the **message** that may not be practical
    (or may not be possible) to test:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 根据服务操作的具体情况，可能发生在**消息**传输和接收之间的步骤可能不实际（或不可能）进行测试：
- en: Testing the `send_message()` part of the overall process has to take steps to
    assure that the transmission of the **message** can be verified without some other
    process (the Gateway service, in this case) consuming the **message** before it
    can be verified. If the unit testing of `send_message` accounts for that, to the
    extent that the `send_message` method itself can be considered trustworthy, then
    the larger scope process test can safely skip testing that part of the whole.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试整个过程中的`send_message()`部分必须采取措施来确保可以在没有其他过程（在这种情况下是网关服务）在**消息**可以被验证之前消耗**消息**的情况下进行**消息**的传输。如果`send_message`的单元测试考虑到了这一点，以至于`send_message`方法本身可以被认为是可信的，那么更大范围的过程测试可以安全地跳过测试整个过程的这一部分。
- en: Similarly, testing of the various `[process-method]` items should provide adequate
    trustworthiness with respect to their parts of the whole flow process. The alternative
    is altering those methods so that their operation can be observed during the process,
    in which case they really aren't the same methods, and any tests that are applied
    are potentially meaningless.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，对各种`[process-method]`的测试应该提供对整个流程的各个部分的可信度。另一种方法是修改这些方法，以便在过程中观察它们的操作，在这种情况下，它们实际上不是相同的方法，而且应用的任何测试可能是毫无意义的。
- en: 'Given that each part of the overall process should have their own unit tests,
    it would be fair to ask these questions: *"What are we actually* *gaining* *by
    testing the whole process, then? Isn''t the collection of individual unit tests
    enough by itself?"* The short answer (though it may be taken as the author''s
    opinion) is **no**—from one vantage point, all of the process tests are, in a
    very real way, unit tests of the Artisan Gateway''s `main` method—the event loop
    that makes the decisions about which method to call based on the content of an
    incoming message. From that perspective alone, and given that `ArtisanGatewayDaemon.main`
    is the critical chunk of functionality in the class, it must be thoroughly tested.
    Also consider that the unit tests required by our testing policy essentially cover
    all of the boxes in the flow diagram: `message-data`, `DaemonMessage`, `send_message`,
    and so on. They do not provide any coverage of the arrows in the flow diagram.
    Though it may be unlikely that the code misses one of the steps that the arrows
    represent, it''s not impossible, so a higher-level, end-to-end process test that
    would reveal any of those gaps would, in turn, provide proof of the trustworthiness
    of the processes as a whole. Similarly, the end results of those processes each
    need to be verifiable—if, for example, an Artisan-Creating-Product process is
    fired off, some assurance needs to be made that once the process is complete,
    that new `Product` object can be retrieved from the data store, with the correct
    data.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于整个流程的每个部分都应该有自己的单元测试，问这些问题是公平的：“通过测试整个流程，我们到底得到了什么？仅仅单独的单元测试就足够了吗？”简短的答案（尽管可能被视为作者的观点）是**不**——从某种角度来看，所有流程测试实际上都是Artisan
    Gateway的`main`方法的单元测试——根据传入消息的内容做出调用哪个方法的决定的事件循环。仅从这个角度来看，鉴于`ArtisanGatewayDaemon.main`是该类中关键的功能块，必须进行彻底测试。还要考虑到，我们测试政策要求的单元测试基本上涵盖了流程图中的所有框：`message-data`，`DaemonMessage`，`send_message`等等。它们并没有覆盖流程图中的*箭头*。虽然代码可能不会错过箭头代表的步骤之一，但这并非不可能，因此一个更高级别的端到端流程测试将揭示任何这些空白，从而证明整个流程的可信度。同样，这些流程的最终结果都需要是可验证的——例如，如果启动了一个Artisan-Creating-Product流程，需要确保一旦流程完成，就可以从数据存储中检索到新的`Product`对象，并且数据正确。
- en: 'Finally, since the various processes all happen behind the scenes, they will
    likely be very hard to debug if a bug slips through into production installation:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于各种流程都是在后台进行的，如果有错误进入生产安装，它们很可能很难进行调试：
- en: There will be little or no visibility into the individual Artisan application
    installations that are starting the execution of the processes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几乎没有办法查看启动流程执行的各个Artisan应用程序安装
- en: The messages that are being sent back and forth, barring extremely detailed
    logging of their content/data, won't persist long enough to be readable and usable
    for debugging in a production setting
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来回发送的消息，除非极其详细地记录其内容/数据，否则不会持续足够长时间以便在生产环境中进行调试时可读和可用
- en: Without more detailed logging, the specific daemon process calls are happening
    invisibly, and their results, if there are any, cannot be checked against the
    original data that they originated from
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有更详细的日志记录，特定的守护进程调用是不可见的，它们的结果（如果有的话）无法与它们来源的原始数据进行对比
- en: The overall testing strategy
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体测试策略
- en: Before writing the code that implements the full process testing, an effort
    needs to be made to complete and successfully execute all of the outstanding unit
    tests. Once this is complete, we can logically take it as a given that any failures
    that arise in the *process* tests are because of something in that process, though
    we may want to take steps to verify sub-process steps, and raise failures for
    certain conditions. This may well evolve as the process tests are written.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写实现完整流程测试的代码之前，需要努力完成并成功执行所有未完成的单元测试。完成后，我们可以逻辑地认为*流程*测试中出现的任何失败都是因为流程中的某些问题，尽管我们可能希望验证子流程步骤，并针对某些条件引发失败。这可能会随着流程测试的编写而发展。
- en: 'Each business object that has a set of corresponding processes needs to check
    for any/all of the following processes that apply:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 每个具有一组相应流程的业务对象都需要检查适用的任何/所有以下流程：
- en: 'Creation of the object, and both local and remote persistence of its data:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的创建，以及其数据的本地和远程持久性：
- en: By each role that is allowed to perform an update
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个允许执行更新的角色
- en: Making sure to test both valid and invalid update attempts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试有效和无效的更新尝试
- en: 'Updating the object''s data:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新对象的数据：
- en: By each role that is allowed to perform an update
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个允许执行更新的角色
- en: Making sure to test both valid and invalid update attempts
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试有效和无效的更新尝试
- en: 'Deletion of the object:'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的删除：
- en: By each role that is allowed perform a deletion
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个允许执行删除的角色
- en: Making sure to test both valid and invalid deletion attempts
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保测试有效和无效的删除尝试
- en: Verifying applicable local and remote data changes after the attempt is made
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证尝试后适用的本地和远程数据更改
- en: 'Determining what would constitute an invalid attempt requires consideration
    of the following questions, at a minimum:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 确定什么构成无效尝试需要考虑至少以下问题：
- en: At any step in the process being tested, what could be corrupted that should
    prevent the process from completing successfully?
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试的流程中的任何步骤，可能会有什么被损坏，应该阻止流程成功完成的情况？
- en: At any step in the process being tested, what could be altered with malicious
    intent that should prevent the process from completing successfully?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试的流程中的任何步骤，可能会有恶意更改，应该阻止流程成功完成的情况是什么？
- en: What tests are already in place that account for these scenarios?
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经有哪些测试考虑了这些情况？
- en: What tests need to be created for any scenarios that aren't accounted for?
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要为未考虑的任何场景创建哪些测试？
- en: 'In the case of the Gateway service, the points with potential for bad data
    variations are:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网关服务，存在潜在的坏数据变体的点有：
- en: '**An invalid attempt is made to create or alter a business object instance:**
    These should be mostly covered by unit tests on the creation and update processes
    of the business objects themselves—these tests should assure that, for example,
    only well-formed data creation and updates are allowed, and having raised an exception
    there, the message transmission process shouldn''t even fire. These cases really
    can''t be tested in the context of the Gateway daemon, but must be tested in the
    applications that talk to it.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**尝试创建或更改业务对象实例的无效尝试：** 这些应该大部分由业务对象本身的创建和更新过程的单元测试覆盖——这些测试应该确保，例如，只允许良好形式的数据创建和更新，并且在引发异常后，消息传输过程甚至不应该触发。这些情况实际上无法在网关守护程序的上下文中进行测试，但必须在与其通信的应用程序中进行测试。'
- en: '**An unauthorized data event message is received:** The testing of message
    signatures in `DaemonMessage` should assure that messages with invalid signatures
    raise an error. As an extension of that, tests of the data event processes should
    assure that if an unauthorized message error is raised, it is handled cleanly,
    and does not execute any data changes.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接收到未经授权的数据事件消息：** 在`DaemonMessage`中对消息签名的测试应该确保具有无效签名的消息引发错误。作为其延伸，数据事件处理的测试应该确保如果引发未经授权的消息错误，它会被干净地处理，并且不执行任何数据更改。'
- en: '**An authorized data event message is received with invalid data:** Provided
    that the unit tests that are relevant for the data event on the origination side
    of the message are complete, this may be an indicator of malicious activity. Testing
    considerations aside for the moment, some review of the logging around this event
    should probably be undertaken to assure that events in this category are logged.
    Whether malicious or not, the corresponding unit tests on the receiving end of
    the message should assure that some kind of exception is raised, and the data
    event process tests should assure that any exceptions raised are handled cleanly
    and do not execute any data changes.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收到带有无效数据的授权数据事件消息：假设消息发起方与数据事件相关的单元测试已经完成，这可能是恶意活动的指示。暂且不考虑测试方面的考虑，应该对该事件周围的日志进行一些审查，以确保该类别的事件被记录。无论是恶意还是不恶意，消息接收端的相应单元测试应该确保引发某种异常，并且数据事件处理测试应该确保处理任何引发的异常，并且不执行任何数据更改。
- en: Though these tests will not, strictly speaking, be unit tests (they would be
    formally classified as some mixture of system or integration tests), we can still
    leverage the functionality of the `unittest` module that has driven all of the
    automated testing for the system up until this point. This will allow the process
    tests to be integrated into, and thus run as part of a complete test suite, if
    there was a desire to do so, or to be run independently, or even individually
    if needed/desired.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些测试严格来说不是单元测试（它们会被正式分类为系统或集成测试的某种混合），我们仍然可以利用`unittest`模块的功能，该模块一直驱动着系统的所有自动化测试。如果有这样的愿望，这将允许将过程测试集成到完整的测试套件中，并作为其一部分运行，或者独立运行，或者根据需要/愿望进行单独运行。
- en: Unit testing variations of note
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值得注意的单元测试变体
- en: The bulk of the unit tests that need to be implemented fall fairly neatly into
    the standard processes that have been in play since the beginning of the `hms_sys`
    development effort, and there's nothing new to say about those. A relatively small
    number of others, however, have some noteworthy variations.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 需要实施的大部分单元测试都相当整洁地落入了自`hms_sys`开发工作开始以来一直在进行的标准流程中，对此没有什么新的说法。然而，还有一小部分其他测试具有一些值得注意的变体。
- en: 'With the advent of a substantial amount of new code that relies heavily on
    either standard Python modules (`atexit`, `logging`, and `signal`, for example,
    in the `daemons` codebases), or various third-party modules that were installed
    to meet specific needs (`pika`, for RabbitMQ support), another aspect of testing
    policy bubbles up: the question of how deeply (or even whether) to test functionality
    that are little more than wrappers around functionality from other sources. It''s
    not an unreasonable assumption that any packages that are part of the Python distribution
    itself are thoroughly tested before they''re included in the distribution. It''s
    probably not unreasonable to assume that any packages that are available to be
    installed through the `pip` utility are also thoroughly tested, though that may
    well vary significantly from package to package.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 随着大量依赖于标准Python模块（例如`atexit`、`logging`和`signal`在`daemons`代码库中）或安装以满足特定需求的各种第三方模块的新代码的出现，测试政策的另一个方面浮出水面：如何深入（甚至是否）测试几乎只是其他来源功能的包装器的功能。可以合理地假设，任何作为Python分发本身的一部分的软件包在包含在分发中之前都经过了彻底的测试。可以合理地假设，可以通过`pip`工具安装的任何软件包也经过了彻底的测试，尽管这可能会因软件包而异。
- en: These are variations on a theme that might be expressed as **trusting the framework**.
    Essentially, this boils down to operating under the assumption that packages installed
    through `pip` (or whatever facilities are provided by the OS) are sufficiently
    tested (for whatever the value of sufficient might be). If these are considered
    sufficiently tested, they do not need to be categorically tested themselves. Whether
    the functionality that was developed that uses trusted framework functionality
    needs to be tested becomes something of a judgment call, perhaps depending on
    the specifics of how the external functionality is used.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是可能被表达为“信任框架”的变体。基本上，这归结为在假设通过`pip`（或操作系统提供的其他设施）安装的软件包已经经过了足够的测试（无论“足够”的价值是什么）。如果认为这些已经经过了足够的测试，它们就不需要被分类测试。使用受信任的框架功能开发的功能是否需要进行测试，可能取决于外部功能的具体使用方式。
- en: This consideration should be borne in mind as the noteworthy variations of unit
    tests are listed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在列出显著变化的单元测试时，应该记住这一点。
- en: 'In the `hms_core` package, tests for the `BaseDaemon` and `BaseDaemonizable`
    ABCs have corresponding concrete classes defined (`BaseDaemonDerived` and `BaseDaemonizableDerived`,
    respectively), which are used to create test instances as needed. That''s not
    new in and of itself—we''ve used concrete derived classes to simplify testing
    of ABCs before. Creating testable instances of either, though, requires a configuration
    file to be passed during instance construction. The creation and clean up of that
    file is handled by the `setUpClass` and `tearDownClass` methods, which are defined
    on the `TestCase` class:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hms_core`包中，`BaseDaemon`和`BaseDaemonizable`的ABCs的测试具有相应的具体类定义（分别为`BaseDaemonDerived`和`BaseDaemonizableDerived`），这些类用于根据需要创建测试实例。这本身并不是新鲜事——我们以前已经使用具体派生类来简化ABC的测试。不过，创建任一可测试的实例都需要在实例构造期间传递一个配置文件。该文件的创建和清理由`setUpClass`和`tearDownClass`方法处理，这些方法在`TestCase`类上定义：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When `setUpClass` executes, before any of the test methods fire, it creates
    a usable config file (`example.config`) in the current working directory, populates
    it with bare-bones configuration data, and keeps track of the filename in a class
    attribute (`cls._config_file)` that the test methods can access. The typical pattern
    for creating a test object within a test method ends up looking like this:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当`setUpClass`执行时，在任何测试方法触发之前，它会在当前工作目录中创建一个可用的配置文件（`example.config`），填充它的基本配置数据，并在一个类属性（`cls._config_file`）中跟踪文件名，以便测试方法可以访问。在测试方法中创建测试对象的典型模式看起来像这样：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A number of tests against members of `hms_core.daemons` were actively skipped.
    The various control methods (`start`, `stop`, and `restart`) of `BaseDaemon` were
    skipped grudgingly. The fundamental issue with trying to test those is that, as
    they stand right now, they are little more than a collection of calls to other
    methods, many of which will, themselves, be tested. The balance falls into the
    trust of the framework category. At most, there is one decision point (in start,
    where a check of the instance's `_running` flag is made) that could, perhaps, be
    usefully tested, but it would have to happen really quickly before a change to
    that flag value would terminate the instance's processes. Ultimately, as long
    as an instance of the daemon starts, stops, and restarts without error, these
    methods are performing as expected, and there is little to gain by explicitly
    testing the corresponding methods.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对`hms_core.daemons`成员进行了一些测试，其中一些被积极跳过。`BaseDaemon`的各种控制方法（`start`，`stop`和`restart`）被勉强跳过。尝试测试它们的根本问题在于，就目前而言，它们只不过是对其他方法的调用集合，其中许多方法本身将被测试。平衡点落在对框架的信任范畴。最多，只有一个决策点（在start中，检查实例的`_running`标志）可能有用地进行测试，但在更改该标志值之前，它必须非常快地发生，以终止实例的进程。最终，只要守护程序的实例启动、停止和重新启动没有错误，这些方法就表现如预期，通过明确测试相应的方法几乎没有什么收益。
- en: A similar decision was made for the `daemonize`, `preflight`, and `start` methods
    in `BaseDaemonizable`, for similar reasons, with the added wrinkle that many of
    the methods being called are provided by standard modules, and themselves would
    fall into the category of trusting the framework.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`BaseDaemonizable`中的`daemonize`，`preflight`和`start`方法也出于类似的原因做出了类似的决定，另外一个问题是，许多被调用的方法是由标准模块提供的，并且它们本身也属于信任框架的范畴。
- en: All of the logging wrapper methods of `BaseDaemon` (`critical`, `debug`, `error`,
    `info`, and `warn`) were actively skipped. The rationale behind that decision
    was that as long as the `Logger` instance that they call is created correctly,
    those instances fall into the "trust the framework" category.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDaemon`的所有日志包装方法（`critical`，`debug`，`error`，`info`和`warn`）都被积极跳过。这一决定背后的理由是，只要它们调用的`Logger`实例被正确创建，这些实例就属于“信任框架”的范畴。'
- en: 'The properties of `BaseDaemonizable` whose values are filesystem paths (`stdin`,
    `stdout`, `stderr`, and `pidfile`) almost follow the standard testing structures
    that we established earlier. The primary difference is that they are filesystem
    path values, and so the test methods for those properties need to include both
    valid and invalid paths and paths that were well-formed, but that couldn''t be
    written to or read from because of filesystem permissions. These tests are also
    tightly bound to the operating system, in a sense: a perfectly valid file path
    in Windows, for example, is not going to be valid in a POSIX-style filesystem,
    such as those used by Linux or macOS.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDaemonizable`的属性（其值为文件系统路径（`stdin`，`stdout`，`stderr`和`pidfile`）几乎遵循我们之前建立的标准测试结构。主要区别在于它们是文件系统路径值，因此这些属性的测试方法需要包括有效和无效的路径，以及由于文件系统权限而无法写入或读取的格式良好的路径。这些测试也与操作系统紧密相关：例如，在Windows中完全有效的文件路径在类似Linux或macOS使用的POSIX风格文件系统中可能无效。'
- en: A similar strategy was required for `BaseDaemon.config_file`, and the `configure`
    method.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDaemon.config_file`和`configure`方法也需要类似的策略。'
- en: 'The `cleanup` and `preflight` methods of `BaseDaemon` fell into a unique category:
    by default, all they do is log (at an `info` logging level) that they have been
    called, so that startup and shutdown activity logging can announce that they were
    executed. If a derived class doesn''t actually override these methods, the baseline
    functionality provided by `BaseDaemon` will be called, and perform the same logging.
    If the same standards are applied that were applied to the logging wrapper methods
    noted earlier, the implication is that `cleanup` and `preflight` both fall into
    the "trust the framework" classification. But what happens if a future need changes
    one of those methods, adding something that goes beyond the simple call to log
    that the method has executed? In that case, if the tests are skipped, there won''t
    be any testing being performed, even if there should be. The simple truth of the
    matter is that changes made that would impact the associated tests cannot be anticipated,
    and as a result, a certain amount of expected discipline has to be assumed—that
    anyone making a substantive change to those base methods will also have to update
    the corresponding tests accordingly.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDaemon`的`cleanup`和`preflight`方法属于一个独特的类别：默认情况下，它们只是记录（在`info`日志级别）它们已被调用，以便启动和关闭活动日志可以宣布它们已被执行。如果派生类实际上没有覆盖这些方法，`BaseDaemon`提供的基线功能将被调用，并执行相同的日志记录。如果应用了早期提到的日志包装器方法相同的标准，那么`cleanup`和`preflight`都属于“信任框架”分类。但是，如果将来的需要改变其中一个方法，添加超出简单调用日志的内容，会发生什么？在这种情况下，如果跳过测试，即使应该进行测试，也不会执行任何测试。事实上，无法预料到会对相关测试产生影响的变化，因此必须假定一定程度的预期纪律——任何对这些基本方法进行实质性更改的人也必须相应地更新相应的测试。'
- en: In the process of building and executing these unit tests, a handful of classes
    that were stubbed out earlier in the development cycle, but that were never actually
    used, surfaced as requiring tests. Since those were never needed (or even implemented,
    in many cases), the classes themselves have been removed, and the corresponding
    test requirements went away as a result.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建和执行这些单元测试的过程中，一些在开发周期早期被存根化但实际上从未被使用的类，需要进行测试。由于这些从未被需要（甚至在许多情况下从未被实现），这些类本身已被移除，相应的测试要求也随之消失。
- en: The `RabbitMQSender` class, in `hms_core.messaging`, had one method—`send_message`—that
    partly fell into the "trust the framework" category. It also needed testing to
    assure that the type checking for a `DaemonMessage` instance was accounted for,
    though. Taken together, the complete testing for the method amounted to little
    more than the type checking test, and assured that the method executed without
    error. After some consideration, retrieving the sent message, or at least performing
    the acknowledgement of it so that it won't sit in some test queue forever, was
    implemented in `send_message` as well.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hms_core.messaging`中的`RabbitMQSender`类有一个方法`send_message`，部分属于“信任框架”类别。它还需要测试以确保对`DaemonMessage`实例的类型检查是被考虑的。综合起来，该方法的完整测试几乎只是类型检查测试，并确保该方法执行时不会出错。经过一些考虑，还在`send_message`中实现了检索发送的消息，或者至少执行确认，以便它不会永远停留在某个测试队列中。
- en: 'The remaining outstanding tests needed, all of which followed reasonably simple
    variations of the standard unit testing processes, were as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的未完成的测试，所有这些测试都遵循标准单元测试流程的合理简单变化，如下所示：
- en: 'In `hms_core.business_objects` and `hms_artisan.artisan_objects`:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`hms_core.business_objects`和`hms_artisan.artisan_objects`中：
- en: Testing the `Artisan.queue_id` and `Artisan.signing_key` properties
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`Artisan.queue_id`和`Artisan.signing_key`属性
- en: 'In `hms_core.co_objects`:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`hms_core.co_objects`中：
- en: Testing the `Artisan.to_message_data` method
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`Artisan.to_message_data`方法
- en: Testing the new `Order` class
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试新的`Order`类
- en: 'In `hms_core.daemons`:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`hms_core.daemons`中：
- en: Testing `BaseDaemon._create_logger`
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`BaseDaemon._create_logger`
- en: 'In `hms_core.messaging`:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`hms_core.messaging`中：
- en: Testing `DaemonMessage`
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`DaemonMessage`
- en: Testing `HasMessageData`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`HasMessageData`
- en: Testing `InvalidMessageError`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`InvalidMessageError`
- en: Testing the standard items of `RabbitMQSender`
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`RabbitMQSender`的标准项目
- en: 'In `hms_artisan.artisan_objects`:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`hms_artisan.artisan_objects`中：
- en: Testing the `Artisan.to_message_data` method
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试`Artisan.to_message_data`方法
- en: With all of the tests in classes outside the `hms_Gateway` namespace accounted
    for, that leaves the properties and methods of the `ArtisanGatewayDaemon` class,
    which are ready to be tested. The properties and most of the methods therein,
    once more, can be tested by following the standard testing policy and process
    that's been in play. The most noteworthy exception is `ArtisanGatewayDaemon.main`,
    which will be skipped in the test module, and tested with the end-to-end-process
    tests that we can build now.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hms_Gateway`命名空间之外的所有测试类中，留下了`ArtisanGatewayDaemon`类的属性和方法，这些属性和大部分方法可以按照标准的测试政策和流程进行测试。最值得注意的例外是`ArtisanGatewayDaemon.main`，它将在测试模块中被跳过，并且现在可以进行端到端流程测试。
- en: Testing Artisan transactions
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试工匠交易
- en: 'The end-to-end process test for an Artisan needs to include the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对工匠的端到端流程测试需要包括以下内容：
- en: Creating an Artisan as it would happen if originating from a Central Office
    staff member
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个工匠，就像从中央办公室工作人员那里发起的那样
- en: Updating an Artisan as it would happen if originating from a Central Office
    staff member
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新一个工匠，就像从中央办公室工作人员那里发起的那样
- en: Updating an Artisan as it would happen if originating with the Artisan themselves
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新一个工匠，就像从工匠自己那里发起的那样
- en: Deleting an Artisan as it would happen if originating from a Central Office
    staff member
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除一个工匠，就像从中央办公室工作人员那里发起的那样
- en: 'Since we aren''t testing classes, which has been the pattern for all of our
    unit tests so far, we don''t need all of the functionality of our standard unit
    test extensions, but we will want to use enough of the same structure and at least
    some of the utilities that were created there in order to integrate the process
    flow tests with the regular unit test runs for the `hms_Gateway` namespace. With
    that in mind, the starting point code looks very similar to our previous test
    modules:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不测试类，这一直是我们所有单元测试的模式，我们不需要我们标准单元测试扩展的所有功能，但我们将希望使用足够相同的结构和至少一些在那里创建的实用程序，以便将流程测试与`hms_Gateway`命名空间的常规单元测试运行集成。考虑到这一点，起点代码看起来与我们以前的测试模块非常相似。
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Since all we really need from the unit testing extensions we''ve been using
    is the output and report-saving functionality, we will only import those:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实际上只需要我们一直在使用的单元测试扩展的输出和报告保存功能，我们只会导入这些功能：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The module-level constants stay the same, and since we''re going to be testing
    against a running instance of the `ArtisanGatewayDaemon` class, we already know
    that we''ll need to import that:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 模块级常量保持不变，由于我们将对运行中的`ArtisanGatewayDaemon`类进行测试，我们已经知道我们需要导入它：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The four process flows that we''re going to test initially can each be represented
    by a single test method. Each of these methods will have to provide whatever code
    needs to be executed for each step of the flow test, but they can start with nothing
    more than an explicit failure:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先测试的四个流程可以分别由单个测试方法表示。这些方法中的每一个都必须提供每个流程测试步骤需要执行的任何代码，但它们可以从明确的失败开始：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Since we''re using our standard unit testing extensions, we still need to actively
    add each test case class to the local test suite:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用标准的单元测试扩展，我们仍然需要主动将每个测试用例类添加到本地测试套件中：
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, since we''ll want to be able to run the process tests module independently,
    we''ll include the same `if __name__ == ''__main__''` code block that''s been
    in all the previous modules, which will provide the output of the test results
    and save the results to a report file if there are no failures:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们希望能够独立运行流程测试模块，我们将包括与之前所有模块中相同的`if __name__ == '__main__'`代码块，它将提供测试结果的输出并将结果保存到报告文件中，如果没有失败的话：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since all of these tests will need a running instance of the `ArtisanGatewayDaemon`
    class, we also need to make sure that one is available. Because a running instance
    of the class is a service, running independently of any other processes, starting
    up a service instance cannot happen as a normal part of any test method—the `main`
    loop would start, and nothing else would progress until it terminated, making
    it impossible to actually test the processes that `main` controls.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些测试都需要`ArtisanGatewayDaemon`类的运行实例，我们还需要确保有一个可用。因为类的运行实例是一个独立于任何其他进程的服务，启动服务实例不能作为任何测试方法的正常部分发生——`main`循环将启动，并且在它终止之前不会有任何其他进展，这使得实际测试`main`控制的流程变得不可能。
- en: 'There are a couple of options that could be pursued to alleviate this issue:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种选择可以缓解这个问题：
- en: 'The test process could, in some fashion, use the operating system service control
    facilities to start a local service instance in much the same way that it would
    be controlled once it was deployed. On a long-term basis, this might be a better
    approach, but at this point in the development process, we aren''t able to actually
    deploy the service code, so that would have to wait for future development. There
    is a trade-off to this approach, though: the service would have to be deployed,
    or some equivalent mechanism would have to be created to mimic a deployed service,
    on each execution of the test suite in order for tests to be accurate.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试过程可以以某种方式使用操作系统服务控制设施来启动本地服务实例，就像在部署后控制它一样。从长远来看，这可能是一个更好的方法，但在开发过程的这一点上，我们实际上无法部署服务代码，所以这将需要等待未来的开发。然而，这种方法存在一个权衡：为了使测试准确，服务必须在每次执行测试套件时部署，或者必须创建一些等效的机制来模仿已部署的服务。
- en: 'Since the service is, ultimately, just an instance of a class, the test process
    could create an instance and start it, let the tests execute, then terminate the
    service instance that was used for the tests. Although this is a more complex
    solution, it feels better in at least one respect: each test suite would be able
    to execute against a service instance that could be customized specifically for
    those tests, including having distinct message queues that could, if necessary,
    be examined while working through issues raised by the test methods, without having
    to sort through a potentially huge set of messages.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于服务最终只是一个类的实例，测试过程可以创建一个实例并启动它，让测试执行，然后终止用于测试的服务实例。虽然这是一个更复杂的解决方案，但至少在某种程度上感觉更好：每个测试套件都可以针对专门为这些测试定制的服务实例执行，包括具有不同消息队列的服务实例，如果必要，可以在解决测试方法引发的问题时进行检查，而无需整理可能庞大的消息集。
- en: 'Implementing the second option involves using the `setUpClass` and `tearDownClass`
    methods that were noted earlier to create the service instance and make it run
    before any tests execute, and shut the instance down after they''ve all completed.
    Since it makes sense to have one test case class for each business object process
    set, setting up `setUpClass` and `tearDownClass` so that they can be reused by
    the various test case classes also feels like a good plan. We can simplify this
    by creating a class that contains all the required logic for both methods, then
    derive the individual test case classes from that new class and the normal `unittest.TestCase`
    class that''s been the backbone of our test case classes so far:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实施第二个选项涉及使用先前提到的`setUpClass`和`tearDownClass`方法，在任何测试执行之前创建服务实例并使其运行，并在所有测试完成后关闭该实例。由于每个业务对象过程集合都应该有一个测试用例类，因此设置`setUpClass`和`tearDownClass`以便它们可以被各种测试用例类重用也是一个不错的计划。我们可以通过创建一个包含两种方法所需逻辑的类来简化这一过程，然后从该新类和迄今为止一直是测试用例类的骨干的`unittest.TestCase`类派生出各个测试用例类：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This, incidentally, shows that it's possible to add helper classes to test suites—classes
    that provide some functionality or capabilities needed during test execution,
    but that aren't, themselves, test case classes.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，这表明可以向测试套件添加辅助类——这些类在测试执行期间提供一些功能或所需的能力，但它们本身不是测试用例类。
- en: 'We need to create a configuration file that the service instance will use,
    but before we do that, we''ll store some of the values we''re likely to need in
    the test methods as class attributes so that we can access them later when needed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个配置文件，服务实例将使用该文件，但在这之前，我们将存储一些我们可能在测试方法中需要的值作为类属性，以便以后在需要时可以访问它们：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The configuration data can be set up as a string that follows the configuration
    structure that was established earlier. Customization of the service instance,
    if needed, can be managed by adding variable/attribute values to the class, and
    making sure that those values get carried into the string, as was done with the
    `cls.Gateway_queue_id` and `cls.Gateway_signing_key` attributes here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据可以设置为一个字符串，遵循先前建立的配置结构。如果需要，可以通过向类添加变量/属性值来定制服务实例，并确保这些值被传递到字符串中，就像这里的`cls.Gateway_queue_id`和`cls.Gateway_signing_key`属性一样：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The configuration data is written to a temporary config file that''s used by
    the test case class, in much the same way that we did before when testing `BaseDaemon`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 配置数据被写入一个临时配置文件，该文件由测试用例类使用，方式与我们在测试`BaseDaemon`时所做的方式相同：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since we may need to access the service instance itself, we''ll create and
    store the instance as another class attribute:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可能需要访问服务实例本身，我们将创建并存储该实例作为另一个类属性：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Starting the service instance requires executing its start method so that the
    process is independent of the running test code. To achieve this, we''re going
    to use the `Process` class, from Python''s `multiprocessing` module, telling it
    what method to call when the `Process` is started, and that the process should
    be treated as a `daemon`, keeping its execution independent from other running
    code. Once that''s been set up, we can start the `Process`, which executes the
    start method of the service instance stored in `cls.Gateway`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务实例需要执行其启动方法，以便该过程独立于运行测试代码。为了实现这一点，我们将使用Python的`multiprocessing`模块中的`Process`类，告诉它在启动`Process`时调用哪个方法，并且该进程应该被视为`daemon`，使其执行独立于其他运行的代码。设置好之后，我们可以启动`Process`，执行存储在`cls.Gateway`中的服务实例的启动方法：
- en: '[PRE14]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `multiprocessing` module will be explored in more detail in [Chapter 19](0f8e550d-d950-4551-ba4b-b652003658a5.xhtml),* Multi-processing
    and HPC in Python,* as we explore various strategies and approaches for scaling
    computational load across multiple processes and machines.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块将在[第19章](0f8e550d-d950-4551-ba4b-b652003658a5.xhtml)中进行更详细的探讨，*Python中的多处理和HPC*，在那里我们将探索跨多个进程和机器分配计算负载的各种策略和方法。'
- en: 'The teardown is much simpler: having stored the process that controls the running
    service instance (`cls.Gateway_process`), that `Process` simply needs to be terminated
    (the `terminate` method call), and the temporary config file deleted so that we
    don''t leave it in the test code. Because the termination of the process may not
    be complete before the teardown execution is complete, a short delay has been
    added as well:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 拆卸要简单得多：存储控制运行服务实例的进程（`cls.Gateway_process`）后，只需终止该`Process`（调用`terminate`方法），并删除临时配置文件，以便不会在测试代码中留下它。由于进程的终止可能在拆卸执行完成之前不完整，因此还添加了一个短暂的延迟：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Using the `NeedsArtisanGateway` class in the test case classes requires some
    trivial code changes: each test case class needs to derive from `NeedsArtisanGateway`
    and `unittest.TestCase`, to begin with:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试用例类中使用`NeedsArtisanGateway`类需要进行一些微不足道的代码更改：每个测试用例类都需要从`NeedsArtisanGateway`和`unittest.TestCase`派生开始：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Also, since `NeedsArtisanGateway` requires a `queue_name` class attribute to
    create the `Gateway_queue_id` class attribute, that needs to be defined:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于`NeedsArtisanGateway`需要一个`queue_name`类属性来创建`Gateway_queue_id`类属性，因此需要定义它：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From that point on, however, all that remains is unchanged:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从那时起，剩下的一切都保持不变：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Before implementing any of the tests, there is some configuration and setup
    that needs to happen within the test module. All of the process tests are expected
    to need data access capabilities, so we need to import the main data store class,
    as well as the data store configuration class, and configure data access to allow
    those capabilities:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施任何测试之前，测试模块中需要进行一些配置和设置。预计所有过程测试都需要数据访问能力，因此我们需要导入主数据存储类，以及数据存储配置类，并配置数据访问以允许这些功能：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, since the process tests are all concerned with message transmission,
    we''ll need to be able to create sender objects—instances of `RabbitMQSender`—as
    well as `DaemonMessage` objects. Those, too, need to be imported, and a base `RabbitMQSender.configuration`
    call needs to be made:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于过程测试都涉及消息传输，我们需要能够创建发送者对象——`RabbitMQSender`的实例——以及`DaemonMessage`对象。这些也需要被导入，并且需要进行基本的`RabbitMQSender.configuration`调用：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`MESSAGE_ORIGINS` in the `import` line is a new module constant, a collection
    of names and values that can be used to control what values are members of the
    collection, what names are associated with them, and to determine whether a given
    value is a member of the collection. It is defined as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`行中的`MESSAGE_ORIGINS`是一个新的模块常量，一个包含名称和值的集合，可以用来控制哪些值是集合的成员，与它们相关联的名称是什么，并确定给定值是否是集合的成员。它的定义如下：'
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Python does have some official enumeration classes, but the one that would otherwise
    be best suited to meet this need, `enum.Enum`, does not allow an arbitrary value
    to check for membership in the enumeration. The differences can be seen in the
    results shown in the `enumeration-example.py` file in this chapter's code (in
    `hms_Gateway/scratch-space`).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Python确实有一些官方的枚举类，但是否则最适合满足这个需求的`enum.Enum`不允许检查任意值是否属于枚举。这些差异可以在本章代码中的`hms_Gateway/scratch-space`中的`enumeration-example.py`文件中看到的结果中看到。
- en: 'Lastly, since the test processes will be using classes with the same names
    from different namespaces (for example, `hms_core.co_objects.Artisan` and `hms_artisan.artisan_objects.Artisan`,
    both named Artisan), we need to import these and rename them in the process, like
    so:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于测试过程将使用具有不同命名空间的相同名称的类（例如，`hms_core.co_objects.Artisan`和`hms_artisan.artisan_objects.Artisan`，都命名为Artisan），我们需要导入它们并在过程中重命名，如下所示：
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: From this point onward, any creation of a `COArtisan` object will be instances
    of the `hms_core.co_objects.Artisan` class, and `ARArtisan` objects will be `hms_artisan.artisan_objects.Artisan`
    instances.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，任何创建`COArtisan`对象都将是`hms_core.co_objects.Artisan`类的实例，而`ARArtisan`对象将是`hms_artisan.artisan_objects.Artisan`的实例。
- en: 'With those out of the way, the implementation of the first process test method
    can (finally) begin. It starts with the creation of the `sender` object, which
    will be used to send the test messages:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，第一个过程测试方法的实现终于可以开始了。它从创建`sender`对象开始，该对象将用于发送测试消息：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In order to test the Artisan creation process, we have to create an Artisan:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试Artisan创建过程，我们必须创建一个Artisan：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We then create the `message` to be sent, and send it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建要发送的`message`，并发送它：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'At this point in the code, the message has been sent, but there''s no easy
    way to determine whether it''s been received yet, let alone processed. Without
    actually writing code (possibly a lot of code) to keep track of messages and their
    status, there''s not much in the way of options to pause processing until we''re
    reasonably certain that the message has been delivered and acted upon. The next
    best option, and one that takes a lot less code effort, though it will slow down
    the test process, is to simply delay the execution for a short time—long enough
    to allow the message to be delivered and acted upon, but not so long that running
    the tests becomes problematically long. Using `time.sleep`, we''re going to delay
    processing for 5 seconds, at least for now. It may need to be increased later,
    or it might be able to be decreased if a better feel for how long the process
    takes to complete is required:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的这一点上，消息已经发送，但没有简单的方法来确定它是否已经被接收，更不用说被处理了。如果没有实际编写代码（可能是大量的代码）来跟踪消息及其状态，那么暂停处理直到我们相当肯定消息已经被传递并被处理的选项就不多了。下一个最佳选项，也是需要更少的代码工作的选项，尽管它会减慢测试过程，就是简单地延迟执行一小段时间——足够让消息被传递并被处理，但不至于使运行测试变得问题严重。使用`time.sleep`，我们将延迟处理5秒，至少目前是这样。以后可能需要增加，或者如果需要更好地了解过程需要多长时间才能完成，也可以减少：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once the message has been received and acted upon, if all went well, then a
    `new_artisan` object will be created by the Gateway service, and saved to the
    database that it''s using. The next step in testing the process is to assure that
    a new object was, in fact, created and stored:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦消息被接收并被处理，如果一切顺利，那么Gateway服务将创建一个`new_artisan`对象，并保存到它正在使用的数据库中。测试过程的下一步是确保实际上创建并存储了一个新对象：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Knowing that the new object was created, we can then check to make sure that
    the new object''s data is identical to the data that was originally sent to create
    it. Since the data dict representation of any data object is going to be the most
    comprehensive—it should include all data that gets persisted—that is a simple
    comparison of the original `Artisan` and the newly created and retrieved `Artisan`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 知道新对象已经创建，我们可以检查确保新对象的数据与最初发送的数据是相同的。由于任何数据对象的数据字典表示都将是最全面的——它应该包括所有被持久化的数据——这就是原始`Artisan`和新创建和检索到的`Artisan`的简单比较：
- en: '[PRE28]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the test process gets past that check, then we''re done with the `new_artisan` object
    that we created to test, and we can delete it from the database:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试过程通过了这个检查，那么我们就完成了用于测试创建的`new_artisan`对象，并且可以从数据库中删除它：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This concludes the "happy path" testing of the process—where everything was
    created, formatted, and sent exactly as intended. Testing unauthorized and badly
    formed messages requires a bit more work, since we''ll be circumventing the checking
    that''s performed by the `Artisan` and `DaemonMessage` classes. Starting, then,
    with an unauthorized message, where the signature of the message doesn''t match
    the signature calculated on the receiving end, we need to first create an unauthorized
    message. We can use the existing message, since it still exists, extract the data
    we''ll be sending, and then alter something—either a data value or the signature
    will do:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了对流程的“快乐路径”测试——在这里，一切都是按照预期创建、格式化和发送的。测试未经授权和格式不正确的消息需要更多的工作，因为我们将会规避`Artisan`和`DaemonMessage`类执行的检查。因此，首先从未经授权的消息开始，消息的签名与接收端计算的签名不匹配，我们需要首先创建一个未经授权的消息。我们可以使用现有的消息，因为它仍然存在，提取我们将要发送的数据，然后改变一些东西——可以是数据值或签名：
- en: '[PRE30]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Since we already have a `sender`, we can use its `channel`, along with the
    `Gateway_queue_id` of the instance, to circumvent the normal sending process that
    expects a `DaemonMessage` instance. Instead, we''ll send the JSON dump of the
    unauthorized message that we just created:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个`sender`，我们可以使用它的`channel`，以及实例的`Gateway_queue_id`，来规避正常的发送过程，该过程期望一个`DaemonMessage`实例。相反，我们将发送刚刚创建的未经授权消息的JSON转储：
- en: '[PRE31]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The test portion of this branch is concerned with whether a data change made
    it through the Gateway service. If one did, it would have generated a new `Artisan`
    record, and we could retrieve the corresponding object. If it did, and we can,
    then something went wrong, and we explicitly cause the test to fail. If the retrieval
    attempt failed (raising an `IndexError` because the result set that comes back
    is a zero-length list, and has no element at `[0]`), that''s the expected/desired
    behavior, and we can simply ignore the error, passing that portion of the test:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分支的测试部分关注的是数据更改是否通过了`Gateway`服务。如果通过了，它将生成一个新的`Artisan`记录，我们可以检索相应的对象。如果通过了，我们可以，那么就出了问题，我们明确导致测试失败。如果检索尝试失败（引发`IndexError`，因为返回的结果集是一个零长度列表，并且在`[0]`位置没有元素），那就是预期/期望的行为，我们可以简单地忽略错误，通过测试的这一部分：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Testing an invalid but authorized message works much the same way, but we''ll
    alter the message data, and then use a normal `DaemonMessage`/`sender` process:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个无效但经过授权的消息的工作方式基本相同，但我们将改变消息的数据，然后使用正常的`DaemonMessage`/`sender`流程：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Variations on the same theme for the Central-Office-updating-Artisan and Central-Office-deleting-Artisan
    processes will look very similar, with each doing the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室更新工匠和中央办公室删除工匠流程的变体看起来非常相似，每个流程都会执行以下操作：
- en: Creating a local Artisan and saving it in order to have a data object that's
    going to be manipulated
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个本地工匠并保存它，以便有一个将要被操作的数据对象。
- en: Optionally verifying that the newly created Artisan exists in the database before
    proceeding, though if the `Artisan.save` method is considered trustworthy from
    other tests, this could be skipped
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在继续之前，可以选择验证新创建的工匠是否存在于数据库中，尽管如果`Artisan.save`方法在其他测试中被认为是可信的，这一步可以被跳过
- en: Creating an appropriate `message` to execute the process being tested, and sending
    it
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个适当的`message`来执行正在测试的流程，并发送它
- en: 'Testing the results against a second instance of the same Artisan:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对比同一个工匠的第二个实例的测试结果：
- en: The update process tests have to make a point of changing all fields that can
    be legitimately changed by the role that the test is acting in—as a Central Office
    user/Artisan Manager. In that respect, it might look very much like previous unit
    tests against methods like `Artisan.to_data_dict`, which return dictionary representations
    of the objects
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新过程测试必须着重更改所有可以合法更改的字段，这些字段可以由测试所扮演的角色（作为中央办公室用户/工匠经理）来更改。在这方面，它可能看起来非常像以前针对`Artisan.to_data_dict`等方法的单元测试，这些方法返回对象的字典表示
- en: It should also make a point of trying to make changes to the Artisan that shouldn't
    be allowed, and verifying that those attempts fail
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还应该着重尝试对工匠进行不允许的更改，并验证这些尝试是否失败
- en: The deletion process test will be considerably simpler, since all it will need
    to do is try and re-acquire the test object (using something similar to `verify_artisan
    = COArtisan.get(str(new_artisan.oid))[0]`, which we looked at previously) with
    the test passing if the retrieval effort fails after deletion is executed
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除过程测试将会更简单，因为它所需要做的就是尝试重新获取测试对象（使用类似于`verify_artisan = COArtisan.get(str(new_artisan.oid))[0]`的方法，我们之前已经看过），如果在执行删除后检索失败，则测试通过
- en: 'Tests against invalid access attempts, such as an Artisan creating an Artisan,
    should also be implemented, and would have a code structure similar to portions
    of the test code shown previously. Before those tests could pass, though, mechanisms
    to actually check the message in the various operation methods would have to be
    implemented. Using the `origin` of the incoming `DaemonMessage` for any given
    operation, this might look something like this, showing a general, any-role-is-allowed
    check and a specific-role-only check, and using the `create_artisan` method of
    the Gateway service as an example:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对无效访问尝试进行测试，比如工匠创建工匠，也应该被实施，并且其代码结构与先前显示的测试代码的部分类似。然而，在这些测试通过之前，必须实施实际检查各种操作方法中的消息的机制。使用传入`DaemonMessage`的`origin`，这可能看起来像这样，显示了一个一般的、任何角色都允许的检查和一个特定角色的检查，并以`Gateway`服务的`create_artisan`方法为例：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tests against invalid role/action execution variants would look very much like
    the testing of `invalid_message` that we saw previously, verifying that the operation
    method doesn't execute when presented with a well-formed message that's attempting
    to execute an operation that's not allowed by any given role/`origin`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 对无效角色/操作执行变体的测试看起来非常像我们之前看到的`invalid_message`的测试，验证当提供一个格式良好的消息尝试执行一个不被任何给定角色/`origin`允许的操作时，操作方法不会执行。
- en: 'Testing transaction processes that originate from the application side of a
    relationship is a bit more complicated, if only because there''s been no significant
    development so far on those applications. To test these processes, a bare-bones
    mock-up of the application processes would have to be created, at least initially—later
    on down the line, when there are reasonably complete and tested applications,
    it might be better to actually run a local instance of them. Both Artisan and
    Central Office applications would need a mock-up, and would need to provide CRUD
    operations methods in much the same manner that the Gateway service daemon''s
    class does. A mock-up of the Artisan application might start with code such as
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 测试起源于关系的应用程序端的交易过程稍微复杂一些，仅仅是因为到目前为止这些应用程序还没有进行重大的开发。为了测试这些过程，至少最初需要创建一个应用程序过程的简化模拟——在以后，当有相当完整和经过测试的应用程序时，最好实际运行它们的本地实例。工匠和中央办公室应用程序都需要一个模拟，并且需要以与网关服务守护程序类似的方式提供CRUD操作方法。工匠应用程序的模拟可能从这样的代码开始：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The structure of the Gateway service could be reused, in part, to provide a
    method that routes messages to their respective operation methods:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 网关服务的结构可以被部分重用，以提供将消息路由到其各自操作方法的方法：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Rather than having a `main` loop, though, the mock-up would be better served
    by having a single method that acts like a single pass through the Gateway service''s
    `main` loop. For testing purposes, this allows the handling of messages to be
    more tightly controlled so that any number of test messages can be sent as part
    of a test process. Then, a single call can be made to the `ArtisanapplicationMock`
    method to read and handle all messages, which results in the fact that those messages
    can be tested. This method, `handle_pending_messages`, still looks a lot such
    as `ArtisanGatewayDaemon.main`, though:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其有一个`main`循环不如有一个单一方法更好，该方法就像通过网关服务的`main`循环的单次通过。对于测试目的，这允许更严格地控制消息的处理，以便任意数量的测试消息可以作为测试过程的一部分发送。然后，可以调用`ArtisanapplicationMock`方法来读取和处理所有消息，这导致这些消息可以被测试。这个方法，`handle_pending_messages`，看起来仍然很像`ArtisanGatewayDaemon.main`，尽管：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With that available, and a corresponding mock-up for the Central Office application,
    the processes for testing transactions that originate with an application passing
    through the Gateway service to the other application and making changes will be
    similar to the testing process for simpler transactions, such as creating an Artisan:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，以及中央办公室应用程序的相应模拟，通过网关服务传递到其他应用程序并进行更改的交易的测试过程将类似于更简单交易的测试过程，比如创建一个工匠：
- en: A message is created for the operation, with the appropriate origin and data
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为操作创建消息，带有适当的来源和数据
- en: That message is sent to the Gateway service
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该消息被发送到网关服务
- en: Verification of any service-level data changes is performed, possibly after
    a delay to ensure that there's been time for the message to be delivered and acted
    upon
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行任何服务级数据更改的验证，可能需要延迟以确保已经有时间传递并执行消息
- en: The `handle_pending_messages` method of the appropriate application mock-up
    class is called to read and process the incoming message
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用适当应用程序模拟类的`handle_pending_messages`方法来读取和处理传入的消息
- en: Testing of the expected results is performed—new local data created for creation
    transactions, changes to existing data for update transactions, and the removal
    of existing data for deletion transactions
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行预期结果的测试——为创建事务创建新的本地数据，为更新事务更改现有数据，为删除事务删除现有数据
- en: This entire process—the creation of code that simulates a more complex system
    or object for testing purposes—is called **Mocking**. Mocking allows tests to
    be written without having to rely on actual (and often far more complex) real
    code implementations.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 整个过程——创建用于测试目的的模拟更复杂系统或对象的代码——称为**模拟**。模拟允许编写测试，而无需依赖实际（通常更复杂）的真实代码实现。
- en: Testing for products and orders, for the most part, can follow similar patterns.
    The primary differences will, of course, be in what object types are being created
    and manipulated, and in what various roles are allowed to do to those objects,
    according to the business rules for each role/operation combination. Additional
    tests may need to be defined to specifically target certain operations—artisans
    fulfilling part of an order, for example, which is fundamentally just an update
    operation. However, this should only alter item fulfilment data, and not all of
    that data at that. Even so, this will almost certainly follow similar test processes
    and  structures to those outlined here.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 产品和订单的测试，在大部分情况下，可以遵循类似的模式。主要的区别当然在于正在创建和操作的对象类型，以及根据每个角色/操作组合的业务规则，各种角色被允许对这些对象做什么。可能需要定义额外的测试来专门针对某些操作——例如，工匠完成订单的一部分，这本质上只是一个更新操作。然而，这应该只会改变项目履行数据，而不是所有的数据。即便如此，这几乎肯定会遵循这里概述的类似的测试过程和结构。
- en: Demonstrating the service
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演示服务
- en: 'A mainstay of many iterative development processes is the requirement that
    the functionality of code can be demonstrated to stakeholders so that they have
    sufficient information to agree that requirements for a story have been met, or
    to point out any gaps in those requirements. Demonstration of a service poses
    some unique challenges to meeting that requirement:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 许多迭代开发过程的核心要求是代码的功能可以向利益相关者展示，以便他们有足够的信息来同意故事的需求已经得到满足，或者指出这些需求中的任何差距。演示服务对满足该要求提出了一些独特的挑战：
- en: Everything that's happening is happening "behind the scenes" invisibly
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一切发生的都是“幕后”不可见的。
- en: Much of what is happening happens so quickly that there simply isn't time to
    see the interim steps that lead to the final results
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多事情发生得如此迅速，以至于根本没有时间看到导致最终结果的中间步骤
- en: The odds are good that there won't be any sort of user interface associated,
    or that even if there is one, that it will provide enough visibility into the
    processes to demonstrate them in enough detail
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很可能不会有任何与用户界面相关的内容，或者即使有，也不会提供足够的可见性来充分展示这些过程的细节
- en: Sometimes, as is the case of the Gateway service, there are also external systems—databases,
    message queue services, and so on, that need to be available to the code being
    run for a demonstration process to actually run successfully. Preparation for
    demonstration needs to take that into account, and have running instances of any
    needed external services available, obviously. In this case, since development
    and testing already relies on those same services being available, this is a non-issue,
    provided that a code demo can be run from a development environment.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，就像网关服务一样，还有一些外部系统——数据库、消息队列服务等，需要对正在运行的代码可用，以便演示过程实际上能够成功运行。演示准备需要考虑到这一点，并确保任何需要的外部服务的运行实例可用。在这种情况下，由于开发和测试已经依赖于这些相同的服务可用，这不是问题，只要可以从开发环境运行代码演示。
- en: 'The process tests that have been implemented can be executed to demonstrate
    that the code is behaving in a predictable fashion, and this a good item to be
    demonstrated, but it does nothing to address our initial concerns. A very basic
    approach to show the inner workings of the various processes would be to write
    a demonstration script that performs the same tasks that occur in the final code,
    in whatever logical or required order is needed, but in user controllable chunks,
    with displays of relevant data when and as needed. It''s a brute-force, bare-bones
    approach, but makes the steps in the processes visible (addressing the first concern),
    and executes each step when a user says to (addressing the second concern). In
    effect, it''s solving the first two concerns by creating a user interface to that
    specific purpose. Though the full demo script is too long to reproduce here, it
    will largely look like the process tests:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 已经实施的过程测试可以执行，以证明代码的行为是可预测的，这是一个很好的演示项目，但它并不能解决我们最初的问题。展示各种过程内部运作的一个非常基本的方法是编写一个演示脚本，执行与最终代码中发生的相同任务，以任何逻辑或所需的顺序，但以用户可控的块，并在需要时显示相关数据。这是一种蛮力、基本的方法，但可以使过程中的步骤可见（解决第一个问题），并在用户说要执行每个步骤时执行（解决第二个问题）。实际上，它通过为特定目的创建用户界面来解决了前两个问题。尽管完整的演示脚本太长而无法在此重现，但它基本上看起来像过程测试：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The configuration of various items, like the data store that the demo process
    will use or the message queue, would need to be provided at about this point in
    the code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 各种项目的配置，比如演示过程将使用的数据存储或消息队列，需要在代码的这一点提供：
- en: 'Because the unit tests for the entire service live in a package structure (that
    mirrors the structure of the real code), the entire unit test suite can be imported,
    and a function can be written to execute them on demand:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为整个服务的单元测试位于一个包结构中（与真实代码的结构相同），可以导入整个单元测试套件，并编写一个函数按需执行它们：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The demonstrations of each data transaction process can also be wrapped in
    individual functions in the demo module. With the exception of new code to display
    information as the demo is running, and to prompt whoever is running the demo
    to allow it to continue, they will look very much like the corresponding process
    test methods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据交易过程的演示也可以封装在演示模块中的单独函数中。除了显示演示运行时的信息和提示运行演示的人允许其继续的新代码之外，它们看起来很像相应的过程测试方法：
- en: '[PRE40]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The code for creating an `Artisan` test object to work with is nearly identical:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建一个“Artisan”测试对象的代码几乎相同：
- en: '[PRE41]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since the demo will need to show the initial state of the `new_artisan` object
    before the transmission of its create message to show that the data persisted
    as expected, some simple, brute-force output of the object''s `data-dict` is in
    order:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于演示需要显示“new_artisan”对象的初始状态，以便在传输其创建消息之前显示数据按预期持久化，因此需要对对象的“data-dict”进行一些简单的蛮力输出：
- en: '[PRE42]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Creating the message, and sending it, looks almost identical, apart from the
    `queue_id` that''s used to identify which queue it gets sent through. It also
    has the same `time.sleep` delay as the corresponding process test, for the same
    reason:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 创建消息并发送消息几乎相同，除了用于标识发送消息的队列的“queue_id”。出于同样的原因，它也具有与相应过程测试相同的“time.sleep”延迟：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The display of the results is essentially the same code used to display the
    `initial_state` that we saw previously; it''s just using the `data-dict` of the
    retrieved, database-persisted instance instead of the original instance:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的显示本质上与我们之前看到的显示“initial_state”的代码相同；它只是使用了检索到的数据库持久化实例的“data-dict”，而不是原始实例：
- en: '[PRE44]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Since showing the original and persisted data is one logical grouping, the
    script waits for input from the user before continuing with the next step of the
    demo:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于显示原始数据和持久化数据是一个逻辑分组，脚本在继续演示的下一步之前等待用户输入：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Setting aside the remaining items in this demo function, and all of the other
    demo functions that would likely be needed, the entire demo script can be executed
    by simply calling each demo function if the module is executed directly (`if __name__
    == ''__main__'')`:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此演示函数中设置剩余项目，并且可能需要所有其他演示函数，如果模块直接执行，则可以通过简单调用每个演示函数来执行整个演示脚本（`if __name__
    == '__main__'`）：
- en: '[PRE46]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The output with just this first segment of the first demo method in place can
    already be used to show that data persistence is accurate:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 仅使用第一个演示方法的第一部分的输出就可以显示数据持久性是准确的：
- en: '![](assets/37671549-83a1-418f-9920-933c19a15f2a.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/37671549-83a1-418f-9920-933c19a15f2a.png)'
- en: 'The steps that follow for this first demo function will be similar:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的这个第一个演示函数的步骤将类似：
- en: Wrapping the execution with data displays of before and after whatever changes
    are made
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将执行与数据显示包装在变更之前和之后
- en: Displaying what data changes are being made when applicable, so that there is
    visibility into those changes
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适用时显示正在进行的数据更改，以便能够看到这些更改
- en: Demonstrating expected failure cases, such as invalid message data or signatures,
    and any role-based variants
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 演示预期的失败案例，例如无效的消息数据或签名，以及任何基于角色的变体
- en: There will almost certainly be enough similarity between what the process test
    methods are proving (and executing) and the demonstrations of those same processes
    that the test methods will supply most of the code needed for all of the demo
    functions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 过程测试方法正在证明（和执行）的内容与这些相同过程的演示几乎肯定会非常相似，测试方法将提供大部分所需的所有演示函数的代码。
- en: Packaging and deploying the service
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和部署服务
- en: 'Since the `hms_Gateway` and `hms_core` projects each have their own `setup.py` file,
    the packaging and deployment process doesn''t need to be any more complicated
    than doing the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`hms_Gateway`和`hms_core`项目各自都有自己的`setup.py`文件，因此打包和部署过程不需要比以下更复杂：
- en: Executing each `setup.py` to generate the installable package
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行每个`setup.py`以生成可安装的软件包
- en: Moving those package files to the server that is going to run the Gateway service
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将这些软件包文件移动到将运行网关服务的服务器
- en: 'Installing them with the following code:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下代码进行安装：
- en: '`pip install HMS-Core-0.1.dev0.tar.gz`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install HMS-Core-0.1.dev0.tar.gz`'
- en: '`pip install HMS-Gateway-0.1.dev0.tar.gz`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pip install HMS-Gateway-0.1.dev0.tar.gz`'
- en: Creating, for new installations, the configuration file at the necessary location
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为新安装创建必要位置的配置文件
- en: The configuration needed to allow the Gateway daemon to start up automatically
    on system boot and shutdown with a system shutdown will vary based on the OS of
    the target machine (more on that in a bit).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 允许网关守护程序在系统启动时自动启动并在系统关闭时关闭所需的配置将根据目标机器的操作系统而变化（稍后会详细介绍）。
- en: If, on the other hand, there is a need for a single package, consolidating the
    `src` directories from all of the relevant projects will need to be undertaken
    as part of the packaging process. That can be accomplished, if it's not available
    through some combination of the normal `setuptools.setup` function's arguments,
    with a `Makefile` and a minor change to the `setup.py` that's in place in the
    project.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果需要一个单一软件包，那么需要在打包过程中进行`src`目录的整合，这需要作为打包过程的一部分进行。如果不能通过正常的`setuptools.setup`函数的参数的某种组合来实现，那么可以通过`Makefile`和对项目中已经存在的`setup.py`进行微小更改来完成。
- en: Support for the inclusion of source code outside a project's main source directory
    has, in the author's experience, had sporadic issues with earlier versions of
    Python and/or the `setuptools` package. If those issues are resolved in the current
    version, then it may possible to use the `package_dir` argument of `setuptools.setup`,
    possibly in combination with the `setuptools.find_package` function to instruct
    the main `setup` function where you can find other package source trees outside
    the current project. The `Makefile` approach described here is not as elegant,
    and can have other (generally minor) issues, but works all the time with only
    basic `setup.py` functionality/requirements.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目的主要源代码目录之外包含源代码的支持在作者的经验中，早期版本的Python和/或`setuptools`包存在零星问题。如果这些问题在当前版本中得到解决，那么可能可以使用`setuptools.setup`的`package_dir`参数，可能结合`setuptools.find_package`函数，指示主`setup`函数在当前项目之外的其他包源树的位置。这里描述的`Makefile`方法不够优雅，可能会有其他（通常是次要的）问题，但只需基本的`setup.py`功能/要求就可以始终正常工作。
- en: 'The relevant change to the `setup.py` file is simple, requiring only the addition
    of the `hms_core` package name to the list of packages to include in the distribution:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件的相关更改很简单，只需要将`hms_core`软件包名称添加到要包含在分发中的软件包列表中：'
- en: '[PRE47]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Since `setup.py` doesn''t care where it''s being run from, a simple brute-force
    solution to gather all of the relevant source code into a single location as a
    `Makefile` target might start with this:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setup.py`不关心它从哪里运行，一个简单的强制解决方案可以将所有相关源代码收集到一个单一位置作为`Makefile`目标的起点可能从这里开始：
- en: '[PRE48]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Step-by-step, all the target is actually doing is the following:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 逐步来看，实际上目标正在做以下事情：
- en: Creating a temporary build directory
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建临时构建目录
- en: Copying the entire package directory from each project into that directory
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每个项目的整个软件包目录复制到该目录
- en: Jumping into the directory and executing a typical `setup.py` run (with the
    modified `setup.py` file)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入目录并执行典型的`setup.py`运行（使用修改后的`setup.py`文件）
- en: Making sure that a directory exists on the filesystem that the final package
    files can be moved to
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保文件系统上存在一个目录，可以将最终软件包文件移动到该目录
- en: Moving the newly created package files to that directory
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将新创建的软件包文件移动到该目录
- en: Removing the temporary build directory
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除临时构建目录
- en: The final output of the combined `Makefile`/`setup.py` process would be a single
    package file, `HMS-Gateway-0.1.dev0.tar.gz`, that includes both the `hms_Gateway`
    and `hms_core` package directories, ready for installation with `pip install HMS-Gateway-0.1.dev0.tar.gz`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 合并`Makefile`/`setup.py`过程的最终输出将是一个单个的包文件，`HMS-Gateway-0.1.dev0.tar.gz`，其中包括`hms_Gateway`和`hms_core`包目录，可以通过`pip
    install HMS-Gateway-0.1.dev0.tar.gz`进行安装。
- en: Common considerations across all operating systems
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有操作系统的共同考虑因素
- en: 'No matter what operating system the Gateway service daemon is running under,
    it will require a full configuration file, at a known location, that stores all
    of the settings that the service will need to know about when it starts up. The
    basic, Linux-flavored version of this configuration file (living in `/etc/hms/hms_Gateway.conf`
    on the target machine the service is running on) looks very much like the bare-bones
    example used in the *Message-Queue implementation with RabbitMQ* section of [Chapter
    16](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml), *The Artisan Gateway Service*:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 无论网关服务守护进程在什么操作系统下运行，它都需要一个完整的配置文件，位于已知位置，存储服务启动时需要了解的所有设置。这个配置文件的基本Linux版本（位于目标机器上运行服务的`/etc/hms/hms_Gateway.conf`中）看起来非常像[第16章](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml)中使用的*使用RabbitMQ实现消息队列*部分的最基本示例，*Artisan网关服务*：
- en: '[PRE49]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This config file is intentionally not part of the packaging process—otherwise,
    every time an update was installed, there would be some risk of overwriting an
    existing and operational configuration. Once the final configuration is in place,
    it should not need to be modified under any reasonably normal circumstances. The
    only difference between the Linux version of the configuration file and one that
    would be used on a Windows server is the log file path (`logging:file:logfile`),
    which would need to be pointed at a Windows filesystem path.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件故意不是打包过程的一部分——否则，每次安装更新时，都会有一些覆盖现有和运行配置的风险。一旦最终配置就位，它在任何正常情况下都不应该需要修改。在Linux版本的配置文件和在Windows服务器上使用的配置文件之间唯一的区别是日志文件路径（`logging:file:logfile`），它需要指向Windows文件系统路径。
- en: 'The service management options that we''ll examine, under both Windows and
    Linux operating systems, allow a simple command-line execution to start the service
    daemon. Older Linux service management might require a separate, freestanding
    script in Bash or Python to bridge between the operating system''s core functionality
    and the user''s and system''s interaction with it. With the advent of these more
    modern options, though, we can launch the service daemon on a production system
    in much the same way it was launched for testing during its development, by adding
    a few lines of code to the end of `hms_Gateway/daemons.py`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Windows和Linux操作系统下检查的服务管理选项允许通过简单的命令行执行来启动服务守护进程。较旧的Linux服务管理可能需要一个独立的Bash或Python脚本，以在操作系统的核心功能和用户与系统的交互之间进行桥接。然而，随着这些更现代的选项的出现，我们可以以与在开发过程中进行测试时相同的方式在生产系统上启动服务守护进程，只需在`hms_Gateway/daemons.py`的末尾添加几行代码：
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: When a Python module is directly executed by the Python interpreter—`python
    -m hms_Gateway.daemons`, for example, or `python /path/to/hms_Gateway/daemons.py`—the
    `if __name__ == '__main__'` condition will evaluate to `True`, and the code within
    that `if` statement will be executed. In this case, it creates an instance of
    `ArtisanGatewayDaemon`, passing the hard-coded config file path, then calling
    the `start` method of the `daemon` object, starting the service.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当Python模块直接由Python解释器执行时——例如`python -m hms_Gateway.daemons`，或者`python /path/to/hms_Gateway/daemons.py`——`if
    __name__ == '__main__'`条件将评估为`True`，并且该`if`语句内的代码将被执行。在这种情况下，它创建了一个`ArtisanGatewayDaemon`的实例，传递了硬编码的配置文件路径，然后调用`daemon`对象的`start`方法，启动服务。
- en: Linux (systemd) execution
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Linux（systemd）执行
- en: 'On a reasonably recent Linux system, service management is handled by another
    service: `systemd`. Configuration is needed for `systemd` to know when and how
    to launch the service daemon, how to shut it down, and how to restart it, along
    with some additional information that is used to determine when the service starts
    during the system''s boot process. A bare-bones starting point `systemd` configuration
    file for the Gateway service would look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个相当新的Linux系统上，服务管理由另一个服务处理：`systemd`。需要配置`systemd`以便知道何时以及如何启动服务守护进程，如何关闭它，并如何重新启动它，以及一些其他信息，用于确定服务在系统引导过程中何时启动。网关服务的一个最基本的`systemd`配置文件起点如下：
- en: '[PRE51]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Where the roles for he mentioned keywords are as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 其中提到的关键字的角色如下：
- en: '`Description` is a simple description of the service'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`是服务的简单描述'
- en: '`After` indicates an operational state target that should be completely established
    before launching the service daemon—in this case, since the Gateway service requires
    network access, we are indicating that it should start after the network online
    target is complete, expecting that all network functionality will be available
    at that point'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`After`指示在启动服务守护进程之前应完全建立的操作状态目标——在这种情况下，由于网关服务需要网络访问，我们指示它应在网络在线目标完成后启动，期望在那时所有网络功能都将可用'
- en: '`ExecStart` is a command that can be executed by the OS to start the service'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStart`是一个可以由操作系统执行的命令，用于启动服务'
- en: '`ExecStop` is a command that will be used to stop the service—in this case,
    using the `pkill` OS utility to find (`-f`) and kill any processes that match
    the `hms_Gateway.daemons` string'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecStop`是一个用于停止服务的命令——在这种情况下，使用`pkill`操作系统实用程序来查找（`-f`）并杀死与`hms_Gateway.daemons`字符串匹配的任何进程'
- en: '`Restart` allows `systemd` to automatically restart the service if it dies
    unexpectedly'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Restart`允许`systemd`在服务意外死机时自动重新启动服务'
- en: '`WantedBy` is an OS state indicator that, in this case, defines under what
    circumstances the service daemon should launch—when a (standard) multi-user-capable
    run-level is reached, typical of a command-line only server system'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “WantedBy”是一个操作系统状态指示器，在这种情况下，它定义了服务守护程序在何种情况下启动 - 当达到（标准）多用户可运行级别时，典型的命令行服务器系统
- en: 'Once both of these configuration files are in place, the Gateway service should
    start automatically after the system boots up, shut down cleanly if the system
    is shut down, and can be manually started, stopped, and restarted with the following
    standard commands:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这两个配置文件都就位，网关服务应该在系统启动后自动启动，在系统关闭时干净地关闭，并且可以使用以下标准命令手动启动、停止和重新启动：
- en: '`systemctl start hms_Gateway`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl start hms_Gateway`'
- en: '`systemctl stop hms_Gateway`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl stop hms_Gateway`'
- en: '`systemctl restart hms_Gateway`'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`systemctl restart hms_Gateway`'
- en: Windows (NSSM) execution
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Windows（NSSM）执行
- en: Running the Gateway service on a Windows machine requires some middleware to
    create a service-compatible wrapper around the Python code that's going to be
    executed. One of the more popular and stable middleware options is the **Non-Sucking
    Service Manager** (**NSSM**). NSSM provides a GUI for creating, installing, and
    managing services that are written in a variety of languages—in general, if a
    program can be run from a command line, NSSM can almost certainly get it running
    as a Windows service.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows机器上运行网关服务需要一些中间件，以在即将执行的Python代码周围创建一个与服务兼容的包装器。其中一个更受欢迎和稳定的中间件选项是**Non-Sucking
    Service Manager**（**NSSM**）。NSSM提供了一个GUI，用于创建、安装和管理用各种语言编写的服务 - 一般来说，如果一个程序可以从命令行运行，NSSM几乎肯定可以将其作为Windows服务运行。
- en: 'NSSM may need to be run with administrative privileges, but in any event, is
    launched from the command line—`C:\path\to\nssm.exe install` launches the GUI,
    and all of the settings needed are present under one of the tabs. The application
    tab defines the Path to the program to be executed (`python.exe`, in our case)
    with whatever Arguments are needed (the Python script to run), as well as a Service
    name, which is used to identify the service:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: NSSM可能需要以管理员权限运行，但无论如何，它都是从命令行启动的 - `C:\path\to\nssm.exe install`启动GUI，并且所有所需的设置都存在于其中一个选项卡下。应用程序选项卡定义了要执行的程序的路径（在我们的情况下是`python.exe`），以及所需的参数（要运行的Python脚本），以及服务名称，用于标识服务：
- en: '![](assets/2511b31c-b2d7-4555-8ff5-195fc4a1526c.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2511b31c-b2d7-4555-8ff5-195fc4a1526c.png)'
- en: 'If an existing NSSM-managed service needs to be modified, it can be accessed
    by executing the NSSM program and specifying the Service name in the command:
    `C:\path\to\nssm.exe install hms_Gateway`, for example.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要修改现有的NSSM管理的服务，可以通过执行NSSM程序并在命令中指定服务名称来访问该服务：例如`C:\path\to\nssm.exe install
    hms_Gateway`。
- en: 'The Details tab allows a Display name and Description to be provided, which
    will appear in the Windows Service Administration interface. It also allows for
    the control of the Startup type: whether the service starts automatically, or
    under other circumstances:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 详细选项卡允许提供显示名称和描述，在Windows服务管理界面中显示。它还允许控制启动类型：服务是自动启动还是在其他情况下启动：
- en: '![](assets/8a9ad1c7-af32-4fd0-8f53-97d68e443fd9.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8a9ad1c7-af32-4fd0-8f53-97d68e443fd9.png)'
- en: Once the Install Service button is clicked, it's done—the new service, wrapped
    and manageable by NSSM, is available in the Windows Services administrator!
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦点击安装服务按钮，就完成了 - 新服务，由NSSM包装和管理，可在Windows服务管理员中使用！
- en: 'At this point, what might be called the "functional foundations" of `hms_sys`
    are pretty complete: all of the data flows that are expected have been accounted
    for, and if there are restrictions mandated by the business rules that aren''t
    implemented in the business logic, there is at least enough support for making
    the decisions related to them quick and easy to implement.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，“hms_sys”的“功能基础”可能已经相当完整：已经考虑到了预期的所有数据流，如果业务规则规定的限制没有在业务逻辑中实现，至少有足够的支持来快速实现与之相关的决策。
- en: 'We still haven''t actually closed most of the stories that the iteration started
    with, though, in retrospect, those were written with goals that were too broad
    for them to be closed without UI development. Had they been broken out into two
    stories (or more) each, one of each set, focusing on the end-user goals and needs
    would look pretty much the same:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们实际上还没有关闭大部分迭代开始的故事，尽管回顾起来，这些故事的目标太宽泛，以至于没有UI开发就无法关闭。如果它们被分成两个（或更多）故事，每个故事集中在最终用户的目标和需求上，看起来基本相同：
- en: As an Artisan Manager, I need to be able to create `Artisan` objects in a GUI
    so that I can manage artisans quickly and easily
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠经理，我需要能够在GUI中创建“工匠”对象，以便我可以快速轻松地管理工匠
- en: As an Artisan Manager, I need to be able to delete `Artisan` objects in a GUI
    so that I can manage artisans quickly and easily
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠经理，我需要能够在GUI中删除“工匠”对象，以便我可以快速轻松地管理工匠
- en: 'Each of these would have a corresponding story that focuses more on assuring
    that there would be some code, some functionality that the GUI-related stories
    could start with, and build upon. Those would probably have looked something like
    this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 每个故事都会有一个相应的故事，更侧重于确保会有一些代码，一些与GUI相关的故事可以从中开始，并建立在其上。它们可能看起来像这样：
- en: As
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: As
- en: a UI developer, I need a mechanism to send create Artisan messages to the Gateway
    service so that I can create a UI to execute that process
  id: totrans-271
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为UI开发人员，我需要一种机制来发送创建工匠消息到网关服务，以便我可以创建一个UI来执行该过程
- en: As a UI developer, I need a mechanism to send delete Artisan messages to the
    Gateway service so that I can create a UI to execute that process
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为UI开发人员，我需要一种机制来发送删除工匠消息到网关服务，以便我可以创建一个UI来执行该过程
- en: Alternately, if each of the original stories' development processes had taken
    the approach of making sure that the entire process for each end user action,
    from GUI to service to database to (where applicable) amother user application,
    had tasks associated with it, that would have allowed the stories as they were
    originally written to be completed in their entirety.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果每个原始故事的开发过程都采取了确保每个最终用户操作的整个过程，从GUI到服务到数据库到（如果适用）另一个用户应用程序，都有与之相关的任务，那么原始编写的故事就可以完全完成。
- en: This kind of gap, in a real-world situation, would have been addressed as part
    of grooming the stories, before they were even put into an active iteration. Story
    grooming is a development team activity, where incoming stories are examined,
    fleshed out, and (when necessary) tweaked with the help of any stakeholders to
    assure that they can be accomplished. Part of this process involves reviewing
    stories and their attendant tasks to assure that everything needed for the story
    to be worked to completion is accounted for. A review of that nature would almost
    certainly have revealed that either the stories, as originally presented here,
    had tasks that represented everything the story needed, or that splitting the
    original stories into UI and mechanism stories was necessary.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的情况下，这种差距本来应该在故事整理的过程中得到解决，甚至在它们被放入活跃迭代之前就得到解决。故事整理是开发团队的活动，其中对传入的故事进行审查、完善，并在必要时与利益相关者一起进行调整，以确保可以完成。这个过程的一部分涉及审查故事及其相关任务，以确保故事完成所需的一切都得到了考虑。这样的审查几乎肯定会揭示，要么原始故事在这里最初的呈现中有代表故事所需的一切的任务，要么将原始故事分成UI和机制故事是必要的。
- en: 'Still, a few stories from the original set feel like they can be closed, barring
    tweaks that might surface during the demonstration and review:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，原始集合中的一些故事似乎可以关闭，除非在演示和审查过程中出现调整：
- en: As an Artisan, I need to be able to send data changes to the Artisan Gateway
    so that those changes can be propagated and acted upon as needed
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要能够将数据更改发送到Artisan Gateway，以便根据需要传播和执行这些更改
- en: As a Central Office user, I need to be able to send data changes to the Artisan
    Gateway so that those changes can be propagated and acted upon as needed
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为中央办公室用户，我需要能够将数据更改发送到Artisan Gateway，以便根据需要传播和执行这些更改
- en: As any user sending messages across to or from the Artisan Gateway service,
    I need those messages to be signed so that they can be validated before being
    acted upon
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为向Artisan Gateway服务发送消息的任何用户，我需要这些消息被签名，以便在执行之前进行验证
- en: Where hms_sys development could go from here
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_sys的开发未来可能会走向何方
- en: There's still a substantial amount of work needed for `hms_sys` to be *truly*
    complete, but all of the design, development, and process principles that needed
    to be exposed have been at this point, so this feels like a good point to break
    away from it and move on to other things. Before moving on, though, there are
    some easily identified items that could be picked up and worked on.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`hms_sys`仍然需要大量工作才能*真正*完成，但所有需要暴露的设计、开发和流程原则到目前为止都已经完成，所以这感觉是一个很好的时机，可以离开这个项目，继续其他事情。然而，在继续之前，还有一些容易识别的项目可以被拾起并进行工作。'
- en: Code review, refactoring, and cleanup
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码审查、重构和清理
- en: There are at least a couple of items in the code as it stands right now that
    could be reviewed and remedied.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 目前的代码中至少有几个项目可以进行审查和纠正。
- en: So far, there's been no call for any request-response process that would need
    to simply return any of the data objects. There are, however, methods that were
    stubbed out to address those potential needs (the various `response_{object}` methods
    in `ArtisanGatewayDaemon`), even though the needs themselves never surfaced. While
    it doesn't hurt to leave them in place, that would, ultimately, entail having
    test case classes and/or test methods that are required by the testing policy
    that don't really serve any purpose. The methods being tested don't do anything,
    and aren't expected to in the foreseeable future. At a minimum, these methods
    and any tests associated with them should probably be commented out, but they
    could even be completely removed, keeping the code cleaner.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有要求任何请求-响应过程，只需简单返回任何数据对象。然而，有一些方法被存根化，以解决这些潜在需求（在`ArtisanGatewayDaemon`中的各种`response_{object}`方法），即使这些需求从未出现过。虽然保留它们不会有害，但最终会需要测试用例类和/或测试方法，这些类和方法是测试政策所要求的，但实际上并没有任何作用。被测试的方法什么也不做，也不会在可预见的未来做任何事情。至少，这些方法及与之相关的任何测试可能应该被注释掉，甚至可以完全删除，以保持代码更清晰。
- en: Since distinct classes were created for orders in both the Artisan and Central
    Office contexts, taking some time to winnow out their common functionality and
    interface, and re-define the `BaseOrder` class in `hms_core` would clean the codebases
    up a bit too. That would also entail reworking the relevant unit tests, and might
    (probably trivially) touch other classes that use the current `Order` classes.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Artisan和Central Office上为订单创建了不同的类，花一些时间来筛选它们的共同功能和接口，并在`hms_core`中重新定义`BaseOrder`类也会使代码更加清晰。这也将需要重新设计相关的单元测试，并可能（可能是微不足道地）涉及使用当前`Order`类的其他类。
- en: 'The presence of Central Office classes in `hms_core`, while an understandable
    decision at the time, could present a small data integrity risk on a longer term
    basis: as members of `hms_core`, they would, at present, be distributed as part
    of an Artisan application (which depends on `hms_core`), and would be available
    to a disgruntled Artisan, if that were ever to occur. Though the risk is probably
    trivial, it''s certainly not an impossible scenario, and there''s really no reason
    why an Artisan application should have any code that''s intended for use only
    by Central Office staff. Re-organizing those items into a separate project/module,
    or altering the build/packaging process to actively remove that module from the
    Artisan application''s codebase, feels like a good idea, eliminating any concerns
    that might arise about deploying code to users who wouldn''t/shouldn''t use it.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`hms_core`中存在中央办公室类，虽然当时这是可以理解的决定，但从长远来看可能会对数据完整性造成一定风险：作为`hms_core`的成员，它们目前作为Artisan应用程序的一部分分发（依赖于`hms_core`），并且可能会被一个不满意的Artisan使用。尽管风险可能微不足道，但这绝对不是不可能的情况，Artisan应用程序没有任何理由拥有只有中央办公室员工才能使用的代码。重新组织这些项目到一个单独的项目/模块中，或者修改构建/打包过程以主动从Artisan应用程序的代码库中删除该模块，感觉是一个不错的主意，消除了关于部署代码给不应该使用它的用户的任何担忧。'
- en: A similar reorganization effort may be needed later on with respect to where
    the `daemons.py` module lives, and how it's used. At this point, we don't really
    have a design for the end user applications–just a collection of functional requirements
    that have been implemented at a fundamental level, and so there's no real feeling
    for how the applications themselves will function. It's possible that the design
    would involve a local service, even if it's only running while the main application
    is active, in which case keeping `daemons.py` in the `hms_core` namespace makes
    sense. If, on the other hand, the end-user applications don't use such a service,
    then there's no reason to deploy the relevant code in either of the end-user applications
    and moving it into its own deployable package, or into a separate but dependent
    project would not a bad idea.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要对`daemons.py`模块的位置和使用进行类似的重新组织努力，这时我们并没有真正为最终用户应用程序设计，只是一系列在基本层面上实现的功能要求的集合，因此对应用程序本身的功能没有真正的感觉。设计可能涉及本地服务，即使只在主应用程序活动时运行，这种情况下将`daemons.py`保留在`hms_core`命名空间是有意义的。另一方面，如果最终用户应用程序不使用这样的服务，那么没有理由将相关代码部署到任何一个最终用户应用程序中，并将其移入自己的可部署包中，或者移入一个独立但依赖的项目也不是一个坏主意。
- en: There are at least a few unit tests (the ones testing the various `to_data_dict`
    methods are probably the most obvious ones) that, because of the way the test
    arguments are used in deeply nested loops, will, over time, take longer and longer
    to execute. As things stand right now, there are as many as a dozen value variations
    that are (or could be) tested, and only a few values being used per variation.
    With three values per variation, and 12 variations to test, each of which lives
    in its own loop, that's 3^(12)—over half a million—assertions that would be executed
    on every execution of that test method. This takes time to execute. Reworking
    the various nested loop test methods so that each value variant is tested individually,
    un-nesting the loops, would speed up test execution significantly—there would
    be 36 (3 × 12) assertions instead of the half-million needed now. The trade-off
    is that the test code will be substantially longer, and potentially (slightly)
    more difficult to maintain as a result, but the time saved in the long run will
    be worth the effort.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有几个单元测试（测试各种`to_data_dict`方法的测试可能是最明显的）由于测试参数在深度嵌套的循环中的使用方式，随着时间的推移，执行时间会越来越长。目前，有多达十几个值变化被测试（或可能被测试），每个变化只使用了少数值。对于每个变化，有三个值，和12个要测试的变化，每个变化都在自己的循环中，这就是3^(12)——超过50万个——断言将在每次执行该测试方法时执行。这需要时间来执行。重新设计各种嵌套循环测试方法，使每个值变体都单独测试，取消循环嵌套，将显著加快测试执行速度——现在只需要36（3
    × 12）个断言，而不是现在需要的50万个。这样做的代价是测试代码会变得更长，并且可能（稍微）更难以维护，但从长远来看节省的时间将是值得的。
- en: Developing a UI
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发UI
- en: 'There are literally dozens of GUI options available for Python applications,
    even if the list is limited to those that are usable on more than one OS/platform—a
    list is maintained on the Python website at [https://wiki.python.org/moin/GuiProgramming](https://wiki.python.org/moin/GuiProgramming).
    The more widely used are sufficiently feature-rich, and whole books could be written
    about each of them. Noteworthy GUI frameworks and toolkits include the following:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Python应用程序有数十种GUI选项可用，即使列表仅限于可在多个操作系统/平台上使用的选项，Python网站上维护了一个列表（[https://wiki.python.org/moin/GuiProgramming](https://wiki.python.org/moin/GuiProgramming)）。最常用的都具有丰富的功能，每个都可以写一整本书。值得注意的GUI框架和工具包包括以下内容：
- en: '**Tkinter:** Distributed as part of Python installations'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Tkinter：**作为Python安装的一部分分发'
- en: '**PyGObject: **A GUI used for many Linux/Gnome applications, related to GnomePython
    and PyGTK ([https://pygobject.readthedocs.io/en/latest/](https://pygobject.readthedocs.io/en/latest/))'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PyGObject：**用于许多Linux/Gnome应用程序的GUI，与GnomePython和PyGTK相关（[https://pygobject.readthedocs.io/en/latest/](https://pygobject.readthedocs.io/en/latest/)）'
- en: '**Kivy: **This includes support for Android and iOS (iPhone) applications ([https://kivy.org/](https://kivy.org/))'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kivy：**这包括对Android和iOS（iPhone）应用程序的支持（[https://kivy.org/](https://kivy.org/)）'
- en: '**Tkinter** is the *de facto* standard for Python application GUIs, and has
    shipped with Python distributions for a long time. While the GUI elements it provides
    are, in many respects, quite basic, it provides enough of them for a wide range
    of application needs to be met. As one of the more mature options, there is a
    lot of documentation available for it (see [https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)),
    and it is quite stable. There are also a fair number of extension packages available
    that likely address needs that a baseline Tkinter installation may not fulfil,
    including **Python Mega****widgets** (**PMW**—[http://pmw.sourceforge.net/doc/](http://pmw.sourceforge.net/doc/)).
    While Tkinter GUIs may not be the most attractive in the world—their appearance
    is tightly bound to the GUI engine of the underlying OS, with all the variations
    that entails—they are *eminently* functional.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**Tkinter**是Python应用程序GUI的*事实*标准，并且已经随Python发行版一起发布了很长时间。虽然它提供的GUI元素在很多方面都相当基本，但它提供了足够多的元素来满足各种应用程序需求。作为较成熟的选项之一，有大量的文档可用（参见[https://wiki.python.org/moin/TkInter](https://wiki.python.org/moin/TkInter)），而且它非常稳定。还有许多扩展包可用，可能满足基本Tkinter安装无法满足的需求，包括**Python
    Mega****widgets**（**PMW**—[http://pmw.sourceforge.net/doc/](http://pmw.sourceforge.net/doc/)）。虽然Tkinter
    GUI可能不是世界上最吸引人的，但它们的外观与底层操作系统的GUI引擎紧密绑定，具有所有相关的变化，它们是*极其*实用的。'
- en: Tkinter doesn't have complex dependencies, making it extremely portable; a given
    Tkinter GUI will function without alteration on any OS, and simple tweaks based
    on the detection of which OS is present are generally not difficult, though they
    may require significant planning ahead of time.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter没有复杂的依赖关系，使其非常便携；给定的Tkinter GUI将在任何操作系统上都可以正常运行，基于检测存在的操作系统进行的简单调整通常并不困难，尽管可能需要提前进行重大规划。
- en: If you've ever worked on a Linux system that has a Gnome frontend, the odds
    are good that you've been exposed to a **PyGObject**-based GUI, whether you knew
    it or not. Although it's part of the open source Gnome Project, and thus perhaps
    more focused on fulfilling needs for various Linux systems, PyGObject is a viable
    option on Windows and Macintosh systems as well. Like most of the GUI frameworks
    available for Python, PyGObject does involve at least some additional software
    installation, and there may be extensive dependencies involved, even if they aren't
    directly visible, but those should be managed by the installation process of PyGObject
    itself. PyGObject assumes at least some control over widget appearance, taking
    that control away from the underlying GUI engine of the OS in order to provide
    a more attractive appearance.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经在具有Gnome前端的Linux系统上工作过，很可能你已经接触过基于**PyGObject**的GUI，无论你是否知道。尽管它是开源Gnome项目的一部分，因此可能更专注于满足各种Linux系统的需求，但PyGObject在Windows和Macintosh系统上也是一个可行的选择。与Python可用的大多数GUI框架一样，PyGObject确实涉及至少一些额外的软件安装，即使它们不是直接可见的，但这些应该由PyGObject本身的安装过程来管理。PyGObject假定至少对部件外观有一定控制，从操作系统的底层GUI引擎中夺取这种控制，以提供更吸引人的外观。
- en: '**Kivy** is a popular option, and is often cited as the go-to GUI framework
    for Python applications needing mobile technology support (Android and iOS applications).
    Judging by several of the entries in their gallery page ([https://kivy.org/#gallery](https://kivy.org/#gallery)),
    it can provide very clean and attractive GUIs. Kivy uses its own design language
    to define how a GUI is laid out, and what the elements look like. Mobile application
    support through Kivy is accomplished by bundling a complete Python installation
    with each Android `apk` or iOS `app` file.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '**Kivy**是一个流行的选择，通常被引用为需要移动技术支持的Python应用程序的首选GUI框架（Android和iOS应用程序）。根据他们的画廊页面中的几个条目来判断（[https://kivy.org/#gallery](https://kivy.org/#gallery)），它可以提供非常干净和吸引人的GUI。Kivy使用自己的设计语言来定义GUI的布局和元素外观。通过Kivy实现对移动应用程序的支持是通过将完整的Python安装与每个Android
    `apk`或iOS `app`文件捆绑在一起来实现的。'
- en: 'Another option, though it might sound odd at first, would be to implement the
    Artisan and Central Office applications as local web servers, and use HTML, CSS,
    and JavaScript to create the GUI. This isn''t as far-fetched as it might sound:
    Python includes a variety of web server classes in the `http.server` module ([https://docs.python.org/3.6/library/http.server.html](https://docs.python.org/3.6/library/http.server.html)),
    and even if none of them were ready to use as-is, they could be extended to provide
    whatever functionality was lacking. Though the servers provided might not be as
    powerful or feature-rich as a dedicated web server (Apache or IIS), they wouldn''t
    really need to be, since there would be only a handful of users accessing it at
    any given time.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择，虽然一开始听起来可能有点奇怪，但是可以将Artisan和Central Office应用程序实现为本地Web服务器，并使用HTML、CSS和JavaScript来创建GUI。这并不像听起来那么牵强：Python在`http.server`模块中包含各种Web服务器类（[https://docs.python.org/3.6/library/http.server.html](https://docs.python.org/3.6/library/http.server.html)），即使它们中没有一个可以直接使用，也可以扩展它们以提供所缺少的功能。虽然提供的服务器可能不像专用Web服务器（Apache或IIS）那样强大或功能丰富，但它们实际上并不需要，因为在任何给定时间只有少数用户访问它。
- en: Order fulfilment and shipping APIs
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单履行和航运API
- en: 'The basic data changes involved in the order fulfilment process that an Artisan
    would execute are reasonably detailed and understood, but there is certainly room
    for improvement. One feature that would be very nice to have would be integration
    with online APIs for the various shipping companies that would be used to deliver
    those fulfilled order items. That integration, depending on the shape of all the
    requirements around it, could be a major development effort all by itself, and
    could include the following:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan执行的订单履行过程中涉及的基本数据更改是相当详细和理解的，但肯定还有改进的空间。一个非常好的功能是与用于交付这些已履行订单物品的各种航运公司的在线API集成。这种集成，取决于其周围的所有要求的形状，可能本身就是一个重大的开发工作，并且可能包括以下内容：
- en: Allowing an Artisan user to provide a package  or shipping ID during transactions
    for both individual and multiple item fulfilment
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许工艺品用户在交易过程中提供包裹或运输ID，用于单个和多个商品的履行。
- en: Sending a confirmation email (if the APIs don't handle that on their own) to
    the customer with shipment tracking information
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向客户发送确认邮件（如果API不能自行处理）并提供发货跟踪信息
- en: Sending some sort of notification to the Central Office that order items have
    been fulfilled, which would be a trigger for whatever manual or automatic process
    which pays the Artisan for the items shipped
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向中央办公室发送某种通知，表明订单商品已经发货，这将触发手动或自动支付工艺品制作者的流程
- en: Over and above that, there would be definitions needed for the various shipper
    APIs (since it's unlikely that any two of them will use the exact same request
    structure) and testing strategies and implementations for them, quite possibly
    with extensive mocking, if the APIs themselves don't provide any test harnesses.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还需要为各种承运人API定义（因为不太可能有两个API使用完全相同的请求结构），并为它们制定测试策略和实施，如果API本身没有提供任何测试工具，很可能需要进行广泛的模拟。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The testing of services, particularly in a repeatable fashion that can be used
    as ongoing regression testing, has its own particular challenges, but none of
    them is insurmountable. The methods presented here are a solid starting point,
    and could be elaborated on in as much detail as required to meet almost any testing
    requirements. That said, these are reasonably complete, and easily managed/maintained
    should new testing requirements surface, whether through the discovery and correction
    of bugs, or the advent of new functional requirements that have to be reflected
    in tests.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的测试，特别是以可重复的方式进行的测试，可以用作持续的回归测试，具有自己的特殊挑战，但没有一个是不可克服的。这里提出的方法是一个坚实的起点，并且可以根据需要详细阐述，以满足几乎任何测试要求。也就是说，这些方法是相当完整的，如果出现新的测试要求，无论是通过发现和修复错误，还是出现新的功能要求需要在测试中反映，都可以很容易地管理/维护。
