- en: OOP, Decorators, and Iterators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP，装饰器和迭代器
- en: La classe non è acqua. (Class will out)– Italian saying
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: La classe non è acqua.（类似水）- 意大利谚语
- en: I could probably write a whole book about **object-oriented programming** (**OOP**)
    and classes. In this chapter, I'm facing the hard challenge of finding the balance
    between breadth and depth. There are simply too many things to tell, and plenty
    of them would take more than this whole chapter if I described them in depth.
    Therefore, I will try to give you what I think is a good panoramic view of the
    fundamentals, plus a few things that may come in handy in the next chapters. Python's
    official documentation will help in filling the gaps.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我可能会写一本关于**面向对象编程**（**OOP**）和类的整本书。在本章中，我面临着在广度和深度之间找到平衡的艰难挑战。有太多的事情要讲述，其中很多如果我深入描述的话，将会占用整个章节以上的篇幅。因此，我将尽量给你一个我认为是对基础知识的良好全景视图，再加上一些在接下来的章节中可能会派上用场的东西。Python的官方文档将有助于填补这些空白。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Decorators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器
- en: OOP with Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的OOP
- en: Iterators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器
- en: Decorators
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器
- en: In Chapter 5, *Saving Time and Memory*, I measured the execution time of various
    expressions. If you recall, I had to initialize a variable to the start time,
    and subtract it from the current time after execution in order to calculate the
    elapsed time. I also printed it on the console after each measurement. That was
    very tedious.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在第5章《节省时间和内存》中，我测量了各种表达式的执行时间。如果你还记得的话，我不得不初始化一个变量到开始时间，并在执行后从当前时间中减去它，以计算经过的时间。我还在每次测量后在控制台上打印出来。那太麻烦了。
- en: 'Every time you find yourself repeating things, an alarm bell should go off.
    Can you put that code in a function and avoid repetition? The answer most of the
    time is *yes*, so let''s look at an example:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你发现自己重复做某些事情时，警报应该响起。你能把那段代码放到一个函数中，避免重复吗？大多数情况下答案是*是*，所以让我们看一个例子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding code, I defined two functions, `f` and `g`, which do nothing
    but sleep (by 0.3 and 0.5 seconds, respectively). I used the `sleep` function
    to suspend the execution for the desired amount of time. Notice how the time measure
    is pretty accurate. Now, how do we avoid repeating that code and those calculations?
    One first potential approach could be the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我定义了两个函数`f`和`g`，它们除了休眠（分别为0.3和0.5秒）之外什么也不做。我使用`sleep`函数来暂停执行所需的时间。请注意时间测量非常准确。现在，我们如何避免重复那段代码和那些计算呢？一个潜在的方法可能是：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Ah, much better now. The whole timing mechanism has been encapsulated into
    a function so we don''t repeat code. We print the function name dynamically and
    it''s easy enough to code. What if we need to pass arguments to the function we
    measure? This code would get just a bit more complicated, so let''s see an example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 啊，现在好多了。整个计时机制已经封装到一个函数中，所以我们不需要重复代码。我们可以动态打印函数名称，编码起来也很容易。如果我们需要将参数传递给我们测量的函数呢？这段代码可能会变得有点复杂，所以让我们看一个例子：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, `f` is expecting to be fed `sleep_time` (with a default value of `0.1`),
    so we don't need `g` any more. I also had to change the `measure` function so
    that it is now accepts a function, any variable positional arguments, and any
    variable keyword arguments. In this way, whatever we call `measure` with, we redirect
    those arguments to the call to `func` we do inside.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`f`期望被提供`sleep_time`（默认值为`0.1`），所以我们不再需要`g`。我还必须更改`measure`函数，使其现在接受一个函数、任意变量位置参数和任意变量关键字参数。这样，无论我们用什么调用`measure`，我们都会将这些参数重定向到我们在内部调用`func`的调用中。
- en: 'This is very good, but we can push it a little bit further. Let''s say we want
    to somehow have that timing behavior built-in into the `f` function, so that we
    could just call it and have that measure taken. Here''s how we could do it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们可以再推进一点。假设我们想要在`f`函数中内置这种计时行为，这样我们就可以直接调用它并进行测量。我们可以这样做：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code is probably not so straightforward. Let's see what happens
    here. The magic is in the **decoration point**. We basically reassign `f` with
    whatever is returned by `measure` when we call it with `f` as an argument. Within
    `measure`, we define another function, `wrapper`, and then we return it. So, the
    net effect is that after the decoration point, when we call `f`, we're actually
    calling `wrapper`. Since the `wrapper` inside is calling `func`, which is `f`,
    we are actually closing the loop like that. If you don't believe me, take a look
    at the last line.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可能并不那么直接。让我们看看这里发生了什么。魔法在于**装饰点**。当我们用`f`作为参数调用`measure`时，我们基本上用`measure`返回的任何东西重新分配了`f`。在`measure`中，我们定义了另一个函数`wrapper`，然后返回它。因此，在装饰点之后的效果是，当我们调用`f`时，实际上是在调用`wrapper`。由于内部的`wrapper`调用了`func`，也就是`f`，我们实际上是这样关闭了循环。如果你不相信我，看看最后一行。
- en: '`wrapper` is actually... a wrapper. It takes variable and positional arguments,
    and calls `f` with them. It also does the time measurement calculation around
    the call.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper`实际上是...一个包装器。它接受变量和位置参数，并用它们调用`f`。它还在调用周围进行时间测量计算。'
- en: 'This technique is called **decoration**, and `measure` is, effectively, a **decorator**.
    This paradigm became so popular and widely used that at some point, Python added
    a special syntax for it (check out [https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/)).
    Let''s explore three cases: one decorator, two decorators, and one decorator that
    takes arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术称为**装饰**，而`measure`实际上是一个**装饰器**。这种范式变得如此受欢迎和广泛使用，以至于Python在某个时候添加了一个专门的语法（查看[https://www.python.org/dev/peps/pep-0318/](https://www.python.org/dev/peps/pep-0318/)）。让我们探讨三种情况：一个装饰器，两个装饰器和一个带参数的装饰器：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Basically, instead of manually reassigning the function to what was returned
    by the decorator, we prepend the definition of the function with the special syntax, `@decorator_name`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们不需要手动将函数重新分配给装饰器返回的内容，而是在函数的定义前面加上特殊的语法`@decorator_name`。
- en: 'We can apply multiple decorators to the same function in the following way:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以以下方式将多个装饰器应用于同一个函数：
- en: '[PRE6]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When applying multiple decorators, pay attention to the order. In the preceding
    example, `func` is decorated with `deco2` first, and the result is decorated with
    `deco1`. A good rule of thumb is: *the closer the decorator is to the function,
    the sooner it is applied*.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用多个装饰器时，要注意顺序。在上面的例子中，首先用`deco2`装饰`func`，然后用`deco1`装饰结果。一个很好的经验法则是：*装饰器离函数越近，越早应用*。
- en: 'Some decorators can take arguments. This technique is generally used to produce
    other decorators. Let''s look at the syntax, and then we''ll see an example of
    it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 有些装饰器可以接受参数。这种技术通常用于生成其他装饰器。让我们先看一下语法，然后再看一个例子：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, this case is a bit different. First, `decoarg` is called with
    the given arguments, and then its return value (the actual decorator) is called
    with `func`. Before I give you another example, let''s fix one thing that is bothering
    me. I don''t want to lose the original function name and docstring (and other
    attributes as well, check the documentation for the details) when I decorate it.
    But because inside our decorator we return `wrapper`, the original attributes
    from `func` are lost and `f` ends up being assigned the attributes of `wrapper`.
    There is an easy fix for that from the beautiful `functools` module. I will fix
    the last example, and I will also rewrite its syntax to use the `@` operator:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这种情况有点不同。首先，使用给定的参数调用`decoarg`，然后调用它的返回值（实际的装饰器）与`func`。在我给你另一个例子之前，让我们解决一个让我困扰的问题。我不想在装饰函数时丢失原始函数名称和文档字符串（以及其他属性，具体细节请查看文档）。但是因为在我们的装饰器内部返回了`wrapper`，来自`func`的原始属性就丢失了，`f`最终被分配了`wrapper`的属性。`functools`模块有一个简单的解决方法。我将修复最后一个例子，并且还将重写其语法以使用`@`运算符：
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now we're talking! As you can see, all we need to do is to tell Python that
    `wrapper` actually wraps `func` (by means of the `wraps` function), and you can
    see that the original name and docstring are now maintained.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们说得通了！正如你所看到的，我们所需要做的就是告诉Python`wrapper`实际上包装了`func`（通过`wraps`函数），你可以看到原始名称和文档字符串现在得到了保留。
- en: 'Let''s see another example. I want a decorator that prints an error message
    when the result of a function is greater than a certain threshold. I will also
    take this opportunity to show you how to apply two decorators at once:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子。我想要一个装饰器，在函数的结果大于一定阈值时打印错误消息。我还将利用这个机会向你展示如何同时应用两个装饰器：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Take your time in studying the preceding example until you are sure you understand
    it well. If you do, I don't think there is any decorator you now won't be able
    to write.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 花点时间来研究上面的例子，直到你确信你理解得很好。如果你理解了，我认为现在没有任何装饰器是你写不出来的。
- en: 'I had to enhance the `measure` decorator, so that its `wrapper` now returns
    the result of the call to `func`. The `max_result` decorator does that as well,
    but before returning, it checks that `result` is not greater than `100`, which
    is the maximum allowed. I decorated `cube` with both of them. First, `max_result`
    is applied, then `measure`. Running this code yields this result:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不增强`measure`装饰器，使得它的`wrapper`现在返回对`func`的调用结果。`max_result`装饰器也是这样做的，但在返回之前，它检查`result`是否大于`100`，这是允许的最大值。我用这两个装饰器装饰了`cube`。首先应用`max_result`，然后是`measure`。运行这段代码会产生这个结果：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For your convenience, I have separated the results of the two calls with a blank
    line. In the first call, the result is `8`, which passes the threshold check.
    The running time is measured and printed. Finally, we print the result (`8`).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，我用一个空行分隔了两次调用的结果。在第一次调用中，结果是`8`，通过了阈值检查。运行时间被测量并打印。最后，我们打印结果（`8`）。
- en: On the second call, the result is `125`, so the error message is printed, the
    result returned, and then it's the turn of `measure`, which prints the running
    time again, and finally, we print the result (`125`).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二次调用中，结果是`125`，所以错误消息被打印，结果被返回，然后轮到`measure`，再次打印运行时间，最后，我们打印结果（`125`）。
- en: Had I decorated the `cube` function with the same two decorators but in a different
    order, the error message would have followed the line that prints the running
    time, instead of have preceded it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我用不同顺序的相同两个装饰器装饰`cube`函数，错误消息将会在打印运行时间的行之后而不是之前。
- en: A decorator factory
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器工厂
- en: 'Let''s simplify this example now, going back to a single decorator: `max_result`.
    I want to make it so that I can decorate different functions with different thresholds,
    I don''t want to write one decorator for each threshold. Let''s amend `max_result`
    so that it allows us to decorate functions specifying the threshold dynamically:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们简化这个例子，回到一个单一的装饰器：`max_result`。我想让它这样做，以便我可以用不同的阈值装饰不同的函数，我不想为每个阈值编写一个装饰器。让我们修改`max_result`，以便它允许我们动态地指定阈值来装饰函数：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code shows you how to write a **decorator factory**. If you recall,
    decorating a function with a decorator that takes arguments is the same as writing
    `func = decorator(argA, argB)(func)`, so when we decorate `cube` with `max_result(75)`,
    we're doing `cube = max_result(75)(cube)`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码向你展示了如何编写**装饰器工厂**。如果你还记得，用带参数的装饰器装饰函数与编写`func = decorator(argA, argB)(func)`是一样的，所以当我们用`max_result(75)`装饰`cube`时，我们实际上是在做`cube
    = max_result(75)(cube)`。
- en: Let's go through what happens, step by step. When we call `max_result(75)`,
    we enter its body. A `decorator` function is defined inside, which takes a function
    as its only argument. Inside that function, the usual decorator trick is performed.
    We define `wrapper`, inside of which we check the result of the original function's
    call. The beauty of this approach is that from the innermost level, we can still
    refer to as both `func` and `threshold`, which allows us to set the threshold
    dynamically.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步步地看发生了什么。当我们调用`max_result(75)`时，我们进入它的主体。在里面定义了一个`decorator`函数，它以函数作为唯一的参数。在该函数内部执行了通常的装饰器技巧。我们定义了`wrapper`，在其中我们检查原始函数调用的结果。这种方法的美妙之处在于，从最内层，我们仍然可以动态地引用`func`和`threshold`，这使我们能够动态地设置阈值。
- en: '`wrapper` returns `result`, `decorator` returns `wrapper`, and `max_result`
    returns `decorator`. This means that our `cube = max_result(75)(cube)` call actually
    becomes `cube = decorator(cube)`. Not just any `decorator` though, but one for
    which `threshold` has a value of `75`. This is achieved by a mechanism called
    **closure**, which is outside of the scope of this chapter but still very interesting,
    so I mentioned it for you to do some research on it.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrapper`返回`result`，`decorator`返回`wrapper`，`max_result`返回`decorator`。这意味着我们的`cube
    = max_result(75)(cube)`调用实际上变成了`cube = decorator(cube)`。不仅仅是任何`decorator`，而是`threshold`的值为`75`的`decorator`。这是通过一种称为**闭包**的机制实现的，这超出了本章的范围，但仍然非常有趣，所以我提到它让您进行一些研究。'
- en: 'Running the last example produces the following result:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上一个示例会产生以下结果：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code allows me to use the `max_result` decorator with different
    thresholds at my own will, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码允许我随心所欲地使用`max_result`装饰器，就像这样：
- en: '[PRE13]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that every decoration uses a different `threshold` value.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，每个装饰都使用不同的`threshold`值。
- en: Decorators are very popular in Python. They are used quite often and they simplify
    (and beautify, I dare say) the code a lot.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器在Python中非常受欢迎。它们经常被使用，并且大大简化（我敢说还美化）了代码。
- en: Object-oriented programming (OOP)
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）
- en: 'It''s been quite a long and hopefully nice journey and, by now, we should be
    ready to explore OOP. I''ll use the definition from Kindler, E.; Krivy, I. (2011).
    *Object-oriented simulation of systems with sophisticated control* by *International
    Journal of General Systems*, and adapt it to Python:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当漫长而希望愉快的旅程，到现在为止，我们应该准备好去探索面向对象编程了。我将使用Kindler, E.; Krivy, I. (2011)的定义。*Object-oriented
    simulation of systems with sophisticated control* by *International Journal of
    General Systems*，并将其适应到Python中：
- en: Object-oriented programming (OOP) is a programming paradigm based on the concept
    of "objects", which are data structures that contain data, in the form of attributes,
    and code, in the form of functions known as methods. A distinguishing feature
    of objects is that an object's method can access and often modify the data attributes
    of the object with which they are associated (objects have a notion of "self").
    In OO programming, computer programs are designed by making them out of objects
    that interact with one another.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）是一种基于“对象”概念的编程范式，对象是包含数据（属性形式）和代码（方法形式）的数据结构。对象的一个显著特征是对象的方法可以访问并经常修改与其关联的数据属性（对象具有“self”的概念）。在面向对象编程中，计算机程序是通过使它们由相互交互的对象构成来设计的。
- en: Python has full support for this paradigm. Actually, as we have already said,
    *everything in Python is an object*, so this shows that OOP is not just supported
    by Python, but it's a part of its very core.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Python完全支持这种范式。实际上，正如我们已经说过的，*Python中的一切都是对象*，因此这表明OOP不仅受到Python的支持，而且它是其核心的一部分。
- en: The two main players in OOP are **objects** and **classes**. Classes are used
    to create objects (objects are instances of the classes from which they were created),
    so we could see them as instance factories. When objects are created by a class,
    they inherit the class attributes and methods. They represent concrete items in
    the program's domain.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的两个主要角色是**对象**和**类**。类用于创建对象（对象是从它们创建的类的实例），因此我们可以将它们视为实例工厂。当对象由类创建时，它们继承类的属性和方法。它们代表程序领域中的具体项目。
- en: The simplest Python class
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最简单的Python类
- en: 'I will start with the simplest class you could ever write in Python:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我将从您可以在Python中编写的最简单的类开始：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s run the preceding code and explain it line by line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行前面的代码，并逐行解释它：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Simplest` class I defined has only the `pass` instruction in its body,
    which means it doesn't have any custom attributes or methods. Brackets after the
    name are optional if empty. I will print its type (`__main__` is the name of the
    scope in which top-level code executes), and I am aware that, in the comment,
    I wrote *object* instead of *class*. It turns out that, as you can see by the
    result of that `print`, *classes are actually objects*. To be precise, they are
    instances of `type`. Explaining this concept would lead us to a talk about **metaclasses**
    and **metaprogramming**, advanced concepts that require a solid grasp of the fundamentals
    to be understood and are beyond the scope of this chapter. As usual, I mentioned
    it to leave a pointer for you, for when you'll be ready to dig deeper.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我定义的`Simplest`类在其主体中只有`pass`指令，这意味着它没有任何自定义属性或方法。如果为空，则名称后面的括号是可选的。我将打印它的类型（`__main__`是顶层代码执行的范围的名称），我知道，在注释中，我写的是*object*而不是*class*。事实证明，正如您可以从`print`的结果中看到的那样，*类实际上是对象*。准确地说，它们是`type`的实例。解释这个概念将导致我们讨论**元类**和**元编程**，这些是需要牢固掌握基本原理才能理解的高级概念，超出了本章的范围。像往常一样，我提到它是为了给您留下一个指针，以便在您准备深入了解时使用。
- en: 'Let''s go back to the example: I used `Simplest` to create an instance, `simp`.
    You can see that the syntax to create an instance is the same as we use to call
    a function. Then we print what type `simp` belongs to and we verify that `simp`
    is in fact an instance of `Simplest`. I''ll show you a better way of doing this
    later on in the chapter.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到这个例子：我使用`Simplest`创建了一个实例`simp`。您可以看到创建实例的语法与我们调用函数的方式相同。然后我们打印`simp`属于的类型，并验证`simp`实际上是`Simplest`的一个实例。我将在本章后面向您展示更好的方法。
- en: 'Up to now, it''s all very simple. What happens when we write `class ClassName():
    pass`, though? Well, what Python does is create a class object and assign it a
    name. This is very similar to what happens when we declare a function using `def`.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，一切都很简单。但是，当我们写`class ClassName(): pass`时会发生什么呢？嗯，Python所做的是创建一个类对象并为其分配一个名称。这与我们使用`def`声明函数时发生的情况非常相似。'
- en: Class and object namespaces
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象的命名空间
- en: After the class object has been created (which usually happens when the module
    is first imported), it basically represents a namespace. We can call that class
    to create its instances. Each instance inherits the class attributes and methods
    and is given its own namespace. We already know that, to walk a namespace, all
    we need to do is to use the dot (`.`) operator.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在类对象创建后（通常在模块首次导入时发生），它基本上代表一个命名空间。我们可以调用该类来创建其实例。每个实例都继承了类属性和方法，并被赋予了自己的命名空间。我们已经知道，要遍历命名空间，我们只需要使用点（`.`）运算符。
- en: 'Let''s look at another example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, I have defined a class attribute called `species`.
    Any variable defined in the body of a class is an attribute that belongs to that
    class. In the code, I have also defined `Person.alive`, which is another class
    attribute. You can see that there is no restriction on accessing that attribute
    from the class. You can see that `man`, which is an instance of `Person`, inherits
    both of them, and reflects them instantly when they change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我定义了一个名为`species`的类属性。在类的主体中定义的任何变量都是属于该类的属性。在代码中，我还定义了`Person.alive`，这是另一个类属性。你可以看到从类中访问该属性没有限制。你可以看到`man`是`Person`的一个实例，它继承了它们两个，并在它们改变时立即反映出来。
- en: '`man` has also two attributes that belong to its own namespace and therefore
    are called **instance attributes**: `name` and `surname`.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`man`也有两个属于它自己命名空间的属性，因此被称为**实例属性**：`name`和`surname`。'
- en: Class attributes are shared among all instances, while instance attributes are
    not; therefore, you should use class attributes to provide the states and behaviors
    to be shared by all instances, and use instance attributes for data that belongs
    just to one specific object.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 类属性在所有实例之间共享，而实例属性不共享；因此，你应该使用类属性来提供所有实例共享的状态和行为，并使用实例属性来存储只属于一个特定对象的数据。
- en: Attribute shadowing
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性遮蔽
- en: 'When you search for an attribute in an object, if it is not found, Python keeps
    searching in the class that was used to create that object (and keeps searching
    until it''s either found or the end of the inheritance chain is reached). This
    leads to an interesting shadowing behavior. Let''s look at another example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在对象中搜索属性时，如果没有找到，Python会继续在用于创建该对象的类中搜索（并一直搜索，直到找到或达到继承链的末尾）。这导致了一个有趣的遮蔽行为。让我们看另一个例子：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code is very interesting. We have defined a class called `Point`
    with two class attributes, `x` and `y`. When we create an instance, `p`, you can
    see that we can print both `x` and `y` from the `p` namespace (`p.x` and `p.y`).
    What happens when we do that is Python doesn't find any `x` or `y` attributes
    on the instance, and therefore searches the class, and finds them there.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常有趣。我们定义了一个名为`Point`的类，其中有两个类属性`x`和`y`。当我们创建一个实例`p`时，你可以看到我们可以从`p`的命名空间（`p.x`和`p.y`）打印出`x`和`y`。当我们这样做时，Python在实例上找不到任何`x`或`y`属性，因此搜索类，并在那里找到它们。
- en: Then we give `p` its own `x` attribute by assigning `p.x = 12`. This behavior
    may appear a bit weird at first, but if you think about it, it's exactly the same
    as what happens in a function that declares `x = 12` when there is a global `x
    = 10` outside. We know that `x = 12` won't affect the global one, and for classes
    and instances, it is exactly the same.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们通过分配`p.x = 12`给`p`赋予了它自己的`x`属性。这种行为一开始可能看起来有点奇怪，但是如果你仔细想想，它与在函数中发生的事情完全相同，当外部有一个全局`x
    = 10`时，函数声明`x = 12`。我们知道`x = 12`不会影响全局变量，对于类和实例来说，情况也是一样的。
- en: After assigning `p.x = 12`, when we print it, the search doesn't need to read
    the class attributes, because `x` is found on the instance, therefore we get `12`
    printed out. We also print `Point.x`, which refers to `x` in the class namespace.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在分配`p.x = 12`之后，当我们打印它时，搜索不需要读取类属性，因为`x`在实例中找到了，因此我们得到了`12`的输出。我们还打印了`Point.x`，它指的是类命名空间中的`x`。
- en: And then, we delete `x` from the namespace of `p`, which means that, on the
    next line, when we print it again, Python will go again and search for it in the
    class, because it won't be found in the instance any more.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`p`的命名空间中删除`x`，这意味着在下一行，当我们再次打印它时，Python将再次在类中搜索它，因为它在实例中不再被找到。
- en: The last three lines show you that assigning attributes to an instance doesn't
    mean that they will be found in the class. Instances get whatever is in the class,
    but the opposite is not true.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后三行向你展示了将属性分配给实例并不意味着它们将在类中被找到。实例得到了类中的所有内容，但反之则不成立。
- en: What do you think about putting the `x` and `y` coordinates as class attributes?
    Do you think it was a good idea? What if you added another instance of `Point`?
    Would that help to show why class attributes can be very useful?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为将`x`和`y`坐标作为类属性是一个好主意吗？如果你添加另一个`Point`的实例会怎么样？这是否有助于说明类属性为什么非常有用？
- en: Me, myself, and I – using the self variable
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我自己和我 - 使用self变量
- en: 'From within a class method, we can refer to an instance by means of a special
    argument, called `self` by convention. `self` is always the first attribute of
    an instance method. Let''s examine this behavior together with how we can share,
    not just attributes, but methods with all instances:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法内部，我们可以通过一个特殊的参数`self`来引用一个实例，按照惯例称之为`self`。`self`始终是实例方法的第一个属性。让我们一起研究这种行为，以及我们如何可以与所有实例共享，不仅是属性，还有方法：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note how the `area` method is used by `sq`. The two calls, `Square.area(sq)`
    and `sq.area()`, are equivalent, and teach us how the mechanism works. Either
    you pass the instance to the method call (`Square.area(sq)`), which within the
    method will take the name `self`, or you can use a more comfortable syntax, `sq.area()`,
    and Python will translate that for you behind the scenes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`area`方法如何被`sq`使用。两个调用`Square.area(sq)`和`sq.area()`是等价的，并教会我们机制是如何工作的。你可以将实例传递给方法调用（`Square.area(sq)`），在方法内部将使用名称`self`，或者你可以使用更舒适的语法`sq.area()`，Python会在幕后为你翻译它。
- en: 'Let''s look at a better example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个更好的例子：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code shows you that nothing prevents us from using arguments when
    declaring methods. We can use the exact same syntax as we used with the function,
    but we need to remember that the first argument will always be the instance. We
    don't need to necessarily call it `self`, but it's the convention, and this is
    one of the few cases where it's very important to abide by it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码向您展示了，在声明方法时没有任何阻止我们使用参数。我们可以使用与函数相同的语法，但需要记住第一个参数始终是实例。我们不一定需要将其称为`self`，但这是约定，这是为数不多的非常重要遵守的情况之一。
- en: Initializing an instance
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化实例
- en: 'Have you noticed how, before calling `p1.final_price(...)`, we had to assign
    `net_price` to `p1`? There is a better way to do it. In other languages, this
    would be called a **constructor**, but in Python, it''s not. It is actually an
    **initializer**, since it works on an already-created instance, and therefore
    it''s called `__init__`. It''s a *magic method*, which is run right after the
    object is created. Python objects also have a `__new__` method, which is the actual
    constructor. In practice, it''s not so common to have to override it though, it''s
    a practice that is mostly used when coding metaclasses, which as we mentioned,
    is a fairly advanced topic that we won''t explore in the book:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到，在调用`p1.final_price(...)`之前，我们必须将`net_price`赋给`p1`？有更好的方法可以做到这一点。在其他语言中，这将被称为**构造函数**，但在Python中不是。它实际上是一个**初始化程序**，因为它在已创建的实例上工作，因此被称为`__init__`。它是一个*魔术方法*，在对象创建后立即运行。Python对象还有一个`__new__`方法，这才是真正的构造函数。实际上，我们通常不需要覆盖它，这种做法在编写元类时才会用到，正如我们提到的，这是一个相当高级的主题，我们不会在本书中探讨：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Things are finally starting to take shape. When an object is created, the `__init__`
    method is automatically run for us. In this case, I coded it so that when we create
    an object (by calling the class name like a function), we pass arguments to the
    creation call, like we would on any regular function call. The way we pass parameters
    follows the signature of the `__init__` method, and therefore, in the two creation
    statements, `10` and `7` will be `side_a` for `r1` and `r2`, respectively, while
    `4` and `3` will be `side_b`. You can see that the call to `area()` from `r1`
    and `r2` reflects that they have different instance arguments. Setting up objects
    in this way is much nicer and more convenient.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 事情终于开始有了眉目。当一个对象被创建时，`__init__`方法会自动运行。在这种情况下，我编写了这样一个代码，当我们创建一个对象（通过调用类名像调用函数一样），我们传递参数给创建调用，就像我们在任何常规函数调用中一样。我们传递参数的方式遵循`__init__`方法的签名，因此，在两个创建语句中，`10`和`7`将分别成为`r1`和`r2`的`side_a`，而`4`和`3`将成为`side_b`。您可以看到从`r1`和`r2`调用`area()`反映了它们具有不同的实例参数。以这种方式设置对象更加美观和方便。
- en: OOP is about code reuse
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP是关于代码重用的
- en: 'By now it should be pretty clear: *OOP is all about code reuse*. We define
    a class, we create instances, and those instances use methods that are defined
    only in the class. They will behave differently according to how the instances
    have been set up by the initializer.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，应该很清楚：*OOP是关于代码重用的*。我们定义一个类，创建实例，这些实例使用仅在类中定义的方法。它们将根据初始化程序设置实例的方式而表现出不同的行为。
- en: Inheritance and composition
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承和组合
- en: 'But this is just half of the story, *OOP is much more powerful*. We have two
    main design constructs to exploit: inheritance and composition.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但这只是故事的一半，*OOP更加强大*。我们有两个主要的设计构造可以利用：继承和组合。
- en: '**Inheritance** means that two objects are related by means of an *Is-A* type
    of relationship. On the other hand, **composition** means that two objects are
    related by means of a *Has-A* type of relationship. It''s all very easy to explain
    with an example:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**继承**意味着两个对象通过*是一个*类型的关系相关联。另一方面，**组合**意味着两个对象通过*有一个*类型的关系相关联。这一切都很容易通过一个例子来解释：'
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding example shows you both the *Is-A* and *Has-A* types of relationships
    between objects. First of all, let's consider `Engine`. It's a simple class that
    has two methods, `start` and `stop`. We then define `ElectricEngine` and `V8Engine`,
    which both inherit from `Engine`. You can see that by the fact that when we define
    them, we put `Engine` within the brackets after the class name.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子向您展示了对象之间*是一个*和*有一个*类型的关系。首先，让我们考虑`Engine`。这是一个简单的类，有两个方法，`start`和`stop`。然后我们定义了`ElectricEngine`和`V8Engine`，它们都继承自`Engine`。您可以看到，当我们定义它们时，在类名后面的括号中放入了`Engine`，这表明它们继承自`Engine`。
- en: This means that both `ElectricEngine` and `V8Engine` inherit attributes and
    methods from the `Engine` class, which is said to be their **base class**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`ElectricEngine`和`V8Engine`都继承自`Engine`类的属性和方法，这被称为它们的**基类**。
- en: The same happens with cars. `Car` is a base class for both `RaceCar` and `CityCar`.
    `RaceCar` is also the base class for `F1Car`. Another way of saying this is that
    `F1Car` inherits from `RaceCar`, which inherits from `Car`. Therefore, `F1Car` *Is-A *`RaceCar`
    and `RaceCar` *Is-A *`Car`. Because of the transitive property, we can say that
    `F1Car`* Is-A *`Car` as well. `CityCar` too, *Is-A *`Car`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车也是如此。`Car`是`RaceCar`和`CityCar`的基类。`RaceCar`也是`F1Car`的基类。另一种说法是，`F1Car`继承自`RaceCar`，`RaceCar`继承自`Car`。因此，`F1Car`*是一个*`RaceCar`，`RaceCar`*是一个*`Car`。由于传递性，我们也可以说`F1Car`*是一个*`Car`。`CityCar`也是*是一个*`Car`。
- en: 'When we define `class A(B): pass`, we say `A` is the *child* of `B`, and `B`
    is the *parent* of `A`. The *parent* and *base* classes are synonyms, are *child*
    and *derived*. Also, we say that a class inherits from another class, or that
    it extends it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们定义`class A(B): pass`时，我们说`A`是`B`的*子类*，而`B`是`A`的*父类*。*父类*和*基类*是同义词，*子类*和*派生类*也是。此外，我们说一个类从另一个类继承，或者扩展它。'
- en: This is the inheritance mechanism.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承机制。
- en: On the other hand, let's go back to the code. Each class has a class attribute,
    `engine_cls`, which is a reference to the engine class we want to assign to each
    type of car. `Car` has a generic `Engine`, while the two race cars have a powerful
    V8 engine, and the city car has an electric one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，让我们回到代码。每个类都有一个类属性`engine_cls`，它是我们想要分配给每种类型汽车的发动机类的引用。`Car`有一个通用的`Engine`，而两辆赛车有一个强大的V8发动机，城市车有一个电动发动机。
- en: When a car is created in the initializer method, `__init__`, we create an instance
    of whatever engine class is assigned to the car, and set it as the `engine` instance
    attribute.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当在初始化方法`__init__`中创建汽车时，我们创建分配给汽车的任何发动机类的实例，并将其设置为`engine`实例属性。
- en: It makes sense to have `engine_cls` shared among all class instances because
    it's quite likely that the same instances of a car will have the same kind of
    engine. On the other hand, it wouldn't be good to have one single engine (an instance
    of any `Engine` class) as a class attribute, because we would be sharing one engine
    among all instances, which is incorrect.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让`engine_cls`在所有类实例之间共享是有道理的，因为很可能同一辆车的实例会有相同类型的发动机。另一方面，将一个单一的发动机（任何`Engine`类的实例）作为类属性是不好的，因为我们会在所有实例之间共享一个发动机，这是不正确的。
- en: The type of relationship between a car and its engine is a *Has-A* type. A car
    *Has-A* engine. This is called **composition**, and reflects the fact that objects
    can be made of many other objects. A car *Has-A* engine, gears, wheels, a frame,
    doors, seats, and so on.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 汽车和发动机之间的关系类型是*Has-A*类型。汽车*Has-A*发动机。这被称为**组合**，反映了对象可以由许多其他对象组成的事实。汽车*Has-A*发动机、齿轮、车轮、车架、车门、座椅等等。
- en: When designing OOP code, it is of vital importance to describe objects in this
    way so that we can use inheritance and composition correctly to structure our
    code in the best way.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计面向对象的代码时，以这种方式描述对象非常重要，这样我们才能正确地使用继承和组合来最佳地构造我们的代码。
- en: Notice how I had to avoid having dots in the `class_inheritance.py` script name,
    as dots in module names make it imports difficult. Most modules in the source
    code of the book are meant to be run as standalone scripts, therefore I chose
    to add dots to enhance readability when possible, but in general, you want to
    avoid dots in your module names.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我必须避免在`class_inheritance.py`脚本名称中使用点，因为模块名称中的点使导入变得困难。书中源代码中的大多数模块都是作为独立脚本运行的，因此我选择在可能的情况下添加点以增强可读性，但一般来说，你应该避免在模块名称中使用点。
- en: 'Before we leave this paragraph, let''s check whether I told you the truth with
    another example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开这一段之前，让我们通过另一个示例来检查我是否告诉了你真相：
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see, `car` is just an instance of `Car`, while `racecar` is an instance
    of `RaceCar` (and of `Car`, by extension) and `f1car` is an instance of `F1Car`
    (and of both `RaceCar` and `Car`, by extension). A *banana* is an instance of
    *banana*. But, also, it is a *Fruit*. Also, it is *Food*, right? This is the same
    concept. To check whether an object is an instance of a class, use the `isinstance`
    method. It is recommended over sheer type comparison: `(type(object) == Class)`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`car`只是`Car`的一个实例，而`racecar`是`RaceCar`的一个实例（通过扩展也是`Car`的一个实例），`f1car`是`F1Car`的一个实例（通过扩展也是`RaceCar`和`Car`的一个实例）。*banana*是*banana*的一个实例。但是，它也是*Fruit*。同时，它也是*Food*，对吧？这是相同的概念。要检查对象是否是类的实例，请使用`isinstance`方法。它比纯粹的类型比较更可取：`(type(object)
    == Class)`。
- en: Notice I have left out the prints you get when instantiating the cars. We saw
    them in the previous example.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我没有在实例化汽车时留下打印信息。我们在上一个示例中看到了它们。
- en: 'Let''s also check inheritance–same setup, different logic in the `for` loops:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们也来检查继承-相同的设置，不同的逻辑在`for`循环中：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Interestingly, we learn that *a class is a subclass of itself*. Check the output
    of the preceding example to see that it matches the explanation I provided.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，我们了解到*一个类是其自身的子类*。检查前面示例的输出，看看它是否与我提供的解释相匹配。
- en: One thing to notice about conventions is that class names are always written
    using `CapWords`, which means `ThisWayIsCorrect`, as opposed to functions and
    methods, which are written `this_way_is_correct`. Also, when in the code, you
    want to use a name that is a Python-reserved keyword or a built-in function or
    class, the convention is to add a trailing underscore to the name. In the first
    `for` loop example, I'm looping through the class names using `for class_ in ...`,
    because `class` is a reserved word. But you already knew all this because you
    have thoroughly studied PEP8, right?
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于惯例的一件事要注意的是，类名始终使用`CapWords`编写，这意味着`ThisWayIsCorrect`，而不是函数和方法，它们是`this_way_is_correct`。此外，在代码中，如果要使用Python保留的关键字或内置函数或类的名称，惯例是在名称后添加下划线。在第一个`for`循环示例中，我正在使用`for
    class_ in ...`循环遍历类名，因为`class`是一个保留字。但你已经知道这一切，因为你已经彻底研究了PEP8，对吧？
- en: 'To help you picture the difference between *Is-A* and *Has-A*, take a look
    at the following diagram:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解*Is-A*和*Has-A*之间的区别，请看下面的图表：
- en: '![](../images/00010.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00010.jpeg)'
- en: Accessing a base class
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问基类
- en: 'We''ve already seen class declarations, such as `class ClassA: pass` and `class
    ClassB(BaseClassName): pass`. When we don''t specify a base class explicitly,
    Python will set the special **object** class as the base class for the one we''re
    defining. Ultimately, all classes derive from an object. Note that, if you don''t
    specify a base class, brackets are optional.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经看到了类声明，比如`class ClassA: pass`和`class ClassB(BaseClassName): pass`。当我们不明确指定基类时，Python会将特殊的**object**类设置为我们正在定义的类的基类。最终，所有类都源自一个对象。请注意，如果不指定基类，括号是可选的。'
- en: 'Therefore, writing `class A: pass` or `class A(): pass` or `class A(object):
    pass` is exactly the same thing. The *object* class is a special class in that
    it has the methods that are common to all Python classes, and it doesn''t allow
    you to set any attributes on it.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，编写`class A: pass`或`class A(): pass`或`class A(object): pass`都是完全相同的。*object*类是一个特殊的类，它具有所有Python类共有的方法，并且不允许你在其上设置任何属性。'
- en: 'Let''s see how we can access a base class from within a class:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何从类内部访问基类：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Take a look at the preceding code. Three of the input parameters are duplicated
    in `Ebook`. This is quite bad practice because we now have two sets of instructions
    that are doing the same thing. Moreover, any change in the signature of `Book.__init__`
    will not be reflected in `Ebook`. We know that `Ebook`* Is-A *`Book`, and therefore
    we would probably want changes to be reflected in the children classes.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的代码。`Ebook`中有三个输入参数是重复的。这是非常糟糕的做法，因为我们现在有两组执行相同操作的指令。此外，`Book.__init__`签名的任何更改都不会反映在`Ebook`中。我们知道`Ebook`*是一个*`Book`，因此我们可能希望更改能够反映在子类中。
- en: 'Let''s see one way to fix this issue:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一种解决这个问题的方法：
- en: '[PRE25]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now, that's better. We have removed that nasty duplication. Basically, we tell
    Python to call the `__init__` method of the `Book` class, and we feed `self` to
    the call, making sure that we bind that call to the present instance.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在好多了。我们去掉了那个讨厌的重复。基本上，我们告诉Python调用`Book`类的`__init__`方法，并将`self`传递给调用，确保将该调用绑定到当前实例。
- en: If we modify the logic within the `__init__` method of `Book`, we don't need
    to touch `Ebook`, it will auto-adapt to the change.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改`Book`的`__init__`方法中的逻辑，我们不需要触及`Ebook`，它将自动适应更改。
- en: 'This approach is good, but we can still do a bit better. Say that we change
    the name of  `Book` to `Liber`, because we''ve fallen in love with Latin. We have
    to change the `__init__` method of `Ebook` to reflect the change. This can be
    avoided by using `super`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法很好，但我们仍然可以做得更好一点。假设我们将`Book`的名称更改为`Liber`，因为我们爱上了拉丁语。我们必须修改`Ebook`的`__init__`方法以反映这一变化。这可以通过使用`super`来避免：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`super` is a function that returns a proxy object that delegates method calls
    to a parent or sibling class. In this case, it will delegate that call to `__init__`
    to the `Book` class, and the beauty of this method is that now we''re even free
    to change `Book` to `Liber` without having to touch the logic in the `__init__`
    method of `Ebook`.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`super`是一个返回代理对象的函数，该代理对象将方法调用委托给父类或同级类。在这种情况下，它将该调用委托给`Book`类的`__init__`，这种方法的美妙之处在于现在我们甚至可以自由地将`Book`更改为`Liber`，而不必触及`Ebook`的`__init__`方法中的逻辑。'
- en: Now that we know how to access a base class from a child, let's explore Python's
    multiple inheritance.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何从子类访问基类，让我们来探索Python的多重继承。
- en: Multiple inheritance
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多重继承
- en: 'Apart from composing a class using more than one base class, what is of interest
    here is how an attribute search is performed. Take a look at the following diagram:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用多个基类来组成一个类之外，这里感兴趣的是属性搜索是如何执行的。看一下下面的图表：
- en: '![](../images/00011.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../images/00011.jpeg)'
- en: 'As you can see, `Shape` and `Plotter` act as base classes for all the others.
    `Polygon` inherits directly from them, `RegularPolygon` inherits from `Polygon`,
    and both `RegularHexagon` and `Square` inherit from `RegulaPolygon`. Note also
    that `Shape` and `Plotter` implicitly inherit from `object`, therefore we have
    what is called a **diamond** or, in simpler terms, more than one path to reach
    a base class. We''ll see why this matters in a few moments. Let''s translate it
    into some simple code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`Shape`和`Plotter`充当了所有其他类的基类。`Polygon`直接从它们继承，`RegularPolygon`从`Polygon`继承，而`RegularHexagon`和`Square`都从`RegulaPolygon`继承。还要注意，`Shape`和`Plotter`隐式地从`object`继承，因此我们有了所谓的**菱形**，或者更简单地说，有多条路径到达基类。我们将在几分钟后看到为什么这很重要。让我们将其翻译成一些简单的代码：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Take a look at the preceding code: the `Shape` class has one attribute, `geometric_type`,
    and two methods: `area` and `get_geometric_type`. It''s quite common to use base
    classes (such as `Shape`, in our example) to define an *interface*–methods for
    which children must provide an implementation. There are different and better
    ways to do this, but I want to keep this example as simple as possible.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面的代码：`Shape`类有一个属性`geometric_type`和两个方法：`area`和`get_geometric_type`。通常使用基类（例如我们的例子中的`Shape`）来定义一个*接口*是很常见的，子类必须提供这些方法的实现。有不同和更好的方法来做到这一点，但我想尽可能地保持这个例子简单。
- en: We also have the `Plotter` class, which adds the `plot` method, thereby providing
    plotting capabilities for any class that inherits from it. Of course, the `plot`
    implementation is just a dummy `print` in this example. The first interesting
    class is `Polygon`, which inherits from both `Shape` and `Plotter`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有`Plotter`类，它添加了`plot`方法，从而为任何继承它的类提供绘图功能。当然，在这个例子中，`plot`的实现只是一个虚拟的`print`。第一个有趣的类是`Polygon`，它同时继承自`Shape`和`Plotter`。
- en: There are many types of polygons, one of which is the regular one, which is
    both equiangular (all angles are equal) and equilateral (all sides are equal),
    so we create the `RegularPolygon` class that inherits from `Polygon`. For a regular
    polygon, where all sides are equal, we can implement a simple `__init__` method
    on `RegularPolygon`, which takes the length of the side. Finally, we create the
    `RegularHexagon` and `Square` classes, which both inherit from `RegularPolygon`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的多边形，其中之一是正多边形，它既是等角的（所有角度相等），又是等边的（所有边相等），因此我们创建了从`Polygon`继承的`RegularPolygon`类。对于正多边形，我们可以在`RegularPolygon`上实现一个简单的`__init__`方法，它接受边长。最后，我们创建了`RegularHexagon`和`Square`类，它们都继承自`RegularPolygon`。
- en: This structure is quite long, but hopefully gives you an idea of how to specialize
    the classification of your objects when you design the code.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结构相当长，但希望能让你了解在设计代码时如何专门化对象的分类。
- en: Now, please take a look at the last eight lines. Note that when I call the `area`
    method on `hexagon` and `square`, I get the correct area for both. This is because
    they both provide the correct implementation logic for it. Also, I can call `get_geometric_type`
    on both of them, even though it is not defined on their classes, and Python has
    to go all the way up to `Shape` to find an implementation for it. Note that, even
    though the implementation is provided in the `Shape` class, the `self.geometric_type`
    used for the return value is correctly taken from the caller instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请看最后八行。请注意，当我在`hexagon`和`square`上调用`area`方法时，我得到了两者的正确面积。这是因为它们都提供了正确的实现逻辑。此外，我可以在它们两个上调用`get_geometric_type`，即使它没有在它们的类上定义，Python也必须一直到`Shape`才能找到它的实现。请注意，即使实现是在`Shape`类中提供的，用于返回值的`self.geometric_type`也是从调用实例中正确获取的。
- en: The `plot` method calls are also interesting, and show you how you can enrich
    your objects with capabilities they wouldn't otherwise have. This technique is
    very popular in web frameworks such as Django (which we'll explore [Chapter 14](part0341.html#A56FQ0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Web Development*), which provides special classes called **mixins**, whose capabilities
    you can just use out of the box. All you have to do is to define the desired mixin
    as one the base classes for your own, and that's it.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`plot`方法的调用也很有趣，并且向您展示了如何为对象增加它们本来没有的功能。这种技术在诸如Django（我们将在第14章中探索*Web Development*）这样的Web框架中非常受欢迎，它提供了称为**mixins**的特殊类，您可以直接使用其功能。您只需要将所需的mixin定义为自己的基类之一，就可以了。'
- en: Multiple inheritance is powerful, but can also get really messy, so we need
    to make sure we understand what happens when we use it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 多重继承很强大，但也可能变得非常混乱，因此我们需要确保了解在使用它时会发生什么。
- en: Method resolution order
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法解析顺序
- en: By now, we know that when you ask for `someobject.attribute` and `attribute`
    is not found on that object, Python starts searching in the class that `someobject`
    was created from. If it's not there either, Python searches up the inheritance
    chain until either `attribute` is found or the `object` class is reached. This
    is quite simple to understand if the inheritance chain is only composed of single-inheritance
    steps, which means that classes have only one parent. However, when multiple inheritance
    is involved, there are cases when it's not straightforward to predict what will
    be the next class that will be searched for if an attribute is not found.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们知道当您要求`someobject.attribute`，并且在该对象上找不到`attribute`时，Python会开始在创建`someobject`的类中搜索。如果那里也找不到，Python会沿着继承链向上搜索，直到找到`attribute`或者到达`object`类。如果继承链只由单继承步骤组成，这是很容易理解的，这意味着类只有一个父类。然而，当涉及到多重继承时，有时很难预测如果找不到属性，下一个将被搜索的类是什么。
- en: 'Python provides a way to always know the order in which classes are searched
    on attribute lookup: the **Method Resolution Order** (**MRO**).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了一种始终了解类在属性查找中被搜索顺序的方法：**Method Resolution Order**（**MRO**）。
- en: The MRO is the order in which base classes are searched for a member during
    lookup. From version 2.3, Python uses an algorithm called **C3**, which guarantees
    monotonicity.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MRO是在查找期间搜索成员的基类的顺序。从2.3版本开始，Python使用一种称为**C3**的算法，它保证了单调性。
- en: In Python 2.2, *new-style classes* were introduced. The way you write a new-style
    class in Python 2.* is to define it with an explicit `object` base class. Classic
    classes were not explicitly inheriting from `object` and have been removed in
    Python 3\. One of the differences between classic and new-style classes in Python
    2.* is that new-style classes are searched with the new MRO.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.2中引入了*新式类*。在Python 2.*中编写新式类的方式是使用显式的`object`基类进行定义。经典类没有明确继承自`object`，并且在Python
    3中已被移除。Python 2.*中经典类和新式类之间的一个区别是新式类使用新的MRO进行搜索。
- en: 'With regards to the previous example, let''s see the MRO for the `Square` class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的例子，让我们看看`Square`类的MRO：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To get to the MRO of a class, we can go from the instance to its `__class__`
    attribute, and from that to its `__mro__` attribute. Alternatively, we could have
    called `Square.__mro__`, or `Square.mro()` directly, but if you have to do it
    dynamically, it's more likely you will have an object than a class.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得类的MRO，我们可以从实例到其`__class__`属性，然后从那里到其`__mro__`属性。或者，我们可以直接调用`Square.__mro__`或`Square.mro()`，但如果你必须动态地执行它，更有可能你会有一个对象而不是一个类。
- en: 'Note that the only point of doubt is the bisection after `Polygon`, where the
    inheritance chain breaks into two ways: one leads to `Shape` and the other to
    `Plotter`. We know by scanning the MRO for the `Square` class that `Shape` is
    searched before `Plotter`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，唯一的疑点是在`Polygon`之后的二分，继承链分为两种方式：一种通向`Shape`，另一种通向`Plotter`。通过扫描`Square`类的MRO，我们知道`Shape`在`Plotter`之前被搜索。
- en: 'Why is this important? Well, consider the following code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这很重要？好吧，考虑以下代码：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both `B` and `C` inherit from `A`, and `D` inherits from both `B` and `C`. This
    means that the lookup for the `label` attribute can reach the top (`A`) through
    either `B` or `C`. According to which is reached first, we get a different result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`B`和`C`都继承自`A`，`D`同时继承自`B`和`C`。这意味着查找`label`属性可以通过`B`或`C`到达顶部（`A`）。根据首先到达的位置，我们会得到不同的结果。'
- en: 'So, in the preceding example, we get `''b''`, which is what we were expecting,
    since `B` is the leftmost one among the base classes of `D`. But what happens
    if I remove the `label` attribute from `B`? This would be a confusing situation:
    will the algorithm go all the way up to `A` or will it get to `C` first? Let''s
    find out:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的例子中，我们得到了`'b'`，这是我们所期望的，因为`B`是`D`的基类中最左边的一个。但是如果我从`B`中删除`label`属性会发生什么呢？这将是一个令人困惑的情况：算法会一直到达`A`还是首先到达`C`？让我们找出来：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: So, we learn that the MRO is `D`-`B`-`C`-`A`-`object`, which means when we ask
    for `d.label`, we get `'c'`, which is correct.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们了解到MRO是`D`-`B`-`C`-`A`-`object`，这意味着当我们要求`d.label`时，我们得到的是`'c'`，这是正确的。
- en: In day-to-day programming, it is not common to have to deal with the MRO, but
    the first time you fight against some mixin from a framework, I promise you'll
    be glad I spent a paragraph explaining it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在日常编程中，通常不常见需要处理MRO，但第一次与框架中的一些混合物作斗争时，我向您保证，您会很高兴我花了一段时间来解释它。
- en: Class and static methods
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和静态方法
- en: 'So far, we have coded classes with attributes in the form of data and instance
    methods, but there are two other types of methods that we can place inside a class:
    **static methods** and **class methods**.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了具有数据和实例方法形式属性的类，但是还有两种类型的方法可以放在类中：**静态方法**和**类方法**。
- en: Static methods
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 静态方法
- en: 'As you may recall, when you create a class object, Python assigns a name to
    it. That name acts as a namespace, and sometimes it makes sense to group functionalities
    under it. Static methods are perfect for this use case since, unlike instance
    methods, they are not passed any special argument. Let''s look at an example of
    an imaginary `StringUtil` class:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得，当您创建一个类对象时，Python会为其分配一个名称。该名称充当命名空间，有时将功能分组在其下是有意义的。静态方法非常适合这种用例，因为与实例方法不同，它们不会传递任何特殊参数。让我们看一个虚构的`StringUtil`类的示例：
- en: '[PRE31]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding code is quite interesting. First of all, we learn that static
    methods are created by simply applying the `staticmethod` decorator to them. You
    can see that they aren't passed any special argument so, apart from the decoration,
    they really just look like functions.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常有趣。首先，我们了解到静态方法是通过简单地将`staticmethod`装饰器应用于它们来创建的。您可以看到它们没有传递任何特殊参数，因此除了装饰之外，它们看起来确实就像函数。
- en: We have a class, `StringUtil`, that acts as a container for functions. Another
    approach would be to have a separate module with functions inside. It's really
    a matter of preference most of the time.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个名为`StringUtil`的类，它充当函数的容器。另一种方法是使用内部函数的单独模块。大多数情况下，这实际上是一种偏好。
- en: The logic inside `is_palindrome` should be straightforward for you to understand
    by now, but, just in case, let's go through it. First, we remove all characters
    from `s` that are neither letters nor numbers. In order to do this, we use the
    `join` method of a string object (an empty string object, in this case). By calling
    `join` on an empty string, the result is that all elements in the iterable you
    pass to `join` will be concatenated together. We feed `join` a generator expression
    that says to take any character from `s` if the character is either alphanumeric
    or a number. This is because, in palindrome sentences, we want to discard anything
    that is not a character or a number.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_palindrome` 中的逻辑现在应该对您来说很简单，但以防万一，让我们来看一下。首先，我们从`s`中删除所有既不是字母也不是数字的字符。为了做到这一点，我们使用字符串对象（在本例中是空字符串对象）的`join`方法。通过在空字符串上调用`join`，结果是将传递给`join`的可迭代对象中的所有元素连接在一起。我们向`join`提供了一个生成器表达式，该表达式表示如果字符是字母数字或数字，则从`s`中取任何字符。这是因为在回文句子中，我们希望丢弃任何不是字符或数字的内容。'
- en: We then lowercase `s` if `case_insensitive` is `True`, and then we proceed to
    check whether it is a palindrome. In order to do this, we compare the first and
    last characters, then the second and the second to last, and so on. If at any
    point we find a difference, it means the string isn't a palindrome and therefore
    we can return `False`. On the other hand, if we exit the `for` loop normally,
    it means no differences were found, and we can therefore say the string is a palindrome.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`case_insensitive`为`True`，我们将转换`s`为小写，然后继续检查它是否是回文。为了做到这一点，我们比较第一个和最后一个字符，然后比较第二个和倒数第二个字符，依此类推。如果我们在任何时候发现差异，这意味着字符串不是回文，因此我们可以返回`False`。另一方面，如果我们正常退出`for`循环，这意味着没有发现任何差异，因此我们可以说字符串是回文。
- en: Notice that this code works correctly regardless of the length of the string;
    that is, if the length is odd or even. `len(s) // 2` reaches half of `s`, and
    if `s` is an odd amount of characters long, the middle one won't be checked (such
    as in *RaDaR*, *D* is not checked), but we don't care; it would be compared with
    itself so it's always passing that check.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，无论字符串的长度是奇数还是偶数，此代码都能正确工作。`len(s) // 2` 可以达到`s`的一半，如果`s`的字符数量是奇数，中间的字符不会被检查（比如在
    *RaDaR* 中，*D* 不会被检查），但我们不在乎；它将与自身进行比较，因此始终通过该检查。
- en: '`get_unique_words` is much simpler: it just returns a set to which we feed
    a list with the words from a sentence. The `set` class removes any duplication
    for us, so we don''t need to do anything else.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_unique_words`要简单得多：它只返回一个集合，我们向其中提供了一个句子中的单词列表。`set`类为我们删除了任何重复项，因此我们不需要做其他任何事情。'
- en: The `StringUtil` class provides us a nice container namespace for methods that
    are meant to work on strings. I could have coded a similar example with a `MathUtil`
    class, and some static methods to work on numbers, but I wanted to show you something
    different.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringUtil`类为我们提供了一个很好的容器命名空间，用于处理字符串的方法。我本可以编写一个类似的示例，使用`MathUtil`类和一些静态方法来处理数字，但我想向您展示一些不同的东西。'
- en: Class methods
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类方法
- en: 'Class methods are slightly different from static methods in that, like instance
    methods, they also take a special first argument, but in this case, it is the
    class object itself. A very common use case for coding class methods is to provide
    factory capability to a class. Let''s see an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法与静态方法略有不同，因为与实例方法一样，它们也需要一个特殊的第一个参数，但在这种情况下，它是类对象本身。编写类方法的一个非常常见的用例是为类提供工厂功能。让我们看一个示例：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the preceding code, I showed you how to use a class method to create a factory
    for the class. In this case, we want to create a `Point` instance by passing both
    coordinates (regular creation `p = Point(3, 7)`), but we also want to be able
    to create an instance by passing a tuple (`Point.from_tuple`) or another instance
    (`Point.from_point`).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我向你展示了如何使用类方法来创建类的工厂。在这种情况下，我们希望通过传递两个坐标（常规创建`p = Point(3, 7)`）来创建一个`Point`实例，但我们也希望能够通过传递一个元组（`Point.from_tuple`）或另一个实例（`Point.from_point`）来创建一个实例。
- en: Within the two class methods, the `cls` argument refers to the `Point` class.
    As with the instance method, which takes `self` as the first argument, the class
    method takes a `cls` argument. Both `self` and `cls` are named after a convention
    that you are not forced to follow but are strongly encouraged to respect. This
    is something that no Python coder would change because it is so strong a convention
    that parsers, linters, and any tool that automatically does something with your
    code would expect, so it's much better to stick to it.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个类方法中，`cls`参数指的是`Point`类。与实例方法一样，实例方法以`self`作为第一个参数，类方法以`cls`作为参数。`self`和`cls`都是根据约定命名的，你不是被强制遵循，但强烈鼓励尊重。这是没有Python程序员会更改的东西，因为它是一个如此强大的约定，解析器、linter和任何自动处理代码的工具都会期望，所以最好坚持遵循它。
- en: 'Class and static methods play well together. Static methods are actually quite
    helpful in breaking up the logic of a class method to improve its layout. Let''s
    see an example by refactoring the `StringUtil` class:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法和静态方法很好地配合。静态方法实际上在分解类方法的逻辑以改进其布局方面非常有帮助。让我们通过重构`StringUtil`类来看一个例子：
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Compare this code with the previous version. First of all, note that even though
    `is_palindrome` is now a class method, we call it in the same way we were calling
    it when it was a static one. The reason why we changed it to a class method is
    that after factoring out a couple of pieces of logic (`_strip_string` and `_is_palindrome`),
    we need to get a reference to them, and if we have no `cls` in our method, the
    only option would be to call them like this: `StringUtil._strip_string(...)` and
    `StringUtil._is_palindrome(...)`, which is not good practice, because we would
    hardcode the class name in the `is_palindrome` method, thereby putting ourselves
    in the position of having to modify it whenever we want to change the class name.
    Using `cls` will act as the class name, which means our code won''t need any amendments.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将这段代码与以前的版本进行比较。首先，请注意，即使`is_palindrome`现在是一个类方法，我们调用它的方式与它是静态方法时的调用方式相同。我们将它更改为类方法的原因是，在提取出一些逻辑片段（`_strip_string`和`_is_palindrome`）之后，我们需要引用它们，如果我们的方法中没有`cls`，唯一的选择就是这样调用它们：`StringUtil._strip_string(...)`和`StringUtil._is_palindrome(...)`，这不是一个好的做法，因为我们会在`is_palindrome`方法中硬编码类名，这样我们就会置自己于在想要更改类名时必须修改它的位置。使用`cls`将作为类名，这意味着我们的代码不需要任何修改。
- en: Notice how the new logic reads much better than the previous version. Moreover,
    notice that, by naming the *factored-out* methods with a leading underscore, I
    am hinting that those methods are not supposed to be called from outside the class,
    but this will be the subject of the next paragraph.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意新的逻辑读起来比以前的版本好得多。此外，注意，通过在*提取出来*的方法前加下划线，我暗示这些方法不应该从类外部调用，但这将是下一段的主题。
- en: Private methods and name mangling
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 私有方法和名称混淆
- en: If you have any background with languages like Java, C#, or C++, then you know
    they allow the programmer to assign a privacy status to attributes (both data
    and methods). Each language has its own slightly different flavor for this, but
    the gist is that public attributes are accessible from any point in the code,
    while private ones are accessible only within the scope they are defined in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有Java、C#或C++等语言的背景，那么你知道它们允许程序员为属性（数据和方法）分配隐私状态。每种语言对此有自己略有不同的特点，但主要是公共属性可以从代码中的任何地方访问，而私有属性只能在其定义的范围内访问。
- en: In Python, there is no such thing. Everything is public; therefore, we rely
    on conventions and on a mechanism called **name mangling**.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，没有这样的东西。一切都是公开的；因此，我们依赖于约定和一种称为**名称混淆**的机制。
- en: 'The convention is as follows: if an attribute''s name has no leading underscores,
    it is considered public. This means you can access it and modify it freely. When
    the name has one leading underscore, the attribute is considered private, which
    means it''s probably meant to be used internally and you should not use it or
    modify it from the outside. A very common use case for private attributes are
    helper methods that are supposed to be used by public ones (possibly in call chains
    in conjunction with other methods), and internal data, such as scaling factors,
    or any other data that ideally we would put in a constant (a variable that cannot
    change, but, surprise, surprise, Python doesn''t have those either).'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 约定如下：如果属性的名称没有下划线，它被认为是公共的。这意味着你可以自由访问和修改它。当名称有一个下划线时，属性被认为是私有的，这意味着它可能是用于内部使用的，你不应该从外部使用或修改它。私有属性的一个非常常见的用例是辅助方法，它们应该被公共方法使用（可能与其他方法一起调用链），以及内部数据，例如缩放因子，或者理想情况下我们会将其放在一个常量中（一个不能改变的变量，但是，惊讶的是，Python也没有这些）。
- en: This characteristic usually scares people from other backgrounds off; they feel
    threatened by the lack of privacy. To be honest, in my whole professional experience
    with Python, I've never heard anyone screaming "*oh my God, we have a terrible
    bug because Python lacks private attributes!*" Not once, I swear.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性通常会吓跑其他背景的人；他们会因为缺乏隐私而感到受到威胁。老实说，在我整个与Python的专业经验中，我从来没有听说过有人因为Python缺乏私有属性而尖叫“*哦，天哪，我们因为Python缺乏私有属性而有了一个可怕的错误！*”我发誓没有一次。
- en: 'That said, the call for privacy actually makes sense because without it, you
    risk introducing bugs into your code for real. Let me show you what I mean:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，对隐私的呼吁实际上是有道理的，因为没有它，你会真正地在你的代码中引入错误。让我告诉你我的意思：
- en: '[PRE34]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code, we have an attribute called `_factor`, and let's pretend
    it's so important that it isn't modified at runtime after the instance is created,
    because `op1` depends on it to function correctly. We've named it with a leading
    underscore, but the issue here is that when we call `obj.op2(42)`, we modify it,
    and this is reflected in subsequent calls to `op1`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个名为`_factor`的属性，假设它非常重要，不希望在创建实例后在运行时被修改，因为`op1`依赖于它才能正确运行。我们用一个前导下划线命名它，但问题在于当我们调用`obj.op2(42)`时，我们修改了它，并且这在后续调用`op1`时也会反映出来。
- en: 'Let''s fix this undesired behavior by adding another leading underscore:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加另一个前导下划线来修复这种不良行为：
- en: '[PRE35]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Wow, look at that! Now it's working as desired. Python is kind of magic and
    in this case, what is happening is that the name-mangling mechanism has kicked
    in.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看那个！现在它按预期工作了。Python有点神奇，在这种情况下，发生的是名称修饰机制已经启动。
- en: Name mangling means that any attribute name that has at least two leading underscores
    and at most one trailing underscore, such as `__my_attr`, is replaced with a name
    that includes an underscore and the class name before the actual name, such as `_ClassName__my_attr`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 名称修饰意味着任何属性名称至少有两个前导下划线和最多一个尾随下划线，例如`__my_attr`，将被替换为一个包含下划线和类名的名称，然后是实际名称，例如`_ClassName__my_attr`。
- en: 'This means that when you inherit from a class, the mangling mechanism gives
    your private attribute two different names in the base and child classes so that
    name collision is avoided. Every class and instance object stores references to
    their attributes in a special attribute called `__dict__`, so let''s inspect `obj.__dict__`
    to see name mangling in action:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着当你从一个类继承时，修饰机制会在基类和子类中给你的私有属性取两个不同的名称，以避免名称冲突。每个类和实例对象都在一个特殊的属性`__dict__`中存储对它们的属性的引用，所以让我们检查`obj.__dict__`来看看名称修饰是如何起作用的：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This is the `_factor` attribute that we find in the problematic version of
    this example. But look at the one that is using `__factor`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在这个例子的有问题版本中找到的`_factor`属性。但是看看使用`__factor`的那个：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See? `obj` has two attributes now, `_A__factor` (mangled within the `A` class),
    and `_B__factor` (mangled within the `B` class). This is the mechanism that ensures
    that when you do `obj.__factor = 42`, `__factor` in `A` isn't changed, because
    you're actually touching `_B__factor`, which leaves `_A__factor` safe and sound.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？`obj`现在有两个属性，`_A__factor`（在`A`类中修饰）和`_B__factor`（在`B`类中修饰）。这就是确保当你执行`obj.__factor
    = 42`时，`A`中的`__factor`不会改变的机制，因为你实际上是在触及`_B__factor`，这样就保留了`_A__factor`的安全和完整。
- en: If you're designing a library with classes that are meant to be used and extended
    by other developers, you will need to keep this in mind in order to avoid the
    unintentional overriding of your attributes. Bugs like these can be pretty subtle
    and hard to spot.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在设计一个希望被其他开发人员使用和扩展的类库，你需要牢记这一点，以避免意外覆盖你的属性。这样的错误可能相当微妙，很难发现。
- en: The property decorator
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性装饰器
- en: Another thing that would be a crime not to mention is the `property` decorator.
    Imagine that you have an `age` attribute in a `Person` class and at some point
    you want to make sure that when you change its value, you're also checking that
    `age` is within a proper range, such as [18, 99]. You can write accessor methods,
    such as `get_age()` and `set_age(...)` (also called **getters** and **setters**),
    and put the logic there. `get_age()` will most likely just return `age`, while
    `set_age(...)` will also do the range check. The problem is that you may already
    have a lot of code accessing the `age` attribute directly, which means you're
    now up to some tedious refactoring. Languages like Java overcome this problem
    by using the accessor pattern basically by default. Many Java **Integrated Development
    Environments** (**IDEs**) autocomplete an attribute declaration by writing getter
    and setter accessor method stubs for you on the fly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一件不得不提的事情是`property`装饰器。想象一下，你在一个`Person`类中有一个`age`属性，而且在某个时候你想要确保当你改变它的值时，你也要检查`age`是否在一个合适的范围内，比如[18,
    99]。你可以编写访问器方法，比如`get_age()`和`set_age(...)`（也称为**getter**和**setter**），并在那里放置逻辑。`get_age()`很可能只是返回`age`，而`set_age(...)`也会进行范围检查。问题是，你可能已经有很多直接访问`age`属性的代码，这意味着你现在需要进行一些繁琐的重构。像Java这样的语言通过默认使用访问器模式来解决这个问题。许多Java
    **集成开发环境**（**IDE**）会在你写属性声明时自动为你编写getter和setter访问器方法的存根。
- en: Python is smarter, and does this with the `property` decorator. When you decorate
    a method with `property`, you can use the name of the method as if it were a data
    attribute. Because of this, it's always best to refrain from putting logic that
    would take a while to complete in such methods because, by accessing them as attributes,
    we are not expecting to wait.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: Python更聪明，它可以使用`property`装饰器来实现这一点。当你用`property`装饰一个方法时，你可以像使用数据属性一样使用方法的名称。因此，最好不要在这样的方法中放入需要花费一些时间才能完成的逻辑，因为通过访问它们作为属性，我们不希望等待。
- en: 'Let''s look at an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子：
- en: '[PRE38]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Person` class may be the first version we write. Then we realize we need
    to put the range logic in place so, with another language, we would have to rewrite
    `Person` as the `PersonWithAccessors` class, and refactor all the code that was
    using `Person.age`. In Python, we rewrite `Person` as `PersonPythonic` (you normally
    wouldn't change the name, of course) so that the age is stored in a private `_age`
    variable, and we define property getters and setters using that decoration, which
    allows us to keep using the `person` instances as we were before. A getter is
    a method that is called when we access an attribute for reading. On the other
    hand, a setter is a method that is called when we access an attribute to write
    it. In other languages, such as Java, it's customary to define them as `get_age()`
    and `set_age(int value)`, but I find the Python syntax much neater. It allows
    you to start writing simple code and refactor later on, only when you need it,
    there is no need to pollute your code with accessors only because they may be
    helpful in the future.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类可能是我们编写的第一个版本。然后我们意识到我们需要放置范围逻辑，所以，用另一种语言，我们需要将`Person`重写为`PersonWithAccessors`类，并重构所有使用`Person.age`的代码。在Python中，我们将`Person`重写为`PersonPythonic`（当然通常不会更改名称），这样年龄就存储在私有的`_age`变量中，并且我们使用装饰器定义属性的getter和setter，这使我们可以像以前一样继续使用`person`实例。getter是在我们读取属性时调用的方法。另一方面，setter是在我们写入属性时调用的方法。在其他语言中，比如Java，习惯上将它们定义为`get_age()`和`set_age(int
    value)`，但我觉得Python的语法更整洁。它允许你开始编写简单的代码，以后再进行重构，只有在需要时才需要，没有必要因为它们可能在将来有用而污染你的代码。'
- en: The `property` decorator also allows for read-only data (no setter) and for
    special actions when the attribute is deleted. Please refer to the official documentation
    to dig deeper.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`property`装饰器还允许只读数据（没有setter）以及在属性被删除时进行特殊操作。请参考官方文档以深入了解。'
- en: Operator overloading
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: I find Python's approach to **operator overloading** to be brilliant. To overload
    an operator means to give it a meaning according to the context in which it is
    used. For example, the `+` operator means addition when we deal with numbers,
    but concatenation when we deal with sequences.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现Python对**运算符重载**的处理方式非常出色。重载运算符意味着根据使用的上下文给它赋予不同的含义。例如，当处理数字时，`+`运算符表示加法，但当处理序列时，它表示连接。
- en: In Python, when you use operators, you're most likely calling the special methods
    of some objects behind the scenes. For example, the `a[k]` call roughly translates
    to `type(a).__getitem__(a, k)`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当你使用操作符时，你很可能在幕后调用一些对象的特殊方法。例如，`a[k]`的调用大致相当于`type(a).__getitem__(a,
    k)`。
- en: 'As an example, let''s create a class that stores a string and evaluates to
    `True` if `''42''` is part of that string, and `False` otherwise. Also, let''s
    give the class a length property that corresponds to that of the stored string:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，让我们创建一个类，它存储一个字符串，并且如果该字符串中包含'42'，则求值为`True`，否则为`False`。此外，让我们给这个类一个长度属性，它对应于存储的字符串的长度：
- en: '[PRE39]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That was fun, wasn't it? For the complete list of magic methods that you can
    override in order to provide your custom implementation of operators for your
    classes, please refer to the Python data model in the official documentation.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 那很有趣，不是吗？要了解可以重写的魔术方法的完整列表，以便为您的类提供自定义的操作符实现，请参考官方文档中的Python数据模型。
- en: Polymorphism – a brief overview
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态-简要概述
- en: The word **polymorphism** comes from the Greek *polys* (many, much) and *morphē*
    (form, shape), and its meaning is the provision of a single interface for entities
    of different types.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**一词来自希腊语*polys*（许多，多）和*morphē*（形式，形状），它的意思是为不同类型的实体提供单一接口。'
- en: In our car example, we call `engine.start()`, regardless of what kind of engine
    it is. As long as it exposes the start method, we can call it. That's polymorphism
    in action.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的汽车示例中，我们调用`engine.start()`，无论引擎是什么类型。只要它公开了start方法，我们就可以调用它。这就是多态的实际应用。
- en: In other languages, such as Java, in order to give a function the ability to
    accept different types and call a method on them, those types need to be coded
    in such a way that they share an interface. In this way, the compiler knows that
    the method will be available regardless of the type of the object the function
    is fed (as long as it extends the proper interface, of course).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，比如Java，为了让函数能够接受不同类型并调用它们的方法，这些类型需要以一种方式编码，使它们共享一个接口。这样，编译器就知道无论函数输入的对象类型是什么（只要它扩展了正确的接口），方法都将可用。
- en: In Python, things are different. Polymorphism is implicit, nothing prevents
    you from calling a method on an object; therefore, technically, there is no need
    to implement interfaces or other patterns.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，情况就不同了。多态是隐式的，没有任何东西阻止你在对象上调用方法；因此，从技术上讲，没有必要实现接口或其他模式。
- en: 'There is a special kind of polymorphism called **ad hoc polymorphism**, which
    is what we saw in the last paragraph: operator overloading. This is the ability
    of an operator to change shape, according to the type of data it is fed.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种特殊的多态称为**特定多态**，这就是我们在上一段看到的：运算符重载。这是运算符根据其输入的数据类型而改变形状的能力。
- en: Polymorphism also allows Python programmers to simply use the interface (methods
    and properties) exposed from an object rather than having to check which class
    it was instantiated from. This allows the code to be more compact and feel more
    natural.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 多态还允许Python程序员简单地使用对象暴露的接口（方法和属性），而无需检查它是从哪个类实例化的。这使得代码更加紧凑，感觉更加自然。
- en: I cannot spend too much time on polymorphism, but I encourage you to check it
    out by yourself, it will expand your understanding of OOP. Good luck!
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能在多态上花太多时间，但我鼓励你自己去了解，这将扩展你对面向对象编程的理解。祝你好运！
- en: Data classes
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: 'Before we leave the OOP realm, there is one last thing I want to mention: data
    classes. Introduced in Python 3.7 by PEP557 ([https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)),
    they can be described as <q class="calibre30">*mutable named tuples with defaults*</q>.
    Let''s dive into an example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们离开面向对象编程领域之前，我想提一件事：数据类。在Python 3.7中由PEP557引入（[https://www.python.org/dev/peps/pep-0557/](https://www.python.org/dev/peps/pep-0557/)），它们可以被描述为<q
    class="calibre30">*带有默认值的可变命名元组*</q>。让我们深入一个例子：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In the previous code, I have created a class to represent a physical body, with
    one method that allows me to calculate its kinetic energy (using the renowned
    formula *E[k]=½mv²*). Notice that `name` is supposed to be a string, while `mass`
    and `speed` are both floats, and both are given a default value. It's also interesting
    that I didn't have to write any `__init__` method, it's done for me by the `dataclass`
    decorator, along with methods for comparison and for producing the string representation
    of the object (implicitly called on the last line by `print`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我创建了一个表示物体的类，其中有一个方法允许我计算它的动能（使用著名的公式*E[k]=½mv²*）。请注意，`name`应该是一个字符串，而`mass`和`speed`都是浮点数，并且都有默认值。有趣的是，我不需要编写任何`__init__`方法，它由`dataclass`装饰器为我完成，还有用于比较和生成对象的字符串表示的方法（在最后一行由`print`隐式调用）。
- en: You can read all the specifications in PEP557 if you are curious, but for now
    just remember that data classes might offer a nicer, slightly more powerful alternative
    to named tuples, in case you need it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，你可以在PEP557中阅读所有的规范，但现在只需记住数据类可能提供一个更好的，稍微更强大的替代命名元组，以防你需要它。
- en: Writing a custom iterator
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写自定义迭代器
- en: 'Now we have all the tools to appreciate how we can write our own custom iterator.
    Let''s first define an iterable and an iterator:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了所有的工具来欣赏我们如何编写自己的自定义迭代器。让我们首先定义一个可迭代对象和一个迭代器：
- en: '**Iterable**: An object is said to be iterable if it''s capable of returning
    its members one at a time. Lists, tuples, strings, and dictionaries are all iterables.
    Custom objects that define either of the `__iter__` or `__getitem__` methods are
    also iterables.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可迭代对象**：如果一个对象能够一次返回其成员，那么它被称为可迭代对象。列表、元组、字符串和字典都是可迭代对象。定义了`__iter__`或`__getitem__`方法的自定义对象也是可迭代对象。'
- en: '**Iterator**: An object is said to be an iterator if it represents a stream
    of data. A custom iterator is required to provide an implementation for `__iter__`
    that returns the object itself, and an implementation for `__next__` that returns
    the next item of the data stream until the stream is exhausted, at which point
    all successive calls to `__next__` simply raise the `StopIteration` exception.
    Built-in functions, such as `iter` and `next`, are mapped to call `__iter__` and
    `__next__` on an object, behind the scenes.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**迭代器**：如果一个对象代表数据流，那么它被称为迭代器。自定义迭代器需要为`__iter__`提供一个返回对象本身的实现，并为`__next__`提供一个实现，该实现返回数据流的下一个项目，直到数据流耗尽，此时所有后续对`__next__`的调用都会简单地引发`StopIteration`异常。内置函数，如`iter`和`next`，在幕后调用`__iter__`和`__next__`。'
- en: 'Let''s write an iterator that returns all the odd characters from a string
    first, and then the even ones:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个迭代器，首先返回字符串中所有的奇数字符，然后返回偶数字符：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: So, we needed to provide an implementation for `__iter__` that returned the
    object itself, and then one for `__next__`. Let's go through it. What needed to
    happen was the return of `_data[0]`, `_data[2]`, `_data[4]`, ..., `_data[1]`,
    `_data[3]`, `_data[5]`, ... until we had returned every item in the data. In order
    to do that, we prepared a list and indexes, such as [`0`, `2`, `4`, `6`, ...,
    `1`, `3`, `5`, ...], and while there was at least an element in it, we popped
    the first one and returned the element from the data that was at that position,
    thereby achieving our goal. When `indexes` was empty, we raised `StopIteration`,
    as required by the iterator protocol.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要为`__iter__`提供一个返回对象本身的实现，然后为`__next__`提供一个实现。让我们来看看。需要发生的是返回`_data[0]`，`_data[2]`，`_data[4]`，...，`_data[1]`，`_data[3]`，`_data[5`，...直到我们返回了数据中的每一项。为了做到这一点，我们准备了一个列表和索引，比如[`0`，`2`，`4`，`6`，...，`1`，`3`，`5`，...]，并且只要其中至少有一个元素，我们就弹出第一个元素并返回数据中该位置的元素，从而实现我们的目标。当`indexes`为空时，我们引发`StopIteration`，这是迭代器协议所要求的。
- en: There are other ways to achieve the same result, so go ahead and try to code
    a different one yourself. Make sure the end result works for all edge cases, empty
    sequences, sequences of lengths of `1`, `2`, and so on.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以实现相同的结果，所以继续尝试编写不同的方法。确保最终结果适用于所有边缘情况、空序列、长度为`1`、`2`等的序列。
- en: Summary
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at decorators, discovered the reasons for having
    them, and covered a few examples using one or more at the same time. We also saw
    decorators that take arguments, which are usually used as decorator factories.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了装饰器，发现了拥有装饰器的原因，并涵盖了一些同时使用一个或多个装饰器的示例。我们还看到了接受参数的装饰器，通常用作装饰器工厂。
- en: We scratched the surface of object-oriented programming in Python. We covered
    all the basics, so you should now be able to understand the code that will come
    in future chapters. We talked about all kinds of methods and attributes that one
    can write in a class, we explored inheritance versus composition, method overriding,
    properties, operator overloading, and polymorphism.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python中只是触及了面向对象编程的表面。我们涵盖了所有的基础知识，所以现在你应该能够理解未来章节中的代码。我们讨论了类中可以编写的各种方法和属性，我们探讨了继承与组合，方法重写，属性，运算符重载和多态性。
- en: At the end, we very briefly touched base on iterators, so now you understand
    generators more deeply.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要地涉及了迭代器，所以现在你更深入地理解了生成器。
- en: In the next chapter, we're going to see how to deal with files and how to persist
    data in several different ways and formats.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何处理文件以及如何以多种不同的方式和格式持久化数据。
