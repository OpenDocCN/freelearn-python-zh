- en: Chapter 13. Deploying Flask Apps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章。部署Flask应用程序
- en: Now that we have reached the last chapter of the book and have a fully functioning
    web app made in Flask, the final step to take in our development is to make the
    app available for the world. There are many different approaches to host your
    Flask app, each of them with their own pros and cons. This chapter will cover
    the best solutions and guide you in what situations you should choose one over
    the other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了书的最后一章，并且在Flask中制作了一个完全功能的Web应用程序，我们开发的最后一步是使该应用程序对外开放。有许多不同的方法来托管您的Flask应用程序，每种方法都有其优缺点。本章将介绍最佳解决方案，并指导您在何种情况下选择其中一种。
- en: Note that, in this chapter, the term server is used to refer to the physical
    machine that is running the operating system. But, when the term web server is
    used, it refers to the program on the server that receives HTTP requests and sends
    responses.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在本章中，术语服务器用于指代运行操作系统的物理机器。但是，当使用术语Web服务器时，它指的是服务器上接收HTTP请求并发送响应的程序。
- en: Deploying on your own server
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您自己的服务器上部署
- en: The most common way to deploy any web app is to run it on a server that you
    have control over. In this case, control means access to a terminal on the server
    with an administrator account. This type of deployment gives you the most amount
    of freedom out of the other choices as it allows you to install any program or
    tool you wish. This is in contrast to other hosting solutions where the web server
    and database are chosen for you. This type of deployment also happens to be the
    least expensive option.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 部署任何Web应用程序的最常见方法是在您可以控制的服务器上运行它。在这种情况下，控制意味着可以使用管理员帐户访问服务器上的终端。与其他选择相比，这种部署方式为您提供了最大的自由度，因为它允许您安装任何程序或工具。这与其他托管解决方案相反，其中Web服务器和数据库是为您选择的。这种部署方式也恰好是最便宜的选择。
- en: The downside to this freedom is that you take the responsibility of keeping
    the server up, backing up user data, keeping the software on the server up to
    date to avoid security issues, and so on. All books have been written on good
    server management. So if this is not a responsibility that you believe you or
    your company can handle, it would be best if you choose one of the other deployment
    options.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这种自由的缺点是您需要负责保持服务器运行，备份用户数据，保持服务器上的软件最新以避免安全问题等。关于良好的服务器管理已经写了很多书。因此，如果您认为您或您的公司无法承担这种责任，最好选择其他部署选项之一。
- en: This section will be based on a Debian Linux-based server, as Linux is far and
    away the most popular OS to run web servers and Debian is the most popular Linux
    distro (a particular combination of software and the Linux kernel released as
    a package). Any OS with bash and a program named SSH (which will be introduced
    in the next section) will work for this chapter. The only differences will be
    the command-line programs to install software on the server.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将基于基于Debian Linux的服务器，因为Linux是远远最受欢迎的运行Web服务器的操作系统，而Debian是最受欢迎的Linux发行版（一种特定的软件和Linux内核的组合，作为一个软件包发布）。任何具有bash和名为SSH的程序（将在下一节介绍）的操作系统都适用于本章。唯一的区别将是安装服务器上软件的命令行程序。
- en: Each of these web servers will use a protocol named **Web Server Gateway Interface**
    (**WSGI**), which is a standard designed to allow Python web applications to easily
    communicate with web servers. We will never directly work with WSGI, but most
    of the web server interfaces we will be using will have WSGI in their name and
    it can be confusing if you don't know what it is.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Web服务器将使用名为**Web服务器网关接口**（**WSGI**）的协议，这是一种旨在允许Python Web应用程序与Web服务器轻松通信的标准。我们永远不会直接使用WSGI，但我们将使用的大多数Web服务器接口都将在其名称中包含WSGI，如果您不知道它是什么，可能会感到困惑。
- en: Pushing code to your server with fabric
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用fabric将代码推送到您的服务器
- en: To automate the process of setting up and pushing our application code to the
    server, we will use a Python tool named fabric. Fabric is a command-line program
    that reads and executes Python scripts on remote servers using a tool named SSH.
    SSH is a protocol that allows a user of one computer to remotely log in to another
    computer and execute commands on the command line, provided that the user has
    an account on the remote machine.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了自动化设置和将应用程序代码推送到服务器的过程，我们将使用一个名为fabric的Python工具。Fabric是一个命令行程序，它使用名为SSH的工具在远程服务器上读取和执行Python脚本。SSH是一种协议，允许一台计算机的用户远程登录到另一台计算机并在命令行上执行命令，前提是用户在远程机器上有一个帐户。
- en: 'To install `fabric`, we will use `pip` as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`fabric`，我们将使用`pip`如下：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`fabric` commands are collections of command-line programs to be run on the
    remote machine''s shell, in this case, bash. We are going to make three different
    commands: one to run our unit tests, one to set up a brand new server to our specifications,
    and one to have the server update its copy of the application code with `git`.
    We will store these commands in a new file at the root of our project directory
    named `fabfile.py`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`fabric`命令是一组命令行程序，将在远程机器的shell上运行，本例中为bash。我们将创建三个不同的命令：一个用于运行单元测试，一个用于根据我们的规格设置全新的服务器，一个用于让服务器使用`git`更新其应用程序代码的副本。我们将把这些命令存储在项目目录根目录下的一个名为`fabfile.py`的新文件中。'
- en: 'As it''s the easiest to create, let''s make the test command first:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是最容易创建的，让我们首先创建测试命令：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To run this function from the command line, we can use `fabric` command-line
    interface by passing the name of the command to run:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要从命令行运行此函数，我们可以使用`fabric`命令行界面，通过传递要运行的命令的名称来运行：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Fabric has three main commands: `local`, `run`, and `sudo`. The `local` function,
    as seen in the preceding function, `run` commands on the local computer. The `run`
    and `sudo` functions run commands on a remote machine, but `sudo` runs commands
    as an administrator. All of these functions notify fabric whether the command
    ran successfully or not. If the command didn''t run successfully, which means
    that, in this case, our tests failed, any other commands in the function will
    not be run. This is useful for our commands because it allows us to force ourselves
    not to push any code to the server that does not pass our tests.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Fabric有三个主要命令：`local`，`run`和`sudo`。`local`函数在前面的函数中可见，`run`在本地计算机上运行命令。`run`和`sudo`函数在远程计算机上运行命令，但`sudo`以管理员身份运行命令。所有这些函数都会通知fabric命令是否成功运行。如果命令未成功运行，这意味着在这种情况下我们的测试失败，函数中的任何其他命令都不会运行。这对我们的命令很有用，因为它允许我们强制自己不要将任何未通过测试的代码推送到服务器。
- en: Now we need to create the command to set up a new server from scratch. What
    this command will do is install the software that our production environment needs
    as well as downloads the code from our centralized `git` repository. It will also
    create a new user that will act as the runner of the web server as well as the
    owner of the code repository.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要创建一个命令来从头开始设置新服务器。这个命令将安装我们的生产环境需要的软件，并从我们的集中式`git`存储库下载代码。它还将创建一个新用户，该用户将充当web服务器的运行者以及代码存储库的所有者。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not run your web server or have your code deployed by the root user. This
    opens your application to a whole host of security vulnerabilities.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用root用户运行您的web服务器或部署您的代码。这会使您的应用程序面临各种安全漏洞。
- en: 'This command will differ based on your operating system, and we will be adding
    this command in the rest of the chapter based on what server you choose:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将根据您的操作系统而有所不同，我们将根据您选择的服务器在本章的其余部分中添加这个命令：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: There are two new fabric features in this script. The first is the `env.hosts`
    assignment, which tells fabric the user and IP address of the machine it should
    be logging in to. Second, there is the `cd` function used in conjunction with
    the with keyword, which executes any functions in the context of that directory
    instead of the home directory of the deploy user. The line that modifies the `git`
    configuration is there to tell `git` to remember your repository's username and
    password, so you do not have to enter it every time you wish to push code to the
    server. Also, before the server is set up, we make sure to update the server's
    software to keep the server up to date.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本中有两个新的fabric功能。第一个是`env.hosts`赋值，它告诉fabric应该登录到的机器的用户和IP地址。其次，有与关键字一起使用的`cd`函数，它在该目录的上下文中执行任何函数，而不是在部署用户的主目录中。修改`git`配置的行是为了告诉`git`记住存储库的用户名和密码，这样您就不必每次希望将代码推送到服务器时都输入它。此外，在设置服务器之前，我们确保更新服务器的软件以保持服务器的最新状态。
- en: Finally, we have the function to push our new code to the server. In time, this
    command will also restart the web server and reload any configuration files that
    come from our code. But that depends on the server you choose, so this is filled
    out in the subsequent sections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个将新代码推送到服务器的功能。随着时间的推移，这个命令还将重新启动web服务器并重新加载来自我们代码的任何配置文件。但这取决于您选择的服务器，因此这将在后续部分中填写。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, if we were to begin working on a new server, all we would need to do to
    set it up is to run the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们要开始在新服务器上工作，我们只需要运行以下命令：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Running your web server with supervisor
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用supervisor运行您的web服务器
- en: Now that we have automated our updating process, we need some program on the
    server to make sure that our web server, and database if you aren't using SQLite,
    is running. To do this, we will use a simple program called supervisor. All that
    supervisor does is automatically runs command-line programs in background processes
    and allows you to see the status of the running programs. Supervisor also monitors
    all of the processes it's running, and if the process dies, it tries to restart
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经自动化了更新过程，我们需要服务器上的一些程序来确保我们的web服务器以及如果您没有使用SQLite的话数据库正在运行。为此，我们将使用一个名为supervisor的简单程序。supervisor的所有功能都是自动在后台进程中运行命令行程序，并允许您查看正在运行的程序的状态。Supervisor还监视其正在运行的所有进程，如果进程死掉，它会尝试重新启动它。
- en: 'To install `supervisor`, we need to add it to the setup command in our `fabfile.py`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`supervisor`，我们需要将其添加到`fabfile.py`中的设置命令中：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To tell `supervisor` what to do, we need to create a configuration file and
    then copy it to the `/etc/supervisor/conf.d/` directory of our server during the
    deploy `fabric` command. `Supervisor` will load all of the files in this directory
    when it starts and attempts to run them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 告诉“supervisor”要做什么，我们需要创建一个配置文件，然后在部署“fabric”命令期间将其复制到服务器的`/etc/supervisor/conf.d/`目录中。当`supervisor`启动并尝试运行时，它将加载此目录中的所有文件。
- en: 'In a new file in the root of our project directory named `supervisor.conf`,
    add the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录的根目录中新建一个名为`supervisor.conf`的文件，添加以下内容：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is the bare minimum configuration needed to get a web server up and running.
    But, supervisor has a lot more configuration options. To view all of the customizations,
    go to the supervisor documentation at [http://supervisord.org/](http://supervisord.org/).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使web服务器运行所需的最低配置。但是，supervisor还有很多配置选项。要查看所有自定义内容，请访问supervisor文档[http://supervisord.org/](http://supervisord.org/)。
- en: This configuration tells `supervisor` to run a command in the context of `/home/deploy/webapp`
    under the `deploy` user. The right hand of the command value is empty because
    it depends on what server you are running and will be filled in for each section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置告诉`supervisor`在`deploy`用户的上下文中运行命令`/home/deploy/webapp`。命令值的右侧为空，因为它取决于您正在运行的服务器，并将填充到每个部分中。
- en: Now we need to add a `sudo` call in the deploy command to copy this configuration
    file to the `/etc/supervisor/conf.d/` directory as follows.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要在部署命令中添加一个`sudo`调用，将此配置文件复制到`/etc/supervisor/conf.d/`目录中，如下所示。
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: A lot of projects just create the files on the server and forget about them,
    but having the configuration file stored in our `git` repository and copied on
    every deployment gives several advantages. First, this means that it is easy to
    revert changes if something goes wrong using `git`. Second, it means that we don't
    have to log in to our server in order to make changes to the files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多项目只是在服务器上创建文件然后忘记它们，但是将配置文件存储在我们的`git`存储库中，并在每次部署时复制它们具有几个优点。首先，这意味着如果出现问题，可以使用`git`轻松恢复更改。其次，这意味着我们不必登录服务器即可对文件进行更改。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't use the Flask development server in production. It not only fails to handle
    concurrent connections but also allows arbitrary Python code to be run on your
    server.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在生产中使用Flask开发服务器。它不仅无法处理并发连接，还允许在服务器上运行任意Python代码。
- en: Gevent
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gevent
- en: The simplest option to get a web server up and running is to use a Python library
    named gevent to host your application. Gevent is a Python library that adds an
    alternative way of doing concurrent programming outside the Python threading library
    called **co-routines**. Gevent has an interface to run WSGI applications that
    is both simple and has good performance. A simple gevent server can easily handle
    hundreds of concurrent users, which is 99% more than the users of websites on
    the Internet will ever have. The downside to this option is that its simplicity
    means a lack of configuration options. There is no way, for example, to add rate
    limiting to the server or to add HTTPS traffic. This deployment option is purely
    for sites that you don't expect to receive a huge amount of traffic. Remember
    YAGNI; only upgrade to a different web server if you really need to.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让Web服务器运行起来的最简单的选择是使用一个名为gevent的Python库来托管您的应用程序。Gevent是一个Python库，它提供了一种在Python线程库之外进行并发编程的替代方式，称为**协程**。Gevent具有一个接口来运行简单且性能良好的WSGI应用程序。一个简单的gevent服务器可以轻松处理数百个并发用户，这比互联网上网站的用户数量多99%。这种选择的缺点是它的简单性意味着缺乏配置选项。例如，无法向服务器添加速率限制或添加HTTPS流量。这种部署选项纯粹是为了那些您不希望接收大量流量的网站。记住YAGNI；只有在真正需要时才升级到不同的Web服务器。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Co-routines are a bit outside of the scope of this book, so a good explanation
    can be found at [https://en.wikipedia.org/wiki/Coroutine](https://en.wikipedia.org/wiki/Coroutine).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 协程有点超出了本书的范围，因此可以在[https://en.wikipedia.org/wiki/Coroutine](https://en.wikipedia.org/wiki/Coroutine)找到一个很好的解释。
- en: 'To install `gevent`, we will use `pip`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`gevent`，我们将使用`pip`：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In a new file in the root of the project directory named `gserver.py`, add
    the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录的根目录中新建一个名为`gserver.py`的文件，添加以下内容：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To run the server with supervisor, just change the command value to the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在supervisor中运行服务器，只需将命令值更改为以下内容：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now when you deploy, `gevent` will be automatically installed for you by running
    your `requirements.txt` on every deployment, that is, if you are properly pip
    freezing after every new dependency is added.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您部署时，`gevent`将通过在每次添加新依赖项后适当地pip冻结来自动安装，也就是说，如果您在每次添加新依赖项后都进行pip冻结。
- en: Tornado
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Tornado
- en: Tornado is another very simple way to deploy WSGI apps purely with Python. Tornado
    is a web server that is designed to handle thousands of simultaneous connections.
    If your application needs real-time data, Tornado also supports WebSockets for
    continuous, long-lived connections to the server.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Tornado是部署WSGI应用程序的另一种非常简单的纯Python方式。Tornado是一个设计用来处理成千上万个同时连接的Web服务器。如果您的应用程序需要实时数据，Tornado还支持WebSockets，以实现与服务器的持续、长期的连接。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not use Tornado in production on a Windows server. The Windows version of
    Tornado is not only much slower, but it is considered beta quality software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在Windows服务器上生产使用Tornado。Tornado的Windows版本不仅速度慢得多，而且被认为是质量不佳的测试版软件。
- en: 'To use Tornado with our application, we will use Tornado''s `WSGIContainer`
    in order to wrap the application object to make it Tornado compatible. Then, Tornado
    will start to listen on port *80* for requests until the process is terminated.
    In a new file named `tserver.py`, add the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Tornado与我们的应用程序一起使用，我们将使用Tornado的`WSGIContainer`来包装应用程序对象，使其与Tornado兼容。然后，Tornado将开始监听端口*80*的请求，直到进程终止。在一个名为`tserver.py`的新文件中，添加以下内容：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run the Tornado with supervisor, just change the command value to the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要在supervisor中运行Tornado，只需将命令值更改为以下内容：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Nginx and uWSGI
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Nginx和uWSGI
- en: 'If you need more performance or customization, the most popular way to deploy
    a Python web application is to use the web server Nginx as a frontend for the
    WSGI server uWSGI by using a reverse proxy. A reverse proxy is a program in networks
    that retrieves contents for a client from a server as if they returned from the
    proxy itself:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要更高的性能或自定义，部署Python Web应用程序的最流行方式是使用Web服务器Nginx作为WSGI服务器uWSGI的前端，通过使用反向代理。反向代理是网络中的一个程序，它从服务器检索内容，就好像它们是从代理服务器返回的一样：
- en: '![Nginx and uWSGI](img/B03929_13_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![Nginx和uWSGI](img/B03929_13_01.jpg)'
- en: Nginx and uWSGI are used in this way because we get the power of the Nginx frontend
    while having the customization of uWSGI.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx和uWSGI是以这种方式使用的，因为我们既可以获得Nginx前端的强大功能，又可以拥有uWSGI的自定义功能。
- en: Nginx is a very powerful web server that became popular by providing the best
    combination of speed and customization. Nginx is consistently faster than other
    web severs such as Apache httpd and has native support for WSGI applications.
    The way it achieves this speed is several good architecture decisions as well
    as the decision early on that they were not going to try to cover a large amount
    of use cases like Apache does. Having a smaller feature set makes it much easier
    to maintain and optimize the code. From a programmer's perspective, it is also
    much easier to configure Nginx, as there is no giant default configuration file
    (`httpd.conf`) that needs to be overridden with `.htaccess` files in each of your
    project directories.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Nginx是一个非常强大的Web服务器，通过提供速度和定制性的最佳组合而变得流行。Nginx始终比其他Web服务器（如Apache httpd）更快，并且原生支持WSGI应用程序。它实现这种速度的方式是通过几个良好的架构决策，以及早期决定他们不打算像Apache那样覆盖大量用例。功能集较小使得维护和优化代码变得更加容易。从程序员的角度来看，配置Nginx也更容易，因为没有一个需要在每个项目目录中用`.htaccess`文件覆盖的巨大默认配置文件（`httpd.conf`）。
- en: One downside is that Nginx has a much smaller community than Apache, so if you
    have an obscure problem, you are less likely to be able to find answers online.
    Also, it's possible that a feature that most programmers are used to in Apache
    isn't supported in Nginx.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个缺点是Nginx的社区比Apache要小得多，因此如果遇到问题，您可能不太可能在网上找到答案。此外，有可能在Nginx中不支持大多数程序员在Apache中习惯的功能。
- en: uWSGI is a web server that supports several different types of server interfaces,
    including WSGI. uWSGI handles severing the application content as well as things
    such as load balancing traffic across several different processes and threads.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI是一个支持多种不同类型的服务器接口（包括WSGI）的Web服务器。uWSGI处理应用程序内容以及诸如负载平衡流量等事项。
- en: 'To install uWSGI, we will use `pip`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装uWSGI，我们将使用`pip`。
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In order to run our application, uWSGI needs a file with an accessible WSGI
    application. In a new file named `wsgi.py` in the top level of the project directory,
    add the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行我们的应用程序，uWSGI需要一个包含可访问的WSGI应用程序的文件。在项目目录的顶层中创建一个名为`wsgi.py`的新文件，添加以下内容：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To test uWSGI, we can run it from the command line with the following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试uWSGI，我们可以使用以下命令从命令行运行它：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you are running this on your server, you should be able to access port *8080*
    and see your app (if you don't have a firewall that is).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在服务器上运行此操作，您应该能够访问*8080*端口并查看您的应用程序（如果您没有防火墙的话）。
- en: What this command does is load the app object from the `wsgi.py` file and makes
    it accessible from `localhost` on port *8080*. It also spawns four different processes
    with two threads each, which are automatically load balanced by a master process.
    This amount of processes is overkill for the vast, vast majority of websites.
    To start off, use a single process with two threads and scale up from there.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令的作用是从`wsgi.py`文件中加载app对象，并使其可以从*8080*端口的`localhost`访问。它还生成了四个不同的进程，每个进程有两个线程，这些进程由一个主进程自动进行负载平衡。对于绝大多数网站来说，这个进程数量是过剩的。首先，使用一个进程和两个线程，然后逐步扩展。
- en: Instead of adding all of the configuration options on the command line, we can
    create a text file to hold our configuration, which brings the same benefits for
    configuration that were listed in the section on supervisor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个文本文件来保存配置，而不是在命令行上添加所有配置选项，这样可以带来与在supervisor部分列出的配置相同的好处。
- en: 'In a new file in the root of the project directory named `uwsgi.ini`, add the
    following code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目目录的根目录中的一个名为`uwsgi.ini`的新文件中添加以下代码：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: uWSGI supports hundreds of configuration options as well as several official
    and unofficial plugins. To leverage the full power of uWSGI, you can explore the
    documentation at [http://uwsgi-docs.readthedocs.org/](http://uwsgi-docs.readthedocs.org/).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI支持数百种配置选项，以及几个官方和非官方的插件。要充分利用uWSGI的功能，您可以在[http://uwsgi-docs.readthedocs.org/](http://uwsgi-docs.readthedocs.org/)上查阅文档。
- en: 'Let''s run the server now from supervisor:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从supervisor运行服务器：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We also need to install Nginx within the setup function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在设置函数中安装Nginx：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Because we are installing Nginx from the OS's package manager, the OS will handle
    running of Nginx for us.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们是从操作系统的软件包管理器中安装Nginx，所以操作系统会为我们处理Nginx的运行。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'At the time of writing, the Nginx version in the official Debian package manager
    is several years old. To install the most recent version, follow the instructions
    here: [http://wiki.nginx.org/Install](http://wiki.nginx.org/Install).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，官方Debian软件包管理器中的Nginx版本已经过时数年。要安装最新版本，请按照这里的说明进行操作：[http://wiki.nginx.org/Install](http://wiki.nginx.org/Install)。
- en: 'Next, we need to create an Nginx configuration file and then copy it to the
    `/etc/nginx/sites-available/ directory` when we push the code. In a new file in
    the root of the project directory named `nginx.conf`, add the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个Nginx配置文件，然后在推送代码时将其复制到`/etc/nginx/sites-available/`目录中。在项目目录的根目录中的一个名为`nginx.conf`的新文件中添加以下内容：
- en: '[PRE20]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: What this configuration file does is it tells Nginx to listen for incoming requests
    on port *80*, and forwards all requests to the WSGI application that is listening
    on port *8080*. Also, it makes an exception for any requests for static files
    and instead sends those requests directly to the file system. Bypassing uWSGI
    for static files gives a great performance boost, as Nginx is really good at serving
    static files quickly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配置文件的作用是告诉Nginx在*80*端口监听传入请求，并将所有请求转发到在*8080*端口监听的WSGI应用程序。此外，它对静态文件的任何请求进行了例外处理，并直接将这些请求发送到文件系统。绕过uWSGI处理静态文件可以大大提高性能，因为Nginx在快速提供静态文件方面非常出色。
- en: 'Finally, in the `fabfile.py` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`fabfile.py`文件中：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Apache and uWSGI
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache和uWSGI
- en: 'Using Apache httpd with uWSGI has mostly the same setup. First off, we need
    an apache configuration file in a new file in the root of our project directory
    named `apache.conf`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Apache httpd与uWSGI基本上具有相同的设置。首先，我们需要在项目目录的根目录中的一个名为`apache.conf`的新文件中创建一个apache配置文件：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This file just tells Apache to pass all requests on port *80* to the uWSGI
    web server listening on port *8080*. However, this functionality requires an extra
    Apache plugin from uWSGI named `mod-proxy-uwsgi`. We can install this as well
    as Apache in the set command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件只是告诉Apache将所有端口为*80*的请求传递到端口为*8080*的uWSGI Web服务器。但是，此功能需要来自uWSGI的额外Apache插件，名为`mod-proxy-uwsgi`。我们可以在set命令中安装这个插件以及Apache：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, in the `deploy` command, we need to copy our Apache configuration
    file into Apache''s configuration directory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在`deploy`命令中，我们需要将我们的Apache配置文件复制到Apache的配置目录中：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Deploying on Heroku
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Heroku上部署
- en: Heroku is the first of the **Platform as a Service** (**PaaS**) providers that
    this chapter will cover. PaaS is a service given to web developers that allows
    them to host their websites on a platform that is controlled and maintained by
    someone else. At the cost of freedom, you gain assurances that your website will
    automatically scale with the number of users your site has with no extra work
    on your part. Using PaaS also tends to be more expensive than running your own
    servers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是本章将要介绍的**平台即服务**（**PaaS**）提供商中的第一个。PaaS是提供给Web开发人员的一项服务，允许他们在由他人控制和维护的平台上托管他们的网站。以牺牲自由为代价，您可以确保您的网站将随着用户数量的增加而自动扩展，而无需您额外的工作。使用PaaS通常也比运行自己的服务器更昂贵。
- en: Heroku is PaaS that aims to be easy to use for web developers by hooking into
    already existing tools and not requiring any large changes in the app. Heroku
    works by reading the file named `Procfile`, which contains commands that your
    Heroku dyno basically a virtual machine sitting on a server, will run. Before
    we begin, you will need a Heroku account. If you wish to just experiment, there
    is a free account available.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku是一种旨在对Web开发人员易于使用的PaaS，它通过连接已经存在的工具并不需要应用程序中的任何大更改来工作。Heroku通过读取名为`Procfile`的文件来工作，该文件包含您的Heroku
    dyno基本上是一个坐落在服务器上的虚拟机将运行的命令。在开始之前，您将需要一个Heroku帐户。如果您只是想进行实验，可以使用免费帐户。
- en: 'In a new file named `Procfile` in the root of the directory, add the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在目录的根目录中新建一个名为`Procfile`的文件，添加以下内容：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This tells Heroku that we have a process named web, which will run the uWSGI
    command and pass the `uwsgi.ini` file. Heroku also needs a file named `runtime.txt`,
    which will tell it what Python runtime you wish to use, (at the time of writing,
    the latest Python release is 2.7.10):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Heroku我们有一个名为web的进程，它将运行uWSGI命令并传递`uwsgi.ini`文件。Heroku还需要一个名为`runtime.txt`的文件，它将告诉它您希望使用哪个Python运行时（在撰写本文时，最新的Python版本是2.7.10）：
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we need to make some modifications to the `uwsgi.ini` file that we
    made earlier:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要对之前创建的`uwsgi.ini`文件进行一些修改：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We set the port at uWSGI listens to the environment variable port because Heroku
    does not directly expose the dyno to the Internet. Instead, it has a very complicated
    load balancer and reverse proxy system, so we need to have uWSGI listen on the
    port that Heroku needs us to listen on. Also, we set **die-on-term** to true so
    that uWSGI listens for a signal termination event from the OS correctly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将端口设置为uWSGI监听环境变量端口，因为Heroku不直接将dyno暴露给互联网。相反，它有一个非常复杂的负载均衡器和反向代理系统，因此我们需要让uWSGI监听Heroku需要我们监听的端口。此外，我们将**die-on-term**设置为true，以便uWSGI正确监听来自操作系统的终止信号事件。
- en: To work with Heroku's command-line tools, we first need to install them, which
    can be done from [https://toolbelt.heroku.com](https://toolbelt.heroku.com).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Heroku的命令行工具，我们首先需要安装它们，可以从[https://toolbelt.heroku.com](https://toolbelt.heroku.com)完成。
- en: 'Next, you need to log in to your account:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要登录到您的帐户：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can test our setup to make sure that it will work on Heroku before we deploy
    it by using the foreman command:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用foreman命令测试我们的设置，以确保它在Heroku上运行之前可以正常工作：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Foreman command simulates the same production environment that Heroku uses run
    our app. To create the dyno, which will run the application on Heroku's servers,
    we will use the `create` command. Then, we can push to the remote branch Heroku
    on our `git` repository to have Heroku servers automatically pull down our changes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Foreman命令模拟了Heroku用于运行我们的应用的相同生产环境。要创建将在Heroku服务器上运行应用程序的dyno，我们将使用`create`命令。然后，我们可以推送到`git`存储库上的远程分支Heroku，以便Heroku服务器自动拉取我们的更改。
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If everything went well, you should have a working application on your new
    Heroku dyno. You can open a new tab to your new web application with the following
    command:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，您应该在新的Heroku dyno上拥有一个可工作的应用程序。您可以使用以下命令在新的标签页中打开新的Web应用程序：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To see the app on a Heroku deployment in action, visit [https://mastering-flask.herokuapp.com/](https://mastering-flask.herokuapp.com/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Heroku部署中的应用程序运行情况，请访问[https://mastering-flask.herokuapp.com/](https://mastering-flask.herokuapp.com/)。
- en: Using Heroku Postgres
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Heroku Postgres
- en: 'Maintaining a database properly is a full-time job. Thankfully, we can use
    one of Heroku''s built-in features in order to automate this process for us. Heroku
    Postgres is a Postgres database that is maintained and hosted entirely by Heroku.
    Because we are using SQLAlchemy, using Heroku Postgres is trivial. In your dyno''s
    dashboard, there is a link to your **Heroku Postgres** information. By clicking
    on it, you will be taken to a page as the one shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地维护数据库是一项全职工作。幸运的是，我们可以利用Heroku内置的功能之一来自动化这个过程。Heroku Postgres是由Heroku完全维护和托管的Postgres数据库。因为我们正在使用SQLAlchemy，所以使用Heroku
    Postgres非常简单。在您的dyno仪表板上，有一个指向**Heroku Postgres**信息的链接。点击它，您将被带到一个页面，就像这里显示的页面一样：
- en: '![Using Heroku Postgres](img/B03929_13_02.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![使用Heroku Postgres](img/B03929_13_02.jpg)'
- en: By clicking on the **URL** field, you will have an SQLAlchemy URL, which you
    can directly copy to your production configuration object.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**URL**字段，您将获得一个SQLAlchemy URL，您可以直接复制到生产配置对象中。
- en: Using Celery on Heroku
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Heroku上使用Celery
- en: We have our production web server and database setup, but we still need to set
    up Celery. Using one of Heroku's many plugins, we can host a RabbitMQ instance
    in the cloud while running the Celery worker on the dyno.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了生产Web服务器和数据库，但我们仍然需要设置Celery。使用Heroku的许多插件之一，我们可以在云中托管RabbitMQ实例，同时在dyno上运行Celery
    worker。
- en: 'The first step is to tell Heroku to run your celery worker in the `Procfile`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是告诉Heroku在`Procfile`中运行您的celery worker：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Next, to install the Heroku RabbitMQ plugin with the free plan (named the `lemur`
    plan), use the following command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，要安装Heroku RabbitMQ插件并使用免费计划（名为`lemur`计划），请使用以下命令：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To get the full list of Heroku add-ons, go to [https://elements.heroku.com/addons](https://elements.heroku.com/addons).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取Heroku插件的完整列表，请转到[https://elements.heroku.com/addons](https://elements.heroku.com/addons)。
- en: 'At the same location on the dashboard where Heroku Postgres was listed, you
    will now find **CloudAMQP**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在Heroku Postgres列出的仪表板上的相同位置，您现在将找到**CloudAMQP**：
- en: '![Using Celery on Heroku](img/B03929_13_03.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![在Heroku上使用Celery](img/B03929_13_03.jpg)'
- en: 'Clicking on it will also give you a screen with a copiable URL, which you can
    paste into your production configuration:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 点击它还会给您一个可复制的URL屏幕，您可以将其粘贴到生产配置中：
- en: '![Using Celery on Heroku](img/B03929_13_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![在Heroku上使用Celery](img/B03929_13_04.jpg)'
- en: Deploying on Amazon web services
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在亚马逊网络服务上部署
- en: '**Amazon Web Services** (**AWS**) is a collection of application platforms
    maintained by Amazon and built on top of the same infrastructure that runs [amazon.com](http://amazon.com).
    To deploy our Flask code, we will be using Amazon Elastic Beanstalk, while the
    database will be hosted on Amazon Relational Database Service, and our messaging
    queue for Celery will be hosted on Amazon Simple Queue Service.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**亚马逊网络服务**（**AWS**）是由亚马逊维护的一组应用程序平台，构建在运行[amazon.com](http://amazon.com)的相同基础设施之上。为了部署我们的Flask代码，我们将使用亚马逊弹性Beanstalk，而数据库将托管在亚马逊关系数据库服务上，我们的Celery消息队列将托管在亚马逊简单队列服务上。'
- en: Using Flask on Amazon Elastic Beanstalk
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在亚马逊弹性Beanstalk上使用Flask
- en: Elastic Beanstalk is a platform for web applications that offers many powerful
    features for developers, so web developers do not have to worry about maintaining
    servers.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Elastic Beanstalk是一个为Web应用程序提供许多强大功能的平台，因此Web开发人员无需担心维护服务器。
- en: For example, your Elastic Beanstalk application will automatically scale by
    utilizing more and more servers as the number of people using your app at once
    grows. For Python apps, Elastic Beanstalk uses Apache in combination with `mod_wsgi`
    to connect to WSGI applications, so there is no extra configuration needed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您的Elastic Beanstalk应用程序将通过利用更多服务器自动扩展，因为同时使用您的应用程序的人数增加。对于Python应用程序，Elastic
    Beanstalk使用Apache与`mod_wsgi`结合连接到WSGI应用程序，因此不需要额外的配置。
- en: 'Before we begin, you will need an [Amazon.com](http://Amazon.com) account and
    log in to [http://aws.amazon.com/elasticbeanstalk](http://aws.amazon.com/elasticbeanstalk).
    When you are logged in, you will see a screen like the following image:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，您将需要一个[Amazon.com](http://Amazon.com)账户并登录[http://aws.amazon.com/elasticbeanstalk](http://aws.amazon.com/elasticbeanstalk)。登录后，您将看到如下图所示的屏幕：
- en: '![Using Flask on Amazon Elastic Beanstalk](img/B03929_13_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![在亚马逊弹性Beanstalk上使用Flask](img/B03929_13_05.jpg)'
- en: 'Click on the dropdown to select Python, and if your application needs a specific
    Python version, be sure to click on **Change platform version** and select the
    Python version you need. You will be taken through a setup process, and finally
    your app will go through an initialization process on Amazon''s servers. While
    this is working, we can install the Elastic Beanstalk command-line tools. These
    tools will allow us to automatically deploy new versions of our application. To
    install them, use `pip`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下拉菜单选择Python，如果您的应用程序需要特定的Python版本，请务必点击**更改平台版本**并选择您需要的Python版本。您将通过设置过程，并最终您的应用程序将在亚马逊的服务器上进行初始化过程。在此期间，我们可以安装Elastic
    Beanstalk命令行工具。这些工具将允许我们自动部署应用程序的新版本。要安装它们，请使用`pip`：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before we can deploy the application, you will need an AWS Id and access key.
    To do this, click on the dropdown that displays your username at the top of the
    page and click on **Security Credentials**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们部署应用程序之前，您将需要一个AWS Id和访问密钥。要做到这一点，请点击显示在页面顶部的用户名的下拉菜单，然后点击**安全凭据**。
- en: '![Using Flask on Amazon Elastic Beanstalk](img/B03929_13_06.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![在亚马逊弹性Beanstalk上使用Flask](img/B03929_13_06.jpg)'
- en: 'Then, click on the gray box that says **Access Keys** to get your ID and key
    pair:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击灰色框，上面写着**访问密钥**以获取您的ID和密钥对：
- en: '![Using Flask on Amazon Elastic Beanstalk](img/B03929_13_07.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![在亚马逊弹性Beanstalk上使用Flask](img/B03929_13_07.jpg)'
- en: 'Once you have your key pair, do not share it with anyone because it will give
    anyone access to have a complete control over all of your platform instances on
    AWS. Now we can set up the command-line tools. In your project directory, run
    the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您拥有密钥对，请不要与任何人分享，因为这将使任何人都能完全控制您在AWS上的所有平台实例。现在我们可以设置命令行工具。在您的项目目录中，运行以下命令：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Select the application that you created earlier to tie this directory to that
    application. We can see what is running on the application instance now by running
    the following:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 选择您之前创建的应用程序，将此目录与该应用程序绑定。我们可以通过运行以下命令来查看应用程序实例上正在运行的内容：
- en: '[PRE36]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Right now, you should just see a placeholder application. Let''s change that
    by deploying our app. Elastic Beanstalk looks for a file named `application.py`
    in your project directory, and it expects a WSGI application named application
    in that file, so let''s create that file now:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该只看到一个占位应用程序。让我们通过部署我们的应用程序来改变这一点。Elastic Beanstalk在您的项目目录中寻找名为`application.py`的文件，并且它期望在该文件中有一个名为application的WSGI应用程序，因此现在让我们创建该文件：
- en: '[PRE37]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Once that file is created, we can finally deploy the application:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了该文件后，我们最终可以部署应用程序：
- en: '[PRE38]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is needed to run Flask on AWS. To see the book's application running on
    Elastic Beanstalk, go to [http://masteringflask.elasticbeanstalk.com](http://masteringflask.elasticbeanstalk.com).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在AWS上运行Flask所需的。要查看该书的应用程序在Elastic Beanstalk上运行，请转到[http://masteringflask.elasticbeanstalk.com](http://masteringflask.elasticbeanstalk.com)。
- en: Using Amazon Relational Database Service
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用亚马逊关系数据库服务
- en: Amazon Relational Database Service is a database hosting platform in the cloud
    that automatically manages several things, such as recovery on node failure and
    keeping several nodes in different locations in sync.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 亚马逊关系数据库服务是一个在云中自动管理多个方面的数据库托管平台，例如节点故障时的恢复以及在不同位置保持多个节点同步。
- en: To use RDS, go to the services tab and click on Relational Database Service.
    To create your database, click on **Get Started**, which will take you though
    a simple setup process.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用RDS，转到服务选项卡，然后单击关系数据库服务。要创建数据库，请单击**开始**，然后按照简单的设置过程进行操作。
- en: 'Once your database has been configured and created, you can use the **endpoint**
    variable listed on the RDS dashboard and the database name and password to create
    the SQLAlchemy URL in your production configuration object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的数据库已配置并创建，您可以使用RDS仪表板上列出的**端点**变量以及数据库名称和密码来在生产配置对象中创建SQLAlchemy URL：
- en: '![Using Amazon Relational Database Service](img/B03929_13_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![使用亚马逊关系数据库服务](img/B03929_13_08.jpg)'
- en: This's all that it takes to create a very resilient database on the cloud with
    Flask!
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在云上使用Flask创建一个非常弹性的数据库所需的全部步骤！
- en: Using Celery with Amazon Simple Queue Service
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Celery与亚马逊简单队列服务
- en: 'In order to use Celery on AWS, we need to have our Elastic Beanstalk instance
    run our Celery worker in the background as well as set up **a Simple Queue Service**
    (**SQS**) messaging queue. For Celery to support SQS, it needs to install a helper
    library from `pip`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在AWS上使用Celery，我们需要让Elastic Beanstalk实例在后台运行我们的Celery worker，并设置**简单队列服务**（**SQS**）消息队列。为了让Celery支持SQS，它需要从`pip`安装一个辅助库：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Setting up a new messaging queue on SQS is very easy. Go to the services tab
    and click on **Simple Queue Servic**e in the applications tab and then click on
    **Create New Queue.** After a very short configuration screen, you should see
    a screen much like the following:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQS上设置一个新的消息队列非常容易。转到服务选项卡，然后单击应用程序选项卡中的**简单队列服务**，然后单击**创建新队列**。在一个非常简短的配置屏幕之后，您应该看到一个类似以下的屏幕：
- en: '![Using Celery with Amazon Simple Queue Service](img/B03929_13_09.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![使用Celery与亚马逊简单队列服务](img/B03929_13_09.jpg)'
- en: 'Now we have to change our `CELERY_BROKER_URL` and `CELERY_BACKEND_URL` to the
    new URL, which takes the following format:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将`CELERY_BROKER_URL`和`CELERY_BACKEND_URL`更改为新的URL，其格式如下：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This uses the key pair you created in the Elastic Beanstalk section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了您在Elastic Beanstalk部分创建的密钥对。
- en: 'Finally, we need to tell Elastic Beanstalk to run a Celery worker in the background.
    We can do this with the `.conf` file in a new directory at the root of the project
    named `.ebextensions` (note the period at the start of the folder name). In a
    file in this new directory, it can be called whatever you wish, add the following
    commands:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要告诉Elastic Beanstalk在后台运行Celery worker。我们可以在项目根目录下的一个新目录中的`.ebextensions`文件夹中使用`.conf`文件来完成这个操作（注意文件夹名称开头的句点）。在这个新目录中的一个文件中，可以随意命名，添加以下命令：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now whenever the instance reboots, this command will be run before the server
    is run.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每当实例重新启动时，此命令将在服务器运行之前运行。
- en: Summary
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: As this chapter explained, there are many different options to hosting your
    application, each having their own pros and cons. Deciding on one depends on the
    amount of time and money you are willing to spend as well as the total number
    of users you expect.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章所解释的，托管应用程序有许多不同的选项，每种选项都有其优缺点。选择一个取决于您愿意花费的时间和金钱以及您预期的用户总数。
- en: Now we have reached the conclusion of the book. I hope that this book was helpful
    to build your understanding of Flask and how it can be used to create applications
    of any complexity with ease and with simple maintainability.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达了本书的结尾。我希望这本书对您理解Flask以及如何使用它轻松创建任何复杂度的应用程序并进行简单维护有所帮助。
