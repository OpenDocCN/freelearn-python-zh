- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Extending Your Blog Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展您的博客应用程序
- en: The previous chapter went through the basics of forms and the creation of a
    comment system. You also learned how to send emails with Django. In this chapter,
    you will extend your blog application with other popular features used on blogging
    platforms, such as tagging, recommending similar posts, providing an RSS feed
    to readers, and allowing them to search posts. You will learn about new components
    and functionalities with Django by building these functionalities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了表单的基础知识以及评论系统的创建。您还学习了如何使用Django发送电子邮件。在本章中，您将通过添加博客平台上常用的其他功能来扩展您的博客应用程序，例如标签、推荐相似帖子、为读者提供RSS订阅源以及允许他们搜索帖子。通过构建这些功能，您将学习到Django的新组件和功能。
- en: 'The chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Implementing tagging using `django-taggit`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`django-taggit`实现标签功能
- en: Retrieving posts by similarity
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过相似度检索帖子
- en: Creating custom template tags and filters to display the latest posts and most
    commented posts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于显示最新帖子及评论最多帖子的自定义模板标签和过滤器
- en: Adding a sitemap to the site
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向网站添加网站地图
- en: Creating feeds for blog posts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为博客帖子创建订阅源
- en: Installing PostgreSQL
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: Using fixtures to dump and load data into the database
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用固定值将数据导入和导出到数据库
- en: Implementing a full-text search engine with Django and PostgreSQL
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django和PostgreSQL实现全文搜索引擎
- en: Functional overview
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能概述
- en: '*Figure 3.1* shows a representation of the views, templates, and functionalities
    that will be built in this chapter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.1*展示了本章将要构建的视图、模板和功能表示：'
- en: '![](img/B21088_03_01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_01.png)'
- en: 'Figure 3.1: Diagram of functionalities built in Chapter 3'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：第3章内置功能图
- en: In this chapter, we will build the functionality to add tags to posts. We will
    extend the `post_list` view to filter posts by tag. When loading a single post
    in the `post_detail` view, we will retrieve similar posts based on common tags.
    We will also create custom template tags to display a sidebar with the total number
    of posts, the latest posts published, and the most commented posts.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建添加标签到帖子的功能。我们将扩展`post_list`视图以按标签过滤帖子。在`post_detail`视图中加载单个帖子时，我们将根据共同标签检索相似帖子。我们还将创建自定义模板标签以显示包含帖子总数、最新发布的帖子以及评论最多的帖子的侧边栏。
- en: We will add support to write posts with Markdown syntax and convert the content
    to HTML. We will create a sitemap for the blog with the `PostSitemap` class and
    implement an RSS feed with the latest posts in the `LatestPostsFeed` class. Finally,
    we will implement a search engine with the `post_search` view and use PostgreSQL
    full-text search capabilities.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加支持使用Markdown语法编写帖子并将内容转换为HTML。我们将使用`PostSitemap`类为博客创建一个网站地图，并在`LatestPostsFeed`类中实现一个RSS订阅源。最后，我们将通过`post_search`视图实现一个搜索引擎，并使用PostgreSQL全文搜索功能。
- en: The source code for this chapter can be found at [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码可以在[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03)找到。
- en: All Python packages used in this chapter are included in the `requirements.txt`
    file in the source code for the chapter. You can follow the instructions to install
    each Python package in the following sections, or you can install all the requirements
    at once with the command `python` `-m` `pip install -r requirements.txt`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的所有Python包都包含在章节源代码中的`requirements.txt`文件中。您可以在以下部分中按照说明安装每个Python包，或者您可以使用命令`python
    -m pip install -r requirements.txt`一次性安装所有依赖项。
- en: Implementing tagging with django-taggit
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`django-taggit`实现标签功能
- en: A very common functionality in blogs is categorizing posts using tags. Tags
    allow you to categorize content in a non-hierarchical manner, using simple keywords.
    A tag is simply a label or keyword that can be assigned to posts. We will create
    a tagging system by integrating a third-party Django tagging application into
    the project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在博客中，一个非常常见的功能是使用标签对帖子进行分类。标签允许您以非层次结构的方式使用简单的关键词对内容进行分类。标签只是一个可以分配给帖子的标签或关键词。我们将通过将第三方Django标签应用程序集成到项目中来创建一个标签系统。
- en: '`django-taggit` is a reusable application that primarily offers you a `Tag`
    model and a manager to easily add tags to any model. You can take a look at its
    source code at [https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`django-taggit`是一个可重用的应用程序，它主要提供您一个`Tag`模型和一个管理器，以便轻松地将标签添加到任何模型。您可以在[https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit)查看其源代码。'
- en: 'Let’s add tagging to our blog. First, you need to install `django-taggit` via
    `pip` by running the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的博客中添加标签功能。首先，您需要通过运行以下命令使用`pip`安装`django-taggit`：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, open the `settings.py` file of the `mysite` project and add `taggit`
    to your `INSTALLED_APPS` setting, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开`mysite`项目的`settings.py`文件，并将`taggit`添加到您的`INSTALLED_APPS`设置中，如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It’s good practice to keep the Django packages at the top, third-party packages
    in the middle, and local applications at the end of `INSTALLED_APPS`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将Django包放在顶部，第三方包放在中间，本地应用放在`INSTALLED_APPS`的末尾是一种良好的实践。
- en: 'Open the `models.py` file of your `blog` application and add the `TaggableManager`
    manager provided by `django-taggit` to the `Post` model using the following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`blog`应用的`models.py`文件，并使用以下代码将`django-taggit`提供的`TaggableManager`管理器添加到`Post`模型中：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `tags` manager will allow you to add, retrieve, and remove tags from `Post`
    objects.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`管理器将允许您向`Post`对象添加、检索和删除标签。'
- en: 'The following schema shows the data models defined by `django-taggit` to create
    tags and store related tagged objects:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下模式显示了`django-taggit`定义的数据模型，用于创建标签并存储相关的标签对象：
- en: '![Diagram  Description automatically generated with low confidence](img/B21088_03_02.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图描述：自动生成，置信度低](img/B21088_03_02.png)'
- en: 'Figure 3.2: Tag models of django-taggit'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：django-taggit的标签模型
- en: The `Tag` model is used to store tags. It contains a `name` and a `slug` field.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Tag`模型用于存储标签。它包含一个`name`和一个`slug`字段。'
- en: The `TaggedItem` model is used to store the related tagged objects. It has a
    `ForeignKey` field for the related `Tag` object. It contains a `ForeignKey` to
    a `ContentType` object and an `IntegerField` to store the related `id` of the
    tagged object. The `content_type` and `object_id` fields combined form a generic
    relationship with any model in your project. This allows you to create relationships
    between a `Tag` instance and any other model instance of your applications. You
    will learn about generic relations ship in *Chapter 7*, *Tracking User Actions*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaggedItem`模型用于存储相关的标签对象。它有一个指向相关`Tag`对象的`ForeignKey`字段。它包含一个指向`ContentType`对象的`ForeignKey`和一个用于存储相关标签对象`id`的`IntegerField`。`content_type`和`object_id`字段结合形成与项目中任何模型之间的通用关系。这允许您在标签实例和应用程序中的任何其他模型实例之间创建关系。您将在*第7章*，*跟踪用户行为*中了解通用关系。'
- en: 'Run the following command in the shell prompt to create a migration for your
    model changes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在shell提示符中运行以下命令以为您模型的更改创建迁移：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You should get the following output:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该得到以下输出：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, run the following command to create the required database tables for `django-taggit`
    models and to synchronize your model changes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以创建`django-taggit`模型所需的数据库表，并同步您的模型更改：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You will see an output indicating that migrations have been applied, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出，表明迁移已应用：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The database is now in sync with the `taggit` models and we can start using
    the functionalities of `django-taggit`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库现在与`taggit`模型同步，我们可以开始使用`django-taggit`的功能了。
- en: Let’s now explore how to use the `tags` manager.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来探索如何使用`tags`管理器。
- en: 'Open the Django shell by running the following command in the system shell
    prompt:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统shell提示符中运行以下命令以打开Django shell：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Run the following code to retrieve one of the posts (the one with the `1` ID):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下代码以检索一篇帖子（ID为`1`的帖子）：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, add some tags to it and retrieve its tags to check whether they were
    successfully added:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，向其添加一些标签并检索其标签以检查它们是否已成功添加：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, remove a tag and check the list of tags again:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，删除一个标签并再次检查标签列表：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It’s really easy to add, retrieve, or remove tags from a model using the manager
    we have defined.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们定义的管理器添加、检索或删除模型中的标签非常简单。
- en: 'Start the development server from the shell prompt with the following command:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令从shell提示符启动开发服务器：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Open [http://127.0.0.1:8000/admin/taggit/tag/](http://127.0.0.1:8000/admin/taggit/tag/)
    in your browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开[http://127.0.0.1:8000/admin/taggit/tag/](http://127.0.0.1:8000/admin/taggit/tag/)。
- en: 'You will see the administration page with the list of `Tag` objects of the
    `taggit` application:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到包含`taggit`应用程序的`Tag`对象列表的管理页面。
- en: '![](img/B21088_03_03.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_03.png)'
- en: 'Figure 3.3: The tag change list view on the Django administration site'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3：Django管理站点上的标签更改列表视图
- en: 'Click on the **jazz** tag. You will see the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**jazz**标签。您将看到以下内容：
- en: '![](img/B21088_03_04.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_04.png)'
- en: 'Figure 3.4: The tag edit view on the Django administration site'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4：Django管理站点上的标签编辑视图
- en: Navigate to `http://127.0.0.1:8000/admin/blog/post/1/change/` to edit the post
    with ID 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`http://127.0.0.1:8000/admin/blog/post/1/change/`以编辑ID为1的帖子。
- en: 'You will see that posts now include a new **Tags** field, as follows, where
    you can easily edit tags:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到帖子现在包括一个新的**标签**字段，如下所示，您可以在其中轻松编辑标签：
- en: '![](img/B21088_03_05.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_05.png)'
- en: 'Figure 3.5: The related Tags field of a Post object'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5：帖子对象的关联标签字段
- en: Now, you need to edit your blog posts to display tags.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要编辑您的博客帖子以显示标签。
- en: 'Open the `blog/post/list.html` template and add the following HTML code highlighted
    in bold:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`blog/post/list.html`模板，并添加以下以粗体显示的HTML代码：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `join` template filter works analogously to Python’s string `join()` method.
    You can concatenate a list of items into one string, using a specific character
    or string to separate each item. For example, a list of tags like `['music', 'jazz',
    'piano']` is converted into a single string, `'music, jazz, piano'`, by joining
    them with `','` as the `join()` separator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`join`模板过滤器与Python的字符串`join()`方法类似。您可以使用特定的字符或字符串将一系列项目连接成一个字符串。例如，一个如`[''music'',
    ''jazz'', ''piano'']`的标签列表通过`join()`分隔符`'',''`连接后，被转换成一个单独的字符串`''music, jazz,
    piano''`。'
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser. You should be able to see
    the list of tags under each post title:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开`http://127.0.0.1:8000/blog/`。您应该能够看到每个帖子标题下的标签列表：
- en: '![](img/B21088_03_06.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_06.png)'
- en: 'Figure 3.6: The Post list item, including related tags'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：帖子列表项，包括相关标签
- en: Next, we will edit the `post_list` view to let users list all posts tagged with
    a specific tag.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将编辑`post_list`视图，让用户列出带有特定标签的所有帖子。
- en: 'Open the `views.py` file of your `blog` application, import the `Tag` model
    from `django-taggit`, and change the `post_list` view to optionally filter posts
    by a tag, as follows. New code is highlighted in bold:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`blog`应用的`views.py`文件，从`django-taggit`导入`Tag`模型，并将`post_list`视图修改为可选地通过标签过滤帖子，如下所示。新代码以粗体显示：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `post_list` view now works as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`post_list`视图现在的工作方式如下：'
- en: It takes an optional `tag_slug` parameter that has a `None` default value. This
    parameter will be passed in the URL.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它接受一个可选的`tag_slug`参数，默认值为`None`。此参数将被传递到URL中。
- en: Inside the view, we build the initial QuerySet, retrieving all published posts,
    and if there is a given tag slug, we get the `Tag` object with the given slug
    using the `get_object_or_404()` shortcut.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中，我们构建初始的查询集，检索所有已发布的帖子，如果提供了一个标签缩写，我们使用`get_object_or_404()`快捷方式获取具有给定缩写的`Tag`对象。
- en: Then, we filter the list of posts by the ones that contain the given tag. Since
    this is a many-to-many relationship, we have to filter posts by tags contained
    in a given list, which, in this case, contains only one element. We use the `__in`
    field lookup. Many-to-many relationships occur when multiple objects of a model
    are associated with multiple objects of another model. In our application, a post
    can have multiple tags and a tag can be related to multiple posts. You will learn
    how to create many-to-many relationships in *Chapter 6*, *Sharing Content on Your
    Website*. You can discover more about many-to-many relationships at [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/).
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们通过包含给定标签的帖子过滤帖子列表。由于这是一个多对多关系，我们必须通过给定列表中的标签过滤帖子，在这个例子中，列表中只有一个元素。我们使用`__in`字段查找。当多个模型对象与多个其他模型对象相关联时，会发生多对多关系。在我们的应用中，一个帖子可以有多个标签，一个标签可以与多个帖子相关联。您将在*第6章*，*在您的网站上共享内容*中学习如何创建多对多关系。您可以在[https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)了解更多关于多对多关系的信息。
- en: Finally, the `render()` function now passes the new `tag` variable to the template.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`render()`函数现在将新的`tag`变量传递给模板。
- en: Remember that QuerySets are lazy. The QuerySets to retrieve posts will only
    be evaluated when you loop over `post_list` when rendering the template.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，查询集是懒加载的。检索帖子的查询集只有在您在渲染模板时遍历`post_list`时才会被评估。
- en: 'Open the `urls.py` file of your `blog` application, comment out the class-based
    `PostListView` URL pattern, and uncomment the `post_list` view, like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 `blog` 应用程序的 `urls.py` 文件，注释掉基于类的 `PostListView` URL 模式，并取消注释 `post_list`
    视图，如下所示：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following additional URL pattern to list posts by tag:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下额外的 URL 模式添加到按标签列出文章的功能中：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, both patterns point to the same view, but they have different
    names. The first pattern will call the `post_list` view without any optional parameters,
    whereas the second pattern will call the view with the `tag_slug` parameter. You
    use a `slug` path converter to match the parameter as a lowercase string with
    ASCII letters or numbers, plus the hyphen and underscore characters.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两种模式都指向同一个视图，但它们有不同的名称。第一个模式将调用没有任何可选参数的 `post_list` 视图，而第二个模式将调用带有 `tag_slug`
    参数的视图。您使用 `slug` 路径转换器将参数匹配为小写字母、ASCII 字母或数字，以及连字符和下划线字符。
- en: 'The `urls.py` file of the `blog` application should now look like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`blog` 应用的 `urls.py` 文件现在应该看起来像这样：'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since you are using the `post_list` view, edit the `blog/post/list.html` template
    and modify the pagination to use the `posts` object:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你正在使用 `post_list` 视图，编辑 `blog/post/list.html` 模板并修改分页以使用 `posts` 对象：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following lines highlighted in bold to the `blog/post/list.html` template:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下加粗的行添加到 `blog/post/list.html` 模板中：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If a user is accessing the blog, they will see the list of all posts. If they
    filter by posts tagged with a specific tag, they will see the tag that they are
    filtering by.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户正在访问博客，他们将看到所有文章的列表。如果他们通过特定标签的文章进行过滤，他们将看到他们正在过滤的标签。
- en: 'Now, edit the `blog/post/list.html` template and change the way tags are displayed,
    as follows. New lines are highlighted in bold:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑 `blog/post/list.html` 模板并更改显示标签的方式，如下。新行被加粗：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding code, we loop through all the tags of a post displaying a custom
    link to the URL to filter posts by that tag. We build the URL with `{% url "blog:post_list_by_tag"
    tag.slug %}`, using the name of the URL and the `slug` tag as its parameter. You
    separate the tags with commas.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们遍历显示自定义链接到 URL 的文章的所有标签，以通过该标签过滤文章。我们使用 `{% url "blog:post_list_by_tag"
    tag.slug %}` 构建该 URL，使用 URL 名称和 `slug` 标签作为其参数。您使用逗号分隔标签。
- en: 'Open `http://127.0.0.1:8000/blog/tag/jazz/` in your browser. You will see the
    list of posts filtered by that tag, like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `http://127.0.0.1:8000/blog/tag/jazz/`。你会看到按该标签过滤的文章列表，如下所示：
- en: '![](img/B21088_03_07.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_07.png)'
- en: 'Figure 3.7: A post filtered by the tag “jazz”'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：按标签“jazz”过滤的文章
- en: Retrieving posts by similarity
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过相似性检索文章
- en: Now that we have implemented tagging for blog posts, you can do many interesting
    things with tags. Tags allow you to categorize posts in a non-hierarchical manner.
    Posts about similar topics will have several tags in common. We will build a functionality
    to display similar posts by the number of tags they share. In this way, when a
    user reads a post, we can suggest to them that they read other related posts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了博客文章的标签功能，你可以用标签做很多有趣的事情。标签允许你以非层次结构的方式对文章进行分类。关于类似主题的文章将具有几个共同的标签。我们将构建一个功能来显示具有共享标签数量的相似文章。这样，当用户阅读一篇文章时，我们可以建议他们阅读其他相关的文章。
- en: 'In order to retrieve similar posts for a specific post, you need to perform
    the following steps:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检索特定文章的相似文章，你需要执行以下步骤：
- en: Retrieve all tags for the current post.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取当前文章的所有标签。
- en: Get all posts that are tagged with any of those tags.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取所有带有任何这些标签的文章。
- en: Exclude the current post from that list to avoid recommending the same post.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该列表中排除当前文章，以避免推荐相同的文章。
- en: Order the results by the number of tags shared with the current post.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按与当前文章共享的标签数量对结果进行排序。
- en: In the case of two or more posts with the same number of tags, recommend the
    most recent post.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有两个或更多文章具有相同数量的标签，建议最新的文章。
- en: Limit the query to the number of posts you want to recommend.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制查询到您想要推荐的帖子数量。
- en: These steps are translated into a complex QuerySet. Let’s edit the `post_detail`
    view to incorporate these similarity-based post suggestions.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤被转换为一个复杂的 QuerySet。让我们编辑 `post_detail` 视图以包含基于相似性的文章建议。
- en: 'Open the `views.py` file of your `blog` application and add the following import
    at the top of it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的 `blog` 应用程序的 `views.py` 文件，并在其顶部添加以下导入：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the `Count` aggregation function of the Django ORM. This function will
    allow you to perform aggregated counts of tags. `django.db.models` includes the
    following aggregation functions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Django ORM的`Count`聚合函数。此函数将允许您执行标签的聚合计数。`django.db.models`包括以下聚合函数：
- en: '`Avg`: The mean value'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Avg`：平均值'
- en: '`Max`: The maximum value'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Max`：最大值'
- en: '`Min`: The minimum value'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Min`：最小值'
- en: '`Count`: The total number of objects'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Count`：对象总数'
- en: You can learn about aggregation at [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)了解有关聚合的信息。
- en: 'Open the `views.py` file of your `blog` application and add the following lines
    to the `post_detail` view. New lines are highlighted in bold:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`blog`应用的`views.py`文件，并将以下行添加到`post_detail`视图中。新行以粗体突出显示：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码如下：
- en: You retrieve a Python list of IDs for the tags of the current post. The `values_list()`
    QuerySet returns tuples with the values for the given fields. You pass `flat=True`
    to it to get single values such as `[1, 2, 3, ...]` instead of one tuple such
    as `[(1,), (2,), (3,) ...]`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您检索当前帖子标签的Python ID列表。`values_list()`查询集返回给定字段的值组成的元组。您传递`flat=True`给它以获取单个值，例如`[1,
    2, 3, ...]`，而不是一个元组，如`[(1,), (2,), (3,) ...]`。
- en: You get all posts that contain any of these tags, excluding the current post
    itself.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将获得包含以下任何标签的所有帖子，但不包括当前帖子本身。
- en: You use the `Count` aggregation function to generate a calculated field—`same_tags`—that
    contains the number of tags shared with all the tags queried.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您使用`Count`聚合函数生成一个计算字段——`same_tags`——它包含与查询的所有标签共享的标签数量。
- en: You order the result by the number of shared tags (descending order) and by
    `publish` to display recent posts first for the posts with the same number of
    shared tags. You slice the result to retrieve only the first four posts.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您按共享标签的数量（降序）和`publish`排序结果，以显示具有相同共享标签数量的帖子中的最新帖子。您截取结果以检索前四个帖子。
- en: You pass the `similar_posts` object to the context dictionary for the `render()`
    function.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将`similar_posts`对象传递到`render()`函数的上下文字典中。
- en: 'Now, edit the `blog/post/detail.html` template and add the following code highlighted
    in bold:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`blog/post/detail.html`模板，并添加以下以粗体突出显示的代码：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The post detail page should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 帖子详情页面应该看起来像这样：
- en: '![](img/B21088_03_08.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_08.png)'
- en: 'Figure 3.8: The post detail page, including a list of similar posts'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8：帖子详情页面，包括类似帖子列表
- en: 'Open `http://127.0.0.1:8000/admin/blog/post/` in your browser, edit a post
    that has no tags, and add the `music` and `jazz` tags, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开`http://127.0.0.1:8000/admin/blog/post/`，编辑一个没有标签的帖子，并添加`music`和`jazz`标签，如下所示：
- en: '![](img/B21088_03_09.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_09.png)'
- en: 'Figure 3.9: Adding the “jazz” and “music” tags to a post'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：将“jazz”和“music”标签添加到帖子中
- en: 'Edit another post and add the `jazz` tag, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑另一个帖子并添加`jazz`标签，如下所示：
- en: '![](img/B21088_03_10.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_10.png)'
- en: 'Figure 3.10: Adding the “jazz” tag to a post'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：将“jazz”标签添加到帖子中
- en: 'The post detail page for the first post should now look like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第一篇帖子的帖子详情页面现在应该看起来像这样：
- en: '![](img/B21088_03_11.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_11.png)'
- en: 'Figure 3.11: The post detail page, including a list of similar posts'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：帖子详情页面，包括类似帖子列表
- en: The posts recommended in the **Similar posts** section of the page appear in
    descending order based on the number of shared tags with the original post.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 页面**相似帖子**部分推荐的帖子根据与原始帖子共享的标签数量降序排列。
- en: We are now able to successfully recommend similar posts to readers. `django-taggit`
    also includes a `similar_objects()` manager that you can use to retrieve objects
    by shared tags. You can take a look at all `django-taggit` managers at [https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们能够成功地向读者推荐类似帖子。`django-taggit`还包括一个`similar_objects()`管理器，您可以使用它通过共享标签检索对象。您可以在[https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html)查看所有`django-taggit`管理器。
- en: You can also add the list of tags to your post detail template in the same way
    as you did in the `blog/post/list.html` template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以像在`blog/post/list.html`模板中做的那样，以相同的方式将标签列表添加到您的帖子详情模板中。
- en: Creating custom template tags and filters
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义模板标签和过滤器
- en: Django offers a variety of built-in template tags, such as `{% if %}` or `{%
    block %}`. You used different template tags in *Chapter 1*, *Building a Blog Application*,
    and *Chapter 2*, *Enhancing Your Blog with Advanced Features*. You can find a
    complete reference of built-in template tags and filters at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了各种内置模板标签，例如`{% if %}`或`{% block %}`。你在*第一章*，*构建博客应用程序*和*第二章*，*使用高级功能增强你的博客*中使用了不同的模板标签。你可以在[https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/)找到内置模板标签和过滤器的完整参考。
- en: Django also allows you to create your own template tags to perform custom actions.
    Custom template tags come in very handy when you need to add a functionality to
    your templates that is not covered by the core set of Django template tags. This
    can be a tag to execute a QuerySet or any server-side processing that you want
    to reuse across templates. For example, we could build a template tag to display
    a list of the latest posts published on the blog. We could include this list in
    the sidebar so that it is always visible, regardless of the view that processes
    the request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Django还允许你创建自己的模板标签来执行自定义操作。当你需要向模板添加核心Django模板标签集未涵盖的功能时，自定义模板标签非常有用。这可以是一个执行QuerySet或任何你想要在模板间重用的服务器端处理的标签。例如，我们可以构建一个模板标签来显示博客上最新发布的帖子列表。我们可以将这个列表包含在侧边栏中，使其始终可见，无论处理请求的是哪个视图。
- en: Implementing custom template tags
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义模板标签
- en: 'Django provides the following helper functions, which allow you to easily create
    template tags:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了以下辅助函数，这些函数允许你轻松创建模板标签：
- en: '`simple_tag`: Processes the given data and returns a string'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`simple_tag`: 处理给定数据并返回一个字符串'
- en: '`inclusion_tag`: Processes the given data and returns a rendered template'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inclusion_tag`: 处理给定数据并返回一个渲染的模板'
- en: Template tags must live inside Django applications.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签必须位于Django应用程序内部。
- en: 'Inside your `blog` application directory, create a new directory, name it `templatetags`,
    and add an empty `__init__.py` file to it. Create another file in the same folder
    and name it `blog_tags.py`. The file structure of the blog application should
    look like the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的`blog`应用程序目录中，创建一个新的目录，命名为`templatetags`，并向其中添加一个空的`__init__.py`文件。在同一个文件夹中创建另一个文件，命名为`blog_tags.py`。博客应用程序的文件结构应该如下所示：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The way you name the file is important because you will use the name of this
    module to load tags in templates.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你命名文件的方式很重要，因为你将使用这个模块的名称来在模板中加载标签。
- en: Creating a simple template tag
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个简单的模板标签
- en: Let’s start by creating a simple tag to retrieve the total posts that have been
    published on the blog.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的标签来检索博客上已发布的总帖子数开始。
- en: 'Edit the `templatetags/blog_tags.py` file you just created and add the following
    code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你刚刚创建的`templatetags/blog_tags.py`文件，并添加以下代码：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We have created a simple template tag that returns the number of posts published
    on the blog.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个简单的模板标签，它返回博客上发布的帖子数量。
- en: Each module that contains template tags needs to define a variable called `register`
    to be a valid tag library. This variable is an instance of `template.Library`,
    and it’s used to register the template tags and filters of the application.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个包含模板标签的模块都需要定义一个名为`register`的变量，以使其成为一个有效的标签库。这个变量是`template.Library`的一个实例，它用于注册应用程序的模板标签和过滤器。
- en: In the preceding code, we have defined a tag called `total_posts` with a simple
    Python function. We have added the `@register.simple_tag` decorator to the function,
    to register it as a simple tag. Django will use the function’s name as the tag
    name.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了一个名为`total_posts`的标签，它使用了一个简单的Python函数。我们向函数添加了`@register.simple_tag`装饰器，以将其注册为一个简单标签。Django将使用函数的名称作为标签名称。
- en: If you want to register it using a different name, you can do so by specifying
    a `name` attribute, such as `@register.simple_tag(name='my_tag')`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想用不同的名称注册它，你可以通过指定一个`name`属性来实现，例如`@register.simple_tag(name='my_tag')`。
- en: After adding a new template tags module, you will need to restart the Django
    development server in order to use the new tags and filters in templates.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加新的模板标签模块后，你需要重新启动Django开发服务器，以便在模板中使用新的标签和过滤器。
- en: Before using custom template tags, we have to make them available for the template
    using the `{% load %}` tag. As mentioned before, we need to use the name of the
    Python module containing our template tags and filters.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用自定义模板标签之前，我们必须使用`{% load %}`标签使它们对模板可用。如前所述，我们需要使用包含我们的模板标签和过滤器的Python模块的名称。
- en: 'Edit the `blog/templates/base.html` template and add `{% load blog_tags %}`
    at the top of it to load your template tags module. Then, use the tag you created
    to display your total posts, as follows. The new lines are highlighted in bold:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/templates/base.html`模板，并在其顶部添加`{% load blog_tags %}`以加载你的模板标签模块。然后，使用你创建的标签显示你的总帖子数，如下所示。新的行以粗体显示：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You will need to restart the server to keep track of the new files added to
    the project. Stop the development server with *Ctrl* + *C* and run it again using
    the following command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要重新启动服务器以跟踪项目中新添加的文件。使用*Ctrl* + *C*停止开发服务器，然后使用以下命令重新运行它：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser. You should see the total
    number of posts in the sidebar of the site, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`http://127.0.0.1:8000/blog/`。你应该在网站的侧边栏中看到帖子的总数，如下所示：
- en: '![](img/B21088_03_12.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_12.png)'
- en: 'Figure 3.12: The total posts published included in the sidebar'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：包含在侧边栏中的总帖子数
- en: 'If you see the following error message, it’s very likely you didn’t restart
    the development server:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你看到以下错误信息，那么很可能你没有重新启动开发服务器：
- en: '![](img/B21088_03_13.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_13.png)'
- en: 'Figure 3.13: The error message when a template tag library is not registered'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：当模板标签库未注册时的错误信息
- en: Template tags allow you to process any data and add it to any template regardless
    of the view executed. You can perform QuerySets or process any data to display
    results in your templates.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模板标签允许你在任何视图中处理任何数据并将其添加到任何模板中。你可以执行查询集或处理任何数据以在模板中显示结果。
- en: Creating an inclusion template tag
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建包含模板标签
- en: We will create another tag to display the latest posts in the sidebar of the
    blog. This time, we will implement an inclusion tag. Using an inclusion tag, you
    can render a template with context variables returned by your template tag.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建另一个标签以在博客侧边栏中显示最新帖子。这次，我们将实现一个包含模板标签。使用包含模板标签，你可以渲染一个模板，该模板使用模板标签返回的上下文变量。
- en: 'Edit the `templatetags/blog_tags.py` file and add the following code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`templatetags/blog_tags.py`文件，并添加以下代码：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding code, we have registered the template tag using the `@register.inclusion_tag`
    decorator. We have specified the template that will be rendered with the returned
    values using `blog/post/latest_posts.html`. The template tag will accept an optional
    `count` parameter that defaults to `5`. This parameter will allow us to specify
    the number of posts to display. We use this variable to limit the results of the
    query `Post.published.order_by('-publish')[:count]`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`@register.inclusion_tag`装饰器注册了模板标签。我们使用`blog/post/latest_posts.html`指定了将使用返回值渲染的模板。模板标签将接受一个可选的`count`参数，默认值为`5`。此参数允许我们指定要显示的帖子数。我们使用此变量来限制查询`Post.published.order_by('-publish')[:count]`的结果。
- en: Note that the function returns a dictionary of variables instead of a simple
    value. Inclusion tags have to return a dictionary of values, which is used as
    the context to render the specified template. The template tag we just created
    allows us to specify the optional number of posts to display as `{% show_latest_posts
    3 %}`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该函数返回一个包含变量的字典而不是一个简单的值。包含标签必须返回一个包含值的字典，该字典用作渲染指定模板的上下文。我们刚刚创建的模板标签允许我们指定要显示的帖子可选数量，格式为`{%
    show_latest_posts 3 %}`。
- en: Now, create a new template file under `blog/post/` and name it `latest_posts.html`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`blog/post/`目录下创建一个新的模板文件，并将其命名为`latest_posts.html`。
- en: 'Edit the new `blog/post/latest_posts.html` template and add the following code
    to it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑新的`blog/post/latest_posts.html`模板，并添加以下代码到其中：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In the preceding code, you have added an unordered list of posts using the
    `latest_posts` variable returned by your template tag. Now, edit the `blog/base.html`
    template and add the new template tag to display the last three posts, as follows.
    The new lines are highlighted in bold:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你使用由你的模板标签返回的`latest_posts`变量添加了一个无序列表。现在，编辑`blog/base.html`模板，并添加新的模板标签以显示最后三篇帖子，如下所示。新的行以粗体显示：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The template tag is called, passing the number of posts to display, and the
    template is rendered in place with the given context.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 调用模板标签时，传递要显示的帖子数，并使用给定上下文在适当位置渲染模板。
- en: 'Next, return to your browser and refresh the page. The sidebar should now look
    like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，返回你的浏览器并刷新页面。侧边栏现在应该看起来像这样：
- en: '![](img/B21088_03_14.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_14.png)'
- en: 'Figure 3.14: The blog sidebar, including the latest published posts'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：博客侧边栏，包括最新发布的帖子
- en: Creating a template tag that returns a QuerySet
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个返回QuerySet的模板标签
- en: Finally, we will create a simple template tag that returns a value. We will
    store the result in a variable that can be reused, rather than outputting it directly.
    We will create a tag to display the most commented posts.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个简单的模板标签，它返回一个值。我们将结果存储在一个可重用的变量中，而不是直接输出。我们将创建一个标签来显示最多评论的帖子。
- en: 'Edit the `templatetags/blog_tags.py` file and add the following import and
    template tag to it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`templatetags/blog_tags.py`文件，并添加以下导入和模板标签：
- en: '[PRE30]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding template tag, you build a QuerySet using the `annotate()` function
    to aggregate the total number of comments for each post. You use the `Count` aggregation
    function to store the number of comments in the computed `total_comments` field
    for each `Post` object. You order the QuerySet by the computed field in descending
    order. You also provide an optional `count` variable to limit the total number
    of objects returned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的模板标签中，你使用`annotate()`函数构建一个QuerySet，以聚合每个帖子的总评论数。你使用`Count`聚合函数将评论数存储在每个`Post`对象的计算字段`total_comments`中。你按计算字段降序排列QuerySet。你还提供了一个可选的`count`变量来限制返回的对象总数。
- en: In addition to `Count`, Django offers the aggregation functions `Avg`, `Max`,
    `Min`, and `Sum`. You can read more about aggregation functions at [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Count`之外，Django还提供了聚合函数`Avg`、`Max`、`Min`和`Sum`。你可以在[https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)了解更多关于聚合函数的信息。
- en: 'Next, edit the `blog/base.html` template and add the following code highlighted
    in bold:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，编辑`blog/base.html`模板，并添加以下加粗显示的代码：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the preceding code, we store the result in a custom variable using the `as`
    argument followed by the variable name. For the template tag, we use `{% get_most_commented_posts
    as most_commented_posts %}` to store the result of the template tag in a new variable
    named `most_commented_posts`. Then, we display the returned posts using an HTML
    unordered list element.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`as`参数和变量名来存储结果，创建一个自定义变量。对于模板标签，我们使用`{% get_most_commented_posts
    as most_commented_posts %}`将模板标签的结果存储在一个名为`most_commented_posts`的新变量中。然后，我们使用HTML无序列表元素显示返回的帖子。
- en: 'Now open your browser and refresh the page to see the final result. It should
    look like the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开你的浏览器并刷新页面，查看最终结果。它应该看起来像以下这样：
- en: '![](img/B21088_03_15.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_15.png)'
- en: 'Figure 3.15: The post list view, including the complete sidebar with the latest
    and most commented posts'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：帖子列表视图，包括包含最新和最多评论帖子的完整侧边栏
- en: You now have a clear idea of how to build custom template tags. You can read
    more about them at [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在对如何构建自定义模板标签有了清晰的认识。你可以在[https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/)了解更多相关信息。
- en: Implementing custom template filters
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现自定义模板过滤器
- en: Django has a variety of built-in template filters that allow you to alter variables
    in templates. These are Python functions that take one or two parameters, the
    value of the variable that the filter is applied to, and an optional argument.
    They return a value that can be displayed or treated by another filter.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一系列内置的模板过滤器，允许你在模板中更改变量。这些是Python函数，它们接受一个或两个参数，即应用过滤器的变量的值，以及一个可选的参数。它们返回一个可以显示或由另一个过滤器处理的值。
- en: A filter is written like `{{ variable``|my_filter` `}}`. Filters with an argument
    are written like `{{ variable``|my_filter:"foo"` `}}`. For example, you can use
    the `capfirst` filter to capitalize the first character of the value, like `{{
    value``|capfirst` `}}`. If `value` is `django`, the output will be `Django`. You
    can apply as many filters as you like to a variable, for example, `{{ variable``|filter1|filter2`
    `}}`, and each filter will be applied to the output generated by the preceding
    filter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器的编写方式为`{{ variable|my_filter }}`。带有参数的过滤器编写方式为`{{ variable|my_filter:"foo"
    }}`。例如，您可以使用`capfirst`过滤器将值的第一个字符转换为大写，如`{{ value|capfirst }}`。如果`value`是`django`，输出将是`Django`。您可以将任意数量的过滤器应用于变量，例如`{{
    variable|filter1|filter2 }}`，每个过滤器都将应用于前一个过滤器生成的输出。
- en: You can find the list of Django’s built-in template filters at [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/#built-in-filter-reference)找到Django内置模板过滤器的列表。
- en: Creating a template filter to support Markdown syntax
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建支持Markdown语法的模板过滤器
- en: We will create a custom filter to enable you to use Markdown syntax in your
    blog posts and then convert the post body to HTML in the templates.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义过滤器，使您能够在博客帖子中使用Markdown语法，然后在模板中将帖子主体转换为HTML。
- en: Markdown is a plain-text formatting syntax that is very simple to use, and it’s
    intended to be converted into HTML. You can write posts using simple Markdown
    syntax and get the content automatically converted into HTML code. Learning Markdown
    syntax is much easier than learning HTML. By using Markdown, you can get other
    non-tech-savvy contributors to easily write posts for your blog. You can learn
    the basics of the Markdown format at [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种非常简单易用的纯文本格式化语法，旨在转换为HTML。您可以使用简单的Markdown语法编写帖子，并自动将其转换为HTML代码。学习Markdown语法比学习HTML容易得多。通过使用Markdown，您可以轻松地让其他非技术贡献者为您撰写博客帖子。您可以在[https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics)上学习Markdown格式的基础知识。
- en: 'First, install the Python `markdown` module via `pip` using the following command
    in the shell prompt:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在shell提示符中使用以下命令通过`pip`安装Python的`markdown`模块：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, edit the `templatetags/blog_tags.py` file and include the following code:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编辑`templatetags/blog_tags.py`文件，并包含以下代码：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We register template filters in the same way as template tags. To prevent a
    name clash between the function name and the `markdown` module, we have named
    the function `markdown_format` and we have named the filter `markdown` for use
    in templates, such as `{{ variable|markdown }}`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以与模板标签相同的方式注册模板过滤器。为了避免函数名与`markdown`模块之间的名称冲突，我们将函数命名为`markdown_format`，并将过滤器命名为`markdown`，以便在模板中使用，例如`{{
    variable|markdown }}`。
- en: Django escapes the HTML code generated by filters; characters of HTML entities
    are replaced with their HTML-encoded characters. For example, `<p>` is converted
    to `&lt;p&gt;` (*less than* symbol, *p* character, *greater than* symbol).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Django会转义由过滤器生成的HTML代码；HTML实体的字符被替换为其HTML编码字符。例如，`<p>`被转换为`&lt;p&gt;`（小于符号，p字符，大于符号）。
- en: We use the `mark_safe` function provided by Django to mark the result as safe
    HTML to be rendered in the template. By default, Django will not trust any HTML
    code and will escape it before placing it in the output. The only exceptions are
    variables that are marked as safe from escaping. This behavior prevents Django
    from outputting potentially dangerous HTML and allows you to create exceptions
    for returning safe HTML.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Django提供的`mark_safe`函数将结果标记为安全的HTML，以便在模板中渲染。默认情况下，Django不会信任任何HTML代码，并在将其放入输出之前将其转义。唯一的例外是标记为安全的变量。这种行为阻止Django输出可能危险的HTML，并允许您为返回安全的HTML创建例外。
- en: In Django, HTML content is escaped by default for security. Use `mark_safe`
    cautiously, only on content you control. Avoid using `mark_safe` on any content
    submitted by non-staff users to prevent security vulnerabilities.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，默认情况下，HTML内容会被转义以提高安全性。请谨慎使用`mark_safe`，仅对您控制的内容使用。避免在由非工作人员用户提交的任何内容上使用`mark_safe`，以防止安全漏洞。
- en: 'Edit the `blog/post/detail.html` template and add the following new code highlighted
    in bold:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog/post/detail.html`模板，并添加以下加粗的新代码：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have replaced the `linebreaks` filter of the `{{ post.body }}` template variable
    with the `markdown` filter. This filter will not only transform line breaks into
    `<p>` tags; it will also transform Markdown formatting into HTML.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将 `{{ post.body }}` 模板变量的 `linebreaks` 过滤器替换为 `markdown` 过滤器。此过滤器不仅将换行符转换为
    `<p>` 标签；它还将 Markdown 格式转换为 HTML。
- en: Storing text in Markdown format in the database, rather than HTML, is a wise
    security strategy. Markdown limits the potential for injecting malicious content.
    This approach ensures that any text formatting is safely converted to HTML only
    at the point of rendering the template.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中以 Markdown 格式存储文本，而不是 HTML，是一种明智的安全策略。Markdown 限制了注入恶意内容的能力。这种方法确保任何文本格式化仅在渲染模板时安全地转换为
    HTML。
- en: 'Edit the `blog/post/list.html` template and add the following new code highlighted
    in bold:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `blog/post/list.html` 模板并添加以下以粗体显示的新代码：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We have added the new `markdown` filter to the `{{ post.body }}` template variable.
    This filter will transform the Markdown content into HTML.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将新的 `markdown` 过滤器添加到 `{{ post.body }}` 模板变量中。此过滤器将 Markdown 内容转换为 HTML。
- en: Therefore, we have replaced the previous `truncatewords` filter with the `truncatewords_html`
    filter. This filter truncates a string after a certain number of words, avoiding
    unclosed HTML tags.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将之前的 `truncatewords` 过滤器替换为 `truncatewords_html` 过滤器。此过滤器在特定数量的单词后截断字符串，避免未关闭的
    HTML 标签。
- en: 'Now open `http://127.0.0.1:8000/admin/blog/post/add/` in your browser and create
    a new post with the following body:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在浏览器中打开 `http://127.0.0.1:8000/admin/blog/post/add/` 并创建一个具有以下正文的新的帖子：
- en: '[PRE36]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The form should look like this:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表格应看起来像这样：
- en: '![](img/B21088_03_16.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_16.png)'
- en: 'Figure 3.16: The post with Markdown content rendered as HTML'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.16：Markdown 内容渲染为 HTML 的帖子
- en: 'Open `http://127.0.0.1:8000/blog/` in your browser and take a look at how the
    new post is rendered. You should see the following output:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://127.0.0.1:8000/blog/` 并查看新帖子是如何渲染的。您应该看到以下输出：
- en: '![](img/B21088_03_17.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_17.png)'
- en: 'Figure 3.17: The post with Markdown content rendered as HTML'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.17：Markdown 内容渲染为 HTML 的帖子
- en: As you can see in *Figure 3.17*, custom template filters are very useful for
    customizing formatting. You can find more information about custom filters at
    [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在 *图 3.17* 中所见，自定义模板过滤器对于自定义格式化非常有用。您可以在 [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/#writing-custom-template-filters)
    找到有关自定义过滤器的更多信息。
- en: Adding a sitemap to the site
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向网站添加站点地图
- en: Django comes with a sitemap framework, which allows you to generate sitemaps
    for your site dynamically. A sitemap is an XML file that tells search engines
    the pages of your website, their relevance, and how frequently they are updated.
    Using a sitemap will make your site more visible in search engine rankings because
    it helps crawlers to index your website’s content.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: Django 内置了站点地图框架，允许您动态地为您的网站生成站点地图。站点地图是一个 XML 文件，它告诉搜索引擎您的网站页面、它们的关联性以及它们更新的频率。使用站点地图将使您的网站在搜索引擎排名中更加可见，因为它有助于爬虫索引您的网站内容。
- en: The Django sitemap framework depends on `django.contrib.sites`, which allows
    you to associate objects to particular websites that are running with your project.
    This comes in handy when you want to run multiple sites using a single Django
    project. To install the sitemap framework, we will need to activate both the `sites`
    and `sitemap` applications in your project. We are going to build a sitemap for
    the blog that includes the links to all published posts.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Django 站点地图框架依赖于 `django.contrib.sites`，这允许您将对象关联到与您的项目一起运行的具体网站。当您想使用单个 Django
    项目运行多个网站时，这非常有用。为了安装站点地图框架，我们需要在您的项目中激活 `sites` 和 `sitemap` 应用程序。我们将为博客构建一个包含所有已发布帖子链接的站点地图。
- en: 'Edit the `settings.py` file of the project and add `django.contrib.sites` and
    `django.contrib.sitemaps` to the `INSTALLED_APPS` setting. Also, define a new
    setting for the site ID, as follows. New code is highlighted in bold:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑项目的 `settings.py` 文件，并将 `django.contrib.sites` 和 `django.contrib.sitemaps`
    添加到 `INSTALLED_APPS` 设置中。同时，定义一个新的站点 ID 设置，如下所示。新代码以粗体显示：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, run the following command from the shell prompt to create the tables of
    the Django site application in the database:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从 shell 提示符运行以下命令以在数据库中创建 Django 站点应用程序的表：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You should see an output that contains the following lines:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到包含以下行的输出：
- en: '[PRE39]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `sites` application is now synced with the database.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`sites` 应用程序现在已与数据库同步。'
- en: 'Next, create a new file inside your `blog` application directory and name it
    `sitemaps.py`. Open the file and add the following code to it:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在您的 `blog` 应用程序目录内创建一个新文件，并将其命名为 `sitemaps.py`。打开文件，并向其中添加以下代码：
- en: '[PRE40]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have defined a custom sitemap by inheriting the `Sitemap` class of the `sitemaps`
    module. The `changefreq` and `priority` attributes indicate the change frequency
    of your post pages and their relevance in your website (the maximum value is `1`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过继承 `sitemaps` 模块的 `Sitemap` 类定义了一个自定义 sitemap。`changefreq` 和 `priority`
    属性表示您的帖子页面的更改频率及其在网站中的相关性（最大值为 `1`）。
- en: The `items()` method returns the QuerySet of objects to include in this sitemap.
    By default, Django calls the `get_absolute_url()` method on each object to retrieve
    its URL. Remember that we implemented this method in *Chapter 2*, *Enhancing Your
    Blog with Advanced Features*, to define the canonical URL for posts. If you want
    to specify the URL for each object, you can add a `location` method to your sitemap
    class.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`items()` 方法返回包含在此 sitemap 中的对象的 QuerySet。默认情况下，Django 会为每个对象调用 `get_absolute_url()`
    方法以检索其 URL。请记住，我们在 *第 2 章*，*通过高级功能增强您的博客* 中实现了此方法，以定义帖子的规范 URL。如果您想为每个对象指定 URL，您可以在您的
    sitemap 类中添加一个 `location` 方法。'
- en: The `lastmod` method receives each object returned by `items()` and returns
    the last time the object was modified.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastmod` 方法接收 `items()` 返回的每个对象，并返回对象最后修改的时间。'
- en: Both the `changefreq` and `priority` attributes can be either methods or attributes.
    You can take a look at the complete sitemap reference in the official Django documentation
    located at [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`changefreq` 和 `priority` 属性可以是方法或属性。您可以在官方 Django 文档中查看完整的 sitemap 参考，文档位于
    [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/)。'
- en: We have created the sitemap. Now we just need to create a URL for it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建 sitemap。现在我们只需要为它创建一个 URL。
- en: 'Edit the main `urls.py` file of the `mysite` project and add the sitemap, as
    follows. New lines are highlighted in bold:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 `mysite` 项目的 `main` `urls.py` 文件，并添加 sitemap，如下所示。新行以粗体显示：
- en: '[PRE41]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code, we have included the required imports and defined a `sitemaps`
    dictionary. Multiple sitemaps can be defined for the site. We have defined a URL
    pattern that matches the `sitemap.xml` pattern and uses the `sitemap` view provided
    by Django. The `sitemaps` dictionary is passed to the `sitemap` view.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们包含了所需的导入并定义了一个 `sitemaps` 字典。可以为网站定义多个 sitemap。我们定义了一个匹配 `sitemap.xml`
    模式的 URL 模式，并使用了 Django 提供的 `sitemap` 视图。`sitemaps` 字典被传递给 `sitemap` 视图。
- en: 'Start the development server from the shell prompt with the following command:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shell 提示符启动开发服务器，使用以下命令：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Open `http://127.0.0.1:8000/sitemap.xml` in your browser. You will see an XML
    output including all of the published posts, like this:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://127.0.0.1:8000/sitemap.xml`。您将看到包括所有已发布帖子的 XML 输出，如下所示：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The URL for each `Post` object is built by calling its `get_absolute_url()`
    method.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用其 `get_absolute_url()` 方法构建每个 `Post` 对象的 URL。
- en: The `lastmod` attribute corresponds to the post `updated` date field, as you
    specified in your sitemap, and the `changefreq` and `priority` attributes are
    also taken from the `PostSitemap` class.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastmod` 属性对应于您在 sitemap 中指定的帖子 `updated` 日期字段，`changefreq` 和 `priority` 属性也来自
    `PostSitemap` 类。'
- en: The domain used to build the URLs is `example.com`. This domain comes from a
    `Site` object stored in the database. This default object was created when you
    synced the site’s framework with your database. You can read more about the `sites`
    framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 用于构建 URL 的域是 `example.com`。此域名来自数据库中存储的 `Site` 对象。当您将网站的框架与数据库同步时，创建了此默认对象。您可以在
    [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/)
    了解更多关于 `sites` 框架的信息。
- en: 'Open `http://127.0.0.1:8000/admin/sites/site/` in your browser. You should
    see something like this:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://127.0.0.1:8000/admin/sites/site/`。您应该看到类似以下的内容：
- en: '![](img/B21088_03_18.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_18.png)'
- en: 'Figure 3.18: The Django administration list view for the Site model of the
    site’s framework'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.18：网站的框架中 Site 模型的 Django 管理列表视图
- en: '*Figure 3.18* contains the list display administration view for the site’s
    framework. Here, you can set the domain or host to be used by the site’s framework
    and the applications that depend on it. To generate URLs that exist in your local
    environment, change the domain name to `localhost:8000`, as shown in *Figure 3.19*,
    and save it:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '*图3.18* 包含了网站框架的列表显示管理视图。在这里，您可以设置网站框架及其依赖的应用程序要使用的域名或主机。要生成本地环境中的URL，将域名更改为`localhost:8000`，如图*图3.19*所示，并保存它：'
- en: '![](img/B21088_03_19.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_19.png)'
- en: 'Figure 3.19: The Django administration edit view for the Site model of the
    site’s framework'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19：网站框架的网站模型Django管理编辑视图
- en: Open `http://127.0.0.1:8000/sitemap.xml` in your browser again. The URLs displayed
    in your sitemap will now use the new hostname and look like `http://localhost:8000/blog/2024/1/22/markdown-post/`.
    Links are now accessible in your local environment. In a production environment,
    you will have to use your website’s domain to generate absolute URLs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 再次在浏览器中打开`http://127.0.0.1:8000/sitemap.xml`。现在在您的网站地图中显示的URL将使用新的主机名，看起来像`http://localhost:8000/blog/2024/1/22/markdown-post/`。链接现在在您的本地环境中可访问。在生产环境中，您将必须使用您网站的域名来生成绝对URL。
- en: Creating feeds for blog posts
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建博客帖子的源
- en: Django has a built-in syndication feed framework that you can use to dynamically
    generate RSS or Atom feeds in a similar manner to creating sitemaps using the
    site’s framework. A web feed is a data format (usually XML) that provides users
    with the most recently updated content. Users can subscribe to the feed using
    a feed aggregator, a software that is used to read feeds and get new content notifications.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个内置的聚合源框架，您可以使用它以创建网站框架类似的方式动态生成RSS或Atom源。一个网络源是一种数据格式（通常是XML），它为用户提供最新更新的内容。用户可以使用源聚合器订阅源，这是一种用于读取源和获取新内容通知的软件。
- en: 'Create a new file in your `blog` application directory and name it `feeds.py`.
    Add the following lines to it:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`blog`应用程序目录中创建一个新文件，并将其命名为`feeds.py`。向其中添加以下行：
- en: '[PRE44]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding code, we have defined a feed by subclassing the `Feed` class
    of the syndication framework. The `title`, `link`, and `description` attributes
    correspond to the `<title>`, `<link>`, and `<description>` RSS elements, respectively.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过继承聚合框架的`Feed`类来定义了一个源。`title`、`link`和`description`属性分别对应于RSS元素中的`<title>`、`<link>`和`<description>`。
- en: We use `reverse_lazy()` to generate the URL for the `link` attribute. The `reverse()`
    method allows you to build URLs by their name and pass optional parameters. We
    used `reverse()` in *Chapter 2*, *Enhancing Your Blog with Advanced Features*.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`reverse_lazy()`生成`link`属性的URL。`reverse()`方法允许您通过名称构建URL并传递可选参数。我们在*第2章*，*通过高级功能增强您的博客*中使用了`reverse()`。
- en: The `reverse_lazy()` utility function is a lazily evaluated version of `reverse()`.
    It allows you to use a URL reversal before the project’s URL configuration is
    loaded.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`reverse_lazy()`实用函数是`reverse()`的延迟评估版本。它允许在项目的URL配置加载之前使用URL反转。'
- en: The `items()` method retrieves the objects to be included in the feed. We retrieve
    the last five published posts to include them in the feed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`items()`方法检索要包含在源中的对象。我们检索最后五篇发布的帖子以包含在源中。'
- en: The `item_title()`, `item_description()`, and `item_pubdate()` methods will
    receive each object returned by `items()` and return the title, description, and
    publication date for each item.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`item_title()`、`item_description()`和`item_pubdate()`方法将接收`items()`返回的每个对象，并为每个项目返回标题、描述和发布日期。'
- en: In the `item_description()` method, we use the `markdown()` function to convert
    Markdown content to HTML and the `truncatewords_html()` template filter function
    to cut the description of posts after 30 words, avoiding unclosed HTML tags.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在`item_description()`方法中，我们使用`markdown()`函数将Markdown内容转换为HTML，并使用`truncatewords_html()`模板过滤器函数在30个单词后截断帖子的描述，以避免未关闭的HTML标签。
- en: 'Now, edit the `blog/urls.py` file, import the `LatestPostsFeed` class, and
    instantiate the feed in a new URL pattern, as follows. New lines are highlighted
    in bold:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，编辑`blog/urls.py`文件，导入`LatestPostsFeed`类，并在新的URL模式中实例化源，如下所示。新行以粗体显示：
- en: '[PRE45]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Navigate to `http://127.0.0.1:8000/blog/feed/` in your browser. You should
    now see the RSS feed, including the last five blog posts:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中导航到`http://127.0.0.1:8000/blog/feed/`。现在您应该能看到RSS源，包括最后五篇博客帖子：
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If you use Chrome, you will see the XML code. If you use Safari, it will ask
    you to install an RSS feed reader.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用Chrome，您将看到XML代码。如果您使用Safari，它将要求您安装RSS源阅读器。
- en: Let’s install an RSS desktop client to view the RSS feed with a user-friendly
    interface. We will use Fluent Reader, which is a multi-platform RSS reader.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装一个RSS桌面客户端，以便使用用户友好的界面查看RSS源。我们将使用Fluent Reader，这是一个多平台RSS阅读器。
- en: Download Fluent Reader for Linux, macOS, or Windows from [https://github.com/yang991178/fluent-reader/releases](https://github.com/yang991178/fluent-reader/releases).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 从[https://github.com/yang991178/fluent-reader/releases](https://github.com/yang991178/fluent-reader/releases)下载适用于Linux、macOS或Windows的Fluent
    Reader。
- en: 'Install Fluent Reader and open it. You will see the following screen:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Fluent Reader并打开它。您将看到以下屏幕：
- en: '![A picture containing chart  Description automatically generated](img/B21088_03_20.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![包含图表的图片，自动生成描述](img/B21088_03_20.png)'
- en: 'Figure 3.20: Fluent Reader with no RSS feed sources'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20：没有RSS源信息的Fluent Reader
- en: 'Click on the settings icon in the top-right corner of the window. You will
    see a screen to add RSS feed sources like the following one:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 点击窗口右上角的设置图标。您将看到一个屏幕，可以添加RSS源，如下所示：
- en: '![Text  Description automatically generated](img/B21088_03_21.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![自动生成描述](img/B21088_03_21.png)'
- en: 'Figure 3.21: Adding an RSS feed in Fluent Reader'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21：在Fluent Reader中添加RSS源
- en: Enter `http://127.0.0.1:8000/blog/feed/` in the **Add source** field and click
    on the **Add** button.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在**添加源**字段中输入`http://127.0.0.1:8000/blog/feed/`并点击**添加**按钮。
- en: 'You will see a new entry with the RSS feed of the blog in the table below the
    form, like this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在表单下方看到一个新的条目，其中包含博客的RSS源，如下所示：
- en: '![Graphical user interface, text, application, email  Description automatically
    generated](img/B21088_03_22.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序，电子邮件，自动生成描述](img/B21088_03_22.png)'
- en: 'Figure 3.22: RSS feed sources in Fluent Reader'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.22：Fluent Reader中的RSS源
- en: 'Now, go back to the main screen of Fluent Reader. You should be able to see
    the posts included in the blog RSS feed, as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到Fluent Reader的主屏幕。您应该能够看到包含在博客RSS源中的文章，如下所示：
- en: '![Graphical user interface, text  Description automatically generated](img/B21088_03_23.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，自动生成描述](img/B21088_03_23.png)'
- en: 'Figure 3.23: RSS feed of the blog in Fluent Reader'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.23：Fluent Reader中的博客RSS源
- en: 'Click on a post to see a description:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 点击一篇文章以查看描述：
- en: '![](img/B21088_03_24.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_24.png)'
- en: 'Figure 3.24: The post description in Fluent Reader'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.24：Fluent Reader中的文章描述
- en: 'Click on the third icon in the top-right corner of the window to load the full
    content of the post page:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 点击窗口右上角第三个图标以加载文章页面的全部内容：
- en: '![](img/B21088_03_25.png)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_25.png)'
- en: 'Figure 3.25: The full content of a post in Fluent Reader'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.25：Fluent Reader中文章的完整内容
- en: The final step is to add an RSS feed subscription link to the blog’s sidebar.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将RSS订阅链接添加到博客的侧边栏。
- en: 'Open the `blog/base.html` template and add the following code highlighted in
    bold:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`blog/base.html`模板并添加以下加粗的代码：
- en: '[PRE47]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now open `http://127.0.0.1:8000/blog/` in your browser and take a look at the
    sidebar. The new link will take users to the blog’s feed:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的浏览器中打开`http://127.0.0.1:8000/blog/`并查看侧边栏。新的链接将用户带到博客的源：
- en: '![](img/B21088_03_26.png)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_26.png)'
- en: 'Figure 3.26: The RSS feed subscription link added to the sidebar'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.26：侧边栏中添加的RSS订阅链接
- en: You can read more about the Django syndication feed framework at [https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/)了解更多关于Django聚合订阅框架的信息。
- en: Adding full-text search to the blog
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向博客添加全文搜索
- en: 'Next, we will add search capabilities to the blog. Searching for data in the
    database with user input is a common task for web applications. The Django ORM
    allows you to perform simple matching operations using, for example, the `contains`
    filter (or its case-insensitive version, `icontains`). You can use the following
    query to find posts that contain the word `framework` in their body:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将向博客添加搜索功能。在数据库中使用用户输入搜索数据是Web应用的常见任务。Django ORM允许您使用例如`contains`过滤器（或其不区分大小写的版本`icontains`）执行简单的匹配操作。您可以使用以下查询来查找正文包含单词`framework`的文章：
- en: '[PRE48]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: However, if you want to perform complex search lookups, retrieving results by
    similarity, or by weighting terms based on how frequently they appear in the text
    or how important different fields are (for example, the relevancy of the term
    appearing in the title versus in the body), you will need to use a full-text search
    engine. When you consider large blocks of text, building queries with operations
    on a string of characters is not enough. A full-text search examines the actual
    words against stored content as it tries to match search criteria.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想执行复杂的搜索查询，通过相似度检索结果，或者根据它们在文本中出现的频率或不同字段的重要性（例如，标题中出现的术语与正文中出现的术语的相关性）来加权术语，您将需要使用全文搜索引擎。当考虑大量文本块时，仅使用字符串上的操作构建查询是不够的。全文搜索在尝试匹配搜索条件时会检查实际单词与存储内容之间的对比。
- en: Django provides a powerful search functionality built on top of PostgreSQL database
    full-text search features. The `django.contrib.postgres` module provides functionalities
    offered by PostgreSQL that are not shared by the other databases that Django supports.
    You can learn about PostgreSQL’s full-text search support at [https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个基于PostgreSQL数据库全文搜索功能的强大搜索功能。`django.contrib.postgres`模块提供了PostgreSQL提供的功能，这些功能是Django支持的其他数据库所不具备的。您可以在[https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html)了解PostgreSQL的全文搜索支持。
- en: Although Django is a database-agnostic web framework, it provides a module that
    supports part of the rich feature set offered by PostgreSQL, which is not offered
    by other databases that Django supports.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django是一个数据库无关的Web框架，但它提供了一个模块，支持PostgreSQL提供的部分丰富功能集，而Django支持的其他数据库则没有提供。
- en: We are currently using an SQLite database for the `mysite` project. SQLite support
    for full-text search is limited and Django doesn’t support it out of the box.
    However, PostgreSQL is much better suited for full-text search and we can use
    the `django.contrib.postgres` module to use PostgreSQL’s full-text search capabilities.
    We will migrate our data from SQLite to PostgreSQL to benefit from its full-text
    search features.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前为`mysite`项目使用SQLite数据库。SQLite对全文搜索的支持有限，Django默认也不支持。然而，PostgreSQL非常适合全文搜索，我们可以使用`django.contrib.postgres`模块来利用PostgreSQL的全文搜索功能。我们将把数据从SQLite迁移到PostgreSQL，以利用其全文搜索特性。
- en: SQLite is sufficient for development purposes. However, for a production environment,
    you will need a more powerful database, such as PostgreSQL, MariaDB, MySQL, or
    Oracle.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite对于开发目的来说是足够的。然而，对于生产环境，您将需要一个更强大的数据库，例如PostgreSQL、MariaDB、MySQL或Oracle。
- en: PostgreSQL provides a Docker image that makes it very easy to deploy a PostgreSQL
    server with a standard configuration.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL提供了一个Docker镜像，使得部署具有标准配置的PostgreSQL服务器变得非常容易。
- en: Installing Docker
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Docker
- en: Docker is a popular open-source containerization platform. It enables developers
    to package applications into containers, simplifying the process of building,
    running, managing, and distributing applications.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个流行的开源容器化平台。它使开发者能够将应用程序打包到容器中，简化了构建、运行、管理和分发应用程序的过程。
- en: First, download and install Docker for your OS. You will find instructions for
    downloading and installing Docker on Linux, macOS, and Windows at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).
    The installation includes both Docker Desktop and Docker command-line interface
    tools.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，下载并安装适用于您操作系统的Docker。您可以在[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)找到关于在Linux、macOS和Windows上下载和安装Docker的说明。安装包括Docker桌面和Docker命令行界面工具。
- en: Installing PostgreSQL
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装PostgreSQL
- en: 'After installing Docker on your Linux, macOS, or Windows machine, you can easily
    pull the PostgreSQL Docker image. Run the following command from the shell:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Linux、macOS或Windows机器上安装Docker后，您可以轻松地拉取PostgreSQL Docker镜像。从shell中运行以下命令：
- en: '[PRE49]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will download the PostgreSQL Docker image to your local machine. You can
    find information about the official PostgreSQL Docker image at [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres).
    You can find other PostgreSQL packages and installers at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载PostgreSQL Docker镜像到您的本地机器。您可以在[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)找到有关官方PostgreSQL
    Docker镜像的信息。您可以在[https://www.postgresql.org/download/](https://www.postgresql.org/download/)找到其他PostgreSQL软件包和安装程序。
- en: 'Execute the following command in the shell to start the PostgreSQL Docker container:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 shell 中执行以下命令以启动 PostgreSQL Docker 容器：
- en: '[PRE50]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Replace `xxxxx` with the desired password for your database user.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `xxxxx` 替换为你数据库用户的所需密码。
- en: 'This command starts a PostgreSQL instance. The `--name` option is used to assign
    a name to the container, in this case, `blog_db`. The `-e` option is to define
    environment variables for the instance. We set the following environment variables:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令启动一个 PostgreSQL 实例。`--name` 选项用于为容器分配一个名称，在本例中为 `blog_db`。`-e` 选项用于定义实例的环境变量。我们设置了以下环境变量：
- en: '`POSTGRES_DB`: Name of the PostgreSQL database. If not defined, the value of
    `POSTGRES_USER` is used for the database name.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRES_DB`：PostgreSQL 数据库的名称。如果未定义，则使用 `POSTGRES_USER` 的值作为数据库名称。'
- en: '`POSTGRES_USER`: Used in conjunction with `POSTGRES_PASSWORD` to define a username
    and password. The user is created with superuser power.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRES_USER`：与 `POSTGRES_PASSWORD` 一起使用来定义用户名和密码。用户以超级用户权限创建。'
- en: '`POSTGRES_PASSWORD`: Sets the superuser password for PostgreSQL.'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRES_PASSWORD`：设置 PostgreSQL 的超级用户密码。'
- en: The `-p` option is used to publish the `5432` port, on which PostgreSQL runs,
    to the same host interface port. This allows external applications to access the
    database. The `-d` option is for *detached mode*, which runs the Docker container
    in the background.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`-p` 选项用于将 PostgreSQL 运行的 `5432` 端口发布到同一主机接口端口。这允许外部应用程序访问数据库。`-d` 选项用于 *分离模式*，它将在后台运行
    Docker 容器。'
- en: 'Open the Docker Desktop application. You should see the new container running,
    as in *Figure 3.27*:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Docker Desktop 应用程序。你应该看到新容器正在运行，如图 *3.27* 所示：
- en: '![](img/B21088_03_27.png)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_27.png)'
- en: 'Figure 3.27: PostgreSQL instance running in Docker Desktop'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.27：在 Docker Desktop 中运行的 PostgreSQL 实例
- en: You will see the newly created `blog_db` container, with the status **Running**.
    Under **Actions**, you can stop or restart the service. You can also delete the
    container. Note that deleting the container will also eliminate the database and
    all the data it contains. You will learn how to persist PostgreSQL data in the
    local filesystem using Docker in *Chapter 17*, *Going Live*.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到新创建的 `blog_db` 容器，状态为 **运行中**。在 **操作** 下，你可以停止或重启服务。你也可以删除容器。请注意，删除容器也将删除数据库及其包含的所有数据。你将在
    *第 17 章*，*上线* 中学习如何使用 Docker 在本地文件系统中持久化 PostgreSQL 数据。
- en: 'You also need to install the `psycopg` PostgreSQL adapter for Python. Run the
    following command in the shell prompt to install it:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要安装 Python 的 `psycopg` PostgreSQL 适配器。在 shell 提示符中运行以下命令来安装它：
- en: '[PRE51]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, we will migrate the existing data in the SQLite database to the new PostgreSQL
    instance.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将将 SQLite 数据库中的现有数据迁移到新的 PostgreSQL 实例。
- en: Dumping the existing data
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导出现有数据
- en: Before switching the database in the Django project, we need to dump the existing
    data from the SQLite database. We will export the data, switch the project’s database
    to PostgreSQL, and import the data into the new database.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在切换 Django 项目的数据库之前，我们需要从 SQLite 数据库中导出现有数据。我们将导出数据，将项目的数据库切换到 PostgreSQL，并将数据导入到新数据库中。
- en: Django comes with a simple way to load and dump data from the database into
    files that are called **fixtures**. Django supports fixtures in JSON, XML, or
    YAML format. We are going to create a fixture with all data contained in the database.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了一种简单的方法来将数据库中的数据加载和导出到称为 **fixtures** 的文件中。Django 支持使用 JSON、XML 或
    YAML 格式的 fixtures。我们将创建一个包含数据库中所有数据的 fixtures。
- en: The `dumpdata` command dumps data from the database into the standard output,
    serialized in JSON format by default. The resulting data structure includes information
    about the model and its fields for Django to be able to load it into the database.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '`dumpdata` 命令将数据从数据库导出到标准输出，默认情况下以 JSON 格式序列化。结果数据结构包括有关模型及其字段的信息，以便 Django
    能够将其加载到数据库中。'
- en: You can limit the output to the models of an application by providing the application
    names to the command, or specifying single models for outputting data using the
    `app.Model` format. You can also specify the format using the `--format` flag.
    By default, `dumpdata` outputs the serialized data to the standard output. However,
    you can indicate an output file using the `--output` flag. The `--indent` flag
    allows you to specify indentation. For more information on `dumpdata` parameters,
    run `python manage.py dumpdata --help`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供应用程序名称给命令，或者指定使用 `app.Model` 格式的单个模型来输出数据来限制输出到应用程序的模型。你也可以使用 `--format`
    标志来指定格式。默认情况下，`dumpdata` 将序列化数据输出到标准输出。然而，你可以使用 `--output` 标志来指定输出文件。`--indent`
    标志允许你指定缩进。有关 `dumpdata` 参数的更多信息，请运行 `python manage.py dumpdata --help`。
- en: 'Execute the following command from the shell prompt:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shell 提示符执行以下命令：
- en: '[PRE52]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'All existing data has been exported in JSON format to a new file named `mysite_data.json`.
    You can view the file contents to see the JSON structure that includes all the
    different data objects for the different models of your installed applications.
    If you get an encoding error when running the command, include the `-Xutf8` flag
    as follows to activate Python UTF-8 mode:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现有数据已以 JSON 格式导出到一个名为 `mysite_data.json` 的新文件中。你可以查看文件内容以查看包括所有不同模型的数据对象的
    JSON 结构。如果你在运行命令时遇到编码错误，请包含 `-Xutf8` 标志如下以激活 Python UTF-8 模式：
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We will now switch the database in the Django project and then we will import
    the data into the new database.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将切换 Django 项目的数据库，然后我们将数据导入到新的数据库中。
- en: Switching the database in the project
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换项目中的数据库
- en: Now you will add the PostgreSQL database configuration to your project settings.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将把 PostgreSQL 数据库配置添加到你的项目设置中。
- en: 'Edit the `settings.py` file of your project and modify the `DATABASES` setting
    to make it look as follows. New code is highlighted in bold:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑你的项目中的 `settings.py` 文件并修改 `DATABASES` 设置以使其看起来如下。新的代码被加粗：
- en: '[PRE54]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The database engine is now `postgresql`. The database credentials are now loaded
    from environment variables using `python-decouple`.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库引擎现在是 `postgresql`。数据库凭据现在通过 `python-decouple` 从环境变量中加载。
- en: 'Let’s add values to the environment variables. Edit the `.env` file of your
    project and add the following lines highlighted in bold:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向环境变量添加值。编辑你的项目中的 `.env` 文件并添加以下加粗的行：
- en: '[PRE55]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Replace `xxxxxx` with the password you used when starting the PostgreSQL container.
    The new database is empty.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `xxxxxx` 替换为你启动 PostgreSQL 容器时使用的密码。新的数据库是空的。
- en: 'Run the following command to apply all database migrations to the new PostgreSQL
    database:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令将所有数据库迁移应用到新的 PostgreSQL 数据库：
- en: '[PRE56]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'You will see an output, including all the migrations that have been applied,
    like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个输出，包括所有已应用的迁移，如下所示：
- en: '[PRE57]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The PostgreSQL database is now in sync with your data models and you can run
    your Django project pointing to the new database. Let’s get the database to the
    same state by loading the data we previously exported from SQLite.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 数据库现在与你的数据模型同步，你可以运行指向新数据库的 Django 项目。让我们通过加载之前从 SQLite 导出的数据来使数据库达到相同的状态。
- en: Loading the data into the new database
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据加载到新的数据库中
- en: We are going to load the data fixtures we generated previously into our new
    PostgreSQL database.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把之前生成的数据固定文件加载到我们的新 PostgreSQL 数据库中。
- en: 'Run the following command to load the previously exported data into the PostgreSQL
    database:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将之前导出的数据加载到 PostgreSQL 数据库中：
- en: '[PRE58]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'You will see the following output:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE59]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The number of objects might differ, depending on the users, posts, comments,
    and other objects that have been created in the database.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的数量可能会根据数据库中创建的用户、帖子、评论和其他对象而有所不同。
- en: 'Start the development server from the shell prompt with the following command:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 从 shell 提示符使用以下命令启动开发服务器：
- en: '[PRE60]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Open `http://127.0.0.1:8000/admin/blog/post/` in your browser to verify that
    all posts have been loaded into the new database. You should see all the posts,
    as follows:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开 `http://127.0.0.1:8000/admin/blog/post/` 以验证所有帖子是否已加载到新的数据库中。你应该看到所有帖子，如下所示：
- en: '![](img/B21088_03_28.png)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B21088_03_28.png)'
- en: 'Figure 3.28: The list of posts on the administration site'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.28：管理网站上帖子列表
- en: Simple search lookups
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单搜索查询
- en: Having enabled PostgreSQL in our project, we can now build a powerful search
    engine by leveraging PostgreSQL’s full-text search capabilities. We will begin
    with basic search lookups and progressively incorporate more sophisticated features,
    such as stemming, ranking, or weighting queries, to build a comprehensive full-text
    search engine.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中启用了PostgreSQL后，我们可以通过利用PostgreSQL的全文搜索功能来构建一个强大的搜索引擎。我们将从基本的搜索查找开始，并逐步引入更复杂的功能，例如词干提取、排名或查询加权，以构建一个全面的全文搜索引擎。
- en: 'Edit the `settings.py` file of your project and add `django.contrib.postgres`
    to the `INSTALLED_APPS` setting, as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您项目的`settings.py`文件，并将`django.contrib.postgres`添加到`INSTALLED_APPS`设置中，如下所示：
- en: '[PRE61]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Open the Django shell by running the following command in the system shell
    prompt:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统shell提示符中运行以下命令以打开Django shell：
- en: '[PRE62]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now you can search against a single field using the `search` QuerySet lookup.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用`search`查询集查找对单个字段进行搜索。
- en: 'Run the following code in the Python shell:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python shell中运行以下代码：
- en: '[PRE63]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This query uses PostgreSQL to create a search vector for the `title` field and
    a search query from the term `django`. Results are obtained by matching the query
    with the vector.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询使用PostgreSQL为`title`字段创建一个搜索向量，并从术语`django`创建一个搜索查询。结果是通过将查询与向量匹配来获得的。
- en: Searching against multiple fields
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对多个字段进行搜索
- en: You might want to search against multiple fields. In this case, you will need
    to define a `SearchVector` object. Let’s build a vector that allows you to search
    against the `title` and `body` fields of the `Post` model.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想要对多个字段进行搜索。在这种情况下，您需要定义一个`SearchVector`对象。让我们构建一个允许您对`Post`模型的`title`和`body`字段进行搜索的向量。
- en: 'Run the following code in the Python shell:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python shell中运行以下代码：
- en: '[PRE64]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Using `annotate` and defining `SearchVector` with both fields, you provide a
    functionality to match the query against both the `title` and `body` of the posts.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`annotate`和定义包含两个字段的`SearchVector`，您提供了一个功能，可以将查询与帖子的`title`和`body`进行匹配。
- en: Full-text search is an intensive process. If you are searching for more than
    a few hundred rows, you should define a functional index that matches the search
    vector you are using. Django provides a `SearchVectorField` field for your models.
    You can read more about this at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 全文搜索是一个密集的过程。如果您要搜索超过几百行，您应该定义一个与您使用的搜索向量匹配的功能索引。Django为您的模型提供了一个`SearchVectorField`字段。您可以在[https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/#performance)了解更多信息。
- en: Building a search view
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建搜索视图
- en: 'Now, you will create a custom view to allow your users to search posts. First,
    you will need a search form. Edit the `forms.py` file of the `blog` application
    and add the following form:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将创建一个自定义视图，允许用户搜索帖子。首先，您需要一个搜索表单。编辑`blog`应用的`forms.py`文件，并添加以下表单：
- en: '[PRE65]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'You will use the `query` field to let users introduce search terms. Edit the
    `views.py` file of the `blog` application and add the following code to it:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用`query`字段让用户输入搜索词。编辑`blog`应用的`views.py`文件，并向其中添加以下代码：
- en: '[PRE66]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In the preceding view, first, we instantiate the `SearchForm` form. To check
    whether the form is submitted, we look for the `query` parameter in the `request.GET`
    dictionary. We send the form using the `GET` method instead of `POST` so that
    the resulting URL includes the `query` parameter and is easy to share. When the
    form is submitted, we instantiate it with the submitted `GET` data and verify
    that the form data is valid. If the form is valid, we search for published posts
    with a custom `SearchVector` instance built with the `title` and `body` fields.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的视图中，首先，我们实例化`SearchForm`表单。为了检查表单是否已提交，我们在`request.GET`字典中查找`query`参数。我们使用`GET`方法而不是`POST`方法发送表单，以便生成的URL包含`query`参数，便于分享。当表单提交时，我们使用提交的`GET`数据实例化它，并验证表单数据是否有效。如果表单有效，我们使用由`title`和`body`字段构建的`SearchVector`实例来搜索已发布的帖子。
- en: The search view is now ready. We need to create a template to display the form
    and the results when the user performs a search.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索视图现在已准备就绪。我们需要创建一个模板来显示当用户进行搜索时的表单和结果。
- en: 'Create a new file inside the `templates/blog/post/` directory, name it `search.html`,
    and add the following code to it:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在`templates/blog/post/`目录内创建一个新文件，命名为`search.html`，并向其中添加以下代码：
- en: '[PRE67]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As in the search view, we distinguish whether the form has been submitted by
    the presence of the `query` parameter. Before the query is submitted, we display
    the form and a submit button. When the search form is submitted, we display the
    query performed, the total number of results, and the list of posts that match
    the search query.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 与搜索视图一样，我们通过`query`参数的存在来区分表单是否已提交。在查询提交之前，我们显示表单和提交按钮。当搜索表单提交时，我们显示执行查询、结果总数以及与搜索查询匹配的帖子列表。
- en: 'Finally, edit the `urls.py` file of the `blog` application and add the following
    URL pattern highlighted in bold:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，编辑`blog`应用的`urls.py`文件并添加以下加粗的URL模式：
- en: '[PRE68]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Next, open `http://127.0.0.1:8000/blog/search/` in your browser. You should
    see the following search form:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在浏览器中打开`http://127.0.0.1:8000/blog/search/`。您应该看到以下搜索表单：
- en: '![](img/B21088_03_29.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_29.png)'
- en: 'Figure 3.29: The form with the query field to search for posts'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.29：带有查询字段的表单，用于搜索帖子
- en: 'Enter a query and click on the **SEARCH** button. You will see the results
    of the search query, as follows:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 输入一个查询并点击**搜索**按钮。您将看到搜索查询的结果，如下所示：
- en: '![](img/B21088_03_30.png)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_30.png)'
- en: 'Figure 3.30: Search results for the term “jazz”'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.30：对“jazz”术语的搜索结果
- en: Congratulations! You have created a basic search engine for your blog.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您已经为您的博客创建了一个基本的搜索引擎。
- en: Stemming and ranking results
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 词干提取和排名结果
- en: Stemming is the process of reducing words to their word stem, base, or root
    form. Stemming is used by search engines to reduce indexed words to their stem,
    and to be able to match inflected or derived words. For example, the words “music,”
    “musical,” and “musicality” can be considered similar words by a search engine.
    The stemming process normalizes each search token into a lexeme, a unit of lexical
    meaning that underlies a set of words that are related through inflection. The
    words “music,” “musical,” and “musicality” would convert to “music” when creating
    a search query.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 词干提取是将单词还原为其词干、词根或基本形式的过程。搜索引擎使用词干提取来将索引词还原为词干，以便能够匹配屈折或派生词。例如，“music”、“musical”和“musicality”这些词可以被搜索引擎视为相似词。词干提取过程将每个搜索标记规范化为一个词素，这是一个词汇意义的单位，是构成一系列通过屈折相关联的词的基础。当创建搜索查询时，“music”、“musical”和“musicality”将转换为“music”。
- en: Django provides a `SearchQuery` class to translate terms into a search query
    object. By default, the terms are passed through stemming algorithms, which helps
    you to obtain better matches.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个`SearchQuery`类，用于将术语转换为搜索查询对象。默认情况下，术语会通过词干提取算法进行传递，这有助于您获得更好的匹配。
- en: The PostgreSQL search engine also removes stop words, such as “a,” “the,” “on,”
    and “of.” Stop words are a set of commonly used words in a language. They are
    removed when creating a search query because they appear too frequently to be
    relevant to searches. You can find the list of stop words used by PostgreSQL for
    the English language at [https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL搜索引擎还会移除停用词，例如“a”、“the”、“on”和“of”。停用词是语言中常用词的集合。在创建搜索查询时，由于它们出现得太频繁，因此被认为与搜索不相关，所以会被移除。您可以在[https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/english.stop)找到PostgreSQL用于英语语言的停用词列表。
- en: We also want to order results by relevancy. PostgreSQL provides a ranking function
    that orders results based on how often the query terms appear and how close together
    they are.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望按相关性对结果进行排序。PostgreSQL提供了一个排名函数，它根据查询术语出现的频率以及它们之间的接近程度来排序结果。
- en: 'Edit the `views.py` file of the `blog` application and add the following imports:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件并添加以下导入：
- en: '[PRE69]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, edit the `post_search` view, as follows. New code is highlighted in bold:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式编辑`post_search`视图。新代码加粗显示：
- en: '[PRE70]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In the preceding code, we create a `SearchQuery` object, filter results by it,
    and use `SearchRank` to order the results by relevancy.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`SearchQuery`对象，通过它过滤结果，并使用`SearchRank`按相关性排序结果。
- en: 'You can open `http://127.0.0.1:8000/blog/search/` in your browser and test
    different searches to test stemming and ranking. The following is an example of
    ranking by the number of occurrences of the word `django` in the title and body
    of the posts:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在浏览器中打开`http://127.0.0.1:8000/blog/search/`并测试不同的搜索以测试词干提取和排名。以下是一个按帖子标题和正文中单词`django`出现次数进行排名的示例：
- en: '![](img/B21088_03_31.png)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_31.png)'
- en: 'Figure 3.31: Search results for the term “django”'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.31：搜索术语“django”的结果
- en: Stemming and removing stop words in different languages
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同语言中执行词干提取和移除停用词
- en: 'We can set up `SearchVector` and `SearchQuery` to execute stemming and remove
    stop words in any language. We can pass a `config` attribute to `SearchVector`
    and `SearchQuery` to use a different search configuration. This allows us to use
    different language parsers and dictionaries. The following example executes stemming
    and removes stop words in Spanish:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置`SearchVector`和`SearchQuery`以在任意语言中执行词干提取并移除停用词。我们可以向`SearchVector`和`SearchQuery`传递一个`config`属性来使用不同的搜索配置。这允许我们使用不同的语言解析器和词典。以下示例在西班牙语中执行词干提取并移除停用词：
- en: '[PRE71]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: You can find the Spanish stop words dictionary used by PostgreSQL at [https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop](https://github.com/postgres/postgres/blob/master/src/backend/snowball/stopwords/spanish.stop)找到PostgreSQL使用的西班牙语停用词词典。
- en: Weighting queries
  id: totrans-432
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询加权
- en: We can boost specific vectors so that more weight is attributed to them when
    ordering results by relevancy. For example, we can use this to give more relevance
    to posts that are matched by title rather than by content.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以增强特定的向量，以便在按相关性排序结果时赋予它们更高的权重。例如，我们可以使用此方法为标题匹配而非内容匹配的帖子赋予更高的相关性。
- en: 'Edit the `views.py` file of the `blog` application and modify the `post_search`
    view as follows. New code is highlighted in bold:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`blog`应用的`views.py`文件，并按如下方式修改`post_search`视图。新代码以粗体显示：
- en: '[PRE72]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In the preceding code, we apply different weights to the search vectors built
    using the `title` and `body` fields. The default weights are `D`, `C`, `B`, and
    `A`, and they refer to the numbers `0.1`, `0.2`, `0.4`, and `1.0`, respectively.
    We apply a weight of `1.0` to the `title` search vector (`A`) and a weight of
    `0.4` to the `body` vector (`B`). Title matches will prevail over body content
    matches. We filter the results to display only the ones with a rank higher than
    `0.3`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们为使用`title`和`body`字段构建的搜索向量应用了不同的权重。默认权重是`D`、`C`、`B`和`A`，分别对应数字`0.1`、`0.2`、`0.4`和`1.0`。我们将`title`搜索向量（`A`）的权重设置为`1.0`，将`body`向量（`B`）的权重设置为`0.4`。标题匹配将优于正文内容匹配。我们过滤结果，只显示排名高于`0.3`的结果。
- en: Searching with trigram similarity
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用三元组相似度搜索
- en: Another search approach is trigram similarity. A trigram is a group of three
    consecutive characters. You can measure the similarity of two strings by counting
    the number of trigrams that they share. This approach turns out to be very effective
    for measuring the similarity of words in many languages.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种搜索方法是三元组相似度。三元组是三个连续字符的组合。你可以通过计算两个字符串共享的三元组数量来衡量它们的相似度。这种方法在衡量许多语言的单词相似度方面非常有效。
- en: To use trigrams in PostgreSQL, you will need to install the `pg_trgm` database
    extension first. Django provides database migration operations to create PostgreSQL
    extensions. Let’s add a migration that creates the extension in the database.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 要在PostgreSQL中使用三元组，你首先需要安装`pg_trgm`数据库扩展。Django提供了创建PostgreSQL扩展的数据库迁移操作。让我们添加一个迁移，在数据库中创建该扩展。
- en: 'First, execute the following command in the shell prompt to create an empty
    migration:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在shell提示符中执行以下命令以创建一个空迁移：
- en: '[PRE73]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This will create an empty migration for the `blog` application. You will see
    the following output:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个空的迁移文件用于`blog`应用。你将看到以下输出：
- en: '[PRE74]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Edit the file `blog/migrations/0005_trigram_ext.py` and add the following lines
    highlighted in bold:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑文件`blog/migrations/0005_trigram_ext.py`，并添加以下以粗体显示的行：
- en: '[PRE75]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: You have added the `TrigramExtension` operation to the database migration. This
    operation executes the SQL statement `CREATE EXTENSION pg_trgm` to create the
    extension in PostgreSQL.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将`TrigramExtension`操作添加到数据库迁移中。此操作执行SQL语句`CREATE EXTENSION pg_trgm`以在PostgreSQL中创建扩展。
- en: You can find more information about database migration operations at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/)找到更多关于数据库迁移操作的信息。
- en: 'Now execute the migration with the following command:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下命令来执行迁移：
- en: '[PRE76]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'You will see the following output:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE77]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The `pg_trgm` extension has been created in the database. Let’s modify `post_search`
    to search for trigrams.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中已创建 `pg_trgm` 扩展。让我们修改 `post_search` 以搜索三字母组合。
- en: 'Edit the `views.py` file of your `blog` application and add the following import:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑您的 `blog` 应用程序的 `views.py` 文件并添加以下导入：
- en: '[PRE78]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Then, modify the `post_search` view as follows. New code is highlighted in
    bold:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式修改 `post_search` 视图。新代码以粗体突出显示：
- en: '[PRE79]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Open `http://127.0.0.1:8000/blog/search/` in your browser and test different
    searches for trigrams. The following example displays a hypothetical typo in the
    `django` term, showing search results for `yango`:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的浏览器中打开 `http://127.0.0.1:8000/blog/search/` 并测试不同的三字母组合搜索。以下示例显示了在 `django`
    术语中的假设错误，显示了 `yango` 的搜索结果：
- en: '![](img/B21088_03_32.png)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B21088_03_32.png)'
- en: 'Figure 3.32: Search results for the term “yango”'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.32：术语“yango”的搜索结果
- en: We have added a powerful search engine to the blog application.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将一个强大的搜索引擎添加到了博客应用程序中。
- en: You can find more information about full-text search with Django and PostgreSQL
    at [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/)
    找到有关Django和PostgreSQL全文搜索的更多信息。
- en: Summary
  id: totrans-462
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you implemented a tagging system by integrating a third-party
    application into your project. You generated post recommendations using complex
    QuerySets. You also learned how to create custom Django template tags and filters
    to provide templates with custom functionalities. You also created a sitemap for
    search engines to crawl your site and an RSS feed for users to subscribe to your
    blog. You then built a search engine for your blog using the full-text search
    engine of PostgreSQL.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您通过将第三方应用程序集成到项目中实现了标签系统。您使用复杂的查询集生成了帖子推荐。您还学习了如何创建自定义Django模板标签和过滤器，以向模板提供自定义功能。您还创建了一个搜索引擎网站地图以供搜索引擎抓取您的网站，以及一个RSS订阅源供用户订阅您的博客。然后，您使用PostgreSQL的全文搜索引擎为您的博客构建了一个搜索引擎。
- en: In the next chapter, you will learn how to build a social website using the
    Django authentication framework and how to implement user account functionalities
    and custom user profiles.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将学习如何使用Django认证框架构建社交网站，以及如何实现用户账户功能和自定义用户资料。
- en: Expanding your project using AI
  id: totrans-465
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AI扩展您的项目
- en: Having completed the blog application, you likely have numerous ideas for adding
    new functionalities to your blog. This section aims to provide some insights into
    exploring new functionalities to incorporate into your project with the assistance
    of ChatGPT. ChatGPT is a sophisticated AI **Large Language Model** (**LLM**) created
    by OpenAI that generates human-like responses based on the prompts it receives.
    In this section, you will be presented with a task to extend your project, accompanied
    by a sample prompt for ChatGPT to assist you.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 完成博客应用程序后，您可能有很多想法来为您的博客添加新的功能。本节旨在通过ChatGPT的帮助，为您提供将新功能纳入项目的见解。ChatGPT是由OpenAI创建的复杂AI
    **大型语言模型**（**LLM**），它根据收到的提示生成类似人类的响应。在本节中，您将面临一个扩展项目的任务，并附有ChatGPT的示例提示以协助您。
- en: Engage with ChatGPT at [https://chat.openai.com/](https://chat.openai.com/).
    You will find similar guidance after completing each Django project within this
    book, in *Chapter 7*, *Tracking User Actions*, *Chapter 11*, *Adding Internationalization
    to Your Shop*, and *Chapter 17*, *Going Live*.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [https://chat.openai.com/](https://chat.openai.com/) 与ChatGPT互动。在完成本书中的每个Django项目后，您将在
    *第7章*，*跟踪用户行为*，*第11章*，*为您的商店添加国际化*，以及 *第17章*，*上线* 中找到类似的指导。
- en: Let’s further enhance your blog with the help of ChatGPT. Your blog currently
    allows filtering posts by tags. Adding these tags to our sitemap could significantly
    improve the SEO optimization of the blog. Use the prompt provided at [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
    for adding tag pages to the sitemap. This challenge is an excellent opportunity
    to refine your project and deepen your understanding of Django, while learning
    to interact with ChatGPT.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助ChatGPT进一步丰富你的博客。你的博客目前允许通过标签过滤帖子。将这些标签添加到我们的站点地图中可以显著提高博客的SEO优化。使用提供的提示[https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)将标签页面添加到站点地图。这个挑战是完善你的项目并深化你对Django理解的好机会，同时学习如何与ChatGPT交互。
- en: ChatGPT is ready to assist with code issues. Simply share your code along with
    any errors you’re facing, and ChatGPT can help you identify and resolve the issues.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ChatGPT准备协助解决代码问题。只需分享你的代码以及你遇到的所有错误，ChatGPT可以帮助你识别和解决这些问题。
- en: Additional resources
  id: totrans-470
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他资源
- en: 'The following resources provide additional information related to the topics
    covered in this chapter:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 以下资源提供了与本章涵盖主题相关的额外信息：
- en: 'Source code for this chapter: [https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03)'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章源代码：[https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03](https://github.com/PacktPublishing/Django-5-by-example/tree/main/Chapter03)
- en: '`django-taggit`: [https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit)'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-taggit`：[https://github.com/jazzband/django-taggit](https://github.com/jazzband/django-taggit)'
- en: '`django-taggit` ORM managers: [https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html)'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django-taggit` ORM管理器：[https://django-taggit.readthedocs.io/en/latest/api.html](https://django-taggit.readthedocs.io/en/latest/api.html)'
- en: 'Many-to-many relationships: [https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多对多关系：[https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/](https://docs.djangoproject.com/en/5.0/topics/db/examples/many_to_many/)
- en: 'Django aggregation functions: [https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django聚合函数：[https://docs.djangoproject.com/en/5.0/topics/db/aggregation/](https://docs.djangoproject.com/en/5.0/topics/db/aggregation/)
- en: 'Built-in template tags and filters: [https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/)'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置模板标签和过滤器：[https://docs.djangoproject.com/en/5.0/ref/templates/builtins/](https://docs.djangoproject.com/en/5.0/ref/templates/builtins/)
- en: 'Writing custom template tags: [https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/)'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义模板标签：[https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/](https://docs.djangoproject.com/en/5.0/howto/custom-template-tags/)
- en: 'Markdown format reference: [https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics
    )'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Markdown格式参考：[https://daringfireball.net/projects/markdown/basics](https://daringfireball.net/projects/markdown/basics
    )
- en: 'Django sitemap framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/)'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django站点地图框架：[https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/](https://docs.djangoproject.com/en/5.0/ref/contrib/sitemaps/)
- en: 'Django sites framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/)'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django站点框架：[https://docs.djangoproject.com/en/5.0/ref/contrib/sites/](https://docs.djangoproject.com/en/5.0/ref/contrib/sites/)
- en: 'Django syndication feed framework: [https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/)'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django聚合框架：[https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/](https://docs.djangoproject.com/en/5.0/ref/contrib/syndication/)
- en: 'Docker download and installation instructions: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker下载和安装说明：[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)
- en: 'PostgreSQL Docker image: [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL Docker镜像：[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)
- en: 'PostgreSQL downloads: [https://www.postgresql.org/download/](https://www.postgresql.org/download/)'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL下载：[https://www.postgresql.org/download/](https://www.postgresql.org/download/)
- en: 'PostgreSQL full-text search capabilities: [https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html)'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PostgreSQL全文搜索功能：[https://www.postgresql.org/docs/16/textsearch.html](https://www.postgresql.org/docs/16/textsearch.html)
- en: 'Database migration operations: [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库迁移操作：[https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/operations/).
- en: Django support for PostgreSQL full-text search – [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/)
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Django对PostgreSQL全文搜索的支持 – [https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/](https://docs.djangoproject.com/en/5.0/ref/contrib/postgres/search/)
- en: ChatGPT interface – [https://chat.openai.com/](https://chat.openai.com/)
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ChatGPT界面 – [https://chat.openai.com/](https://chat.openai.com/)
- en: Sample ChatGPT prompt to add tag pages to the sitemap – [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加标签页面到网站地图的ChatGPT示例提示 – [https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md](https://github.com/PacktPublishing/Django-5-by-example/blob/main/Chapter03/prompts/task.md)
