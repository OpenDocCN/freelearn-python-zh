- en: Chapter 21. Advanced Database Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第21章。高级数据库管理
- en: This chapter provides additional information on each of the supported relational
    databases in Django, as well as notes and tips and tricks for connecting to legacy
    databases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了有关Django中支持的每个关系数据库的额外信息，以及连接到传统数据库的注意事项和技巧。
- en: General notes
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般注意事项
- en: Django attempts to support as many features as possible on all database back-ends.
    However, not all database back-ends are alike, and the Django developers had to
    make design decisions on which features to support and which assumptions could
    be made safely.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Django尝试在所有数据库后端上支持尽可能多的功能。然而，并非所有的数据库后端都是一样的，Django开发人员必须对支持哪些功能和可以安全假设的内容做出设计决策。
- en: This file describes some of the features that might be relevant to Django usage.
    Of course, it is not intended as a replacement for server-specific documentation
    or reference manuals.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本文件描述了一些可能与Django使用相关的特性。当然，它并不打算替代特定服务器的文档或参考手册。
- en: Persistent connections
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久连接
- en: Persistent connections avoid the overhead of re-establishing a connection to
    the database in each request. They're controlled by the `CONN_MAX_AGE` parameter
    which defines the maximum lifetime of a connection. It can be set independently
    for each database. The default value is 0, preserving the historical behavior
    of closing the database connection at the end of each request. To enable persistent
    connections, set `CONN_MAX_AGE` to a positive number of seconds. For unlimited
    persistent connections, set it to `None`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 持久连接避免了在每个请求中重新建立与数据库的连接的开销。它们由`CONN_MAX_AGE`参数控制，该参数定义了连接的最大生存期。它可以独立设置每个数据库。默认值为0，保留了在每个请求结束时关闭数据库连接的历史行为。要启用持久连接，请将`CONN_MAX_AGE`设置为正数秒数。要获得无限的持久连接，请将其设置为`None`。
- en: Connection management
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接管理
- en: Django opens a connection to the database when it first makes a database query.
    It keeps this connection open and reuses it in subsequent requests. Django closes
    the connection once it exceeds the maximum age defined by `CONN_MAX_AGE` or when
    it isn't usable any longer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Django在首次进行数据库查询时会打开与数据库的连接。它会保持这个连接打开，并在后续请求中重用它。一旦连接超过`CONN_MAX_AGE`定义的最大寿命，或者不再可用，Django会关闭连接。
- en: In detail, Django automatically opens a connection to the database whenever
    it needs one and doesn't have one already-either because this is the first connection,
    or because the previous connection was closed.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，Django在需要连接数据库时会自动打开一个连接，如果没有已经存在的连接，要么是因为这是第一个连接，要么是因为上一个连接已经关闭。
- en: At the beginning of each request, Django closes the connection if it has reached
    its maximum age. If your database terminates idle connections after some time,
    you should set `CONN_MAX_AGE` to a lower value, so that Django doesn't attempt
    to use a connection that has been terminated by the database server. (This problem
    may only affect very low traffic sites.)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求开始时，如果连接已经达到最大寿命，Django会关闭连接。如果您的数据库在一段时间后终止空闲连接，您应该将`CONN_MAX_AGE`设置为较低的值，这样Django就不会尝试使用已被数据库服务器终止的连接。（这个问题可能只影响非常低流量的站点。）
- en: At the end of each request, Django closes the connection if it has reached its
    maximum age or if it is in an unrecoverable error state. If any database errors
    have occurred while processing the requests, Django checks whether the connection
    still works, and closes it if it doesn't. Thus, database errors affect at most
    one request; if the connection becomes unusable, the next request gets a fresh
    connection.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个请求结束时，如果连接已经达到最大寿命或处于不可恢复的错误状态，Django会关闭连接。如果在处理请求时发生了任何数据库错误，Django会检查连接是否仍然有效，如果无效则关闭连接。因此，数据库错误最多影响一个请求；如果连接变得无法使用，下一个请求将获得一个新的连接。
- en: Caveats
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Since each thread maintains its own connection, your database must support at
    least as many simultaneous connections as you have worker threads.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个线程都维护自己的连接，因此您的数据库必须支持至少与您的工作线程一样多的同时连接。
- en: Sometimes a database won't be accessed by the majority of your views, for example,
    because it's the database of an external system, or thanks to caching. In such
    cases, you should set `CONN_MAX_AGE` to a low value or even `0`, because it doesn't
    make sense to maintain a connection that's unlikely to be reused. This will help
    keep the number of simultaneous connections to this database small.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，数据库不会被大多数视图访问，例如，因为它是外部系统的数据库，或者由于缓存。在这种情况下，您应该将`CONN_MAX_AGE`设置为较低的值，甚至为`0`，因为维护一个不太可能被重用的连接是没有意义的。这将有助于保持对该数据库的同时连接数较小。
- en: The development server creates a new thread for each request it handles, negating
    the effect of persistent connections. Don't enable them during development.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发服务器为每个处理的请求创建一个新的线程，从而抵消了持久连接的效果。在开发过程中不要启用它们。
- en: When Django establishes a connection to the database, it sets up appropriate
    parameters, depending on the backend being used. If you enable persistent connections,
    this setup is no longer repeated every request. If you modify parameters such
    as the connection's isolation level or time zone, you should either restore Django's
    defaults at the end of each request, force an appropriate value at the beginning
    of each request, or disable persistent connections.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django建立与数据库的连接时，它会根据所使用的后端设置适当的参数。如果启用了持久连接，这个设置就不会在每个请求中重复。如果您修改了连接的隔离级别或时区等参数，您应该在每个请求结束时恢复Django的默认设置，或者在每个请求开始时强制设置适当的值，或者禁用持久连接。
- en: Encoding
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编码
- en: Django assumes that all databases use UTF-8 encoding. Using other encodings
    may result in unexpected behavior such as value too long errors from your database
    for data that is valid in Django. See the following database specific notes for
    information on how to set up your database correctly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Django假设所有数据库都使用UTF-8编码。使用其他编码可能会导致意外行为，例如数据库对Django中有效的数据产生值过长的错误。有关如何正确设置数据库的信息，请参阅以下特定数据库的注意事项。
- en: postgreSQL notes
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: postgreSQL注意事项
- en: Django supports PostgreSQL 9.0 and higher. It requires the use of Psycopg2 2.0.9
    or higher.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Django支持PostgreSQL 9.0及更高版本。它需要使用Psycopg2 2.0.9或更高版本。
- en: Optimizing postgreSQL's configuration
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化postgreSQL的配置
- en: 'Django needs the following parameters for its database connections:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Django需要其数据库连接的以下参数：
- en: '`client_encoding`: `''UTF8''`,'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client_encoding`: `''UTF8''`,'
- en: '`default_transaction_isolation`: `''read committed''` by default, or the value
    set in the connection options (see here),'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_transaction_isolation`: 默认为`''read committed''`，或者连接选项中设置的值（见此处），'
- en: '`timezone`: `''UTC''` when `USE_TZ` is `True`, value of `TIME_ZONE` otherwise.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timezone`: 当`USE_TZ`为`True`时为`''UTC''`，否则为`TIME_ZONE`的值。'
- en: If these parameters already have the correct values, Django won't set them for
    every new connection, which improves performance slightly. You can configure them
    directly in `postgresql.conf` or more conveniently per database user with `ALTER
    ROLE`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些参数已经具有正确的值，Django不会为每个新连接设置它们，这会稍微提高性能。您可以直接在`postgresql.conf`中配置它们，或者更方便地通过`ALTER
    ROLE`为每个数据库用户配置它们。
- en: Django will work just fine without this optimization, but each new connection
    will do some additional queries to set these parameters.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Django在没有进行此优化的情况下也可以正常工作，但每个新连接都会执行一些额外的查询来设置这些参数。
- en: Isolation level
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离级别
- en: 'Like PostgreSQL itself, Django defaults to the `READ COMMITTED` isolation level.
    If you need a higher isolation level such as `REPEATABLE READ` or `SERIALIZABLE`,
    set it in the `OPTIONS` part of your database configuration in `DATABASES`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与PostgreSQL本身一样，Django默认使用`READ COMMITTED`隔离级别。如果需要更高的隔离级别，如`REPEATABLE READ`或`SERIALIZABLE`，请在`DATABASES`中的数据库配置的`OPTIONS`部分中设置它：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Under higher isolation levels, your application should be prepared to handle
    exceptions raised on serialization failures. This option is designed for advanced
    uses.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高的隔禅级别下，您的应用程序应该准备好处理由于序列化失败而引发的异常。此选项设计用于高级用途。
- en: Indexes for varchar and text columns
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: varchar和text列的索引
- en: When specifying `db_index=True` on your model fields, Django typically outputs
    a single `CREATE INDEX` statement. However, if the database type for the field
    is either `varchar` or `text` (for example, used by `CharField`, `FileField`,
    and `TextField`), then Django will create an additional index that uses an appropriate
    PostgreSQL operator class for the column. The extra index is necessary to correctly
    perform lookups that use the `LIKE` operator in their SQL, as is done with the
    `contains` and `startswith` lookup types.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型字段上指定`db_index=True`时，Django通常会输出一个`CREATE INDEX`语句。但是，如果字段的数据库类型为`varchar`或`text`（例如，由`CharField`，`FileField`和`TextField`使用），那么Django将创建一个使用适当的PostgreSQL操作符类的额外索引。额外的索引是必要的，以正确执行使用`LIKE`操作符的查找，这在它们的SQL中使用`contains`和`startswith`查找类型时会发生。
- en: MySQL notes
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL注意事项
- en: Version support
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本支持
- en: Django supports MySQL 5.5 and higher.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Django支持MySQL 5.5及更高版本。
- en: Django's `inspectdb` feature uses the `information_schema` database, which contains
    detailed data on all database schemas.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Django的`inspectdb`功能使用包含所有数据库模式详细数据的`information_schema`数据库。
- en: Django expects the database to support Unicode (UTF-8 encoding) and delegates
    to it the task of enforcing transactions and referential integrity. It is important
    to be aware of the fact that the two latter ones aren't actually enforced by MySQL
    when using the MyISAM storage engine, see the next section.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Django期望数据库支持Unicode（UTF-8编码）并委托给它执行事务和引用完整性的任务。重要的是要意识到，当使用MyISAM存储引擎时，MySQL实际上并不执行这两个任务，详见下一节。
- en: Storage engines
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储引擎
- en: MySQL has several storage engines. You can change the default storage engine
    in the server configuration.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL有几种存储引擎。您可以在服务器配置中更改默认存储引擎。
- en: Until MySQL 5.5.4, the default engine was MyISAM. The main drawbacks of MyISAM
    are that it doesn't support transactions or enforce foreign-key constraints. On
    the plus side, it was the only engine that supported full-text indexing and searching
    until MySQL 5.6.4.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 直到MySQL 5.5.4，默认引擎是MyISAM。MyISAM的主要缺点是它不支持事务或强制外键约束。另一方面，直到MySQL 5.6.4，它是唯一支持全文索引和搜索的引擎。
- en: Since MySQL 5.5.5, the default storage engine is InnoDB. This engine is fully
    transactional and supports foreign key references. It's probably the best choice
    at this point. However, note that the InnoDB autoincrement counter is lost on
    a MySQL restart because it does not remember the `AUTO_INCREMENT` value, instead
    recreating it as `max(id)+1`. This may result in an inadvertent reuse of `AutoField`
    values.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 自MySQL 5.5.5以来，默认存储引擎是InnoDB。该引擎完全支持事务，并支持外键引用。这可能是目前最好的选择。但是，请注意，InnoDB自增计数器在MySQL重新启动时会丢失，因为它不记住`AUTO_INCREMENT`值，而是将其重新创建为`max(id)+1`。这可能导致`AutoField`值的意外重用。
- en: 'If you upgrade an existing project to MySQL 5.5.5 and subsequently add some
    tables, ensure that your tables are using the same storage engine (that is MyISAM
    vs. InnoDB). Specifically, if tables that have a `ForeignKey` between them use
    different storage engines, you may see an error like the following when running
    `migrate`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将现有项目升级到MySQL 5.5.5，然后添加一些表，请确保您的表使用相同的存储引擎（即MyISAM vs. InnoDB）。特别是，如果在它们之间具有`ForeignKey`的表使用不同的存储引擎，那么在运行`migrate`时可能会看到以下错误：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: MySQL DB API drivers
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MySQL DB API驱动程序
- en: 'The Python Database API is described in PEP 249\. MySQL has three prominent
    drivers that implement this API:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python数据库API在PEP 249中有描述。MySQL有三个实现此API的知名驱动程序：
- en: MySQLdb ([https://pypi.python.org/pypi/MySQL-python/1.2.4](https://pypi.python.org/pypi/MySQL-python/1.2.4))
    is a native driver that has been developed and supported for over a decade by
    Andy Dustman.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQLdb（[https://pypi.python.org/pypi/MySQL-python/1.2.4](https://pypi.python.org/pypi/MySQL-python/1.2.4)）是由Andy
    Dustman开发和支持了十多年的本地驱动程序。
- en: mySQLclient ([https://pypi.python.org/pypi/mysqlclient](https://pypi.python.org/pypi/mysqlclient))
    is a fork of `MySQLdb` which notably supports Python 3 and can be used as a drop-in
    replacement for MySQLdb. At the time of this writing, this is the recommended
    choice for using MySQL with Django.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: mySQLclient ([https://pypi.python.org/pypi/mysqlclient](https://pypi.python.org/pypi/mysqlclient))是`MySQLdb`的一个分支，特别支持Python
    3，并且可以作为MySQLdb的替代品。在撰写本文时，这是使用Django与MySQL的推荐选择。
- en: MySQL Connector/Python ([http://dev.mysql.com/downloads/connector/python](http://dev.mysql.com/downloads/connector/python))
    is a pure Python driver from Oracle that does not require the MySQL client library
    or any Python modules outside the standard library.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL Connector/Python ([http://dev.mysql.com/downloads/connector/python](http://dev.mysql.com/downloads/connector/python))是来自Oracle的纯Python驱动程序，不需要MySQL客户端库或标准库之外的任何Python模块。
- en: All these drivers are thread-safe and provide connection pooling. `MySQLdb`
    is the only one not supporting Python 3 currently.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些驱动程序都是线程安全的，并提供连接池。`MySQLdb`是目前唯一不支持Python 3的驱动程序。
- en: In addition to a DB API driver, Django needs an adapter to access the database
    drivers from its ORM. Django provides an adapter for MySQLdb/mysqlclient while
    MySQL Connector/Python includes itsown.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了DB API驱动程序，Django还需要一个适配器来访问其ORM中的数据库驱动程序。Django为MySQLdb/mysqlclient提供了一个适配器，而MySQL
    Connector/Python则包含了自己的适配器。
- en: mySQLdb
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mySQLdb
- en: Django requires MySQLdb version 1.2.1p2 or later.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Django需要MySQLdb版本1.2.1p2或更高版本。
- en: 'If you see `ImportError: cannot import name ImmutableSet` when trying to use
    Django, your MySQLdb installation may contain an outdated `sets.py` file that
    conflicts with the built-in module of the same name from Python 2.4 and later.
    To fix this, verify that you have installed MySQLdb version 1.2.1p2 or newer,
    then delete the `sets.py` file in the MySQLdb directory that was left by an earlier
    version.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '如果在尝试使用Django时看到`ImportError: cannot import name ImmutableSet`，则您的MySQLdb安装可能包含一个过时的`sets.py`文件，与Python
    2.4及更高版本中同名的内置模块发生冲突。要解决此问题，请验证您是否安装了MySQLdb版本1.2.1p2或更新版本，然后删除MySQLdb目录中由早期版本留下的`sets.py`文件。'
- en: There are known issues with the way MySQLdb converts date strings into datetime
    objects. Specifically, date strings with value `0000-00-00` are valid for MySQL
    but will be converted into `None` by MySQLdb.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MySQLdb将日期字符串转换为datetime对象时存在已知问题。具体来说，值为`0000-00-00`的日期字符串对于MySQL是有效的，但在MySQLdb中会被转换为`None`。
- en: This means you should be careful while using loaddata/dumpdata with rows that
    may have `0000-00-00` values, as they will be converted to `None`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在使用可能具有`0000-00-00`值的行的loaddata/dumpdata时，您应该小心，因为它们将被转换为`None`。
- en: At the time of writing, the latest release of MySQLdb (1.2.4) doesn't support
    Python 3\. In order to use MySQLdb under Python 3, you'll have to install `mysqlclient`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，最新版本的MySQLdb（1.2.4）不支持Python 3。要在Python 3下使用MySQLdb，您需要安装`mysqlclient`。
- en: mySQLclient
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mySQLclient
- en: Django requires mysqlclient 1.3.3 or later. Note that Python 3.2 is not supported.
    Except for the Python 3.3+ support, mysqlclient should mostly behave the same
    as MySQLdb.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Django需要mysqlclient 1.3.3或更高版本。请注意，不支持Python 3.2。除了Python 3.3+支持外，mysqlclient应该与MySQLdb大致相同。
- en: mySQL connector/python
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mySQL connector/python
- en: MySQL Connector/Python is available from the download page. The Django adapter
    is available in versions 1.1.X and later. It may not support the most recent releases
    of Django.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL Connector/Python可从下载页面获取。Django适配器可在1.1.X及更高版本中获取。它可能不支持最新版本的Django。
- en: Timezone definitions
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 时区定义
- en: If you plan on using Django's timezone support, use `mysql_tzinfo_to_sql` to
    load time zone tables into the MySQL database. This needs to be done just once
    for your MySQL server, not per database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用Django的时区支持，请使用`mysql_tzinfo_to_sql`将时区表加载到MySQL数据库中。这只需要针对您的MySQL服务器执行一次，而不是每个数据库。
- en: Creating your database
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的数据库
- en: 'You can create your database using the command-line tools and this SQL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用命令行工具和以下SQL创建您的数据库：
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This ensures all tables and columns will use UTF-8 by default.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以确保所有表和列默认使用UTF-8。
- en: Collation settings
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 校对设置
- en: The collation setting for a column controls the order in which data is sorted
    as well as what strings compare as equal. It can be set on a database-wide level
    and also per-table and per-column. This is documented thoroughly in the MySQL
    documentation. In all cases, you set the collation by directly manipulating the
    database tables; Django doesn't provide a way to set this on the model definition.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列的校对设置控制数据排序的顺序以及哪些字符串比较相等。它可以在数据库范围内设置，也可以在每个表和每个列上设置。这在MySQL文档中有详细说明。在所有情况下，您都可以通过直接操作数据库表来设置校对；Django不提供在模型定义中设置这一点的方法。
- en: By default, with a UTF-8 database, MySQL will use the `utf8_general_ci` collation.
    This results in all string equality comparisons being done in a *case-insensitive*
    manner. That is, "`Fred`" and "`freD`" are considered equal at the database level.
    If you have a unique constraint on a field, it would be illegal to try to insert
    both "`aa`" and "`AA`" into the same column, since they compare as equal (and,
    hence, non-unique) with the default collation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对于UTF-8数据库，MySQL将使用`utf8_general_ci`校对。这导致所有字符串相等比较以*不区分大小写*的方式进行。也就是说，"`Fred`"和"`freD`"在数据库级别被视为相等。如果在字段上有唯一约束，尝试将"`aa`"和"`AA`"插入同一列将是非法的，因为它们比较为相等（因此不唯一）。
- en: In many cases, this default will not be a problem. However, if you really want
    case-sensitive comparisons on a particular column or table, you would change the
    column or table to use the `utf8_bin` collation. The main thing to be aware of
    in this case is that if you are using MySQLdb 1.2.2, the database backend in Django
    will then return bytestrings (instead of Unicode strings) for any character fields
    it receives from the database. This is a strong variation from Django's normal
    practice of *always* returning Unicode strings.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，这个默认值不会有问题。但是，如果您真的想在特定列或表上进行区分大小写的比较，您将更改列或表以使用“utf8_bin”排序规则。在这种情况下要注意的主要事情是，如果您使用的是MySQLdb
    1.2.2，则Django中的数据库后端将为从数据库接收到的任何字符字段返回字节串（而不是Unicode字符串）。这与Django *始终*返回Unicode字符串的正常做法有很大的不同。
- en: It is up to you, the developer, to handle the fact that you will receive bytestrings
    if you configure your table(s) to use `utf8_bin` collation. Django itself should
    mostly work smoothly with such columns (except for the `contrib.sessions` `Session`
    and `contrib.admin` `LogEntry` tables described here), but your code must be prepared
    to call `django.utils.encoding.smart_text()` at times if it really wants to work
    with consistent data-Django will not do this for you (the database backend layer
    and the model population layer are separated internally so the database layer
    doesn't know it needs to make this conversion in this one particular case).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由您作为开发人员来处理这样一个事实，即如果您配置表使用“utf8_bin”排序规则，您将收到字节串。Django本身应该大部分可以顺利地处理这样的列（除了这里描述的“contrib.sessions”“Session”和“contrib.admin”“LogEntry”表），但是您的代码必须准备在必要时调用“django.utils.encoding.smart_text（）”，如果它真的想要处理一致的数据-Django不会为您做这个（数据库后端层和模型填充层在内部是分开的，因此数据库层不知道它需要在这一个特定情况下进行这种转换）。
- en: If you're using MySQLdb 1.2.1p2, Django's standard `CharField` class will return
    Unicode strings even with `utf8_bin` collation. However, `TextField` fields will
    be returned as an `array.array` instance (from Python's standard `array` module).
    There isn't a lot Django can do about that, since, again, the information needed
    to make the necessary conversions isn't available when the data is read in from
    the database. This problem was fixed in MySQLdb 1.2.2, so if you want to use `TextField`
    with `utf8_bin` collation, upgrading to version 1.2.2 and then dealing with the
    byte strings (which shouldn't be too difficult) as described bfore is the recommended
    solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是MySQLdb 1.2.1p2，Django的标准“CharField”类将即使使用“utf8_bin”排序规则也返回Unicode字符串。但是，“TextField”字段将作为“array.array”实例（来自Python的标准“array”模块）返回。Django对此无能为力，因为再次，当数据从数据库中读取时，所需的信息不可用。这个问题在MySQLdb
    1.2.2中得到了解决，因此，如果您想要在“utf8_bin”排序规则下使用“TextField”，则升级到1.2.2版本，然后按照之前描述的处理字节串（这不应该太困难）是推荐的解决方案。
- en: Should you decide to use `utf8_bin` collation for some of your tables with MySQLdb
    1.2.1p2 or 1.2.2, you should still use `utf8_general_ci` (the default) collation
    for the `django.contrib.sessions.models.Session` table (usually called `django_session`)
    and the `django.contrib.admin.models.LogEntry` table (usually called `django_admin_log`).
    Please note that according to MySQL Unicode Character Sets, comparisons for the
    `utf8_general_ci` collation are faster, but slightly less correct, than comparisons
    for `utf8_unicode_ci`. If this is acceptable for your application, you should
    use `utf8_general_ci` because it is faster. If this is not acceptable (for example,
    if you require German dictionary order), use `utf8_unicode_ci` because it is more
    accurate.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您决定在MySQLdb 1.2.1p2或1.2.2中使用“utf8_bin”排序规则来处理一些表，您仍应该为“django.contrib.sessions.models.Session”表（通常称为“django_session”）和“django.contrib.admin.models.LogEntry”表（通常称为“django_admin_log”）使用“utf8_general_ci”（默认值）排序规则。请注意，根据MySQL
    Unicode字符集，“utf8_general_ci”排序规则的比较速度更快，但比“utf8_unicode_ci”排序规则稍微不正确。如果这对您的应用程序是可以接受的，您应该使用“utf8_general_ci”，因为它更快。如果这是不可接受的（例如，如果您需要德语字典顺序），请使用“utf8_unicode_ci”，因为它更准确。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Model formsets validate unique fields in a case-sensitive manner. Thus when
    using a case-insensitive collation, a formset with unique field values that differ
    only by case will pass validation, but upon calling `save()`, an `IntegrityError`
    will be raised.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 模型表单集以区分大小写的方式验证唯一字段。因此，在使用不区分大小写的排序规则时，具有仅大小写不同的唯一字段值的表单集将通过验证，但在调用“save（）”时，将引发“IntegrityError”。
- en: Connecting to the database
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Connection settings are used in this order:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 连接设置按以下顺序使用：
- en: '`OPTIONS`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “OPTIONS”
- en: '`NAME`, `USER`, `PASSWORD`, `HOST`, `PORT`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “NAME”，“USER”，“PASSWORD”，“HOST”，“PORT”
- en: MySQL option files
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL选项文件
- en: 'In other words, if you set the name of the database in `OPTIONS`, this will
    take precedence over `NAME`, which would override anything in a MySQL option file.
    Here''s a sample configuration which uses a MySQL option file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果在“OPTIONS”中设置了数据库的名称，这将优先于“NAME”，这将覆盖MySQL选项文件中的任何内容。以下是一个使用MySQL选项文件的示例配置：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Several other MySQLdb connection options may be useful, such as `ssl`, `init_command`,
    and `sql_mode`. Consult the MySQLdb documentation for more details.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些MySQLdb连接选项可能会有用，例如“ssl”，“init_command”和“sql_mode”。请参阅MySQLdb文档以获取更多详细信息。
- en: Creating your tables
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建您的表
- en: When Django generates the schema, it doesn't specify a storage engine, so tables
    will be created with whatever default storage engine your database server is configured
    for.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django生成模式时，它不指定存储引擎，因此表将使用数据库服务器配置的默认存储引擎创建。
- en: The easiest solution is to set your database server's default storage engine
    to the desired engine.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的解决方案是将数据库服务器的默认存储引擎设置为所需的引擎。
- en: If you're using a hosting service and can't change your server's default storage
    engine, you have a couple of options.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用托管服务并且无法更改服务器的默认存储引擎，则有几种选择。
- en: 'After the tables are created, execute an `ALTER TABLE` statement to convert
    a table to a new storage engine (such as InnoDB):'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表后，执行“ALTER TABLE”语句将表转换为新的存储引擎（例如InnoDB）：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This can be tedious if you have a lot of tables.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有很多表，这可能会很麻烦。
- en: 'Another option is to use the `init_command` option for MySQLdb prior to creating
    your tables:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个选项是在创建表之前使用MySQLdb的`init_command`选项：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This sets the default storage engine upon connecting to the database. After
    your tables have been created, you should remove this option as it adds a query
    that is only needed during table creation to each database connection.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在连接到数据库时设置默认存储引擎。创建表后，应删除此选项，因为它会向每个数据库连接添加一个仅在表创建期间需要的查询。
- en: Table names
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表名
- en: There are known issues in even the latest versions of MySQL that can cause the
    case of a table name to be altered when certain SQL statements are executed under
    certain conditions. It is recommended that you use lowercase table names, if possible,
    to avoid any problems that might arise from this behavior. Django uses lowercase
    table names when it auto-generates table names from models, so this is mainly
    a consideration if you are overriding the table name via the `db_table` parameter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在最新版本的MySQL中，也存在已知问题，可能会在特定条件下执行某些SQL语句时更改表名的情况。建议您尽可能使用小写表名，以避免可能由此行为引起的任何问题。Django在自动生成模型的表名时使用小写表名，因此，如果您通过`db_table`参数覆盖表名，则主要考虑这一点。
- en: Savepoints
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存点
- en: Both the Django ORM and MySQL (when using the InnoDB storage engine) support
    database savepoints.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Django ORM和MySQL（使用InnoDB存储引擎时）都支持数据库保存点。
- en: If you use the MyISAM storage engine, please be aware of the fact that you will
    receive database-generated errors if you try to use the savepoint-related methods
    of the transactions API. The reason for this is that detecting the storage engine
    of a MySQL database/table is an expensive operation so it was decided it isn't
    worth to dynamically convert these methods in no-op's based in the results of
    such detection.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用MyISAM存储引擎，请注意，如果尝试使用事务API的保存点相关方法，您将收到数据库生成的错误。原因是检测MySQL数据库/表的存储引擎是一项昂贵的操作，因此决定不值得根据此类检测结果动态转换这些方法为无操作。
- en: Notes on specific fields
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定字段的注意事项
- en: Character fields
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符字段
- en: Any fields that are stored with `VARCHAR` column types have their `max_length`
    restricted to 255 characters if you are using `unique=True` for the field. This
    affects `CharField`, `SlugField` and `CommaSeparatedIntegerField`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对字段使用`unique=True`，则存储为`VARCHAR`列类型的任何字段的`max_length`将限制为255个字符。这会影响`CharField`，`SlugField`和`CommaSeparatedIntegerField`。
- en: Fractional seconds support for time and datetime fields
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间和日期时间字段的分数秒支持
- en: MySQL 5.6.4 and later can store fractional seconds, provided that the column
    definition includes a fractional indication (for example, `DATETIME(6)`). Earlier
    versions do not support them at all. In addition, versions of MySQLdb older than
    1.2.5 have a bug that also prevents the use of fractional seconds with MySQL.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 5.6.4及更高版本可以存储分数秒，前提是列定义包括分数指示（例如，`DATETIME(6)`）。早期版本根本不支持它们。此外，早于1.2.5的MySQLdb版本存在一个错误，也会阻止与MySQL一起使用分数秒。
- en: 'Django will not upgrade existing columns to include fractional seconds if the
    database server supports it. If you want to enable them on an existing database,
    it''s up to you to either manually update the column on the target database, by
    executing a command such as:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库服务器支持，Django不会将现有列升级以包括分数秒。如果要在现有数据库上启用它们，您需要手动更新目标数据库上的列，例如执行以下命令：
- en: '[PRE6]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: or using a `RunSQL` operation in a `data migration`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 或在`数据迁移`中使用`RunSQL`操作。
- en: By default, new `DateTimeField` or `TimeField` columns are now created with
    fractional seconds support on MySQL 5.6.4 or later with either mysqlclient or
    MySQLdb 1.2.5 or later.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用mysqlclient或MySQLdb 1.2.5或更高版本在MySQL 5.6.4或更高版本上创建新的`DateTimeField`或`TimeField`列时现在支持分数秒。
- en: TIMESTAMP columns
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 时间戳列
- en: If you are using a legacy database that contains `TIMESTAMP` columns, you must
    set `USE_TZ = False` to avoid data corruption. `inspectdb` maps these columns
    to `DateTimeField` and if you enable timezone support, both MySQL and Django will
    attempt to convert the values from UTC to local time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用包含`TIMESTAMP`列的旧数据库，则必须将`USE_TZ = False`设置为避免数据损坏。`inspectdb`将这些列映射到`DateTimeField`，如果启用时区支持，则MySQL和Django都将尝试将值从UTC转换为本地时间。
- en: Row locking with Queryset.Select_For_Update()
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Queryset.Select_For_Update()进行行锁定
- en: MySQL does not support the `NOWAIT` option to the `SELECT ... FOR UPDATE` statement.
    If `select_for_update()` is used with `nowait=True` then a `DatabaseError` will
    be raised.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL不支持`SELECT ... FOR UPDATE`语句的`NOWAIT`选项。如果使用`select_for_update()`并且`nowait=True`，则会引发`DatabaseError`。
- en: Automatic typecasting can cause unexpected results
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动类型转换可能导致意外结果
- en: When performing a query on a string type, but with an integer value, MySQL will
    coerce the types of all values in the table to an integer before performing the
    comparison. If your table contains the values "`abc`", "`def`" and you query for
    `WHERE mycolumn=0`, both rows will match. Similarly, `WHERE mycolumn=1` will match
    the value "`abc1`". Therefore, string type fields included in Django will always
    cast the value to a string before using it in a query.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在对字符串类型执行查询时，但具有整数值时，MySQL将在执行比较之前将表中所有值的类型强制转换为整数。如果您的表包含值"`abc`"，"`def`"，并且您查询`WHERE
    mycolumn=0`，则两行都将匹配。同样，`WHERE mycolumn=1`将匹配值"`abc1`"。因此，在Django中包含的字符串类型字段在使用它进行查询之前将始终将该值转换为字符串。
- en: If you implement custom model fields that inherit from `Field` directly, are
    overriding `get_prep_value()`, or use `extra()` or `raw()`, you should ensure
    that you perform the appropriate typecasting.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您实现了直接继承自`Field`的自定义模型字段，正在覆盖`get_prep_value()`，或使用`extra()`或`raw()`，则应确保执行适当的类型转换。
- en: SQLite notes
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite注意事项
- en: SQLite provides an excellent development alternative for applications that are
    predominantly read-only or require a smaller installation footprint. As with all
    database servers, though, there are some differences that are specific to SQLite
    that you should be aware of.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite为主要是只读或需要较小安装占用空间的应用程序提供了一个优秀的开发替代方案。然而，与所有数据库服务器一样，SQLite具有一些特定于SQLite的差异，您应该注意。
- en: Substring matching and case sensitivity
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子字符串匹配和区分大小写
- en: 'For all SQLite versions, there is some slightly counter-intuitive behavior
    when attempting to match some types of strings. These are triggered when using
    the `iexact` or `contains` filters in Querysets. The behavior splits into two
    cases:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有SQLite版本，在尝试匹配某些类型的字符串时，会出现一些略微反直觉的行为。这些行为在Querysets中使用`iexact`或`contains`过滤器时会触发。行为分为两种情况：
- en: For substring matching, all matches are done case-insensitively. That is a filter
    such as filter(`name__contains="aa"`) will match a name of "Aabb".
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于子字符串匹配，所有匹配都是不区分大小写的。也就是说，过滤器`filter（name__contains="aa"）`将匹配名称为“Aabb”的名称。
- en: For strings containing characters outside the ASCII range, all exact string
    matches are performed case-sensitively, even when the case-insensitive options
    are passed into the query. So the `iexact` filter will behave exactly the same
    as the exact filter in these cases.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于包含ASCII范围之外字符的字符串，所有精确的字符串匹配都是区分大小写的，即使在查询中传递了不区分大小写的选项。因此，在这些情况下，`iexact`过滤器的行为将与精确过滤器完全相同。
- en: Some possible workarounds for this are documented at sqlite.org, but they aren't
    utilized by the default SQLite backend in Django, as incorporating them would
    be fairly difficult to do robustly. Thus, Django exposes the default SQLite behavior
    and you should be aware of this when doing case-insensitive or substring filtering.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题的一些可能的解决方法在sqlite.org上有记录，但默认的Django SQLite后端没有使用它们，因为将它们整合起来可能会相当困难。因此，Django暴露了默认的SQLite行为，您在进行不区分大小写或子字符串过滤时应该注意这一点。
- en: Old SQLite and CASE expressions
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧的SQLite和CASE表达式
- en: SQLite 3.6.23.1 and older contains a bug when handling query parameters in a
    `CASE` expression that contains an `ELSE` and arithmetic.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 3.6.23.1及更早版本在处理包含`ELSE`和算术的`CASE`表达式中的查询参数时存在一个错误。
- en: SQLite 3.6.23.1 was released in March 2010, and most current binary distributions
    for different platforms include a newer version of SQLite, with the notable exception
    of the Python 2.7 installers for Windows.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 3.6.23.1于2010年3月发布，大多数不同平台的当前二进制发行版都包含了更新版本的SQLite，但值得注意的是Python 2.7的Windows安装程序除外。
- en: As of this writing, the latest release for Windows-Python 2.7.10-includes SQLite
    3.6.21\. You can install `pysqlite2` or replace `sqlite3.dll` (by default installed
    in `C:\Python27\DLLs`) with a newer version from sqlite.org to remedy this issue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 截至目前，Windows-Python 2.7.10的最新版本包括SQLite 3.6.21。您可以安装`pysqlite2`或将`sqlite3.dll`（默认安装在`C:\Python27\DLLs`中）替换为来自sqlite.org的更新版本以解决此问题。
- en: Using newer versions of the SQLite DB-API 2.0 driver
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用更新版本的SQLite DB-API 2.0驱动程序
- en: Django will use a `pysqlite2` module in preference to `sqlite3` as shipped with
    the Python standard library if it finds one is available.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现可用的话，Django将优先使用`pysqlite2`模块而不是Python标准库中附带的`sqlite3`。
- en: This provides the ability to upgrade both the DB-API 2.0 interface or SQLite
    3 itself to versions newer than the ones included with your particular Python
    binary distribution, if needed.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，这提供了升级DB-API 2.0接口或SQLite 3本身到比特定Python二进制发行版中包含的版本更新的能力。
- en: Database is locked errors
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库被锁定的错误
- en: 'SQLite is meant to be a lightweight database, and thus can''t support a high
    level of concurrency. `OperationalError: database is locked` errors indicate that
    your application is experiencing more concurrency than `sqlite` can handle in
    default configuration. This error means that one thread or process has an exclusive
    lock on the database connection and another thread timed out waiting for the lock
    the be released.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQLite旨在成为一个轻量级的数据库，因此无法支持高并发。`OperationalError: database is locked`错误表明您的应用程序正在经历比`sqlite`默认配置中可以处理的并发更多的情况。这个错误意味着一个线程或进程在数据库连接上有一个独占锁，另一个线程在等待锁被释放时超时了。'
- en: 'Python''s SQLite wrapper has a default timeout value that determines how long
    the second thread is allowed to wait on the lock before it times out and raises
    the `OperationalError: database is locked` error.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Python的SQLite包装器具有默认的超时值，确定第二个线程在锁上等待多长时间才会超时并引发`OperationalError: database
    is locked`错误。'
- en: 'If you''re getting this error, you can solve it by:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遇到此错误，您可以通过以下方法解决：
- en: Switching to another database backend. At a certain point SQLite becomes too
    light for real-world applications, and these sorts of concurrency errors indicate
    you've reached that point.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换到另一个数据库后端。在某一点上，SQLite对于真实世界的应用程序来说变得太轻，这些并发错误表明您已经达到了这一点。
- en: Rewriting your code to reduce concurrency and ensure that database transactions
    are short-lived.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写您的代码以减少并发并确保数据库事务的持续时间较短。
- en: 'Increase the default timeout value by setting the `timeout` database options:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置`timeout`数据库选项来增加默认超时值：
- en: '[PRE7]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will simply make SQLite wait a bit longer before throwing database is locked
    errors; it won't really do anything to solve them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这只会使SQLite在抛出数据库被锁定错误之前等待更长的时间；它实际上并不会真正解决这些问题。
- en: queryset.Select_For_Update() not Supported
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: queryset.Select_For_Update()不支持
- en: SQLite does not support the `SELECT ... FOR UPDATE` syntax. Calling it will
    have no effect.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite不支持`SELECT ... FOR UPDATE`语法。调用它不会产生任何效果。
- en: pyformat parameter style in raw queries not supported
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 原始查询中不支持pyformat参数样式
- en: For most backends, raw queries (`Manager.raw()` or `cursor.execute()`) can use
    the pyformat parameter style, where placeholders in the query are given as `'%(name)s'`
    and the parameters are passed as a dictionary rather than a list. SQLite does
    not support this.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数后端，原始查询（`Manager.raw()`或`cursor.execute()`）可以使用pyformat参数样式，其中查询中的占位符为`'%(name)s'`，参数作为字典而不是列表传递。SQLite不支持这一点。
- en: Parameters not quoted in connection.queries
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接.queries中未引用的参数
- en: '`sqlite3` does not provide a way to retrieve the SQL after quoting and substituting
    the parameters. Instead, the SQL in `connection.queries` is rebuilt with a simple
    string interpolation. It may be incorrect. Make sure you add quotes where necessary
    before copying a query into an SQLite shell.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3`不提供在引用和替换参数后检索SQL的方法。相反，在`connection.queries`中的SQL将使用简单的字符串插值重新构建。这可能是不正确的。在将查询复制到SQLite
    shell之前，请确保在必要的地方添加引号。'
- en: Oracle notes
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Oracle注意事项
- en: Django supports Oracle Database Server versions 11.1 and higher. Version 4.3.1
    or higher of the `cx_Oracle` ([http://cx-oracle.sourceforge.net/](http://cx-oracle.sourceforge.net/))
    Python driver is required, although we recommend version 5.1.3 or later as these
    versions support Python 3.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Django支持Oracle数据库服务器版本11.1及更高版本。需要版本4.3.1或更高版本的`cx_Oracle`（[http://cx-oracle.sourceforge.net/](http://cx-oracle.sourceforge.net/)）Python驱动程序，尽管我们建议使用版本5.1.3或更高版本，因为这些版本支持Python
    3。
- en: Note that due to a Unicode-corruption bug in `cx_Oracle` 5.0, that version of
    the driver should **not** be used with Django; `cx_Oracle` 5.0.1 resolved this
    issue, so if you'd like to use a more recent `cx_Oracle`, use version 5.0.1.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于`cx_Oracle` 5.0中存在Unicode损坏错误，因此不应该使用该驱动程序的该版本与Django一起使用；`cx_Oracle`
    5.0.1解决了此问题，因此如果您想使用更新的`cx_Oracle`，请使用版本5.0.1。
- en: '`cx_Oracle` 5.0.1 or greater can optionally be compiled with the `WITH_UNICODE`
    environment variable. This is recommended but not required.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`cx_Oracle` 5.0.1或更高版本可以选择使用`WITH_UNICODE`环境变量进行编译。这是推荐的，但不是必需的。'
- en: 'In order for the `python manage.py migrate` command to work, your Oracle database
    user must have privileges to run the following commands:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`python manage.py migrate`命令工作，您的Oracle数据库用户必须具有运行以下命令的权限：
- en: '`CREATE TABLE`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`'
- en: '`CREATE SEQUENCE`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE SEQUENCE`'
- en: '`CREATE PROCEDURE`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE PROCEDURE`'
- en: '`CREATE TRIGGER`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TRIGGER`'
- en: 'To run a project''s test suite, the user usually needs these *additional* privileges:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目的测试套件，用户通常需要这些*额外*权限：
- en: '`CREATE USER`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE USER`'
- en: '`DROP USER`'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DROP USER`'
- en: '`CREATE TABLESPACE`'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TABLESPACE`'
- en: '`DROP TABLESPACE`'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DROP TABLESPACE`'
- en: '`CREATE SESSION WITH ADMIN OPTION`'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE SESSION WITH ADMIN OPTION`'
- en: '`CREATE TABLE WITH ADMIN OPTION`'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TABLE WITH ADMIN OPTION`'
- en: '`CREATE SEQUENCE WITH ADMIN OPTION`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE SEQUENCE WITH ADMIN OPTION`'
- en: '`CREATE PROCEDURE WITH ADMIN OPTION`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE PROCEDURE WITH ADMIN OPTION`'
- en: '`CREATE TRIGGER WITH ADMIN OPTION`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE TRIGGER WITH ADMIN OPTION`'
- en: Note that, while the `RESOURCE` role has the required `CREATE TABLE`, `CREATE
    SEQUENCE`, `CREATE PROCEDURE` and `CREATE TRIGGER` privileges, and a user granted
    `RESOURCE WITH ADMIN OPTION` can grant `RESOURCE`, such a user cannot grant the
    individual privileges (for example, `CREATE TABLE`), and thus `RESOURCE WITH ADMIN
    OPTION` is not usually sufficient for running tests.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，虽然`RESOURCE`角色具有所需的`CREATE TABLE`、`CREATE SEQUENCE`、`CREATE PROCEDURE`和`CREATE
    TRIGGER`权限，而且授予`RESOURCE WITH ADMIN OPTION`的用户可以授予`RESOURCE`，但这样的用户不能授予单个权限（例如`CREATE
    TABLE`），因此`RESOURCE WITH ADMIN OPTION`通常不足以运行测试。
- en: Some test suites also create views; to run these, the user also needs the `CREATE
    VIEW WITH ADMIN OPTION` privilege. In particular, this is needed for Django's
    own test suite.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一些测试套件还会创建视图；要运行这些视图，用户还需要`CREATE VIEW WITH ADMIN OPTION`权限。特别是Django自己的测试套件需要这个权限。
- en: All of these privileges are included in the DBA role, which is appropriate for
    use on a private developer's database.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些权限都包含在DBA角色中，这适用于在私人开发人员的数据库上使用。
- en: 'The Oracle database backend uses the `SYS.DBMS_LOB` package, so your user will
    require execute permissions on it. It''s normally accessible to all users by default,
    but in case it is not, you''ll need to grant permissions like so:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle数据库后端使用`SYS.DBMS_LOB`包，因此您的用户将需要对其具有执行权限。通常情况下，默认情况下所有用户都可以访问它，但如果不行，您将需要授予权限，如下所示：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Connecting to the database
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'To connect using the service name of your Oracle database, your `settings.py`
    file should look something like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Oracle数据库的服务名称进行连接，您的`settings.py`文件应该如下所示：
- en: '[PRE9]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this case, you should leave both `HOST` and `PORT` empty. However, if you
    don''t use a `tnsnames.ora` file or a similar naming method and want to connect
    using the SID (`xe` in this example), then fill in both `HOST` and `PORT` like
    so:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，您应该将`HOST`和`PORT`都留空。但是，如果您不使用`tnsnames.ora`文件或类似的命名方法，并且希望使用SID（在此示例中为`xe`）进行连接，那么请填写`HOST`和`PORT`如下：
- en: '[PRE10]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should either supply both `HOST` and `PORT`, or leave both as empty strings.
    Django will use a different connect descriptor depending on that choice.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该同时提供`HOST`和`PORT`，或者将两者都留空。Django将根据选择使用不同的连接描述符。
- en: Threaded option
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程选项
- en: 'If you plan to run Django in a multithreaded environment (for example, Apache
    using the default MPM module on any modern operating system), then you **must**
    set the `threaded` option of your Oracle database configuration to True:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在多线程环境中运行Django（例如，在任何现代操作系统上使用默认MPM模块的Apache），那么您**必须**将Oracle数据库配置的`threaded`选项设置为True：
- en: '[PRE11]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Failure to do this may result in crashes and other odd behavior.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 未能这样做可能会导致崩溃和其他奇怪的行为。
- en: INSERT ... RETURNING INTO
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INSERT ... RETURNING INTO
- en: By default, the Oracle backend uses a `RETURNING INTO` clause to efficiently
    retrieve the value of an `AutoField` when inserting new rows. This behavior may
    result in a `DatabaseError` in certain unusual setups, such as when inserting
    into a remote table, or into a view with an `INSTEAD OF` trigger.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Oracle后端使用`RETURNING INTO`子句来高效地检索`AutoField`的值，当插入新行时。这种行为可能会导致某些不寻常的设置中出现`DatabaseError`，例如在远程表中插入，或者在具有`INSTEAD
    OF`触发器的视图中插入。
- en: 'The `RETURNING INTO` clause can be disabled by setting the `use_returning_into`
    option of the database configuration to False:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`RETURNING INTO`子句可以通过将数据库配置的`use_returning_into`选项设置为False来禁用：'
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this case, the Oracle backend will use a separate `SELECT` query to retrieve
    `AutoField` values.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Oracle后端将使用单独的`SELECT`查询来检索`AutoField`值。
- en: Naming issues
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名问题
- en: Oracle imposes a name length limit of 30 characters.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle对名称长度有30个字符的限制。
- en: To accommodate this, the backend truncates database identifiers to fit, replacing
    the final four characters of the truncated name with a repeatable MD5 hash value.
    Additionally, the backend turns database identifiers to all-uppercase.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应这一点，后端将数据库标识符截断以适应，用可重复的MD5哈希值替换截断名称的最后四个字符。此外，后端将数据库标识符转换为全大写。
- en: 'To prevent these transformations (this is usually required only when dealing
    with legacy databases or accessing tables which belong to other users), use a
    quoted name as the value for `db_table`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些转换（通常仅在处理传统数据库或访问属于其他用户的表时才需要），请使用带引号的名称作为`db_table`的值：
- en: '[PRE13]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Quoted names can also be used with Django's other supported database backends;
    except for Oracle, however, the quotes have no effect.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 带引号的名称也可以与Django的其他支持的数据库后端一起使用；但是，除了Oracle之外，引号没有任何效果。
- en: When running `migrate`, an `ORA-06552` error may be encountered if certain Oracle
    keywords are used as the name of a model field or the value of a `db_column` option.
    Django quotes all identifiers used in queries to prevent most such problems, but
    this error can still occur when an Oracle datatype is used as a column name. In
    particular, take care to avoid using the names `date`, `timestamp`, `number` or
    `float` as a field name.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行`migrate`时，如果将某些Oracle关键字用作模型字段的名称或`db_column`选项的值，则可能会遇到`ORA-06552`错误。 Django引用所有在查询中使用的标识符，以防止大多数此类问题，但是当Oracle数据类型用作列名时，仍然可能发生此错误。特别要注意避免使用名称`date`，`timestamp`，`number`或`float`作为字段名称。
- en: NULL and empty strings
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NULL和空字符串
- en: Django generally prefers to use the empty string ('' ") rather than `NULL`,
    but Oracle treats both identically. To get around this, the Oracle backend ignores
    an explicit `null` option on fields that have the empty string as a possible value
    and generates DDL as if `null=True`. When fetching from the database, it is assumed
    that a `NULL` value in one of these fields really means the empty string, and
    the data is silently converted to reflect this assumption.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Django通常更喜欢使用空字符串（''“）而不是`NULL`，但是Oracle将两者视为相同。为了解决这个问题，Oracle后端会忽略对具有空字符串作为可能值的字段的显式`null`选项，并生成DDL，就好像`null=True`一样。在从数据库中获取数据时，假定这些字段中的`NULL`值实际上意味着空字符串，并且数据会被默默地转换以反映这一假设。
- en: Textfield limitations
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Textfield的限制
- en: 'The Oracle backend stores `TextField`s as `NCLOB` columns. Oracle imposes some
    limitations on the usage of such LOB columns in general:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle后端将`TextField`存储为`NCLOB`列。 Oracle对此类LOB列的使用施加了一些限制：
- en: LOB columns may not be used as primary keys.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOB列不能用作主键。
- en: LOB columns may not be used in indexes.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOB列不能用于索引。
- en: LOB columns may not be used in a `SELECT DISTINCT` list. This means that attempting
    to use the `QuerySet.distinct` method on a model that includes `TextField` columns
    will result in an error when run against Oracle. As a workaround, use the `QuerySet.defer`
    method in conjunction with `distinct()` to prevent `TextField` columns from being
    included in the `SELECT DISTINCT` list.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LOB列不能在`SELECT DISTINCT`列表中使用。这意味着在包含`TextField`列的模型上尝试使用`QuerySet.distinct`方法将导致针对Oracle运行时出错。作为解决方法，使用`QuerySet.defer`方法与`distinct()`结合使用，以防止`TextField`列被包括在`SELECT
    DISTINCT`列表中。
- en: Using a 3rd-Party database backend
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用第三方数据库后端
- en: 'In addition to the officially supported databases, there are backends provided
    by 3rd parties that allow you to use other databases with Django:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 除了官方支持的数据库外，还有第三方提供的后端，允许您使用其他数据库与Django一起使用：
- en: SAP SQL Anywhere
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SAP SQL Anywhere
- en: IBM DB2
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM DB2
- en: Microsoft SQL Server
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft SQL Server
- en: Firebird
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebird
- en: ODBC
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ODBC
- en: ADSDB
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ADSDB
- en: The Django versions and ORM features supported by these unofficial backends
    vary considerably. Queries regarding the specific capabilities of these unofficial
    backends, along with any support queries, should be directed to the support channels
    provided by each 3rd party project.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这些非官方后端支持的Django版本和ORM功能差异很大。关于这些非官方后端的具体功能以及任何支持查询，应该直接向每个第三方项目提供的支持渠道提出。
- en: Integrating Django with a legacy database
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Django与传统数据库集成
- en: While Django is best suited for developing new applications, it's quite possible
    to integrate it into legacy databases. Django includes a couple of utilities to
    automate as much of this process as possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Django最适合开发新应用程序，但完全可以将其集成到传统数据库中。Django包括一些实用程序，以尽可能自动化这个过程。
- en: Once you've got Django set up, you'll follow this general process to integrate
    with an existing database.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好Django后，您将按照以下一般流程与现有数据库集成。
- en: Give Django your database parameters
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给Django提供您的数据库参数
- en: 'You''ll need to tell Django what your database connection parameters are, and
    what the name of the database is. Do that by editing the `DATABASES` setting and
    assigning values to the following keys for the `''default''` connection:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要告诉Django您的数据库连接参数是什么，数据库的名称是什么。通过编辑`DATABASES`设置并为`'default'`连接分配值来完成这一点：
- en: '`NAME`'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`'
- en: '`ENGINE <DATABASE-ENGINE>`'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENGINE <DATABASE-ENGINE>`'
- en: '`USER`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`'
- en: '`PASSWORD`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PASSWORD`'
- en: '`HOST`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HOST`'
- en: '`PORT`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PORT`'
- en: Auto-generate the models
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动生成模型
- en: 'Django comes with a utility called `inspectdb` that can create models by introspecting
    an existing database. You can view the output by running this command:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Django带有一个名为`inspectdb`的实用程序，可以通过内省现有数据库来创建模型。您可以通过运行此命令查看输出：
- en: '[PRE14]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save this as a file by using standard Unix output redirection:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准的Unix输出重定向将此保存为文件：
- en: '[PRE15]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This feature is meant as a shortcut, not as definitive model generation. See
    the documentation of `inspectdb` for more information.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能旨在作为快捷方式，而不是最终的模型生成。有关更多信息，请参阅`inspectdb`的文档。
- en: Once you've cleaned up your models, name the file `models.py` and put it in
    the Python package that holds your app. Then add the app to your `INSTALLED_APPS`
    setting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 清理模型后，将文件命名为`models.py`并将其放在包含您的应用程序的Python包中。然后将该应用程序添加到您的`INSTALLED_APPS`设置中。
- en: 'By default, `inspectdb` creates unmanaged models. That is, `managed = False`
    in the model''s `Meta` class tells Django not to manage each table''s creation,
    modification, and deletion:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`inspectdb`创建的是不受管理的模型。也就是说，在模型的`Meta`类中的`managed = False`告诉Django不要管理每个表的创建、修改和删除：
- en: '[PRE16]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you do want to allow Django to manage the table's lifecycle, you'll need
    to change the `managed` option preceding to `True` (or simply remove it because
    `True` is its default value).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实希望Django管理表的生命周期，你需要将前面的`managed`选项更改为`True`（或者简单地删除它，因为`True`是它的默认值）。
- en: Install the core Django tables
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装核心Django表
- en: 'Next, run the `migrate` command to install any extra needed database records
    such as admin permissions and content types:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，运行`migrate`命令来安装任何额外需要的数据库记录，比如管理员权限和内容类型：
- en: '[PRE17]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Cleaning up generated models
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理生成的模型
- en: 'As you might expect, the database introspection isn''t perfect, and you''ll
    need to do some light clean-up of the resulting model code. Here are a few pointers
    for dealing with the generated models:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，数据库内省并不完美，你需要对生成的模型代码进行一些轻微的清理。以下是处理生成模型的一些建议：
- en: Each database table is converted to a model class (that is, there is a one-to-one
    mapping between database tables and model classes). This means that you'll need
    to refactor the models for any many-to-many join tables into `ManyToManyField`
    objects.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个数据库表都转换为一个模型类（也就是说，数据库表和模型类之间是一对一的映射）。这意味着你需要将许多对多连接表的模型重构为`ManyToManyField`对象。
- en: 'Each generated model has an attribute for every field, including id primary
    key fields. However, recall that Django automatically adds an id primary key field
    if a model doesn''t have a primary key. Thus, you''ll want to remove any lines
    that look like this:'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个生成的模型都有一个属性对应每个字段，包括id主键字段。然而，要记住，如果一个模型没有主键，Django会自动添加一个id主键字段。因此，你需要删除任何看起来像这样的行：
- en: '[PRE18]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Not only are these lines redundant, but also they can cause problems if your
    application will be adding *new* records to these tables.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些行不仅是多余的，而且如果你的应用程序将向这些表中添加*新*记录，它们还会引起问题。
- en: Each field's type (for example, `CharField`, `DateField`) is determined by looking
    at the database column type (for example, `VARCHAR`, `DATE`). If `inspectdb` cannot
    map a column's type to a model field type, it will use `TextField` and will insert
    the Python comment `'This field type is a guess.'` next to the field in the generated
    model. Keep an eye out for that, and change the field type accordingly if needed.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段的类型（例如`CharField`、`DateField`）是通过查看数据库列类型（例如`VARCHAR`、`DATE`）来确定的。如果`inspectdb`无法将列的类型映射到模型字段类型，它将使用`TextField`，并在生成的模型中在字段旁边插入Python注释`'This
    field type is a guess.'`。留意这一点，如果需要，相应地更改字段类型。
- en: If a field in your database has no good Django equivalent, you can safely leave
    it off. The Django model layer is not required to include every field in your
    table(s).
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据库中的字段没有良好的Django等效项，你可以放心地将其删除。Django模型层并不要求包含表中的每个字段。
- en: If a database column name is a Python reserved word (such as `pass`, `class`,
    or `for`), `inspectdb` will append "`_field`" to the attribute name and set the
    `db_column` attribute to the real field name (for example, `pass`, `class`, or
    `for`).
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果数据库列名是Python保留字（比如`pass`、`class`或`for`），`inspectdb`会在属性名后面添加"`_field`"，并将`db_column`属性设置为真实字段名（例如`pass`、`class`或`for`）。
- en: 'For example, if a table has an `INT` column called `for`, the generated model
    will have a field like this:'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，如果一个表有一个名为`for`的`INT`列，生成的模型将有一个类似这样的字段：
- en: '[PRE19]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`inspectdb` will insert the Python comment `''Field renamed because it was
    a Python reserved word.''` next to the field.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspectdb`会在字段旁边插入Python注释`''Field renamed because it was a Python reserved
    word.''`。'
- en: If your database contains tables that refer to other tables (as most databases
    do), you might need to rearrange the order of the generated models so that models
    that refer to other models are ordered properly. For example, if model `Book`
    has a `ForeignKey` to model `Author`, model `Author` should be defined before
    model `Book`. If you need to create a relationship on a model that has not yet
    been defined, you can use a string containing the name of the model, rather than
    the model object itself.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的数据库包含引用其他表的表（大多数数据库都是这样），你可能需要重新排列生成的模型的顺序，以便引用其他模型的模型被正确排序。例如，如果模型`Book`有一个指向模型`Author`的`ForeignKey`，模型`Author`应该在模型`Book`之前定义。如果需要在尚未定义的模型上创建关系，你可以使用包含模型名称的字符串，而不是模型对象本身。
- en: '`inspectdb` detects primary keys for PostgreSQL, MySQL, and SQLite. That is,
    it inserts `primary_key=True` where appropriate. For other databases, you''ll
    need to insert `primary_key=True` for at least one field in each model, because
    Django models are required to have a `primary_key=True` field.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inspectdb`检测PostgreSQL、MySQL和SQLite的主键。也就是说，它会在适当的地方插入`primary_key=True`。对于其他数据库，你需要在每个模型中至少插入一个`primary_key=True`字段，因为Django模型需要有一个`primary_key=True`字段。'
- en: Foreign-key detection only works with PostgreSQL and with certain types of MySQL
    tables. In other cases, foreign-key fields will be generated as `IntegerField`'s,
    assuming the foreign-key column was an `INT` column.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外键检测只适用于PostgreSQL和某些类型的MySQL表。在其他情况下，外键字段将被生成为`IntegerField`，假设外键列是一个`INT`列。
- en: Test and tweak
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和调整
- en: Those are the basic steps-from here you'll want to tweak the models Django generated
    until they work the way you'd like. Try accessing your data via the Django database
    API, and try editing objects via Django's admin site, and edit the models file
    accordingly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是基本步骤-从这里开始，你需要调整Django生成的模型，直到它们按照你的意愿工作。尝试通过Django数据库API访问数据，并尝试通过Django的管理站点编辑对象，并相应地编辑模型文件。
- en: What's next?
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: That's all folks!
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！
- en: 'I hope you have enjoyed reading *Mastering Django: Core* and have learned a
    lot from the book. While this book will serve you as a complete reference to Django,
    there is still no substitute for plain old practice-so get coding and all the
    best with your Django career!'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您喜欢阅读《精通Django：核心》，并从这本书中学到了很多。虽然这本书将为您提供Django的完整参考，但没有什么能替代老实的实践-所以开始编码，祝您在Django职业生涯中一切顺利！
- en: The remaining chapters are purely for your reference. They include appendices
    and quick references for all of the functions and fields in Django
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的章节纯粹供您参考。它们包括附录和所有Django函数和字段的快速参考。
