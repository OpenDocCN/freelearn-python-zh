- en: 2 Organizing a project
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 组织项目
- en: It is Day 0\. You have a project in hand. You are fired up and ready to build
    a new web application. Ideas are swirling in your head, and your fingers are itching
    to start punching the keyboard. Time to sit down and start coding!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第0天。你手头有一个项目。你充满激情，准备构建一个新的Web应用程序。你的脑海中充满了想法，你的手指迫不及待地想要开始敲击键盘。是时候坐下来开始编码了！
- en: Or is it? It is tempting to start building an application as soon as the ideas
    about what we want to build begin to formulate in our heads. Before doing that,
    we should think about setting ourselves up for success. Having a solid foundation
    for the building will make the process much easier, reduce bugs, and result in
    a cleaner application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 或者是吗？在我们头脑中关于我们想要构建的想法开始形成时，立即开始构建应用程序是很诱人的。在这样做之前，我们应该考虑如何为成功做好准备。有一个坚实的基础将使这个过程更容易，减少错误，并产生更干净的应用程序。
- en: 'The three foundations for beginning any Python web application project are:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 开始任何Python Web应用程序项目的三个基础是：
- en: your IDE/coding editor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的IDE/代码编辑器
- en: an environment for running your development application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行你的开发应用程序的环境
- en: a project application structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个项目应用程序结构
- en: 'These three elements take into account a lot of personal tastes. There are
    so many good tools and approaches. There is no way a single book could cover them
    all. If you are a more seasoned developer and already have a set of preferences:
    great, run with that and skip ahead to the next chapter.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个元素考虑了很多个人喜好。有如此多的优秀工具和方法。没有任何一本书能够涵盖所有这些。如果你是一个经验丰富的开发者并且已经有一套偏好：太好了，继续前进并跳到下一章。
- en: 'In this chapter, we will explore a couple of modern options to get you up and
    running. The focus will be upon foundation #2 (the environment) and foundation
    #3 (the application structure). We skip #1 and assume you are using a modern IDE
    of your own choosing. Popular choices in the Python world include VS Code, Pycharm,
    and Sublime Text. If you are not using one of these or something similar, go look
    them up and find one that works for you.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索一些现代选项，帮助你快速启动。重点将放在第二个基础（环境）和第三个基础（应用程序结构）。我们跳过第一个基础，并假设你正在使用自己选择的现代IDE。Python世界中的流行选择包括VS
    Code、PyCharm和Sublime Text。如果你没有使用这些或类似的产品，去查找并找到一个适合你的。
- en: After we setup our environment, we will explore some patterns to be implemented
    in Sanic that will help define your application architecture. This is not a software
    architecture book. I highly recommend you learn about approaches like “Domain
    Driven Design” and “Clean Architecture”. This book is focused much more on the
    practical aspects and decisions of building a web application in Sanic, so feel
    free to adjust the patterns as you feel necessary.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置好环境后，我们将探讨在Sanic中实现的一些模式，这将有助于定义你的应用程序架构。这不是一本软件架构的书。我强烈建议你学习像“领域驱动设计”和“清洁架构”这样的方法。这本书更多地关注在Sanic中构建Web应用程序的实用方面和决策，所以请根据需要自由调整模式。
- en: 'In this chapter, we’ll go through the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Setting up an environment and directory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置环境和目录
- en: Using blueprints effectively
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用蓝图
- en: Wiring it all up
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合所有元素
- en: Running our application
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, we will assume you have the following already setup on your
    computer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们将假设你已经在你的电脑上设置了以下内容：
- en: Modern Python installation (Python 3.7 or newer)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代Python安装（Python 3.7或更高版本）
- en: Terminal (and basic knowledge of how to execute programs)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端（以及如何执行程序的基本知识）
- en: IDE (as discussed above)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IDE（如上所述）
- en: Setting up an environment and directory
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置环境和目录
- en: 'The first few steps that you take when starting any project have a monumental
    impact on the entirety of the project. Whether you are embarking on a multi-year
    project—or one that will be complete in a couple of hours—these early decisions
    will shape how you and others work on the project. But, even though these are
    important choices, do not fall into the trap of thinking that you need to find
    the *perfect* solution. There is no single “right way” to set up an environment
    or project directory. Remember our discussion from the previous chapter: we want
    to make the choices that fit the project at hand.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始任何项目时，你采取的前几步将对整个项目产生重大影响。无论你是开始一个可能持续多年的项目，还是只需要几个小时就能完成的项目，这些早期的决定将塑造你和他人如何在这个项目上工作。但是，尽管这些选择很重要，不要陷入认为你需要找到*完美*解决方案的陷阱。没有单一的正确方式来设置环境或项目目录。记住我们之前章节的讨论：我们想要做出适合当前项目的选择。
- en: Environment
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 环境
- en: A good practice for Python development is to isolate its running environment
    from other projects. This is typically accomplished with virtual environments.
    In its most basic understanding, a virtual environment is a tool that allows you
    to install Python dependencies in isolation. This is important so that when we
    begin to develop our application, we have control of the requirements and dependencies
    in use. In its absence, we might mistakenly run our application and have requirements
    from other projects bleed into the application causing bugs and unintended behaviors.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python开发来说，一个良好的实践是将它的运行环境与其他项目隔离开来。这通常是通过虚拟环境来实现的。在最基本的理解中，虚拟环境是一个工具，它允许你在隔离的环境中安装Python依赖项。这很重要，因为当我们开始开发我们的应用程序时，我们可以控制所使用的需求和依赖项。如果没有它，我们可能会错误地运行我们的应用程序，导致其他项目的需求渗透到应用程序中，造成错误和意外的行为。
- en: Usage of a virtual environment is so foundational in the Python development
    world, that it has become the expected “norm” when creating a Python script or
    application. The first step you should always do when starting a new project is
    making a new virtual environment for it. The alternative to them is to run your
    application with your operating system’s installation of Python. Do not do this.
    It may be fine for a while, but eventually, you will come across conflicting requirements,
    naming collisions, or other difficulties that all stem from a lack of isolation.
    The first step to becoming a better Python developer is to use virtual environments
    if you are not already.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python开发世界中，虚拟环境的使用是如此基础，以至于在创建Python脚本或应用程序时，它已经成为预期的“规范”。当你开始一个新的项目时，你应该做的第一步是为它创建一个新的虚拟环境。它们的替代方案是使用操作系统安装的Python运行你的应用程序。不要这样做。这可能在一开始是可行的，但最终，你将遇到冲突的需求、命名冲突或其他困难，所有这些困难都源于缺乏隔离。成为更好的Python开发者的第一步是使用虚拟环境，如果你还没有这样做的话。
- en: It is also extremely helpful to acquaint yourself with the different tools that
    IDEs provide in hooking up to your virtual environment. These tools will often
    include things like code completion, and guide you as you start using features
    of your dependencies.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉IDE提供的将虚拟环境连接到你的不同工具也非常有帮助。这些工具通常包括代码补全等功能，并指导你开始使用依赖项的功能。
- en: We do eventually want to run our application using containers. Being able to
    run our application inside of a Docker container will greatly reduce the complexity
    in deploying our application down the road. This will be discussed further in
    *Chapter 9, Best practices to improve your web applications*. However, I also
    believe that our application should be runnable (and therefore testable) from
    multiple environments. Even if we intend to use Docker down the road, we first
    need our application running locally without it. Debugging becomes much easier
    when our application does not rely upon an overly complex set of requirements
    just to run. Therefore, let’s spend some time thinking about how to setup a virtual
    environment.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终希望使用容器来运行我们的应用程序。能够在Docker容器中运行我们的应用程序将大大减少未来部署应用程序的复杂性。这将在*第9章，提高你的Web应用程序的最佳实践*中进一步讨论。然而，我也相信我们的应用程序应该能够在多个环境中运行（因此可测试）。即使我们打算将来使用Docker，我们首先也需要在没有它的本地环境中运行我们的应用程序。当我们的应用程序不依赖于过于复杂的依赖项来运行时，调试变得更加容易。因此，让我们花些时间思考如何设置虚拟环境。
- en: There are many great tutorials and resources about how to use virtual environments.
    There are also many tools out there that are created to help manage the process.
    While I personally am a fan of the simple, tried and true method of `virtualenv`
    plus `virtuanenvwrapper`, there are many people who are fans of `pipenv`, or `poetry`.
    These latter tools are meant to be a more “complete” encapsulation of your running
    environment. If they work for you, great. You are encouraged to spend some time
    to see what strikes a chord and resonates with your development pattern and needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用虚拟环境有许多优秀的教程和资源。还有许多工具被创建出来以帮助管理这个过程。虽然我个人是 `virtualenv` 加 `virtuanenvwrapper`
    这种简单、可靠方法的粉丝，但许多人喜欢 `pipenv` 或 `poetry`。这些后者的工具旨在成为您运行环境的更“完整”封装。如果它们适合您，那很好。我们鼓励您花些时间看看什么与您的开发模式和需求产生共鸣。
- en: We will leave virtual environments aside for now, and briefly explore the usage
    of a relatively new pattern in Python. In Python 3.8, Python adopted a new pattern
    in PEP 582 that formalizes the inclusion of requirements into an isolated environment
    in a special `__pypackages__` directory that lives inside the project. While the
    concept is similar to virtual environments, it works a little differently.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在暂时不考虑虚拟环境，而是简要探索 Python 中一个相对较新的模式。在 Python 3.8 中，Python 采用了 PEP 582 中的一种新模式，该模式将需求正式包含到项目内部的一个特殊
    `__pypackages__` 目录中，从而在一个隔离的环境中。虽然这个概念与虚拟环境类似，但它的工作方式略有不同。
- en: In order to implement `__pypackages__`, we are making it mandatory for our fictitious
    development team to use `pdm`. This is a relatively new tool that makes it super
    simple to adhere to some of the latest practices in modern Python development.
    If this approach interests you, take some time to go read PEP 582 ([https://www.python.org/dev/peps/pep-0582/](https://www.python.org/dev/peps/pep-0582/))
    and look at `pdm` ([https://pdm.fming.dev/](https://pdm.fming.dev/)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现 `__pypackages__`，我们要求我们的虚构开发团队强制使用 `pdm`。这是一个相对较新的工具，它使得遵循现代 Python 开发的一些最新实践变得非常简单。如果您对此方法感兴趣，请花些时间阅读
    PEP 582 ([https://www.python.org/dev/peps/pep-0582/](https://www.python.org/dev/peps/pep-0582/))
    并查看 `pdm` ([https://pdm.fming.dev/](https://pdm.fming.dev/))。
- en: 'You can get started by installing it with `pip`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用 `pip` 来安装它：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Refer to the installation instructions on their website for more details: [https://pdm.fming.dev/#installation](https://pdm.fming.dev/#installation).
    Pay particular attention to useful features like shell completion and IDE integrations.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考他们网站上的安装说明以获取更多详细信息：[https://pdm.fming.dev/#installation](https://pdm.fming.dev/#installation)。请特别注意像
    shell 完成和 IDE 集成这样的有用功能。
- en: 'Now let’s proceed with setting up:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续进行设置：
- en: To get started, we create a new directory for our application, and from that
    directory run the following and follow the prompts to setup a basic structure.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们为我们的应用程序创建一个新的目录，并从这个目录运行以下命令，然后按照提示设置基本结构。
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now we will install Sanic.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将安装 Sanic。
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We now have access to Sanic. Just to confirm in our heads that we are indeed
    in an isolated environment, let’s quickly jump into the Python REPL, and check
    the location of Sanic using: sanic.__file__.'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以访问 Sanic。为了确认我们确实在一个隔离的环境中，让我们快速跳入 Python REPL，并使用以下命令检查 Sanic 的位置：sanic.__file__。
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Sanic CLI
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sanic CLI
- en: As discussed in *Chapter 8, Running a Server*, there are many considerations
    that go into *how* to deploy and run Sanic. Unless we are specifically looking
    into one of these alternatives, you can assume in this book that we are running
    Sanic using the Sanic CLI. This will standup our application using the integrated
    Sanic web server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 8 章所述，关于如何部署和运行 Sanic 有许多考虑因素。除非我们特别关注这些替代方案之一，否则在本书中您可以假设我们正在使用 Sanic CLI
    运行 Sanic。这将使用集成的 Sanic 网络服务器启动我们的应用程序。
- en: 'First, we will check to see what version we are running:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将检查我们正在运行哪个版本：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'And check to see what options we can use with the CLI:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后查看我们可以使用 CLI 的选项：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our standard form for running our applications right now will be:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在运行应用程序的标准形式将是：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: What thought went into the decision for using this command? Let’s take a look.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用此命令的决定中考虑了哪些因素？让我们看看。
- en: Why src.server:app?
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么是 src.server:app？
- en: First, we are going to run this from the `./booktracker` directory. All of our
    code will be nested in a `src` directory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将从这个 `./booktracker` 目录运行这个命令。我们所有的代码都将嵌套在 `src` 目录中。
- en: 'Second, it is somewhat standard practice that our application creates a single
    `Sanic()` instance, and assigns it to a variable called `app`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，这是一个相对标准的做法，我们的应用程序创建一个单一的`Sanic()`实例，并将其分配给一个名为`app`的变量：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If we were to place that into a file called `app.py`, then our module and variable
    start to get confused.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将它放入一个名为`app.py`的文件中，那么我们的模块和变量开始变得混乱。
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The above import statement is, well, ugly. As much as possible, it is beneficial
    to avoid naming conflicts between modules and the contents of that module.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上述导入语句，嗯，很丑。尽可能避免模块和该模块内容之间的命名冲突是有益的。
- en: 'A bad example of this exists in the standard library. Have you ever done this
    one by accident:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中存在一个这样的坏例子。你有没有不小心做过这个：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Oops, we should have used `from datetime import datetime`. We want to minimize
    the replication of module names and properties, and to make our imports easy to
    remember and intuitive to look at.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，我们应该使用`from datetime import datetime`。我们希望最小化模块名称和属性的重复，并使我们的导入易于记忆和直观。
- en: 'Therefore, we will place our global `app` variable into a file called `server.py`.
    Sanic will look for our app instance when you pass in the form: `<module>:<variable>`.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将我们的全局`app`变量放入一个名为`server.py`的文件中。Sanic会在你传入以下形式时查找我们的应用程序实例：`<module>:<variable>`。
- en: Why -p 7777?
  id: totrans-60
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么是-p 7777？
- en: We, of course, could choose any arbitrary port here. Many web servers will use
    port `8000` and that is the Sanic default if we just left it out completely. However,
    precisely because it is standard, we want to choose something else. Often, it
    is beneficial to choose a port that is less likely to collide with other ports
    that might be running on your machine. The more we can preserve common ports,
    the less likely we will run into collisions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以选择任何任意的端口。许多网络服务器将使用端口`8000`，如果我们完全忽略它，那么这就是Sanic的默认端口。然而，正是因为它是标准的，我们想要选择另一个端口。通常，选择一个不太可能与你的机器上运行的其它端口冲突的端口是有益的。我们能够保留的常用端口越多，我们遇到冲突的可能性就越小。
- en: Why --debug?
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么是--debug？
- en: 'While developing, having `DEBUG` mode enabled provides: a more verbose output
    from Sanic, and an auto-reloading server. It can be helpful to see more logs,
    but make sure you turn this off in production.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，启用`DEBUG`模式可以提供：来自Sanic的更冗余的输出和一个自动重新加载的服务器。查看更多日志可能会有所帮助，但请确保在生产环境中关闭此功能。
- en: The auto-reloading feature is particularly beneficial because you can start
    writing your app in one window, and in a separate terminal session have it running.
    Then, every time that you make a change and save the application, Sanic will restart
    the server and immediately your new code is available for testing.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重新加载功能特别有益，因为你可以在一个窗口中开始编写你的应用程序，然后在另一个终端会话中运行它。然后，每次你做出更改并保存应用程序时，Sanic都会重新启动服务器，你的新代码立即可用于测试。
- en: If you want the auto-reloading, but not all the extra verbosity, consider using
    `--auto-reload` instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自动重新加载，但又不想有所有额外的冗余信息，考虑使用`--auto-reload`代替。
- en: Why --workers=2?
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为什么是--workers=2？
- en: It is not an uncommon problem where someone begins to build an application and
    then realizes down the road that they have made a mistake by not preparing for
    horizontal scaling. Perhaps they added global state that cannot be accessed outside
    of a single process.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是一个罕见的问题，有人开始构建一个应用程序，然后意识到他们没有为横向扩展做准备，最终犯了一个错误。也许他们添加了全局状态，这些状态无法在单个进程之外访问。
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Oops, now that person needs to go back and re-engineer the solution if they
    want to scale up the application. This could be a costly endeavor. Luckily, we
    are smarter than that.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，现在那个人需要回去重新设计解决方案，如果他们想要扩展应用程序的话。这可能是一项代价高昂的任务。幸运的是，我们比那样聪明。
- en: By forcing our development pattern to include multiple workers from the beginning,
    it will help remind us as we are solving problems that our application *must*
    account for scaling. Even if our ultimate deployment does not use multiple Sanic
    workers per instance (and instead, for example, uses multiple Kubernetes pods
    with single worker instances–see *Chapter 9, Best practices to improve your web
    applications*), this constant safeguard is a helpful way to keep the ultimate
    goal integral to the design process.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制我们的开发模式从一开始就包括多个工作者，这将有助于我们在解决问题时提醒自己，我们的应用程序*必须*考虑到扩展。即使我们的最终部署不使用每个实例的多个Sanic工作者（例如，使用多个Kubernetes
    pod，每个pod只有一个工作者实例–参见*第9章，提高你的Web应用程序的最佳实践*），这种持续的保护措施是保持最终目标与设计过程一致的有帮助方式。
- en: Directory Structure
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目录结构
- en: There are many different patterns you can follow for organizing a web application.
    Perhaps the simplest would be the single file `server.py` where all of your logic
    exists together. For obvious reasons, this is not a practical solution for larger,
    real world projects. So we will ignore that one.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于组织Web应用程序，你可以遵循许多不同的模式。可能最简单的是单文件`server.py`，其中包含所有的逻辑。由于显而易见的原因，这不是更大、更实际的项目的实际解决方案。所以我们将忽略这一点。
- en: What types of solutions are there? Perhaps we could use the “apps” structure
    that Django prefers where discrete portions of our application are grouped together
    into a single module. Or, perhaps you prefer to group by type, for example, by
    keeping all of your view controllers together. We make no judgments here about
    what is better for your needs, but we need to understand some consequences of
    our decisions.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些类型的解决方案？也许我们可以使用Django偏好的“apps”结构，将应用程序的离散部分组合成一个模块。或者，也许你更喜欢按类型分组，例如，将所有的视图控制器放在一起。在这里，我们不做任何关于什么更适合你需求的判断，但我们需要了解我们决策的一些后果。
- en: 'When making a decision, you might want to learn some common practices. This
    might be a good opportunity to go look up some of the following patterns:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在做决定时，你可能想了解一些常见的做法。这可能是一个查找以下模式的好机会：
- en: '**Model View Controller** (**MVC**)'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型视图控制器**（**MVC**）'
- en: '**Model View ViewModel** (**MVVM**)'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型视图视图模型**（**MVVM**）'
- en: '**Domain Driven Design** (**DDD**)'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**领域驱动设计**（**DDD**）'
- en: '**Clean Architecture** (**CA**)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**清洁架构**（**CA**）'
- en: 'Just to give you a flavor of the differences (or at least my interpretation
    of them), you might structure your project in one of the following ways:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了让你了解这些差异（或者至少是我对它们的解释），你可能会以以下方式之一来构建你的项目：
- en: 'You might use MVC:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会使用MVC：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or you might use DDD:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你可能使用DDD：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this book, we are going to adopt something that approximates a hybrid approach.
    There is a time and place for applying these theoretical constructs. I urge you
    to learn them. The information is useful. But we are here to learn *how* to practically
    go about building an application with Sanic.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将采用一种类似于混合方法的东西。应用这些理论结构的时间和地点是存在的。我敦促你们去学习它们。这些信息是有用的。但我们在这里是为了学习**如何**使用Sanic实际构建一个应用程序。
- en: 'Here’s the modified structure:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是修改后的结构：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let’s breakdown each of these to see what they might look like and understand
    the thought process behind this application design.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一分析这些，看看它们可能是什么样子，并理解这个应用程序设计的背后的思考过程。
- en: ./blueprints
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ./blueprints
- en: This might strike you as odd since ultimately this directory looks like it contains
    more than just blueprints. And, you would be right. Looking at the tree, you see
    that “blueprints” includes both `view.py` and `model.py`. The goal of this directory
    is to separate your application into logical components, or domains. It functions
    much the same way as an `apps` directory might in a Django application. If you
    can isolate some construct or portion of your application as being a distinct
    entity, it should probably have a subfolder here.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能让你觉得有些奇怪，因为最终这个目录看起来包含的不仅仅是蓝图。而且，你会是对的。查看树状结构，你会看到“blueprints”包括`view.py`和`model.py`。这个目录的目标是将你的应用程序分成逻辑组件或领域。它的工作方式与Django应用程序中的`apps`目录非常相似。如果你可以将某些结构或应用程序的一部分隔离为独立的实体，那么它可能应该有一个子目录。
- en: A single module in this directory might contain models for validating incoming
    requests, utilities for fetching data from a database, and blueprints with attached
    route handlers. This keeps related code close together.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本目录下的单个模块可能包含验证传入请求的模型、从数据库获取数据的实用工具以及带有附加路由处理器的蓝图。这样做可以将相关代码放在一起。
- en: But why call it `blueprints`? Each subdirectory will contain much more than
    a single `Blueprint` object. The point is to reinforce the idea that everything
    in this directory resolves around one of these discrete components. The standard
    method for organization a so-called component in Sanic is the `Blueprint` (which
    we will more about in the next section). Therefore, each subdirectory will have
    one–and only one–`Blueprint` object.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么叫它`blueprints`？每个子目录将包含比单个`Blueprint`对象多得多的内容。重点是强化这样一个观点：这个目录中的所有内容都围绕这些离散组件之一。在Sanic中组织所谓的组件的标准方法是`Blueprint`（我们将在下一节中了解更多）。因此，每个子目录将有一个——而且只有一个——`Blueprint`对象。
- en: 'Another important rule: *nothing* inside the `./bluprints` directory will reference
    our Sanic application. That means that both `Sanic.get_app()` and `from server
    import app` are forbidden inside this directory.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要规则：`./bluprints`目录内的**任何内容**都不会引用我们的Sanic应用程序。这意味着在这个目录内禁止使用`Sanic.get_app()`和`from
    server import app`。
- en: It is generally helpful to think of a blueprint as corresponding to a portion
    of your API design pattern.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将蓝图视为与您的API设计模式的一部分相对应是有帮助的。
- en: '`example.com/auth -> ./blueprints/auth`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.com/auth -> ./blueprints/auth`'
- en: '`example.com/cake -> ./blueprints/cake`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.com/cake -> ./blueprints/cake`'
- en: '`example.com/pie -> ./blueprints/pie`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.com/pie -> ./blueprints/pie`'
- en: '`example.com/user -> ./blueprints/user`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example.com/user -> ./blueprints/user`'
- en: ./middleware
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ./middleware
- en: This directory should contain any middleware that is meant to be global in scope.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 此目录应包含任何旨在具有全局范围的中间件。
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As discussed later in this Chapter and in *Chapter 6, Outside the response cycle*
    and also at the Sanic User Guide ([https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware](https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware)),
    middleware can be global or attach to blueprints. If you need to apply middleware
    to specific routes, perhaps blueprint based middleware makes sense. In this case,
    you should nest them in the appropriate `./blueprints` directory and not here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章后面和*第6章，响应周期之外*以及Sanic用户指南（[https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware](https://sanicframework.org/en/guide/best-practices/blueprints.html#middleware)）中讨论的那样，中间件可以是全局的或附加到蓝图上。如果您需要将中间件应用于特定路由，基于蓝图的中间件可能是有意义的。在这种情况下，您应该将它们嵌套在适当的`./blueprints`目录中，而不是这里。
- en: ./common
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ./common
- en: This module is meant to be a place to store class definitions and functions
    that will be used to build your application. It is for everything that will span
    your blueprints and be pervasive within your application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块旨在存储用于构建应用程序的类定义和函数。它是关于将跨越您的蓝图并在您的应用程序中普遍使用的所有内容。
- en: '**TIP**'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Try to expand upon the directory structure here to meet your needs. But, try
    not to add too many top level directories. If you start cluttering up your folders,
    think about how you might be able to nest directories inside one another. Usually
    you will find that this leads to a cleaner architecture. There is also such as
    thing as going too far with nesting. For example, if you need to navigate ten
    levels deep in your appication code, perhaps you should dial it back.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尝试根据您的需求扩展这里的目录结构。但是，尽量不要添加太多的顶级目录。如果您开始使文件夹杂乱无章，考虑一下您如何能够将目录嵌套在彼此内部。通常，您会发现这会导致更清晰的架构。过度嵌套也是一件事情。例如，如果您需要在应用程序代码中导航到十层深度，可能应该适当减少。
- en: It’s still Day 0\. You still have a lot of great ideas in your head about what
    you want to build. And thanks to some thoughtful pre-planning, we now have an
    effective setup for building out application locally. At this point we should
    know how the application will run locally, and generally how the project will
    be organized. What we will learn next is the transition step from application
    structure to business logic.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是第一天。您头脑中还有很多关于您想要构建的伟大想法。多亏了一些深思熟虑的预先规划，我们现在已经为在本地构建应用程序提供了一个有效的设置。在这个时候，我们应该知道应用程序如何在本地运行，以及项目通常是如何组织的。接下来我们将学习的是从应用程序结构到业务逻辑的过渡步骤。
- en: Using Blueprints effectively
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效使用蓝图
- en: 'If you already know what a blueprint is, imagine for a moment that you do not.
    As we are building out our application and trying to structure our code base in
    a logical and maintainable pattern, we realize that we need to constantly pass
    around our `app` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经知道什么是蓝图，那么请暂时想象一下您不知道。当我们构建应用程序并试图以逻辑和可维护的模式结构化我们的代码库时，我们意识到我们需要不断传递我们的`app`对象：
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This can become very tedious if we need to make changes to our endpoints. You
    can imagine a scenario where we would need to go update a bunch of separate files
    to duplicate the same change over and over again.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要对我们的端点进行更改，这可能会变得非常繁琐。您可以想象一个场景，我们需要更新多个单独的文件，反复重复相同的更改。
- en: Perhaps more frustratingly, we might end up in a scenario where we have circular
    imports.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可能更令人沮丧的是，我们可能会陷入一个存在循环导入的场景。
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Blueprints solve both of these problems, and allow us to abstract away some
    content so that the component can stand on its own. Returning to the above example,
    we take the common part of the endpoints (`/my`) and add it to the `Blueprint`
    definition.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图解决了这两个问题，并允许我们抽象出一些内容，以便组件可以独立存在。回到上面的例子，我们将端点的公共部分（`/my`）添加到`Blueprint`定义中。
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, we were able to group these routes together into a single blueprint.
    Importantly, this allows us to pull common parts of the URL path (`/my`) to the
    `Blueprint`, which gives us flexibility to make changes in the future.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们能够将这些路由组合成一个单独的蓝图。重要的是，这允许我们将URL路径的公共部分（`/my`）拉到`Blueprint`中，这为我们提供了在将来进行更改的灵活性。
- en: No matter how you decide to organize your file structure, you probably should
    always use blueprints. They make organization easier, and can even be nested.
    Personally, I will only ever use `@app.route` in the most trivial of web applications.
    For any *real* projects, I always attach routes to blueprints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你决定如何组织你的文件结构，你可能应该始终使用蓝图。它们使组织更容易，甚至可以嵌套。我个人只会在我最简单的Web应用中使用`@app.route`。对于任何*真实*的项目，我总是将路由附加到蓝图上。
- en: Blueprint registration
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图注册
- en: 'Just creating our blueprints is not enough. Python would have no way to know
    they exist. We need to import our blueprints and attach them to our application.
    This is done through a simple registration method: `app.blueprint()`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建我们的蓝图是不够的。Python将无法知道它们的存在。我们需要导入我们的蓝图并将它们附加到我们的应用程序上。这是通过一个简单的注册方法完成的：`app.blueprint()`。
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A common “gotcha” is misunderstanding what `blueprint` is doing. Something
    like this will not work as expected:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的“陷阱”是误解了`blueprint`的作用。以下这样的代码不会按预期工作：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: At the instant that we register a Blueprint, everything that was attached to
    it will reattach to the application. That means that anything added to the Blueprint
    *after* the call to `app.blueprint()` will not be applied. In the above example,
    `/oops` will not exist on the application. Therefore, you should try and register
    your blueprints as late as possible.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们注册蓝图的那一刻，所有附加到它的内容都将重新附加到应用程序上。这意味着在调用`app.blueprint()`之后添加到蓝图中的任何内容都不会应用。在上面的例子中，`/oops`将不会存在于应用程序中。因此，你应该尽可能晚地注册你的蓝图。
- en: '**TIP**'
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'I think it is super convenient to always name blueprint variables `bp`. When
    I open a file, I automatically know what `bp` means. Some people may find it helpful
    to name their variable more meaningful: `user_bp` or `auth_bp`. For me, I would
    rather keep them consistent in the files I am always looking at, and just rename
    them at import: `from user import bp as user_bp`.'
  id: totrans-126
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我认为始终将蓝图变量命名为`bp`非常方便。当我打开一个文件时，我自动就知道`bp`代表什么。有些人可能觉得将变量命名得更有意义更有帮助：`user_bp`或`auth_bp`。对我来说，我更愿意在我总是查看的文件中保持一致性，并在导入时重命名它们：`from
    user import bp as user_bp`。
- en: Blueprint versioning
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝图版本控制
- en: A very powerful and common construct in API design is versioning. Let’s imagine
    that we are developing our book API that will be consumed by customers. They have
    already created their integrations, and perhaps they have been using the API for
    some time already.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在API设计中，版本控制是一个非常强大且常见的结构。让我们想象一下，我们正在开发我们的书籍API，该API将被客户使用。他们已经创建了他们的集成，也许他们已经使用了一段时间的API。
- en: You have some new business requirements, or new features you want to support.
    The only way to accomplish that is to change how a particular endpoint works.
    But, this will break backwards compatibility for the users. This is a dilemma.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些新的业务需求，或者你想要支持的新功能。完成这一点的唯一方法是改变特定端点的工作方式。但这将破坏用户的向后兼容性。这是一个困境。
- en: API designers often solve this problem by versioning their routes. Sanic makes
    this easy by adding a keyword argument to a route definition, or (perhaps more
    usefully) a Blueprint.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: API设计者通常通过版本控制他们的路由来解决此问题。Sanic通过向路由定义添加一个关键字参数或（可能更有用）一个蓝图来简化这一点。
- en: You can learn more about versioning in the User Guide ([https://sanicframework.org/en/guide/advanced/versioning.html](https://sanicframework.org/en/guide/advanced/versioning.html))
    and we will discuss it in more depth in *Chapter 3, Routing and intaking HTTP
    requests*. For now, we will be content to know that our original API design needs
    a modification, and we will see how we can achieve that in the next section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在用户指南中了解更多关于版本控制的信息（[https://sanicframework.org/en/guide/advanced/versioning.html](https://sanicframework.org/en/guide/advanced/versioning.html)），我们将在第
    3 章“路由和接收 HTTP 请求”中更深入地讨论它。现在，我们将满足于知道我们的原始 API 设计需要修改，我们将在下一节中看到我们如何实现这一点。
- en: Grouping blueprints
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组蓝图
- en: As you begin to develop your applications, you might start to see similarities
    between blueprints. Just like we saw that we could pull common parts of routes
    out to the `Blueprint`, we can pull common parts of a `Blueprint` out into a `BlueprintGroup`.
    This provides the same purpose.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始开发你的应用程序时，你可能会开始看到蓝图之间的相似性。就像我们看到了我们可以将路由的公共部分提取到 `Blueprint` 中一样，我们也可以将
    `Blueprint` 的公共部分提取到 `BlueprintGroup` 中。这提供了相同的目的。
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We have now added `/api` to the beginning of every route path defined inside
    of `myinfo` and `somethingelse`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经将 `/api` 添加到了 `myinfo` 和 `somethingelse` 中定义的每个路由路径的开头。
- en: By grouping blueprints, we are condensing our logic and becoming less repetitive.
    In the above example, by adding a prefix to the whole group, we no longer need
    to manage individual endpoints or even Blueprints. We really need to keep the
    nesting possibilities in mind as we design the layout of our endpoints and our
    project structure.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分组蓝图，我们正在压缩我们的逻辑，减少重复。在上面的例子中，通过给整个组添加前缀，我们不再需要管理单个端点或甚至蓝图。我们确实需要在设计端点和项目结构布局时牢记嵌套的可能性。
- en: 'In the last section, we mentioned using versions to provide an easy path towards
    flexibly upgrading our API. Let’s go back to our book tracking application and
    see what this might look like. If you recall our application looked like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们提到了使用版本来提供灵活升级 API 的简单路径。让我们回到我们的图书跟踪应用程序，看看这可能会是什么样子。如果你还记得，我们的应用程序看起来是这样的：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And the `view.py` files:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以及 `view.py` 文件：
- en: '`# ./blueprints/book/view.py`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`# ./blueprints/book/view.py`'
- en: '`bp = Blueprint("book", url_prefix="/book")`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bp = Blueprint("book", url_prefix="/book")`'
- en: '`# ./blueprints/author/view.py`'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`# ./blueprints/author/view.py`'
- en: '`bp = Blueprint("author", url_prefix="/author")`'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bp = Blueprint("author", url_prefix="/author")`'
- en: Let’s imagine the scenario where this API is already deployed and in use by
    customers when our new business requirements come in for a `/v2/books` route.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想这样一个场景：当我们的新业务需求是 `/v2/books` 路由时，这个 API 已经部署并为客户所使用。
- en: 'We add it to our existing architecture, and immediately it is starting to look
    ugly and messy:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其添加到现有的架构中，它立即开始看起来丑陋且杂乱：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s re-factor this. We will not change `./blueprints/author` or `./blueprints/book`,
    just nest them a little deeper. That part of the application is already built
    and we do not want to touch it. But, now that we have learned from our mistake,
    we want to revise our strategy for `/v2` endpoints to look like this:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构这个。我们不会改变 `./blueprints/author` 或 `./blueprints/book`，只是让它们嵌套得深一点。这部分应用程序已经构建好了，我们不想去动它。但是，既然我们已经从错误中吸取了教训，我们想要修改我们的
    `/v2` 端点的策略，使其看起来像这样：
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We just created a new file, `group.py`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个新的文件，`group.py`：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Grouping blueprints is a powerful concept when building complex APIs. It allows
    us to nest Blueprints as deep as we need to, while providing us with both routing
    and organizational control. In this example, notice how we were able to assign
    `version=2` to the group. This means now that every route attached to a Blueprint
    in this group will have a `/v2` path prefix.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建复杂的 API 时，分组蓝图是一个强大的概念。它允许我们根据需要嵌套蓝图，同时为我们提供路由和组织控制。在这个例子中，注意我们是如何将 `version=2`
    分配给组的。这意味着现在，这个组中每个与蓝图关联的路由都将有一个 `/v2` 路径前缀。
- en: Wiring it all up
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接所有组件
- en: As we have learned, creating a pragmatic directory structure leads to predictable
    and easy to navigate source code. Because it is predictable to us as developers,
    it is also predictable for computers to run. Perhaps we can use this to our advantage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，创建一个实用的目录结构会导致可预测且易于导航的源代码。因为对我们开发者来说是可预测的，对计算机运行来说也是可预测的。也许我们可以利用这一点。
- en: 'Earlier we discussed one of the problems we often encounter when trying to
    expand our application from the single file structure: circular imports. We can
    solve this well with our blueprints, but it still leaves us wondering about what
    to do with things that we might want to attach at the application level (such
    as middleware, listeners, and signals). Let’s take a look at those use cases now.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们讨论了在尝试将应用程序从单文件结构扩展时经常遇到的一个问题：循环导入。我们可以用我们的蓝图很好地解决这个问题，但这仍然让我们对在应用程序级别可能想要附加的东西（如中间件、监听器和信号）感到困惑。现在让我们看看这些用例。
- en: Controlled imports
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制导入
- en: It is generally preferred to break code up into modules using nested directories
    and files that helps us both logically think about our code, but also navigate
    to it. This does not come without a cost. What happens when there are two modules
    that are interdependent? This will cause a circular import exception, and our
    Python application will crash. We need to not only think about how to logically
    organize our code, but also how different parts of the code can be imported and
    used in other locations.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们更倾向于使用嵌套目录和文件将代码拆分成模块，这有助于我们逻辑上思考我们的代码，同时也便于导航。但这并非没有代价。当有两个相互依赖的模块时会发生什么？这将导致循环导入异常，我们的Python应用程序将崩溃。我们需要不仅考虑如何逻辑上组织我们的代码，还要考虑代码的不同部分如何在其他位置导入和使用。
- en: 'Consider the following example. First, create a file called `./server.py` like
    this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下示例。首先，创建一个名为`./server.py`的文件，如下所示：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Second, create a second file called `./services/db.py`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，创建一个名为`./services/db.py`的第二个文件。
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This example illustrates the problem. When we run our application, we need `Sanic(__file__)`
    to run before `Sanic.get_app()`. But, we need to import `.services.db` so that
    it can attach to our application. Which file evaluates first? Since the Python
    interpreter will run instructions sequentially, we need to make sure that we instantiate
    the `Sanic()` object before importing the `db` module.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了问题。当我们运行我们的应用程序时，我们需要在`Sanic.get_app()`之前运行`Sanic(__file__)`。但是，我们需要导入`.services.db`以便它能够附加到我们的应用程序上。哪个文件先评估？由于Python解释器将按顺序执行指令，我们需要确保在导入`db`模块之前实例化`Sanic()`对象。
- en: 'This will work:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效：
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'But, it sort of looks ugly and non-Pythonic. Indeed, if you run tools like
    `flake8` you will start to notice that your environment does not really like this
    pattern so much either. It breaks the normal practice of placing imports at the
    top of the file. Learn more about this anti-pattern here: [https://www.flake8rules.com/rules/E402.html](https://www.flake8rules.com/rules/E402.html).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，它看起来有点丑陋，也不符合Python的风格。确实，如果你运行像`flake8`这样的工具，你将开始注意到你的环境也不太喜欢这种模式。它打破了在文件顶部放置导入的正常做法。在这里了解更多关于这种反模式的信息：[https://www.flake8rules.com/rules/E402.html](https://www.flake8rules.com/rules/E402.html)。
- en: You may decide that you do not care, and that is perfectly okay. Remember, we
    are in this to find the solution that works for your application. Before we make
    the decision, however, let’s look at some other alternatives.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能觉得这并不重要，这是完全可以接受的。记住，我们做这件事是为了找到适合你应用程序的解决方案。然而，在我们做出决定之前，让我们看看一些其他的替代方案。
- en: 'We could have a single “startup” file that will be a controlled set of import
    ordering:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以有一个单一的“启动”文件，这将是一个受控的导入顺序集合：
- en: '[PRE28]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, instead of running `sanic server:app` we want to point our server to the
    new `startup.py`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不想运行`sanic server:app`，而是想将我们的服务器指向新的`startup.py`。
- en: '[PRE29]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let’s keep looking for an alternative.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续寻找替代方案。
- en: '**TIP**'
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `Sanic.get_app()` construct is a very useful pattern to get access to your
    app instance without having to pass it around by import. This is a very helpful
    step in the right direction, and you can learn more about it in the User Guide.
    https://sanicframework.org/en/guide/basics/app.html#app-registry
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`Sanic.get_app()`结构是一个非常有用的模式，可以在不通过导入传递的情况下访问你的应用程序实例。这是朝着正确方向迈出的一个非常有帮助的步骤，你可以在用户指南中了解更多关于它的信息。[https://sanicframework.org/en/guide/basics/app.html#app-registry](https://sanicframework.org/en/guide/basics/app.html#app-registry)'
- en: Factory pattern
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工厂模式
- en: We are going to move our application creation into a factory pattern. You may
    be familiar with this if you come from Flask as many examples and tutorials use
    a similar construct. The main reason for doing this here is that we want to setup
    our application for good development practices in the future. It also will ultimately
    solve the circular import problem. Later on down the line in Chapter 9, we will
    talk about testing. In the absence of a nice factory, testing will become much
    more difficult.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把应用程序创建移动到工厂模式。如果你来自Flask，你可能熟悉这个概念，因为许多示例和教程都使用了类似的构造。在这里这样做的主要原因是我们希望为未来的良好开发实践设置我们的应用程序。这最终也将解决循环导入问题。在第九章后面，我们将讨论测试。如果没有好的工厂，测试将变得非常困难。
- en: We need to create a new file `./utilities/app_factory.py`, and redo our `./server.py`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的文件`./utilities/app_factory.py`，并重新做我们的`./server.py`。
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As you can see, our new factory will create the `app` instance, and attach some
    blueprints to it. We specifically are allowing for the factory to override the
    blueprints that it will use. Perhaps this is unnecessary and we could instead
    hard-code them in all the time. But, I like the flexibility that this provides
    us, and find it helpful later on down the road when I want to start testing my
    application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的新工厂将创建`app`实例，并将一些蓝图附加到它上。我们特别允许工厂覆盖它将使用的蓝图。也许这并不必要，我们完全可以一直将它们硬编码。但我喜欢这种灵活性，并且发现它在以后的道路上很有帮助，当我想要开始测试我的应用程序时。
- en: One problem that might jump out at you is that it requires our modules to have
    a global `bp` variable. While I mentioned that is standard practice for me, it
    might not work in all scenarios.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会跳出一个问题，那就是它要求我们的模块有一个全局的`bp`变量。虽然我提到这是我的标准做法，但它可能并不适用于所有场景。
- en: Autodiscovery
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动发现
- en: The Sanic User Guide gives us another idea in the “How to…” section. See https://sanicframework.org/en/guide/how-to/autodiscovery.html.
    It suggests we create an `autodiscover` utility that will handle some of the importing
    for us, and also have the benefit of automatically attaching blueprints. Remember
    how I said I like predictable folder structures? We are about to take advantage
    of this pattern.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Sanic用户指南在“如何做…”部分给了我们另一个想法。见 https://sanicframework.org/en/guide/how-to/autodiscovery.html。它建议我们创建一个`autodiscover`工具，该工具将为我们处理一些导入，并且还有自动附加蓝图的好处。记得我曾经说过我喜欢可预测的文件夹结构吗？我们即将利用这个模式。
- en: 'Let’s create `./utilities/autodiscovery.py`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`./utilities/autodiscovery.py`：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This file closely matches what the User Guide suggests ([https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py](https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py)).
    Noticeably absent from the code presented there is the idea of recursion. If you
    look up the function in the User Guide, you will see that it includes the ability
    to recursively search through our source code looking for `Blueprint` instances.
    While convenient, in the application that we are building we want the express
    control provided by having to declare every blueprint’s location. Quoting Tim
    Peters, *The Zen of Python*, again:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件与用户指南中建议的内容非常相似（[https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py](https://sanicframework.org/en/guide/how-to/autodiscovery.html#utility.py)）。值得注意的是，那里展示的代码中缺少递归的概念。如果你在用户指南中查找该函数，你会看到它包括递归搜索我们的源代码以查找`Blueprint`实例的能力。虽然很方便，但在我们正在构建的应用程序中，我们希望通过声明每个蓝图的位置来获得明确控制。再次引用Tim
    Peters的《Python之禅》：
- en: Explicit is better than implicit.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 明确优于隐晦。
- en: What the autodiscover tool does is allow us to pass locations to modules, and
    hands the task of importing them over to the application. After loading the module,
    it will inspect it any Blueprints. The last thing it will handle is automatically
    registering the discovered Blueprints to our application instance.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 自动发现工具的作用是允许我们将位置传递给模块，并将导入它们的任务交给应用程序。加载模块后，它将检查任何蓝图。最后，它将自动将发现的蓝图注册到我们的应用程序实例中。
- en: 'Now, our `server.py` looks like this:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`server.py`看起来是这样的：
- en: '[PRE32]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**TIP**'
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this example, we are using the import paths as strings. We just as easily
    could import the modules here, and pass those objects since the `autodiscover`
    utility works with both module objects and strings. We prefer strings though since
    it will keep the annoying circular import exceptions away.
  id: totrans-191
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用字符串作为导入路径。我们同样可以在这里导入模块，并传递这些对象，因为`autodiscover`工具既适用于模块对象也适用于字符串。我们更喜欢字符串，因为它可以避免讨厌的循环导入异常。
- en: Another thing to keep in mind is that this autodiscover tool could be used for
    a module containing middleware or listeners. The given example is still fairly
    simplistic, and will not cover all use cases. How, for example, should we handle
    deeply nested Blueprint groups? This is a great opportunity for you to experiment,
    and I highly encourage you to spend some time playing with application structure
    and the autodiscover tool to figure out what works best for you.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的事情是，这个自动发现工具可以用于包含中间件或监听器的模块。给出的例子仍然相当简单，不会涵盖所有用例。例如，我们应该如何处理深度嵌套的蓝图组？这是一个很好的机会让你进行实验，我强烈鼓励你花些时间玩转应用程序结构和自动发现工具，以找出最适合你的方法。
- en: Running our application
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: Now that we have laid our application foundations, we are almost ready to run
    our server. We are going to make one small change to `server.py` to include a
    small little utility to run at startup to show us what routes are registered.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经奠定了应用程序的基础，我们几乎准备好运行我们的服务器了。我们将在`server.py`中进行一个小改动，以包含一个在启动时运行的实用工具，显示已注册的路由。
- en: '[PRE33]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can head over to the GitHub repository [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02)
    to see the full source code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以前往GitHub仓库[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/02)查看完整的源代码。
- en: 'We can now start our application for the first time. Remember, this is going
    to be our pattern:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以首次启动我们的应用程序。记住，这将是我们的模式：
- en: '[PRE34]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We should see something like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似这样的情况：
- en: '[PRE35]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Hooray!
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 欢呼！
- en: 'And now, for the tempting part. What does our code actually do? Head over to
    your favorite web browser and open: [http://127.0.0.1:7777/book](http://127.0.0.1:7777/book).
    It might not be much to look at yet, but you should see some JSON data. Next,
    try going to `/author` and `/v2/book`. You should now see the content that we
    created above. Feel free to play around with these routes adding to them. Every
    time you do, you should see your changes reflected in the web browser.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了最诱人的部分。我们的代码实际上做了什么？打开你最喜欢的网络浏览器并访问：[http://127.0.0.1:7777/book](http://127.0.0.1:7777/book)。现在可能看起来不多，但你应该能看到一些JSON数据。接下来，尝试访问`/author`和`/v2/book`。你现在应该能看到我们上面创建的内容。你可以随意玩转这些路由，向它们添加内容。每次你这样做，你都应该在浏览器中看到你的更改。
- en: Our journey into web application development as officially begun.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正式开始了网络应用程序开发的旅程。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We have looked at the important impact of some of the early decisions we make
    about setting up our environment and project organization. We can—and should—constantly
    adapt our environment and application to meet changing needs. We used `pdm` to
    leverage some of the newest tools for running our server in a well-defined and
    isolated environment.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经审视了我们关于设置环境和项目组织所做的一些早期决策的重要影响。我们可以——并且应该——不断地调整我们的环境和应用程序以满足不断变化的需求。我们使用了`pdm`来利用运行服务器的新工具，在定义良好且隔离的环境中运行。
- en: In our example, we then started to build our application. Perhaps we were too
    hasty when we added our `/book` route, because we quickly realized that we needed
    the endpoint to perform differently. Rather than breaking the application for
    existing users, we simply created a new group of blueprints that will be the beginning
    of a `/v2` of our API. By nesting and grouping blueprints, we are setting the
    application up for future flexibility and development maintainability. Going forward,
    let’s stick to this pattern as much as possible.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们随后开始构建我们的应用程序。也许我们在添加`/book`路由时过于仓促，因为我们很快意识到我们需要端点以不同的方式执行。为了避免破坏现有用户的程序，我们简单地创建了一个新的蓝图组，这将是我们的API
    `/v2`的开始。通过嵌套和分组蓝图，我们正在为未来的灵活性和开发可维护性设置应用程序。从现在开始，让我们尽可能坚持这个模式。
- en: We also examined a few alternative approaches for organizing our application
    logic. These early decisions will impact the import ordering and shape the look
    of the application. We decided to adopt a factory method that will help us in
    the future when we start to test the application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还考察了几种组织应用程序逻辑的替代方法。这些早期的决策将影响导入顺序并塑造应用程序的外观。我们决定采用一种工厂方法，这将在我们开始测试应用程序时对我们有所帮助。
- en: 'With the basic application structure decided, we will begin in the next chapter
    to explore the most important aspect of a web server and framework: handling the
    request/response cycle. We know that we will use blueprints, but it is time to
    dive in and look more closely at what we can do with Sanic routing and handlers.
    In this chapter, there was a taste of it with API versioning. In the next chapter
    we will also look at routing more generally, and try to understand some strategies
    for designing application logic within a web API.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 基本应用结构确定后，我们将在下一章开始探讨网络服务器和框架最重要的方面：处理请求/响应周期。我们知道我们将使用蓝图，但现在是我们深入探究使用 Sanic
    路由和处理器的可能性的时候了。在这一章中，我们已经对 API 版本化有所了解。在下一章中，我们还将更广泛地探讨路由，并尝试理解一些在 Web API 中设计应用程序逻辑的策略。
