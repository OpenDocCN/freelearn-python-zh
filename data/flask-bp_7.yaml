- en: Chapter 7. Dinnerly – Recipe Sharing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。Dinnerly - 食谱分享
- en: In this chapter, we will explore modern methods of the so-called social login,
    where we allow a user to authenticate with our application using derived credentials
    from another web application. Currently, the most widespread third-party applications
    that support this mechanism are, somewhat unsurprisingly, Twitter and Facebook.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨所谓的社交登录的现代方法，其中我们允许用户使用来自另一个网络应用程序的派生凭证对我们的应用程序进行身份验证。目前，支持这种机制的最广泛的第三方应用程序是Twitter和Facebook。
- en: While there exist several other widespread web applications that support this
    type of integration (for example, LinkedIn, Dropbox, Foursquare, Google, and GitHub
    to name a few), the majority of your potential users will be in possession of
    at least one account on either Twitter or Facebook, the two major social networks
    of this time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然存在其他几种广泛的网络应用程序支持这种集成类型（例如LinkedIn、Dropbox、Foursquare、Google和GitHub等），但您潜在用户的大多数将至少拥有Twitter或Facebook中的一个帐户，这两个是当今主要的社交网络。
- en: To do this, we will be adding, configuring, and deploying the Flask-OAuthlib
    extension. This extension abstracts out some of the usual difficulties and roadblocks
    that are often experienced when dealing with an OAuth-based authorization flow
    (which we will explain shortly) and includes functionalities to quickly set up
    the defaults required to negotiate the provider / consumer / resource owner token
    exchange. As a bonus, the extension will provide us with the ability to interact
    with the authenticated APIs of these remote services on behalf of the user.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将添加、配置和部署Flask-OAuthlib扩展。该扩展抽象出了通常在处理基于OAuth的授权流程时经常遇到的一些困难和障碍（我们将很快解释），并包括功能以快速设置所需的默认值来协商提供者/消费者/资源所有者令牌交换。作为奖励，该扩展将为我们提供与用户代表的这些远程服务的经过身份验证的API进行交互的能力。
- en: First OAuth
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先是OAuth
- en: 'Let''s get this out of the way: OAuth can be somewhat difficult to grasp. Adding
    to this fire is the fact that the OAuth framework/protocol has gone through a
    major revision in the last few years. Version 2 was published in 2012, but due
    to a variety of factors, there are some web applications that continue to implement
    the OAuth v1 protocol.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先把这个搞清楚：OAuth可能有点难以理解。更加火上浇油的是，OAuth框架/协议在过去几年中经历了一次重大修订。第2版于2012年发布，但由于各种因素，仍有一些网络应用程序继续实施OAuth
    v1协议。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: OAuth 2.0 is not backwards compatible with OAuth 1.0\. Moreover, OAuth 2.0 is
    less of a formal protocol specification and more of an authorization framework
    specification. Most OAuth 2.0 implementations across modern web applications are
    not interoperable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 2.0与OAuth 1.0不兼容。此外，OAuth 2.0更像是授权框架规范，而不是正式的协议规范。现代网络应用程序中大多数OAuth 2.0实现是不可互操作的。
- en: 'For the sake of simplicity, we''ll view a high-level overview of the general
    terms, vocabulary, and functionalities of the OAuth 2.0 authorization framework.
    Version 2 is the simpler of the two specifications and with good reason: one of
    the design goals of the latter was to make client implementations simpler and
    less prone to error. Much of the terminology is similar, if not identical, across
    the two versions.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们将概述OAuth 2.0授权框架的一般术语、词汇和功能。第2版是两个规范中更简单的一个，这是有道理的：后者的设计目标之一是使客户端实现更简单，更不容易出错。大部分术语在两个版本中是相似的，如果不是完全相同的。
- en: While the intricacies of the OAuth authorization exchanges will mostly be abstracted
    away from us thanks to the Flask-OAuthlib extension and underlying Python packages
    that handle the real grunt work, a cursory level of knowledge regarding the OAuth
    authorization framework (specifically the most common authorization grant flows)
    for web applications and the typical implementations will be beneficial.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然由于Flask-OAuthlib扩展和处理真正繁重工作的底层Python包，OAuth授权交换的复杂性大部分将被我们抽象化，但对于网络应用程序和典型实现的OAuth授权框架（特别是最常见的授权授予流程）的一定水平的了解将是有益的。
- en: Why use OAuth?
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用OAuth？
- en: One of the great sins of proper online personal security is the reuse of access
    credentials across different services. This opens you up to a variety of security-related
    issues if the credentials you use for one application are compromised. You now
    have the possibility of being compromised on all the applications where this same
    set of credentials are used and the only way to fix this post facto would be to
    go and change your credentials everywhere.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 适当的在线个人安全的一个重大错误是在不同服务之间重复使用访问凭证。如果您用于一个应用的凭证被泄露，这将使您面临各种安全问题。现在，您可能会在使用相同一组凭证的所有应用程序上受到影响，唯一的后期修复方法是去到处更改您的凭证。
- en: Even worse than reusing the credentials across the different services is having
    a user willingly turn over their credentials for a third-party service, say Twitter,
    to some other service, say Foursquare, so that the latter can make requests to
    Twitter on behalf of the user (for example, posting check-ins to their Twitter
    timeline). While not immediately obvious, one of the problems with this approach
    is that the credentials must be stored in plain text.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 比在不同服务之间重复使用凭证更糟糕的是，用户自愿将他们的凭证交给第三方服务，比如Twitter，以便其他服务，比如Foursquare，可以代表用户向Twitter发出请求（例如，在他们的Twitter时间轴上发布签到）。虽然不是立即明显，但这种方法的问题之一是凭证必须以明文形式存储。
- en: This situation is not ideal for a variety of reasons, and some of these reasons
    are not things that you, as an application developer, can control.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 出于各种原因，这种情况并不理想，其中一些原因是您作为应用程序开发人员无法控制的。
- en: OAuth, in both version 1 and version 2 of the framework, attempt to solve the
    problem of cross-application shared credentials by creating an open standard for
    API access delegation. The principle goal of OAuth's original design was to ensure
    that a user of application A could delegate access to application B on their behalf
    and also ensure that application B was never in possession of the credentials
    that could compromise the user account on application A.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth在框架的1版和2版中都试图通过创建API访问委托的开放标准来解决跨应用程序共享凭据的问题。OAuth最初设计的主要目标是确保应用程序A的用户可以代表其委托应用程序B访问，并确保应用程序B永远不会拥有可能危害应用程序A用户帐户的凭据。
- en: Note
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While an application in possession of delegated credentials can abuse these
    credentials to perform some unsavory actions, the root credentials have never
    been shared and thus the owner of the account can simply invalidate the delegated
    credentials that have been abused. If the root account credentials had simply
    been given to the third-party application, then this latter could have taken complete
    control of the account by changing all of the primary authentication information
    (username, e-mail, password, and so on), which would effectively hijack the account.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然拥有委托凭据的应用程序可以滥用这些凭据来执行一些不良操作，但根凭据从未被共享，因此帐户所有者可以简单地使被滥用的委托凭据无效。如果根帐户凭据简单地被提供给第三方应用程序，那么后者可以通过更改所有主要身份验证信息（用户名、电子邮件、密码等）来完全控制帐户，从而有效地劫持帐户。
- en: Terminology
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 术语
- en: Most of the confusion about OAuth usage and implementation stems from a misunderstanding
    of the essential vocabulary and terminology that is used to describe the basic
    authorization flow. Even worse, there are several popular web applications that
    have implemented OAuth (in some form or another) and decided to use their own
    vocabulary for portions of the protocol/framework instead of those that have been
    decided upon in the official RFC.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 关于OAuth的使用和实施的大部分混乱源于对用于描述基本授权流的基本词汇和术语的误解。更糟糕的是，有几个流行的Web应用程序已经实施了OAuth（以某种形式），并决定使用自己的词汇来代替官方RFC中已经决定的词汇。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An RFC, or a Request For Comments, is a memorandum-style publication of a document
    or set of documents from the **Internet Engineering Task Force** (**IETF**), which
    is the principal body that governs the open standards on which most of the Internet
    is built upon. RFCs are usually denoted by a numeric code, which uniquely identifies
    them in the IETF. For example, the OAuth 2.0 authorization framework RFC is number
    6749 and can be found in its entirety on the IETF website.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: RFC，或称为请求评论，是来自**互联网工程任务组**（**IETF**）的一份文件或一组文件的备忘录式出版物，IETF是管理大部分互联网建立在其上的开放标准的主要机构。RFC通常由一个数字代码表示，该代码在IETF中唯一标识它们。例如，OAuth
    2.0授权框架RFC编号为6749，可以在IETF网站上完整找到。
- en: 'To help alleviate some of this confusion, here''s a simplified description
    of what most of the essential components of an OAuth implementation mean in plain
    English:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助减轻一些混乱，以下是OAuth实施中大多数基本组件的简化描述：
- en: '**Consumer**: This is the application that is making the request on behalf
    of the user. In our particular case, the Dinnerly application is considered the
    consumer. Confusingly enough, the official OAuth specification refers to the client
    instead of the consumer. Even more confusingly, some applications use the consumer
    *and* client terms. Usually, a consumer is represented by a key and secret that
    must be kept in your application configuration, and they must be well-guarded.
    If a malicious entity were to gain access to your consumer key and secret, they
    could then pretend to be your application when making authorized requests with
    the third-party provider.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费者：这是代表用户发出请求的应用程序。在我们的特定情况下，Dinnerly应用程序被视为消费者。令人困惑的是，官方的OAuth规范是指客户端而不是消费者。更令人困惑的是，一些应用程序同时使用消费者和客户端术语。通常，消费者由必须保存在应用程序配置中的密钥和秘钥表示，并且必须受到良好的保护。如果恶意实体获得了您的消费者密钥和秘钥，他们就可以在向第三方提供商发出授权请求时假装成您的应用程序。
- en: '**Provider**: This is the third-party service that the consumer is attempting
    to access on behalf of a user. In our case, Twitter and Facebook are the providers
    that we will be using for our application signing in. Other examples of providers
    could be GitHub, LinkedIn, Google, and any other service that offers a grant-based
    OAuth authorization flow.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提供者**：这是消费者代表用户试图访问的第三方服务。在我们的情况下，Twitter和Facebook是我们将用于应用程序登录的提供者。其他提供者的例子可能包括GitHub、LinkedIn、Google以及任何其他提供基于授权流的OAuth授权的服务。'
- en: '**Resource owner**: This is the entity that is capable of consenting to the
    delegated resource access. In most cases, the resource owner is an end user of
    both the applications (for example, Twitter and Dinnerly) in question.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源所有者**：这是有能力同意委托资源访问的实体。在大多数情况下，资源所有者是所涉及应用程序的最终用户（例如，Twitter和Dinnerly）。'
- en: '**Access token(s)**: This is a credential that the client uses to make requests
    to the provider on behalf of a user in order to access the protected resources.
    The token can be linked with a particular permission scope, which limits what
    resources it can access. Additionally, the access token may expire after a certain
    amount of time determined by the provider; at which point the use of a refresh
    token is required to obtain a new, valid access token.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问令牌**：这是客户端代表用户向提供者发出请求以访问受保护资源的凭据。令牌可以与特定的权限范围相关联，限制其可以访问的资源。此外，访问令牌可能会在由提供者确定的一定时间后过期；此时需要使用刷新令牌来获取新的有效访问令牌。'
- en: '**Authorization server**: This is the server (usually represented by a URI
    endpoint) that is responsible for issuing access tokens to the consumer application
    after the resource owner has consented to delegating their access.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权服务器**：这是负责在资源所有者同意委托他们的访问权限后向消费者应用程序发放访问令牌的服务器（通常由URI端点表示）。'
- en: '**Flow type**: The OAuth 2.0 framework provides outlines of several different
    flows for authorization. Some are best suited for command-line applications where
    no web browser is present, others are better suited for native mobile applications,
    and some have also been created to connect devices that have very limited access
    capabilities (for example, if you want to delegate your Twitter account privileges
    to your Internet-enabled toaster). The authorization flow that we are most interested
    in, unsurprisingly, is the one designed for basic web browser-based access.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流程类型**：OAuth 2.0框架提供了几种不同的授权流程概述。有些最适合于没有网络浏览器的命令行应用程序，有些更适合于原生移动应用程序，还有一些是为连接具有非常有限访问能力的设备而创建的（例如，如果您想将Twitter帐户特权委托给您的联网烤面包机）。我们最感兴趣的授权流程，不出所料，是为基本基于网络浏览器的访问而设计的。'
- en: 'With the preceding list of vocabulary, you should now be able to comprehend
    the official abstract protocol flow that is listed in the official OAuth 2.0 RFC:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述词汇表，您现在应该能够理解官方OAuth 2.0 RFC中列出的官方抽象协议流程：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following description of the steps listed in the flow diagram has been
    taken from RFC 6749 and made a bit more relevant for our purposes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从RFC 6749中列出的流程图中列出的步骤的描述，并且为了我们的目的更加相关：
- en: The client (or consumer) requests the resource owner to grant an authorization.
    This is usually where the user is redirected to a login screen on the remote provider,
    say Twitter, where it is explained that the client application wishes to access
    the protected resources that you control. On agreeing to this, we enter the next
    step.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端（或消费者）请求资源所有者授予授权。这通常是用户被重定向到远程提供者的登录屏幕的地方，比如Twitter，在那里解释了客户端应用程序希望访问您控制的受保护资源。同意后，我们进入下一步。
- en: The client receives an authorization grant from the resource owner (user), which
    is a temporary credential representing the resource owner's authorization for
    the particular type of authorization flow that the provider has implemented. This
    is typically an authorization code grant flow for most web applications.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端从资源所有者（用户）那里收到授权凭证，这是代表资源所有者对提供者实施的特定类型授权流程的授权的临时凭证。对于大多数Web应用程序来说，这通常是授权代码授予流程。
- en: Once the client has received the grant credentials, it sends them to the authorization
    server to request an authentication token on behalf of the resource owner.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦客户端收到授权凭证，它会将其发送到授权服务器，以代表资源所有者请求认证令牌。
- en: The authorization server validates the grant credentials and authenticates the
    client making the request. Upon fulfilling these two requirements, the server
    returns a valid authentication token to the client that can then be used to make
    authenticated requests to the provider on behalf of the user.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 授权服务器验证授权凭证并对发出请求的客户端进行身份验证。在满足这两个要求后，服务器将有效的认证令牌返回给客户端，然后客户端可以使用该令牌代表用户向提供者发出经过认证的请求。
- en: So what's wrong with OAuth 1.0?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 那么OAuth 1.0有什么问题呢？
- en: 'In theory: not much. In practice: it''s somewhat difficult and extremely error
    prone to be implemented correctly for the consumer.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上：没有太多问题。实际上：对于消费者来说，正确实施起来有些困难，而且极易出错。
- en: The primary difficulties in implementing and using an OAuth 1.0 provider revolve
    around consumer applications not performing the required cryptographic request
    signing properly. The arguments and parameters had to be collected from the query
    string in addition to the request body and various OAuth parameters (for example,
    `oauth_nonce`, `oauth_signature_method`, `oauth_timestamp`, and so on) and then
    URL-encoded (meaning that non-URL safe values are specially encoded to ensure
    they are transmitted correctly). Once the key/value pairs have been encoded, they
    must then be sorted lexicographically by key (remember, the encoded key and not
    the raw key value) and then concatenated to a single string using typical URL
    parameter separators. Additionally, the HTTP verb that is to be used to submit
    the request (for example, `GET` or `POST`) must be prepended to the string that
    we just created and then followed by the URL that the request will be sent to.
    Finally, the signing key is to be constructed from the consumer secret key and
    an OAuth token secret and then passed to an implementation of the HMAC-SHA1 hashing
    algorithm along with the payload that we constructed earlier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施和使用OAuth 1.0提供程序时的主要困难围绕着消费者应用程序未能正确执行所需的加密请求签名。参数和参数必须从查询字符串中收集，还必须从请求正文和各种OAuth参数（例如，`oauth_nonce`，`oauth_signature_method`，`oauth_timestamp`等）中收集，然后进行URL编码（意味着非URL安全值被特殊编码以确保它们被正确传输）。一旦键/值对已被编码，它们必须按键的字典顺序进行排序（记住，编码后的键而不是原始键值），然后使用典型的URL参数分隔符将它们连接成一个字符串。此外，要提交请求的HTTP动词（例如，`GET`或`POST`）必须预先添加到我们刚刚创建的字符串中，然后跟随请求将被发送到的URL。最后，签名密钥必须由消费者秘钥和OAuth令牌秘钥构建，然后传递给HMAC-SHA1哈希算法的实现，以及我们之前构建的有效载荷。
- en: Assuming that you got all this correct (and it's incredibly easy to make a simple
    mistake such as sorting your keys alphabetically instead of lexicographically),
    only then would the request be considered valid. Moreover, in the event of a miscalculated
    signature, there's no simple way to determine where the mistake was made.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您已经全部正确理解了这些（很容易出现简单错误，比如按字母顺序而不是按字典顺序对密钥进行排序），那么请求才会被视为有效。此外，在发生签名错误的情况下，没有简单的方法确定错误发生的位置。
- en: One of the reasons that this rather complex process is required for OAuth 1.0
    is that a design goal of this protocol was that it should function across insecure
    protocols such as HTTP, but still ensure that the request has not been modified
    by a malicious party along the way.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 1.0需要这种相当复杂的过程的原因之一是，该协议的设计目标是它应该跨不安全的协议（如HTTP）运行，但仍确保请求在传输过程中没有被恶意方修改。
- en: OAuth 2.0, while not universally accepted as a worthy successor to OAuth 1.0,
    has greatly simplified the implementation by simply requiring that all the communication
    occur over HTTPS.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管OAuth 2.0并不被普遍认为是OAuth 1.0的值得继任者，但它通过简单要求所有通信都在HTTPS上进行，大大简化了实现。
- en: Three-legged authorization
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三步授权
- en: In the so-called three-legged authorization flow for the OAuth framework, an
    application (`consumer`) makes requests on behalf of a user (`resource owner`)
    in order to access the resources present on a remote service (`provider`).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在OAuth框架的所谓三步授权流程中，应用程序（`consumer`）代表用户（`resource owner`）发出请求，以访问远程服务（`provider`）上的资源。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There also exists a two-legged authorization flow, which is primarily used for
    application-to-application access where a resource owner is not required to consent
    to delegated access to the protected resources. Twitter, for example, implements
    both two-legged and three-legged authorization flows, but the former does not
    have the same access scope as the latter in terms of resource access and imposed
    API rate limits.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还存在一个两步授权流程，主要用于应用程序之间的访问，资源所有者不需要同意委托访问受保护资源。例如，Twitter实现了两步和三步授权流程，但前者在资源访问和强制API速率限制方面没有与后者相同的访问范围。
- en: This is what Flask-Social will allow us to implement for Twitter and Facebook,
    the two providers that we have chosen, where our application will act as the consumer.
    The end result will be that our Dinnerly application will be in possession of
    access tokens for both the providers that will allow us to make authenticated
    API requests on behalf of our users (the resource owners), which is necessary
    to implement any sort of cross-social network posting functionality.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Flask-Social将允许我们为Twitter和Facebook实现的功能，我们选择的两个提供者，我们的应用程序将作为消费者。最终结果将是我们的Dinnerly应用程序将拥有这两个提供者的访问令牌，这将允许我们代表我们的用户（资源所有者）进行经过身份验证的API请求，这对于实现任何跨社交网络发布功能是必要的。
- en: Setting up the application
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用程序
- en: 'Once again, let''s set up a barebones folder for our project along with the
    associated virtual environment in order to isolate our application dependencies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们为我们的项目设置一个基本的文件夹，以及相关的虚拟环境，以隔离我们的应用程序依赖关系：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once created, let''s install the basic packages that we will require including
    Flask itself along with the Flask-OAuthlib extension, our trusty friend Flask-SQLAlchemy,
    and Flask-Login, which we used in a previous chapter:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建后，让我们安装我们需要的基本包，包括Flask本身以及Flask-OAuthlib扩展，我们值得信赖的朋友Flask-SQLAlchemy和我们在之前章节中使用过的Flask-Login：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We''ll utilize our trusty Blueprint-based application structure that has served
    us so well in the past chapters to ensure a solid foundation. For now, we''ll
    have a single users Blueprint where the OAuth handling will be taken care of:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用我们在过去章节中表现良好的Blueprint应用程序结构，以确保坚实的基础。现在，我们将有一个单一的用户Blueprint，其中将处理OAuth处理：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once the very basic folder and file structure has been established, let''s
    use an application factory to create our main application object. For now, all
    we''re going to do is instantiate a very simple application with a Flask-SQLAlchemy
    database connection in `application/__init__.py`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了非常基本的文件夹和文件结构，让我们使用应用程序工厂来创建我们的主应用程序对象。现在，我们要做的只是在`application/__init__.py`中实例化一个非常简单的应用程序，其中包含一个Flask-SQLAlchemy数据库连接：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To ensure that we can actually run the application and create the database,
    let''s use the simple `run.py` and `database.py` scripts that we will place sibling
    to the `application` folder. The contents of `run.py` are similar to what we used
    in the previous chapters:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们实际上可以运行应用程序并创建数据库，让我们使用简单的`run.py`和`database.py`脚本，将它们放在`application`文件夹的同级目录。`run.py`的内容与我们在之前章节中使用的内容类似：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Later on in this chapter, we will explore alternative methods of running the
    Dinnerly application, most of which are more well-suited to production deployments.
    The Werkzeug development server that is invoked on `app.run()` is highly unsuitable
    for anything other than local development.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将探讨运行Dinnerly应用程序的替代方法，其中大部分更适合生产部署。在`app.run()`上调用的Werkzeug开发服务器非常不适合除了本地开发之外的任何其他用途。
- en: 'Our `database.py` is, quite similarly, simple and to the point:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`database.py`同样简单明了：
- en: '[PRE6]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will allow us to create the relevant schema in our database based on our
    model definitions, which have not yet been declared; running the script right
    now will essentially be a no op. This is okay! We have much to do before this
    becomes useful.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们根据我们的模型定义在数据库中创建相关的模式，但我们还没有声明模型；现在运行脚本基本上不会有任何操作。这没关系！在这变得有用之前我们还有很多工作要做。
- en: Declaring our models
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明我们的模型
- en: As is the case with most applications, we begin by declaring our data models
    and any relationships that they require. We will, of course, require a `User`
    model, which will be the centerpiece of the OAuth authorization and token exchange.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数应用程序一样，我们首先声明我们的数据模型和它们需要的任何关系。当然，我们需要一个`User`模型，它将是OAuth授权和令牌交换的核心。
- en: As you may recall from our brief overview of the OAuth terminology and the basic
    three-legged authorization grant flow, the access tokens are what allow a client
    (our Dinnerly application) to query resources on a remote service provider (for
    example, Twitter or Facebook). As we need these tokens to make requests to the
    listed service providers, we're going to want to store them somewhere so that
    we can use them without having the user reauthenticate for every action; this
    would be quite tedious.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能还记得我们对OAuth术语和基本的三步授权授予流程的简要概述，访问令牌是允许客户端（我们的Dinnerly应用程序）查询远程服务提供商（例如Twitter或Facebook）资源的东西。由于我们需要这些令牌来向列出的服务提供商发出请求，我们希望将它们存储在某个地方，以便我们可以在没有用户为每个操作重新进行身份验证的情况下使用它们；这将非常繁琐。
- en: 'Our `User` model will be quite similar to the `User` models that we have used
    previously (although we removed a few attributes to simplify things a bit), and
    we''ll place it in the obvious location of `application/users/models.py`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`User`模型将与我们以前使用过的`User`模型非常相似（尽管我们删除了一些属性以简化事情），我们将把它放在`application/users/models.py`的明显位置：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we have not included anything regarding a password. As the intent
    of this application is to require either Facebook or Twitter to create an account
    and log in, we've eschewed the typical username/password credentials combination
    in favor of delegating authentication to one of these third-party services.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有包括有关密码的任何内容。由于此应用程序的意图是要求使用Facebook或Twitter创建帐户并登录，我们放弃了典型的用户名/密码凭据组合，而是将身份验证委托给这些第三方服务之一。
- en: 'To help with our user session management, we''re going to reuse the Flask-Login
    extension that we explored in a previous chapter. In case you''ve forgotten, one
    of the basic requirements of the extension is to have four methods declared on
    whatever model you are using to represent an authenticated user: `is_authenticated`,
    `is_active`, `is_anonymous`, and `get_id`. Let''s append the most basic versions
    of these methods to our already declared `User` model:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们的用户会话管理，我们将重用我们在之前章节中探讨过的Flask-Login扩展。以防您忘记，扩展的基本要求之一是在用于表示经过身份验证的用户的任何模型上声明四种方法：`is_authenticated`，`is_active`，`is_anonymous`和`get_id`。让我们将这些方法的最基本版本附加到我们已经声明的`User`模型中：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, you may have noticed that there are no declared attributes on the `User`
    model for our Twitter or Facebook access tokens. Adding these attributes are an
    option, of course, but we're going to use a slightly different approach that requires
    more up-front complexity and will allow more providers to be added without polluting
    our `User` model more than necessary.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可能已经注意到`User`模型上没有声明的Twitter或Facebook访问令牌属性。当然，添加这些属性是一个选择，但我们将使用稍微不同的方法，这需要更多的前期复杂性，并且将允许添加更多提供程序而不会过度污染我们的`User`模型。
- en: 'Our approach will center on the idea of creating multiple one-to-one data relationships
    between a user and the various provider types that will be represented by their
    own models. Let''s add our first provider model in `application/users/models.py`
    to the store:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法将集中在创建用户与各种提供程序类型之间的多个一对一数据关系的想法上，这些关系将由它们自己的模型表示。让我们在`application/users/models.py`中添加我们的第一个提供程序模型到存储：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding model declares a foreign key relationship to the `User` model
    via the `user_id` attribute, and the additional fields (other than the primary
    key) store the requisite OAuth token and secret to make authenticated requests
    to the Twitter API on behalf of the user. Additionally, we store the Twitter `screen_name`
    and `twitter_user_id` to give us the option of using this value as username for
    the related user. Keeping the Twitter user ID around helps us match users on Twitter
    with local Dinnerly users (as `screen_name` can be changed but the IDs are immutable).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的模型通过`user_id`属性声明了与`User`模型的外键关系，除了主键之外的其他字段存储了进行身份验证请求所需的OAuth令牌和密钥，以代表用户访问Twitter
    API。此外，我们还存储了Twitter的`screen_name`和`twitter_user_id`，以便将此值用作相关用户的用户名。保留Twitter用户ID有助于我们将Twitter上的用户与本地Dinnerly用户匹配（因为`screen_name`可以更改，但ID是不可变的）。
- en: 'Once the `TwitterConnection` model is defined, let''s add the relationship
    to the `User` model so that we can access the associated credentials via the `twitter`
    attribute:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`TwitterConnection`模型被定义，让我们将关系添加到`User`模型中，以便我们可以通过`twitter`属性访问相关的凭据：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This establishes a very simple one-to-one relationship between `User` and `TwitterConnection`.
    The `uselist=False` argument ensures that the configured attribute will refer
    to a scalar value instead of a list, which would be the default for a one-to-many
    relationship.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`User`和`TwitterConnection`之间建立了一个非常简单的一对一关系。`uselist=False`参数确保配置的属性将引用标量值，而不是列表，这将是一对多关系的默认值。
- en: 'Accordingly, once we''ve obtained a user object instance, we can access the
    associated `TwitterConnection` model data via `user.twitter`. If no credentials
    have been attached, then this will return `None`; if there are attached credentials,
    we can access the subattributes just as you expect: `user.twitter.oauth_token`,
    `user.twitter.screen_name`, and others.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦我们获得了用户对象实例，我们就可以通过`user.twitter`访问相关的`TwitterConnection`模型数据。如果没有附加凭据，那么这将返回`None`；如果有附加凭据，我们可以像预期的那样访问子属性：`user.twitter.oauth_token`，`user.twitter.screen_name`等。
- en: 'Let''s do the same for the equivalent `FacebookConnection` model, which has
    similar attributes. The difference from the `TwitterConnection` model is that
    Facebook OAuth only requires a single token (instead of a combination token and
    secret), and we can choose to store the Facebook-specific ID and name (whereas
    in the other model, we stored the Twitter `screen_name`):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为等效的`FacebookConnection`模型做同样的事情，它具有类似的属性。与`TwitterConnection`模型的区别在于Facebook
    OAuth只需要一个令牌（而不是组合令牌和密钥），我们可以选择存储Facebook特定的ID和名称（而在其他模型中，我们存储了Twitter的`screen_name`）：
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we''ve established this model, we''ll want to introduce the relationship
    to our `User` model as we did for the `TwitterConnection` model previously:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们建立了这个模型，我们就会想要像之前为`TwitterConnection`模型一样，将这种关系引入到我们的`User`模型中：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The functionality and usage of the preceding `facebook` attribute of a `user`
    instance is identical to that of the `twitter` attribute that we defined previously.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`user`实例的前述`facebook`属性的功能和用法与我们之前定义的`twitter`属性完全相同。'
- en: Handling OAuth in our views
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的视图中处理OAuth
- en: 'With our basic user and OAuth connection models established, let''s start constructing
    the required Flask-OAuthlib objects to handle the authorization grant flows. The
    first step is to initialize the extension in the usual way for our application
    factory. While we''re at it, let''s also initialize the Flask-Login extension,
    which we will use to manage authenticated sessions for our logged-in users:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们基本的用户和OAuth连接模型，让我们开始构建所需的Flask-OAuthlib对象来处理授权授予流程。第一步是以我们应用程序工厂的通常方式初始化扩展。在此期间，让我们也初始化Flask-Login扩展，我们将用它来管理已登录用户的认证会话：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now that we have an `oauth` object available to us, we can instantiate separate
    OAuth remote application clients for each service provider. Let''s place these
    in our `application/users/views.py module`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个`oauth`对象可供我们使用，我们可以为每个服务提供商实例化单独的OAuth远程应用程序客户端。让我们将它们放在我们的`application/users/views.py模块`中：
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, there seems to be quite a lot going on during the instantiation of these
    OAuth objects, but most of it is simply telling the generic OAuth connection library
    where the service provider URI endpoints exist for various portions of the three-legged
    OAuth authorization grant flow. There are, however, a few argument values that
    you''ll need to fill in yourself: the consumer keys (for Twitter) and the application
    keys (for Facebook). To obtain these, you must register a new OAuth client application
    on the respective services, and you can do so here:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在实例化这些OAuth对象时似乎有很多事情要做，但其中大部分只是告诉通用的OAuth连接库各种三方OAuth授权授予流程的服务提供商URI端点在哪里。然而，有一些参数值需要您自己填写：消费者密钥（对于Twitter）和应用程序密钥（对于Facebook）。要获得这些值，您必须在相应的服务上注册一个新的OAuth客户端应用程序，您可以在这里这样做：
- en: 'Twitter: [https://apps.twitter.com/app/new](https://apps.twitter.com/app/new),
    and then navigate to the **Keys** and **Access Tokens** tab to obtain the consumer
    key and consumer secret.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Twitter: [https://apps.twitter.com/app/new](https://apps.twitter.com/app/new)，然后转到**Keys**和**Access
    Tokens**选项卡以获取消费者密钥和消费者密钥。'
- en: 'Facebook: [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)
    and agree to the terms of service and register your account for application development.
    Once there, select the website type of application to add and follow the instructions
    to generate the required application ID and application secret.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Facebook: [https://developers.facebook.com/apps/](https://developers.facebook.com/apps/)，同意服务条款并注册您的帐户进行应用程序开发。然后，选择要添加的网站类型应用程序，并按照说明生成所需的应用程序ID和应用程序密钥。'
- en: In the case of Facebook, we requested the ability to publish to the wall of
    the user in question via the `publish_actions` value of the scope key in the `request_token_params`
    argument of the `remote_app` method of the OAuth object that we've created. This
    is enough for our purposes, but if you want to interact with the Facebook API
    more than simply pushing status updates, you'll need to request the correct set
    of permissions. The Facebook documentation has additional information and guidelines
    on how third-party application developers should use the permission scope values
    to perform different actions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在Facebook的情况下，我们通过`request_token_params`参数的`scope`键的`publish_actions`值请求了发布到相关用户的墙上的权限。这对我们来说已经足够了，但如果您想与Facebook
    API互动不仅仅是推送状态更新，您需要请求正确的权限集。Facebook文档中有关于第三方应用程序开发者如何使用权限范围值执行不同操作的额外信息和指南。
- en: Once you've obtained the requisite keys and secrets, insert them where we left
    placeholders in the preceding `oauth` remote application client configurations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您获得了所需的密钥和密钥，就将它们插入到前述`oauth`远程应用程序客户端配置中留下的占位符中。
- en: Now, we need to have our application handle the various portions of the authorization
    flow that require users to request a grant token from the service provider. We
    also need our application to handle the callback routes that the service provider
    will redirect to with the various OAuth tokens and secrets once the process is
    completed so that we can persist these values to our database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要让我们的应用程序处理授权流程的各个部分，这些部分需要用户从服务提供商那里请求授予令牌。我们还需要让我们的应用程序处理回调路由，服务提供商将在流程完成时重定向到这些路由，并携带各种OAuth令牌和密钥，以便我们可以将这些值持久化到我们的数据库中。
- en: 'Let''s whip up a users Blueprint to namespace the various routes in `application/users/views.py`,
    and while we''re at it, import a few utilities from Flask and Flask-Login to help
    our integration:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个用户Blueprint来对`application/users/views.py`中的各种路由进行命名空间处理，同时，我们还可以从Flask和Flask-Login中导入一些实用程序来帮助我们的集成：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As per the requirements of Flask-Login, we need to define a `user_loader` function
    that will fetch a user from our database by the ID:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Flask-Login的要求，我们需要定义一个`user_loader`函数，它将通过ID从我们的数据库中获取用户：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In a very similar fashion, Flask-OAuthlib requires us to define a method (per
    service, of course) that will act as a token getter; while Flask-Login needs `user_loader`
    to fetch users from our database by the ID. The OAuthlib needs to have a function
    that fetches the OAuth token(s) of the currently logged-in user. If no user is
    currently logged in, then the method should return `None`, indicating that we
    should probably start an authorization grant flow to obtain the required tokens:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以非常相似的方式，Flask-OAuthlib要求我们定义一个方法（每个服务一个）作为令牌获取器；而Flask-Login需要`user_loader`通过ID从数据库中获取用户。OAuthlib需要一个函数来获取当前登录用户的OAuth令牌。如果当前没有用户登录，则该方法应返回`None`，表示我们可能需要开始授权授予流程来获取所需的令牌：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we used the `current_user` proxy object that Flask-Login provides
    us with in order to access the object of the currently authenticated user, and
    then we call the `is_authenticated` method that we defined in our `User` model
    earlier in the chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了Flask-Login提供的`current_user`代理对象来访问当前经过身份验证的用户的对象，然后我们调用了在本章前面定义的`User`模型中的`is_authenticated`方法。
- en: 'Following this, we need to define the routes and handlers to kick off the three-legged
    authorization grant. Our first users Blueprint route will handle attempted logins
    using Twitter as the third-party provider:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义路由和处理程序来启动三方授权授予。我们的第一个用户蓝图路由将处理使用Twitter作为第三方提供商的尝试登录：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The preceding route first determines if the current user is already authenticated
    and redirects them to the main `recipes.index` route handler if they are.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的路由首先确定当前用户是否已经经过身份验证，并在他们已经经过身份验证时将其重定向到主`recipes.index`路由处理程序。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We've set up some redirects for the `recipes.index` route, which we have yet
    to define. If you intend on testing out this part of the application before we
    set these up, you'll have to either add a stub page to that Blueprint route or
    change it to something else.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经为`recipes.index`路由设置了一些重定向，但我们还没有定义。如果您打算在我们设置这些之前测试应用程序的这一部分，您将不得不在蓝图路由中添加一个存根页面，或者将其更改为其他内容。
- en: If the user is not already authenticated, we initiate the authorization grant
    via the `twitter.authorize` method invocation. This will initiate the OAuth flow,
    and upon successful completion of the grant (assuming that the user consents to
    allow our application to access to their third-party protected resources), Twitter
    will invoke a GET request to the callback URL that we provided as the first argument.
    This request will contain the OAuth tokens and any additional information that
    they have deemed useful (such as `screen_name`) in the query arguments, and it's
    then up to us to handle the request as we would any other and extract out the
    information that we require.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户尚未经过身份验证，我们通过`twitter.authorize`方法调用来启动授权授予。这将启动OAuth流程，并在授权成功完成后（假设用户同意允许我们的应用程序访问他们的第三方受保护资源），Twitter将调用GET请求到我们提供的回调URL作为第一个参数。这个请求将包含OAuth令牌和他们认为有用的任何其他信息（如`screen_name`）在查询参数中，然后由我们来处理请求，提取出我们需要的信息。
- en: 'To this end, we define a `twitter_authorized` route handler whose sole purpose
    is to extract out OAuth tokens and secrets so that we can persist them in our
    database and then use the `login_user` function from Flask-Login to create an
    authenticated user session for our Dinnerly application:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们定义了一个`twitter_authorized`路由处理程序，其唯一目的是提取出OAuth令牌和密钥，以便我们可以将它们持久化到我们的数据库中，然后使用Flask-Login的`login_user`函数为我们的Dinnerly应用程序创建一个经过身份验证的用户会话：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the preceding route handler, we first attempt to extract the OAuth data from
    the grant flow, which is made available to us in `twitter.authorized_response()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的路由处理程序中，我们首先尝试从授权流中提取OAuth数据，这些数据可以通过`twitter.authorized_response()`提供给我们。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If the user decided to decline the authorization grant request, then `twitter.authorized_response()`
    will return `None`. Handling this error scenario is left as an exercise for the
    reader.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户决定拒绝授权请求，那么`twitter.authorized_response()`将返回`None`。处理这种错误情况留给读者作为一个练习。
- en: 'Hint: A Flash message and redirect to a page describing what happened are probably
    a good start!'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：闪存消息和重定向到描述发生情况的页面可能是一个很好的开始！
- en: Once the OAuth tokens have been extracted from the OAuth data response of the
    grant flow, we check the database to see if a user with this token already exists.
    If this is the case, then the user has already created an account on Dinnerly
    and simply wishes to reauthenticate. (Perhaps as they are using a different browser,
    thus they do not have the previously generated session cookie available.)
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从授权流的OAuth数据响应中提取出OAuth令牌，我们就会检查数据库，看看是否已经存在具有此令牌的用户。如果是这种情况，那么用户已经在Dinnerly上创建了一个帐户，并且只希望重新验证身份。（也许是因为他们正在使用不同的浏览器，因此他们没有之前生成的会话cookie可用。）
- en: If no user in our system has the OAuth token assigned to them, then we create
    a new `User` record with the data that we've just received. Once this is persisted
    to the SQLAlchemy session, we log them in using the `login_user` function from
    Flask-Login.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们系统中没有用户被分配了OAuth令牌，那么我们将使用我们刚刚收到的数据创建一个新的`User`记录。一旦这个记录被持久化到SQLAlchemy会话中，我们就使用Flask-Login的`login_user`函数将他们登录。
- en: 'While we focused on the route handlers and Twitter OAuth authorization grant
    flow here, the process for Facebook is very similar. Our users Blueprint gets
    two more routes attached, which will handle the logins that want to use Facebook
    as the third-party service provider:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里专注于路由处理程序和Twitter OAuth授权授予流程，但Facebook的流程非常相似。我们的用户蓝图附加了另外两个路由，这些路由将处理希望使用Facebook作为第三方服务提供商的登录：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We then define the `facebook_authorized` handler, which will receive the OAuth
    token parameters via the query arguments, in a very similar manner to the `twitter_authorized`
    route handler:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义了`facebook_authorized`处理程序，它将以与`twitter_authorized`路由处理程序非常相似的方式通过查询参数接收OAuth令牌参数：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: One nontrivial difference between this handler and the one that we previously
    defined for Twitter is the invocation of the `facebook.get('/me')` method. Once
    we've performed the authorization grant exchange, the facebook OAuth object is
    able to make authenticated requests to the Facebook API on behalf of the user.
    We will use this newfound ability to query for some basic details regarding the
    user who delegated the authorization credentials, such as the Facebook ID and
    name of the user in question. Once obtained, we store this information along with
    the OAuth credentials for the newly created user.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理程序与我们之前为Twitter定义的处理程序之间的一个不容忽视的区别是调用`facebook.get('/me')`方法。一旦我们执行了授权授予交换，facebook
    OAuth对象就能够代表用户对Facebook API进行经过身份验证的请求。我们将利用这一新发现的能力来查询有关委托授权凭据的用户的一些基本细节，例如该用户的Facebook
    ID和姓名。一旦获得，我们将存储这些信息以及新创建用户的OAuth凭据。
- en: Creating recipes
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建食谱
- en: 'Now that we''ve allowed users to create authenticated accounts on Dinnerly
    with Twitter or Facebook, we need to create something worth sharing on these social
    networks! We''ll keep things very simple with a `Recipe` model, which we''ll create
    in the `application/recipes/models.py` module:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经允许用户使用Twitter或Facebook在Dinnerly上创建经过身份验证的帐户，我们需要在这些社交网络上创建一些值得分享的东西！我们将通过`application/recipes/models.py`模块创建一个非常简单的`Recipe`模型：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There''s nothing incredibly special about the `Recipe` model that we''ve just
    defined; it has a title, ingredients, and instructions. Each recipe is owned by
    a single user, and we''ve created the requisite relationship-based field and our
    `ForeignKey` entry in the model so that our data is properly linked together in
    the usual relational database way. There are a few fields to store the typical
    things that you''d expect in any recipe: `title`, `ingredients`, and `instructions`.
    As the point of Dinnerly is to share snippets of recipes on various social networks,
    we should add a method that will help generate a short summary of a recipe and
    limit it to fewer than 140 characters (to appease the Twitter API):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的`Recipe`模型并没有什么特别之处；它有一个标题、配料和说明。每个食谱都归属于一个用户，我们已经创建了必要的基于关系的字段和我们模型中的`ForeignKey`条目，以便我们的数据以通常的关系数据库方式正确链接在一起。有一些字段用于存储任何食谱中你所期望的典型内容：`title`、`ingredients`和`instructions`。由于Dinnerly的目的是在各种社交网络上分享食谱片段，我们应该添加一个方法来帮助生成食谱的简短摘要，并将其限制在140个字符以下（以满足Twitter
    API的要求）：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding `summarize` method will return the title of `Recipe` if the title
    contains fewer than 140 characters. If it contains more than 140 characters, we
    will split the string into a list using a space as the delimiter, use `rsplit`
    (which starts at the end of the string instead of the beginning as `str.split`
    does), and then append the ellipsis.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前面定义的`summarize`方法将返回`Recipe`的标题，如果标题包含的字符少于140个。如果包含的字符超过140个，我们将使用空格作为分隔符将字符串拆分成列表，使用`rsplit`（它从字符串的末尾而不是`str.split`所做的开头开始），然后附加省略号。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `summarize` method that we just defined will only reliably work for ASCII
    text. There exist Unicode characters that may resemble a space as represented
    in the ASCII character set, but our method will not split on these correctly as
    it's expecting a different character.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义的`summarize`方法只能可靠地处理ASCII文本。存在一些Unicode字符，可能与ASCII字符集中的空格相似，但我们的方法不会正确地在这些字符上拆分。
- en: Posting recipes to Twitter and Facebook
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将食谱发布到Twitter和Facebook
- en: 'Upon posting a new recipe, we''d like to automatically post the summary to
    the services that have been connected for the user in question. There are, of
    course, many ways to go about this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布新食谱时，我们希望自动将摘要发布到已连接到该用户的服务。当然，有许多方法可以实现这一点：
- en: In our yet-to-be defined recipe view handlers, we could call the respective
    OAuth connection object methods after the successful creation/committing of a
    `Recipe` object instance
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们尚未定义的食谱视图处理程序中，我们可以在成功创建/提交`Recipe`对象实例后调用相应的OAuth连接对象方法。
- en: The user could be required to visit a particular URI (or submit a form with
    particular data), which would trigger the cross-posting
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户可能需要访问特定的URI（或提交具体数据的表单），这将触发跨发布。
- en: When the `Recipe` object is committed to the database, we could listen for the
    `after_insert` event emitted by SQLAlchemy and push out our summary to the connected
    social networks then
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`Recipe`对象提交到数据库时，我们可以监听SQLAlchemy发出的`after_insert`事件，并将我们的摘要推送到连接的社交网络上。
- en: As the first two options are relatively simple, somewhat boring, and we haven't
    explored SQLAlchemy events at all in this book so far, the third option is the
    one that we'll implement.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前两个选项相对简单，有点无聊，并且到目前为止我们在这本书中还没有探讨过SQLAlchemy事件，所以第三个选项是我们将要实现的。
- en: SQLAlchemy events
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLAlchemy事件
- en: One of the less well-known features of SQLAlchemy is the event API, which publishes
    several core and ORM-level hooks that will allow us to attach to and execute arbitrary
    code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的一个不太为人所知的特性是事件API，它发布了几个核心和ORM级别的钩子，允许我们附加和执行任意代码。
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The event system is very similar in spirit (if not in implementation) to the
    Blinker dispatching system that we saw in a previous chapter. Instead of creating,
    publishing, and consuming blinker-based signals, we are simply going to listen
    for events published by the SQLAlchemy subsystem.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件系统在精神上（如果不是在实现上）与我们在前一章中看到的Blinker分发系统非常相似。我们不是创建、发布和消费基于blinker的信号，而是简单地监听SQLAlchemy子系统发布的事件。
- en: Most applications will never need to implement handlers for the various events
    that are published. They are usually the purview of plugins and extensions to
    SQLAlchemy, which allow the developer to augment the functionality of their application
    without requiring them to write large amounts of boilerplate connector / adapter
    / interface logic to interact with these plugins or extensions.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序永远不需要实现对已发布事件的处理程序。它们通常是SQLAlchemy的插件和扩展的范围，允许开发人员增强其应用程序的功能，而无需编写大量的样板连接器/适配器/接口逻辑来与这些插件或扩展进行交互。
- en: 'The SQLAlchemy events that we are interested in are categorized under ORM Events.
    Even in this restricted umbrella of events (there are a plethora of additional
    published core events that we won''t even discuss here), there are still quite
    a few events. What most developers are interested in, generally, are the mapper-level
    events:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们感兴趣的SQLAlchemy事件被归类为ORM事件。即使在这个受限的事件范围内（还有大量其他已发布的核心事件，我们甚至不会在这里讨论），仍然有相当多的事件。大多数开发人员通常感兴趣的是映射器级别的事件：
- en: '`before_insert`: This receives an object instance before an `INSERT` statement
    is emitted corresponding to that instance'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before_insert`：在发出与该实例对应的`INSERT`语句之前，此函数接收一个对象实例'
- en: '`after_insert`: This receives an object instance after an `INSERT` statement
    is emitted corresponding to that instance'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_insert`：在发出与该实例对应的`INSERT`语句之后，此函数接收一个对象实例'
- en: '`before_update`: This receives an object instance before an `UPDATE` statement
    is emitted corresponding to that instance'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before_update`：在发出与该实例对应的`UPDATE`语句之前，此函数接收一个对象实例'
- en: '`after_update`: This receives an object instance after an `UPDATE` statement
    is emitted corresponding to that instance'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_update`：在发出与该实例对应的`UPDATE`语句之后，此函数接收一个对象实例'
- en: '`before_delete`: This receives an object instance before a `DELETE` statement
    is emitted corresponding to that instance'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`before_delete`：在发出与该实例对应的`DELETE`语句之前，此函数接收一个对象实例'
- en: '`after_delete`: This receives an object instance after a `DELETE` statement
    has been emitted corresponding to that instance'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`after_delete`：在发出与该实例对应的`DELETE`语句之后，此函数接收一个对象实例'
- en: Each named event is emitted along with the SQLAlchemy `Mapper` object (which
    defines the correlation of `class` attributes to database columns), Connection
    object that was/will be used to execute the query, and target object instance
    that was being acted on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 每个命名事件都会与SQLAlchemy的`Mapper`对象一起发出（该对象定义了`class`属性与数据库列的对应关系），将被用于执行查询的连接对象，以及被操作的目标对象实例。
- en: Generally, the idea is that the developer would use the raw connection object
    to execute simple SQL statements (for example, increment a counter, add a row
    to a logging table, and so on). We, however, will use the `after_insert` event
    to publish a summary of our recipe to both Twitter and Facebook.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，开发人员会使用原始连接对象来执行简单的SQL语句（例如，增加计数器，向日志表添加一行等）。然而，我们将使用`after_insert`事件来将我们的食谱摘要发布到Twitter和Facebook。
- en: 'To make things a bit simpler from an organizational standpoint, let''s move
    the Twitter and Facebook OAuth client object instantiations to their own module
    in `application/users/services.py`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从组织的角度简化事情，让我们将Twitter和Facebook的OAuth客户端对象实例化移到它们自己的模块中，即`application/users/services.py`中：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In moving this functionality to a separate module, we can avoid some of the
    more nasty possibilities for circular imports. Now, in the `application/recipes/models.py`
    module, we will add the following function that will be invoked when the `after_insert`
    event is emitted and identified by the `listens_for` decorator:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将此功能移动到一个单独的模块中，我们可以避免一些更糟糕的循环导入可能性。现在，在`application/recipes/models.py`模块中，我们将添加以下函数，当发出`after_insert`事件并由`listens_for`装饰器标识时将被调用：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our listener function only requires a target (the recipe instance that was acted
    on) for our purposes. We get the recipe summary thanks to our previously written
    `Recipe.summarize()` method, and then use the post method of both OAuth client
    objects (accounting for the different endpoint URIs and expected payload formats
    for each service) to create a status update across whichever services the user
    who posted the recipe has connected to.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的监听函数只需要一个目标（被操作的食谱实例）。我们通过之前编写的`Recipe.summarize()`方法获得食谱摘要，然后使用OAuth客户端对象的`post`方法（考虑到每个服务的不同端点URI和预期的负载格式）来创建用户已连接到的任何服务的状态更新。
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The error-handling code for the function that we defined here is somewhat inefficient;
    each API may return different HTTP error codes, and it's quite possible that one
    service may accept the post while the other would refuse it for some as yet unknown
    reason. Handling the various failure modes that may arise when interacting with
    multiple remote third-party APIs is complex and could be the subject of a book
    itself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里定义的函数的错误处理代码有些低效；每个API可能返回不同的HTTP错误代码，很可能一个服务可能会接受帖子，而另一个服务可能会因为某种尚未知的原因而拒绝它。处理与多个远程第三方API交互时可能出现的各种故障模式是复杂的，可能是一本书的主题。
- en: Finding common friends
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 寻找共同的朋友
- en: A very typical feature of most modern, socially-oriented web applications is
    the ability to find users on an application that you are already familiar with
    on some other application social network. This helps you to bootstrap any sort
    of friendship/follower model that you may want to implement for your application.
    Nobody likes to have zero friends on a new platform, so why not connect with the
    friends that you've already made in other places?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代的社交型网络应用程序的一个非常典型的特性是能够在你已经熟悉的应用程序上找到其他社交网络上的用户。这有助于您为应用程序实现任何类型的友谊/关注者模型。没有人喜欢在新平台上没有朋友，所以为什么不与您在其他地方已经交过的朋友联系呢？
- en: This is relatively easy to accomplish by finding the intersection of accounts
    that the user is following on Twitter and users that currently exist in the Dinnerly
    application.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 通过找到用户在Twitter上正在关注的账户和当前存在于Dinnerly应用程序中的用户的交集，这相对容易实现。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An intersection C of two sets, A and B, is the set of common elements that exist
    in A and B and no other elements.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合A和B的交集C是存在于A和B中的共同元素的集合，没有其他元素。
- en: If you don't already understand the basic concepts of mathematical sets and
    the operations that can be performed on them, a primer on the naïve set theory
    should be on your reading list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还不了解数学集合的基本概念以及可以对其执行的操作，那么应该在您的阅读列表中加入一个关于天真集合论的入门课程。
- en: 'We start by adding a route handler that an authenticated user can query to
    find their list of common friends in our `application/users.views.py` module:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先添加一个路由处理程序，经过身份验证的用户可以查询该处理程序，以查找他们在`application/users.views.py`模块中的共同朋友列表。
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We used simple `abort()` calls in the preceding method, but there's nothing
    stopping you from creating templates that are rendered with additional information
    to help the end user understand why a certain operation failed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的方法中，我们使用了简单的`abort()`调用，但是没有阻止您创建模板，这些模板会呈现附加信息，以帮助最终用户理解为什么某个操作失败了。
- en: The preceding view function is wrapped with the `login_required` decorator from
    our trusty Flask-Login extension to ensure that any request to this route is made
    by an authenticated user. An unauthenticated user would not be able to find common
    friends on Dinnerly for somewhat obvious reasons.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的视图函数使用了我们可靠的Flask-Login扩展中的`login_required`装饰器进行包装，以确保对此路由的任何请求都是由经过身份验证的用户发出的。未经身份验证的用户由于某种明显的原因无法在Dinnerly上找到共同的朋友。
- en: We then ensure that the authenticated user has connected a set of Twitter OAuth
    credentials and pluck out the `twitter_user_id` value so that we can properly
    construct the Twitter API request, which requires either the ID or `screen_name`
    of the user in question.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们确保经过身份验证的用户已连接了一组Twitter OAuth凭据，并取出`twitter_user_id`值，以便我们可以正确构建Twitter
    API请求，该请求要求用户的ID或`screen_name`。
- en: Tip
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While `screen_name` might seem slightly easier to debug and reason about than
    a long numeric identifier, remember that it is possible for a person to update
    `screen_name` on Twitter at any time. If you wanted to rely on this value, you
    would need to write some code to verify and update the locally stored `screen_name`
    value if and when it does change on the remote service.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`screen_name`可能比长数字标识符更容易调试和推理，但请记住，一个人随时可以在Twitter上更新`screen_name`。如果您想依赖这个值，您需要编写一些代码来验证并在远程服务上更改时更新本地存储的`screen_name`值。
- en: Once the `GET` request is made for the Twitter IDs of the people that the account
    follows on the remote service, we parse this result and construct a list of integers
    that we can then pass to a SQLAlchemy query on the User-mapped class. Now that
    we've obtained a list of users, we can pass these to our view (which we will not
    provide an implementation of—this is left as an exercise for the reader).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对远程服务上账户关注的人的Twitter ID进行了`GET`请求，我们解析这个结果并构建一个整数列表，然后将其传递给User-mapped类上的SQLAlchemy查询。现在我们已经获得了一个用户列表，我们可以将这些传递给我们的视图（我们不会提供实现，这留给读者作为练习）。
- en: Of course, finding common friends is only half of the equation. Once we've found
    users that are our friends on Twitter, the next step is to follow them on Dinnerly
    as well. For this, we need to add a (minimal!) social component to our application,
    similar to what we implemented in a previous chapter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，找到共同的朋友只是方程的一半。一旦我们在Twitter上找到了我们的朋友，下一步就是在Dinnerly上也关注他们。为此，我们需要向我们的应用程序添加一个（最小的！）社交组件，类似于我们在上一章中实现的内容。
- en: This will require adding a few database-related entities, which we can do using
    our normal procedure of updating/adding the relevant models and then recreating
    the database schema, but we'll take this opportunity to explore a more formalized
    method of tracking schema-related changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要添加一些与数据库相关的实体，我们可以使用更新/添加相关模型的常规程序，然后重新创建数据库模式，但我们将利用这个机会来探索一种更正式的跟踪模式相关变化的方法。
- en: Interlude – database migrations
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插曲 - 数据库迁移
- en: 'For quite some time in the world of application development, we used a variety
    of tools to track and record code-related changes over time. Generally, these
    fall under the umbrella of version control systems, or VCS, and there are many
    of them to choose from: Git, Mercurial, Subversion, Perforce, Darcs, and several
    others. Each system functions in a slightly (or not so slightly) different manner,
    but they all have the same goal of preserving point-in-time snapshots of a codebase
    (or portions of a codebase, depending on the tool being used) so that it can be
    recreated at a later time.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序开发的世界中，我们使用各种工具来跟踪和记录随时间变化的代码相关变化。一般来说，这些都属于版本控制系统的范畴，有很多选择：Git、Mercurial、Subversion、Perforce、Darcs等。每个系统的功能略有不同，但它们都有一个共同的目标，即保存代码库的时间点快照（或代码库的部分，取决于所使用的工具），以便以后可以重新创建它。
- en: One aspect of web applications that is generally difficult to capture and track
    is the current state of the database. In the past, we made do by storing entire
    SQL snapshots along with the application code and would instruct developers to
    drop and recreate their database. The next level of improvement on this would
    be the creation of small SQL-based scripts that should be run in a particular
    order to gradually build up the underlying schema progressively in such a way
    that when modifications are required, another small SQL-based script is added
    to the list.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序的一个方面通常难以捕捉和跟踪是数据库的当前状态。过去，我们通过存储整个SQL快照以及应用程序代码来解决这个问题，并指示开发人员删除并重新创建他们的数据库。对此的下一级改进将是创建一些小型基于SQL的脚本，应按特定顺序逐渐构建底层模式，以便在需要修改时，将另一个小型基于SQL的脚本添加到列表中。
- en: While this latter method is quite flexible (it can work for almost any type
    of application that depends on a relational database), a slight abstraction that
    could leverage the functionality of the SQLAlchemy object-relational model that
    we already use would be beneficial.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然后一种方法非常灵活（它几乎可以适用于任何依赖关系数据库的应用程序），但是稍微抽象化，可以利用我们已经使用的SQLAlchemy对象关系模型的功能，这将是有益的。
- en: Alembic
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Alembic
- en: Such an abstraction already exists, and it's called Alembic. This library, by
    the same author of SQLAlchemy, allows us to create and manage the changesets that
    correspond to the schema modifications that are required to accommodate the modifications
    that are made to our SQLAlchemy data models.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的抽象已经存在，它叫做Alembic。这个库由SQLAlchemy的相同作者编写，允许我们创建和管理对应于我们的SQLAlchemy数据模型所需的模式修改的变更集。
- en: 'As with most of the libraries that we''ve discussed over the course of this
    book, it has been wrapped in a Flask extension as Flask-Alembic. Let''s install
    it in our current virtual environment:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 和我们在本书中讨论过的大多数库一样，Flask-Alembic也被封装成了一个Flask扩展。让我们在当前的虚拟环境中安装它：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As most of Flask-Alembic''s functionalities can and should be controlled via
    CLI scripts, the package includes hooks to enable a Flask-Script command. So let''s
    install this as well:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数Flask-Alembic的功能可以和应该通过CLI脚本来控制，所以该软件包包括了启用Flask-Script命令的钩子。因此，让我们也安装这个功能：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will create our `manage.py` Python script to control our CLI commands as
    sibling to our `application/ package` and ensure that it includes the db hooks
    to integrate Flask-Alembic:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建我们的`manage.py` Python脚本来控制我们的CLI命令，作为我们`application/包`的兄弟，并确保它包含用于集成Flask-Alembic的db钩子：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have both of these extensions installed, we need to configure the
    Flask-Alembic extension so that it''s aware of our application object. We will
    do this in the usual way in our application factory function:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了这两个扩展，我们需要配置Flask-Alembic扩展，以便它了解我们的应用对象。我们将在应用程序工厂函数中以通常的方式来做这个：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s capture the current database schema that is described by the SQLAlchemy
    models that we defined in our application:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们捕获当前数据库模式，这个模式是由我们在应用程序中定义的SQLAlchemy模型描述的：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will create two new files in the `migrations/ folder` (which was created
    the first time this command was run), one of which will be named with a bunch
    of random characters followed by `_initial_schema.py`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`migrations/文件夹`中创建两个新文件（在第一次运行此命令时创建），其中一个文件将以一堆随机字符开头，后跟`_initial_schema.py`。
- en: Note
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The random-looking characters are actually not so random: they are hash-based
    identifiers that help the migration system behave in a more predictable manner
    when there can be multiple developers working on migrations for different portions
    of the application all at the same time, which is somewhat typical these days.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来随机的字符实际上并不那么随机：它们是基于哈希的标识符，可以帮助迁移系统在多个开发人员同时为应用程序的不同部分工作迁移时以更可预测的方式运行，这在当今是相当典型的。
- en: The other file, `script.py.mako`, is the template that Alembic will utilize
    to generate these automatic revision summaries when the command is invoked. This
    script can be edited to suit your needs, but don't remove any of the template
    `(${foo})` variables!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个文件`script.py.mako`是Alembic在调用命令时将使用的模板，用于生成这些自动修订摘要。这个脚本可以根据您的需要进行编辑，但不要删除任何模板`${foo}`变量！
- en: 'The generated migration file includes two function definitions: `upgrade()`
    and `downgrade()`. The upgrade function is run when Alembic takes the current
    database revision (which is `None` at this point) and attempts to bring it to
    the target (often the latest) revision. The `downgrade()` function does the same
    but for the opposite direction. Having both is very convenient for rollback-type
    situations, when switching between code branches that contain different sets of
    migrations, and several other edge cases. Many developers ignore the generation
    and testing of downgrade migrations and then sorely regret it at a later date
    in the lifetime of the project.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的迁移文件包括两个函数定义：`upgrade()`和`downgrade()`。当Alembic获取当前数据库修订版（此时为`None`）并尝试将其带到目标（通常是最新）修订版时，将运行升级函数。`downgrade()`函数也是如此，但是方向相反。拥有这两个函数对于回滚类型的情况非常方便，当在包含不同迁移集的代码分支之间切换时，以及其他一些边缘情况。许多开发人员忽略了生成和测试降级迁移，然后在项目的生命周期的后期非常后悔。
- en: 'Your exact migration may look a little bit different based on what relational
    database you''re using, but it should look something similar to this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您使用的关系数据库，您的确切迁移可能会有所不同，但它应该看起来类似于这样：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now, there's quite a lot going on in this script, or at least it seems so. What's
    happening in the `upgrade()` function is the creation of the tables that correspond
    to the model metadata that we've defined in the application and the fields that
    belong to them. Alembic was able to infer what needed to be generated by comparing
    the current model definitions with the currently active database schema and outputting
    the list of commands that are required to synchronize them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个脚本中有很多事情要做，或者至少看起来是这样。`upgrade()`函数中正在发生的是创建与我们在应用程序中定义的模型元数据和属于它们的字段相对应的表。通过比较当前模型定义和当前活动数据库模式，Alembic能够推断出需要生成什么，并输出所需的命令列表来同步它们。
- en: 'Most of the syntax elements should be relatively self-explanatory if you are
    familiar with relational database terminology (columns, primary keys, constraints,
    and so on), and you can read about what they all mean in the Alembic operation
    reference: [http://alembic.readthedocs.org/en/latest/ops.html](http://alembic.readthedocs.org/en/latest/ops.html)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉关系数据库术语（列、主键、约束等），那么大多数语法元素应该相对容易理解，您可以在Alembic操作参考中阅读它们的含义：[http://alembic.readthedocs.org/en/latest/ops.html](http://alembic.readthedocs.org/en/latest/ops.html)
- en: 'With the initial schema migration generated, now it''s time to apply it:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成了初始模式迁移后，现在是应用它的时候了：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This will emit the necessary SQL (based on the generated migration) to the RDBMS
    that you configured in the Flask-SQLAlchemy configuration.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将向您在Flask-SQLAlchemy配置中配置的关系型数据库管理系统发出必要的SQL（基于生成的迁移）。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After this rather lengthy and content-filled chapter, you should feel more at
    ease with OAuth and OAuth-related implementations and general terminology, and
    additionally, the usefulness of database migrations, especially the style of migrations
    produced by Alembic that are synchronized to the table and the constraint metadata
    declared in the application models.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个相当冗长且内容丰富的章节之后，您应该会对OAuth及与OAuth相关的实现和一般术语感到更加放心，此外，数据库迁移的实用性，特别是由Alembic生成的与应用程序模型中声明的表和约束元数据同步的迁移风格。
- en: The chapter started out with an in-depth exploration of the OAuth authorization
    grant flow and terminology—no small feat considering the complex nature of OAuth!
    Once we established a bit of a knowledge baseline, we implemented an application
    that leveraged Flask-OAuthlib to provide users with the ability to create accounts
    and sign in with third-party services such as Twitter and Facebook.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从深入探讨OAuth授权授予流程和术语开始，考虑到OAuth的复杂性，这并不是一件小事！一旦我们建立了一定的知识基础，我们就实现了一个应用程序，利用Flask-OAuthlib为用户提供了创建账户并使用Twitter和Facebook等第三方服务进行登录的能力。
- en: After fleshing out the data handling portions of the example application, we
    then turned our attention to Alembic, the SQLAlchemy data migration toolkit, to
    synchronize the changes in our models with our relational database.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在完善示例应用程序的数据处理部分之后，我们转向了Alembic，即SQLAlchemy数据迁移工具包，以将我们模型中的更改与我们的关系型数据库同步。
- en: The project that we started in this final chapter is a great kick-off point
    for most socially-aware web applications. You are highly encouraged to use the
    knowledge gained in this and the previous chapters to create a modern, highly-tested,
    functional web application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开始的项目对于大多数具有社交意识的网络应用程序来说是一个很好的起点。我们强烈建议您利用本章和前几章学到的知识来创建一个现代、经过高度测试的、功能齐全的网络应用程序。
