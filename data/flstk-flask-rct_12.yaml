- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: In building full-stack web applications, you will more than often want to implement
    a system that allows users to trust you with their sensitive information. As a
    full-stack web developer, it is crucial to understand how to implement robust
    authentication and authorization mechanisms. You need to know how to protect the
    security of user data and the integrity of your application. Imagine you are building
    an e-commerce website that allows users to make online purchases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建全栈Web应用程序时，你通常会希望实现一个系统，让用户信任你处理他们的敏感信息。作为一名全栈Web开发者，了解如何实现强大的身份验证和授权机制至关重要。你需要知道如何保护用户数据的安全和应用程序的完整性。想象一下，你正在构建一个允许用户在线购物的电子商务网站。
- en: If you do not properly authenticate and authorize users, it would be possible
    for someone to gain unauthorized access to the website and place orders using
    someone else’s personal information. This could result in financial loss for the
    legitimate user as well as damage to the reputation of an online business or that
    of your clients.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你未能正确地验证和授权用户，那么有人可能会未经授权访问网站并使用他人的个人信息下订单。这可能导致合法用户的财务损失，并损害在线业务或你的客户的声誉。
- en: Furthermore, if you fail to properly authenticate and authorize users, it could
    also open your web application up to attacks such as SQL injection, where an attacker
    can gain access to sensitive information stored in your database. This could lead
    to the loss of customer data and legal repercussions may be staring you in the
    face.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你未能正确地验证和授权用户，这也可能使你的Web应用程序容易受到诸如SQL注入等攻击，攻击者可以访问存储在数据库中的敏感信息。这可能导致客户数据的丢失，并且可能面临法律后果。
- en: In this chapter, we will delve into the world of web security and explore the
    best practices and techniques for securing Flask web applications. As the famous
    computer scientist Bruce Schneier once said, *Security is a process, not a product*
    ([https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html)).
    This chapter will equip you with the knowledge and skills needed to understand
    the importance of information security and how to implement it in a Flask application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入Web安全的世界，探索保护Flask Web应用程序的最佳实践和技术。正如著名的计算机科学家布鲁斯·施奈尔（Bruce Schneier）曾经说过：“安全是一个过程，而不是一个产品”([https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html](https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html))。本章将为你提供了解信息安全的重要性以及如何在Flask应用程序中实施它的知识和技能。
- en: From understanding the fundamentals of authentication and authorization to managing
    user sessions and creating accounts with secure passwords, this chapter will cover
    the crucial elements of web application security. We will examine the process
    of securing your Flask application and show you how to implement these concepts
    in practice.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 从理解身份验证和授权的基本原理到管理用户会话和创建具有安全密码的账户，本章将涵盖Web应用程序安全的关键要素。我们将检查保护你的Flask应用程序的过程，并展示如何在实践中实现这些概念。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Understanding the fundamentals of information security
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解信息安全的基本原理
- en: Defining authentication and the authentication role in web applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义Web应用程序中的身份验证和身份验证角色
- en: Implementing password security and hashing passwords
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现密码安全和散列密码
- en: Understanding access and authorization in web application development
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Web应用程序开发中的访问和授权
- en: Adding authentication to your Flask application
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将身份验证添加到你的Flask应用程序中
- en: Identifying system users and managing their information
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别系统用户并管理他们的信息
- en: Session management
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会话管理
- en: Creating a password-protected dashboard
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建受密码保护的仪表板
- en: Implementing flash messages in Flask
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Flask中实现闪存消息
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The complete code for this chapter is available on GitHub at: [https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整代码可在GitHub上找到：[https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12](https://github.com/PacktPublishing/Full-Stack-Flask-and-React/tree/main/Chapter12)。
- en: Understanding the fundamentals of information security
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解信息安全的基本原理
- en: Information security is a critical aspect of web application development. In
    today’s digital age, personal and sensitive information is often stored and transmitted
    through web applications, making them vulnerable to various types of security
    threats. These threats can range from simple attacks such as **SQL injection**
    and **cross-site scripting** (**XSS**) to more complex attacks such as **man-in-the-middle**
    (**MITM**) and **distributed denial of** **service** (**DDoS**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 信息安全是Web应用程序开发的关键方面。在当今数字时代，个人和敏感信息通常通过Web应用程序存储和传输，这使得它们容易受到各种类型的网络安全威胁。这些威胁的范围从简单的攻击，如**SQL注入**和**跨站脚本**（**XSS**），到更复杂的攻击，如**中间人攻击**（**MITM**）和**分布式拒绝服务**（**DDoS**）。
- en: 'Let’s delve deeper into some of the various types of threats that can compromise
    your web application security:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解一些可能危害您的Web应用程序安全性的各种威胁类型：
- en: '`username` and `password` details. If the application is vulnerable to SQL
    injection, an attacker could input something like `'' OR ''1''=''1` in the password
    field.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`用户名`和`密码`详细信息。如果应用程序容易受到SQL注入攻击，攻击者可以在密码字段中输入类似`'' OR ''1''=''1`的内容。'
- en: The SQL query may then become `SELECT * FROM users WHERE username = 'username'
    AND password = '' OR '1'='1';`, which would potentially allow the attacker to
    log in without a valid password.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQL查询可能变为`SELECT * FROM users WHERE username = 'username' AND password = ''
    OR '1'='1';`，这可能会让攻击者无需有效密码即可登录。
- en: '`<script>malicious_scripts()</script>`, other users viewing the comment section
    might execute the script unintentionally.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<script>malicious_scripts()</script>`，其他查看评论部分的用户可能会无意中执行该脚本。'
- en: '**Cross-site request forgery** (**CSRF**): This is an attack where an attacker
    tricks a user into unknowingly making a request to a web application on which
    the user is authenticated. This can lead to unauthorized actions being taken on
    behalf of the user without their consent.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**跨站请求伪造**（**CSRF**）：这是一种攻击，攻击者诱使用户不知情地向用户已认证的Web应用程序发出请求。这可能导致未经用户同意代表用户执行未经授权的操作。'
- en: CSRF attacks exploit the trust that a website has in a user’s browser. For instance,
    an unsuspecting user logs into an online banking website and gets a session cookie.
    The attacker creates a malicious web page that contains a hidden form that submits
    a request to transfer money from the user’s account to the attacker’s account.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CSRF攻击利用了网站对用户浏览器的信任。例如，一个毫无戒心的用户登录到在线银行网站并获取会话cookie。攻击者创建了一个包含隐藏表单的恶意网页，该表单提交请求将用户的账户资金转移到攻击者的账户。
- en: The user visits the attacker’s web page, and the hidden form is submitted using
    the user’s session cookie, resulting in an unauthorized transfer. This type of
    attack exploits the trust that a website has in the user’s browser to perform
    unauthorized actions.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用户访问攻击者的网页，并使用用户的会话cookie提交隐藏表单，导致未经授权的数据传输。这种攻击利用了网站对用户浏览器执行未经授权操作的信任。
- en: '**Distributed Denial of Service** (**DDoS**) **attacks**: This type of attack
    involves overwhelming a target server, service, or network with a flood of traffic
    from multiple sources, rendering it inaccessible to legitimate users. For instance,
    an attacker might use a botnet (a network of compromised computers) to send a
    massive amount of traffic to a web application. This can cause a web application
    to become slow or entirely unavailable to users.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式拒绝服务**（**DDoS**）攻击：这种攻击涉及从多个来源向目标服务器、服务或网络发送大量流量，使其对合法用户不可访问。例如，攻击者可能使用僵尸网络（被破坏的计算机网络）向Web应用程序发送大量流量。这可能导致Web应用程序变慢或完全无法向用户提供服务。'
- en: However, there are ways you can mitigate against these malicious threats, which
    are capable of undermining your web application. Now, we will highlight some of
    the best practices for securing your web application.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些方法可以减轻这些恶意威胁，它们能够破坏您的Web应用程序。现在，我们将强调一些保护Web应用程序的最佳实践。
- en: '**Input validation**: You need to ensure that all input data is properly sanitized
    and validated to prevent SQL injection and XSS attacks.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入验证**：您需要确保所有输入数据都经过适当的清理和验证，以防止SQL注入和XSS攻击。'
- en: '`SQLAlchemy` in Flask, handle the construction of SQL queries for you and provide
    a safe and efficient way to interact with databases.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Flask中使用`SQLAlchemy`，为您处理SQL查询的构建，并提供一种安全且高效的方式与数据库交互。
- en: '**Password storage**: Store passwords securely using a strong hashing algorithm
    and a unique salt for each user.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密码存储**：使用强大的哈希算法和为每个用户生成唯一的盐值来安全地存储密码。'
- en: '**Use of HTTPS**: Use HTTPS to encrypt all communication between the client
    and the server to prevent eavesdropping and MITM attacks.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用HTTPS**：使用HTTPS加密客户端和服务器之间的所有通信，以防止窃听和中间人攻击。'
- en: '**Session management**: Properly manage sessions to prevent session hijacking
    and fix session fixation vulnerabilities in your web application.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**会话管理**：正确管理会话以防止会话劫持并修复Web应用程序中的会话固定漏洞。'
- en: '**Access control**: Use role-based access control to restrict access to sensitive
    resources and functionality.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：使用基于角色的访问控制来限制对敏感资源和功能的访问。'
- en: '**Logging and monitoring**: You need to consistently keep detailed logs of
    all application activity and monitor them for suspicious activity.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志和监控**：您需要持续记录所有应用程序活动的详细日志，并监控可疑活动。'
- en: '**Using up-to-date software**: You need to regularly update the framework,
    libraries, and all dependencies that your web application is using to ensure that
    known vulnerabilities are patched.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用最新软件**：您需要定期更新框架、库以及Web应用程序使用的所有依赖项，以确保已知漏洞得到修补。'
- en: '`X-XSS-Protection`, `X-Frame-Options`, and `Content-Security-Policy` to prevent
    certain types of attacks.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`X-XSS-Protection`、`X-Frame-Options`和`Content-Security-Policy`来防止某些类型的攻击。
- en: '**Regularly testing for vulnerabilities**: Regularly conduct penetration testing
    and vulnerability scanning to identify and fix any security issues.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定期测试漏洞**：定期进行渗透测试和漏洞扫描，以识别和修复任何安全漏洞。'
- en: In the remaining parts of this chapter, we will discuss and implement authentication
    with authorization in a Flask web application to help you keep your application
    and its users’ data secure.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，我们将讨论和实现Flask Web应用程序中的身份验证和授权，以帮助您确保您的应用程序及其用户数据的安全。
- en: Next, we will discuss authentication and the authentication role in web applications.
    This will improve your understanding of how to verify users’ identities and the
    various types of authentications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论Web应用程序中的身份验证和身份验证角色。这将提高您对如何验证用户身份以及各种身份验证类型的理解。
- en: Defining authentication and the authentication role in web application
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义Web应用程序中的身份验证和身份验证角色
- en: '**Authentication** is the process of verifying the identity of a user and ensuring
    that only authorized users have access to the application’s resources and functionality.
    Authentication is an important aspect of any web application, including those
    built with Flask.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**身份验证**是验证用户身份并确保只有授权用户才能访问应用程序的资源和服务的过程。身份验证是任何Web应用程序的重要方面，包括使用Flask构建的应用程序。'
- en: This is typically done by prompting the user to provide a set of credentials,
    such as a username and password, that the web application can use to confirm the
    user’s identity. The purpose of authentication in web application development
    is to ensure that only authorized users can access sensitive information and perform
    certain actions within a web application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是通过提示用户提供一组凭证，例如用户名和密码，Web应用程序可以使用这些凭证来确认用户身份来完成的。在Web应用程序开发中，身份验证的目的是确保只有授权用户可以访问敏感信息并在Web应用程序中执行某些操作。
- en: 'In web development, we have several types of authentication methods that can
    be used in any web application project. These are some of the most commonly used
    methods:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在Web开发中，我们有几种可以在任何Web应用程序项目中使用的身份验证方法。以下是一些最常用的方法：
- en: '**Password-based authentication**: This is the most common form of authentication
    we encounter in everyday use and involves the user entering a username/email and
    password to gain access to the web application. This method is simple and easy
    to implement but comes with its weakness. Password-based authentication is vulnerable
    to attacks such as brute-force and dictionary attacks.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于密码的身份验证**：这是我们日常使用中最常见的身份验证形式，涉及用户输入用户名/电子邮件和密码以获取对Web应用程序的访问权限。这种方法简单易行，但存在其弱点。基于密码的身份验证容易受到暴力破解和字典攻击等攻击。'
- en: '**Multi-factor authentication** (**MFA**): This method adds an additional layer
    of security by requiring the user to provide multiple forms of identification.
    For instance, a user may be required to enter a password and also provide a one-time
    code that’s been sent to their phone or email. MFA is more secure than password-based
    authentication but can negatively impact the user experience.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多因素认证（MFA）**：这种方法通过要求用户提供多种身份验证形式来增加一个额外的安全层。例如，用户可能需要输入密码，并提供发送到他们的手机或电子邮件的一次性代码。MFA比基于密码的认证更安全，但可能会对用户体验产生负面影响。'
- en: '**Token-based authentication**: This method involves the user being issued
    a token that they must present to the web application to gain access. Tokens can
    be in the form of a JWT or OAuth token and are often stored in a browser’s cookies
    or local storage. Tokens can easily be revoked, making it easier to maintain security.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于令牌的认证**：这种方法涉及向用户发放一个令牌，他们必须向Web应用程序出示以获得访问权限。令牌可以是JWT或OAuth令牌的形式，通常存储在浏览器的cookies或本地存储中。令牌可以轻松撤销，这使得维护安全性变得更加容易。'
- en: '**Biometric authentication**: This method involves the use of biological characteristics
    such as fingerprints, facial recognition, or voice recognition to verify a user’s
    identity. Biometric authentication is considered to be more secure than other
    methods but can be more expensive to implement.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生物识别认证**：这种方法涉及使用生物特征，如指纹、面部识别或语音识别来验证用户的身份。生物识别认证被认为比其他方法更安全，但实施成本可能更高。'
- en: When you are deciding which authentication method to use, it’s crucial to consider
    the level of security required for the web application and the user experience.
    Each of these authentication methods has its pros and cons. It is essential to
    choose the right method for your application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当你决定使用哪种认证方法时，考虑Web应用程序所需的安全级别和用户体验至关重要。这些认证方法各有优缺点。选择适合你应用程序的正确方法是至关重要的。
- en: For instance, if you are building a web application that requires a high level
    of security, you may want to consider using MFA or biometric authentication. And
    of course, biometric authentication is rarely used in public or general-purpose
    web applications. If you are building a simple web application that does not require
    a high level of security, password-based authentication may be safe and sufficient.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你正在构建一个需要高度安全性的网络应用程序，你可能想要考虑使用多因素认证（MFA）或生物识别认证。当然，生物识别认证很少在公共或通用网络应用程序中使用。如果你正在构建一个不需要高度安全性的简单网络应用程序，基于密码的认证可能是安全且足够的。
- en: Next, we will discuss the concept of implementing password security and hashing
    passwords in securing a Flask web application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论在Flask Web应用程序中实现密码安全和哈希密码的概念。
- en: Implementing password security and hashing passwords
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现密码安全和哈希密码
- en: In any web application that requires access, passwords are often the first line
    of defense against unauthorized access. As a developer, you will want to ensure
    that passwords are securely managed when building Flask applications. A critical
    component of password management in web applications is to never store passwords
    in plaintext.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何需要访问的Web应用程序中，密码通常是防止未经授权访问的第一道防线。作为开发者，你将想要确保在构建Flask应用程序时，密码被安全地管理。Web应用程序中密码管理的关键组成部分是永远不要以明文形式存储密码。
- en: Instead, passwords should be hashed, which is a one-way encryption process that
    produces a fixed-length output that cannot be reversed. When a user enters their
    password, it is hashed and compared with the stored hash. If the two hashes match,
    the password is correct. Hashing passwords can help protect against attacks such
    as brute-force and dictionary attacks.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，密码应该被哈希处理，这是一个单向加密过程，它产生一个固定长度的输出，无法被逆转。当用户输入他们的密码时，它会被哈希处理并与存储的哈希值进行比较。如果两个哈希值匹配，则密码正确。哈希密码可以帮助保护免受暴力攻击和字典攻击等攻击。
- en: Brute-force attacks involve trying every possible combination of characters
    to find a match, while dictionary attacks involve trying a pre-computed list of
    words. Hashing passwords makes it computationally infeasible for an attacker to
    reverse the hash and discover the original password.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 暴力攻击涉及尝试所有可能的字符组合以找到匹配项，而字典攻击则涉及尝试预计算的单词列表。哈希密码使得攻击者无法在计算上逆转哈希并发现原始密码变得不可行。
- en: In Flask, you can use a library such as `Flask-Bcrypt` to handle password hashing.
    `Flask-Bcrypt` is a Flask extension that provides `bcrypt` password hashing for
    Flask. `Flask-Bcrypt` provides a simple interface for hashing and checking passwords.
    You can also use `Flask-Bcrypt` to generate random salts for use in password hashing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Flask 中，你可以使用 `Flask-Bcrypt` 这样的库来处理密码哈希。`Flask-Bcrypt` 是一个 Flask 扩展，为 Flask
    提供了 `bcrypt` 密码哈希功能。`Flask-Bcrypt` 提供了简单的接口用于哈希和检查密码。你还可以使用 `Flask-Bcrypt` 生成用于密码哈希的随机盐。
- en: 'Let’s quickly run through an example of password hashing using `Flask-Bcrypt`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速通过一个使用 `Flask-Bcrypt` 进行密码哈希的例子：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code uses the `Flask Bcrypt` library to hash and check a password.
    It imports the `Bcrypt` class and the `check_password_hash` function, creating
    an instance of `Bcrypt` with the Flask application. When the form is submitted,
    the password is hashed using the `flask_bcrypt` extension, and the hashed password
    is displayed back to the user on the same page. The `render_template` function
    is used to render the HTML templates, and the `Bcrypt` extension is used for secure
    password hashing.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码使用了 `Flask Bcrypt` 库来哈希和检查密码。它导入了 `Bcrypt` 类和 `check_password_hash` 函数，使用
    Flask 应用程序创建了一个 `Bcrypt` 实例。当表单提交时，使用 `flask_bcrypt` 扩展对密码进行哈希处理，并将哈希后的密码在同一页面上显示给用户。`render_template`
    函数用于渲染 HTML 模板，而 `Bcrypt` 扩展用于安全的密码哈希。
- en: Next, we will discuss access and authorization in web application development.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论网络应用程序开发中的访问和授权。
- en: Understanding access and authorization in web application development
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解网络应用程序开发中的访问和授权
- en: Access and authorization in web application development is the process of controlling
    who has access to specific resources and actions within a web application. As
    a developer, you will want to design and ensure that users can only perform actions
    they are authorized to perform and access resources they are authorized to access
    in a web application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序开发中的访问和授权是控制谁可以访问 Web 应用程序中特定资源和操作的过程。作为一个开发者，你将希望设计和确保用户只能执行他们被授权执行的操作，并访问他们被授权访问的资源。
- en: As discussed earlier, authentication is the process of verifying the identity
    of a user. Authorization is the process of determining what a user is allowed
    to do within a web application. When you combine these two mechanisms, you have
    a system that ensures that only authorized users can access sensitive information
    and perform certain actions within a web application.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，认证是验证用户身份的过程。授权是确定用户在 Web 应用程序中可以做什么的过程。当你结合这两个机制时，你就有了一个系统，确保只有授权用户才能访问敏感信息并在
    Web 应用程序中执行某些操作。
- en: 'Several different types of access control methods can be used in web application
    development. We will discuss some of them and make specific reference to how Flask
    can handle access and authorization:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序开发中可以使用多种不同的访问控制方法。我们将讨论其中一些，并具体说明 Flask 如何处理访问和授权：
- en: '`Flask-Login` and `Flask-Security`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-Login` 和 `Flask-Security`。'
- en: '`Flask-OAuthlib`. This extension provides support for `OAuth 1.0a` and `OAuth
    2.0`. `Flask-OAuthlib` makes it easy for developers to implement OAuth in their
    Flask applications.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-OAuthlib`。此扩展提供了对 `OAuth 1.0a` 和 `OAuth 2.0` 的支持。`Flask-OAuthlib` 使得开发者在
    Flask 应用程序中实现 OAuth 变得容易。'
- en: '`Flask-JWT` and `Flask-JWT-Extended`.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-JWT` 和 `Flask-JWT-Extended`。'
- en: These extensions provide features such as token generation, verification, and
    expiration, as well as the ability to restrict access to certain resources and
    actions based on the claims contained in the JWT to ensure that it was generated
    by a trusted source and has not been tampered with.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些扩展提供了令牌生成、验证和过期等功能，以及根据 JWT 中包含的声明来限制对某些资源和操作的访问，以确保它是由可信源生成的且未被篡改。
- en: '`Flask-RBAC`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-RBAC`。'
- en: The `Flask-RBAC` extension provides features such as role management, permission
    management, and the ability to restrict access to certain resources and actions
    based on the user’s role.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Flask-RBAC` 扩展提供了角色管理、权限管理和基于用户角色的限制对某些资源和操作的访问的能力。'
- en: '`Flask-Policies`. `Flask-Policies` provides features such as policy management,
    enforcement, and the ability to restrict access to certain resources and actions
    based on the conditions specified in the policies.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Flask-Policies`。`Flask-Policies` 提供了策略管理、执行以及根据策略中指定的条件限制对某些资源和操作的访问的能力。'
- en: By using these libraries, you can easily handle user roles and permissions and
    restrict access to certain views and routes based on the user’s role. Next, we
    will take a look at how to implement authentication in a Flask web application.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这些库，你可以轻松处理用户角色和权限，并根据用户的角色限制对某些视图和路由的访问。接下来，我们将探讨如何在Flask Web应用程序中实现身份验证。
- en: Adding authentication to your Flask application
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的Flask应用程序添加身份验证
- en: JWT is a popular method for authentication in modern web applications. A JWT
    is a JSON object that is digitally signed and can be used to authenticate users
    by transmitting claims between parties, such as an authorization server and a
    resource server. In a Flask web application, you can use the `PyJWT` library to
    encode and decode JWTs for authentication.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: JWT是现代Web应用程序中流行的身份验证方法。JWT是一个经过数字签名的JSON对象，可以通过在各方之间传输声明（例如授权服务器和资源服务器）来用于身份验证用户。在Flask
    Web应用程序中，你可以使用`PyJWT`库来编码和解码JWT以进行身份验证。
- en: When a user logs into a Flask application, the backend verifies the user’s credentials,
    such as their email and password, and if they are valid, a JWT is generated and
    sent back to the client. The client stores the JWT in the browser’s local storage
    or as a cookie. For subsequent requests to protected routes and resources, the
    client sends the JWT in the request header.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录Flask应用程序时，后端验证用户的凭据，如他们的邮箱和密码，如果它们有效，则生成JWT并发送给客户端。客户端将JWT存储在浏览器的本地存储或作为cookie。对于后续请求受保护的路线和资源，客户端在请求头中发送JWT。
- en: The backend decodes the JWT to verify the user’s identity, grants or denies
    access to the requested resources, and generates a new JWT for subsequent requests.
    JWT for authentication allows stateless authentication. This means that the authentication
    information is stored in the JWT, which can be passed around between different
    servers, instead of on the server’s memory. This makes it easier to scale the
    application and reduces the risk of data loss or corruption.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 后端解码JWT以验证用户的身份，授予或拒绝对请求资源的访问，并为后续请求生成新的JWT。JWT身份验证允许无状态身份验证。这意味着身份验证信息存储在JWT中，可以在不同的服务器之间传递，而不是存储在服务器的内存中。这使得扩展应用程序更容易，并降低了数据丢失或损坏的风险。
- en: JWT authentication also enhances security by using digital signatures to prevent
    data tampering. The signature is generated using a secret key that’s shared between
    the server and the client. The signature ensures that the data in the JWT has
    not been altered in transit. JWT authentication is a secure and efficient method
    for authenticating users in a Flask application.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JWT身份验证还通过使用数字签名来防止数据篡改，从而增强了安全性。签名使用服务器和客户端之间共享的秘密密钥生成。签名确保JWT中的数据在传输过程中未被更改。JWT身份验证是Flask应用程序中安全且高效的用户身份验证方法。
- en: By implementing JWT authentication in a Flask application, developers can simplify
    the process of authenticating users and reduce the risk of security breaches.
    Let’s examine the backend and frontend implementation of JWT.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Flask应用程序中实现JWT身份验证，开发者可以简化用户身份验证的过程，并降低安全漏洞的风险。让我们来检查JWT的后端和前端实现。
- en: Flask backend
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask后端
- en: 'The following code defines two Flask endpoints – `/api/v1/login` and `/api/v1/dashboard`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码定义了两个Flask端点 – `/api/v1/login` 和 `/api/v1/dashboard`：
- en: '[PRE1]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `/api/v1/login` endpoint is for handling user login requests. It takes
    in a JSON request with two properties: `email` and `password`. If either of these
    properties is missing, the function returns a JSON response with a message indicating
    `Missing email or password` and a status code of `400` (Bad Request).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`/api/v1/login` 端点是用于处理用户登录请求的。它接收一个包含两个属性的JSON请求：`email` 和 `password`。如果这两个属性中的任何一个缺失，函数将返回一个包含消息“缺少邮箱或密码”和状态码`400`（错误请求）的JSON响应。'
- en: Next, the function queries the database for a user with the given email. If
    no such user exists, or if the password provided does not match the hashed password
    stored in the database, the function returns a JSON response with a message indicating
    `Invalid email or password` and a status code of `401` (Unauthorized).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，该函数查询数据库以查找具有给定邮箱的用户。如果不存在这样的用户，或者提供的密码与数据库中存储的散列密码不匹配，则函数返回一个包含消息“无效的邮箱或密码”和状态码`401`（未授权）的JSON响应。
- en: Otherwise, the function generates a JWT using the `create_access_token` function
    and returns it as a JSON response, along with a status code of `200` (OK). The
    JWT can be used to authenticate the user in subsequent requests to the backend.
    The `/api/v1/dashboard` endpoint is a protected endpoint that can only be accessed
    by users who have a valid JWT.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，函数会使用 `create_access_token` 函数生成一个 JWT，并将其作为 JSON 响应返回，状态码为 `200`（OK）。JWT
    可以用于在后续请求中对用户进行认证。`/api/v1/dashboard` 端点是一个受保护的端点，只有拥有有效 JWT 的用户才能访问。
- en: The `jwt_required` decorator is used to enforce this restriction. When this
    endpoint is accessed, the JWT is used to extract the user’s identity, which is
    then used to retrieve the user’s `email` from the database. This email is then
    returned as a JSON response, along with a status code of `200` (OK).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `jwt_required` 装饰器来强制执行此限制。当访问此端点时，JWT 用于提取用户的身份，然后从数据库中检索用户的 `email`。然后，该电子邮件作为
    JSON 响应返回，状态码为 `200`（OK）。
- en: React frontend
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 前端
- en: 'The following code shows a login form and a dashboard. The `LoginForm` component
    has three states – `email`, `password`, and `accessToken`. When the form is submitted,
    it makes a `POST` request to the `/api/v1/login` endpoint with the email and password
    data, and the response of the request is stored in the `accessToken` state:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了登录表单和仪表板。`LoginForm` 组件有三个状态 – `email`、`password` 和 `accessToken`。当表单提交时，它会对
    `/api/v1/login` 端点发送一个带有电子邮件和密码数据的 `POST` 请求，并将请求的响应存储在 `accessToken` 状态中：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Dashboard` component takes an `accessToken` prop and has one state, `email`.
    It makes a `GET` request to the `/api/v1/dashboard` endpoint with an authorization
    header set to `accessToken`, and the response is stored in the `email` state.
    The component displays a message stating `"Welcome to` `dashboard, [email]!"`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dashboard` 组件接受一个 `accessToken` 属性，并有一个状态，`email`。它会对 `/api/v1/dashboard`
    端点发送一个带有设置为 `accessToken` 的授权头的 `GET` 请求，并将响应存储在 `email` 状态中。该组件显示一条消息，内容为 `"欢迎来到`
    `dashboard, [email]!"`。'
- en: The `LoginForm` component returns either the `Dashboard` component if `accessToken`
    is truthy, or the login form if `accessToken` is `falsy`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoginForm` 组件根据 `accessToken` 是否为真返回 `Dashboard` 组件或登录表单。'
- en: Next, we will discuss how to identify web application users and manage their
    information.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何识别网络应用程序用户并管理他们的信息。
- en: Identifying system users and managing their information
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别系统用户和管理他们的信息
- en: In most web applications, users are identified by a unique identifier such as
    a username or email address. Typically, in a Flask application, you can use a
    database to store user information, such as usernames, email addresses, and hashed
    passwords.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数网络应用程序中，用户通过唯一的标识符（如用户名或电子邮件地址）进行识别。通常，在 Flask 应用程序中，你可以使用数据库来存储用户信息，例如用户名、电子邮件地址和散列密码。
- en: When a user attempts to log in, the entered credentials (username and password)
    are compared to the information stored in the database. If the entered credentials
    match, the user is authenticated, and a session is created for that user. In Flask,
    you can use the built-in session object to store and retrieve user information.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试登录时，输入的凭据（用户名和密码）将与数据库中存储的信息进行比较。如果输入的凭据匹配，则用户被认证，并为该用户创建一个会话。在 Flask 中，你可以使用内置的会话对象来存储和检索用户信息。
- en: By using sessions, you can easily identify users in a Flask web application
    and retrieve information about them. However, it’s important to note that sessions
    are vulnerable to session hijacking attacks. So, it’s essential to use secure
    session management techniques such as regenerating session IDs after login and
    using secure cookies.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用会话，你可以在 Flask 网络应用程序中轻松识别用户并检索他们的信息。然而，需要注意的是，会话容易受到会话劫持攻击。因此，使用诸如登录后重新生成会话
    ID 和使用安全cookie等安全的会话管理技术是至关重要的。
- en: 'Let’s examine an implementation example:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考察一个实现示例：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code, the first line imports the required modules from the
    Flask library. The next line creates an instance of the `Flask` class and assigns
    it to the `app` variable. The `app.secret_key` attribute is set to `'secret_key'`,
    which is used to securely sign the session cookie.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第一行从 Flask 库中导入所需的模块。下一行创建了一个 `Flask` 类的实例，并将其分配给 `app` 变量。`app.secret_key`
    属性被设置为 `'secret_key'`，它用于安全地签名会话cookie。
- en: The login function is defined as a POST endpoint at the `api/v1/login` route.
    This endpoint uses the `request.get_json()` method to get the JSON data from the
    request body and extract the values for `email` and `password`. `email` is then
    stored in the session using `session['email'] = email`. The function returns a
    JSON response with a message of `"Login successful"` and a `201` status code,
    indicating the successful creation of a resource.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 登录功能被定义为 `api/v1/login` 路径上的 POST 端点。此端点使用 `request.get_json()` 方法从请求体中获取 JSON
    数据并提取 `email` 和 `password` 的值。然后使用 `session['email'] = email` 将 `email` 存储在会话中。该函数返回一个包含消息
    `"Login successful"` 和状态码 `201` 的 JSON 响应，表示成功创建资源。
- en: Then, the dashboard function is defined as a GET endpoint at the `api/v1/dashboard`
    route. It retrieves `email` from the session using `session.get('email')`. The
    function then queries the database for a user with the specified email using `User.query.filter_by(email=email).first()`.
    The `email` and user data (converted into a dictionary using `to_dict()`) are
    returned in a JSON response with a 200 status code, indicating the successful
    retrieval of a resource.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，仪表板功能被定义为 `api/v1/dashboard` 路径上的 GET 端点。它使用 `session.get('email')` 从会话中检索
    `email`。然后，该函数使用 `User.query.filter_by(email=email).first()` 查询数据库以获取具有指定电子邮件的用户。`email`
    和用户数据（使用 `to_dict()` 转换为字典）以 JSON 响应的形式返回，状态码为 200，表示成功检索资源。
- en: You can also identify users in a Flask application with a token-based authentication
    method. In this method, a token is issued to the user when they log in, and the
    token is stored in the user’s browser as a cookie or placed in local storage.
    This token is then sent with each subsequent request made by the user, and the
    server uses this token to identify the user. JWT is a commonly used token format,
    and libraries such as `Flask-JWT` and `Flask-JWT-Extended` make it easy to implement
    JWT-based authentication in Flask.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用基于令牌的认证方法在 Flask 应用程序中识别用户。在此方法中，当用户登录时，会向用户颁发一个令牌，并将该令牌存储在用户的浏览器中作为cookie或放置在本地存储中。然后，此令牌随用户发出的每个后续请求一起发送，服务器使用此令牌来识别用户。JWT
    是常用的令牌格式，`Flask-JWT` 和 `Flask-JWT-Extended` 等库使得在 Flask 中实现基于 JWT 的认证变得简单。
- en: Next, we will delve deeper into tracking a user’s session in a web application.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入了解在 Web 应用程序中跟踪用户会话。
- en: Session management
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话管理
- en: '`Flask-Session`; on the frontend React side, you can use React’s `localStorage`
    or `sessionStorage`.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Flask-Session`；在前端 React 端，你可以使用 React 的 `localStorage` 或 `sessionStorage`。'
- en: Flask thrives on its simplicity as a framework of choice for Python that makes
    it easy to build small to enterprise-sized web applications. Flask can manage
    user sessions using the built-in session object and some of the available Flask
    extensions contributed by the community members.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Flask 作为 Python 的首选框架，以其简洁性而闻名，使得构建从小型到企业级大小的 Web 应用程序变得容易。Flask 可以使用内置的会话对象和一些社区成员提供的
    Flask 扩展来管理用户会话。
- en: A session object is a dictionary-like object that is stored on the server and
    can be accessed by the client via a secure session cookie. To use a session object,
    a *secret key* must be set in the Flask application. This secret key is used to
    encrypt and sign the session data, which is stored in a secure cookie on the client’s
    browser. When a user visits a protected resource, the server verifies the session
    cookie and grants access if the cookie is valid.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 会话对象是一个类似字典的对象，存储在服务器上，可以通过安全的会话cookie由客户端访问。要使用会话对象，必须在 Flask 应用程序中设置一个 *密钥*。此密钥用于加密和签名会话数据，这些数据存储在客户端浏览器的安全cookie中。当用户访问受保护的资源时，服务器验证会话cookie，如果cookie有效，则授予访问权限。
- en: Let’s implement session management in a Flask backend and React frontend. We
    will create a counter endpoint that keeps track of the number of times a user
    visited a dashboard page.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 Flask 后端和 React 前端中实现会话管理。我们将创建一个计数器端点，用于跟踪用户访问仪表板页面的次数。
- en: Flask backend
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask 后端
- en: We will use `Flask-Session` to store session data and securely manage sessions.
    To use `Flask-Session`, you need to install it first. You can do this by running
    the `pip install flask-session` command in the Terminal.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `Flask-Session` 来存储会话数据并安全地管理会话。要使用 `Flask-Session`，您需要先安装它。您可以在终端中运行
    `pip install flask-session` 命令来完成此操作。
- en: 'Once you’ve installed `Flask-Session`, you need to add the following code to
    your Flask application:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 `Flask-Session` 后，您需要将以下代码添加到您的 Flask 应用程序中：
- en: '[PRE4]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code shows a simple implementation of session management in a
    Flask backend:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了在 Flask 后端中实现会话管理的简单示例：
- en: The first line imports the Flask module, while the second line imports the `Flask-Session`
    extension.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行导入 Flask 模块，而第二行导入 `Flask-Session` 扩展。
- en: The next few lines create a Flask application object and configure the session
    type to be stored on the filesystem.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的几行创建了一个 Flask 应用程序对象，并配置会话类型存储在文件系统中。
- en: The `Session` object is then initialized with the Flask application object as
    its argument.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，使用 Flask 应用程序对象作为其参数初始化 `Session` 对象。
- en: The `@app.route` decorator creates a route – in this case, `/api/v1/counters`
    – for the `visit_counter` function.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`@app.route` 装饰器为 `visit_counter` 函数创建了一个路由 - 在这种情况下，是 `/api/v1/counters` 路由。'
- en: The `visit_counter` function retrieves the current value of the `counter` key
    in the session or sets it to `0` if it doesn’t exist, and then increments the
    value by `1`. The updated value is then returned to the user in the response.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`visit_counter` 函数检索会话中 `counter` 键的当前值，如果不存在则将其设置为 `0`，然后增加 `1`。然后，将更新后的值作为响应返回给用户。'
- en: Let’s explore the React frontend part of this implementation.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这个实现中的 React 前端部分。
- en: React Frontend
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React 前端
- en: You can use the Axios library to send HTTP requests to the Flask server. If
    not installed yet, you can install Axios with the `npm install` `axios` command.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Axios 库向 Flask 服务器发送 HTTP 请求。如果尚未安装，可以使用 `npm install axios` 命令安装 Axios。
- en: 'Once you’ve installed Axios, you can use it to send an HTTP request to the
    Flask server to set or get the session data:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Axios，你就可以使用它向 Flask 服务器发送 HTTP 请求来设置或获取会话数据：
- en: '[PRE5]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding code demonstrates the frontend implementation of a React frontend
    that retrieves the visit counter from a Flask backend:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码演示了 React 前端的前端实现，它从 Flask 后端检索访问计数器。
- en: The first line imports the required libraries – that is, `React` and `axios`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行导入所需的库 - 即 `React` 和 `axios`。
- en: The next section declares the `VisitCounter` function component, which returns
    a view for the user.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分声明了 `VisitCounter` 函数组件，它返回一个用户视图。
- en: Within the component, the state variable counter is initialized using the `useState`
    hook.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在组件内部，使用 `useState` 钩子初始化状态变量 `counter`。
- en: The `getCounter` function uses the `axios` library to make a `GET` request to
    the `/api/v1/counters` endpoint on the Flask backend. The response from the backend,
    which contains the updated counter value, is then used to update the counter state
    variable.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getCounter` 函数使用 `axios` 库向 Flask 后端的 `/api/v1/counters` 端点发送 `GET` 请求。然后，使用来自后端的响应（其中包含更新的计数器值）来更新计数器状态变量。'
- en: The component returns a div that displays the value of the counter and a button
    that, when clicked, triggers the `getCounter` function to retrieve the updated
    counter value from the backend.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 组件返回一个 div，显示计数器的值，以及一个按钮，当点击时，会触发 `getCounter` 函数从后端检索更新的计数器值。
- en: Next, we will discuss how to create a password-protected dashboard in a Flask-React
    web application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何在 Flask-React Web 应用程序中创建密码保护的仪表板。
- en: Creating a password-protected dashboard
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建密码保护的仪表板
- en: Protecting pages in a web application is essential for maintaining security
    and privacy. By extension, this can help prevent unauthorized access to sensitive
    information. In this section, you will be implementing a protected dashboard page
    in a Flask-React web application.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Web 应用程序中保护页面对于维护安全和隐私至关重要。通过扩展，这有助于防止未经授权访问敏感信息。在本节中，你将在 Flask-React Web
    应用程序中实现一个受保护的仪表板页面。
- en: A dashboard is a user-friendly interface that provides an overview of data and
    information. The data that’s displayed on a dashboard can come from a variety
    of sources, such as databases, spreadsheets, and APIs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板是一个用户友好的界面，提供了数据和信息的概览。仪表板上显示的数据可以来自各种来源，例如数据库、电子表格和 API。
- en: Flask backend
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask 后端
- en: 'The following code demonstrates an implementation that allows an admin user
    to log in and see a protected dashboard page. We will implement minimalist login
    and logout endpoints that define login and logout functionality and protect the
    `dashboard` endpoint. The application uses the `Flask-Session` library to store
    session data in the filesystem:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了一个实现，允许管理员用户登录并查看受保护的仪表板页面。我们将实现最小化的登录和注销端点，定义登录和注销功能并保护 `dashboard`
    端点。应用程序使用 `Flask-Session` 库在文件系统中存储会话数据：
- en: '[PRE6]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the `login` endpoint, the application receives a `POST` request with the
    `username` and `password` parameters in the request body in JSON format. The code
    checks if the `username` and `password` parameters match the predefined values
    – that is, `admin` and `secret`. If the values match, the code sets the `logged_in`
    key in the session data to `True`, indicating that the user is logged in.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`login`端点，应用程序接收一个包含请求体中JSON格式的`username`和`password`参数的`POST`请求。代码检查`username`和`password`参数是否与预定义的值匹配——即`admin`和`secret`。如果值匹配，代码将会话数据中的`logged_in`键设置为`True`，表示用户已登录。
- en: It returns a JSON response with a message stating `Login successful`. If the
    values don’t match, the code returns a JSON response with a message stating `Login
    failed` and a `401` HTTP status code, indicating unauthorized access.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个包含声明`Login successful`的消息的JSON响应。如果值不匹配，代码返回一个包含声明`Login failed`和`401`
    HTTP状态代码的JSON响应，表示未授权访问。
- en: The `logout` endpoint removes the `logged_in` key from the session data, indicating
    that the user is logged out. It returns a JSON response with a message stating
    `Logout successful`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`logout`端点从会话数据中删除`logged_in`键，表示用户已注销。它返回一个包含声明`Logout successful`的消息的JSON响应。'
- en: The dashboard endpoint checks if the `logged_in` key exists in the session data.
    If it does not, the code returns a JSON response with a message stating `Unauthorized
    access` and a `401` HTTP status code. If the `logged_in` key exists, the code
    returns a JSON response with a message stating `"Welcome to` `the dashboard"`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表板端点检查会话数据中是否存在`logged_in`键。如果不存在，代码返回一个包含声明`Unauthorized access`和`401` HTTP状态代码的JSON响应。如果`logged_in`键存在，代码返回一个包含声明`"Welcome
    to` `the dashboard"`的JSON响应。
- en: React frontend
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React前端
- en: 'The following code snippet is a React component that displays a dashboard for
    a user. It uses React hooks, specifically `useState` and `useEffect`, to manage
    its state and update the user interface:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段是一个React组件，用于显示用户的仪表板。它使用React钩子，特别是`useState`和`useEffect`，来管理其状态和更新用户界面：
- en: '[PRE7]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When the component is rendered, it makes an HTTP `GET` request to `http://localhost:5000/api/v1/dashboard`
    using the `axios` library. This is done in the `checkLogin` function, which is
    called by the `useEffect` hook when the component is mounted.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件渲染时，它使用`axios`库向`http://localhost:5000/api/v1/dashboard`发出HTTP `GET`请求。这是在`checkLogin`函数中完成的，该函数在组件挂载时由`useEffect`钩子调用。
- en: If the response from the server is `200 OK`, this means that the user is authorized
    to access the dashboard. The component’s state is updated to reflect this by setting
    `isLoggedIn` to `true` and `message` to the message returned from the server.
    If the response is not `200 OK`, this means the user is unauthorized and `isLoggedIn`
    remains `false`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器的响应是`200 OK`，这意味着用户有权访问仪表板。组件的状态通过将`isLoggedIn`设置为`true`和`message`设置为从服务器返回的消息来更新，以反映这一点。如果响应不是`200
    OK`，这意味着用户未授权，`isLoggedIn`保持为`false`。
- en: Finally, the component returns a message that tells the user whether they have
    access to the dashboard. If `isLoggedIn` is `false`, it returns `Unauthorized
    access`. If `isLoggedIn` is `true`, it returns the message from the server.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，组件返回一个消息，告诉用户他们是否有权访问仪表板。如果`isLoggedIn`为`false`，它返回`Unauthorized access`。如果`isLoggedIn`为`true`，它返回来自服务器的消息。
- en: In this way, you can create a password-protected dashboard that is only accessible
    to authenticated users using React and Flask with added security for your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，您可以使用React和Flask创建一个密码保护的仪表板，只有经过身份验证的用户才能访问，从而为您的应用程序增加安全性。
- en: Next, you will learn how to implement flash messages in Flask and React web
    applications.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将学习如何在Flask和React Web应用程序中实现Flash消息。
- en: Implementing flash messages in Flask
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Flask中实现Flash消息
- en: Flash messages enhance the user experience in any web application, providing
    informative and timely feedback to users. Flash is used to display status or error
    messages on web pages after a redirect. For instance, after a successful form
    submission, a message can be stored in the flash to display a success message
    on the redirected page.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Flash消息增强了任何Web应用程序的用户体验，为用户提供及时和有用的反馈。Flash用于在重定向后显示网页上的状态或错误消息。例如，在表单提交成功后，可以将消息存储在Flash中，以便在重定向页面上显示成功消息。
- en: The flash message is stored in the user’s session, which is a dictionary-like
    object that can store information between requests. With flash messages, you can
    pass information between requests securely and efficiently. This is useful for
    displaying messages that don’t need to persist for a long time or that need to
    be shown only once, such as success or error messages. Since flash messages are
    stored in the user’s session, they are only accessible by the server and are not
    sent to the client in plain text, making them secure.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 闪存信息存储在用户的会话中，这是一个类似于字典的对象，可以在请求之间存储信息。使用闪存信息，您可以在请求之间安全高效地传递信息。这对于显示不需要长时间持续或只需要显示一次的消息很有用，例如成功或错误消息。由于闪存信息存储在用户的会话中，它们只能由服务器访问，并且不会以纯文本形式发送到客户端，这使得它们更加安全。
- en: Let’s modify the login and logout endpoints to show flash messages.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改登录和注销端点以显示闪存信息。
- en: Flask backend
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Flask后端
- en: 'The following code demonstrates the implementation of a flash message system
    with login and logout endpoints. The code starts by importing the necessary modules
    and creating a Flask application. The `app.secret_key = "secret_key"` line sets
    the secret key, which is used to encrypt the flash messages stored in the session:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了带有登录和注销端点的闪存信息系统的实现。代码首先导入必要的模块并创建一个Flask应用程序。`app.secret_key = "secret_key"`这一行设置了密钥，该密钥用于加密存储在会话中的闪存信息：
- en: '[PRE8]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `login` endpoint is defined by the `login` function, which is bound to the
    `/api/v1/login` URL. The function retrieves the `username` and `password` values
    from the JSON data in the request, and checks if they match the predefined values
    of `"admin"` and `"secret"`. If the values match, the user’s session is marked
    as logged in by setting the `logged_in` key in the session, and a flash message
    is set to indicate that the login was successful.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 登录端点由`login`函数定义，该函数绑定到`/api/v1/login` URL。该函数从请求中的JSON数据中检索`username`和`password`值，并检查它们是否与预定义的`"admin"`和`"secret"`值匹配。如果值匹配，用户的会话通过在会话中设置`logged_in`键标记为已登录，并设置一个表示登录成功的闪存信息。
- en: The function then returns a JSON response, indicating the login was successful.
    If the values do not match, a flash message is set, indicating the login failed,
    and a JSON response indicating the login failure is returned. The logout endpoint
    is defined by the `logout` function, which is bound to the `/``api/v1/logout`
    URL.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数随后返回一个JSON响应，指示登录成功。如果值不匹配，设置一个闪存信息，指示登录失败，并返回一个表示登录失败的JSON响应。注销端点由`logout`函数定义，该函数绑定到`/api/v1/logout`
    URL。
- en: The function removes the `logged_in` key from the session, indicating that the
    user is no longer logged in, and sets a flash message indicating that the logout
    was successful. A JSON response indicating the logout was successful is then returned.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 函数从会话中删除`logged_in`键，表示用户不再登录，并设置一个表示注销成功的闪存信息。随后返回一个表示注销成功的JSON响应。
- en: React frontend
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: React前端
- en: 'The following snippet demonstrates a React functional component that represents
    the dashboard of a web application handling flash messages from the backend. The
    `Dashboard` component makes use of `useState` and `useEffect` hooks:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了一个表示从后端处理闪存信息的Web应用程序仪表板的React函数组件。`Dashboard`组件使用了`useState`和`useEffect`钩子：
- en: '[PRE9]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Dashboard` component keeps track of the following state variables:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dashboard`组件跟踪以下状态变量：'
- en: '`isLoggedIn`: A Boolean value indicating if the user is logged in or not. It
    is initially set to `false`.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isLoggedIn`: 一个表示用户是否登录的布尔值。它最初设置为`false`。'
- en: '`message`: A string value that represents a message that is displayed on the
    dashboard.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`message`: 一个表示在仪表板上显示的消息的字符串值。'
- en: '`flashMessage`: A string value that represents a flash message that is displayed
    on the page.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flashMessage`: 一个表示在页面上显示的闪存信息的字符串值。'
- en: 'The `Dashboard` component has three functions:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dashboard`组件有三个功能：'
- en: '`checkLogin`: An asynchronous function that makes a `GET` request to the `/api/v1/dashboard`
    endpoint to check if the user is logged in or not. If the response status is `200`,
    it updates the `isLoggedIn` state variables to `true` and messages a value of
    `response.data.message`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`checkLogin`: 一个异步函数，它向`/api/v1/dashboard`端点发送`GET`请求以检查用户是否已登录。如果响应状态是`200`，它将`isLoggedIn`状态变量更新为`true`，并显示`response.data.message`的值。'
- en: '`handleLogin`: An asynchronous function that makes a `POST` request to the
    `/api/v1/login` endpoint with the provided `username` and `password` values as
    the request body. If the response status is `200`, it updates the `isLoggedIn`
    state variables to `true` and `flashMessage` to the value of `response.data.message`.
    If the response status is not `200`, it updates `flashMessage` to the value of
    `response.data.message`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleLogin`: 一个异步函数，它使用提供的`username`和`password`值作为请求体，向`/api/v1/login`端点发送`POST`请求。如果响应状态是`200`，它将`isLoggedIn`状态变量更新为`true`并将`flashMessage`更新为`response.data.message`的值。如果响应状态不是`200`，它将`flashMessage`更新为`response.data.message`的值。'
- en: '`handleLogout`: An asynchronous function that makes a `GET` request to the
    `/api/v1/logout` endpoint. If the response status is `200`, it updates the `isLoggedIn`
    state variables to `false` and `flashMessage` to the value of `response.data.message`.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handleLogout`: 一个异步函数，它向`/api/v1/logout`端点发送`GET`请求。如果响应状态是`200`，它将`isLoggedIn`状态变量更新为`false`并将`flashMessage`更新为`response.data.message`的值。'
- en: The `useEffect` hook is used to call the `checkLogin` function when the component
    is mounted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`useEffect`钩子在组件挂载时调用`checkLogin`函数。
- en: Finally, the component returns a UI, depending on the value of `isLoggedIn:`.
    If the user is not logged in, it displays a message saying `"Unauthorized access"`
    and a `"``Login successful"`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，组件根据`isLoggedIn:`的值返回一个UI。如果用户未登录，它将显示一条消息说“未经授权访问”和“``登录成功"”。
- en: In this way, you can use flash messages to provide feedback to the user in a
    React application via the frontend, and then use the Flask backend to enhance
    the user’s experience. Overall, flash messages make web applications more interactive
    and user-friendly.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你可以在React应用程序的前端使用闪存消息向用户提供反馈，然后使用Flask后端来增强用户体验。总的来说，闪存消息使Web应用程序更加互动和用户友好。
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has provided a comprehensive overview of the fundamentals of information
    security and how to secure a Flask web application using authentication and authorization.
    You learned about the best practices and were provided with use cases for implementing
    authentication and authorization in a Flask application. We also discussed different
    types of authentication methods and access control methods.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 本章提供了关于信息安全基础以及如何使用身份验证和授权来确保Flask Web应用程序的全面概述。你了解了最佳实践，并提供了在Flask应用程序中实现身份验证和授权的用例。我们还讨论了不同的身份验证方法和访问控制方法。
- en: You explored how to manage user sessions and implement password-protected dashboards.
    Additionally, this chapter has shown you how to use flash messages to provide
    feedback to users of web applications. You are expected to have garnered a solid
    understanding of how to secure a Flask application and be able to implement authentication
    and authorization in your projects.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你探索了如何管理用户会话和实现密码保护的仪表板。此外，本章还展示了如何使用闪存消息向Web应用程序的用户提供反馈。你应已对如何确保Flask应用程序的安全以及如何在项目中实现身份验证和授权有了坚实的理解。
- en: In the next chapter, we will discuss how to handle errors in Flask web applications
    with React handling the frontend part of it. We will delve into in-built Flask
    debugging capabilities and learn how to handle custom error messages in React-Flask
    applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何处理Flask Web应用程序中的错误，其中React处理前端部分。我们将深入研究内置的Flask调试功能，并学习如何在React-Flask应用程序中处理自定义错误消息。
