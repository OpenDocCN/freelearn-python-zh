- en: Chapter 4. Functions, the Building Blocks of Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 函数，代码的构建块
- en: '|   | *"To create architecture is to put in order. Put what in order? Function
    and objects."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|   | *"创造建筑就是整理。整理什么？功能和对象。" |   |'
- en: '|   | --*Le Corbusier* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|   | --*勒·柯布西耶* |'
- en: In this chapter, we're going to explore functions. We already said that everything
    is an object in Python, and functions are no exception to this. But, what exactly
    is a function? A **function** is a sequence of instructions that perform a task,
    bundled as a unit. This unit can then be imported and used wherever it's needed.
    There are many advantages to using functions in your code, as we'll see shortly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨函数。我们之前已经说过，在Python中，一切都是对象，函数也不例外。但是，函数究竟是什么呢？**函数**是一系列执行任务的指令序列，作为一个单元捆绑在一起。这个单元可以随后导入并在需要的地方使用。使用函数在代码中有许多优点，我们很快就会看到。
- en: 'I believe the saying, *a picture is worth one thousand words*, is particularly
    true when explaining functions to someone who is new to this concept, so please
    take a look at the following image:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为“一图胜千言”这句话在向一个对这一概念新手解释函数时尤其正确，所以请看一下下面的图片：
- en: '![Functions, the Building Blocks of Code](img/4715_04_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![函数，代码的构建块](img/4715_04_01.jpg)'
- en: As you can see, a function is a block of instructions, packaged as a whole,
    like a box. Functions can accept input arguments and produce output values. Both
    of these are optional, as we'll see in the examples in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，函数是一块指令的集合，作为一个整体打包，就像一个盒子。函数可以接受输入参数并产生输出值。这两个都是可选的，正如我们在本章的例子中将会看到的。
- en: A function in Python is defined by using the `def` keyword, after which the
    name of the function follows, terminated by a pair of braces (which may or may
    not contain input parameters) and, finally, a colon (`:`) signals the end of the
    function definition line. Immediately afterwards, indented by four spaces, we
    find the body of the function, which is the set of instructions that the function
    will execute when called.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，函数是通过使用`def`关键字定义的，之后跟随着函数名，由一对括号（可能包含或不包含输入参数）终止，最后，一个冒号（`:`）标志着函数定义行的结束。紧接着，缩进四个空格，我们找到函数的主体，这是函数被调用时将执行的一组指令。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that the indentation by four spaces is not mandatory, but it is the amount
    of spaces suggested by **PEP8**, and, in practice, it is the most widely used
    spacing measure.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用四个空格缩进不是强制性的，但它是由**PEP8**建议的空格数量，在实践中，这是最广泛使用的缩进度量。
- en: A function may or may not return output. If a function wants to return output,
    it does so by using the `return` keyword, followed by the desired output. If you
    have an eagle eye, you may have noticed the little ***** after **Optional** in
    the output section of the preceding picture. This is because a function always
    returns something in Python, even if you don't explicitly use the `return` clause.
    If the function has no `return` statement in its body, it's return value is `None`.
    The reasons behind this design choice are out of the scope of an introductory
    chapter, so all you need to know is that this behavior will make your life easier,
    as always, thank you Python.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可能返回也可能不返回输出。如果函数想要返回输出，它将通过使用`return`关键字，后跟所需的输出来实现。如果你有敏锐的眼睛，你可能已经注意到了前一张图片输出部分**可选**后面的一个小星号。这是因为Python中的函数总是返回某些东西，即使你没有明确使用`return`子句。如果一个函数在其主体中没有`return`语句，它的返回值是`None`。这个设计选择背后的原因超出了入门章节的范围，所以你只需要知道这种行为会像往常一样使你的生活更轻松，感谢Python。
- en: Why use functions?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么使用函数？
- en: 'Functions are among the most important concepts and constructs of any language,
    so let me give you a few reasons why we need them:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何语言中最重要和最基本的概念和结构之一，所以让我给你几个为什么我们需要它们的原因：
- en: They reduce code duplication in a program. By having a specific task taken care
    of by a nice block of packaged code that we can import and call whenever we want,
    we don't need to duplicate its implementation.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们减少了程序中的代码重复。通过让一个特定的任务由一个漂亮的打包代码块来处理，我们可以随时导入和调用它，我们不需要重复其实现。
- en: They help in splitting a complex task or procedure into smaller blocks, each
    of which becomes a function.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们帮助将复杂任务或程序拆分成更小的块，每个块都成为一个函数。
- en: They hide the implementation details from their users.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们将实现细节隐藏给用户。
- en: They improve traceability.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可追溯性。
- en: They improve readability.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提高了可读性。
- en: Let's look at a few examples to get a better understanding of each point.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子，以更好地理解每个要点。
- en: Reduce code duplication
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少代码重复
- en: Imagine that you are writing a piece of scientific software, and you need to
    calculate primes up to a limit, as we did in the previous chapter. You write several
    algorithms and prime numbers, being the basis of many different types of calculations,
    keep creeping into your code. Well, you have a nice algorithm to calculate them,
    so you copy and paste it to wherever you need. One day, though, your friend *Mister
    Smarty* gives you a better algorithm to calculate prime numbers, and this will
    save you a lot of time. At this point, you need to go over your whole codebase
    and replace the old code with the new code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在编写一段科学软件，你需要计算到某个限制的质数，就像我们在上一章所做的那样。你编写了几个算法和质数，作为许多不同类型计算的基础，不断地出现在你的代码中。好吧，你有一个计算它们的良好算法，所以你把它复制粘贴到你需要的地方。然而，有一天，你的朋友**聪明先生**给你提供了一个更好的计算质数的算法，这将为你节省很多时间。在这个时候，你需要检查整个代码库，用新代码替换旧代码。
- en: This is actually a very bad way to go about it. It's error-prone, you never
    know what lines you are chopping out or leaving there by mistake when you cut
    and paste code in other code, and you may also risk missing one of the places
    where prime calculation was done, leaving your software with different versions.
    Can you imagine if you discovered that the old way was buggy? You would have an
    undetected bug in your code, and bugs like this are quite hard to spot, especially
    in big codebases.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是一种非常糟糕的做法。它容易出错，你永远不知道在复制粘贴代码时，你会不小心删除或留下哪些行，你还有可能错过进行质数计算的地方，导致你的软件出现不同版本。你能想象如果你发现旧方法有错误吗？你会在代码中有一个未检测到的错误，而这种错误很难被发现，尤其是在大型代码库中。
- en: So, what should you do? Simple! You write a function, `get_prime_numbers(upto)`,
    and use it anywhere you need a list of primes. When *Mister Smarty* comes to you
    and gives you the new code, all you have to do is replace the body of that function
    with the new implementation, and you're done! The rest of the software will automatically
    adapt, since it's just calling the function.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你应该怎么做呢？很简单！你编写一个函数，`get_prime_numbers(upto)`，并在你需要质数列表的地方使用它。当**聪明先生**来给你新代码时，你只需要替换那个函数的主体部分，然后你就完成了！其余的软件将自动适应，因为它只是调用函数。
- en: Your code will be shorter, it will not suffer from inconsistencies between old
    and new ways of performing a task, or undetected bugs due to copy and paste failures
    or oversights. Use functions, and you'll only gain from it, I promise.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码会更短，它不会因为旧方法和新方法执行任务的不一致，或者由于复制粘贴失败或疏忽而导致的未检测到的错误而受到影响。使用函数，我保证你只会从中受益。
- en: Splitting a complex task
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解复杂任务
- en: Functions are very useful also to split a long or complex task into smaller
    pieces. The end result is that the code benefits from it in several ways, for
    example, readability, testability, and reuse. To give you a simple example, imagine
    that you're preparing a report. Your code needs to fetch data from a data source,
    parse it, filter it, polish it, and then a whole series of algorithms needs to
    be run against it, in order to produce the results which will feed the `Report`
    class. It's not uncommon to read procedures like this that are just one big function
    `do_report(data_source)`. There are tens or hundreds of lines of code which end
    with `return report`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也非常有用，可以将一个长或复杂的任务分解成更小的部分。结果是，代码在多个方面都从中受益，例如可读性、可测试性和可重用性。为了给你一个简单的例子，想象一下你正在准备一份报告。你的代码需要从数据源获取数据，解析它，过滤它，润色它，然后需要对它运行一系列算法，以便生成将喂养`Report`类的结果。阅读这样的程序并不罕见，它们只是一个大函数`do_report(data_source)`。有成百上千行代码以`return
    report`结束。
- en: 'Situations like this are common in code produced by scientists. They have brilliant
    minds and they care about the correctness of the end result but, unfortunately,
    sometimes they have no training in programming theory. It is not their fault,
    one cannot know everything. Now, picture in your head something like a few hundred
    lines of code. It''s very hard to follow through, to find the places where things
    are changing context (like finishing one task and starting the next one). Do you
    have the picture in your mind? Good. Don''t do it! Instead, look at this code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在科学家编写的代码中很常见。他们有卓越的头脑，他们关心最终结果是否正确，但不幸的是，他们有时没有编程理论的训练。这不是他们的错，没有人能知道一切。现在，在你的脑海中想象一些类似几百行代码的东西。要跟得上是非常困难的，要找到事情改变上下文的地方（比如完成一个任务，开始下一个任务）。你在脑海中形成了这样的画面吗？很好。不要这样做！相反，看看这段代码：
- en: '`data.science.example.py`'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`data.science.example.py`'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous example is fictitious, of course, but can you see how easy it would
    be to go through the code? If the end result looks wrong, it would be very easy
    to debug each of the single data outputs in the `do_report` function. Moreover,
    it's even easier to exclude part of the process temporarily from the whole procedure
    (you just need to comment out the parts you need to suspend). Code like this is
    easier to deal with.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子当然是虚构的，但你能否看到遍历代码有多容易？如果最终结果看起来不正确，将非常容易调试`do_report`函数中的每个单独的数据输出。此外，从整个流程中暂时排除部分过程（你只需要注释掉你需要暂停的部分）甚至更容易。这样的代码更容易处理。
- en: Hide implementation details
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐藏实现细节
- en: Let's stay with the preceding example to talk about this point as well. You
    can see that, by going through the code of the `do_report` function, you can get
    a pretty good understanding without reading one single line of implementation.
    This is because functions hide the implementation details. This feature means
    that, if you don't need to delve into details, you are not forced to, in the way
    you would if `do_report` was just one big fat function. In order to understand
    what was going on, you would have to read the implementation details. You don't
    need to with functions. This reduces the time you spend reading the code and since,
    in a professional environment, reading code takes much more time than actually
    writing it, it's very important to reduce it as much as we can.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前面的例子来讨论这个观点。你可以看到，通过阅读`do_report`函数的代码，你可以在不阅读一行实现代码的情况下获得相当好的理解。这是因为函数隐藏了实现细节。这个特性意味着，如果你不需要深入了解细节，你就不必像`do_report`只是一个庞大的函数那样被迫这样做。为了理解发生了什么，你必须阅读实现细节。你不需要用函数这样做。这减少了你阅读代码的时间，因为在专业环境中，阅读代码所花费的时间比实际编写代码的时间要多得多，因此尽可能地减少它是非常重要的。
- en: Improve readability
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可读性
- en: Coders sometimes don't see the point in writing a function with a body of one
    or two lines of code, so let's look at an example that shows you why you should
    do it.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 编程者有时看不到写一个只有一到两行代码的函数的意义，所以让我们看看一个例子，展示你为什么应该这样做。
- en: 'Imagine that you need to multiply two matrices:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你需要乘以两个矩阵：
- en: '![Improve readability](img/4715_04_03.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![提高可读性](img/4715_04_03.jpg)'
- en: 'Would you prefer to have to read this code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你更愿意阅读以下代码吗？
- en: '`matrix.multiplication.nofunc.py`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix.multiplication.nofunc.py`'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or would you prefer this one:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 或者你更喜欢这个吗？
- en: '`matrix.multiplication.func.py`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix.multiplication.func.py`'
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's much easier to understand that `c` is the result of the multiplication
    between `a` and `b` in the second example. It's much easier to read through the
    code and, if you don't need to modify that part, you don't even need to go into
    the implementation details.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，理解`c`是`a`和`b`相乘的结果要容易得多。阅读代码要容易得多，而且如果你不需要修改这部分，你甚至不需要进入实现细节。
- en: Therefore, readability is improved here while, in the first snippet, you would
    have to spend time trying to understand what that complicated list comprehension
    was doing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的可读性得到了提高，而在第一个片段中，你将不得不花时间试图理解那个复杂的列表解析到底在做什么。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't worry if you don't understand *list comprehensions*, we'll study them
    in the next chapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解*列表解析*，不要担心，我们将在下一章学习它们。
- en: Improve traceability
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高可追溯性
- en: Imagine that you have written an e-commerce website. You have displayed the
    product prices all over the pages. Imagine that the prices in your database are
    stored with no VAT, but you want to display them on the website with VAT at 20%.
    Here's a few ways of calculating the VAT-inclusive price from the VAT-exclusive
    price.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你已经编写了一个电子商务网站。你在页面上到处显示了产品价格。想象一下，你的数据库中存储的价格没有增值税，但你希望在网站上以 20% 的增值税显示它们。这里有几种从不含增值税的价格计算增值税含税价格的方法。
- en: '`vat.py`'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`vat.py`'
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All these four different ways of calculating a VAT-inclusive price are perfectly
    acceptable, and I promise you I have found them all in my colleagues' code, over
    the years. Now, imagine that you have started selling your products in different
    countries and some of them have different VAT rates so you need to refactor your
    code (throughout the website) in order to make that VAT calculation dynamic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这四种计算增值税含税价格的方法都是完全可以接受的，我保证我在过去几年里在我的同事的代码中找到了它们。现在，想象一下，你已经开始在不同的国家销售你的产品，其中一些国家有不同的增值税率，因此你需要重构你的代码（在整个网站上）以便使增值税计算动态化。
- en: How do you trace all the places in which you are performing a VAT calculation?
    Coding today is a collaborative task and you cannot be sure the VAT has been calculated
    using only one of those forms. It's going to be hell, believe me.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何追踪你执行增值税计算的所有地方？现在的编码是一个协作任务，你不能确定增值税是否只使用这些形式之一进行计算。相信我，那将会是一场灾难。
- en: So, let's write a function that takes the input values, `vat` and `price` (VAT-exclusive),
    and returns a VAT-inclusive price.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们编写一个函数，它接受输入值 `vat` 和 `price`（不含增值税），并返回增值税含税价格。
- en: '`vat.function.py`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`vat.function.py`'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now you can import that function and apply it in any place of your website where
    you need to calculate a VAT-inclusive price and when you need to trace those calls,
    you can search for `calculate_price_with_vat`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以导入这个函数并在你网站上需要计算增值税含税价格的地方应用它，当你需要追踪这些调用时，你可以搜索 `calculate_price_with_vat`。
- en: Note
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that, in the preceding example, `price` is assumed to be VAT-exclusive,
    and `vat` has a percentage value (for example, 19, 20, 23, and so on).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在先前的例子中，`price` 被假定为不含增值税，而 `vat` 有一个百分比值（例如，19、20、23 等等）。
- en: Scopes and name resolution
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域和名称解析
- en: Do you remember when we talked about scopes and namespaces in the first chapter?
    We're going to expand on that concept now. Finally, we can talk about functions
    and this will make everything easier to understand. Let's start with a very simple
    example.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在第一章讨论作用域和命名空间的时候吗？现在我们将扩展这个概念。最后，我们可以讨论函数，这将使一切更容易理解。让我们从一个非常简单的例子开始。
- en: '`scoping.level.1.py`'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoping.level.1.py`'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'I have defined the name `test` in two different places in the previous example.
    It is actually in two different scopes. One is the global scope (`test = 0`),
    and the other is the local scope of the function `my_function` (`test = 1`). If
    you execute the code, you''ll see this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我在两个不同的地方定义了 `test` 这个名字。实际上，它位于两个不同的作用域中。一个是全局作用域（`test = 0`），另一个是函数
    `my_function` 的局部作用域（`test = 1`）。如果你执行代码，你会看到这个：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It''s clear that `test = 1` shadows the assignment `test = 0` in `my_function`.
    In the global context, `test` is still `0`, as you can see from the output of
    the program but we define the name `test` again in the function body, and we set
    it to point to an integer of value `1`. Both the two `test` names therefore exist,
    one in the global scope, pointing to an `int` object with value 0, the other in
    the `my_function` scope, pointing to an `int` object with value 1\. Let''s comment
    out the line with `test = 1`. Python goes and searches for the name `test` in
    the next enclosing namespace (recall the *LEGB* rule: *Local*, *Enclosing*, *Global*,
    *Built-in* described in [Chapter 1](ch01.html "Chapter 1. Introduction and First
    Steps – Take a Deep Breath"), *Introduction and First Steps – Take a Deep Breath*)
    and, in this case, we will see the value `0` printed twice. Try it in your code.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 很明显，`test = 1` 在 `my_function` 中覆盖了赋值 `test = 0`。在全局上下文中，`test` 仍然是 `0`，正如你可以从程序的输出中看到的那样，但我们再次在函数体中定义了
    `test` 这个名字，并将其设置为指向值为 `1` 的整数。因此，这两个 `test` 名字都存在，一个在全局作用域中，指向值为 0 的 `int` 对象，另一个在
    `my_function` 作用域中，指向值为 1 的 `int` 对象。让我们注释掉 `test = 1` 这一行。Python 会去下一个封装的作用域中寻找
    `test` 这个名字（回想一下 *LEGB* 规则：*Local*，*Enclosing*，*Global*，*Built-in*，在第 1 章[第 1
    章。介绍和第一步 – 深呼吸](ch01.html "Chapter 1. Introduction and First Steps – Take a Deep
    Breath")中描述），在这种情况下，我们会看到值 `0` 被打印两次。在你的代码中试一试。
- en: 'Now, let''s raise the stakes here and level up:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们提高难度，提升一个层次：
- en: '`scoping.level.2.py`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoping.level.2.py`'
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code, we have two levels of shadowing. One level is in the
    function `outer`, and the other one is in the function `inner`. It is far from
    rocket science, but it can be tricky. If we run the code, we get:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有两个级别的阴影。一个级别在函数`outer`中，另一个级别在函数`inner`中。这并不复杂，但可能会有些棘手。如果我们运行代码，我们会得到：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try commenting out the line `test = 1`. What do you think the result will be?
    Well, when reaching the line `print('outer:', test)`, Python will have to look
    for `test` in the next enclosing scope, therefore it will find and print `0`,
    instead of `1`. Make sure you comment out `test = 2` as well, to see if you understand
    what happens, and if the LEGB rule is clear, before proceeding.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试注释掉这一行`test = 1`。你认为结果会怎样？嗯，当执行到`print('outer:', test)`这一行时，Python将不得不在下一个封闭作用域中寻找`test`，因此它会找到并打印`0`，而不是`1`。确保你也注释掉`test
    = 2`，以便理解发生了什么，并且在继续之前，LEGB规则是清晰的。
- en: Another thing to note is that Python gives you the ability to define a function
    in another function. The inner function's name is defined within the namespace
    of the outer function, exactly as would happen with any other name.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，Python允许你在另一个函数中定义一个函数。内部函数的名称是在外部函数的命名空间中定义的，这与任何其他名称的情况完全相同。
- en: The global and nonlocal statements
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局和非局部语句
- en: 'Going back to the preceding example, we can alter what happens to the shadowing
    of the test name by using one of these two special statements: `global` and `nonlocal`.
    As you can see from the previous example, when we define `test = 2` in the function
    `inner`, we overwrite `test` neither in the function `outer`, nor in the global
    scope. We can get read access to those names if we use them in a nested scope
    that doesn''t define them, but we cannot modify them because, when we write an
    assignment instruction, we''re actually defining a new name in the current scope.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 回到前面的例子，我们可以通过使用这两个特殊语句之一来改变对`test`名字的阴影：`global`和`nonlocal`。正如你从前面的例子中看到的，当我们函数`inner`中定义`test
    = 2`时，我们既没有在函数`outer`中也没有在全局作用域中覆盖`test`。如果我们使用它们在未定义它们的嵌套作用域中，我们可以获取对这些名字的读取访问，但我们不能修改它们，因为当我们写一个赋值指令时，我们实际上是在当前作用域中定义一个新的名字。
- en: 'How do we change this behavior? Well, we can use the `nonlocal` statement.
    According to the official documentation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何改变这种行为？嗯，我们可以使用`nonlocal`语句。根据官方文档：
- en: '*"The `nonlocal` statement causes the listed identifiers to refer to previously
    bound variables in the nearest enclosing scope excluding globals."*'
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"`nonlocal`语句使列出的标识符引用最近封闭作用域中先前绑定的变量，但不包括全局变量。"*'
- en: 'Let''s introduce it in the function `inner`, and see what happens:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在函数`inner`中引入它，看看会发生什么：
- en: '`scoping.level.2.nonlocal.py`'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoping.level.2.nonlocal.py`'
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice how in the body of the function `inner` I have declared the `test` name
    to be `nonlocal`. Running this code produces the following result:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在函数`inner`的主体中，我已经将`test`这个名字声明为`nonlocal`。运行这段代码会产生以下结果：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Wow, look at that result! It means that, by declaring `test` to be `nonlocal`
    in the function `inner`, we actually get to bind the name `test` to that declared
    in the function `outer`. If we removed the `nonlocal` `test` line from the function
    `inner` and tried the same trick in the function `outer`, we would get a `SyntaxError`,
    because the `nonlocal` statement works on enclosing scopes excluding the global
    one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，看看那个结果！这意味着，通过在函数`inner`中将`test`声明为`nonlocal`，我们实际上将`test`这个名字绑定到了函数`outer`中声明的那个。如果我们从函数`inner`中移除`nonlocal
    test`这一行，并在函数`outer`中尝试同样的技巧，我们会得到一个`SyntaxError`，因为`nonlocal`语句作用于封闭作用域，但不包括全局作用域。
- en: Is there a way to get to that `test = 0` in the global namespace then? Of course,
    we just need to use the `global` statement. Let's try it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 那么有没有办法在全局命名空间中访问到`test = 0`呢？当然，我们只需要使用`global`语句。让我们试试。
- en: '`scoping.level.2.global.py`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`scoping.level.2.global.py`'
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that we have now declared the name `test` to be `global`, which will basically
    bind it to the one we defined in the global namespace (`test = 0`). Run the code
    and you should get the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在已经将名字`test`声明为`global`，这基本上会将它绑定到我们在全局命名空间中定义的那个（`test = 0`）。运行代码，你应该会得到以下结果：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This shows that the name affected by the assignment `test = 2` is now the `global`
    one. This trick would also work in the `outer` function because, in this case,
    we're referring to the global scope. Try it for yourself and see what changes,
    get comfortable with scopes and name resolution, it's very important.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明受 `test = 2` 赋值影响的名称现在是全局的。这个技巧在 `outer` 函数中也会起作用，因为在这种情况下，我们是在引用全局作用域。自己试一试，看看会发生什么变化，熟悉作用域和名称解析，这非常重要。
- en: Input parameters
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 输入参数
- en: 'At the beginning of this chapter, we saw that a function can take input parameters.
    Before we delve into all possible type of parameters, let''s make sure you have
    a clear understanding of what passing a parameter to a function means. There are
    three key points to keep in mind:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们看到了一个函数可以接受输入参数。在我们深入所有可能的参数类型之前，让我们确保你对将参数传递给函数的含义有一个清晰的理解。有三个关键点需要记住：
- en: Argument passing is nothing more than assigning an object to a local variable
    name
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数传递不过是将一个对象赋值给一个局部变量名
- en: Assigning an object to an argument name inside a function doesn't affect the
    caller
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数内部将对象赋值给参数名称不会影响调用者
- en: Changing a mutable object argument in a function affects the caller
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中更改可变对象参数会影响调用者
- en: Let's look at an example for each of these points.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看每个这些点的例子。
- en: Argument passing
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数传递
- en: Take a look at the following code. We declare a name `x` in the global scope,
    then we declare a function `func(y)` and we call it, passing `x`. I highlighted
    the call in the code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的代码。我们在全局作用域中声明了一个名为 `x` 的变量，然后我们声明了一个函数 `func(y)` 并调用它，传递了 `x`。我在代码中突出了这个调用。
- en: '`key.points.argument.passing.py`'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`key.points.argument.passing.py`'
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When `func` is called with `x`, what happens is that within its local scope,
    a name `y` is created, and it''s pointed to the same object `x` is pointing to.
    This is better clarified by the following picture:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当用 `x` 调用 `func` 时，在它的局部作用域内，创建了一个名为 `y` 的变量，并且它指向了与 `x` 相同的对象。以下图片可以更好地说明这一点：
- en: '![Argument passing](img/4715_04_02.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![参数传递](img/4715_04_02.jpg)'
- en: 'The right part of the preceding picture depicts the state of the program when
    execution has reached the end, after `func` has returned (`None`). Take a look
    at the **Frames** column, and note that we have two names, **x** and **func**,
    in the global namespace (**Global frame)**, pointing to an **int** (with a value
    of three) and to a function object, respectively. Right below it, in the rectangle
    titled **func**, we can see the function''s local namespace, in which only one
    name has been defined: **y**. Because we have called **func** with **x** (line
    5 in the left part of the picture), **y** is pointing to the same object that
    **x** is pointing to. This is what happens under the hood when an argument is
    passed to a function. If we had used the name **x** instead of **y** in the function
    definition, things would have been exactly the same (only maybe a bit confusing
    at first), there would be a local **x** in the function, and a global **x** outside,
    as we saw in the *Scopes and name resolution* section.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 前一张图的右侧展示了程序执行到达末尾时的状态，在 `func` 返回 (`None`) 之后。看看 **Frames** 这一列，注意我们在全局命名空间（**Global
    frame**）中有两个名称，**x** 和 **func**，分别指向一个 **int**（值为三）和一个函数对象。在其下方，在标题为 **func**
    的矩形中，我们可以看到函数的局部命名空间，其中只定义了一个名称：**y**。因为我们用 **x**（图片左侧的第五行）调用了 **func**，所以 **y**
    指向了与 **x** 相同的对象。这就是当将参数传递给函数时幕后发生的事情。如果我们用 **x** 而不是 **y** 在函数定义中使用，事情将会完全一样（可能一开始会有些困惑），函数中会有一个局部的
    **x**，外部有一个全局的 **x**，就像我们在 *作用域和名称解析* 部分看到的那样。
- en: So, in a nutshell, what really happens is that the function creates in its local
    scope the names defined as arguments and, when we call it, we basically tell Python
    which objects those names must be pointed towards.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，真正发生的事情是函数在其局部作用域中创建了定义为参数的名称，当我们调用它时，我们基本上告诉 Python 这些名称必须指向哪些对象。
- en: Assignment to argument names don't affect the caller
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数名称的赋值不会影响调用者
- en: This is something that can be tricky to understand at first, so let's look at
    an example.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这一开始可能有点难以理解，所以让我们看看一个例子。
- en: '`key.points.assignment.py`'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`key.points.assignment.py`'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, when the line `x = 7` is executed, what happens is that
    within the local scope of the function `func`, the name `x` is pointed to an integer
    with value 7, leaving the global `x` unaltered.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，当执行到 `x = 7` 这一行时，发生的事情是在函数 `func` 的局部作用域内，名称 `x` 指向了一个值为 7 的整数，而全局的
    `x` 保持不变。
- en: Changing a mutable affects the caller
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改变可变对象会影响调用者
- en: 'This is the final point, and it''s very important because Python apparently
    behaves differently with mutables (just apparently though). Let''s look at an
    example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最后一个要点，它非常重要，因为Python显然对可变对象有不同的行为（尽管只是表面上如此）。让我们看一个例子：
- en: '`key.points.mutable.py`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`key.points.mutable.py`'
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Wow, we actually changed the original object! If you think about it, there is
    nothing weird in this behavior. The name `x` in the function is set to point to
    the caller object by the function call and within the body of the function, we're
    not changing `x`, in that we're not changing its reference, or, in other words,
    we are not changing the object `x` is pointing to. What we're doing is accessing
    that object's element at position 1, and changing its value.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们实际上改变了原始对象！如果你这么想，这种行为并没有什么奇怪的。函数中的`x`名称是通过函数调用设置为指向调用者对象的，在函数体内，我们并没有改变`x`，也就是说，我们并没有改变它的引用，或者说，我们并没有改变`x`指向的对象。我们所做的是访问该对象的第1个位置的元素，并改变它的值。
- en: 'Remember point #2: "*Assigning an object to an argument name within a function
    doesn''t affect the caller*". If that is clear to you, the following code should
    not be surprising.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记住第2点：“*在函数内部将对象赋给参数名称不会影响调用者*”。如果你明白了这一点，下面的代码应该不会让你感到惊讶。
- en: '`key.points.mutable.assignment.py`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`key.points.mutable.assignment.py`'
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Take a look at the two lines I have highlighted. At first, we just access the
    caller object again, at position 1, and change its value to number 42\. Then,
    we reassign `x` to point to the string `''something else''`. This leaves the caller
    unaltered, according to point #2, and, in fact, the output is the same as that
    of the previous snippet.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我高亮显示的两行。起初，我们只是再次访问调用者对象，在位置1，并将其值更改为数字42。然后，我们将`x`重新赋值以指向字符串`'something
    else'`。根据第2点，这不会改变调用者，实际上，输出与前面的代码片段相同。
- en: Take your time to play around with this concept and experiment with prints and
    calls to the `id` function until everything is clear in your mind. This is one
    of the key aspects of Python and it must be very clear, otherwise you risk introducing
    subtle bugs into your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个概念，并通过打印和调用`id`函数进行实验，直到你心中的一切都清楚。这是Python的一个关键方面，它必须非常清晰，否则你可能会在代码中引入微妙的错误。
- en: Now that we have a good understanding of input parameters and how they behave,
    let's see how we can specify them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地理解了输入参数及其行为，让我们看看我们如何指定它们。
- en: How to specify input parameters
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何指定输入参数
- en: There are five different ways of specifying input parameters. Let's look at
    them one by one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 有五种不同的方式来指定输入参数。让我们逐一来看。
- en: Positional arguments
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置参数
- en: Positional arguments are read from left to right and they are the most common
    type of arguments.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 位置参数从左到右读取，它们是最常见的参数类型。
- en: '`arguments.positional.py`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.positional.py`'
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There is not much else to say. They can be as numerous as you want and they
    are assigned by position. In the function call, `1` comes first, `2` comes second
    and `3` comes third, therefore they are assigned to `a`, `b` and `c` respectively.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 没有多少其他要说的话。它们可以像你想要的那样多，并且它们通过位置进行分配。在函数调用中，`1`排在第一位，`2`排在第二位，`3`排在第三位，因此它们分别分配给`a`、`b`和`c`。
- en: Keyword arguments and default values
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关键字参数和默认值
- en: '**Keyword arguments** are assigned by keyword using the `name=value` syntax.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键字参数**使用`name=value`语法通过关键字进行分配。'
- en: '`arguments.keyword.py`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.keyword.py`'
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Keyword arguments act when calling the function instead of respecting the left-to-right
    positional assignment, k. Keyword arguments are matched by name, even when they
    don't respect the definition's original position (we'll see that there is a limitation
    to this behavior later, when we mix and match different types of arguments).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '关键字参数在调用函数时起作用，而不是尊重从左到右的位置赋值，k。关键字参数通过名称匹配，即使它们不尊重定义的原始位置（我们将在后面看到，这种行为的限制）。 '
- en: The counterpart of keyword arguments, on the definition side, is **default values**.
    The syntax is the same, `name=value`, and allows us to not have to provide an
    argument if we are happy with the given default.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义方面，关键字参数的对立面是**默认值**。语法相同，`name=value`，这允许我们如果对给定的默认值满意，则不需要提供参数。
- en: '`arguments.default.py`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.default.py`'
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The are two things to notice, which are very important. First of all, you cannot
    specify a default argument on the left of a positional one. Second, note how in
    the examples, when an argument is passed without using the `argument_name=value`
    syntax, it must be the first one in the list,, and it is always assigned to `a`.
    Try and scramble those arguments and see what happens. Python error messages are
    very good at telling you what''s wrong. So, for example, if you tried something
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有两点需要注意，这两点非常重要。首先，你不能在位置参数的左侧指定默认参数。其次，注意在示例中，当一个参数没有使用`argument_name=value`语法传递时，它必须是列表中的第一个参数，并且它总是被分配给`a`。尝试打乱这些参数，看看会发生什么。Python的错误信息非常擅长告诉你出了什么问题。所以，例如，如果你尝试了以下操作：
- en: '[PRE20]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You would get the following error:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你会得到以下错误：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This informs you that you've called the function incorrectly.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉你你调用函数的方式不正确。
- en: Variable positional arguments
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变位置参数
- en: Sometimes you may want to pass a variable number of positional arguments to
    a function and Python provides you with the ability to do it. Let's look at a
    very common use case, the `minimum` function. This is a function that calculates
    the minimum of its input values.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能希望向函数传递一个可变数量的位置参数，Python为你提供了这样做的能力。让我们看看一个非常常见的用例，即`minimum`函数。这是一个计算输入值最小值的函数。
- en: '`arguments.variable.positional.py`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.variable.positional.py`'
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, when we specify a parameter prepending a `*` to its name, we
    are telling Python that that parameter will be collecting a variable number of
    positional arguments, according to how the function is called. Within the function,
    `n` is a tuple. Uncomment the `print(n)` to see for yourself and play around with
    it for a bit.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们指定一个参数，在其名称前加上`*`时，我们是在告诉Python，该参数将根据函数的调用方式收集一个可变数量的位置参数。在函数内部，`n`是一个元组。取消注释`print(n)`来亲自查看并稍作尝试。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have you noticed how we checked if `n` wasn't empty with a simple `if n:`? This
    is due to the fact that collection objects evaluate to `True` when non-empty,
    and otherwise `False` in Python. This is true for tuples, sets, lists, dictionaries,
    and so on.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有注意到我们如何用一个简单的`if n:`来检查`n`是否为空？这是因为收集对象在Python中在非空时评估为`True`，否则为`False`。这对元组、集合、列表、字典等都是成立的。
- en: One other thing to note is that we may want to throw an error when we call the
    function with no arguments, instead of silently doing nothing. In this context,
    we're not concerned about making this function robust, but in understanding variable
    positional arguments.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一点需要注意，我们可能希望在调用函数时不带任何参数时抛出错误，而不是默默地什么都不做。在这个上下文中，我们并不关心使这个函数健壮，而是理解可变位置参数。
- en: Let's make another example to show you two things that, in my experience, are
    confusing to those who are new to this.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再举一个例子来展示两个在我个人经验中对于初学者来说可能令人困惑的事情。
- en: '`arguments.variable.positional.unpacking.py`'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.variable.positional.unpacking.py`'
- en: '[PRE23]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Take a good look at the last two lines of the preceding example. In the first
    one, we call `func` with one argument, a four elements tuple. In the second example,
    by using the `*` syntax, we''re doing something called **unpacking**, which means
    that the four elements tuple is unpacked, and the function is called with four
    arguments: `1, 3, -7, 9`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细看看前面示例的最后两行。在第一个例子中，我们用包含四个元素的元组作为参数调用`func`。在第二个例子中，通过使用`*`语法，我们正在进行一种称为**拆包**的操作，这意味着四个元素的元组被拆包，函数被调用时带有四个参数：`1,
    3, -7, 9`。
- en: This behavior is part of the magic Python does to allow you to do amazing things
    when calling functions dynamically.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是Python在动态调用函数时允许你做令人惊叹的事情的魔法之一。
- en: Variable keyword arguments
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变关键字参数
- en: 'Variable keyword arguments are very similar to variable positional arguments.
    The only difference is the syntax (`**` instead of `*`) and that they are collected
    in a dictionary. Collection and unpacking work in the same way, so let''s look
    at an example:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可变关键字参数与可变位置参数非常相似。唯一的区别是语法（使用`**`而不是`*`）以及它们被收集在一个字典中。收集和拆包的工作方式相同，所以让我们看一个例子：
- en: '`arguments.variable.keyword.py`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.variable.keyword.py`'
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: All the calls are equivalent in the preceding example. You can see that adding
    a `**` in front of the parameter name in the function definition tells Python
    to use that name to collect a variable number of keyword parameters. On the other
    hand, when we call the function, we can either pass `name=value` arguments explicitly,
    or unpack a dictionary using the same `**` syntax.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，所有的调用都是等效的。你可以看到，在函数定义中参数名前加上`**`告诉 Python 使用该名称收集可变数量的关键字参数。另一方面，当我们调用函数时，我们可以明确传递`name=value`形式的参数，或者使用相同的`**`语法解包一个字典。
- en: The reason why being able to pass a variable number of keyword parameters is
    so important may not be evident at the moment, so, how about a more realistic
    example? Let's define a function that connects to a database. We want to connect
    to a default database by simply calling this function with no parameters. We also
    want to connect to any other database by passing the function the appropriate
    arguments. Before you read on, spend a couple of minutes figuring out a solution
    by yourself.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 能够传递可变数量的关键字参数之所以如此重要，可能现在还不明显，那么，让我们看看一个更实际的例子？让我们定义一个连接数据库的函数。我们希望通过不带参数调用此函数来连接默认数据库。我们还想通过传递适当的参数来连接任何其他数据库。在你继续阅读之前，花几分钟时间自己想出一个解决方案。
- en: '`arguments.variable.db.py`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.variable.db.py`'
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note in the function we can prepare a dictionary of connection parameters (`conn_params`)
    in the function using default values as fallback, allowing them to be overwritten
    if they are provided in the function call. There are better ways to do this with
    fewer lines of code but we''re not concerned with that now. Running the preceding
    code yields the following result:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在函数中，我们可以使用默认值作为后备来准备一个连接参数的字典（`conn_params`），允许在函数调用中提供时覆盖它们。有更少的代码行数来完成这个任务的方法，但我们现在不关心这个。运行前面的代码会产生以下结果：
- en: '[PRE26]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note the correspondence between the function calls and the output. Note how
    default values are either there or overridden, according to what was passed to
    the function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数调用与输出的对应关系。注意默认值要么存在，要么被传递给函数的值覆盖。
- en: Keyword-only arguments
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 仅关键字参数
- en: 'Python 3 allows for a new type of parameter: the **keyword-only** parameter.
    We are going to study them only briefly as their use cases are not that frequent.
    There are two ways of specifying them, either after the variable positional arguments,
    or after a bare *. Let''s see an example of both.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 允许一种新的参数类型：**仅关键字**参数。我们将简要研究它们，因为它们的使用场景并不频繁。指定它们有两种方式，要么在变量位置参数之后，要么在裸星号`*`之后。让我们看看两种方式的示例。
- en: '`arguments.keyword.only.py`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.keyword.only.py`'
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As anticipated, the function, `kwo`, takes a variable number of positional arguments
    (`a`) and a keyword-only function, `c`. The results of the calls are straightforward
    and you can uncomment the third call to see what error Python returns.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，函数`kwo`接受一个可变数量的位置参数（`a`）和一个仅关键字函数`c`。调用的结果很简单，你可以取消注释第三个调用以查看 Python 返回的错误。
- en: The same applies to the function, `kwo2`, which differs from `kwo` in that it
    takes a positional argument `a`, a keyword argument `b`, and then a keyword-only
    argument, `c`. You can uncomment the third call to see the error.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则也适用于函数`kwo2`，它与`kwo`的不同之处在于它接受一个位置参数`a`，一个关键字参数`b`，然后是一个仅关键字参数`c`。你可以取消注释第三个调用以查看错误。
- en: Now that you know how to specify different types of input parameters, let's
    see how you can combine them in function definitions.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何指定不同类型的输入参数，让我们看看如何在函数定义中组合它们。
- en: Combining input parameters
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合输入参数
- en: 'You can combine input parameters, as long as you follow these ordering rules:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 只要遵循以下排序规则，你就可以组合输入参数：
- en: When defining a function, normal positional arguments come first (`name`), then
    any default arguments (`name=value`), then the variable positional arguments (`*name`,
    or simply `*`), then any keyword-only arguments (either `name` or `name=value`
    form is good), then any variable keyword arguments (`**name`).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在定义函数时，正常的位置参数先于（`name`），然后是任何默认参数（`name=value`），然后是变量位置参数（`*name`，或者简单地`*`），然后是任何仅关键字参数（`name`或`name=value`形式均可），最后是任何变量关键字参数（`**name`）。
- en: 'On the other hand, when calling a function, arguments must be given in the
    following order: positional arguments first (`value`), then any combination of
    keyword arguments (`name=value`), variable positional arguments (`*name`), then
    variable keyword arguments (`**name`).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，在调用函数时，必须按照以下顺序提供参数：首先是位置参数（`value`），然后是任何组合的关键字参数（`name=value`），然后是可变位置参数（`*name`），最后是可变关键字参数（`**name`）。
- en: Since this can be a bit tricky when left hanging in the theoretical world, let's
    look at a couple of quick examples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这可能在理论世界中悬而未决，让我们看看几个快速示例。
- en: '`arguments.all.py`'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.all.py`'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note the order of the parameters in the function definition, and that the two
    calls are equivalent. In the first one, we''re using the unpacking operators for
    iterables and dictionaries, while in the second one we''re using a more explicit
    syntax. The execution of this yields (I printed only the result of one call):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 注意函数定义中参数的顺序，以及两个调用是等效的。在第一个调用中，我们使用了可迭代对象和字典的解包操作符，而在第二个调用中，我们使用了更明确的语法。执行结果如下（我只打印了一个调用的结果）：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's now look at an example with keyword-only arguments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在来看一个有关关键字参数的例子。
- en: '`arguments.all.kwonly.py`'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.all.kwonly.py`'
- en: '[PRE30]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Note that I have highlighted the keyword-only arguments in the function declaration.
    They come after the variable positional argument `*args`, and it would be the
    same if they came right after a single `*` (in which case there wouldn''t be a
    variable positional argument). The execution of this yields (I printed only the
    result of one call):'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在函数声明中突出显示了关键字参数。它们位于可变位置参数`*args`之后，如果它们直接跟在单个`*`之后（在这种情况下，将没有可变位置参数），结果也会相同。执行结果如下（我只打印了一个调用的结果）：
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'One other thing to note are the names I gave to the variable positional and
    keyword arguments. You''re free to choose differently, but be aware that `args`
    and `kwargs` are the conventional names given to these parameters, at least generically.
    Now that you know how to define a function in all possible flavors, let me show
    you something tricky: mutable defaults.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一件事需要注意是我给可变位置参数和关键字参数取的名字。你可以自由选择不同的名字，但请注意，`args`和`kwargs`是这些参数的传统名称，至少在通用意义上。现在，既然你已经知道了如何以所有可能的方式定义函数，让我给你展示一个有点棘手的东西：可变默认值。
- en: Avoid the trap! Mutable defaults
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免陷阱！可变默认值
- en: 'One thing to be very aware of with Python is that default values are created
    at `def` time, therefore, subsequent calls to the same function will possibly
    behave differently according to the mutability of their default values. Let''s
    look at an example:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有一件事需要我们非常注意，那就是默认值是在`def`时创建的，因此，对同一函数的后续调用可能会根据其默认值的可变性表现出不同的行为。让我们来看一个例子：
- en: '`arguments.defaults.mutable.py`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.defaults.mutable.py`'
- en: '[PRE32]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The parameters both have mutable default values. This means that, if you affect
    those objects, any modification will stick around in subsequent function calls.
    See if you can understand the output of those calls:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数都有可变默认值。这意味着，如果你影响了这些对象，任何修改都会在后续的函数调用中保留。看看你是否能理解这些调用的输出：
- en: '[PRE33]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It's interesting, isn't it? While this behavior may seem very weird at first,
    it actually makes sense, and it's very handy, for example, when using memoization
    techniques (Google an example of that, if you're interested).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣，不是吗？虽然一开始这种行为可能看起来非常奇怪，但实际上它是有道理的，而且非常方便，例如，在使用记忆化技术时（如果你感兴趣，可以谷歌搜索一个例子）。
- en: 'Even more interesting is what happens when, between the calls, we introduce
    one that doesn''t use defaults, like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 更有趣的是，当在调用之间引入一个不使用默认值的调用时会发生什么，就像这样：
- en: '`arguments.defaults.mutable.intermediate.call.py`'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.defaults.mutable.intermediate.call.py`'
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When we run this code, this is the output:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这段代码时，这是输出结果：
- en: '[PRE35]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This output shows us that the defaults are retained even if we call the function
    with other values. One question that comes to mind is, how do I get a fresh empty
    value every time? Well, the convention is the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出显示，即使我们用其他值调用函数，默认值也会保留。一个自然而然的问题就是，我如何每次都得到一个全新的空值？嗯，惯例是这样的：
- en: '`arguments.defaults.mutable.no.trap.py`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`arguments.defaults.mutable.no.trap.py`'
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that, by using the preceding technique, if `a` isn't passed when calling
    the function, you always get a brand new empty list.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过使用前面的技术，如果在调用函数时没有传递`a`，你总是会得到一个全新的空列表。
- en: Okay, enough with the input, let's look at the other side of the coin, the output.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，关于输入的部分就到这里吧，让我们来看看硬币的另一面，输出。
- en: Return values
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值
- en: Return values of functions are one of those things where Python is light years
    ahead of most other languages. Functions are usually allowed to return one object
    (one value) but, in Python, you can return a tuple, and this implies that you
    can return whatever you want. This feature allows a coder to write software that
    would be much harder to write in any other language, or certainly more tedious.
    We've already said that to return something from a function we need to use the
    `return` statement, followed by what we want to return. There can be as many return
    statements as needed in the body of a function.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是那些Python在大多数其他语言中领先的地方之一。通常允许函数返回一个对象（一个值），但在Python中，你可以返回一个元组，这意味着你可以返回任何你想要的东西。这个特性允许程序员编写在其他任何语言中难以编写或肯定更繁琐的软件。我们之前已经说过，要从函数中返回某些内容，我们需要使用`return`语句，后面跟着我们想要返回的内容。在函数体中可以有任意多的`return`语句。
- en: On the other hand, if within the body of a function we don't return anything,
    the function will return `None`. This behavior is harmless and, even though I
    don't have the room here to go into detail explaining why Python was designed
    like this, let me just tell you that this feature allows for several interesting
    patterns, and confirms Python as a very consistent language.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果在函数体中我们不返回任何内容，函数将返回`None`。这种行为是无害的，尽管我没有足够的空间在这里详细解释为什么Python被设计成这样，但让我告诉你，这个特性允许实现几个有趣的模式，并证实Python是一个非常一致的语言。
- en: 'I say it''s harmless because you are never forced to collect the result of
    a function call. I''ll show you what I mean with an example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是无害的，因为你永远不会被迫收集函数调用的结果。我会用一个例子来展示我的意思：
- en: '`return.none.py`'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`return.none.py`'
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that the whole body of the function is comprised only of the `pass` statement.
    As the official documentation tells us, `pass` is a null operation. When it is
    executed, nothing happens. It is useful as a placeholder when a statement is required
    syntactically, but no code needs to be executed. In other languages, we would
    probably just indicate that with a pair of curly braces (`{}`), which define an
    *empty scope* but in Python a scope is defined by indenting code, therefore a
    statement such as `pass` is necessary.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，整个函数体只包含`pass`语句。正如官方文档所告诉我们的，`pass`是一个空操作。当它被执行时，什么都不会发生。当需要语法上的语句但不需要执行任何代码时，它很有用。在其他语言中，我们可能会用一对花括号（`{}`）来表示，这对花括号定义了一个*空范围*，但在Python中，范围是通过缩进来定义的，因此需要一个像`pass`这样的语句。
- en: Notice also that the first call of the function `func` returns a value (`None`)
    which we don't collect. As I said before, collecting the return value of a function
    call is not mandatory.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，函数`func`的第一个调用返回一个值（`None`），我们没有收集它。正如我之前说的，收集函数调用的返回值不是强制的。
- en: 'Now, that''s good but not very interesting so, how about we write an interesting
    function? Remember that in [Chapter 1](ch01.html "Chapter 1. Introduction and
    First Steps – Take a Deep Breath"), *Introduction and First Steps – Take a Deep
    Breath*, we talked about the factorial of a function. Let''s write our own here
    (for simplicity, I will assume the function is always called correctly with appropriate
    values so I won''t sanity-check on the input argument):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这很好，但不是很吸引人，那么我们写一个有趣的函数怎么样？记住，在[第1章](ch01.html "第1章。简介和第一步 – 深呼吸")中，*简介和第一步
    – 深呼吸*，我们讨论了函数的阶乘。让我们在这里写一个自己的（为了简单起见，我将假设函数总是以适当的值正确调用，所以我不需要在输入参数上进行合理性检查）：
- en: '`return.single.value.py`'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`return.single.value.py`'
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that we have two points of return. If `n` is either `0` or `1` (in Python
    it's common to use the `in` type of check as I did instead of the more verbose
    `if n ==0 or n == 1:`), we return `1`. Otherwise, we perform the required calculation,
    and we return `result`. Can we write this function a little bit more Pythonically?
    Yes, but I'll let you figure out that for yourself, as an exercise.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有两个返回点。如果`n`是`0`或`1`（在Python中，使用`in`类型的检查比更冗长的`if n == 0 or n == 1:`更常见），我们返回`1`。否则，我们执行所需的计算，并返回`result`。我们能把这个函数写得更有Python风格吗？是的，但我会让你自己作为练习来找出这一点。
- en: '`return.single.value.2.py`'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`return.single.value.2.py`'
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I know what you're thinking, one line? Python is elegant, and concise! I think
    this function is readable even if you have never seen `reduce` or `mul`, but if
    you can't read it or understand it, set aside a few minutes and do some research
    on the Python documentation until its behavior is clear to you. Being able to
    look up functions in the documentation and understand code written by someone
    else is a task every developer needs to be able to perform, so think of this as
    a good exercise, and good luck!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么，一行？Python既优雅又简洁！我认为即使你没有见过`reduce`或`mul`，这个函数也是可读的，但如果你不能阅读它或理解它，请留出几分钟时间，做一些关于Python文档的研究，直到你对其行为有清晰的认识。在文档中查找函数并理解他人编写的代码是每个开发者都需要能够执行的任务，所以把这看作是一个好的练习，祝你好运！
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To this end, make sure you look up the `help` function, which comes in very
    handy exploring with the console.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了这个目的，确保你查阅了`help`函数，这在用控制台探索时非常有用。
- en: Returning multiple values
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回多个值
- en: 'Unlike in most other languages, in Python it''s very easy to return multiple
    objects from a function. This feature opens up a whole world of possibilities
    and allows you to code in a style that is hard to reproduce with other languages.
    Our thinking is limited by the tools we use, therefore when Python gives you more
    freedom than other languages, it is actually boosting your own creativity as well.
    To return multiple values is very easy, you just use tuples (either explicitly
    or implicitly). Let''s look at a simple example that mimics the `divmod` built-in
    function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他语言不同，在Python中从函数中返回多个对象非常容易。这个特性打开了一个全新的世界，并允许你以其他语言难以复制的风格进行编码。我们的思维受到我们使用的工具的限制，因此当Python给你比其他语言更多的自由时，实际上是在提升你自己的创造力。要返回多个值非常简单，你只需使用元组（无论是显式还是隐式）。让我们看看一个简单的例子，它模拟了内置的`divmod`函数：
- en: '`return.multiple.py`'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`return.multiple.py`'
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: I could have wrapped the highlighted part in the preceding code in braces, making
    it an explicit tuple, but there's no need for that. The preceding function returns
    both the result and the remainder of the division, at the same time.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我本可以将前面代码中高亮的部分用大括号括起来，使其成为一个显式的元组，但这样做没有必要。前面的函数同时返回了除法的结果和余数。
- en: A few useful tips
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些有用的技巧
- en: 'When writing functions, it''s very useful to follow guidelines so that you
    write them well. I''ll quickly point some of them out here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写函数时，遵循一些指导原则非常有用，这样你就能写出好的函数。我会快速指出其中的一些：
- en: '**Functions should do one thing**: Functions that do one thing are easy to
    describe in one short sentence. Functions which do multiple things can be split
    into smaller functions which do one thing. These smaller functions are usually
    easier to read and understand. Remember the data science example we saw a few
    pages ago.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应该只做一件事**：只做一件事的函数可以用一句话简单描述。做多件事的函数可以拆分成更小的函数，这些小函数通常更容易阅读和理解。记得我们之前几页看到的那个数据科学例子。'
- en: '**Functions should be small**: The smaller they are, the easier it is to test
    them and to write them so that they do one thing.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数应该小而简单**：它们越小，就越容易测试，也越容易编写，以便它们只做一件事。'
- en: '**The fewer input parameters, the better**: Functions which take a lot of arguments
    quickly become harder to manage (among other issues).'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**输入参数越少越好**：需要很多参数的函数很快就会变得难以管理（以及其他问题）。'
- en: '**Functions should be consistent in their return values**: Returning `False`
    or `None` is not the same thing, even if within a Boolean context they both evaluate
    to `False`. `False` means that we have information (`False`), while `None` means
    that there is no information. Try writing functions which return in a consistent
    way, no matter what happens in their body.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数的返回值应该一致**：返回`False`或`None`并不相同，即使它们在布尔上下文中都评估为`False`。`False`表示我们有信息（`False`），而`None`表示没有信息。尝试编写在函数体中无论发生什么都能以一致方式返回的函数。'
- en: '**Functions shouldn''t have side effects**: In other words, functions should
    not affect the values you call them with. This is probably the hardest statement
    to understand at this point, so I''ll give you an example using lists. In the
    following code, note how `numbers` is not sorted by the `sorted` function, which
    actually returns a sorted copy of `numbers`. Conversely, the `list.sort()` method
    is acting on the `numbers` object itself, and that is fine because it is a method
    (a function that belongs to an object and therefore has the rights to modify it):'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数不应该有副作用**：换句话说，函数不应该影响你调用它们时传递的值。这一点可能是目前最难理解的观点，所以我将用一个使用列表的例子来解释。在下面的代码中，注意`numbers`并不是由`sorted`函数排序的，实际上`sorted`函数返回的是`numbers`的排序副本。相反，`list.sort()`方法是在`numbers`对象本身上操作的，这是可以的，因为它是一个方法（一个属于对象的函数，因此有权修改它）：'
- en: '[PRE41]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Follow these guidelines and you'll write better functions, which will serve
    you well.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循这些指南，你将能写出更好的函数，这对你的工作大有裨益。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Chapter 3*, *Functions* in *Clean Code* by Robert C. Martin, Prentice Hall
    is dedicated to functions and it''s probably the best set of guidelines I''ve
    ever read on the subject.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '*《Clean Code》第三章节，*函数*，由罗伯特·C·马丁撰写，由Prentice Hall出版，专门讨论函数，这可能是我在这个主题上读过的最好的指南集。'
- en: Recursive functions
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归函数
- en: When a function calls itself to produce a result, it is said to be **recursive**.
    Sometimes recursive functions are very useful in that they make it easier to write
    code. Some algorithms are very easy to write using the recursive paradigm, while
    others are not. There is no recursive function that cannot be rewritten in an
    iterative fashion, so it's usually up to the programmer to choose the best approach
    for the case at hand.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用自身以产生结果时，它被称为**递归**。有时递归函数非常有用，因为它们使编写代码变得更容易。有些算法使用递归范式编写起来非常容易，而有些则不然。没有哪个递归函数不能重写为迭代形式，所以通常取决于程序员根据具体情况选择最佳方法。
- en: A recursive function usually has a set of base cases for which the return value
    doesn't depend on a subsequent call to the function itself and a set of recursive
    cases, for which the return value is calculated with one or more calls to the
    function itself.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 递归函数通常有一组基本案例，其返回值不依赖于对函数本身的后续调用，以及一组递归案例，其返回值是通过一个或多个对函数本身的调用来计算的。
- en: 'As an example, we can consider the (hopefully familiar by now) `factorial`
    function *N!*. The base case is when *N* is either 0 or 1\. The function returns
    1 with no need for further calculation. On the other hand, in the general case,
    *N!* returns the product *1 * 2 * ... * (N-1) * N*. If you think about it, *N!*
    can be rewritten like this: *N! = (N-1)! * N*. As a practical example, consider
    *5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5*.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以考虑（希望现在已经熟悉）的`factorial`函数 *N!*。基本案例是当 *N* 为0或1时。函数不需要进一步计算就返回1。另一方面，在一般情况下，*N!*
    返回 *1 * 2 * ... * (N-1) * N* 的乘积。如果你这么想，*N!* 可以重写为：*N! = (N-1)! * N*。作为一个实际例子，考虑
    *5! = 1 * 2 * 3 * 4 * 5 = (1 * 2 * 3 * 4) * 5 = 4! * 5*。
- en: 'Let''s write this down in code:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用代码来记录这一点：
- en: '`recursive.factorial.py`'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '`recursive.factorial.py`'
- en: '[PRE42]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When writing recursive functions, always consider how many nested calls you
    make, there is a limit. For further information on this, check out `sys.getrecursionlimit()`
    and `sys.setrecursionlimit()`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写递归函数时，始终考虑你做了多少嵌套调用，这是有限制的。有关此方面的更多信息，请查看`sys.getrecursionlimit()`和`sys.setrecursionlimit()`。
- en: Recursive functions are used a lot when writing algorithms and they can be really
    fun to write. As a good exercise, try to solve a couple of simple problems using
    both a recursive and an iterative approach.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写算法时，递归函数被大量使用，编写它们确实很有趣。作为一个好的练习，尝试使用递归和迭代两种方法解决几个简单的问题。
- en: Anonymous functions
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 匿名函数
- en: One last type of functions that I want to talk about are **anonymous** functions.
    These functions, which are called **lambdas** in Python, are usually used when
    a fully-fledged function with its own name would be overkill, and all we want
    is a quick, simple one-liner that does the job.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想讨论的一种函数类型是**匿名**函数。这些函数在Python中被称为**lambda**函数，通常在不需要具有自己名称的完整函数时使用，我们只需要一个快速、简单的单行代码来完成工作。
- en: 'Imagine that you want a list of all the numbers up to *N* which are multiples
    of five. Imagine that you want to filter those out using the `filter` function,
    which takes a function and an iterable and constructs a filter object which you
    can iterate on, from those elements of iterable for which the function returns
    `True`. Without using an anonymous function, you would do something like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要一个包含所有乘以五的数字的列表，直到*N*。假设你想使用`filter`函数过滤这些数字，该函数接受一个函数和一个可迭代对象，并从返回`True`的可迭代对象元素中构建一个过滤器对象，你可以迭代它。不使用匿名函数，你会这样做：
- en: '`filter.regular.py`'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter.regular.py`'
- en: '[PRE43]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I have highlighted the main logic of `get_multiples_of_five`. Note how the
    filter uses `is_multiple_of_five` to filter the first *n* natural numbers. This
    seems a bit excessive, the task is simple and we don''t need to keep the `is_multiple_of_five`
    function around for anything else. Let''s rewrite it using a lambda function:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我突出了`get_multiples_of_five`的主要逻辑。注意过滤器如何使用`is_multiple_of_five`来过滤前*n*个自然数。这似乎有点过度，任务很简单，我们不需要保留`is_multiple_of_five`函数用于其他任何事情。让我们使用lambda函数重写它：
- en: '`filter.lambda.py`'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter.lambda.py`'
- en: '[PRE44]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The logic is exactly the same but the filtering function is now a lambda. Defining
    a lambda is very easy and follows this form: `func_name = lambda [parameter_list]:
    expression`. A function object is returned, which is equivalent to this: `def
    func_name([parameter_list]): return expression`.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '逻辑完全相同，但过滤函数现在是一个lambda。定义lambda非常简单，遵循以下形式：`func_name = lambda [parameter_list]:
    expression`。返回的是一个函数对象，它与以下内容等价：`def func_name([parameter_list]): return expression`。'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that optional parameters are indicated following the common syntax of wrapping
    them in square brackets.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，可选参数按照常见的语法用方括号括起来表示。
- en: 'Let''s look at another couple of examples of equivalent functions defined in
    the two forms:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看两种形式定义的等价函数的另一个例子：
- en: '`lambda.explained.py`'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`lambda.explained.py`'
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding examples are very simple. The first one adds two numbers, and
    the second one produces the uppercase version of a string. Note that I assigned
    what is returned by the `lambda` expressions to a name (`adder_lambda`, `to_upper_lambda`),
    but there is no need for that when you use lambdas in the way we did in the `filter`
    example before.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例非常简单。第一个示例是添加两个数字，第二个示例是生成字符串的大写版本。请注意，我将`lambda`表达式返回的值赋给了一个名字（`adder_lambda`、`to_upper_lambda`），但在我们之前在`filter`示例中使用lambda的方式时，并不需要这样做。
- en: Function attributes
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数属性
- en: 'Every function is a fully-fledged object and, as such, they have many attributes.
    Some of them are special and can be used in an introspective way to inspect the
    function object at runtime. The following script is an example that shows all
    of them and how to display their value for an example function:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都是一个完整的对象，因此它们具有许多属性。其中一些是特殊的，可以在运行时以自省的方式使用，以检查函数对象。以下脚本是一个示例，展示了所有这些属性以及如何显示示例函数的值：
- en: '`func.attributes.py`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`func.attributes.py`'
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'I used the built-in `getattr` function to get the value of those attributes.
    `getattr(obj, attribute)` is equivalent to `obj.attribute` and comes in handy
    when we need to get an attribute at runtime using its string name. Running this
    script yields:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了内置的`getattr`函数来获取这些属性的值。`getattr(obj, attribute)`等同于`obj.attribute`，在需要使用字符串名称在运行时获取属性时非常有用。运行此脚本会产生：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: I have omitted the value of the `__globals__` attribute, it was too big. An
    explanation of the meaning of this attribute can be found in the *types* section
    of the *Python Data Model* documentation page.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我省略了`__globals__`属性的值，因为它太大。关于此属性含义的解释可以在*Python数据模型*文档页面的*类型*部分找到。
- en: Built-in functions
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: Python comes with a lot of built-in functions. They are available anywhere and
    you can get a list of them by inspecting the `builtin` module with `dir(__builtin__)`,
    or by going to the official Python documentation. Unfortunately, I don't have
    the room to go through all of them here. Some of them we've already seen, such
    as `any`, `bin`, `bool`, `divmod`, `filter`, `float`, `getattr`, `id`, `int`,
    `len`, `list`, `min`, `print`, `set`, `tuple`, `type`, and `zip`, but there are
    many more, which you should read at least once.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了许多内置函数。它们在任何地方都可以使用，你可以通过检查`builtin`模块的`dir(__builtin__)`或访问官方Python文档来获取它们的列表。不幸的是，我没有足够的空间在这里全部介绍它们。我们已经看到了一些，例如`any`、`bin`、`bool`、`divmod`、`filter`、`float`、`getattr`、`id`、`int`、`len`、`list`、`min`、`print`、`set`、`tuple`、`type`和`zip`，但还有很多，你应该至少阅读一次。
- en: Get familiar with them, experiment, write a small piece of code for each of
    them, make sure you have them at the tip of your fingers so that you can use them
    when you need them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 熟悉它们，进行实验，为每个编写一小段代码，确保你能够随时使用它们。
- en: One final example
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个最后的例子
- en: Before we finish off this chapter, how about a final example? I was thinking
    we could write a function to generate a list of prime numbers up to a limit. We've
    already seen the code for this so let's make it a function and, to keep it interesting,
    let's optimize it a bit.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束这一章之前，不妨举一个最后的例子？我想我们可以编写一个函数来生成一个小于等于某个限制的质数列表。我们已经看到了这段代码，让我们将其变成一个函数，并且为了保持趣味性，让我们对其进行一些优化。
- en: 'It turns out that you don''t need to divide it by all numbers from 2 to *N*-1
    to decide if a number *N* is prime. You can stop at ![One final example](img/4715_04_04.jpg).
    Moreover, you don''t need to test the division for all numbers from 2 to ![One
    final example](img/4715_04_04.jpg), you can just use the primes in that range.
    I''ll leave it to you to figure out why this works, if you''re interested. Let''s
    see how the code changes:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你不需要将一个数除以从 2 到 *N*-1 的所有数来决定一个数 *N* 是否为质数。你可以在 ![一个最后的例子](img/4715_04_04.jpg)
    处停止。此外，你不需要对从 2 到 ![一个最后的例子](img/4715_04_04.jpg) 的所有数进行除法测试，你只需使用该范围内的质数即可。如果你感兴趣，我会让你自己找出为什么这会起作用。让我们看看代码如何变化：
- en: '`primes.py`'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`primes.py`'
- en: '[PRE48]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The code is the same as in the previous chapter. We have changed the division
    algorithm so that we only test divisibility using the previously calculated primes
    and we stopped once the testing divisor was greater than the root of the candidate.
    We used the result list `primelist` to get the primes for the division. We calculated
    the root value using a fancy formula, the integer value of the ceiling of the
    root of the candidate. While a simple `int(k ** 0.5) + 1` would have served our
    purpose as well, the formula I chose is cleaner and requires me to use a couple
    of imports, which I wanted to show you. Check out the functions in the `math`
    module, they are very interesting!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 代码与上一章相同。我们改变了除法算法，以便我们只使用之前计算出的质数来测试可除性，并且一旦测试除数大于候选数的平方根，我们就停止测试。我们使用一个花哨的公式来计算根值，即候选数根的整数上界。虽然简单的
    `int(k ** 0.5) + 1` 也能达到我们的目的，但我选择的公式更简洁，需要我使用几个导入，我想向你展示。查看 `math` 模块中的函数，它们非常有趣！
- en: Documenting your code
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录你的代码
- en: I'm a big fan of code that doesn't need documentation. When you program correctly,
    choose the right names and take care of the details, your code should come out
    as self-explanatory and documentation should not be needed. Sometimes a comment
    is very useful though, and so is some documentation. You can find the guidelines
    for documenting Python in *PEP257 – Docstring conventions*, but I'll show you
    the basics here.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我非常喜欢不需要文档的代码。当你正确编程，选择合适的名称并注意细节时，你的代码应该是自解释的，不需要文档。尽管有时注释和一些文档非常有用。你可以通过 *PEP257
    – Docstring conventions* 找到记录 Python 的指南，但我会在这里展示基础知识。
- en: Python is documented with strings, which are aptly called **docstrings**. Any
    object can be documented, and you can use either one-line or multi-line docstrings.
    One-liners are very simple. They should not provide another signature for the
    function, but clearly state its purpose.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: Python 使用字符串进行文档记录，这些字符串被称为 **docstrings**。任何对象都可以进行文档记录，你可以使用单行或多行 docstrings。单行非常简单。它们不应该为函数提供另一个签名，但应清楚地说明其目的。
- en: '`docstrings.py`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`docstrings.py`'
- en: '[PRE49]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Using triple double-quoted strings allows you to expand easily later on. Use
    sentences that end in a period, and don't leave blank lines before or after.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 使用三重双引号字符串可以让你轻松地稍后扩展。使用以句号结尾的句子，并且不要在前后留空白行。
- en: Multi-line comments are structured in a similar way. There should be a one-liner
    that briefly gives you the gist of what the object is about, and then a more verbose
    description. As an example, I have documented a fictitious `connect` function,
    using the Sphinx notation, in the following example.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 多行注释的结构与此类似。应该有一行简短地描述对象的主要内容，然后是一个更详细的描述。例如，我使用 Sphinx 语法在以下示例中记录了一个虚构的 `connect`
    函数。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Sphinx** is probably the most widely used tool for creating Python documentation.
    In fact, the official Python documentation was written with it. It''s definitely
    worth spending some time checking it out.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sphinx** 可能是创建 Python 文档最广泛使用的工具。实际上，官方的 Python 文档就是用它编写的。花些时间了解它绝对是值得的。'
- en: '`docstrings.py`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`docstrings.py`'
- en: '[PRE50]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Importing objects
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入对象
- en: 'Now that you know a lot about functions, let''s see how to use them. The whole
    point of writing functions is to be able to later reuse them, and this in Python
    translates to importing them into the namespace in which you need them. There
    are many different ways to import objects into a namespace, but the most common
    ones are just two: `import module_name` and `from module_name import function_name`.
    Of course, these are quite simplistic examples, but bear with me for the time
    being.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对函数了解得很多了，让我们看看如何使用它们。编写函数的整个目的就是为了能够以后重用它们，在 Python 中这表示将它们导入到你需要的命名空间中。将对象导入命名空间的方法有很多种，但最常见的就是两种：`import
    module_name` 和 `from module_name import function_name`。当然，这些只是相当简单的例子，但请耐心等待。
- en: The form `import module_name` finds the module `module_name` and defines a name
    for it in the local namespace where the `import` statement is executed.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 形式 `import module_name` 会找到 `module_name` 模块，并在执行 `import` 语句的本地命名空间中为其定义一个名称。
- en: The form `from module_name import identifier` is a little bit more complicated
    than that, but basically does the same thing. It finds `module_name` and searches
    for an attribute (or a submodule) and stores a reference to `identifier` in the
    local namespace.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 形式 `from module_name import identifier` 比那要复杂一点，但基本上做的是同样的事情。它会找到 `module_name`
    并搜索一个属性（或子模块），并将 `identifier` 的引用存储在本地命名空间中。
- en: 'Both forms have the option to change the name of the imported object using
    the `as` clause, like this:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 两种形式都有使用 `as` 子句更改导入对象名称的选项，如下所示：
- en: '[PRE51]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Just to give you a flavor of what importing looks like, here''s an example
    from a test module of a number theory library I wrote some years ago (it''s available
    on Bitbucket):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你对导入有一个直观的了解，这里有一个例子，来自我几年前编写的一个数论库的测试模块（它在 Bitbucket 上可用）：
- en: '`karma/test_nt.py`'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`karma/test_nt.py`'
- en: '[PRE52]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'I commented some of them and I hope it''s easy to follow. When you have a structure
    of files starting in the root of your project, you can use the dot notation to
    get to the object you want to import into your current namespace, be it a package,
    a module, a class, a function, or anything else. The `from module import` syntax
    also allows a catch-all clause `from module import *`, which is sometimes used
    to get all the names from a module into the current namespace at once, but it''s
    frowned upon for several reasons: performances, the risk of silently shadowing
    other names, and so on. You can read all that there is to know about imports in
    the official Python documentation but, before we leave the subject, let me give
    you a better example.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我对其中的一些进行了注释，希望这很容易理解。当你有一个从项目根目录开始的文件结构时，你可以使用点符号来获取你想要导入到当前命名空间的对象，无论是包、模块、类、函数还是其他任何东西。`from
    module import` 语法还允许一个通配符子句 `from module import *`，有时用于一次性将模块中的所有名称导入到当前命名空间中，但出于几个原因，这并不被推荐：性能、静默覆盖其他名称的风险等等。你可以在官方
    Python 文档中找到有关导入的所有信息，但在我们离开这个话题之前，让我给你一个更好的例子。
- en: 'Imagine that you have defined a couple of functions: `square(n)` and `cube(n)`
    in a module, `funcdef.py`, which is in the `lib` folder. You want to use them
    in a couple of modules which are at the same level of the `lib` folder, called
    `func_import.py`, and `func_from.py`. Showing the tree structure of that project
    produces something like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个模块中定义了一些函数：`square(n)` 和 `cube(n)`，该模块名为 `funcdef.py`，位于 `lib` 文件夹中。你想要在位于
    `lib` 文件夹同一级别的几个模块中使用它们，这些模块分别叫做 `func_import.py` 和 `func_from.py`。显示该项目的树结构会产生如下内容：
- en: '[PRE53]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Before I show you the code of each module, please remember that in order to
    tell Python that it is actually a package, we need to put a `__init__.py` module
    in it.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向你展示每个模块的代码之前，请记住，为了告诉 Python 它实际上是一个包，我们需要在其中放置一个 `__init__.py` 模块。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are two things to note about the `__init__.py` file. First of all, it
    is a fully fledged Python module so you can put code into it as you would with
    any other module. Second, as of Python 3.3, its presence is no longer required
    to make a folder be interpreted as a Python package.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `__init__.py` 文件有两点需要注意。首先，它是一个完整的 Python 模块，所以你可以像在其他模块中一样在其中放置代码。其次，从 Python
    3.3 开始，它的存在不再是将文件夹解释为 Python 包所必需的。
- en: 'The code is as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下：
- en: '`funcdef.py`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`funcdef.py`'
- en: '[PRE54]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`func_import.py`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`func_import.py`'
- en: '[PRE55]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '`func_from.py`'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '`func_from.py`'
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Both these files, when executed, print `100` and `1000`. You can see how differently
    we then access the `square` and `cube` functions, according to how and what we
    imported in the current scope.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个文件在执行时都会打印`100`和`1000`。你可以看到我们如何根据当前作用域中导入的方式和内容，以不同的方式访问`square`和`cube`函数。
- en: Relative imports
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对导入
- en: 'The imports we''ve seen until now are called absolute, that is to say they
    define the whole path of the module that we want to import, or from which we want
    to import an object. There is another way of importing objects into Python, which
    is called relative import. It''s helpful in situations in which we want to rearrange
    the structure of large packages without having to edit sub-packages, or when we
    want to make a module inside a package able to import itself. Relative imports
    are done by adding as many leading dots in front of the module as the number of
    folders we need to backtrack, in order to find what we''re searching for. Simply
    put, it is something like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们至今所看到的导入被称为绝对导入，也就是说，它们定义了我们想要导入的模块的整个路径，或者我们想要从中导入对象的路径。在Python中导入对象还有另一种方式，称为相对导入。在需要重新组织大型包的结构而不必编辑子包，或者当我们想要使包内的模块能够导入自身时，这种方法很有帮助。相对导入是通过在模块前添加与我们需要回溯的文件夹数量相同数量的前导点来完成的，以便找到我们正在寻找的内容。简单来说，它就像这样：
- en: '[PRE57]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: For a complete explanation of relative imports, refer to **PEP328** ([https://www.python.org/dev/peps/pep-0328](https://www.python.org/dev/peps/pep-0328)).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相对导入的完整解释，请参考**PEP328** ([https://www.python.org/dev/peps/pep-0328](https://www.python.org/dev/peps/pep-0328))。
- en: In later chapters, we'll create projects using different libraries and we'll
    use several different types of imports, including relative ones, so make sure
    you take a bit of time to read up about it in the official Python documentation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在后面的章节中，我们将使用不同的库来创建项目，并且我们会使用几种不同类型的导入，包括相对导入，所以请确保你花一些时间在官方Python文档中阅读相关内容。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, finally we explored the world of functions. They are extremely
    important and, from now on, we'll use them basically everywhere. We talked about
    the main reasons for using them, the most important of which are code reuse and
    implementation hiding.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们终于探索了函数的世界。它们极其重要，从现在开始，我们将基本上在所有地方使用它们。我们讨论了使用函数的主要原因，其中最重要的是代码重用和实现隐藏。
- en: We saw that a function object is like a box that takes optional input and produces
    output. We can feed input values to a function in many different ways, using positional
    and keyword arguments, and using variable syntax for both types.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到函数对象就像一个盒子，它接受可选输入并产生输出。我们可以通过多种方式向函数提供输入值，使用位置参数和关键字参数，以及使用变量语法来处理这两种类型。
- en: Now you should know how to write a function, how to document it, import it into
    your code, and call it.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你应该知道如何编写一个函数，如何对其进行文档化，将其导入到你的代码中，并调用它。
- en: The next chapter will force me to push my foot down on the throttle even more
    so I suggest you take any opportunity you get to consolidate and enrich the knowledge
    you've gathered until now by putting your nose into the Python official documentation.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将迫使我进一步加大油门，所以我建议你抓住任何机会，通过深入研究Python官方文档来巩固和丰富你至今所积累的知识。
- en: Ready for the cool stuff? Let's go!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 准备好迎接酷炫的内容了吗？让我们开始吧！
