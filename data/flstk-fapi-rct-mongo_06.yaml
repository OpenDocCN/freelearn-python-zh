- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Authentication and Authorization
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证和授权
- en: The concepts of authentication—proving that the user is who they claim to be—and
    authorization—making sure that the authenticated user should or should not be
    able to perform certain operations on your API—are very complex. In this chapter,
    you will explore the topics of authentication and authorization from a very practical
    standpoint and from the FARM stack perspective.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 认证的概念——证明用户是他们所声称的人——以及授权——确保经过认证的用户应该或不应该能够对你的API执行某些操作——都是非常复杂的。在本章中，您将从非常实用的角度以及FARM堆栈的角度来探讨认证和授权的主题。
- en: The chapter will detail a simple yet robust and extensible setup for your FastAPI
    backend, based on **JSON Web Token** (**JWT**)—arguably the most popular and practical
    authentication method that has emerged in the last years. Then, you will see how
    to integrate your JWT-based authentication methods into React, leveraging some
    of React’s powerful features—namely, Hooks, Context, and React Router.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将详细说明一个简单、健壮且可扩展的FastAPI后端设置，基于**JSON Web Token**（JWT）——可以说是近年来出现的最受欢迎和实用的认证方法。然后，您将看到如何将基于JWT的认证方法集成到React中，利用React的一些强大功能——即Hooks、Context和React
    Router。
- en: By the end of this chapter, you should have a solid grasp of authentication
    methods that both FastAPI on the backend and React on the frontend have to offer,
    and you will be able to authenticate users and control what they can and cannot
    do within your application with granularity and precision.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您应该对FastAPI在后端和React在前端提供的认证方法有一个牢固的掌握，您将能够以细粒度和精确度对用户进行认证并控制他们在应用中的操作。
- en: 'The chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The user model and how it relates to other resources
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户模型及其与其他资源的关系
- en: JWT authentication mechanism—the big picture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JWT认证机制——整体概述
- en: Authentication and authorization tools in FastAPI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FastAPI中的认证和授权工具
- en: How to protect the routes, routers, or the entire app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何保护路由、路由器或整个应用
- en: Various solutions for authenticating with React
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React认证的各种解决方案
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the sample application in this chapter, you should have the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的示例应用，您应该具备以下条件：
- en: Node.js version 18 or later
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js版本18或更高
- en: Python 3.11.7 or later
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.11.7或更高版本
- en: The requirements are identical to those in the previous chapters, and the new
    packages that you will install will be described as they are used.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要求与前面章节中的要求相同，您将安装的新包将按其使用情况进行描述。
- en: Understanding JSON Web Token
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解JSON Web Token
- en: 'HTTP is a stateless protocol, and that fact alone implies several important
    consequences. One of them is that if you want to persist some kind of state between
    requests, you must resort to a mechanism that will be able to remember a set of
    data, such as who the logged-in user was, what the selected items during a previous
    browser session were, or what the site preferences were. In order to achieve such
    functionality, and identify the current user, you as a developer have numerous
    options at your disposal. Some of the most popular and modern solutions are the
    following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是一种无状态协议，仅此一点就暗示了几个重要的后果。其中之一是，如果您想在请求之间持久化某种状态，您必须求助于一种能够记住一组数据（例如，登录的用户是谁，在之前的浏览器会话期间选择了哪些项目，或者网站偏好设置是什么）的机制。为了实现这种功能并识别当前用户，作为开发人员，您有众多选项可供选择。以下是一些最受欢迎和最现代的解决方案：
- en: '**Credential-based authentication:** It requires the user to enter personal
    credentials, such as a username or email, along with a password'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于凭证的认证**：它要求用户输入个人凭证，如用户名或电子邮件，以及密码'
- en: '**Passwordless login:** Users receive a secure, time-limited token via email
    or another communication channel for authentication instead of using a traditional
    password after creating an account. The secure token is used for session authentication,
    eliminating the need to type or remember passwords.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无密码登录**：用户在创建账户后，通过电子邮件或其他通信渠道接收一个安全、时间有限的令牌进行认证，而不是使用传统的密码。安全的令牌用于会话认证，消除了输入或记住密码的需要。'
- en: '**Biometric passwords:** It utilizes a bio-feature of the user, such as a fingerprint,
    for authentication.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生物识别密码**：它利用用户的生物特征，如指纹，进行认证。'
- en: '**Social authentication:** Users leverage their existing social media accounts
    (e.g., Google, Facebook, or LinkedIn) for authentication. This associates the
    user’s social media account with their account on the platform.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社交认证**：用户利用他们现有的社交媒体账户（例如，Google、Facebook 或 LinkedIn）进行认证。这将用户的社交媒体账户与平台上的账户关联起来。'
- en: '**Classic personal credentials method:** Users provide an email and choose
    a password during registration. Optionally, users can also select a username.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经典个人凭证方法**：用户在注册时提供电子邮件并选择密码。用户还可以选择用户名作为可选项。'
- en: This chapter will consider the classic personal credentials method. When users
    register, they provide an email and choose a password and, optionally, a username.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将考虑经典的个人凭证方法。当用户注册时，他们提供电子邮件并选择密码，以及可选的用户名。
- en: What is JWT?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JWT 是什么？
- en: While there are different ways of maintaining the identity of a user across
    different parts of an app, JWT is arguably the most common and popular method
    of connecting frontend applications (React, Vue.js, and Angular) or mobile apps
    with an API (in our case, a REST API). JWT is nothing but a standard, a way of
    structuring a big string composed of seemingly random characters and numbers that
    encapsulate user data in a secure way.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有不同方式在应用程序的不同部分之间维护用户的身份，但 JWT 可以说是连接前端应用程序（如 React、Vue.js 和 Angular）或移动应用程序与
    API（在我们的案例中，是 REST API）最常见和最受欢迎的方法。JWT 仅仅是一个标准，一种结构化由看似随机的字符和数字组成的大字符串的方式，以安全的方式封装用户数据。
- en: JWTs contain three parts—the **header**, the **payload**, and the **signature**.
    The header hosts metadata about the token itself—the algorithm used for signing
    the token and the type of the token.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JWT 包含三个部分——**头部**、**负载**和**签名**。头部包含有关令牌本身的元数据——用于签名令牌的算法和令牌的类型。
- en: 'The payload is the most interesting part. It contains the following information
    necessary for authentication:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 负载数据是最有趣的部分。它包含以下必要的认证信息：
- en: 'Data (claims): The ID of the user (or the username)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据（声明）：用户的 ID（或用户名）
- en: 'The **issued at field** (**iat**): The date and time of issuing the token'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**签发时间字段**（**iat**）：签发令牌的日期和时间'
- en: 'The time at which the token ceases to be valid: Tied to the duration of the
    token'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌失效的时间：与令牌的有效期相关联
- en: 'Optionally, other fields: For example, the username, roles etc.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的其他字段：例如，用户名、角色等。
- en: 'The payload is decodable and readable by everyone. You can read more about
    tokens and understand how they look in the JWT documentation: [https://jwt.io](https://jwt.io).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 负载数据可以被每个人解码和阅读。您可以阅读更多关于令牌的信息，了解它们在 JWT 文档中的样子：[https://jwt.io](https://jwt.io).
- en: Finally, the most important part of the token is the signature. The signature
    guarantees the claims made by the token. The signature is reproduced (calculated)
    and compared with the original—thus preventing the modification of the claims.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，令牌最重要的部分是签名。签名保证了令牌所声明的信息。签名被重新生成（计算）并与原始签名进行比较——从而防止声明被修改。
- en: For example, consider a JWT stating that the username is `John`. Now, if someone
    were to attempt to change this to `Rita`, they would also need to modify the signature
    to match. However, altering the signature would render the token invalid. This
    mechanism ensures that the token’s content remains unchanged and authentic.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个声明用户名为 `John` 的 JWT。现在，如果有人试图将其更改为 `Rita`，他们还需要修改签名以匹配。然而，修改签名将使令牌无效。这种机制确保令牌的内容保持不变且真实。
- en: The token is hence able to completely replace the authentication data—user or
    email and password combinations that do not need to be transmitted more than once.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，令牌可以完全取代认证数据——用户或电子邮件和密码组合不需要多次传输。
- en: In the upcoming sections, you will learn how to implement a JWT-based authentication
    flow in your app.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，您将学习如何在您的应用程序中实现基于 JWT 的认证流程。
- en: FastAPI backend with users and dependencies
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有用户和依赖项的 FastAPI 后端
- en: Web applications (or mobile apps, for that matter) are not very useful if they
    are not secure. You must have heard about tiny errors in the authentication implementations
    that result in hundreds of thousands or even millions of compromised accounts,
    potentially exposing sensitive and valuable information.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序不安全，那么网络应用程序（或移动应用程序）将没有太大用处。您可能已经听说过在认证实现中出现的微小错误，这些错误可能导致数十万甚至数百万个账户被破坏，可能暴露敏感和有价值的信息。
- en: FastAPI is based on OpenAPI—previously known as `apiKey`, `http`, `OAuth 2.0`,
    `openIdConnect`, and so on). While the FastAPI documentation website ([https://fastapi.tiangolo.com/tutorial/security/](https://fastapi.tiangolo.com/tutorial/security/))
    provides an excellent and detailed tutorial on creating an authentication flow,
    it is based on the `OAuth 2.0` protocol, which uses form data to send the credentials
    (username and password).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 基于 OpenAPI——之前被称为 `apiKey`、`http`、`OAuth 2.0`、`openIdConnect` 等）。虽然
    FastAPI 文档网站 ([https://fastapi.tiangolo.com/tutorial/security/](https://fastapi.tiangolo.com/tutorial/security/))
    提供了一个优秀且详细的教程，用于创建身份验证流程，但它基于 `OAuth 2.0` 协议，该协议使用表单数据发送凭证（用户名和密码）。
- en: In the following sections, you will devise a simple user model that will enable
    an authentication flow. You will then learn how to encode the user data into a
    JWT and how to use the token for accessing protected routes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，你将设计一个简单的用户模型，这将使身份验证流程成为可能。然后，你将学习如何将用户数据编码成 JWT，以及如何使用令牌来访问受保护的路线。
- en: User model for authentication
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身份验证的用户模型
- en: The basis of every authentication flow is the user model, which has to be able
    to store a minimum set of data needed for unequivocally identifying the users.
    The most common unique fields are an email address, a username, and, of course,
    a primary key—an `ObjectId` instance in the case of MongoDB.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个身份验证流程的基础是用户模型，它必须能够存储一组最小数据，以便明确地识别用户。最常见的唯一字段是一个电子邮件地址、一个用户名，当然，还有一个主键——在
    MongoDB 的情况下是一个 `ObjectId` 实例。
- en: Modeling data with MongoDB is inherently different from modeling relational
    databases as discussed in [*Chapter 2*](B22406_02.xhtml#_idTextAnchor026), *Setting
    Up the Database with MongoDB*. The driving idea is to think of queries upfront
    and model your relationships taking into account the queries that your app is
    going to be making most frequently.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MongoDB 模型数据与在 [*第 2 章*](B22406_02.xhtml#_idTextAnchor026)，*使用 MongoDB 设置数据库*
    中讨论的建模关系型数据库本质上是不同的。驱动思想是提前考虑查询，并考虑你的应用程序将要最频繁执行的查询来建模你的关系。
- en: 'Authentication and authorization with FastAPI: a walk-through'
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 FastAPI 进行身份验证和授权：教程
- en: Authentication and authorization with FastAPI are much easier to understand
    through an example. In the next few sub-sections, you will develop a simple yet
    fully functional authentication system that will contain all the mandatory steps.
    To highlight the important parts, while keeping the example as concise as possible,
    you will not use a real MongoDB connection. Instead, you will make your own JSON
    file-based **database** that will store users as they register into the app and
    effectively mock a MongoDB collection. The first and foremost step is to review
    your authentication system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过示例，使用 FastAPI 进行身份验证和授权更容易理解。在接下来的几个子章节中，你将开发一个简单但功能齐全的身份验证系统，它将包含所有必需的步骤。为了突出重要部分，同时尽可能使示例简洁，你将不会使用真实的
    MongoDB 连接。相反，你将创建自己的基于 JSON 文件的基础 **数据库**，该数据库将存储用户在应用程序中注册时的数据，并有效地模拟 MongoDB
    集合。首要步骤是审查你的身份验证系统。
- en: Reviewing all the parts of your authentication system
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审查你的身份验证系统的所有部分
- en: 'The following list provides a quick recapitulation of the tools and packages
    needed for implementing a FastAPI authentication workflow:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表提供了一个快速回顾，列出了实现 FastAPI 身份验证工作流程所需的工具和包：
- en: 'To implement a FastAPI authentication workflow, you must use FastAPI’s security
    tools. In FastAPI, when you need to declare dependencies with `Security()` class.
    The other FastAPI import that will be needed is the type of dependable—in this
    case, you will use **bearer** tokens for authorization. You can refer to the FastAPI
    documentation: [https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer](https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer).'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要实现 FastAPI 的身份验证工作流程，你必须使用 FastAPI 的安全工具。在 FastAPI 中，当你需要使用 `Security()` 类声明依赖项时。其他你将需要的
    FastAPI 导入是可信赖的类型——在这种情况下，你将使用 **bearer** 令牌进行授权。你可以参考 FastAPI 文档：[https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer](https://fastapi.tiangolo.com/reference/security/#fastapi.security.HTTPBearer)。
- en: 'You also need password hashing and comparing functionality, which `passlib`
    can provide. The `passlib.context` module contains one main class: `passlib.context.CryptContext`,
    designed to take care of many of the more frequent coding tasks associated with
    hashing and comparing strings through various algorithms. Your authentication
    system requires two main functionalities: hashing passwords during user registration
    and comparing hashed passwords during login with those stored in your database.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还需要密码散列和比较功能，这 `passlib` 可以提供。`passlib.context` 模块包含一个主要类：`passlib.context.CryptContext`，设计用于处理与散列和比较字符串相关的许多更常见的编码任务。您的身份验证系统需要两个主要功能：在用户注册期间散列密码，以及在登录期间将散列密码与存储在您的数据库中的散列密码进行比较。
- en: Finally, **PyJWT** will provide the functionality to encode and decode JWT.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**PyJWT** 将提供编码和解码 JWT 的功能。
- en: Creating the model
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'The next steps involve creating the basic FastAPI application in a new virtual
    environment, activating the environment, installing the necessary packages, and
    creating a suitable model of the users with the required fields:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及在新的虚拟环境中创建基本的 FastAPI 应用程序，激活环境，安装必要的软件包，并创建具有所需字段的合适用户模型：
- en: 'Create a new directory, set it as the working directory with the `cd` (change
    directory) command, create a new Python environment in `/venv`, and activate it:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的目录，使用 `cd`（更改目录）命令将其设置为工作目录，在 `/venv` 中创建一个新的 Python 环境，并激活它：
- en: '[PRE0]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once the new Python environment is active, install the needed packages for
    the authentication system and the application overall:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦新的 Python 环境激活，安装身份验证系统和应用程序所需的软件包：
- en: '[PRE1]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to be able to reproduce exactly the code in the book, you are strongly
    encouraged to use the `/backend/requirements.txt` file from the accompanying repository
    and install the packages with the `pip install -r` `requirements.txt` command.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想能够精确地重现书中的代码，强烈建议您使用附带存储库中的 `/backend/requirements.txt` 文件，并使用 `pip install
    -r requirements.txt` 命令安装软件包。
- en: 'The following are the last three packages needed for your authentication system:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为您的身份验证系统所需的最后三个软件包：
- en: '`Passlib` is a password hashing library for Python, and it supports a wide
    range of hashing algorithms, including `bcrypt`. It is very useful as it provides
    a unified interface for hashing and verifying passwords.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Passlib` 是一个用于 Python 的密码散列库，它支持广泛的散列算法，包括 `bcrypt`。它非常有用，因为它提供了一个统一的接口用于散列和验证密码。'
- en: The `bcrypt` package is a Python module that provides the password hashing method
    based on the Blowfish password hashing algorithm that you will be using. Please
    stick to the provided version of the package as there are some unresolved issues
    with later versions.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bcrypt` 软件包是一个 Python 模块，它提供了一个基于 Blowfish 密码散列算法的密码散列方法，您将使用此方法。请坚持使用提供的软件包版本，因为后续版本存在一些未解决的问题。'
- en: '`PyJWT` is the Python library for encoding and decoding JWT.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PyJWT` 是用于编码和解码 JWT 的 Python 库。'
- en: 'Next, create the models for the application. As this app will only deal with
    users, the `models.py` file is rather simple:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建应用程序的模型。由于此应用程序将仅处理用户，因此 `models.py` 文件相当简单：
- en: '[PRE2]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The models are self-explanatory, and they are left to be as explicit as possible.
    `UserBase` corresponds to the user representation that will be stored in your
    dummy database, or in a MongoDB collection (pay special attention to `Object_id`).
    In the given solution, the `id` field will be a UUID, so you set it to a string
    type.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是自解释的，并且被留得尽可能明确。`UserBase` 对应于将存储在您的虚拟数据库中或 MongoDB 集合中的用户表示（请特别注意 `Object_id`）。在给定解决方案中，`id`
    字段将是一个 UUID，因此您将其设置为字符串类型。
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A Python `ObjectId()` class for the purpose of this demonstration.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为此演示目的的 Python `ObjectId()` 类。
- en: 'The `models.py` file contains two additional auxiliary Pydantic models: `UserIn`,
    which accepts the user data for registration or login (typically username and
    password, but can easily be extended to include email or other data), and `UserOut`,
    which is responsible for representing users within the application, excluding
    the hashed password but including the ID and the username.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`models.py` 文件包含两个额外的辅助 Pydantic 模型：`UserIn`，它接受用于注册或登录的用户数据（通常是用户名和密码，但可以轻松扩展以包括电子邮件或其他数据），以及
    `UserOut`，它负责在应用程序中表示用户，不包括散列密码但包括 ID 和用户名。'
- en: '`UsersList` finally just outputs the list of all users, and you will use this
    model as an example for your protected route. Now, build your `app.py` file and
    create the actual application.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersList` 最终只是输出所有用户的列表，你将使用这个模型作为受保护路由的示例。现在，构建你的 `app.py` 文件并创建实际的应用程序。'
- en: Creating the application file
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建应用程序文件
- en: 'After defining the models, you can now proceed and create the main FastAPI
    application and the authentication class:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了模型之后，你现在可以继续创建主要的 FastAPI 应用程序和认证类：
- en: 'Open a new Python file and name it `app.py`. Inside this file, create a minimal
    FastAPI application:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的 Python 文件，命名为 `app.py`。在这个文件中，创建一个最小的 FastAPI 应用程序：
- en: '[PRE3]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We will return to this file shortly, but for now, let’s keep it as short as
    possible. Now it is time to build out the heart of your authentication system.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们很快就会回到这个文件，但现在，让我们尽量让它尽可能短。现在，是时候构建你认证系统的核心了。
- en: 'In the same folder, create the `authentication.py` file and start building
    it. Having all this at hand, open the newly created `authentication.py` file and
    begin crafting the authentication class. For this, you must first scaffold the
    `AuthHandler` class and add the required imports:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个文件夹中，创建 `authentication.py` 文件并开始构建它。有了所有这些，打开新创建的 `authentication.py` 文件，开始构建认证类。为此，你必须首先构建
    `AuthHandler` 类并添加所需的导入：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that you have learned about all these imports, you can craft a class named
    `AuthHandler`, that uses FastAPI’s `HTTPBearer` as the security dependency and
    defines a password-processing context from `passlib`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了所有这些导入，你可以创建一个名为 `AuthHandler` 的类，该类使用 FastAPI 的 `HTTPBearer` 作为安全依赖，并从
    `passlib` 定义密码处理上下文。
- en: Adding security dependency and password-processing context
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加安全依赖和密码处理上下文
- en: This procedure consists of multiple steps. You’ll need to add a secret string
    that would ideally be generated randomly and kept safe in an environment variable,
    far from any `git commit`. The secret string is necessary for hashing the passwords.
    Here, you will hardcode it in this file for simplicity.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程包括多个步骤。你需要添加一个秘密字符串，理想情况下应该是随机生成的，并安全地存储在环境变量中，远离任何 `git commit`。这个秘密字符串对于哈希密码是必要的。在这里，为了简单起见，你将在这个文件中硬编码它。
- en: 'So, continue with the same file and code the desired functionality step by
    step, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，继续使用同一个文件，逐步编写所需的功能，如下所示：
- en: '`authentication.py` file under the `AuthHandler` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authentication.py` 文件在 `AuthHandler` 类下：'
- en: '[PRE5]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This function simply creates a hash of the given password, and this result is
    what you will be storing in your database. It is making good use of your previously
    defined `passlib` context.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个函数只是创建给定密码的哈希值，这个结果就是你将在数据库中存储的内容。它很好地使用了你之前定义的 `passlib` 上下文。
- en: '`authentication.py` file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authentication.py` 文件：'
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Similar to the previous function, `verify_password` simply verifies that the
    hash of `plain_password` is indeed equal to the (already) hashed password and
    it returns `True` or `False`.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与前面的函数类似，`verify_password` 简单地验证 `plain_password` 的哈希值是否确实等于（已经）哈希过的密码，并返回 `True`
    或 `False`。
- en: '`authentication.py` file:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`authentication.py` 文件：'
- en: '[PRE7]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `encode_token` method of your class leverages the `PyJWT` package’s `encode`
    method to create the JWT itself, and it is very explicit; the payload contains
    the expiration time (very important—you do not want the JWTs to last for too long)
    and the *issued-at time* (the `iat` part). Also, it references the dictionary
    named `sub`, which contains all the data that you wish to encode—in this case,
    the user ID and the username, although you could also add a role (regular user,
    administrator, and so on) or other data. To recap, the JWT encodes three pieces
    of data:'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你的类的 `encode_token` 方法利用 `PyJWT` 包的 `encode` 方法来创建 JWT 本身，它非常明确；有效载荷包含过期时间（非常重要——你不想
    JWT 持续太久）和 *发行时间*（`iat` 部分）。它还引用了名为 `sub` 的字典，其中包含你希望编码的所有数据——在这种情况下，是用户 ID 和用户名，尽管你也可以添加角色（普通用户、管理员等）或其他数据。总结一下，JWT
    编码了三份数据：
- en: The expiration duration, in this example, 30 minutes.
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过期持续时间，在这个例子中，30 分钟。
- en: The time of issuing the token, in this example, it is set to `now()`.
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 令牌的发行时间，在这个例子中，设置为 `now()`。
- en: The `sub` part is the data (in the form of a dictionary) that you want to include
    in the token. In this example, it is the user ID and the username.
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub` 部分是你想要包含在令牌中的数据（以字典的形式）。在这个例子中，它是用户 ID 和用户名。'
- en: '**Decoding** **the token**'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**解码** **令牌**'
- en: 'Continue building out the class, as now the reverse functionality is required—a
    way of decoding the token:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继续构建类，因为现在需要反向功能——解码令牌的方法：
- en: '[PRE8]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: def auth_wrapper(
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: def auth_wrapper(
- en: self,
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: self,
- en: 'auth: HTTPAuthorizationCredentials = Security(security)) -> dict:'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'auth: HTTPAuthorizationCredentials = Security(security)) -> dict:'
- en: return self.decode_token(auth.credentials)
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return self.decode_token(auth.credentials)
- en: '[PRE9]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You will use this `auth_wrapper` as the dependency—it will check for the presence
    of a valid JWT passed as a bearer token in the request headers for all the routes
    or entire routers that need authorization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用此`auth_wrapper`作为依赖项——它将检查请求头中是否存在有效的JWT作为承载令牌，用于所有需要授权的路由或整个路由器。
- en: The `authorization.py` file is a minimal implementation of an authentication/authorization
    flow.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`authorization.py` 文件是对认证/授权流程的最小实现。'
- en: In the previous steps you wrapped most of the authentication and authorization
    functionality into a simple and compact class. The creation of the token, its
    encoding and decoding, as well as the password hashing and verification. Finally,
    you have created a simple dependency that will be used for verifying the user
    and enabling or disabling access to protected routes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的步骤中，您将大多数认证和授权功能封装到一个简单紧凑的类中。创建令牌、编码和解码、以及密码哈希和验证。最后，您创建了一个简单的依赖项，用于验证用户并启用或禁用对受保护路由的访问。
- en: Building the FastAPI router for the application will be very similar to the
    ones that you have already built in [*C**hapter 2*](B22406_02.xhtml#_idTextAnchor026),
    *Setting Up the Database with MongoDB*. You will have two basic endpoints for
    registering and logging in, and they will rely heavily on the `AuthHandler` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 构建应用程序的FastAPI路由器将与您在[*第2章*](B22406_02.xhtml#_idTextAnchor026)中构建的类似，即使用MongoDB设置数据库。您将有两个基本端点用于注册和登录，它们将严重依赖于`AuthHandler`类。
- en: Creating the APIRouter for the users
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户的APIRouter
- en: 'In this section, you will create the APIRouter for the users and implement
    the login and register functionalities with the help of the authentication class
    and a mock database service implemented with dictionaries and UUID. To achieve
    this functionality, perform the following steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将创建用于用户的APIRouter，并在认证类和用字典和UUID实现的模拟数据库服务的帮助下实现登录和注册功能。为了实现此功能，请执行以下步骤：
- en: 'Create a folder `routers` in the root of your application and a file named
    `users.py` inside of it. Add the following code to the `users.py` file:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序的根目录下创建一个名为`routers`的文件夹，并在其中创建一个名为`users.py`的文件。将以下代码添加到`users.py`文件中：
- en: '[PRE10]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: After adding the imports at the start of the file, create the APIRouter and
    the registration endpoint. The registration function uses the fake JSON database
    to store the username and the hashed password, by using the `authentication.py`
    file that you created before.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头添加导入之后，创建APIRouter和注册端点。注册函数使用模拟的JSON数据库存储用户名和哈希密码，通过使用您之前创建的`authentication.py`文件。
- en: '[PRE11]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In order to demonstrate a basic JWT-based authentication and authorization system,
    a fake data storage solution is used. Instead of connecting through a driver to
    a MongoDB cluster, you use a simple JSON file for storing users along with their
    hashed passwords—a solution similar to the popular JSON Server Node package, used
    for testing and scaffolding purposes. However, all the functionality and logic
    presented will apply to real database scenarios, and it is easily adaptable for
    MongoDB drivers or ODMs, such as PyMongo, Motor, or Beanie.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示基于JWT的基本认证和授权系统，使用了模拟数据存储解决方案。您不是通过驱动程序连接到MongoDB集群，而是使用简单的JSON文件来存储用户及其哈希密码——这是一个类似于用于测试和脚手架目的的流行JSON
    Server Node包的解决方案。然而，所有展示的功能和逻辑都适用于真实数据库场景，并且很容易适应MongoDB驱动程序或ODM，如PyMongo、Motor或Beanie。
- en: After the imports, which include a couple of packages that you will likely not
    need when working with a real MongoDB database, such as `uuid`, you have instantiated
    APIRouter and the custom-made `AuthHandler` class.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导入之后，包括一些您在处理真实MongoDB数据库时可能不需要的包，例如`uuid`，您已经实例化了APIRouter和自定义的`AuthHandler`类。
- en: The `/register` endpoint accepts the new user’s data in the body and molds it
    through the `UserIn` Pydantic class defined in the `models.py` file, while the
    output is set to be of class `UserBase`. This is something that you would likely
    avoid as it will send the hashed password back to the newly registered user.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`/register` 端点接受新用户的数据并在`models.py`文件中定义的`UserIn` Pydantic类中对其进行塑形，而输出设置为`UserBase`类。这可能是您想要避免的，因为它会将哈希密码发送给新注册的用户。'
- en: 'Instead of a real MongoDB database, you are reading the contents of a JSON
    file called `users.json`—this file will host a very simple data structure that
    will mimic your users’ MongoDB collection: a simple array of dictionaries containing
    user data – the ID, the username, and the hashed password.'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代替真实的 MongoDB 数据库，你正在读取一个名为 `users.json` 的 JSON 文件的内容——这个文件将托管一个非常简单的数据结构，将模拟你的用户
    MongoDB 集合：一个包含用户数据的简单字典数组——ID、用户名和哈希密码。
- en: Now that you have this “database,” or array of users, it is easy to just loop
    over them and verify whether it contains a user with the same username as the
    user trying to register—if so, you just dismiss it with a gentle `HTTP 409` response
    code and a `Username already` `taken` message.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你有了这个“数据库”，或者用户数组，很容易遍历它们并验证是否包含一个尝试注册的用户具有相同的用户名——如果是这样，你只需用温和的 `HTTP 409`
    响应代码和 `Username already` `taken` 消息将其忽略。
- en: If the username is not taken, proceed to start using your `auth_handler` instance
    and set the plain-text raw password to its hashed counterpart, safe to be stored
    inside the database.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果用户名未被占用，则继续使用你的 `auth_handler` 实例，并将纯文本原始密码设置为它的哈希版本，安全地存储在数据库中。
- en: 'In order to be able to store the user as a Python dictionary, use `jsonable_encoder`
    and add a new key to it: the `uuid` string that will be used as the ID of the
    new user.'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了能够将用户存储为 Python 字典，请使用 `jsonable_encoder` 并向其中添加一个新的键：用作新用户 ID 的 `uuid` 字符串。
- en: Finally, append the user (represented as a dictionary with an ID, username,
    and hashed password) to your list of users, write the modified list to the JSON
    file, and return the user.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，将用户（以包含 ID、用户名和哈希密码的字典形式表示）添加到你的用户列表中，将修改后的列表写入 JSON 文件，并返回用户。
- en: 'Now, continuing with the `users.py` router, you can create the `login` endpoint
    as well by adding the following code at the end of the file:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续使用 `users.py` 路由器，你还可以通过在文件末尾添加以下代码来创建 `login` 端点：
- en: '[PRE12]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code follows a similar logic: it loads the user data and attempts to find
    the login user by their username (similar to a find query). If the user is not
    found or the password verification fails, the endpoint raises an exception. It’s
    considered a good security practice to inform the user that the entire combination
    of username and password is invalid, without specifying which part exactly failed.
    If both checks pass, you encode the token and return it to the user.'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码遵循类似的逻辑：它加载用户数据并尝试通过用户名找到登录用户（类似于查找查询）。如果用户未找到或密码验证失败，端点将引发异常。不具体说明哪个部分失败，而是告知用户整个用户名和密码组合无效，被认为是一种良好的安全实践。如果两个检查都通过，你将编码令牌并将其返回给用户。
- en: 'Time to hook up the router. Edit the previously created `app.py` file by replacing
    the contents of the file with the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候连接路由器了。通过替换文件内容来编辑之前创建的 `app.py` 文件：
- en: '[PRE13]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, you added the `users` router.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，你添加了 `users` 路由器。
- en: 'Now, create a file called `users.json` in the root of your project and populate
    it with an empty `users` array:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的项目根目录下创建一个名为 `users.json` 的文件，并用一个空的 `users` 数组填充它：
- en: '[PRE14]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Save the file and start the FastAPI application from the shell:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并从 shell 中启动 FastAPI 应用程序：
- en: '[PRE15]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You should be able to perform a user registration and a user login. Try it
    with the HTTPie client:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该能够执行用户注册和用户登录。使用 HTTPie 客户端尝试一下：
- en: '[PRE16]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The server should send the following response, but bear in mind that your hash
    and UUID will be different:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器应该发送以下响应，但请注意，你的哈希和 UUID 将不同：
- en: '[PRE17]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you peek in the `users.json` file, you should see something like this:'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你查看 `users.json` 文件，你应该能看到类似以下的内容：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In a real-world system, you would not want to send the hashed password even
    to the logged-in user, but this whole system is for demonstration purposes and
    created to be as illustrative as possible.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的系统中，你甚至不希望将哈希密码发送给已登录的用户，但这个整个系统是为了演示目的而创建的，旨在尽可能具有说明性。
- en: 'You have created a full authentication flow (for demonstration purposes—you
    will not use a JSON file with dictionaries and UUIDs in production) and you have
    crafted all the mandatory functionalities: creating users (registration), checking
    for the validity of the submitted data, and user login. Finally, you tested the
    registration functionality by creating a test user.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个完整的身份验证流程（仅用于演示目的——在生产中你不会使用包含字典和 UUID 的 JSON 文件），并且你已经实现了所有必需的功能：创建用户（注册）、检查提交数据的有效性以及用户登录。最后，你通过创建一个测试用户来测试了注册功能。
- en: Testing the login functionality with HTTPie
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 HTTPie 测试登录功能
- en: Now, test the login functionality with the correct user/password combination
    and then a wrong one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用正确的用户/密码组合测试登录功能，然后使用错误的组合。
- en: 'First, log in. In the terminal, issue the following HTTPie command:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，登录。在终端中，发出以下HTTPie命令：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The response should be just a big string—your JWT—the value of this token (here,
    it starts with the string *eyJhbGciOiJ…*) should be copied and saved for testing
    the authenticated route later:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应应该只是一个大字符串——你的JWT——这个令牌的值（这里，它以字符串*eyJhbGciOiJ…*开头）应该被复制并保存以供稍后测试已验证的路由：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Try something like the following (notice the password is wrong):'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试以下操作（注意密码是错误的）：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The response will be similar to the following:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 响应将类似于以下内容：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You have just implemented your own authentication system with FastAPI from scratch.
    Now it would be great to put it to use in a route.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经从头开始实现了自己的FastAPI认证系统。现在，把它用在路由上会很好。
- en: Creating a protected route
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建受保护的路由
- en: 'Say that now you want a new endpoint that lists all the users in your system,
    and you want to make it visible only to logged-in users. This method would allow
    you to protect any route in different routers, just by leveraging the powerful
    FastAPI dependency injection system:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你现在想要一个新端点，该端点列出你系统中所有的用户，并且你希望它只对已登录用户可见。这种方法将允许你通过利用强大的FastAPI依赖注入系统来保护不同路由中的任何路由：
- en: 'Open the `users.py` file and add the following route at the end:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`users.py`文件，在末尾添加以下路由：
- en: '[PRE23]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The key to this route is the `user_data` part—if the dependency is not met,
    the route will respond with an exception and the messages defined in `authentication.py`.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这条路径的关键在于`user_data`部分——如果依赖项不满足，该路径将响应异常，并显示`authentication.py`中定义的消息。
- en: 'Try to log in, grab the JWT that you got from the login endpoint and have copied
    (if it hasn''t expired!), and then pass it as the bearer token:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试登录，获取从登录端点获得的JWT（如果它还没有过期！），然后将其作为承载令牌传递：
- en: '[PRE24]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result should contain all the users that you have created so far:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果应包含你迄今为止创建的所有用户：
- en: '[PRE25]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you try to modify the token, or if you let it expire, the result will be
    the following:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你尝试修改令牌，或者让它过期，结果将是以下内容：
- en: '[PRE26]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this section, you saw how to create a simple but efficient authentication
    system on your FastAPI backend, create a JWT generator, verify the tokens, protect
    some routes, and provide the routes needed for creating (registering) new users
    and logging in. The next section will show how things work on the front end.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了如何在FastAPI后端创建一个简单但高效的认证系统，创建JWT生成器，验证令牌，保护一些路由，并提供创建（注册）新用户和登录所需的路由。下一节将展示前端的工作方式。
- en: Authenticating the users in React
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在React中认证用户
- en: In this section, you will go through a basic mechanism that will enable you
    to have a simple authentication flow on the client side. Everything will revolve
    around the JWT and the way you decide to handle it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解一个基本机制，这将使你能够在客户端实现简单的认证流程。一切都将围绕JWT以及你决定如何处理它展开。
- en: React.js is an unopinionated UI library. It provides numerous ways of implementing
    user authentication and authorization. Since your FastAPI backend implements JWT-based
    authentication, you have to decide how to deal with the JWT in React.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: React.js是一个无偏见的UI库。它提供了多种实现用户认证和授权的方法。由于你的FastAPI后端实现了基于JWT的认证，你必须决定如何在React中处理JWT。
- en: In this chapter, you are going to store it in memory, then in `localStorage`
    (an HTML5 simple web storage object in JavaScript that allows applications to
    store key-value pairs in a user’s web browser with no expiration date). This chapter
    will not cover cookie-based solutions, which tend to be the most robust and secure,
    as one such solution will be covered in the next chapter.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将把它存储在内存中，然后存储在`localStorage`中（JavaScript中的HTML5简单Web存储对象，允许应用程序在用户的Web浏览器中存储无过期日期的键值对）。本章不会涵盖基于cookie的解决方案，因为这种解决方案通常是最稳健和安全的，下一章将介绍此类解决方案。
- en: Each of these methods has its benefits and drawbacks, and it is very useful
    to get acquainted with them. Authentication should always be taken very seriously
    and, depending on your application scope and requirements, it should always be
    a topic that requires thorough analysis.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法各有优缺点，了解它们非常有用。认证应该始终非常认真对待，并且根据你的应用程序范围和需求，它应该始终是一个需要彻底分析的话题。
- en: There is an ongoing debate on what the optimal solution for storing authentication
    data is—in this case, the JWT. As always, there are pros and cons to each solution.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 关于存储认证数据的最佳解决方案一直存在争议——在这种情况下，是JWT。像往常一样，每种解决方案都有其优缺点。
- en: Cookies have been around for a very long time—they can store data in key-value
    pairs in the browser and are readable from both the browser and the server. Their
    popularity coincided with the classic server-side-rendered websites. However,
    they can store a very limited amount of data and the structure of said data has
    to be very simple.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Cookie已经存在很长时间了——它们可以在浏览器中以键值对的形式存储数据，并且可以从浏览器和服务器中读取。它们的流行与经典的服务器端渲染网站相吻合。然而，它们只能存储非常有限的数据，并且数据结构必须非常简单。
- en: '`localstorage` and `sessionStorage` were introduced with HTML5 as a way to
    address the need for storing complex data structures in **single-page applications**
    (**SPAs**), among other things. Their capacity is around 10 MB, depending on the
    browser’s implementation, compared to 4 KB of cookie capacity. Session storage
    data persists through a session, while local storage remains in the browser even
    after it is closed and reopened until manually deleted, making SPAs the most pleasant
    but also the most vulnerable solution. Both can host complex JSON data structures.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`localstorage`和`sessionStorage`随着HTML5的引入而出现，是为了解决在**单页应用**（**SPAs**）中存储复杂数据结构的需求，以及其他一些需求。它们的容量大约为10
    MB，具体取决于浏览器的实现，而cookie的容量为4 KB。会话存储数据在会话期间持续存在，而本地存储在浏览器中即使关闭和重新打开后也会保留，直到手动删除，这使得SPAs成为最令人愉悦但也最易受攻击的解决方案。两者都可以托管复杂的JSON数据结构。'
- en: Storing JWTs in `localstorage` is easy and it provides a great user and developer
    experience.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`localstorage`中存储JWT很简单，并且提供了极佳的用户和开发者体验。
- en: The majority of authorities on the subject suggest storing JWTs in HTTP-only
    cookies, as they cannot be accessed through JavaScript and require the frontend
    and the backend to run on the same domain.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数该领域的权威人士建议将JWT存储在HTTP-only cookie中，因为它们不能通过JavaScript访问，并且需要前端和后端在同一个域上运行。
- en: This can be accomplished in different ways, through routing requests or using
    a proxy. Another popular strategy is the use of so-called refresh tokens. In this
    method, the application issues one token upon login, and then this token is used
    to generate other (refresh) tokens automatically, allowing you to strike the right
    balance between security and user experience.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过不同的方式实现，通过路由请求或使用代理。另一种流行的策略是使用所谓的刷新令牌。在此方法中，应用程序在登录时发行一个令牌，然后使用此令牌自动生成其他（刷新）令牌，从而在安全性和用户体验之间找到正确的平衡。
- en: The Context API
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Context API
- en: In [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051), *Python Type Hints and Pydantic*,
    you learned how to manage simple pieces of the state of a component through the
    `useState` hook.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B22406_03.xhtml#_idTextAnchor051)，“Python类型提示和Pydantic”，你学习了如何通过`useState`钩子管理组件状态的简单部分。
- en: Imagine that you have a top-level component—maybe even the root `App.js` component—and
    you need to pass some piece of state to a deeply nested component inside the React
    component tree. You would need to pass that piece of data to a component that
    is inside the `App.js` stateful component and then pass it further down the tree
    until it reaches the subcomponent that actually needs said data.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个顶级组件——甚至可能是根`App.js`组件——并且你需要将一些状态传递到React组件树中的深层嵌套组件。你需要将这部分数据传递给`App.js`状态组件内的组件，然后将其进一步传递到树中，直到达到真正需要这些数据的子组件。
- en: 'This pattern is known as **prop drilling**—passing a state value through props
    and having multiple components that do not use this state value; they just pass
    it on. Prop drilling has several implications, most of which are best avoided:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式被称为**属性钻取**——通过属性传递状态值，并且有多个不使用该状态值的组件；它们只是将其传递下去。属性钻取有几个影响，其中大多数最好是避免的：
- en: Refactoring and changing code is more difficult because you must keep the state
    value channels of communication intact at all times
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构和修改代码更困难，因为你必须始终保持状态值通信通道的完整性
- en: Code is less reusable as components need to always provide the state value
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码的可重用性较低，因为组件需要始终提供状态值
- en: More code needs to be written, as components need to accept and forward props
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要编写的代码更多，因为组件需要接受和转发属性
- en: React introduced the **Context API** as a way of providing values across components
    without the need for prop drilling.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: React通过**Context API**引入了一种在组件之间提供值而不需要属性钻取的方法。
- en: Creating a simple SPA
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个简单的SPA
- en: In the following section, you will create a very simple SPA that will allow
    users to register (if they are not registered yet), log in with a username and
    password, and, if authenticated, see the list of all registered users. The UI
    will tightly mimic your backend.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建一个非常简单的SPA，允许用户注册（如果他们尚未注册），使用用户名和密码登录，如果认证成功，将看到所有注册用户的列表。UI将紧密模仿你的后端。
- en: Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order for the frontend to be functional and testable, it is mandatory to
    provide the backend from the previous section, so be sure to run the FastAPI backend
    with:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前端功能正常且可测试，必须提供上一节中的后端，因此请确保使用以下命令运行FastAPI后端：
- en: '`uvicorn` `app:app --reload`'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`uvicorn` `app:app --reload`'
- en: The frontend will connect to the running FastAPI backend through the API. While
    FastAPI is serving the application on the address `http://127.0.0.1:8000`, the
    React frontend will use this same URL to connect, perform GET and POST requests,
    authenticate users and list resources.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 前端将通过API连接到正在运行的FastAPI后端。虽然FastAPI在地址`http://127.0.0.1:8000`上提供服务，但React前端将使用相同的URL进行连接，执行GET和POST请求，认证用户并列出资源。
- en: 'You will go through the main concepts of the Context API storing the JWT in
    the application. Begin with the following steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你将了解将JWT存储在应用程序中的Context API的主要概念。以下步骤开始：
- en: Create a new Vite React project, install Tailwind, and add Tailwind CSS as it
    simplifies the styling of the application. Please refer to [*Chapter 5*](B22406_05.xhtml#_idTextAnchor090),
    *Setting up a React Workflow*, in order to do so. Also, delete files and folder
    that will not be needed (assets such as `App.css`).
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Vite React项目，安装Tailwind，并添加Tailwind CSS，因为它简化了应用程序的样式。请参阅[*第5章*](B22406_05.xhtml#_idTextAnchor090)，*设置React工作流程*，以了解如何操作。同时，删除不需要的文件和文件夹（如`App.css`）。
- en: 'Create in the `/src` folder a new file and name it `AuthContext.jsx`. The `.jsx`
    extension is a reminder that the context is indeed a React component that will
    wrap all the other components that need access to the context variables, functions,
    objects, or arrays:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`/src`文件夹中创建一个新文件，并将其命名为`AuthContext.jsx`。`.jsx`扩展名是一个提醒，即上下文确实是一个React组件，它将包装所有需要访问上下文变量、函数、对象或数组的其他组件：
- en: '[PRE27]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code shows the structure of the context creation – you imported
    `createContext` from React and created your first context (`AuthContext`). After
    defining a couple of state variables and setters (for the user, the `jwt` token
    and the message), you returned the `AuthContext` component and the values that
    will be available in the context. The syntax is a bit different from the one used
    for the hooks examined in [*Chapter 4*](B22406_04.xhtml#_idTextAnchor071), *Getting
    Started with FastAPI*, but this is a straightforward template that you will reuse
    many times, should you opt for the Context API.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码显示了上下文创建的结构 - 你从React中导入了`createContext`并创建了你的第一个上下文（`AuthContext`）。在定义了一些状态变量和设置器（用于用户、`jwt`令牌和消息）之后，你返回了`AuthContext`组件和将在上下文中可用的值。语法与[*第4章*](B22406_04.xhtml#_idTextAnchor071)，*FastAPI入门*中检查的钩子语法略有不同，但这是一个你将多次重用的简单模板，如果你选择使用Context
    API。
- en: 'While simple, creating a context involves several steps:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然简单，但创建上下文涉及多个步骤：
- en: First, you will need to create the actual context that will be shared across
    the application.
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，你需要创建将在应用程序中共享的实际上下文。
- en: After that, the context should be provided to all the components needing access
    to its values.
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，应该将上下文提供给所有需要访问其值的组件。
- en: The components that need to access the context values need to subscribe to the
    context in order to be able to read, but also write to it.
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要访问上下文值的组件需要订阅上下文，以便能够读取，但也可以写入。
- en: So, the first step when creating a context should be defining exactly what type
    of information you need to pass to components. If you think about it, you would
    definitely want the JWT since that is the whole point of this exercise. In order
    to showcase context functionality, you will also include the logged-in user and
    a message that will display the state of the application.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，创建上下文的第一步应该是明确你需要传递给组件的确切信息类型。如果你这么想，你肯定希望使用JWT，因为这就是这个练习的全部意义。为了展示上下文功能，你还将包括已登录的用户和将显示应用程序状态的消息。
- en: But since the context can also contain and pass functions—and that’s indeed
    one of its most useful features—you will also add to the context the `register`,
    `login`, and `logout` functions. That may not be something you would do in a production
    system, but it will showcase the capabilities of Context API.
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 但是，由于上下文还可以包含并传递函数——这确实是它的最有用功能之一——你还将向上下文中添加 `register`、`login` 和 `logout`
    函数。这可能在生产系统中不是你想要做的事情，但它将展示 Context API 的功能。
- en: 'Now, the only thing left to do is add the functions to the context. To do that,
    edit the existing `AuthContext.jsx` file and, after declaring the state variables,
    define the function for registering new users:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的事情是将函数添加到上下文中。为此，编辑现有的 `AuthContext.jsx` 文件，在声明状态变量之后，定义注册新用户的函数：
- en: '[PRE28]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This simple JavaScript function is part of the context, and the only thing that
    interacts with your context is the setting of the status message—if a user is
    successfully created, the message confirms it. In case of an error, the message
    is set to the error. You will want to provide a more complex validation logic
    and a nicer UI, but this is quite illustrative of the context functioning.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个简单的 JavaScript 函数是上下文的一部分，唯一与你的上下文交互的是设置状态消息——如果用户成功创建，消息将确认这一点。如果发生错误，消息将被设置为错误。你可能想要提供更复杂的验证逻辑和更友好的用户界面，但这对上下文的工作方式有很好的说明。
- en: 'Now add the other function related to authentication—the `login()` function:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加与认证相关的其他函数——`login()` 函数：
- en: '[PRE29]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding code is similar to the `register` function—it sends a `POST` request
    to the FastAPI `/login` endpoint with the user-provided username and password,
    and it clears any pre-existing JWT in the process. If the request is successful,
    the retrieved token is set to its state variable and the username accordingly.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码与 `register` 函数类似——它向 FastAPI `/login` 端点发送一个 `POST` 请求，包含用户提供的用户名和密码，并在过程中清除任何现有的
    JWT。如果请求成功，检索到的令牌将被设置为状态变量，并相应地设置用户名。
- en: 'The final piece of the puzzle is logging the user out. Since you are dealing
    only with the Context API and not some persistent storage solutions, the code
    is very short; it just needs to clear the context variables and set the appropriate
    message:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个拼图是注销用户。由于你只处理 Context API 而不是某些持久存储解决方案，代码非常简短；它只需要清除上下文变量并设置适当的消息：
- en: '[PRE30]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Your `AuthContext` is nearly complete—the only thing left is to inform the
    context that it needs to provide the previously defined functions. So, modify
    the `return` statement to include everything:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的 `AuthContext` 几乎完成了——唯一剩下的事情是通知上下文它需要提供之前定义的函数。因此，修改 `return` 语句以包含所有内容：
- en: '[PRE31]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As a final touch, add a `useContext` React hook that facilitates working with
    contexts:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为最后的润色，添加一个 `useContext` React 钩子，以简化与上下文的工作：
- en: '[PRE32]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This simple one-line hook allows you to now use `AuthContext` in any component
    that has access to the context—so any component wrapped inside `AuthContext`—with
    some simple ES6 destructuring. With your `AuthContext` now in place, you can put
    it directly in the `App.jsx` component and wrap it around all the other components.
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这条简单的单行钩子现在允许你在任何可以访问上下文的组件中使用 `AuthContext` ——也就是说，任何被 `AuthContext` 包裹的组件——只需进行一些简单的
    ES6 解构。现在你的 `AuthContext` 已经设置好了，你可以直接将其放入 `App.jsx` 组件中，并将其包裹在其他所有组件周围。
- en: 'Open the `App.jsx` file and edit it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.jsx` 文件并编辑它：
- en: '[PRE33]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This root component doesn’t contain anything that you haven’t seen already—apart
    from importing `AuthProvider`—the component of your custom authentication context
    responsible for wrapping the area of components and a bit of Tailwind styles.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个根组件不包含你之前没有见过的内容——除了导入 `AuthProvider`——这是你的自定义认证上下文组件，负责包裹组件区域和一点 Tailwind
    样式。
- en: 'Now comes the part where you will define the components that will be wrapped
    inside the context – as those components will be able to consume the context,
    have access to the context data, and modify it. For a bit more complex application,
    you would likely resort to the React Router package, but since this will be a
    very simple application, you will cram all the components into one page. There
    aren’t many of them:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是定义将包裹在上下文内部的组件的部分——因为这些组件将能够消费上下文，访问上下文数据，并对其进行修改。对于更复杂的应用程序，你可能会求助于 React
    Router 包，但由于这将是一个非常简单的应用程序，你将把所有组件挤在一个页面上。它们并不多：
- en: '`login()` function from the context.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文中的 `login()` 函数。
- en: '**Register**: Similar to the login component, but for registering new users.'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注册**：与登录组件类似，但用于注册新用户。'
- en: '**Message**: The simplest component, used only to display the status of the
    app.'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息**：最简单的组件，仅用于显示应用程序的状态。'
- en: '**Users**: The component whose state depends on the authentication status:
    if the user is logged in, they can see the list of users, meaning the JWT is present
    and valid; otherwise, the user is prompted to make a login.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户**：其状态依赖于身份验证状态的组件：如果用户已登录，他们可以看到用户列表，这意味着 JWT 存在且有效；否则，将提示用户进行登录。'
- en: 'The `Register` component will be used for user registration. It needs to display
    a form. Create the `Register.jsx` file in the `/src` folder and create a simple
    form with two fields:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Register` 组件将用于用户注册。它需要显示一个表单。在 `/src` 文件夹中创建 `Register.jsx` 文件，并创建一个包含两个字段的简单表单：'
- en: '[PRE34]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You have just created a React-specific form with the help of two local state
    variables that take care of keeping track and sending the username and password
    to your FastAPI instance. The `register` function is imported from `AuthContext`
    through the `useAuth()` hook. That line really shows how easy it is to work with
    the context from within the wrapped components.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已经使用两个本地状态变量创建了一个特定于 React 的表单，这些变量负责跟踪并发送用户名和密码到你的 FastAPI 实例。`register` 函数通过
    `useAuth()` 钩子从 `AuthContext` 中导入。那一行真正展示了在包装组件内部与上下文一起工作是多么容易。
- en: Finally, `handleSubmit` performs the call to the `register` function, clears
    the fields, and prevents the default HTML form behavior.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，`handleSubmit` 执行对 `register` 函数的调用，清除字段并阻止默认的 HTML 表单行为。
- en: 'Create the `Login.jsx` file, which is nearly identical (and here you could
    practice your React skills and perform some refactoring). The component has a
    login form that will be used for logging in:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `Login.jsx` 文件，它与之前几乎相同（在这里你可以练习你的 React 技能并进行一些重构）。该组件有一个登录表单，将用于登录：
- en: '[PRE35]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'There are two components left to be inserted in your simple auth application
    powered by FastAPI and React. First, create the `src/Message.jsx` component, which
    will be used to display the status message:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的由 FastAPI 和 React 驱动的简单身份验证应用程序中，还有两个组件需要插入。首先，创建 `src/Message.jsx` 组件，它将用于显示状态消息：
- en: '[PRE36]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `Messages` component reads the message state variable from the context and
    displays it to the users.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Messages` 组件从上下文中读取消息状态变量并将其显示给用户。'
- en: 'Now, you can finally create the `src/Users.jsx` component and edit it:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你终于可以创建 `src/Users.jsx` 组件并对其进行编辑：
- en: '[PRE37]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This component does a bit of heavy lifting compared to the others. It imports
    `jwt` (along with the `logout` function) from the context. This is important since
    the output of the `Users.jsx` component depends entirely on the existence and
    validity of the JWT.
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与其他组件相比，这个组件做了一些繁重的工作。它从上下文中导入 `jwt`（以及 `logout` 函数）。这很重要，因为 `Users.jsx` 组件的输出完全取决于
    JWT 的存在和有效性。
- en: After declaring a local state variable—`users`—the component uses the `useEffect`
    React hook to perform a call to the REST API, and since the `/users/list` endpoint
    is protected, the JWT token needs to be present and valid.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在声明一个本地状态变量 `users` 之后，组件使用 `useEffect` React 钩子执行对 REST API 的调用，由于 `/users/list`
    端点是受保护的，JWT 令牌需要存在且有效。
- en: If the call to the `/users/list` endpoint is successful, the retrieved users
    data is sent to the `users` variable and displayed. Finally, if there is no `jwt`
    in the context, the user is asked to perform a login and the `logout` function
    from the context.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果对 `/users/list` 端点的调用成功，检索到的用户数据将被发送到 `users` 变量并显示。最后，如果上下文中没有 `jwt`，将要求用户执行登录操作并从上下文中调用
    `logout` 函数。
- en: 'Finally, to tie everything together, replace the `App.jsx` file with the following
    code to import the components, and finalize the root component:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了将所有这些整合在一起，用以下代码替换 `App.jsx` 文件以导入组件，并最终完成根组件：
- en: '[PRE38]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now, you’ll be able to test the application—try registering, logging in, entering
    invalid data, and so on. You have created a very simple but complete full stack
    authentication solution. In the next section, you will learn about some methods
    of persisting the login data.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将能够测试应用程序——尝试注册、登录、输入无效数据等等。你已经创建了一个非常简单但完整的全栈身份验证解决方案。在下一节中，你将了解一些持久化登录数据的方法。
- en: Persisting authentication data with localStorage
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 localStorage 持久化身份验证数据
- en: As mentioned before, the most developer-friendly option for persisting authentication
    is the use of `localStorage` or `sessionStorage`. `localStorage` becomes very
    useful when it comes to storing temporary, local data. It is widely used for tasks
    such as remembering shopping cart data or user login on any website where security
    is not paramount. `localStorage` has a higher storage limit than cookies (5 MB
    versus 4 KB) and does not get sent with every HTTP request. This makes it a better
    choice for client-side storage.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，对于持久化认证，最符合开发者需求的选项是使用 `localStorage` 或 `sessionStorage`。当涉及到存储临时、本地数据时，`localStorage`
    非常有用。它被广泛用于记住购物车数据或用户在任何网站上的登录信息（在这些网站上安全性不是首要考虑因素）。与 cookies 相比，`localStorage`
    具有更高的存储限制（5 MB 对 4 KB），并且不会随着每个 HTTP 请求发送。这使得它成为客户端存储的更好选择。
- en: To use `localStorage`, you can set and get JSON items using the `setItem()`
    and `getItem()` methods, respectively. One important thing to remember is that
    `localStorage` only stores strings, so you will need to use `JSON.stringify()`
    and `JSON.parse()` to convert between JavaScript objects and strings.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `localStorage`，你可以分别使用 `setItem()` 和 `getItem()` 方法来设置和获取 JSON 项。需要记住的一个重要事项是
    `localStorage` 只存储字符串，因此你需要使用 `JSON.stringify()` 和 `JSON.parse()` 在 JavaScript
    对象和字符串之间进行转换。
- en: 'Armed with this knowledge, try to summarize what the app requirements are –
    you want the user to be able to refresh or close and reopen the application window/tab
    and remain logged in if they were logged in, in the first place. Translated into
    React language, you need a `useEffect` hook that will run and verify whether there
    is a token stored in `localStorage`. If it is present, you want to check this
    token through the FastAPI `/me` endpoint and set the username accordingly:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这些知识，尝试总结应用的要求——你希望用户能够在刷新或关闭并重新打开应用程序窗口/标签页的情况下保持登录状态，如果他们最初已经登录。用 React
    术语来说，你需要一个 `useEffect` 钩子，它会运行并验证 `localStorage` 中是否存储了令牌。如果存在，你想要通过 FastAPI 的
    `/me` 端点检查这个令牌，并相应地设置用户名：
- en: 'Open the existing `AuthContext.jsx` file, and after the `useState` hook, define
    the `useEffect` call:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开现有的 `AuthContext.jsx` 文件，在 `useState` 钩子之后定义 `useEffect` 调用：
- en: '[PRE39]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The bulk of your persistence logic is located in the `useEffect` call. First,
    you can try to get the `jwt` token from `localStorage` and then use that token
    to get the user data from the `/me` route. If the username is found, it is set
    in the context and the user is (already) logged in. If not, you clear `localStorage`
    or send a message that the token has expired (in the `Users.jsx` component).
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大部分持久化逻辑都位于 `useEffect` 调用中。首先，你可以尝试从 `localStorage` 获取 `jwt` 令牌，然后使用该令牌从 `/me`
    路由获取用户数据。如果找到用户名，它会被设置在上下文中，并且用户（已经）登录。如果没有找到，你将清除 `localStorage` 或在 `Users.jsx`
    组件中发送一个令牌已过期的消息。
- en: 'The `login()` function also has to be modified in order to take account of
    `localStorage`. In the same `AuthContext.jsx`, modify the `login()` function:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`login()` 函数也必须进行修改，以便考虑到 `localStorage`。在相同的 `AuthContext.jsx` 中修改 `login()`
    函数：'
- en: '[PRE40]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The only modification involves setting the new JWT to the `localStorage` `jwt`
    variable. Hence, the `logout()` function will also need to clear `localstorage`.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 唯一的修改是将新的 JWT 设置到 `localStorage` 的 `jwt` 变量中。因此，`logout()` 函数也需要清除 `localStorage`。
- en: 'In the same `AuthContext.jsx` file, modify the `logout` function:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的 `AuthContext.jsx` 文件中，修改 `logout` 函数：
- en: '[PRE41]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, in order to make your application even more explicit and informative,
    open the `Users.jsx` component and replace it with the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了使你的应用程序更加明确和易于理解，打开 `Users.jsx` 组件并将其替换为以下代码：
- en: '[PRE42]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The app is now able to persist the logged-in user, retrieve the stored JWT,
    and restore the previous authentication state. Before trying to log in, make sure
    that the FastAPI backend is working properly on port `8000`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用程序能够持久化已登录用户，检索存储的 JWT，并恢复之前的认证状态。在尝试登录之前，请确保 FastAPI 后端在端口 `8000` 上正常运行。
- en: Try logging in, refreshing the browser, closing the tab, and reopening it.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试登录，刷新浏览器，关闭标签页，然后重新打开。
- en: You can also try this with the token inside the **Application** tab in the developer
    toolbar of Chrome or Firefox and see what happens if you tamper with it or delete
    it.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 Chrome 或 Firefox 的开发者工具栏中的 **Application** 标签页内尝试使用令牌，看看如果你篡改它或删除它会发生什么。
- en: Other authentication solutions
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他认证解决方案
- en: It is important to emphasize again that the `localStorage` for instance, but
    keeping in mind the specificities of both solutions.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是再次强调，例如 `localStorage`，但需要考虑到两种解决方案的具体细节。
- en: Finally, it is important to get acquainted with the various third-party authentication
    options. **Firebase** and **Supabase** are popular database and authentication
    services that can be used solely for managing users and authenticating them. **Clerk**
    and **Kinde** are newer players in the field and are particularly geared toward
    the React/Next.js/Remix.js ecosystem, while **Auth0** and **Cognito** are industry-standard
    solutions. Almost all third-party authentication systems offer a generous free
    or almost-free tier, but once your application grows, you are bound to hit a paid
    tier, and the costs vary and replacing these services, should the need arise,
    is not easy.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，熟悉各种第三方身份验证选项也很重要。**Firebase**和**Supabase**是流行的数据库和身份验证服务，可以仅用于管理用户和验证他们。**Clerk**和**Kinde**是该领域的后起之秀，特别针对React/Next.js/Remix.js生态系统，而**Auth0**和**Cognito**是行业标准解决方案。几乎所有第三方身份验证系统都提供慷慨的免费或几乎免费的级别，但一旦你的应用程序增长，你不可避免地会遇到付费级别，而且费用各不相同，如果需要，替换这些服务并不容易。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you’ve seen a very basic, but quite representative, implementation
    of two versions of an authentication mechanism. You learned how FastAPI enables
    the use of standard-compliant authentication methods and implemented one of the
    simplest possible yet effective solutions – without persisting the authentication
    data and storing the `localStorage`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了一个非常基础但相当有代表性的身份验证机制两种版本的实现。你学习了FastAPI如何启用符合标准身份验证方法的使用，并实现了最简单但有效的解决方案之一——不持久化身份验证数据和不存储`localStorage`。
- en: You have learned how elegant and flexible FastAPI is when it comes to defining
    granular roles and permissions, especially with MongoDB, with the aid of **Pydantic**
    as the middleman. This chapter was focused exclusively on **JWTs** as the means
    of communication because it is the primary and most popular tool in SPAs nowadays,
    and it enables great connectivity between services or microservices. **JWT** mechanisms
    shine when you need to develop different applications with the same FastAPI and
    MongoDB-powered backend—for instance, a React web application and a React Native
    or Flutter-based mobile app.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到，在定义细粒度角色和权限方面，FastAPI是多么优雅和灵活，尤其是在MongoDB的帮助下，**Pydantic**作为中间人。本章专注于**JWTs**作为通信手段，因为它是当今SPA的主要和最受欢迎的工具，它使得服务或微服务之间具有很好的连接性。当你需要使用相同的FastAPI和MongoDB后端开发不同的应用程序时，**JWT**机制特别出色——例如，一个React网络应用程序和一个基于React
    Native或Flutter的移动应用程序。
- en: Furthermore, carefully considering your authentication and authorization strategy
    is crucial, especially when extracting user data from third-party systems may
    not be feasible or practical. This highlights the importance of devising robust
    authentication and authorization methods.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仔细考虑你的身份验证和授权策略至关重要，尤其是在从第三方系统中提取用户数据可能不可行或不切实际的情况下。这突出了制定稳健的身份验证和授权方法的重要性。
- en: In the next chapter, you will create a more complex FastAPI backend, with image
    uploading through a third-party service and use a MongoDB database for persistance.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将创建一个更复杂的FastAPI后端，通过第三方服务上传图片，并使用MongoDB数据库进行持久化。
