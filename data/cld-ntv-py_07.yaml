- en: Learning Event Sourcing and CQRS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习事件溯源和CQRS
- en: In the last chapter, we looked into the drawbacks of our current business model,
    and now, in this chapter, we'll look at how **Event Sourcing** (**ES**) and **CQRS**
    (**Command Query Responsibility Segregation**) would be helpful to overcome those.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了看当前业务模型的缺点，现在，在本章中，我们将看看事件溯源（ES）和命令查询责任分离（CQRS）如何有助于克服这些问题。
- en: In this chapter, we will talk about some architectural designs that deal with
    massive scalability. We will also look at two patterns, Event Sourcing and CQRS,
    which are all about solving the problem response behavior for such an enormous
    number of requests.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些处理大规模可扩展性的架构设计。我们还将研究事件溯源和CQRS这两种模式，这些模式都是为了解决如此大量请求的问题响应行为。
- en: Many of us think that compliance with twelve-factor apps will make our application
    a cloud native application with higher scalability, but there are other strategies,
    such as ES and CQRS, which can make our application more reliable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们许多人认为遵守十二要素应用程序将使我们的应用程序成为具有更高可扩展性的云原生应用程序，但是还有其他策略，比如ES和CQRS，可以使我们的应用程序更可靠。
- en: Since cloud native applications are internet facing, we expect thousands or
    millions of requests from different sources. Implementing infrastructure architecture
    to handle the requests by scaling up or down aren't enough. You need to make your
    application support such enormous scaling. That's when these patterns come into
    the picture.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于云原生应用程序面向互联网，我们期望来自不同来源的成千上万甚至数百万的请求。实施基础架构架构来处理请求的扩展或缩小是不够的。您需要使您的应用程序支持如此巨大的扩展。这就是这些模式出现的时候。
- en: 'The topics that we will cover in this chapter are listed as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖的主题如下：
- en: Introduction to Event Sourcing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源介绍
- en: Introduction to Command Query Responsibility Segregation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍命令查询责任分离
- en: Example code to implement ES and CQRS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现ES和CQRS的示例代码
- en: Event Sourcing with Apache Kafka
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Apache Kafka进行事件溯源
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'Let''s start with reviewing the *n*-tier architecture, where we have some clients,
    a network, a business model, some business logic, some data storage, and so on.
    This is a basic model, which you will find as part of any architectural design.
    It looks something like the following diagram:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从审查*n*层架构开始，其中我们有一些客户端、网络、业务模型、一些业务逻辑、一些数据存储等等。这是一个基本模型，您会发现它作为任何架构设计的一部分。它看起来像下面的图表：
- en: '![](img/00078.jpeg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00078.jpeg)'
- en: 'As you can see in this architecture, we have these different models that come
    into action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这个架构中所看到的，我们有这些不同的模型在起作用：
- en: '**View Model**: This is basically for client-side interaction'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图模型：这基本上是为客户端交互而设计的
- en: '**DTO Model**: This is for communication between the client and the REST Endpoints'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTO模型：这是客户端和REST端点之间的通信
- en: '**Business Model**: This is a combination of **DAO** (**Data Access Object**)
    and business service, which interprets the user requests, and communicates with
    the storage service'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务模型：这是DAO（数据访问对象）和业务服务的组合，解释用户请求，并与存储服务通信
- en: '**E-R Model**: This defines the relationship between entities (that is, **DTO**
    and **RDMS**/**NDMS**)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: E-R模型：这定义了实体之间的关系（即DTO和RDMS/NDMS）
- en: 'Now that you have some idea about the architecture, let''s understand its characteristics,
    which are listed as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对架构有了一些了解，让我们了解其特点，如下所示：
- en: '**Identical stack for application**: In this model, we use the same stack of
    elements for all read and write operations, starting from REST API to business
    service, and then we access the storage services, and so on, as all the different
    component codes are deployed together as a single entity.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的相同堆栈：在这个模型中，我们对所有读写操作使用相同的元素堆栈，从REST API到业务服务，然后访问存储服务等等，因为所有不同的组件代码都作为单个实体一起部署。
- en: 'The following diagram shows the **Read**/**Write** operation flow through different
    models:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了通过不同模型的读/写操作流程：
- en: '![](img/00079.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00079.jpeg)'
- en: '**Identical Data Model**: In this scenario, you will find that most of the
    times, we use the same or a similar data model for business logic processing,
    or for reading and writing data.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相同的数据模型：在这种情况下，您会发现大多数情况下，我们用于业务逻辑处理或读写数据的数据模型相同或类似。
- en: '**Deployment Units**: We use coarse-grained deployment units, which consist
    of the following:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署单元：我们使用粗粒度的部署单元，包括以下内容：
- en: A build (an executable collection of components)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构建（一组可执行的组件）
- en: Documents (end-user support material and release notes)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档（最终用户支持材料和发布说明）
- en: Installation artifacts, which combine both the read and write code together
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装工件，将读取和写入代码结合在一起
- en: '**Accessing data directly:** If we want to change data, we usually go ahead.
    Especially, in the case of RDBMS, we change the data directly, as in the following
    case--if we want to update the row with **User ID** **1** with another dataset,
    we usually do it directly. Also, once we have updated this value, the old value
    will be void from the application as well as the storage side, and cannot be retrieved:![](img/00080.jpeg)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接访问数据：如果我们想要更改数据，通常我们会继续。特别是在关系型数据库的情况下，我们直接更改数据，如下例--如果我们想要使用另一个数据集更新**用户ID**
    **1**的行，我们通常会直接这样做。而且，一旦我们更新了这个值，旧值将从应用程序以及存储端无效，并且无法检索！[](img/00080.jpeg)
- en: So far, we have been making use of the preceding approach, and I would say that
    it is pretty much proven and successful in terms of the response from user requests.
    However, there are other alternate approaches which can perform much better than
    this when compared.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用前面的方法，并且我会说，就用户请求的响应而言，它在很大程度上是经过验证和成功的。然而，与之相比，还有其他替代方法可以表现得更好。
- en: 'Let''s discuss the drawbacks of the aforementioned business architecture approach,
    which are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论上述业务架构方法的缺点，如下所示：
- en: '**Inability to scale independently**: Since our code for the read and write
    operations reside at the same location, we cannot scale our read or write for
    the application independently. Say you have 90% read and 10% write from the application
    side at a particular point in time, we can''t scale our read independently. In
    order to scale reads, we need to scale out the complete architecture, which is
    of no use, and increases the waste of resources.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无法独立扩展**：由于我们的读写操作代码驻留在同一位置，我们无法独立扩展应用程序的读取或写入。假设在特定时间点，应用程序的读取占90%，写入占10%，我们无法独立扩展读取。为了扩展读取，我们需要扩展整个架构，这是没有用的，还会增加资源的浪费。'
- en: '**No data history**: Since we are dealing with the scenario where we update
    the data directly, once the data is updated, the application will start showing
    the latest dataset after some period of time. Also, once the dataset is updated,
    old data values are not tracked, and hence, are lost. Even if we want to implement
    such kinds of features, we need to write lots of code to enable it.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**没有数据历史**：由于我们处理的是直接更新数据的情况，一旦数据更新，应用程序将在一段时间后开始显示最新的数据集。此外，一旦数据集更新，旧的数据值就不会被跟踪，因此会丢失。即使我们想要实现这种功能，我们也需要编写大量的代码来启用它。'
- en: '**Monolithic approach**: This approach tends to be a monolithic approach, as
    we try to merge things together. Moreover, we have coarse-grained deployment units,
    and we try to keep the code of the different components together. So, this kind
    of approach will ultimately result in a mess, which will be difficult to resolve.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单片式方法**：这种方法往往是一种单片式方法，因为我们试图将事物合并在一起。此外，我们有粗粒度的部署单元，并且我们试图将不同组件的代码放在一起。因此，这种方法最终会导致一团糟，很难解决。'
- en: One kind of approach which addresses these challenges is Event Sourcing.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些挑战的一种方法是事件溯源。
- en: Understanding Event Sourcing
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解事件溯源
- en: By simple definition, Event Sourcing is an architectural pattern which determines
    the state of an application by a sequence of events.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，事件溯源是一种架构模式，它通过一系列事件来确定应用程序的状态。
- en: The best way to understand Event Sourcing is by using an analogy. One of the
    best examples would be **online** **shopping**, which is an event processing system.
    Somebody places an order, which gets registered in an order queue for a vendor
    ordering system. Then, this status is notified to the customer at different stages
    of the order being delivered.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 理解事件溯源的最佳方法是使用类比。其中一个最好的例子就是**在线购物**，这是一个事件处理系统。有人下订单，订单被注册到供应商订购系统的订单队列中。然后，订单在不同阶段被通知给客户。
- en: 'All these events, which occur one after the other, form a sequence of events
    called an event stream, which should look something like the following diagram:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些事件一个接一个地发生，形成了一个称为事件流的事件序列，应该看起来像以下图表所示：
- en: '![](img/00081.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00081.jpeg)'
- en: So, Event Sourcing takes consideration of events which happened in the past,
    and are recorded for processing based on certain transactions.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，事件溯源考虑了过去发生的事件，并记录了基于某些交易进行处理。
- en: 'An ideal Event Sourcing system is based on the building blocks shown in the
    following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的事件溯源系统是基于以下图表中显示的构建模块的：
- en: '![](img/00082.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00082.jpeg)'
- en: The preceding diagram depicts an ideal event processing system, starting from
    the application to the creation of **Events** related to a certain incident, and
    then putting them in an **Event Queue** for further processing, which is performed
    by an **Event Handler**. Based on the description of the **Events**, the **Event
    Handler** processes them accordingly, and registers them in the **Store**.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图表描述了一个理想的事件处理系统，从应用程序开始到创建与某个事件相关的**事件**，然后将它们放入**事件队列**进行进一步处理，由**事件处理程序**执行。根据**事件**的描述，**事件处理程序**相应地处理它们，并将它们注册到**存储**中。
- en: Event Sourcing follows certain laws/tenets, which make application development
    a structured and disciplined process. Most people usually feel that Event Sourcing
    is hard or they think it is outright because of these tenets, which must not be
    broken, as doing so will create a huge chaos in the application.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源遵循某些法则/原则，这使得应用程序开发成为一个有结构和纪律的过程。大多数人通常觉得事件溯源很难，或者他们认为它是绝对的，因为这些原则不能被打破，否则会在应用程序中造成巨大的混乱。
- en: Laws of Event Sourcing
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件溯源的法则
- en: 'Listed next are some of the Event Sourcing laws which need to be maintained
    while implementing ES on any system (that is, application design):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些事件溯源法则，需要在任何系统（即应用程序设计）中实施时保持：
- en: '**Idempotency**: An ideal event-sourced business logic must be idempotent.
    This means that when you execute a business logic against an input stream of data,
    the resultant state of the application will always remain the same. Yes, that''s
    true, it will remain the same irrespective of the number of times you execute
    the business logic.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：理想的事件溯源业务逻辑必须是幂等的。这意味着当您针对一系列数据执行业务逻辑时，应用程序的结果状态将始终保持不变。是的，无论您执行业务逻辑的次数如何，它的结果状态都将保持不变。'
- en: '**Isolation**: Event Sourcing must not depend on the external event streams.
    This is one of the most important tenets of Event Sourcing. Generally, business
    logic is rarely ever executed in a vacuum. Applications usually interact with
    external entities for reference. Moreover, applications make use of cached information
    from external sources, even if developers don''t consider that point. Now, the
    question that arises is what happens if your business logic uses the external
    input to compute results? Let''s take the example of a stock exchange, where stock
    prices keep on changing, which means that the stock price at the time of state
    computation won''t be the same on multiple evaluations, which violates the idempotent
    rule.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：事件溯源不应依赖外部事件流。这是事件溯源的最重要原则之一。通常，业务逻辑很少在真空中执行。应用程序通常与外部实体进行交互以进行参考。此外，应用程序使用来自外部来源的缓存信息，即使开发人员没有考虑到这一点。现在，出现的问题是，如果您的业务逻辑使用外部输入来计算结果会发生什么？让我们以股票交易为例，股票价格不断变化，这意味着在状态计算时的股价在多次评估中不会相同，这违反了幂等规则。'
- en: As per the developer's understanding, this is a very difficult condition to
    satisfy. However, the solution to deal with this is to inject notifications into
    the main event stream from external events. Since these notifications are now
    part of the main events stream, you will get the expected result every time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据开发人员的理解，这是一个非常难以满足的条件。然而，处理这个问题的解决方案是从外部事件向主事件流中注入通知。由于这些通知现在是主事件流的一部分，您将每次都得到预期的结果。
- en: '**Quality assurance**: An event-sourced application, after being developed
    completely, should be a well-tested application. Writing test cases for the event-sourced
    application is easy--it usually takes a list of inputs and returns some state,
    considering that you are writing test cases following the previously defined principles.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量保证**：一个经过完全开发的事件溯源应用程序应该是一个经过充分测试的应用程序。为事件溯源应用程序编写测试用例很容易--通常需要一系列输入并返回一些状态，考虑到您是按照先前定义的原则编写测试用例。'
- en: '**Recoverable**: Event-sourced applications should support recovery and replay.
    If you have a cloud native application which adheres to all the guidelines of
    the twelve-factor apps to create an application suitable for the cloud platform,
    Event Sourcing plays a vital role in disaster recovery.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可恢复性**：事件溯源应用程序应支持恢复和重放。如果您有一个符合十二要素应用程序所有指南的云原生应用程序，以创建适合云平台的应用程序，事件溯源在灾难恢复中发挥着重要作用。'
- en: Assuming that the event stream is durable, an event-sourced application's initial
    advantage is to compute the state of the application. Usually, in a cloud environment,
    it is possible that the application crashes because of numerous reasons; Event
    Sourcing can help us identify the last state of the application, and recover it
    quickly to reduce the downtime. Moreover, Event Sourcing's replay functionality
    gives you the ability to look at the past state at the time of auditing, as well
    as troubleshooting.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设事件流是持久的，事件溯源应用程序的初始优势是计算应用程序的状态。通常，在云环境中，由于多种原因可能导致应用程序崩溃；事件溯源可以帮助我们识别应用程序的最后状态，并快速恢复以减少停机时间。此外，事件溯源的重放功能使您能够在审计和故障排除时查看过去的状态。
- en: '**Big Data**: Event Sourcing applications often generate huge amounts of data.
    Since an event-sourced application keeps track of every event, it is possible
    that it will generate huge amounts of data. It depends on how many events you
    have, how often they arrive, and how huge the data payload is for the events.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大数据**：事件溯源应用程序通常会生成大量数据。由于事件溯源应用程序跟踪每个事件，可能会生成大量数据。这取决于您有多少事件，它们多频繁到达，以及事件的数据负载有多大。'
- en: '**Consistency**: Event-sourced applications often maintain consistency for
    the registering of events. Think of banking transactions--every event happening
    during a bank transaction is very crucial. It should be noted that consistency
    should be maintained while recording it.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：事件溯源应用程序通常会保持事件注册的一致性。想想银行交易--银行交易期间发生的每个事件都非常重要。应该注意，在记录时应保持一致性。'
- en: 'It is very important to understand that these events are something that happened
    in the past, because when we name these events, they should be understandable.
    Examples of a few valid names for events could be as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解这些事件是过去发生的事情，因为当我们命名这些事件时，它们应该是可以理解的。一些有效的事件名称示例可能如下：
- en: '`PackageDeliveredEvent`'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PackageDeliveredEvent`'
- en: '`UserVerifiedEvent`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserVerifiedEvent`'
- en: '`PaymentVerifiedEvent`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PaymentVerifiedEvent`'
- en: 'Invalid events would be named as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 无效的事件将被命名如下：
- en: '`CreateUserEvent`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateUserEvent`'
- en: '`AddtoCartEvent`'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddtoCartEvent`'
- en: 'The following is some example code for an event:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个事件的示例代码：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'There are a few points that you should know:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些要注意的要点：
- en: Every event is immutable, which means that an event, once fired, cannot be reverted.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个事件都是不可变的，这意味着一旦触发了事件，就无法撤销。
- en: You never delete an event. Even if we try to delete an event, we consider deletion
    also as an event.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您永远不会删除事件。即使我们试图删除事件，我们也将删除视为一个事件。
- en: Event streams are driven by message-broker architecture. Some of the message
    brokers are RabbitMQ, ActiveMQ, and so on.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件流由消息代理架构驱动。一些消息代理包括RabbitMQ、ActiveMQ等。
- en: 'Now, let''s discuss some of the pros of Event Sourcing, which are as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论事件溯源的一些优点，如下所示：
- en: Event Sourcing gives the capability to rebuild the system very quickly
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源能够快速重建系统
- en: Event Sourcing gives you command over the data, which means that the data we
    require for our processing is easy to acquire by looking at the event stream for
    your processing purpose, say by audit, analysis, and so it should be audit, analysis,
    and so on
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件溯源使您对数据具有控制权，这意味着我们需要的处理数据可以通过查看事件流轻松获取，比如审计、分析等
- en: By looking at the events, it is easy to understand what went wrong during a
    period of time, considering a set of data
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查看事件，很容易理解在一段时间内发生了什么错误，考虑到一组数据
- en: Event replay would be advantageous during troubleshooting or bug fixing
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件重放在故障排除或错误修复期间会有优势
- en: Now, the question arises that since we are generating such a huge amount of
    events, does this affect the performance of the application? I would say, YES!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，问题出现了，由于我们生成了如此大量的事件，这是否会影响应用程序的性能？我会说，是的！
- en: As our application is generating events for every transaction which needs to
    be processed by the event handler, the response time of the application is reduced.
    The solution to this problem is CQRS.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序为每个需要由事件处理程序处理的事务生成事件，因此应用程序的响应时间得到了缩短。解决这个问题的方法是CQRS。
- en: Introduction to CQRS
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS简介
- en: Command Query Responsibility Segregation is a fancy pattern name, which means
    decoupling the input and the output of your system. In CQRS, we mainly talk about
    the read and write characteristics of our application; so, the commands in the
    context of CQRS are mainly write operations, while the queries are read operations,
    and responsibility means that we separate our read and write operations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 命令查询职责分离是一个花哨的模式名称，意味着解耦系统的输入和输出。在CQRS中，我们主要讨论应用程序的读和写特性；因此，在CQRS的上下文中，命令主要是写操作，而查询是读操作，责任意味着我们分离了读和写操作。
- en: 'If we look at the architecture described in the first section, Introduction,
    and apply CQRS, the architecture will be divided into half, and would look something
    like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下第一部分介绍中描述的架构，并应用CQRS，那么架构将被分成两半，看起来会是这样的：
- en: '![](img/00083.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00083.jpeg)'
- en: Now we will look at some code examples.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看一些代码示例。
- en: 'A traditional interface module would look something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的接口模块会是这样的：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Split-up, or as I prefer to call them, CQRS-ified interfaces, would look something
    like this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 分离，或者我更喜欢称之为CQRS-化的接口，会是这样的：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'So, the overall architecture, after the implementation of CQRS and Event Sourcing,
    would be something like the one shown in the following diagram:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在实施CQRS和事件溯源后，整体架构会像下图所示的那样：
- en: '![](img/00084.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00084.jpeg)'
- en: This is the complete architecture after the implementation of Event Sourcing
    and CQRS.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在实施事件溯源和CQRS后的完整架构。
- en: In a classic monolithic application, you have endpoints that write to a database,
    and endpoints that read from it. The same database is used for both read and write
    operations, and you don't reply to the endpoints until an acknowledgement or commit
    is received from the database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典的单体应用中，您有写入数据库的端点和从中读取的端点。相同的数据库用于读取和写入操作，并且在从数据库接收到确认或提交之前，不会回复端点。
- en: On a massive scale, with a high inbound event throughput and complex event processing
    requirements, you can't afford to run slow queries for reads, nor can you afford
    to sit and wait for processing to take place every time you get a new inbound
    event.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模情况下，具有高入站事件吞吐量和复杂事件处理要求，您不能承受读取慢查询，也不能每次获得新的入站事件时等待处理。
- en: 'The flow for both read and write operations works as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 读和写操作的流程如下：
- en: '**Write model**: In this case, when a command is fired from the endpoint and
    received at the **Command Business Service**, it first issues the events for every
    incident to the **Event Store**. In the **Event Store**, you also have a **Command
    processor**, or, in other words, event handler, and this **Command processor**
    is able to derive the application state into a separate **Storage**, which could
    be a relational storage.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**写模型**：在这种情况下，当从端点触发命令并在**命令业务服务**接收到时，首先为每个事件发出事件到**事件存储**。在**事件存储**中，您还有一个**命令处理器**，或者换句话说，事件处理程序，这个**命令处理器**能够将应用程序状态派生到一个单独的**存储**中，这可能是一个关系型存储。'
- en: '**Read model**: In the case of the **Read** model, we simply use the **Query
    Endpoints** to query the data which we want to **Read** or retrieve for the application
    usage by the client.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读模型**：在**读**模型的情况下，我们只需使用**查询端点**来查询客户端想要**读取**或检索的数据，以供应用程序使用。'
- en: The biggest advantage is that we don't need to go through the **Write** model
    (which is on the right-hand side of the preceding image). When it comes to querying
    the database, this process makes our query execution faster, and reduces the response
    time which, in turn, increases the application's performance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的优势是我们不需要通过**写**模型（在前图的右侧）进行。在查询数据库时，这个过程使我们的查询执行更快，并减少了响应时间，从而提高了应用程序的性能。
- en: Advantages of the CQRS-ified architecture
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS-化架构的优势
- en: 'This architecture has the following advantages:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构有以下优点：
- en: '**Independent scalability and deployment**: We can now scale and deploy an
    individual component based on its usage. As in the case of microservices, we can
    now have separate microservices for each of the tasks, say a read microservice
    and a write microservice, in this architecture stack.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**独立的可伸缩性和部署**：现在我们可以根据其使用情况扩展和部署单个组件。就像微服务的情况一样，我们现在可以为每个任务拥有单独的微服务，比如一个读微服务和一个写微服务，在这个架构堆栈中。'
- en: '**Choice of technologies**: Freedom with regards to the choice of technologies
    for the different sections of the business model. For instance, for the command
    functionality, we could choose Scala or similar (assuming that we have a complex
    business model, and we have a lot of data to write). In the case of a query, we
    can choose, for example, ROR (Ruby on Rails) or Python (which we are already using).'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术选择**：在业务模型的不同部分选择技术的自由。例如，对于命令功能，我们可以选择Scala或类似的语言（假设我们有一个复杂的业务模型，并且有大量数据要写入）。在查询的情况下，我们可以选择，例如，ROR（Ruby
    on Rails）或Python（我们已经在使用）。'
- en: This type of architecture is best suited for bounded context from **DDD** (**Domain-Driven
    design**), because we can define the business context for the microservices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的架构最适合于**DDD**（领域驱动设计）的有界上下文，因为我们可以为微服务定义业务上下文。
- en: Challenges related to ES and CQRS
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与ES和CQRS相关的挑战
- en: 'Every architecture design model has its own challenges for implementation.
    Let''s discuss the challenges of ES and CQRS:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每种架构设计模型在实施时都有自己的挑战。让我们讨论ES和CQRS的挑战：
- en: '**Inconsistency**: Systems developed using ES and CQRS are mostly consistent.
    However, as we store the events issued by the **Command Business Service** at
    the **Event Store**, and store the state of the application in the main **Storage**
    as well, I would say this kind of system is not fully consistent. If we really
    want to make our system fully consistent using ES and CQRS, we need to keep our
    **Event Store** and main **Storage** on a single **Relational Database**, and
    our **Command processor** should handle all our incoming events, and store them
    in both storages at the same time, as depicted in the following diagram:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不一致性**：使用ES和CQRS开发的系统大多是一致的。然而，由于我们在**事件存储**中存储**命令业务服务**发出的事件，并且在主**存储**中也存储应用程序的状态，我会说这种系统并不完全一致。如果我们真的想使用ES和CQRS使我们的系统完全一致，我们需要将我们的**事件存储**和主**存储**放在一个单一的**关系数据库**上，我们的**命令处理器**应该处理所有我们的传入事件，并同时将它们存储在两个存储中，如下图所示：'
- en: '![](img/00085.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00085.jpeg)'
- en: I would say that the consistency level should be defined by understanding the
    business domain. How much consistency you would need in events, and how much these
    consistencies would cost, needs to be understood. After inspecting your business
    domain, you will be able to make these decisions considering the aforementioned
    factors.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为一致性水平应该由对业务领域的理解来定义。需要了解事件中需要多少一致性，以及这些一致性会带来多大的成本。在检查业务领域之后，您将能够考虑上述因素做出这些决定。
- en: '**Validation**: It is very easy when we talk in terms of validating the customer
    registration form, where we need to validate the individual field, and so on.
    But actual validation comes when we have to do validation based on uniqueness--say
    we have a customer with certain user credentials (username/password). So, to make
    sure that the username is unique is a crucial validation when we have more than
    2 million customers who need to be registered. A few questions that need to be
    asked in terms of validation are as follows:'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：当我们谈论验证客户注册表单时，这非常容易，我们需要验证各个字段等等。但实际的验证是在我们需要基于唯一性进行验证时--比如说我们有一个具有特定用户凭据（用户名/密码）的客户。因此，确保用户名是唯一的是一个关键的验证，当我们有超过200万需要注册的客户时。在验证方面需要问一些问题，如下所示：'
- en: What is the data requirement for validation?
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证的数据需求是什么？
- en: Where to retrieve the data for validation from?
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从哪里检索验证数据？
- en: What is the probability of validation?
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证的概率是多少？
- en: What is the impact of validation failure on the business?
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证失败对业务的影响是什么？
- en: '**Parallel data updates**: This is very crucial in terms of data consistency.
    Say, you have a user who wants to update certain records at the same time, or
    within a difference of nanoseconds. In this case, the possibility of consistency
    as well as validation checks is challenging, as there is a possibility that one
    user might end up overwriting the other user information which could create chaos.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并行数据更新**：这在数据一致性方面非常重要。比如说，您有一个用户想要在同一时间或在纳秒的差距内更新某些记录。在这种情况下，一致性和验证检查的可能性是具有挑战性的，因为有可能一个用户可能会覆盖另一个用户的信息，这可能会造成混乱。'
- en: Overcoming challenges
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 克服挑战
- en: One way to solve such a problem in Event Sourcing is to add versions in events,
    which will act as a handle for making changes to the data and make sure it is
    validated fully.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件源中解决这样的问题的一种方法是在事件中添加版本，这将作为对数据进行更改的处理，并确保它得到充分验证的处理。
- en: Problem solving
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题解决
- en: 'Let''s take the use case shown in the following diagram for Event Sourcing
    and CQRS to understand it in terms of writing code for it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以以下图表中显示的用例为例，以了解在编写代码时如何理解事件源和CQRS：
- en: '![](img/00086.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00086.jpeg)'
- en: Explanation of the problem
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释问题
- en: In this case, we are provided with **User Details** such as **User ID** (which
    should be unique), **username**, **password**, **email ID**, and so on, and we
    have to create two write **Commands** to be fired--**UserRegistrationCommand**
    and **UpdatePasswordCommand**, which trigger two **Events:** **UserRegisterEvents**
    and **UpdatePasswordEvents**. The idea is that a user, once registered, should
    be able to reset the password as per their needs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们提供了**用户详细信息**，如**用户ID**（应该是唯一的），**用户名**，**密码**，**电子邮件ID**等等，我们需要创建两个要触发的写**命令**--**UserRegistrationCommand**和**UpdatePasswordCommand**，触发两个**事件**：**UserRegisterEvents**和**UpdatePasswordEvents**。这个想法是，一旦注册用户，就应该能够根据他们的需求重置密码。
- en: The solution
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: In order to solve this problem, we will need to write functions related to write
    commands to receive the inputs and update the event store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要编写与写命令相关的函数来接收输入并更新事件存储。
- en: 'Now, let''s add the following code to the `commands.py` file, which will have
    code related to the write commands that need to be performed as described:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下代码添加到`commands.py`文件中，其中将包含需要执行的写命令相关的代码：
- en: '[PRE3]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, we have added the functions related to the commands, but it should be called
    from somewhere with the user details.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经添加了与命令相关的函数，但它应该从某个地方调用用户详细信息。
- en: Let's add a new file called `main.py` from where the preceding command's function
    will be called.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个名为`main.py`的新文件，从这里将调用前面命令的函数。
- en: 'In the following code, we call the preceding code by triggering events:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们通过触发事件来调用前面的代码：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s understand the preceding code, function by function:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个理解前面的代码：
- en: '[PRE5]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The last code initializes the `self` object with some default values; it is
    similar to the initialize function in any programming language.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的代码初始化了`self`对象的一些默认值；这类似于任何编程语言中的初始化函数。
- en: 'Next, we defined the `userRegister` function, which, basically, collects `userdetails`,
    and then creates the event (`UserRegisterevent(userdetails))`) as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义了`userRegister`函数，基本上收集`userdetails`，然后创建事件（`UserRegisterevent(userdetails))`）如下：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So, once the user is registered, he/she is authorized to update the profile
    details, which could be the email ID, password, username, and others--in our case,
    it is the password. Please refer to the following code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦用户注册，他/她就有权更新配置文件详细信息，这可能是电子邮件ID、密码、用户名等--在我们的情况下，是密码。请参考以下代码：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You can write similar code for updating the email ID, username, or others.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写类似的代码来更新电子邮件ID、用户名或其他信息。
- en: 'Moving on, we need to add error handling, as in our `main.py` file, we call
    a custom module, `errors`, to handle operation-related errors. Let''s add the
    following code to `errors.py` to pass the errors if caught:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加错误处理，因为在我们的`main.py`文件中，我们调用一个自定义模块`errors`来处理与操作相关的错误。让我们将以下代码添加到`errors.py`中以传递捕获的错误：
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in `main.py`, we call the `Aggregate` module, and you must be
    wondering why it is being used. The `Aggregate` module is very important as it
    keeps track of the changes that need to be applied. In other words, it forces
    the event to commit all its uncommented changes to the event store.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在`main.py`中所看到的，我们调用`Aggregate`模块，您一定想知道为什么要使用它。`Aggregate`模块非常重要，因为它跟踪需要应用的更改。换句话说，它强制事件将其所有未注释的更改提交到事件存储。
- en: 'In order to do so, let''s add the following code to a new file called `aggregate.py`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们将以下代码添加到一个名为`aggregate.py`的新文件中：
- en: '[PRE9]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In `aggregate.py`, we initialize the `self` object, which is called in `main.py`,
    and then keep a track of events which are being triggered. After a period of time,
    we will make a call to apply the changes from `main.py` to update `eventstore`
    with the updated values and events.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`aggregate.py`中，我们初始化了`self`对象，该对象在`main.py`中被调用，然后跟踪被触发的事件。一段时间后，我们将调用`main.py`中的更改来更新`eventstore`的更新值和事件。
- en: '[PRE10]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we are left with the command handler, which is very important, as it decides
    which operation needs to be performed and the respective events that need to be
    triggered. Let''s add the file `command_handler.py` with the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们还剩下命令处理程序，这非常重要，因为它决定了需要执行的操作以及需要触发的相应事件。让我们添加名为`command_handler.py`的文件，并添加以下代码：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In `command_handler.py`, we have written a handle function which will make the
    decision of the flow of event execution.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在`command_handler.py`中，我们编写了一个处理函数，它将决定事件执行流程。
- en: As you can see, we called the `@contextmanager` module, which is very important
    to understand here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们调用了`@contextmanager`模块，在这里非常重要。
- en: 'Let''s take a scenario: suppose there are two people, Bob and Alice, and both
    are using the same user credentials. Let''s say they both are trying to update
    the profile details field, for example, the password, at the same time. Now, we
    need to understand how these commands get requested. In short, whose request will
    hit the event store first. Also, if both the users update the password, then it
    is highly possible that one user''s updated password will be overwritten by another.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个场景：假设有两个人，Bob和Alice，两者都使用相同的用户凭据。假设他们都试图同时更新配置文件详细信息字段，例如密码。现在，我们需要了解这些命令是如何请求的。简而言之，谁的请求会先到达事件存储。此外，如果两个用户都更新密码，那么很可能一个用户的更新密码将被另一个用户覆盖。
- en: One way of solving the problem is to use version along with user schema, as
    we use it in the context manager. We take `user_version` as an argument, which
    will determine the state of the user data, and once it is modified, we can increment
    the version to make the data consistent.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 解决问题的一种方法是在用户模式中使用版本，就像我们在上下文管理器中使用的那样。我们将`user_version`作为参数，它将确定用户数据的状态，一旦修改，我们可以增加版本以使数据一致。
- en: So, in our case, if Bob's modified value is updated first (of course, with the
    new version), and if Alice's request version field doesn't match with the version
    in the database, then Alice's update request will be rejected.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的情况下，如果Bob的修改值首先更新（当然，使用新版本），如果Alice的请求版本字段与数据库中的版本不匹配，则Alice的更新请求将被拒绝。
- en: Once this is updated, we should be able to register and update the password.
    Though this is an example to show how to implement CQRS, you can extend this to
    create microservices on top of it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更新完成，我们应该能够注册和更新密码。虽然这只是一个示例，展示了如何实现CQRS，但您可以扩展它以在其上创建微服务。
- en: Kafka as an eventstore
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kafka作为事件存储
- en: Although we have already seen the CQRS implementation, I still feel that you
    may have a few queries related to `eventstore`, and how it works. That's why I'll
    take the use case of Kafka, which can be used as an `eventstore` for your application.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经看到了CQRS的实现，但我仍然觉得您可能对`eventstore`及其工作方式有一些疑问。这就是为什么我将采用Kafka的用例，它可以用作应用程序的`eventstore`。
- en: Kafka is, typically, a message broker or message queue (similar to RabbitMQ,
    JMS, and others).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka通常是一个消息代理或消息队列（类似于RabbitMQ、JMS等）。
- en: As per the Kafka documentation, Event Sourcing is a style of application design
    where the state changes are logged as a time-ordered sequence of records. Kafka's
    support for very large stored log data makes it an excellent backend for an application
    built in this style.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Kafka文档，事件溯源是一种应用设计风格，其中状态更改被记录为时间顺序的记录序列。Kafka对非常大的存储日志数据的支持使其成为构建此风格的应用程序的优秀后端。
- en: 'For more information related to implementing Kafka, read its documentation
    at this link: [https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实施Kafka的更多信息，请阅读此链接上的文档：[https://kafka.apache.org/documentation/](https://kafka.apache.org/documentation/)。
- en: 'Kafka has the following basic components:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka具有以下基本组件：
- en: '**Producers**: This sends messages to Kafka'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：将消息发送到Kafka'
- en: '**Consumers**: These subscribe to streams of messages in Kafka'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：这些订阅Kafka中的消息流'
- en: 'Kafka works in the following manner:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka的工作方式如下：
- en: Producers write messages in Kafka topics, which could be users
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者在Kafka主题中写入消息，这些消息可能是用户
- en: Every message that is in a Kafka topic is appended at the end of the partition
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kafka主题中的每条消息都会被追加到分区的末尾
- en: Kafka only supports **write** operations.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka只支持**写**操作。
- en: Partitions represent streams of events, and topics can be categorized into multiple
    topics
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分区代表事件流，主题可以被分类为多个主题
- en: Partitions in topics are independent of each other
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主题中的分区彼此独立。
- en: To avoid disaster, Kafka partitions are replicated across several machines
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了避免灾难，Kafka分区会被复制到多台机器上
- en: To consume Kafka messages, the client reads the message sequentially, starting
    from the offset, which is set in Kafka by the consumer
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了消费Kafka消息，客户端按顺序读取消息，从在Kafka中由消费者设置的偏移开始
- en: Applying Event Sourcing with Kafka
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kafka应用事件溯源
- en: 'Let''s take a use case where the client tries to perform a certain operation,
    and we are using Kafka as an eventstore to capture all the messages that are being
    passed. In this case, we have the user management service, which could be a microservice
    responsible for managing all user requests. We will start with identifying the
    topics for Kafka based on user events, which could be one of the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个使用案例，客户端尝试执行某个操作，我们使用Kafka作为事件存储来捕获所有传递的消息。在这种情况下，我们有用户管理服务，它可能是负责管理所有用户请求的微服务。我们将从基于用户事件的Kafka主题开始识别主题，可能是以下之一：
- en: '`UserCreatedEvent`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserCreatedEvent`'
- en: '`UserUpdatedEvent`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserUpdatedEvent`'
- en: '`UserDeletionEvent`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserDeletionEvent`'
- en: '`UserLoggedinEvent`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserLoggedinEvent`'
- en: '`UserRoleUpdatedEvent`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRoleUpdatedEvent`'
- en: 'These events will, ideally, be published by the **User Management Service**,
    and all microservices will consume these events. The following diagram shows the
    user request flow:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些事件理想情况下将由**用户管理服务**发布，并且所有微服务都将消费这些事件。以下图表显示了用户请求流程：
- en: '![](img/00087.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00087.jpeg)'
- en: How it works
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理
- en: A user makes a `POST` request to the API gateway, which is an entry point for
    the user management service to register users. The API gateway, in turn, makes
    an **RPC** Call (**Remote procedure call**) to the `createUser` method in the
    management service. The `createUser` endpoint performs a set of validations on
    the user input. If the input is invalid, it will throw an exception, and return
    the error to the API gateway. Once the user input is validated, the user is registered,
    and `UserCreatedEvent` is triggered to get published in Kafka. In Kafka, partitions
    capture the events. In our example, the users topic has three partitions, so the
    event will be published to one of the three partitions based on some defined logic;
    this logic is defined by us, which varies based on the use case.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 用户向API网关发出`POST`请求，这是用户管理服务注册用户的入口点。API网关反过来调用管理服务中的`createUser`方法。`createUser`端点对用户输入进行一系列验证。如果输入无效，它将抛出异常，并将错误返回给API网关。一旦用户输入被验证，用户将被注册，并且将触发`UserCreatedEvent`以在Kafka中发布。在Kafka中，分区捕获事件。在我们的示例中，用户主题有三个分区，因此事件将根据一些定义的逻辑发布到三个分区中的一个；这个逻辑由我们定义，根据用例的不同而变化。
- en: All read operations such as listing user, and more, can be retrieved directly
    from readStore (database such as PostgreSQL).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 所有读取操作，比如列出用户等，都可以直接从readStore（如PostgreSQL等数据库）中检索出来。
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This was a complex chapter, but if you understand it fully, it will make your
    application efficient and high performance.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个复杂的章节，但如果你完全理解了它，它将使你的应用程序高效且性能卓越。
- en: We kicked off by understanding the drawbacks of the classic architecture, and
    then moved on to discuss the concept and implementation of ES and CQRS. We also
    looked at the implementation of a sample problem. We talked about why these patterns
    are useful, and how they have a particular harmony with massive-scale, cloud native
    applications.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先了解了经典架构的缺点，然后讨论了ES和CQRS的概念和实现。我们还看了一个示例问题的实现。我们谈到了为什么这些模式有用，以及它们如何与大规模、云原生应用程序特别协调。
- en: In the upcoming chapter, we are going to deep dive into the security of the
    application. Stay tuned!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨应用程序的安全性。敬请关注！
