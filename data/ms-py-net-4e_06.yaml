- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Network Security with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行网络安全
- en: In my opinion, network security is a tricky topic to write about. The reason
    is not a technical one but rather has to do with setting up the correct scope.
    The boundaries of network security are so wide that they touch all seven layers
    of the OSI model. From layer 1 of wiretapping to layer 4 of the transport protocol
    vulnerability, to layer 7 of man-in-the-middle spoofing, network security is everywhere.
    The issue is exacerbated by all the newly discovered vulnerabilities, which sometimes
    seem to be a daily occurrence. This does not even include the human social engineering
    aspect of network security.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，网络安全是一个难以写作的话题。原因不是技术性的，而是与设定正确的范围有关。网络安全的边界非常广泛，触及OSI模型的七个层次。从第1层的窃听到第4层的传输协议漏洞，再到第7层的中间人欺骗，网络安全无处不在。新发现的所有漏洞都加剧了这个问题，有时似乎每天都有发生。这还不包括网络安全中的人为社会工程方面。
- en: As such, in this chapter, I would like to set the scope for what we will discuss.
    As we have been doing up to this point, we will primarily focus on using Python
    for network device security at OSI layers 3 and 4\. We will look at Python tools
    that we can use to manage individual network devices for security purposes, as
    well as using Python as a glue to connect different components. Hopefully, we
    can treat network security holistically using Python in different OSI layers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我想设定我们将讨论的范围。正如我们到目前为止所做的那样，我们将主要关注使用Python在OSI第3层和第4层进行网络设备安全。我们将查看我们可以用于管理单个网络设备以进行安全目的的Python工具，以及使用Python作为连接不同组件的粘合剂。希望我们能够使用Python在不同OSI层上全面处理网络安全。
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: The lab setup
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室设置
- en: Python Scapy for security testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python Scapy用于安全测试
- en: Access lists
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问列表
- en: Forensic analysis with Syslog and **Uncomplicated Firewall** (**UFW**) using
    Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Python的Syslog和**简单防火墙**（**UFW**）进行取证分析
- en: Other tools, such as a MAC address filter list, private VLAN, and Python IP
    table binding
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具，如MAC地址过滤器列表、私有VLAN和Python IP表绑定
- en: Let’s begin by looking at our lab setup for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章的实验室设置开始看起。
- en: The Lab Setup
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验室设置
- en: The devices being used in this chapter are a bit different from the previous
    chapters. In the previous chapters, we isolated a particular set of devices. For
    this chapter, we will use a few more Linux hosts in our lab to illustrate the
    function of the tools we will use. The connectivity and operating system information
    are important as they have ramifications regarding the security tools we will
    show later in this chapter. For example, if we want to apply an access list to
    protect the server, we need to know what the topology looks like and in which
    direction the client is making their connections. The Ubuntu host connections
    are a bit different than what we have seen so far, so please refer to this lab
    section when you see the example later if needed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的设备与前面章节略有不同。在前面章节中，我们隔离了一组特定的设备。对于本章，我们将在实验室中使用更多的Linux主机来展示我们将使用的工具的功能。连接性和操作系统信息很重要，因为它们与本章后面我们将展示的安全工具有关。例如，如果我们想应用访问列表来保护服务器，我们需要知道拓扑结构是什么样的，以及客户端连接的方向。Ubuntu主机的连接方式与我们所见的不同，所以如果需要，请参考此实验室部分，稍后查看示例。
- en: We will use the same Cisco CML tool with the NYC nodes with two additional Ubuntu
    hosts. The lab topology is provided with the course files.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与NYC节点相同的Cisco CML工具，并添加两个额外的Ubuntu主机。实验室拓扑结构包含在课程文件中。
- en: 'The way to add a Linux host in CML is the same as adding network nodes, simply
    click on **add nodes** and pick Ubuntu as the selection. We will name the outside
    host connecting to `nyc-cor-r1` as the client, and the host behind `nyc-cor-edg-r1`
    as the server:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在CML中添加Linux主机的步骤与添加网络节点相同，只需点击**添加节点**并选择Ubuntu即可。我们将连接到`nyc-cor-r1`的外部主机命名为客户端，连接到`nyc-cor-edg-r1`的主机命名为服务器：
- en: '![](img/B18403_06_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_06_01.png)'
- en: 'Figure 6.1: Adding Ubuntu Hosts'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：添加Ubuntu主机
- en: 'This is a good point to review and learn about Ubuntu Linux networking. We
    will spend some time listing out the Ubuntu Linux networking options of the setup.
    Here is an overview of the lab topology:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个回顾和学习Ubuntu Linux网络的好时机。我们将花一些时间列出设置中的Ubuntu Linux网络选项。以下是实验室拓扑的概述：
- en: '![](img/B18403_06_02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B18403_06_02.png)'
- en: 'Figure 6.2: Lab Topology'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：实验室拓扑
- en: The IP addresses listed will probably be different in your lab. They are listed
    here to easily reference in the remainder of the chapter code examples.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的 IP 地址可能因您的实验室而异。这里列出它们是为了在章节剩余部分的代码示例中方便引用。
- en: 'We will add two dual-home links to the hosts, one for the default gateway going
    to the unmanaged switch for management and internet. The other link is used to
    route the internet traffic. As illustrated, we will rename the host on the top
    as the client, and the bottom host as the server using the `hostname <name>` command.
    This is analogous to an internet client trying to access a corporate server within
    our network. The version of Ubuntu Linux in the CML software is 18.04 LTS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在主机上添加两个双栈链接，一个用于默认网关，连接到未管理的交换机以进行管理和互联网访问。另一个链接用于路由互联网流量。如图所示，我们将使用 `hostname
    <name>` 命令将顶部的宿主命名为客户端，将底部的宿主命名为服务器。这类似于一个互联网客户端试图访问我们网络内的企业服务器。CML 软件中使用的 Ubuntu
    Linux 版本是 18.04 LTS：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To list and turn up the links, we can use the `ip link` and `ifconfig` commands:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出和启用链接，我们可以使用 `ip link` 和 `ifconfig` 命令：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For the hosts, when we first turn it up, it will have an initial network configuration
    under `/etc/netplan/50-cloud-init.yaml`. We will back it up and create our own:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于主机，当我们首次启动它时，它将在 `/etc/netplan/50-cloud-init.yaml` 下有一个初始网络配置。我们将备份它并创建自己的配置：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the two network links, we will use the following configuration to configure
    the default gateway for `ens3` (management and internet) as well as the internal
    link:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个网络链接，我们将使用以下配置来配置 `ens3` 的默认网关（管理和互联网）以及内部链接：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To allow the network change to take effect, we can use the `netplan apply`
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使网络更改生效，我们可以使用 `netplan apply` 命令：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is a quick output for the server side:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是服务器端的一个快速输出：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will put the connected network into the existing OSPF network. Here is the
    configuration of `nyc-cor-r1`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把连接的网络放入现有的 OSPF 网络中。以下是 `nyc-cor-r1` 的配置：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The configuration of `nyc-cor-edg-r1` is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`nyc-cor-edg-r1` 的配置如下：'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here comes the part that might be a bit tricky for engineers who might be new
    to host-based networking. By default, the host has a routing preference as well.
    The default gateway we added for `ens3` will allow us to use the lab gateway for
    the “destination of last resort.” We can see the routing table on the host via
    the `route` command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是可能对那些对基于主机的网络不太熟悉的工程师来说有点棘手的部分。默认情况下，主机也有一个路由优先级。我们为 `ens3` 添加的默认网关将允许我们使用实验室网关作为“最后的手段”的目标。我们可以通过
    `route` 命令在主机上查看路由表：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We will use the following command to route traffic from the client to the server
    via the `route` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令通过 `route` 命令将客户端到服务器的流量路由：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We will do the same on the server side:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在服务器端做同样的事情：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To verify the client-to-server path, let’s ping and trace the route to make
    sure that traffic between our hosts is going through the network devices instead
    of the default route:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证客户端到服务器的路径，让我们使用 ping 和路由跟踪来确保主机之间的流量是通过网络设备而不是默认路由来传输的：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The final task is to prepare the host for the remainder of the chapter with
    updated repositories:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的任务是为本章剩余部分准备主机，更新仓库：
- en: '[PRE14]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Great! We have our lab; we are now ready to look at some security tools and
    measures using Python.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的实验室已经准备好了；我们现在可以查看一些使用 Python 的安全工具和措施。
- en: Python Scapy
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python Scapy
- en: Scapy ([https://scapy.net](https://scapy.net)) is a powerful Python-based interactive
    packet crafting program. Outside of some expensive commercial programs, very few
    tools can do what Scapy can do, to my knowledge. It is one of my favorite tools
    in Python.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy ([https://scapy.net](https://scapy.net)) 是一个基于 Python 的强大交互式数据包构建程序。据我所知，除了少数昂贵的商业程序之外，几乎没有其他工具能像
    Scapy 那样做到。它是我的 Python 最喜欢的工具之一。
- en: 'The main advantage of Scapy is that it allows us to craft our packet from a
    very basic level. In the words of Scapy’s creator:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 的主要优势在于它允许我们从非常基础的级别构建数据包。用 Scapy 创始人的话来说：
- en: ”Scapy is a powerful interactive packet manipulation program. It is able to
    forge or decode packets of a wide number of protocols, send them on the wire,
    capture them, match requests and replies, and much more…… with most other tools,
    you won’t build something the author did not imagine. These tools have been built
    for a specific goal and can’t deviate much from it.”
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Scapy 是一个强大的交互式数据包操纵程序。它能够伪造或解码大量协议的数据包，将它们发送到线路上，捕获它们，匹配请求和回复，等等……与其他大多数工具相比，你不会构建作者没有想象到的东西。这些工具是为特定目标构建的，不能偏离太多。”
- en: Let’s now take a look at the tool.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个工具。
- en: Installing Scapy
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Scapy
- en: 'Scapy has had an interesting path when it comes to Python 3 support. Back in
    2015, there was an independent fork of Scapy from version 2.2.0 that aimed to
    support Python 3, named `Scapy3k`. In this book, we are using the main code base
    from the original Scapy project. If you have read the previous edition of the
    book and used a Scapy version that was only compatible with Python 2, please take
    a look at the Python 3 support per Scapy release:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3支持方面，Scapy经历了一段有趣的历程。在2015年，从版本2.2.0开始，Scapy有一个独立的分支，名为`Scapy3k`，旨在支持Python
    3。在这本书中，我们使用原始Scapy项目的代码库。如果您已经阅读了本书的前一版并使用了仅兼容Python 2的Scapy版本，请查看Scapy每个版本的Python
    3支持：
- en: '![Table  Description automatically generated with medium confidence](img/B18403_06_03.1.png)![A
    picture containing chart  Description automatically generated](img/B18403_06_03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![表格描述自动生成，置信度中等](img/B18403_06_03.1.png)![包含图表的图片，描述自动生成](img/B18403_06_03.png)'
- en: 'Figure 6.3: Python version support (source: https://scapy.net/download/)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：Python版本支持（来源：https://scapy.net/download/）
- en: 'We will install the official release from the source:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从源安装官方版本：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Following installation, we can launch the Scapy interactive shell by typing
    in **scapy** in the Command Prompt:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，我们可以通过在命令提示符中输入**scapy**来启动Scapy交互式shell：
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is a quick test to make sure we can access the `Scapy` library from Python
    3:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个快速测试，以确保我们可以从Python 3访问`Scapy`库：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Awesome! Scapy is now installed and can be executed from our Python interpreter.
    Let’s take a look at its usage via the interactive shell in the next section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！Scapy现在已安装，可以从我们的Python解释器中执行。让我们在下一节通过交互式shell查看其用法。
- en: Interactive examples
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式示例
- en: 'In our first example, we will craft an **Internet Control Message Protocol**
    (**ICMP**) packet on the client and send it to the server. On the server side,
    we will use `tcpdump` with a host filter to see the packet coming in:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们将在客户端构建一个**互联网控制消息协议**（**ICMP**）包并发送到服务器。在服务器端，我们将使用带有主机过滤器的`tcpdump`来查看进入的包：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, it is very simple to craft a packet from Scapy. Scapy allows
    you to build the packet layer by layer using the slash (`/`) as the separator.
    The `send` function operates at the layer 3 level, which takes care of routing
    and layer 2 for you. There is also a `sendp()` alternative that operates at layer
    2, which means you will need to specify the interface and link layer protocol.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用Scapy构建包非常简单。Scapy允许您通过斜杠（`/`）作为分隔符逐层构建包。`send`函数在第三层操作，负责路由，并为您处理第二层。还有一个`sendp()`替代方案，它在第二层操作，这意味着您需要指定接口和链路层协议。
- en: 'Let’s look at capturing the returned packet by using the `send-request` (`sr`)
    function. We are using a special variation of `sr`, called `sr1`, which only returns
    one packet that answers from the packet sent:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`send-request`（`sr`）函数来捕获返回的包。我们使用`sr`的一个特殊变体，称为`sr1`，它只返回一个响应于发送的包的包：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'One thing to note is that the `sr()` function returns a tuple containing answered
    and unanswered lists:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个需要注意的事项是，`sr()`函数返回一个包含已响应和未响应列表的元组：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let’s take a look at what is contained inside the tuple:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看元组中包含的内容：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we were to only take a look at the answered packet list, we could see that
    it is a `NamedTuple` containing the packet that we have sent as well as the returned
    packet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只查看响应包列表，我们可以看到它是一个包含我们发送的包以及返回的包的`NamedTuple`：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Scapy also provides a layer 7 construct, such as a DNS query. In the following
    example, we are querying an open DNS server for the resolution of [www.google.com](http://www.google.com):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy还提供第七层构造，例如DNS查询。在以下示例中，我们正在查询一个公开的DNS服务器以解析[www.google.com](http://www.google.com)：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Let’s take a look at some other Scapy features. We’ll begin by using Scapy for
    packet captures.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看Scapy的一些其他功能。我们将从使用Scapy进行包捕获开始。
- en: Packet captures with Scapy
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scapy进行包捕获
- en: 'As network engineers, we constantly have to capture packets on the wire during
    troubleshooting. We typically use Wireshark or similar tools, but Scapy can also
    be used to easily capture packets on the wire:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为网络工程师，我们在故障排除过程中必须不断在电缆上捕获包。我们通常使用Wireshark或类似工具，但Scapy也可以用来轻松捕获电缆上的包：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can look at the packets in some more detail, including the raw format:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更详细地查看包，包括原始格式：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have seen the basic workings of Scapy. Let’s now move on and see how we can
    use Scapy for certain aspects of common security testing.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Scapy 的基本工作原理。现在，让我们继续看看我们如何使用 Scapy 进行某些方面的常见安全测试。
- en: The TCP port scan
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TCP 端口扫描
- en: The first step for any potential hackers is almost always trying to learn which
    service is open on the network to focus their efforts on the attack. Of course,
    we need to open certain ports to service our customers; that is part of the risk
    we must accept. However, we should close any other open port that needlessly exposes
    a larger attack surface. We can use Scapy to do a simple TCP open port scan to
    scan our own host.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何潜在的黑客来说，第一步几乎总是尝试了解网络上哪些服务是开放的，以便将他们的攻击重点放在这些服务上。当然，我们需要打开某些端口来服务我们的客户；这是我们必须接受的风险的一部分。然而，我们应该关闭任何其他不必要的开放端口，以减少攻击面。我们可以使用
    Scapy 对我们的主机进行简单的 TCP 开放端口扫描。
- en: 'We can send a `SYN` packet and see whether the server will return with `SYN-ACK`
    for various ports. Let’s start with Telnet, TCP port `23`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以发送一个 `SYN` 数据包，看看服务器是否会为各种端口返回 `SYN-ACK`。让我们从 Telnet 开始，TCP 端口 `23`：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Note that, in the output here, the server is responding with a `RESET+ACK`
    for TCP port `23`. However, TCP port `22` (SSH) is open; therefore, a `SYN-ACK`
    is returned:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这里的输出中，服务器对于 TCP 端口 `23` 返回了 `RESET+ACK`。然而，TCP 端口 `22`（SSH）是开放的；因此，返回了
    `SYN-ACK`：
- en: '[PRE27]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can also scan a range of destination ports from `20` to `22`; note that
    we are using `sr()` for send-receive instead of the `sr1()` send-receive-one-packet
    variant:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以扫描从 `20` 到 `22` 的目标端口范围；注意，我们在这里使用 `sr()` 发送-接收而不是 `sr1()` 发送-接收一个数据包的变体：
- en: '[PRE28]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can also specify a destination network instead of a single host. As you
    can see from the `10.0.0.8/29` block, hosts `10.0.0.9`, `10.0.0.10`, and `10.0.0.14`
    returned with `SA`, which corresponds to the two network devices and the host:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以指定一个目标网络而不是单个主机。正如您从 `10.0.0.8/29` 块中可以看到，主机 `10.0.0.9`、`10.0.0.10` 和 `10.0.0.14`
    返回了 `SA`，这对应于两个网络设备和主机：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Based on what we have learned so far, we can make a simple script for reusability,
    `scapy_tcp_scan_1.py`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止所学的内容，我们可以编写一个简单的脚本以实现可重用性，`scapy_tcp_scan_1.py`：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the script, we start with the suggested importing of `scapy` and the `sys`
    module for taking in arguments. The `tcp_scan()` function is similar to what we
    have seen up to this point, the only difference being that we functionalized it
    so that we can acquire inputs from arguments and then call the `tcp_scan()` function
    in the `main()` function.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本中，我们首先按照建议导入 `scapy` 和 `sys` 模块以接收参数。`tcp_scan()` 函数与我们迄今为止所看到的功能类似，唯一的区别是我们将其功能化，以便可以从参数获取输入，然后在
    `main()` 函数中调用 `tcp_scan()` 函数。
- en: 'Remember that access to the low-level network requires root access; therefore,
    our script needs to be executed as `sudo`. Let’s try the script on port `22` (SSH)
    and port `80` (HTTP):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，访问低级网络需要 root 权限；因此，我们的脚本需要以 `sudo` 方式执行。让我们在端口 `22`（SSH）和端口 `80`（HTTP）上尝试脚本：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This was a relatively lengthy example of the TCP scan script, which demonstrated
    the power of crafting your packet with Scapy. We tested the steps in the interactive
    shell and finalized the usage with a simple script. Now, let’s look at some more
    examples of Scapy’s usage for security testing.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对较长的 TCP 扫描脚本示例，展示了使用 Scapy 构造数据包的强大功能。我们在交互式外壳中测试了这些步骤，并通过一个简单的脚本最终确定了用法。现在，让我们看看
    Scapy 在安全测试中的一些更多用法示例。
- en: The ping collection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Ping 收集
- en: 'Let’s say our network contains a mix of Windows, Unix, and Linux machines,
    with network users adding their machines from the **Bring Your Own Device** (**BYOD**)
    policy; they may or may not support an ICMP ping. We can now construct a file
    with three types of common pings for our network – the ICMP, TCP, and UDP pings
    – in `scapy_ping_collection.py`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的网络包含 Windows、Unix 和 Linux 机器的混合，网络用户根据 **自带设备**（**BYOD**）政策添加他们的机器；他们可能支持或不支持
    ICMP ping。现在，我们可以构建一个包含我们网络三种常见 ping 的文件——ICMP、TCP 和 UDP ping——在 `scapy_ping_collection.py`
    中：
- en: '[PRE32]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can then execute all three types of pings on the network in one script:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一个脚本中执行网络上的所有三种类型的 ping：
- en: '[PRE33]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: At this point, hopefully, you will agree with me that by having the ability
    to construct your custom packet, you can be in charge of the type of operations
    and tests that you would like to run. Along the same thought of constructing our
    custom packets using Scapy, we can construct our packets to perform security tests
    on our network.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，希望你会同意我的观点，通过拥有构建自定义数据包的能力，你可以掌控你想要运行的操作和测试类型。沿着使用 Scapy 构建自定义数据包的思路，我们也可以构建数据包来对我们网络进行安全测试。
- en: Common attacks
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见攻击
- en: In this example, let’s look at how we can construct our packet to conduct some
    classic attacks, such as *Ping of Death* ([https://en.wikipedia.org/wiki/Ping_of_death](https://en.wikipedia.org/wiki/Ping_of_death))
    and *Land Attack* ([https://en.wikipedia.org/wiki/Denial-of-service_attack](https://en.wikipedia.org/wiki/Denial-of-service_attack)).
    These are network penetration tests that you previously had to pay for with similar
    commercial software. With Scapy, you can conduct the test while maintaining full
    control and adding more tests in the future.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，让我们看看我们如何构建我们的数据包来进行一些经典攻击，比如 *死亡之ping* ([https://en.wikipedia.org/wiki/Ping_of_death](https://en.wikipedia.org/wiki/Ping_of_death))
    和 *Land 攻击* ([https://en.wikipedia.org/wiki/Denial-of-service_attack](https://en.wikipedia.org/wiki/Denial-of-service_attack))。这些是以前你必须用类似商业软件付费的网络渗透测试。使用
    Scapy，你可以在保持完全控制的同时进行测试，并在将来添加更多测试。
- en: 'The first attack sends the destination host with a bogus IP header, such as
    an IP header length of two and an IP version of three:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种攻击发送一个带有虚假 IP 头的数据包到目标主机，例如 IP 头长度为两个和 IP 版本为三个：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `ping_of_death_attack` consists of the regular ICMP packet with a payload
    bigger than 65,535 bytes:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ping_of_death_attack` 由一个负载大于 65,535 字节的常规 ICMP 数据包组成：'
- en: '[PRE35]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `land_attack` wants to redirect the client response back to the client
    and exhausts the host’s resources:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`land_attack` 试图将客户端的响应重定向回客户端，并耗尽主机的资源：'
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These are pretty old vulnerabilities or classic attacks that a modern operating
    system is no longer susceptible to. For our Ubuntu 20.04 host, none of the preceding
    attacks will bring it down. However, as more security issues are being discovered,
    Scapy is a great tool for initiating tests against our network and host without
    waiting for the impacted vendor to give you a validation tool. This is especially
    true for the zero-day (published without prior notification) attacks that seem
    more and more common on the internet. Scapy is a tool that can do a lot more than
    what we can cover in this chapter, but luckily, there are lots of open source
    resources on Scapy that we can reference.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相当古老的漏洞或经典攻击，现代操作系统已经不再容易受到它们的影响。对于我们的 Ubuntu 20.04 主机，上述任何攻击都不会使其崩溃。然而，随着更多安全问题的发现，Scapy
    是一个很好的工具，可以在等待受影响的供应商提供验证工具之前，对我们的网络和主机进行测试。这在互联网上越来越常见的零日（未提前通知发布）攻击中尤其如此。Scapy
    是一个可以做很多我们在这个章节中无法涵盖的事情的工具，但幸运的是，Scapy 有许多开源资源可供参考。
- en: Scapy resources
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scapy 资源
- en: We have spent much effort working with Scapy in this chapter. This is partially
    due to the high regard in which I hold the tool. I hope you agree that Scapy is
    a great tool to keep in our toolset as network engineers. The best part about
    Scapy is that it is constantly being developed with an engaged community of users.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这一章中花费了很多努力与 Scapy 合作。这部分的理由是我对工具的高度评价。我希望你同意 Scapy 是我们网络工程师工具集中的一个伟大工具。Scapy
    最好的部分是它始终由一个活跃的用户社区进行开发。
- en: I would highly recommend at least going through the Scapy tutorial at [http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial](http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial),
    as well as any of the documentation that is of interest to you.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议至少浏览一下 Scapy 教程 [http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial](http://scapy.readthedocs.io/en/latest/usage.html#interactive-tutorial)，以及任何对你感兴趣的文档。
- en: Of course, network security is more than just crafting packets and testing vulnerabilities.
    In the next section, we’ll take a look at automating the access list that is commonly
    used to protect sensitive internal resources.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，网络安全不仅仅是构建数据包和测试漏洞。在下一节中，我们将探讨自动化通常用于保护敏感内部资源的访问列表。
- en: Access lists
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问列表
- en: The network access lists are usually the first line of defense against outside
    intrusions and attacks. Generally speaking, routers and switches process packets
    at a much faster rate than servers by utilizing high-speed memory hardware such
    as **ternary content-addressable memory** (**TCAM**). They do not need to see
    the application layer information. Instead, they just examine the layer 3 and
    layer 4 headers and decide whether the packets can be forwarded. Therefore, we
    generally utilize network device access lists as a first step in safeguarding
    our network resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 网络访问列表通常是抵御外部入侵和攻击的第一道防线。一般来说，路由器和交换机通过利用高速内存硬件（如 **三值内容可寻址存储器**（TCAM））来处理数据包的速度比服务器快得多。它们不需要看到应用层信息。相反，它们只需检查第
    3 层和第 4 层的头部信息，并决定是否可以转发数据包。因此，我们通常将网络设备访问列表作为保护网络资源的第一步。
- en: As a rule of thumb, we want to place access lists as close to the source (client)
    as possible. Inherently, we also trust the inside host and distrust clients beyond
    our network boundary. The access list is, therefore, usually placed in the inbound
    direction on the external-facing network interface(s). In our lab scenario, this
    means we will place an inbound access list at Ethernet2/2 on `nyc-cor-r1`, which
    is directly connected to the client host.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验法则，我们希望将访问列表尽可能靠近源（客户端）放置。本质上，我们也信任内部主机，不相信网络边界之外的客户端。因此，访问列表通常放置在外部网络接口的入站方向。在我们的实验室场景中，这意味着我们将在
    `nyc-cor-r1` 的 Ethernet2/2 上放置一个入站访问列表，该接口直接连接到客户端主机。
- en: 'If you are unsure of the direction and placement of the access list, a few
    points might help here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对访问列表的方向和位置不确定，以下几点可能对你有所帮助：
- en: Think of the access list from the perspective of the network device.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络设备的角度思考访问列表。
- en: Simplify the packets in terms of just source and destination IPs and use one
    host as an example.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅从源和目的 IP 地址的角度简化数据包，并使用一个主机作为示例。
- en: In our lab, traffic from our server to the client will have a source IP of `10.0.0.9`,
    with a destination IP of `10.0.0.5`.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的实验室中，从我们的服务器到客户端的流量将具有源 IP 地址 `10.0.0.9`，目的 IP 地址为 `10.0.0.5`。
- en: The traffic from the client to the server will have a source IP of `10.0.0.5`,
    and a destination IP of `10.0.0.9`.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从客户端到服务器的流量将具有源 IP 地址 `10.0.0.5`，目的 IP 地址为 `10.0.0.9`。
- en: 'Obviously, every network is different, and how the access list should be constructed
    depends on the services provided by your server. But, as an inbound border access
    list, you should do the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，每个网络都是不同的，访问列表应该如何构建取决于你的服务器提供的服务。但是，作为一个入站边界访问列表，你应该做以下事情：
- en: Deny RFC 3030 special-use address sources, such as `127.0.0.0/8`.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝 RFC 3030 特殊用途地址源，例如 `127.0.0.0/8`。
- en: Deny RFC 1918 space, such as `10.0.0.0/8`.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝 RFC 1918 空间，例如 `10.0.0.0/8`。
- en: Deny our own space as the source IP; in this case, `10.0.0.4/30`.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以源 IP 地址的形式拒绝我们的空间；在这种情况下，`10.0.0.4/30`。
- en: Permit inbound TCP ports `22` (SSH) and `80` (HTTP) to host `10.0.0.9`.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许来自主机 `10.0.0.9` 的入站 TCP 端口 `22`（SSH）和 `80`（HTTP）。
- en: Deny everything else.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拒绝其他所有内容。
- en: 'Here is a good list of bogon networks to block: [https://ipinfo.io/bogon](https://ipinfo.io/bogon).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很好的 bogon 网络列表，可以阻止：[https://ipinfo.io/bogon](https://ipinfo.io/bogon)。
- en: Knowing what to add is only half of the step. In the next section, let’s take
    a look at how to implement the intended access list with Ansible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 知道要添加什么只是步骤的一半。在下一节中，让我们看看如何使用 Ansible 实现预期的访问列表。
- en: Implementing access lists with Ansible
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Ansible 实现访问列表
- en: 'The easiest way to implement this access list would be to use Ansible. We have
    already looked at Ansible in previous chapters, but it is worth repeating the
    advantages of using Ansible in this scenario:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此访问列表的最简单方法就是使用 Ansible。我们已经在之前的章节中讨论过 Ansible，但在此场景下使用 Ansible 的优势值得重复提及：
- en: '**Easier management**: For a long access list, we can utilize the `include`
    statement to break the access list into more manageable pieces. The smaller pieces
    can then be managed by other teams or service owners.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易于管理**：对于长的访问列表，我们可以使用 `include` 语句将访问列表分解成更易于管理的部分。然后，较小的部分可以由其他团队或服务所有者管理。'
- en: '**Idempotency**: We can schedule the playbook at regular intervals and only
    the necessary changes will be made.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**幂等性**：我们可以定期安排剧本执行，并且只有必要的更改会被做出。'
- en: '**Each task is explicit**: We can separate the construct of the entries as
    well as apply the access list to the proper interface.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个任务都是明确的**：我们可以分离条目的结构，并将访问列表应用到适当的接口上。'
- en: '**Reusability**: In the future, if we add additional external-facing interfaces,
    we just need to add the device to the list of devices for the access list.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：在未来，如果我们添加额外的面向外部的接口，我们只需将设备添加到访问列表的设备列表中。'
- en: '**Extensible**: You will notice that we can use the same playbook for constructing
    the access list and apply it to the right interface. We can start small and expand
    to separate playbooks in the future as needed.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：您会注意到我们可以使用相同的剧本来构建访问列表并将其应用到正确的接口上。我们可以从小处着手，并在需要时将其扩展为单独的剧本。'
- en: 'The `host` file is pretty standard. We will also follow our standards of putting
    the variables in the `host_vars` folder:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 主机文件相当标准。我们还将遵循我们的标准，将变量放在`host_vars`文件夹中：
- en: '[PRE37]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will declare the variables in the playbook:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在剧本中声明变量：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To save space, we will only illustrate denying the RFC 1918 space. Implementing
    the denial of RFC 3030 and our own space will be identical to the steps used for
    the RFC 1918 space. Note that we did not deny `10.0.0.0/8` in our playbook because
    our configuration currently uses the `10.0.0.0` network for addressing. Of course,
    we could perform the single host permit first and deny `10.0.0.0/8` in a later
    entry, but in this example, we just chose to omit it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省空间，我们只展示拒绝RFC 1918空间。实施RFC 3030和我们的空间的拒绝将与RFC 1918空间的步骤相同。请注意，在我们的剧本中我们没有拒绝`10.0.0.0/8`，因为我们的配置目前使用`10.0.0.0`网络进行寻址。当然，我们可以在第一个单主机允许之后，在稍后的条目中拒绝`10.0.0.0/8`，但在这个例子中，我们只是选择省略它：
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we are allowing the established connection sourcing from the server
    inside to be allowed back in. We use the final explicit `deny` `ip` `any` statement
    as a high-sequence number (`1000`) so that we can insert any new entries later
    on.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们允许从服务器内部发起的已建立连接返回。我们使用最终的显式`deny` `ip` `any`语句作为高序列号（`1000`），这样我们就可以在以后插入任何新的条目。
- en: 'We can then apply the access list to the correct interface:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将访问列表应用到正确的接口上：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This may seem like a lot of work for a single access list. For an experienced
    engineer, using Ansible to do this task will take longer than just logging in
    to the device and configuring the access list. However, remember that this playbook
    can be reused many times in the future, so it will save you time in the long run.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来为单个访问列表做的工作很多。对于经验丰富的工程师来说，使用Ansible来完成这项任务可能比仅仅登录到设备并配置访问列表要花更长的时间。然而，请记住，这个剧本可以在未来多次重用，所以从长远来看，这将为您节省时间。
- en: It is my experience that often, for a long access list, a few entries will be
    for one service, a few entries will be for another, and so on. The access lists
    tend to grow organically over time, and it becomes very hard to keep track of
    the origin and purpose of each entry. The fact that we can break them apart makes
    the management of a long access list much simpler.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，对于长访问列表，一些条目可能用于一个服务，一些条目用于另一个服务，依此类推。访问列表往往会随着时间的推移自然增长，并且很难追踪每个条目的来源和目的。我们可以将它们分开的事实使得管理长访问列表变得更加简单。
- en: 'Now, let’s execute the playbook and `verify` on `nx-osv-1`:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`nx-osv-1`上执行剧本并`verify`：
- en: '[PRE42]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We should log in to `nyc-cor-r1` to verify the changes:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该登录到`nyc-cor-r1`来验证更改：
- en: '[PRE43]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We have seen the implementation of IP access lists that check layer 3 information
    on the network. In the next section, let’s look at how to restrict device access
    in a layer 2 environment.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了实现IP访问列表的示例，该访问列表在网络中检查第3层信息。在下一节中，让我们看看如何在第2层环境中限制设备访问。
- en: MAC access lists
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MAC访问列表
- en: In the case where you have a layer 2 environment, or where you are using non-IP
    protocols on Ethernet interfaces, you can still use a MAC address access list
    to allow or deny hosts based on MAC addresses. The steps are similar to the IP
    access list, but the match will be based on MAC addresses. Recall that for MAC
    addresses, or physical addresses, the first six hexadecimal symbols belong to
    an **organizationally unique identifier** (**OUI**). So, we can use the same access
    list matching pattern to deny a certain group of hosts.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在您有第2层环境，或者在使用以太网接口上的非IP协议的情况下，您仍然可以使用基于MAC地址的访问列表来允许或拒绝基于MAC地址的主机。步骤与IP访问列表类似，但匹配将基于MAC地址。回想一下，对于MAC地址或物理地址，前六个十六进制符号属于一个**组织唯一标识符**（**OUI**）。因此，我们可以使用相同的访问列表匹配模式来拒绝一组特定的主机。
- en: We are testing this on IOSv with the `ios_config` module. For older Ansible
    versions, the change will be pushed out every single time the playbook is executed.
    For newer Ansible versions, the control node will check for changes first and
    only make changes when needed.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用`ios_config`模块在IOSv上进行测试。对于较旧的Ansible版本，每次执行剧本时都会推送更改。对于较新的Ansible版本，控制节点会首先检查更改，只有在需要时才会进行更改。
- en: 'The `host` file and the top portion of the playbook are similar to the IP access
    list; the `tasks` portion is where the different modules and arguments are used:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`host`文件和剧本的上半部分与IP访问列表相似；`tasks`部分是使用不同模块和参数的地方：'
- en: '[PRE44]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can execute the playbook and verify its application on `iosv-1`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`iosv-1`上执行剧本并验证其应用：
- en: '[PRE45]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'As we have done before, let’s log in to the device to verify our change:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所做的那样，让我们登录到设备以验证我们的更改：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As more virtual networks become popular, layer 3 information sometimes becomes
    transparent to the underlying virtual links. In these scenarios, the MAC access
    list becomes a good option if you need to restrict access to those links. In this
    section, we have used Ansible to automate the implementation of both layer 2 and
    layer 3 access lists. Now, let’s change gears a bit but stay within the security
    context and look at how to pick up necessary security information from `syslogs`
    using Python.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多虚拟网络的普及，第三层信息有时对底层虚拟链路来说是透明的。在这些情况下，如果需要限制对这些链路的访问，MAC访问列表是一个不错的选择。在本节中，我们已使用Ansible自动化实现第二层和第三层访问列表的实施。现在，让我们稍微改变一下方向，但仍然保持在安全背景下，看看如何使用Python从`syslogs`中提取必要的安全信息。
- en: The Syslog search
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Syslog搜索
- en: There are plenty of documented network security breaches that took place over
    an extended period. In these slow breaches, we quite often saw signs and traces
    in logs indicating that there were suspicious activities. These can be found in
    both server and network device logs. The activities were not detected, not because
    there was a lack of information, but rather because there was **too much** information.
    The critical information we were looking for is usually buried deep in a mountain
    of information that is hard to sort out.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段较长的时间内，发生了许多记录在案的网络安全漏洞。在这些缓慢的漏洞中，我们经常在日志中看到迹象和痕迹，表明存在可疑活动。这些迹象可以在服务器和网络设备日志中找到。活动没有被检测到，并不是因为没有足够的信息，而是因为信息**太多**。我们正在寻找的关键信息通常深埋在难以整理的信息堆中。
- en: Besides Syslog, UFW is another great source of log information for servers.
    It is a frontend to IP tables, which is a server firewall. UFW makes managing
    firewall rules very simple and logs a good amount of information. Refer to the
    *Other Tools* section for more information on UFW.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Syslog之外，UFW也是服务器日志信息的一个很好的来源。它是IP表的前端，而IP表是一个服务器防火墙。UFW使得管理防火墙规则变得非常简单，并记录了大量信息。有关UFW的更多信息，请参阅*其他工具*部分。
- en: In this section, we will try to use Python to search through the Syslog text
    in order to detect the activities that we were looking for. Of course, the exact
    terms that we will search for depend on the device we are using. For example,
    Cisco provides a list of messages to look for in Syslog for any access-list violation
    logging. It is available at [http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html](http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将尝试使用Python搜索Syslog文本，以检测我们正在寻找的活动。当然，我们将搜索的确切术语将取决于我们使用的设备。例如，Cisco提供了一份在Syslog中查找任何访问列表违规日志的消息列表。它可在[http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html](http://www.cisco.com/c/en/us/about/security-center/identify-incidents-via-syslog.html)找到。
- en: For more understanding of access control list logging, go to [http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html](http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于访问控制列表日志的信息，请访问[http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html](http://www.cisco.com/c/en/us/about/security-center/access-control-list-logging.html)。
- en: 'For our exercise, we will use a Nexus switch anonymized Syslog file containing
    about 65,000 lines of log messages. This file is included for you in the book’s
    GitHub repository:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的练习中，我们将使用一个包含大约65,000行日志消息的Nexus交换机匿名Syslog文件。此文件已包含在本书的GitHub存储库中：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We have inserted some Syslog messages from the Cisco documentation ([http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html](https://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html))
    as the log message that we should be looking for:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经从思科文档中插入了一些Syslog消息（[http://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html](https://www.cisco.com/c/en/us/support/docs/switches/nexus-7000-series-switches/118907-configure-nx7k-00.html)）作为我们应该寻找的日志消息：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We will be using simple examples with regular expressions. If you are already
    familiar with the regular expression module in Python, feel free to skip the rest
    of the section.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简单的例子和正则表达式。如果你已经熟悉Python中的正则表达式模块，可以自由跳过本节的其余部分。
- en: Searching with the regular expression module
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用正则表达式模块进行搜索
- en: 'For our first search, we will simply use the regular expression module to search
    for the terms we are looking for. We will use a simple loop to do the following:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一次搜索，我们将简单地使用正则表达式模块来搜索我们正在寻找的术语。我们将使用一个简单的循环来完成以下操作：
- en: '[PRE49]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It took about four-hundredths of a second to search through the log file:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索日志文件大约需要四百分之一秒：
- en: '[PRE50]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'It is recommended to compile the search term for a more efficient search. It
    will not impact us much since the script is already pretty fast. Python’s interpretative
    nature might make it slower. However, it will make a difference when we search
    through a larger text body, so let’s make the change:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 建议编译搜索词以实现更高效的搜索。由于脚本已经相当快，这不会对我们影响很大。Python的解释性可能使其变慢。然而，当我们搜索更大的文本体时，这会有所不同，所以让我们做出改变：
- en: '[PRE51]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The timing result is actually slower:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的计时结果实际上更慢：
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s expand the example a bit. Assuming we have several files and multiple
    terms to search through, we will copy the original file to a new file:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微扩展一下这个例子。假设我们有几个文件和多个术语要搜索，我们将复制原始文件到一个新文件中：
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will also include searching for the `PAM: Authentication failure` term.
    We will add another loop to search both files:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还将包括搜索`PAM: Authentication failure`这个术语。我们将添加另一个循环来搜索两个文件：'
- en: '[PRE54]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can now see the difference in performance by expanding our search terms
    and the number of messages:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展我们的搜索词和消息数量，我们现在可以看到性能的差异：
- en: '[PRE55]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Of course, when it comes to performance tuning, it is a never-ending, impossible
    race to zero, and the performance sometimes depends on the hardware you are using.
    But the important point is to regularly perform audits of your log files using
    Python so that you can catch the early signals of any potential breach.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，当谈到性能调整时，这是一个永无止境、不可能达到零点的竞赛，性能有时取决于你使用的硬件。但重要的是要定期使用Python对你的日志文件进行审计，这样你就可以捕捉到任何潜在违规的早期信号。
- en: We have looked at some of the key ways in which we can enhance our network security
    in Python, but there are several other powerful tools that can make this process
    easier and more effective. In the final section of this chapter, we will explore
    some of these tools.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了在Python中增强我们的网络安全的一些关键方法，但还有一些其他强大的工具可以使这个过程更容易、更有效。在本章的最后部分，我们将探讨一些这些工具。
- en: Other tools
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: There are other network security tools that we can use and automate with Python.
    Let’s take a look at two of the most commonly used ones.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python自动化并使用其他网络安全工具。让我们看看两个最常用的工具。
- en: Private VLANs
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有VLAN
- en: '**Virtual local area networks** (**VLANs**) have been around for a long time.
    They are essentially broadcast domains where all hosts can be connected to a single
    switch but are partitioned out to different domains, so we can separate the hosts
    according to which hosts can see others via broadcasts. Let’s consider a map based
    on IP subnets. For example, in an enterprise building, I would likely see one
    IP subnet per physical floor: `192.168.1.0/24` for the first floor, `192.168.2.0/24`
    for the second floor, and so on. In this pattern, we use a `/24` block for each
    floor. This gives a clear delineation of my physical network as well as my logical
    network. A host wanting to communicate beyond its subnet will need to traverse
    through its layer 3 gateway, where I can use an access list to enforce security.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟局域网（VLANs**）已经存在很长时间了。它们本质上是一组广播域，其中所有主机都可以连接到单个交换机，但被分割到不同的域中，因此我们可以根据哪些主机可以通过广播看到其他主机来分离主机。让我们考虑一个基于IP子网的映射。例如，在一个企业建筑中，我可能会在每个物理楼层看到一个IP子网：一楼为`192.168.1.0/24`，二楼为`192.168.2.0/24`，依此类推。在这个模式中，我们为每个楼层使用一个`/24`块。这为我的物理网络以及我的逻辑网络提供了一个清晰的界定。想要在其子网之外通信的主机需要通过其层3网关进行穿越，在那里我可以使用访问列表来强制执行安全性。'
- en: What happens when different departments reside on the same floor? Perhaps the
    finance and sales teams are on the second floor, and I would not want the sales
    team’s hosts in the same broadcast domain as the finance team. I can break the
    subnet down further, but that might become tedious and break the standard subnet
    scheme previously set up. This is where a private VLAN can help.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当不同的部门位于同一楼层时会发生什么？也许财务和销售团队在二楼，我不希望销售团队的主持人与财务团队处于同一个广播域。我可以进一步细分子网，但这可能会变得繁琐，并破坏之前设置的子网标准方案。这就是私有VLAN能发挥作用的地方。
- en: 'The private VLAN essentially breaks up the existing VLAN into sub-VLANs. There
    are three categories within a private VLAN:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 私有VLAN本质上将现有的VLAN分割成子VLAN。私有VLAN中有三个类别：
- en: '**The Promiscuous (P) port**: This port is allowed to send and receive layer
    2 frames from any other port on the VLAN; this usually belongs to the port connecting
    to the layer 3 routers.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混杂（P）端口**：此端口允许从VLAN上的任何其他端口发送和接收层2帧；这通常属于连接到层3路由器的端口。'
- en: '**The Isolated (I) port**: This port is only allowed to communicate with P
    ports, and it is typically connected to hosts when you do not want it to communicate
    with other hosts in the same VLAN.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离（I）端口**：此端口仅允许与P端口通信，通常在您不希望它与同一VLAN中的其他主机通信时连接到主机。'
- en: '**The Community (C) port**: This port is allowed to communicate with other
    C ports in the same community and with P ports.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**社区（C）端口**：此端口允许与同一社区中的其他C端口以及P端口通信。'
- en: We can again use Ansible or any other Python scripts introduced so far to accomplish
    this task. By now, we should have enough practice and confidence to implement
    this feature via automation, so I will not repeat the steps here. Being aware
    of the private VLAN feature will come in handy when you need to isolate ports
    even further in a layer 2 VLAN.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次使用Ansible或之前介绍过的任何其他Python脚本来完成此任务。到目前为止，我们应该已经积累了足够的实践和信心，可以通过自动化来实现此功能，因此这里不再重复步骤。当您需要进一步隔离层2
    VLAN中的端口时，了解私有VLAN功能将非常有用。
- en: UFW with Python
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UFW与Python
- en: 'We briefly mentioned UFW as the front end for IP tables on Ubuntu hosts. Here
    is a quick overview:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到了UFW作为Ubuntu主机上IP表的前端。以下是一个快速概述：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'As you can see, the advantage of UFW is that it provides a simple interface
    to construct otherwise complicated IP table rules. There are several Python-related
    tools we can use with UFW to make things even simpler:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，UFW的优势在于它提供了一个简单的界面来构建其他情况下复杂的IP表规则。我们可以使用与UFW一起使用的几个Python相关工具来使事情更加简单：
- en: We can use the Ansible UFW module to streamline our operations. More information
    is available at [https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html](https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用Ansible UFW模块来简化我们的操作。更多信息请参阅[https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html](https://docs.ansible.com/ansible/latest/collections/community/general/ufw_module.html)。
- en: There are Python wrapper modules around UFW as an API (visit [https://gitlab.com/dhj/easyufw](https://gitlab.com/dhj/easyufw)).
    This can make integration easier if you need to dynamically modify UFW rules based
    on certain events.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 UFW 旁边有 Python 包装模块作为 API（访问 [https://gitlab.com/dhj/easyufw](https://gitlab.com/dhj/easyufw)）。如果你需要根据某些事件动态修改
    UFW 规则，这将使集成更容易。
- en: UFW itself is written in Python. Therefore, you can use existing Python knowledge
    if we need to extend the current command sets. More information is available at
    [https://launchpad.net/ufw](https://launchpad.net/ufw).
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UFW 本身是用 Python 编写的。因此，如果我们需要扩展当前的命令集，你可以使用现有的 Python 知识。更多信息请参阅 [https://launchpad.net/ufw](https://launchpad.net/ufw)。
- en: UFW proves to be a good tool to safeguard your network server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: UFW 证明是一个很好的工具，可以保护你的网络服务器。
- en: Further reading
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Python is a very common language used in many security-related fields. A few
    of the books I would recommend are listed as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一个非常常用的语言，在许多与安全相关的领域中使用。以下是我推荐的一些书籍：
- en: '**Violent Python**: A cookbook for hackers, forensic analysts, penetration
    testers, and security engineers, by T.J. O’Connor (ISBN-10: 1597499579)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《暴力 Python》**：黑客、法医分析师、渗透测试人员和安全工程师的食谱，作者 T.J. O’Connor（ISBN-10: 1597499579）'
- en: '**Black Hat Python**: Python programming for hackers and pen-testers, by Justin
    Seitz (ISBN-10: 1593275900)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**《黑帽 Python》**：黑客和渗透测试人员的 Python 编程，作者 Justin Seitz（ISBN-10: 1593275900）'
- en: I have personally used Python extensively in my research work on **Distributed
    Denial of Service** (**DDoS**) at A10 Networks. If you are interested in learning
    more, the guide can be downloaded for free at [https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/](https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 A10 Networks 的 **分布式拒绝服务**（**DDoS**）研究工作中广泛使用了 Python。如果你有兴趣了解更多，指南可以免费下载，请访问
    [https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/](https://www.a10networks.com/resources/ebooks/distributed-denial-service-ddos/)。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at network security with Python. We used the Cisco
    CML tool to set up our lab with hosts and network devices, consisting of NX-OSv
    and IOSv types. We took a tour around Scapy, which allows us to construct packets
    from the ground up.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 Python 进行网络安全。我们使用 Cisco CML 工具设置实验室，包括主机和网络设备，包括 NX-OSv 和 IOSv
    类型。我们参观了 Scapy，它允许我们从底层构建数据包。
- en: Scapy can be used in interactive mode for quick testing. Once testing is completed
    in interactive mode, we can put the steps into a file for more scalable testing.
    It can be used to perform various network penetration testing for known vulnerabilities.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 可以用于交互模式进行快速测试。一旦在交互模式下完成测试，我们可以将这些步骤放入文件中进行更可扩展的测试。它可以用于执行针对已知漏洞的各种网络渗透测试。
- en: We also looked at how we can use both an IP access list and a MAC access list
    to protect our network. They are usually the first line of defense in our network
    protection. Using Ansible, we can deploy access lists consistently and quickly
    to multiple devices.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如何使用 IP 访问列表和 MAC 访问列表来保护我们的网络。它们通常是我们的网络保护中的第一道防线。使用 Ansible，我们可以快速且一致地将访问列表部署到多个设备。
- en: Syslog and other log files contain useful information that we should regularly
    comb through to detect any early signs of a breach. Using Python regular expressions,
    we can systematically search for known log entries that can point us to security
    events that require our attention. Besides the tools we have discussed, private
    VLAN and UFW are among some other useful tools that we can use for more security
    protection.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Syslog 和其他日志文件包含有用的信息，我们应该定期检查以检测任何早期入侵迹象。使用 Python 正则表达式，我们可以系统地搜索指向需要我们注意的安全事件的已知日志条目。除了我们讨论的工具之外，私有
    VLAN 和 UFW 是其他一些我们可以用于更多安全保护的实用工具。
- en: In *Chapter 7*, *Network Monitoring with Python – Part 1*, we will look at how
    to use Python for network monitoring. Monitoring allows us to know what is happening
    in our network, as well as the state of the network.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第 7 章*，*使用 Python 进行网络监控（第一部分*），我们将探讨如何使用 Python 进行网络监控。监控使我们能够了解网络中正在发生的事情，以及网络的状态。
- en: Join our book community
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的书籍社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2903617220506617062.png)'
