- en: Chapter 10. Techniques for Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。调试技术
- en: Debugging a program can often be as hard, or sometimes, even more difficult
    than writing it. Quite often, programmers seem to spend an awful amount of time
    hunting for that elusive bug, the reason for which may be staring them in the
    face, yet not revealing itself.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 调试程序通常会像编写程序一样困难，有时甚至更困难。很多时候，程序员似乎会花费大量的时间寻找那个难以捉摸的错误，其原因可能正盯着他们，却不显露出来。
- en: Many developers, even the good ones, find troubleshooting a difficult art. Most
    often, programmers resort to complicated debugging techniques when simple approaches
    such as properly placed print statements and strategically commented code would
    do the trick.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员，甚至是优秀的开发人员，发现故障排除是一门困难的艺术。大多数情况下，程序员在简单的方法，如适当放置的打印语句和策略性注释的代码等方法无法解决问题时，就会求助于复杂的调试技术。
- en: Python comes with its own set of problems when it comes to debugging code. Being
    a dynamically typed language, type-related exceptions, which happen due to the
    programmer assuming a type to be something (when it's something else), are pretty
    common in Python. Name errors and attribute errors fall in a similar category
    too.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python在调试代码时会带来自己的一套问题。作为一种动态类型的语言，由于程序员假设类型是某种类型（当它实际上是其他类型），类型相关的异常在Python中是非常常见的。名称错误和属性错误也属于类似的范畴。
- en: In this chapter, we will exclusively focus on this lesser discussed aspect of
    software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于软件的这一少讨论的方面。
- en: 'Here is a topic wise listing of what we are going to encounter in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个按主题分类的列表，我们将在本章中遇到的内容：
- en: 'Maximum subarray problem:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大子数组问题：
- en: The power of "print"
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “打印”的力量
- en: Analysis and rewrite
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析和重写
- en: Timing and optimizing the code
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计时和优化代码
- en: 'Simple debugging tricks and techniques:'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的调试技巧和技术：
- en: Word searcher program
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词搜索程序
- en: Word searcher program—debugging step 1
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词搜索程序-调试步骤1
- en: Word searcher program—debugging step 2
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词搜索程序-调试步骤2
- en: Word searcher program—final code
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单词搜索程序-最终代码
- en: Skipping blocks of code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳过代码块
- en: Stopping execution
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止执行
- en: External dependencies—using wrappers
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部依赖-使用包装器
- en: Replacing functions with their return value/data (Mocking)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用返回值/数据替换函数（模拟）
- en: Saving to/loading data from files as cache
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到/从文件加载为缓存
- en: Saving to/loading data from memory as cache
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据保存到/从内存加载为缓存
- en: Returning random/mock data
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回随机/模拟数据
- en: Generating random patient data
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 生成随机患者数据
- en: 'Logging as a debugging technique:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录作为调试技术：
- en: Simple application logging
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的应用程序日志记录
- en: Advanced logging—logger objects
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级日志记录-记录器对象
- en: Advanced logging—custom formatting and loggers
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 高级日志记录-自定义格式和记录器
- en: Advanced logging—writing to syslog
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 高级日志记录-写入syslog
- en: 'Debugging tools—using debuggers:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试工具-使用调试器：
- en: A debugging session with pdb
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与pdb一起进行调试会话
- en: Pdb—similar tools
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pdb-类似工具
- en: iPdb
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: iPdb
- en: Pdb++
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Pdb++
- en: 'Advanced debugging—tracing:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级调试-跟踪：
- en: The trace module
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪模块
- en: The lptrace program
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: lptrace程序
- en: System call tracing using strace
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用strace进行系统调用跟踪
- en: Okay, so let's debug it!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们调试一下！
- en: Maximum subarray problem
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最大子数组问题
- en: For starters, let us look at an interesting problem. In this problem, the goal
    is to find the maximum contiguous subarray of an array (sequence) of integers
    having mixed negative and positive numbers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一个有趣的问题。在这个问题中，目标是找到一个混合负数和正数的整数数组（序列）的最大连续子数组。
- en: 'For example, say we have the following array:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有以下数组：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is pretty obvious with a quick scan that the maximum sum is for the subarray
    `[20, -10, 30, 15]`, giving a sum of `55`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过快速扫描很明显，最大和的子数组是`[20, -10, 30, 15]`，得到和`55`。
- en: 'Let us say, as a first cut, you write this piece of code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们说，作为第一步，你写下了这段代码：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now let''s try it out:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们试一下：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This output seems clearly wrong, as any manual addition of any subarray in the
    array doesn't seem to yield a number more than 55\. We need to debug the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出看起来显然是错误的，因为在数组中手动添加任何子数组似乎都不会产生大于55的数字。我们需要调试代码。
- en: The power of "print"
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: “打印”的力量
- en: 'In order to debug the preceding example, a simple, strategically-placed **"print"**
    statement does the trick. Let''s print out the sub-sequences in the inner `for`
    loop:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试前面的例子，一个简单而策略性放置的**“打印”**语句就可以解决问题。让我们在内部的`for`循环中打印出子序列：
- en: 'The function is modified as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 函数修改如下：
- en: 'max_subarray: v1'
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: max_subarray：v1
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now the code executes and prints this output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码执行并打印出这个输出：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The problem is clear now by looking at the output of the print statements.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看打印语句的输出，问题现在变得清晰了。
- en: There is a subarray `[20, 30, 15]` (highlighted in bold in the preceding output),
    which produces the sum *65*. However, this is *not a valid subarray*, as the elements
    are not contiguous in the original array.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个子数组`[20, 30, 15]`（在前面的输出中用粗体标出），产生和*65*。然而，这不是一个有效的子数组，因为元素在原始数组中不是连续的。
- en: Clearly, the program is wrong and needs a fix.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，程序是错误的，需要修复。
- en: Analysis and rewrite
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析和重写
- en: A quick analysis tells us that the use of `itertools.combinations` is the culprit
    here. We used it as a way to quickly generate all the subarrays of different lengths
    from the array, but using combinations *does not* respect the order of items,
    and generates *all* combinations producing subarrays that are not contiguous.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 快速分析告诉我们，使用`itertools.combinations`在这里是罪魁祸首。我们使用它作为一种快速从数组中生成所有不同长度的子数组的方法，但是使用组合*不*尊重项目的顺序，并生成*所有*组合，产生不连续的子数组。
- en: 'Clearly, we need to rewrite this. Here is a first attempt at the rewrite:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要重写这个。这是重写的第一次尝试：
- en: 'max_subarray: v2'
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: max_subarray：v2
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now the output is as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在输出如下：
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The answer is not correct again, as it gives the suboptimal answer *40*, not
    the correct one, which is, *55*. Again, the print statement comes to the rescue,
    as it tells us clearly that the main array itself is not being considered—we have
    an *off-by-one* bug.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 答案再次不正确，因为它给出了次优解*40*，而不是正确的解答*55*。再次，打印语句挺身而出，因为它清楚地告诉我们，主数组本身没有被考虑进去-我们有一个*偏移一个*的错误。
- en: Note
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An off-by-one or one-off error occurs in programming when an array index used
    to iterate over a sequence (array) is off either by *one less* or *one more* than
    the correct value. This is often found in languages where the index for sequences
    start from zero such as C/C++, Java, or Python.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，当用于迭代序列（数组）的数组索引比正确值要少一个或多一个时，就会出现一个偏差或一次性错误。这经常出现在序列的索引从零开始的语言中，比如C/C++、Java或Python。
- en: 'In this case, the *off-by-one* error is in this line:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*off-by-one*错误在这一行中：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The correct code should, instead, be as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的代码应该是这样的：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'With this fix, our code produces the output as expected:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个修复，我们的代码产生了预期的输出：
- en: 'max_subarray: v2'
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'max_subarray: v2'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Let us assume at this point that you consider the code to be complete.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这一点上假设您认为代码已经完成。
- en: You pass the code on to a reviewer, and they mention that your code, though
    called `max_subarray`, actually forgets to return the subarray itself, instead
    returning only the sum. There is also the feedback that you don't need to maintain
    an array of sums.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 您将代码传递给审阅人员，他们提到您的代码，尽管被称为`max_subarray`，但实际上忘记了返回子数组本身，而只返回了总和。还有反馈说您不需要维护一个总和数组。
- en: 'You combine this feedback and produce a version 3.0 of the code, which fixes
    both the issues:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您结合这些反馈，生成了修复了这两个问题的代码版本3.0：
- en: 'max_subarray: v3'
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 'max_subarray: v3'
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that we removed the print statement in this last version, as the logic
    was already correct, and so, there was no need of debugging.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在最后一个版本中删除了打印语句，因为逻辑已经正确，所以不需要调试。
- en: All good.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一切正常。
- en: Timing and optimizing the code
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时和优化代码
- en: If you analyze the code a bit, you'll find that the code performs two passes
    through the full sequence, one outer and one inner. So if the sequence contains
    *n* items, the code performs *n*n* passes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您稍微分析一下代码，您会发现代码对整个序列进行了两次遍历，一次外部遍历，一次内部遍历。因此，如果序列包含*n*个项目，代码将执行*n*n*次遍历。
- en: We know from [Chapter 4](part0031.xhtml#aid-TI1E1 "Chapter 4. Good Performance
    is Rewarding!"), *Good Performance is Rewarding!*, on performance that such a
    piece of code performs at the order of *O(n2)*. We can measure the real time spent
    on the code by using a simple `context-manager` using the `with` operator.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[第4章](part0031.xhtml#aid-TI1E1 "第4章。良好的性能是值得的！")中知道，*良好的性能是值得的！*，关于性能，这样一段代码的性能是*O(n2)*。我们可以使用简单的`上下文管理器`和`with`运算符来测量代码的实际运行时间。
- en: 'Our context manager looks as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的上下文管理器如下：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let us modify the code to create an array of random numbers of different sizes
    to measure the time taken. We will write a function for this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改代码，创建一个不同大小的随机数数组来测量所花费的时间。我们将为此编写一个函数：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let us time our logic for various sizes of arrays, beginning with 100:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试各种大小的数组的逻辑，从100开始：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For an array of 1000, the code will be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个大小为1000的数组，代码将如下：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: So this takes about 3.3 seconds.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 所以大约需要3.3秒。
- en: It can be shown that with an input size of 10000, the code will take around
    2 to 3 hours to run.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 可以证明，对于输入大小为10000，代码运行大约需要2到3小时。
- en: 'Is there a way to optimize the code? Yes, there is an *O(n)* version of the
    same code, which looks like this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种方法可以优化代码？是的，有一个*O(n)*版本的相同代码，看起来像这样：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With this version, the time taken is much better:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个版本，所花费的时间要好得多：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For an array of 1000, the time taken is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个大小为1000的数组，所花费的时间如下：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For an array of 10000, the time is around 44 milliseconds:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个大小为10000的数组，时间大约为44毫秒：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Simple debugging tricks and techniques
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简单的调试技巧和技术
- en: We saw the power of the simple `print` statement in the previous example. In
    a similar way, other simple techniques can be used to debug programs without requiring
    to resort to a debugger.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的示例中看到了简单的`print`语句的威力。类似的其他简单技术也可以用来调试程序，而无需使用调试器。
- en: 'Debugging can be thought of as a step-wise process of exclusion until the programmer
    arrives at the truth—the cause of the bug. It essentially involves the following
    steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 调试可以被认为是一个逐步排除的过程，直到程序员找到真相——错误的原因。它基本上涉及以下步骤：
- en: Analyze the code and come up with a set of probable assumptions (causes) that
    may be the source of the bug.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析代码，并得出一组可能的假设（原因），可能是错误的来源。
- en: Test out each of the assumptions one by one by using appropriate debugging techniques.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逐个测试每个假设，使用适当的调试技术。
- en: At every step of the test, you either arrive at the source of the bug—as the
    test succeeds telling you the problem was with the specific cause you were testing
    for; or the test fails and you move on to test the next assumption.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试的每一步，您要么找到了错误的原因——因为测试成功告诉您问题出在您正在测试的特定原因；要么测试失败，您继续测试下一个假设。
- en: You repeat the last step until you either arrive at the cause or you discard
    the current set of probable assumptions. Then you restart the entire cycle until
    you (hopefully) find the cause.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复上一步，直到找到原因或放弃当前一组可能的假设。然后重新开始整个循环，直到（希望）找到原因。
- en: Word searcher program
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词搜索程序
- en: In this section, we will look at some simple debugging techniques one by one
    using examples. We will start with the example of a word searcher program that
    looks for lines containing a specific word in a list of files—and appends and
    returns the lines in a list.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将逐个使用示例来看一些简单的调试技巧。我们将从一个单词搜索程序的示例开始，该程序在文件列表中查找包含特定单词的行，并将这些行附加并返回到一个列表中。
- en: 'Here is the listing of the code for the word searcher program:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是单词搜索程序的代码清单：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You may have noticed a subtle bug in the preceding code—it appends to the wrong
    list. It reads from the list "lines", and appends to the same list, which will
    cause the list to grow forever; the program will go into an infinite loop when
    it encounters even a single line containing the given word.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到前面的代码中有一个细微的错误——它附加到了错误的列表上。它从列表“lines”中读取，并附加到同一个列表，这将导致列表无限增长；当遇到包含给定单词的一行时，程序将进入无限循环。
- en: 'Let''s run the program on the current directory:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在当前目录上运行程序：
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: On any day, you may find this bug easily. On a bad day you may be stuck on this
    for a while, not noticing that the same list being read from is being appended
    to.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何一天，你可能会很容易地找到这个bug。在糟糕的一天，你可能会卡在这里一段时间，没有注意到正在读取的列表是被追加的。
- en: 'Here are a few things that you can do:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是你可以做的一些事情：
- en: As the code is hanging and there are two loops, find out the loop that causes
    the problem. To do this, either put a print statement between the two loops, or
    put a `sys.exit` function, which will cause the interpreter to exit at that point.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于代码挂起并且有两个循环，找出导致问题的循环。为了做到这一点，可以在两个循环之间放置一个打印语句，或者放置一个`sys.exit`函数，这将导致解释器在那一点退出。
- en: A print statement can be missed by a developer, especially if the code has many
    other print statements, but a `sys.exit` can never be missed of course.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员可能会忽略打印语句，特别是如果代码中有很多其他打印语句，但`sys.exit`当然不会被忽略。
- en: Word searcher program—debugging step 1
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词搜索程序-调试步骤1
- en: 'The code is rewritten as follows to insert a specific `sys.exit(…)` call between
    the two loops:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重写如下，插入了一个特定的`sys.exit(…)`调用在两个循环之间：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When trying it out a second time, we get this output:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次尝试时，我们得到了这个输出：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now it's pretty clear that the problem is not in the first loop. You can now
    proceed to debug the second loop (we are assuming that you are totally blind to
    the wrong variable usage, so you are figuring out the issue the hard way, by debugging).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在很明显问题不在第一个循环中。现在你可以继续调试第二个循环（我们假设你完全不知道错误的变量使用方式，所以你正在通过调试的方式艰难地找出问题）。
- en: Word searcher program—debugging step 2
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词搜索程序-调试步骤2
- en: 'Whenever you suspect a block of code inside a loop to be causing a bug, there
    are a few tricks to debug this, and confirm your suspicion. These include the
    following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你怀疑循环内的一段代码可能导致bug时，有一些调试技巧可以帮助你确认这一点。这些包括以下内容：
- en: Put a strategic continue just preceding the block of code. If the problem disappears,
    then you've confirmed that the specific block or any next block that is the issue.
    You can continue to move down your `continue` statement until you identify the
    specific block of code that is causing the issue.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码块之前放置一个策略性的`continue`。如果问题消失了，那么你已经确认了特定的代码块或下一个代码块是问题所在。你可以继续移动你的`continue`语句，直到找到引起问题的具体代码块。
- en: Make Python skip the code block by prefixing it with an `if 0:`. This is more
    useful if the block is a line of code or a few lines of code.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让Python跳过代码块，通过在其前面加上`if 0:`。如果代码块是一行代码或几行代码，这将更有用。
- en: If there is a lot of code inside a loop, and the loop executes many times, print
    statements may not help you much, as a ton of data will be printed, and it would
    be difficult to sift and scan through it and find out where the problem is.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果循环内有大量的代码，并且循环执行多次，打印语句可能不会对你有太大帮助，因为会打印出大量的数据，很难筛选和扫描找出问题所在。
- en: 'In this case, we will use the first trick to figure out the issue. Here is
    the modified code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将使用第一个技巧来找出问题。以下是修改后的代码：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now the code executes, making it pretty clear that the problem is in the processing
    step. Hopefully, from there it is just one step to figure out the bug, as the
    programmer has finally got his eye on the line causing the issue by way of the
    process of debugging.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在代码执行了，很明显问题出在处理步骤中。希望从那里只需一步就能找出bug，因为程序员终于通过调试过程找到了引起问题的代码行。
- en: Word searcher program—final code
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单词搜索程序-最终代码
- en: We spent some time figuring out issues in the program by a couple of debugging
    steps documented in the previous sections. With this our hypothetical programmer
    was able to find the issue in the code and solve it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们花了一些时间通过前几节中记录的一些调试步骤来解决程序中的问题。通过这些步骤，我们假设的程序员能够找到代码中的问题并解决它。
- en: 'Here is the final code with the bug fixed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是修复了bug的最终代码：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Let us summarize the simple debugging tricks that we've learned so far in this
    section, and also look at a few related tricks and techniques.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们在本节中学到的简单调试技巧，并看一些相关的技巧和方法。
- en: Skipping blocks of code
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过代码块
- en: A programmer can skip code blocks that they suspect of causing a bug during
    debugging. If the block is inside a loop, this can be done by skipping execution
    with a `continue` statement. We've seen an example of this already.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试期间，程序员可以跳过他们怀疑会导致bug的代码块。如果代码块在循环内，可以通过`continue`语句跳过执行。我们已经看到了一个例子。
- en: 'If the block is outside of a loop, this can be done by using an `if 0`, and
    moving the suspect code to the dependent block, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码块在循环之外，可以通过使用`if 0`，并将怀疑的代码移动到依赖块中来完成：
- en: '[PRE27]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the bug disappears after this, then you're sure that the problem lies in
    the suspected blocks of code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果bug在此之后消失了，那么你可以确定问题出在怀疑的代码块中。
- en: This trick has its own deficiency, in that it requires indenting large blocks
    of code to the right, which once the debugging is finished, should be indented
    back. Hence it is not advised for anything more than 5-6 lines of code.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个技巧有其自身的不足之处，因为它需要将大块的代码缩进到右侧，一旦调试完成，就应该将其重新缩进。因此，不建议用于超过5-6行代码的任何情况。
- en: Stopping execution
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 停止执行
- en: If you're in the middle of a hectic programming session, and you're trying to
    figure out an elusive bug, having already tried print statements, using the debugger,
    and other approaches, a rather drastic, but often fantastically useful, approach
    is to stop the execution just before or at the suspected code path using a function,
    `sys.exit` expression.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在进行紧张的编程工作，并且正在尝试找出一个难以捉摸的bug，已经尝试了打印语句、使用调试器和其他方法，一个相当激进但通常非常有用的方法是在怀疑的代码路径之前或之后停止执行，使用函数`sys.exit`表达式。
- en: 'A `sys.exit(<strategic message>)` stops the program dead in its tracks, so
    this *can''t be missed* by the programmer. This is often very useful in the following
    scenarios:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`sys.exit(<strategic message>)`会使程序立即停止，因此程序员*不会错过*它。在以下情况下，这通常非常有用：'
- en: A complex piece of code has an elusive bug depending upon specific values or
    ranges of input, which causes an exception that is caught and ignored, but later
    causes an issue in the program.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一段复杂的代码存在一个难以捉摸的bug，取决于特定的输入值或范围，导致一个被捕获并忽略的异常，但后来导致程序出现问题。
- en: In this case, checking for the specific value or range, and then exiting the
    code using the right message in the exception handler via `sys.exit` will allow
    you to pinpoint the problem. The programmer can then decide to fix the issue by
    correcting the input or variable processing code.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种情况下，检查特定值或范围，然后通过`sys.exit`在异常处理程序中使用正确的消息退出代码，将允许你找出问题的根源。程序员然后可以决定通过纠正输入或变量处理代码来解决问题。
- en: When writing concurrent programs, wrong usage of resource locking or other issues
    can make it difficult to track bugs like deadlocks, race conditions, and others.
    Since debugging multithreaded or multiple process programs via the debugger is
    very difficult, a simple technique is to put a `sys.exit` in the suspect function
    after implementing the correct exception-handling code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写并发程序时，资源锁定的错误使用或其他问题可能会使跟踪死锁、竞争条件等bug变得困难。由于通过调试器调试多线程或多进程程序非常困难，一个简单的技巧是在怀疑的函数中放置`sys.exit`，在实现正确的异常处理代码后。
- en: When your code has a serious memory leak or an infinite loop, then it becomes
    difficult to debug after a while, and you're not able to pinpoint the problem
    otherwise. Moving a `sys.exit(<message>)` line from one line of code to the next
    until you identify the problem can be used as a last resort.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你的代码存在严重的内存泄漏或无限循环时，随着时间的推移，调试变得困难，你无法找出问题的根源。将`sys.exit(<message>)`这一行代码从一行移到下一行，直到确定问题，可以作为最后的手段。
- en: External dependencies—using wrappers
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部依赖-使用包装器
- en: In cases where you suspect the problem is not inside your function, but in a
    function that you are calling from your code, this approach can be used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在你怀疑问题不在你的函数内部，而是在你从代码中调用的函数中时，可以使用这种方法。
- en: Since the function is outside of your control, you can try and replace it with
    a wrapper function in a module where you have control.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该函数不在你的控制范围之内，你可以尝试用你可以控制的模块中的包装器函数替换它。
- en: 'For example, the following is generic code for processing serial JSON data.
    Let us assume that the programmer finds a bug with processing of certain data
    (maybe having a certain key-value pair), and suspects the external API to be the
    source of the bug. The bug may be that the API times out, returns a corrupt response,
    or in the worst case, causes a crash:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是用于处理串行JSON数据的通用代码。假设程序员发现处理某些数据的bug（可能具有某个键值对），并怀疑外部API是bug的来源。bug可能是API超时、返回损坏的响应，或在最坏的情况下导致崩溃：
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'One way to verify this is to *dummy* or *fake* the API for the specific ranges
    or values of the data. In this case, it can be done by creating a wrapper function
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 验证的一种方法是对特定范围或数据的API进行*虚拟*，在这种情况下，可以通过创建以下包装器函数来实现：
- en: '[PRE29]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If your suspicion is indeed correct, this will cause the problem to disappear.
    You can then use this as a test code, and communicate with the stakeholders of
    the external API to get the problem fixed, or write code to make sure that the
    problem key-value pair is skipped in data sent to the API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的怀疑是正确的，这将导致问题消失。然后你可以将其用作测试代码，并与外部API的利益相关者沟通，以解决问题，或编写代码确保在发送到API的数据中跳过问题的键值对。
- en: Replacing functions with their return value/data (Mocking)
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用返回值/数据替换函数（模拟）
- en: In modern web application programming, you are never too far away from a blocking
    I/O call in your program. This can be a simple URL request, a slightly involved
    external API request, or maybe a costly database query and such calls can be the
    sources of bugs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Web应用程序编程中，你的程序中从来不会离开阻塞I/O调用太远。这可能是一个简单的URL请求，稍微复杂的外部API请求，或者可能是一个昂贵的数据库查询，这些调用可能是bug的来源。
- en: 'You may find either of the following situations:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到以下情况之一：
- en: The return data from such a call could be the cause of an issue
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这样的调用返回数据可能是问题的原因
- en: The call itself is the cause of an issue, such as I/O or network errors, timeouts,
    or resource contentions
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用本身是问题的原因，比如I/O或网络错误、超时或资源争用
- en: 'When you encounter problems with costly I/O, replicating them can often be
    a problem. This is because of the following reasons:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你遇到昂贵I/O的问题时，复制它们通常会成为一个问题。这是因为以下原因：
- en: The I/O calls take time, so debugging this costs you a lot of wasted time, not
    allowing you to focus on the real issue
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: I/O调用需要时间，因此调试会浪费大量时间，无法专注于真正的问题。
- en: Subsequent calls may not be repeatable with respect to the issue, as external
    requests may return slightly different data every time
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续调用可能无法重复出现问题，因为外部请求可能每次返回略有不同的数据
- en: If you are using an external paid API, the calls may actually cost you money,
    so you cannot exhaust a lot of such calls on debugging and testing
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用的是外部付费API，调用实际上可能会花费你的钱，因此你不能在调试和测试上花费大量这样的调用
- en: A common technique that is very useful in these cases is to save the return
    data of these APIs/functions, and then mock the functions by using their return
    data to replace the functions/APIs themselves. This is an approach similar to
    mock testing, but it is used in the context of debugging.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下非常有用的一种常见技术是保存这些API/函数的返回数据，然后通过使用它们的返回数据来替换函数/API本身来模拟函数。这是一种类似于模拟测试的方法，但是它是在调试的上下文中使用的。
- en: 'Let us look at an example of an API that returns *business listings* on websites,
    given a business address including details like its name, street address, city,
    and so on. The code looks like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个API的示例，它根据企业地址返回网站上的*商家列表*，包括名称、街道地址、城市等详细信息。代码如下：
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The code makes a few assumptions, one of which is that every site has the same
    API URL and parameters. Note that this is only for illustration purposes. In reality,
    each site will have very different API formats including its URL and the parameters
    it accepts.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码做出了一些假设，其中之一是每个站点都具有相同的API URL和参数。请注意，这仅用于说明目的。实际上，每个站点的API格式都会有很大不同，包括其URL和接受的参数。
- en: Note that in this last piece of code, the actual work is being done in the `process_listings`
    function, the code for which is not shown, as the example is illustrative.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这段代码的最后，实际工作是在`process_listings`函数中完成的，由于示例是说明性的，因此未显示代码。
- en: 'Let''s say you are trying to debug this function. However, due to a delay or
    error in the API calls, you find you are wasting a lot of valuable time in fetching
    the listings themselves. What are some of the techniques that you can use to avoid
    this dependency? Here are a few things that you can do:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在尝试调试此函数。但是，由于API调用的延迟或错误，您发现自己在获取列表本身方面浪费了大量宝贵的时间。您可以使用哪些技术来避免这种依赖？以下是一些您可以做的事情：
- en: Instead of fetching listings via API, save them to files, to a database, or
    an in-memory store, and load them on demand
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要通过API获取列表，而是将它们保存到文件、数据库或内存存储中，并按需加载
- en: Cache the return value of the `api_search` function via a caching or memoize
    patterns so that further calls after the first call, return data from memory
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过缓存或记忆模式缓存`api_search`函数的返回值，以便在第一次调用后，进一步调用从内存返回数据
- en: Mock the data, and return random data that has the same characteristics as the
    original data
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟数据，并返回具有与原始数据相同特征的随机数据
- en: We will look at each of these in turn.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次查看这些内容。
- en: Saving to / loading data from files as cache
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据保存到/从文件中加载作为缓存
- en: 'In this technique, you construct a filename using unique keys from the input
    data. If a matching file exists on disk, it is opened and the data is returned,
    otherwise, the call is made and the data is written. This can be achieved by using
    a *file caching* decorator as the following code illustrates:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种技术中，您使用输入数据的唯一键构造文件名。如果磁盘上存在匹配的文件，则打开该文件并返回数据，否则进行调用并写入数据。可以通过使用*文件缓存*装饰器来实现，如下面的代码所示：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here''s how this preceding code works:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这段代码的工作原理：
- en: The `api_search` function is decorated with `filecache` as a decorator.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`api_search`函数被装饰为`filecache`。'
- en: '`filecache` uses `unique_key` as the function to calculate the unique filename
    for storing the results of an API call. In this case, the `unique_key` function
    uses the hash of a combination of the business name, street, and city, plus the
    site queried for in order to build the unique value.'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`filecache`使用`unique_key`作为计算存储API调用结果的唯一文件名的函数。在这种情况下，`unique_key`函数使用业务名称、街道和城市的组合的哈希值，以及查询的站点来构建唯一值。'
- en: The first time the function is called, the data is fetched via API and stored
    in the file. During further invocations, the data is returned directly from the
    file.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一次调用函数时，数据通过API获取并存储在文件中。在进一步调用期间，数据直接从文件返回。
- en: This works pretty well in most cases. Most data is loaded just once, and on
    further calls, returned from the file cache. However, this suffers from the problem
    of *stale data*, as once the file is created, the data is always returned from
    it. Meanwhile, the data on the server may have changed.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这在大多数情况下效果相当不错。大多数数据只加载一次，再次调用时从文件缓存返回。然而，这会遇到“陈旧数据”的问题，因为一旦文件创建，数据总是从中返回。与此同时，服务器上的数据可能已经发生了变化。
- en: This can be solved by using an in-memory key-value store and saving the data
    there instead of in files on disk. One can use well-known key-value stores such
    as **Memcached**, **MongoDB**, or **Redis** for this purpose. In the following
    example, we'll show you how to replace the `filecache` decorator with a *memorycache*
    decorator using Redis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用内存键值存储解决，并将数据保存在内存中，而不是在磁盘上的文件中。可以使用著名的键值存储，如**Memcached**、**MongoDB**或**Redis**来实现这一目的。在下面的示例中，我们将向您展示如何使用Redis将`filecache`装饰器替换为*memorycache*装饰器。
- en: Saving to / loading data from memory as cache
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将数据保存到/从内存中加载作为缓存
- en: 'In this technique, a unique in-memory cache key is constructed using unique
    values from the input arguments. If the cache is found on the cache store by querying
    using the key, its value is returned from the store; or else the call is made
    and the cache is written. To ensure that data is not too stale, a fixed **time-to-live**
    (**TTL**) is used. We use Redis as the cache store engine:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种技术中，使用输入参数的唯一值构造唯一的内存缓存键。如果通过使用键查询在缓存存储中找到缓存，则从存储中返回其值；否则进行调用并写入缓存。为了确保数据不会太陈旧，使用了固定的**生存时间**（**TTL**）。我们使用Redis作为缓存存储引擎：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we are reusing the definition of `unique_key` from the previous code
    example.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们正在重用先前代码示例中的`unique_key`的定义。
- en: 'The only thing that changes in the rest of the code is that we replace the
    `filecache` decorator with the `memoize` one:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的其余部分中唯一变化的是我们用`memoize`替换了`filecache`装饰器：
- en: '[PRE33]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The advantages of this version over the previous one are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本相对于之前的版本的优势如下：
- en: The cache is stored in memory. No additional files are created.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存存储在内存中。不会创建额外的文件。
- en: The cache is created with a TTL, beyond which it expires. So the problem of
    stale data is circumvented. The TTL is customizable, and defaults to a day (86400
    seconds) in this example.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存是使用TTL创建的，超过TTL后会过期。因此，陈旧数据的问题被规避了。TTL是可定制的，在这个例子中默认为一天（86400秒）。
- en: 'There are a few other techniques for mocking external API calls and similar
    dependencies. Some of these are listed as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些模拟外部API调用和类似依赖的技术。以下是其中一些：
- en: Using a `StringIO` object in Python to read/write data, instead of using a file.
    For example, the `filecache` or `memoize` decorators can be easily modified to
    use a `StringIO` object.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中使用`StringIO`对象读取/写入数据，而不是使用文件。例如，`filecache`或`memoize`装饰器可以很容易地修改为使用`StringIO`对象。
- en: Using a mutable default argument, such as a dictionary or a list, as a cache
    and writing results to it. Since a mutable argument in Python holds its state
    after repeated calls, it effectively works as an in-memory cache.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可变默认参数，如字典或列表，作为缓存并将结果写入其中。由于Python中的可变参数在重复调用后保持其状态，因此它实际上可以作为内存缓存。
- en: Replacing an external API with a call to a replacement/dummy API call to a service
    on the local machine (`127.0.0.1` IP address) by editing the system host's file,
    adding an entry for the host in question, and putting its IP as `127.0.0.1`. The
    call to localhost can always return a standard (canned) response.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过编辑系统主机文件，为外部API替换为对本地机器上的服务的调用（`127.0.0.1` IP地址）添加一个主机条目，并将其IP设置为`127.0.0.1`。对localhost的调用总是可以返回标准（预设）响应。
- en: 'For example, on Linux and other POSIX systems, you can add a line like this
    in the `/etc/hosts` file:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在Linux和其他POSIX系统上，可以在`/etc/hosts`文件中添加以下行：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this technique is a very useful and clever approach as long as you
    remember to comment out such lines after testing!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，只要记得在测试后注释掉这些行，这种技术就是一种非常有用和巧妙的方法！
- en: Returning random/mock data
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 返回随机/模拟数据
- en: Another technique, which is mostly useful for performance testing and debugging,
    is to feed functions with data that is *similar*, but *not the same* as the original
    data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种技术，主要用于性能测试和调试，是使用*相似但不同*于原始数据的数据来提供函数。
- en: Let us say, for example, that you are working on an application that works with
    patient/doctor data for patients under a specific insurance scheme (say Medicare/Medicaid
    in the US, ESI in India) to analyze and find out patterns such as common ailments,
    top 10 health issues in terms of government expenses, and so on.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您正在开发一个应用程序，该应用程序与特定保险计划（例如美国的Medicare/Medicaid，印度的ESI）下的患者/医生数据一起工作，以分析并找出常见疾病、政府支出前10位的健康问题等模式。
- en: Let us say that your application is expected to load and analyze tens of thousands
    of rows of patient data from a database at one time, which is expected to scale
    to 1-2 million under peak load. You want to debug the application, and find out
    performance characteristics under such load, but you don't have any real data,
    as the data is in the collection stage.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序预计一次从数据库加载和分析成千上万行患者数据，并且在高峰负载下预计扩展到100-200万行。您想要调试应用程序，并找出在这种负载下的性能特征，但是您没有任何真实数据，因为数据还处于收集阶段。
- en: In such scenarios, libraries or functions that generate and return mock data
    are very useful. In this section, we will use a third-party Python library to
    accomplish this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，生成和返回模拟数据的库或函数非常有用。在本节中，我们将使用第三方Python库来实现这一点。
- en: Generating random patient data
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 生成随机患者数据
- en: 'Let us assume that, for a patient, we need the following basic fields:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，对于一个患者，我们需要以下基本字段：
- en: Name
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 姓名
- en: Age
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 年龄
- en: Gender
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性别
- en: Health Issue
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 健康问题
- en: Doctor's Name
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 医生的姓名
- en: Blood Group
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 血型
- en: Insured or Not
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有无保险
- en: Date of last visit to doctor
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一次就医日期
- en: The `schematics` library in Python provides a way to generate such data structures
    using simple types, which can then be validated, transformed, and also mocked.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`schematics`库提供了一种使用简单类型生成这些数据结构的方法，然后可以对其进行验证、转换和模拟。
- en: 'The `schematics` is a library installable via `pip` using the following command:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`schematics`是一个可通过以下命令使用`pip`安装的库：'
- en: '[PRE35]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To generate a model of a person with just name and age, it''s as simple as
    writing a class in `schematics`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成只有姓名和年龄的人的模型，只需在`schematics`中编写一个类即可：
- en: '[PRE36]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To generate mock data, a mock object is returned, and a *primitive* is created
    using this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 生成模拟数据时，返回一个模拟对象，并使用此对象创建一个*primitive*：
- en: '[PRE37]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: One can create custom types using Schematics. For the *Patient* model, for example,
    let us say that we are only interested in the age group 18—80, so we need to return
    age data in that range.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用Schematics创建自定义类型。例如，对于*Patient*模型，假设我们只对18-80岁的年龄组感兴趣，因此需要返回该范围内的年龄数据。
- en: 'The following custom type does that for us:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下自定义类型为我们做到了这一点：
- en: '[PRE38]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Also, since the names returned by the schematics library are just random strings,
    they have some room for improvement. The following `NameType` class improves upon
    it by returning names containing a clever mix of vowels and consonants:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于Schematics库返回的姓名只是随机字符串，还有改进的空间。以下的`NameType`类通过返回包含元音和辅音巧妙混合的姓名来改进：
- en: '[PRE39]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'When combining both of these new types, our `Person` class looks much better
    when returning mock data:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两种新类型结合起来后，我们的`Person`类在返回模拟数据时看起来更好：
- en: '[PRE40]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In a similar way, it is rather easy to come up with a set of custom types and
    standard types to satisfy all the fields required for a *Patient* model:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，很容易提出一组自定义类型和标准类型，以满足*Patient*模型所需的所有字段：
- en: '[PRE42]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, combining all these with some standard types and default values into a
    Patient model, we get the following code:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有这些与一些标准类型和默认值结合到一个*Patient*模型中，我们得到以下代码：
- en: '[PRE43]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, creating random data of any size is as easy as invoking the `get_mock_object`
    method on the Patient class for any number *n*:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建任意大小的随机数据就像在*Patient*类上调用`get_mock_object`方法一样简单：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For example, to create 10,000 random patient data, we use the following:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建10,000个随机患者数据，我们可以使用以下方法：
- en: '[PRE45]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This data can be input to the processing functions as mock data until the real
    data is made available.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据可以作为模拟数据输入到处理函数中，直到真实数据可用为止。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: The Faker library in Python is also useful for generating a wide variety
    of fake data such as names, addresses, URIs, random text, and the like.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Python中的Faker库也可用于生成各种假数据，如姓名、地址、URI、随机文本等。
- en: Let us now move on from these simple tricks and techniques to something more
    involved, mainly configuring logging in your applications.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从这些简单的技巧和技术转移到更复杂的内容，主要是配置应用程序中的日志记录。
- en: Logging as a debugging technique
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为调试技术的日志记录
- en: 'Python comes with standard library support for logging via the aptly named
    `logging` module. Though print statements can be used as a quick and rudimentary
    tool for debugging, real-life debugging mostly requires that the system or application
    generate some logs. Logging is useful because of the following reasons:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了对日志记录的标准库支持，通过名为`logging`的模块。虽然可以使用打印语句作为快速和简陋的调试工具，但现实生活中的调试大多需要系统或应用程序生成一些日志。日志记录是有用的，因为有以下原因：
- en: Logs are usually saved to specific log files, typically, with timestamps, and
    remain at the server for a while until they are rotated out. This makes debugging
    easy even if the programmer is debugging the issue some time after it happened.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志通常保存在特定的日志文件中，通常带有时间戳，并在服务器上保留一段时间，直到它们被轮换出去。这使得即使程序员在发生问题一段时间后进行调试，调试也变得容易。
- en: Logging can be done at different levels—from the basic INFO to the verbose DEBUG
    levels—changing the amount of information output by the application. This allows
    the programmer to debug at different levels of logging to extract the information
    they want, and figure out the problem.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在不同级别进行日志记录，从基本的INFO到冗长的DEBUG级别，改变应用程序输出的信息量。这使程序员能够在不同级别的日志记录中进行调试，提取他们想要的信息，并找出问题所在。
- en: Custom loggers can be written, which can perform logging to various outputs.
    At its most basic, logging is done to log files, but one can also write loggers
    that write to sockets, HTTP streams, databases, and the like.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以编写自定义记录器，可以将日志记录到各种输出。在最基本的情况下，日志记录是写入日志文件的，但也可以编写将日志记录到套接字、HTTP流、数据库等的记录器。
- en: Simple application logging
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的应用程序日志记录
- en: 'To configure simple logging in Python is rather easy and is shown as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中配置简单的日志记录相当容易，如下所示：
- en: '[PRE46]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Nothing happens on executing the preceding code, because, by default, `logging`
    is configured at the **WARNING** level. However, it is pretty easy to configure
    logging to change its level.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码不会发生任何事情，因为默认情况下，`logging`被配置为**WARNING**级别。但是，很容易配置日志以更改其级别。
- en: 'The following code changes logging to log at the `info` level, and also adds
    a target file to save the log:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将日志记录更改为以`info`级别记录，并添加一个目标文件来保存日志：
- en: '[PRE47]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If we inspect the `application.log` file, we will find that it contains the
    following lines:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们检查`application.log`文件，我们会发现它包含以下行：
- en: '[PRE48]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In order to add timestamps to the log lines, we need to configure the logging
    format. This can be done as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在日志行中添加时间戳，我们需要配置日志格式。可以按以下方式完成：
- en: '[PRE49]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Combining this, we get the final logging configuration as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 结合起来，我们得到最终的日志配置如下：
- en: '[PRE50]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, the contents of `application.log` looks something like the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`application.log`的内容看起来像下面这样：
- en: '[PRE51]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Logging supports variable arguments, which are used to supply arguments to a
    template string supplied as the first argument.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 日志支持变量参数，用于向作为第一个参数提供的模板字符串提供参数。
- en: 'Direct logging of arguments separated by commas doesn''t work. For example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 逗号分隔的参数的直接日志记录不起作用。例如：
- en: '[PRE52]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'However, we can use the following:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以使用以下方法：
- en: '[PRE53]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The earlier example works nicely.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子运行得很好。
- en: Advanced logging—logger objects
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级日志记录-记录器对象
- en: Logging using the `logging` module directly works in most simple situations.
    However, in order to extract the maximum value out of the `logging` module, we
    should work with logger objects. It also allows us to perform a lot of customizations
    such as custom formatters, custom handlers, and so on.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用`logging`模块进行日志记录在大多数简单情况下都可以工作。但是，为了从`logging`模块中获得最大的价值，我们应该使用记录器对象。它还允许我们执行许多自定义操作，比如自定义格式化程序、自定义处理程序等。
- en: 'Let us write a function that returns such a custom logger. It accepts the application
    name, the logging level, and two more options—the log filename, and whether to
    turn console logging on or not:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个返回这样一个自定义记录器的函数。它接受应用程序名称、日志级别和另外两个选项-日志文件名和是否打开控制台日志记录：
- en: '[PRE54]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Let''s inspect the function:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下这个函数：
- en: Instead of using `logging` directly, it creates a `logger` object using the
    `logging.getLogger` factory function.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不直接使用`logging`，而是使用`logging.getLogger`工厂函数创建一个`logger`对象。
- en: By default, the `logger` object is useless as it has not been configured with
    any handlers. Handlers are stream wrappers that take care of logging to a specific
    stream, such as the console, files, sockets, and so on.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，`logger`对象是无用的，因为它没有配置任何处理程序。处理程序是流包装器，负责将日志记录到特定流，如控制台、文件、套接字等。
- en: The configuration is done on this logger object, such as setting the level (via
    the `setLevel` method) and adding handlers such as the `FileHandler` for logging
    to a file and a `StreamHandler` for logging to the console.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个记录器对象上进行配置，比如设置级别（通过`setLevel`方法）和添加处理程序，比如用于记录到文件的`FileHandler`和用于记录到控制台的`StreamHandler`。
- en: 'Formatting of the log message is done on the handlers, and not on the logger
    object per se. We use a standard format of `<timestamp>: <level>—<message>` using
    the date format for the timestamp of `YY-mm-dd HH:MM:SS`.'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 日志消息的格式化是在处理程序上完成的，而不是在记录器对象本身上完成的。我们使用`YY-mm-dd HH:MM:SS`的日期格式作为时间戳的标准格式。
- en: 'Let''s see this in action:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的运行情况：
- en: '[PRE55]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inspecting the app.log file in the same directory reveals the following contents:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一目录中检查app.log文件会发现以下内容：
- en: '[PRE56]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Advanced logging—custom formatting and loggers
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级日志记录-自定义格式和记录器
- en: We looked at how we can create and configure logger objects according to our
    requirements. Sometimes, one needs to go over and above, and print extra data
    in the log lines, which helps debugging.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了如何根据我们的要求创建和配置记录器对象。有时，需要超越并在日志行中打印额外的数据，这有助于调试。
- en: A common problem that arises in debugging applications, especially those that
    are performance critical, is to find out how much time each function or method
    takes. Now, though this can be found out by methods such as profiling the application
    using profilers and by using some techniques discussed previously like timer context
    managers, quite often, a custom logger can be written to do the trick.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试应用程序中经常出现的一个常见问题，特别是那些对性能至关重要的应用程序，就是找出每个函数或方法需要多少时间。尽管可以通过使用性能分析器对应用程序进行性能分析等方法来找出这一点，并且通过使用之前讨论过的一些技术，如计时器上下文管理器，很多时候，可以编写一个自定义记录器来实现这一点。
- en: Let us assume that your application is a business listing API server, which
    responds to listing API requests like the one we discussed in an earlier section.
    When it starts off, it needs to initialize a number of objects and load some data
    from the DB.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序是一个业务列表API服务器，响应类似于我们在前一节中讨论的列表API请求。当它启动时，需要初始化一些对象并从数据库加载一些数据。
- en: 'Assume that as part of performance optimization, you have tuned these routines,
    and would like to record how much time these take. We''ll see if we can write
    a custom logger to do it for us:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设作为性能优化的一部分，您已经调整了这些例程，并希望记录这些例程需要多少时间。我们将看看是否可以编写一个自定义记录器来为我们完成这项工作：
- en: '[PRE57]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We have built a custom class named `LoggerWrapper`. Let us analyze the code
    and see what it does:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个名为`LoggerWrapper`的自定义类。让我们分析一下代码并看看它的作用：
- en: The `__init__` method of this class is very similar to our `create_logger` function
    written before. It takes the same argument, constructs handler objects, and configures
    the `logger`. However, this time, the `logger` object is part of the outer `LoggerWrapper`
    instance.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个类的`__init__`方法与之前编写的`create_logger`函数非常相似。它接受相同的参数，构造处理程序对象，并配置`logger`。但是，这一次，`logger`对象是外部`LoggerWrapper`实例的一部分。
- en: The formatter takes an additional variable template named `timespent`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化程序接受一个名为`timespent`的额外变量模板。
- en: No direct logging methods seem to be defined. However, using the partial functions
    technique, we wrap the `_dolog` method at the different levels of logging, and
    set them on the class as `logging` methods, dynamically, by using `setattr`.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 似乎没有定义直接的日志记录方法。但是，使用部分函数技术，我们在不同级别的日志记录中包装`_dolog`方法，并将它们动态地设置为类的`logging`方法，使用`setattr`。
- en: The `_dolog` method calculates the time spent in each routine by using a marker
    timestamp—initialized the first time, and then reset in every call. The time spent
    is sent to the logging methods using a dictionary argument named extra.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_dolog`方法通过使用标记时间戳来计算每个例程中花费的时间——第一次初始化，然后在每次调用时重置。花费的时间使用一个名为extra的字典参数发送到日志记录方法。'
- en: 'Let''s see how the application can use this logger wrapper to measure the time
    spent in critical routines. Here is an example that assumes a Flask web application:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看应用程序如何使用这个记录器包装器来测量关键例程中花费的时间。以下是一个假设使用Flask Web应用程序的示例：
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that the time spent is logged inside square brackets just after the timestamp.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，花费的时间在时间戳之后的方括号内记录。
- en: 'Let''s say that this last code produces an output like the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设最后的代码产生了以下输出：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: From the log lines, it's evident that the initialization took 14 seconds, whereas
    the loading of configuration and data took 1 min and 55 seconds.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从日志行可以明显看出，初始化花费了14秒，而配置和数据的加载花费了1分55秒。
- en: By adding similar log lines, you can get a quick and reasonably accurate estimate
    of the time spent on critical pieces of the application. Being saved in log files,
    another added advantage is that you don't need to specially calculate and save
    it anywhere else.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加类似的日志行，您可以快速而相当准确地估计应用程序关键部分的时间。保存在日志文件中，另一个额外的优势是您不需要特别计算和保存它在其他地方。
- en: Note
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using this custom logger, note that the time shown as time spent for a given
    log line is the time spent in the routine of the previous line.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个自定义记录器，请注意，显示为给定日志行花费的时间是在前一行例程中花费的时间。
- en: Advanced logging—writing to syslog
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 高级日志记录——写入syslog
- en: POSIX systems such as Linux and Mac OS X have a system log file, which the application
    can write to. Typically, this file is present as `/var/log/syslog`. Let us see
    how Python logging can be configured to write to the system log file.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 像Linux和Mac OS X这样的POSIX系统有一个系统日志文件，应用程序可以写入。通常，该文件存在为`/var/log/syslog`。让我们看看如何配置Python日志记录以写入系统日志文件。
- en: 'The main change that you need to make is to add a system log handler to the
    logger object like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的主要更改是向记录器对象添加系统日志处理程序，如下所示：
- en: '[PRE60]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s modify our `create_logger` function to enable it to write to `syslog`,
    and see the complete code in action:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的`create_logger`函数，使其能够写入`syslog`，并查看完整的代码运行情况：
- en: '[PRE61]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now let us try to create a logger while logging to `syslog`:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试创建一个记录器，同时记录到`syslog`：
- en: '[PRE62]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Let''s inspect syslog to see if it actually got logged:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查syslog，看看它是否真的被记录了下来：
- en: '[PRE63]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The output shows that it did.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示它确实做到了。
- en: Debugging tools—using debuggers
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试工具——使用调试器
- en: Most programmers tend to think of *debugging* as something that they ought to
    do with a debugger. In this chapter, we have so far seen that more than an exact
    science, debugging is an art, which can be done using a lot of tricks and techniques
    rather than directly jumping to a debugger. However, sooner or later, we expected
    to encounter the debugger in this chapter—and here we are!
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数程序员倾向于将*调试*视为他们应该使用调试器进行的事情。在本章中，我们迄今为止已经看到，调试不仅仅是一门精确的科学，而且是一门艺术，可以使用许多技巧和技术来完成，而不是直接跳到调试器。然而，迟早，我们期望在本章中遇到调试器——现在就是时候了！
- en: The Python Debugger, or pdb as it is known, is part of the Python runtime.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Python调试器，或者称为pdb，是Python运行时的一部分。
- en: 'Pdb can be invoked when running a script from the beginning as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在从头开始运行脚本时调用Pdb，如下所示：
- en: '[PRE64]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, the most common way in which programmers invoke pdb is to insert the
    following line at a place in the code where you want to enter the debugger:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，程序员通常调用pdb的最常见方式是在代码中想要进入调试器的地方插入以下行：
- en: '[PRE65]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let us use this, and try and debug an instance of the first example in this
    chapter, that is, the sum of the max subarray. We will debug the `O(n)` version
    of the code as an example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这个，并尝试调试本章第一个示例的一个实例，也就是最大子数组的和。我们将调试代码的`O(n)`版本作为示例：
- en: '[PRE66]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: A debugging session with pdb
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pdb进行调试会话
- en: 'The debugger is entered in the very first loop immediately after the program
    is run:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序运行后立即进入调试器的第一个循环中：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can stop the execution using (*s*). Pdb will execute the current line,
    and stop:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用(*s*)来停止执行。Pdb将执行当前行，并停止：
- en: '[PRE68]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'You can inspect the variables by simply typing them and pressing [*Enter*]:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过简单地输入变量名称并按[*Enter*]来检查变量：
- en: '[PRE69]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The current stack trace can be printed using (*w*) or where. An arrow (→) indicates
    the current stack frame:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用(*w*)或where打印当前堆栈跟踪。箭头(→)表示当前堆栈帧：
- en: '[PRE70]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The execution can be continued until the next breakpoint by using (*c*) or
    continue:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用(*c*)或continue继续执行，直到下一个断点：
- en: '[PRE71]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In the preceding code, we continued three iterations of the `for` loop until
    the max value changed from 20 to 35\. Let us inspect where we are in the sequence:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们继续了`for`循环的三次迭代，直到最大值从20变为35。让我们检查一下我们在序列中的位置：
- en: '[PRE72]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'We have one more item to go in the list, namely, the last one. Let us inspect
    the source code at this point using the (*l*) or the `list` command:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个项目要在列表中完成，即最后一个项目。让我们使用(*l*)或`list`命令来检查此时的源代码：
- en: '[PRE73]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'One can traverse up and down the stack frames by using the (*u*) or `up` and
    (*d*) or *down* commands, respectively:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用(*u*)或`up`和(*d*)或*down*命令在堆栈帧上下移动：
- en: '[PRE74]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Let''s now return from the function:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们从函数中返回：
- en: '[PRE75]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The return value of the function is *45*.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的返回值是*45*。
- en: Pdb has a lot of other commands than what we covered here. However, we don't
    intend for this session to be a fully-fledged pdb tutorial. Interested programmers
    can refer to the documentation on the Web to learn more.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: Pdb有很多其他命令，不仅限于我们在这里介绍的内容。但是，我们不打算让本次会话成为一个完整的pdb教程。有兴趣的程序员可以参考网络上的文档以了解更多信息。
- en: Pdb—similar tools
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pdb-类似的工具
- en: The Python community has built a number of useful tools that build on top of
    pdb, but add more useful functionality, developer's ease-of-use, or both.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: Python社区已经构建了许多有用的工具，这些工具是在pdb的基础上构建的，但添加了更多有用的功能、开发者的易用性，或者两者兼而有之。
- en: iPdb
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iPdb
- en: iPdb is iPython-enabled pdb. It exports functions to access the iPython debugger.
    It also has tab completion, syntax highlighting, and better traceback, and introspection
    methods.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: iPdb是启用iPython的pdb。它导出函数以访问iPython调试器。它还具有制表完成、语法高亮和更好的回溯和内省方法。
- en: iPdb can be installed with pip.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: iPdb可以通过pip安装。
- en: 'The following screenshot shows a session of debugging using iPdb, the same
    function as we did with pdb before. Observe the syntax highlighting that **iPdb**
    provides:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了使用iPdb进行调试会话，与之前使用pdb相同的功能。注意**iPdb**提供的语法高亮：
- en: '![iPdb](../Images/image00523.jpeg)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![iPdb](../Images/image00523.jpeg)'
- en: iPdb in action, showing syntax highlighting
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: iPdb在操作中，显示语法高亮
- en: 'Also note that iPdb provides a fuller stack trace as opposed to pdb:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，iPdb提供了比pdb更完整的堆栈跟踪：
- en: '![iPdb](../Images/image00524.jpeg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![iPdb](../Images/image00524.jpeg)'
- en: iPdb in action, showing a fuller stack trace than pdb
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: iPdb在操作中，显示比pdb更完整的堆栈跟踪
- en: Note that iPdb uses iPython as the default runtime instead of Python.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，iPdb使用iPython作为默认运行时，而不是Python。
- en: Pdb++
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pdb++
- en: Pdb++ is a drop-in replacement for pdb with features similar to iPdb, but it
    works on the default Python runtime instead of requiring iPython. Pdb++ is also
    installable via pip.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: Pdb++是pdb的一个替代品，具有类似于iPdb的功能，但它适用于默认的Python运行时，而不需要iPython。Pdb++也可以通过pip安装。
- en: Once pdb++ is installed, it takes over at all places that import pdb, so no
    code change is required at all.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 安装pdb++后，它将接管所有导入pdb的地方，因此根本不需要更改代码。
- en: Pdb++ does smart command parsing. For example, if there are variable names conflicting
    with the standard Pdb commands, pdb will give preference to the command over displaying
    the variable contents. Pdb++ figures this out intelligently.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Pdb++进行智能命令解析。例如，如果变量名与标准Pdb命令冲突，pdb将优先显示变量内容而不是命令。Pdb++能够智能地解决这个问题。
- en: 'Here is a screenshot showing Pdb++ in action, including syntax highlighting,
    tab completion, and smart command parsing:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是显示Pdb++在操作中的屏幕截图，包括语法高亮、制表完成和智能命令解析：
- en: '![Pdb++](../Images/image00525.jpeg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![Pdb++](../Images/image00525.jpeg)'
- en: Pdb++ in action—Note the smart command parsing, where the variable c is interpreted
    correctly
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: Pdb++在操作中-请注意智能命令解析，其中变量c被正确解释
- en: Advanced debugging—tracing
  id: totrans-372
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级调试-跟踪
- en: Tracing of a program right from the beginning can often be used as an advanced
    debugging technique. Tracing allows a developer to trace program execution, find
    caller/callee relationships, and figure out all functions executed during the
    run of a program.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 从一开始跟踪程序的执行通常可以作为一种高级调试技术。跟踪允许开发人员跟踪程序执行，找到调用者/被调用者关系，并找出程序运行期间执行的所有函数。
- en: The trace module
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪模块
- en: Python comes with a default `trace` module as part of its standard library.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带了一个默认的`trace`模块作为其标准库的一部分。
- en: The trace module takes one of the `–trace`, `--count`, or `–listfuncs` options.
    |The first option traces and prints all the source lines as they are executed.
    The second option produces an annotated list of files, which shows how many times
    a statement was executed. The latter simply displays all the functions executed
    by running of the program.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: trace模块接受`-trace`、`--count`或`-listfuncs`选项之一。第一个选项跟踪并打印所有源行的执行情况。第二个选项生成一个文件的注释列表，显示语句执行的次数。后者简单地显示程序运行期间执行的所有函数。
- en: 'The following is a screenshot of the subarray problem being invoked by the
    `–trace` option of the `trace` module:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`trace`模块的`-trace`选项调用子数组问题的屏幕截图：
- en: '![The trace module](../Images/image00526.jpeg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![trace模块](../Images/image00526.jpeg)'
- en: Tracing program execution using the trace module by using its –trace option.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用其-trace选项，可以使用trace模块跟踪程序执行。
- en: As you can see, the *trace* module, traced the entire program execution, printing
    the lines of code one by one. Since most of this code is a `for` loop, you actually
    see the lines of code in the loop getting printed the number of times the loop
    was executed (five times).
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，*trace*模块跟踪了整个程序执行过程，逐行打印代码行。由于大部分代码都是`for`循环，您实际上会看到循环中的代码行被打印出循环执行的次数（五次）。
- en: The `–trackcalls` option traces and prints the relationships between the caller
    and callee functions.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '`-trackcalls`选项跟踪并打印调用者和被调用函数之间的关系。'
- en: There are many other options to the trace module such as tracking calls, generating
    annotated file listings, reports, and so on. We won't be having an exhaustive
    discussion regarding these, as the reader can refer to the documentation of this
    module on the Web to read more about it.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: trace模块还有许多其他选项，例如跟踪调用、生成带注释的文件列表、报告等。我们不会对这些进行详尽的讨论，因为读者可以参考Web上有关此模块的文档以获取更多信息。
- en: The lptrace program
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: lptrace程序
- en: When debugging servers and trying to find out performance or other issues on
    production environments, what a programmer needs is not often the Python system
    or stack trace as given by the *trace* module, but to attach to a process in realtime
    and see what functions are getting executed.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试服务器并尝试在生产环境中查找性能或其他问题时，程序员需要的通常不是由*trace*模块提供的Python系统或堆栈跟踪，而是实时附加到进程并查看正在执行哪些函数。
- en: Note
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: lptrace can be installed using pip. Note that it doesn't work with **Python3**.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: lptrace可以使用pip安装。请注意，它不适用于**Python3**。
- en: The `lptrace` package allows you to do this. Instead of giving a script to run,
    it attaches to an existing process running a Python program via its process ID,
    such as running servers, applications, and the like.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`lptrace`包允许您执行此操作。它不是提供要运行的脚本，而是通过其进程ID附加到正在运行Python程序的现有进程，例如运行服务器、应用程序等。'
- en: 'In the folllowing screenshot, you can see *lptrace* debugging the Twisted chat
    server that we developed in [Chapter 8](part0067.xhtml#aid-1VSLM2 "Chapter 8. Python
    – Architectural Patterns"), *Architectural Patterns—The Pythonic Approach* live.
    The session shows the activity when the client andy has connected:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的屏幕截图中，您可以看到* lptrace *调试我们在[第8章](part0067.xhtml#aid-1VSLM2 "第8章。Python-架构模式")中开发的Twisted聊天服务器，*架构模式-
    Pythonic方法*实时。会话显示了客户端andy连接时的活动：
- en: '![The lptrace program](../Images/image00527.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![lptrace程序](../Images/image00527.jpeg)'
- en: lptrace command debugging a chat server in Twisted
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: lptrace命令调试Twisted中的聊天服务器
- en: There are lots of log lines, but you can observe how some well-known methods
    of the Twisted protocol are being logged such as **connectionMade** when the client
    has connected. Socket calls such as *accept* can also be seen as part of accepting
    the connection from the client.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多日志行，但您可以观察到一些Twisted协议的众所周知的方法被记录，例如客户端连接时的**connectionMade**。还可以看到接受来自客户端的连接的Socket调用，例如*accept*。
- en: System call tracing using strace
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用strace进行系统调用跟踪
- en: '`Strace` is a Linux command, which allows a user to trace system calls and
    signals invoked by a running program. It is not exclusive to Python, but it can
    be used to debug any program. Strace can be used in combination with lptrace to
    troubleshoot programs with respect to their system calls.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '`Strace`是一个Linux命令，允许用户跟踪运行程序调用的系统调用和信号。它不仅适用于Python，还可以用于调试任何程序。Strace可以与lptrace结合使用，以便就其系统调用进行故障排除。'
- en: '`Strace` is similar to *lptrace* in that it can be made to attach to a running
    process. It can also be invoked to run a process from the command line, but it
    is more useful when running attached to a process such as a server.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`Strace`与*lptrace*类似，可以附加到正在运行的进程。它也可以被调用以从命令行运行进程，但在附加到服务器等进程时更有用。'
- en: 'For example, this screenshot shows the strace output when running attached
    to our chat server:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，此屏幕截图显示了附加到我们的聊天服务器时的strace输出：
- en: '![System call tracing using strace](../Images/image00528.jpeg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
  zh: '![使用strace进行系统调用跟踪](../Images/image00528.jpeg)'
- en: strace command attached to the Twisted chat server
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 附加到Twisted聊天服务器的strace命令
- en: The *strace* command corroborates the conclusion of the `lptrace` command of
    the server waiting on an **epoll** handle for incoming connections.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*strace*命令证实了服务器正在等待**epoll**句柄以接收连接的`lptrace`命令的结论。'
- en: 'This is what happens when a client connects:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这是客户端连接时发生的情况：
- en: '![System call tracing using strace](../Images/image00529.jpeg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![使用strace进行系统调用跟踪](../Images/image00529.jpeg)'
- en: strace command showing system calls for a client connecting to the Twisted chat
    server
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: strace命令显示客户端连接到Twisted聊天服务器的系统调用
- en: Strace is a very powerful tool, which can be combined with tools specific for
    the runtime (such as lptrace for Python) in order to do advanced debugging in
    production environments.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Strace是一个非常强大的工具，可以与特定于运行时的工具（例如Python的lptrace）结合使用，以便在生产环境中进行高级调试。
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about different debugging techniques with Python.
    We started with the simple *print* statement and followed it with simple tricks
    to debug a Python program such as using the *continue* statement in a loop, strategically
    placed `sys.exit` calls between code blocks, and so on.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了使用Python的不同调试技术。我们从简单的*print*语句开始，然后使用*continue*语句在循环中进行简单的调试技巧，以及在代码块之间
    strategically placed `sys.exit` 调用等。
- en: We then looked at debugging techniques in some detail, especially on mocking
    and randomizing data. Techniques such as caching in files and in-memory database
    such as Redis were discussed with examples.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们详细讨论了一些调试技术，特别是模拟和随机化数据。讨论了文件缓存和Redis等内存数据库的技术，并提供了示例。
- en: An example using Python schematics library showed generating random data for
    a hypothetical application in the healthcare domain.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python schematics库的示例显示了在医疗保健领域的假设应用程序中生成随机数据。
- en: The next section was about logging and using it as a debugging technique. We
    discussed simple logging using the *logging* module, advanced logging using `logger`
    object, and wrapped up the discussion by creating a logger wrapper with its custom
    formatting for logging time taken inside functions. We also studied an example
    of writing to syslog.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分是关于日志记录及其作为调试技术的使用。我们讨论了使用*logging*模块进行简单日志记录，使用`logger`对象进行高级日志记录，并通过创建具有自定义格式的日志记录函数内部所花费时间的记录器包装器来结束讨论。我们还学习了一个写入syslog的示例。
- en: The end of the chapter was devoted to a discussion on debugging tools. You learned
    the basic commands of pdb, the Python debugger, and took a quick look at similar
    tools that provide a better experience, namely, iPdb and Pdb++. We ended the chapter
    with a brief discussion on tracing tools such as lptrace and the ubiquitous *strace*
    program on Linux.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的结尾专门讨论了调试工具。您学习了pdb，Python调试器的基本命令，并快速了解了提供更好体验的类似工具，即iPdb和Pdb++。我们在本章结束时简要讨论了诸如lptrace和Linux上无处不在的*strace*程序之类的跟踪工具。
- en: This brings us to the conclusion of this chapter and the book.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是本章和本书的结论。
