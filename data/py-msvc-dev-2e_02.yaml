- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Discovering Quart
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现 Quart
- en: '**Quart** was started in 2017 as an evolution of the popular **Flask** framework.
    Quart shares many of the same design decisions as Flask, and so a lot of the advice
    for one will work with the other. This book will focus on Quart to allow us to
    support asynchronous operations and to explore features such as WebSockets and
    HTTP/2 support.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Quart** 是在 2017 年作为流行的 **Flask** 框架的进化而开始的。Quart 与 Flask 具有许多相同的设计决策，因此很多关于
    Flask 的建议也适用于 Quart。本书将专注于 Quart，以便我们支持异步操作并探索诸如 WebSocket 和 HTTP/2 支持等功能。'
- en: 'Quart and Flask are not the only Python frameworks. There is a long history
    of projects aimed at providing services on the web, such as **Bottle**, **cherrypy**,
    and **Django**. All of these tools are used around the web, and they all share
    a similar goal: to offer the Python community simple tools for building web applications
    quickly.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Quart 和 Flask 不是唯一的 Python 框架。在网络上提供服务的项目有着悠久的历史，例如 **Bottle**、**cherrypy**
    和 **Django**。所有这些工具都在网络上被使用，它们都拥有一个类似的目标：为 Python 社区提供构建 Web 应用程序的简单工具。
- en: The smaller frameworks, such as Quart and Bottle, are often called microframeworks;
    however, the term can be a bit misleading. It does not mean you can only create
    micro-applications. Using those tools, you can build any application, large or
    small. The prefix "micro" means that the framework tries to make as few decisions
    as possible. It lets you freely organize your application code and use whichever
    libraries you want.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 小型框架，如 Quart 和 Bottle，通常被称为微框架；然而，这个术语可能有些误导。这并不意味着你只能创建微应用。使用这些工具，你可以构建任何大小应用。前缀“微”意味着框架试图做出尽可能少的决策。它让你可以自由组织你的应用程序代码，并使用你想要的任何库。
- en: A microframework acts as the glue code that delivers requests to your system
    and sends back responses. It does not enforce any particular paradigm on your
    project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 微框架充当粘合代码，将请求传递到你的系统中，并发送响应。它不会对你的项目强制执行任何特定的范式。
- en: A typical example of this philosophy is when you need to interact with a SQL
    database. A framework such as Django is batteries-included and provides everything
    you need to build your web app, including an **Object-Relational Mapper** (**ORM**)
    to bind objects with database query results.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这种哲学的一个典型例子是当你需要与 SQL 数据库交互时。Django 等框架是“电池组”式的，提供了构建 Web 应用程序所需的一切，包括一个 **对象关系映射器**（**ORM**）来绑定对象与数据库查询结果。
- en: If you want to use an alternative ORM such as SQLAlchemy in Django to benefit
    from some of its great features, you'd be choosing a difficult path that would
    involve rewriting a lot of the Django library you are hoping to make use of, because
    of the tight integration Django has with the ORM it comes with. For certain applications,
    that's a good thing, but not necessarily for producing a microservice.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Django 中使用 SQLAlchemy 等替代 ORM 来利用其一些优秀功能，你将选择一条艰难的道路，因为这将涉及重写你希望利用的 Django
    库中的大量代码，因为 Django 与其自带的 ORM 集成非常紧密。对于某些应用程序来说，这可能是个好事，但并不一定适用于构建微服务。
- en: Quart, on the other hand, does not have a built-in library to interact with
    your data, leaving you free to choose your own. The framework will only attempt
    to make sure it has enough hooks to be extended by external libraries to provide
    various kinds of features. In other words, using an ORM in Quart, and making sure
    you're doing the right thing with SQL sessions and transactions, will mostly consist
    of adding a package such as SQLAlchemy to your project. If you don't like how
    a particular library integrates, you're free to use another one or to build your
    own integration. Quart can also make use of the more common Flask extensions,
    although there is a performance risk there as they are unlikely to be asynchronous
    and could block your application's work.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Quart 没有内置的库来与你的数据交互，这让你可以自由选择自己的库。框架只会尝试确保它有足够的钩子，以便外部库可以扩展并提供各种功能。换句话说，在
    Quart 中使用 ORM，并确保你正确处理 SQL 会话和事务，主要就是将 SQLAlchemy 等包添加到你的项目中。如果你不喜欢某个特定库的集成方式，你可以自由地使用另一个库或自己构建集成。Quart
    也可以使用更常见的 Flask 扩展，尽管这样做存在性能风险，因为这些扩展不太可能是异步的，可能会阻塞你的应用程序的工作。
- en: Of course, that's not a silver bullet. Being completely free in your choices
    also means that it is easier to make poor decisions and build an application that
    relies on defective libraries, or one that is not well designed. But fear not!
    This chapter will make sure you know what Quart has to offer, and how to organize
    your code for building microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是万能的解决方案。在您的选择上完全自由也意味着更容易做出糟糕的决定，构建一个依赖于有缺陷的库或设计不佳的应用程序。但不必担心！本章将确保您了解
    Quart 提供的内容，以及如何组织代码来构建微服务。
- en: 'This chapter covers the following topics:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Making sure we have Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们已安装 Python
- en: How Quart handles requests
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quart 如何处理请求
- en: Quart's built-in features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quart 的内置功能
- en: A microservice skeleton
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务骨架
- en: The goal of this chapter is to give you all the information needed to build
    microservices with Quart. By doing so, it inevitably duplicates some of the information
    you can find in Quart's official documentation, but focuses on providing interesting
    details and anything relevant when building microservices. Quart and Flask have
    good online documentation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是提供您构建 Quart 微服务所需的所有信息。通过这样做，不可避免地会重复一些您可以在 Quart 官方文档中找到的信息，但专注于提供构建微服务时有趣细节和任何相关内容。Quart
    和 Flask 都有良好的在线文档。
- en: 'Make sure you take a look at Quart''s and Flask''s documentation, listed respectively:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您查看 Quart 和 Flask 的文档，分别列出如下：
- en: '[https://pgjones.gitlab.io/quart/index.html](https://pgjones.gitlab.io/quart/index.html)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pgjones.gitlab.io/quart/index.html](https://pgjones.gitlab.io/quart/index.html)'
- en: '[https://flask.palletsprojects.com/](https://flask.palletsprojects.com/ )'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://flask.palletsprojects.com/](https://flask.palletsprojects.com/)'
- en: Both should serve as a great complement to this chapter. The source code is
    located at [https://gitlab.com/pgjones/quart](https://gitlab.com/pgjones/quart).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都应作为本章的绝佳补充。源代码位于 [https://gitlab.com/pgjones/quart](https://gitlab.com/pgjones/quart)。
- en: This is worth being aware of, as the source code is always the ultimate truth
    when you need to understand how the software works.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点值得注意，因为当您需要了解软件如何工作时，源代码总是终极真理。
- en: Making sure we have Python
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保我们已安装 Python
- en: Before we start digging into its features, we should make sure that we have
    Python installed and working!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始深入研究其功能之前，我们应该确保我们已经安装并配置了 Python！
- en: You might see some documentation or posts online that mention *Python version
    2*. There was a long transition from Python 2 to Python 3, and had this book been
    written a few years earlier, we would be discussing the merits of each. However,
    Python 3 is fully capable of everything the majority of people need to do, and
    Python 2 stopped being supported by the core Python team in 2020\. This book uses
    the latest Python 3.9 stable release for all its code examples, but they are likely
    to work on Python 3.7 or later, as that's the minimum version that Quart requires
    in order to work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会在网上看到一些提及 *Python 版本 2* 的文档或帖子。从 Python 2 到 Python 3 的过渡期很长，如果这本书几年前就写成，我们可能会讨论每个版本的优点。然而，Python
    3 已经能够满足大多数人所需的所有功能，Python 2 在 2020 年停止由核心 Python 团队支持。本书使用最新的 Python 3.9 稳定版本来展示所有代码示例，但它们很可能在
    Python 3.7 或更高版本上也能运行，因为这是 Quart 所需的最小版本。
- en: 'If your computer does not have at least Python 3.7, you can download a new
    version from Python''s own website, where installation instructions are provided:
    [https://www.python.org/downloads/](https://www.python.org/downloads/).'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的计算机没有至少 Python 3.7，您可以从 Python 的官方网站下载新版本，那里提供了安装说明：[https://www.python.org/downloads/](https://www.python.org/downloads/)。
- en: You will find it easier if all the code examples in this book are run in a virtual
    environment, or virtualenv ([https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html)).
    A virtual environment is Python's way of keeping each project separate, as it
    means you can install Quart and any other libraries you need; it will only affect
    the application you are currently working on. Other applications and projects
    can have different libraries, or different versions of the same library, without
    them getting in the way of each other. Using a virtualenv also means that you
    can easily recreate your project's dependencies somewhere else, which will be
    very useful when we deploy a microservice in a later chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个书中所有的代码示例都在虚拟环境中运行，你会发现这会更容易。或者使用 virtualenv ([https://docs.python.org/3/library/venv.html](https://docs.python.org/3/library/venv.html))。虚拟环境是
    Python 保持每个项目独立的方式，这意味着你可以安装 Quart 和任何其他你需要的库；它只会影响你当前正在工作的应用程序。其他应用程序和项目可以有不同的库，或者同一库的不同版本，而不会相互干扰。使用
    virtualenv 还意味着你可以轻松地在其他地方重新创建项目依赖，这在我们在后面的章节中部署微服务时将非常有用。
- en: Some code editors, such as PyCharm or Visual Studio, may manage a virtual environment
    for you. Every code example in the book runs in a terminal, and so we will use
    a terminal to create our virtualenv. This also shows how things work in more detail
    than viewing a program's output on the web, or in log files, and will be helpful
    when fixing any problems in the future.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一些代码编辑器，如 PyCharm 或 Visual Studio，可能会为你管理虚拟环境。本书中的每个代码示例都在终端中运行，因此我们将使用终端来创建我们的
    virtualenv。这也显示了比在网页或日志文件中查看程序输出更详细的工作方式，并且在未来修复任何问题时将非常有帮助。
- en: 'In a terminal, such as a macOS Terminal application, or a Windows Subsystem
    for Linux, change to the directory you would like to work in and run the following
    command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中，例如 macOS 终端应用程序或 Windows Subsystem for Linux，切换到你想要工作的目录，并运行以下命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Depending on how you installed Python, you may need to use `python3` to create
    the virtual environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你安装 Python 的方式，你可能需要使用 `python3` 来创建虚拟环境。
- en: 'This creates a new virtual environment called `my-venv` in the current directory.
    You could give it another path if you like, but it''s important to remember where
    it is. To use the virtual environment, you must activate it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在当前目录中创建一个名为 `my-venv` 的新虚拟环境。如果你愿意，可以给它指定另一个路径，但重要的是要记住它的位置。要使用虚拟环境，你必须激活它：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: For most of the command-line examples in this book, we assume you are running
    on Linux, as that is what most services online use, so it is good to be familiar
    with it. This means that most of the commands will also work on macOS or on Windows
    using the Windows Subsystem for Linux. It's also possible to run Docker containers
    on all these systems, and we will describe containers later on when we discuss
    deploying your microservice.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中的大多数命令行示例中，我们假设你正在 Linux 上运行，因为大多数在线服务都使用 Linux，所以熟悉它是很好的。这意味着大多数命令在 macOS
    或使用 Windows Subsystem for Linux 的 Windows 上也能正常工作。在这些系统上运行 Docker 容器也是可能的，我们将在讨论部署微服务时再详细介绍容器。
- en: 'Now, let''s install Quart so that we can run our example code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们安装 Quart，以便我们可以运行示例代码：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: To stop using the virtual environment without closing the terminal, you can
    type `deactivate`. For now, though, let's keep the virtualenv active and look
    at how Quart will work.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不关闭终端的情况下停止使用虚拟环境，你可以输入 `deactivate`。不过，现在让我们保持 virtualenv 激活状态，看看 Quart 将如何工作。
- en: How Quart handles requests
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quart 处理请求的方式
- en: The framework entry point is the `Quart` class in the `quart.app` module. Running
    a Quart application means running one single instance of this class, which will
    take care of handling incoming **Asynchronous Server Gateway Interface** (**ASGI**)
    and **Web Server Gateway Interface** (**WSGI**) requests, dispatch them to the
    right code, and then return a response. Remember that in *Chapter 1*, *Understanding
    Microservices*, we discussed ASGI and WSGI, and how they define the interface
    between a web server and a Python application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 框架的入口点是 `quart.app` 模块中的 `Quart` 类。运行 Quart 应用程序意味着运行这个类的单个实例，它将负责处理传入的 **异步服务器网关接口**（**ASGI**）和
    **Web 服务器网关接口**（**WSGI**）请求，将它们分发给正确的代码，然后返回响应。记住，在 *第一章*，*理解微服务* 中，我们讨论了 ASGI
    和 WSGI，以及它们如何定义 Web 服务器和 Python 应用程序之间的接口。
- en: The Quart class offers a `route` method, which can decorate your functions.
    When you decorate a function this way, it becomes a view and is registered in
    the routing system.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Quart类提供了一个`route`方法，可以用来装饰您的函数。以这种方式装饰函数后，它成为一个视图，并注册到路由系统中。
- en: When a request arrives, it will be to a specific endpoint—usually a web address
    (such as [https://duckduckgo.com/?q=quart](https://duckduckgo.com/?q=quart)) or
    part of an address, such as `/api`. The routing system is how Quart connects an
    endpoint to the view—the bit of code that will run to process the request.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个请求到达时，它将指向一个特定的端点——通常是一个网址（例如[https://duckduckgo.com/?q=quart](https://duckduckgo.com/?q=quart)）或地址的一部分，例如`/api`。路由系统是Quart如何将端点与视图连接起来的方式——即运行以处理请求的代码部分。
- en: 'Here''s a very basic example of a fully functional Quart application:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个功能齐全的Quart应用程序的非常基础的示例：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All the code samples are available on GitHub at [https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例都可以在GitHub上找到，地址为[https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSamples](https://github.com/PacktPublishing/Python-Microservices-Development-2nd-Edition/tree/main/CodeSample)。
- en: We see that our function returns a dictionary, and Quart knows that this should
    be encoded as a JSON object to be transferred. However, only querying the `/api`
    endpoint returns the value. Every other endpoint would return a 404 Error, indicating
    that it can't find the resource you requested because we haven't told it about
    any!
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到我们的函数返回一个字典，Quart知道这应该被编码为JSON对象以进行传输。然而，只有查询`/api`端点才会返回值。其他任何端点都会返回404错误，表示它找不到您请求的资源，因为我们没有告诉它任何信息！
- en: The `__name__` variable, whose value will be `__main__` when you run that single
    Python module, is the name of the application package. It's used by Quart to create
    a new logger with that name to format all the log messages, and to find where
    the file is located on the disk. Quart will use the directory as the root for
    helpers, such as the configuration that is associated with your app, and to determine
    default locations for the `static` and `templates` directories, which we will
    discuss later.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`__name__`变量，当您运行单个Python模块时其值将是`__main__`，是应用程序包的名称。Quart使用该名称创建一个新的日志记录器来格式化所有日志消息，并找到文件在磁盘上的位置。Quart将使用该目录作为辅助程序的根目录，例如与您的应用程序关联的配置，以及确定`static`和`templates`目录的默认位置，我们将在后面讨论。'
- en: 'If you run that module in a terminal, the `Quart` app will run its own development
    web server, and start listening to incoming connections on port `5000`. Here,
    we assume that you are still in the virtual environment created earlier and that
    the code above is in a file called `quart_basic.py`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在终端中运行该模块，`Quart`应用程序将运行其自己的开发Web服务器，并开始监听端口`5000`上的传入连接。这里，我们假设您仍然处于之前创建的虚拟环境中，并且上面的代码在名为`quart_basic.py`的文件中：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Visiting `http://localhost:5000/api` in your browser or with the `curl` command
    will return a valid JSON response with the right headers:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浏览器或`curl`命令访问`http://localhost:5000/api`将返回一个包含正确头部的有效JSON响应：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `curl` command is going to be used a lot in this book. If you are under
    Linux or macOS, it should be pre-installed; refer to [https://curl.haxx.se/](https://curl.haxx.se/).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将大量使用`curl`命令。如果您在Linux或macOS下，它应该已经预安装；请参阅[https://curl.haxx.se/](https://curl.haxx.se/)。
- en: 'If you are not developing your application on the same computer as the one
    that you are testing it on, you may need to adjust some of the settings, such
    as which IP addresses it should use to listen for connections. When we discuss
    deploying a microservice, we will cover some of the better ways of changing its
    configuration, but for now, the `app.run` line can be changed to use a different
    `host` and `port`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不是在测试计算机上开发应用程序，您可能需要调整一些设置，例如它应该使用哪些IP地址来监听连接。当我们讨论部署微服务时，我们将介绍一些更好的更改其配置的方法，但现在，可以将`app.run`行更改为使用不同的`host`和`port`：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: While many web frameworks explicitly pass a `request` object to your code, Quart
    provides a global `request` variable, which points to the current `request` object
    it built for the incoming HTTP request.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然许多Web框架明确地将`request`对象传递给您的代码，但Quart提供了一个全局的`request`变量，它指向它为传入的HTTP请求构建的当前`request`对象。
- en: This design decision makes the code for the simpler views very concise. As in
    our example, if you don't have to look at the request content to reply, there
    is no need to have it around. As long as your view returns what the client should
    get and Quart can serialize it, everything happens as you would hope. For other
    views, they can just import that variable and use it.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计决策使得简单视图的代码非常简洁。就像我们的例子一样，如果你不需要查看请求内容来回复，就没有必要保留它。只要你的视图返回客户端应该得到的内容，并且Quart可以序列化它，一切就会如你所愿发生。对于其他视图，它们只需导入该变量并使用它即可。
- en: 'The `request` variable is global, but it is unique to each incoming request
    and is thread-safe. Let''s add some `print` method calls here and there so that
    we can see what''s happening under the hood. We will also explicitly make a `Response`
    object using `jsonify`, instead of letting Quart do that for us, so that we can
    examine it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`变量是全局的，但它对每个传入的请求都是唯一的，并且是线程安全的。让我们在这里添加一些`print`方法调用，以便我们可以看到底层发生了什么。我们还将显式地使用`jsonify`创建一个`Response`对象，而不是让Quart为我们做这件事，这样我们就可以检查它：'
- en: '[PRE7]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Running that new version in conjunction with the `curl` command in another
    terminal, you get a lot of details, including the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中与`curl`命令一起运行新版本，你会得到很多详细信息，包括以下内容：
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s explore what''s happening here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这里发生了什么：
- en: '`Routing`: When the service starts, Quart creates the `QuartMap` object, and
    we can see here what it knows about endpoints and the associated views.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`路由`: 当服务启动时，Quart创建`QuartMap`对象，我们在这里可以看到它对端点和相关视图的了解。'
- en: '`Request`: Quart creates a `Request` object and `my_microservice` is showing
    us that it is a `GET` request to `/api`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Request`: Quart创建一个`Request`对象，`my_microservice`向我们展示它是一个对`/api`的`GET`请求。'
- en: '`dir()` shows us which methods and variables are in a class, such as `get_data()`
    to retrieve any data that was sent with the request.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dir()`显示了一个类中哪些方法和变量，例如`get_data()`用于检索随请求发送的任何数据。'
- en: '`Response`: A `Response` object to be sent back to the client; in this case,
    `curl`. It has an HTTP response code of `200`, indicating that everything is fine,
    and its data is the ''Hello world'' dictionary we told it to send.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response`: 要发送回客户端的`Response`对象；在这种情况下，是`curl`。它有一个HTTP响应代码`200`，表示一切正常，并且其数据是我们告诉它发送的''Hello
    world''字典。'
- en: Routing
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由
- en: Routing happens in `app.url_map`, which is an instance of the `QuartMap` class
    that uses a library called `Werkzeug`. That class uses regular expressions to
    determine whether a function decorated by `@app.route` matches the incoming request.
    The routing only looks at the path you provided in the route call to see whether
    it matches the client's request.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 路由发生在`app.url_map`中，这是一个`QuartMap`类的实例，它使用一个名为`Werkzeug`的库。该类使用正则表达式来确定由`@app.route`装饰的函数是否与传入的请求匹配。路由只查看你在路由调用中提供的路径，以查看它是否与客户端的请求匹配。
- en: 'By default, the mapper will only accept `GET`, `OPTIONS`, and `HEAD` methods
    on a declared route. Sending an HTTP request to a valid endpoint with an unsupported
    method will return a `405 Method Not Allowed` response together with a list of
    supported methods in the `allow` header:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，映射器将只接受在声明的路由上的`GET`、`OPTIONS`和`HEAD`方法。使用不支持的方法向有效的端点发送HTTP请求将返回一个`405
    Method Not Allowed`响应，并在`allow`头中附带支持的方法列表：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you want to support specific methods allowing you to `POST` to an endpoint
    or `DELETE` some data, you can pass them to the `route` decorator with the `methods`
    argument, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要支持特定的方法，允许你向端点`POST`或`DELETE`一些数据，你可以通过`methods`参数将它们传递给`route`装饰器，如下所示：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note that the `OPTIONS` and `HEAD` methods are implicitly added in all rules
    since it is automatically managed by the request handler. You can deactivate this
    behavior by giving the `provide_automatic_options=False` argument to the `route`
    function. This can be useful when you want to add custom headers to the response
    when `OPTIONS` is called, such as when dealing with **Cross-Origin Resource Sharing**
    (**CORS**), in which you need to add several `Access-Control-Allow-*` headers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于请求处理器自动管理，所有规则中都会隐式添加`OPTIONS`和`HEAD`方法。你可以通过将`provide_automatic_options=False`参数传递给`route`函数来禁用此行为。这在你想要在`OPTIONS`被调用时向响应添加自定义头时很有用，例如在处理**跨源资源共享**（**CORS**）时，你需要添加几个`Access-Control-Allow-*`头。
- en: 'For more information regarding `HTTP` request methods, a good resource is the
    Mozilla Developer Network: [https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`HTTP`请求方法的更多信息，一个很好的资源是Mozilla开发者网络：[https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods).
- en: Variables and converters
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量和转换器
- en: A common requirement for an API is the ability to specify exactly which data
    we want to request. For example, if you have a system where each person has a
    unique number to identify them, you might want to create a function that handles
    all requests sent to the `/person/N` endpoint, so that `/person/3` only deals
    with ID number `3`, and `/person/412` only affects the person with ID `412`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于API的一个常见要求是能够指定我们想要请求的确切数据。例如，如果你有一个系统中每个人都有一个唯一的数字来识别他们，你可能会想创建一个处理发送到`/person/N`端点的所有请求的函数，这样`/person/3`只处理ID号为`3`的人，而`/person/412`只影响ID为`412`的人。
- en: 'You can do this with variables in the `route`, using the `<VARIABLE_NAME>`
    syntax. This notation is pretty standard (`Bottle` also uses it), and allows you
    to describe endpoints with dynamic values. If we create a `route` such as `/person/<person_id>`,
    then, when Quart calls your function, it converts the value it finds in the URL
    to a function argument with the same name:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`route`中的变量来做这件事，使用`<VARIABLE_NAME>`语法。这种表示法相当标准（`Bottle`也使用它），允许你用动态值描述端点。如果我们创建一个`route`，例如`/person/<person_id>`，那么，当Quart调用你的函数时，它会将URL中找到的值转换为具有相同名称的函数参数：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you have several routes that match the same URL, the mapper uses a particular
    set of rules to determine which one it calls. `Quart` and `Flask` both use `Werkzeug`
    to organize their routing; this is the implementation description taken from Werkzeug''s
    routing module:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有几个匹配相同URL的路由，映射器会使用一组特定的规则来确定调用哪个。`Quart`和`Flask`都使用`Werkzeug`来组织它们的路由；这是从Werkzeug的路由模块中摘取的实现描述：
- en: Rules without any arguments come first for performance. This is because we expect
    them to match faster and some common rules usually don't have any arguments (index
    pages, and so on).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 没有参数的规则优先考虑性能。这是因为我们期望它们匹配得更快，一些常见的规则通常没有参数（索引页面等）。
- en: The more complex rules come first, so the second argument is the negative length
    of the number of weights.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更复杂的规则优先，因此第二个参数是权重的负数。
- en: Lastly, we order by the actual weights.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们按实际权重排序。
- en: Werkzeug's rules have, therefore, weights that are used to sort them, and this
    is not used or made visible in Quart. So, it boils down to picking views with
    more variables first, and then the others, in order of appearance, when Python
    imports the different modules. The rule of thumb is to make sure that every declared
    route in your app is unique, otherwise tracking which one gets picked will give
    you a headache.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Werkzeug的规则有用于排序的权重，而在Quart中这些权重既没有被使用也没有被显示。所以，这归结为首先选择变量较多的视图，然后按出现顺序选择其他视图，当Python导入不同的模块时。一个经验法则是确保你的应用程序中声明的每个路由都是唯一的，否则追踪哪个被选中会让你头疼。
- en: This also means that our new route will not respond to queries sent to `/person`,
    or `/person/3/help`, or any other variation—only to `/person/` followed by some
    set of characters. Characters include letters and punctuation, though, and we
    have already decided that `/api/apiperson_id` is a number! This is where converters
    are useful.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着我们的新路由不会对发送到`/person`、`/person/3/help`或任何其他变体的查询做出响应——只对`/person/`后面跟一些字符集的查询做出响应。然而，字符包括字母和标点符号，而且我们已经决定`/api/apiperson_id`是一个数字！这就是转换器有用的地方。
- en: 'We can tell the `route` that a variable has a specific type. Since `/api/apiperson_id`
    is an integer, we can use `<int:person_id>`, as in the previous example, so that
    our code only responds when we give a number, and not when we give a name. You
    can also see that instead of the string `"3"`, `person_id` is a number, with no
    quotes:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以告诉`route`一个变量具有特定的类型。由于`/api/apiperson_id`是一个整数，我们可以使用`<int:person_id>`，就像前面的例子一样，这样我们的代码只有在给出数字时才响应，而不是给出名称时。你还可以看到，与字符串`"3"`不同，`person_id`是一个没有引号的数字：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If we had two routes, one for `/person/<int:person_id>` and one for `/person/<person_id>`
    (with different function names!), then the more specific one, which needs an integer,
    would get all the requests that had a number in the right place, and the other
    function would get the remaining requests.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个路由，一个用于 `/person/<int:person_id>`，另一个用于 `/person/<person_id>`（具有不同的函数名！），那么需要整数的更具体的一个将获取所有在正确位置有数字的请求，而另一个函数将获取剩余的请求。
- en: Built-in converters are `string` (the default is a Unicode string), `int`, `float`,
    `path`, `any`, and `uuid`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 内置转换器包括 `string`（默认为 Unicode 字符串）、`int`、`float`、`path`、`any` 和 `uuid`。
- en: The path converter is like the default converter, but includes forward slashes,
    so that a request to a URL, `/api/some/path/like/this`, would match the route
    `/api/<path:my_path>`, and the function would get an argument called `my_path`
    containing `some/path/like/this`. If you are familiar with regular expressions,
    it's similar to matching `[^/].*?`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 路径转换器类似于默认转换器，但包括正斜杠，因此对 URL 的请求，如 `/api/some/path/like/this`，将匹配路由 `/api/<path:my_path>`，函数将获得一个名为
    `my_path` 的参数，其中包含 `some/path/like/this`。如果你熟悉正则表达式，它类似于匹配 `[^/].*?`。
- en: '`int` and `float` are for integers and floating-point—decimal—numbers. The
    `any` converter allows you to combine several values. It can be a bit confusing
    to use at first, but it might be useful if you need to route several specific
    strings to the same place. A route of `/<any(about, help, contact):page_name>`
    will match requests to `/about`, `/help`, or `/contact`, and which one was chosen
    will be in the `page_name` variable passed to the function.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`int` 和 `float` 用于整数和浮点数——十进制数。`any` 转换器允许你组合多个值。一开始使用可能会有些困惑，但如果你需要将几个特定的字符串路由到同一位置，它可能很有用。路由
    `/<any(about, help, contact):page_name>` 将匹配对 `/about`、`/help` 或 `/contact` 的请求，并且所选的哪一个将包含在传递给函数的
    `page_name` 变量中。'
- en: The `uuid` converter matches the UUID strings, such as those that you get from
    Python's `uuid` module, providing unique identifiers. Examples of all these converters
    in action are also in the code samples for this chapter on GitHub.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`uuid` 转换器匹配 UUID 字符串，例如从 Python 的 `uuid` 模块中获得的字符串，提供唯一的标识符。所有这些转换器在实际操作中的示例也包含在本章的
    GitHub 代码示例中。'
- en: 'It''s quite easy to create your custom converter. For example, if you want
    to match user IDs with usernames, you could create a converter that looks up a
    database and converts the integer into a username. To do this, you need to create
    a class derived from the `BaseConverter` class, which implements two methods:
    the `to_python()` method to convert the value to a Python object for the view,
    and the `to_url()` method to go the other way (used by `url_for()`, which is described
    in the next section):'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义转换器相当简单。例如，如果你想匹配用户 ID 和用户名，你可以创建一个查找数据库并将整数转换为用户名的转换器。为此，你需要创建一个从 `BaseConverter`
    类派生的类，该类实现两个方法：`to_python()` 方法将值转换为视图的 Python 对象，以及 `to_url()` 方法用于反向转换（由 `url_for()`
    使用，将在下一节中描述）：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ValidationError` method is raised in case the conversion fails, and the
    mapper will consider that the `route` simply does not match that request. Let''s
    try a few calls to see how that works in practice:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果转换失败，将引发 `ValidationError` 方法，映射器将考虑该 `route` 简单地不匹配该请求。让我们尝试几个调用，看看它在实际中是如何工作的：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Be aware that the above is just an example of demonstrating the power of converters—an
    API that handles personal information in this way could give a lot of information
    away to malicious people. It can also be painful to change all the routes when
    the code evolves, so it is best to only use this sort of technique when necessary.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，上面的只是一个展示转换器强大功能的示例——一个以这种方式处理个人信息的 API 可能会向恶意人员泄露大量信息。当代码演变时，更改所有路由也可能很痛苦，因此最好只在必要时使用这种技术。
- en: The best practice for routing is to keep it as static and straightforward as
    possible. This is especially true as moving all the endpoints requires changing
    all of the software that connects to them! It is often a good idea to include
    a version in the URL for an endpoint so that it is immediately clear that the
    behavior will be different between, for example, `/v1/person` and `/v2/person`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 路由的最佳实践是尽可能保持其静态和直接。这一点在移动所有端点需要更改所有连接到它们的软件时尤其正确！通常，在端点的 URL 中包含一个版本号是一个好主意，这样就可以立即清楚地知道，例如
    `/v1/person` 和 `/v2/person` 之间的行为将有所不同。
- en: The url_for function
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`url_for` 函数'
- en: 'The last interesting feature of Quart''s routing system is the `url_for()`
    function. Given any view, it will return its actual URL. Here''s an example of
    using Python interactively:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Quart的路由系统的最后一个有趣特性是`url_for()`函数。给定任何视图，它将返回其实际URL。以下是一个使用Python交互式使用的示例：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The previous example uses the **Read-Eval-Print Loop** (**REPL**), which you
    can get by running the Python executable directly. There is also some extra code
    there to set up an asynchronous program because here, Quart is not doing that
    for us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例使用了**读取-评估-打印循环**（**REPL**），您可以通过直接运行Python可执行文件来获取它。那里还有一些额外的代码来设置异步程序，因为在这里，Quart不会为我们做这件事。
- en: The `url_for` feature is quite useful in templates when you want to display
    the URLs of some views—depending on the execution context. Instead of hardcoding
    some links, you can just point the function name to `url_for` to get it.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想在模板中显示某些视图的URL时，`url_for`功能非常有用——这取决于执行上下文。您不必硬编码一些链接，只需将函数名指向`url_for`即可获取它。
- en: Request
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求
- en: When a request comes in, Quart calls the view and uses a Request Context to
    make sure that each request has an isolated environment, specific to that request.
    We saw an example of that in the code above, where we were testing things using
    the helper method, `test_request_context()`. In other words, when you access the
    global request object in your view, you are guaranteed that it is unique to the
    handling of your specific request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当收到请求时，Quart调用视图并使用请求上下文来确保每个请求都有一个隔离的环境，特定于该请求。我们在上面的代码中看到了一个例子，我们使用辅助方法`test_request_context()`进行测试。换句话说，当你在视图中访问全局请求对象时，你可以保证它是针对你特定请求的处理。
- en: As we saw earlier when calling `dir(request)`, the `Request` object contains
    a lot of methods when it comes to getting information about what is happening,
    such as the address of the computer making the request, what sort of request it
    is, and other information such as authorization headers. Feel free to experiment
    with some of these request methods using the example code as a starting point.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前在调用`dir(request)`时看到的，当涉及到获取有关正在发生的事情的信息时，`Request`对象包含许多方法，例如请求的计算机地址、请求类型以及其他信息，如授权头。请随意使用示例代码作为起点，实验一些这些请求方法。
- en: 'In the following example, an HTTP Basic Authentication request that is sent
    by the client is always converted to a base64 form when sent to the server. Quart
    will detect the Basic prefix and will parse it into `username` and `password`
    fields in the `request.authorization` attribute:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，客户端发送的HTTP基本认证请求在发送到服务器时始终被转换为base64形式。Quart将检测Basic前缀，并将其解析为`request.authorization`属性中的`username`和`password`字段：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This behavior makes it easy to implement a pluggable authentication system on
    top of the `request` object. Other common request elements, such as cookies and
    files, are all accessible via other attributes, as we will discover throughout
    this book.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为使得在`request`对象之上实现可插拔的认证系统变得容易。其他常见的请求元素，如cookies和files，都可以通过其他属性访问，正如我们将在整本书中了解到的那样。
- en: Response
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应
- en: In many of the previous examples, we have simply returned a Python dictionary
    and left Quart to produce a response for us that the client will understand. Sometimes,
    we have called `jsonify()` to ensure that the result is a JSON object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多之前的示例中，我们只是返回了一个Python字典，并让Quart为我们生成客户端可以理解的响应。有时，我们调用`jsonify()`以确保结果是JSON对象。
- en: 'There are other ways to make a response for our web application, along with
    some other values that are automatically converted to the proper object for us.
    We could return any of the following, and Quart would do the right thing:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以为我们的Web应用程序生成响应，还有一些其他值会自动转换为正确的对象。我们可以返回以下任何一个，Quart都会做正确的事：
- en: '`Response()`: Creates a `Response` object manually.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Response()`：手动创建一个`Response`对象。'
- en: '`str`: A string will be encoded as a text/html object in the response. This
    is especially useful for HTML pages.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`str`：字符串将被编码为响应中的text/html对象。这对于HTML页面特别有用。'
- en: '`dict`: A dictionary will be encoded as application/json using `jsonify()`.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`：字典将被`jsonify()`编码为application/json。'
- en: A generator or asynchronous generator object can be returned so that data can
    be streamed to the client.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以返回一个生成器或异步生成器对象，以便将数据流式传输到客户端。
- en: 'A `(response, status)` tuple: The response will be converted to a `response`
    object if it matches one of the preceding data types, and the status will be the HTTP
    response code used.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `(response, status)` 元组：如果响应匹配前面提到的数据类型之一，它将被转换为 `response` 对象，状态将是使用的 HTTP
    响应代码。
- en: 'A `(response, status, headers)` tuple: The response will be converted, and
    the `response` object will use a dictionary provided as headers that should be
    added to the response.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `(response, status, headers)` 元组：响应将被转换，并且 `response` 对象将使用提供的字典作为头部信息添加到响应中。
- en: In most cases, a microservice will be returning data that some other software
    will interpret and choose how to display, and so we will be returning Python dictionaries
    or using `jsonify()` if we want to return a list or other object that can be serialized
    as JSON.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，一个微服务将返回一些其他软件将解释并选择如何显示的数据，因此如果我们想返回一个列表或其他可以序列化为 JSON 的对象，我们将返回 Python
    字典或使用 `jsonify()`。
- en: 'Here''s an example with YAML, another popular way of representing data: the
    `yamlify()` function will return a `(response, status, headers)` tuple, which
    will be converted by Quart into a proper `Response` object:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 YAML 的示例，YAML 是另一种流行的数据表示方式：`yamlify()` 函数将返回一个 `(response, status,
    headers)` 元组，该元组将被 Quart 转换成一个合适的 `Response` 对象：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The way Quart handles requests can be summarized as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Quart 处理请求的方式可以总结如下：
- en: When the application starts, any function decorated with `@app.route()` is registered
    as a view and stored in `app.url_map`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当应用程序启动时，任何使用 `@app.route()` 装饰的函数都被注册为一个视图并存储在 `app.url_map` 中。
- en: A call is dispatched to the right view depending on its endpoint and method.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据其端点和方法，将调用分配到正确的视图中。
- en: A `Request` object is created in a local, isolated execution context.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个局部、隔离的执行上下文中创建了一个 `Request` 对象。
- en: A `Response` object wraps the content to send back.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个 `Response` 对象封装了要发送的内容。
- en: These four steps are roughly all you need to know to start building apps using
    Quart. The next section will summarize the most important built-in features that
    Quart offers, alongside this request-response mechanism.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个步骤基本上就是你开始使用 Quart 构建应用程序所需了解的全部内容。下一节将总结 Quart 提供的最重要内置功能，以及这种请求-响应机制。
- en: Quart's built-in features
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Quart 的内置功能
- en: 'The previous section gave us a good understanding of how Quart processes a
    request, and that''s good enough to get you started. There are more helpers that
    will prove useful. We''ll discover the following main ones in this section:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节让我们对 Quart 处理请求的方式有了很好的理解，这对您开始使用 Quart 已经足够了。还有更多有用的辅助工具。在本节中，我们将发现以下主要工具：
- en: 'The `session` object: Cookie-based data'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`session` 对象：基于 Cookie 的数据'
- en: '**Globals**: Storing data in the `request` context'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局变量**：在 `request` 上下文中存储数据'
- en: '**Signals**: Sending and intercepting events'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信号**：发送和拦截事件'
- en: '**Extensions and middleware**: Adding features'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展和中间件**：添加功能'
- en: '**Templates**: Building text-based content'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模板**：构建基于文本的内容'
- en: '**Configuring**: Grouping your running options in a `config` file'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：在 `config` 文件中分组你的运行选项'
- en: '**Blueprints**: Organizing your code in namespaces'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**蓝图**：在命名空间中组织你的代码'
- en: '**Error handling and debugging**: Dealing with errors in your app'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理和调试**：处理应用程序中的错误'
- en: The session object
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`session` 对象'
- en: Like the `request` object, Quart creates a `session` object, which is unique
    to the `request` context. It's a dict-like object, which Quart serializes into
    a cookie on the user side. The data contained in the session mapping is dumped
    into a JSON mapping, then compressed using `zlib` to make it smaller, and finally
    encoded in base64.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `request` 对象类似，Quart 创建了一个 `session` 对象，它是 `request` 上下文唯一的。它是一个类似于字典的对象，Quart
    将其序列化成用户端的 cookie。会话映射中包含的数据将被转换为 JSON 映射，然后使用 `zlib` 进行压缩以减小其大小，最后使用 base64 进行编码。
- en: When the `session` gets serialized, the **itsdangerous** ([https://pythonhosted.org/itsdangerous/](https://pythonhosted.org/itsdangerous/))
    library signs the content using a `secret_key` value defined in the application.
    The signing uses **HMAC** ([https://en.wikipedia.org/wiki/Hash-based_message_authentication_code](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code))
    and SHA1.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `session` 被序列化时，**itsdangerous** ([https://pythonhosted.org/itsdangerous/](https://pythonhosted.org/itsdangerous/))
    库使用在应用程序中定义的 `secret_key` 值对内容进行签名。签名使用 **HMAC** ([https://en.wikipedia.org/wiki/Hash-based_message_authentication_code](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code))
    和 SHA1。
- en: This signature, which is added to the data as a suffix, ensures that the client
    cannot tamper with the data that is stored in a cookie unless they know the secret
    key to sign the session value. Note that the data itself is not encrypted. Quart
    will let you customize the signing algorithm to use, but HMAC + SHA1 is good enough
    when you need to store data in cookies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个签名作为数据的后缀添加，确保客户端无法篡改存储在 cookie 中的数据，除非他们知道用于签名会话值的秘密密钥。请注意，数据本身并未加密。Quart
    允许您自定义要使用的签名算法，但在您需要将数据存储在 cookie 中时，HMAC + SHA1 已经足够好了。
- en: However, when you're building microservices that are not producing HTML, you
    rarely rely on cookies as they are specific to web browsers. However, the idea
    of keeping a volatile key-value storage for each user can be extremely useful
    for speeding up some of the server-side work. For instance, if you need to perform
    some database look-ups to get some information pertaining to a user every time
    they connect, caching this information in a `session`-like object on the server
    side and retrieving the values based on their authentication details makes a lot
    of sense.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当您构建不生成 HTML 的微服务时，您很少依赖 cookie，因为它们是特定于网络浏览器的。但是，为每个用户保持一个易失性的键值存储的想法对于加快一些服务器端工作可以非常有用。例如，如果您需要在每次用户连接时执行一些数据库查找以获取与用户相关的信息，那么在服务器端将此信息缓存在一个类似
    `session` 的对象中，并根据其身份验证详细信息检索值是非常有意义的。
- en: Globals
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局变量
- en: As discussed earlier in this chapter, Quart provides a mechanism for storing
    global variables that are unique to a particular `request` context. That is used
    for `request` and `session`, but is also available to store any custom object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所述，Quart 提供了一种机制来存储特定于某个 `request` 上下文的全局变量。这用于 `request` 和 `session`，但也可以用来存储任何自定义对象。
- en: The `quart.g` variable contains all globals, and you can set whatever attributes
    you want on it. In Quart, the `@app.before_request` decorator can be used to point
    to a function that the app will call every time a request is made, just before
    it dispatches the `request` to a view.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`quart.g` 变量包含所有全局变量，您可以在其上设置任何属性。在 Quart 中，可以使用 `@app.before_request` 装饰器指向一个函数，该函数将在每次请求之前被应用程序调用，在将请求分派到视图之前。'
- en: 'It''s a typical pattern in Quart to use `before_request` to set values in the
    globals. That way, all the functions that are called within the request context
    can interact with the special global variable called `g` and get the data. In
    the following example, we copy the `username` provided when the client performs
    an HTTP Basic Authentication in the `user` attribute:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quart 中，使用 `before_request` 来设置全局值是一种典型模式。这样，在请求上下文中调用的所有函数都可以与名为 `g` 的特殊全局变量交互并获取数据。在下面的示例中，我们复制了客户端在执行
    HTTP Basic Authentication 时提供的 `username`，并将其存储在 `user` 属性中：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When a client requests the `/api` view, the `authenticate` function will set
    `g.user` depending on the headers provided:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端请求 `/api` 视图时，`authenticate` 函数将根据提供的头信息设置 `g.user`：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Any data you may think of that's specific to a `request` context, and that would
    be usefully shared throughout your code, can be added to `quart.g`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 任何您可能想到的特定于 `request` 上下文的数据，并且在整个代码中可以有用地共享，都可以添加到 `quart.g` 中。
- en: Signals
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信号
- en: Sometimes in an application, we want to send a message from one place to another,
    when components are not directly connected. One way in which we can send such
    messages is to use signals. Quart integrates with `Blinker` ([https://pythonhosted.org/blinker/](https://pythonhosted.org/blinker/)),
    which is a signal library that lets you subscribe a function to an event.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在应用程序中，我们希望在组件没有直接连接的情况下，从一个地方向另一个地方发送消息。我们可以发送此类消息的一种方式是使用信号。Quart 与 `Blinker`
    ([https://pythonhosted.org/blinker/](https://pythonhosted.org/blinker/)) 集成，这是一个信号库，允许您将函数订阅到事件。
- en: 'Events are instances of the `AsyncNamedSignal` class, which is based on the
    `blinker.base.NamedSignal` class. It is created with a unique label, and Quart
    instantiates 10 of them in version 0.13\. Quart triggers signals at critical moments
    during the processing of a request. Since `Quart` and `Flask` use the same system,
    we can refer to the following full list: [http://flask.pocoo.org/docs/latest/api/#core-signals-list](http://flask.pocoo.org/docs/latest/api/#core-signals-list).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是 `AsyncNamedSignal` 类的实例，该类基于 `blinker.base.NamedSignal` 类。它使用一个唯一的标签创建，Quart
    在 0.13 版本中创建了 10 个这样的实例。Quart 在请求处理的关键时刻触发信号。由于 `Quart` 和 `Flask` 使用相同的系统，我们可以参考以下完整列表：[http://flask.pocoo.org/docs/latest/api/#core-signals-list](http://flask.pocoo.org/docs/latest/api/#core-signals-list)。
- en: Registering to a particular event is done by calling the signal's `connect`
    method. Signals are triggered when some code calls the signal's `send` method.
    The `send` method accepts extra arguments to pass data to all the registered functions.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用信号的`connect`方法来注册特定事件。当某些代码调用信号的`send`方法时，会触发信号。`send`方法接受额外的参数，以便将数据传递给所有已注册的函数。
- en: 'In the following example, we register the finished function to the `request_finished`
    signal. That function will receive the `response` object:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将`finished`函数注册到`request_finished`信号。该函数将接收`response`对象：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `signal` feature is provided by `Blinker`, which is installed by default
    as a dependency when you install `Quart`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal`功能由`Blinker`提供，当你安装`Quart`时，`Blinker`作为依赖项默认安装。'
- en: Some signals implemented in Quart are not useful in microservices, such as the
    ones occurring when the framework renders a template. However, there are some
    interesting signals that Quart triggers throughout the `request` life, which can
    be used to log what's going on. For instance, the `got_request_exception` signal
    is triggered when an exception occurs before the framework does something with
    it. That's how **Sentry**'s ([https://sentry.io](https://sentry.io)) Python client
    hooks itself in to log exceptions.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Quart实现的一些信号在微服务中可能没有用，例如当框架渲染模板时发生的信号。然而，有一些有趣的信号在Quart的整个`request`生命周期中被触发，可以用来记录正在发生的事情。例如，当框架在处理异常之前发生异常时，会触发`got_request_exception`信号。这就是**Sentry**([https://sentry.io](https://sentry.io))的Python客户端如何将自己挂钩以记录异常的方式。
- en: It can also be interesting to implement custom signals in your apps when you
    want to trigger some of your features with events and decouple the code. For example,
    if your microservice produces PDF reports, and you want to have the reports cryptographically
    signed, you could trigger a `report_ready` signal, and have a signer register
    to that event.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想通过事件触发一些功能并解耦代码时，在你的应用程序中实现自定义信号可能也很有趣。例如，如果你的微服务生成PDF报告，并且你想对报告进行加密签名，你可以触发一个`report_ready`信号，并让签名者注册该事件。
- en: One important aspect of the signals implementation is that the registered functions
    are not called in any particular order, and so if there are dependencies between
    the functions that get called, this may cause trouble. If you need to do more
    complex or time-consuming work, then consider using a `queue` such as **RabbitMQ**
    ([https://www.rabbitmq.com/](https://www.rabbitmq.com/)) or one provided by a
    cloud platform such as Amazon Simple Queue Service or Google PubSub to send a
    message to another service. These message queues offer far more options than a
    basic signal and allow two components to communicate easily without even necessarily
    being on the same computer. We will cover an example of message queues in *Chapter
    6*, *Interacting with Other Services*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 信号实现的一个重要方面是，注册的函数不会按任何特定顺序调用，因此如果被调用的函数之间存在依赖关系，这可能会导致问题。如果你需要执行更复杂或耗时的操作，那么考虑使用`queue`，如**RabbitMQ**([https://www.rabbitmq.com/](https://www.rabbitmq.com/))或由云平台如Amazon
    Simple Queue Service或Google PubSub提供的`queue`，将消息发送到另一个服务。这些消息队列提供了比基本信号更多的选项，并允许两个组件轻松通信，甚至不必在相同的计算机上。我们将在*第6章*，*与其他服务交互*中介绍消息队列的示例。
- en: Extensions and middleware
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展和中间件
- en: Quart extensions are simply Python projects that, once installed, provide a
    package or a module named `quart_something`. They can be useful for avoiding having
    to reinvent anything when wanting to do things such as authentication or sending
    an email.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Quart扩展只是Python项目，一旦安装，就提供名为`quart_something`的包或模块。它们在需要执行如身份验证或发送电子邮件等操作时，可以避免重新发明轮子。
- en: 'Because Quart can support some of the extensions available to `Flask`, you
    can often find something to help in Flask''s list of extensions: Search for `Framework::Flask`
    in the Python package index at [https://pypi.org/](https://pypi.org/). To use
    `Flask` extensions, you must first import a `patch` module to ensure that it will
    work. For example, to import Flask''s `login` extension, use the following commands:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`Quart`可以支持一些`Flask`可用的扩展，你通常可以在Flask的扩展列表中找到一些有用的东西：在Python包索引[https://pypi.org/](https://pypi.org/)中搜索`Framework::Flask`。要使用`Flask`扩展，你必须首先导入一个`patch`模块以确保它能够正常工作。例如，要导入Flask的`login`扩展，请使用以下命令：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The most up-to-date list of Flask extensions that are known to work with Quart
    will be at the address below. This is a good place to start looking when searching
    for extra features that your microservice needs: [http://pgjones.gitlab.io/quart/how_to_guides/flask_extensions.html](http://pgjones.gitlab.io/quart/how_to_guides/flask_extensions.html).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 已知与 Quart 兼容的 Flask 扩展的最新列表可以在以下地址找到。这是在寻找你的微服务需要的额外功能时的一个好起点：[http://pgjones.gitlab.io/quart/how_to_guides/flask_extensions.html](http://pgjones.gitlab.io/quart/how_to_guides/flask_extensions.html)。
- en: The other mechanism for extending Quart is to use ASGI or WSGI middleware. These
    extend the application by wrapping themselves around an endpoint and changing
    the data that goes in and comes out again.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展 Quart 的另一种机制是使用 ASGI 或 WSGI 中间件。这些通过围绕端点包装自身来扩展应用程序，并改变进出数据。
- en: 'In the example that follows, the middleware fakes an `X-Forwarded-For` header,
    so the Quart application thinks it''s behind a proxy such as `nginx`. This is
    useful in a testing environment when you want to make sure your application behaves
    properly when it tries to get the remote IP address, since the `remote_addr` attribute
    will get the IP of the proxy, and not the real client. In this example, we have
    to create a new `Headers` object, as the existing one is immutable:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，中间件模拟了一个 `X-Forwarded-For` 标头，这样 Quart 应用程序就会认为它位于一个代理（如 `nginx`）后面。在测试环境中，当你想确保应用程序在尝试获取远程
    IP 地址时表现正常时，这很有用，因为 `remote_addr` 属性将获取代理的 IP 地址，而不是真实客户端的 IP 地址。在这个例子中，我们必须创建一个新的
    `Headers` 对象，因为现有的一个是不可变的：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Notice that we use `app.asgi_app` here to wrap the ASGI application. `app.asgi_app`
    is where the application is stored to let people wrap it in this way. The `send`
    and `receive` parameters are channels through which we can communicate. It's worth
    remembering that if the middleware returns a response to the client, then the
    rest of the `Quart` app will never see the request!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里使用 `app.asgi_app` 来包装 ASGI 应用程序。`app.asgi_app` 是应用程序存储的地方，以便人们可以以这种方式包装它。`send`
    和 `receive` 参数是通过它们我们可以通信的通道。值得记住的是，如果中间件向客户端返回响应，那么 `Quart` 应用程序将永远不会看到该请求！
- en: In most situations, we won't have to write our own middleware, and it will be
    enough to include an extension to add a feature that someone else has produced.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们不需要编写自己的中间件，只需包含一个扩展来添加其他人已经制作的功能就足够了。
- en: Templates
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板
- en: Sending back JSON or YAML documents is easy enough, as we have seen in the examples
    so far. It's also true that most microservices produce machine-readable data and
    if a human needs to read it, the frontend must format it properly, using, for
    example, JavaScript on a web page. In some cases, though, we might need to create
    documents with some layout, whether it's an HTML page, a PDF report, or an email.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所看到的示例，发送回 JSON 或 YAML 文档是足够简单的。同样，大多数微服务产生的是机器可读数据，如果人类需要阅读它，前端必须正确地格式化它，例如在网页上使用
    JavaScript。然而，在某些情况下，我们可能需要创建具有某些布局的文档，无论是 HTML 页面、PDF 报告还是电子邮件。
- en: For anything that's text-based, Quart integrates a template engine called **Jinja**
    ([https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)). You
    will often find examples showing Jinja being used to create HTML documents, but
    it works with any text-based document. Configuration management tools such as
    Ansible use Jinja to create configuration files from a template so that a computer's
    settings can be kept up to date automatically.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何基于文本的内容，Quart 集成了名为 **Jinja** 的模板引擎（[https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)）。你经常会看到示例展示
    Jinja 被用来创建 HTML 文档，但它可以与任何基于文本的文档一起使用。配置管理工具，如 Ansible，使用 Jinja 从模板创建配置文件，以便计算机的设置可以自动保持最新。
- en: Most of the time, Quart will use Jinja to produce HTML documents, email messages,
    or some other piece of communication meant for a human—such as an SMS message
    or a bot that talks to people on tools such as Slack or Discord. Quart provides
    helpers such as `render_template`, which generate responses by picking a Jinja
    template, and provides the output given some data.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，Quart 会使用 Jinja 来生成 HTML 文档、电子邮件消息或其他面向人类的通信内容——例如短信或与 Slack 或 Discord
    等工具上的人交谈的机器人。Quart 提供了如 `render_template` 这样的辅助工具，通过选择一个 Jinja 模板并给出一些数据来生成响应。
- en: 'For example, if your microservice sends emails instead of relying on the standard
    library''s email package to produce the email content, which can be cumbersome,
    you could use Jinja. The following example email template should be saved as `email_template.j2`
    in order for the later code examples to work:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的微服务发送电子邮件而不是依赖于标准库的电子邮件包来生成电子邮件内容，这可能会很繁琐，那么你可以使用 Jinja。以下示例电子邮件模板应该保存为
    `email_template.j2`，以便后续的代码示例能够正常工作：
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Jinja uses double brackets for marking variables that will be replaced by a
    value. Variables can be anything that is passed to Jinja at execution time. You
    can also use Python's `if` and `for` blocks directly in your templates with the
    `{% for x in y % }... {% endfor %}` and `{% if x %}...{% endif %}` notations.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 使用双括号来标记将被值替换的变量。变量可以是执行时传递给 Jinja 的任何内容。你还可以直接在模板中使用 Python 的 `if` 和
    `for` 块，使用 `{% for x in y % }... {% endfor %}` 和 `{% if x %}...{% endif %}` 标记。
- en: 'The following is a Python script that uses the email template to produce an
    entirely valid `RFC 822` message, which you can send via SMTP:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用电子邮件模板生成完全有效的 `RFC 822` 消息的 Python 脚本，你可以通过 SMTP 发送它：
- en: '[PRE26]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `render_email` function uses the `Template` class to generate the email
    using the data provided.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`render_email` 函数使用 `Template` 类来生成电子邮件，使用提供的数据。'
- en: 'Jinja is a powerful tool and comes with many features that would take too much
    space to describe here. If you need to do some templating work in your microservices,
    it is a good choice, also being present in Quart. Check out the following for
    full documentation on Jinja''s features: [https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Jinja 是一个强大的工具，并附带了许多在这里描述会占用太多空间的特性。如果你需要在你的微服务中进行一些模板化工作，它是一个不错的选择，也存在于 Quart
    中。查看以下链接以获取 Jinja 特性的完整文档：[https://jinja.palletsprojects.com/](https://jinja.palletsprojects.com/)。
- en: Configuration
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: When building applications, you will need to expose options to run them, such
    as the information needed to connect to a database, the contact email address
    to use, or any other variable that is specific to a deployment.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，你需要公开运行它们所需的选项，例如连接到数据库所需的信息、要使用的联系电子邮件地址或任何特定于部署的变量。
- en: 'Quart uses a mechanism similar to Django in its configuration approach. The
    `Quart` object comes with an object called `config`, which contains some built-in
    variables, and which can be updated when you start your `Quart` app via your configuration
    objects. For example, you can define a `Config` class in a Python-format file
    as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Quart 在其配置方法上使用了一种类似于 Django 的机制。`Quart` 对象包含一个名为 `config` 的对象，其中包含一些内置变量，并且可以在你启动
    `Quart` 应用程序时通过你的配置对象进行更新。例如，你可以在 Python 格式的文件中定义一个 `Config` 类，如下所示：
- en: '[PRE27]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It can then be loaded from your `app` object using `app.config.from_object`:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用 `app.config.from_object` 从你的 `app` 对象中加载它：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, there are two significant drawbacks when using Python modules as configuration
    files. Firstly, since these configuration modules are Python files, it can be
    tempting to add code to them as well as simple values. By doing so, you will have
    to treat those modules like the rest of the application code; this can be a complicated
    way to ensure that it always produces the right value, especially if the configuration
    is produced with a template! Usually, when an application is deployed, the configuration
    is managed separately from the code.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用 Python 模块作为配置文件时，存在两个显著的缺点。首先，由于这些配置模块是 Python 文件，因此很容易在其中添加代码以及简单的值。这样做的话，你将不得不像对待其他应用程序代码一样对待这些模块；这可能会是一种复杂的方式来确保它始终产生正确的值，尤其是在使用模板生成配置的情况下！通常，当应用程序部署时，配置是独立于代码进行管理的。
- en: Secondly, if another team is in charge of managing the configuration file of
    your application, they will need to edit the Python code to do so. While this
    is usually fine, it makes it increase the chance that some problems will be introduced,
    as it assumes that the other people are familiar with Python and how your application
    is structured. It is often good practice to make sure that someone who just needs
    to change the configuration doesn't also need to know how the code works.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果另一个团队负责管理你的应用程序的配置文件，他们需要编辑 Python 代码来完成这项工作。虽然这通常是可以接受的，但它增加了引入一些问题的可能性，因为它假设其他人熟悉
    Python 以及你的应用程序的结构。通常，确保只需要更改配置的人不需要了解代码的工作方式是一种良好的实践。
- en: 'Since Quart exposes its configuration via `app.config`, it is quite simple
    to load additional options from a JSON, YAML, or other popular text-based configuration
    formats. All of the following examples are equivalent:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Quart 通过 `app.config` 暴露其配置，因此从 JSON、YAML 或其他流行的基于文本的配置格式中加载附加选项相当简单。以下所有示例都是等效的：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can give `from_file` a function to use to understand the data, such as `yaml.safe_load`,
    `toml.load`, and `json.load`. If you prefer the INI format with `[sections]` along
    with `name = value`, then many extensions exist to help, and the standard library's
    `ConfigParser` is also straightforward.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为 `from_file` 提供一个用于理解数据的函数，例如 `yaml.safe_load`、`toml.load` 和 `json.load`。如果你更喜欢带有
    `[sections]` 和 `name = value` 的 INI 格式，那么存在许多扩展来帮助，标准库的 `ConfigParser` 也非常直接。
- en: Blueprints
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 蓝图
- en: When you write microservices that have more than a single endpoint, you will
    end up with a number of different decorated functions—remember those are functions
    with a decorator above, such as `@app.route`. The first logical step to organize
    your code is to have one module per endpoint, and when you create your app instance,
    make sure they get imported so that Quart registers the views.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写具有多个端点的微服务时，你将结束于许多不同的装饰函数——记住那些是带有装饰器的函数，例如 `@app.route`。组织代码的第一个逻辑步骤是每个端点有一个模块，当你创建应用实例时，确保它们被导入，这样
    Quart 就可以注册视图。
- en: 'For example, if your microservice manages a company''s employees database,
    you could have one endpoint to interact with all employees, and one with teams.
    You could organize your application into these three modules:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的微服务管理一个公司的员工数据库，你可以有一个端点用于与所有员工交互，另一个端点用于与团队交互。你可以将你的应用程序组织成这三个模块：
- en: '`app.py`: To contain the `Quart` app object, and to run the app'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`: 包含 `Quart` 应用对象，并运行应用'
- en: '`employees.py`: To provide all the views related to employees'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`employees.py`: 用于提供所有与员工相关的视图'
- en: '`teams.py`: To provide all the views related to teams'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teams.py`: 用于提供所有与团队相关的视图'
- en: From there, employees and teams can be seen as a subset of the app, and might
    have a few specific utilities and configurations. This is a standard way of structuring
    any Python application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，员工和团队可以被视为应用的子集，可能有一些特定的实用程序和配置。这是构建任何 Python 应用程序的标准方式。
- en: 'Blueprints take this logic a step further by providing a way to group your
    views into namespaces, making the structure used in separate files and giving
    it some special framework assistance. You can create a `Blueprint` object that
    looks like a `Quart` app object, and then use it to arrange some views. The initialization
    process can then register blueprints with `app.register_blueprint` to make sure
    that all the views defined in the blueprint are part of the app. A possible implementation
    of the employee''s blueprint could be as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 蓝图通过提供一种将视图分组到命名空间中的方法，进一步扩展了这种逻辑，使得在单独的文件中使用这种结构，并为其提供一些特殊的框架支持。你可以创建一个类似于
    `Quart` 应用对象的 `Blueprint` 对象，然后使用它来安排一些视图。初始化过程可以通过 `app.register_blueprint` 注册蓝图，以确保蓝图定义的所有视图都是应用的一部分。员工蓝图的一个可能实现如下：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The main module (`app.py`) can then import this file, and register its blueprint
    with `app.register_blueprint(teams)`. This mechanism is also interesting when
    you want to reuse a generic set of views in another application or several times
    in the same application—it's easy to imagine a situation where, for example, both
    the inventory management area and a sales area might want to have the same ability
    to look at current stock levels.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 主要模块（`app.py`）可以导入此文件，并使用 `app.register_blueprint(teams)` 注册其蓝图。当你想在另一个应用程序或同一应用程序中多次重用一组通用的视图时，这种机制也非常有趣——可以想象一个场景，例如，库存管理区域和销售区域可能都需要查看当前库存水平的能力。
- en: Error handling
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 错误处理
- en: When something goes wrong in your application, it is important to be able to
    control what responses the clients will receive. In HTML web apps, you usually
    get specific HTML pages when you encounter a `404` (Resource not found) or `5xx`
    (Server error), and that's how Quart works out of the box. But when building microservices,
    you need to have more control of what should be sent back to the client—that's
    where custom error handlers are useful.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序出现问题时，能够控制客户端将接收到的响应是很重要的。在 HTML 网络应用中，当你遇到 `404`（资源未找到）或 `5xx`（服务器错误）时，通常会得到特定的
    HTML 页面，这就是 Quart 默认的工作方式。但在构建微服务时，你需要对应该发送回客户端的内容有更多的控制——这就是自定义错误处理器有用的地方。
- en: The other important feature is the ability to debug your code when an unexpected
    error occurs; Quart comes with a built-in debugger, which can be activated when
    your app runs in debug mode.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要功能是在发生意外错误时调试你的代码；Quart自带一个内置的调试器，可以在你的应用程序以调试模式运行时激活。
- en: Custom error handler
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义错误处理器
- en: 'When your code does not handle an exception, Quart returns an HTTP `500` response
    without providing any specific information, like the traceback. Producing a generic
    error is a safe default behavior to avoid leaking any private information to users
    in the body of the error. The default `500` response is a simple HTML page along
    with the right status code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的代码没有处理异常时，Quart会返回一个HTTP `500`响应，不提供任何特定信息，如跟踪信息。生成通用错误是一个安全的默认行为，以避免在错误信息的正文中向用户泄露任何私人信息。默认的`500`响应是一个简单的HTML页面以及正确的状态码：
- en: '[PRE31]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When implementing microservices using JSON, it is good practice to make sure
    that every response sent to clients, including any exception, is JSON-formatted.
    Consumers of your microservice will expect every response to be machine-parseable.
    It's far better to tell a client that you had an error and have it set up to process
    that message and show it to a human than to give a client something it doesn't
    understand and have it raise its own errors.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用JSON实现微服务时，一个好的做法是确保发送给客户端的每个响应，包括任何异常，都是JSON格式的。你的微服务的消费者期望每个响应都是可机器解析的。告诉客户端你遇到了错误，并让它设置好处理该消息并展示给人类，比给客户端一些他们不理解的东西并让它抛出自己错误要好得多。
- en: Quart lets you customize the app error handling via a couple of functions. The
    first one is the `@app.errorhandler` decorator, which works like `@app.route`.
    But instead of providing an endpoint, the decorator links a function to a specific
    error code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Quart允许你通过几个函数自定义应用程序错误处理。第一个是`@app.errorhandler`装饰器，它的工作方式类似于`@app.route`。但与提供端点不同，装饰器将一个函数链接到一个特定的错误代码。
- en: 'In the following example, we use it to connect a function that will return
    a JSON-formatted error when Quart returns a `500` server response (any code exception):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们使用它来连接一个函数，当Quart返回`500`服务器响应（任何代码异常）时，该函数将返回JSON格式的错误：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Quart will call this error view no matter what exception the code raises. However,
    in case your application issues an HTTP `404` or any other `4xx` or `5xx` response,
    you will be back to the default HTML responses that Quart sends. To make sure
    your app sends JSON for every `4xx` and `5xx` response, we need to register that
    function to each error code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 无论代码抛出什么异常，Quart都会调用这个错误视图。然而，如果你的应用程序返回HTTP `404`或任何其他`4xx`或`5xx`响应，你将回到Quart发送的默认HTML响应。为了确保你的应用程序为每个`4xx`和`5xx`响应发送JSON，我们需要将这个函数注册到每个错误代码。
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `jsonify_errors` function modifies a `Quart` app instance and sets up the
    custom JSON error handler for every `4xx` and `5xx` error that might occur.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonify_errors`函数修改了一个`Quart`应用程序实例，并为可能发生的每个`4xx`和`5xx`错误设置了自定义的JSON错误处理器。'
- en: A microservice skeleton
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务骨架
- en: So far in this chapter, we have looked at how Quart works, and at most of the
    built-in features it provides—all of which we will be using throughout this book.
    One topic we have not yet covered is how to organize the code in your projects,
    and how to instantiate your `Quart` app. Every example so far has used a single
    Python module and the `app.run()` call to run the service.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们探讨了Quart的工作原理，以及它提供的几乎所有内置功能——我们将在整本书中使用这些功能。我们还没有涉及的一个主题是如何组织项目中的代码，以及如何实例化你的`Quart`应用程序。到目前为止的每个示例都使用了一个Python模块和`app.run()`调用来运行服务。
- en: Having everything in a module is possible, but will create a lot of headaches
    unless your code is just a few lines. Since we will want to release and deploy
    the code, it's better to have it inside a Python package so that we can use standard
    packaging tools such as `pip` and `setuptools`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容放在一个模块中是可能的，但除非你的代码只有几行，否则会带来很多麻烦。由于我们希望发布和部署代码，最好将其放在Python包中，这样我们就可以使用标准的打包工具，如`pip`和`setuptools`。
- en: It is also a good idea to organize views into blueprints, and have one module
    per blueprint. This lets us keep better track of what each bit of code does, and
    re-use code whenever possible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将视图组织到蓝图，并为每个蓝图创建一个模块也是一个好主意。这让我们能更好地跟踪每段代码的作用，并在可能的情况下重用代码。
- en: Lastly, the `run()` call can be removed from the code since Quart provides a
    generic run command that looks for an application using information from the `QUART_APP`
    environment variable. Using that runner offers extra options, such as the ability
    to configure the host and port that will be used to run the app without going
    into the settings each time.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，可以从代码中删除 `run()` 调用，因为 Quart 提供了一个通用的运行命令，该命令通过 `QUART_APP` 环境变量的信息查找应用程序。使用该运行器提供了额外的选项，例如，可以在不进入设置的情况下配置用于运行应用程序的主机和端口。
- en: The microservice project on GitHub was created for this book and is a generic
    Quart project that you can use to start a microservice. It implements a simple
    layout, which works well for building microservices. You can install and run,
    and then modify it. The project can be found at [https://github.com/PythonMicroservices/microservice-skeleton](https://github.com/PythonMicroservices/microservice-skeleton).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 上的微服务项目是为本书创建的，是一个通用的 Quart 项目，您可以用它来启动微服务。它实现了一个简单的布局，这对于构建微服务非常有效。您可以安装并运行它，然后对其进行修改。项目可以在
    [https://github.com/PythonMicroservices/microservice-skeleton](https://github.com/PythonMicroservices/microservice-skeleton)
    找到。
- en: 'The `microservice` project skeleton contains the following structure:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`microservice` 项目骨架包含以下结构：'
- en: '`setup.py`: Distutils'' setup file, which is used to install and release the
    project.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup.py`: Distutils 的设置文件，用于安装和发布项目。'
- en: '`Makefile`: A Makefile that contains a few useful targets to make, build, and
    run the project.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Makefile`: 包含一些有用的目标，用于构建、构建和运行项目。'
- en: '`settings.yml`: The application default settings in a YAML file.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`settings.yml`: 在 YAML 文件中的应用默认设置。'
- en: '`requirements.txt`: The project dependencies following the `pip` format produced
    by `pip freeze`.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requirements.txt`: 根据 `pip freeze` 生成的 `pip` 格式的项目依赖。'
- en: '`myservices/`: The actual package'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`myservices/`: 实际的包'
- en: '`__init__.py`'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`app.py`: The app module, which contains the app itself'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.py`: 包含应用程序本身的模块'
- en: '`views/`: A directory containing the views organized in blueprints'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views/`: 包含按蓝图组织视图的目录'
- en: '`__init__.py`'
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`home.py`: The home blueprint, which serves the root endpoint'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`home.py`: 为主蓝图，它服务于根端点'
- en: '`tests/:` The directory containing all the tests'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests/:` 包含所有测试的目录'
- en: '`__init__.py`'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`test_home.py`: Tests for the home blueprint views'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_home.py`: 对主蓝图视图的测试'
- en: 'In the following code, the `app.py` file instantiates a `Quart` app using a
    helper function called `create_app` to register the blueprints and update the
    settings:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，`app.py` 文件使用名为 `create_app` 的辅助函数实例化 `Quart` 应用程序，以注册蓝图并更新设置：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `home.py` view uses a blueprint to create a simple route that doesn''t
    return anything:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`home.py` 视图使用蓝图创建了一个简单的路由，不返回任何内容：'
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This example application can run via Quart''s built-in command line, using
    the package name:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例应用程序可以通过 Quart 内置的命令行运行，使用包名：
- en: '[PRE37]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From there, building JSON views for your microservice consists of adding modules
    to microservices/views, and their corresponding tests.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里开始，为您的微服务构建 JSON 视图包括向微服务/views 添加模块及其相应的测试。
- en: Summary
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter gave us a detailed overview of the Quart framework and how it
    can be used to build microservices. The main things to remember are:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为我们提供了 Quart 框架的详细概述以及如何使用它来构建微服务。需要记住的主要事项是：
- en: Quart wraps a simple request-response mechanism around the ASGI protocol, which
    lets you write your applications in almost vanilla Python.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quart 在 ASGI 协议周围包装了一个简单的请求-响应机制，这使得您几乎可以用纯 Python 编写应用程序。
- en: Quart is easy to extend and can use Flask extensions if required.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quart 很容易扩展，如果需要，可以使用 Flask 扩展。
- en: 'Quart comes with some useful built-in features: blueprints, globals, signals,
    a template engine, and error handlers.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Quart 内置了一些有用的功能：蓝图、全局变量、信号、模板引擎和错误处理器。
- en: The microservice project is a Quart skeleton, which will be used to write microservices
    throughout this book.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务项目是一个 Quart 骨架，本书将使用它来编写微服务。
- en: 'The next chapter will focus on development methodology: how to continuously
    code, test, and document your microservices.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将重点介绍开发方法：如何持续编码、测试和记录您的微服务。
