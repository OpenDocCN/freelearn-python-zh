- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Decorators – Enabling Code Reuse by Decorating
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器 – 通过装饰实现代码重用
- en: In this chapter, you are going to learn about Python decorators. The previous
    chapters have already shown the usage of a few decorators, but you will now find
    out more about them. Decorators are essentially function/class wrappers that can
    be used to modify the input, output, or even the function/class itself before
    executing it. This type of wrapping can just as easily be achieved by having a
    separate function that calls the inner function, or via inheriting small feature
    classes commonly called **mixins**. As is the case with many Python constructs,
    decorators are not the only way to reach the goal but are definitely convenient
    in many cases.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习关于 Python 装饰器的内容。前几章已经展示了几个装饰器的用法，但现在你将了解更多关于它们的信息。装饰器本质上是对函数/类的包装，可以在执行之前修改输入、输出，甚至函数/类本身。这种包装同样可以通过拥有一个调用内部函数的单独函数，或者通过继承通常称为
    **mixins** 的小功能类来实现。与许多 Python 构造一样，装饰器不是达到目标的唯一方法，但在许多情况下确实很方便。
- en: While you can get along fine without knowing too much about decorators, they
    give you a lot of “reuse power” and are therefore used heavily in framework libraries
    such as web frameworks. Python actually comes bundled with some useful decorators,
    most notably the `@property`, `@classmethod`, and `@staticmethod` decorators.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以不用太多了解装饰器就能过得很好，但它们提供了大量的“重用能力”，因此在框架库（如Web框架）中得到了广泛使用。Python 实际上附带了一些有用的装饰器，最著名的是
    `@property`、`@classmethod` 和 `@staticmethod` 装饰器。
- en: 'There are, however, some particularities to take note of: wrapping a function
    creates a new function and makes it harder to reach the inner function and its
    properties. One example of this is the `help(function)` functionality of Python;
    by default, you, your editor, and your documentation generator can lose function
    properties such as the help text and the module the function exists in.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些特定的注意事项需要注意：包装一个函数会创建一个新的函数，并使得访问内部函数及其属性变得更加困难。一个例子是 Python 的 `help(function)`
    功能；默认情况下，你、你的编辑器和你的文档生成器可能会丢失函数属性，如帮助文本和函数所在的模块。
- en: This chapter will cover the usage of both function and class decorators, as
    well as the intricate details you need to know when decorating functions within
    classes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖函数和类装饰器的用法，以及装饰类内函数时需要了解的复杂细节。
- en: 'The following are the topics covered:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些涵盖的主题：
- en: Decorating functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰函数
- en: Decorating class functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰类函数
- en: Decorating classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰类
- en: Useful decorators in the Python Standard Library
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 标准库中的有用装饰器
- en: Decorating functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰函数
- en: 'Decorators are functions or classes that wrap other functions and/or classes.
    In its most basic form, you can view a regular function call as `add(1, 2)`, which
    transforms into `decorator(add(1, 2))` when applying a decorator. There’s slightly
    more to it, but we will come to that later. Let’s implement that `decorator()`
    function:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器是包装其他函数和/或类的函数或类。在其最基本的形式中，你可以将常规函数调用视为 `add(1, 2)`，当应用装饰器时，它将转换为 `decorator(add(1,
    2))`。这还有更多内容，但我们会稍后讨论。让我们来实现这个 `decorator()` 函数：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make the syntax easier to use, Python has a special syntax for this case.
    So, instead of adding a line such as the preceding one below the function, you
    can decorate a function using the `@` operator as a shortcut:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使语法更容易使用，Python 为这种情况提供了一种特殊的语法。因此，你可以在函数下方添加一行，如前面的示例，而不是使用 `@` 操作符作为快捷方式来装饰一个函数：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This example shows the simplest and most useless decorator you can get: simply
    returning the input function and doing nothing else.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了最简单且最无用的装饰器：简单地返回输入函数而不做其他任何事情。
- en: 'From this, you might wonder what the use of a decorator is and what is so special
    about them. Some possibilities of decorators are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，你可能会想知道装饰器的用途以及它们有什么特别之处。装饰器的一些可能性包括：
- en: Registering a function/class
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册函数/类
- en: Modifying function/class input
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改函数/类输入
- en: Modifying function/class output
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改函数/类输出
- en: Logging function calls/class instantiations
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录函数调用/类实例化
- en: All of these will be covered later in this chapter, but let’s start simple for
    now.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容将在本章的后续部分进行介绍，但现在我们先从简单开始。
- en: 'Our first decorator will show how we can modify both the input and the output
    of a function call. Additionally, it adds some `logging` calls so we can see what
    is happening:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个装饰器将展示我们如何修改函数调用的输入和输出。此外，它还添加了一些 `logging` 调用，以便我们可以看到发生了什么：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This should show you how powerful decorators can be. We can modify, add, and/or
    remove arguments. We can modify the return value or even call a completely different
    function if we want to. And we can easily log all behavior if needed, which can
    be very useful when debugging. Instead of `return function(...)`, we can return
    something completely different if we wish.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该能展示出装饰器的强大之处。我们可以修改、添加和/或删除参数。我们可以修改返回值，或者如果我们想的话，甚至可以调用一个完全不同的函数。而且，如果需要，我们可以轻松地记录所有行为，这在调试时非常有用。我们可以返回与
    `return function(...)` 完全不同的内容。
- en: More extensive examples of how to log using decorators are covered in *Chapter
    12,* *Debugging – Solving the Bugs*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于如何使用装饰器进行日志记录的示例，请参阅第 12 章，“调试 – 解决错误”。
- en: Generic function decorators
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用函数装饰器
- en: 'The decorator we wrote earlier explicitly used the `a` and `b` arguments so
    it only works with functions that have a signature very similar to taking `a`
    and `b` arguments. If we want to make the generator more generic, we can replace
    `a, b` with `*args` and `**kwargs` to get the arguments and keyword arguments,
    respectively. That introduces a new problem, however. We either need to make sure
    to only use regular arguments or keyword arguments, or the checking will become
    increasingly difficult:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前编写的装饰器明确使用了 `a` 和 `b` 参数，因此它仅适用于具有非常类似接受 `a` 和 `b` 参数签名的函数。如果我们想使生成器更通用，我们可以将
    `a, b` 替换为 `*args` 和 `**kwargs` 来分别获取位置参数和关键字参数。然而，这引入了一个新问题。我们需要确保只使用常规参数或关键字参数，否则检查将变得越来越困难：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As can be seen, in this case, keyword arguments are broken. To work around
    this issue, we have a few different methods. We can change the arguments to positional-only
    or keyword-only arguments:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在这种情况下，关键字参数被破坏。为了解决这个问题，我们有几种不同的方法。我们可以将参数更改为仅位置参数或仅关键字参数：
- en: This code uses positional-only arguments (the `/` as the last function argument),
    which have been supported since Python 3.8\. For older versions, you can emulate
    this behavior using `*args` instead of explicit arguments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用仅位置参数（`/` 作为最后一个函数参数），这自 Python 3.8 起已被支持。对于旧版本，你可以使用 `*args` 而不是显式参数来模拟此行为。
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or we can make Python automatically take care of this by fetching the signature
    and binding it to the given arguments:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以让 Python 自动处理这个问题，通过获取签名并将其绑定到给定的参数：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By using this method, the function has become a lot more versatile. We could
    easily add arguments to the `add` function and still be sure that the decorator
    functions.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种方法，函数变得更加灵活。我们可以轻松地向 `add` 函数添加参数，并仍然确保装饰器函数正常工作。
- en: The importance of functools.wraps
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`functools.wraps` 的重要性'
- en: 'Whenever you are writing a decorator, always be sure to add `functools.wraps`
    to wrap the inner function. Without wrapping it, you will lose all properties
    from the original function, which can lead to confusion and unexpected behavior.
    Take a look at the following code without `functools.wraps`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 每次编写装饰器时，务必确保添加 `functools.wraps` 以包装内部函数。如果不进行包装，你将失去原始函数的所有属性，这可能导致混淆和意外的行为。看看以下没有
    `functools.wraps` 的代码：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, our `add` method has no documentation anymore and the name is gone. It
    has been renamed `_decorator`. Since we are indeed calling `_decorator`, this
    is understandable, but it’s very inconvenient for code that relies on this information.
    Now we will try the same code with a minor difference; we will use `functools.wraps`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `add` 方法已经没有文档说明，名称也消失了。它已经被重命名为 `_decorator`。由于我们确实在调用 `_decorator`，这是可以理解的，但这对依赖于这些信息的代码来说非常不方便。现在我们将尝试相同的代码，但略有不同；我们将使用
    `functools.wraps`：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Without any further changes, we now have documentation and the expected function
    name. The working of `functools.wraps` is nothing magical; it copies and updates
    several attributes. Specifically, the following attributes are copied:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有进行任何其他更改的情况下，我们现在有了文档和预期的函数名称。`functools.wraps` 的工作原理并不神奇；它复制并更新了几个属性。具体来说，以下属性被复制：
- en: '`__doc__`'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__doc__`'
- en: '`__name__`'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__name__`'
- en: '`__module__`'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__module__`'
- en: '`__annotations__`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__annotations__`'
- en: '`__qualname__`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__qualname__`'
- en: Also, `__dict__` is updated using `_decorator.__dict__.update(add.__dict__)`,
    and a new property called `__wrapped__` is added, which contains the original
    function (`add,` in this case). The actual `wraps` function is available in the
    `functools.py` file of your Python distribution.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`__dict__` 使用 `_decorator.__dict__.update(add.__dict__)` 进行更新，并添加了一个名为 `__wrapped__`
    的新属性，它包含原始函数（在这种情况下是 `add`）。实际的 `wraps` 函数可在你的 Python 发行版的 `functools.py` 文件中找到。
- en: Chaining or nesting decorators
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接或嵌套装饰器
- en: 'Since we’re wrapping functions, there is nothing stopping us from adding multiple
    wrappers. The order is important to keep in mind, though, because the decorators
    are initialized starting from the inside, but are called starting from the outside.
    Additionally, the teardown starts from the inside again:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在包装函数，我们无法阻止添加多个包装器。然而，需要注意的是顺序，因为装饰器是从内部开始初始化的，但却是从外部开始调用的。此外，拆卸也是从内部开始的：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As you can see in the output, the decorators are called from outer to inner
    before running the function and running from inner to outer when processing the
    results.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在输出中看到的，在运行函数之前，装饰器是从外部到内部调用的，而在处理结果时是从内部到外部调用的。
- en: Registering functions using decorators
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用装饰器注册函数
- en: We have seen how calls can be tracked, arguments can be modified, and return
    values can be changed. Now it is time to see how we can use decorators to register
    a function that can be useful for registering plugins, callbacks, and so on.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何跟踪调用，修改参数，以及更改返回值。现在，我们将看到如何使用装饰器注册一个对注册插件、回调等有用的函数。
- en: One situation where this is very useful is a user interface. Let us assume we
    have a GUI that has a button that can be clicked. By creating a system that can
    register callbacks, we can make the button fire a “clicked” signal and connect
    functions to that event.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况在用户界面中非常有用。让我们假设我们有一个GUI，它有一个可以被点击的按钮。通过创建一个可以注册回调的系统，我们可以使按钮触发一个“点击”信号，并将函数连接到该事件。
- en: 'To create an event manager like that, we will now create a class that keeps
    track of all of the registered functions and allows the firing of events:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个类似的事件管理器，我们现在将创建一个类来跟踪所有已注册的函数并允许触发事件：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Firstly, we create the `EventRegistry` class to handle all of the events and
    store all the callbacks. After that, we register a few functions with the registry.
    Lastly, we fire a few events to see if it works as expected.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建`EventRegistry`类来处理所有事件并存储所有回调。之后，我们将一些函数注册到注册表中。最后，我们触发一些事件以查看它是否按预期工作。
- en: 'While this example is rather basic, this pattern can be applied to many scenarios:
    handling events for a web server, letting plugins register themselves for events,
    letting plugins register themselves in an application, and so on.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个示例相当基础，但这种模式可以应用于许多场景：处理网络服务器的事件，让插件注册事件，让插件在应用程序中注册，等等。
- en: Memoization using decorators
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用装饰器的记忆化
- en: Memoization is a simple trick for remembering results to make code run a lot
    faster in specific scenarios. The basic trick here is to store a mapping of the
    input and expected output so that you have to calculate a value only once. One
    of the most common examples of this technique is the naïve (recursive) Fibonacci
    function.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记忆化是一个简单的技巧，用于记住结果，以便在特定场景中使代码运行得更快。这里的技巧是存储输入和预期输出的映射，这样你只需要计算一次值。这种技术最常见的一个例子是简单的（递归）斐波那契函数。
- en: 'The Fibonacci sequence starts from 0 or 1 (depending how you look at it) and
    each consecutive number consists of the sum of the previous two numbers. To illustrate
    the pattern starting from the additions of the initial `0` and `1`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列从0或1开始（这取决于你如何看待它），每个连续的数字都是前两个数字之和。为了说明从初始的`0`和`1`加法开始的模式：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'I will now show how you can build a very basic memoization function decorator,
    and how it can be used:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在将展示如何构建一个非常基本的记忆化函数装饰器，以及如何使用它：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The memoize decorator has to be used without arguments and the cache can be
    introspected as well:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`memoize`装饰器必须无参数使用，并且缓存也可以被检查：'
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When arguments are given, it breaks because the decorator is not built to support
    them:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当给出参数时，它将崩溃，因为装饰器并没有被构建来支持这些参数：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, the arguments need to be hashable to work with this implementation:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，参数需要是可哈希的才能与这个实现一起工作：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: While examples with a small `n` will work easily without memoization, for larger
    numbers it will run for an extremely long time. For `n=2`, the function would
    execute `fibonacci(n - 1)` and `fibonacci(n - 2)` recursively, resulting in exponential
    time complexity. For `n=30`, the Fibonacci function would already be called 2,692,537
    times; at `n=50`, it will stall or even crash your system.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用小的`n`值时，示例将很容易工作而不需要记忆化，但对于较大的数字，它将运行非常长的时间。对于`n=2`，函数将递归地执行`fibonacci(n
    - 1)`和`fibonacci(n - 2)`，导致指数级的时间复杂度。对于`n=30`，斐波那契函数已经被调用2,692,537次；在`n=50`时，它可能会停滞或甚至崩溃你的系统。
- en: Without memoization, the call stack becomes a tree that very quickly grows.
    To illustrate, let’s assume we want to calculate `fibonacci(4)`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 没有缓存的情况下，调用栈会变成一个树，它很快就会迅速增长。为了说明，让我们假设我们想要计算 `fibonacci(4)`。
- en: First, `fibonacci(4)` calls `fibonacci(3)` and `fibonacci(2)`. There’s nothing
    special here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`fibonacci(4)` 调用了 `fibonacci(3)` 和 `fibonacci(2)`。这里没有什么特别之处。
- en: Now, `fibonacci(3)` calls `fibonacci(2)` and `fibonacci(1)`. You will notice
    that we got `fibonacci(2)` for the second time now. `fibonacci(4)` also executed
    it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`fibonacci(3)` 调用了 `fibonacci(2)` 和 `fibonacci(1)`。你会注意到现在我们第二次得到了 `fibonacci(2)`。`fibonacci(4)`
    也执行了它。
- en: That split with each call is exactly the problem. Each function call starts
    two new function calls, which means it doubles for every call. And those double
    again and again until we have reached the end of the calculation.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用时的这种分割正是问题所在。每个函数调用开始两个新的函数调用，这意味着每次调用都会翻倍。而且它们会一次又一次地翻倍，直到我们达到计算的末尾。
- en: Because the memoized version caches the results and only needs to calculate
    every number once, it doesn’t even break a sweat and only needs to execute `31`
    times for `n=30`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓存版本缓存了结果并且只需要计算每个数字一次，它甚至不费吹灰之力，对于 `n=30` 只需要执行 `31` 次。
- en: This decorator also shows how a context can be attached to a function itself.
    In this case, the cache property becomes an attribute of the internal (wrapped
    `fibonacci`) function so that an extra `memoize` decorator for a different object
    won’t clash with any of the other decorated functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器还展示了如何将上下文附加到函数本身。在这种情况下，缓存属性成为内部（包装的 `fibonacci`）函数的一个属性，这样就不会与任何其他装饰的函数发生冲突。
- en: Note, however, that implementing the memoization function yourself is generally
    not that useful anymore since Python introduced `lru_cache` (**least recently
    used cache**) in Python 3.2\. The `lru_cache` is similar to the preceding memoize
    decorator function but a bit more advanced. It maintains a fixed cache size (`128`
    by default) to save memory, and stores statistics so you can check whether the
    cache size should be increased.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，由于 Python 在 3.2 版本中引入了 `lru_cache`（**最近最少使用缓存**），自己实现缓存函数现在通常不再那么有用。`lru_cache`
    与前面的 `memoize` 装饰器函数类似，但更高级。它维护一个固定的缓存大小（默认为 `128`），以节省内存，并存储统计信息，这样你就可以检查是否应该增加缓存大小。
- en: If you are only looking for statistics and have no need for caching, you can
    also set the `maxsize` to `0`. Or if you want to forego the LRU algorithm and
    save everything, you can pass `None` as `maxsize`. With a fixed size, the `lru_cache`
    will keep only the most recently accessed items and discard the oldest once it
    is full.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关心统计信息并且不需要缓存，你也可以将 `maxsize` 设置为 `0`。或者，如果你想放弃 LRU 算法并保存所有内容，可以将 `maxsize`
    传递为 `None`。具有固定大小的 `lru_cache` 将只保留最近访问的项目，并在填满后丢弃最旧的项。
- en: In most cases, I would suggest using `lru_cache` over your own decorator, but
    if you always need to store all items or if you need to process the keys before
    storing them, you can always roll your own. At the very least, it is useful to
    know how to write a decorator like this.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我建议使用 `lru_cache` 而不是你自己的装饰器，但如果你需要存储所有项目或者需要在存储之前处理键，你总是可以自己实现。至少，了解如何编写这样的装饰器是有用的。
- en: 'To demonstrate how `lru_cache` works internally, we will calculate `fibonacci(100)`,
    which would keep our computer busy until the end of the universe without any caching.
    Moreover, to make sure that we can actually see how many times the `fibonacci`
    function is being called, we’ll add an extra decorator that keeps track of the
    count, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 `lru_cache` 内部是如何工作的，我们将计算 `fibonacci(100)`，如果没有缓存，这将使我们的计算机忙碌到宇宙的尽头。此外，为了确保我们实际上可以看到
    `fibonacci` 函数被调用的次数，我们将添加一个额外的装饰器来跟踪计数，如下所示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You might wonder why we need only 101 calls with a cache size of `3`. That’s
    because we recursively require only `n - 1` and `n - 2`, so we have no need for
    a larger cache in this case. If your cache is not performing as expected, the
    cache size might be the culprit.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们只需要 `3` 的缓存大小进行 `101` 次调用。那是因为我们递归地只需要 `n - 1` 和 `n - 2`，所以在这种情况下我们不需要更大的缓存。如果你的缓存没有按预期工作，缓存大小可能是罪魁祸首。
- en: 'Additionally, this example shows the usage of two decorators for a single function.
    You can see these as the layers of an onion. When calling `fibonacci`, the execution
    order is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个例子展示了为单个函数使用两个装饰器的情况。你可以把它们看作是洋葱的层。当调用 `fibonacci` 时，执行顺序如下：
- en: '`functools.lru_cache`'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`functools.lru_cache`'
- en: '`counter`'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`counter`'
- en: '`fibonacci`'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fibonacci`'
- en: Returning the values works in the reverse order, of course; `fibonacci` returns
    its value to `counter`, which passes the value along to `lru_cache`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值的工作顺序是相反的，当然；`fibonacci` 将其值返回给 `counter`，然后 `counter` 将值传递给 `lru_cache`。
- en: Decorators with (optional) arguments
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有（可选）参数的装饰器
- en: The previous examples mostly used simple decorators without any arguments. As
    you have already seen with `lru_cache`, decorators can accept arguments as well
    since they are just regular functions, but this adds an extra layer to a decorator.
    This means that we need to check the decorator arguments to see if they are the
    decorated method or a regular argument. The only caveat is that the optional argument
    should not be callable. If the argument has to be callable, you will need to pass
    it as a keyword argument instead.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子大多使用了不带任何参数的简单装饰器。正如您已经通过 `lru_cache` 看到的，装饰器也可以接受参数，因为它们只是普通的函数，但这给装饰器增加了一个额外的层次。这意味着我们需要检查装饰器的参数，以确定它们是被装饰的方法还是普通参数。唯一的注意事项是可选参数不应该可调用。如果参数必须可调用，您需要将其作为关键字参数传递。
- en: 'The upcoming code shows a decorator that has an optional (keyword) argument
    to the decorator:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码展示了具有可选（关键字）参数的装饰器：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This decorator uses the `callable()` test to see whether the argument is a callable
    such as a function. This method works in many cases, but if for some reason your
    argument to the `add()` decorator is callable, this will break because it will
    be called instead of the function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此装饰器使用 `callable()` 测试来查看参数是否是可调用的，例如函数。这种方法在许多情况下都有效，但如果您的 `add()` 装饰器的参数是可调用的，这将导致错误，因为它将被调用而不是函数。
- en: Whenever you have the choice available, I recommend that you either have a decorator
    with arguments or without them. Having optional arguments makes the flow of the
    function less obvious and slightly harder to debug when issues arise.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您有选择时，我建议您要么使用带参数的装饰器，要么使用不带参数的装饰器。拥有可选参数会使函数的流程不那么明显，当出现问题时，调试稍微困难一些。
- en: Creating decorators using classes
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类创建装饰器
- en: 'Similar to how we create regular function decorators, it is also possible to
    create decorators using classes instead. As is always the case with classes, this
    makes storing data, inheriting, and reuse more convenient than with functions.
    After all, a function is just a callable object and a class can implement the
    callable interface as well. The following decorator works similarly to the `debug`
    decorator we used earlier, but uses a class instead of a regular function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建常规函数装饰器的方式类似，也可以使用类来创建装饰器。正如类总是那样，这使得存储数据、继承和重用比函数更方便。毕竟，函数只是一个可调用对象，而类也可以实现可调用接口。以下装饰器的工作方式与之前使用的
    `debug` 装饰器类似，但使用的是类而不是普通函数：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only notable difference between functions and classes is that `functools.wraps`
    is now replaced with `functools.update_wrapper` in the `__init__` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 函数和类之间唯一的显著区别是，在 `__init__` 方法中，`functools.wraps` 现在由 `functools.update_wrapper`
    替换。
- en: Since class methods have a `self` argument in addition to the regular arguments,
    you might wonder whether decorators will function in that scenario. The next section
    will cover decorator usage within classes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类方法除了常规参数外还有一个 `self` 参数，您可能会想知道装饰器是否会在那种情况下工作。下一节将介绍类内部装饰器的使用。
- en: Decorating class functions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰类函数
- en: 'Decorating class functions is very similar to regular functions, but you need
    to be aware of the required first argument, `self`—the class instance. You have
    most likely already used a few class function decorators. The `classmethod`, `staticmethod`,
    and `property` decorators, for example, are used in many different projects. To
    explain how all this works, we will build our own versions of the `classmethod`,
    `staticmethod`, and `property` decorators. First, let’s look at a simple decorator
    for class functions to demonstrate the difference from regular decorators:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰类函数与常规函数非常相似，但您需要意识到所需的首个参数 `self`——类实例。您可能已经使用了一些类函数装饰器。例如，`classmethod`、`staticmethod`
    和 `property` 装饰器在许多不同的项目中都有使用。为了解释这一切是如何工作的，我们将构建自己的 `classmethod`、`staticmethod`
    和 `property` 装饰器版本。首先，让我们看看一个简单的类函数装饰器，以展示它与常规装饰器的区别：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As is the case with regular functions, the class function decorator now gets
    passed along `self` as the instance. Nothing unexpected!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如常规函数的情况一样，类函数装饰器现在将 `self` 作为实例传递。没有什么意外的！
- en: Skipping the instance – classmethod and staticmethod
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跳过实例 – 类方法和静态方法
- en: The difference between a `classmethod` and a `staticmethod` is fairly simple.
    The `classmethod` passes a class object instead of a class instance (`self`),
    and `staticmethod` skips both the class and the instance entirely. This effectively
    makes `staticmethod` very similar to a regular function outside of a class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`classmethod` 和 `staticmethod` 之间的区别相当简单。`classmethod` 传递一个类对象而不是类实例（`self`），而
    `staticmethod` 完全跳过类和实例。这实际上使得 `staticmethod` 在类外部与普通函数非常相似。'
- en: In the following examples, we will use `pprint.pprint(... width=60)` to account
    for the width of the book. Additionally, `locals()` is a Python built-in that
    shows all local variables. Similarly, a `globals()` function is also available.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用 `pprint.pprint(... width=60)` 来考虑书籍的宽度。此外，`locals()` 是 Python 的内置函数，显示所有局部变量。同样，`globals()`
    函数也是可用的。
- en: 'Before we recreate `classmethod` and `staticmethod`, we need to take a look
    at the expected behavior of these methods:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重新创建 `classmethod` 和 `staticmethod` 之前，我们需要看一下这些方法的预期行为：
- en: '[PRE19]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following examples will use the example above to illustrate the difference
    between a regular (class instance) method, a `classmethod`, and a `staticmethod`.
    Be wary of the difference between `spam` (lowercase) the instance and `Spam` (capitalized)
    the class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将使用上面的示例来说明普通（类实例）方法、`classmethod` 和 `staticmethod` 之间的区别。请注意 `spam`（小写）的实例和
    `Spam`（大写）的类之间的区别：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In particular, the last example is rather tricky. Because we passed some arguments
    to the function, these have automatically been passed as the `self` argument.
    Similarly, the last example shows how you can use this argument handling to call
    a method using a given instance. `Spam.some_instancemethod(spam)` is identical
    to `spam.some_instancemethod()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，最后一个示例相当棘手。因为我们向函数传递了一些参数，这些参数自动作为 `self` 参数传递。同样，最后一个示例展示了如何使用这个参数处理来使用给定的实例调用方法。`Spam.some_instancemethod(spam)`
    与 `spam.some_instancemethod()` 相同。
- en: 'Now let’s look at the `classmethod`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `classmethod`：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The main difference here is that instead of `self` we now have `cls`, which
    contains the class (`Spam`) instead of the instance (`spam`).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 主要区别在于，我们现在有 `cls` 而不是 `self`，它包含类（`Spam`）而不是实例（`spam`）。
- en: The names `self` and `cls` are conventions and are not enforced in any way.
    You could easily call them `s` and `c` or something completely different instead.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 和 `cls` 是约定俗成的命名，并且没有任何强制要求。你可以轻松地将它们命名为 `s` 和 `c` 或者其他完全不同的名称。'
- en: Next up is the `staticmethod`. The `staticmethod` behaves identically to a regular
    function outside of a class.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `staticmethod`。`staticmethod` 在类外部表现得与普通函数相同。
- en: '[PRE22]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Before we can continue with decorators, you need to be aware of how Python
    descriptors function. Descriptors can be used to modify the binding behavior of
    object attributes. This means that if a descriptor is used as the value of an
    attribute, you can modify which value is being set, got, and deleted when these
    operations are called on the attribute. Here is a basic example of this behavior:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续使用装饰器之前，你需要了解 Python 描述符是如何工作的。描述符可以用来修改对象属性的绑定行为。这意味着如果描述符被用作属性值，你可以在这些操作被调用时修改设置的值、获取的值和删除的值。以下是一个基本示例：
- en: '[PRE23]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see, whenever we set or get values from `sandwich.spam`, it actually
    calls `__get__` or `__set__` on `Spam`, which has access not only to its own variables,
    but also the calling class. A very useful feature for automatic conversions and
    type checking, the `property` decorator we will see in the next section is just
    a more convenient implementation of this technique.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每次我们从 `sandwich.spam` 设置或获取值时，实际上是在调用 `Spam` 的 `__get__` 或 `__set__`，它不仅有权访问自己的变量，还可以访问调用类。这是一个非常有用的特性，对于自动转换和类型检查非常有用，我们将在下一节中看到的
    `property` 装饰器只是这种技术的更方便的实现。
- en: 'Now that you know how descriptors work, we can continue with creating the `classmethod`
    and `staticmethod` decorators. For these two, we simply need to modify `__get__`
    instead of `__call__` so that we can control which type of instance (or none at
    all) is passed along:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了描述符的工作原理，我们可以继续创建 `classmethod` 和 `staticmethod` 装饰器。对于这两个装饰器，我们只需要修改
    `__get__` 而不是 `__call__`，这样我们就可以控制传递的类型实例（或根本不传递）：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `ClassMethod` decorator still features a sub-function to actually produce
    a working decorator. Looking at the function, you can most likely guess how it
    functions. Instead of passing `instance` as the first argument to `self.method`,
    it passes `cls`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClassMethod` 装饰器仍然具有一个子函数来实际生成一个可工作的装饰器。查看该函数，你很可能会猜到它是如何工作的。它不是将 `instance`
    作为 `self.method` 的第一个参数传递，而是传递 `cls`。'
- en: '`StaticMethod` is even simpler, because it completely ignores both the `instance`
    and the `cls`. It can just return the original method unmodified. Because it returns
    the original method without any modifications, we have no need for the `functools.wraps`
    call either.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`StaticMethod` 更简单，因为它完全忽略了 `instance` 和 `cls`。它可以返回未经修改的原始方法。因为它返回的是未经修改的原始方法，所以我们不需要
    `functools.wraps` 调用。'
- en: Properties – Smart descriptor usage
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性 - 智能描述符使用
- en: The `property` decorator is probably the most used decorator in Python land.
    It allows you to add getters/setters to existing instance properties so that you
    can add validators and modify your values before setting them to your instance
    properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 装饰器可能是 Python 中使用最广泛的装饰器。它允许你向现有实例属性添加获取器和设置器，这样你就可以添加验证器并在将值设置到实例属性之前修改它们。'
- en: The `property` decorator can be used both as an assignment and as a decorator.
    The following example shows both syntaxes so that you know what to expect from
    the `property` decorator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`property` 装饰器既可以作为赋值使用，也可以作为装饰器使用。以下示例展示了两种语法，以便你知道 `property` 装饰器可以期待什么。'
- en: Python 3.8 added `functools.cached_property`, which functions the same as `property`
    but executes only once per instance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.8 添加了 `functools.cached_property`，该函数与 `property` 功能相同，但每个实例只执行一次。
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Similar to how we implemented the `classmethod` and `staticmethod` decorators,
    we need the Python descriptors again. This time, we require the full power of
    the descriptors, not just `__get__` but `__set__` and `__delete__` as well. For
    brevity, however, we will skip handling the documentation and some error handling:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们实现 `classmethod` 和 `staticmethod` 装饰器的方式，我们再次需要 Python 描述符。这次，我们需要描述符的全部功能，不仅仅是
    `__get__`，还包括 `__set__` 和 `__delete__`。然而，为了简洁起见，我们将跳过处理文档和一些错误处理：
- en: '[PRE26]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: That doesn’t look all that complicated, does it? The descriptors make up most
    of the code, which is fairly straight to the point. Only the `getter`/`setter`/`deleter`
    functions might look a bit strange, but they’re actually fairly straightforward
    as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来并不那么复杂，对吧？描述符构成了大部分代码，相当直接。只有 `getter`/`setter`/`deleter` 函数可能看起来有点奇怪，但它们实际上也很直接。
- en: To make sure the `property` still works as expected, the class returns a new
    `Property` instance while copying the other methods. The only small caveat to
    make this work here is the `return self` in the `__get__` method.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `property` 仍然按预期工作，类在复制其他方法的同时返回一个新的 `Property` 实例。这里要使这个功能正常工作的小提示是在 `__get__`
    方法中的 `return self`。
- en: '[PRE27]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As expected, our `Property` decorator works as it should. But note that this
    is a more limited version of the built-in `property` decorator; our version has
    no checking for edge cases.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们的 `Property` 装饰器按预期工作。但请注意，这是一个比内置的 `property` 装饰器更有限的版本；我们的版本没有对边缘情况进行检查。
- en: 'Naturally, being Python, there are more methods of achieving the effect of
    properties. In the previous examples, you saw the bare descriptor implementation,
    and in our previous example, you saw the `property` decorator. Now we will look
    at a generic solution by implementing `__getattr__` or `__getattribute__`. Here’s
    a simple demonstration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，作为 Python，有更多方法可以达到属性的效果。在先前的例子中，你看到了裸描述符实现，在我们的先前的例子中，你看到了 `property` 装饰器。现在我们将通过实现
    `__getattr__` 或 `__getattribute__` 来查看一个通用的解决方案。以下是一个简单的演示：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `__getattr__` method looks for existing attributes, for example, it checks
    whether the key exists in `instance.__dict__`, and is called only if it does not
    exist. That’s why we never see a `__getattr__` for the registry attribute. The
    `__getattribute__` method is called in all cases, which makes it a bit more dangerous
    to use. With the `__getattribute__` method, you will need a specific exclusion
    for `registry` since it will be executed infinitely through recursion if you try
    to access `self.registry`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__` 方法查找现有属性，例如，它检查键是否存在于 `instance.__dict__` 中，并且仅在它不存在时调用。这就是为什么我们从未看到对注册属性的
    `__getattr__` 的调用。`__getattribute__` 方法在所有情况下都会被调用，这使得它使用起来稍微有些危险。使用 `__getattribute__`
    方法时，你需要对 `registry` 进行特定的排除，因为它在尝试访问 `self.registry` 时会无限递归执行。'
- en: There is rarely a need to look at descriptors, but they are used by several
    internal Python processes, such as the `super()` method when inheriting classes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有必要查看描述符，但它们被几个内部Python进程使用，例如在继承类时使用的`super()`方法。
- en: Now that you know how to create decorators for regular functions and class methods,
    let’s continue by decorating entire classes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何为常规函数和类方法创建装饰器，让我们继续通过装饰整个类来继续。
- en: Decorating classes
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰类
- en: Python 2.6 introduced the class decorator syntax. As is the case with the function
    decorator syntax, this is not really a new technique either. Even without the
    syntax, a class can be decorated simply by executing `DecoratedClass = decorator(RegularClass)`.
    After the previous sections, you should be familiar with writing decorators. Class
    decorators are no different from regular ones, except for the fact that they take
    a class instead of a function. As is the case with functions, this happens at
    declaration time and *not* at instantiating/calling time.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Python 2.6引入了类装饰器语法。与函数装饰器语法一样，这也不是一项新技术。即使没有语法，也可以通过执行`DecoratedClass = decorator(RegularClass)`简单地装饰一个类。在之前的章节中，你应该已经熟悉了编写装饰器。类装饰器与常规装饰器没有区别，只是它们接受一个类而不是一个函数。与函数一样，这发生在声明时间，而不是在实例化/调用时间。
- en: Because there are quite a few alternative ways to modify how classes work, such
    as standard inheritance, mixins, and metaclasses (read more in *Chapter 8*, *Metaclasses
    – Making Classes (Not Instances) Smarter*), class decorators are never strictly
    needed. This does not reduce their usefulness, but it does offer an explanation
    of why you will most likely not see too many examples of class decorating in the
    wild.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有相当多的方法可以修改类的工作方式，例如标准继承、混入和元类（更多内容请参阅*第8章*，*元类 – 使类（而非实例）更智能*），类装饰器从未是严格必需的。这并不减少它们的有用性，但它确实解释了为什么你不太可能看到太多类装饰的示例。
- en: Singletons – Classes with a single instance
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单例 – 只有一个实例的类
- en: 'Singletons are classes that always allow only a single instance to exist. So,
    instead of getting an instance specifically for your call, you always get the
    same one. This can be very useful for things such as a database connection pool,
    where you don’t want to keep opening connections all of the time but want to reuse
    the original ones:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 单例是始终只允许存在一个实例的类。因此，你总是得到同一个实例，而不是为你的调用获取一个特定的实例。这对于像数据库连接池这样的东西非常有用，你不想总是打开连接，但想重用原始的连接：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see in the `a is b` comparison, both objects have the same identity,
    so we can conclude that they are indeed the same object. As is the case with regular
    decorators, due to the `functools.wraps` functionality, we can still access the
    original class through `Spam.__wrapped__` if needed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在`a is b`比较中看到的，两个对象具有相同的身份，因此我们可以得出结论，它们确实是同一个对象。正如常规装饰器的情况一样，由于`functools.wraps`功能，如果需要，我们仍然可以通过`Spam.__wrapped__`访问原始类。
- en: The `is` operator compares objects by identity, which is implemented as the
    memory address in CPython. If `a is b` returns `True`, we can conclude that both
    `a` and `b` are the same instance.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符通过身份比较对象，这在CPython中实现为内存地址。如果`a is b`返回`True`，我们可以得出结论，`a`和`b`是同一个实例。'
- en: Total ordering – Making classes sortable
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全排序 – 使类可排序
- en: At some point or the other, you have probably needed to sort data structures.
    While this is easily achievable using the key parameter of the `sorted` function,
    there is a more convenient way if you need to do this often—by implementing the
    `__gt__`, `__ge__`, `__lt__`, `__le__`, and `__eq__` functions. That seems a bit
    verbose, doesn’t it? If you want the best performance, it’s still a good idea,
    but if you can take a tiny performance hit and some slightly more complicated
    stack traces, then `total_ordering` might be a nice alternative.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，你可能需要排序数据结构。虽然使用`sorted`函数的键参数可以轻松实现这一点，但如果需要经常这样做，有一个更方便的方法——通过实现`__gt__`、`__ge__`、`__lt__`、`__le__`和`__eq__`函数。这听起来有点冗长，不是吗？如果你想获得最佳性能，这仍然是一个好主意，但如果你可以接受一点性能损失和一些稍微复杂一点的堆栈跟踪，那么`total_ordering`可能是一个不错的选择。
- en: 'The `total_ordering` class decorator can implement all required sort functions
    based on a class that possesses an `__eq__` function and one of the comparison
    functions (`__lt__`, `__le__`, `__gt__`, or `__ge__`). This means you can seriously
    shorten your function definitions. Let’s compare the regular function definition
    and the function definition using the `total_ordering` decorator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`total_ordering` 类装饰器可以根据具有 `__eq__` 函数和其中一个比较函数（`__lt__`、`__le__`、`__gt__`
    或 `__ge__`）的类实现所有所需的排序函数。这意味着你可以大大缩短你的函数定义。让我们比较一下常规函数定义和使用 `total_ordering` 装饰器的函数定义：'
- en: '[PRE30]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As you can see, without `functools.total_ordering`, it’s quite a bit of work
    to create a fully sortable class. Now we will test whether they actually sort
    in a similar way:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，没有 `functools.total_ordering`，创建一个完全可排序的类需要相当多的工作。现在我们将测试它们是否确实以类似的方式排序：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you might be wondering, “Why isn’t there a class decorator to make a class
    sortable using a specified key property?” Well, that might indeed be a good idea
    for the `functools` library, but it isn’t there yet. So, let’s see how we would
    implement something like it while still using `functools.total_ordering`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能想知道，“为什么没有类装饰器可以用来通过指定的键属性使类可排序？”好吧，这确实可能是 `functools` 库的一个好主意，但现在还没有。所以，让我们看看我们如何在仍然使用
    `functools.total_ordering` 的同时实现类似的功能：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Certainly, this greatly simplifies the making of a sortable class. And if you
    would rather have your own key function instead of `getattr`, it’s even easier.
    Simply replace the `getattr(self, attr)` call with `key_function(self)`, do that
    for `other` as well, and change the argument for the decorator to your function.
    You can even use that as the base function and implement `sort_by_attribute` by
    simply passing a wrapped `getattr` function.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这大大简化了创建可排序类的过程。如果你更愿意使用自己的键函数而不是 `getattr`，那就更容易了。只需将 `getattr(self, attr)`
    调用替换为 `key_function(self)`，同样对 `other` 也这样做，并将装饰器的参数更改为你的函数。你甚至可以使用它作为基本函数，并通过简单地传递一个包装的
    `getattr` 函数来实现 `sort_by_attribute`。
- en: Now that you know how to create all types of decorators, let’s look at a few
    useful decorator examples bundled with Python.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何创建所有类型的装饰器，让我们看看 Python 内置的一些有用的装饰器示例。
- en: Useful decorators
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的装饰器
- en: In addition to the ones already mentioned in this chapter, Python comes bundled
    with a few other useful decorators. There are some that aren’t in the standard
    library (yet?).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本章中提到的那些之外，Python 还内置了一些其他有用的装饰器。有些装饰器目前不在标准库中（也许将来会加入）。
- en: Single dispatch – Polymorphism in Python
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单分发 – Python 中的多态
- en: If you’ve used C++ or Java before, you’re probably used to having ad hoc polymorphism
    available—different functions being called depending on the argument types. Python
    being a dynamically typed language, most people would not expect the possibility
    of a single dispatch pattern. Python, however, is a language that is not only
    dynamically typed but also strongly typed, which means we can rely on the type
    we receive.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过 C++ 或 Java，你可能已经习惯了有专门的泛型多态可用——根据参数类型调用不同的函数。Python 作为一种动态类型语言，大多数人不会期望存在单分发模式。然而，Python
    不仅是一种动态类型语言，而且是一种强类型语言，这意味着我们可以依赖我们接收到的类型。
- en: 'A dynamically typed language does not require strict type definitions. While
    a language such as C would require the following to declare an integer:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 动态类型语言不需要严格的类型定义。而像 C 这样的语言需要以下内容来声明一个整数：
- en: '[PRE33]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Python simply accepts that our value has a type:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Python 只是接受我们的值具有类型：
- en: '[PRE34]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Although with type hinting we could also do:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用类型提示来做同样的事情：
- en: '[PRE35]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As opposed to languages such as JavaScript and PHP, however, Python does very
    little implicit type conversion. In Python, the following will return an error,
    whereas JavaScript would execute it without any problems:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与 JavaScript 和 PHP 等语言相比，Python 做的隐式类型转换非常少。在 Python 中，以下将返回错误，而 JavaScript
    会无任何问题执行它：
- en: '[PRE36]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In Python, the result is a `TypeError`. In JavaScript, it’s `'spam5'`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，结果是 `TypeError`。在 JavaScript 中，结果是 `'spam5'`。
- en: The idea of single dispatch is that depending on the type you pass, the correct
    function is called. Since `str + int` results in an error in Python, this can
    be very convenient to automatically convert your arguments before passing them
    to your function. This can be useful for separating the actual workings of your
    function from the type conversions.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 单分发的基本思想是，根据你传递的类型，调用正确的函数。由于在 Python 中 `str + int` 会导致错误，这可以在将参数传递给函数之前自动转换参数变得非常方便。这可以用来将函数的实际工作与类型转换分离。
- en: 'Since Python 3.4, there is a decorator that makes it easily possible to implement
    the single dispatch pattern in Python. This decorator is useful if you need to
    execute different functions depending on the `type()` of your input variable.
    Here is a basic example:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Python 3.4以来，有一个装饰器可以轻松地在Python中实现单分派模式。如果你需要根据输入变量的`type()`执行不同的函数，这个装饰器很有用。以下是一个基本示例：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `singledispatch` decorator automatically calls the correct function for
    the type passed as the first argument. As you can see in the example, this works
    both when using type annotations and if explicit types are passed to the `register`
    function.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`singledispatch`装饰器会自动调用作为第一个参数传递的类型对应的正确函数。正如你在示例中看到的，这在使用类型注解和显式传递类型到`register`函数时都有效。'
- en: 'Let’s see how we could make a simplified version of this method ourselves:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何自己实现这个方法的简化版本：
- en: '[PRE38]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Naturally, this method is a bit basic and it uses a single global registry,
    which limits its application. But this exact pattern can be used for registering
    plugins or callbacks.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 自然地，这种方法有点基础，它使用单个全局注册表，这限制了它的应用。但这个确切的模式可以用来注册插件或回调函数。
- en: When naming the functions, make sure that you do not overwrite the original
    `singledispatch` function. If you named `show_int` as just `show_type`, it would
    overwrite the initial `show_type` function. This would make it impossible to access
    the original `show_type` function and make all `register` operations after that
    fail as well.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名函数时，确保不要覆盖原始的`singledispatch`函数。如果你将`show_int`命名为`show_type`，它将覆盖初始的`show_type`函数。这将使得无法访问原始的`show_type`函数，并导致之后的`register`操作也失败。
- en: 'Now, a slightly more useful example—differentiating between a filename and
    a file handler:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一个稍微有用一点的例子——区分文件名和文件句柄：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So now we have a single `write_as_json` function; it calls the right code depending
    on the type. If it’s a `str` or `bytes` object, it will automatically open the
    file and call the regular version of `write_as_json`, which accepts file objects.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个单一的`write_as_json`函数；它根据类型调用正确的代码。如果它是一个`str`或`bytes`对象，它将自动打开文件并调用`write_as_json`的常规版本，该版本接受文件对象。
- en: Writing a decorator that does this is not that hard to do, of course, but it’s
    still quite convenient to have the `singledispatch` decorator in the base library.
    It most certainly beats manually checking the given argument types with a list
    of `isinstance()` `if`/`elif`/`elif`/`else` statements.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，编写一个执行此操作的装饰器并不难，但仍然很方便在基础库中有`singledispatch`装饰器。它无疑比手动使用`isinstance()`的`if`/`elif`/`elif`/`else`语句检查给定的参数类型要方便得多。
- en: To see which function will be called, you can use the `write_as_json.dispatch`
    function with a specific type. When passing along a `str`, you will get the `write_as_json_filename`
    function. It should be noted that the names of the dispatched functions are completely
    arbitrary. They are accessible as regular functions, of course, but you can name
    them anything you like.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看哪个函数将被调用，你可以使用`write_as_json.dispatch`函数和一个特定的类型。当传递一个`str`时，你会得到`write_as_json_filename`函数。需要注意的是，分派函数的名称完全是任意的。它们当然可以作为常规函数访问，但你喜欢怎么命名就怎么命名。
- en: 'To check the registered types, you can access the registry, which is a dictionary,
    through `write_as_json.registry`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查已注册的类型，你可以通过`write_as_json.registry`访问注册表，它是一个字典：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: contextmanager — with statements made easy
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: contextmanager — 使with语句变得简单
- en: 'Using the `contextmanager` class, we can make the creation of a context wrapper
    very easy. Context wrappers are used whenever you use a `with` statement. One
    example is the `open` function, which works as a context wrapper as well, allowing
    you to use the following code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`contextmanager`类，我们可以使创建上下文包装器变得非常简单。上下文包装器在每次使用`with`语句时都会使用。一个例子是`open`函数，它也作为一个上下文包装器工作，允许你使用以下代码：
- en: '[PRE41]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Let’s just assume for now that the `open` function is not usable as a context
    manager and that we need to build our own function to do this. The standard method
    of creating a context manager is by creating a class that implements the `__enter__`
    and `__exit__` methods:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设现在`open`函数不能用作上下文管理器，我们需要构建自己的函数来完成这个任务。创建上下文管理器的标准方法是通过创建一个实现`__enter__`和`__exit__`方法的类：
- en: '[PRE42]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'While that works perfectly, it’s a tad verbose. With `contextlib.contextmanager`,
    we can have the same behavior in just a few lines:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样工作得很好，但有点冗长。使用`contextlib.contextmanager`，我们可以在几行代码中实现相同的行为：
- en: '[PRE43]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Simple, right? However, I should mention that for this specific case—the closing
    of objects—there is a dedicated function in `contextlib`, and it is even easier
    to use.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吗？然而，我应该提到，对于这个特定的案例——对象的关闭——`contextlib`中有一个专门的函数，而且使用起来甚至更简单。
- en: With `file` objects, database connections, and connections, it is important
    to always have a `close()` call to clean up resources. In the case of a `file`,
    it tells the operating system to write the data to disk (as opposed to temporary
    buffers), and in the case of network connections and database connections, it
    releases the network connection and related resources on both ends. With database
    connections, it will also notify the server that the connection is no longer needed
    so that part is also handled gracefully.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件对象、数据库连接和连接，始终有一个`close()`调用来清理资源是很重要的。在文件的情况下，它告诉操作系统将数据写入磁盘（而不是临时缓冲区），而在网络连接和数据库连接的情况下，它释放两端的网络连接和相关资源。对于数据库连接，它还会通知服务器该连接不再需要，因此这部分也可以优雅地处理。
- en: Without these calls, you can quickly run into “too many open files” or “too
    many connections” errors.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这些调用，你可能会迅速遇到“打开的文件太多”或“连接太多”的错误。
- en: 'Let’s demonstrate it with the most basic example of when `closing()` would
    be useful:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个最基本的情况来演示`closing()`何时会有用：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For a `file` object, you can usually also use `with open(...)` because it is
    a context manager by itself, but if some other part of the code handles the opening,
    you don’t always have that luxury, and in those cases, you will need to close
    it yourself. Additionally, some objects such as requests made by `urllib` don’t
    support automatic closing in that manner and benefit from this function.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于文件对象，你通常也可以使用`with open(...)`，因为它本身就是一个上下文管理器，但如果代码的其他部分处理了打开操作，你就不总是有这种便利，在这些情况下，你需要自己关闭它。此外，一些对象，如`urllib`发出的请求，不支持以这种方式自动关闭，并从中受益于这个函数。
- en: But wait; there’s more! In addition to being usable in a `with` statement, the
    results of a `contextmanager` are actually usable as decorators since Python 3.2\.
    In older Python versions, the `contextmanager` was simply a small wrapper, but
    since Python 3.2 it’s based on the `ContextDecorator` class, which makes it a
    decorator.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等；还有更多！除了可以在`with`语句中使用外，从Python 3.2开始，`contextmanager`的结果实际上也可以用作装饰器。在较老的Python版本中，`contextmanager`只是一个小的包装器，但自从Python
    3.2以来，它基于`ContextDecorator`类，这使得它成为一个装饰器。
- en: 'The `open_context_manager` context manager isn’t really suitable as a decorator
    since it has a `yield <value>` as opposed to an empty `yield` (more about that
    in *Chapter 7*, *Generators and Coroutines – Infinity, One Step at a Time*), but
    we can think of other functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`open_context_manager`上下文管理器并不真正适合作为装饰器，因为它有一个`yield <value>`而不是空的`yield`（更多内容请参阅*第7章*，*生成器和协程
    – 一次一步的无限*），但我们可以考虑其他函数：'
- en: '[PRE45]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: There are quite a few nice use cases for this, but at the very least, it’s just
    a convenient way to wrap a function in a context without all the (nested) `with`
    statements.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个，有很多很好的用例，但至少，它是一个方便地将函数包装在上下文中的方法，而不需要所有的（嵌套）`with`语句。
- en: Validation, type checks, and conversions
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证、类型检查和转换
- en: 'While checking for types is usually not the best way to go in Python, at times
    it can be useful if you know that you will need a specific type (or something
    that can be cast to that type). To facilitate this, Python 3.5 introduced a type
    hinting system so that you can do the following:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在Python中检查类型通常不是最好的方法，但在某些情况下，如果你知道你需要一个特定的类型（或可以转换为该类型的某个东西），它可能是有用的。为了方便起见，Python
    3.5引入了类型提示系统，这样你就可以做以下操作：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In some cases, it can be useful to change these hints into requirements. Instead
    of using an `isinstance()`, we will simply try to enforce the types by casting,
    which is more along the lines of duck-typing.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将提示转换为要求可能是有用的。我们不再使用`isinstance()`，而是简单地通过类型转换来强制执行类型，这更接近鸭子类型。
- en: 'The essence of duck-typing is: if it looks like a duck, walks like a duck,
    and quacks like a duck, it might be a duck. Essentially, this means that we don’t
    care if the value is a `duck` or something else, only if it supports the `quack()`
    method that we need.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型的本质是：如果它看起来像鸭子，走起路来像鸭子，叫起来也像鸭子，那么它可能就是一只鸭子。本质上，这意味着我们不在乎值是`duck`还是其他什么，只要它支持我们需要的`quack()`方法。
- en: 'To enforce the type hints, we can create a decorator:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制执行类型提示，我们可以创建一个装饰器：
- en: '[PRE47]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This is a fairly simple yet very versatile type enforcer that should work with
    most type annotations.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单但非常通用的类型强制器，应该可以与大多数类型注解一起工作。
- en: Useless warnings – How to ignore them safely
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 无用的警告 - 如何安全地忽略它们
- en: 'When writing in Python, warnings are often very useful when you’re actually
    writing the code. When executing it, however, it is not useful to get that same
    message every time you run your script/application. So, let’s create some code
    that allows easy hiding of the expected warnings, but not all of them so that
    we can easily catch new ones:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当用Python编写代码时，警告在编写代码时通常非常有用。然而，在执行时，每次运行你的脚本/应用程序时都收到相同的消息是没有用的。所以，让我们创建一些代码，允许轻松隐藏预期的警告，但不是所有的警告，这样我们就可以轻松捕捉到新的警告：
- en: '[PRE48]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using this method, we can catch the first (expected) warning and still see the
    second (unexpected) warning.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们可以捕捉到第一个（预期的）警告，同时仍然看到第二个（意外的）警告。
- en: Now that you have seen some examples of useful decorators, it is time to continue
    with a few exercises and see how much you can write yourself.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些有用的装饰器示例，是时候继续进行一些练习，看看你能自己写多少了。
- en: Exercises
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Decorators have a huge range of uses, so you can probably think of some yourself
    after reading this chapter, but you can easily elaborate on some of the decorators
    we wrote earlier:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器有巨大的用途范围，所以在阅读完这一章后，你可能自己就能想到一些，但你很容易就可以详细阐述我们之前编写的某些装饰器：
- en: Extend the `track` function to monitor execution time.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`track`函数扩展以监控执行时间。
- en: Extend the `track` function with min/max/average execution time and call count.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`track`函数扩展以包含最小/最大/平均执行时间和调用次数。
- en: Modify the memoization function to function with unhashable types.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改记忆化函数以使其能够处理不可哈希的类型。
- en: Modify the memoization function to have a cache per function instead of a global
    one.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改记忆化函数，使其每个函数都有自己的缓存而不是全局缓存。
- en: Create a version of `functools.cached_property` that can be recalculated as
    needed.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个版本的`functools.cached_property`，可以根据需要重新计算。
- en: Create a single-dispatch decorator that considers all or a configurable number
    of arguments instead of only the first one.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单次调用的装饰器，它考虑所有或可配置数量的参数，而不是只考虑第一个参数。
- en: Enhance the `type_check` decorator to include additional checks such as requiring
    a number to be greater than or less than a given value.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强`type_check`装饰器，包括额外的检查，例如要求一个数字大于或小于给定的值。
- en: 'Example answers for these exercises can be found on GitHub: [https://github.com/mastering-python/exercises](Chapter_6.xhtml).
    You are encouraged to submit your own solutions and learn about alternative solutions
    from others.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这些练习的示例答案可以在GitHub上找到：[https://github.com/mastering-python/exercises](Chapter_6.xhtml)。我们鼓励你提交自己的解决方案，并从他人的替代方案中学习。
- en: Summary
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter showed you some of the places where decorators can be used to make
    our code simpler and add some fairly complex behavior to very simple functions.
    Truthfully, most decorators are more complex than the regular function would have
    been by simply adding the functionality directly, but the added advantage of applying
    the same pattern to many functions and classes is generally well worth it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您展示了装饰器可以用于使我们的代码更简单，并为非常简单的函数添加一些相当复杂的行为。诚实地讲，大多数装饰器比直接添加功能的功能性函数要复杂，但将相同的模式应用于许多函数和类所带来的额外优势通常是非常值得的。
- en: 'Decorators have so many uses to make your functions and classes smarter and
    more convenient to use:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器有如此多的用途，可以让你的函数和类更智能、更方便使用：
- en: Debugging
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Validation
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证
- en: Argument convenience (pre-filling or converting arguments)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数便利性（预填充或转换参数）
- en: Output convenience (converting the output to a specific type)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出便利性（将输出转换为特定类型）
- en: The most important takeaway of this chapter should be to never forget `functools.wraps`
    when wrapping a function. Debugging decorated functions can be rather difficult
    because of (unexpected) behavior modification, but losing attributes as well can
    make that problem much worse.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最重要的收获应该是永远不要忘记在包装函数时使用`functools.wraps`。由于（意外的）行为修改，调试装饰函数可能相当困难，但丢失属性也会使这个问题变得更糟。
- en: The next chapter will show you how and when to use `generators` and `coroutines`.
    This chapter has already shown you the usage of the `with` statement briefly,
    but `generators` and `coroutines` go much further with this. We will still be
    using decorators often, both in this book and when using Python in general, so
    make sure you have a good understanding of how they work.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向您展示如何以及何时使用`generators`和`coroutines`。这一章已经简要介绍了`with`语句的用法，但`generators`和`coroutines`在这方面可以做得更多。我们仍然会经常使用装饰器，无论是在这本书中还是在一般使用Python时，所以请确保您对它们的工作方式有很好的理解。
- en: Join our community on Discord
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：[https://discord.gg/QMzJenHuJf](https://discord.gg/QMzJenHuJf)
- en: '![](img/QR_Code156081100001293319171.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code156081100001293319171.png)'
