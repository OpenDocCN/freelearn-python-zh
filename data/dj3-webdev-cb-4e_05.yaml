- en: Custom Template Filters and Tags
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义模板过滤器和标签
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Following conventions for your own template filters and tags
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循自己的模板过滤器和标签的约定
- en: Creating a template filter to show how many days have passed since a post was
    published
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以显示自发布以来经过了多少天
- en: Creating a template filter to extract the first media object
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器来提取第一个媒体对象
- en: Creating a template filter to humanize URLs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以使URL更加人性化
- en: Creating a template tag to include a template, if it exists
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以包含模板（如果存在）
- en: Creating a template tag to load a QuerySet in a template
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以在模板中加载QuerySet
- en: Creating a template tag to parse content as a template
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板标签以将内容解析为模板
- en: Creating template tags to modify request query parameters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板标签以修改请求查询参数
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: Django has an extensive template system with features such as template inheritance,
    filters to change the representation of values, and tags for presentational logic.
    Moreover, Django allows you to add your own template filters and tags to your
    apps. Custom filters or tags should be located in a template-tag library file
    under the `templatetags` Python package in your app. Your template-tag library
    can then be loaded in any template with the `{% load %}` template tag. In this
    chapter, we will create several useful filters and tags that will give more control
    to template editors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'Django具有功能丰富的模板系统，包括模板继承、更改值表示的过滤器和用于表现逻辑的标签等功能。此外，Django允许您向应用程序添加自定义模板过滤器和标签。自定义过滤器或标签应位于您的应用程序中的`templatetags`
    Python包下的模板标签库文件中。然后可以使用`{% load %}`模板标签在任何模板中加载您的模板标签库。在本章中，我们将创建几个有用的过滤器和标签，以便更多地控制模板编辑者。 '
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For working with the code of this chapter, you will need the latest stable version
    of Python 3, the MySQL or PostgreSQL database, and a Django project with a virtual
    environment.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用本章的代码，您将需要最新稳定版本的Python 3，MySQL或PostgreSQL数据库，以及带有虚拟环境的Django项目。
- en: You can find all the code for this chapter at the `ch05` directory of the GitHub
    repository: [https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub存储库的`ch05`目录中找到本章的所有代码：[https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition](https://github.com/PacktPublishing/Django-3-Web-Development-Cookbook-Fourth-Edition)。
- en: Following conventions for your own template filters and tags
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遵循自己的模板过滤器和标签的约定
- en: 'Custom template filters and tags can be confusing and inconsistent if you don''t
    have guidelines to follow. It is essential to have both handy and flexible template
    filters and tags that should serve template editors as much as possible. In this
    recipe, we will take a look at some conventions that you should use when enhancing
    the functionality of the Django template system:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有遵循指南，自定义模板过滤器和标签可能会令人困惑和不一致。拥有方便灵活的模板过滤器和标签对于模板编辑者来说非常重要。在本篇中，我们将看一些增强Django模板系统功能时应该使用的约定：
- en: Don't create or use custom template filters or tags when the logic for the page
    fits better in the view, context processors, or model methods. When your content
    is context-specific, such as a list of objects or an object-detail view, load
    the object in the view. If you need to show some content on nearly every page,
    create a context processor. Use custom methods of the model instead of template
    filters when you need to get some properties of an object that are not related
    to the context of the template.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当页面的逻辑更适合于视图、上下文处理器或模型方法时，不要创建或使用自定义模板过滤器或标签。当您的内容是特定于上下文的，例如对象列表或对象详细视图时，在视图中加载对象。如果您需要在几乎每个页面上显示一些内容，请创建上下文处理器。当您需要获取与模板上下文无关的对象的一些属性时，请使用模型的自定义方法而不是模板过滤器。
- en: Name the template-tag library with the `_tags` suffix. When your template-tag
    library is named differently than your app, you can avoid ambiguous package-importing
    problems.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`_tags`后缀命名模板标签库。当您的模板标签库与您的应用程序命名不同时，您可以避免模糊的包导入问题。
- en: 'In the newly created library, separate the filters from the tags—for example,
    using comments, as shown in the following code:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新创建的库中，将过滤器与标签分开，例如使用注释，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When creating advanced custom template tags, make sure that their syntax is
    easy to remember by including the following constructs that can follow the tag name:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建高级自定义模板标签时，确保其语法易于记忆，包括以下可以跟随标签名称的构造：
- en: '`for [app_name.model_name]`: Include this construct to use a specific model.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for [app_name.model_name]`：包括此构造以使用特定模型。'
- en: '`using [template_name]`: Include this construct to use a template for the output
    of the template tag.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`using [template_name]`：包括此构造以使用模板作为模板标签的输出。'
- en: '`limit [count]`: Include this construct to limit the results to a specific
    number.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit [count]`：包括此构造以将结果限制为特定数量。'
- en: '`as [context_variable]`: Include this construct to store the results in a context
    variable that can be reused multiple times.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`as [context_variable]`：包括此构造以将结果存储在可以多次重用的上下文变量中。'
- en: Try to avoid multiple values that are defined positionally in the template tags,
    unless they are self-explanatory. Otherwise, this will likely confuse template
    developers.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽量避免在模板标签中定义多个按位置定义的值，除非它们是不言自明的。否则，这可能会使模板开发人员感到困惑。
- en: Make as many resolvable arguments as possible. Strings without quotes should
    be treated as context variables that need to be resolved, or as short words that
    remind you of the structure of the template-tag components.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能使可解析的参数多。没有引号的字符串应被视为需要解析的上下文变量，或者作为提醒模板标签组件结构的简短单词。
- en: Creating a template filter to show how many days have passed since a post was
    published
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以显示自发布以来经过了多少天
- en: When talking about creation or modification dates, it is convenient to read
    a more human-readable time difference—for example, the blog entry was posted 3
    days ago, the news article was published today, and the user last logged in yesterday.
    In this recipe, we will create a template filter named `date_since`, which converts
    dates to humanized time differences based on days, weeks, months, or years.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论创建或修改日期时，方便阅读更加人性化的时间差异，例如，博客条目是3天前发布的，新闻文章是今天发布的，用户上次登录是昨天。在这个示例中，我们将创建一个名为`date_since`的模板过滤器，它将根据天、周、月或年将日期转换为人性化的时间差异。
- en: Getting ready
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create the `core` app, and put it under `INSTALLED_APPS` in the settings, if
    you haven't done so already. Then, create a `templatetags` Python package in this
    app (Python packages are directories with an empty `__init__.py` file).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未完成，请创建`core`应用程序，并将其放置在设置中的`INSTALLED_APPS`中。然后，在此应用程序中创建一个`templatetags`
    Python包（Python包是带有空的`__init__.py`文件的目录）。
- en: How to do it...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a `utility_tags.py` file with the following content:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`utility_tags.py`文件，其中包含以下内容：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This filter used in a template, as shown in the following code, will render
    something similar to yesterday, last week, or 5 months ago:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板中使用此过滤器，如下所示的代码将呈现类似于昨天、上周或5个月前的内容：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can apply this filter to values of the `date` and `datetime` types.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将此过滤器应用于`date`和`datetime`类型的值。
- en: Each template-tag library has a register of `template.Library` type where filters
    and tags are collected. Django filters are functions registered by the `@register.filter`
    decorator. In this case, we pass the `is_safe=True` parameter to indicate that
    our filter will not introduce any unsafe HTML markup.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板标签库都有一个`template.Library`类型的注册表，其中收集了过滤器和标签。 Django过滤器是由`@register.filter`装饰器注册的函数。在这种情况下，我们传递了`is_safe=True`参数，以指示我们的过滤器不会引入任何不安全的HTML标记。
- en: 'By default, the filter in the template system will be named the same as the
    function or another callable object. If you want, you can set a different name
    for the filter by passing the name to the decorator, as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，模板系统中的过滤器将与函数或其他可调用对象的名称相同。如果需要，可以通过将名称传递给装饰器来为过滤器设置不同的名称，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The filter itself is fairly self-explanatory. At first, the current date is
    read. If the given value of the filter is of the `datetime` type, its `date` is
    extracted. Then, the difference between today and the extracted value is calculated
    based on the `DAYS_PER_YEAR`, `DAYS_PER_MONTH`, `DAYS_PER_WEEK`, or days intervals.
    Depending on the count, different string results are returned, falling back to
    displaying a formatted date if the value is in the future.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤器本身相当不言自明。首先读取当前日期。如果过滤器的给定值是`datetime`类型，则提取其`date`。然后，根据`DAYS_PER_YEAR`、`DAYS_PER_MONTH`、`DAYS_PER_WEEK`或天数间隔计算今天和提取值之间的差异。根据计数，返回不同的字符串结果，如果值在未来，则返回格式化日期。
- en: There's more...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If required, we could cover other stretches of time too, as in 20 minutes ago,
    5 hours ago, or even 1 decade ago. To do so, we would add more intervals to the
    existing `diff_map` set, and to show the difference in time, we would need to
    operate on `datetime` values instead of `date` values.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们也可以覆盖其他时间段，例如20分钟前、5小时前，甚至是10年前。为此，我们将在现有的`diff_map`集合中添加更多的间隔，并且为了显示时间差异，我们需要对`datetime`值进行操作，而不是`date`值。
- en: See also
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a template filter to extract the first media object* recipe
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取第一个媒体对象的模板过滤器的方法
- en: The *Creating a template filter to humanize URLs* recipe
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以使URL更加人性化的方法
- en: Creating a template filter to extract the first media object
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器来提取第一个媒体对象
- en: Imagine that you are developing a blog overview page, and, for each post, you
    want to show images, music, or videos on that page, taken from the content. In
    such a case, you need to extract the `<figure>`, `<img>`, `<object>`, `<embed>`,
    `<video>`, `<audio>`, and `<iframe>` tags from the HTML content of the post, as
    stored on a field of the post model. In this recipe, we will see how to perform
    this using regular expressions in the `first_media` filter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您正在开发一个博客概述页面，对于每篇文章，您希望从内容中显示图像、音乐或视频，这些内容来自内容。在这种情况下，您需要从帖子模型的字段中存储的HTML内容中提取`<figure>`、`<img>`、`<object>`、`<embed>`、`<video>`、`<audio>`和`<iframe>`标签。在这个示例中，我们将看到如何使用`first_media`过滤器来执行此操作。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the `core` app that should be set in `INSTALLED_APPS` in
    the settings and should contain the `templatetags` package in this app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从`core`应用程序开始，在设置中应设置为`INSTALLED_APPS`，并且应该包含此应用程序中的`templatetags`包。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `utility_tags.py` file, add the following content:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在`utility_tags.py`文件中，添加以下内容：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'If the HTML content in the database is valid, and you put the following code
    in the template, it will retrieve the media tags from the content field of the
    object; otherwise, an empty string will be returned if no media is found:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据库中的HTML内容有效，并且将以下代码放入模板中，则将从对象的内容字段中检索媒体标签；否则，如果未找到媒体，则将返回空字符串：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Regular expressions are a powerful feature to search or replace patterns of
    text. At first, we define lists of all the supported media tag names, splitting
    them into groups for those that have both opening and closing tags (`MEDIA_CLOSED_TAGS`),
    and those that are self-closed (`MEDIA_SINGLE_TAGS`). From these lists, we generate
    the compiled regular expression as `MEDIA_TAGS_REGEX`. In this case, we search
    for all the possible media tags, allowing them to occur across multiple lines.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式是搜索或替换文本模式的强大功能。首先，我们定义了所有支持的媒体标签名称的列表，将它们分成具有开放和关闭标签（`MEDIA_CLOSED_TAGS`）和自关闭标签（`MEDIA_SINGLE_TAGS`）的组。从这些列表中，我们生成了编译后的正则表达式`MEDIA_TAGS_REGEX`。在这种情况下，我们搜索所有可能的媒体标签，允许它们跨越多行出现。
- en: 'Let''s see how this regular expression works, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个正则表达式是如何工作的，如下所示：
- en: Alternating patterns are separated by the pipe (`|`) symbol.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交替模式由管道（`|`）符号分隔。
- en: There are two groups within the patterns—first of all, those with both opening
    and closing normal tags (`<figure>`, `<object>`, `<video>`, `<audio>`, `<iframe>`,
    and `<picture>`), and then one final pattern for what are called self-closing
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式中有两组——首先是那些具有开放和关闭普通标签（`<figure>`，`<object>`，`<video>`，`<audio>`，`<iframe>`和`<picture>`）的标签，然后是最后一个模式，用于所谓的自关闭
- en: or void tags (`<img>` and `<embed>`).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 或空标签（`<img>`和`<embed>`）。
- en: For the possibly multiline normal tags, we will use the `[\S\s]+?` pattern that
    matches any symbol at least once; however, we do this as few times as possible
    until we find the string that goes after it.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可能是多行的普通标签，我们将使用`[\S\s]+?`模式，该模式至少匹配任何符号一次；但是，我们尽可能少地执行这个操作，直到找到它后面的字符串。
- en: Therefore, `<figure[\S\s]+?</figure>` searches for the start of the `<figure>`
    tag and everything after it, until it finds the closing `</figure>` tag.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，`<figure[\S\s]+?</figure>`搜索`<figure>`标签的开始以及它后面的所有内容，直到找到`</figure>`标签的闭合。
- en: Similarly, with the `[^>]+` pattern for self-closing tags, we search for any
    symbol except the right-angle bracket (possibly better known as a greater-than
    symbol—that is to say, `>`) at least once and as many times as possible, until
    we encounter such a bracket indicating the closure of the tag.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，对于自关闭标签的`[^>]+`模式，我们搜索除右尖括号（可能更为人所知的是大于号符号，即`>`）之外的任何符号，至少一次，尽可能多次，直到遇到指示标签关闭的尖括号。
- en: The `re.MULTILINE` flag ensures that matches can be found, even if they span
    multiple lines in the content. Then, in the filter, we perform a search using
    this regular-expression pattern. By default, in Django, the result of any filter
    will show the `<`, `>`, and `&` symbols escaped as the `&lt;`, `&gt;`, and `&amp;`
    entities, respectively. In this case, however, we use the `mark_safe()` function
    to indicate that the result is safe and HTML-ready, so that any content will be
    rendered without escaping. Because the originating content is user input, we do
    this instead of passing `is_safe=True` when registering the filter, as we need
    to explicitly certify that the markup is safe.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`re.MULTILINE`标志确保可以找到匹配项，即使它们跨越内容中的多行。然后，在过滤器中，我们使用这个正则表达式模式进行搜索。默认情况下，在Django中，任何过滤器的结果都会显示为`<`，`>`和`&`符号转义为`&lt;`，`&gt;`和`&amp;`实体。然而，在这种情况下，我们使用`mark_safe()`函数来指示结果是安全的并且已准备好用于HTML，以便任何内容都将被呈现而不进行转义。因为原始内容是用户输入，所以我们这样做，而不是在注册过滤器时传递`is_safe=True`，因为我们需要明确证明标记是安全的。'
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you are interested in regular expressions, you can learn more about them
    in the official Python documentation at [https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对正则表达式感兴趣，可以在官方Python文档中了解更多信息[https://docs.python.org/3/library/re.html](https://docs.python.org/3/library/re.html)。
- en: See also
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板过滤器以显示发布后经过多少天*食谱'
- en: The *Creating a template filter to humanize URLs* recipe
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板过滤器以使URL更加人性化*食谱'
- en: Creating a template filter to humanize URLs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板过滤器以使URL更加人性化
- en: Web users commonly recognize URLs without the protocol (`http://`) or trailing
    slash (`/`), and, similarly, they will enter URLs in this fashion in address fields.
    In this recipe, we will create a `humanize_url` filter that is used to present
    URLs to the user in a shorter format, truncating very long addresses, similar
    to what Twitter does with the links in tweets.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Web用户通常在地址字段中以不带协议（`http://`）或斜杠（`/`）的方式识别URL，并且以类似的方式输入URL。在这个食谱中，我们将创建一个`humanize_url`过滤器，用于以更短的格式向用户呈现URL，截断非常长的地址，类似于Twitter在推文中对链接所做的操作。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Similar to the previous recipes, we will start with the `core` app that should
    be set in `INSTALLED_APPS` in the settings, which contains the `templatetags`
    package in the app.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的食谱类似，我们将从`core`应用程序开始，在设置中应该设置`INSTALLED_APPS`，其中包含应用程序中的`templatetags`包。
- en: How to do it...
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In the `FILTERS` section of the `utility_tags.py` template library in the `core`
    app, let''s add the `humanize_url` filter and register it, as shown in the following
    code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在`core`应用程序的`utility_tags.py`模板库的`FILTERS`部分中，让我们添加`humanize_url`过滤器并注册它，如下所示：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'We can use the `humanize_url` filter in any template, as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何模板中使用`humanize_url`过滤器，如下所示：
- en: '[PRE7]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The filter uses regular expressions to remove the leading protocol and trailing
    slash, shortens the URL to the given amount of letters (40, by default), and adds
    an ellipsis to the end after truncating it if the full URL doesn't fit the specified
    letter count. For example, for the  `https://docs.djangoproject.com/en/3.0/howto/custom-template-tags/` URL,
    the 40-character humanized version would be `docs.djangoproject.com/en/3.0/howto/cus…`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 该过滤器使用正则表达式来删除前导协议和尾部斜杠，将URL缩短到给定的字母数量（默认为40），并在截断后添加省略号，如果完整的URL不符合指定的字母数量。例如，对于`https://docs.djangoproject.com/en/3.0/howto/custom-template-tags/`的URL，40个字符的人性化版本将是`docs.djangoproject.com/en/3.0/howto/cus…`。
- en: See also
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a template filter to show how many days have passed since a post
    was published* recipe
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板过滤器以显示发布后经过多少天*食谱'
- en: The *Creating a template filter to extract the first media object* recipe
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板过滤器以提取第一个媒体对象*食谱'
- en: The *Creating a template tag to include a template, if it exists* recipe
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以包含模板（如果存在）*食谱'
- en: Creating a template tag to include a template, if it exists
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板标签以包含模板（如果存在）
- en: Django provides the `{% include %}` template tag that allows one template to
    render and include another template. However, this template tag raises an error
    if you try to include a template that doesn't exist in the filesystem. In this
    recipe, we will create a `{% try_to_include %}` template tag that includes another
    template, if it exists, and fails silently by rendering as an empty string otherwise.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了`{% include %}`模板标签，允许一个模板呈现和包含另一个模板。但是，如果您尝试包含文件系统中不存在的模板，则此模板标签会引发错误。在此食谱中，我们将创建一个`{%
    try_to_include %}`模板标签，如果存在，则包含另一个模板，并通过渲染为空字符串来静默失败。
- en: Getting ready
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start again with the `core` app that is installed and ready for custom
    template tags.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从已安装并准备好自定义模板标签的`core`应用程序开始。
- en: How to do it...
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to create the `{% try_to_include %}` template tag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤创建`{% try_to_include %}`模板标签：
- en: 'First, let''s create the function parsing the template-tag arguments, as follows:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建解析模板标签参数的函数，如下所示：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we need a custom `IncludeNode` class in the same file, extending from
    the base `template.Node`. Let''s insert it just before the `try_to_include()`
    function, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在同一文件中创建一个自定义的`IncludeNode`类，该类从基本的`template.Node`扩展。让我们在`try_to_include()`函数之前插入它，如下所示：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Advanced custom template tags consist of two things:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 高级自定义模板标签由两部分组成：
- en: A function that parses the arguments of the template tag
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解析模板标签参数的函数
- en: The `Node` class that is responsible for the logic of the template tag as well
    as the output
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责模板标签逻辑和输出的`Node`类
- en: The `{% try_to_include %}` template tag expects one argument— that is, `template_name`.
    Therefore, in the `try_to_include()` function, we try to assign the split contents
    of the token only to the `tag_name` variable (which is `try_to_include`) and the
    `template_name` variable. If this doesn't work, a `TemplateSyntaxError` is raised.
    The function returns the `IncludeNode` object, which gets the `template_name`
    field and stores it in a template `Variable` object for later use.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% try_to_include %}`模板标签期望一个参数——即`template_name`。因此，在`try_to_include()`函数中，我们尝试将令牌的拆分内容仅分配给`tag_name`变量（即`try_to_include`）和`template_name`变量。如果这不起作用，将引发`TemplateSyntaxError`。该函数返回`IncludeNode`对象，该对象获取`template_name`字段并将其存储在模板`Variable`对象中以供以后使用。'
- en: In the `render()` method of `IncludeNode`, we resolve the `template_name` variable.
    If a context variable was passed to the template tag, its value will be used here
    for `template_name`. If a quoted string was passed to the template tag, then the
    content within the quotes will be used for `included_template`, whereas a string
    corresponding to a context variable will be resolved into its string equivalent
    for the same.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IncludeNode`的`render()`方法中，我们解析`template_name`变量。如果上下文变量被传递给模板标签，则其值将在此处用于`template_name`。如果引用的字符串被传递给模板标签，那么引号内的内容将用于`included_template`，而与上下文变量对应的字符串将被解析为其相应的字符串等效。
- en: Lastly, we will try to load the template, using the resolved `included_template`
    string, and render it with the current template context. If that doesn't work,
    an empty string is returned.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将尝试加载模板，使用解析的`included_template`字符串，并在当前模板上下文中呈现它。如果这不起作用，则返回空字符串。
- en: 'There are at least two situations where we could use this template tag:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有两种情况可以使用此模板标签：
- en: 'When including a template whose path is defined in a model, as follows:'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在包含路径在模型中定义的模板时，如下所示：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When including a template whose path is defined with the `{% with %}` template
    tag somewhere high in the template context variable''s scope. This is especially
    useful when you need to create custom layouts for plugins in the placeholder of
    a template in Django CMS:'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板上下文变量的范围中的某个地方使用`{% with %}`模板标签定义路径的模板。当您需要为Django CMS中模板的占位符创建自定义布局时，这是非常有用的：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Later, the placeholder can be filled with the `editorial_content` plugins,
    and the `editorial_content_template_path` context variable is then read and the
    template can be safely included, if available:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，占位符可以使用`editorial_content`插件填充，然后读取`editorial_content_template_path`上下文变量，如果可用，则可以安全地包含模板：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's more...
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can use the `{% try_to_include %}` tag in any combination with the default
    `{% include %}` tag to include the templates that extend other templates. This
    is beneficial for large-scale web platforms, where you have different kinds of
    lists in which complex items share the same structure as widgets but have a different
    source of data.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在任何组合中使用`{% try_to_include %}`标签和默认的`{% include %}`标签来包含扩展其他模板的模板。这对于大型网络平台非常有益，其中您有不同类型的列表，其中复杂的项目与小部件具有相同的结构，但具有不同的数据来源。
- en: 'For example, in the artist list template, you can include the `artist_item`
    template, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在艺术家列表模板中，您可以包含`artist_item`模板，如下所示：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This template will extend from the item base, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板将从项目基础扩展，如下所示：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The item base defines the markup for any item and also includes a `Like` widget,
    as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 项目基础定义了任何项目的标记，并包括`Like`小部件，如下所示：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See also
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Implementing the Like widget* recipe in [Chapter 4](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*,
    Templates and JavaScript*
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在[第4章](707758de-0bea-479d-8e79-3e4de6c956d5.xhtml)*中实现`Like`小部件的食谱，模板和JavaScript'
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签以在模板中加载QuerySet*食谱'
- en: The *Creating a template tag to parse content as a template* recipe
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个将内容解析为模板的模板标签*食谱'
- en: The *Creating template tags to modify request query parameters* recipe
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建模板标签以修改请求查询参数*食谱'
- en: Creating a template tag to load a QuerySet in a template
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板标签以在模板中加载QuerySet
- en: Generally, the content that should be shown on a web page will be defined in
    the context by views. If the content is to be shown on every page, it is logical
    to create a context processor to make it available globally. Another situation
    is when you need to show additional content, such as the latest news or a random
    quote, on some pages—for example, the starting page or the details page of an
    object. In this case, you can load the necessary content with a custom `{% load_objects
    %}` template tag, which we will implement in this recipe.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，应在视图中定义应显示在网页上的内容。如果要在每个页面上显示内容，逻辑上应创建上下文处理器以使其全局可用。另一种情况是当您需要在某些页面上显示其他内容，例如最新新闻或随机引用，例如起始页面或对象的详细页面。在这种情况下，您可以使用自定义
    `{% load_objects %}` 模板标签加载必要的内容，我们将在本教程中实现。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we will start with the `core` app, which should be installed and
    ready for custom template tags.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次从 `core` 应用程序开始，该应用程序应已安装并准备好用于自定义模板标签。
- en: 'In addition, to illustrate the concept, let''s create a `news` app with an
    `Article` model, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了说明这个概念，让我们创建一个带有 `Article` 模型的 `news` 应用程序，如下所示：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There, the interesting part is the `custom_manager` for the `Article` model.
    The manager can be used to list out random published articles.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，有趣的部分是 `Article` 模型的 `custom_manager`。该管理器可用于列出随机发布的文章。
- en: Using the examples of the previous chapter, you can complete the app with URL
    configurations, views, templates, and administration setup. Then, add some articles
    to the database using the administration form.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上一章的示例，您可以完成具有 URL 配置、视图、模板和管理设置的应用程序。然后，使用管理表单向数据库添加一些文章。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'An advanced custom template tag consists of a function that parses the arguments
    that are passed to the tag, and the `Node` class that renders the output of the
    tag or modifies the template context. Perform the following steps to create the
    `{% load_objects %}` template tag:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 高级自定义模板标签由解析传递给标签的参数的函数和呈现标签输出或修改模板上下文的 `Node` 类组成。执行以下步骤创建 `{% load_objects
    %}` 模板标签：
- en: 'First, let''s create the function that handles the parsing of the template-tag
    arguments, as follows:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建处理模板标签参数解析的函数，如下所示：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will create the custom `ObjectsNode` class in the same file, extending
    from the `template.Node` base. Let''s insert it just before the `load_objects()`
    function, as shown in the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在同一文件中创建自定义 `ObjectsNode` 类，扩展自 `template.Node` 基类。让我们在 `load_objects()`
    函数之前插入它，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `{% load_objects %}` template tag loads a QuerySet defined by the method
    of the manager from a specified app and model, limits the result to the specified
    count, and saves the result to the given context variable.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% load_objects %}` 模板标签加载由管理器方法定义的指定应用程序和模型的 QuerySet，将结果限制为指定的计数，并将结果保存到给定的上下文变量中。'
- en: 'The following code is a simple example of how to use the template tag that
    we have just created. It will load all news articles in any template, using the
    following snippet:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是如何使用我们刚刚创建的模板标签的简单示例。它将在任何模板中加载所有新闻文章，使用以下代码片段：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is using the `all()` method of the default `objects` manager of the `Article`
    model, and it will sort the articles by the `ordering` attribute defined in the
    `Meta` class of the model.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 `Article` 模型的默认 `objects` 管理器的 `all()` 方法，并且它将按照模型的 `Meta` 类中定义的 `ordering`
    属性对文章进行排序。
- en: Next is an example that uses a custom manager with a custom method to query
    the objects from the database. A manager is an interface that provides the database
    query operations to models.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个示例，使用自定义管理器和自定义方法从数据库中查询对象。管理器是为模型提供数据库查询操作的接口。
- en: 'Each model has at least one manager called `objects`, by default. For our `Article`
    model, we added an extra manager called `custom_manager` with a method, `random_published()`.
    Here is how we can use it with our `{% load_objects %}` template tag to load one
    random published article:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型至少有一个默认的名为 `objects` 的管理器。对于我们的 `Article` 模型，我们添加了一个名为 `custom_manager`
    的额外管理器，其中包含一个名为 `random_published()` 的方法。以下是我们如何在 `{% load_objects %}` 模板标签中使用它来加载一个随机发布的文章：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Let's look at the code of the `{% load_objects %}` template tag. In the parsing
    function, there are two allowed forms for the tag—with or without a `limit`. The
    string is parsed, and if the format is recognized, the components of the template
    tag are passed to the `ObjectsNode` class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下 `{% load_objects %}` 模板标签的代码。在解析函数中，标签有两种允许的形式——带有或不带有 `limit`。字符串被解析，如果识别格式，则模板标签的组件将传递给
    `ObjectsNode` 类。
- en: In the `render()` method of the `Node` class, we check the manager's name and
    its method's name. If no manager is specified, `_default_manager` will be used.
    This is an automatic property of any model injected by Django and points to the
    first available `models.Manager()` instance. In most cases, `_default_manager`
    will be the `objects` manager. After that, we will call the method of the manager
    and fall back to an empty QuerySet if the method doesn't exist. If a `limit` is
    defined, we resolve the value of it and limit the QuerySet accordingly. Lastly,
    we will store the resulting QuerySet in the context variable, as given by `var_name`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Node` 类的 `render()` 方法中，我们检查管理器的名称及其方法的名称。如果未指定管理器，则将使用 `_default_manager`。这是
    Django 注入的任何模型的自动属性，并指向第一个可用的 `models.Manager()` 实例。在大多数情况下，`_default_manager`
    将是 `objects` 管理器。之后，我们将调用管理器的方法，并在方法不存在时回退到空的 QuerySet。如果定义了 `limit`，我们将解析其值并相应地限制
    QuerySet。最后，我们将将结果的 QuerySet 存储在上下文变量中，如 `var_name` 所给出的那样。
- en: See also
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a model mixin with URL-related methods* recipe in [Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)
    [2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*, Models and Database Structure*
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在 [Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)
    [2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*，模型和数据库结构中创建一个带有 URL 相关方法的模型混合的食谱'
- en: The *Creating a model mixin to handle creation and modification dates* recipe
    in [Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[ ](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*,
    Models and Database Structure*
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[ ](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*，Models
    and Database Structure*中的*创建模型混合以处理创建和修改日期*配方
- en: The *Creating a template tag to include a template, if it exists* recipe
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[ ](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*，Models
    and Database Structure*中的*创建一个模板标签以包含模板（如果存在）*配方
- en: The *Creating a template tag to parse content as a template* recipe
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[ ](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*，Models
    and Database Structure*中的*创建一个模板标签以将内容解析为模板*配方
- en: The *Creating template tags to modify request query parameters* recipe
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建模板标签以修改请求查询参数的配方
- en: Creating a template tag to parse content as a template
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个模板标签以将内容解析为模板
- en: In this recipe, we will create the `{% parse %}` template tag that will allow
    you to put template snippets in the database. This is valuable when you want to
    provide different content for authenticated and unauthenticated users, when you
    want to include a personalized salutation, or when you don't want to hardcode
    the media paths in the database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建`{% parse %}`模板标签，它将允许您将模板片段放入数据库。当您想要为经过身份验证和未经身份验证的用户提供不同的内容，当您想要包含个性化的称谓，或者当您不想在数据库中硬编码媒体路径时，这将非常有价值。
- en: Getting ready
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: As usual, we will start with the `core` app that should be installed and ready
    for custom template tags.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们将从`core`应用程序开始，该应用程序应该已经安装并准备好用于自定义模板标签。
- en: How to do it...
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'An advanced custom template tag consists of a function that parses the arguments
    that are passed to the tag, and a `Node` class that renders the output of the
    tag or modifies the template context. Perform the following steps to create the `{%
    parse %}` template tag:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 高级自定义模板标签由一个解析传递给标签的参数的函数和一个`Node`类组成，该类渲染标签的输出或修改模板上下文。执行以下步骤来创建`{% parse %}`模板标签：
- en: 'First, let''s create the function parsing the arguments of the template tag,
    as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建解析模板标签参数的函数，如下所示：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we will create the custom `ParseNode` class in the same file, extending
    from the base `template.Node`, as shown in the following code (place it just before
    the `parse()` function):'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将在同一文件中创建自定义的`ParseNode`类，该类从基本的`template.Node`扩展，如下面的代码所示（将其放在`parse()`函数之前）：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `{% parse %}` template tag allows you to parse a value as a template and
    render it immediately or store it in a context variable.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% parse %}`模板标签允许您将值解析为模板并立即渲染它，或将其存储在上下文变量中。'
- en: 'If we have an object with a description field, which can contain template variables
    or logic, we can parse and render it using the following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个带有描述字段的对象，该字段可以包含模板变量或逻辑，我们可以使用以下代码解析和渲染它：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It is also possible to define a value to parse using a quoted string, as shown
    in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用引号字符串定义要解析的值，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Let's take a look at the code of the `{% parse %}` template tag. The parsing
    function checks the arguments of the template tag bit by bit. At first, we expect
    the parse name and the template value. If there are still more bits in the token,
    we expect the combination of an optional `as` word followed by the context variable
    name. The template value and the optional variable name are passed to the `ParseNode`
    class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`{% parse %}`模板标签的代码。解析函数逐位检查模板标签的参数。首先，我们期望解析名称和模板值。如果仍然有更多的位于令牌中，我们期望可选的`as`单词后跟上上下文变量名的组合。模板值和可选变量名被传递给`ParseNode`类。
- en: The `render()` method of that class first resolves the value of the template
    variable and creates a template object out of it. The `context_vars` are copied
    and a request context is generated, which the template renders. If the variable
    name is defined, the result is stored in it and an empty string is rendered; otherwise,
    the rendered template is shown immediately.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 该类的`render()`方法首先解析模板变量的值，并将其创建为模板对象。然后复制`context_vars`并生成请求上下文，模板进行渲染。如果定义了变量名，则将结果存储在其中并渲染一个空字符串；否则，立即显示渲染的模板。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Creating a template tag to include a template, if it exists* recipe
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[Ch](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[apter](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[ ](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)[2](4d961db0-e9dd-4449-b140-41ea147bccb5.xhtml)*，Models
    and Database Structure*中的*创建一个模板标签以包含模板（如果存在）*配方
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中加载查询集的*创建模板标签*配方
- en: The *Creating template tags to modify request query parameters* recipe
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*创建模板标签以修改请求查询参数*配方中
- en: Creating template tags to modify request query parameters
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建模板标签以修改请求查询参数
- en: Django has a convenient and flexible system to create canonical and clean URLs
    just by adding regular-expression rules to the URL configuration files. However,
    there is a lack of built-in techniques to manage query parameters. Views such
    as search or filterable object lists need to accept query parameters to drill
    down through the filtered results using another parameter or to go to another
    page. In this recipe, we will create `{% modify_query %}`, `{% add_to_query %}`,
    and `{% remove_from_query %}` template tags, which let you add, change, or remove
    the parameters of the current query.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Django有一个方便灵活的系统，可以通过向URL配置文件添加正则表达式规则来创建规范和干净的URL。然而，缺乏内置技术来管理查询参数。诸如搜索或可过滤对象列表的视图需要接受查询参数，以通过另一个参数深入筛选结果或转到另一页。在这个配方中，我们将创建`{%
    modify_query %}`、`{% add_to_query %}`和`{% remove_from_query %}`模板标签，让您可以添加、更改或删除当前查询的参数。
- en: Getting ready
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Once again, we start with the `core` app that should be set in `INSTALLED_APPS` which contains
    the `templatetags` package.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们从`core`应用程序开始，该应用程序应该在`INSTALLED_APPS`中设置，其中包含`templatetags`包。
- en: 'Also, make sure that you have the `request` context processor added to the
    `context_processors` list in the `TEMPLATES` settings under `OPTIONS`, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 还要确保在`OPTIONS`下的`TEMPLATES`设置中将`request`上下文处理器添加到`context_processors`列表中。
- en: '[PRE25]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'For these template tags, we will be using the `@simple_tag` decorator that
    parses the components and requires you to just define the rendering function,
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些模板标签，我们将使用`@simple_tag`装饰器来解析组件，并要求您只需定义呈现函数，如下所示：
- en: 'First, let''s add a helper method for putting together the query strings that
    each of our tags will output:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个辅助方法来组合每个标签输出的查询字符串：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we will create the `{% modify_query %}` template tag:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建`{% modify_query %}`模板标签：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let''s create the `{% add_to_query %}` template tag:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建`{% add_to_query %}`模板标签：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Lastly, let''s create the `{% remove_from_query %}` template tag:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建`{% remove_from_query %}`模板标签：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: All three created template tags behave similarly. At first, they read the current
    query parameters from the `request.GET` dictionary-like `QueryDict` object to
    a new list of (key, value) `query_params` tuples. Then, the values are updated
    depending on the positional arguments and keyword arguments. Lastly, the new query
    string is formed via the helper method defined first. In this process, all spaces
    and special characters are URL-encoded, and the ampersands connecting the query
    parameters are escaped. This new query string is returned to the template.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个创建的模板标签的行为都类似。首先，它们从`request.GET`字典样的`QueryDict`对象中读取当前查询参数，然后将其转换为新的（键，值）`query_params`元组列表。然后，根据位置参数和关键字参数更新值。最后，通过首先定义的辅助方法形成新的查询字符串。在此过程中，所有空格和特殊字符都被URL编码，并且连接查询参数的和号被转义。将此新的查询字符串返回到模板。
- en: To read more about the `QueryDict` objects, refer to the official Django documentation
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关`QueryDict`对象的更多信息，请参阅官方Django文档
- en: at [https://docs.djangoproject.com/en/3.0/ref/request-response/#querydict-objects](https://docs.djangoproject.com/en/3.0/ref/request-response/#querydict-objects).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在[https://docs.djangoproject.com/en/3.0/ref/request-response/#querydict-objects](https://docs.djangoproject.com/en/3.0/ref/request-response/#querydict-objects)。
- en: 'Let''s take a look at an example of how the `{% modify_query %}` template tag
    can be used. Positional arguments in the template tag define which query parameters
    are to be removed, and the keyword arguments define which query parameters are
    to be updated in the current query. If the current URL is `http://127.0.0.1:8000/artists/?category=fine-art&page=5`,
    we can use the following template tag to render a link that goes to the next page:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个示例，演示了`{% modify_query %}`模板标签的用法。模板标签中的位置参数定义要删除哪些查询参数，关键字参数定义要在当前查询中更新哪些查询参数。如果当前URL是`http://127.0.0.1:8000/artists/?category=fine-art&page=5`，我们可以使用以下模板标签呈现一个转到下一页的链接：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following snippet is the output rendered using the preceding template tag:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前述模板标签呈现的输出如下代码段所示：
- en: '[PRE31]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can also use the following example to render a link that resets pagination
    and goes to another category, `sculpture`, as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下示例来呈现一个重置分页并转到另一个类别`sculpture`的链接，如下所示：
- en: '[PRE32]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'So, the output rendered using the preceding template tag would be as shown
    in this snippet:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用前述模板标签呈现的输出将如下代码段所示：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With the `{% add_to_query %}` template tag, you can add, step by step, the
    parameters with the same name. For example, if the current URL is `http://127.0.0.1:8000/artists/?category=fine-art`,
    you can add another category, `Sculpture`, with the help of the following snippet:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`{% add_to_query %}`模板标签，您可以逐步添加具有相同名称的参数。例如，如果当前URL是`http://127.0.0.1:8000/artists/?category=fine-art`，您可以使用以下代码段添加另一个类别`Sculpture`：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This will be rendered in the template, as shown in the following snippet:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在模板中呈现，如下代码段所示：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Lastly, with the help of the `{% remove_from_query %}` template tag, you can
    remove, step by step, the parameters with the same name. For example, if the current
    URL is `http://127.0.0.1:8000/artists/?category=fine-art&category=sculpture`,
    you can remove the `Sculpture` category, with the help of the following snippet:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，借助`{% remove_from_query %}`模板标签的帮助，您可以逐步删除具有相同名称的参数。例如，如果当前URL是`http://127.0.0.1:8000/artists/?category=fine-art&category=sculpture`，您可以使用以下代码段删除`Sculpture`类别：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will be rendered in the template as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在模板中呈现如下：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See also
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: The *Filtering object lists* recipe in [Chapter 3](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*,
    Forms and Views*
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第3章](ac26c6a6-3fd1-4b28-8b01-5b3cda40f4f9.xhtml)*中的*对象列表过滤器*配方，表单和视图'
- en: The *Creating a template tag to include a template, if it exists* recipe
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签来包含模板（如果存在）*配方'
- en: The *Creating a template tag to load a QuerySet in a template* recipe
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签来在模板中加载QuerySet*配方'
- en: The *Creating a template tag to parse content as a template* recipe
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建一个模板标签来解析内容作为模板*配方'
