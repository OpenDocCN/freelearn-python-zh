- en: '*Chapter 8*: Introduction to Python'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：Python简介'
- en: In this chapter, we will be learning about the Python commands and functionalities
    while applying them to problems. As we delve into the first chapter of *Section
    2*, *Applying Python and Computational Thinking*, we will be using more complex
    Python programming. In this chapter, we will focus more on language, while the
    remaining chapters will focus on application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习Python的命令和功能，并将它们应用到问题中。当我们深入*第2节*，*应用Python和计算思维*的第一章时，我们将使用更复杂的Python编程。在本章中，我们将更多地关注语言，而其余章节将侧重于应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing Python
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Python
- en: Working with dictionaries and lists
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典和列表
- en: Using variables and functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用变量和函数
- en: Learning about files, data, and iteration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习文件、数据和迭代
- en: Using object-oriented programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用面向对象的编程
- en: As we dig deeper into the Python programming language, remember that some of
    the content has been covered in previous chapters as we looked at the computational
    thinking process, such as the use of dictionaries and functions. This chapter
    will allow you to find critical information more easily when looking for Python
    commands to meet your computational thinking problem needs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们深入研究Python编程语言时，请记住，一些内容已经在之前的章节中涵盖过，比如我们在研究计算思维过程时使用的字典和函数。本章将帮助您更轻松地找到满足您计算思维问题需求的Python命令的关键信息。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter08)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要最新版本的Python来运行本章中的代码。您可以在此处找到本章中使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter08](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter08)
- en: Introducing Python
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Python
- en: Python is one of the fastest-growing programming languages due to its ease of
    use. One of the draws of Python is that we can write the same programs we do with
    languages such as C, C++, and Java, but with fewer lines of code and simpler language
    and syntax. Another big draw of Python is that it is **extensible**, which means
    we can add capabilities and functionalities to it.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其易用性，Python是增长最快的编程语言之一。Python的吸引力之一是，我们可以用更少的代码行和更简单的语言和语法编写与C、C++和Java等语言相同的程序。Python的另一个吸引力在于它是**可扩展的**，这意味着我们可以为其添加功能和功能。
- en: While not all functionalities are inherently built in, we can use libraries
    to add what we need. Those libraries are available to download and use. For example,
    if we wanted to work with data and data science, there are a few libraries we
    can download, such as **Pandas**, **NumPy**, **Matplotlib**, **SciPy**, **Scikit
    Learn**, and more. But before we get into those libraries, let's look at how the
    Python language works and learn its basics.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有功能都是内置的，但我们可以使用库来添加我们需要的功能。这些库可以下载并使用。例如，如果我们想要处理数据和数据科学，我们可以下载一些库，比如**Pandas**、**NumPy**、**Matplotlib**、**SciPy**、**Scikit
    Learn**等。但在我们深入研究这些库之前，让我们先了解一下Python语言的工作原理并学习其基础知识。
- en: 'Python has some built-in reference functions. The following table shows the
    functions in alphabetical order:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python具有一些内置的引用函数。下表按字母顺序列出了这些函数：
- en: '![Table 8.1 – Python built-in functions'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '![表8.1 - Python内置函数'
- en: '](image/Table_8.1.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_8.1.jpg)'
- en: Table 8.1 – Python built-in functions
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.1 - Python内置函数
- en: While we won't go over all the functions in this book, we will use some of them
    as we look at Python and its algorithms. Let's start with some of the mathematical
    functions listed here.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会在本书中涵盖所有的函数，但在研究Python及其算法时，我们会使用其中一些函数。让我们从这里列出的一些数学函数开始。
- en: Mathematical built-in functions
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学内置函数
- en: In Python, some of the mathematical functions are already built in, such as
    the `abs()`, `eval()`, `max()`, `min()`, and `sum()` functions. These are not
    the only mathematical functions built in, but we'll take a closer look at these
    particular ones in order to understand how Python deals with them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一些数学函数已经内置，比如`abs()`、`eval()`、`max()`、`min()`和`sum()`函数。这些并非所有内置的数学函数，但我们将仔细研究这些特定函数，以了解Python如何处理它们。
- en: 'The `abs()` function will help us find the absolute value of a number, either
    an integer or a float. Take a look at the following code snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`abs()`函数将帮助我们找到一个数的绝对值，无论是整数还是浮点数。请看下面的代码片段：'
- en: ch8_absFunction.py
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_absFunction.py
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run this program, we''ll get the absolute value of `–3.89`. Remember
    that the absolute value of a number is its distance from 0\. Take a look at the
    output when we run this program:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，我们将得到`–3.89`的绝对值。请记住，一个数的绝对值是它到0的距离。运行这个程序时，请看一下输出：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Since the absolute value is always positive, when we run `abs(–3.89)`, we get
    `3.89`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绝对值始终是正数，当我们运行`abs(–3.89)`时，我们得到`3.89`。
- en: 'Another helpful mathematical function is the `eval()` function. We can define
    a variable in this function and then call for Python to evaluate an algebraic
    expression using that value. In the Python shell, we can first define the variable
    as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的数学函数是`eval()`函数。我们可以在这个函数中定义一个变量，然后调用Python来使用该值评估代数表达式。在Python shell中，我们可以首先定义变量如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that the variable is defined, we can call the `eval()` function with any
    expression. For example, take a look at the following input and output:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在变量已经定义，我们可以用任何表达式调用`eval()`函数。例如，请看下面的输入和输出：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, Python used the previously defined `p` value of `2`, and substituted
    then evaluated the expression to produce this output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Python使用了先前定义的`p`值`2`，并替换然后评估表达式以产生这个输出：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Python program also works as a calculator, so you can perform mathematical
    operations as you normally would. Here are a few examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序也可以作为计算器使用，因此你可以像平常一样进行数学运算。以下是一些例子：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As you can see, Python knows to read the dash as a subtraction and produces
    the result of the mathematical expression:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Python知道将破折号视为减法，并产生数学表达式的结果：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the next case, Python interpreted `+` as a mathematical symbol and provided
    the result of the sum expression:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个案例中，Python将`+`解释为数学符号，并提供了求和表达式的结果：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice the last expression, `10**5`. In Python, we can use two stars (`**`)
    to denote exponents:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意最后一个表达式`10**5`。在Python中，我们可以使用两个星号（`**`）表示指数：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let''s take a look at the `max()` function. This function can be used
    on an iterable list, but we can test it with just two numbers:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`max()`函数。这个函数可以用在可迭代的列表上，但我们可以用只有两个数字的列表来测试它：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can clearly see what the output is:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到输出是什么：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s take another example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is the output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As you can see from the output, the function always chooses the largest item.
    You can add a third item and the function will still choose the maximum value.
    These built-in functions are smart in a way that they are coded to work with what
    is provided – two or three items, for example – without having to tell Python
    explicitly how many items we''ll be introducing:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看出，该函数总是选择最大的项。你可以添加第三个项，该函数仍然会选择最大值。这些内置函数在某种程度上很聪明，它们被编码为能够处理所提供的内容
    - 例如两个或三个项 - 而无需明确告诉Python我们将引入多少项：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output obtained is:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的输出是：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As you can see, we did not have to add anything to the built-in function to
    find the maximum of three values.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们不必向内置函数添加任何内容来找到三个值的最大值。
- en: 'The `min()` function is the opposite; it chooses the minimum value. Take a
    look at the following minimum function:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`函数则相反；它选择最小值。看一下下面的最小函数：'
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is the output:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: As you can see, the function used the same list we used for the maximum function,
    but this time the output is `109`, which is the minimum value of that group of
    numbers.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，该函数使用了与最大函数相同的列表，但这次输出是`109`，这是该组数字的最小值。
- en: There are other mathematical functions, such as `sum()`. If you're a Python
    beginner, it's recommended that you play around with those functions to learn
    how they work. These functions will be key to your algorithms as you design solutions
    for computational thinking problems. We will also use some of these functions
    as we look at other Python functionalities, such as dictionaries and arrays.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他数学函数，比如`sum()`。如果你是Python初学者，建议你尝试使用这些函数来了解它们的工作方式。这些函数将成为你算法的关键，因为你设计计算思维问题的解决方案。当我们研究其他Python功能时，比如字典和数组，我们也会使用其中一些函数。
- en: Working with dictionaries and lists
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用字典和列表
- en: Before we get too deep into dictionaries and lists, it's important to note that
    Python does not contain arrays in the built-in functions. We can use lists and
    perform a lot of the traditional functions on lists that we'd use for arrays.
    However, for more robust functionalities with arrays, a library is needed, such
    as NumPy.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究字典和列表之前，重要的是要注意Python的内置函数中不包含数组。我们可以使用列表，并对列表执行许多传统的数组函数。但是，对于数组的更强大功能，需要使用库，例如NumPy。
- en: 'Python has four collection data types, which are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Python有四种集合数据类型，如下所示：
- en: '**Lists**: Ordered and changeable; can have duplicates'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列表**：有序且可更改；可以有重复项'
- en: '**Tuples**: Ordered and unchangeable; can have duplicates'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**元组**：有序且不可更改；可以有重复项'
- en: '**Sets**: Unordered and unindexed; cannot have duplicates'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：无序且无索引；不能有重复项'
- en: '**Dictionaries**: Unordered, changeable, and indexed; cannot have duplicates'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典**：无序、可更改和有索引；不能有重复项'
- en: As noted, we won't be going into NumPy libraries or other data libraries just
    yet. For now, we're going to focus on dictionaries and lists.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们暂时不会涉及NumPy库或其他数据库。现在，我们将专注于字典和列表。
- en: Defining and using dictionaries
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和使用字典
- en: 'You may recall that we used dictionaries in [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding Algorithms and Algorithmic Thinking*, when we created a menu of
    items. Dictionaries in Python are collections that have the following three characteristics:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还记得我们在[*第3章*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056)中使用了字典，*理解算法和算法思维*，当时我们创建了一个项目菜单。Python中的字典是具有以下三个特征的集合：
- en: They are unordered.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是无序的。
- en: They are changeable.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们是可更改的。
- en: They are indexed by keys.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们由键索引。
- en: 'Dictionaries are organized as value pairs. For example, we can have a dictionary
    with value pairs of states and their capitals. Take a look at the following dictionary:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是以值对的形式组织的。例如，我们可以有一个包含州和它们的首府值对的字典。看一下下面的字典：
- en: ch8_dictionary1.py
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_dictionary1.py
- en: '[PRE19]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we were to print this dictionary without any conditions to the `print` statement,
    we would get the following output:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在没有条件的情况下将这个字典打印出来，我们会得到以下输出：
- en: '[PRE20]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, each value pair is printed at once. Just like we built the
    dictionary in this way, Python also has a built-in `dict()` function. The same
    dictionary can be built using that function, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，每个值对都一次打印出来。就像我们以这种方式构建了字典一样，Python也有一个内置的`dict()`函数。可以使用该函数构建相同的字典，如下所示：
- en: ch8_dictionary2.py
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_dictionary2.py
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You can see that the dictionary is constructed very similarly in both examples,
    with some changes in syntax, such as the use of colons in the first instance,
    versus parentheses and commas in the second one. However, the `print` statement
    produces the same result.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这两个例子中字典的构造方式非常相似，语法上有一些变化，比如第一个实例中使用冒号，而第二个实例中使用括号和逗号。然而，`print`语句产生了相同的结果。
- en: 'Dictionaries are said to be key-value pairs because the first item is the key
    and the second, paired item is the value. So, for `Ohio` and `Columbus`, `Ohio`
    is the *key* while `Columbus` is the *value*. We can use the key to call any value.
    For example, I can call `states[''Ohio'']` and it should return `''Columbus''`.
    Take a look at the code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 据说字典是键值对，因为第一个项目是键，第二个配对项目是值。因此，对于`Ohio`和`Columbus`，`Ohio`是*键*，而`Columbus`是*值*。我们可以使用键来调用任何值。例如，我可以调用`states['Ohio']`，它应该返回`'Columbus'`。看一下代码：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This is the output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can do that for any key-value pair in the dictionary. But if we try to call
    a key that''s not in the dictionary, such as `Alabama`, then we get the following
    error:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为字典中的任何键值对做到这一点。但是，如果我们尝试调用字典中没有的键，比如`Alabama`，那么我们会得到以下错误：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This leads to the following error being displayed:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致显示以下错误：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice that this gives a `KeyError`, mentioned in the list of errors in [*Chapter
    7*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100), *Identifying Challenges within
    Solutions*, in the *Errors in logic* section. But let''s say we do want to add
    `Alabama` and the capital, which is `Montgomery`. We can use the following code
    to do so:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这会导致`KeyError`，在[*第7章*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100)的错误列表中提到，*在解决方案中识别挑战*，在*逻辑错误*部分。但是假设我们确实想要添加`Alabama`和首都`Montgomery`。我们可以使用以下代码来实现：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can call the dictionary again after entering the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输入以下代码后再次调用字典：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This gives us the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们以下输出：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the dictionary added the `'Alabama':'Montgomery'` key-value pair
    at the end of the dictionary.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，字典在字典末尾添加了`'Alabama':'Montgomery'`键值对。
- en: 'We can also delete key-value pairs using the `del` code, as shown:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`del`代码删除键值对，如下所示：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, if we go ahead and print the `states` dictionary, `Delaware` is no longer
    on the list:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们继续打印`states`字典，`Delaware`就不再在列表中了：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This is the output after deleting the state:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 删除州之后的输出：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, you can continue to add items or delete them without having to go into
    the main algorithm.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以继续添加项目或删除它们，而无需进入主算法。
- en: 'With dictionaries, you can also add multiple values to one key. Let''s say
    I play three sports (I don''t). I could list those in a dictionary and match them
    to one key value. Take a look at the following algorithm:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字典，您还可以向一个键添加多个值。假设我玩三种运动（我没有）。我可以在字典中列出它们，并将它们与一个键值匹配。看一下以下算法：
- en: ch8_dictionary3.py
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_dictionary3.py
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We can print the full dictionary using `print(miscellaneous)`, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`print(miscellaneous)`打印完整的字典，如下所示：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is how we get the output:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们得到输出的方式：
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As you can see, the printed dictionary includes all the values. If I want to
    print only the sports, then I can use the `miscellaneous[''sports'']` code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，打印的字典包括所有值。如果我只想打印运动项目，那么我可以使用`miscellaneous['sports']`代码：
- en: '[PRE35]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This is the output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Notice that we did not use the `print()` function at all. We used the dictionary,
    which we called `miscellaneous`, and called the `'sports'` key. Note that we were
    able to get this result because we called the dictionary in the **IDLE** command
    window in Python. If you want to include this in your algorithm, you'll still
    need to use the `print()` function.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们根本没有使用`print()`函数。我们使用了我们称之为`miscellaneous`的字典，并调用了`'sports'`键。请注意，我们之所以能够得到这个结果，是因为我们在Python的**IDLE**命令窗口中调用了字典。如果您想将其包含在您的算法中，您仍然需要使用`print()`函数。
- en: While we won't go into all the functionalities of dictionaries here, you can
    see how they can be helpful in creating algorithms that contain key-value pairs.
    Python allows us to add and alter the dictionary, call values, and more with the
    use of simple code without having to access the entire dictionary to do so.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里不会详细介绍字典的所有功能，但您可以看到它们如何有助于创建包含键值对的算法。Python允许我们添加和修改字典，调用值等，而无需访问整个字典来实现这一点。
- en: Next, we'll take a look at lists.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们来看看列表。
- en: Defining and using lists
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义和使用列表
- en: 'Lists in Python are ordered and changeable. We can create lists for anything,
    such as types of animals, colors, fruit, numbers, or really whatever we want.
    Since we can have duplicate values, we could have a list for three apples that
    just says `apple, apple, apple`. For example, take a look at the list shown:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的列表是有序且可更改的。我们可以为任何事物创建列表，比如动物的类型、颜色、水果、数字，或者真的任何我们想要的东西。由于我们可以有重复的值，我们可以有一个只说`apple,
    apple, apple`的三个苹果的列表。例如，看一下所示的列表：
- en: ch8_list1.py
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_list1.py
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When we print this list, all the items are included. The output is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们打印这个列表时，所有项目都包括在内。输出如下：
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: As you can see, we have the same value three times. We would not be able to
    do that with a dictionary, which does not allow duplicate members.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有相同的值三次。我们无法在字典中做到这一点，因为字典不允许重复成员。
- en: 'Now, let''s take a look at what we can do with lists. Let''s start with the
    following list of animals:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们可以用列表做什么。让我们从以下动物列表开始：
- en: ch8_list2.py
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_list2.py
- en: '[PRE39]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The first item in the list is `''dog''`. Lists have indexes, starting at 0\.
    So, if we printed `animals[0]`, we''d get `dog`. We can check it here:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一项是`'dog'`。列表有索引，从0开始。因此，如果我们打印`animals[0]`，我们会得到`dog`。我们可以在这里检查：
- en: '[PRE40]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is the output with index 0:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是索引0的输出：
- en: '[PRE41]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'There are six items on the list, but the last index is `[5]`. So, to print
    `elephant`, we''d need to print using that index:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中有六个项目，但最后一个索引是`[5]`。因此，要打印`elephant`，我们需要使用该索引进行打印：
- en: '[PRE42]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'You can also use negative numbers for indexes in lists. The `[–1]` index refers
    to the last index, so it represents `elephant`, the same as index `[5]`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在列表中使用负数索引。`[–1]`索引是指最后一个索引，因此它代表`elephant`，与索引`[5]`相同：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `[–2]` index refers to the second-to-last index, so `tiger`, and so on.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`[–2]`索引是指倒数第二个索引，因此是`tiger`，以此类推。'
- en: 'We can also print multiple items from a list by specifying a range of indexes.
    Take a look at the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过指定索引范围来打印列表中的多个项目。看一下以下代码：
- en: '[PRE44]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is the output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE45]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As you can see, we printed the second item on the list, which corresponds to
    index `[1]`, and the next two items.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们打印了列表中的第二个项目，对应索引`[1]`，以及接下来的两个项目。
- en: 'With lists, we can also add items, replace items, delete items, check for the
    length, and more. To add an item, we need to use the `append()` method. Let''s
    add the `duck` item to our list:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用列表，我们还可以添加项目，替换项目，删除项目，检查长度等等。要添加一个项目，我们需要使用`append()`方法。让我们把`duck`项目添加到我们的列表中：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Here is the added item:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是添加的项目：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Notice that our list now has `duck` at the end of the list. But let''s say
    we want to remove `bird` and substitute it with `butterfly`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的列表现在在列表末尾有`duck`。但是假设我们想要移除`bird`并用`butterfly`替换它：
- en: 'First, we have to identify the index for `bird`. That index is `2`, as it is
    the third item on the list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须确定`bird`的索引。该索引是`2`，因为它是列表中的第三个项目：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Here is the output, with `bird` replaced:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出，`bird`被替换了：
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The list now contains `butterfly`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 列表现在包含`butterfly`。
- en: 'Removing an item is fairly straightforward, as we just use the `remove()` method
    and the item we want to remove:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 删除一个项目相当简单，我们只需使用`remove()`方法和我们想要删除的项目：
- en: '[PRE50]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, `lion` has been removed from the list:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`lion`已经从列表中移除了：
- en: '[PRE51]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We can also remove an item by index using the `pop()` method. Using index `1`
    removes the second item on the list. Refer to the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过索引使用`pop()`方法删除一个项目。使用索引`1`会移除列表中的第二个项目。参考以下代码：
- en: '[PRE52]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Then, we can try the following:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试以下操作：
- en: '[PRE53]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that Python identifies the item at index `1` that was *popped* out of
    the list. When we print the list again, the item is no longer there. If we want
    to remove the last item, we do not have to specify an index. Refer to the following
    code:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Python识别了从列表中*弹出*的索引`1`处的项目。当我们再次打印列表时，该项目就不再存在了。如果我们想要移除最后一个项目，我们不必指定索引。参考以下代码：
- en: '[PRE54]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we can try the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试以下操作：
- en: '[PRE55]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As mentioned, when no index is specified, the last item on the list is *popped*
    and removed from the list.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，当没有指定索引时，列表上的最后一个项目会被*弹出*并从列表中移除。
- en: 'There is yet another way to remove an item from the list, by using the `del`
    keyword:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种方法可以从列表中删除一个项目，那就是使用`del`关键字：
- en: '[PRE56]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This is the output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE57]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Our list lost the second item on the list. We can also use the `del` keyword
    to delete the list entirely:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列表失去了列表中的第二个项目。我们还可以使用`del`关键字完全删除列表：
- en: '[PRE58]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This error is the output here:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误是输出在这里：
- en: '[PRE59]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: As you can see, I can no longer print the list because it is not defined. Notice
    we received a `NameError` description of `name 'animals' is not defined`. This
    is one of the other errors mentioned in [*Chapter 7*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100),
    *Identifying Challenges within Solutions*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我不能再打印列表，因为它没有定义。请注意，我们收到了一个`NameError`描述`name 'animals' is not defined`。这是[*第7章*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100)中提到的另一个错误，*在解决方案中识别挑战*。
- en: 'Important Note:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: For the next few code examples, I ran my original code from the `ch8_list2.py`
    file again to get my original list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个代码示例中，我再次运行了`ch8_list2.py`文件中的原始代码，以获得我的原始列表。
- en: We can clear an entire list without eliminating the actual list by using the
    `clear()` method, as follows.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`clear()`方法清空整个列表，而不是消除实际的列表。
- en: '[PRE60]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is the output we get:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们得到的输出：
- en: '[PRE61]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: In this case, the list now prints as an empty list without giving an error message.
    That's because the list is still there and defined, it's just empty.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，列表现在打印为空列表，而不会给出错误消息。这是因为列表仍然存在并且已定义，只是空的。
- en: 'Now, let''s say I wanted the length of my list. We can find the length of the
    list by using `len()`. Again, I went back to the original list to run the following
    code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我想要知道我的列表的长度。我们可以使用`len()`来找到列表的长度。同样，我回到原始列表运行以下代码：
- en: '[PRE62]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We get the following output:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE63]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Our original list contained six elements – that is, six animals.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的原始列表包含六个元素 - 也就是六种动物。
- en: 'Now, let''s define another list that contains colors:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义另一个包含颜色的列表：
- en: ch8_list3.py
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_list3.py
- en: '[PRE64]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The output for this algorithm is two lists. Now, if we wanted to combine the
    two lists, we could do so using the `extend()` method.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法的输出是两个列表。现在，如果我们想要合并这两个列表，我们可以使用`extend()`方法。
- en: 'Let''s take a look at how we can append `colors` to the `animals` list:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将`colors`附加到`animals`列表中：
- en: '[PRE65]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is the appended list:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是追加后的列表：
- en: '[PRE66]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Our list now includes all our animals and all our colors. We could have also
    used the following method to extend `colors` with `animals`. The difference is
    that the colors would appear first on our list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的列表现在包含了所有的动物和所有的颜色。我们也可以使用以下方法将`colors`与`animals`扩展。不同之处在于颜色会首先出现在我们的列表中：
- en: '[PRE67]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This is how the list now appears:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在列表的样子是这样的：
- en: '[PRE68]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can also sort lists, which is helpful when we want to have an alphabetical
    list or if we want to sort a list of numbers. Take a look at the two lists in
    the following algorithm:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以对列表进行排序，当我们想要有一个按字母顺序排列的列表或者想要对数字列表进行排序时，这是很有帮助的。看一下以下算法中的两个列表：
- en: ch8_list4.py
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_list4.py
- en: '[PRE69]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This is how they appear unsorted:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是它们未排序时的样子：
- en: '[PRE70]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s sort both lists and see what happens:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对两个列表进行排序，看看会发生什么：
- en: '[PRE71]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We will get this output:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE72]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Then, we can try the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试以下操作：
- en: '[PRE73]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We get this as the output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到了这个输出：
- en: '[PRE74]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: As you can see, the numbers were sorted from smallest to largest, while the
    animals were sorted in alphabetical order.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，数字按从小到大的顺序排序，而动物按字母顺序排序。
- en: Let's talk for a second about why this is so helpful. Imagine that you have
    a list of items displayed on your website that come from a Python list. They are
    all sorted and perfectly displayed. But let's now say you want to add more items.
    It's easier to add them in any order to your list using the methods we have discussed,
    then we can sort them so that they continue to be in alphabetical order.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈一下为什么这样很有帮助。想象一下，你的网站上显示了来自Python列表的项目列表。它们都被排序并完美地显示出来。但现在让我们说你想添加更多的项目。使用我们讨论过的方法，将它们以任何顺序添加到你的列表中会更容易，然后我们可以对它们进行排序，以便它们继续按字母顺序排列。
- en: Of course, these are not the only things we can do with lists. Python allows
    us to work with lists in many ways that are user-friendly and function similar
    to what arrays do in other programming languages. When we need to use them in
    other ways, we can search for libraries that contain those functionalities.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些不是我们可以用列表做的唯一的事情。Python允许我们以许多用户友好的方式使用列表，并且与其他编程语言中的数组类似地进行操作。当我们需要以其他方式使用它们时，我们可以搜索包含这些功能的库。
- en: Both lists and dictionaries are important in the Python programming language.
    In this section, you saw that dictionaries use key-value pairs, while lists include
    values. Both can be edited using methods and functions built into the Python programming
    language. You'll see them again when we apply Python to more complex computational
    thinking problems in *Section 3*, *Data Processing, Analysis, and Applications
    Using Computational Thinking and Python*, of this book.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python编程语言中，列表和字典都很重要。在本节中，你看到字典使用键值对，而列表包括值。两者都可以使用内置在Python编程语言中的方法和函数进行编辑。当我们将Python应用于更复杂的计算思维问题时，你将再次看到它们，这在本书的*第3节*，*使用计算思维和Python进行数据处理、分析和应用*中。
- en: Now, we'll take a look at how we use variables and functions in Python.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Python中使用变量和函数。
- en: Using variables and functions
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用变量和函数
- en: In Python, we use variables to store a value. We can then use the value to perform
    operations, evaluate expressions, or use them in functions. Functions give sets
    of instructions for the algorithm to follow when they are called in an algorithm.
    Many functions include variables within them. So, let's first look at how we define
    and use variables, then take a look at Python functions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用变量来存储一个值。然后我们可以使用这个值来执行操作，评估表达式，或者在函数中使用它们。函数在算法中被调用时给出一系列指令。许多函数在其中包括变量。所以，让我们首先看看如何定义和使用变量，然后再看看Python函数。
- en: Variables in Python
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的变量
- en: 'Python does not have a command for declaring variables. We can create variables
    by naming them and setting them equal to whatever value we''d like. Let''s take
    a look at an algorithm that contains multiple variables:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有声明变量的命令。我们可以通过给它们命名并将它们设置为我们想要的任何值来创建变量。让我们看一个包含多个变量的算法：
- en: ch8_variables.py
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_variables.py
- en: '[PRE75]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As you can see, we can use a letter, a longer name, and even include underscores
    in naming our variables. We cannot, however, start a variable name with a number.
    When we run this program, we get the following output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以使用字母、更长的名称，甚至在变量命名中包括下划线。但是，我们不能以数字开头命名变量。当我们运行这个程序时，我们得到以下输出：
- en: '[PRE76]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Each variable was printed without any problems. If we had used a number to begin
    any variable name, we would have gotten an error. However, if I had named the
    `country_1` variable as `_country`, that would be an acceptable variable name
    in Python.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每个变量都被打印出来，没有任何问题。如果我们使用数字来开始任何变量名，我们会得到一个错误。但是，如果我将`country_1`变量命名为`_country`，那将是Python中一个可接受的变量名。
- en: Now, let's take a look at what we can do with variables.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们可以用变量做什么。
- en: Combining variables
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合变量
- en: 'One thing variables allow us to do is combine them in a `print` statement.
    For example, I can create a `print` statement that prints `Marcus Greece`. To
    do so, I can use the `+` character, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 变量允许我们做的一件事是在`print`语句中组合它们。例如，我可以创建一个打印`Marcus Greece`的`print`语句。为了做到这一点，我可以使用`+`字符，如下所示：
- en: '[PRE77]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Notice that between the two `+` characters, there''s `'' ''`. This is done
    to add a space so that our `print` statement won''t look like `MarcusGreece`.
    Now, let''s combine `b` and `name` in a `print` statement:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在两个`+`字符之间，有`' '`。这是为了添加一个空格，这样我们的`print`语句就不会看起来像`MarcusGreece`。现在，让我们在`print`语句中组合`b`和`name`：
- en: '[PRE78]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This will give us an error message:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给我们一个错误消息：
- en: '[PRE79]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Notice that the error states `TypeError: unsupported operand types for +`.
    It also states that we have `''int''` and `''str''`, which means we are combining
    two different data types.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，错误说明了`TypeError: unsupported operand types for +`。它还说明了我们有`''int''`和`''str''`，这意味着我们正在组合两种不同的数据类型。'
- en: 'To be able to combine those two data types in a `print` statement, we can just
    convert `int`, which is our `b` variable, to `str`. Here''s what that looks like:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够在`print`语句中组合这两种数据类型，我们可以将`int`（我们的`b`变量）转换为`str`。看起来是这样的：
- en: '[PRE80]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This easily gives us the desired result:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易给我们想要的结果：
- en: '[PRE81]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Now that we've made them both strings, we can combine them in the `print` function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将它们都变成了字符串，我们可以在`print`函数中将它们组合起来。
- en: 'Sometimes, we''ll want to create many variables at once. Python allows us to
    do that with one line of code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会想一次创建多个变量。Python允许我们用一行代码来做到这一点：
- en: ch8_variables2.py
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_variables2.py
- en: '[PRE82]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When we run this algorithm, we get the following output:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个算法时，我们得到以下输出：
- en: '[PRE83]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: As you can see, when we print the `a` variable, the first value to the right
    of the equals sign is printed. The first line of the algorithm assigned four different
    values to four different variables.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，当我们打印`a`变量时，等号右边的第一个值被打印出来。算法的第一行分配了四个不同的值给四个不同的变量。
- en: Let's now look at functions, as we'll need them to further our variables conversation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看函数，因为我们需要它们来进一步讨论变量。
- en: Working with functions
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数
- en: 'In [*Chapter 7*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100), *Identifying
    Challenges within Solutions*, we wrote an algorithm that printed even numbers
    for any given range of numbers. We''re going to revisit that by defining a function
    to do that work for us. Let''s take a look at an algorithm for the even numbers
    problem:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B15413_07_Final_SK_ePub.xhtml#_idTextAnchor100)，*在解决方案中识别挑战*中，我们编写了一个算法，打印出任何给定数字范围内的偶数。我们将通过定义一个函数来重新访问这个问题。让我们看一下偶数问题的算法：
- en: ch8_evenNumbers.py
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_evenNumbers.py
- en: '[PRE84]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: If we run this program in Python, there is no output; however, we can now run
    the function for any range of numbers. Notice that we have added an `a` and `b`
    variable within this function. That's so that the endpoints are included when
    the program runs.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python中运行此程序，将不会有输出；但是，我们现在可以为任何数字范围运行该函数。请注意，我们在此函数中添加了`a`和`b`变量。这样在程序运行时就会包括端点。
- en: 'Let''s see what happens when we run the program for the ranges `(2, 10)` and
    `(12, 25)`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们运行范围为`(2, 10)`和`(12, 25)`时会发生什么：
- en: '[PRE85]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The output is as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE86]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Then, we can try the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以尝试以下操作：
- en: '[PRE87]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The output is as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE88]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'As you can see, instead of having to go inside the algorithm to call the function,
    once we''ve run the function, we can just call it for any range in the Python
    shell. As before, if our range is too large, the shell will show a really long
    list of numbers. So, we can define another variable, this time a list, and append
    the values to that list within the function:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们无需进入算法来调用函数，一旦我们运行了函数，我们就可以在Python shell中为任何范围调用它。与以前一样，如果我们的范围太大，shell将显示一个非常长的数字列表。因此，我们可以定义另一个变量，这次是一个列表，并在函数内部将值附加到该列表：
- en: ch8_evenNumbers2.py
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_evenNumbers2.py
- en: '[PRE89]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Notice that we defined the list outside of the function. We can do it either
    way. It can live within the function or outside. The difference is that the list
    exists even if the function is not called; that is, once I run the algorithm,
    I can call the list, which will be empty, or call the function, which will use
    the list. If outside the function, it's a global variable. If inside, it only
    exists when the function is called.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在函数外定义了列表。我们可以以任何方式做。它可以存在于函数内部或外部。区别在于，即使未调用函数，列表也存在；也就是说，一旦运行算法，我可以调用列表，它将为空，或者调用函数，它将使用列表。如果在函数外部，它是全局变量。如果在内部，只有在调用函数时才存在。
- en: 'Let''s try to run that now for the range `(10, 50)`:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在尝试运行范围为`(10, 50)`的程序：
- en: '[PRE90]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This is the output:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE91]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: As you can see, the even numbers between and including `10` and `50` are now
    included in the list and printed.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，`10`和`50`之间的偶数现在包括在列表中并打印出来。
- en: 'Let''s look at another example of a function that takes a `(name)` string argument:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个接受`(name)`字符串参数的函数的示例：
- en: ch8_nameFunction.py
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_nameFunction.py
- en: '[PRE92]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Once we run this algorithm, we can call the function for any name. Take a look:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行了这个算法，我们就可以为任何名称调用该函数。看一下：
- en: '[PRE93]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'We get this output:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下输出：
- en: '[PRE94]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Let''s input another name:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们输入另一个名称：
- en: '[PRE95]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'We will see the following output:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE96]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: As you can see, once a function is defined in an algorithm and the algorithm
    is run, we can call that function, as needed.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一旦在算法中定义了一个函数并运行了算法，我们可以根据需要调用该函数。
- en: Now, we did use an iteration in the previous example with even numbers, so it's
    time we started looking more closely at files, data, and iteration, so let's pause
    and take a look at that. As we get to iteration, we'll run into a few more function
    examples.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在先前的偶数示例中使用了迭代，所以是时候更仔细地看看文件、数据和迭代了，让我们暂停一下并看看。当我们进行迭代时，我们将遇到更多的函数示例。
- en: Learning about files, data, and iteration
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习有关文件、数据和迭代的知识
- en: In this section, we're going to take a look at how to handle files, data, and
    iteration with Python. This will give us information on how to use an algorithm
    to open, edit, and run already-existing Python files or new files. With iteration,
    we'll learn how to repeat lines of code based on some conditions, limiting how
    many times or under what conditions a section of the algorithm will run for. We'll
    start with files first.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看看如何处理文件、数据和迭代与Python。这将为我们提供有关如何使用算法来打开、编辑和运行已存在的Python文件或新文件的信息。通过迭代，我们将学习如何根据某些条件重复代码行，限制算法的某个部分将运行多少次或在什么条件下运行。我们将首先从文件开始。
- en: Handling files in Python
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中处理文件
- en: 'In Python, the main function associated with files is the `open()` function.
    If you are opening a file in the same directory, you can use the following command
    line:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，与文件相关的主要函数是`open()`函数。如果要在相同目录中打开文件，可以使用以下命令行：
- en: '[PRE97]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If the file is in another location, you need to find the path for the file
    and include that in the command, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件位于另一个位置，您需要找到文件的路径并在命令中包含该路径，如下所示：
- en: '[PRE98]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'There are a few more things we can tell the program to do in addition to opening
    the file. They are listed as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 除了打开文件之外，我们还可以告诉程序做一些其他事情。它们列在下面：
- en: '`r`: Used to open the file for reading (this is the default, so it does not
    need to be included); creates a new file if the file does not exist.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：用于打开文件进行读取（这是默认值，因此不需要包含）；如果文件不存在，则创建新文件。'
- en: '`w`: Used to open the file for writing; creates a new file if the file does
    not exist.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：用于打开文件进行写入；如果文件不存在，则创建新文件。'
- en: '`a`: Used to open a file to append; creates a new file if the file does not
    exist.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a`：用于打开文件以进行追加；如果文件不存在，则创建新文件。'
- en: '`x`: Used to create a specified file; if the file already exists, returns an
    error.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：用于创建指定的文件；如果文件已经存在，则返回错误。'
- en: 'There are two more things that can be used in addition to the methods listed.
    When used, they identify how a file needs to be handled – that is, as binary or
    text:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 除了列出的方法之外，还有两件事可以用于标识文件需要如何处理 - 即作为二进制还是文本：
- en: '`t`: Text (this is the default, so if not specified, it defaults to text)'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`t`：文本（这是默认值，因此如果未指定，则默认为文本）'
- en: '`b`: Binary (used for binary mode – for example, images)'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`: 二进制（用于二进制模式 - 例如图像）'
- en: 'Take a look at the following code. Since this code is a single line and specific
    to each path, it is not included in the repository:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下代码。由于这段代码是单行的，而且针对每个路径都是特定的，所以没有包含在存储库中：
- en: '[PRE99]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The preceding code is the same as the previous code, `fOpen = open('filename.txt')`.
    Since `r` and `t` are the defaults, not including them results in the same execution
    of the algorithm.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码与先前的代码相同，`fOpen = open('filename.txt')`。由于`r`和`t`是默认值，不包括它们会导致算法的相同执行。
- en: If we wanted to open a file for writing, we could use the `fOpen = open('filename.txt',
    'w')` code. To close files in Python, we use the `close()` code.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要打开一个文件进行写入，我们可以使用`fOpen = open('filename.txt', 'w')`代码。在Python中关闭文件，我们使用`close()`代码。
- en: 'Some additional methods for text files are included in the following list.
    This is not an exhaustive list, but contains some of the most commonly used methods:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件的一些附加方法包括在以下列表中。这不是一个详尽的列表，但包含了一些最常用的方法：
- en: '`read()`: Can be used to read lines of a file; using `read(3`) reads the first
    3 data.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`read()`: 可以用来读取文件的行；使用`read(3)`读取前3个数据。'
- en: '`tell()`: Used to find the current position as a number of bytes.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tell()`: 用于找到当前位置的字节数。'
- en: '`seek()`: Moves the cursor to the original/initial position.'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seek()`: 将光标移动到原始/初始位置。'
- en: '`readline()`: Reads each individual line of a file.'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readline()`: 读取文件的每一行。'
- en: '`detach()`: Used to separate the underlying binary buffer from `TextIOBase`
    and return it.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detach()`: 用于将底层二进制缓冲区与`TextIOBase`分离并返回它。'
- en: '`readable()`: This will return `True` if it can read the file stream.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readable()`: 如果可以读取文件流，则返回`True`。'
- en: '`fileno()`: Used to return an integer number for the file.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fileno()`: 用于返回文件的整数编号。'
- en: As you can see, you can use Python to manipulate and get information from text
    files. This can come in handy when adding lines of code to an existing text file,
    for example. Now, let's look at data in Python.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你可以使用Python来操纵并从文本文件中获取信息。例如，当向现有文本文件添加代码行时，这可能会很有用。现在，让我们来看看Python中的数据。
- en: Data in Python
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Python中的数据
- en: Before we get into data, let's clarify that we're not talking about data types,
    which we discussed in [*Chapter 1*](B15413_01_Final_SK_ePub.xhtml#_idTextAnchor017),
    *Fundamentals of Computer Science*. For this chapter, we're looking at data and
    ways to interact with it, mostly as lists.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理数据之前，让我们澄清一下，我们不是在讨论数据类型，这是我们在[*第1章*](B15413_01_Final_SK_ePub.xhtml#_idTextAnchor017)中讨论的，*计算机科学基础*。在本章中，我们将主要以列表的形式查看数据和与数据交互的方式。
- en: Let's look at some of the things we can do with data.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以用数据做些什么。
- en: First, grab the `ch8_survey.txt` file from the repository. You'll need it for
    the next algorithm.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从存储库中获取`ch8_survey.txt`文件。你将需要它用于下一个算法。
- en: 'Say you asked your friends to choose between the colors blue, red, and yellow
    for a group logo. The `ch8_survey.txt` file contains the results of those votes.
    Python allows us to manipulate that data. For example, the first line of the file
    says `Payton – Blue`. We can make that line print out `Payton voted for Blue`
    instead. Let''s look at the algorithm:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你让你的朋友们在蓝色、红色和黄色之间为一个团体标志进行选择。`ch8_survey.txt`文件包含了这些投票的结果。Python允许我们操纵这些数据。例如，文件的第一行说`Payton
    – Blue`。我们可以使该行打印出`Payton投票支持蓝色`。让我们看看算法：
- en: ch8_surveyData.py
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_surveyData.py
- en: '[PRE100]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s break down our code to understand what is happening:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的代码，以了解发生了什么：
- en: The first line opens the survey file and keeps it open.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行打开了调查文件并保持打开状态。
- en: The next line, `for line in file`, will iterate through each line in the file
    to perform the following commands.
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一行，`for line in file`，将遍历文件中的每一行执行以下命令。
- en: The algorithm then takes the information and splits it at the dash. The first
    part is defined as the name (`name = divide[0]`) and the second is defined as
    the color (`color = divide[1]`).
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后算法将信息分割在破折号处。第一部分被定义为名字（`name = divide[0]`），第二部分被定义为颜色（`color = divide[1]`）。
- en: Finally, the code prints out the line with the `voted for` text added.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，代码打印出了带有`投票支持`文本的行。
- en: 'Take a look at the following output:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下输出：
- en: '[PRE101]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'As you can see, you now have each line adjusted to remove the dashes and include
    the `voted for` phrase. But what if you wanted to count the votes? We can write
    an algorithm for that as well:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，现在每一行都经过调整，去掉了破折号，并包括了`投票支持`短语。但是如果你想要计算投票呢？我们也可以为此编写一个算法：
- en: ch8_surveyData2.py
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_surveyData2.py
- en: '[PRE102]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'As you can see, we are counting the votes by verifying each line and using
    the `if color == "Blue"` code. When we run this algorithm, we get the following
    output:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们正在通过验证每一行并使用`if color == "Blue"`代码来计算投票。当我们运行这个算法时，我们得到以下输出：
- en: '[PRE103]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: As you can see, the algorithm prints out the initial `print()` command, then
    prints the counted votes for `Blue`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，该算法打印出了初始的`print()`命令，然后打印出了`蓝色`的计数投票。
- en: We can also work with data to find things such as the mean, median, and mode,
    but we won't go over those now. If we need them in the future for one of our applied
    problems, we'll go ahead and use them. However, most of those data-specific problems
    will use libraries to simplify some of the algorithms and computations.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以处理数据，找出诸如均值、中位数和众数之类的东西，但现在我们不会详细讨论。如果将来我们在某个应用问题中需要它们，我们会使用它们。然而，大多数这些特定于数据的问题将使用库来简化一些算法和计算。
- en: Now, let's talk a bit more about iteration, which we've been using but will
    need to define further to better understand its use.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再谈一下迭代，我们一直在使用，但需要进一步定义以更好地理解其用法。
- en: Using iteration in algorithms
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在算法中使用迭代
- en: Before we go into iteration, let's define the term. **Iteration** means repetition.
    When we use iteration in algorithms, we are repeating steps. Think of a `for`
    loop , which we've used in problems before, such as the even numbers problem—the
    algorithm iterated through a range of numbers. It repeated for all the numbers
    in our range.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入迭代之前，让我们定义一下术语。**迭代**意味着重复。当我们在算法中使用迭代时，我们正在重复步骤。想想我们之前在问题中使用过的`for`循环，比如偶数问题——算法迭代了一系列数字。它对我们范围内的所有数字进行了重复。
- en: 'Let''s take a look at another example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子：
- en: ch8_colorLoop.py
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_colorLoop.py
- en: '[PRE104]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The iteration in this algorithm is that it will repeat the `print` process for
    each of the colors in the original colors list.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法中的迭代是它将为原始颜色列表中的每种颜色重复执行`print`过程。
- en: 'This is the output:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出：
- en: '[PRE105]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: As you can see, each of the colors was printed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每种颜色都被打印出来了。
- en: 'We can also get input from a user, then iterate to perform some operation.
    For example, take a look at the following algorithm:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从用户那里获取输入，然后迭代执行一些操作。例如，看看以下算法：
- en: ch8_whileAlgorithm.py
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_whileAlgorithm.py
- en: '[PRE106]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: As you can see, we defined `ask` as the input variable. Then, we printed double
    the number and reduced the number by `1` as long as `ask` was greater than `0`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们将输入变量定义为`ask`。然后，只要`ask`大于`0`，我们就打印出加倍的数字并将数字减`1`。
- en: 'The output looks like this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE107]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The output shows the list created by doubling the initial number, which is *8*
    x *2 = 16*, then continues until the `ask` variable is no longer greater than
    `0`.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了通过将初始数字加倍而创建的列表，即*8* x *2 = 16*，然后继续直到`ask`变量不再大于`0`。
- en: 'Next, let''s take a look at how we can iterate through multiple lists. The
    algorithm uses two lists and then prints a single statement using information
    from both:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何可以迭代遍历多个列表。该算法使用两个列表，然后使用两者的信息打印出一个语句：
- en: ch8_Iterations.py
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_Iterations.py
- en: '[PRE108]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'When we run the algorithm, we get the following output:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行算法时，我们得到以下输出：
- en: '[PRE109]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Take a look at the `print` statement: `print("Type of jewelry:` `%s` `in` `%s`
    `color."` `%(j,` `c))`. The `%s` symbols will be replaced by the `(j,` `c)` values,
    respectively. So, the first `%s` symbol gets the items from `j` and the second
    `%s` symbol gets the items from `c`, where `j` is the item from the jewelry list
    and `c` is the color from the colors list.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下`print`语句：`print("Type of jewelry:` `%s` `in` `%s` `color."` `%(j,` `c))`。`%s`符号将分别被`(j,`
    `c)`的值替换。因此，第一个`%s`符号获取`j`的项目，第二个`%s`符号获取`c`的项目，其中`j`是来自珠宝列表的项目，`c`是来自颜色列表的颜色。
- en: As you can see, we can iterate through lists in multiple ways. These are only
    a few examples to get comfortable with loops and how to use information in our
    algorithms. As we dive deeper into more complex problems, the algorithms will
    get more sophisticated, so we'll revisit many of the topics in this chapter and
    earlier chapters.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以以多种方式迭代列表。这只是一些示例，让我们熟悉循环和如何在我们的算法中使用信息。随着我们深入更复杂的问题，算法将变得更复杂，所以我们将重新讨论本章和之前章节中的许多主题。
- en: Before moving on to the next chapter, we need to look at **Object-Oriented Programming**
    (**OOP**).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入下一章之前，我们需要看一下**面向对象编程**（**OOP**）。
- en: Using object-oriented programming
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用面向对象编程
- en: 'OOP is a way to structure data into objects. The Python program is an object-oriented
    program in that it structures algorithms as objects in order to bundle them based
    on properties and behaviors. To learn about OOP, we will need to know how to do
    the following:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程是一种将数据结构化为对象的方法。Python程序是一种面向对象的程序，它将算法结构化为对象，以便根据属性和行为对它们进行打包。要了解面向对象编程，我们需要知道如何做以下事情：
- en: Create classes
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建类
- en: Use classes to create objects
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类创建对象
- en: Use class inheritance to model systems
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类继承来建模系统
- en: 'In Python, we use classes to bundle data. To understand classes, let''s create
    one:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们使用类来打包数据。要理解类，让我们创建一个：
- en: '[PRE110]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'We can then call the `Books()` class and get the location where the class is
    saved on our computer. Notice that my output will not match yours, as the class
    will be saved in different locations:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以调用`Books()`类并获取类在计算机上保存的位置。请注意，我的输出将与您的不同，因为类将保存在不同的位置：
- en: '[PRE111]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'This is my output:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的输出：
- en: '[PRE112]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now that we''ve created the class, we can add book objects to the class:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了类，我们可以向类添加书籍对象：
- en: '[PRE113]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Each of these instances is a distinct object in `Books()`. If we were to compare
    them, since they are distinct, `a == b` would return `False`.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实例中的每一个都是`Books()`中的一个独特对象。如果我们要比较它们，由于它们是不同的，`a == b`将返回`False`。
- en: 'Now, let''s take a look at a class that creates an address book. By creating
    the class, we can add entries as needed:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个创建地址簿的类。通过创建类，我们可以根据需要添加条目：
- en: ch8_addressBook.py
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_addressBook.py
- en: '[PRE114]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'In this algorithm, we''ve created an `Entry` class that stands for items in
    an address book. Once we run the algorithm, we can add entries to the address
    book and call information on them. For example, take a look at the following code:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个算法中，我们创建了一个代表地址簿中条目的`Entry`类。一旦我们运行算法，我们就可以向地址簿添加条目并调用它们的信息。例如，看看以下代码：
- en: '[PRE115]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This code enters `Johnny` into the address book. Now, we can call Johnny''s
    first name, last name, and phone number separately, as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`Johnny`输入地址簿。现在，我们可以分别调用Johnny的名字、姓氏和电话号码，如下所示：
- en: '[PRE116]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'This is my output:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的输出：
- en: '[PRE117]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'We can call the last name:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用姓氏：
- en: '[PRE118]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'This is the obtained output:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获得的输出：
- en: '[PRE119]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can also call for phone number:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以调用电话号码：
- en: '[PRE120]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'We can see the output for this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个输出：
- en: '[PRE121]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'We can add as many entries as we''d like, then call them as needed:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加任意多的条目，然后根据需要调用它们：
- en: '[PRE122]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'This is our output:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的输出：
- en: '[PRE123]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'After adding the entries, we can call a last name:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 添加条目后，我们可以调用姓氏：
- en: '[PRE124]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'We get this output:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个输出：
- en: '[PRE125]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: As you can see, we added two new entries, then called Emma's phone number and
    Max's last name.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们添加了两个新条目，然后调用了Emma的电话号码和Max的姓氏。
- en: Once we have classes, we can have one class that inherits methods and attributes
    for other classes. Because the classes are inheriting the attributes and methods,
    the original class is called the **parent class**, while the new class is called
    a **child class**.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了类，我们就可以有一个类继承其他类的方法和属性。因为这些类继承了属性和方法，原始类被称为**父类**，而新类被称为**子类**。
- en: 'Going back to our address book, we can create a child class by passing the
    class to the new one. I know, it sounds confusing, but take a look at the algorithm:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的地址簿，我们可以通过将类传递给新类来创建一个子类。我知道，这听起来很混乱，但看一下这个算法：
- en: '[PRE126]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'We can now add more items using that child class as well. See the following
    example:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以使用子类添加更多项目。看下面的例子：
- en: '[PRE127]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We can do more with classes, but let's try to pull this chapter together by
    solving a problem and designing an algorithm that uses at least some of the components
    learned about.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用类做更多的事情，但让我们尝试通过解决一个问题并设计一个算法，使用至少学到的一些组件来总结这一章。
- en: Problem 1 - Creating a book library
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题1 - 创建一个书库
- en: Let's say you have a lot of books and want to create an algorithm that stores
    information about the books. You want to record each book's title, author, publication
    date, and number of pages. Create an algorithm for this scenario.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有很多书，想创建一个存储有关书籍信息的算法。你想记录每本书的标题、作者、出版日期和页数。为这种情况创建一个算法。
- en: 'First, let''s think about the problem:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们思考一下问题：
- en: The number of books I own changes constantly, so I'd want to create something
    that I can add information to, as needed.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我拥有的书的数量不断变化，所以我希望创建一个可以根据需要添加信息的东西。
- en: I also want to be able to remove books that I no longer own.
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我也希望能够删除我不再拥有的书。
- en: 'While we could use a library, the best solution for this particular problem
    would be a class. Let''s start by creating a class called `Books`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用库，但对于这个特定的问题，最好的解决方案是一个类。让我们从创建一个名为`Books`的类开始：
- en: ch8_BookLibrary.py
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_BookLibrary.py
- en: '[PRE128]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'As you can see, we have our class defined. The class has four arguments: `title`,
    `author`, `pubDate`, and `pages`. After the definition, two books have been added.
    When we run this program, nothing happens, really, but we can then call information
    on either book:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经定义了我们的类。该类有四个参数：`title`、`author`、`pubDate`和`pages`。在定义之后，添加了两本书。当我们运行这个程序时，实际上什么都不会发生，但我们可以调用任一本书的信息：
- en: '[PRE129]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'We will get this output:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE130]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'We will call the publishing date of `book2`:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将调用`book2`的出版日期：
- en: '[PRE131]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'We obtain this output:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个输出：
- en: '[PRE132]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: You can see that I can now call any of the elements saved for each of the books
    after I've run the algorithm.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，我现在可以在运行算法后调用每本书保存的任何元素。
- en: 'Now, take a look at how a third book can be added within the Python shell,
    as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何在Python shell中添加第三本书：
- en: '[PRE133]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Since the book has been added, we can call information about this book as well:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 由于书已经添加，我们也可以调用关于这本书的信息：
- en: '[PRE134]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We get this output:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到这个输出：
- en: '[PRE135]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'We can call the total pages of `book3`:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以调用`book3`的总页数：
- en: '[PRE136]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'We will get the following output:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE137]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: As you can see, we can add books to our class from within the algorithm, or
    after running the algorithm in the Python shell. Now, let's take a look at another
    problem.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们可以在算法中添加书籍到我们的类中，或者在Python shell中运行算法后添加书籍。现在，让我们看看另一个问题。
- en: Problem 2 - Organizing information
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题2 - 组织信息
- en: 'We''ve been asked to create an algorithm that takes three numbers as input
    and provides the sum of the numbers. There are multiple ways we can do this, but
    let''s look at using the `eval()` function:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被要求创建一个算法，它接受三个数字作为输入，并提供这些数字的总和。我们可以用多种方法来做到这一点，但让我们看看如何使用`eval()`函数：
- en: ch8_Sums.py
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_Sums.py
- en: '[PRE138]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Notice that we defined each of the input variables as an `int` type. This is
    defined so that the evaluation is done correctly.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将每个输入变量定义为`int`类型。这样定义是为了正确执行评估。
- en: 'Here is the output for our algorithm:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们算法的输出：
- en: '[PRE139]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: If we had forgotten to add the type for each of the numbers, the function would
    have evaluated that as `123` instead because it just adds each string to the next
    one. So, if our input had been `John`, `Mary`, `Jack`, our output would have been
    `JohnMaryJack`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忘记为每个数字添加类型，函数会将其评估为`123`，因为它只是将每个字符串添加到下一个字符串。所以，如果我们的输入是`John`、`Mary`、`Jack`，我们的输出将是`JohnMaryJack`。
- en: 'We previously didn''t go into the `sum()` function. Let''s take a look at using
    that function instead:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有涉及`sum()`函数。让我们看看如何使用该函数：
- en: ch8_Sums2.py
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_Sums2.py
- en: '[PRE140]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Using `sum` in this case requires that we add our inputs to a list, as `sum()`
    works with iterables, such as lists. Although this solution has more code, the
    output is exactly the same as our `eval()` function, as you can see here:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下使用`sum`需要我们将输入添加到列表中，因为`sum()`可以处理可迭代对象，比如列表。虽然这种解决方案代码更多，但输出与我们的`eval()`函数完全相同，如下所示：
- en: '[PRE141]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: As you can see, we get the same answer as before using a different Python function.
    Let's look at one more problem before we move on to the next chapter.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们使用不同的Python函数得到了与之前相同的答案。在我们继续下一章之前，让我们再看一个问题。
- en: Problem 3 - Loops and math
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3 - 循环和数学
- en: For this problem, we have to create an algorithm that prints out the squares
    of all the numbers given a range of two numbers. Remember, we can print each individually,
    but if the range is large, it's best we have a list instead. We'll also need to
    iterate in the range, and we have to add 1 to the maximum if we want to include
    the endpoints.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们必须创建一个算法，打印出给定范围内所有数字的平方。记住，我们可以单独打印每个数字，但如果范围很大，最好我们有一个列表。我们还需要在范围内进行迭代，并且如果我们想要包括端点，我们必须将最大值加1。
- en: 'Take a look at the following algorithm:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下算法：
- en: ch8_SquareLoops.py
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_SquareLoops.py
- en: '[PRE142]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Notice that we added a `j` variable to our algorithm. We didn''t use `i = i**2`
    because that would change the value of `i`, which would affect our iteration in
    the algorithm. By using `j`, we can then use `i` to iterate through the range
    given. Let''s look at our output:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们在算法中添加了一个`j`变量。我们没有使用`i = i**2`，因为那样会改变`i`的值，这会影响算法中的迭代。通过使用`j`，我们可以使用`i`来遍历给定的范围。让我们来看看我们的输出：
- en: '[PRE143]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: This algorithm prints out our list of squares for the range provided. It also
    has an initial `print` statement that explains what the code will do.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法打印出我们提供范围的平方列表。它还有一个初始的“print”语句，解释了代码将要做的事情。
- en: Now that we've looked at a few examples, let's look at parent classes and child
    classes and how inheritance works.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看了一些例子，让我们来看看父类和子类以及继承是如何工作的。
- en: Using inheritance
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用继承
- en: In Python, we can pass methods and properties from one class to another using
    inheritance. The parent class has the methods and properties that will be inherited.
    The child class inherits from the parent class. The parent class is an object
    and the child class is an object, so we are defining the properties of classes.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用继承将方法和属性从一个类传递到另一个类。父类具有将被继承的方法和属性。子类继承自父类。父类是一个对象，子类也是一个对象，所以我们正在定义类的属性。
- en: 'Let''s see how that works using a science example. We''re going to create a
    class called `mammals`. Not all mammals are viviparous. A mammal is viviparous
    when it gives birth to live young. A mammal that is not viviparous is the platypus.
    The platypus lays eggs instead of giving birth to live young. If we were writing
    an algorithm for this, we would want the animals to inherit the characteristics
    of the parent – in this case, `mammals`. Let''s take a look at the following snippet
    of code:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用一个科学例子。我们将创建一个名为`mammals`的类。并不是所有的哺乳动物都是胎生的。哺乳动物在产下活仔时是胎生的。不是胎生的哺乳动物是鸭嘴兽。鸭嘴兽产卵而不是产下活仔。如果我们要为此编写一个算法，我们希望动物继承父类的特征
    - 在这种情况下是`mammals`。让我们看看下面的代码片段：
- en: ch8_mammals.py
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: ch8_mammals.py
- en: '[PRE144]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: From the preceding code, notice that the `mammals()` class uses a description
    and then information about mammals and viviparity. `monkey` is defined using the
    same description as the `mammals` class, but then includes a different statement
    for viviparity. The same thing happens with `platypus`. The `monkey` and `platypus`
    classes are child classes of the `mammals` class.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，注意到`mammals()`类使用了一个描述，然后是有关哺乳动物和胎生的信息。`monkey`使用了与`mammals`类相同的描述，但是包括了一个不同的胎生声明。`platypus`也是一样的情况。`monkey`和`platypus`类都是`mammals`类的子类。
- en: 'The three classes, the parent and the two children, are then simplified into
    a variable so that they can be used by calling that variable. Finally, the algorithm
    prints the description and viviparity statements for the parent and the two children.
    Let''s take a look at that output:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个类，父类和两个子类，然后被简化为一个变量，以便通过调用该变量来使用。最后，算法打印出了父类和两个子类的描述和胎生声明。让我们来看看输出：
- en: '[PRE145]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: As you can see, all three classes used the same description. That's because
    we didn't make any changes to the description for the children. When we defined
    the classes, we only changed the parts we wanted to be different from the parent
    class. Everything else is inherited from the parent class.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，所有三个类都使用了相同的描述。这是因为我们没有对子类的描述进行任何更改。当我们定义类时，我们只改变了想要与父类不同的部分。其他所有内容都是从父类继承而来的。
- en: Parent classes and children are widely used in Python for multiple purposes.
    For example, in gaming, you may have enemies that all have some of the same characteristics.
    Rather than defining each enemy with all the characteristics separately, we can
    create a parent class that includes all the common characteristics, then change
    the individual characteristics of all the enemies as child classes. This is just
    one of the ways in which inheritance can be used. There are many other uses and
    it helps us save time and avoid errors by only defining them with the parent classes.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，父类和子类被广泛用于多种目的。例如，在游戏中，你可能会有一些具有相同特征的敌人。我们可以创建一个包含所有共同特征的父类，然后将所有敌人的个体特征作为子类进行更改，而不是分别定义每个敌人的所有特征。这只是继承可以使用的方式之一。还有许多其他用途，它可以帮助我们节省时间，并通过只用父类定义它们来避免错误。
- en: Now that we've had some experience with classes and learned about OOP, let's
    wrap up the chapter.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一些类的经验，并学习了面向对象编程，让我们结束本章。
- en: Summary
  id: totrans-467
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the basics of Python programming. We looked at
    some of the built-in functions, worked with dictionaries and lists, used variables
    and functions, learned about files, data, and iteration, and learned about classes
    and OOP.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Python编程的基础知识。我们研究了一些内置函数，使用了字典和列表，使用了变量和函数，学习了有关文件、数据和迭代的知识，并学习了类和面向对象编程。
- en: As we mentioned in this chapter and when solving previous problems, Python provides
    multiple ways for us to solve the same problems. One example of that is provided
    in the *Problem 2 - Organizing information* section of this chapter, where we
    used the `eval()` and `sum()` functions in two different algorithms to produce
    the same result. As we continue to learn about Python and how to write our algorithms,
    choosing which functions, variables, arguments, and more to use will start to
    become second nature. Some of the more challenging concepts and content in this
    chapter have to do with data analysis, such as the survey we used when introducing
    data in Python in the *Data in Python* section of this chapter, and classes. It's
    important to get some practice in those areas so that you can get a better understanding
    of those topics.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章和解决以前的问题时提到的，Python为我们提供了多种解决同一问题的方法。其中一个例子就是在本章的“问题2 - 组织信息”部分提供的，我们在两种不同的算法中使用了`eval()`和`sum()`函数来产生相同的结果。随着我们继续学习Python以及如何编写我们的算法，选择使用哪些函数、变量、参数等将开始变得自然而然。本章中一些更具挑战性的概念和内容涉及数据分析，比如我们在介绍Python中的数据时使用的调查，以及类。在这些领域进行一些练习是很重要的，这样你就能更好地理解这些主题。
- en: After this chapter, you can now work with built-in functions, distinguish between
    lists, dictionaries, and classes, and solve problems that combine multiple different
    concepts, such as variables, iterations, and lists. In the next chapter, we will
    be looking at input and output in more depth to help us when designing algorithms.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章之后，你现在可以使用内置函数，区分列表、字典和类，并解决结合多个不同概念的问题，比如变量、迭代和列表。在下一章中，我们将更深入地研究输入和输出，以帮助我们设计算法。
