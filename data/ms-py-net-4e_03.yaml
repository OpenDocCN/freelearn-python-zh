- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: APIs and Intent-Driven Networking
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: API和意图驱动的网络
- en: In *Chapter 2*, *Low-Level Network Device Interactions*, we looked at ways to
    interact with network devices using Python libraries such as Pexpect, Paramiko,
    Netmiko, and Nornir. Paramiko and similar libraries use persistent sessions that
    simulate a user typing in commands as if sitting in front of a Terminal. This
    approach works fine up to a point. It is easy to send commands for execution on
    a device and capture the output. However, when the output becomes more than a
    few lines of characters, it becomes difficult for a computer program to interpret
    the output. The returned output from Paramiko, for example, is a series of characters
    meant to be read by a human being. The structure of the output consists of lines
    and spaces that are human-friendly but difficult to be understood by computer
    programs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第二章*，*低级网络设备交互*中，我们探讨了使用Python库（如Pexpect、Paramiko、Netmiko和Nornir）与网络设备交互的方法。Paramiko和类似的库使用持久会话，模拟用户在终端前输入命令。这种方法在某种程度上是可行的。向设备发送命令并捕获输出很容易。然而，当输出超过几行字符时，计算机程序解释输出就变得困难。例如，Paramiko返回的输出是一系列字符，旨在由人类阅读。输出的结构由行和空格组成，对人类友好，但对计算机程序来说难以理解。
- en: 'The key point is: for our computer programs to automate many of the tasks we
    want to perform, we need to interpret the returned results and make follow-up
    actions based on the returned results. When we cannot accurately and predictably
    interpret the returned results, we cannot execute the next command with confidence.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关键点在于：为了使我们的计算机程序自动化执行我们想要执行的大多数任务，我们需要解释返回的结果并根据返回的结果采取后续行动。当我们无法准确和可预测地解释返回的结果时，我们就无法有信心地执行下一个命令。
- en: This is a similar issue faced by the internet community in general, not just
    with network automation, whenever computers need to communicate with each other.
    Imagine the difference between a computer and a human being when they both read
    a web page. The human sees words, pictures, and spaces interpreted by the browser;
    the computer sees raw HTML code, Unicode characters, and binary files. What happens
    when a website needs to become a web service for another computer? The same web
    resources need to accommodate both human clients and other computer programs.
    Essentially, the web server needs to transfer information to another computer
    in the most optimized way. How do we do that?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个互联网社区普遍面临的问题，而不仅仅是网络自动化，每当计算机需要相互通信时。想象一下当计算机和人类阅读网页时的区别。人类看到的是浏览器解释的文字、图片和空间；而计算机看到的是原始HTML代码、Unicode字符和二进制文件。当网站需要成为另一台计算机的Web服务时会发生什么？相同的Web资源需要同时容纳人类客户端和其他计算机程序。本质上，Web服务器需要以最优化的方式将信息传输到另一台计算机。我们如何做到这一点？
- en: 'The answer is the **application program interface** (**API**). It is important
    to note that an API is a concept and not a particular technology or framework.
    As defined by Wikipedia:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是**应用程序编程接口**（**API**）。需要注意的是，API是一个概念，而不是特定的技术或框架。根据维基百科的定义：
- en: In computer programming, an application programming interface (API) is a set
    of subroutine definitions, protocols, and tools for building application software.
    In general terms, it’s a set of clearly defined methods of communication between
    various software components. A good API makes it easier to develop a computer
    program by providing all the building blocks, which are then put together by the
    programmer.
  id: totrans-6
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在计算机编程中，应用程序编程接口（API）是一组子程序定义、协议和工具，用于构建应用程序软件。一般而言，它是一组明确定义的软件组件之间通信的方法。一个好的API通过提供所有构建块，使得开发计算机程序变得更加容易，然后由程序员将这些构建块组合起来。
- en: In our use case, the set of clearly defined methods of communication would be
    between our Python program and the destination device. The APIs from our network
    devices provide a separate interface for the computer programs, such as our Python
    scripts. The exact API implementation is vendor and sometimes product specific.
    One vendor will prefer XML, while another might use JSON; one product might use
    HTTPS as the underlying transport protocol, and others might provide Python libraries
    called SDKs to be used with the device. We will see many different vendors and
    product examples in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的用例中，明确定义的通信方法将存在于我们的Python程序和目标设备之间。我们的网络设备提供的API为计算机程序（如我们的Python脚本）提供了一个独立的接口。确切的API实现是供应商和有时是产品特定的。一个供应商可能会偏好XML，而另一个可能会使用JSON；一个产品可能会使用HTTPS作为底层传输协议，而其他产品可能会提供用于设备的Python库，称为SDK。在本章中，我们将看到许多不同的供应商和产品示例。
- en: 'Despite the differences, the concept of an API remains the same: it is a communication
    method optimized for other computer programs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在差异，API的概念仍然是相同的：它是一种针对其他计算机程序优化的通信方法。
- en: 'In this chapter, we will look at the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: Treating **infrastructure as code** (**IaC**), intent-driven networking, and
    data modeling
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将**基础设施视为代码**（**IaC**）、意图驱动的网络和数据建模
- en: Cisco NX-API, **Application Centric Infrastructure** (**ACI**), and Meraki examples
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco NX-API、**应用中心基础设施**（**ACI**）和Meraki示例
- en: Juniper **Network Configuration Protocol** (**NETCONF**) and PyEZ
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper **网络配置协议**（**NETCONF**）和PyEZ
- en: Arista eAPI and pyeapi
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arista eAPI和pyeapi
- en: We will start by examining why we want to treat infrastructure as code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从探讨为什么我们要将基础设施视为代码开始。
- en: Infrastructure-as-Code (IaC)
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础设施即代码 (IaC)
- en: In a perfect world, network engineers and architects who design and manage networks
    should focus on what they want the network to achieve instead of the device-level
    interactions. But we all know the world is far from perfect. Many years ago, when
    I worked as an intern for a second-tier ISP, one of my first assignments was to
    install a router on a customer’s site to turn up their fractional frame relay
    link (remember those?). *How would I do that?* I asked. I was handed down a standard
    operating procedure for turning up frame relay links.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个完美的世界里，网络工程师和架构师在设计和管理网络时应该专注于他们希望网络实现的目标，而不是设备级别的交互。但我们都知道这个世界远非完美。许多年前，当我作为一家二线ISP的实习生工作时，我的第一个任务之一就是在客户现场安装一个路由器，以开通他们的分数帧中继链路（还记得那些吗？）。*我该如何做呢？*
    我问。我被 handed down 一份开通帧中继链路的标准操作程序。
- en: I went to the customer site, blindly typed in the commands, looked at the green
    lights flashing, happily packed my bag, and patted myself on the back for a job
    well done. As exciting as that assignment was, I did not fully understand what
    I was doing. I was simply following instructions without thinking about the implication
    of the commands I was typing in. How would I troubleshoot something if the light
    was red instead of green? No doubt I would have had to call the office and ask
    a more senior engineer for help.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我去了客户现场，盲目地输入命令，看着绿色的指示灯闪烁，高兴地收拾好背包，为自己的工作感到自豪。尽管这项任务很令人兴奋，但我并没有完全理解我在做什么。我只是盲目地遵循指示，没有考虑我输入的命令的含义。如果指示灯是红色而不是绿色，我将如何进行故障排除？毫无疑问，我必须打电话给办公室，请求一位经验更丰富的工程师的帮助。
- en: Network engineering is not about typing commands into a device; it is about
    building a way that allows services to be delivered from one point to another
    with as little friction as possible. The commands we have to use and the output
    we have to interpret are merely means to an end. In other words, we should be
    focused on our intent for the network. **What we want our network to achieve is
    much more important than the command syntax we use to get the device to do what
    we want it to do**. If we further abstract that idea of describing our intent
    as lines of code, we can potentially describe our whole infrastructure as a particular
    state. The infrastructure will be described in lines of code with the necessary
    software or framework to enforce that state.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 网络工程不仅仅是将命令输入到设备中；它是在尽可能减少摩擦的情况下，建立一个从一点到另一点提供服务的途径。我们必须使用的命令和必须解释的输出只是达到目的的手段。换句话说，我们应该专注于我们对网络的意图。**我们希望网络实现的目标比我们用来让设备做我们想要它做的事情的命令语法更重要**。如果我们进一步将描述我们意图的想法抽象为代码行，我们就可以潜在地描述我们的整个基础设施为特定的状态。基础设施将通过代码行来描述，并带有必要的软件或框架来强制执行该状态。
- en: Intent-driven networking
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 意图驱动的网络
- en: Since the publication of the first edition of this book, the terms **intent-based
    networking** (**IBN**) and **intent-driven networking** (**IDN**) have seen an
    uptick after major network vendors chose to use them to describe their next-generation
    devices. The two terms generally mean the same thing. *In my opinion, IDN is the
    idea of defining a state that the network should be in and having software code
    to enforce that state*. As an example, if my goal is to block port `80` from being
    externally accessible, that is how I should declare it as the intention of the
    network. The underlying software will be responsible for knowing the syntax of
    configuring and applying the necessary access list on the border router to achieve
    that goal. Of course, IDN is an idea with no clear answer on the exact implementation.
    The software we use to enforce our declared intent can be a library, a framework,
    or a complete package we purchase from a vendor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 自从本书第一版出版以来，随着主要网络供应商选择使用**基于意图的网络**（**IBN**）和**意图驱动的网络**（**IDN**）来描述他们的下一代设备，这两个术语的使用频率有所上升。这两个术语通常意味着相同的事情。*在我看来，IDN是定义网络应处于的状态并拥有软件代码来强制执行该状态的想法*。例如，如果我的目标是阻止端口`80`从外部访问，这就是我应该将其声明为网络意图的方式。底层软件将负责了解配置和应用于边界路由器上的必要访问列表的语法以实现该目标。当然，IDN是一个没有明确答案的关于确切实现的想法。我们用来强制执行我们声明的意图的软件可以是一个库、一个框架，或者我们从供应商那里购买的完整包。
- en: When using an API, it is my opinion that it gets us closer to a state of IDN.
    In short, because we abstract the layer of a specific command executed on our
    destination device, we focus on our intent instead of the specific commands. For
    example, going back to our `block port 80` access-list example, we might use `access-list`
    and `access-group` on a Cisco router and `filter-list` on a Juniper router. However,
    by using an API, our program can start asking the executor for their intent while
    masking the kind of physical device the software is talking to. We can even use
    a higher-level declarative framework, such as Ansible, which we will cover in
    *Chapter 4*, *The Python Automation Framework*. But for now, let’s focus on network
    APIs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用API时，我认为它使我们更接近IDN的状态。简而言之，因为我们抽象了在目标设备上执行特定命令的层，我们关注的是意图而不是特定命令。例如，回到我们的`block
    port 80`访问列表示例，我们可能在Cisco路由器上使用`access-list`和`access-group`，在Juniper路由器上使用`filter-list`。然而，通过使用API，我们的程序可以开始询问执行者他们的意图，同时隐藏软件正在与哪种物理设备通信。我们甚至可以使用更高层次的声明性框架，例如我们在*第4章*，*Python自动化框架*中将要介绍的Ansible。但现在，让我们专注于网络API。
- en: Screen scraping versus API structured output
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 屏幕抓取与API结构化输出
- en: 'Imagine a common scenario where we need to log into the network device and
    make sure all the interfaces on the device are in an up/up state (both the status
    and the protocol are showing as `up`). For the human network engineers getting
    into a Cisco NX-OS device, it is simple enough to issue the `show ip interface
    brief` command in the Terminal to easily tell from the output which interface
    is up:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个常见的场景，我们需要登录网络设备并确保设备上的所有接口都处于up/up状态（状态和协议都显示为`up`）。对于进入Cisco NX-OS设备的网络工程师来说，在终端中发出`show
    ip interface brief`命令就足够简单，可以很容易地从输出中看出哪个接口是up的：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The line break, white spaces, and the first line of the column title are easily
    distinguished by the human eye. They are there to help us line up, say, the IP
    addresses of each interface from line one to lines two and three. If we were to
    put ourselves in the computer’s position for capturing the information, all these
    spaces and line breaks only take us away from the important output, which is:
    which interfaces are in the up/up state? To illustrate this point, we can look
    at the Paramiko output for the `show interface brief` command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 行中断、空白和列标题的第一行很容易被肉眼区分。它们的存在是为了帮助我们对齐，比如，从第一行到第二行和第三行的每个接口的IP地址。如果我们把自己放在计算机的位置来捕获信息，所有这些空白和行中断只会让我们远离重要的输出，即：哪些接口处于up/up状态？为了说明这一点，我们可以看看`show
    interface brief`命令的Paramiko输出：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If we were to parse out that data contained in the output variable, this is
    what I would do in a pseudo-code fashion (pseudo-code means a simplified representation
    of the actual code I would write) to subtract the text into the information I
    need:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要解析输出变量中包含的数据，我将以伪代码的形式（伪代码意味着实际代码的简化表示）这样做，以将文本减到所需的信息中：
- en: Split each line via the line break.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过行中断分割每一行。
- en: I do not need the first line that contains the executed command of `show ip
    interface brief` and will discard it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我不需要包含`show ip interface brief`执行的命令的第一行，我会将其丢弃。
- en: Take out everything on the second line up until the hostname prompt, and save
    it in a variable.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从第二行取出直到主机名提示符的所有内容，并将其保存在一个变量中。
- en: For the rest of the lines, because we do not know how many interfaces there
    are, we will use a regular expression statement to search if the line starts with
    interface names, such as `lo` for loopback and `GigabitEthernet` for Ethernet
    interfaces.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于其余的行，因为我们不知道有多少接口，我们将使用正则表达式语句来搜索行是否以接口名称开头，例如`lo`代表回环接口和`GigabitEthernet`代表以太网接口。
- en: We will need to split this line into three sections separated by a space, each
    consisting of the name of the interface, IP address, and then the interface status.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将这一行分成三个部分，由空格分隔，每个部分分别包含接口名称、IP地址以及接口状态。
- en: The interface status will then be split further using the while space to give
    us the protocol, the link, and the admin status.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接口状态将通过空格进一步分割，以给我们协议、链路和管理状态。
- en: 'Whew, that is a lot of work just for something that a human being can tell
    at a glance! The steps are what we need to do when we need to screen scrap unstructured
    texts. There are many downsides to this method, but some of the bigger problems
    that I can see are listed as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁，这只是一项大量工作，仅仅是为了人类一眼就能看出的事情！这些步骤是我们需要执行屏幕抓取非结构化文本时的步骤。这种方法有很多缺点，但我能看到的更大问题如下：
- en: '**Scalability**: We spent so much time on painstaking details to parse out
    the outputs from each command. It is hard to imagine how we can do this for the
    hundreds of commands we typically run.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：我们花费了大量时间在繁琐的细节上，以解析每个命令的输出。很难想象我们如何为通常运行的数百个命令做这件事。'
- en: '**Predictability**: There is no guarantee that the output stays the same between
    different software versions. If the output is changed ever so slightly, it might
    just render our hard-fought battle of information gathering useless.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可预测性**：无法保证不同软件版本之间的输出保持一致。如果输出有细微的变化，它可能会使我们的信息收集斗争变得毫无意义。'
- en: '**Vendor and software lock-in**: Once we spend all this effort parsing the
    output for this particular vendor and software version, in this case, Cisco IOS,
    we need to repeat this process for the next vendor we pick. I don’t know about
    you, but if I were to evaluate a new vendor, the new vendor would be at a severe
    onboarding disadvantage if I have to rewrite all the screen scrap code again.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商和软件锁定**：一旦我们投入所有努力解析特定供应商和软件版本的输出，在这个例子中是Cisco IOS，我们就需要为下一个我们选择的供应商重复这个过程。我不知道你怎么样，但如果我要评估一个新的供应商，如果我要再次重写所有的屏幕抓取代码，新的供应商将处于严重的入门劣势。'
- en: 'Let’s compare that with an output from an NX-API call for the same `show ip
    interface brief` command. We will go over the specifics of getting this output
    from the device later in this chapter, but what is important here is to compare
    the following output to the previous screen scraping output (the full output is
    in the course code repository):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下NX-API调用相同`show ip interface brief`命令的输出。我们将在本章后面详细说明如何从设备获取此输出，但这里重要的是将以下输出与之前的屏幕抓取输出（完整输出在课程代码库中）进行比较：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: NX-API can return output in XML or JSON, and this is the JSON output. Right
    away, we can see the output is structured and can be mapped directly to the Python
    dictionary data structure. Once this is converted to a Python dictionary, no extensive
    parsing is required — we can simply pick the key and retrieve the value associated
    with the key. We can also see from the output that there is various metadata in
    the output, such as the success or failure of the command. If the command fails,
    there will be a message telling the sender the reason for the failure. We no longer
    need to keep track of the command issued, because it is already returned to you
    in the `input` field. There is also other useful metadata in the output, such
    as the NX-API version.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: NX-API可以返回XML或JSON格式的输出，这是JSON输出。我们可以立即看到输出是有结构的，可以直接映射到Python字典数据结构。一旦转换为Python字典，就不需要大量的解析——我们只需简单地选择键并检索与键关联的值。我们还可以从输出中看到，输出中有各种元数据，例如命令的成功或失败。如果命令失败，将有一条消息告诉发送者失败的原因。我们不再需要跟踪发出的命令，因为它已经通过`input`字段返回给你了。输出中还有其他有用的元数据，例如NX-API版本。
- en: This type of exchange makes life easier for both vendors and operators. On the
    vendor side, they can easily transfer configuration and state information. They
    can add extra fields when the need to expose additional data arises using the
    same data structure. On the operator side, we can easily ingest the information
    and build our infrastructure automation around it. It is agreed by all that network
    automation and programmability are beneficial to both network vendors and operators.
    The questions are usually about the transport, format, and structure of the automation
    messages. As we will see later in this chapter, there are many competing technologies
    under the umbrella of API. On the transport language alone, we have REST API,
    NETCONF, and RESTCONF, among others.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这种交换使得供应商和运营商的生活都变得更加容易。在供应商方面，他们可以轻松地传输配置和状态信息。当需要使用相同的数据结构暴露更多数据时，他们可以轻松地添加额外字段。在运营商方面，我们可以轻松地获取信息，并围绕它构建我们的基础设施自动化。所有人都同意，网络自动化和可编程性对网络供应商和运营商都有益。问题通常涉及自动化消息的传输、格式和结构。正如我们将在本章后面看到的那样，在API的伞形之下，有许多竞争技术。仅就传输语言而言，我们就有REST
    API、NETCONF和RESTCONF等。
- en: Data modeling for IaC
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IaC的数据建模
- en: 'According to Wikipedia ([https://en.wikipedia.org/wiki/Data_model](https://en.wikipedia.org/wiki/Data_model)),
    the definition of a data model is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科（[https://en.wikipedia.org/wiki/Data_model](https://en.wikipedia.org/wiki/Data_model)），数据模型的定义如下：
- en: A data model is an abstract model that organizes elements of data and standardizes
    how they relate to one another and to properties of real-world entities. For instance,
    a data model may specify that the data element representing a car be composed
    of a number of other elements which, in turn, represent the color and size of
    the car and define its owner.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 数据模型是一个抽象模型，它组织数据元素并标准化它们相互之间以及与现实世界实体属性的关系。例如，数据模型可能指定代表汽车的元素由多个其他元素组成，这些元素反过来又代表汽车的颜色和大小，并定义其所有者。
- en: 'The data modeling process is illustrated in the following diagram:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 数据建模过程在以下图中展示：
- en: '![Diagram  Description automatically generated](img/B18403_03_01.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图示  自动生成描述](img/B18403_03_01.png)'
- en: 'Figure 3.1: Data example process'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：数据示例过程
- en: When applying the data model concept to the network, we can say the network
    data model is an abstract model that describes our network. If we take a closer
    look at a physical data center, a layer 2 Ethernet switch can be considered a
    device containing a table of MAC addresses mapped to each port. Our switch data
    model describes how the MAC address should be kept in a table, which includes
    the keys, additional characteristics (think of VLAN and private VLAN), and more.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当将数据模型概念应用于网络时，我们可以称网络数据模型是一个抽象模型，它描述了我们的网络。如果我们仔细观察一个物理数据中心，一个二层以太网交换机可以被认为是一个包含映射到每个端口的MAC地址表的设备。我们的交换机数据模型描述了MAC地址应该如何保存在表中，包括键、附加特性（想想VLAN和私有VLAN）以及更多。
- en: Similarly, we can move beyond devices and map the whole data center in a data
    model. We can start with the number of devices in each of the access, distribution,
    and core layers, how they are connected, and how they should behave in a production
    environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以超越设备，在数据模型中映射整个数据中心。我们可以从接入层、分发层和核心层中的设备数量开始，它们是如何连接的，以及它们在生产环境中应该如何表现。
- en: For example, if we have a fat-tree network, we can declare in the model how
    many links each of the spine routers have, the number of routes they should contain,
    and the number of next-hops each of the prefixes would have.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个胖树网络，我们可以在模型中声明每个脊路由器有多少链路，它们应该包含多少路由，以及每个前缀会有多少下一跳。
- en: Remember we talked about IaC? These characteristics can be mapped out in a format
    that can then be referenced as the ideal state we can check against using software
    programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们讨论过IaC吗？这些特性可以以软件程序可以参考的格式映射出来，然后作为我们可以检查的理想状态。
- en: YANG and NETCONF
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: YANG和NETCONF
- en: One of the network data modeling languages is YANG, an interesting acronym for
    **Yet Another Next Generation** (despite common belief, some of the IETF workgroups
    do have a sense of humor). It was first published in RFC 6020 in 2010 and has
    since gained traction among vendors and operators.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据建模语言之一是YANG，这是一个有趣的缩写，代表**“另一个下一代”**（尽管普遍认为，一些IETF工作组确实有幽默感）。它首次于2010年在RFC
    6020中发布，并自此在供应商和运营商中获得了认可。
- en: As a data modeling language, YANG is used to model the configuration of devices.
    It can also represent state data manipulated by the NETCONF protocol, NETCONF
    remote procedure calls, and NETCONF notifications. It aims to provide a common
    abstraction layer between the protocols, such as NETCONF, and the underlying vendor-specific
    syntax for configuration and operations. We will look at some examples of YANG
    later in this chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种数据建模语言，YANG用于建模设备的配置。它还可以表示由NETCONF协议、NETCONF远程过程调用和NETCONF通知操作的状态数据。它的目标是提供协议（如NETCONF）和底层供应商特定配置和操作语法之间的通用抽象层。我们将在本章后面查看一些YANG的示例。
- en: Now that we have discussed the high-level concepts of API-based device management
    and data modeling, let us look at some examples from Cisco in their API structures.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了基于API的设备管理和数据建模的高级概念，让我们来看看思科在其API结构中的几个示例。
- en: Cisco API examples
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 思科API示例
- en: Cisco Systems, the 800-pound gorilla in the networking space, have not missed
    out on the trend of network automation. In their push for network automation,
    they have made various in-house developments, product enhancements, partnerships,
    and many external acquisitions. However, with product lines spanning routers,
    switches, firewalls, servers (unified computing), wireless, collaboration software
    and hardware, and analytic software, it is hard to know where to start.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络领域占据800磅巨猿地位的思科系统，没有错过网络自动化的趋势。在推动网络自动化的过程中，他们进行了各种内部开发、产品增强、合作以及许多外部收购。然而，由于产品线涵盖了路由器、交换机、防火墙、服务器（统一计算）、无线、协作软件和硬件以及分析软件，很难知道从哪里开始。
- en: 'Since this book focuses on Python and networking, we will scope the Cisco examples
    in this section to the main networking products. In particular, we will cover
    the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书侧重于Python和网络，我们将本节中的思科示例范围限定在主要网络产品上。特别是，我们将涵盖以下内容：
- en: Nexus with NX-API
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有NX-API的Nexus
- en: Cisco NETCONF and YANG examples
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科NETCONF和YANG示例
- en: Cisco **Application Centric Infrastructure** (**ACI**)
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科**应用中心基础设施**（**ACI**）
- en: Cisco Meraki examples
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 思科Meraki示例
- en: For the NX-API and NETCONF examples in this chapter, we can either use the Cisco
    DevNet always-on lab devices mentioned in *Chapter 2*, *Low-Level Network Device
    Interactions*, or a locally run Cisco CML virtual lab.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章中的NX-API和NETCONF示例，我们可以使用*第二章*，*低级网络设备交互*中提到的思科DevNet始终在线实验室设备，或者使用本地运行的思科CML虚拟实验室。
- en: 'We will use the same lab topology as we did in *Chapter 2*, *Low-Level Network
    Device Interactions*, and focus on the devices running **NX-OSv**, **lax-cor-r1**,
    and **nyc-cor-r1**:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用与*第二章*，*低级网络设备交互*中相同的实验室拓扑，并专注于运行**NX-OSv**、**lax-cor-r1**和**nyc-cor-r1**的设备：
- en: '![Diagram  Description automatically generated](img/B18403_03_02.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B18403_03_02.png)'
- en: 'Figure 3.2: Lab NX-OSv Device'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：实验室NX-OSv设备
- en: Let’s take a look at the Cisco NX-API example first.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看思科NX-API的示例。
- en: Cisco NX-API
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 思科NX-API
- en: Nexus is Cisco’s primary product line of data center switches. The NX-API ([http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html))
    allows the engineer to interact with the switch outside of the device via a variety
    of transports including SSH, HTTP, and HTTPS.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus是思科数据中心交换机的主要产品线。NX-API（[http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html](http://www.cisco.com/c/en/us/td/docs/switches/datacenter/nexus9000/sw/6-x/programmability/guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide/b_Cisco_Nexus_9000_Series_NX-OS_Programmability_Guide_chapter_011.html)）允许工程师通过SSH、HTTP和HTTPS等多种传输方式与交换机进行交互。
- en: Lab preparation
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实验室准备
- en: 'Remember to activate our Python virtual environment. This should be a given
    requirement whenever we perform labs from now on:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 记得激活我们的Python虚拟环境。这应该是我们从现在开始进行实验室操作的一个基本要求：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `ncclient` ([https://github.com/ncclient/ncclient](https://github.com/ncclient/ncclient))
    library is a Python library for NETCONF clients. We will also install a popular
    Python HTTP client library called Requests ([https://pypi.org/project/requests/](https://pypi.org/project/requests/)).
    We can install both via pip:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`ncclient` ([https://github.com/ncclient/ncclient](https://github.com/ncclient/ncclient))
    库是一个用于 NETCONF 客户端的 Python 库。我们还将安装一个流行的 Python HTTP 客户端库，称为 Requests ([https://pypi.org/project/requests/](https://pypi.org/project/requests/))。我们可以通过
    pip 安装这两个库：'
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'NX-API on Nexus devices is turned off by default, so we will need to turn it
    on. We will also need a user. In this case, we will just use the existing user
    of `cisco`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 设备上的 NX-API 默认是关闭的，因此我们需要将其打开。我们还需要一个用户。在这种情况下，我们将仅使用现有的 `cisco` 用户：
- en: '[PRE5]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For our lab, we will turn on both the `nxapi` `http` and the `nxapi` `sandbox`
    configuration; keep in mind that both should be turned off in production:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的实验室，我们将打开 `nxapi` `http` 和 `nxapi` `sandbox` 配置；请注意，在生产环境中这两个都应该关闭：
- en: '[PRE6]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to look at our first NX-API example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好查看我们的第一个 NX-API 示例。
- en: NX-API examples
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NX-API 示例
- en: NX-API sandbox is a great way to play around with various commands, data formats,
    and even copy the Python script directly from the web page. In the last step,
    we turned it on for learning purposes. Again, the sandbox should be turned off
    in production.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: NX-API 沙盒是玩转各种命令、数据格式，甚至直接从网页复制 Python 脚本的好方法。在上一步中，我们为了学习目的将其打开。再次强调，沙盒在生产环境中应该关闭。
- en: 'Let’s launch a web browser with the Nexus device’s management IP and look at
    the various message formats, requests, and responses based on the CLI commands
    that we are already familiar with:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Nexus 设备的管理 IP 启动一个网页浏览器，查看基于我们已熟悉的 CLI 命令的各种消息格式、请求和响应：
- en: '![](img/B18403_03_03.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18403_03_03.png)'
- en: 'Figure 3.3: NX-API Developer Sandbox'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：NX-API 开发者沙盒
- en: 'In the following example, I have selected `JSON-RPC` and the `CLI` command
    type for the `show version` command. Click on **POST**, and we will see both the
    **REQUEST** and **RESPONSE**:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我选择了 `JSON-RPC` 和 `CLI` 命令类型来执行 `show version` 命令。点击 **POST**，我们将看到
    **请求** 和 **响应**：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_03_04.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18403_03_04.png)'
- en: 'Figure 3.4: NX-API Sandbox example output'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：NX-API 沙盒示例输出
- en: The sandbox comes in handy if you are unsure about the supportability of the
    message format or if you have questions about the response data field keys for
    the value you want to retrieve in your code.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对消息格式的可支持性不确定，或者如果你对你的代码中想要检索的值对应的响应数据字段键有疑问，沙盒会很有用。
- en: 'In our first example, `cisco_nxapi_1.py`, we are just going to connect to the
    Nexus device and print out the capabilities exchanged when the connection was
    first made:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例 `cisco_nxapi_1.py` 中，我们只是连接到 Nexus 设备并打印出首次连接时交换的能力：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In our example, we are using the `ncclient` library to connect to the device.
    The connection parameters of the host, port, username, and password are self-explanatory.
    The device parameter specifies the kind of device the client is connecting to.
    The `hostkey_verify` bypasses the `known_host` requirement for SSH; if it’s not
    set to false, the host fingerprint will need to be listed in the `~/.ssh/known_hosts`
    file. The `look_for_keys` option disables public-private key authentication and
    uses the username and password combination for authentication.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用 `ncclient` 库连接到设备。主机、端口、用户名和密码的连接参数是显而易见的。设备参数指定客户端连接到的设备类型。`hostkey_verify`
    跳过了 SSH 的 `known_host` 要求；如果它未设置为 false，则主机指纹需要列在 `~/.ssh/known_hosts` 文件中。`look_for_keys`
    选项禁用了公私钥认证，并使用用户名和密码组合进行认证。
- en: 'The output will show the XML- and NETCONF-supported features of this version
    of NX-OS:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将显示本版 NX-OS 支持的 XML 和 NETCONF 功能：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Using ncclient and NETCONF over SSH is great because it gets us closer to the
    native implementation and syntax. We will use the same library later on in this
    book for other vendors as a comparison. For NX-API, we can also use HTTPS and
    JSON-RPC. In the earlier screenshot of **NX-API Developer Sandbox**, if you noticed,
    in the **REQUEST** box, there is a box labeled **Python**. If you click on it,
    you will be able to get an automatically converted Python script based on the
    Requests library.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ncclient 和通过 SSH 的 NETCONF 非常好，因为它使我们更接近原生实现和语法。我们将在本书的后面部分使用相同的库来比较其他供应商。对于
    NX-API，我们还可以使用 HTTPS 和 JSON-RPC。在 **NX-API 开发者沙盒** 的早期截图，如果您注意到了，在 **请求** 框中有一个标记为
    **Python** 的框。如果您点击它，您将能够根据 Requests 库自动转换成 Python 脚本。
- en: 'For the `show version` example from the NX-API sandbox, the following Python
    script is automatically generated for us. I am pasting in the output without any
    modifications:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自 NX-API 沙盒的 `show version` 示例，以下 Python 脚本为我们自动生成。我在这里粘贴输出，没有进行任何修改：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `cisco_nxapi_2.py` script, you will see that I have taken the script
    the NX-API sandbox generated and only modified the URL, username, and password
    of the script. The output was parsed to include only the software version. Here
    is the output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cisco_nxapi_2.py` 脚本中，您将看到我已经修改了 NX-API 沙盒生成的脚本中的 URL、用户名和密码。输出被解析，只包含软件版本。以下是输出：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The best part about using this method is that the same overall syntax structure
    works with configuration and `show` commands. This is illustrated in the `cisco_nxapi_3.py`
    file, configuring the device with a new hostname. After command execution, you
    will see the device hostname being changed from `lax-cor-r1` to `lax-cor-r1-new`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法最好的部分是，相同的总体语法结构适用于配置和 `show` 命令。这可以在 `cisco_nxapi_3.py` 文件中看到，该文件使用新的主机名配置设备。在命令执行后，您将看到设备主机名从
    `lax-cor-r1` 更改为 `lax-cor-r1-new`：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'For multiline configuration, you can use the ID field to specify the order
    of operations. This is shown in `cisco_nxapi_4.py`. The following payload was
    listed for changing the description of the interface Ethernet 2/12 in the interface
    configuration mode:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多行配置，您可以使用 ID 字段来指定操作的顺序。这可以在 `cisco_nxapi_4.py` 中看到。以下有效载荷被列出，用于在接口配置模式下更改以太网
    2/12 接口的描述：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can verify the result of the previous configuration script by looking at
    the running configuration of the Nexus device:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查看 Nexus 设备的运行配置来验证先前配置脚本的结果：
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next example, we will see how we can use YANG with NETCONF.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将看到如何使用 YANG 与 NETCONF。
- en: The Cisco YANG Model
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cisco YANG 模型
- en: 'Let us take a look at Cisco’s YANG model support with an example. First, we
    should know that the YANG model only defines the type of schema sent over the
    NETCONF protocol without dictating what the data should be. Secondly, it is worth
    pointing out that NETCONF exists as a standalone protocol, as we saw in the NX-API
    section. Thirdly, YANG has different supportability across vendors and product
    lines. For example, if we run a capability exchange script for a Cisco CSR 1000v
    running IOS-XE, we can see the YANG models supported on the platform:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来看看 Cisco 的 YANG 模型支持。首先，我们应该知道 YANG 模型只定义了通过 NETCONF 协议发送的架构类型，而没有规定数据应该是什么。其次，值得注意的是，NETCONF
    作为独立协议存在，正如我们在 NX-API 部分所看到的。第三，YANG 在不同供应商和产品线上的支持性不同。例如，如果我们为运行 IOS-XE 的 Cisco
    CSR 1000v 运行能力交换脚本，我们可以在平台上看到支持的 YANG 模型：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: YANG has somewhat uneven support among different vendors and products. I have
    included a `cisco_yang_1.py` script with the book code repository for a Cisco
    IOS-XE always-on sandbox provided by Cisco Devnet that shows how to parse out
    the NETCONF XML output with YANG filters called `urn:ietf:params:xml:ns:yang:ietf-interfaces`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: YANG 在不同供应商和产品线上的支持性有些不均匀。我在本书的代码库中包含了一个 `cisco_yang_1.py` 脚本，展示了如何使用 Cisco
    Devnet 提供的 Cisco IOS-XE 总是开启沙盒，通过 YANG 过滤器 `urn:ietf:params:xml:ns:yang:ietf-interfaces`
    解析出 NETCONF XML 输出。
- en: We can see the latest vendor support on the YANG GitHub project page ([https://github.com/YangModels/yang/tree/master/vendor](https://github.com/YangModels/yang/tree/master/vendor)).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 YANG GitHub 项目页面上看到最新的供应商支持（[https://github.com/YangModels/yang/tree/master/vendor](https://github.com/YangModels/yang/tree/master/vendor)）。
- en: The Cisco ACI examples
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cisco ACI 示例
- en: The Cisco Application Centric Infrastructure, or ACI, is meant to provide a
    centralized controller approach to all network components we defined within its
    management scope. In the data center context, the centralized controller is aware
    of and manages the spine, leaf, and top-of-rack switches, as well as all the network
    service functions. This can be done through a GUI, CLI, or API. Some might argue
    that the ACI is Cisco’s answer to broader controller-based, software-defined networking.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco 应用中心基础设施，或称 ACI，旨在为其管理范围内定义的所有网络组件提供一个集中式控制器方法。在数据中心环境中，集中式控制器了解并管理脊线、叶子和机架顶部交换机，以及所有网络服务功能。这可以通过图形用户界面（GUI）、命令行界面（CLI）或
    API 来实现。有些人可能会认为 ACI 是思科对基于控制器、软件定义网络更广泛解决方案的回应。
- en: 'The ACI API follows the REST model to use the HTTP verbs (`GET`, `POST`, and
    `DELETE`) to specify the intended operation. In our example, we can use the Cisco
    DevNet always-on lab ACI device ([https://devnetsandbox.cisco.com/RM/Topology](https://devnetsandbox.cisco.com/RM/Topology)):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ACI API 遵循 REST 模型，使用 HTTP 动词（`GET`、`POST` 和 `DELETE`）来指定预期操作。在我们的示例中，我们可以使用
    Cisco DevNet 永久在线实验室 ACI 设备([https://devnetsandbox.cisco.com/RM/Topology](https://devnetsandbox.cisco.com/RM/Topology))：
- en: '![A picture containing graphical user interface  Description automatically
    generated](img/B18403_03_05.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![包含图形用户界面的图片 描述自动生成](img/B18403_03_05.png)'
- en: 'Figure 3.5: Cisco DevNet Sandboxes'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：Cisco DevNet 沙盒
- en: Always check the latest Cisco DevNet page for the latest device information,
    username, and password as they may have changed since the book was written.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 始终检查最新的 Cisco DevNet 页面以获取最新的设备信息、用户名和密码，因为自本书编写以来它们可能已更改。
- en: 'The controller is the brain of the network that maintains visibility to all
    network devices:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是网络的“大脑”，它对所有网络设备保持可见性：
- en: '![Diagram  Description automatically generated](img/B18403_03_06.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图表 描述自动生成](img/B18403_03_06.png)'
- en: 'Figure 3.6: Cisco ACI Controller'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6：Cisco ACI 控制器
- en: 'We can use a web browser to log on to the controller and take a look at the
    different tenants:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用网页浏览器登录到控制器并查看不同的租户：
- en: '![Graphical user interface  Description automatically generated](img/B18403_03_07.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面 描述自动生成](img/B18403_03_07.png)'
- en: 'Figure 3.7: Cisco ACI Tenants'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：Cisco ACI 租户
- en: 'Let’s use a Python interactive prompt to see how we can interact with the ACI
    controller. We will start by importing the correct libraries and defining the
    destination URL as well as the login credentials:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Python 交互式提示符来看看我们如何与 ACI 控制器交互。我们将首先导入正确的库，并定义目标 URL 以及登录凭证：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can then make a request and convert the response into JSON format:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以发出请求并将响应转换为 JSON 格式：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can grab the token from the response and use it as an authentication cookie
    for future requests to the controller. In the example below, we query for the
    `cisco` tenant that we saw in the controller tenant section:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从响应中获取令牌并将其用作未来请求控制器的身份验证cookie。在下面的示例中，我们查询控制器租户部分中看到的 `cisco` 租户：
- en: '[PRE17]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, we only query a single controller device, but we can get a high-level
    view of all the network devices that the controller is aware of. This is pretty
    neat! The downside is, of course, that the ACI controller only supports Cisco
    devices at this time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只查询单个控制器设备，但我们可以获取控制器所了解的所有网络设备的高级视图。这相当不错！当然，缺点是 ACI 控制器目前只支持思科设备。
- en: '**Cisco IOS-XE**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cisco IOS-XE**'
- en: For the most part, Cisco IOS-XE scripts are functionally similar to scripts
    we have written for NX-OS. IOS-XE has additional features that can benefit Python
    network programmability, such as on-box Python and a guest shell, [https://developer.cisco.com/docs/ios-xe/#!on-box-python-and-guestshell-quick-start-guide/onbox-python](https://developer.cisco.com/docs/ios-xe/#!on-box-python-and-guestshell-quick-start-guide/onbox-python).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，Cisco IOS-XE 脚本与为 NX-OS 编写的脚本在功能上相似。IOS-XE 具有额外的功能，可以提升 Python 网络编程能力，例如机箱内
    Python 和虚拟机壳，[https://developer.cisco.com/docs/ios-xe/#!on-box-python-and-guestshell-quick-start-guide/onbox-python](https://developer.cisco.com/docs/ios-xe/#!on-box-python-and-guestshell-quick-start-guide/onbox-python)。
- en: Similar to ACI, Cisco Meraki is a centrally managed controller that has visibility
    for multiple wired and wireless networks. Unlike the ACI controller, Meraki is
    cloud based, so it is hosted outside of the on-premises location. Let us look
    at some of the Cisco Meraki features and examples in the next section.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ACI 类似，Cisco Meraki 是一个集中式管理的控制器，它对多个有线和无线网络具有可见性。与 ACI 控制器不同，Meraki 是基于云的，因此它托管在本地场所之外。让我们在下一节中查看一些
    Cisco Meraki 功能和示例。
- en: Cisco Meraki controller
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cisco Meraki 控制器
- en: 'Cisco Meraki is a cloud-based centralized controller that simplifies IT management
    of devices. The approach is very similar to ACI with the exception that the controller
    has a cloud-based public URL. The user typically receives the API key via the
    GUI, then it can be used in a Python script to retrieve the organization ID:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Cisco Meraki 是一个基于云的集中式控制器，简化了设备的 IT 管理。其方法与 ACI 非常相似，唯一的区别是控制器有一个基于云的公共 URL。用户通常通过
    GUI 接收 API 密钥，然后可以在 Python 脚本中使用它来检索组织 ID：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let us execute the script, `cisco_meraki_1.py`, which is a simple request toward
    an always-on Meraki controller provided by Cisco DevNet:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们执行脚本 `cisco_meraki_1.py`，这是一个简单的请求，针对的是由 Cisco DevNet 提供的始终开启的 Meraki 控制器：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'From there, the organization ID can be used to further retrieve information,
    such as the inventory, network information, and so on:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，可以使用组织 ID 进一步检索信息，例如库存、网络信息等：
- en: '[PRE20]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s take a look at the output from the `cisco_meraki_2.py` script:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `cisco_meraki_2.py` 脚本的输出：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We have seen examples of Cisco devices using NX-API, ACI, and the Meraki controller.
    In the next section, let us take a look at some of the Python examples working
    with Juniper Networks devices.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了使用 NX-API、ACI 和 Meraki 控制器的 Cisco 设备的示例。在下一节中，让我们看看一些与 Juniper Networks
    设备一起工作的 Python 示例。
- en: The Python API for Juniper Networks
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Juniper Networks 的 Python API
- en: Juniper Networks has always been a favorite among the service provider crowd.
    If we take a step back and look at the service provider vertical, it would make
    sense that automating network equipment is at the top of their list of requirements.
    Before the dawn of cloud-scale data centers, service providers had the most network
    equipment to manage. For example, a typical enterprise network might have a few
    redundant internet connections at the corporate headquarters with a few hub-and-spoke
    remote sites connected back to the HQ using a private **multiprotocol label switching**
    (**MPLS**) network. But to a service provider, they are the ones needing to build,
    provision, manage, and troubleshoot the MPLS connections and the underlying networks.
    They make their money by selling the bandwidth along with value-added managed
    services. It would make sense for the service providers to invest in automation
    to use the fewest engineering hours to keep the network humming along. In their
    use case, network automation is a key to their competitive advantage.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper Networks 一直受到服务提供商群体的喜爱。如果我们退后一步，看看服务提供商行业，那么自动化网络设备成为他们需求列表中的首要任务是有道理的。在云规模数据中心出现之前，服务提供商需要管理的网络设备最多。例如，一个典型的企业网络可能在总部有少量冗余互联网连接，以及一些通过使用私有
    **多协议标签交换**（**MPLS**）网络连接回总部的星型远程站点。但对于服务提供商来说，他们需要构建、配置、管理和排除 MPLS 连接及其底层网络的故障。他们通过销售带宽以及增值管理服务来赚钱。对于服务提供商来说，投资自动化以使用最少的工程小时数来保持网络正常运行是有意义的。在他们的情况下，网络自动化是他们竞争优势的关键。
- en: In my opinion, the difference between a service provider’s network needs compared
    to a cloud data center is that, traditionally, service providers aggregate more
    services into a single device. A good example would be MPLS, which almost all
    major service providers provide but rarely adopt in enterprise or data center
    networks. Juniper Networks has identified this need for network programmability
    and excelled at fulfilling the service provider requirements of automating. Let’s
    take a look at some of Juniper’s automation APIs.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，服务提供商的网络需求与云数据中心之间的区别在于，传统上，服务提供商将更多服务聚合到单个设备中。一个很好的例子是 MPLS，几乎所有主要服务提供商都提供但很少在企业或数据中心网络中使用。Juniper
    Networks 已经识别了网络可编程性的需求，并在满足服务提供商自动化需求方面表现出色。让我们看看 Juniper 的自动化 API 的一些示例。
- en: Juniper and NETCONF
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Juniper 和 NETCONF
- en: 'NETCONF is an IETF standard that was first published in 2006 as `RFC 4741`
    and later revised in `RFC 6241`. Juniper Networks contributed heavily to both
    of the RFC standards. In fact, Juniper was the sole author of `RFC 4741`. It makes
    sense that Juniper devices fully support NETCONF, and it serves as the underlying
    layer for most of its automation tools and frameworks. Some of the main characteristics
    of NETCONF include the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: NETCONF 是一个由 IETF 发布的标准，首次于 2006 年以 `RFC 4741` 的形式发布，后来在 `RFC 6241` 中进行了修订。Juniper
    Networks 对这两个 RFC 标准都做出了重大贡献。实际上，Juniper 是 `RFC 4741` 的唯一作者。Juniper 设备完全支持 NETCONF
    是合情合理的，它还作为其大多数自动化工具和框架的底层层。NETCONF 的一些主要特性包括以下内容：
- en: It uses **extensible markup language** (**XML**) for data encoding.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 **可扩展标记语言**（**XML**）进行数据编码。
- en: It uses **remote procedure calls** (**RPCs**). Therefore, if HTTP(s) is the
    transport protocol, the URL endpoint is identical while the operation intended
    is specified in the request’s body.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用 **远程过程调用**（**RPC**）。因此，如果 HTTP(s) 是传输协议，URL 端点是相同的，而操作意图则在请求体中指定。
- en: 'It is conceptually based on layers from top to bottom. The layers include the
    content, operations, messages, and transport:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它从上到下基于层结构。层包括内容、操作、消息和传输：
- en: '![Diagram  Description automatically generated with medium confidence](img/B18403_03_08.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成，置信度中等](img/B18403_03_08.png)'
- en: 'Figure 3.8: NETCONF model'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：NETCONF 模型
- en: Juniper Networks provides an extensive NETCONF XML management protocol developer
    guide ([https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview](https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview))
    in its technical library. Let’s take a look at its usage.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper Networks 在其技术库中提供了一个广泛的 NETCONF XML 管理协议开发者指南 ([https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview](https://www.juniper.net/techpubs/en_US/junos13.2/information-products/pathway-pages/netconf-guide/netconf.html#overview))。让我们看看它的用法。
- en: Device preparation
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设备准备
- en: 'To start using NETCONF, let’s create a separate user as well as turn on the
    required services:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 NETCONF，让我们创建一个单独的用户以及开启所需的服务：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For the Juniper device lab, I am using an older, unsupported platform called
    **JunOS Olive**. It is solely used for lab purposes. You can use your favorite
    search engine to find some interesting facts and history about Juniper Olive.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Juniper 设备实验室，我正在使用一个较旧的、不受支持的平台，称为 **JunOS Olive**。它仅用于实验室目的。你可以使用你喜欢的搜索引擎查找一些关于
    Juniper Olive 的有趣事实和历史。
- en: 'On the Juniper device, you can always take a look at the configuration either
    in a flat file or in XML format. The `flat` file comes in handy when you need
    to specify a one-liner command to make configuration changes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Juniper 设备上，你总是可以在平面文件或 XML 格式下查看配置。当需要指定一行命令来更改配置时，`flat` 文件会很有用：
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The XML format comes in handy at times when you need to see the XML structure
    of the configuration:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要查看配置的 XML 结构时，XML 格式会很有用：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We installed the necessary Linux libraries and the `ncclient` Python library
    in the *Lab software installation and device preparation within Cisco NX-API*
    section. If you have not done so, go back to that section and install the necessary
    packages.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 *Cisco NX-API 中的实验室软件安装和设备准备* 部分安装了必要的 Linux 库和 `ncclient` Python 库。如果你还没有这样做，请回到该部分并安装必要的包。
- en: We are now ready to look at our first Juniper NETCONF example.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以查看我们的第一个 Juniper NETCONF 示例。
- en: Juniper NETCONF examples
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Juniper NETCONF 示例
- en: 'We will use a pretty straightforward example to execute `show version`. We
    will name this file `junos_netconf_1.py`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个非常直接的例子来执行 `show version`。我们将把这个文件命名为 `junos_netconf_1.py`：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: All the fields in the script should be pretty self-explanatory, with the exception
    of `device_params`. Starting with ncclient 0.4.1, the device handler was added
    to specify different vendors or platforms. For example, the name can be Juniper,
    CSR, Nexus, or Huawei. We also added `hostkey_verify=False` because we are using
    a self-signed certificate from the Juniper device.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本中的所有字段都应该相当直观，除了 `device_params`。从 ncclient 0.4.1 版本开始，设备处理器被添加来指定不同的供应商或平台。例如，名称可以是
    Juniper、CSR、Nexus 或华为。我们还添加了 `hostkey_verify=False`，因为我们正在使用 Juniper 设备的自签名证书。
- en: 'The returned output is `rpc-reply` encoded in XML with an output element:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的输出是使用 XML 编码的 `rpc-reply`，其中包含输出元素：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can parse the XML output to just include the output text:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解析 XML 输出，只包括输出文本：
- en: '[PRE27]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `junos_netconf_2.py`, we will make configuration changes to the device.
    We will start with some new imports for constructing new XML elements and the
    connection manager object:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `junos_netconf_2.py` 中，我们将对设备进行配置更改。我们将从一些新的导入开始，用于构建新的 XML 元素和连接管理器对象：
- en: '[PRE28]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will lock the configuration and make configuration changes:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将锁定配置并做出配置更改：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the build configuration section, we create a new element of `system` with
    sub-elements of `host-name` and `domain-name`. If you were wondering about the
    hierarchy structure, you can see from the XML display that the node structure
    with `system` is the parent of `host-name` and `domain-name`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建配置部分，我们创建了一个新的 `system` 元素，并包含 `host-name` 和 `domain-name` 子元素。如果您想知道层次结构，您可以从
    XML 显示中看到 `system` 节点是 `host-name` 和 `domain-name` 的父节点：
- en: '[PRE30]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After the configuration is built, the script will push the configuration and
    commit the configuration changes. These are the normal best practice steps (`lock`,
    `configure`, `unlock`, `commit`) for Juniper configuration changes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 配置构建完成后，脚本将推送配置并提交配置更改。这些是 Juniper 配置更改的正常最佳实践步骤（`lock`、`configure`、`unlock`、`commit`）。
- en: '[PRE31]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Overall, the NETCONF steps map pretty well to what we would have done in the
    CLI steps. Please take a look at the `junos_netconf_3.py` script for a more reusable
    code. The following example combines the step-by-step example with a few Python
    functions:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，NETCONF 步骤与我们在 CLI 步骤中会执行的操作非常匹配。请查看 `junos_netconf_3.py` 脚本以获取更可重用的代码。以下示例结合了逐步示例和一些
    Python 函数：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This file can be executed by itself, or it can be imported to be used by other
    Python scripts.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件可以独立执行，也可以导入到其他 Python 脚本中使用。
- en: Juniper also provides a Python library to be used with their devices called
    PyEZ. We will look at a few examples of using the library in the following section.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper 还提供了一个名为 PyEZ 的 Python 库，用于与其设备一起使用。我们将在下一节中查看一些使用该库的示例。
- en: Juniper PyEZ for developers
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Juniper PyEZ 开发者指南
- en: '**PyEZ** is a high-level Python library implementation that integrates better
    with your existing Python code. By utilizing the Python API that wraps around
    the underlying configuration, you can perform common operations and configuration
    tasks without extensive knowledge of the Junos CLI.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '**PyEZ** 是一个高级 Python 库实现，与现有的 Python 代码集成得更好。通过利用围绕底层配置的 Python API，您可以在不深入了解
    Junos CLI 的情况下执行常见操作和配置任务。'
- en: Juniper maintains a comprehensive Junos PyEZ developer guide at [https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration)
    on their technical library. If you are interested in using PyEZ, I would highly
    recommend at least a glance through the various topics in the guide.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Juniper 在其技术库中维护了一个全面的 Junos PyEZ 开发者指南，网址为 [https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/information-products/pathway-pages/junos-pyez-developer-guide.html#configuration)。如果您对使用
    PyEZ 感兴趣，我强烈建议至少浏览一下指南中的各个主题。
- en: Installation and preparation
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装和准备
- en: The installation instructions for each of the operating systems can be found
    on the *Installing Junos PyEZ* ([https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html))
    page.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作系统的安装说明可以在 *安装 Junos PyEZ* ([https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html](https://www.juniper.net/techpubs/en_US/junos-pyez1.0/topics/task/installation/junos-pyez-server-installing.html))
    页面上找到。
- en: '`PyEZ` packages can be installed via `pip`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`PyEZ` 软件包可以通过 `pip` 进行安装：'
- en: '[PRE33]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'On the Juniper device, NETCONF needs to be configured as the underlying XML
    API for PyEZ:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Juniper 设备上，需要将 NETCONF 配置为 PyEZ 的底层 XML API：
- en: '[PRE34]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For user authentication, we can either use password authentication or an SSH
    key pair. We can create a new user or use the existing user. For `ssh` key authentication,
    first, generate the key pair on your management host if you have not done so for
    *Chapter 2*, *Low-Level Network Device Interactions*:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于用户认证，我们可以使用密码认证或 SSH 密钥对。我们可以创建新用户或使用现有用户。对于 `ssh` 密钥认证，首先，如果你的管理主机尚未为 *第
    2 章*，*低级网络设备交互* 生成密钥对，请先生成密钥对：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By default, the public key will be called `id_rsa.pub` under `~/.ssh/`, while
    the private key will be named `id_rsa` in the same directory. Treat the private
    key like a password that you never share. The public key can be freely distributed.
    In our use case, we will copy the public key to the `/tmp` directory and enable
    the Python 3 HTTP server module to create a reachable URL:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，公钥将在 `~/.ssh/` 下被命名为 `id_rsa.pub`，而私钥将在同一目录下命名为 `id_rsa`。将私钥视为你永远不会分享的密码。公钥可以自由分发。在我们的用例中，我们将公钥复制到
    `/tmp` 目录，并启用 Python 3 HTTP 服务器模块以创建一个可访问的 URL：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From the Juniper device, we can create the user and associate the public key
    by downloading the public key from the Python 3 web server:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Juniper 设备，我们可以创建用户并关联公钥，通过从 Python 3 网络服务器下载公钥：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, if we try to `ssh` with the private key from the management station, the
    user will be automatically authenticated:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试从管理站使用私钥 `ssh`，用户将被自动认证：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Let’s make sure that both of the authentication methods work with PyEZ. Let’s
    try the username and password combination:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保两种认证方法都能与 PyEZ 一起工作。让我们尝试用户名和密码组合：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can also try to use the SSH key authentication:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以尝试使用 SSH 密钥认证：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Great! We are now ready to look at some examples for PyEZ.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们现在可以看看 PyEZ 的几个示例。
- en: PyEZ examples
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyEZ 示例
- en: 'In the previous interactive prompt, we saw that when the device connects, the
    object automatically retrieves a few facts about the device. In our first example,
    `junos_pyez_1.py`, we were connecting to the device and executing an RPC call
    for `show interface em1`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的交互式提示中，我们看到当设备连接时，对象会自动检索一些关于设备的事实。在我们的第一个例子 `junos_pyez_1.py` 中，我们正在连接到设备并执行
    `show interface em1` 的 RPC 调用：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Device` class has an `rpc` property that includes all operational commands.
    This is awesome because there is no slippage between what we can do in CLI versus
    API. The catch is that we need to find the corresponding `xml rpc` element tag
    for the CLI command. In our first example, how do we know `show interface em1`
    equates to `get_interface_information`? We have three ways of finding out this
    information:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Device` 类有一个包含所有操作命令的 `rpc` 属性。这很棒，因为我们可以在 CLI 和 API 之间没有滑动。但是，我们需要找到 CLI
    命令对应的 `xml rpc` 元素标签。在我们的第一个例子中，我们如何知道 `show interface em1` 等同于 `get_interface_information`？我们有三种方法来找出这些信息：'
- en: We can reference the *Junos XML API Operational Developer Reference*.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以参考 *Junos XML API 操作开发者参考*。
- en: We can use the CLI and display the XML RPC equivalent and replace the dash (-)
    between the words with an underscore (_).
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 CLI 并显示 XML RPC 等价物，并将单词之间的破折号（-）替换为下划线（_）。
- en: We can also do this programmatically by using the PyEZ library.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以通过使用 PyEZ 库来编程实现。
- en: 'I typically use the second option to get the output directly:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我通常使用第二种方法直接获取输出：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Here is an example of using PyEZ programmatically (the third option):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 PyEZ 编程的示例（第三种方法）：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Of course, we can make configuration changes as well. In the `junos_pyez_2.py`
    configuration example, we will import an additional `Config()` method from PyEZ:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以进行配置更改。在 `junos_pyez_2.py` 配置示例中，我们将从 PyEZ 导入一个额外的 `Config()` 方法：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We will utilize the same block to connect to a device:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用相同的块来连接到设备：
- en: '[PRE45]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `new Config()` method will load the XML data and make the configuration
    changes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`new Config()` 方法将加载 XML 数据并执行配置更改：'
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The PyEZ examples are simple by design. Hopefully, they demonstrate the ways
    you can leverage PyEZ for your Junos automation needs. In the following example,
    let’s look at how we can work with Arista network devices using Python libraries.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: PyEZ 示例设计得很简单。希望它们能展示你如何利用 PyEZ 满足你的 Junos 自动化需求。在下面的例子中，让我们看看我们如何使用 Python
    库与 Arista 网络设备一起工作。
- en: The Arista Python API
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arista Python API
- en: '**Arista Networks** has always been focused on large-scale data center networks.
    On its corporate profile page ([https://www.arista.com/en/company/company-overview](https://www.arista.com/en/company/company-overview)),
    it states the following:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '**Arista Networks** 一直专注于大规模数据中心网络。在其公司简介页面上（[https://www.arista.com/en/company/company-overview](https://www.arista.com/en/company/company-overview)），它声明如下：'
- en: ”Arista Networks is an industry leader in data-driven, client to cloud networking
    for large data center, campus, and routing environments.”
  id: totrans-226
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Arista Networks 是大型数据中心、校园和路由环境的数据驱动、客户端到云网络行业的领导者。”
- en: Notice that the statement specifically called out **large data centers**, which
    we know are exploding with servers, databases, and, yes, network equipment. It
    makes sense that automation has always been one of Arista’s leading features.
    In fact, it has a Linux underpinning behind its operating system, allowing many
    added benefits, such as Linux commands and a built-in Python interpreter directly
    on the platform. From day one, Arista was open about exposing the Linux and Python
    features to the network operators.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该声明特别提到了**大型数据中心**，我们知道那里服务器、数据库和网络设备都在爆炸式增长。自动化一直是Arista的领先特性之一是有道理的。事实上，它的操作系统背后有Linux的支持，这带来了许多附加的好处，例如Linux命令和平台上的内置Python解释器。从第一天起，Arista就公开了将Linux和Python功能暴露给网络操作员。
- en: Like other vendors, you can interact with Arista devices directly via eAPI,
    or you can choose to leverage their Python library. We will see examples of both
    in this chapter.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他供应商一样，您可以直接通过eAPI与Arista设备交互，或者您可以选择利用他们的Python库。在本章中，我们将看到这两个示例。
- en: Arista eAPI management
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arista eAPI管理
- en: Arista’s eAPI was first introduced in EOS 4.12 a few years ago. It transports
    a list of show or configuration commands over HTTP or HTTPS and responds in JSON.
    An important distinction is that it is an RPC and **JSON-RPC**, instead of a pure
    RESTful API that is served over HTTP or HTTPS. The difference is that we make
    the request to the same URL endpoint using the same HTTP method (`POST`). But
    instead of using HTTP verbs (`GET`, `POST`, `PUT`, `DELETE`) to express our action,
    we simply state our intended action in the request’s body. In the case of eAPI,
    we will specify a `method` key with a `runCmds` value.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，Arista的eAPI首次在EOS 4.12中引入。它通过HTTP或HTTPS传输一组显示或配置命令，并以JSON格式响应。一个重要的区别是，它是一个RPC和**JSON-RPC**，而不是在HTTP或HTTPS上提供的纯RESTful
    API。区别在于我们使用相同的HTTP方法（`POST`）向相同的URL端点发出请求。但与使用HTTP动词（`GET`、`POST`、`PUT`、`DELETE`）来表示我们的操作不同，我们只需在请求体中声明我们的预期操作。在eAPI的情况下，我们将指定一个具有`runCmds`值的`method`键。
- en: For the following examples, I am using a physical Arista switch running EOS
    4.16.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我使用的是运行EOS 4.16的物理Arista交换机。
- en: eAPI preparation
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eAPI准备
- en: 'The eAPI agent on the Arista device is disabled by default, so we will need
    to enable it on the device before we can use it:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Arista设备上的eAPI代理默认是禁用的，因此在使用它之前，我们需要在设备上启用它：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we have turned off the HTTP server and are using HTTPS as the
    sole transport instead. The management interfaces, by default, reside in a VRF
    called **management**. In my topology, I am accessing the device via the management
    interface; therefore, I have specified the VRF for eAPI management.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经关闭了HTTP服务器，并使用HTTPS作为唯一的传输方式。默认情况下，管理接口位于名为**management**的VRF中。在我的拓扑中，我通过管理接口访问设备；因此，我为eAPI管理指定了VRF。
- en: 'You can check that API management state via the `show management api http-commands`
    command:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过`show management api http-commands`命令检查API管理状态：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After enabling the agent, we can access the exploration page for eAPI by going
    to the device’s IP address in a web browser. If you have changed the default port
    for access, just append it. The authentication is tied to the method of authentication
    on the switch. We will use the username and password configured locally on the
    device. By default, a self-signed certificate will be used:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 启用代理后，我们可以在网页浏览器中通过访问设备的IP地址来访问eAPI的探索页面。如果您已更改了默认的访问端口，只需将其附加即可。认证与交换机上设置的认证方式相关联。我们将使用设备上配置的本地用户名和密码。默认情况下，将使用自签名证书：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_03_09.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18403_03_09.png)'
- en: 'Figure 3.9: Arista EOS explorer'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9：Arista EOS探索
- en: 'We will be taken to an explorer page, where we can type in the CLI command
    and get a nice output for the body of our request. For example, if I want to see
    how to make a request body for `show version`, this is the output I will see from
    the explorer:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将被带到探索页面，在那里我们可以输入CLI命令，并获得我们请求主体的良好输出。例如，如果我想查看如何为`show version`创建请求主体，这就是我在探索器中看到的输出：
- en: '![Graphical user interface, text, application  Description automatically generated](img/B18403_03_10.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![图形用户界面，文本，应用程序  自动生成的描述](img/B18403_03_10.png)'
- en: 'Figure 3.10: Arista EOS explorer viewer'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：Arista EOS探索查看器
- en: The overview link will take us to the sample use and background information,
    while the command documentation will serve as reference points for the show commands.
    Each command reference will contain the returned value field name, type, and a
    brief description. The online reference scripts from Arista use `jsonrpclib` ([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/)),
    which we will use.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 概览链接将带我们到示例使用和背景信息，而命令文档将作为show命令的参考点。每个命令参考将包含返回值字段名、类型和简要描述。Arista的在线参考脚本使用`jsonrpclib`([https://github.com/joshmarshall/jsonrpclib/](https://github.com/joshmarshall/jsonrpclib/))，我们将使用它。
- en: The examples in this section mainly use Python 2.7 as jsonrpclib was not ported
    to Python 3 for a long time. However, per GitHub pull request [https://github.com/joshmarshall/jsonrpclib/issues/38](https://github.com/joshmarshall/jsonrpclib/issues/38),
    Python 3 support should be included.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例主要使用Python 2.7，因为jsonrpclib长时间未移植到Python 3。然而，根据GitHub拉取请求[https://github.com/joshmarshall/jsonrpclib/issues/38](https://github.com/joshmarshall/jsonrpclib/issues/38)，Python
    3支持应该被包含。
- en: 'Installation is straightforward using `pip`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`进行安装非常直接：
- en: '[PRE49]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: eAPI examples
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: eAPI示例
- en: 'We can then write a simple program called `eapi_1.py` to look at the response
    text:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以编写一个简单的程序，名为`eapi_1.py`，来查看响应文本：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is the response I received from the previous `runCmds()` method:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前`runCmds()`方法返回的响应：
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'As you can see, the result is a list containing one dictionary item. If we
    need to grab the serial number, we can simply reference the item number and the
    key:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，结果是包含一个字典项的列表。如果我们需要获取序列号，我们可以简单地引用项号和键：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The output will contain only the serial number:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将只包含序列号：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: To be more familiar with the command reference, I recommend clicking on the
    **Command Documentation** link on the eAPI page and comparing our output with
    the output of **show version** in the documentation.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要更熟悉命令参考，我建议点击eAPI页面上的**命令文档**链接，并将我们的输出与文档中**show version**的输出进行比较。
- en: As noted earlier, unlike REST, the JSON-RPC client uses the same URL endpoint
    for calling the server resources. We can see from the previous example that the
    `runCmds()` method contains a list of commands. For the execution of configuration
    commands, you can follow the same steps and configure the device via a list of
    commands.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，与REST不同，JSON-RPC客户端使用相同的URL端点来调用服务器资源。我们可以从之前的示例中看到`runCmds()`方法包含一个命令列表。对于配置命令的执行，你可以遵循相同的步骤，并通过命令列表配置设备。
- en: 'Here is an example of configuration commands in a file named `eapi_2.py`. In
    our example, we wrote a function that takes the `switch` object and the list of
    commands as attributes:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个名为`eapi_2.py`的文件中的配置命令示例。在我们的例子中，我们编写了一个函数，该函数将`switch`对象和命令列表作为属性：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Here is the output of the command’s execution:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是命令执行输出的结果：
- en: '[PRE55]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, do a quick check on the `switch` to verify the command’s execution:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，快速检查`switch`以验证命令的执行情况：
- en: '[PRE56]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Overall, eAPI is fairly straightforward and simple to use. Most programming
    languages have libraries similar to `jsonrpclib`, which abstracts away JSON-RPC
    internals. With a few commands, you can start integrating Arista EOS automation
    into your network.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，eAPI相当直观且易于使用。大多数编程语言都有类似于`jsonrpclib`的库，这些库抽象了JSON-RPC的内部机制。只需几个命令，你就可以开始将Arista
    EOS自动化集成到你的网络中。
- en: The Arista Pyeapi library
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Arista Pyeapi库
- en: The Python client Pyeapi ([http://pyeapi.readthedocs.io/en/master/index.html](http://pyeapi.readthedocs.io/en/master/index.html))
    library is a native Python library wrapper around eAPI. It provides a set of bindings
    to configure Arista EOS nodes. Why do we need Pyeapi when we already have eAPI?
    The answer is “it depends.” Picking between Pyeapi and eAPI is mostly a judgment
    call.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Python客户端库Pyeapi([http://pyeapi.readthedocs.io/en/master/index.html](http://pyeapi.readthedocs.io/en/master/index.html))是围绕eAPI的本地Python库包装器。它提供了一套绑定来配置Arista
    EOS节点。为什么我们需要Pyeapi，因为我们已经有了eAPI？答案是“这取决于。”在Pyeapi和eAPI之间进行选择主要是一个判断决定。
- en: If you are in a non-Python environment, eAPI is probably the way to go. From
    our examples, you can see that the only requirement of eAPI is a JSON-RPC-capable
    client. Thus, it is compatible with most programming languages. When I first started
    out in the field, Perl was the dominant language for scripting and network automation.
    There are still many enterprises that rely on Perl scripts as their primary automation
    tool. If you’re in a situation where the company has already invested a ton of
    resources and the code base is in a language other than Python, eAPI with JSON-RPC
    would be a good bet.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个非Python环境中，eAPI可能是更好的选择。从我们的示例中，你可以看到eAPI的唯一要求是一个支持JSON-RPC的客户端。因此，它与大多数编程语言兼容。当我最初进入这个领域时，Perl是脚本和网络自动化的主导语言。仍然有许多企业依赖于Perl脚本作为它们的主要自动化工具。如果你处于公司已经投入了大量资源且代码库不是Python语言的情况，使用带有JSON-RPC的eAPI将是一个不错的选择。
- en: However, for those of us who prefer to code in Python, a native Python library
    such as Pyeapi means a more natural feeling in writing our code. It certainly
    makes extending a Python program to support the EOS node easier. It also makes
    keeping up with the latest changes in Python easier. For example, we can use Python
    3 with Pyeapi ([https://pyeapi.readthedocs.io/en/master/requirements.html](https://pyeapi.readthedocs.io/en/master/requirements.html))!
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于我们这些喜欢用Python编程的人来说，像Pyeapi这样的本地Python库意味着在编写代码时感觉更自然。它确实使得将Python程序扩展以支持EOS节点变得更加容易。它也使得跟上Python的最新变化变得更加容易。例如，我们可以使用Python
    3与Pyeapi一起使用（[https://pyeapi.readthedocs.io/en/master/requirements.html](https://pyeapi.readthedocs.io/en/master/requirements.html)）！
- en: Pyeapi installation
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pyeapi安装
- en: 'Installation is straightforward with `pip`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`安装非常简单：
- en: '[PRE57]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that pip will also install the `netaddr` library as it is part of the stated
    requirements ([http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html))
    for Pyeapi.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，pip也会安装`netaddr`库，因为它是Pyeapi的指定要求之一（[http://pyeapi.readthedocs.io/en/master/requirements.html](http://pyeapi.readthedocs.io/en/master/requirements.html)）。
- en: By default, the Pyeapi client will look for an INI-style hidden (with a period
    in front) file called `eapi.conf` in your home directory. You can override this
    behavior by specifying the `eapi.conf` file path. It is generally a good idea
    to separate your connection credential and lock it down from the script itself.
    You can check out the Arista Pyeapi documentation ([http://pyeapi.readthedocs.io/en/master/configfile.html#configfile](http://pyeapi.readthedocs.io/en/master/configfile.html#configfile))
    for the fields contained in the file.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Pyeapi客户端将在你的主目录中查找一个名为`eapi.conf`的INI风格的隐藏（前面带有点）文件。你可以通过指定`eapi.conf`文件路径来覆盖此行为。通常，将连接凭证与脚本本身分离并锁定是一个好主意。你可以查看Arista
    Pyeapi文档（[http://pyeapi.readthedocs.io/en/master/configfile.html#configfile](http://pyeapi.readthedocs.io/en/master/configfile.html#configfile)）以了解文件中包含的字段。
- en: 'Here is the file I am using in the lab:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我在实验室中使用的文件：
- en: '[PRE58]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The first line, `[connection:Arista1]`, contains the name that we will use
    in our Pyeapi connection; the rest of the fields should be pretty self-explanatory.
    You can lock down the file to be read-only for the user using this file:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行`[connection:Arista1]`包含我们将用于Pyeapi连接的名称；其余字段应该相当直观。你可以锁定文件，使其对使用此文件的用户为只读：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Now that Pyeapi is installed, let’s get into some examples.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Pyeapi已经安装好了，让我们来看一些示例。
- en: Pyeapi examples
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pyeapi示例
- en: 'Let’s start by connecting to the EOS node by creating an object in the interactive
    Python shell:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从通过在交互式Python shell中创建一个对象来连接到EOS节点开始：
- en: '[PRE60]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'We can execute `show` commands to the node and receive the output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向节点执行`show`命令并接收输出：
- en: '[PRE61]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The configuration field can be either a single command or a list of commands
    using the `config()` method:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 配置字段可以是单个命令或使用`config()`方法的命令列表：
- en: '[PRE62]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that command abbreviations (`show run` versus `show running-config`) and
    some extensions will not work:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，命令缩写（`show run`与`show running-config`）和一些扩展可能不会工作：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We can always catch the results and get the desired value:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终捕获结果并获取所需值：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'So far, we have been doing what we have been doing with eAPI for `show` and
    `configuration` commands. Pyeapi offers various APIs to make life easier. In the
    following example, we will connect to the node, call the VLAN API, and start to
    operate on the VLAN parameters of the device. Let’s take a look:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用eAPI对`show`和`configuration`命令进行操作。Pyeapi提供了各种API来简化生活。在下面的示例中，我们将连接到节点，调用VLAN
    API，并开始对设备的VLAN参数进行操作。让我们看看：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Let’s verify that VLAN 10 was created on the device:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们验证设备上是否已创建了 VLAN 10：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: As we can see, the Python native API on the EOS object is where Pyeapi excels
    beyond eAPI. It abstracts the lower-level attributes into the device object and
    makes the code cleaner and easier to read.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，EOS 对象上的 Python 原生 API 是 Pyeapi 在 eAPI 之上的优势所在。它将底层属性抽象到设备对象中，使代码更简洁、更容易阅读。
- en: For a full list of ever-increasing Pyeapi APIs, check the official documentation
    ([http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html](http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html)).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Pyeapi API 的完整列表，请参阅官方文档（[http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html](http://pyeapi.readthedocs.io/en/master/api_modules/_list_of_modules.html)）。
- en: To round up this section, let’s assume that we repeat the previous steps enough
    times that we would like to write another Python class to save us some work.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结本节，让我们假设我们重复之前的步骤足够多次，以至于我们希望编写另一个 Python 类来节省我们的工作。
- en: 'The `pyeapi_1.py` script is shown as follows:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`pyeapi_1.py` 脚本如下所示：'
- en: '[PRE67]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As we can see from the script, we automatically connect to the node, set the
    hostname, and load `running_config` upon connection. We also create a method of
    the class that creates VLAN by using the VLAN API. Let’s try out the script in
    an interactive shell:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从脚本中我们可以看到，我们自动连接到节点，设置主机名，并在连接时加载 `running_config`。我们还创建了一个使用 VLAN API 创建 VLAN
    的类方法。让我们在交互式外壳中尝试运行这个脚本：
- en: '[PRE68]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We have now looked at Python scripts for three of the top vendors in networking:
    Cisco Systems, Juniper Networks, and Arista Networks. In the next section, we
    will take a look at an open-source network operating system that is gaining some
    momentum in the same space.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经研究了网络领域三大供应商的 Python 脚本：思科系统、Juniper 网络和 Arista 网络。在下一节中，我们将探讨一个在相同领域获得一些动力的开源网络操作系统。
- en: VyOS example
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: VyOS 示例
- en: VyOS is a fully open-source network OS that runs on a wide range of hardware,
    virtual machines, and cloud providers ([https://vyos.io/](https://vyos.io/)).
    Because of its open-source nature, it is gaining wide support in the open-source
    community. Many open-source projects are using VyOS as the default platform for
    testing. In the last section of the chapter, we will look at a quick VyOS example.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: VyOS 是一个完全开源的网络操作系统，它可以在广泛的硬件、虚拟机和云服务提供商上运行（[https://vyos.io/](https://vyos.io/））。由于其开源特性，它在开源社区中获得了广泛的支持。许多开源项目都将
    VyOS 作为默认的测试平台。在章节的最后部分，我们将查看一个简短的 VyOS 示例。
- en: 'The VyOS image can be downloaded in various formats: [https://wiki.vyos.net/wiki/Installation](https://wiki.vyos.net/wiki/Installation).
    Once it’s downloaded and initialized, we can install the Python library on our
    management host:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: VyOS 映像可以以各种格式下载：[https://wiki.vyos.net/wiki/Installation](https://wiki.vyos.net/wiki/Installation)。一旦下载并初始化，我们就可以在我们的管理主机上安装
    Python 库：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The example script, `vyos_1.py`, is very simple:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 示例脚本 `vyos_1.py` 非常简单：
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We can execute the script to change the system domain name:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行脚本以更改系统域名：
- en: '[PRE71]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can log in to the device to verify the domain name change:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以登录到设备以验证域名更改：
- en: '[PRE72]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As you can see from the example, the method we use for VyOS is pretty similar
    to the other examples we have seen before from proprietary vendors. This is mainly
    by design, as they provide an easy transition from using other vendor equipment
    to open-source VyOS. We are getting close to the end of the chapter. There are
    some other libraries that are worth mentioning and should be kept an eye out for
    in development, which we will do in the next section.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 如示例所示，我们使用的 VyOS 方法与其他来自专有供应商的示例非常相似。这主要是出于设计考虑，因为它们提供了一种从使用其他供应商设备到开源 VyOS
    的便捷过渡。我们接近章节的结尾。还有一些其他库值得提及，并在开发中保持关注，我们将在下一节中介绍。
- en: Other libraries
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他库
- en: We’ll finish this chapter by mentioning that there are several excellent efforts
    in terms of vendor-neutral libraries such as Nornir ([https://nornir.readthedocs.io/en/stable/index.html](https://nornir.readthedocs.io/en/stable/index.html)),
    Netmiko ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko)),
    NAPALM ([https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm)),
    and Scrapli ([https://carlmontanari.github.io/scrapli/](https://carlmontanari.github.io/scrapli/)).
    We have seen some of their examples in the last chapter. Most of these vendor-neutral
    libraries are likely a step slower to support the latest platform or features.
    However, because the libraries are vendor neutral, if you do not like vendor lock-in
    for your tools, these libraries are good choices. Another benefit of using vendor-neutral
    libraries is that they are normally open source, so you can contribute upstream
    for new features and bug fixes.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过提及几个关于供应商中立库的杰出努力来结束这一章，例如Nornir ([https://nornir.readthedocs.io/en/stable/index.html](https://nornir.readthedocs.io/en/stable/index.html))、Netmiko
    ([https://github.com/ktbyers/netmiko](https://github.com/ktbyers/netmiko))、NAPALM
    ([https://github.com/napalm-automation/napalm](https://github.com/napalm-automation/napalm))
    和 Scrapli ([https://carlmontanari.github.io/scrapli/](https://carlmontanari.github.io/scrapli/))。我们在上一章中看到了它们的一些示例。这些供应商中立库中大多数可能需要更长时间来支持最新的平台或功能。然而，由于这些库是供应商中立的，如果你不喜欢工具的供应商锁定，这些库是不错的选择。使用供应商中立库的另一个好处是它们通常是开源的，因此你可以为新的功能和错误修复做出贡献。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at various ways to communicate with and manage network
    devices from Cisco, Juniper, Arista, and Vyatta. We looked at both direct communication
    with the likes of NETCONF and REST and using vendor-provided libraries such as
    PyEZ and Pyeapi. These are different layers of abstraction meant to provide a
    way to programmatically manage your network devices without human intervention.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与Cisco、Juniper、Arista和Vyatta网络设备通信和管理的方法。我们探讨了与NETCONF和REST的直接通信，以及使用供应商提供的库，如PyEZ和Pyeapi。这些都是不同层次的抽象，旨在提供一种无需人工干预即可通过编程管理网络设备的方法。
- en: In *Chapter 4*, *The Python Automation Framework*, we will take a look at a
    higher level of vendor-neutral abstraction framework called Ansible. Ansible is
    an open-source, general-purpose automation tool written in Python. It can be used
    to automate servers, network devices, load balancers, and much more. Of course,
    for our purpose, we will focus on using this automation framework for network
    devices.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *第4章*，*Python自动化框架* 中，我们将探讨一个更高层次的供应商中立抽象框架，称为Ansible。Ansible是一个用Python编写的开源通用自动化工具。它可以用于自动化服务器、网络设备、负载均衡器等等。当然，对于我们的目的，我们将专注于使用这个自动化框架来管理网络设备。
- en: Join our book community
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的图书社区
- en: 'To join our community for this book – where you can share feedback, ask questions
    to the author, and learn about new releases – follow the QR code below:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的社区——在那里你可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/networkautomationcommunity](https://packt.link/networkautomationcommunity)'
- en: '![](img/QR_Code2903617220506617062.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code2903617220506617062.png)'
