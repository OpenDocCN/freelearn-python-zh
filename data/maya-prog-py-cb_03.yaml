- en: Chapter 3. Working with Geometry
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 使用几何体
- en: 'In this chapter, we''ll be looking at ways to create and manipulate geometry
    with scripting. The following topics will be covered:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨通过脚本创建和操作几何体的方法。以下主题将得到涵盖：
- en: Working with selected objects and checking node type
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与选定的对象一起工作并检查节点类型
- en: Accessing geometric data in polygonal models
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问多边形模型中的几何数据
- en: Accessing geometric data in NURBS objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问NURBS对象中的几何数据
- en: Creating curves
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建曲线
- en: Creating new polygonal faces
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的多边形面
- en: Creating new modifiers (noise)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的修改器（噪声）
- en: Creating novel primitives (tetrahedron)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的原语（四面体）
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we'll be looking at how to manipulate geometry within Maya
    via scripting. First off, we'll look at how to make sure that we have the right
    kind of object selected. From there, we'll look at how to retrieve information
    about particular kinds of geometry (both polygonal and NURBS).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何通过脚本在Maya中操作几何体。首先，我们将看看如何确保我们选择了正确的类型的对象。从那里，我们将看看如何检索有关特定类型几何体的信息（包括多边形和NURBS）。
- en: We'll also be looking at how to create new geometry (both single faces and entire
    objects) and how to create per-vertex modifications to existing objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何创建新的几何体（包括单个面和整个对象），以及如何对现有对象进行按顶点修改。
- en: Working with selected objects and checking node type
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与选定的对象一起工作并检查节点类型
- en: Very often, you will want to make a script that only works on certain kinds
    of objects and the objects that already exist before the user invokes your script.
    In this case, you'll want to be able to not only determine what object(s) are
    currently selected but also to verify that the selected object(s) are of the appropriate
    type. In this example, we'll be creating a script that will verify that the currently
    selected object is, in fact, an instance of polygonal geometry and altering the
    user if it isn't.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 非常常见的情况是，你可能只想编写一个只对某些类型的对象以及用户在运行脚本之前已经存在的对象起作用的脚本。在这种情况下，你将希望能够不仅确定当前选中的对象是什么，还要验证选中的对象是否为适当的类型。在本例中，我们将创建一个脚本，用于验证当前选中的对象实际上是否是多边形几何体的实例，如果不是，则修改用户。
- en: How to do it...
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new script and add the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本并添加以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you run the preceding script with nothing selected, you should get an error
    indicating that you should select something. If you run it with something other
    than a polygon object selected, you'll also get an error, but indicating this
    you should select a polygonal object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的脚本而没有选择任何内容，你应该会得到一个错误提示，表明你应该选择一些内容。如果你选择了一个非多边形对象，你也会得到一个错误，但会提示你应该选择一个多边形对象。
- en: If you run it with a polygonal object, however, the script will print **FOUND
    POLYGON**.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你选择了一个多边形对象，脚本将打印**找到多边形**。
- en: How it works...
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The script consists of two functions—one (`currentSelectionPolygonal`) to test
    if a given object is polygonal geometry and another (`checkSelection`) to invoke
    that on the currently selected object. Because `checkSelection` is the entry point
    for the script, that's where we'll start.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本由两个函数组成——一个（`currentSelectionPolygonal`）用于测试给定的对象是否是多边形几何体，另一个（`checkSelection`）用于在当前选中的对象上调用它。因为`checkSelection`是脚本的入口点，所以我们将从这里开始。
- en: 'The first thing that we have to do is to get a list of what object or objects
    are currently selected. To do this, we''ll use the `ls` command. The `ls` command
    is short for *list* and another example of the bash scripting heritage of **Maya
    Embedded Language** (**MEL**) that carries over to the Python command list. The
    `ls` command can do a variety of things, but the most common way that you''re
    likely to use it is with the `selection` flag to return a list of the currently
    selected nodes, as in:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须做的第一件事是获取当前选中的对象或对象的列表。为此，我们将使用`ls`命令。`ls`命令是*list*的缩写，也是**Maya嵌入式语言**（**MEL**）的bash脚本遗产的另一个例子，这种遗产延续到了Python命令列表中。`ls`命令可以执行各种操作，但最常见的方式可能是使用`selection`标志来返回当前选中的节点的列表，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that even though we''re essentially asking Maya a question, it is not
    necessary to use the `query` flag. In fact, using the query mode for the `ls`
    command will generate an error. Note that we store the result of the `ls` command
    into a variable named `selectedObjects`. This will give us a collection of objects
    as a Python list, with objects appearing in the order in which they were selected.
    First, we want to make sure that at least one object is selected by checking the
    length of `selectedObjs`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们本质上是在向Maya提问，但使用`query`标志并不是必要的。实际上，使用`ls`命令的查询模式将生成错误。注意，我们将`ls`命令的结果存储在一个名为`selectedObjects`的变量中。这将给我们一个Python列表形式的对象集合，对象以它们被选择的顺序出现。首先，我们想要确保至少选择了一个对象，通过检查`selectedObjs`的长度：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If the user hasn't selected anything, we use the `error` command to both notify
    the user and stop the execution of the script. Adding meaningful error messages
    is a great way to give your users quality feedback. You can also use the `warning()`
    command to present the user with feedback without stopping the script. In both
    cases, the error (or warning) will show to the user in the same way as built-in
    errors (or warnings), appearing in the bottom of Maya's interface and with a red
    (or yellow) background.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户没有选择任何内容，我们使用`error`命令来通知用户并停止脚本的执行。添加有意义的错误信息是提供高质量反馈的绝佳方式。您还可以使用`warning()`命令向用户提供反馈而不停止脚本。在这两种情况下，错误（或警告）将以与内置错误（或警告）相同的方式显示给用户，出现在Maya界面的底部，并带有红色（或黄色）背景。
- en: Once we know that we have at least one object selected, we want to make sure
    that the given object is a polygonal one. Using `-1` as the index into the list
    allows us to count backwards from the end. In this case, that will give us the
    most recently selected object.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道我们至少选择了一个对象，我们想要确保给定的对象是一个多边形对象。使用`-1`作为列表中的索引允许我们从末尾开始计数。在这种情况下，这将给我们最近选择的对象。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We then pass that object to our `currentSelectionPolygonal` function, which
    will determine if it is, in fact, a polygonal object. This function will handle
    the check and return either `True` or `False`, depending on whether or not the
    object in question is polygonal geometry.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后将该对象传递给我们的`currentSelectionPolygonal`函数，该函数将确定它实际上是否是一个多边形对象。这个函数将处理检查并返回`True`或`False`，这取决于所讨论的对象是否是多边形几何形状。
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's generally a good idea to break up your scripts into distinct parts, with
    each one responsible for one distinct task. This makes your scripts much easier
    to write and maintain. However, it also requires that the different parts be able
    to communicate with each other. The `return` statement is one of the most common
    ways to do this. It causes the current function to stop and *return* to the previous
    scope. If you give it a value, that value is brought back along, allowing information
    to be passed from one function to another.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通常将脚本分解成不同的部分是一个好主意，每个部分负责一个特定的任务。这使得编写和维护脚本变得更加容易。然而，这也要求不同的部分能够相互通信。`return`语句是完成这一点的最常见方式之一。它会导致当前函数停止并*返回*到上一个作用域。如果您给它一个值，该值将随它返回，从而允许信息从一个函数传递到另一个函数。
- en: We can check the type of given node by using the `nodeType()` command, but there's
    a bit more to it than that. If we check the type of the selected object itself,
    we'll almost always get *transform*. This is due to the fact that most things
    you interact with in Maya are composed of two nodes, not one. There is generally
    a shape node, which holds all of the specific data associated with a given object
    (faces, vertices, and so on), and a transform object that holds the position,
    rotation, and scale (along with a few other things) common to all objects that
    appear on screen and can be moved. The shape node is always a child of its corresponding
    transform node.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`nodeType()`命令来检查给定节点的类型，但这不仅仅是那样。如果我们检查所选对象本身的类型，我们几乎总是会得到*变换*。这是因为你在Maya中交互的大多数事物都是由两个节点组成的，而不是一个。通常有一个形状节点，它包含与给定对象相关的所有特定数据（面、顶点等），还有一个变换对象，它包含所有屏幕上出现并可移动的对象的共同位置、旋转和缩放（以及一些其他东西）。形状节点始终是其相应变换节点的子节点。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When you click on something in the interface, such as a polygonal object, you're
    actually clicking on the shape node, but Maya will automatically jump one step
    up the hierarchy to the transform node so that you can move it. That is often
    used to create controls for rigging by having the shape node for a curve be a
    child of some other transform, providing an easy way to grab bones inside a model
    by clicking on non-renderable curves (for example).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在界面中点击某个对象时，例如多边形对象，你实际上是在点击形状节点，但Maya会自动跳到层次结构中的一步，到变换节点，这样你就可以移动它。这通常用于通过使曲线的形状节点成为其他变换的子节点来创建绑定控制，从而提供一种通过点击不可渲染的曲线（例如）来抓取模型内部骨骼的简单方法。
- en: 'So, what we actually need in order to test the geometry type is the shape node
    associated with the transform. There are a couple of ways to go about this, but
    the best is to use the `listRelatives()` command with `shapes=True`. This will
    give us the shape node associated with the input node (if any):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上需要来测试几何类型的是与变换关联的形状节点。有几种方法可以做到这一点，但最好的方法是使用带有`shapes=True`的`listRelatives()`命令。这将给我们提供与输入节点关联的形状节点（如果有的话）：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we''ve done this, we can test its type with `nodeType` to see what kind
    of geometry we have. If we have a polygonal object, it will result in `mesh`.
    If the node type is, in fact `mesh`, we return a value of `True`. If it''s anything
    other than `mesh`, we return `False` instead:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们做了这件事，我们可以使用`nodeType`来测试其类型，看看我们有什么样的几何形状。如果我们有一个多边形对象，它将导致`mesh`。如果节点类型实际上是`mesh`，我们返回一个值为`True`。如果它不是`mesh`，我们则返回`False`：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note that `return False` appears outside of an `else` block. This is mainly
    a stylistic choice. If you have a `return` statement inside a conditional (as
    we do here), it's a good idea to have a `return` statement that is outside the
    conditional that is guaranteed to be called, to ensure that there is no possible
    way that the function can fail to provide a return value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`return False`出现在`else`块之外。这主要是一种风格选择。如果你在条件（如我们在这里所做的那样）内部有一个`return`语句，那么有一个`return`语句是保证会被调用的，这样可以确保函数没有可能不提供返回值。
- en: 'Some people don''t like to have multiple return values in a single function
    though, and if you''re one of them, you could just as well create a variable and
    return that instead, as in:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有些人不喜欢在单个函数中有多个返回值，但如果你是其中之一，你也可以创建一个变量并返回它，如下所示：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Or, for a more compact (but perhaps slightly less readable) approach, you could
    just return the result of the comparison itself:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，为了更紧凑（但可能稍微不那么易读）的方法，你只需返回比较本身的结果：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All of this would have the same result, in that the function would return `True`
    if and only if the object tested possessed a shape node of type `mesh`. At this
    point, we're done with the `currentSelectionPolygonal` function and can turn our
    attention back to `checkSelection`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都会产生相同的结果，即如果测试的对象具有类型为`mesh`的形状节点，则函数将返回`True`。在这个时候，我们完成了`currentSelectionPolygonal`函数，可以将注意力转回`checkSelection`。
- en: 'All that''s left is to check the return value and notify the user of the result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是检查返回值并通知用户结果：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There's more...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can use the same technique of grabbing the shape node with `listRelatives`
    and testing its type to identify other kinds of objects. Some of the more useful
    ones to be aware of are `nurbsCurve` for NURBS curves and `nurbsSurface` for NURBS
    objects.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与`listRelatives`获取形状节点并测试其类型相同的技巧来识别其他类型的对象。其中一些更有用的类型包括`nurbsCurve`用于NURBS曲线和`nurbsSurface`用于NURBS对象。
- en: Accessing geometric data in polygonal models
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在多边形模型中访问几何数据
- en: In this example, we'll be looking at how to get information about polygonal
    geometry, which will form the basis for more complex scripts.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何获取多边形几何信息，这将成为更复杂脚本的基石。
- en: Getting ready
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new scene and make sure that it contains one or more polygonal objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并确保它包含一个或多个多边形对象。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script, name it `polyStats.py`, and add the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`polyStats.py`，并添加以下代码：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Running the preceding code will result in information about the currently selected
    polygonal object being printed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将在控制台打印出当前所选多边形对象的信息。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `polyEvaluate` command is pretty straightforward and can be used to determine
    various information about a polygonal object. In this case, we're just grabbing
    the number of vertices, edges, and faces that the object contains.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`polyEvaluate`命令相当直观，可以用来确定多边形对象的各种信息。在这种情况下，我们只是获取对象包含的顶点、边和面的数量。'
- en: There's more...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Grabbing the number of components that an object contains isn't really all that
    useful, in and of itself. To perform the useful work, you'll likely want to access
    the components directly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个对象包含的组件数量本身并不是特别有用。为了执行有用的操作，您可能希望直接访问组件。
- en: 'In order to do this, you''ll want to be understand that each object has a collection
    of components stored as a Python list, which are named as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，您需要理解每个对象都存储了一个Python列表中的组件集合，命名如下：
- en: '| Component | List name |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 列表名称 |'
- en: '| --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Vertices | vtx |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 顶点 | vtx |'
- en: '| Edges | e |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 边 | e |'
- en: '| Faces | f |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Faces | f |'
- en: 'So, to select the first vertex for a given object (whose name is stored in
    a variable `obj`), you could do the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了选择给定对象（其名称存储在变量`obj`中）的第一个顶点，您可以这样做：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You could similarly grab the first edge with:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用类似的方式获取第一个边：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or the first face with:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 或者第一个面：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Since the lists of components are just ordinary Python lists, you can also
    refer to collections of components by using a colon along with a start or a stop
    index (or both). For example, if we wanted to select vertices from `5` to `12`,
    we could do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件列表只是普通的Python列表，您也可以使用冒号以及起始或结束索引（或两者）来引用组件集合。例如，如果我们想从`5`到`12`选择顶点，我们可以这样做：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This would work, but could quickly get awkward if you wanted to have the starting
    and ending indices as variables as well, which would result in something like
    the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，但如果您还想将起始和结束索引作为变量，这可能会变得有些尴尬，结果可能如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This would build up the proper value to pass to `cmds.select` (something like
    `polySurface5.vtx[5:12]`), but is a bit awkward to type. An easier way is to use
    Python's built-in string formatting capability, which can be used to fit variables
    into a specific string.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建出传递给`cmds.select`的正确值（例如`polySurface5.vtx[5:12]`），但输入起来有些繁琐。一个更简单的方法是使用Python内置的字符串格式化功能，它可以用来将变量放入特定的字符串中。
- en: 'To do this, start with an example of the string you want to end up with, as
    in:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要这样做，从一个您想要得到的字符串示例开始，如下所示：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, identify each portion of the string that will change. In this case, we
    want to pass in three things—the name of the object, the start index, and the
    end index. For each one, replace the specific value with a number wrapped in curly
    braces, as in:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，确定字符串中将要改变的部分。在这种情况下，我们想要传递三个东西——对象名称、起始索引和结束索引。对于每一个，用花括号包裹的数字替换特定的值，如下所示：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once you''ve done this, you can call `format()` on the string, passing in values
    to replace the curly-bracketed numbers, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，您可以在字符串上调用`format()`，传递值以替换花括号中的数字，如下所示：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The numbers inside the brackets serve as indices and tell Python which of the
    arguments passed into format should go where. In this case, we're saying that
    the first argument (the object name) should go at the start and that the next
    two should be placed inside the square brackets.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号内的数字作为索引，告诉Python传递给`format`的参数应该放在哪里。在这种情况下，我们说的是第一个参数（对象名称）应该放在开始处，接下来的两个应该放在方括号内。
- en: 'Here''s an example of it all put together:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个将所有这些放在一起示例：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Accessing geometric data in NURBS objects
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在NURBS对象中访问几何数据
- en: In this example, we'll be looking at how to retrieve information about NURBS
    surfaces, starting with the number of **control vertices** (**CVs**) they contain.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何检索有关NURBS表面的信息，从它们包含的**控制顶点**（**CVs**）的数量开始。
- en: However, the number of CVs in a NURBS object isn't quite as straightforward
    as the number of vertices in a polygonal object. Although polygonal objects are
    relatively simple, with their shape determined directly by the position of the
    vertices, the curvature at any given point of a NURBS object is influenced by
    multiple points. The exact number of points that influence a given area depends
    on the degree of the surface.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，NURBS对象中的CV数量并不像多边形对象中的顶点数量那样简单直接。尽管多边形对象相对简单，它们的形状直接由顶点的位置决定，但NURBS对象在任何给定点的曲率受多个点的影响。影响特定区域的确切点数取决于表面的度数。
- en: To see how this works, we'll create a script that will determine the total number
    of CVs in each direction (`U` and `V`) of a NURBS surface, and we'll look at how
    to select a particular CV.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这是如何工作的，我们将创建一个脚本，该脚本将确定NURBS表面每个方向（`U`和`V`）中的CV总数，并且我们将查看如何选择特定的CV。
- en: Getting ready
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have a scene containing at least one NURBS surface.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你有包含至少一个NURBS表面的场景。
- en: How to do it...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new file, name it `getNURBSinfo.py` (or similar), and add the following
    code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，命名为`getNURBSinfo.py`（或类似），并添加以下代码：
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Select a NURBS surface and run the script. You'll see the number of CVs in each
    of the parametric directions (`U` and `V`) output to the script editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个NURBS表面并运行脚本。您将看到每个参数化方向（`U`和`V`）中的CV数量输出到脚本编辑器。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we use the `getAttr` command to retrieve information about
    the selected object. The `getAttr` command is short for *get attribute* and can
    be used to retrieve the value of any attribute on a given node, making it useful
    in a wide range of circumstances.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`getAttr`命令来检索有关所选对象的信息。`getAttr`命令是“获取属性”的缩写，可以用来检索给定节点上任何属性的价值，这使得它在各种情况下都很有用。
- en: 'In this particular situation, we''re using it to get two things per direction
    along the surface—the number of spans and the degree, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，我们正在用它来获取沿着表面的每个方向上的两件事——跨度和度数，如下所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The "degree" of a NURBS surface (or curve) is the number of points that influence
    each point along the geometry and ranges from 1 (linear) to 3\. Curves and surfaces
    with degree of 1 are linear and resemble polygonal geometry. Curves and surfaces
    with degrees of greater than 1 interpolate multiple points to generate curvature.
    The total number of CVs in a curve or surface is always equal to the number of
    spans plus the degree.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NURBS表面（或曲线）的“度数”是影响几何中每个点的点的数量，范围从1（线性）到3。度数为1的曲线和表面是线性的，类似于多边形几何。度数大于1的曲线和表面通过插值多个点来生成曲率。曲线或表面中的CV总数始终等于跨度的数量加上度数。
- en: 'One easy way to understand that is to think of the simplest possible curve—a
    straight line. That curve would have a single span (one segment) and would be
    of degree 1 (linear), and it would still require two points (the start and the
    end) in order to be defined. In that case, we would have:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一种理解这个概念简单的方法是考虑最简单的曲线——一条直线。这条曲线将有一个跨度（一个段），度数为1（线性），并且仍然需要两个点（起点和终点）来定义。在这种情况下，我们将有：
- en: '*(1 span) + (degree of 1) = 2 points*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*(1跨度) + (度数为1) = 2个点*'
- en: For more complex curves, more points would be needed, but it's the same principle—the
    minimum number will always be (degree of curve) plus one (since it's impossible
    to have a curve or a surface with zero spans).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的曲线，需要更多的点，但原理相同——最小数量总是（曲线度数）加一（因为不可能有一个没有跨度的曲线或表面）。
- en: 'So, to get the total number of CVs, we use `getAttr` twice, once to get the
    spans and again to get the degree, then we add the totals, as in the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要获取CV的总数，我们使用`getAttr`两次，一次获取跨度，再次获取度数，然后将总数相加，如下所示：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, to we''ll finish off the script by selecting the first and last CVs.
    Selecting a CV on a NURBS surface is quite similar to selecting a vertex of a
    polygon, with the two following key differences:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过选择第一个和最后一个CV来完成脚本。在NURBS表面上选择CV与选择多边形的顶点非常相似，但有以下两个关键区别：
- en: We use `.cv` instead of `.vtx`
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用`.cv`而不是`.vtx`
- en: We need to specify two indices (one for `U` and one for `V`) instead of one
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要指定两个索引（一个用于`U`，一个用于`V`）而不是一个
- en: 'Selecting the first CV is pretty easy; we just use zero for both indices:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 选择第一个CV相当简单；我们只需为两个索引都使用零：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Selecting the last CV is a bit more involved and requires that we string together
    a few different parts to make sure that we end up with something like `myObj.cv[8][8]`
    in the case that the surface has nine CVs in each direction. We need to subtract
    one from the total CV number and wrap that in `str()` so that Python will allow
    us to combine it with the text. Putting this all together gives us:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 选择最后一个CV稍微复杂一些，需要我们将几个不同的部分组合在一起，以确保我们最终得到类似`myObj.cv[8][8]`的东西，如果表面在每个方向上有九个CV。我们需要从CV总数中减去一个，并将其放在`str()`中，这样Python就会允许我们将它与文本组合在一起。将这些组合在一起，我们得到：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, we could use string formatting to build up the input, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用字符串格式化来构建输入，如下所示：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The previously mentioned discussion is based on having working with a NURBS
    surface. If we were working with a curve instead, things would be much the same,
    but we would use a single index to specify the CV rather than two, as in:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的讨论是基于使用NURBS曲面。如果我们使用的是曲线而不是曲面，情况将非常相似，但我们将使用单个索引来指定CV，而不是两个，如下所示：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Also note that when we retrieve the values for degree and span, we do not specify
    `U` or `V` because curves have only one dimension rather than two.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，当我们检索度数和跨度值时，我们不指定`U`或`V`，因为曲线只有一个维度而不是两个。
- en: Creating curves
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建曲线
- en: In this example, we'll be looking at how to create curves with code. This can
    be used for a number of different purposes, such as forming the basis for further
    modeling operation or creating custom controls for complex rigs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何使用代码创建曲线。这可以用于多种不同的目的，例如作为进一步建模操作的基础或为复杂的装置创建自定义控件。
- en: We'll actually be making two curves in this example—a simple one that we create
    directly and a more complex one that we create one point at a time.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将制作两条曲线——一条直接创建的简单曲线和一条逐点创建的更复杂的曲线。
- en: Here's what we'll end up with as our output and moving both curves away from
    the origin.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们最终的输出，将两个曲线都从原点移开。
- en: '![Creating curves](img/4657_03_01.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![创建曲线](img/4657_03_01.jpg)'
- en: How to do it...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file and name it `makeCurves.py` or similar. Add the following
    code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，并将其命名为`makeCurves.py`或类似名称。添加以下代码：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you run the preceding code, you'll end up with two curves being created—a
    square and an astroid curve.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你将得到两条曲线——一个是正方形曲线，另一个是心形曲线。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To make a new curve, we'll want to first understand what we're trying to make.
    In the case of the square, it's easy enough. We just need to have four points—each
    half of the width away from the origin in each combination of positive and negative
    ( (-,-), (-,+), (+,+), and (+,-)).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一条新曲线，我们首先需要了解我们想要创建什么。在正方形的情况下，这很简单。我们只需要有四个点——每个点距离原点的一半宽度，在每个正负组合中（(-,-),
    (-,+), (+,+), 和 (+,-))）。
- en: 'To actually make the curve, we''ll use the `curve` command and specify a list
    of points. We''ll also set the degree of our curve to `1`, that is, make it linear,
    which makes sense for a square. Putting that together gives us the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际创建曲线，我们将使用`curve`命令并指定一系列点。我们还将设置曲线的度数为`1`，即使其线性，这对于正方形来说是有意义的。将这些放在一起，我们得到以下结果：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note that we specify five points rather than four. If we leave it at only four
    points, we would end up with three spans rather than four, leaving one of the
    sides of our square missing. One way to address this is to simply repeat the first
    point at the end of the point list to close the curve.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们指定了五个点而不是四个。如果我们只留下四个点，我们最终会得到三个跨度而不是四个，导致正方形的一边缺失。解决这个问题的方法之一是简单地重复点列表末尾的第一个点来闭合曲线。
- en: For a more complex example, we'll create an **astroid curve** using some fun
    math. To make this easier, we'll create a function that will accept a parameterized
    input and output a two-element tuple with the *X* and *Y* coordinates of the curve
    for that input. We'll also append points to the curve as we go, as it is sometimes
    an easier way to approach things for more complex curves.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个更复杂的例子，我们将使用一些有趣的数学方法创建一个**心形曲线**。为了使这个过程更容易，我们将创建一个函数，该函数将接受参数化输入并输出一个包含曲线该输入的X和Y坐标的两个元素的元组。我们还将逐点向曲线中添加点，因为对于更复杂的曲线，这有时是一种更容易的方法。
- en: 'The parameterized equations for the curve can be written as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线的参数方程可以写成如下：
- en: 'Here, theta ranges from 0 to 2pi. Putting the value in terms of Python gives
    us the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，theta的范围是从0到2π。用Python表示这个值，我们得到以下结果：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we have a function that will give us the curve we want, we''ll create
    a new curve and add points to it one at a time. First, we make the curve and set
    it to have a degree of three (cubic) so that it''s nice and smooth, as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个函数可以给出我们想要的曲线，我们将创建一条新曲线并逐点添加到它。首先，我们创建曲线并将其设置为具有三次（立方）度数，这样它就会很平滑，如下所示：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, we''ll step through our range of zero to (2 * pi) and add a new point
    to the existing curve:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将遍历从零到（2 * π）的范围，并在现有曲线上添加一个新点：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We start by calculating our input as 1/32nd of (2 * pi) times our index and
    passing it into our curve function. We then use the `curve` command again, but
    with a couple of changes, namely:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算输入为（2 * π）的1/32乘以我们的索引，并将其传递给曲线函数。然后我们再次使用`curve`命令，但进行了一些更改，即：
- en: We specify the curve we're working on by passing it as the first argument
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过将其作为第一个参数传递来指定我们正在工作的曲线
- en: We use the `append=True` flag to let Maya know that the points should be added
    to the existing curve instead of creating a new one
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `append=True` 标志让 Maya 知道应该将点添加到现有曲线而不是创建一个新的曲线。
- en: We specify a single point using the output of our `curveFunction` for the *X*
    and *Y* coordinates and 0 for the *Z* coordinate
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `curveFunction` 的输出指定一个点，用于 *X* 和 *Y* 坐标，以及 *Z* 坐标的 0
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Although you likely won't have a need for astroid curves in your own projects,
    there are plenty of situations where you may want to create curves in a step-by-step
    fashion. For example, you might want to create a curve based on an animation sequence,
    by adding a point for the position of a given object each frame. We'll see how
    to grab positions on a frame-by-frame basis when we look at scripting for animation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可能在自己的项目中不需要心形线，但有很多情况下你可能想要逐步创建曲线。例如，你可能想根据动画序列创建一个曲线，通过在每一帧添加给定对象的位位置点。当我们查看动画脚本时，我们将看到如何逐帧获取位置。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on the astroid curve, have a look at its entry on the Wolfram
    MathWorld website, [http://mathworld.wolfram.com/Astroid.html](http://mathworld.wolfram.com/Astroid.html).
    That's just one of the fun curves that the site explains, along with all sorts
    of other mathematical resources that you might find useful.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关于心形线（astroid curve）的更多信息，请查看 Wolfram MathWorld 网站的条目，[http://mathworld.wolfram.com/Astroid.html](http://mathworld.wolfram.com/Astroid.html)。这只是该网站解释的有趣曲线之一，以及你可能觉得有用的各种其他数学资源。
- en: Creating new polygonal faces
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的多边形面
- en: In this example, we'll be looking at how to create new polygonal faces with
    code, both a simple quad and a more complex example that incorporates an internal
    hole.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将探讨如何使用代码创建新的多边形面，包括一个简单的四边形和一个更复杂的例子，该例子包含一个内部洞。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new file, name it `polyCreate.py` (or similar), and add the following
    code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新文件，命名为 `polyCreate.py`（或类似），并添加以下代码：
- en: '[PRE32]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If you run the preceding script, you'll see two new objects created, both in
    the *XY* plane—one is a simple square and the other is a square with a hole in
    the center.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的脚本，你会看到创建了两个新对象，都在 *XY* 平面上——一个是简单的正方形，另一个是在中心有洞的正方形。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `polyCreateFacet` command is fairly straightforward and expects to receive
    an array of point positions. Each point should be stored in a tuple of three values,
    each one for the *X*, *Y*, and *Z* position of the vertex.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`polyCreateFacet` 命令相当直接，并期望接收一个点位置数组。每个点应存储在一个包含三个值的元组中，每个值分别对应顶点的 *X*、*Y*
    和 *Z* 位置。'
- en: 'In the first example, we merely call the `polyCreateFacet` command directly
    and provide the four points that make up the corners of a 2-unit square centered
    at the origin and aligned in the *XY* plane. We have the following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，我们只是直接调用 `polyCreateFacet` 命令，并提供组成以原点为中心、在 *XY* 平面上对齐的 2 单位正方形四个顶点的四个点。以下是我们的代码：
- en: '[PRE33]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can also create polygons with internal holes, but in order to do that, you'll
    need to signal to Maya that you're starting a hole. To do this, you'll need to
    feed the `polyCreateFacet` command a blank point as an empty tuple.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建带有内部洞的多边形，但为了做到这一点，你需要向 Maya 信号你正在开始一个洞。为此，你需要向 `polyCreateFacet` 命令提供一个空点作为空元组。
- en: When creating more complex faces, it can be easier to create an array to hold
    the various points and push them onto it one at a time, rather than trying to
    have a single long argument to the `polyCreateFacet` command.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建更复杂的面时，创建一个数组来存储各种点并逐个将其推入它可能更容易，而不是尝试将单个长参数传递给 `polyCreateFacet` 命令。
- en: 'We start, once again, with four points to define a square in the *XY* plane,
    as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次从四个点开始，在 *XY* 平面上定义一个正方形，如下所示：
- en: '[PRE34]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In order to get Maya to start creating a hole in the face we''re making, we
    next add an empty tuple:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Maya 开始在我们制作的面上创建一个洞，我们接下来添加一个空元组：
- en: '[PRE35]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Now we can start adding the points for the hole. In this case, we'll add points
    to make a circular hole with 32 points. This's done easily enough with a little
    bit of trigonometry. Because we're making a hole with 32 segments, we divide one
    full rotation (in radians, so `math.pi * 2`) by `32` and multiply by our index
    to get the value we feed to the trigonometric functions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始添加孔的点了。在这种情况下，我们将添加32个点来制作一个圆形孔。这可以通过一点三角学轻松完成。因为我们用32个段来制作孔，所以我们把一个完整的旋转（以弧度为单位，所以`math.pi
    * 2`）除以`32`，然后乘以我们的索引，得到我们提供给三角函数的值。
- en: 'Putting that all together give us the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些放在一起，我们得到以下结果：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we''ll have an array of 37 tuples representing 36 points plus one blank
    entry to indicate the start of a cutout region. Passing that into the `polyCreateFacet`
    command gives us the final result. We use the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将有一个包含37个元组的数组，代表36个点加上一个空白条目，以指示切割区域的开始。将此传递给`polyCreateFacet`命令将给出最终结果。我们使用以下代码：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: When creating polygonal faces, the order in which the vertices are specified
    is important. It's likely obvious that adding vertices out of order would cause
    the resulting faces to be bent in unintended ways, but the order also affects
    the direction that the face or faces **normals** will point. Always be sure to
    specify your points around the outer edge of the face that you're creating, and
    in the counter-clockwise direction, which will cause the normals to point out
    of the screen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建多边形面时，指定顶点的顺序非常重要。很明显，如果顶点顺序错误，会导致生成的面以意想不到的方式弯曲，但顺序也会影响面或面的法线指向的方向。务必确保按照创建的面外围的顺时针方向指定你的点，这样法线就会指向屏幕外。
- en: 'If you want the normals to point in the other direction, either specify them
    in the opposite order or explicitly reverse the normals on the created faces using
    the `polyNormal` command as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让法线指向另一个方向，要么以相反的顺序指定它们，要么使用以下`polyNormal`命令显式地反转创建的面的法线：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `4` variable likely seems cryptic, but the `polyNormal` command can perform
    a few different specific functions (including a few deprecated options), and the
    `normalMode` flag is how to tell Maya which one you want. For details, be sure
    to consult the Python command documentation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`4`变量可能看起来很神秘，但`polyNormal`命令可以执行几个不同的特定功能（包括一些已弃用的选项），而`normalMode`标志是告诉Maya你想要哪个的一个方法。有关详细信息，请务必查阅Python命令文档。'
- en: If you find yourself creating complex faces, such as our second example with
    the hole, you might want to ensure that you are left with faces of no more than
    four sides. You can certainly do it by creating the faces one at a time and joining
    them (which we will do in the custom primitive example, mentioned later), or you
    can create the shape as a single face, then triangulate it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己正在创建复杂的面，例如我们带有孔的第二例，你可能想确保你留下的面不超过四边。你当然可以通过一次创建一个面并将它们连接起来（我们将在稍后提到的自定义原语示例中这样做）来实现，或者你可以创建一个形状作为一个单一的面，然后将其三角化。
- en: 'To triangulate the resulting face, run the `polyTriangulate` command after
    creating it, as in the following:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要三角化生成的面，在创建它之后运行`polyTriangulate`命令，如下所示：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can also have Maya attempt to combine the resulting triangles into quads
    by running the `polyQuad` command as follows:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过运行以下`polyQuad`命令让Maya尝试将生成的三角形合并成四边形：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Quadrangulation doesn't always work, but it also generally doesn't hurt anything.
    Leaving **ngons** in your meshes, on the other hand, can lead to all sorts of
    problems down the road and is best avoided.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 四角化并不总是有效，但它通常也不会造成伤害。另一方面，在网格中留下**非四边形**可能会导致各种问题，最好避免。
- en: Creating new modifiers (noise)
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的修改器（噪声）
- en: Many 3D modeling and animation packages provide a way to add a bit of random
    noise to the vertices of an object, but Maya does not. This may seem like an oversight,
    but it also provides us with a great example project.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 许多3D建模和动画软件包提供了一种方法，可以在对象顶点上添加一些随机噪声，但Maya没有。这看起来可能是一个疏忽，但它也为我们提供了一个很好的项目示例。
- en: 'In this example, we''ll write a script to step through all of the vertices
    of a polygonal object and move each of them slightly. Here''s an example of what
    a simple polygonal sphere looks like both before and after applying the script
    that we''ll be developing:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将编写一个脚本来遍历多边形对象的全部顶点，并将它们稍微移动一下。以下是一个简单的多边形球体在应用我们将开发的脚本之前和之后的示例：
- en: '![Creating new modifiers (noise)](img/4657_03_02.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![创建新的修改器（噪声）](img/4657_03_02.jpg)'
- en: How to do it...
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new script, name it `addNoise.py`, and add the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，命名为`addNoise.py`，并添加以下代码：
- en: '[PRE41]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you run this code with a polygonal object selected, you'll see that each
    of the vertices is moved by a small random amount (`0.2` units).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择多边形对象并运行此代码，您会看到每个顶点都通过一个小随机量（`0.2`单位）移动。
- en: How it works...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'First off, we''ll want to make sure that we have a polygonal object selected
    by:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们希望确保我们已选择多边形对象：
- en: Grabbing the currently selected objects
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取当前选定的对象
- en: Determining the shape node (if any) attached to the most recently selected object
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定最近选择的对象（如果有的话）附加的形状节点
- en: Testing the shape node to make sure that it's a polygonal object
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试形状节点以确保它是一个多边形对象
- en: 'Take a look at the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下代码：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once we''ve done that, we''ll want to loop through each of the vertices of
    the object, but first we''ll need to know how many vertices it contains. So, we
    use the `polyEvaluate` command as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们这样做，我们希望遍历对象的每个顶点，但首先我们需要知道它包含多少个顶点。因此，我们使用`polyEvaluate`命令如下：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now we''re ready to loop through the vertices and move each one. Because we''ll
    want each axis to be independent, we''ll start by creating a variable to hold
    the offsets for each:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好遍历顶点并移动每个顶点。因为我们希望每个轴都是独立的，所以我们首先创建一个变量来保存每个的偏移量：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we''re ready to loop through the object. For each pass, we''ll want to
    set the `randAmt` array to random variables, then apply those to the position
    of the vertex:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好遍历这个对象。对于每次遍历，我们希望将`randAmt`数组设置为随机变量，然后将这些变量应用到顶点的位置：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A note on how we're setting the random amount—we want to make sure that the
    values produced range between the input value (as the maximum) and its negative
    equivalent (as the minimum).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于我们如何设置随机数量的说明——我们希望确保产生的值在输入值（作为最大值）和它的负等效值（作为最小值）之间。
- en: The `random.random()` function will produce a random number between 0 and 1\.
    Multiplying it by doubling the input will give us a value between 0 and (amt *
    2), and subtracting the input value will give us the proper range.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`random.random()`函数将产生一个介于0和1之间的随机数。将其乘以输入值的两倍将给我们一个介于0和（amt * 2）之间的值，减去输入值将给我们正确的范围。'
- en: 'Now we''ll actually move the vertices by first selecting the individual vertex
    and moving it using the `move` command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将首先通过选择单个顶点并使用`move`命令移动它来移动顶点：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Note that Maya does also offer a `polyMoveVertex` command, which might seem
    like a better way to go about tweaking the position of each vertex. While that
    will absolutely work, it will run much slower due to the additional overhead of
    creating another **database availability group** (**DAG**) node for each moved
    vertex. If you would like to see for yourself, try commenting out the lines that
    select and move the vertices and adding the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Maya还提供了一个`polyMoveVertex`命令，这可能看起来是调整每个顶点位置的一个更好的方法。虽然这绝对有效，但由于为每个移动的顶点创建另一个**数据库可用性组**（**DAG**）节点所带来的额外开销，它将运行得慢得多。如果您想亲自看看，尝试注释掉选择和移动顶点的行，并添加以下内容：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Try running this and see how long it takes, then comment out this, re-enable
    the select and move lines and rerun the script. You'll likely see that the `polyMoveVertex`
    version takes a significantly longer time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行这个，看看它需要多长时间，然后注释掉这一行，重新启用选择和移动行并重新运行脚本。您可能会看到`polyMoveVertex`版本需要更长的时间。
- en: 'Once we''ve run through all of the vertices and moved each one slightly, we''ll
    want to make sure that we finish up by selecting the original object, thereby
    setting the user up to take further actions on the object. Take a look at the
    following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们遍历了所有的顶点并将每个顶点稍微移动了一下，我们希望确保通过选择原始对象来完成，从而使用户能够对对象执行进一步的操作。看看以下代码：
- en: '[PRE48]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: There's more...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'This example would only work on polygonal objects, but it would be easy to
    extend it to work with NURBS surface or even curves as well. To do this, we would
    need to do the following two things:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只会对多边形对象有效，但很容易扩展到与NURBS曲面甚至曲线一起工作。为此，我们需要做以下两件事：
- en: Test for the type of geometry (`nurbsSurface` or `nurbsCurve`)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试几何类型（`nurbsSurface`或`nurbsCurve`）
- en: Alter the point selection code to reference the appropriate type of point
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改点选择代码以引用适当的点类型
- en: One further complication is that CVs of a NURBS surface have to be accessed
    in a two-dimensional array, rather than the flat array of the polygonal surfaces
    `vtx` list.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更复杂的因素是，NURBS曲面的CVs必须以二维数组的形式访问，而不是多边形表面的`vtx`列表的平面数组。
- en: Creating novel primitives (tetrahedron)
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的原语（四面体）
- en: In this example, we'll be creating a brand new (to Maya) geometric primitive—a
    tetrahedron. Tetrahedrons are simple in principle, but would require numerous
    steps to create using Maya's interface. As such, they make a great candidate for
    scripting.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将创建一个全新的（对Maya而言）几何原语——四面体。四面体在原理上很简单，但使用Maya的界面创建它们需要许多步骤。因此，它们非常适合脚本编写。
- en: We'll be creating a script that will create a tetrahedron of a given edge width
    as a polygonal mesh.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个脚本，该脚本将创建一个具有给定边宽的四面体作为多边形网格。
- en: Getting ready
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we start writing code, we'll want to make sure that we have a good grasp
    on the math behind tetrahedrons. A tetrahedron is the simplest regular polyhedron
    that consists of four faces, each of which is an equilateral triangle.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写代码之前，我们想要确保我们对四面体的数学原理有很好的理解。四面体是最简单的正多面体，由四个面组成，每个面都是一个等边三角形。
- en: 'Each tetrahedron consists of only four points. For convenience, we''ll name
    the three around the base **A**, **B**, and **C**, and the point at the tip **D**,
    as in the following illustration:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 每个四面体仅由四个点组成。为了方便，我们将底部的三个点命名为**A**、**B**和**C**，而顶部的点命名为**D**，如下面的插图所示：
- en: '![Getting ready](img/4657_03_03.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4657_03_03.jpg)'
- en: To make the math easier, we'll set point **A** to the origin ([0,0,0]). Because
    every side of the base is of the same length, we can find point **B** by simply
    moving along the *x* axis by the desired edge length, giving us [length, 0, 0]
    for **B**.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使数学更容易，我们将点**A**设置为原点([0,0,0])。因为底面的每一边长度都相同，我们可以通过沿着*x*轴移动所需的边长来找到点**B**，给**B**的坐标为[长度,
    0, 0]。
- en: 'Point **C** is only slightly more involved. First, we note that every equilateral
    triangle can be split into two similar right triangles as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 点**C**的处理稍微复杂一些。首先，我们注意到每个等边三角形都可以分成两个相似的直角三角形，如下所示：
- en: Finding the *X* coordinate of point **C** is easy; all we have to do is halve
    the edge length. The *Z* coordinate is in turn equal to the height of each of
    the half triangles in the previously mentioned illustration, which we don't yet
    know. However, we *do* know the length of the other two sides, that is, the shorter
    side is half of our edge length, and the hypotenuse is just the full edge length
    itself.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 找到点**C**的*X*坐标很容易；我们只需要将边长除以二。而*Z*坐标则等于前面提到的插图中所提到的每个半三角形的长度，但我们还不知道。然而，我们知道其他两边的长度，即较短的一边是边长的一半，而斜边则是完整的边长本身。
- en: 'Therefore, by the Pythagorean theorem, we know that:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据勾股定理，我们知道：
- en: '![Getting ready](img/4657_03_07.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4657_03_07.jpg)'
- en: 'Or, rewriting it a bit, we have the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，稍作改写，我们有以下公式：
- en: '![Getting ready](img/4657_03_08.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4657_03_08.jpg)'
- en: Finally, we'll need the coordinates of the tip of the tetrahedron. We'll get
    those in a way similar to how we arrived at the coordinates for **C**, in that
    we'll use another right triangle, but this one will be slightly different; it
    will be the triangle formed by point **A**, point **D**, and the point in the
    center of the base (which we'll call point **E**).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要四面体顶点的坐标。我们将以类似于我们找到**C**坐标的方式获得这些坐标，即我们将使用另一个直角三角形，但这个三角形将略有不同；它将是点**A**、点**D**和底面中心点（我们将称之为点**E**）形成的三角形。
- en: '![Getting ready](img/4657_03_04.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4657_03_04.jpg)'
- en: First, let's find point **E**. Because it's the center of the base, we can just
    average the *X* and *Z* coordinates of **A**, **B**, and **C**, and we'll have
    **E**'s location. Then, we can construct a triangle that will allow us to determine
    the vertical position of point **D**.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们找到点**E**。因为它位于底部的中心，我们可以简单地平均**A**、**B**和**C**的*X*和*Z*坐标，从而得到**E**的位置。然后，我们可以构造一个三角形，这将帮助我们确定点**D**的垂直位置。
- en: '![Getting ready](img/4657_03_05.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/4657_03_05.jpg)'
- en: Point **D** will have the same *X* and *Z* coordinates as **E**, but needs to
    be raised by the proper amount along the *y* axis to create a proper tetrahedron.
    To find that distance, we'll use the triangle formed by **A**, **E**, and **D**.
    The hypotenuse is, once again, a full side of the tetrahedron, so that's easy.
    The shorter base (**A**-**E**) is the distance from **A** to the center of the
    base. To find that, we can use the distance formula, making the calculation simpler
    by choosing point **A** as the origin.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 点**D**将具有与**E**相同的**X**和**Z**坐标，但需要在**y**轴上提升适当的量以创建一个合适的四面体。为了找到这个距离，我们将使用由**A**、**E**和**D**形成的三角形。斜边，再次强调，是四面体的一个完整边，所以这很简单。较短的底边（**A**-**E**）是**A**到底部中心的距离。为了找到这个距离，我们可以使用距离公式，通过选择点**A**作为原点来简化计算。
- en: '![Getting ready](img/4657_03_09.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/4657_03_09.jpg)'
- en: 'Because both the *X* and *Z* coordinates of point **A** are zero, we get the
    following:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 因为点**A**的**X**和**Z**坐标都是零，所以我们得到以下结果：
- en: '![Getting ready](img/4657_03_10.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/4657_03_10.jpg)'
- en: 'Once we''ve done that, we know the lengths of two of the sides of the triangle,
    and we can calculate the third by using the Pythagorean theorem once again, as
    follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个操作，我们就知道三角形的两边长度，我们可以通过再次使用勾股定理来计算第三边，如下所示：
- en: '![Getting ready](img/4657_03_11.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/4657_03_11.jpg)'
- en: Now that we have a good handle on how to create a tetrahedron, we're ready to
    actually write the script.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地掌握了如何创建四面体，我们准备实际编写脚本。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new script and name it `makeTetrahedron.py`. Add the following code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的脚本，并将其命名为`makeTetrahedron.py`。添加以下代码：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Run this code, and you should end up with a tetrahedron with a side length of
    5 units, with the base centered at the origin.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，你应该得到一个边长为5个单位的四面体，底部中心位于原点。
- en: '![How to do it...](img/4657_03_06.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/4657_03_06.jpg)'
- en: How it works...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First off, we calculate all the points that we'll need, as outlined in the preceding
    *Getting ready* section. Each point is a three-element array of *X*, *Y*, and
    *Z* coordinates.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算所有需要的点，如前述“准备中”部分所述。每个点是一个包含**X**、**Y**和**Z**坐标的三元素数组。
- en: 'The first two points are easy:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个点很容易：
- en: '[PRE50]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '`pointC` is a bit more complex and requires us to use the Pythagorean theorem:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`pointC`稍微复杂一些，需要我们使用勾股定理：'
- en: '[PRE51]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In order to calculate the position for `pointD`, we first determine the center
    of the base, which we''ll call `pointE`. Use the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算`pointD`的位置，我们首先确定底部的中心，我们将称之为`pointE`。使用以下代码：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we can determine `pointD` by setting the *X* and *Z* coordinates to
    those of `pointE` and using the Pythagorean theorem to determine the *Y* coordinate
    as follows:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过将**X**和**Z**坐标设置为`pointE`的坐标，并使用勾股定理来确定**Y**坐标来确定`pointD`，如下所示：
- en: '[PRE53]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Once we''ve done that, we can create individual faces with the `polyCreateFacet`
    command. We''ll use the `polyCreateFacet` command four times, once for each of
    the tetrahedron''s faces. We''ll also store the result into an array so that we
    can select all of the faces for final processing later. We have the following
    code:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个操作，我们就可以使用`polyCreateFacet`命令创建单个面。我们将使用`polyCreateFacet`命令四次，每次用于四面体的一个面。我们还将结果存储到一个数组中，这样我们可以在稍后进行最终处理时选择所有面。我们有以下代码：
- en: '[PRE54]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At this point, we have all of our geometry created, but we''ll want to do a
    few things to finish off the object, namely:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经创建了所有的几何形状，但我们还想做一些事情来完成对象，即：
- en: Combine all the faces into a single object.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有面组合成一个单一的对象。
- en: Move the object so that the base is centered at the origin.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将对象移动，使底部中心位于原点。
- en: Set the object's pivot point so that it is also centered at the base.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置对象的轴心点，使其也位于底部中心。
- en: Freeze the transformations.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 冻结变换。
- en: 'First off, let''s combine the faces into a single object by selecting them.
    We start by replacing the current selection by the first face, then adding each
    of the additional three faces to the selection by using `add=True` in our call
    to `cmds.select()`.We have the following code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过选择面将面组合成一个单一的对象。我们首先通过将当前选择替换为第一个面开始，然后通过在`cmds.select()`调用中使用`add=True`将额外的三个面添加到选择中。我们有以下代码：
- en: '[PRE55]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Once we have all the faces selected, we can combine them with `polyUnite`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了所有的面，我们就可以使用`polyUnite`将它们组合起来：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: It will cause all of the faces to be combined into a single polygonal object,
    but it's only the start. If we leave things at that, we'll end up with disconnected
    faces and multiple vertices at each of the tetrahedron's four points. To finish
    off, we'll want to make sure that vertices that are on top of each other are merged.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 它将导致所有面合并成一个单一的多边形对象，但这只是开始。如果我们就这样结束，我们最终会得到不相连的面和在每个四面体的四个点上的多个顶点。为了完成它，我们想要确保重叠的顶点被合并。
- en: 'To do this, we''ll start by selecting all of the vertices in our model:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先选择我们模型中的所有顶点：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that we use the `vtx` list to select vertices, but we leave out both the
    start and end indices, having just a colon. That's an easy shorthand way to refer
    to the entire contents of a list and will cause all of the vertices in our model
    to be selected. Once we've done it, we tell Maya to merge nearby vertices with
    the `polyMergeVertex` command, passing in a small threshold distance.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `vtx` 列表来选择顶点，但我们省略了起始和结束索引，只使用一个冒号。这是一个简单的简写方式来引用列表的全部内容，并将导致选择我们模型中的所有顶点。一旦我们完成，我们告诉
    Maya 使用 `polyMergeVertex` 命令合并附近的顶点，传递一个小阈值距离。
- en: '[PRE58]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This tells Maya that any vertices that are less than 0.0001 units apart should
    be merged into a single vertex. At this point, we have a proper tetrahedron with
    four faces and four vertices. Because the rest of the operations we want to perform
    deal with the object as a whole (rather than its vertices), we switch back to
    the object mode by reselecting the object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Maya，任何小于 0.0001 单位距离的顶点都应该合并成一个单一的顶点。到目前为止，我们有一个有四个面和四个顶点的正确四面体。因为我们要执行的其余操作都是针对整个对象（而不是其顶点），所以我们通过重新选择对象来切换回对象模式。
- en: '[PRE59]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Now we have a single object, but we want to center it. Luckily, we still have
    `pointE`, which contains the *X* and *Z* coordinates of the base''s center, relative
    to the origin. So, we''ll start by moving the combined object in the negative
    direction on *X* and *Z* by the same amount:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个单一的对象，但我们想要将其居中。幸运的是，我们仍然有 `pointE`，它包含相对于原点的基座的 *X* 和 *Z* 坐标。因此，我们将首先以相同的量在
    *X* 和 *Z* 方向上移动组合对象：
- en: '[PRE60]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we have the object where we want it, but its pivot point is still located
    at what used to be the origin (`pointA`). To fix it, we''ll use the `xform` command
    to move the pivot point, as follows:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将对象放置到我们想要的位置，但它的重心点仍然位于原来的原点（`pointA`）。为了修复它，我们将使用 `xform` 命令来移动重心点，如下所示：
- en: '[PRE61]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `pivots` flag will move the object's pivot to the specified location. In
    this case, we're moving it by the same amount (but in the opposite direction)
    that we moved the object, resulting in the pivot remaining at the origin, even
    though the object itself has been moved.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`pivots` 标志将对象的重心移动到指定的位置。在这种情况下，我们以与移动对象相同的量（但方向相反）移动它，结果重心仍然保持在原点，尽管对象本身已经被移动。'
- en: Finally, we'll finish off by freezing the transformations so that our object
    starts off with 0,0,0 for its position, and we will delete the construction history.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过冻结变换来结束，这样我们的对象在位置上以 0,0,0 开始，并且我们将删除构造历史。
- en: '[PRE62]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Then, we're left with a fully-formed tetrahedron, centered at the origin and
    with a clean construction history and ready for further use.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就剩下了一个完全形成的四面体，以原点为中心，具有干净的构造历史，并准备好进一步使用。
- en: There's more...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A tetrahedron is a fairly simple object, but all of the principles we used to
    create it can easily be extended to more complex shapes with more inputs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 四面体是一个相当简单的对象，但我们用来创建它的所有原理都可以很容易地扩展到具有更多输入的更复杂形状。
