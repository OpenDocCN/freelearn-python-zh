- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Abstract Base Classes and Operator Overloading
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象基类和运算符重载
- en: We often need to make a distinction between concrete classes that have a complete
    set of attributes and methods, and an abstract class that is missing some details.
    This parallels the philosophical idea of abstraction as a way to summarize complexities.
    We might say that a sailboat and an airplane have a common, abstract relationship
    of being vehicles, but the details of how they move are distinct.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要在具有完整属性和方法集合的具体类和缺少一些细节的抽象类之间做出区分。这类似于抽象作为总结复杂性的哲学思想。我们可能会说，帆船和飞机有共同的、抽象的关系，即它们都是交通工具，但它们移动的细节是不同的。
- en: 'In Python, we have two approaches to defining similar things:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们有两种定义类似事物的途径：
- en: '**Duck typing**: When two class definitions have the same attributes and methods,
    then instances of the two classes have the same protocol and can be used interchangeably.
    We often say, "When I see a bird that walks like a duck and swims like a duck and
    quacks like a duck, I call that bird a duck."'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**鸭子类型**: 当两个类定义具有相同的属性和方法时，这两个类的实例具有相同的协议并且可以互换使用。我们常说，“当我看到一只既像鸭子走路又像鸭子游泳还像鸭子嘎嘎叫的鸟时，我就称那只鸟为鸭子。”'
- en: '**Inheritance**: When two class definitions have common aspects, a subclass
    can share common features of a superclass. The implementation details of the two
    classes may vary, but the classes should be interchangeable when we use the common
    features defined by the superclass.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**继承**：当两个类定义有共同特性时，子类可以共享超类的共同特性。这两个类的实现细节可能不同，但在使用由超类定义的共同特性时，这些类应该是可互换的。'
- en: 'We can take inheritance one step further. We can have superclass definitions
    that are abstract: this means they aren''t directly useable by themselves, but
    can be used through inheritance to create concrete classes.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将继承进一步深化。我们可以拥有抽象的父类定义：这意味着它们自身不能直接使用，但可以通过继承来创建具体的类。
- en: 'We have to acknowledge a terminology problem around the terms *base class*
    and *superclass*. This is confusing because they''re synonyms. There are two parallel
    metaphors here, and we flip back and forth between them. Sometimes, we''ll use
    the "base class is a foundation" metaphor, where another class builds on it via
    inheritance. Other times, we''ll use the "concrete class extends a superclass"
    metaphor. The "super" class is superior to the concrete class; it''s typically
    drawn above it on a UML class diagram, and it needs to be defined first. For example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认在术语“基类”和“超类”周围存在一个术语问题。这很令人困惑，因为它们是同义词。这里有两种平行的隐喻，我们在它们之间来回切换。有时，我们会使用“基类是基础”的隐喻，其中另一个类通过继承在其之上构建。其他时候，我们会使用“具体类扩展超类”的隐喻。超类优于具体类；它通常在UML类图中位于其上方，并且需要首先定义。例如：
- en: '![Diagram  Description automatically generated](img/B17070_06_01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_06_01.png)'
- en: 'Figure 6.1: Abstract base class'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：抽象基类
- en: Our base class, named `BaseClass` here, has a special class, `abc.ABC`, as a
    parent class. This provides some special metaclass features that help make sure
    the concrete classes have replaced the abstractions. In this diagram, we have
    added a big "A" circle to mark the class as abstract. This bit of decoration is
    optional, and often unhelpful, so we won't use it in other diagrams. The slanted
    font is another hint that the class is abstract.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基础类，在此命名为`BaseClass`，有一个特殊的类`abc.ABC`作为其父类。这提供了一些特殊的元类特性，有助于确保具体类已经替换了抽象。在这个图中，我们添加了一个大“A”圆圈来标记这个类为抽象类。这种装饰是可选的，并且通常并不有帮助，所以我们不会在其他图中使用它。斜体字体是另一个表明该类为抽象类的提示。
- en: The diagram shows an abstract method, `a_method()`, which doesn't have a defined
    body. A subclass must provide this. Again, a slanted font is used for the method
    name to provide a hint that it's abstract. The two concrete subclasses provide
    this missing method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图表展示了一个抽象方法 `a_method()`，它没有定义方法体。子类必须提供这个方法。同样，使用斜体字来表示方法名，以提供这是一个抽象方法的提示。两个具体子类提供了这个缺失的方法。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating an abstract base class
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个抽象基类
- en: ABCs and type hints
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABCs 和类型提示
- en: The `collections.abc` module
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collections.abc` 模块'
- en: Creating your own abstract base class
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的抽象基类
- en: Demystifying the magic – looking under the hood at the implementation of an
    ABC
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭秘魔法——探究ABC实现的内部机制
- en: Operator overloading
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符重载
- en: Extending built-ins
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展内置函数
- en: Metaclasses
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类
- en: The case study in this chapter will build on the case study material in previous
    chapters. We'll be able to look closely at different ways to partition data among
    training sets and testing sets.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的案例研究将基于前几章的案例研究材料。我们将能够仔细研究在不同训练集和测试集之间划分数据的不同方法。
- en: We'll start by looking at how we use an abstract class and create a concrete
    class from it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何使用抽象类并从中创建一个具体类。
- en: Creating an abstract base class
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个抽象基类
- en: Imagine we are creating a media player with third-party plugins. It is advisable
    to create an abstract base class (ABC) in this case to document what API the third-party
    plugins should provide (documentation is one of the stronger use cases for ABCs).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们正在创建一个带有第三方插件的媒体播放器。在这种情况下，创建一个抽象基类（ABC）是明智的，以便记录第三方插件应提供的API（文档是抽象基类（ABC）的强大用例之一）。
- en: The general design is to have a common feature, like `play()`, that applies
    to a number of classes. We don't want to pick some particular media format to
    use as a superclass; it seems somehow wrong to claim that some format is foundational,
    and all others are derived from it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通用设计是拥有一个共同特性，例如`play()`，这个特性适用于多个类。我们不希望选择某个特定的媒体格式作为超类；声称某种格式是基础性的，而所有其他格式都由此派生出来，这似乎有些不妥。
- en: We'd prefer to define the media player as an *abstraction*. Each unique kind
    of media file format can provide a *concrete* implementation of the abstraction.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更愿意将媒体播放器定义为一种*抽象*。每种独特的媒体文件格式都可以提供该抽象的*具体*实现。
- en: 'The `abc` module provides the tools to do this. Here''s an abstract class that
    requires a subclass to provide a concrete method and a concrete property to be
    useful:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc` 模块提供了完成此操作的工具。以下是一个抽象类，它要求子类提供一个具体方法和一个具体属性才能发挥作用：'
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `abc.ABC` class introduces a **metaclass** – a class used to build the concrete
    class definitions. Python's default metaclass is named `type`. The default metaclass
    doesn't check for abstract methods when we try to create an instance. The `abc.ABC`
    class includes an extension to the `type` metaclass to prevent us from creating
    instances of classes that are not fully defined.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc.ABC` 类引入了一个 **元类** —— 用于构建具体类定义的类。Python 的默认元类名为 `type`。默认元类在尝试创建实例时不会检查抽象方法。`abc.ABC`
    类扩展了 `type` 元类，以防止我们创建未完全定义的类的实例。'
- en: There are two decorators used to describe the placeholders in the abstraction.
    The example shows `@abc.abstractmethod` and a combination of `@property` and `@abc.abstractmethod`.
    Python uses decorators widely to make modifications to the general nature of the
    method or function. In this case, it provides additional details used by the metaclass
    that was included by the `ABC` class. Because we marked a method or property as
    abstract, any subclass of this class must implement that method or property in
    order to be a useful, concrete implementation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在抽象中描述占位符时使用了两个装饰器。示例展示了`@abc.abstractmethod`以及`@property`和`@abc.abstractmethod`的组合。Python广泛使用装饰器来修改方法或函数的一般性质。在这种情况下，它提供了由`ABC`类包含的元类使用的额外细节。因为我们标记了一个方法或属性为抽象的，所以这个类的任何子类都必须实现该方法或属性，才能成为一个有用且具体的实现。
- en: The bodies of the methods are actually `...` . This three-dot token, the ellipsis,
    really is valid Python syntax. It's not a placeholder used only in this book;
    it's the Python code to remind everyone a useful body needs to be written in order
    to create a working, concrete subclass.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法的主体实际上是 `...` 。这个省略号标记，实际上是一个有效的 Python 语法。它不仅仅是在这本书中用作占位符；它是 Python 代码，用来提醒大家，为了创建一个工作状态良好的具体子类，需要编写一个有用的主体。
- en: We've used the `@property` decorator on the `ext()` method, also. Our intent
    for the `ext` property is to provide a simple class-level variable with a string
    literal value. It's helpful to describe this as an `@property` to allow the implementation
    to choose between a simple variable and a method that implements the property.
    A simple variable in the concrete class will meet the expectations of the abstract
    class at runtime and will also help **mypy** to check the code for consistent
    use of types. A method could be used as an alternative to a simple attribute variable
    in case some more sophisticated computation is required.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也在`ext()`方法上使用了`@property`装饰器。对于`ext`属性，我们的意图是提供一个具有字符串字面值值的简单类级别变量。将其描述为`@property`有助于实现选择在简单变量和实现属性的方法之间进行选择。在具体类中的简单变量将在运行时满足抽象类的期望，并且也有助于**mypy**检查代码类型的一致使用。如果需要更复杂的计算，可以使用方法作为简单属性变量的替代。
- en: 'One of the consequences of marking these properties is the class now has a
    new special attribute, `__abstractmethods__`. This attribute lists all of the
    names that need to be filled in to create a concrete class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 标记这些属性的一个后果是，这个类现在有一个新的特殊属性，`__abstractmethods__`。这个属性列出了需要填写以创建具体类所需的所有名称：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'See what happens if you implement a subclass? We''ll look at an example that
    doesn''t supply concrete implementations for the abstractions. We''ll also look
    at an example that does supply the required attribute:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 看看如果你实现了一个子类会发生什么？我们将查看一个没有为抽象提供具体实现的示例。我们还将查看一个提供了所需属性的示例：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The definition of a `Wav` subclass fails to implement either of the abstract
    attributes. When we try to create an instance of the `Wav` class, an exception
    is raised. Because this subclass of `MediaLoader` is still abstract, it is not
    possible to instantiate the class. The class is still a potentially useful abstract
    class, but you'd have to subclass it and fill in the abstract placeholders before
    it can actually do anything.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`Wav`子类的定义未能实现任何一个抽象属性。当我们尝试创建`Wav`类的实例时，会引发异常。因为这个`MediaLoader`子类仍然是抽象的，所以无法实例化该类。这个类仍然是一个可能很有用的抽象类，但您必须将其子类化并填充抽象占位符，它才能实际执行任何操作。'
- en: The `Ogg` subclass supplies both attributes, so it – at the least – can instantiate
    cleanly. It's true, the body of the `play()` method doesn't do very much. What's
    important is that all of the placeholders were filled, making `Ogg` a concrete
    subclass of the abstract `MediaLoader` class.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ogg` 子类提供了这两个属性，因此它至少可以干净地实例化。确实，`play()` 方法的主体并没有做很多。重要的是所有的占位符都被填充了，这使得
    `Ogg` 成为抽象 `MediaLoader` 类的一个具体子类。'
- en: There's a subtle issue with using a class-level variable for the preferred media
    file extension. Because the `ext` attribute is a variable, it can be updated.
    Using `o.ext = '.xyz'` is not expressly prohibited. Python doesn't have an easy,
    obvious way to create read-only attributes. We often rely on documentation to
    explain the consequences of changing the value of the `ext` attribute.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类级别的变量作为首选媒体文件扩展名存在一个微妙的问题。因为`ext`属性是一个变量，它可以被更新。使用`o.ext = '.xyz'`并没有被明确禁止。Python没有简单直观的方式来创建只读属性。我们通常依赖文档来解释更改`ext`属性值所带来的后果。
- en: This has clear advantages when creating a complex application. The use of abstraction
    like this makes it very easy for **mypy** to conclude that a class does (or does
    not) have the required methods and attributes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这在创建复杂应用程序时具有明显优势。使用这种抽象使得**mypy**能够很容易地得出一个类是否具有所需的方法和属性的结论。
- en: This also mandates a certain amount of fussy importing to be sure that the module
    has access to the necessary abstract base classes for an application. One of the
    advantages of duck typing is the ability to avoid complex imports and still create
    a useful class that can act polymorphically with peer classes. This advantage
    is often outweighed by the ability of the `abc.ABC` class definition to support
    type checking via **mypy**, and to also do a runtime check for completeness of
    a subclass definition. The `abc.ABC` class also provides far more useful error
    messages when something is wrong.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这也要求进行一定程度的繁琐导入，以确保模块能够访问应用程序所需的必要抽象基类。鸭子类型的一个优点是能够避免复杂的导入，同时仍然创建一个可以与同类类多态交互的有用类。这种优点往往被`abc.ABC`类定义支持通过**mypy**进行类型检查的能力所超越，并且还可以对子类定义的完整性进行运行时检查。当出现问题时，`abc.ABC`类还能提供更多有用的错误信息。
- en: One important use case for ABCs is the `collections` module. This module defines
    the built-in generic collections using a sophisticated set of base classes and
    mixins.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ABCs的一个重要用例是`collections`模块。该模块使用一组复杂的基类和混入定义了内置的泛型集合。
- en: The ABCs of collections
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的ABC
- en: A really comprehensive use of the abstract base classes in the Python standard
    library lives in the `collections` module. The collections we use are extensions
    of the `Collection` abstract class. `Collection` is an extension of an even more
    fundamental abstraction, `Container`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 标准库中，对抽象基类的真正综合运用体现在 `collections` 模块中。我们使用的集合是 `Collection` 抽象类的扩展。`Collection`
    是一个更基础抽象 `Container` 的扩展。
- en: 'Since the foundation is the `Container` class, let''s inspect it in the Python
    interpreter to see what methods this class requires:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基础是`Container`类，让我们在Python解释器中检查它，看看这个类需要哪些方法：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, the `Container` class has exactly one abstract method that needs to be
    implemented, `__contains__()`. You can issue `help(Container.__contains__)` to
    see what the function signature should look like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Container` 类恰好有一个需要实现的方法，即 `__contains__()`。您可以通过执行 `help(Container.__contains__)`
    来查看函数签名应该是什么样的：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can see that `__contains__()` needs to take a single argument. Unfortunately,
    the help file doesn't tell us much about what that argument should be, but it's
    pretty obvious from the name of the ABC and the single method it implements that
    this argument is the value the user is checking to see whether the container holds.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`__contains__()`方法需要接受一个单一参数。不幸的是，帮助文件并没有告诉我们这个参数应该是什么，但从ABC的名称以及它实现的单一方法来看，这个参数就是用户用来检查容器是否包含该值的值。
- en: 'This `__contains__()` special method implements the Python `in` operator. This
    method is implemented by `set`, `list`, `str`, `tuple`, and `dict`. However, we
    can also define a silly container that tells us whether a given value is in the
    set of odd integers:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `__contains__()` 特殊方法实现了 Python 的 `in` 操作符。该方法由 `set`、`list`、`str`、`tuple`
    和 `dict` 实现。然而，我们也可以定义一个愚蠢的容器，它告诉我们给定的值是否在奇数集合中：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We've used the modulo test for oddity. If the remainder of `x` divided by two
    is zero, then `x` was even, otherwise `x` was odd.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了模数测试来判断奇偶性。如果`x`除以二的余数为零，那么`x`就是偶数，否则`x`就是奇数。
- en: 'Here''s the interesting part: we can instantiate an `OddContainer` object and
    determine that, even though we did not extend `Container`, the class behaves as
    a `Container` object:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个有趣的部分：我们可以实例化一个`OddContainer`对象，并确定即使我们没有扩展`Container`类，该类仍然表现得像一个`Container`对象：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: And that is why duck typing is way more awesome than classical polymorphism.
    We can create is-a relationships without the overhead of writing the code to set
    up inheritance (or worse, multiple inheritance).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，鸭子类型（duck typing）远比经典的多态性（polymorphism）更出色。我们可以在不编写设置继承（或者更糟糕的是多重继承）代码的开销下创建“是...类型”的关系。
- en: 'One cool thing about the `Container` ABC is that any class that implements
    it gets to use the `in` keyword for free. In fact, `in` is just syntax sugar that
    delegates to the `__contains__()` method. Any class that has a `__contains__()` method
    is a `Container` and can therefore be queried by the `in` keyword. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Container` ABC的一个酷特点是，任何实现了它的类都可以免费使用`in`关键字。实际上，`in`只是一个语法糖，它委托给`__contains__()`方法。任何具有`__contains__()`方法的类都是`Container`，因此可以通过`in`关键字进行查询。例如：'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The real value here is the ability to create new kinds of collections that are
    completely compatible with Python's built-in generic collections. We could, for
    example, create a dictionary that uses a binary tree structure to retain keys
    instead of a hashed lookup. We'd start with the `Mapping` abstract base class
    definitions, but change the algorithms that support methods like `__getitem__()`,
    `__setitem__()`, and `__delitem__()`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里真正的价值在于能够创建与Python内置泛型集合完全兼容的新类型集合。例如，我们可以创建一个使用二叉树结构来保留键而不是哈希查找的字典。我们将从`Mapping`抽象基类定义开始，但会更改支持`__getitem__()`、`__setitem__()`和`__delitem__()`等方法的算法。
- en: 'Python''s duck typing works (in part) via the `isinstance()` and `issubclass()`
    built-in functions. These functions are used to determine class relationships.
    They rely on two internal methods that classes can provide: `__instancecheck__()`
    and `__subclasscheck__()`. An ABC class can provide a `__subclasshook__()` method,
    which is used by the `__subclasscheck__()` method to assert that a given class
    is a proper subclass of the abstract base class. The details are a bit beyond
    this book; consider this a signpost pointing out the path that needs to be followed
    when creating novel classes that need to live side by side with built-in classes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python的鸭子类型（duck typing）通过内置函数`isinstance()`和`issubclass()`（部分）工作。这些函数用于确定类之间的关系。它们依赖于类可以提供的两个内部方法：`__instancecheck__()`和`__subclasscheck__()`。一个抽象基类（ABC）可以提供一个`__subclasshook__()`方法，该方法被`__subclasscheck__()`方法用来断言给定的类是抽象基类的适当子类。这些细节超出了本书的范围；这可以被视为一个路标，指出在创建需要与内置类并存的创新类时需要遵循的路径。
- en: Abstract base classes and type hints
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象基类和类型提示
- en: The concept of an abstract base class is closely tied to the idea of a generic
    class. An abstract base class is often generic with respect to some detail that
    is supplied by a concrete implementation.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类的概念与泛型类的思想紧密相连。抽象基类通常在某个由具体实现提供的细节上是泛型的。
- en: Most of Python's generic classes – classes like `list`, `dict`, and `set` –
    can be used as type hints, and these hints can be parameterized to narrow the
    domain. There's a world of difference between `list[Any]` and `list[int]`; the
    value `["a", 42, 3.14]` is valid for the first type hint, but invalid for the
    other. This concept of *parameterizing* the generic type to make it more specific
    often applies to abstract classes, also.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数Python的通用类——例如`list`、`dict`和`set`——可以用作类型提示，并且这些提示可以进行参数化以缩小范围。`list[Any]`和`list[int]`之间有着天壤之别；值`["a",
    42, 3.14]`对于第一种类型提示是有效的，但对于另一种则无效。这种将通用类型参数化以使其更具体的概念，通常也适用于抽象类。
- en: For this to work, you'll often need to incorporate `from __future__ import annotations`
    as the very first line of code. This modifies the behavior of Python to permit
    function and variable annotations to parameterize these standard collections.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，你通常需要将 `from __future__ import annotations` 作为代码的第一行。这修改了Python的行为，允许函数和变量注释来参数化这些标准集合。
- en: 'Generic classes and abstract base classes are not the same thing. The two concepts
    overlap, but are distinct:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通用类和抽象基类不是同一回事。这两个概念有重叠，但又是不同的：
- en: Generic classes have an implicit relationship with `Any`. This often needs to
    be narrowed using type parameters, like `list[int]`. The list class is concrete,
    and when we want to extend it, we'll need to plug in a class name to replace the
    `Any` type. The Python interpreter does not use generic class hints in any way;
    they are only checked by static analysis tools such as **mypy**.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用类与`Any`具有隐式关系。这通常需要使用类型参数来缩小范围，例如`list[int]`。列表类是具体的，当我们想要扩展它时，我们需要插入一个类名来替换`Any`类型。Python解释器根本不使用通用类提示；它们只由静态分析工具如**mypy**进行检查。
- en: Abstract classes have placeholders instead of one or more methods. These placeholder
    methods require a design decision that supplies a concrete implementation. These
    classes are not completely defined. When we extend it, we'll need to provide a
    concrete method implementation. This is checked by **mypy**. That's not all. If
    we don't provide the missing methods, the interpreter will raise a runtime exception
    when we try to create an instance of an abstract class.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类使用占位符代替一个或多个方法。这些占位符方法需要做出一个设计决策，以提供具体的实现。这些类并不是完全定义好的。当我们扩展它们时，我们需要提供具体的方法实现。这由**mypy**进行检查。但这还不是全部。如果我们没有提供缺失的方法，当尝试创建一个抽象类的实例时，解释器将引发运行时异常。
- en: Some classes can be both abstract and generic. As noted above, the type parameter
    helps **mypy** understand our intention, but isn't required. The concrete implementation
    is required.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些类可以是抽象的和泛型的。如上所述，类型参数帮助**mypy**理解我们的意图，但不是必需的。需要具体的实现。
- en: 'Another concept that''s adjacent to abstract classes is the **protocol**. This
    is the essence of how duck typing works: when two classes have the same batch
    of methods, they both adhere to a common protocol. Any time we see classes with
    similar methods, there''s a common protocol; this may be formalized with a type
    hint.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与抽象类相邻的另一个概念是**协议**。这是鸭子类型工作原理的精髓：当两个类拥有相同的批方法时，它们都遵循一个共同的协议。每次我们看到具有相似方法的类时，都有一个共同的协议；这可以通过类型提示来形式化。
- en: 'Consider objects that can be hashed. Immutable classes implement the `__hash__()`
    method, including strings, integers, and tuples. Generally, mutable classes don''t
    implement the `__hash__()` method; this includes classes like `list`, `dict`,
    and `set`. This one method is the `Hashable` protocol. If we attempt to write
    a type hint like `dict[list[int], list[str]]`, then **mypy** will object that
    `list[int]` can''t be used as a key. It can''t be a key because the given type,
    `list[int]`, doesn''t implement the `Hashable` protocol. At runtime, the attempt
    to create a dictionary item with a mutable key will fail for the same reason:
    a list doesn''t implement the required method.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑可哈希的对象。不可变类实现了 `__hash__()` 方法，包括字符串、整数和元组。通常，可变类不实现 `__hash__()` 方法；这包括 `list`、`dict`
    和 `set` 等类。这个方法就是 `Hashable` 协议。如果我们尝试编写像 `dict[list[int], list[str]]` 这样的类型提示，那么
    **mypy** 将会反对 `list[int]` 不能用作键。它不能用作键，因为给定的类型 `list[int]` 没有实现 `Hashable` 协议。在运行时，尝试使用可变键创建字典项也会因为同样的原因失败：列表没有实现所需的方法。
- en: The essence of creating ABCs is defined in the `abc` module. We'll look at how
    this works later. For now, we want to make use of abstract classes, and that means
    using the definitions in the `collections` module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ABCs的本质定义在`abc`模块中。我们稍后会探讨它是如何工作的。目前，我们想要使用抽象类，这意味着要使用`collections`模块中的定义。
- en: The collections.abc module
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The collections.abc module
- en: One prominent use of abstract base classes is in the `collections.abc` module.
    This module provides the abstract base class definitions for Python's built-in
    collections. This is how `list`, `set`, and `dict` (and a few others) can be built
    from individual component definitions.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类的一个显著用途是在`collections.abc`模块中。此模块提供了Python内置集合的抽象基类定义。这就是如何从单个组件定义中构建`list`、`set`和`dict`（以及其他一些）的原因。
- en: We can use the definitions to build our own unique data structures in ways that
    overlap with built-in structures. We can also use the definitions when we want
    to write a type hint for a specific feature of a data structure, without being
    overly specific about alternative implementations that might also be acceptable.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用定义来构建我们自己的独特数据结构，这些结构的方式与内置结构重叠。我们还可以在想要为数据结构的一个特定特性编写类型提示时使用这些定义，而不必过于具体地说明可能也接受的替代实现。
- en: The definitions in `collections.abc` don't – trivially – include `list`, `set`,
    or `dict`. Instead, the module provides definitions like `MutableSequence`, `MutableMapping`,
    and `MutableSet`, which are – in effect – abstract base classes for which the
    `list`, `dict`, or `set` classes we use are the concrete implementations. Let's
    follow the various aspects of the definition of `Mapping` back to their origins.
    Python's `dict` class is a concrete implementation of `MutableMapping`. The abstraction
    comes from the idea of mapping a key to a value. The `MutableMapping` class depends
    on the `Mapping` definition, an immutable, frozen dictionary, potentially optimized
    for lookups. Let's follow the relationships among these abstractions.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc` 中的定义并不——简单地——包括 `list`、`set` 或 `dict`。相反，该模块提供了诸如 `MutableSequence`、`MutableMapping`
    和 `MutableSet` 这样的定义，这些定义——实际上——是抽象基类，而我们使用的 `list`、`dict` 或 `set` 类则是这些基类的具体实现。让我们回顾
    `Mapping` 定义的各个方面及其起源。Python 的 `dict` 类是 `MutableMapping` 的具体实现。这种抽象来源于将键映射到值的思想。`MutableMapping`
    类依赖于 `Mapping` 定义，一个不可变、冻结的字典，可能针对查找进行了优化。让我们追踪这些抽象之间的关系。'
- en: 'Here''s the path we want to follow:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们要遵循的路径：
- en: '![Diagram  Description automatically generated](img/B17070_06_02.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_06_02.png)'
- en: 'Figure 6.2: The Mapping abstractions'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：映射抽象
- en: 'Starting in the middle, we can see the `Mapping` definition depends on the
    `Collection` class definition. The definition of the `Collection` abstract class,
    in turn, depends on three other abstract base classes: `Sized`, `Iterable`, and
    `Container`. Each of these abstractions demands specific methods.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从中间开始，我们可以看到`Mapping`定义依赖于`Collection`类定义。反过来，`Collection`抽象类的定义又依赖于三个其他的抽象基类：`Sized`、`Iterable`和`Container`。每个这些抽象都要求特定的方法。
- en: 'If we''re going to create a lookup-only dictionary – a concrete `Mapping` implementation
    – we''ll need to implement at least the following methods:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要创建一个只读的字典——一个具体的`Mapping`实现——我们需要实现至少以下方法：
- en: The `Sized` abstraction requires an implementation for the `__len__()` method.
    This lets an instance of our class respond to the `len()` function with a useful
    answer.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sized` 抽象需要为 `__len__()` 方法提供一个实现。这使得我们的类实例能够对 `len()` 函数提供一个有用的回答。'
- en: The `Iterable` abstraction requires an implementation for the `__iter__()` method.
    This lets an object work with the `for` statement and the `iter()` function. In
    *Chapter 10*, *The Iterator Pattern*, we'll revisit this topic.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable` 抽象需要实现 `__iter__()` 方法。这使得一个对象能够与 `for` 语句和 `iter()` 函数一起工作。在 *第
    10 章*，*迭代器模式*，我们将重新探讨这个主题。'
- en: The `Container` abstraction requires an implementation for the `__contains__()`
    method. This permits the `in` and `not in` operators to work.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`容器`抽象需要实现`__contains__()`方法。这允许`in`和`not in`运算符正常工作。'
- en: The `Collection` abstraction combines `Sized`, `Iterable`, and `Container` without
    introducing additional abstract methods.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection` 抽象将 `Sized`、`Iterable` 和 `Container` 结合在一起，而不引入额外的抽象方法。'
- en: The `Mapping` abstraction, based on `Collection`, requires, among other things,
    `__getitem__()`, `__iter__()`, and `__len__()`. It has a default definition for
    `__contains__()`, based on whatever `__iter__()` method we provide. The `Mapping`
    definition will provide a few other methods, also.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于`Collection`的`Mapping`抽象，需要`__getitem__()`、`__iter__()`和`__len__()`等方法，其中之一。它为`__contains__()`提供了一个默认定义，基于我们提供的`__iter__()`方法。`Mapping`定义还将提供一些其他方法。
- en: This list of methods comes directly from the abstract relationships in the base
    classes. By building our new dictionary-like immutable class from these abstractions,
    we can be sure that our class will collaborate seamlessly with other Python generic
    classes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法列表直接来源于基类中的抽象关系。通过从这些抽象中构建我们的新字典式不可变类，我们可以确保我们的类将与其他Python泛型类无缝协作。
- en: When we look at the documentation in [https://docs.python.org/3.9/library/collections.abc.html](https://docs.python.org/3.9/library/collections.abc.html),
    we see the page is dominated by a table showing abstract class definitions and
    the definitions they depend on. There's a lattice of dependencies showing overlap
    among the class definitions. It's this overlap that allows us to use a `for` statement
    to iterate through every kind of collection that implements the `Iterable` abstract
    base class.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看[https://docs.python.org/3.9/library/collections.abc.html](https://docs.python.org/3.9/library/collections.abc.html)中的文档时，我们看到页面主要由一个表格展示抽象类定义及其依赖的定义所主导。这里有一个依赖关系的网格，显示了类定义之间的重叠。正是这种重叠使得我们可以使用`for`语句遍历实现`Iterable`抽象基类的每一种集合。
- en: Let's define our own immutable `Mapping` object implementation by extending
    the abstract classes. The goal is to be able to load our dictionary-like mapping
    once with keys and values, and then use it to map the keys to their values. Since
    we aren't going to allow any updates, we can apply a variety of algorithms to
    make it very fast as well as very compact.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过扩展抽象类来定义我们自己的不可变`Mapping`对象实现。目标是能够一次性加载我们的类似字典的映射，并使用它将键映射到它们的值。由于我们不会允许任何更新，我们可以应用各种算法使其既非常快速又非常紧凑。
- en: 'The goal is a class with a type hint like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是拥有如下类型的类：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We're going to create a dictionary-like mapping from some key to – well – an
    object of any possible type. We've defined the key with the type `Comparable`
    because we want to be able to compare the keys and sort them into order. Searching
    through a list in order is often more efficient than searching a list that's not
    in order.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个类似于字典的映射，从一些键映射到——好吧——任何可能的类型对象。我们使用类型`Comparable`定义了键，因为我们希望能够比较键并将它们排序。在有序列表中进行搜索通常比在无序列表中进行搜索更有效。
- en: We'll look at the core of a `Lookup` class definition first. We'll return to
    the `Comparable` class definition after solidifying the essentials of a new kind
    of mapping from keys to values.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看`Lookup`类定义的核心。在巩固了从键到值的新类型映射的基本要素之后，我们将回到`Comparable`类定义。
- en: 'When we look at ways we can construct a dictionary, we see that a dictionary
    can be built from two different kinds of data structures. Our new mapping has
    to have this same flexibility. The two structures are exemplified by the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑构建字典的方法时，我们会发现字典可以由两种不同的数据结构构建而成。我们新的映射必须具备这种相同的灵活性。以下两个结构是例证：
- en: '[PRE9]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can build a mapping from an existing mapping, or we can build a mapping
    from a sequence of two-tuples with keys and values. This means there are two separate
    definitions for `__init__()`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从现有的映射中构建一个映射，或者我们可以从包含键和值的二元组序列中构建一个映射。这意味着`__init__()`有两个独立的定义：
- en: '`def __init__(self, source: BaseMapping) -> None`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def __init__(self, source: BaseMapping) -> None`'
- en: '`def __init__(self, source: Iterable[tuple[Comparable, Any]]) -> None`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`def __init__(self, source: 可迭代的[tuple[可比较, 任意]]) -> None`'
- en: These two definitions have distinct type hints. To make it clear to **mypy**,
    we need to provide **overloaded** method definitions. This is done with a special
    decoration from the `typing` module, `@overload`. We'll provide two method definitions
    with the two alternatives; after these, we'll provide the real method definition
    that does the useful work. Because these are type hints, they're not *required*.
    They're wordy, and they help us be sure we've got a sensible implementation.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义具有不同的类型提示。为了使 **mypy** 清楚，我们需要提供 **重载** 的方法定义。这通过 `typing` 模块中的一个特殊装饰器
    `@overload` 来实现。我们将提供两个带有两种替代方案的方法定义；在这些定义之后，我们将提供实际执行有用工作的方法定义。因为这些是类型提示，所以它们不是必需的。它们可能有些冗长，但有助于我们确保有一个合理的实现。
- en: 'Here''s the first part of the `Lookup` class definition. We''ll break this
    into pieces because the `__init__()` method needs to cover these two cases defined
    by the alternative overloads:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Lookup`类定义的第一部分。我们将将其拆分成几个部分，因为`__init__()`方法需要涵盖由替代重载定义的这两个情况：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `__init__()` method needs to handle three cases for loading a mapping. This
    means building the values from a sequence of pairs, or building the values from
    another mapping object, or creating an empty sequence of values. We need to separate
    the keys from the values and put them into two parallel lists. A sorted list of
    keys can be rapidly searched to find a match. The sorted list of values is returned
    when we get a key's value from the mapping.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法需要处理三种情况以加载映射。这意味着从一系列的键值对中构建值，或者从另一个映射对象中构建值，或者创建一个空的值序列。我们需要将键和值分开并将它们放入两个并行列表中。一个排序后的键列表可以快速搜索以找到匹配项。当我们从映射中获取键的值时，返回排序后的值列表。'
- en: 'Here are the imports needed:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是需要导入的依赖：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are the other abstract methods that are defined by the `@abstractmethod`
    decorator. We provide the following concrete implementations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是其他由`@abstractmethod`装饰器定义的抽象方法。我们提供了以下具体实现：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `__len__()`, `__iter__()`, and `__contains__()` methods are required by
    the `Sized`, `Iterable`, and `Container` abstract classes. The `Collection` abstract
    class combines the other three without introducing any new abstract methods.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`__len__()`、`__iter__()` 和 `__contains__()` 方法是 `Sized`、`Iterable` 和 `Container`
    抽象类所要求的。`Collection` 抽象类结合了其他三个，但没有引入任何新的抽象方法。'
- en: The `__getitem__()` is required to be a `Mapping`. Without it, we can't retrieve
    an individual value for a given key.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getitem__()` 方法必须是一个 `Mapping`。没有它，我们无法根据给定的键检索单个值。'
- en: The use of the `bisect` module is one way to find a specific value rapidly in
    a sorted list of keys. The `bisect.bisect_left()` function finds the spot where
    a key belongs in a list. If the key is there, we can return the value to which
    it maps. If the key is not there, we can raise the `KeyError` exception.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `bisect` 模块是快速在排序键列表中查找特定值的一种方法。`bisect.bisect_left()` 函数用于找到键在列表中的位置。如果键存在，我们可以返回它所映射的值。如果键不存在，我们可以引发
    `KeyError` 异常。
- en: Note that the `__contains__()` definition has the `object` class as the type
    hint, unlike the other methods. This is required because Python's `in` operation
    needs to support any kind of object, even ones that don't obviously support the
    `Comparable` protocol.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__contains__()` 方法定义中使用了 `object` 类作为类型提示，这与其他方法不同。这是必需的，因为 Python 的 `in`
    操作需要支持任何类型的对象，甚至那些明显不支持 `Comparable` 协议的对象。
- en: 'Here''s how it looks when we use our shiny new `Lookup` class:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们使用我们闪亮的新`Lookup`类时的样子：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This collection, generally, behaves a bit like a dictionary. There are a number
    of dict-like aspects we can't use, though, because we chose an abstract base class
    that didn't describe the full set of methods for the `dict` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这组集合通常表现得有点像字典。尽管如此，我们无法使用一些像字典那样的特性，因为我们选择了一个抽象基类，它没有描述`dict`类的全部方法集。
- en: 'If we try something like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试类似这样做：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We''ll get an exception that spells out the limitation of the class we built:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遇到一个异常，它将说明我们构建的类的局限性：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This exception is consistent with the rest of our design. An update to this
    object means inserting an item at the correct position to maintain a sorted order.
    Shuffling a large list around gets expensive; if we need to update the lookup
    collection, we should consider other data structures like a Red-Black tree. But,
    for the pure search operation using the bisect algorithm, this performs nicely.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常与我们的设计其余部分保持一致。更新此对象意味着在正确的位置插入一个项目以保持排序顺序。在大列表周围进行洗牌变得昂贵；如果我们需要更新查找集合，我们应该考虑其他数据结构，如红黑树。但是，对于使用二分查找算法的纯搜索操作，这表现得很不错。
- en: 'We skipped over the definition of the `Comparable` class. This defines the
    minimum set of features – the protocol – for the keys. It''s a way to formalize
    the comparison rules required to keep the keys for the mapping in order. This
    helps **mypy** confirm that objects we try to use as keys really can be compared:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过了`Comparable`类的定义。这定义了键的最小特征集——即协议——用于键。这是一种形式化比较规则的方式，这些规则是保持映射中键的顺序所需的。这有助于**mypy**确认我们尝试用作键的对象确实可以进行比较：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's no implementation. This definition is used to introduce a new type hint.
    Because it's a hint, we provide `...` as the body for the methods, since the bodies
    will be provided by existing class definitions like `str` and `int`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 没有实现。这个定义用于引入一个新的类型提示。因为这是一个提示，所以我们为方法提供`...`作为主体，因为主体将由现有的类定义，如`str`和`int`提供。
- en: Note that we don't rely on items having a hash code. This is an interesting
    extension to the built-in `dict` class, which requires the keys be hashable.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并不依赖于项目具有哈希码。这是对内置`dict`类的一个有趣扩展，它要求键必须是可哈希的。
- en: 'The general approach to using abstract classes is this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用抽象类的一般方法是这样的：
- en: Find a class that does most of what you need.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个能满足你大部分需求的课程。
- en: Identify the methods in the `collections.abc` definitions that are marked as
    *abstract*. The documentation often gives a lot of information, but you'll also
    have to look at the source.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别`collections.abc`定义中标记为*抽象*的方法。文档通常会提供很多信息，但你还需要查看源代码。
- en: Subclass the abstract class, filling in the missing methods.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继承抽象类，填充缺失的方法。
- en: While it can help to make a checklist of the methods, there are tools to help
    with this. Creating a unit test (we'll cover testing in *Chapter 13*, *Testing
    Object-Oriented Programs*) means you need to create an instance of your new class.
    If you haven't defined all the abstract methods, this will raise an exception.
    Using **mypy** will also spot abstract methods that aren't properly defined in
    the concrete subclass.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然制作一个方法清单可能会有所帮助，但也有一些工具可以帮助你完成这项工作。创建一个单元测试（我们将在*第13章*，*面向对象程序的测试*中介绍测试）意味着你需要创建你新类的一个实例。如果你还没有定义所有抽象方法，这将引发一个异常。使用**mypy**也可以发现那些在具体子类中未正确定义的抽象方法。
- en: This is a powerful way to reuse code when we choose the abstractions well; a
    person can form a mental model of the class without knowing all of the details.
    It's also a powerful way to create closely related classes that can easily be
    examined by **mypy**. Beyond those two advantages, the formality of marking a
    method as abstract gives us a runtime assurance that the concrete subclass really
    does implement all the required methods.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在选择了合适的抽象时重用代码的强大方式；一个人可以在不知道所有细节的情况下形成对类的心理模型。这同样是一种创建紧密相关的类并能够轻松被**mypy**检查的强大方式。除了这两个优点之外，将方法标记为抽象的形式性还给我们提供了运行时保证，即具体的子类确实实现了所有必需的方法。
- en: Now that we've seen how to use an abstract base class, let's look at defining
    a new abstraction.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用抽象基类，接下来让我们看看如何定义一个新的抽象。
- en: Creating your own abstract base class
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自己的抽象基类
- en: 'We have two general paths to creating classes that are similar: we can leverage
    duck typing or we can define common abstractions. When we leverage duck typing,
    we can formalize the related types by creating a type hint using a protocol definition
    to enumerate the common methods, or a `Union[]` to enumerate the common types.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两条创建类似类的通用路径：我们可以利用鸭子类型，或者我们可以定义公共抽象。当我们利用鸭子类型时，我们可以通过创建一个使用协议定义来列举公共方法或使用`Union[]`来列举公共类型的类型提示来形式化相关类型。
- en: There are an almost unlimited number of influencing factors that suggest one
    or the other approach. While duck typing offers the most flexibility, we may sacrifice
    the ability to use **mypy**. An abstract base class definition can be wordy and
    potentially confusing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 影响因素几乎无限，它们暗示了某种或另一种方法。虽然鸭子类型提供了最大的灵活性，但我们可能要牺牲使用**mypy**的能力。抽象基类定义可能过于冗长且容易引起混淆。
- en: We'll tackle a small problem. We want to build a simulation of games that involve
    polyhedral dice. These are the dice including four, six, eight, twelve, and twenty
    sides. The six-sided dice are conventional cubes. Some sets of dice include 10-sided
    dice, which are cool, but aren't – technically – a *regular* polyhedron; they're
    two sets of five "kite-shaped" faces.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解决一个小问题。我们想要构建一个涉及多面骰子的游戏模拟。这些骰子包括四面、六面、八面、十二面和二十面。六面骰子是传统的立方体。有些骰子套装包括十面骰子，这很酷，但技术上并不是一个*规则*多面体；它们是由两组五个“风筝形”面组成的。
- en: 'One question that comes up is how best to simulate rolls of these different
    shaped dice. There are three readily available sources of random data in Python:
    the `random` module, the `os` module, and the `secrets` module. If we turn to
    third-party modules, we can add in cryptographic libraries like `pynacl`, which
    offer yet more random number capabilities.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个问题是如何最好地模拟这些不同形状骰子的滚动。在Python中，有三个现成的随机数据来源：`random`模块、`os`模块和`secrets`模块。如果我们转向第三方模块，我们可以添加加密库如`pynacl`，它提供了更多的随机数功能。
- en: Rather than bake the choice of random number generator into a class, we can
    define an abstract class that has the general features of a die. A concrete subclass
    can supply the missing randomization capability. The random module has a very
    flexible generator. The `os` module's capability is limited, but involves using
    an *entropy collector* to increase randomness. Flexibility and high entropy are
    generally combined by cryptographic generators.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将随机数生成器的选择嵌入到类中，而是可以定义一个具有骰子一般特征的抽象类。一个具体的子类可以提供缺失的随机化能力。`random`模块有一个非常灵活的生成器。`os`模块的功能有限，但涉及使用一个*熵收集器*来增加随机性。灵活性和高熵通常通过加密生成器结合在一起。
- en: 'To create our dice-rolling abstraction, we''ll need the `abc` module. This
    is distinct from the `collections.abc` module. The `abc` module has the foundational
    definitions for abstract classes:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的掷骰子抽象，我们需要`abc`模块。这与`collections.abc`模块不同。`abc`模块包含抽象类的基础定义：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've defined a class that inherits from the `abc.ABC` class. Using `ABC` as
    the parent class assures us that any attempt to create an instance of the `Die`
    class directly will raise a `TypeError` exception. This is a runtime exception;
    it's also checked by **mypy**.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个从 `abc.ABC` 类继承的类。使用 `ABC` 作为父类可以确保任何尝试直接创建 `Die` 类实例的操作都会引发一个 `TypeError`
    异常。这是一个运行时异常；它也由 **mypy** 进行检查。
- en: 'We''ve marked a method, `roll()`, as abstract with the `@abc.abstract` decorator.
    This isn''t a very complex method, but any subclass should match this abstract
    definition. This is only checked by **mypy**. Of course, if we make a mess of
    the concrete implementation, things are likely to break at runtime. Consider this
    mess of code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@abc.abstract`装饰器将方法`roll()`标记为抽象。这不是一个非常复杂的方法，但任何子类都应该符合这个抽象定义。这仅由**mypy**进行检查。当然，如果我们把具体实现搞得一团糟，运行时很可能会出现问题。考虑以下一团糟的代码：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will raise a `TypeError` exception at runtime. The problem is caused by
    the base class `__init__()` not providing the `a` and `b` parameters to this strange-looking
    `roll()` method. This is valid Python code, but it doesn't make sense in this
    context. The method will also generate **mypy** errors, providing ample warning
    the method definition doesn't match the abstraction.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行时引发一个 `TypeError` 异常。问题是由基类 `__init__()` 没有为这个看起来奇怪的 `roll()` 方法提供 `a`
    和 `b` 参数引起的。这是有效的 Python 代码，但在这种上下文中没有意义。该方法还会生成 **mypy** 错误，提供了足够的警告，表明方法定义与抽象不匹配。
- en: 'Here''s what two proper extensions to the `Die` class look like:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Die`类两个适当扩展的示例：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've provided methods that provide a suitable definition for the abstract placeholder
    in the `Die` class. They use vastly different approaches to selecting a random
    value. The four-sided die uses `random.choice()`. The six-sided die – the common
    cube most people know – uses `random.randint()`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提供了为`Die`类中的抽象占位符提供合适定义的方法。它们采用了截然不同的方法来选择一个随机值。四面骰子使用`random.choice()`。六面骰子——即大多数人所熟知的普通立方骰子——使用`random.randint()`。
- en: Let's go a step further and create another abstract class. This one will represent
    a handful of dice. Again, we have a number of candidate solutions, and we can
    use an abstract class to defer the final design choices.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更进一步，创建另一个抽象类。这个类将代表一把骰子。同样，我们有许多候选解决方案，并且可以使用抽象类来推迟最终的设计选择。
- en: The interesting part of this design is the differences in the rules for games
    with handfuls of dice. In some games, the rules require the player to roll all
    the dice. The rules for a lot of games with two dice require the player to roll
    both dice. In other games, the rules allow players to save dice, and re-roll selected
    dice. In some games, like Yacht, the players are allowed at most two re-rolls.
    In other games, like Zilch, they are allowed to re-roll until they elect to save
    their score or roll something invalid and lose all their points, scoring zilch
    (hence the name).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计的有趣之处在于掷骰子游戏规则的不同。在一些游戏中，规则要求玩家掷出所有骰子。许多两骰子游戏的规则要求玩家掷出两个骰子。在其他游戏中，规则允许玩家保留骰子，并重新掷选定的骰子。在一些游戏中，比如“帆船”游戏，玩家最多允许重新掷骰子两次。在其他游戏中，比如“零分”游戏，他们可以一直重新掷骰子，直到他们选择保留得分或掷出无效的骰子，从而失去所有分数，得到零分（因此得名）。
- en: 'These are dramatically different rules that apply to a simple list of `Die`
    instances. Here''s a class that leaves the roll implementation as an abstraction:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是应用于简单`Die`实例列表的截然不同的规则。下面是一个将掷骰子实现作为抽象的类：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `__init__()` method expects an integer, `n`, and the class used to create
    `Die` instances, named `die_class`. The type hint is `Type[Die]`, telling **mypy**
    to be on the lookout for any subclass of the abstract base class `Die`. We don't
    expect an instance of any of the `Die` subclasses; we expect the class object
    itself. We'd expect to see `SomeDice(6, D6)` to create a list of six instances
    of the `D6` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 方法期望一个整数，`n`，以及用于创建 `Die` 实例的类，命名为 `die_class`。类型提示为 `Type[Die]`，告诉
    **mypy** 密切关注任何抽象基类 `Die` 的子类。我们并不期望任何 `Die` 子类的实例；我们期望的是类对象本身。我们期望看到 `SomeDice(6,
    D6)` 来创建一个包含六个 `D6` 类实例的列表。'
- en: We've defined the collection of `Die` instances as a list because that seems
    simple. Some games will identify dice by their position when saving some dice
    and rerolling the remainder of the dice, and the integer list indices seem useful
    for that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Die`实例的集合定义为列表，因为这看起来很简单。有些游戏在保存一些骰子并重新掷剩余骰子时，会通过位置来识别骰子，整数列表索引对于这一点来说似乎很有用。
- en: 'This subclass implements the roll-all-the-dice rule:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子类实现了“掷所有骰子”的规则：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each time the application evaluates `roll()`, all the dice are updated. It
    looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每次应用程序评估 `roll()` 时，所有骰子都会更新。它看起来是这样的：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The object, `sd`, is an instance of the concrete class, `SimpleDice`, built
    from the abstract class, `Dice`. The instance of `SimpleDice` contains six instances
    of the `D6` class. This, too, is a concrete class built from the abstract class
    `Die`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对象`sd`是抽象类`Dice`派生出的具体类`SimpleDice`的一个实例。这个`SimpleDice`实例包含了六个`D6`类的实例。同样，`D6`类也是一个从抽象类`Die`派生出的具体类。
- en: 'Here''s another subclass that provides a dramatically different set of methods.
    Some of these fill in the spaces left by abstract methods. Others, however, are
    unique to the subclass:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个提供一组截然不同方法的子类。其中一些方法填补了抽象方法留下的空白。然而，还有一些方法是子类独有的：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ve created a set of saved positions. This is initially empty. We can use
    the `saving()` method to provide an iterable collection of integers as positions
    to save. It works like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一套保存位置。最初它是空的。我们可以使用`saving()`方法来提供一个整数位置的迭代集合以进行保存。它的工作方式如下：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We improved the hand from three of a kind to a full house.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将手牌从三张同花顺提升到了满堂红。
- en: In both cases, the `Die` class and the `Dice` class, it's not clear that the
    `abc.ABC` base class and the presence of an `@abc.abstractmethod` decoration is
    dramatically better than providing a concrete base class with a common set of
    default definitions.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，无论是`Die`类还是`Dice`类，并不明显地看出`abc.ABC`基类以及存在`@abc.abstractmethod`装饰比提供一个具有一组常见默认定义的具体基类有显著优势。
- en: In some languages, the abstraction-based definition is required. In Python,
    because of duck typing, abstraction is optional. In cases where it clarifies the
    design intent, use it. In cases where it seems fussy and little more than overhead,
    set it aside.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些语言中，需要基于抽象的定义。在Python中，由于鸭子类型，抽象是可选的。在它有助于阐明设计意图的情况下，使用它。在它显得过于繁琐且几乎无足轻重的情况下，则将其置之不理。
- en: Because it's used to define the collections, we'll often use the `collection.abc`
    names in type hints to describe the protocols objects must follow. In less common
    cases, we'll leverage the `collections.abc` abstractions to create our own unique
    collections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它用于定义集合，所以我们经常在类型提示中使用`collection.abc`名称来描述协议对象必须遵循的规则。在不常见的场合，我们将利用`collections.abc`抽象来创建我们自己的独特集合。
- en: Demystifying the magic
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭秘魔法
- en: 'We''ve used abstract base classes and it''s clear they''re doing a lot of work
    for us. Let''s look inside the class to see some of what''s going on:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了抽象基类，很明显它们为我们做了很多工作。让我们看看类内部，看看一些正在发生的事情：
- en: '[PRE25]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The abstract method, `roll()`, is tracked in a specially named attribute, `__abstractmethods__`,
    of the class. This suggests what the `@abc.abstractmethod` decorator does. This
    decorator sets `__isabstractmethod__` to mark the method. When Python finally
    builds the class from the various methods and attributes, the list of abstractions
    is also collected to create a class-level set of methods that must be implemented.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法 `roll()` 在类的特别命名的属性 `__abstractmethods__` 中进行跟踪。这表明了 `@abc.abstractmethod`
    装饰器的作用。此装饰器将 `__isabstractmethod__` 设置为标记方法。当 Python 最终从各种方法和属性构建类时，抽象方法的列表也会被收集，以创建一个必须实现的方法的类级别集合。
- en: Any subclass that extends `Die` will also inherit this `__abstractmethods__`
    set. When methods are defined inside the subclass, names are removed from the
    set as Python builds the class from the definitions. We can only create instances
    of a class where the set of abstract methods in the class is empty.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 任何扩展 `Die` 的子类也将继承这个 `__abstractmethods__` 集合。当在子类内部定义方法时，随着 Python 从定义构建类，名称将从集合中移除。我们只能创建那些类中抽象方法集合为空的类的实例。
- en: 'Central to this is the way classes are created: a class builds objects. This
    is the essence of most of object-oriented programming. But what is a class?'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的核心是类的创建方式：类构建对象。这是大多数面向对象编程的本质。但什么是类呢？
- en: 'A class is another object with two very limited jobs: it has the special methods
    used to create and manage instances of the class, and it also acts as a container
    for the method definitions for objects of the class. We think of building class
    objects with the `class` statement, which leaves open the question of how the
    `class` statement builds the `class` object.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类是另一种具有两个非常有限职责的对象：它拥有用于创建和管理该类实例的特殊方法，并且它还充当该类对象方法定义的容器。我们认为使用`class`语句构建类对象，这留下了`class`语句如何构建`class`对象的问题。
- en: The `type` class is the internal object that builds our application classes.
    When we enter the code for a class, the details of construction are actually the
    responsibility of methods of the `type` class. After `type` has created our application
    class, our class then creates the application objects that solve our problem.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`type` 类是构建我们应用程序类的内部对象。当我们输入类的代码时，构建的细节实际上是 `type` 类方法的职责。在 `type` 创建了我们的应用程序类之后，我们的类随后创建了解决我们问题的应用程序对象。'
- en: The `type` object is called the **metaclass**, the class used to build classes.
    This means every class object is an instance of `type`. Most of the time, we're
    perfectly happy with letting a `class` statement be handled by the `type` class
    so our application code can run. There's one place, however, where we might want
    to change how `type` works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`type` 对象被称为**元类**，是用于构建类的类。这意味着每个类对象都是 `type` 的一个实例。大多数情况下，我们很乐意让 `class`
    语句由 `type` 类处理，以便我们的应用程序代码可以运行。然而，有一个地方，我们可能想要改变 `type` 的工作方式。'
- en: 'Because `type` is itself a class, it can be extended. A class `abc.ABCMeta`
    extends the `type` class to check for methods decorated with `@abstractmethod`.
    When we extend `abc.ABC`, we''re creating a new class that uses the `ABCMeta`
    metaclass. We can see this in the value of the special `__mro__` attribute of
    the `ABCMeta` class; this attribute lists the classes used for resolving method
    names (**MRO** is **Method Resolution Order**). This special attribute lists the
    following classes to be searched for a given attribute: the `abc.ABCMeta` class,
    the `type` class, and finally the `object` class.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `type` 本身就是一个类，所以它可以被扩展。类 `abc.ABCMeta` 扩展了 `type` 类以检查带有 `@abstractmethod`
    装饰的方法。当我们扩展 `abc.ABC` 时，我们正在创建一个新的类，该类使用 `ABCMeta` 元类。我们可以在 `ABCMeta` 类的特殊 `__mro__`
    属性的值中看到这一点；该属性列出了用于解析方法名称的类（**MRO** 是 **方法解析顺序**）。这个特殊属性列出了要搜索给定属性的以下类：`abc.ABCMeta`
    类、`type` 类，最后是 `object` 类。
- en: 'We can use the `ABCMeta` metaclass explicitly when we create a new class, if
    we want:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在创建新类时，如果想显式使用`ABCMeta`元类，可以这样操作：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We've used `metaclass` as a keyword parameter when defining the components that
    make up a class. This means the `abc.ABCMeta` extension to type will be used to
    create the final class object.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在定义组成类的组件时使用了`metaclass`作为关键字参数。这意味着将使用`abc.ABCMeta`扩展来创建最终的类对象。
- en: Now that we've seen how classes are built, we can consider other things we can
    do when creating and extending classes. Python exposes the binding between the
    syntactic operators, like the `/` operator, and the methods of the implementing
    class. This allows the `float` and `int` classes to do different things with the
    `/` operator, but it can also be used for quite different purposes. For example,
    the `pathlib.Path` class, which we will discuss in *Chapter 9*, *Strings, Serialization,
    and File Paths*, also makes use of the `/` operator.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何构建类，我们就可以考虑在创建和扩展类时可以做的事情。Python 揭示了语法运算符（如 `/` 运算符）与实现类的方法之间的绑定。这使得
    `float` 和 `int` 类可以使用 `/` 运算符做不同的事情，但它也可以用于相当不同的目的。例如，我们将在第 9 章“字符串、序列化和文件路径”中讨论的
    `pathlib.Path` 类，也使用了 `/` 运算符。
- en: Operator overloading
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符重载
- en: 'Python''s operators, `+`, `/`, `-`, `*`, and so on, are implemented by special
    methods on classes. We can apply Python operators more widely than the built-in
    numbers and collection types. Doing this can be called "overloading" the operators:
    letting them work with more than the built-in types.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的运算符，如 `+`, `/`, `-`, `*` 等，是通过类上的特殊方法实现的。我们可以比内置的数字和集合类型更广泛地应用 Python
    运算符。这样做可以称为“重载”运算符：让它们能够与更多内置类型一起工作。
- en: 'Looking back at the *The collections.abc module* section, earlier in this chapter,
    we dropped a hint about how Python connects some built-in features with our classes.
    When we look at the `collections.abc.Collection` class, it is the abstract base
    class for all `Sized`, `Iterable`, `Containers`; it requires three methods that
    enable two built-in functions and one built-in operator:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章早先的 *The collections.abc module* 部分，我们曾暗示了 Python 如何将一些内置特性与我们的类关联起来。当我们查看
    `collections.abc.Collection` 类时，它是所有 `Sized`、`Iterable`、`Containers` 的抽象基类；它需要三个方法来启用两个内置函数和一个内置运算符：
- en: The `__len__()` method is used by the built-in `len()` function.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__len__()` 方法被内置的 `len()` 函数所使用。'
- en: The `__iter__()` method is used by the built-in `iter()` function, which means
    it's used by the `for` statement.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iter__()` 方法被内置的 `iter()` 函数使用，这意味着它被 `for` 语句使用。'
- en: The `__contains__()` method is used by the built-in `in` operator. This operator
    is implemented by methods of built-in classes.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__contains__()` 方法由内置的 `in` 操作符使用。此操作符由内置类的方法实现。'
- en: 'It''s not wrong to imagine the built-in `len()` function has this definition:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 想象内置的 `len()` 函数具有如下定义是没有错的：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we ask for `len(x)`, it's doing the same thing as `x.__len__()`, but is
    shorter, easier to read, and easier to remember. Similarly, `iter(y)` is effectively
    `y.__iter__()`. And an expression like `z in S` is evaluated as if it was `S.__contains__(z)`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们请求`len(x)`时，它执行的操作与`x.__len__()`相同，但更短，更易于阅读，也更易于记忆。同样，`iter(y)`实际上等同于`y.__iter__()`。而像`z
    in S`这样的表达式，其评估过程就像它是`S.__contains__(z)`一样。
- en: 'And yes, with a few exceptions, all of Python works this way. We write pleasant,
    easy-to-read expressions that are transformed into special methods. The only exceptions
    are the logic operations: `and`, `or`, `not`, and `if-else`. These don''t map
    directly to special method definitions.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了少数例外，Python 都是按照这种方式工作的。我们编写愉快、易于阅读的表达式，这些表达式会被转换成特殊方法。唯一的例外是逻辑运算符：`and`、`or`、`not`
    和 `if-else`。这些并不直接映射到特殊方法定义。
- en: 'Because almost all of Python relies on the special methods, it means we can
    change their behavior to add features. We can overload the operators with new
    data types. One prominent example of this is in the `pathlib` module:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为几乎所有的 Python 都依赖于特殊方法，这意味着我们可以改变它们的行为来添加功能。我们可以用新的数据类型重载运算符。一个突出的例子是在 `pathlib`
    模块中：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note: Your results will vary, depending on your operating system and your username.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您的结果将因操作系统和用户名而异。
- en: What doesn't vary is that the `/` operator is used to connect a `Path` object
    with string objects to create a new `Path` object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不变的是，`/`运算符用于将`Path`对象与字符串对象连接，以创建一个新的`Path`对象。
- en: 'The `/` operator is implemented by the `__truediv__()` and `__rtruediv__()`
    methods. In order to make operations commutative, Python has two places to look
    for an implementation. Given an expression of `A` *op* `B`, where *op* is any
    of the Python operators like `__add__` for `+`, Python does the following checks
    for special methods to implement the operator:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`/` 运算符是通过 `__truediv__()` 和 `__rtruediv__()` 方法实现的。为了使操作具有交换性，Python 在查找实现时会查看两个地方。给定一个表达式
    `A *op* B`，其中 *op* 是 Python 中的任何运算符，如 `__add__` 对应于 `+`，Python 会进行以下检查以实现特殊方法来执行运算符：'
- en: There's a special case when `B` is a proper subclass of `A`. In those rare cases,
    the order is reversed so `B.__r`*op*`__(A)` can be tried before any of the others.
    This lets the subclass `B` override an operation from superclass `A`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `B` 是 `A` 的真子类时，存在一个特殊情况。在这些罕见的情况下，顺序会被颠倒，因此 `B.__r`*op*`__(A)` 可以在尝试其他任何操作之前被尝试。这使得子类
    `B` 可以覆盖超类 `A` 中的操作。
- en: Try `A.__`*op*`__(B)`. If this returns a value that's not the special `NotImplemented`
    value, this is the result. For a `Path` object expression like `home / "miniconda3"`,
    this is effectively `home.__truediv__("miniconda3")`. A new `Path` object is built
    from the old `Path` object and the string.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试 `A.__op**(B)`. 如果这返回的不是特殊的 `NotImplemented` 值，这就是结果。对于一个 `Path` 对象表达式，例如
    `home / "miniconda3"`，这实际上等同于 `home.__truediv__("miniconda3")`。一个新的 `Path` 对象将从旧的
    `Path` 对象和字符串中构建。
- en: Try `B.__r`*op*`__(A)`. This might be the `__radd__()` method for the reverse
    addition implementation. If this method returns a value other than the `NotImplemented`
    value, this is the result. Note that the operand ordering is reversed. For commutative
    operations, like addition and multiplication, this does not matter. For non-commutative
    operations, like subtraction and division, the change in ordering needs to be
    reflected in the implementation.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试 `B.__r`*op*`__(A)`. 这可能是反向加法实现的 `__radd__()` 方法。如果此方法返回的值不是 `NotImplemented`
    值，则这是结果。请注意，操作数顺序被反转。对于交换律操作，如加法和乘法，这并不重要。对于非交换律操作，如减法和除法，顺序的改变需要在实现中反映出来。
- en: 'Let''s return to our handful of dice example. We can implement a `+` operator
    to add a `Die` instance to a collection of `Dice`. We''ll start with a base definition
    of a class that contains a heterogenous handful of different kinds of dice. Check
    the previous `Dice` class, which assumed homogenous dice. This isn''t an abstract
    class; it has a definition of `roll` that re-rolls all the dice. We''ll start
    with some basics and then incorporate the `__add__()` special method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的一把骰子的例子。我们可以实现一个`+`运算符来将一个`Die`实例添加到一个`Dice`集合中。我们将从一个包含不同种类骰子的异构一把骰子的基础类定义开始。查看之前的`Dice`类，它假设了同质骰子。这不是一个抽象类；它有一个`roll`方法的定义，该定义会重新掷所有骰子。我们将从一些基础知识开始，然后引入`__add__()`特殊方法：
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This shouldn't be much of a surprise. It looks a lot like the `Dice` class defined
    above. We've added an `adjust` attribute set by the `plus()` method so we can
    use `DDice(D6, D6, D6).plus(2)`. It fits better with some tabletop role-playing
    games (TTRPGs).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这点并不令人惊讶。它看起来与上面定义的`Dice`类非常相似。我们添加了一个由`plus()`方法设置的`adjust`属性，这样我们就可以使用`DDice(D6,
    D6, D6).plus(2)`。它与一些桌面角色扮演游戏（TTRPGs）更契合。
- en: Also, recall that we provide the types of the dice to the `DDice` class, not
    instances of the dice. We use the class object, `D6`, not a `Die` instance, created
    by an expression like `D6()`. The instances of the classes are created by `DDice`
    in the `__init__()` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住我们向 `DDice` 类提供骰子的类型，而不是骰子的实例。我们使用类对象 `D6`，而不是通过表达式 `D6()` 创建的 `Die` 实例。类的实例是通过
    `DDice` 类的 `__init__()` 方法创建的。
- en: 'Here''s the cool part: we can use the plus operator with `DDice` objects, `Die`
    classes, and integers to define a complex roll of the dice:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有个酷炫的功能：我们可以使用加号运算符与 `DDice` 对象、`Die` 类以及整数一起定义一个复杂的骰子投掷：
- en: '[PRE30]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two methods are similar in many ways. We check for three separate kinds
    of `+` operations:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法在许多方面都很相似。我们检查三种不同的`+`运算：
- en: If the argument value, `die_class`, is a type, and it's a subclass of the `Die`
    class, then we're adding another `Die` object to a `DDice` collection. It's an
    expression like `DDice(D6) + D6 + D6`. The semantics of most operator implementations
    is to create a new object from the previous objects.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数值 `die_class` 是一个类型，并且它是 `Die` 类的子类，那么我们就在 `DDice` 集合中添加另一个 `Die` 对象。这类似于
    `DDice(D6) + D6 + D6` 这样的表达式。大多数操作符实现的意义是从前面的对象创建一个新的对象。
- en: If the argument value is an integer, then we're adding an adjustment to a set
    of dice. This is something like `DDice(D6, D6, D6) + 2`.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数值是一个整数，那么我们正在对一个骰子集合进行调整。这就像 `DDice(D6, D6, D6) + 2`。
- en: If the argument value is neither a subclass of `Die` nor an integer, then something
    else is going on, and this class doesn't have an implementation. This may be some
    kind of bug, or it might be that the other class involved in the operation can
    provide an implementation; returning `NotImplemented` gives the other object a
    chance at performing the operation.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果参数值既不是`Die`的子类也不是整数，那么可能存在其他情况，并且这个类没有实现。这可能是某种错误，或者可能是参与操作的另一个类可以提供实现；返回`NotImplemented`给其他对象一个执行操作的机会。
- en: Because we've provided `__radd__()` as well as `__add__()`, these operations
    are commutative. We can use expressions like `D6 + DDice(D6) + D6` and `2 + DDice(D6,
    D6)`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经提供了 `__radd__()` 以及 `__add__()`，这些操作是交换的。我们可以使用类似 `D6 + DDice(D6) + D6`
    和 `2 + DDice(D6, D6)` 的表达式。
- en: We need to make specific `isinstance()` checks because Python operators are
    completely generic, and the expected type hint must be `Any`. We can only narrow
    down the applicable types through runtime checks. The **mypy** program is astute
    about following the branching logic to confirm that an integer object was properly
    used in an integer context.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行特定的 `isinstance()` 检查，因为 Python 操作符是完全通用的，预期的类型提示必须是 `Any`。我们只能通过运行时检查来缩小适用类型。**mypy**
    程序在遵循分支逻辑以确认整数对象在整数上下文中正确使用方面非常聪明。
- en: '"But wait," you say. "My favorite game has rules that call for 3d6+2." This
    is shorthand for rolling three six-sided dice and adding two to the result. In
    many TTRPGs, this kind of abbreviation is used to summarize the dice.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '"但是等等，”你说，“我喜欢的游戏有需要3d6+2的规则。”这表示掷三个六面的骰子并将结果加二。在许多桌上角色扮演游戏（TTRPGs）中，这种缩写用于总结骰子的使用。'
- en: 'Can we add multiplication to do this? There''s no reason why not. For multiplication,
    we only need to worry about integers. `D6 * D6` isn''t used in any of the rules,
    but `3*D6` matches the text of most TTRPG rules nicely:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否添加乘法来完成这个操作？完全没有理由不行。对于乘法，我们只需要担心整数。`D6 * D6` 在任何规则中都没有使用，但 `3*D6` 与大多数桌面角色扮演游戏（TTRPG）规则的文本非常吻合：
- en: '[PRE31]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These two methods follow a similar design pattern to the `__add__()` and `__radd__()`
    methods. For each existing `Die` subclass, we'll create several instances of the
    class. This lets us use `3 * DDice(D6) + 2` as an expression to define a dice-rolling
    rule. The Python operator precedence rules still apply, so the `3 * DDice(D6)`
    portion is evaluated first.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法遵循与 `__add__()` 和 `__radd__()` 方法相似的设计模式。对于每个现有的 `Die` 子类，我们将创建几个类的实例。这使得我们可以使用
    `3 * DDice(D6) + 2` 这样的表达式来定义掷骰子的规则。Python 的运算符优先级规则仍然适用，因此 `3 * DDice(D6)` 这一部分会先被评估。
- en: 'Python''s use of the various `__`*op*`__()` and `__r`*op*`__()` methods works
    out extremely well for applying the various operators to objects that are immutable:
    strings, numbers, and tuples being the primary examples. Our handful of dice presents
    a bit of a head-scratcher because the state of the individual dice can change.
    What''s important is that we treat the composition of the hand as immutable. Each operation on
    a `DDice` object creates a new `DDice` instance.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Python 对各种 `__`*op*`__()` 和 `__r`*op*`__()` 方法的使用，对于将各种运算符应用于不可变对象（如字符串、数字和元组）来说非常有效。我们的一把骰子可能会让人有些摸不着头脑，因为单个骰子的状态可能会改变。重要的是，我们将手牌的组合视为不可变的。对
    `DDice` 对象的每一次操作都会创建一个新的 `DDice` 实例。
- en: What about mutable objects? When we write an assignment statement like `some_list
    += [some_item]`, we're mutating the value of the `some_list` object. The `+=`
    statement does the same thing as the more complex expression `some_list.extend([some_item])`.
    Python supports this with operators with names like `__iadd__()` and `__imul__()`.
    These are "in-place" operations, designed to mutate objects.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，可变对象又是怎样的呢？当我们编写一个赋值语句，例如 `some_list += [some_item]`，我们实际上是在修改 `some_list`
    对象的值。`+=` 语句与更复杂的表达式 `some_list.extend([some_item])` 做的是同样的事情。Python 通过像 `__iadd__()`
    和 `__imul__()` 这样的操作符名称支持这种操作。这些是“原地”操作，旨在修改对象。
- en: 'For example, consider:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This can be processed one of two ways:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过两种方式之一进行处理：
- en: If `DDice` implements `__iadd__()`, this becomes `y.__iadd__(D6)`. The object
    can mutate itself in place.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `DDice` 实现了 `__iadd__()`，这将变为 `y.__iadd__(D6)`。该对象可以就地修改自身。
- en: If `DDice` does not implement `__iadd__()`, this is `y = y.__add__(D6)`. The
    object creates a new, immutable object, and that's given the old object's variable
    name. This lets us do things like `string_variable += "."`. Under the hood, `string_variable`
    is not mutated; it's replaced.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `DDice` 没有实现 `__iadd__()`，则这是 `y = y.__add__(D6)`。该对象创建了一个新的、不可变的对象，并赋予它旧对象的变量名。这使得我们可以执行类似
    `string_variable += "."` 的操作。在底层，`string_variable` 并未被修改；它被替换了。
- en: 'If it makes sense for an object to be mutable, we can support in-place mutation
    of a `DDice` object with this method:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对一个对象进行可变操作是有意义的，我们可以通过这个方法支持对`DDice`对象的就地修改：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `__iadd__()` method appends to the internal collection of dice. It follows
    rules similar to the `__add__()` methods: when a class is provided, an instance
    is created, and it''s added to the `self.dice` list; if an integer is provided,
    it''s added to the `self.adjust` value.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iadd__()` 方法向骰子的内部集合中添加元素。它遵循与 `__add__()` 方法类似的规则：当提供一个类时，会创建一个实例，并将其添加到
    `self.dice` 列表中；如果提供一个整数，则将其添加到 `self.adjust` 值中。'
- en: 'We can now perform incremental changes to a single dice-rolling rule. We can
    mutate the state of a single `DDice` object using assignment statements. Because
    the object mutates, we aren''t creating a lot of copies of the object. The creation
    of complex dice looks like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以对单个掷骰子规则进行增量更改。我们可以使用赋值语句来改变单个`DDice`对象的状态。由于对象发生了变化，我们并没有创建很多对象的副本。复杂骰子的创建方式如下：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This builds the 3d6+2 dice roller in incremental pieces.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这逐步构建了3d6+2骰子投掷器。
- en: The use of the internal special method names allows for seamless integration
    with other Python features. We can build classes using `collections.abc` that
    fit with existing collections. We can override the methods implementing the Python
    operators to create easy-to-use syntax.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内部特殊方法名称允许与其他 Python 功能无缝集成。我们可以使用 `collections.abc` 构建与现有集合相匹配的类。我们可以重写实现
    Python 操作符的方法，以创建易于使用的语法。
- en: We can leverage the special method names to add features to Python's built-in
    generic collections. We'll turn to that topic next.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用特殊的方法名称来为 Python 的内置泛型集合添加功能。我们将在下一节中讨论这个话题。
- en: Extending built-ins
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展内置功能
- en: 'Python has two collections of built-ins that we might want to extend. We can
    broadly classify these into the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有两个内置集合，我们可能想要扩展。我们可以将这些大致分为以下几类：
- en: Immutable objects, including numbers, strings, bytes, and tuples. These will
    often have extended operators defined. In the *Operator overloading* section of
    this chapter, we looked at how we can provide arithmetic operations for objects
    of the `Dice` class.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变对象，包括数字、字符串、字节和元组。这些对象通常会定义扩展运算符。在本章的“运算符重载”部分，我们探讨了如何为`Dice`类的对象提供算术运算。
- en: Mutable collections, including sets, lists, and dictionaries. When we look at
    the definitions in `collections.abc`, these are sized, iterable containers, three
    distinct aspects that we might want to focus on. In *The collections.abc module*
    section of this chapter, we looked at creating an extension to the `Mapping` abstract
    base class.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变集合，包括集合、列表和字典。当我们查看`collections.abc`中的定义时，这些是带大小、可迭代的容器，三个我们可能想要关注的独立方面。在本章的*`collections.abc`模块*部分，我们探讨了如何创建对`Mapping`抽象基类的扩展。
- en: There are other built-in types, but these two groupings are generally applicable
    to a variety of problems. For example, we could create a dictionary that rejects
    duplicate values.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 除了其他内置类型外，这两组分类通常适用于各种问题。例如，我们可以创建一个拒绝重复值的字典。
- en: 'The built-in dictionary always updates the value associated with a key. This
    can lead to odd-looking code that works. For example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 内置字典总是更新与键关联的值。这可能导致看起来奇怪但能正常工作的代码。例如：
- en: '[PRE35]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后：
- en: '[PRE36]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: These are well-defined behaviors. It may be odd-looking to provide two keys
    in the expression but have only one key in the result, but the rules for building
    dictionaries make these inevitable and correct results.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是定义良好的行为。在表达式中提供两个键但在结果中只有一个键看起来可能有些奇怪，但构建字典的规则使得这种情况不可避免且结果正确。
- en: We may, however, not like the behavior of silently ignoring a key. It may make
    our application needlessly complex to worry about the possibility of duplicates.
    Let's create a new kind of dictionary that won't update items once they've been
    loaded.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不喜欢默默忽略一个键的行为。这可能会让我们的应用程序变得不必要地复杂，去担心重复的可能性。让我们创建一种新的字典，一旦加载了项目，它就不会更新这些项目。
- en: 'Studying `collections.abc`, we need to extend a mapping, with a changed definition
    of `__setitem__()` to prevent updating an existing key. Working at the interactive
    Python prompt, we can try this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 学习 `collections.abc` 时，我们需要扩展一个映射，通过改变 `__setitem__()` 的定义来防止更新现有的键。在交互式 Python
    提示符下工作，我们可以尝试这样做：
- en: '[PRE37]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'And when we put it to use, we see the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将它付诸实践时，我们看到了以下情况：
- en: '[PRE38]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We're not done, but we're off to a good start. This dictionary rejects duplicates
    under some circumstances.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成，但已经有一个良好的开端。在某些情况下，这个字典会拒绝重复项。
- en: 'However, it isn''t blocking duplicate keys when we try to construct a dictionary
    from another dictionary. We don''t want this to work:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们尝试从一个字典构造另一个字典时，它并没有阻止重复的键。我们不希望它这样做：
- en: '[PRE39]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So we've got some work to do. Some expressions properly raise exceptions, where
    as other expressions still silently ignore duplicate keys.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所以我们还有一些工作要做。一些表达式会正确地引发异常，而其他表达式仍然默默地忽略重复的键。
- en: The basic problem is that not all methods that set items are using `__setitem__()`.
    To alleviate the above problems, we'll need to override `__init__()` as well.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 基本问题是并非所有设置项的方法都使用了 `__setitem__()`。为了缓解上述问题，我们还需要重写 `__init__()` 方法。
- en: 'We''ll also need to add type hints to our initial draft. This will let us leverage
    **mypy** to confirm that our implementation will work in general. Here''s a version
    with `__init__()` added:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在我们的初稿中添加类型提示。这将使我们能够利用**mypy**来确认我们的实现将普遍适用。下面是添加了`__init__()`的方法版本：
- en: '[PRE40]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This version of the `NoDupDict` class implements an `__init__()` method that
    will work with a variety of data types. We enumerated the various types using
    the `DictInit` type hint. This includes a sequence of *key-value* pairs, as well
    as another mapping. In the case of a sequence of key-value pairs, we can use the
    previously defined `__setitem__()` to raise an exception in the event of duplicate
    key values.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的 `NoDupDict` 类实现了一个 `__init__()` 方法，它可以与多种数据类型一起工作。我们使用 `DictInit` 类型提示列举了各种类型。这包括一系列
    *键值对*，以及另一个映射。在键值对序列的情况下，我们可以使用之前定义的 `__setitem__()` 方法来在键值重复时抛出异常。
- en: This covers the initialization use cases, but – still – doesn't cover every
    method that can update a mapping. We still have to implement `update()`, `setdefault()`,
    `_``_or__()`, and `__ior__()` to extend all the methods that can mutate a dictionary.
    While this is a pile of work to create, the work is encapsulated in a dictionary
    subclass that we can use in our application. This subclass is completely compatible
    with built-in classes; it implements many methods we didn't write, and it has
    one extra feature we did write.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了初始化用例，但——仍然——没有涵盖所有可以更新映射的方法。我们仍然需要实现`update()`、`setdefault()`、`__or__()`和`__ior__()`来扩展所有可以修改字典的方法。虽然创建这些方法需要大量工作，但这些工作被封装在一个字典子类中，我们可以在我们的应用程序中使用它。这个子类与内置类完全兼容；它实现了我们没有编写的方法，并且还有一个我们编写的额外功能。
- en: We've built a more complex dictionary that extends the core features of a Python
    `dict` class. Our version adds a feature to reject duplicates. We've also touched
    on the use of `abc.ABC` (and `abc.ABCMeta`) to create abstract base classes. There
    are times when we might want to take more direct control of the mechanics of creating
    a new class. We'll turn next to metaclasses.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个更复杂的字典，它扩展了Python `dict`类的核心功能。我们的版本增加了一个拒绝重复的功能。我们还涉及了使用`abc.ABC`（以及`abc.ABCMeta`）来创建抽象基类。有时我们可能希望更直接地控制创建新类的机制。接下来，我们将转向元类。
- en: Metaclasses
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类
- en: As we noted earlier, creating a new class involves work done by the `type` class.
    The job of the `type` class is to create an empty class object so the various
    definitions and attributes assignment statements will build the final, usable
    class we need for our application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所述，创建一个新的类涉及到由`type`类执行的工作。`type`类的任务是创建一个空的类对象，这样各种定义和属性赋值语句就可以构建出我们应用所需的最终、可用的类。
- en: 'Here''s how it works:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的工作原理：
- en: '![Diagram  Description automatically generated](img/B17070_06_03.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_06_03.png)'
- en: 'Figure 6.3: How type creates MyClass'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：如何创建MyClass类型
- en: The `class` statement is used to locate the appropriate metaclass; if no special
    `metaclass=` is provided, then the `type` class is used. The `type` class will
    prepare a new, empty dictionary, called a namespace, and then the various statements
    in the class populate this container with attributes and method definitions. Finally,
    the "new" step completes creation of the class; this is generally where we can
    make our changes.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`语句用于定位适当的元类；如果没有提供特殊的`metaclass=`，则使用`type`类。`type`类将准备一个新的、空的字典，称为命名空间，然后类中的各种语句将填充这个容器，添加属性和方法定义。最后，“new”步骤完成类的创建；这通常是我们可以进行更改的地方。'
- en: 'Here''s a diagram showing how we can use a new class, SpecialMeta, to tap into
    the way `type` builds a new class for us:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个图表展示我们如何使用一个新的类，SpecialMeta，来利用`type`为我们构建新类的方式：
- en: '![Diagram  Description automatically generated](img/B17070_06_04.png)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图表描述自动生成](img/B17070_06_04.png)'
- en: 'Figure 6.4: Extending the type class'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：扩展类型类
- en: If we use the `metaclass=` option when creating a class, we change the metaclass
    that's used. In the preceding diagram, `SpecialMeta` is a subclass of the `type`
    class, and it can do some special processing for our class definitions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在创建类时使用 `metaclass=` 选项，我们将改变所使用的元类。在先前的图中，`SpecialMeta` 是 `type` 类的子类，并且它可以为我们的类定义执行一些特殊处理。
- en: While there are some clever things we can do with this technique, it's important
    to keep metaclasses in perspective. They change the way class objects are built,
    with the potential to redefine what it means to be a class. This can drastically
    shift the foundation of Pythonic object-oriented programming. It can lead to frustration
    when people reading and maintaining the code can't figure out why something works;
    it should not be undertaken lightly.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以用这个技术做一些巧妙的事情，但保持对元类的正确认识是很重要的。它们改变了类对象构建的方式，有可能重新定义了“类”的含义。这可能会极大地改变Python面向对象编程的基础。当阅读和维护代码的人无法理解为什么某些事情会起作用时，这可能会导致挫败感；不应轻率地采取这种做法。
- en: Let's look at a metaclass that builds a few small features into a class definition
    for us. Let's continue to extend the dice simulation examples from earlier in
    this chapter. We may have a number of classes of die, each an instance of the
    abstract base class `Die`. We'd like them all to have an audit log surrounding
    the `roll()` method supplied by the implementation. We'd like to track each roll
    separately, perhaps so someone can review them for their statistical validity.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个元类，它为我们把一些小特性构建到类定义中。让我们继续扩展本章前面提到的骰子模拟示例。我们可能有一系列骰子类，每个都是抽象基类 `Die`
    的一个实例。我们希望它们都拥有围绕实现提供的 `roll()` 方法的审计日志。我们希望分别跟踪每次投掷，也许这样有人可以审查它们的统计有效性。
- en: Because we don't want to force the programmers of various kinds of dice to include
    any extra or new code, we prefer to add logging to the abstract base class for
    all `Die` classes, and also adjust the concrete implementation of the `roll()`
    method to create logging output.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不想强迫各种骰子的程序员包含任何额外的或新的代码，所以我们更倾向于为所有 `Die` 类的抽象基类添加日志记录功能，并且调整 `roll()`
    方法的具体实现以创建日志输出。
- en: This is a tall order. It's made a little more challenging because we're working
    with abstract classes. This requires some care to disentangle abstract class construction
    from concrete class construction. We don't want to force programmers to change
    their concrete `Die` class definitions.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很高的要求。由于我们正在处理抽象类，这使得任务变得更加具有挑战性。这需要我们小心地区分抽象类构造和具体类构造。我们不希望强迫程序员更改他们的具体`Die`类定义。
- en: 'To solve this problem using metaclasses, we need to do three things to each
    concrete `Die`-related class that gets built:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用元类解决这个问题，我们需要对每个构建的与`Die`相关的具体类执行以下三件事：
- en: Extend the `ABCMeta` metaclass. We need to support the `@abc.abstractmethod`
    decoration, so we want all the existing metaclass features from the built-in `type`
    metaclass.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展 `ABCMeta` 元类。我们需要支持 `@abc.abstractmethod` 装饰，因此我们希望从内置的 `type` 元类中获取所有现有的元类功能。
- en: Inject a `logger` attribute into each class. It's common to have the logger
    name match the class name; this is easy to do in a metaclass. We can create the
    logger as part of the class, prior to any instances of the class being created.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`logger`属性注入到每个类中。通常，日志记录器的名称与类名相匹配；在元类中这样做很容易。我们可以在创建类的任何实例之前，将日志记录器作为类的一部分创建。
- en: Wrap the concrete `roll()` method into a function that uses the programmer's
    supplied `roll()` method, but also writes a message to the logger. This is similar
    to the way a method decorator works.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将混凝土的 `roll()` 方法封装成一个函数，该函数使用程序员提供的 `roll()` 方法，同时向记录器写入消息。这与方法装饰器的工作方式类似。
- en: 'The metaclass definition needs a `__new__()` method to make slight adjustments
    to the way the final class is built. We don''t need to extend the `__prepare__()`
    method. Our `__new__()` method will use `abc.ABCMeta.__new__()` to build the final
    class object. This `ABCMeta` class will decide if the object is concrete or remains
    abstract because `roll()` was not defined:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 元类定义需要使用 `__new__()` 方法对最终类的构建方式做轻微调整。我们不需要扩展 `__prepare__()` 方法。我们的 `__new__()`
    方法将使用 `abc.ABCMeta.__new__()` 来构建最终的类对象。这个 `ABCMeta` 类将决定对象是具体的还是保持抽象状态，因为 `roll()`
    方法尚未定义：
- en: '[PRE41]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `__new__()` method is given a bewildering pile of argument values:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()` 方法接收一大堆令人困惑的参数值：'
- en: The `metaclass` parameter is a reference to the metaclass doing the work. Python
    doesn't generally create and use instances of metaclasses. Instead, the metaclass
    itself is passed as a parameter to each method. It's a bit like the `self` value
    provided to an object, but it's the class, not an instance of a class.
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`元类`参数是对执行工作的元类的引用。Python 通常不会创建和使用元类的实例。相反，元类本身被作为参数传递给每个方法。这有点像提供给对象的`self`值，但它是类，而不是类的实例。'
- en: The `name` parameter is the name of the target class, taken from the original
    `class` statement.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`参数是目标类的名称，取自原始的`class`语句。'
- en: The `bases` parameter is the list of base classes. These are the mixins, sorted
    into method resolution order. In this example, it will be the superclass we'll
    define that uses this metaclass, `DieLog`, shown shortly below.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bases`参数是基类列表。这些是混入类，按照方法解析顺序排序。在这个例子中，它将是我们将定义的、使用此元类的超类，即下面将要展示的`DieLog`。'
- en: The `namespace` parameter is a dictionary that was started by the `__prepare__()`
    method of the built-in `type` class. The dictionary was updated when the body
    of the class was executed; `def` statements and assignment statements will create
    items in this dictionary. When we get to the `__new__()` method, the methods (and
    variables) of the class are staged here, waiting to build the final class object.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namespace`参数是一个由内置`type`类的`__prepare__()`方法启动的字典。当类体执行时，该字典会被更新；`def`语句和赋值语句将在该字典中创建条目。当我们到达`__new__()`方法时，类的（方法和变量）将在这里进行编排，等待构建最终的类对象。'
- en: The `kwargs` parameter will have any keyword arguments provided as part of the
    class definition. If we used a statement like `class D6L(DieLog, otherparam="something")`
    to create a new class, then the `otherparam` would be one of the `kwargs` to `__new__()`.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kwargs` 参数将包含作为类定义一部分提供的任何关键字参数。如果我们使用类似 `class D6L(DieLog, otherparam="something")`
    的语句来创建一个新类，那么 `otherparam` 将会是传递给 `__new__()` 的 `kwargs` 之一。'
- en: The `__new__()` method must return the new class definition. Generally, this
    is the result of using the superclass `__new__()` method to build the class object.
    In our case, the superclass method is `abc.ABCMeta.__new__()`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()` 方法必须返回新的类定义。通常，这是通过使用超类 `__new__()` 方法来构建类对象的结果。在我们的例子中，超类方法是 `abc.ABCMeta.__new__()`。'
- en: Within this method, the `if` statement checks to see if the class being built
    defined the needed `roll()` method. If the method is marked with the `@abc.abstractmethod`
    decorator, then the method will have an attribute of `__isabstractmethod__` and
    the value of the attribute will be `True`. For a concrete method – without a decorator
    – there will be no `__isabstractmethod__` attribute value. The condition confirms
    there's a `roll()` method and if that `roll()` method is concrete.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，`if` 语句检查正在构建的类是否定义了所需的 `roll()` 方法。如果该方法被标记为 `@abc.abstractmethod` 装饰器，那么该方法将有一个属性
    `__isabstractmethod__`，并且该属性的值将是 `True`。对于一个具体的方法——没有装饰器——将不会有 `__isabstractmethod__`
    属性值。这个条件确认存在一个 `roll()` 方法，并且如果该 `roll()` 方法是具体的。
- en: For classes with a concrete `roll()` method, we'll add `"logger"` to the namespace
    that was built, providing a default value of an appropriately named logger. If
    a logger is already present, we'll leave it in place.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有具体 `roll()` 方法的班级，我们将在构建的命名空间中添加 `"logger"`，提供一个名为适当的默认日志记录器。如果已经存在日志记录器，我们将保持其位置不变。
- en: Next, `namespace["roll"]` picks out the function defined in the concrete class,
    the `roll` method. We'll define a replacement method, `logged_roll`. To be sure
    the new `logged_roll()` method looks like the original method, we've used the
    `@wraps` decorator. This will copy the original method name and docstring onto
    the new method, making it look like the definition originally present in the class.
    This is put back into the namespace so it can be incorporated into the new class.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`namespace["roll"]` 从具体类中挑选出定义的函数，即 `roll` 方法。我们将定义一个替换方法，`logged_roll`。为了确保新的
    `logged_roll()` 方法看起来像原始方法，我们使用了 `@wraps` 装饰器。这将复制原始方法名称和文档字符串到新方法中，使其看起来像原本在类中存在的定义。然后，这个定义被放回命名空间中，以便它可以被新类所包含。
- en: Finally, we evaluate `abc.ABCMeta.__new__()` with the metaclass, the class name,
    the base classes, and the namespace that we modified if there was a concrete implementation
    of the `roll()` method. The `__new__()` operation finalizes the class, doing all
    the original Python housekeeping.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用元类、类名、基类以及如果存在具体的`roll()`方法实现，我们修改的命名空间来评估`abc.ABCMeta.__new__()`。`__new__()`操作最终确定类，执行所有原始的Python家务工作。
- en: 'It can be awkward to use a metaclass; for this reason, it''s common to provide
    a superclass that uses the metaclass. This means our application can extend the
    superclass without having to fuss around with an extra `metaclass=` parameter
    in the class definition:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用元类可能会有些尴尬；因此，通常提供一个使用元类的超类是很常见的。这意味着我们的应用程序可以扩展超类，而无需在类定义中额外处理`metaclass=`参数：
- en: '[PRE42]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This superclass, `DieLog`, is built by the metaclass. Any subclass of this class
    will also be built by the metaclass.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这个超类`DieLog`是由元类构建的。这个类的任何子类也将由元类构建。
- en: 'Now, our application can create subclasses of `DieLog`, without having to worry
    about the details of the metaclass: we don''t have to remember to include `metaclass=`
    in the definition. Our final application classes are quite streamlined:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序可以创建`DieLog`的子类，无需担心元类的细节：我们不需要记得在定义中包含`metaclass=`。我们的最终应用程序类相当简洁：
- en: '[PRE43]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We''ve created a dice roller here that logs each roll in a logger named after
    the class. Here''s how it looks logging to the console:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里创建了一个掷骰子工具，每次掷骰的结果都会记录在一个以类命名的记录器中。以下是它向控制台记录的样子：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The details of the logging aspect of this `D6L` class are completely divorced
    from the application-specific processing of this class. We can change the metaclass
    to change details of the logging, knowing that all of the relevant application
    classes will be changed when the metaclass changes.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `D6L` 类的日志记录方面的细节与该类特定的应用处理完全分离。我们可以更改元类来更改日志记录的细节，知道当元类更改时，所有相关的应用类都将被更改。
- en: Since a metaclass changes how a class is built, there are no boundaries on the
    kinds of things a metaclass can do. The common advice is to keep the metaclass
    features very small because they're obscure. As written, the `logged_roll()` method
    of the metaclass will discard any return value from the concrete `roll()` method
    in a subclass.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元类改变了类的构建方式，因此元类可以做的事情没有界限。常见的建议是保持元类特性非常小，因为它们很晦涩。按照目前的写法，元类的`logged_roll()`方法将丢弃子类中具体`roll()`方法的任何返回值。
- en: Case study
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: We'll refine our case study in this chapter. Previously, in *Chapter 2*, *Objects
    in Python*, we talked in a vague way about loading the training data and splitting
    it into two clumps – the training set and the testing set. In *Chapter 5*, *When
    to Use Object-Oriented Programming*, we looked at ways to deserialize the source
    file into `Sample` instances.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中完善我们的案例研究。之前，在*第二章*，*Python中的对象*中，我们以模糊的方式讨论了加载数据训练集并将其分为两个部分——训练集和测试集。在*第五章*，*何时使用面向对象编程*中，我们探讨了将源文件反序列化为`Sample`实例的方法。
- en: 'In this chapter, we want to look further at this operation of using the raw
    data to create a number of `TrainingKnownSample` instances separate from a number
    of `TestingKnownSample` instances. In the previous chapter, we identified four
    cases for sample objects, shown in the following table:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们希望进一步探讨使用原始数据创建多个`TrainingKnownSample`实例的操作，这些实例与多个`TestingKnownSample`实例分开。在前一章中，我们确定了样本对象的四种情况，如下表所示：
- en: '|  | Known | Unknown |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  | 已知 | 未知 |'
- en: '| --- | --- | --- |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Unclassified | Training data | Sample waiting to be classified |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 未分类 | 训练数据 | 待分类的样本 |'
- en: '| Classified | Testing data | Classified sample |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 分类 | 测试数据 | 分类样本 |'
- en: When looking at the known samples, classified by a Botanist, we need to split
    the data into two separate classes. We'll use a variety of approaches to do this,
    including a number of overloaded comparison operations.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看由植物学家分类的已知样本时，我们需要将数据分成两个独立的类别。我们将采用多种方法来完成这项工作，包括一系列重载的比较操作。
- en: 'Our training data sorting can be approached from two distinct directions:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的训练数据排序可以从两个不同的方向来处理：
- en: We can ingest all the raw data, then distribute it into two collections for
    later use
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以摄入所有原始数据，然后将它们分配到两个集合中以便后续使用
- en: During the process of ingestion, we can make selections among the collections
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在摄入过程中，我们可以在集合之间进行选择
- en: The net effect is the same. Working with an entire collection can be relatively
    simple, while using a great deal of memory. Processing items individually can
    be more complex, without requiring as much memory.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 净效果是相同的。处理整个集合可能相对简单，但会消耗大量内存。逐个处理项目可能更复杂，但所需的内存较少。
- en: We'll start by building some sophisticated collections. The first will be a
    list that tracks two sublists.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先构建一些复杂的集合。第一个将是一个跟踪两个子列表的列表。
- en: Extending the list class with two sublists
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用两个子列表扩展列表类
- en: We can extend the built-in `list` class to add some features. It's important
    to note that extending built-in types can be tricky because the type hints for
    these types are sometimes surprisingly complex.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展内置的`list`类以添加一些功能。需要注意的是，扩展内置类型可能会很棘手，因为这些类型的类型提示有时会出人意料地复杂。
- en: 'Python''s built-in structures like `list` have a variety of initialization
    alternatives:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的内置结构如 `list` 有多种初始化选项：
- en: We can use `list()` to create an empty list
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`list()`来创建一个空列表
- en: We can use `list(x)` to create a list from an iterable source of data
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用`list(x)`从可迭代的源数据创建一个列表
- en: 'To make this clear to **mypy**, we need to use the `@overload` decorator; this
    will expose the two distinct ways the `list` class `__init__()` method is used:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让**mypy**清楚这一点，我们需要使用`@overload`装饰器；这将展示`list`类`__init__()`方法被使用的两种不同方式：
- en: '[PRE45]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We've defined two overloads for the `__init__()` method; these are the formalisms
    to tell **mypy** what our intent is. The first overload is `__init__()` with no
    positional parameters. This should create an empty list of `SampleDict` objects.
    The second overload is `__init__()` with an iterable source of `SampleDict` objects
    as the only positional parameter. The lonely `*` separates parameters where the
    argument value can be provided positionally from parameters where the argument
    value must be provided as a keyword. The `training_subset` parameter will stand
    out from the ordinary list-like initializer.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`__init__()`方法定义了两种重载；这些是告诉**mypy**我们意图的形式。第一种重载是没有任何位置参数的`__init__()`。这应该创建一个空的`SampleDict`对象列表。第二种重载是`__init__()`，它只有一个位置参数，即`SampleDict`对象的可迭代来源。孤独的`*`将参数分为两种：一种是可以按位置提供参数值的参数，另一种必须作为关键字提供参数值的参数。`training_subset`参数将与普通的列表初始化器明显不同。
- en: The third definition is the actual implementation. This definition of the `__init__()`
    method lacks the `@overload` decorator. The implementation uses the superclass'`__init__()`
    method to build a `List[SampleDict]` object. A subclass might want to extend this
    method to partition the data when creating a `SamplePartition` object.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个定义是实际实现。这个`__init__()`方法的定义缺少`@overload`装饰器。实现使用超类的`__init__()`方法来构建一个`List[SampleDict]`对象。子类可能想要扩展这个方法，以便在创建`SamplePartition`对象时对数据进行分区。
- en: The intent is to be able to subclass this with a class having a name like `SomeSamplePartition`,
    and use `data = SomeSamplePartition(data, training_subset=0.67)` to create an
    object, `data`, which is a list with a few extra features.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 目的是能够使用一个类似 `SomeSamplePartition` 的类来子类化，并通过 `data = SomeSamplePartition(data,
    training_subset=0.67)` 创建一个对象 `data`，这个对象是一个包含一些额外功能的列表。
- en: Since this is a superclass, we haven't provided a definition for the `training`
    or `testing` properties. Each algorithm can have different implementations of
    the methods that provide values for these attributes.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个超类，我们没有为`training`或`testing`属性提供定义。每个算法都可以有不同的方法实现，以提供这些属性的值。
- en: 'This depends on the following `SampleDict` definition:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这取决于以下`SampleDict`定义：
- en: '[PRE46]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This tells **mypy** that we're working with a dictionary that has only the five
    supplied keys and no others. This can support some validation to check that literal
    key values match this set.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 **mypy** 我们正在使用一个只包含五个提供的键而没有其他键的字典。这可以支持一些验证来检查字面量键值是否与这个集合匹配。
- en: Let's look at some subclasses that provide different partitioning strategies.
    We'll start with one that shuffles and cuts, like a deck of cards.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看一些提供不同分区策略的子类。我们将从一个像一副扑克牌那样洗牌和切割的子类开始。
- en: A shuffling strategy for partitioning
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区的一种洗牌策略
- en: One alternative is to shuffle and cut a list – precisely the way a deck of cards
    is shuffled and cut before a game. We can use `random.shuffle()` to handle the
    randomized shuffling. The cut is – in a way – a hyperparameter. How large should
    the training set be compared to the testing set? Suggestions for knowledgeable
    data scientists include 80% to 20%, 67% to 33%, and an even 50% to 50% split.
    Because expert opinion varies, we need to provide a way for a scientist to adjust
    the partition ratio.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是对列表进行洗牌和切割——这正是游戏开始前一副牌被洗牌和切割的方式。我们可以使用`random.shuffle()`来处理随机洗牌。切割——从某种意义上说——是一个超参数。训练集应该比测试集大多少？对于知识渊博的数据科学家的一些建议包括80%到20%，67%到33%，以及50%到50%的均等分割。由于专家意见不一，我们需要提供一个方法让科学家调整分割比例。
- en: 'We''ll make the split a feature of the class. We can create separate subclasses
    to implement alternative splits. Here''s a shuffling implementation:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使拆分成为类的一个特性。我们可以创建独立的子类来实现不同的拆分。下面是一个洗牌实现的示例：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since we're extending the `SamplePartition` superclass, we can leverage the
    overloaded `__init__()` method definitions. For this subclass, we need to provide
    a concrete implementation compatible with the superclass.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在扩展`SamplePartition`超类，我们可以利用重载的`__init__()`方法定义。对于这个子类，我们需要提供一个与超类兼容的具体实现。
- en: The two properties, `training` and `testing`, both make use of an internal `shuffle()`
    method. This method uses the split attribute to make sure it will shuffle the
    samples exactly one time. In addition to tracking whether or not the data is shuffled,
    the `self.split` attribute also shows where to split the samples into training
    and test subsets.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个属性，`training`和`testing`，都使用了内部的`shuffle()`方法。该方法使用split属性来确保它将样本恰好打乱一次。除了跟踪数据是否被打乱之外，`self.split`属性还显示了如何将样本分割成训练集和测试集子集。
- en: 'The `training` and `testing` properties also use Python list slicing to subdivide
    the raw `SampleDict` objects, and build useful `TrainingKnownSample` and `TestingKnownSample`
    objects from the raw data. These rely on a list comprehension to apply a class
    constructor, for example `TrainingKnownSample`, to the dictionary of row values
    in a subset of the list, `self[: self.split]]`. The list comprehension saves us
    from building a list with a `for` statement and a bunch of `append()` operations.
    We''ll look at even more variations of this in *Chapter 10*, *The Iterator Pattern*.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`训练`和`测试`属性也使用Python列表切片来细分原始的`SampleDict`对象，并从原始数据中构建有用的`TrainingKnownSample`和`TestingKnownSample`对象。这些操作依赖于列表推导式来应用类构造函数，例如`TrainingKnownSample`，到列表子集的行值字典中，`self[:
    self.split]]`。列表推导式使我们免于使用`for`语句和一系列的`append()`操作来构建列表。我们将在第10章，*迭代器模式*中看到更多这种操作的变体。'
- en: Because this depends on the `random` module, the results are difficult to predict,
    making testing needless complex. Many data scientists want the data shuffled,
    but they also want reproducible results. By setting `random.seed()` to a fixed
    value, we can create random, but reproducible, collections of samples.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这依赖于`random`模块，结果难以预测，使得测试变得没有必要复杂。许多数据科学家希望数据被打乱，但他们也希望得到可重复的结果。通过将`random.seed()`设置为固定值，我们可以创建随机但可重复的样本集合。
- en: 'This works as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这样工作的：
- en: '[PRE48]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With a random seed of `42`, we always get the same two samples in the testing
    set.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用随机种子`42`，我们在测试集中总是得到相同的两个样本。
- en: 'This allows us to build the initial list in a variety of ways. We can, for
    example, append data items to an empty list, like this:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够以多种方式构建初始列表。例如，我们可以将数据项追加到一个空列表中，如下所示：
- en: '[PRE49]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The `SamplePartition` subclass of `list` will inherit all the methods of the
    parent class. This allows us to make changes to the internal state of the list
    prior to extracting the training and testing subsets. We've added the sizing parameter
    as a keyword-only parameter to make sure it's clearly separated from the list
    object used to initialize the list.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`SamplePartition` 子类继承自 `list` 类的所有方法。这使得我们能够在提取训练集和测试集之前对列表的内部状态进行修改。我们添加了大小参数作为关键字参数，以确保它与用于初始化列表的列表对象明确区分开来。'
- en: An incremental strategy for partitioning
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分区的一个增量策略
- en: We have an alternative to splitting a single list after it's been built. Instead
    of extending the `list` class to provide two sub-lists, we can reframe the problem
    slightly. Let's define a subclass of `SamplePartition` that makes a random choice
    between testing and training on each `SampleDict` object that is presented via
    initialization, or the `append()` or `extend()` methods.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在构建单个列表之后有一个替代方案。而不是扩展`list`类以提供两个子列表，我们可以稍微重新定义问题。让我们定义一个`SamplePartition`的子类，该子类在通过初始化、`append()`或`extend()`方法呈现的每个`SampleDict`对象上，在测试和训练之间做出随机选择。
- en: 'Here''s an abstraction that summarizes our thinking on this. We''ll have three
    methods for building a list, and two properties that will provide the training
    and testing sets, as below. We don''t inherit from `List` because we''re not providing
    any other list-like features, not even `__len__()`. The class has only five methods,
    as shown:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个抽象，总结了我们对这个问题的思考。我们将有三种构建列表的方法，以及两个属性将提供训练和测试集，如下所示。我们不继承自`List`，因为我们没有提供任何其他类似列表的功能，甚至不包括`__len__()`。这个类只有五个方法，如下所示：
- en: '[PRE50]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This definition has no concrete implementations. It provides five placeholders
    where methods can be defined to implement the necessary dealing algorithm. We've
    changed the definition of the `training_subset` parameter slightly from the previous
    example. Here, we've defined it as two integers. This lets us count and deal incrementally.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义没有具体的实现。它提供了五个占位符，可以在其中定义方法以实现必要的处理算法。我们略微修改了`training_subset`参数的定义，与之前的示例相比。在这里，我们将其定义为两个整数。这使得我们可以逐个计数和处理。
- en: 'Here''s how we can extend this to create a concrete subclass that wraps two
    internal collections. We''ll break this into two parts – first, building the collections,
    and then building the properties to expose the values of the collections:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何扩展这个方法来创建一个具体的子类，该子类封装了两个内部集合。我们将将其分为两个部分——首先，构建集合，然后构建属性以暴露集合的值：
- en: '[PRE51]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We've defined an initializer that sets the initial state of two empty collections.
    Then, it uses the `extend()` method to build the collections from a source iterable,
    if it's provided.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个初始化器，用于设置两个空集合的初始状态。然后，如果提供了源可迭代对象，它将使用`extend()`方法从该对象构建集合。
- en: The `extend()` method relies on the `append()` method to allocate a `SampleDict` instance
    to either the testing or training subsets. The `append()` method actually does
    all the work. It counts the items and makes a decision based on some modulo arithmetic.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`extend()` 方法依赖于 `append()` 方法来为测试集或训练集分配一个 `SampleDict` 实例。实际上，`append()`
    方法完成了所有的工作。它会计算项目数量，并根据一些模运算做出决策。'
- en: The training subset is defined as a fraction; we've shown it defined as a tuple,
    (8, 10), with a comment suggesting this means 8/10 or 80% training, the remainder
    for testing. For a given counter value, *c*, if *c* *< 8 (mod 10)*, we'll call
    it training, while if *c* *≥* *8 (mod 10)*, we'll call it testing.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 训练子集被定义为分数；我们已将其定义为元组（8，10），并在注释中说明这表示8/10或80%用于训练，剩余部分用于测试。对于给定的计数器值*c*，如果*c*
    *< 8 (mod 10)*，我们将其称为训练，而如果*c* *≥* *8 (mod 10)*，我们将其称为测试。
- en: 'Here are the remaining two methods that are used to expose the values of the
    two internal list objects:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于揭示两个内部列表对象值的剩余两种方法：
- en: '[PRE52]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: To an extent, these can be seen as useless. It's common in Python to simply
    name the two internal collections `self.training` and `self.testing`. If we use
    attributes, we don't really need these property methods.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在一定程度上，这些可能被视为无用。在Python中，通常简单地命名两个内部集合为`self.training`和`self.testing`是很常见的。如果我们使用属性，实际上并不需要这些属性方法。
- en: We've seen two class designs to partition the source data into testing and training
    subsets. One version relies on random numbers for shuffling, while the other doesn't
    rely on a random number generator. There are, of course, other combinations of
    random-based selection and incremental distribution of items that we've left as
    exercises for the reader.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了两种将源数据划分为测试集和训练集的类设计。一种版本依赖于随机数进行洗牌，而另一种则不依赖于随机数生成器。当然，还有其他基于随机选择的组合和项目增量分布的组合，我们将这些留作读者的练习。
- en: Recall
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回忆
- en: 'Here are some of the key points in this chapter:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键点如下：
- en: Using abstract base class definitions is a way to create class definitions with
    placeholders. This is a handy technique, and can be somewhat clearer than using
    `raise NotImplementedError` in unimplemented methods.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象基类定义是一种创建带有占位符的类定义的方法。这是一个实用的技巧，并且在未实现的方法中使用`raise NotImplementedError`时，它可能更加清晰。
- en: ABCs and type hints provide ways to create class definitions. An ABC is a type
    hint that can help to clarify the essential features we need from an object. It's
    common, for example, to use `Iterable[X]` to emphasize that we need one aspect
    of a class implementation.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ABCs和类型提示提供了创建类定义的方法。ABC是一种类型提示，可以帮助我们明确从对象中需要的核心特性。例如，使用`Iterable[X]`来强调我们需要类实现的一个方面是很常见的。
- en: The `collections.abc` module defines abstract base classes for Python's built-in
    collections. When we want to make our own unique collect class that can integrate
    seamlessly with Python, we need to start with the definitions from this module.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: The `collections.abc` 模块定义了 Python 内置集合的抽象基类。当我们想要创建一个可以无缝集成到 Python 中的独特收集类时，我们需要从这个模块的定义开始。
- en: Creating your own abstract base class leverages the `abc` module. The `abc.ABC`
    class definition is often a perfect starting point for creating an abstract base
    class.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的抽象基类可以利用 `abc` 模块。`abc.ABC` 类定义通常是创建抽象基类的完美起点。
- en: The bulk of the work is done by the `type` class. It's helpful to review this
    class to understand how classes are created by the methods of `type`.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大部分工作是由`type`类完成的。回顾这个类有助于理解`type`类是如何通过方法创建类的。
- en: Python operators are implemented by special methods in classes. We can – in
    a way – "overload" an operator by defining appropriate special methods so that
    the operator works with objects of our unique class.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python运算符通过类中的特殊方法实现。我们可以在某种程度上通过定义适当特殊方法来“重载”运算符，使得运算符可以与我们的独特类对象一起工作。
- en: Extending built-ins is done via a subclass that modifies the behavior of a built-in
    type. We'll often use `super()` to leverage the built-in behavior.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展内置类型是通过一个修改内置类型行为的子类来完成的。我们通常会使用 `super()` 来利用内置行为。
- en: We can implement our own metaclasses to change – in a fundamental way – how
    Python class objects are built.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以自定义元类来以根本的方式改变 Python 类对象的构建方式。
- en: Exercises
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: We've looked at the concept of defining abstract classes to define some – but
    not all – common features of two objects. Take a quick look around to see how
    you can apply these principles to your own work. A script can often be restated
    as a class; each major step of the work a separate method. Do you have similar-looking
    scripts that – perhaps – share a common abstract definition? Another place to
    find things that are partially related is in the classes that describe data files.
    A spreadsheet file often has small variations in layout; this suggests they have
    a common abstract relationship, but a method needs to be part of an extension
    to handle the variations in the layouts.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经探讨了定义抽象类来定义两个对象的一些——但不是所有——共同特性的概念。快速环顾四周，看看你如何将这些原则应用到自己的工作中。一个脚本通常可以被重新表述为一个类；工作的每个主要步骤对应一个独立的方法。你是否有看起来相似的脚本——可能——共享一个共同的抽象定义？另一个可以找到部分相关内容的地方是在描述数据文件的类中。电子表格文件在布局上通常有一些小的变化；这表明它们有一个共同的抽象关系，但需要一个方法作为扩展的一部分来处理布局上的变化。
- en: When we think about the `DDice` class, there's yet another enhancement that
    would be nice. Right now, the operators are all defined for `DDice` instances
    only. In order to create a hand of dice, we need to – somewhere – use a `DDice`
    constructor. This leads to `3*DDice(D6)+2`, which seems to be needlessly wordy.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们思考`DDice`类时，还有一个增强功能会很好。目前，所有操作符都只针对`DDice`实例定义。为了创建一副骰子，我们需要在某个地方使用`DDice`构造函数。这导致了`3*DDice(D6)+2`，这似乎是多余的冗长。
- en: 'It would be nicer to be able to write `3*d6+1`. This implies some changes to
    the design:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写 `3*d6+1` 会更好。这暗示了一些设计上的改动：
- en: Since we can't (easily) apply operators to classes, we have to work with instances
    of classes. We've assumed `d6 = D6()` was used to create a `Die` instance that
    can be an operand.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们无法（轻易地）将运算符应用于类，我们必须处理类的实例。我们假设`d6 = D6()`被用来创建一个`Die`实例，它可以作为操作数。
- en: The `Die` class needs a `__mul__()` method and an `__rmul__()` method. When
    we multiply a `Die` instance by an integer, this will create a `DDice` instance
    populated with the die's type, `DDice(type(self))`. This is because `DDice` expects
    a type and it creates its own instances from the type.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Die` 类需要一个 `__mul__()` 方法和一个 `__rmul__()` 方法。当我们用一个整数乘以一个 `Die` 实例时，这将创建一个包含骰子类型的
    `DDice` 实例，即 `DDice(type(self))`。这是因为 `DDice` 预期一个类型，并从该类型创建自己的实例。'
- en: This creates a circular relationship between `Die` and `DDice`. It doesn't present
    any real problems because both definitions are in the same module. We can use
    strings in the type hints, so having a `Die` method use a type hint of `-> "DDice"`
    works out nicely. The **mypy** program can use strings for forward references
    to types that haven't been defined yet.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这在`Die`和`DDice`之间建立了一个循环关系。由于这两个定义都在同一个模块中，所以这不会带来任何真正的问题。我们可以在类型提示中使用字符串，因此让`Die`方法使用类型提示`->
    "DDice"`效果很好。**mypy**程序可以使用字符串作为对尚未定义的类型的前向引用。
- en: Now, look back over some of the examples we looked at in previous chapters.
    Can we leverage an abstract class definition to perhaps simplify the various ways
    in which `Sample` instances need to behave?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回顾一下我们在前几章中讨论的一些示例。我们能否利用抽象类定义来简化`Sample`实例需要表现的各种行为方式？
- en: Look at the `DieMeta` example. As written, the `logged_roll()` method of the
    metaclass will discard any return value from the concrete `roll()` method in a
    subclass. This may not be appropriate in all cases. What kind of rewrite is required
    to make the metaclass method wrapper return a value from the wrapped method? Does
    this change the `DieLog` superclass definition?
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`DieMeta`示例。按照目前的写法，元类的`logged_roll()`方法会丢弃子类中`roll()`具体方法的任何返回值。这可能在所有情况下都不合适。需要如何重写才能使元类方法包装器从包装的方法返回一个值？这会改变`DieLog`超类定义吗？
- en: Can we use the superclass to provide a logger? (It seems like the answer is
    a resounding "yes.")
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用超类来提供一个日志记录器吗？（答案似乎是一个响亮的“是的。”）
- en: 'More importantly, can we use a decorator to provide logging for a concrete
    `roll()` method? Write this decorator. Then consider whether or not we can trust
    developers to include this decorator. Should we trust other developers to use
    the framework correctly? While we can imagine developers forgetting to include
    the decorator, we can also imagine unit tests to confirm that log entries are
    written. Which seems better: a visible decorator with a unit test or a metaclass
    that tweaks code invisibly?'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们能否使用装饰器为具体的`roll()`方法提供日志记录功能？编写这个装饰器。然后考虑我们是否可以信任开发者包含这个装饰器。我们应该信任其他开发者正确使用框架吗？虽然我们可以想象开发者会忘记包含装饰器，但我们也可以想象单元测试来确认日志条目的写入。哪种方式更好：一个可见的装饰器加上单元测试，还是一种无形地调整代码的元类？
- en: In the case study, we defined the testing and training properties as `Iterable[SampleDict]`
    instead of `List[SampleDict]`. When we look at `collections.abc`, we see that
    a `List` is a `Sequence` that is a subclass of the `Iterable` base class. Can
    you see advantages to distinguishing between these three levels of abstraction?
    If `Iterable` works in general, should we always use iterables? What aspects distinguish
    `Sequence` from `Iterable`? Do the different collections of features have any
    impact on the classes in the case study?
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在案例研究中，我们将测试和训练属性定义为 `Iterable[SampleDict]` 而不是 `List[SampleDict]`。当我们查看 `collections.abc`
    时，我们看到 `List` 是一个 `Sequence`，它是 `Iterable` 基类的一个子类。你能看到区分这三个抽象层次的优势吗？如果 `Iterable`
    在一般情况下都适用，我们是否应该总是使用可迭代对象？`Sequence` 与 `Iterable` 有哪些区别？不同的特征集合对案例研究中的类是否有影响？
- en: Summary
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we focused on identifying objects, especially objects that
    are not immediately apparent; objects that manage and control. Objects should
    have both data and behaviors, but properties can be used to blur the distinction
    between the two. The DRY principle is an important indicator of code quality,
    and inheritance and composition can be applied to reduce code duplication.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们专注于识别对象，尤其是那些不是立即显而易见的对象；那些管理和控制的对象。对象应具备数据和行为，但属性可以被用来模糊两者之间的区别。DRY原则是代码质量的重要指标，继承和组合可以用来减少代码重复。
- en: In the next two chapters, we'll cover several of the built-in Python data structures
    and objects, focusing on their object-oriented properties and how they can be
    extended or adapted.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将介绍几个内置的Python数据结构和对象，重点关注它们的面向对象特性以及它们如何被扩展或适应。
