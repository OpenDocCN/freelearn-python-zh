- en: Accessing and Mining Data from Network
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从网络中访问和挖掘数据
- en: Looking back, we now have a fair idea of the basics of writing Python scripts
    and how to get meaningful data out of information. We have covered how to write
    Python scripts, interact with network devices, and have also worked on the basics
    of PowerShell so that we can work with both PowerShell and Python scripts. Now
    we will move towards a deeper understanding of using Python by looking at various
    examples. In this chapter we will focus on working with various Network devices
    to dig or fetch relevant information from devices, working on that information
    to create new configurations and pushing it back to the devices for added or enhanced
    functionality.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，我们现在对编写Python脚本和如何从信息中获取有意义的数据有了相当的了解。我们已经介绍了如何编写Python脚本，与网络设备交互，并且还研究了PowerShell的基础，以便我们可以使用PowerShell和Python脚本。现在，我们将通过查看各种示例来深入了解Python的使用。在本章中，我们将专注于与各种网络设备一起工作，以挖掘或从设备中获取相关信息，处理这些信息以创建新的配置，并将其推回设备以增加或增强功能。
- en: We will work on some common scenarios that we may face and try to solve them
    with Python. These examples or scenarios can be extended depending on a programmer's
    needs, and can be used as a reference to achieve automation in complex tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一些我们可能遇到的一些常见场景，并尝试用Python来解决它们。这些示例或场景可以根据程序员的实际需求进行扩展，并可作为参考以实现复杂任务的自动化。
- en: 'Some of the key concepts we will be covering are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍的一些关键概念如下：
- en: Device configuration
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备配置
- en: Multi-vendor environments
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多供应商环境
- en: IPv4 to IPv6 conversion
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IPv4到IPv6的转换
- en: Office/DC relocations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 办公室/数据中心搬迁
- en: Site rollouts
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 站点推广
- en: BYOD configs for switches
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 交换机BYOD配置
- en: Device OS upgrades
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备操作系统升级
- en: IP configs/interface parsing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IP配置/接口解析
- en: Device configurations
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备配置
- en: 'We need to deploy three routers with a standard base configuration. The base
    configuration remains the same on each router, but as each router is different,
    we need to automate the generation of the three config files for each router.
    The assumption is that all the routers have a standard hardware configuration
    with the same types of ports:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要部署三个具有标准基本配置的路由器。基本配置在每个路由器上保持不变，但由于每个路由器都不同，我们需要自动化生成每个路由器的三个配置文件。假设所有路由器都具有标准硬件配置，具有相同类型的端口：
- en: '![](img/d50bf4ba-cbd3-4e52-b0fc-0259d1dd9c06.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d50bf4ba-cbd3-4e52-b0fc-0259d1dd9c06.jpg)'
- en: 'As we can see in the diagram, routers R1, R2, and R3 have the following cabling:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在图中所见，路由器R1、R2和R3的布线如下：
- en: R1 `f1/0` (FastEthernet1/0) connected R2 `f1/0`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R1 `f1/0`（快速以太网1/0）连接到R2 `f1/0`
- en: R1 `f0/0` connected to R3 `f0/0`
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R1 `f0/0` 连接到R3 `f0/0`
- en: R2 `f0/1` connected to R3 `f0/1`
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R2 `f0/1` 连接到R3 `f0/1`
- en: 'The standard config or template is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 标准配置或模板如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Adding some more complexity, we need to ensure the `name-server` is different
    for each router. If each router is going to be deployed in different networks,
    here is the mapping that we want:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 增加一些复杂性，我们需要确保每个路由器的`名称服务器`不同。如果每个路由器将被部署在不同的网络中，这是我们想要的映射：
- en: R1 -> hostname testindia
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R1 -> 主机名 testindia
- en: R2 -> hostname testusa
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R2 -> 主机名 testusa
- en: R3 -> hostname testUK
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: R3 -> 主机名 testUK
- en: 'The logging host and name server will depend upon the region, so the mapping
    will be as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 日志主机和名称服务器将取决于区域，因此映射如下：
- en: '**India router**: logserver (1.1.1.1) and nameserver (1.1.1.2)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**印度路由器**：日志服务器（1.1.1.1）和名称服务器（1.1.1.2）'
- en: '**USA router**: logserver (2.1.1.1) and nameserver (2.1.1.2)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**美国路由器**：日志服务器（2.1.1.1）和名称服务器（2.1.1.2）'
- en: '**UK router**: logserver (3.1.1.1) and nameserver (3.1.1.2)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**英国路由器**：日志服务器（3.1.1.1）和名称服务器（3.1.1.2）'
- en: 'The code to perform the requested task is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行请求任务的代码如下：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first list is a dictionary that defines the logging host and nameserver
    config based upon the region. The `standardtemplate` variable is used to store
    the template. If we have a multi-line value that needs to be stored in a variable,
    we can use the three-quote format as we see in the preceding example.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个列表是一个字典，它根据区域定义了日志主机和名称服务器配置。`standardtemplate`变量用于存储模板。如果我们需要将多行值存储在变量中，我们可以使用前面示例中看到的三引号格式。
- en: 'Now, as we currently know the generic or default hostnames, we can just parse
    through each of the current hostnames, and, based upon the hostname values, generate
    the config. This output can be saved onto a file or can be directly generated
    from the script and pasted onto the router for the basic configuration. Similarly,
    we can enhance this by adding the IP addresses shown in the next example in the
    format `<ipaddress>` `<subnet mask`>:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们目前知道通用的或默认的主机名，我们可以逐个解析当前的主机名，并根据主机名值生成配置。此输出可以保存到文件中，也可以直接从脚本生成并粘贴到路由器上进行基本配置。同样，我们可以通过添加下一个示例中显示的IP地址来增强此脚本，格式为`<ipaddress>`
    `<subnet mask>`：
- en: 'testindia f1/0: `10.0.0.1` `255.0.0.0`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'testindia f1/0: `10.0.0.1` `255.0.0.0`'
- en: 'testusa  f1/0: `10.0.0.2` `255.0.0.0`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'testusa f1/0: `10.0.0.2` `255.0.0.0`'
- en: 'testindia f0/0: `11.0.0.1` `255.0.0.0`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'testindia f0/0: `11.0.0.1` `255.0.0.0`'
- en: 'testUK f0/0: `11.0.0.2` `255.0.0.0`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'testUK f0/0: `11.0.0.2` `255.0.0.0`'
- en: 'testusa f0/1: `12.0.0.1` `255.0.0.0`'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'testusa f0/1: `12.0.0.1` `255.0.0.0`'
- en: 'testUK f0/1: `12.0.0.2` `255.0.0.0`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'testUK f0/1: `12.0.0.2` `255.0.0.0`'
- en: 'The code to perform this task is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此任务的代码如下：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this case, we define a function that has a standard interface template. The
    template is now modified with the specific IP addresses and updated depending
    upon the calling value in the function (which is the router name). Also, we remove
    the unused lines by replacing them with a none value denoted by two double quotes
    `""` without any spaces between them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个具有标准接口模板的函数。现在，该模板已根据函数中的调用值（即路由器名称）进行了修改，并进行了更新。同时，我们通过用两个双引号`""`（之间没有空格）表示的无用行替换它们来删除未使用的行。
- en: 'Once we have the generated config, we can use a simple file handling operation
    to save it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了生成的配置，我们可以使用简单的文件处理操作来保存它：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can see, the output for both the generic template and interface configuration
    can be concatenated or added to a variable named `myfinaloutput`, and that is
    now being saved in a file called `myrouterconfig.txt` in the `C:\check` folder.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，通用模板和接口配置的输出可以连接或添加到名为`myfinaloutput`的变量中，现在它被保存在`C:\check`文件夹中的名为`myrouterconfig.txt`的文件中。
- en: Similarly, we can enhance the script by adding more functions for specific tasks
    such as **Open Shortest Path First** (**OSPF**) configs and **Border Gateway Protocol**
    (**BGP**) configs, create enhanced and complex configurations based upon specific
    router names, and store them in separate `.txt` files that would be ready for
    the final push to the network devices.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过添加更多特定任务的功能来增强脚本，例如**开放式最短路径优先**（**OSPF**）配置和**边界网关协议**（**BGP**）配置，根据特定的路由器名称创建增强和复杂的配置，并将它们存储在单独的`.txt`文件中，以便最终推送到网络设备。
- en: Multi-vendor environments
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多供应商环境
- en: Sometimes we have many vendors participating in a configuration change or even
    creating various templates from scratch. We have vendors such as Arista, Cisco
    (IOS, NXOS), and Juniper that participate in network design in different layers.
    While dealing with situations such as this we need to be clear which layer each
    of the vendors is working on and create dynamic templates for each type of vendor
    involved.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们有许多供应商参与配置更改，甚至从头开始创建各种模板。我们有一些供应商，如Arista、Cisco（IOS、NXOS）和Juniper，在不同层次上参与网络设计。在处理此类情况时，我们需要清楚每个供应商正在工作的层次，并为每种类型的供应商创建动态模板。
- en: Taking a scenario in which we know the hardware platform and the role of the
    device (such as access layer, core layer, or **top of rack** (**TOR**) layer;
    we can generate configs quickly with very basic parameters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个场景中，如果我们知道硬件平台和设备的作用（例如接入层、核心层或**机架顶部**（**TOR**）层），我们可以使用非常基本的参数快速生成配置。
- en: If a device is in production, we can use the SNMP protocol to fetch information
    for that device and create dynamic values based upon the return type of devices.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个设备处于生产状态，我们可以使用SNMP协议获取该设备的信息，并根据设备的返回类型创建动态值。
- en: As a basic idea, we can have a look at [https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB.](https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 作为基本思路，我们可以查看[https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB.](https://wiki.opennms.org/wiki/Hardware_Inventory_Entity_MIB)
- en: This has the information on the current open standard **Managed Information
    Base** (**MIB**) that is used by SNMP to get basic device information.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含了当前开放标准**管理信息库**（**MIB**）的信息，该信息由SNMP用于获取基本设备信息。
- en: Again following good practice, we should ensure we create a generic function
    that can return the device type. Additionally, SNMP **Object Identifiers (OIDs**)
    can go deep inside to fetch information such as the current number of interfaces,
    the state of the interfaces, and even which interfaces are operational so that
    we can quickly make intelligent decisions based upon a device's current health
    or information fetched from a device.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 再次遵循良好的实践，我们应该确保我们创建一个通用的函数，该函数可以返回设备类型。此外，SNMP **对象标识符（OIDs**）可以深入到获取诸如当前接口数量、接口状态以及哪些接口是操作性的等信息，这样我们就可以根据设备的当前健康状况或从设备获取的信息快速做出智能决策。
- en: We will be installing and using the `PySNMP` libraryto query SNMP with device.
    To install it we will use the earlier method of `pip install pysnmp`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装并使用 `PySNMP` 库来查询设备上的 SNMP。为了安装它，我们将使用之前的 `pip install pysnmp` 方法。
- en: 'Basic  `PySNMP`documentation can be viewed at the following URL:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的 `PySNMP` 文档可以在以下 URL 中查看：
- en: '[https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html](https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html](https://pynet.twb-tech.com/blog/snmp/python-snmp-intro.html)'
- en: 'As an example, we will try to fetch the current version of a network device:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将尝试获取网络设备的当前版本：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The sample output for the preceding code when queried against a network device
    is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当查询网络设备时，前面代码的示例输出如下：
- en: '![](img/77a31f3a-e4ed-4b2d-832d-148e5a11a9bf.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/77a31f3a-e4ed-4b2d-832d-148e5a11a9bf.jpg)'
- en: On our test router, we enabled SNMP using the `snmp-server community public
    RO` command, and through executing the preceding Python code written, got the
    `RO` string public to read the `sysDescr.0` value, which is in Cisco standards
    the truncated show version.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的测试路由器上，我们使用 `snmp-server community public RO` 命令启用了 SNMP，并通过执行前面编写的 Python
    代码，获取了 `RO` 字符串 public 以读取 `sysDescr.0` 值，这在 Cisco 标准中是截断的显示版本。
- en: Using this method of fetching information using SNMP, we can discover what types
    of device there are and based on the output, we can make intelligent decisions
    such as generating device-specific configs without asking for device type inputs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用通过 SNMP 获取信息的方法，我们可以发现有哪些类型的设备，并根据输出，我们可以做出智能决策，例如生成特定设备的配置，而无需请求设备类型输入。
- en: 'Additionally, here is an example using PySNMP to fetch the current interfaces
    on a router:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里有一个使用 PySNMP 获取路由器当前接口的示例：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output when queried for interface info on our sample router is as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当在示例路由器上查询接口信息时的输出如下：
- en: '![](img/c0cae82a-c71e-4d5a-a69e-fe20240f9b9e.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0cae82a-c71e-4d5a-a69e-fe20240f9b9e.jpg)'
- en: As we can see, we use the `bulkCmd` method, which walks through all the SNMP
    values and returns the output for the interfaces.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用 `bulkCmd` 方法，该方法遍历所有 SNMP 值并返回接口的输出。
- en: The OID `1.3.6.1.2.1.2.2.1.2` is used as reference to fetch these values from
    the device.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: OID `1.3.6.1.2.1.2.2.1.2` 被用作参考，从设备中获取这些值。
- en: In a similar way, we can utilize the available SNMP OIDs for different vendors
    to fetch the specific information from multiple devices and proceed with our expected
    tasks based upon the returned values.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以利用不同厂商提供的可用 SNMP OIDs 从多个设备中获取特定信息，并根据返回的值执行预期的任务。
- en: IP configs/interface parsing
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IP 配置/接口解析
- en: There are many instances in which we need to parse interface configs to fetch
    useful information. For example, from a list of devices, find all the interfaces
    that are trunk. Another example could be to find all the interfaces that are `admin-shutdown`
    (shutdown on the router), or even fetch the IP address configurations from interfaces.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们需要解析接口配置以获取有用的信息。例如，从一个设备列表中找到所有 trunk 接口。另一个例子可能是找到所有 `admin-shutdown`（在路由器上关闭）的接口，或者甚至从接口中获取
    IP 地址配置。
- en: There might be instances wherein we need to find out whether particular IP addresses
    or subnets are configured on the router.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的情况，我们需要找出特定的 IP 地址或子网是否已在路由器上配置。
- en: A good way to extract any information is using regex. Regex is term that is
    used to match a particular pattern and either fetch the matched pattern or validate
    whether a certain pattern is present in the parsed text.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 提取任何信息的一个好方法是使用正则表达式。正则表达式是一个用于匹配特定模式并从解析的文本中获取匹配的模式或验证是否存在特定模式的术语。
- en: 'Here are the most basic and important regexes that are used in Python:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 中使用的一些最基本和最重要的正则表达式：
- en: '| `.` | Match any character except newline |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `.` | 匹配除换行符之外的任何字符 |'
- en: '| `^` | Match the start of the string |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `^` | 匹配字符串的开始|'
- en: '| `$` | Match the end of the string |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 匹配字符串的末尾|'
- en: '| `*` | Match 0 or more repetitions |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 匹配 0 或更多重复|'
- en: '| `+` | Match 1 or more repetitions |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 匹配 1 或更多重复|'
- en: '| `?` | Match 0 or 1 repetitions |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 匹配 0 或 1 次重复|'
- en: '| `\A` | Match only at the start of the string |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `\A` | 仅匹配字符串的开始|'
- en: '| `\b` | Match an empty string, only at the beginning or end of a word |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `\b` | 匹配一个空字符串，仅在单词的开始或结束时|'
- en: '| `\B` | Match an empty string, only when it is not at the beginning or end
    of a word |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `\B` | 匹配一个空字符串，仅在它不是单词的开始或结束时|'
- en: '| `\d` | Match digits (such as [0-9]) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 匹配数字（例如 [0-9]）|'
- en: '| `\D` | Match any non digit (such as [^0-9]) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `\D` | 匹配任何非数字字符（例如 [^0-9]）|'
- en: '| `\Z` | Match only at the end of a string |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `\Z` | 仅匹配字符串的末尾|'
- en: '| `\` | Escape special characters |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `\` | 转义特殊字符|'
- en: '| `[]` | Match a set of characters |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `[]` | 匹配一组字符|'
- en: '| `[a-z]` | Match any lowercase ASCII letter |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `[a-z]` | 匹配任何小写 ASCII 字母|'
- en: '| `[^]` | Match characters NOT in a set |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `[^]` | 匹配不在集合中的字符|'
- en: '| `A&#124;B` | Match either A or B regular expressions (non-greedy) |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `A&#124;B` | 匹配 A 或 B 正则表达式（非贪婪）|'
- en: '| `\s` | Match whitespace characters (such as [ \t\n\r\f\v]) |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `\s` | 匹配空白字符（例如 [ \t\n\r\f\v]）|'
- en: '| `\S` | Match non whitespace characters (such as [^ \t\n\r\f\v]) |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `\S` | 匹配非空白字符（例如 [^ \t\n\r\f\v]）|'
- en: '| `\w` | Match unicode word characters (such as  [a-zA-Z0-9_]) |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 匹配任何 Unicode 单词字符（例如 [a-zA-Z0-9_]）|'
- en: '| `\W` | Match any character not a Unicode word character (such as  [^a-zA-Z0-9_])
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `\W` | 匹配任何不是 Unicode 单词字符的字符（例如 [^a-zA-Z0-9_]）|'
- en: 'From this string, My IP address is `10.10.10.20` and by subnet mask is `255.255.255.255`,
    we need to get the IP address and subnet mask using regex:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个字符串中，我的 IP 地址是 `10.10.10.20`，子网掩码是 `255.255.255.255`，我们需要使用正则表达式获取 IP 地址和子网掩码：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output when the preceding code is executed is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码的输出如下：
- en: '![](img/5842005f-74fc-4bdf-8fac-fb8cd53aa768.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5842005f-74fc-4bdf-8fac-fb8cd53aa768.jpg)'
- en: As we can see, the regex for the IP address that we used is `\d+.\d+.\d+.\d+`.
    The `\d` means a digit, and `+` means multiple repetitions, because we are looking
    for a value of multiple digits separated by three dots.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们使用的 IP 地址正则表达式是 `\d+.\d+.\d+.\d+`。这里的 `\d` 表示一个数字，而 `+` 表示多次重复，因为我们正在寻找由三个点分隔的多个数字的值。
- en: However, in our case we have this type of repetition in two places, one in the
    IP address and the other in the subnet mask, so we modify the regex to search
    for `ip address is  \d+.\d+.\d+.\d+`for the IP address and `subnet mask is \d+.\d+.\d+.\d+` for
    the subnet mask. The command `re.search` inside both the `if` loops returns true
    if a match is found, and false if a match isn't found. In the example, once we
    find the pattern in the `if` condition we use `re.search` again and extract the
    value using `.group(0)`, which now contains the matched regex pattern.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们的情况下，我们在两个地方有这种重复类型，一个在 IP 地址中，另一个在子网掩码中，因此我们修改正则表达式以搜索 `ip address is  \d+.\d+.\d+.\d+`
    用于 IP 地址和 `subnet mask is \d+.\d+.\d+.\d+` 用于子网掩码。`if` 循环内部的 `re.search` 命令在找到匹配项时返回
    true，如果没有找到匹配项则返回 false。在示例中，一旦我们在 `if` 条件中找到模式，我们再次使用 `re.search` 并使用 `.group(0)`
    提取值，现在它包含匹配的正则表达式模式。
- en: Since, we are only concerned with the IP address and the subnet mask, we replace
    the other string values with a blank or none value so we only get the specific
    IP address and subnet mask values.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只关心 IP 地址和子网掩码，我们将其他字符串值替换为空白或无值，以便我们只获取特定的 IP 地址和子网掩码值。
- en: 'Additionally, using the inbuilt `socket` library, there might be a reason to
    check whether the IP address (IPv4 or IPv6) is valid or not. Here is an example
    of this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用内置的 `socket` 库，可能存在检查 IP 地址（IPv4 或 IPv6）是否有效的理由。以下是一个示例：
- en: '[PRE7]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/78441d58-8d1c-4c0d-945f-c447f5593419.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/78441d58-8d1c-4c0d-945f-c447f5593419.jpg)'
- en: Using the `socket` library, we validate the IPv4 and IPv6 IP addresses.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `socket` 库，我们验证 IPv4 和 IPv6 IP 地址。
- en: 'Another task, as we mentioned earlier, is finding the interfaces that have
    `trunk` enabled:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个任务，如我们之前提到的，是找到已启用 `trunk` 的接口：
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output for the preceding code is given as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/09766937-eb10-44a3-9c56-c4fd4d5feac2.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09766937-eb10-44a3-9c56-c4fd4d5feac2.jpg)'
- en: Here, we need to find out the common config that separates each chunk of interface.
    As we see in every interface configuration, the word `interface` separates the
    configurations of each interface, so we split out the config in chunks on interface
    work using the `split` command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要找出分隔每个接口块的共同配置。正如我们在每个接口配置中看到的那样，单词`interface`分隔了每个接口的配置，因此我们使用`split`命令在接口工作上将配置分割成块。
- en: Once we have each chunk, we use the `(fa|te)\d+/\d+` `re` pattern to get the
    interface name on any chunk that contains the word `trunk`. The pattern says that
    any value that starts with `fa` or `te`, is followed by any number of digits with
    a `\`, and again is followed by any number of digits, will be a match.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了每个块，我们使用`(fa|te)\d+/\d+`的`re`模式来获取包含单词`trunk`的任何块上的接口名称。该模式表示任何以`fa`或`te`开头，后跟一个或多个数字和一个`\`，然后再次跟一个或多个数字的值将匹配。
- en: 'Similarly in the same code, we only want to know which interfaces that are
    configured as `trunk` are in the active state (not shut). Here is the code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在相同的代码中，我们只想知道哪些配置为`trunk`的接口处于活动状态（未关闭）。以下是代码：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/6cd711c9-5afc-47ef-ae62-6bf447e5fc36.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6cd711c9-5afc-47ef-ae62-6bf447e5fc36.jpg)'
- en: We added an extra condition to proceed with only those chunks that have `no
    shut` in addition to `trunk` keywords. In this case, we only proceed with chunks
    that meet both conditions and in the preceding example, `te3/1` is not in the
    list as it is in the `shut` state.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个额外条件，仅对那些除了`trunk`关键字外还有`no shut`的块进行操作。在这种情况下，我们只对满足这两个条件的块进行操作，在前面的示例中，`te3/1`不在列表中，因为它处于`shut`状态。
- en: When validating any IP config, we can parse the config, fetch the IP addresses,
    validate each IP address (IPv4 or IPv6), and if there are any incorrect values,
    point out the incorrect values. This can help to ensure we are validating the
    IP addresses that might have crept in because of any manual copy or paste actions.
    Of course, this also means we will not see any production issues because the config
    will already be pre-validated for correctness using this logic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当验证任何IP配置时，我们可以解析配置，获取IP地址，验证每个IP地址（IPv4或IPv6），如果有任何不正确的值，则指出不正确的值。这有助于确保我们正在验证可能由于任何手动复制或粘贴操作而悄悄进入的IP地址。当然，这也意味着我们不会看到任何生产问题，因为配置已经使用此逻辑预先验证了正确性。
- en: 'The code to validate any given IPv4 or IPv6 address from a device config is
    as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 验证设备配置中任何给定的IPv4或IPv6地址的代码如下：
- en: '[PRE10]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/ad4c8a01-4998-4f15-86f5-626c6cbfa9db.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ad4c8a01-4998-4f15-86f5-626c6cbfa9db.jpg)'
- en: We take each line from `sampletext` and find out the IPv4 or IPv6 IPs from each
    line. Then we parse that information into our IP validation functions, and if
    there is an incorrect IP, it will print out the IP address that is not correct.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`sampletext`的每一行中获取IPv4或IPv6 IP地址，然后将该信息解析到我们的IP验证函数中，如果有不正确的IP地址，它将打印出不正确的IP地址。
- en: Similarly, we can validate other aspects of the config by creating specific
    functions and perform a full sanity and validation check on any given config.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以通过创建特定的函数来验证配置的其他方面，并对任何给定的配置执行完整的健全性和验证检查。
- en: Device OS upgrades
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设备操作系统升级
- en: Sometimes we need to upgrade devices such as routers, switches, and firewalls.
    It is easy to perform upgrades on one device, but we need automation to upgrade
    multiple routers. Different devices have different ways of upgrading IOS or OS
    images, and the automation or scripts are created with different methods depending
    on the device.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要升级设备，如路由器、交换机和防火墙。在一个设备上执行升级很容易，但我们需要自动化来升级多个路由器。不同的设备有不同的升级IOS或OS映像的方式，自动化或脚本根据设备的不同而采用不同的方法。
- en: 'Taking an example of upgrading a Cisco IOS router; there are two basic steps
    or tasks that need to be performed:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以升级思科IOS路由器为例；需要执行两个基本步骤或任务：
- en: Copy the relevant OS or IOS image into `flash:` or `bootflash:`.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将相关的OS或IOS映像复制到`flash:`或`bootflash:`。
- en: Change the config to reload the router with the new image.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改配置以使用新映像重新加载路由器。
- en: '**Task 1: Prerequisites (to copy relevant OS or IOS image):**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务1：先决条件（复制相关的OS或IOS映像）：**'
- en: We need a FTP server that's accessible from the router and has the IOS image
    that we need on the router
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个可以从路由器访问的FTP服务器，并且服务器上有我们在路由器上需要的IOS映像
- en: We need the image, the correct MD5 checksum, and the image size for validation
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要映像、正确的MD5校验和以及映像大小以进行验证
- en: 'The sample code for task 1 is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 任务1的示例代码如下：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This code is going to push the IOS image into the router. The `while` loop will
    continue to monitor the progress of code copying until the specific image size
    is not met in the directory. The moment we have specified image size, the script
    will move to the next action, which is validating the MD5 checksum.  Once the
    MD5 checksum is validated, it prints out a final confirmation that the IOS image
    is not copied and MD5 validated.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将把IOS映像推送到路由器。`while`循环将继续监控代码复制的进度，直到目录中不满足特定的映像大小。当我们达到指定的映像大小时，脚本将移动到下一个动作，即验证MD5校验和。一旦MD5校验和被验证，它将打印出一个最终确认，表明IOS映像已复制并MD5验证。
- en: We can use this function on any router with just a couple of tweaks to the image
    name, size, and MD5 checksums for different sets of images.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何路由器上使用此功能，只需对映像名称、大小和不同映像集的MD5校验和进行一些调整。
- en: An important thing to note here is the `file prompt quiet` command. This needs
    to be executed before we start copying the command, as it suppresses any confirmation
    prompts in the router. If we get these confirmation prompts, it is tough to deal
    with all the prompts, thus adding to the complexity of the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个重要事项是`file prompt quiet`命令。在我们开始复制命令之前，需要执行此命令，因为它会抑制路由器中的任何确认提示。如果我们得到这些确认提示，处理所有提示将变得困难，从而增加了代码的复杂性。
- en: By adding this command, we suppress the confirmation and once we have the code
    copied, we enable it to its default state of file prompt.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加此命令，我们抑制了确认，一旦代码复制完成，我们就将其启用到默认的文件提示状态。
- en: '**Task 2: To change the bootvar of the router to a new OS image**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务2：将路由器的bootvar更改为新的OS映像**：'
- en: 'This is where we set the bootvar in Cisco, to point to the new IOS image to
    be loaded:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们设置Cisco中的bootvar，使其指向要加载的新IOS映像的地方：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/82c715a9-ffb6-43f3-b9c3-90f3caa1a79e.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82c715a9-ffb6-43f3-b9c3-90f3caa1a79e.jpg)'
- en: As we can see, in this code we create a command with the new image and send
    it to the router using the `send_config_set` method. This method executes the
    command under `config t`. Once this is done, we validate from the new output fetched
    from running the `show run | in boot`command again, to confirm that the bootvar
    is now pointing to the new OS image.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，在这段代码中，我们使用新映像创建一个命令，并通过`send_config_set`方法将其发送到路由器。此方法在`config t`下执行命令。一旦完成，我们再次运行`show
    run | in boot`命令以获取新的输出，以验证bootvar现在是否指向新的OS映像。
- en: If all is good, then we run `wr mem` to save this new config.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们就运行`wr mem`来保存这个新配置。
- en: Once both the tasks are completed, we need to reload the router for the change
    to take affect. There are multiple scenarios that need to be taken care of before
    a reload. A direct reload can be performed as Task 3 using the `reload` command,
    but as a best practice we need to ensure no production or live traffic is currently
    on the router, as a reload will disrupt the current traffic flow. Also, it is
    advisable to be logged into the console to validate the reload progress and for
    faster recovery if there is a reload failure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个任务都完成，我们需要重新加载路由器以使更改生效。在重新加载之前，需要处理多个场景。可以直接使用`reload`命令作为任务3执行直接重新加载，但作为最佳实践，我们需要确保路由器上没有生产或实时流量，因为重新加载将中断当前的流量流。此外，建议登录到控制台以验证重新加载进度，并在重新加载失败时快速恢复。
- en: IPv4 to IPv6 conversion
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IPv4到IPv6转换
- en: 'There are multiple ways to convert an IPv4 address to an IPv6 address. In Python
    3, we have the inbuilt `ipaddress` module:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 将IPv4地址转换为IPv6地址有多种方法。在Python 3中，我们有内置的`ipaddress`模块：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/4955c089-e699-458b-b816-1efcb3c6d5c1.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4955c089-e699-458b-b816-1efcb3c6d5c1.jpg)'
- en: There are many different methods or functions in the `ipaddress` library that
    we can use for various purposes. The documentation and details can be found at [https://docs.python.org/3/library/ipaddress.html.](https://docs.python.org/3/library/ipaddress.html)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ipaddress`库中，有许多不同的方法或函数可供我们用于各种目的。文档和详细信息可以在[https://docs.python.org/3/library/ipaddress.html.](https://docs.python.org/3/library/ipaddress.html)找到。
- en: Site rollouts
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 站点部署
- en: As we continue to work with multi-vendor environments, there is a demand to
    quickly roll out devices and configs to get a particular site up and running.
    Multiple techniques can be deployed for site rollouts, which involves a standard
    set of devices connected to standard ports with a standard IOS or code image on
    each device ready to be racked and powered up.  To determine the standard **Stock
    Keeping Unit** (**SKU**) for a specific site, we can segregate it as t-shirt sizes.
    At the planning stage we can create t-shirt sizes based upon certain parameters,
    such as usage, load, and redundancy.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续在多供应商环境中工作，有需求快速部署设备和配置以使特定地点上线运行。可以部署多种技术进行地点部署，这涉及到一组标准设备连接到标准端口，每个设备上都有标准的IOS或代码镜像，准备上架和供电。为了确定特定地点的标准**库存单位**（**SKU**），我们可以将其划分为T恤尺寸。在规划阶段，我们可以根据某些参数创建T恤尺寸，例如使用情况、负载和冗余。
- en: At the lowest level, let's say **extra small size** (**XS**) can have a single
    router and a single switch with the router terminating at an internet link. The
    switch is connected to the `FastEthernet 0/1` (for 100 Mbps) or `Gi0/1`(for 1000
    Mbps) port on the router, and end users directly plug in to the switch to get
    access. Based upon this XS SKU (or t-shirt size), we can determine the hardware
    vendor, such as Cisco, DLink, or other network device providers, for each of the
    router and the switch.  Next, when we have finalized the hardware providers, we
    work on generating the config template.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在最低级别，比如说**超小尺寸**（**XS**）可以只有一个路由器和一台交换机，路由器终止于互联网链路。交换机连接到路由器的`FastEthernet
    0/1`（100 Mbps）或`Gi0/1`（1000 Mbps）端口，最终用户直接将设备插入交换机以获取访问权限。基于这个XS SKU（或T恤尺寸），我们可以确定每个路由器和交换机的硬件供应商，例如Cisco、DLink或其他网络设备提供商。接下来，当我们确定了硬件供应商后，我们开始生成配置模板。
- en: 'The config template is typically based on two criteria:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 配置模板通常基于两个标准：
- en: Role of the device
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备的作用
- en: Hardware vendor
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬件供应商
- en: In the same XS size, let's say we have Cisco 3064 (Cisco Nexus running Cisco
    NXOS) as the router, and an Alcatel switch in the switch layer. As we have now
    finalized the hardware vendor and the role of each device, we can easily create
    template configs.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在相同的XS尺寸中，比如说我们有一个作为路由器的Cisco 3064（运行Cisco NXOS的Cisco Nexus）和一个在交换层中的Alcatel交换机。既然我们已经确定了硬件供应商和每个设备的作用，我们就可以轻松地创建模板配置。
- en: As mentioned earlier, once we have the standard hardware, we also need to ensure
    the ports are standard (for example, the uplink of switch will be connected from
    port `Gi1/0` to the router's `Gi1/1`). This will help us by ensuring we create
    a near-complete template with the interface configuration also being taken into
    consideration.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一旦我们有了标准硬件，我们还需要确保端口是标准的（例如，交换机的上行链路将从端口`Gi1/0`连接到路由器的`Gi1/1`）。这将帮助我们确保我们创建了一个几乎完整的模板，同时考虑了接口配置。
- en: 'A template contains a basic configuration with certain values being determined
    later on. It is a very generic layout that we can fill in with values from various
    inputs, such as identifying free IP addresses, the next hostname in the sequence,
    and which routing needs to be in place as a standard configuration:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 模板包含一个基本的配置，某些值将在以后确定。这是一个非常通用的布局，我们可以用各种输入的值来填充，例如识别可用的IP地址、序列中的下一个主机名，以及作为标准配置需要放置哪种路由：
- en: '![](img/11e0779b-374e-4781-9052-5e450fbd3b77.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/11e0779b-374e-4781-9052-5e450fbd3b77.jpg)'
- en: As we see in the preceding figure, the central Python script is calling different
    functions (with the initial inputs being the vendor and the standard role-based
    template), and fetching specific information such as free IP addresses, next available
    hostname (such as `rtr01` or `rtr05`) and routing information (such as **Enhanced
    Interior Gateway Routing Protocol** (**EIGRP**) with subnet `10.10.10.0/255` being
    advertised on the network). Each of these inputs and more (depending upon the
    requirements) are separate Python functions, with the template being changed depending
    upon the return values of the Python function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，中央Python脚本正在调用不同的函数（初始输入为供应商和基于角色的标准模板），并获取特定的信息，如可用的IP地址、下一个可用的主机名（如`rtr01`或`rtr05`）以及路由信息（如**增强型内部网关路由协议**（**EIGRP**）在网络上广播子网`10.10.10.0/255`）。这些输入以及更多（根据需求而定）都是独立的Python函数，模板根据Python函数的返回值进行更改。
- en: 'As an example, we need to get the IP address from a SQL table where the IP
    address shows as unassigned using Python (we would be using `MySQLdb` library
    in Python for this):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要使用Python从SQL表中获取IP地址，其中IP地址显示为未分配（我们将使用Python中的`MySQLdb`库来完成此操作）：
- en: '[PRE14]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This returns a free IP address from the SQL table that we can call into other
    functions to generate our configs. Of course, once this is given, we also need
    to update the table to ensure we set the `isfree` value in the record to `false`
    so that a new call to this function would ensure that we get the next free IP
    address in the SQL table.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从SQL表中返回一个空闲IP地址，我们可以将其调用到其他函数中以生成我们的配置。当然，一旦给出这个，我们还需要更新表以确保我们将记录中的`isfree`值设置为`false`，这样对函数的新调用将确保我们获取SQL表中的下一个空闲IP地址。
- en: Adding all of this together, we can fetch details from multiple tables and even
    call APIs for specific tools to get specialized information, and, taking the return
    values  from all of these functions or methods as inputs,  the template would
    be called with these return values replacing the variables specified in the template.
    Once the template values are filled in, the output will be the final generated
    config that is ready to be deployed on the router/network devices.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有这些结合起来，我们可以从多个表中获取详细信息，甚至调用特定工具的API以获取专门的信息，并且，将这些函数或方法的返回值作为输入，模板将使用这些返回值替换模板中指定的变量。一旦模板值填写完毕，输出将是最终生成的配置，该配置已准备好部署到路由器/网络设备上。
- en: By creating this baseline automation based upon the t-shirt size specifications,
    the script can be called again with a new t-shirt size that can include a new
    set of devices, such as load balancers, multiple routers, and each of the different
    routers in different roles depending on the t-shirt size and complexity.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过根据T恤尺寸规范创建此基线自动化，脚本可以再次被调用，以包含新的一组设备，例如负载均衡器、多个路由器，以及根据T恤尺寸和复杂度，不同角色的每个不同路由器。
- en: The next step after the generation of the final config templates is to apply
    the configs to the router. It is always advisable to perform this functionality
    using the console. Once we have the basic config in place to get SSH/Telnet access
    to the device, we can keep a session open with the console while performing the
    push of the remaining configs on the various devices. Netmiko can be used for
    this purpose, with the intention of pushing all the configs using the newly generated
    templates.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成最终配置模板之后，下一步是将配置应用到路由器上。始终建议使用控制台执行此功能。一旦我们有了基本的配置以获取对设备的SSH/Telnet访问权限，我们就可以在控制台上保持会话打开，同时将剩余的配置推送到各个设备上。Netmiko可用于此目的，目的是使用新生成的模板推送所有配置。
- en: Assuming the cables are connected properly, as per the standards, the next step
    is to validate the traffic and configurations. To do this we again rely on Netmiko
    to fetch routes, logs, and even specific information such as interface counters
    and BGP router tables.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 假设电缆已正确连接，符合标准，下一步是验证流量和配置。为此，我们再次依赖Netmiko来获取路由、日志以及诸如接口计数器和BGP路由器表等特定信息。
- en: Additionally, we could also work on SNMP inputs to validate the current running
    health of each device. A device can sometime perform well in test conditions,
    but once production or live traffic is on its data plane, it can spike in hardware
    resources, causing latency or packet drops. The SNMP stats will give us a clear
    idea of the health of each device, such as CPU usage, memory usage, and even the
    current temperature of certain devices and its modules, to display the overall
    health of the SKU or the t-shirt size site rollout.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以对SNMP输入进行工作以验证每个设备的当前运行健康状态。设备有时在测试条件下表现良好，但一旦生产或实时流量在其数据平面上，它可能会在硬件资源上激增，导致延迟或数据包丢失。SNMP统计信息将给我们一个清晰的每个设备的健康状况，例如CPU使用率、内存使用率，甚至某些设备的当前温度及其模块，以显示SKU或T恤尺寸站点的整体健康状况。
- en: Office/DC relocations
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 办公/数据中心搬迁
- en: There are times when we need to relocate, shut down, or migrate a site to a
    different location. This involves a lot of pre-checks, pre-validations, and ensuring
    the same setup of network PoD is active in the other location.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要将站点搬迁、关闭或迁移到不同的位置。这涉及到大量的预检查、预验证，并确保网络PoD的相同设置在另一个位置是活跃的。
- en: In a multi-vendor environment, and with the increasing SKU size based upon t-shirt
    size, keeping a track of all active sessions, traffic flows, current interface
    status, and specific routes manually is difficult. Using Python, we can create
    an automated way to create a basic checklist and it can be ensured that after
    relocation the same checklist acts as a post validation checklist.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个多厂商环境中，随着T恤尺码的增加，SKU数量的增加，手动跟踪所有活跃会话、流量、当前接口状态和特定路由是困难的。使用Python，我们可以创建一个自动化的基本清单，并确保在搬迁后，相同的清单可以作为后验证清单。
- en: 'As an example, we create a basic script that asks if we need to perform a pre-check/post-check
    and save that in files named `pre-check` and `post-check`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们创建一个基本的脚本，询问是否需要执行预检查/后检查，并将结果保存到名为`pre-check`和`post-check`的文件中：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/e726fcd4-c421-400b-94c8-b54c2c0a1acf.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e726fcd4-c421-400b-94c8-b54c2c0a1acf.jpg)'
- en: Assume that the `precheck.txt` file was taken at the site for multiple devices
    before the migration or relocation, and `postcheck.txt` was taken at the site
    after relocation. Now let's write a quick script that compares both files and
    prints out the difference.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`precheck.txt`文件在迁移或搬迁之前在多个设备所在的现场被采集，而`postcheck.txt`文件是在搬迁之后在现场采集的。现在让我们编写一个简单的脚本，比较这两个文件并打印出差异。
- en: 'Python has a library called `difflib` to perform this task:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个名为`difflib`的库来执行这个任务：
- en: '[PRE16]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '![](img/5657105f-a8e3-4959-ba83-bc03896f61a7.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5657105f-a8e3-4959-ba83-bc03896f61a7.jpg)'
- en: As we can see in `precheck.txt` and `postcheck.txt`, the files are being compared
    line by line. Anything that is unchanged is displayed as it is, but anything that
    is different is shown by either a `-` or `+`. The `-` sign at start of the line
    specifies that the specific line is from first file (which is `precheck.txt` in
    our case), and a `+` sign depicts the same line has been output in the new file
    (which is `postcheck.txt`). Using this method, we can quickly validate the differences
    between `precheck` and `postcheck` and work on fixing the relevant issues after
    the migration or relocation.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在`precheck.txt`和`postcheck.txt`中看到的，文件是逐行比较的。任何没有变化的内容都按原样显示，但任何有差异的内容都会用`-`或`+`来表示。行首的`-`符号指定了该特定行来自第一个文件（在我们的例子中是`precheck.txt`），而`+`符号表示相同的行已经在新的文件（即`postcheck.txt`）中输出。使用这种方法，我们可以快速验证`precheck`和`postcheck`之间的差异，并在迁移或搬迁后修复相关的问题。
- en: There are times when we want to automatically run the script to take a backup
    of the current config of routers. In this case, let's assume that the relocation
    is planned for tomorrow. Before any activity starts we want to ensure we have
    a backup of the current device configs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们希望自动运行脚本以备份当前路由器的配置。在这种情况下，让我们假设搬迁计划在明天进行。在开始任何活动之前，我们想要确保我们有当前设备配置的备份。
- en: 'A simple script stated would do the trick:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的脚本就能解决问题：
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The script is going to parse each device in the devices list one by one, execute
    the `show run` command, and save it in the given filename (the filename is the
    same as the given device name or IP). However, the next question is how to ensure
    this runs at the scheduled time. In Linux we have cron job that we can set up
    for this, and there is also Windows Task Scheduler.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将逐个解析设备列表中的每个设备，执行`show run`命令，并将其保存到给定的文件名中（文件名与给定的设备名或IP相同）。然而，下一个问题是如何确保它在预定的时间运行。在Linux中，我们有cron作业可以设置用于此目的，Windows也有任务计划程序。
- en: 'The following example shows the basic process of creating the task in Task
    Scheduler:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了在任务计划程序中创建任务的基本过程：
- en: 'Open Task Scheduler in Windows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Windows中打开任务计划程序：
- en: '>![](img/84456129-2387-4ac2-a8bf-c1f53df878ae.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '>![](img/84456129-2387-4ac2-a8bf-c1f53df878ae.jpg)'
- en: 'Click on Create a Basic Task on the right side of the Task Scheduler:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任务计划程序的右侧单击“创建基本任务”：
- en: '![](img/00a1e53b-6b7a-44ec-9cb1-f6d363d092cc.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00a1e53b-6b7a-44ec-9cb1-f6d363d092cc.jpg)'
- en: 'Click on Next and select the frequency of the task:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“下一步”并选择任务的频率：
- en: '![](img/9c3fc115-aea5-45be-8b1b-7c4c2bc786fc.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9c3fc115-aea5-45be-8b1b-7c4c2bc786fc.jpg)'
- en: 'Click Next, select the time, and again click Next. Move to Start a Program.
    At this point, you need to add the details shown in the following screenshot.
    We have to provide the full path of `python.exe` in the Program/script: window,
    and in the Add arguments (optional) section, the full path of the Python script
    (with the `.py` extension) enclosed in double quotes:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击下一步，选择时间，然后再次点击下一步。转到启动程序。在这个时候，您需要添加以下屏幕截图中显示的详细信息。我们必须在程序/脚本窗口中提供`python.exe`的完整路径，并在添加参数（可选）部分，用双引号括起Python脚本（带有`.py`扩展名）的完整路径：
- en: '![](img/49199f49-4c8e-436d-8156-a0433d3f1292.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/49199f49-4c8e-436d-8156-a0433d3f1292.jpg)'
- en: 'On the final page, click on Finish to submit the changes and create the task:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一页，点击完成以提交更改并创建任务：
- en: '![](img/b23de7e1-ff39-460f-9d89-55bd5f3de113.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b23de7e1-ff39-460f-9d89-55bd5f3de113.jpg)'
- en: Once this is done, you can run it manually by right-clicking on the created
    task and clicking on the Run option. If the task succeeds, it will return the
    same in the Task Scheduler window. If all is fine, the task will automatically
    run at the given time in the Task Scheduler.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，您可以通过右键单击创建的任务并点击运行选项来手动运行它。如果任务成功，它将在任务计划程序窗口中返回相同的结果。如果一切正常，任务将在任务计划程序中指定的时间自动运行。
- en: This can also be run as a service and at regular intervals, such as daily and
    hourly, depending on how frequently we want to run the script in our environment.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以作为一个服务运行，并且可以按照固定的间隔，例如每天和每小时，根据我们希望在环境中运行脚本的频率来决定。
- en: These scheduled backups can sometimes be taken as baseline and can also act
    as last known good configuration scenarios.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计划好的备份有时可以作为基线，也可以作为已知良好配置的场景。
- en: Bring Your Own Device (BYOD) configs for switches
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交换机的自带设备（BYOD）配置
- en: As our network becomes more scalable, we need to broaden the current architecture
    designs of our network to incorporate better switches and routers to meet the
    demand. There may be times when we have a specialized demand and a specific set
    of hardware needs to be added to our network to meet those demands.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的网络变得更加可扩展，我们需要拓宽我们当前的网络架构设计，以纳入更好的交换机和路由器来满足需求。有时我们可能会有特定的需求，需要将特定的硬件添加到我们的网络中以满足这些需求。
- en: Another requirement may be to lower the cost while increasing the scalability.
    In this case we would need to add different vendor switches to meet the demand.
    There might also be a very specific demand for a certain office or a site. In
    this case, we need to add different vendor hardware to fulfill some specific requirements.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可能的需求可能是降低成本同时提高可扩展性。在这种情况下，我们需要添加不同供应商的交换机来满足需求。也可能会有对某个办公室或地点的非常具体的需求。在这种情况下，我们需要添加不同供应商的硬件来满足一些特定的要求。
- en: All of the scenarios that we have just observed have one thing in common. To
    meet demand or specific requirements, we cannot rely on a single vendor solution
    on the network. There would be a random collection of devices to ensure a particular
    set of requirements are met. This is where we introduce the term BYOD. BYOD is
    a new standard that embraces new designs, hardware, and architecture to gel with
    our current SKU or design. It can be as simple as adding a new mobile phone to
    our corporate network using wireless, or a bit more complex, such as adding specific
    vendor hardware to the network.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才观察到的所有场景都有一个共同点。为了满足需求或特定要求，我们不能仅仅依赖网络上的单一供应商解决方案。我们需要一个随机集合的设备来确保满足特定的要求。这就是我们引入BYOD（Bring
    Your Own Device，自带设备）概念的地方。BYOD是一个新的标准，它接纳新的设计、硬件和架构，以适应我们当前的SKU或设计。它可能简单到只是通过无线方式将一部新手机添加到我们的企业网络，或者稍微复杂一些，比如将特定供应商的硬件添加到网络中。
- en: Architects need to ensure they have good way of forecasting the demand and knowing
    whether the current network design or hardware can meet those demands. In any
    case, there needs to be a requirement in the initial design to ensure that cross-vendor
    platforms are supported with the current technologies. There is a bit of conflict
    in this design methodology. For example, a certain vendor, such as Cisco, has
    the neighbor discovery protocol, **Cisco-specific protocol** (**CDP**), which
    discovers the correct Cisco devices as neighbors of the current device. However,
    to ensure the CDP is discovering and showing the correct information, every device
    needs to be Cisco. On the other hand we have **Link Layer Discovery Protocol**
    (**LLDP**), which is nearly the same as CDP but is open source, so lot of other
    vendors including Cisco also have the option to perform discovery using LLDP instead
    of CDP. Now, Cisco CDP is a Cisco-specific protocol; Cisco has ensured that certain
    parameters can only be exchanged or discovered using CDP, and for that matter,
    every device participating in CDP must be a Cisco device.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 架构师需要确保他们有良好的预测需求的方法，并了解当前的网络设计或硬件是否能够满足这些需求。在任何情况下，初始设计都需要确保当前技术支持跨厂商平台。在这个设计方法中存在一些冲突。例如，某些厂商，如思科，拥有邻居发现协议，**思科特定协议**
    (**CDP**)，它可以发现当前设备的正确思科设备作为邻居。然而，为了确保 CDP 能够发现并显示正确的信息，每个设备都需要是思科的。另一方面，我们有 **链路层发现协议**
    (**LLDP**)，它与 CDP 几乎相同，但它是开源的，因此许多其他厂商，包括思科，也有选择使用 LLDP 而不是 CDP 进行发现的机会。现在，思科
    CDP 是一个思科特定协议；思科确保某些参数只能通过 CDP 交换或发现，因此参与 CDP 的每个设备都必须是思科的设备。
- en: LLDP, being open source, is limited to parameters that are part of open standards
    or the **Internet Engineering Task Force** (**IETF**) framework, and all vendors
    supporting LLDP only adhere to those open standards for cross-platform and hardware
    compatibility. This also results in some participating vendors not sending or
    discovering specialized parameters that are meant specifically for that vendor
    (such as Cisco). Going back to the earlier point, in this case the architecture
    design from day one needs to ensure those standards that are multi-vendor or open
    source only need to be used in a baseline design or architecture. A similar example
    to LLDP would be using open standards such as OSPF or BGP instead of EIGRP, which
    is meant only for Cisco devices.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: LLDP 作为开源协议，仅限于开放标准或 **互联网工程任务组** (**IETF**) 框架中的参数，并且所有支持 LLDP 的厂商仅遵守这些开放标准以实现跨平台和硬件兼容性。这也导致一些参与厂商不会发送或发现专门为该厂商设计的参数（例如思科）。回到之前提到的观点，在这种情况下，从第一天开始的设计架构需要确保多厂商或开源标准仅用于基本设计或架构。LLDP
    的一个类似例子是使用开放标准如 OSPF 或 BGP 而不是 EIGRP，后者仅适用于思科设备。
- en: As mentioned earlier, we need to have specific roles defined and hardware or
    vendor templates that should be created based upon the device or hardware that
    we are introducing in the current design as a BYOD strategy. Keeping the open
    standard approach, we need to ensure that the templates being created are generic,
    and vendor-specific configs can later be introduced into the device.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们需要定义特定的角色，并根据我们在当前设计中引入的设备或硬件创建硬件或厂商模板，这些模板应基于我们作为 BYOD 策略引入的设备。保持开放标准的方法，我们需要确保创建的模板是通用的，并且可以稍后将其特定厂商的配置引入到设备中。
- en: 'SNMP is a powerful protocol that helps manage a lot of these cross-vendor or
    BYOD strategies seamlessly. With a basic configuration of enabling SNMP with a
    specific read-only community string, we can create quick scripts in Python to
    get basic information from BYOD devices. Taking an example, let''s assume we have
    two devices that we need to know the type and vendor of:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: SNMP 是一种强大的协议，它有助于无缝地管理许多跨厂商或 BYOD 策略。通过基本配置启用 SNMP 并使用特定的只读社区字符串，我们可以用 Python
    编写快速脚本以从 BYOD 设备获取基本信息。以一个例子来说明，假设我们需要知道以下两个设备的类型和厂商：
- en: '[PRE18]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The output for the previous code is as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '![](img/632e5f8d-0b08-408f-9861-148edd3bfc17.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/632e5f8d-0b08-408f-9861-148edd3bfc17.jpg)'
- en: As we can see in the preceding output, now we just need to know the IP address
    and the open standard SNMP OID, SNMPv2-MIB. `sysDescr` will give the output for
    both devices. In this case, we can see that one is Cisco 3600 and the other is
    Cisco 3700. Based upon the information returned, we can proceed with the configuration.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述输出所示，现在我们只需要知道IP地址和开放标准SNMP OID，即SNMPv2-MIB。`sysDescr`将为两个设备提供输出。在这种情况下，我们可以看到一个是Cisco
    3600，另一个是Cisco 3700。根据返回的信息，我们可以进行配置。
- en: There are various other tasks that need to be performed based upon the BYOD
    strategy. If there was a mobile phone that you wanted to connect to your network,
    the only thing needed is a connection to a corporate network and a policy that
    you could push to the devices to check for various compliance checks such as operating
    system and anti-virus. Based upon these results, the queried devices can be placed
    in another VLAN that can be called either a quarantine VLAN, which has very limited
    access, or a corporate VLAN, which has full access to corporate resources.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 根据BYOD策略，需要执行各种其他任务。如果您想将一部手机连接到您的网络，所需的就是连接到企业网络，以及可以推送到设备以检查各种合规性检查（如操作系统和防病毒软件）的策略。根据这些结果，查询的设备可以被放置在另一个VLAN中，可以称为隔离VLAN，它具有非常有限的可访问性，或者企业VLAN，它可以完全访问企业资源。
- en: In a similar way, as part of the BYOD for switches strategy, we need to perform
    certain checks to ensure the device is suitable to be part of our network design.
    Yes, we need to keep an open policy for various types of device, but there needs
    to be a loosely coupled framework under which devices can qualify to be part of
    BYOD acceptance.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，作为交换机BYOD策略的一部分，我们需要执行某些检查以确保设备适合成为我们网络设计的一部分。是的，我们需要为各种类型的设备保持开放政策，但需要在设备能够符合BYOD接受资格的松散耦合框架下。
- en: 'Let''s look at an example that ensures that a device is compatible enough to
    be part of a BYOD framework. The core requirement is the switch from Cisco and
    it should have `FastEthernet0/0` as one of the interfaces:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个确保设备足够兼容以成为BYOD框架一部分的例子。核心要求是Cisco交换机，并且它应该有一个`FastEthernet0/0`作为其接口之一：
- en: '[PRE19]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output for the previous code is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '![](img/addb3b92-1f37-493f-8e27-ade47fdfe9a7.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/addb3b92-1f37-493f-8e27-ade47fdfe9a7.jpg)'
- en: We parse two devices and, using open source SNMP, get the vendor and interface
    info. Next, we validate, and based upon our conditions we return a `True` or `False`.
    A true condition for all checks results in acceptance of the device as BYOD.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解析了两个设备，并使用开源SNMP获取厂商和接口信息。接下来，我们进行验证，并根据我们的条件返回`True`或`False`。所有检查条件都为`True`将导致设备作为BYOD被接受。
- en: 'Let''s change the rule a bit. Let''s say if any device has an Ethernet interface,
    then it is not eligible for BYOD:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微改变一下规则。假设任何具有以太网接口的设备都不符合BYOD资格：
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output for the previous code is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码的输出如下：
- en: '![](img/b8fbf329-19c7-45c1-aa9b-96f25d9ed2b4.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8fbf329-19c7-45c1-aa9b-96f25d9ed2b4.jpg)'
- en: As we can see in this example, we validated for any interface that starts with
    the `Ethernet` keyword. The `string.startswith("given string")` function is used
    to evaluate if any given string is at the start of the string that it is being
    compared with. In our case, the device with the IP `192.168.255.248` had an Ethernet-only
    interface, which returned the value `True` for validation the Ethernet-only interface.
    As this is considered a failure for our validation, a `False` was returned, and
    the script calls it out as a BYOD acceptance failure because this specific condition
    has failed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如本例所示，我们对以`Ethernet`关键字开头的任何接口进行了验证。使用`string.startswith("given string")`函数来评估任何给定的字符串是否是其正在比较的字符串的开头。在我们的情况下，具有IP地址`192.168.255.248`的设备有一个仅以太网接口，该接口在验证仅以太网接口时返回了`True`值。由于这被认为是我们验证的失败，因此返回了`False`，并且脚本将其称为BYOD接受失败，因为这一特定条件失败了。
- en: In a similar way, we can validate and ensure multiple checks on on any number
    of devices, and ensure only those that pass the BYOD framework checks are accepted
    in the network.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以对任何数量的设备进行验证和多项检查，并确保只有通过BYOD框架检查的设备被接受到网络中。
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at various complex scenarios to see how new site
    migrations and validations are performed. We also looked at the concepts of multi-vendor
    configurations, creating templates, and generating configs for devices, and also
    IPv4 to IPv6 migration techniques.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了各种复杂场景，以了解新的站点迁移和验证是如何进行的。我们还探讨了多厂商配置的概念，创建模板，为设备生成配置，以及IPv4到IPv6迁移技术。
- en: We focused on specialized extraction of particular data, such as an IP addresses,
    validations of that data, and conditions of failure or acceptance of the data.
    Additionally, site rollouts and BYOD strategies were discussed, along with best
    practices such as t-shirt size and validations of BYOD conditions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们专注于特定数据的专项提取，例如IP地址，以及该数据的验证，以及数据失败或接受的条件。此外，还讨论了站点推广和BYOD策略，以及最佳实践，如T恤尺码和BYOD条件的验证。
- en: In the next chapter, we will go deeper and introduce the web-enabled framework.
    This will help us create our own APIs and create browser-based Python scripts
    that can be executed from anywhere.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将进一步深入，介绍Web启用框架。这将帮助我们创建自己的API，并创建基于浏览器的Python脚本，这些脚本可以从任何地方执行。
