- en: Chapter 2. Dealing with Exceptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 处理异常
- en: In the previous chapter, we started with a simple command-line script and gradually
    transformed it into an object-oriented code. Several new features were added in
    the process. So far, we have paid little attention to the application quality.
    We neglected to look for any obvious errors encountered during the program execution.
    Such errors detected during the application runtime are referred to as **exceptions**.
    In this chapter, you will learn techniques to make the application more robust
    by handling exceptions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们从一个简单的命令行脚本开始，逐渐将其转换为面向对象的代码。在这个过程中添加了几个新功能。到目前为止，我们很少关注应用程序质量。我们忽略了在程序执行过程中遇到的任何明显错误。在应用程序运行时检测到的这些错误被称为**异常**。在本章中，你将学习通过处理异常来使应用程序更加健壮的技术。
- en: 'Specifically, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将涵盖以下主题：
- en: What are the exceptions in Python?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 中有哪些异常？
- en: Controlling the program flow with the `try…except` clause
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `try…except` 子句控制程序流程
- en: Dealing with common problems by handling exceptions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过处理异常处理常见问题
- en: Creating and using custom exception classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用自定义异常类
- en: Let's start by reviewing the feedback you received from the users.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从回顾用户反馈开始。
- en: Revisiting Attack of the Orcs v1.0.0
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视《兽人攻击》v1.0.0
- en: The heal feature added in v1.0.0 became a hit among the core users. The OOP
    approach put you in a better position to implement new features (or so you thought!).
    As the feature requests started pouring in, so did the reported bugs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 v1.0.0 中添加的恢复功能在核心用户中非常受欢迎。面向对象的方法使你能够更好地实现新功能（或者你认为如此！）。随着功能请求的涌入，报告的bug也越来越多。
- en: '| *The game is OK, but there are several annoyances. For example, when prompted
    to choose a hut, sometimes I input a number greater than 5 or input a character
    by mistake. After this, it just prints some weird error message and the application
    terminates. Can you fix this?* |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| *游戏还可以，但有几个令人烦恼的地方。例如，当被提示选择小屋时，有时我会输入大于5的数字或误输入字符。之后，它只打印一些奇怪的错误信息，应用程序就终止了。你能修复这个问题吗？*
    |'
- en: '![Revisiting Attack of the Orcs v1.0.0](img/B05034_02_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![重新审视《兽人攻击》v1.0.0](img/B05034_02_01.jpg)'
- en: Debugging the problem
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试问题
- en: 'Let''s try to reproduce the reported problem. Run the example from [Chapter
    1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing Simple
    Applications*:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试重现报告的问题。运行来自 [第一章](ch01.html "第一章 开发简单应用程序") 的示例，*开发简单应用程序*：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When prompted for the hut number, enter any character, as shown in the following
    screenshot:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示输入小屋编号时，输入任何字符，如下面的截图所示：
- en: '![Debugging the problem](img/B05034_02_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![调试问题](img/B05034_02_02.jpg)'
- en: 'The application is terminated with an error **traceback** in the console. A
    traceback is a snapshot of the call stack at the point where the exception (the
    error) occurred. In this particular example, the `_process_user_choice` method
    is called by the `play` method, which is called directly from the module. The
    line numbers show where these calls occur. It is useful for debugging. The reported
    error in this case is `ValueError`. It occurred because we assumed the user choice
    as an integer. The other problem reported is when the hut number does not fall
    in the range 1 to 5\. The traceback error received is `IndexError`. It occurs
    while accessing the entry in the `huts` list corresponding to the user input:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在控制台中出现错误**跟踪回溯**后被终止。跟踪回溯是在异常（错误）发生时的调用栈快照。在这个特定的例子中，`_process_user_choice`
    方法是由 `play` 方法调用的，而 `play` 方法直接从模块中调用。行号显示了这些调用发生的位置。这对于调试很有用。在这种情况下报告的错误是 `ValueError`。它发生是因为我们假设用户选择的是一个整数。另一个报告的问题是当小屋编号不在1到5的范围内时。收到的跟踪回溯错误是
    `IndexError`。它发生在访问用户输入对应的 `huts` 列表条目时：
- en: '![Debugging the problem](img/B05034_02_03.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![调试问题](img/B05034_02_03.jpg)'
- en: 'If you look at the two tracebacks closely, both these errors occur in the `_process_user_choice`
    method of the `AttackOfTheOrcs` class. Let''s review the original method:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细查看两个跟踪回溯，这两个错误都发生在 `AttackOfTheOrcs` 类的 `_process_user_choice` 方法中。让我们回顾一下原始方法：
- en: '![Debugging the problem](img/B05034_02_04.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![调试问题](img/B05034_02_04.jpg)'
- en: Good! We have pinpointed where the problem is. Now, the next task is to fix
    these bugs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！我们已经确定了问题的所在。现在，下一个任务是修复这些错误。
- en: Fixing the bugs…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复错误…
- en: '| *Sir Foo has some thoughts on fixing bugs…* |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *Sir Foo 对修复错误有一些想法…* |'
- en: '![Fixing the bugs…](img/B05034_02_05.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![修复错误…](img/B05034_02_05.jpg)'
- en: '| *Sure. One way to fix the reported problems is to add conditional blocks
    which ensure that the user input is a number between 1 and 5.* |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| *当然。修复报告问题的方法之一是添加条件块，以确保用户输入是介于1和5之间的数字。* |'
- en: But like many other languages, Python provides an elegant way to handle such
    situations using the `try…except` clause. It is based on the **Easier to Ask for
    Forgiveness than Permission** (**EAFP**) principle.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但像许多其他语言一样，Python提供了一种优雅的方式来处理这种情况，即使用`try…except`子句。它基于**更容易请求原谅而不是请求许可**（**EAFP**）原则。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**The EAFP principle**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**EAFP原则**'
- en: When coding, you assume some things exist and try writing the code accordingly.
    But if this turns out to be a wrong assumption, you ask for forgiveness by catching
    that exception. This is a very common approach used in Python development. You
    can check out the Python 3 documentation ([https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html))
    that defines this idiom. In some cases, exception handling can affect the performance
    when compared to the use of the `if` condition blocks; however, you will most
    likely find more good things than bad ones when using the `try…except` clause.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在编码时，你假设某些事物存在，并相应地编写代码。但如果这证明是一个错误的假设，你将通过捕获那个例外来请求原谅。这是在Python开发中非常常见的一种方法。你可以查看Python
    3文档（[https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)），其中定义了这个习语。在某些情况下，与使用`if`条件块相比，异常处理可能会影响性能；然而，当你使用`try…except`子句时，你很可能会发现更多的好处而不是坏处。
- en: Exceptions
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 例外
- en: Before jumping straight into the code and fixing these issues, let's first understand
    what an exception is and what we mean by handling an exception.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在直接跳入代码并修复这些问题之前，让我们首先了解什么是例外，以及我们所说的处理例外是什么意思。
- en: What is an exception?
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是例外？
- en: An **exception** is an object in Python. It gives us information about an error
    detected during the program execution. The errors noticed while debugging the
    application were **unhandled exceptions** as we didn't see those coming. Later
    in the chapter, you will learn the techniques to handle these exceptions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，**例外**是一个对象。它为我们提供了关于程序执行过程中检测到的错误的信息。在调试应用程序时注意到的错误是**未处理的例外**，因为我们没有预料到这些错误。在接下来的章节中，你将学习处理这些例外情况的技术。
- en: The `ValueError` and `IndexError` exceptions seen in the earlier tracebacks
    are examples of built-in exception types in Python. In the following section,
    you will learn about some other built-in exceptions supported in Python.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期的跟踪信息中看到的`ValueError`和`IndexError`例外是Python中内置例外类型的例子。在下一节中，你将了解Python支持的一些其他内置例外。
- en: Most common exceptions
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最常见的例外
- en: 'Let''s quickly review some of the most frequently encountered exceptions. The
    easiest way is to try running some buggy code and let it report the problem as
    an error traceback! Start your Python interpreter and write the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速回顾一些最常遇到的例外情况。最简单的方法是尝试运行一些有问题的代码，让它报告问题作为错误跟踪信息！启动你的Python解释器，并编写以下代码：
- en: '![Most common exceptions](img/B05034_02_06.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![最常见的例外](img/B05034_02_06.jpg)'
- en: 'Here are a few more exceptions:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些额外的例外情况：
- en: '![Most common exceptions](img/B05034_02_07.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![最常见的例外](img/B05034_02_07.jpg)'
- en: As you can see, each line of the code throws an error traceback with an exception
    type (shown highlighted). These are a few of the built-in exceptions in Python.
    A comprehensive list of built-in exceptions can be found at [https://docs.python.org/3/library/exceptions.html#bltin-exceptions](https://docs.python.org/3/library/exceptions.html#bltin-exceptions).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码的每一行都会抛出一个带有例外类型的错误跟踪信息（显示为高亮）。这些是Python中的一些内置例外。可以在[https://docs.python.org/3/library/exceptions.html#bltin-exceptions](https://docs.python.org/3/library/exceptions.html#bltin-exceptions)找到内置例外的完整列表。
- en: Python provides `BaseException` as the base class for all built-in exceptions.
    However, most of the built-in exceptions do not directly inherit `BaseException`.
    Instead, they are derived from a class called `Exception` that in turn inherits
    from `BaseException`. The built-in exceptions that deal with program exit (for
    example, `SystemExit`) are derived directly from `BaseException`. You can also
    create your own exception class as a subclass of `Exception`. You will learn about
    that later in this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Python为所有内置例外提供了`BaseException`作为基类。然而，大多数内置例外并不直接继承自`BaseException`。相反，它们从一个称为`Exception`的类中派生，该类反过来又继承自`BaseException`。处理程序退出的内置例外（例如，`SystemExit`）直接从`BaseException`派生。你还可以创建自己的例外类作为`Exception`的子类。你将在本章后面了解这一点。
- en: Exception handling
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理
- en: 'So far, we saw have seen the exceptions occur. Now it is time to learn how
    to use the `try…except` clause to handle these exceptions. The following pseudocode
    shows a very simple example of the `try…except` clause:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了异常的发生。现在，是时候学习如何使用`try…except`子句来处理这些异常了。以下伪代码展示了`try…except`子句的一个非常简单的例子：
- en: '![Exception handling](img/B05034_02_08.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理](img/B05034_02_08.jpg)'
- en: 'Let''s review the preceding code snippet:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码片段：
- en: First, the program tries to execute the code inside the `try` clause.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，程序尝试执行`try`子句中的代码。
- en: During this execution, if something goes wrong (if an exception occurs), it
    jumps out of this `try` clause. The remaining code in the `try` block is not executed.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个执行过程中，如果出现问题（如果发生异常），它将跳出这个`try`子句。`try`块中剩余的代码将不会执行。
- en: It then looks for an appropriate exception handler in the `except` clause and
    executes it.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它将在`except`子句中寻找合适的异常处理器并执行它。
- en: 'The `except` clause used here is a universal one. It will catch all types of
    exceptions occurring within the `try` clause. Instead of having this "catch-all"
    handler, a better practice is to catch the errors that you anticipate and write
    an exception handling code specific to those errors. For example, the code in
    the `try` clause might throw an `AssertionError`. Instead of using the universal
    `except` clause, you can write a specific exception handler, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的`except`子句是一个通用的。它将捕获`try`子句中发生的所有类型的异常。与其使用这个“捕获所有”的处理程序，不如更好地实践是捕获你预期的错误，并为这些错误编写特定的异常处理代码。例如，`try`子句中的代码可能会抛出`AssertionError`。而不是使用通用的`except`子句，你可以编写一个特定的异常处理器，如下所示：
- en: '![Exception handling](img/B05034_02_09.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理](img/B05034_02_09.jpg)'
- en: 'Here, we have an `except` clause that exclusively deals with `AssertionError`.
    What it also means is that any error other than the `AssertionError` will slip
    through as an unhandled exception. For that, we need to define multiple `except`
    clauses with different exception handlers. However, at any point in time, only
    one exception handler will be called. This can be better explained with an example.
    Let''s take a look at the following code snippet:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个专门处理`AssertionError`的`except`子句。这也意味着除了`AssertionError`之外的其他错误将作为一个未处理的异常滑过。为此，我们需要定义多个具有不同异常处理器的`except`子句。然而，在任何时候，只有一个异常处理器会被调用。这可以通过一个例子更好地解释。让我们看看以下代码片段：
- en: '![Exception handling](img/B05034_02_10.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![异常处理](img/B05034_02_10.jpg)'
- en: The `try` block calls `solve_something()`. This function accepts a number as
    a user input and makes an assertion that the number is greater than zero. If the
    assertion fails, it jumps directly to the handler, `except AssertionError`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`try`块调用`solve_something()`。这个函数接受一个用户输入的数字，并断言这个数字大于零。如果断言失败，它将直接跳转到处理器，`except
    AssertionError`。'
- en: In the other scenario, with `a > 0`, the rest of the code in `solve_something()`
    is executed. You will notice that the variable `x` is not defined, which results
    in `NameError`. This exception is handled by the other exception clause, `except
    NameError`. Likewise, you can define specific exception handlers for anticipated
    errors.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种场景中，如果`a > 0`，`solve_something()`中的其余代码将被执行。你会注意到变量`x`未定义，这导致`NameError`。这个异常由另一个异常子句`except
    NameError`处理。同样，你可以为预期的错误定义特定的异常处理器。
- en: Raising and re-raising an exception
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出和重新抛出异常
- en: 'The `raise` keyword in Python is used to force an exception to occur. Put another
    way, it raises an exception. The syntax is simple; just open the Python interpreter
    and type:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`raise`关键字用于强制抛出一个异常。换句话说，它引发了一个异常。语法很简单；只需打开Python解释器并输入：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This produces the following error traceback:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这会产生以下错误跟踪信息：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In some situations, we need to re-raise an exception. To understand this concept
    better, here is a trivial scenario. Suppose, in the `try` clause, you have an
    expression that divides a number by zero. In ordinary arithmetic, this expression
    has no meaning. It's a bug! This causes the program to raise an exception called
    `ZeroDivisionError`. If there is no exception handling code, the program will
    just print the error message and terminate.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要重新抛出一个异常。为了更好地理解这个概念，这里有一个简单的场景。假设，在`try`子句中，你有一个除以零的表达式。在普通算术中，这个表达式没有意义。这是一个错误！这会导致程序抛出一个名为`ZeroDivisionError`的异常。如果没有异常处理代码，程序将只打印错误消息并终止。
- en: What if you wish to write this error to some log file and then terminate the
    program? Here, you can use an `except` clause to log the error first. Then, use
    the `raise` keyword without any arguments to re-raise the exception. The exception
    will be propagated upwards in the stack. In this example, it terminates the program.
    The exception can be re-raised with the `raise` keyword without any arguments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将此错误写入某个日志文件然后终止程序呢？在这里，您可以使用 `except` 子句首先记录错误。然后，使用不带任何参数的 `raise` 关键字重新抛出异常。异常将向上传播到堆栈中。在这个例子中，它将终止程序。可以使用不带任何参数的
    `raise` 关键字重新抛出异常。
- en: 'Here is an example that shows how to re-raise an exception:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，展示了如何重新抛出异常：
- en: '![Raising and re-raising an exception](img/B05034_02_11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![抛出和重新抛出异常](img/B05034_02_11.jpg)'
- en: 'As can be seen, a division by zero exception is raised while solving the `a/b`
    expression. This is because the value of variable `b` is set to `0`. For illustration
    purposes, we assumed that there is no specific exception handler for this error.
    So, we will use the general `except` clause where the exception is re-raised after
    logging the error. If you want to try this yourself, just write the code illustrated
    earlier in a new Python file, and run it from a terminal window. The following
    screenshot shows the output of the preceding code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，在解决 `a/b` 表达式时抛出了除以零的异常。这是因为变量 `b` 的值被设置为 `0`。为了说明目的，我们假设没有为这个错误指定特定的异常处理器。因此，我们将使用通用的
    `except` 子句，在记录错误后重新抛出异常。如果您想亲自尝试，只需将前面展示的代码写入一个新的 Python 文件，并在终端窗口中运行它。以下截图显示了前面代码的输出：
- en: '![Raising and re-raising an exception](img/B05034_02_12.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![抛出和重新抛出异常](img/B05034_02_12.jpg)'
- en: The else block of try…except
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: try…except 的 else 块
- en: 'There is an optional `else` block that can be specified in the `try…except`
    clause. The `else` block is executed only if no exception occurs in the `try…except`
    clause. The syntax is as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try…except` 子句中可以指定一个可选的 `else` 块。只有当 `try…except` 子句中没有发生异常时，`else` 块才会执行。其语法如下：
- en: '![The else block of try…except](img/B05034_02_13.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![try…except 的 else 块](img/B05034_02_13.jpg)'
- en: The `else` block is executed before the `finally` clause, which we will study
    next.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`else` 块在 `finally` 子句之前执行，我们将在下一节学习。'
- en: finally...clean it up!
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: finally...清理它！
- en: 'There is something else to add to the `try…except…else` story: an optional
    `finally` clause. As the name suggests, the code within this clause is executed
    at the end of the associated `try…except` block. Whether or not an exception is
    raised, the `finally` clause, if specified, will certainly get executed at the
    end of the `try…except` clause. Imagine it as an all-weather guarantee given by
    Python! The following code snippet shows the `finally` block in action:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `try…except…else` 的故事中还有其他要补充的内容：一个可选的 `finally` 子句。正如其名所示，此子句中的代码在相关的 `try…except`
    块结束时执行。无论是否抛出异常，如果指定了 `finally` 子句，它将肯定在 `try…except` 子句结束时执行。想象一下，这是 Python 给出的一个全方位的保证！以下代码片段显示了
    `finally` 块的实际操作：
- en: '![finally...clean it up!](img/B05034_02_14.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![finally...清理它！](img/B05034_02_14.jpg)'
- en: 'Running this simple code will produce the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此简单代码将产生以下输出：
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The last line in the output is the `print` statement from the `finally` clause.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后一行是 `finally` 子句中的 `print` 语句。
- en: '![finally...clean it up!](img/B05034_02_15.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![finally...清理它！](img/B05034_02_15.jpg)'
- en: '| *That''s a good question! Let''s add a twist to the tale. What if the new
    code in the except clause forces a return from the function? In such a scenario,
    will your solution execute the last line of code shown in the earlier screenshot?*
    |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| *这是一个很好的问题！让我们给这个故事加一个转折。如果 except 子句中的新代码强制函数返回，会发生什么？在这种情况下，您的解决方案会执行前面截图中的最后一行代码吗？*
    |'
- en: The code snippets with and without the `finally` clause are shown in the following
    screenshot. The code in the `finally` clause is assured to be executed in the
    end, even when the `except` clause instructs the code to return from the function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了带有和没有 `finally` 子句的代码片段。`finally` 子句中的代码确保在 `except` 子句指示从函数返回之前执行。
- en: '![finally...clean it up!](img/B05034_02_16.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![finally...清理它！](img/B05034_02_16.jpg)'
- en: The `finally` clause is typically used to perform clean-up tasks before leaving
    the function. An example use case is to close a database connection or a file.
    However, note that, for this purpose, you can also use the `with` statement in
    Python.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`finally` 子句通常用于在离开函数之前执行清理任务。一个示例用法是关闭数据库连接或文件。然而，请注意，为此目的，您也可以在 Python 中使用
    `with` 语句。'
- en: Back to the game – Attack of the Orcs v1.1.0
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回到游戏 – 奥克之攻 v1.1.0
- en: With this knowledge of the exception handling, let's work on the next incremental
    version of the application.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了异常处理的知识后，让我们开始工作，制作应用程序的下一个增量版本。
- en: Preparatory work
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before writing any code, let's first understand how the rest of the section
    is organized. In a nutshell, we will start with v1.0.0 of the code from [Chapter
    1](ch01.html "Chapter 1. Developing Simple Applications"), *Developing Simple
    Applications,* progressively add the exception handling code, and call the new
    version v1.1.0.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，让我们首先了解本节的其他部分是如何组织的。简而言之，我们将从 [第1章](ch01.html "第1章. 开发简单应用程序")，*开发简单应用程序*
    的代码 v1.0.0 版本开始，逐步添加异常处理代码，并调用新的版本 v1.1.0。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Python files in the supporting code bundle already include the exception
    handling code to be discussed in this section as well as in a later section of
    this chapter, *Defining custom exceptions*
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 支持代码包中的 Python 文件已经包含了本节以及本章后续部分“定义自定义异常”中将要讨论的异常处理代码。
- en: 'The following points elaborate further details:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点进一步阐述了详细内容：
- en: We will start by downloading the v1.0.0 of the game from [Chapter 1](ch01.html
    "Chapter 1. Developing Simple Applications"), *Developing Simple Applications*.
    The file name is `ch01_ex03_AbstractBaseClass.py` (recall that this was provided
    as a solution to an exercise in [Chapter 1](ch01.html "Chapter 1. Developing Simple
    Applications"), *Developing Simple Applications*). You can find this file in this
    chapter's code bundle.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将首先从 [第1章](ch01.html "第1章. 开发简单应用程序")，*开发简单应用程序* 下载游戏的 v1.0.0 版本。文件名为 `ch01_ex03_AbstractBaseClass.py`（回想一下，这是在
    [第1章](ch01.html "第1章. 开发简单应用程序")，*开发简单应用程序* 中提供的练习题的解决方案）。你可以在这个章节的代码包中找到此文件。
- en: Compare the aforementioned file with `ch01_ex03.py`. The only difference here
    is the use of an abstract base class, `AbstractGameUnit`, instead of an ordinary
    base class, `GameUnit`. The rest of the code is identical.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将上述文件与 `ch01_ex03.py` 进行比较。这里唯一的区别是使用了抽象基类 `AbstractGameUnit` 而不是普通基类 `GameUnit`。其余代码完全相同。
- en: Let's copy `ch01_ex03_AbstractBaseClass.py` and save it as `attackoftheorcs_v1_1.py`.
    or give it any name you like. In the following discussion, we will refer to the
    file by this new name and incrementally add exception handling code to it.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们复制 `ch01_ex03_AbstractBaseClass.py` 并将其保存为 `attackoftheorcs_v1_1.py`，或者你可以给它起任何你喜欢的名字。在接下来的讨论中，我们将以此新名字来引用该文件，并逐步向其中添加异常处理代码。
- en: As noted before, the supporting code bundle has all the exception handling code
    that we will review. You will find a file by the same name (`attackoftheorcs_v1_1.py`)
    in the code bundle with all the changes included.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，支持代码包中包含了我们将要审查的所有异常处理代码。你将在代码包中找到一个同名文件（`attackoftheorcs_v1_1.py`），其中包含了所有更改。
- en: Adding the exception handling code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加异常处理代码
- en: 'This will essentially be a bug-fix version with no new features added. The
    debugging done earlier has already helped us find where the problems are. Open
    the Python file (`attackoftheorcs_v1_1.py`) and update the `_process_user_choice`
    method of the `AbstractGameUnit` class. The updated version of this method with
    the new `try…except` clauses is shown in the following code snippet:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将基本上是一个修复错误的版本，不会添加任何新功能。之前所做的调试已经帮助我们找到了问题所在。打开 Python 文件（`attackoftheorcs_v1_1.py`），并更新
    `AbstractGameUnit` 类的 `_process_user_choice` 方法。带有新 `try…except` 子句的此方法更新版本如下所示：
- en: '![Adding the exception handling code](img/B05034_02_17.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![添加异常处理代码](img/B05034_02_17.jpg)'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you missed reading this earlier, you should copy the `ch01_ex03_AbstractBaseClass.py`
    file and name it `attackoftheorcs_v1_1.py`. Then work with this new file to add
    the preceding exception handling code. Alternatively, you can simply review the
    file with the same name provided in the code bundle for this chapter. It includes
    all the changes we will discuss next. The Python 2.7.9 compatible source file
    is also provided in the code bundle.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前错过了阅读这部分内容，你应该复制 `ch01_ex03_AbstractBaseClass.py` 文件，并将其命名为 `attackoftheorcs_v1_1.py`。然后使用这个新文件添加前面的异常处理代码。或者，你也可以简单地查看代码包中提供的同名文件。它包含了我们将要讨论的所有更改。Python
    2.7.9 兼容的源文件也包含在代码包中。
- en: 'Let''s review the preceding code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码：
- en: In the `try` clause, if the `user_choice` variable is not a number, the `ValueError`
    exception occurs, which is handled by `except ValueError as e`
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `try` 子句中，如果 `user_choice` 变量不是一个数字，将发生 `ValueError` 异常，该异常由 `except ValueError
    as e` 处理。
- en: The `as` keyword is used to assign exception to an `e` object
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`as`关键字将异常分配给`e`对象
- en: Alternatively, you can just use the syntax `except ValueError`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者，你也可以直接使用语法`except ValueError`
- en: The second `try…except` clause takes care of the situation where the input number
    goes out of range of the `huts` list
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个`try…except`子句处理输入数字超出`huts`列表范围的情况
- en: When the `IndexError` exception occurs, the `continue` statement in the `except`
    clause makes the user re-enter the input
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发生`IndexError`异常时，`except`子句中的`continue`语句会使用户重新输入输入值
- en: That's all we need. Now, let's run the application next.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的所有内容。现在，让我们运行应用程序。
- en: Running Attack of the Orcs v1.1.0
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行《奥克之攻》v1.1.0
- en: 'It is time to run the application and see if these changes fix the reported
    problems. Run the program in a terminal window, as shown in the following code
    snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候运行应用程序，看看这些更改是否解决了报告的问题。在终端窗口中运行程序，如下代码片段所示：
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When prompted for an input, enter some unacceptable value for the hut number:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当提示输入时，输入一个不可接受的棚屋编号值：
- en: '![Running Attack of the Orcs v1.1.0](img/B05034_02_18.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![运行《奥克之攻》v1.1.0](img/B05034_02_18.jpg)'
- en: Looks good! At least the reported problems have been resolved. It is easy to
    find more such errors. For example, a user can still enter 0 or a negative number
    while choosing a hut, or, when the program asks for permission to attack the enemy,
    any input other than `y` or `n` is not handled gracefully. As an exercise, have
    a go at fixing these issues yourself!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！至少报告的问题已经解决。很容易找到更多这样的错误。例如，用户在选择棚屋时还可以输入0或负数，或者当程序请求允许攻击敌人时，任何除`y`或`n`之外的输入都没有得到优雅的处理。作为练习，尝试自己修复这些问题！
- en: Defining custom exceptions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义自定义异常
- en: You can define your own exception class by inheriting from the `Exception` base
    class or any other exception class. Why do we need such customization? Firstly,
    you can create an exception class with a descriptive name. This allows us to identify
    the purpose of the exception just by looking at the descriptive name. For example,
    instead of `ValueError`, a custom exception named `ValueGreaterThanFiveError`
    will immediately help identify the problem. There are other advantages as well.
    You can use such classes to add customized messages based on error subcategories,
    writing error logs, and so on. Let's learn how to define custom exceptions next.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从`Exception`基类或任何其他异常类继承来自定义异常类。为什么我们需要这样的定制？首先，你可以创建一个具有描述性名称的异常类。这允许我们仅通过查看描述性名称就能识别异常的目的。例如，而不是`ValueError`，一个名为`ValueGreaterThanFiveError`的自定义异常将立即帮助我们识别问题。还有其他优点。你可以使用这样的类根据错误子类别添加自定义消息、编写错误日志等。让我们学习如何定义自定义异常。
- en: Preparatory work
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here is a list of files we will use:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将使用的文件列表：
- en: '`attackoftheorcs_v1_1.py`: This is the file from the previous section that
    we will use. As mentioned earlier, the supporting code bundle already has a file
    by the same name. It includes all the modifications we will discuss.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attackoftheorcs_v1_1.py`: 这是上一节中我们将使用的文件。如前所述，支持代码包已经有一个同名文件。它包括我们将讨论的所有修改。'
- en: '`gameuniterror.py`: This is a new module to hold a custom exception class.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameuniterror.py`: 这是一个新的模块，用于存放自定义异常类。'
- en: '`heal_exception_example.py`: This is where the top-level control code will
    be written. This is a simplified version of the game where we do not need to play
    the whole game in order to reproduce the problem.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heal_exception_example.py`: 这里将编写顶层控制代码。这是一个简化版的游戏，我们不需要玩完整游戏就能重现问题。'
- en: You need to put all the aforementioned files in the same directory.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要将所有上述文件放在同一个目录下。
- en: Custom exception – The problem
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义异常 – 问题
- en: To demonstrate the use of custom exceptions, let's identify a trivial problem.
    Observe the `heal` method shown next (recall that it is defined in `AbstractGameUnit`,
    the superclass of `Knight`). You can find it in the `attackoftheorcs_v1_1.py`
    file.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示自定义异常的使用，让我们识别一个简单的问题。观察下面显示的`heal`方法（回想一下，它定义在`Knight`的父类`AbstractGameUnit`中）。你可以在`attackoftheorcs_v1_1.py`文件中找到它。
- en: '![Custom exception – The problem](img/B05034_02_19.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![自定义异常 – 问题](img/B05034_02_19.jpg)'
- en: The method has two optional arguments. If `full_healing` is set to `True`, the
    game unit will regain all its lost hit points. The other option, `heal_by`, heals
    the game unit by a small amount. In this version, we are not using the `heal_by`
    option. But in a future version, you may want to introduce a turn-based feature
    in the game, where the injured units are healed by a small amount on every turn*.*
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法有两个可选参数。如果 `full_healing` 设置为 `True`，游戏单位将恢复所有失去的生命值。另一个选项 `heal_by` 通过一小部分来
    `heal` 游戏单位。在这个版本中，我们没有使用 `heal_by` 选项。但在未来的版本中，你可能想在游戏中引入回合制功能，其中受伤的单位在每个回合中通过一小部分来恢复健康*。
- en: To demonstrate how to create and use custom exceptions, let's introduce an artificial
    bug in the `heal_by` feature! Save the following code as `heal_exception_example.py`
    and place this file in the same directory as `attackoftheorcs_v1_1.py`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何创建和使用自定义异常，让我们在 `heal_by` 功能中引入一个人工错误！将以下代码保存为 `heal_exception_example.py`
    并将此文件放置在 `attackoftheorcs_v1_1.py` 相同的目录中。
- en: '![Custom exception – The problem](img/B05034_02_20.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![自定义异常 – 问题](img/B05034_02_20.jpg)'
- en: This is a simplified version of the game where we do not need to play the whole
    game in order to create this artificial bug! It is a top-level control code that
    creates a `Knight` instance, forcefully reduces the hit points (check out `knight.health_meter`)
    as if the knight has fought a combat and sustained injuries. In the end, it calls
    the `heal` function with the `heal_by` argument.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简化版的游戏，我们不需要玩完整游戏就能创建这个人工错误！这是一个顶层控制代码，它创建一个 `Knight` 实例，强制减少生命值（查看 `knight.health_meter`），就像骑士已经战斗并受伤一样。最后，它使用
    `heal_by` 参数调用 `heal` 函数。
- en: 'Have you noticed a problem here? Recall that the `knight` instance can have
    a maximum of `40` hit points (check out the instance attribute `Knight.max_hp`).
    The preceding code is trying to `heal` the knight by `100` points using the `heal_by`
    argument. Clearly, it will exceed the limit. One way of preventing this is to
    add an assertion statement in the `heal` method, as shown in the following code
    snippet:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到这里有什么问题吗？回想一下，`knight` 实例的最大生命值是 `40`（查看实例属性 `Knight.max_hp`）。前面的代码试图使用
    `heal_by` 参数通过 `100` 点来 `heal` 骑士。显然，这将超过限制。防止这种情况的一种方法是在 `heal` 方法中添加一个断言语句，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This will raise an `AssertionError`. This is an acceptable solution. Another
    way to accomplish this is to use a custom exception class. It is demonstrated
    next.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发一个 `AssertionError`。这是一个可接受的解决方案。另一种实现方式是使用自定义异常类。接下来将演示。
- en: Writing a new exception class
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写新的异常类
- en: 'It is trivial to create a new exception class derived from `Exception`. Open
    your Python interpreter and create the following class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Exception` 类派生一个新的异常类是非常简单的。打开你的 Python 解释器，创建以下类：
- en: '[PRE6]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'That''s all! We have a new exception class, `GameUnitError`, ready to be deployed.
    How to test this exception? Just `raise` it. Type the following line of code in
    your Python interpreter:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 那就全部了！我们有一个新的异常类 `GameUnitError`，准备部署。如何测试这个异常？只需 `raise` 它。在你的 Python 解释器中输入以下代码行：
- en: '[PRE7]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Raising the newly created exception will print the following traceback:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出新创建的异常将打印以下跟踪回溯：
- en: '[PRE8]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Copy the `GameUnitError` class into its own module, `gameuniterror.py`, and
    save it in the same directory as `attackoftheorcs_v1_1.py`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `GameUnitError` 类复制到其自己的模块 `gameuniterror.py` 中，并将其保存到与 `attackoftheorcs_v1_1.py`
    相同的目录中。
- en: 'Next, update the `attackoftheorcs_v1_1.py` file to include the following changes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新 `attackoftheorcs_v1_1.py` 文件以包含以下更改：
- en: 'First, add the following import statement at the beginning of the file:'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，在文件开头添加以下导入语句：
- en: '[PRE9]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The second change is in the `AbstractGameUnit.heal` method. The updated code
    is shown in the following code snippet. Observe the highlighted code that raises
    the custom exception whenever the value of `self.health_meter` exceeds that of
    `self.max_hp`.![Writing a new exception class](img/B05034_02_21.jpg)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个更改是在 `AbstractGameUnit.heal` 方法中。更新的代码如下所示。观察高亮显示的代码，当 `self.health_meter`
    的值超过 `self.max_hp` 时，会抛出自定义异常。![编写新的异常类](img/B05034_02_21.jpg)
- en: 'With these two changes, run `heal_exception_example.py` created earlier. You
    will see the new exception being raised, as shown in the following screenshot:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这两个更改，运行之前创建的 `heal_exception_example.py`。你将看到新异常被抛出，如下面的截图所示：
- en: '![Writing a new exception class](img/B05034_02_22.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![编写新的异常类](img/B05034_02_22.jpg)'
- en: Expanding the exception class
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展异常类
- en: 'Can we do something more with the `GameUnitError` class? Certainly! Just like
    any other class, we can define attributes and use them. Let''s expand this class
    further. In the modified version, it will accept an additional argument and some
    predefined error code. The updated `GameUnitError` class is shown in the following
    screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否对`GameUnitError`类做更多的事情？当然可以！就像任何其他类一样，我们可以定义属性并使用它们。让我们进一步扩展这个类。在修改后的版本中，它将接受一个额外的参数和一些预定义的错误代码。更新后的`GameUnitError`类如下所示：
- en: '![Expanding the exception class](img/B05034_02_23.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![扩展异常类](img/B05034_02_23.jpg)'
- en: 'Let''s take a look at the code in the preceding screenshot:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下前面截图中的代码：
- en: First, it calls the `__init__` method of the `Exception` superclass and then
    defines some additional instance variables.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它调用`Exception`超类的`__init__`方法，然后定义一些额外的实例变量。
- en: A new dictionary object, `self.error_dict`, holds the error integer code and
    the error information as key-value pairs.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个新的字典对象`self.error_dict`持有错误整数代码和错误信息作为键值对。
- en: The `self.error_message` stores the information about the current error depending
    on the error code provided.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.error_message`根据提供的错误代码存储有关当前错误的信息。'
- en: The `try…except` clause ensures that `error_dict` actually has the key specified
    by the `code` argument. It doesn't in the `except` clause; we just retrieve the
    value with the default error code of `000`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`try…except`子句确保`error_dict`实际上具有由`code`参数指定的键。在`except`子句中并不存在；我们只是使用默认错误代码`000`来检索值。'
- en: 'Now, let''s take look at the consumer of this class. Observe the modified `heal`
    method. The only change here is the additional argument to the `GameUnitError`
    instance. Here, we pass an error code as the second argument:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个类的消费者。观察修改后的`heal`方法。这里唯一的改变是向`GameUnitError`实例添加了一个额外的参数。在这里，我们将错误代码作为第二个参数传递：
- en: '![Expanding the exception class](img/B05034_02_24.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![扩展异常类](img/B05034_02_24.jpg)'
- en: 'So far, we have made changes to the `GameUnitError` class and the `AbstractGameUnit.heal`
    method. We are not done yet. The last piece of the puzzle is to modify the `main`
    program in the `heal_exception_example.py` file. The code is shown in the following
    screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对`GameUnitError`类和`AbstractGameUnit.heal`方法进行了修改。我们还没有完成。最后一部分是要修改`heal_exception_example.py`文件中的`main`程序。代码如下所示：
- en: '![Expanding the exception class](img/B05034_02_25.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![扩展异常类](img/B05034_02_25.jpg)'
- en: 'Let''s review the code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下代码：
- en: As the `heal_by` value is too large, the `heal` method in the `try` clause raises
    the `GameUnitError` exception.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于`heal_by`值太大，`try`子句中的`heal`方法抛出了`GameUnitError`异常。
- en: The new `except` clause handles the `GameUnitError` exception just like any
    other built-in exceptions.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的`except`子句像处理任何其他内置异常一样处理`GameUnitError`异常。
- en: Within the `except` clause, we have two `print` statements. The first one prints
    `health_meter > max_hp!` (recall that, when this exception was raised in the `heal`
    method, this string was given as the first argument to the `GameUnitError` instance).
    The second `print` statement retrieves and prints the `error_message` attribute
    of the `GameUnitError` instance.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`except`子句中，我们有两条`print`语句。第一条打印`health_meter > max_hp!`（回想一下，当这个异常在`heal`方法中被抛出时，这个字符串被作为`GameUnitError`实例的第一个参数）。第二条`print`语句检索并打印`GameUnitError`实例的`error_message`属性。
- en: 'We have got all the changes in place. We can run this example from a terminal
    window as:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了所有的更改。我们可以从终端窗口运行这个示例：
- en: '[PRE10]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the program is shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的输出如下所示：
- en: '![Expanding the exception class](img/B05034_02_26.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![扩展异常类](img/B05034_02_26.jpg)'
- en: In this simple example, we have just printed the error information to the console.
    You can further write verbose error logs to a file and keep track of all the error
    messages generated while the application is running.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们只是将错误信息打印到控制台。你可以进一步将详细的错误日志写入文件，并跟踪应用程序运行期间生成的所有错误消息。
- en: Inheriting from the exception class
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从异常类继承
- en: '| *Sir Foo has* *something to say about the error codes maintained in* `GameUnitError.error_dict`
    *seen earlier…* |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| *Sir Foo有* *一些关于之前在`GameUnitError.error_dict`中维护的错误代码的看法…* |'
- en: '![Inheriting from the exception class](img/B05034_02_28.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![从异常类继承](img/B05034_02_28.jpg)'
- en: '| *You are right. While raising an exception, you need to remember what each
    error number corresponds to. Let''s discuss a few alternatives.* |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| *你是正确的。在抛出异常时，你需要记住每个错误号对应的内容。让我们讨论一些替代方案。* |'
- en: 'One option is to use unique strings as keys of `error_dict` in place of the
    error numbers, for example:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是使用唯一的字符串作为`error_dict`的键，而不是错误号，例如：
- en: '[PRE11]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This alleviates the problem of remembering the error codes. However, this approach
    is not suitable if you want to do something beyond just printing a message. For
    example, depending on the error type, you may want to do some additional processing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这减轻了记住错误代码的问题。然而，如果你想要做的不仅仅是打印消息，这种方法就不适用了。例如，根据错误类型，你可能想要进行一些额外的处理。
- en: 'A better approach is to use `GameUnitError` as a base exception class and derive
    new classes that target specific errors. The descriptive names of these exception
    classes should help convey the same information. The following code snippet shows
    an example of how to do it. You can replace the existing code in `gameuniterror.py`
    with the one shown in the following screenshot:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是使用`GameUnitError`作为基异常类，并派生出针对特定错误的新的类。这些异常类的描述性名称应该有助于传达相同的信息。以下代码片段展示了如何实现它的一个示例。你可以用以下截图中的代码替换`gameuniterror.py`中现有的代码：
- en: '![Inheriting from the exception class](img/B05034_02_29.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![从异常类继承](img/B05034_02_29.jpg)'
- en: 'Now, in the `heal` method, instead of raising the `GameUnitError` exception,
    just `raise` the `HealthMeterException`. Be sure to `import` the `HealthMeterException`
    module as indicated in the following code snippet:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`heal`方法中，不要抛出`GameUnitError`异常，而是直接`raise``HealthMeterException`。确保按照以下代码片段中的指示导入`HealthMeterException`模块。
- en: '![Inheriting from the exception class](img/B05034_02_30.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![从异常类继承](img/B05034_02_30.jpg)'
- en: 'Running the code with the aforementioned changes produces a similar output.
    It is just that we have revised `error_message` of the `HealthMeterException`
    class. The output is shown as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述更改运行代码会产生类似的输出。只是我们修订了`HealthMeterException`类的`error_message`。输出如下所示：
- en: '[PRE12]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Likewise, you can create other subclasses to deal with specific issues.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你也可以创建其他子类来处理特定问题。
- en: Exercise
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Identify any code that can benefit from exception handling. For example, create
    a new `HutError` exception, and use it to raise errors related to the `Hut` class.
    Here is a cheat sheet:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 识别任何可以从异常处理中受益的代码。例如，创建一个新的`HutError`异常，并使用它来抛出与`Hut`类相关的错误。以下是一个速查表：
- en: '![Exercise](img/B05034_02_27.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![练习](img/B05034_02_27.jpg)'
- en: 'Instead of using `error_dict`, you can also create subclasses, such as:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以不使用`error_dict`，而是创建子类，例如：
- en: '[PRE13]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter served as an introduction to the basics of exception handling in
    Python. We saw how the exceptions occur, learned about some common built-in exception
    classes, and wrote simple code to handle these exceptions using the `try…except`
    clause. By handling exceptions, we fixed some obvious bugs in the *Attack of the
    Orcs* game.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Python中异常处理的基础。我们看到了异常是如何发生的，了解了一些常见的内置异常类，并编写了简单的代码来使用`try…except`子句处理这些异常。通过处理异常，我们修复了“奥克之攻”游戏中的某些明显错误。
- en: The chapter also demonstrated techniques, such as raising and re-raising exceptions,
    using the `finally` clause, and so on. The later part of the chapter focused on
    implementing custom exception classes. We defined a new exception class and used
    it for raising custom exceptions for our application.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还演示了技术，例如抛出和重新抛出异常，使用`finally`子句等。本章的后期部分专注于实现自定义异常类。我们定义了一个新的异常类，并使用它为我们的应用程序抛出自定义异常。
- en: With exception handling, the code is in a better shape. However, we still have
    the majority of the code squished inside a single file (`attackoftheorcs_v1_1.py`).
    In the next chapter, you will learn how to package the application code and release
    it to a broader audience.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过异常处理，代码的形态变得更好。然而，我们仍然有大部分代码挤在一个单独的文件（`attackoftheorcs_v1_1.py`）中。在下一章中，你将学习如何打包应用程序代码并将其发布给更广泛的受众。
