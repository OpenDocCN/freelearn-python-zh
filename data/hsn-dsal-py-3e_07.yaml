- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Heaps and Priority Queues
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆和优先队列
- en: A heap data structure is a tree-based data structure in which each node of the
    tree has a specific relationship with other nodes, and they are stored in a specific
    order. Depending upon the specific order of the nodes in the tree, heaps can be
    of different types, such as a `min` heap and a `max` heap.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 堆数据结构是一种基于树的数据库结构，其中树中的每个节点与其他节点具有特定的关系，并且它们以特定的顺序存储。根据树中节点的特定顺序，堆可以是不同类型的，例如最小堆和最大堆。
- en: A priority queue is an important data structure that is similar to the queue
    and stack data structures that stores data along with the priority associated
    with them. In this, the data is served according to the priority. Priority queues
    can be implemented using an array, linked list, and trees; however, they are often
    implemented using a heap as it is very efficient.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列是一个重要的数据结构，它类似于队列和栈数据结构，存储数据及其相关的优先级。在这里，数据是按照优先级进行服务的。优先队列可以使用数组、链表和树来实现；然而，它们通常使用堆来实现，因为它非常高效。
- en: 'In this chapter, we will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: The concept of the heap data structure and different operations on it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆数据结构的概念及其上的不同操作
- en: Understanding the concept of the priority queue and its implementation using
    Python
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解优先队列的概念及其使用 Python 的实现
- en: Heaps
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 堆
- en: 'A heap data structure is a specialization of a tree in which the nodes are
    ordered in a specific way. A heap is a data structure where each data elements
    satisfies a `heap` property, and the `heap` property states that there must be
    a certain relationship between a parent node and its child nodes. According to
    this certain relationship in the tree, the heaps can be of two types, in other
    words, `max` heaps and `min` heaps. In a `max` heap, each parent node value must
    always be greater than or equal to all its children. In this kind of tree, the
    `root` node must be the greatest value in the tree. For example, see *Figure 7.1*
    showing the `max` heap in which all the nodes have greater values compared to
    their children:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 堆数据结构是树的一种特殊化，其中节点以特定的方式进行排序。堆是一种数据结构，其中每个数据元素都满足堆属性，堆属性表明父节点和子节点之间必须存在某种关系。根据这种特定的关系，堆可以分为两种类型，换句话说，最大堆和最小堆。在最大堆中，每个父节点的值必须始终大于或等于其所有子节点。在这种类型的树中，根节点必须是树中的最大值。例如，参见
    *图 7.1* 展示的最大堆，其中所有节点的值都大于其子节点：
- en: '![](img/B17217_07_01.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2：最小堆的示例](img/B17217_07_01.png)'
- en: 'Figure 7.1: An example of a max heap'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1：最大堆的示例
- en: 'In a `min` heap, the relationship between parent and children is that the value
    of the parent node must always be less than or equal to its children. This rule
    should be followed by all the nodes in the tree. In the `min` heap, the `root`
    node holds the lowest value. For example, see *Figure 7.2* showing the `min` heap
    in which all the nodes have smaller values compared to their children:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在最小堆中，父节点和子节点之间的关系是父节点的值必须始终小于或等于其子节点。这个规则应该适用于树中的所有节点。在最小堆中，根节点持有最低的值。例如，参见
    *图 7.2* 展示的最小堆，其中所有节点的值都小于其子节点：
- en: '![](img/B17217_07_02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1：最大堆的示例](img/B17217_07_02.png)'
- en: 'Figure 7.2: An example of a min heap'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2：最小堆的示例
- en: The heap is an important data structure due to its several applications and
    uses in implementing heap sort algorithms and priority queues. We will be discussing
    these in detail later in the chapter. The heap can be any kind of tree; however
    the most common type of heap is a binary heap in which each node has at most two
    children.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一个重要的数据结构，因为它有多个应用，并且在实现堆排序算法和优先队列中得到了广泛的使用。我们将在本章的后面详细讨论这些内容。堆可以是任何类型的树；然而，最常见的一种堆是二叉堆，其中每个节点最多有两个子节点。
- en: If the binary heap is a **complete binary tree** with `n` nodes, then it will
    have a minimum height of `log`[2]`n`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果二叉堆是一个包含 `n` 个节点的完全二叉树，那么它的高度至少为 `log`[2]`n`。
- en: 'A complete binary tree is one in which each row must be fully filled before
    starting to fill the next row, as shown in the following *Figure 7.3*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 完全二叉树是一种必须先填满每一行，然后才能开始填充下一行的树，如下面的 *图 7.3* 所示：
- en: '![](img/B17217_07_03.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3：完全二叉树的示例](img/B17217_07_03.png)'
- en: 'Figure 7.3: An example of a complete binary tree'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3：完全二叉树的示例
- en: 'In order to implement the heap, we can derive a relationship between parent
    and child nodes in `index` values. The relationship is that the children of any
    node at the `n` index can be retrieved easily, in other words, the left child
    will be located at `2n`, and the right child will be located at `2n + 1`. For
    example, the node `C` would be at the index of `3`, since node `C` is a right
    child of the node `A`, which is at index `1`, so it becomes `2n+1 = 2*1 + 1 =
    3`. This relationship always holds true. Let’s say we have a list of elements
    `{A, B, C, D, E}` as shown in *Figure 7.4*. If we store any element at an index
    of `i`, then its parent can be stored at index `i/2`, for example, if the index
    of the node `D` is `4`, then its parent would be at 4/2 = 2, index `2`. The index
    of root has to be starting from 1 in the array. See *Figure 7.4* to understand
    the concept:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现堆，我们可以推导出父节点和子节点在`index`值之间的关系。这种关系是，任何节点在`n`索引处的子节点可以很容易地检索到，换句话说，左子节点位于`2n`，右子节点位于`2n
    + 1`。例如，节点`C`位于索引`3`，因为节点`C`是位于索引`1`的节点`A`的右子节点，所以它变为`2n+1 = 2*1 + 1 = 3`。这种关系始终成立。假设我们有一个元素列表`{A,
    B, C, D, E}`，如*图7.4*所示。如果我们把任何元素存储在索引`i`处，那么它的父节点可以存储在索引`i/2`处，例如，如果节点`D`的索引是`4`，那么它的父节点就在`4/2
    = 2`，索引`2`。根节点的索引必须在数组中从`1`开始。参见*图7.4*以了解概念：
- en: '![](img/B17217_07_04.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_04.png)'
- en: 'Figure 7.4: Binary tree and index positions of all the nodes'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：二叉树和所有节点的索引位置
- en: This relation between parent and child is a complete binary tree. In respect
    of indexing values, it is very important in order to efficiently retrieve, search,
    and store the data elements in the heap. Due to this property, it is very easy
    to implement the heap. The only constraint is that we should have indexing starting
    from `1`, and if we implement the heap using an array, then we have to add one
    dummy element at index `0` in the array. Next, let’s understand the implementation
    of the heap. It is important to note that we will be discussing all the concepts
    with respect to the `min` heap, and the implementation for the `max` heap will
    be very similar to it, with the only difference being the `heap` property.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 父亲和子节点之间的关系是一个完全二叉树。在索引值方面，这对于在堆中有效地检索、搜索和存储数据元素非常重要。由于这个特性，实现堆变得非常容易。唯一的约束是我们应该从`1`开始索引，如果我们使用数组实现堆，那么我们必须在数组的索引`0`处添加一个虚拟元素。接下来，让我们了解堆的实现。重要的是要注意，我们将讨论所有概念都与`min`堆相关，而`max`堆的实现将与它非常相似，唯一的区别是`heap`属性。
- en: 'Let’s discuss the implementation of the `min` heap using Python. We start with
    the `heap` class, as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论使用Python实现最小堆的实现。我们首先从`heap`类开始，如下所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We initialize the heap list with a zero to represent the dummy first element,
    and we are adding a dummy element just to start the indexing of data items from
    `1` since if we start indexing from `1`, accessing of the elements becomes very
    easy due to the parent-child relationship. We also create a variable to hold the
    size of the heap. We will further discuss different operations, such as `insert`,
    `delete`, and `delete` at a specific location in the heap. Let’s start with the
    insertion operation in the heap.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用零初始化堆列表来表示虚拟的第一个元素，并且添加一个虚拟元素只是为了从`1`开始索引数据项，因为如果我们从`1`开始索引，由于父子关系，访问元素变得非常容易。我们还创建了一个变量来保存堆的大小。我们将进一步讨论不同的操作，例如在堆中插入、删除和删除特定位置的元素。让我们从堆中的插入操作开始。
- en: Insert operation
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插入操作
- en: The insertion of an item into a `min` heap works in two steps. First, we add
    the new element to the end of the list (which we understand to be the bottom of
    the tree), and we increment the size of the heap by one. Secondly, after each
    insertion operation, we need to arrange the new element up in the heap tree, to
    organize all the nodes in such a way that satisfies the `heap` property, which
    in this case is that each node must be larger than its parent. In other words,
    the value of the parent node must always be less than or equal to its children,
    and the lowest element in the `min-heap` needs to be the root element. Therefore,
    we first insert an element into the last heap of the tree; however, after inserting
    an element into the heap, it is possible that the `heap` property is violated.
    In that case, the nodes have to be rearranged so that all the nodes satisfy the
    `heap` property. This process is called heapifying. To heapify the `min` heap,
    we need to find the minimum of its children and swap it with the current element,
    and this process has to be repeated until the `heap` property is satisfied for
    all the nodes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将一个元素插入到`min`堆中分为两个步骤。首先，我们将新元素添加到列表的末尾（我们理解为树的底部），并将堆的大小增加一。其次，在每次插入操作之后，我们需要将新元素在堆树中重新排列，以组织所有节点，使其满足`堆`属性，在这种情况下是每个节点必须大于其父节点。换句话说，父节点的值必须始终小于或等于其子节点，而`min-heap`中的最小元素需要是根元素。因此，我们首先将一个元素插入到树的最后一个堆中；然而，在将元素插入堆之后，可能会违反`堆`属性。在这种情况下，节点必须重新排列，以便所有节点都满足`堆`属性。这个过程称为堆化。为了堆化`min`堆，我们需要找到其子节点的最小值并将其与当前元素交换，并且这个过程必须重复进行，直到所有节点都满足`堆`属性。
- en: 'Let’s consider an example of adding an element in the `min` heap, such as inserting
    a new node with a value of `2` in *Figure 7.5*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个在`min`堆中添加元素的例子，比如在*图7.5*中插入一个值为`2`的新节点：
- en: '![](img/B17217_07_05.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_05.png)'
- en: 'Figure 7.5: Insertion of a new node 2 in the existing heap'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：在现有堆中插入新节点2
- en: 'The new element will be added to the last position in the third row or level.
    Its index value is `7`. We compare that value with its parent. The parent is at
    index `7/2 = 3` (integer division). The parent node holds value `6`, which is
    higher than the new node value (in other words, 2), so according to the property
    of the `min` heap, we swap these values, as shown in *Figure 7.6*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 新元素将被添加到第三行或级别的最后一个位置。其索引值是`7`。我们将其值与其父节点进行比较。父节点位于索引`7/2 = 3`（整数除法）。父节点持有值`6`，这个值高于新节点值（换句话说，2），因此根据`min`堆的性质，我们交换这两个值，如图*图7.6*所示：
- en: '![](img/B17217_07_06.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_06.png)'
- en: 'Figure 7.6: Swapping nodes 2 and 6 to maintain the heap property'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：交换节点2和6以保持堆属性
- en: The new data element has been swapped and moved up to index `3`. Since, we have
    to check all the nodes up to the root, we check the index of its parent node which
    is *3/2 = 1 (integer division)*, so we continue the process to heapify.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 新的数据元素已经交换并移动到索引`3`。由于我们必须检查所有节点直到根节点，我们检查其父节点的索引，即*3/2 = 1（整数除法）*，所以我们继续堆化过程。
- en: 'So, we compare both of these elements, and swap again, as shown in *Figure
    7.7*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们比较这两个元素，并再次交换，如图*图7.7*所示：
- en: '![](img/B17217_07_07.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_07.png)'
- en: 'Figure 7.7: Swapping nodes 2 and 3 to maintain the heap property'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7：交换节点2和3以保持堆属性
- en: 'After the final swap, we reach the root. Here, we can notice that this heap
    adheres to the definition of the `min` heap, as shown in *Figure 7.8*:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终交换后，我们到达根节点。在这里，我们可以注意到这个堆符合`min`堆的定义，如图*图7.8*所示：
- en: '![](img/B17217_07_08.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_08.png)'
- en: 'Figure 7.8: Final heap after insertion of a new node 2'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8：插入新节点2后的最终堆
- en: 'Now, let’s take another example to see how to create and insert elements in
    a heap. We start with the construction of a heap by inserting 10 elements, one
    by one. The elements are `{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}`. We can see a step-by-step
    process to insert elements into the heap in *Figure 7.9*:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再举一个例子，看看如何创建和插入堆中的元素。我们从一个堆的构建开始，逐个插入10个元素。这些元素是`{4, 8, 7, 2, 9, 10,
    5, 1, 3, 6}`。我们可以在*图7.9*中看到将元素插入堆的逐步过程：
- en: '![](img/B17217_07_09.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_09.png)'
- en: 'Figure 7.9: The step-by-step procedure to create a heap'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.9：创建堆的逐步过程
- en: 'We can see, in the preceding diagram, a step-by-step process to insert elements
    into the heap. Here, we continue adding elements, as shown in *Figure 7.10*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在前面的图中看到将元素插入堆的逐步过程。在这里，我们继续添加元素，如图*图7.10*所示：
- en: '![](img/B17217_07_10.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_10.png)'
- en: 'Figure 7.10: Steps 7 to 9 in creating the heap'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10：创建堆的步骤7到9
- en: 'Finally, we insert an element, `6`, into the heap, as shown in *Figure 7.11*:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将元素`6`插入到堆中，如图*图7.11*所示：
- en: '![](img/B17217_07_11.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_07_11.png)'
- en: 'Figure 7.11: Last step and construction of the final heap'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11：最后一步和最终堆的构建
- en: 'The implementation of the insertion operation in the heap is discussed as follows.
    Firstly, we create a helper method, called the `arrange`, that takes care of arrangements
    of all the nodes after insertion of a new node. Here is the implementation of
    the `arrange()` method, which should be defined in the `MinHeap` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 堆中插入操作的实现如下。首先，我们创建一个辅助方法，称为`arrange`，它负责在插入新节点后对所有节点进行排列。以下是`arrange()`方法的实现，该方法应在`MinHeap`类中定义：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We execute the loop until we reach up to the `root` node; until then, we can
    keep arranging the element. Here, we are using integer division. The loop will
    break out after the following condition:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们执行循环直到达到`root`节点；在此之前，我们可以继续排列元素。在这里，我们使用整数除法。循环将在以下条件成立后退出：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After that, we compare the values between the parent and child node. If the
    parent is greater than the child, swap the two values:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们比较父节点和子节点之间的值。如果父节点大于子节点，则交换这两个值：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Finally, after each iteration, we move up in the tree:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在每次迭代后，我们在树中向上移动：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This method ensures that the elements are ordered properly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法确保元素被正确排序。
- en: 'Now, for adding new elements in the heap, we need to use the following `insert`
    method, which should be defined in the `MinHeap` class:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了向堆中添加新元素，我们需要使用以下`insert`方法，该方法应在`MinHeap`类中定义：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the above code, we can insert an element using the `append` method; then
    we increase the size of the heap. Then, in the last line of the `insert` method,
    we call the `arrange()` method to reorganize the heap (heapify it) to ensure that
    all the nodes in the heap satisfy the `heap` property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们可以使用`append`方法插入一个元素；然后增加堆的大小。然后在`insert`方法的最后一行，我们调用`arrange()`方法重新组织堆（堆化）以确保堆中的所有节点都满足`heap`属性。
- en: 'Now, let’s create the heap and insert that data `{4, 8, 7, 2, 9, 10, 5, 1,
    3, 6}` using the `insert()` method, which is defined in the `MinHeap` class, as
    shown in the following code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建堆并使用`MinHeap`类中定义的`insert()`方法插入数据`{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}`，如下所示：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can print the heap list, just to inspect how the elements are ordered. If
    you redraw this as a tree structure, you will notice that it meets the required
    properties of a heap, similar to what we created manually:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以打印堆列表，以便检查元素是如何排序的。如果你将其重新绘制为树结构，你会注意到它符合堆所需的所有属性，类似于我们手动创建的：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the above code is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can see in the output that all the data items of the heap in the array are
    as in the index position as per *Figure 7.11*. Next, we will discuss the delete
    operation in the heap.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中看到，数组中堆的所有数据项与*图7.11*中的索引位置一致。接下来，我们将讨论堆中的删除操作。
- en: Delete operation
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 删除操作
- en: The `delete` operation removes an element from the heap. To delete any element
    from the heap, let’s first discuss how we can delete the root element since it
    is mostly used for several use cases, such as finding the minimum or maximum element
    in a heap. Remember, in a `min-heap`, the root element denotes the minimum value
    of the list, and the root of the `max-heap` gives the maximum value of the list
    of elements.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`操作从堆中删除一个元素。要从堆中删除任何元素，我们首先讨论如何删除根元素，因为它在许多用例中都被广泛使用，例如在堆中查找最小或最大元素。记住，在`min-heap`中，根元素表示列表的最小值，而`max-heap`的根给出元素列表的最大值。'
- en: Once we delete the root element from the heap, we make the last element of the
    heap the new root of the heap. In that case, the `heap` property will not be satisfied
    by the tree. So, we have to reorganize the nodes of the tree such that all the
    nodes of the tree satisfy the `heap` property. The delete operation in `min-heap`
    works as follows.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从堆中删除根元素，我们将堆的最后一个元素作为堆的新根。在这种情况下，树将不满足`heap`属性。因此，我们必须重新组织树的节点，使得树中的所有节点都满足`heap`属性。`min-heap`中的删除操作如下所示。
- en: Once we delete the `root` node, we need a new `root` node. For this, we take
    the last item from the list and make it the new root.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除`root`节点后，我们需要一个新的`root`节点。为此，我们从列表中取出最后一个元素并将其作为新的根。
- en: Since the selected last node might not be the lowest element of the heap, we
    have to reorganize the nodes of the heap.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于选定的最后一个节点可能不是堆中的最低元素，我们必须重新组织堆的节点。
- en: We reorganize the nodes from the `root` node to the last node (which is made
    into a new root); this process is called heapify. Since we move from top to bottom
    (which means from the `root` node down to the last element) of the heap, this
    process is called percolate down.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从根节点到最后一个节点（被制成一个新的根节点）重新组织节点；这个过程称为堆化。由于我们从顶部到底部（这意味着从根节点到底部元素）移动堆，这个过程称为下沉。
- en: 'Let’s consider an example to help us understand this concept in the following
    heap. First, we delete the `root` node that has value `2`, as shown in *Figure
    7.12*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子来帮助我们理解以下堆中的这个概念。首先，我们删除具有值`2`的根节点，如图*7.12*所示：
- en: '![](img/B17217_07_12.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_12.png)'
- en: 'Figure 7.12: Deletion of a node with value 2 at the root in the existing heap'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12：在现有堆中删除根节点值为2的节点
- en: 'Once we delete the root, next we need to choose a node that can be the new
    root; commonly, we choose to take the last node, in other words, node `6` at index
    `7`. So, the last element, `6`, is placed at the root position, as shown in *Figure
    7.13*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 删除根节点后，接下来我们需要选择一个可以作为新根的节点；通常，我们选择取最后一个节点，换句话说，索引为`7`的节点`6`。因此，最后一个元素`6`被放置在根位置，如图*7.13*所示：
- en: '![](img/B17217_07_13.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_13.png)'
- en: 'Figure 7.13: Moving the last element, in other words, node 6 to the root position'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13：将最后一个元素，即节点6移动到根位置
- en: 'After moving the last element to the new root, clearly this tree is now not
    satisfying the `min-heap` property. So, we have to reorganize the nodes of the
    heap, hence we move down from the root to the nodes in the heap, that is, heapify
    the tree. So, we compare the value of the newly replaced node with all its children
    nodes in the tree. In this example, we compare the two children of the root, that
    is, `5` and `3`. Since the right child is smaller, its index is `3`, which is
    represented as *(root index * 2 + 1)*. We will go ahead with this node and compare
    the new `root` node with the value at this index, as shown in *Figure 7.14*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一个元素移动到新根之后，很明显，这棵树现在不再满足`min-heap`属性。因此，我们必须重新组织堆的节点，因此我们从根节点向下移动到堆中的节点，即堆化树。因此，我们比较新替换的节点与树中所有子节点的值。在这个例子中，我们比较根节点的两个子节点，即`5`和`3`。由于右子节点较小，其索引为`3`，表示为*(root
    index * 2 + 1)*。我们将继续使用这个节点，并将新的`root`节点与该索引处的值进行比较，如图*7.14*所示：
- en: '![](img/B17217_07_14.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_14.png)'
- en: 'Figure 7.14: Swapping of the root node with the node 3'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14：根节点与节点3的交换
- en: 'Now, the node with value `6` should be moved down to index `3` as per the `min
    heap` property. Next, we need to compare it to its children down to the heap.
    Here, we only have one child, so we don’t need to worry about which child to compare
    it against (for a `min` heap, it is always the lesser child), as shown in *Figure
    7.15*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，具有值`6`的节点应该根据最小堆属性移动到索引`3`。接下来，我们需要将其与其子节点比较到堆中。在这里，我们只有一个子节点，所以我们不需要担心比较哪个子节点（对于最小堆，总是较小的子节点），如图*7.15*所示：
- en: '![](img/B17217_07_15.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_15.png)'
- en: 'Figure 7.15: Swapping of node 6 and node 10'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15：节点6和节点10的交换
- en: There is no need to swap here since it is following the `min-heap` property.
    After reaching the last one, the final heap adheres to the `min-heap` property.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里不需要交换，因为它遵循`min-heap`属性。达到最后一个节点后，最终的堆遵循`min-heap`属性。
- en: 'In order to implement the deletion of the `root` node from the heap using Python,
    firstly, we implement the percolate-down process, in other words, the `sink()`
    method. Before we implement the `sink()` method, we implement a `helper` method
    for finding out which of the children to compare against the parent node. This
    `helper` method is `minchild()`, which should be defined in the `MinHeap` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Python实现从堆中删除根节点，首先，我们实现下沉过程，换句话说，`sink()`方法。在我们实现`sink()`方法之前，我们实现一个用于确定与父节点比较的子节点的`helper`方法。这个`helper`方法是`minchild()`，应该在`MinHeap`类中定义：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this method, firstly, we check if we get beyond the end of the list—if we
    do, then we return the index of the left child:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，首先，我们检查是否超过了列表的末尾——如果我们做到了，那么我们就返回左子节点的索引：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Otherwise, we simply return the index of the lesser of the two children:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，我们只需返回两个子节点中较小的一个的索引：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now we can create the `sink()` method. The `sink()` method should be defined
    in the `MinHeap` class:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以创建`sink()`方法。`sink()`方法应该在`MinHeap`类中定义：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the above code, we first run the loop until the end of the tree so that
    we can sink (move down) our element down as far as is needed; this is shown in
    the following code snippet:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先运行循环直到树的末尾，这样我们就可以将我们的元素下沉（向下移动）到所需的最低位置；这在下述代码片段中显示：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to know which of the left or right children to compare against.
    This is where we make use of the `minindex()` function, as shown in the following
    code snippet:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要知道比较的是左子节点还是右子节点。这就是我们使用`minindex()`函数的地方，如下述代码片段所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we compare parent and child to see whether we need to make the swap,
    as we did in the `arrange()` method during the insertion operation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们比较父节点和子节点，以确定是否需要交换，就像我们在插入操作期间在`arrange()`方法中所做的那样：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to make sure that we move down the tree in each iteration
    so that we don’t get stuck in a loop, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要确保在每次迭代中向下移动树，以避免陷入循环，如下所示：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, we can implement the main `delete_at_root()` method itself, which should
    be defined in the `MinHeap` class:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现主要的`delete_at_root()`方法本身，该方法应在`MinHeap`类中定义：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the above code for deletion of the `root` node, we first copy the root element
    in a variable item, and then the last element is moved to the `root` node in the
    following statement:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述删除`root`节点的代码中，我们首先将根元素复制到一个变量`item`中，然后在下一条语句中将最后一个元素移动到`root`节点：
- en: '[PRE18]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Further, we reduce the size of the heap, and remove the element from the heap,
    and then we use the `sink()` method to reorganize the heap element so that all
    the elements of the heap follow the `heap` property.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们减少堆的大小，从堆中删除元素，然后我们使用`sink()`方法重新组织堆元素，以便堆的所有元素都遵循`heap`属性。
- en: 'We can now use the following code to delete the `root` node from the heap.
    Let’s first insert some data items `{2, 3, 5, 7, 9, 10, 6}` in the heap and then
    remove the `root` node:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下代码从堆中删除`root`节点。首先，我们在堆中插入一些数据项`{2, 3, 5, 7, 9, 10, 6}`，然后删除`root`节点：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output of the above code is as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can see in the output that the root element 2 is returned in the new heap,
    and that the data elements are rearranged so that all the nodes of the heap are
    following the `heap` property (indexes of the nodes can checked as shown in *Figure
    7.16*). Next, we will discuss if we want to delete any node with the given index
    position.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在输出中看到，新的堆中返回了根元素2，并且数据元素被重新排列，以便堆的所有节点都遵循`heap`属性（可以像*图7.16*中所示的那样检查节点的索引）。接下来，我们将讨论是否要删除给定索引位置的任何节点。
- en: Deleting an element at a specific location from a heap
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从堆中删除特定位置的元素
- en: 'Generally, we delete an element at the root, however, an element can be deleted
    at a specific location from the heap. Let us understand it with an example. Given
    the following heap, let’s assume that we want to delete a node with value `3`
    at index `2`. After deleting the node with value `3`, we move the last node to
    the deleted node, in other words, the node with value `15`, as shown in *Figure
    7.16*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们会从根节点删除一个元素，然而，也可以从堆的特定位置删除一个元素。让我们通过一个例子来理解它。给定以下堆，假设我们想要删除值为`3`的节点，索引为`2`。删除值为`3`的节点后，我们将最后一个节点移动到被删除的节点，换句话说，就是值为`15`的节点，如图*图7.16*所示：
- en: '![](img/B17217_07_16.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_16.png)'
- en: 'Figure 7.16: The deletion of node 3 from the heap'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16：从堆中删除节点3
- en: 'After shifting the last element to the deleted node, we compare this with its
    root element since it is already greater than the root element, so we do not swap.
    Next, we compare this element with all of its children, and since the left child
    is smaller, it is swapped with the left child, as shown in *Figure 7.17*:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将最后一个元素移至被删除的节点后，我们比较这个元素与其根元素，因为它已经大于根元素，所以我们不需要交换。接下来，我们比较这个元素与其所有子元素，因为左子节点较小，所以它与左子节点交换，如图*图7.17*所示：
- en: '![](img/B17217_07_17.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_17.png)'
- en: 'Figure 7.17: A comparison of node 15 with 5 and 11, and swapping node 15 and
    node 5'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17：节点15与5和11的比较，以及节点15和节点5的交换
- en: 'After swapping node `15` with node `5`, we move down in the heap. Next, we
    compare node `15` with its child, node `8`. Finally, node `8` and node `15` are
    swapped. Now, the final tree follows the `heap` property, as shown in *Figure
    7.18*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在将节点`15`与节点`5`交换后，我们在堆中向下移动。接下来，我们比较节点`15`与其子节点，节点`8`。最后，节点`8`和节点`15`交换。现在，最终的树遵循`heap`属性，如图*图7.18*所示：
- en: '![](img/B17217_07_18.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_18.png)'
- en: 'Figure 7.18: The final heap after swapping node 8 and node 15'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18：交换节点8和节点15后的最终堆
- en: 'The implementation of the delete operation for removing a data item at any
    given index location is given below, which should be defined in the `MinHeap`
    class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下给出删除任何给定索引位置数据项的删除操作的实现，应在`MinHeap`类中定义：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the above output, we see that, before and after, the heap nodes are placed
    according to their index positions. We have discussed the concepts and implementation
    using examples of `min-heap`; all these operations and concepts can be easily
    implemented for a `max-heap` by simply reversing the logic in conditions where
    we ensured that the parent node should have smaller values compared to the children
    in `min-heap`. Now in the case of `max-heap`, we have to make the larger value
    in the parent. Heaps are used in various applications such as to implement heap
    sort and priority queues, which we will discuss in subsequent sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们看到，在前后，堆节点都是按照它们的索引位置放置的。我们已经通过`最小堆`的例子讨论了概念和实现；所有这些操作和概念都可以通过简单地反转在`最小堆`中确保父节点值小于子节点的条件逻辑，轻松地应用于`最大堆`。现在在`最大堆`的情况下，我们必须使父节点的值更大。堆被用于各种应用，例如实现堆排序和优先队列，我们将在后续章节中讨论。
- en: Heap sort
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 堆排序
- en: 'Heap is an important data structure for sorting a list of elements since it
    is very suitable for a large number of elements. If we want to sort a list of
    elements, say in ascending order, we can use `min-heap` for this purpose; we first
    create a `min-heap` of all the given data elements, and as per the `heap` property,
    the smallest data value will be stored at the root of the heap. With the help
    of the `heap` property, it is straightforward to sort the elements. The process
    is as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是一种重要的数据结构，用于对元素列表进行排序，因为它非常适合大量元素。如果我们想按升序对元素列表进行排序，我们可以使用`最小堆`来实现这个目的；我们首先创建一个包含所有给定数据元素的`最小堆`，根据`堆`的性质，最小的数据值将被存储在堆的根节点。借助`堆`的性质，对元素进行排序变得非常直接。过程如下：
- en: Create a `min-heap` using all the given data elements.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用所有给定的数据元素创建一个`最小堆`。
- en: Read and delete the root element, which is the minimum value. After that, copy
    the last element of the tree to the new root, and further reorganize the tree
    to maintain the `heap` property.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取并删除根元素，即最小值。之后，将树的最后一个元素复制到新的根节点，并进一步重新组织树以保持`堆`的性质。
- en: Now, we repeat *step 2* until we get all the elements.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们重复*步骤 2*，直到我们得到所有元素。
- en: Finally, we get the sorted list of elements.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们得到排序后的元素列表。
- en: The data elements are stored in the heap adhering to the `heap` property; whenever
    a new element is added or deleted, the `heap` property is maintained using the
    `arrange()` and `sink()` `helper` methods, respectively, as discussed in previous
    sections.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 数据元素按照`堆`的性质存储在堆中；每当添加或删除新元素时，分别使用前面章节中讨论的`arrange()`和`sink()``辅助`方法来维护`堆`的性质。
- en: 'In order to implement heap sort using the heap data structure, first we create
    a heap with the data items `{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}` using the below code
    (details of the creation of the heap are given in previous sections):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用堆数据结构实现堆排序，我们首先使用以下代码创建一个包含数据项 `{4, 8, 7, 2, 9, 10, 5, 1, 3, 6}` 的堆（堆的创建细节在前面章节中给出）：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the above code, the `min-heap`, `h`, is created and the elements in `unsorted_list`
    are inserted. After each call to the `insert()` method, the heap order property
    is restored by the subsequent call to the `sink` method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，创建了`最小堆``h`，并将`unsorted_list`中的元素插入。在每次调用`insert()`方法后，通过后续调用`sink`方法恢复堆顺序属性。
- en: 'After creation of the heap, next, we read and delete the root element. In each
    iteration, we get the minimum value, and thus the data items in ascending order.
    The implementation of the `heap_sort() method` should be defined in the `minHeap`
    class (it uses the `delete_at_root()` method discussed in previous sections):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建堆之后，接下来，我们读取并删除根元素。在每次迭代中，我们得到最小值，因此数据项按升序排列。`heap_sort()`方法的实现应该在`minHeap`类中定义（它使用前面章节中讨论的`delete_at_root()`方法）：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the above code, we create an empty array, `sorted_list`, which stores all
    the data elements in sorted order. Then we run the loop for the number of items
    in the list. In each iteration, we call the `delete_at_root()` method to get the
    minimum value, which is appended to `sorted_list`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个空数组`sorted_list`，用于存储所有已排序的数据元素。然后我们运行循环，循环次数与列表中的项目数相同。在每次迭代中，我们调用`delete_at_root()`方法来获取最小值，并将其追加到`sorted_list`。
- en: 'Now we can use the heap sort algorithm using the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下代码来使用堆排序算法：
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the above code is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The time complexity to build the heap using the insert method takes `O(n)` times.
    Further, to reorganize the tree after deleting the root element takes `O(log n)`
    since we go from top to bottom in the heap tree, and the height of the heap is
    `log2(n)`, hence the complexity of rearranging the tree is `O(log n)`. So, overall,
    the worst-case time complexity of the heap sort is `O(n logn)`. Heapsort is very
    efficient in general, giving a worst-case, average-case and best-case complexity
    of `O(nlogn)`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用插入方法构建堆的时间复杂度为`O(n)`。进一步地，在删除根元素后重新组织树的时间复杂度为`O(log n)`，因为我们是从堆树的上到下进行操作的，而堆的高度是`log2(n)`，因此重新排列树的时间复杂度是`O(log
    n)`。所以，总体来说，堆排序的最坏情况时间复杂度是`O(n logn)`。堆排序在一般情况下非常高效，其最坏情况、平均情况和最佳情况的时间复杂度均为`O(nlogn)`。
- en: Priority queues
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优先队列
- en: A priority queue is a data structure that is similar to a queue in which data
    is retrieved based on the **First In, First Out** (**FIFO**) policy, but in the
    priority queue, priority is attached with the data. In the priority queue, the
    data is retrieved based on the priority associated with the data elements, the
    data elements with the highest priority are retrieved before the lower priority
    data elements, and if two data elements have the same priority, they are retrieved
    according to the **FIFO** policy.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列是一种数据结构，它类似于队列，其中数据是根据**先进先出**（**FIFO**）策略检索的，但在优先队列中，数据与优先级相关联。在优先队列中，数据是根据与数据元素相关的优先级检索的，优先级最高的数据元素先被检索，优先级较低的数据元素后被检索，如果两个数据元素具有相同的优先级，则根据**FIFO**策略检索。
- en: We can assign the priority of the data depending upon the application. It is
    used in many applications, such as CPU scheduling, and many algorithms also rely
    on priority queues, such as Dijkstra’s shortest-path, A* search, and Huffman codes
    for data compression.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据应用来分配数据的优先级。它在许多应用中都有使用，例如CPU调度，许多算法也依赖于优先队列，如Dijkstra的最短路径算法、A*搜索算法和用于数据压缩的Huffman编码。
- en: 'So, in the priority queue, the item with the highest priority is served first.
    The priority queue stores the data according to the priority associated with the
    data, so insertion of an element will be at a specific position in the priority
    queue. Priority queues can be considered as modified queues that return the items
    in the order of highest priority instead of returning the items in the **FIFO**
    order. A priority queue can be implemented by modifying an enqueue position by
    inserting the item according to the priority. It is demonstrated in *Figure 7.19*,
    in which given the queue, a new item `5` is added to the queue at a specific index
    (here assuming that the data items having higher values have higher priority):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在优先队列中，优先级最高的项目首先被服务。优先队列根据与数据相关的优先级存储数据，因此元素的插入将在优先队列的特定位置。优先队列可以被视为修改后的队列，它按最高优先级顺序返回项目，而不是按**FIFO**顺序返回项目。可以通过修改入队位置并按优先级插入项目来实现优先队列。这在*图7.19*中得到了演示，其中给定的队列中添加了一个新的项目`5`到队列的特定索引（这里假设具有更高值的数据项具有更高的优先级）：
- en: '![A picture containing text, clock  Description automatically generated](img/B17217_07_19.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本、时钟的图片，描述自动生成](img/B17217_07_19.png)'
- en: 'Figure 7.19: A demonstration of a priority queue'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19：优先队列的演示
- en: 'Let’s understand the priority queue with an example. When we receive data elements
    in an order, the elements are enqueued in the priority queue in the order of priority
    (assuming that the higher data value is of higher importance). Firstly, the priority
    queue is empty, so `3` is added initially in the queue; the next data element
    is `8`, which will be enqueued at the start since it is greater than `3`. Next,
    the data item is `2`, then `6`, and finally, `10`, which are enqueued in the priority
    queue as per their priority, and when the dequeue operation is applied, the high
    priority item will be dequeued first. All the steps are represented in *Figure
    7.20*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来理解优先队列。当我们按顺序接收数据元素时，元素将按照优先级（假设数据值越高，重要性越高）的顺序入队。首先，优先队列是空的，所以最初在队列中添加了`3`；下一个数据元素是`8`，由于它大于`3`，它将被入队到队列的起始位置。接下来是数据项`2`，然后是`6`，最后是`10`，它们按照优先级入队，当执行出队操作时，高优先级的项目将首先出队。所有步骤都在*图7.20*中表示：
- en: '![](img/B17217_07_20.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_07_20.png)'
- en: 'Figure 7.20: A step-by-step procedure to create a priority queue'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.20：创建优先队列的逐步过程
- en: 'Let us discuss the implementation of a priority queue in Python. We first define
    the node class. A node class will have the data elements along with the priority
    associated with the data in the priority queue:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论在Python中实现优先队列。我们首先定义节点类。节点类将包含与优先队列中的数据相关联的数据元素：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we define the `PriorityQueue` class and initialize the queue:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`PriorityQueue`类并初始化队列：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, let us discuss the implementation of the insertion operation for adding
    a new data element to the priority queue. In the implementation, we assume that
    the data element has high priority if it has a smaller priority value (for example,
    a data element with the priority value `1` has higher priority compared to the
    data element that has a priority value `4`). The following are cases of insertion
    of elements in a priority queue:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们讨论插入操作的实施，用于将新的数据元素添加到优先队列中。在实现中，我们假设数据元素的优先级值越小，优先级越高（例如，优先级值为`1`的数据元素比优先级值为`4`的数据元素优先级高）。以下是在优先队列中插入元素的案例：
- en: Insertion of a data element to the priority queue when the queue is initially
    empty.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当队列最初为空时，向优先队列中插入数据元素。
- en: If the queue is not empty, we perform the traversal of the queue and reach the
    appropriate index position in the queue according to the associated priorities
    by comparing the priorities of the existing node with the new node. We add the
    new node before the node that has a priority greater than the new node.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果队列不为空，我们执行队列的遍历，并通过比较现有节点与新节点的优先级，根据相关的优先级在队列中达到适当的索引位置。我们将在优先级高于新节点的节点之前添加新节点。
- en: If the new node has a lower priority than the high priority value, then the
    node will be added to the start of the queue.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果新节点的优先级低于高优先级值，则节点将被添加到队列的起始位置。
- en: 'The implementation of the `insert()` method is as follows, which should be
    defined in the `PriorityQueue` class:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert()` 方法的实现如下，它应该在 `PriorityQueue` 类中定义：'
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the above code, we first append a new data element when the queue is empty,
    and then we iteratively reach the appropriate position by comparing the priorities
    associated with the data elements.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，当队列为空时，我们首先添加一个新的数据元素，然后通过比较数据元素相关的优先级，迭代地达到适当的位置。
- en: 'Next, when we apply the delete operation in the priority queue, the highest
    priority data element is returned and removed from the queue. It should be defined
    in the `PriorityQueue` class as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当我们对优先队列应用删除操作时，最高优先级的数据元素将被返回并从队列中移除。它应该在`PriorityQueue`类中如下定义：
- en: '[PRE31]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding code, we get the top element with the highest priority value.
    Further, the implementation of the `show()` method that prints all the data elements
    of the priority queue in the order of the priorities should be defined in the
    `PriorityQueue` class:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们获取具有最高优先级值的顶级元素。进一步，实现`show()`方法，该方法应在`PriorityQueue`类中定义，用于按优先级顺序打印优先队列中的所有数据元素：
- en: '[PRE32]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let’s consider an example to see how to use the priority queue in which
    we firstly add data elements (`"Cat"`, “`Bat"`, `"Rat"`, `"Ant"`, and `"Lion"`)
    with associated priorities `13`, `2`, `1`, `26`, and `25`, respectively:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑一个例子，看看如何使用优先队列，我们首先添加具有相关优先级`13`、`2`、`1`、`26`和`25`的数据元素（`"Cat"`、`"Bat"`、`"Rat"`、`"Ant"`和`"Lion"`）：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output of the above code is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE34]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Priority queues can be implemented using several data structures; in the above
    example, we saw its implementation using a list of tuples where the tuple contains
    the priority as the first element and the value data item as the next element.
    However, the priority queues are mostly implemented using a heap, since it is
    efficient with the worst-case time complexity of `O(log n)` in insertion and deletion
    operations.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 优先队列可以使用几种数据结构实现；在上面的例子中，我们看到了使用包含优先级作为第一个元素和值数据项作为下一个元素的元组列表实现的示例。然而，优先队列通常使用堆实现，因为它在插入和删除操作中的最坏情况时间复杂度为`O(log
    n)`，因此效率很高。
- en: 'The implementation of the priority queue using heap is very similar to what
    we have discussed in the `min-heap` implementation. The only difference is that
    now we store the priorities associated with the data elements, and we create a
    `min-heap` tree considering the priority values using a list of tuples in Python.
    For completeness, the code for the priority queue using heaps is as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用堆实现优先队列的代码与我们在`min-heap`实现中讨论的非常相似。唯一的区别是现在我们存储与数据元素相关的优先级，并使用Python中的元组列表创建一个考虑优先级值的`min-heap`树。为了完整性，以下是用堆实现的优先队列的代码：
- en: '[PRE35]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We use the code below to create a priority queue with data elements `"Bat"`,
    `"Cat"`, `"Rat"`, `"Ant"`, `"Lion"`, and `"Bear"` with the associated priority
    values `2`, `13`, `18`, `26`, `3`, and `4`, respectively:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码创建一个包含数据元素`"Bat"`、`"Cat"`、`"Rat"`、`"Ant"`、`"Lion"`和`"Bear"`的优先队列，相应的优先级值分别为`2`、`13`、`18`、`26`、`3`和`4`：
- en: '[PRE36]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output of the above code is as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE37]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the above output, we can see that it shows a `min-heap` tree that adheres
    to the `min-heap` property. Now we can use the code below to remove the data elements:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以看到它显示了一个遵循`min-heap`属性的`min-heap`树。现在我们可以使用以下代码来删除数据元素：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE39]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the above output, we can see that the data items are produced according to
    the priorities associated with the data elements.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以看到数据项是按照与数据元素相关的优先级产生的。
- en: Summary
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed an important data structure, in other words,
    the heap data structure. We also discussed heap properties for `min-heap` and
    `max-heap`. We have seen the implementation of several operations that can be
    applied to the heap data structure, such as heapifying, and the insertion and
    deletion of a data element from the heap. We have also discussed two of the important
    applications of the heap—heap sort and a priority queue. The heap is an important
    data structure since it has many applications, such as sorting, selecting minimum
    and maximum values in a list, graph algorithms, and priority queues. Moreover,
    the heap can also be useful when we have to repeatedly remove a data object with
    the highest or lowest priority values.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了一个重要的数据结构，换句话说，就是堆数据结构。我们还讨论了`min-heap`和`max-heap`的堆属性。我们看到了可以应用于堆数据结构的几个操作的实现，例如堆化、从堆中插入和删除数据元素。我们还讨论了堆的两个重要应用——堆排序和优先队列。堆是一个重要的数据结构，因为它有多个应用，例如排序、在列表中选择最小和最大值、图算法和优先队列。此外，当我们需要反复删除具有最高或最低优先级值的数据对象时，堆也可能很有用。
- en: In the next chapter, we will discuss the concepts of **Hashing** and **Symbol
    Tables**.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论**哈希**和**符号表**的概念。
- en: Exercises
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: What will be the time complexity for deleting an arbitrary element from the
    `min-heap`?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`min-heap`中删除任意元素的时间复杂度是多少？
- en: What will be the time complexity for finding the `kth` smallest element from
    the `min-heap`?
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查找`min-heap`中第`k`个最小元素的时间复杂度是多少？
- en: What will be the worst-case time complexity for ascertaining the smallest element
    from a binary `max-heap` and binary `min-heap`?
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从二叉`max-heap`和二叉`min-heap`中确定最小元素的最坏情况时间复杂度是多少？
- en: What will be the time complexity to make a `max-heap` that combines two `max-heap`
    each of size `n`?
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个大小为`n`的`max-heap`合并成一个`max-heap`的时间复杂度是多少？
- en: The level order traversal of `max-heap` is `12`, `9`, `7`, `4`, and `2`. After
    inserting new elements `1` and `8`, what will be the final `max-heap` and the
    level order traversal of the final `max-heap`?
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`max-heap`的层序遍历是`12`、`9`、`7`、`4`和`2`。在插入新元素`1`和`8`之后，最终的`max-heap`和最终的`max-heap`的层序遍历将是什么？'
- en: Which of the following is a binary `max-heap`?
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个是二叉`max-heap`？
- en: '![Diagram  Description automatically generated](img/B17217_07_21.png)![Diagram  Description
    automatically generated](img/B17217_07_22.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.21：示例树](img/B17217_07_21.png)![图 7.21：示例树](img/B17217_07_22.png)'
- en: 'Figure 7.21: Example trees'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21：示例树
- en: Join our community on Discord
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的 Discord 空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1421249772551223062.png)'
