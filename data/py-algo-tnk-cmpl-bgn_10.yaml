- en: Chapter 4
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章
- en: Introduction to Basic Algorithmic Concepts
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 基本算法概念简介
- en: 4.1 What is an Algorithm?
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1 什么是算法？
- en: In technical terms, an algorithm^([[1]](footnotes.html#Endnote_1)) is a strictly
    defined finite sequence of well-defined statements (often called instructions
    or commands) that provides the solution to a problem or to a specific class of
    problems for any acceptable set of input values (if there are any inputs). In
    other words, an algorithm is a step-by-step procedure to solve a given problem.
    The term finite means that the algorithm must reach an end point and cannot run
    forever.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上讲，算法^([[1]](footnotes.html#Endnote_1))是一个严格定义的有限序列，由定义良好的语句（通常称为指令或命令）组成，为任何可接受的输入值集（如果有输入）提供问题的解决方案或特定类问题的解决方案。换句话说，算法是解决给定问题的逐步过程。有限意味着算法必须达到终点，不能无限期地运行。
- en: You can find algorithms everywhere in your real life, not just in computer science.
    For instance, the process of preparing toast or a cup of tea can be expressed
    as an algorithm. Certain steps, in a particular order, must be followed to achieve
    your goal.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的现实生活中，您可以在任何地方找到算法，而不仅仅是计算机科学中。例如，准备吐司或一杯茶的过程可以用算法来表示。为了达到目标，必须遵循特定顺序的某些步骤。
- en: 4.2 The Algorithm for Making a Cup of Tea
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2 制作一杯茶的算法
- en: The following is an algorithm for making a cup of tea.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个制作一杯茶的算法。
- en: 1)Put a teabag in a cup.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 1)在杯子中放入一袋茶叶。
- en: 2)Fill a kettle with water.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 2)往壶里加水。
- en: 3)Boil the water in the kettle.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 3)在壶中烧开水。
- en: 4)Pour some of the boiled water into the cup.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 4)将一些沸水倒入杯子中。
- en: 5)Add milk to the cup.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 5)向杯子中加入牛奶。
- en: 6)Add sugar to the cup.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 6)向杯子中加入糖。
- en: 7)Stir the tea.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 7)搅拌茶。
- en: 8)Drink the tea.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 8)喝茶。
- en: As you can see, certain steps must be followed. These steps are in a specific
    order, even though some of the steps could be rearranged. For example, steps 5
    and 6 can be reversed. You could add the sugar first, and the milk afterwards.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，必须遵循某些步骤。这些步骤有特定的顺序，尽管某些步骤可以重新排列。例如，步骤5和6可以颠倒。您可以先加糖，然后加牛奶。
- en: '![](img/notice.jpg)Keep in mind that the order of some steps can probably be
    changed but you can''t move them far away from where they should be. For example,
    you can''t move step 3 (“Boil the water in the kettle.”) to the end of the algorithm,
    because you will end up drinking a cup of iced tea (and not a warm one) which
    is totally different from your initial goal!'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)请记住，某些步骤的顺序可能可以改变，但您不能将它们移得太远。例如，您不能将步骤3（“在壶中烧开水。”）移到算法的末尾，因为您最终会喝到一杯冰茶（而不是一杯热茶），这与您的初始目标完全不同！'
- en: 4.3 Properties of an Algorithm
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3 算法的性质
- en: 'In his book The Art of Computer Programming, Volume 1: Fundamental Algorithms,
    Donald E. Knuth^([[3]](footnotes.html#Endnote_3)) asserts that an algorithm must
    satisfy the following five properties:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的书《计算机程序设计艺术》第一卷《基本算法》中，Donald E. Knuth^([[3]](footnotes.html#Endnote_3))断言，一个算法必须满足以下五个属性：
- en: '►Input: The algorithm must have input values from a specified set.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ►输入：算法必须从指定的一组输入值中获取。
- en: '►Output: The algorithm must produce the output values from a specified set
    of input values. The output values are the solution to a problem.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ►输出：算法必须从指定的一组输入值产生输出值。输出值是问题的解决方案。
- en: '►Finiteness: For any input, the algorithm must terminate after a finite number
    of steps.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ►有限性：对于任何输入，算法必须在有限步骤后终止。
- en: '►Definiteness: All steps of the algorithm must be precisely defined. Every
    instruction within the algorithm should be clear and unambiguous. An algorithm
    must explicitly describe how the computation is to be carried out. The property
    of definiteness ensures that the agent executing the instructions will always
    know which command to perform next. Some examples of algorithms that do not satisfy
    the property of definiteness are:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: ►确定性：算法的所有步骤都必须精确定义。算法中的每条指令都应该是清晰且无歧义的。算法必须明确描述如何执行计算。确定性的属性确保执行指令的代理将始终知道下一步要执行哪个命令。以下是一些不满足确定性属性的算法示例：
- en: ►an algorithm that involves dividing a number by zero without any checks or
    safeguards. Dividing by zero is mathematically undefined, and an algorithm that
    doesn't handle this scenario can lead to unexpected results or errors in the computation.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ►一个涉及除以零的算法，没有任何检查或保护措施。除以零在数学上是未定义的，而未处理此场景的算法可能导致计算中出现意外的结果或错误。
- en: ►an algorithm that attempts to calculate the square root of a negative number
    without accounting for complex numbers. The square root of a negative number is
    not a real number but a complex one. If the algorithm doesn't handle this properly,
    it might produce invalid or nonsensical results.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ►一个试图计算负数平方根而不考虑复数的算法。负数的平方根不是一个实数，而是一个复数。如果算法没有正确处理这个问题，它可能会产生无效或不合逻辑的结果。
- en: '►Effectiveness: It refers to the ability of an algorithm to consistently and
    accurately produce a meaningful and correct result for all possible valid inputs
    (including edge cases) within a finite amount of time. The steps of the algorithm
    must be basic enough so that, for example, someone using a pencil and paper could
    carry them out exactly.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ►效率：它指的是算法在有限的时间内，对于所有可能的合法输入（包括边缘情况）持续且准确地产生有意义且正确结果的能力。算法的步骤必须足够基本，以便例如，使用铅笔和纸的人可以精确地执行它们。
- en: 4.4 Okay About Algorithms. But What is a Computer Program Anyway?
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4 关于算法，我们可以说得很好。但计算机程序究竟是什么呢？
- en: A computer program is nothing more than an algorithm that is written in a language
    that computers can understand, like Python, Java, C++, or C#.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序不过是用计算机可以理解的语言（如Python、Java、C++或C#）编写的算法。
- en: A computer program cannot actually make you a cup of tea or cook your dinner,
    although an algorithm can guide you through the steps to do it yourself. However,
    programs can (for example) be used to calculate the average value of a set of
    numbers, or to find the maximum value among them. Artificial intelligence programs
    can even play chess or solve logic puzzles.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序实际上不能帮你泡一杯茶或做一顿饭，尽管算法可以指导你完成这些步骤。然而，程序可以（例如）用来计算一组数字的平均值，或者找出其中的最大值。人工智能程序甚至可以下棋或解决逻辑谜题。
- en: 4.5 The Three Parties!
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5 三方当事人！
- en: There are always three parties involved in an algorithm—the one that writes
    the algorithm, the one that executes it, and the one that uses or enjoys it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法中总是涉及三方当事人——编写算法的一方、执行算法的一方以及使用或享受算法的一方。
- en: Let's take an algorithm for preparing a meal, for example. Someone writes the
    algorithm (the author of the recipe book), someone executes it (probably your
    mother, who prepares the meal following the steps from the recipe book), and someone
    uses it (probably you, who enjoys the meal).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以准备餐点的算法为例。有人编写算法（食谱书的作者），有人执行它（可能是你的母亲，她根据食谱书的步骤准备餐点），有人使用它（可能是你，你享受着这顿饭）。
- en: Now consider a real computer program. Let's take a video game, for example.
    Someone writes the algorithm in a computer language (the programmer), something
    executes it (usually a laptop or a computer), and someone uses it or plays with
    it (the user).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个真实的计算机程序。以视频游戏为例。有人用计算机语言编写算法（程序员），有人执行它（通常是笔记本电脑或计算机），有人使用它或与之互动（用户）。
- en: Be cautious, as sometimes the terms “programmer” and “user” can be a source
    of ambiguity. When you write a computer program, you temporarily assume the role
    of “the programmer” but when you use your own program, you take on the role of
    “the user”.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，有时“程序员”和“用户”这两个术语可能会引起歧义。当你编写计算机程序时，你暂时扮演“程序员”的角色，但当你使用自己的程序时，你则扮演“用户”的角色。
- en: 4.6 The Three Main Stages Involved in Creating an Algorithm
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.6 创建算法涉及到的三个主要阶段
- en: 'An algorithm should consist of three stages: data input, data processing, and
    results output. This order is specific and cannot be changed.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法应该由三个阶段组成：数据输入、数据处理和结果输出。这个顺序是特定的，不能改变。
- en: Consider a computer program that finds the average value of three numbers. First,
    the program must prompt (ask) the user to enter the numbers (the data input stage).
    Next, the program must calculate the average value of the numbers (the data processing
    stage). Finally, the program must display the result on the computer's screen
    (the results output stage).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个寻找三个数字平均值的计算机程序。首先，程序必须提示（询问）用户输入数字（数据输入阶段）。接下来，程序必须计算数字的平均值（数据处理阶段）。最后，程序必须在计算机屏幕上显示结果（结果输出阶段）。
- en: Let's take a look at these stages in more detail.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些阶段。
- en: First stage – Data input
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段 – 数据输入
- en: 1)Prompt the user to enter a number.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 1)提示用户输入一个数字。
- en: 2)Prompt the user to enter a second number.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2)提示用户输入第二个数字。
- en: 3)Prompt the user to enter a third number.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 3)提示用户输入第三个数字。
- en: Second stage – Data processing
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段 – 数据处理
- en: 4)Calculate the sum of the three numbers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 4)计算三个数字的和。
- en: 5)Divide the sum by 3.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 5)将和除以3。
- en: Third stage – Results output
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段 – 结果输出
- en: 6)Display the result on the screen.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 6)在屏幕上显示结果。
- en: In some rare situations, the input stage may be absent and the computer program
    may consist of only two stages. For example, consider a computer program that
    is written to calculate the following sum.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些罕见的情况下，输入阶段可能不存在，计算机程序可能只包含两个阶段。例如，考虑一个编写来计算以下和的计算机程序。
- en: 1 + 2 + 3 + 4 + 5
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 1 + 2 + 3 + 4 + 5
- en: In this example, the user must enter no values at all because the computer program
    knows exactly what to do. It must calculate the sum of the numbers 1 to 5 and
    then display the value of 15 on the user's screen. The two required stages (data
    processing and results output) are shown here.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，用户必须输入没有任何值，因为计算机程序知道确切要做什么。它必须计算从1到5的数字之和，然后在用户的屏幕上显示15的值。这里显示了两个必需的阶段（数据处理和结果输出）。
- en: First stage – Data input
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段 – 数据输入
- en: Nothing to do
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 没有事情要做
- en: Second stage – Data processing
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段 – 数据处理
- en: 1)Calculate the sum of 1 + 2 + 3 + 4 + 5.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 1)计算1 + 2 + 3 + 4 + 5的和。
- en: Third stage – Results output
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段 – 结果输出
- en: 2)Display the result on the screen.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 2)在屏幕上显示结果。
- en: However, what if you want to let the user decide the upper limit of that sum?
    What if you want to let the user decide whether to sum the numbers 1 to 5 or the
    numbers 1 to 20? In that case, the program must include an input stage at the
    beginning of the program to let the user enter that upper limit. Once the user
    enters that upper limit, the computer can calculate the result. The three required
    stages are shown here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你想让用户决定那个和的上限呢？如果你想让用户决定是计算1到5的数字之和还是1到20的数字之和呢？在这种情况下，程序必须在程序开始时包含一个输入阶段，让用户输入那个上限。一旦用户输入了那个上限，计算机就可以计算出结果。这里显示了三个必需的阶段。
- en: First stage – Data input
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段 – 数据输入
- en: 1)Prompt the user to enter a number.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 1)提示用户输入一个数字。
- en: Second stage – Data processing
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段 – 数据处理
- en: 2)Calculate the sum 1 + 2 + … (up to and including the upper limit the user
    entered).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 2)计算和1 + 2 + …（直到用户输入的上限，包括上限）。
- en: Third stage – Results output
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段 – 结果输出
- en: 3)Display the results on the screen.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 3)在屏幕上显示结果。
- en: For example, if the user enters the number 6 as the upper limit, the computer
    would find the result of 1 + 2 + 3 + 4 + 5 + 6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果用户将数字6作为上限输入，计算机将找到1 + 2 + 3 + 4 + 5 + 6的结果。
- en: 4.7 Flowcharts
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.7 流程图
- en: A flowchart is a graphical method of presenting an algorithm, usually on paper.
    It is the visual representation of the algorithm's flow of execution. In other
    words, it visually represents how the flow of execution proceeds from one statement
    to the next until the end of the algorithm is reached. The basic symbols that
    flowcharts use are shown in Table 4-1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 流程图是一种图形化展示算法的方法，通常在纸上进行。它是算法执行流程的视觉表示。换句话说，它以视觉方式表示执行流程如何从一个语句继续到下一个语句，直到算法结束。流程图使用的基本符号如表4-1所示。
- en: '| Flowchart Symbols | Description |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 流程图符号 | 描述 |'
- en: '| .![Image](img/chapter04-01.png) | Start/End: Represents the beginning or
    the end of an algorithm. The Start symbol has one exit and the End symbol has
    one entrance. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| .![Image](img/chapter04-01.png) | 开始/结束：表示算法的开始或结束。开始符号有一个出口，结束符号有一个入口。|'
- en: '| .![Image](img/chapter04-02.png) | Arrow: Shows the flow of execution. An
    arrow coming from one symbol and ending at another symbol shows that control passes
    to the symbol that the arrow is pointing to. Arrows are always drawn as straight
    lines going up and down or sideways (never at an angle). |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| .![Image](img/chapter04-02.png) | 箭头：显示执行流程。从一个符号开始并结束在另一个符号上的箭头表示控制传递到箭头指向的符号。箭头总是以直线形式向上、向下或横向绘制（永远不会以角度绘制）。|'
- en: '| .![Image](img/chapter04-03.png) | Process: Represents a process or mathematical
    (formula) calculation. The Process symbol has one entrance and one exit. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| .![Image](img/chapter04-03.png) | 处理：表示一个过程或数学（公式）计算。处理符号有一个入口和一个出口。|'
- en: '| .![Image](img/chapter04-04.png) | Data Input/Output: Represents the data
    input or the results output. In most cases, data comes from a keyboard and results
    are displayed on a screen. The Data input/output symbol has one entrance and one
    exit. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| .![Image](img/chapter04-04.png) | 数据输入/输出：表示数据输入或结果输出。在大多数情况下，数据来自键盘，结果显示在屏幕上。数据输入/输出符号有一个入口和一个出口。|'
- en: '| .![Image](img/chapter04-05.png) | Decision: Indicates the point at which
    a decision is made. Based on a given condition (which can be true or false), the
    algorithm will follow either the right or the left path. The Decision symbol has
    one entrance and two (and always only two) exits. |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](img/chapter04-05.png) | 决策：表示做出决策的点。基于给定的条件（可以是真或假），算法将遵循右或左的路径。决策符号有一个入口和两个（并且始终只有两个）出口。
    |'
- en: '| .![Image](img/chapter04-06.png) | Definite Loop: Shows the repetition of
    a statement or block of statements for a predefined number of times. The Definite
    Loop symbol has one entrance and one exit. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](img/chapter04-06.png) | 确定循环：表示一个语句或语句块重复预定义的次数。确定循环符号有一个入口和一个出口。
    |'
- en: '| .![Image](img/chapter04-07.png) | Off‑page connectors: Show continuation
    of a flowchart onto another page. They are used to connect segments on multiple
    pages when a flowchart gets too big to fit onto one sheet of paper. The outgoing
    off‑page connector symbol has one entrance and the incoming off‑page connector
    symbol has one exit. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| ![Image](img/chapter04-07.png) | 离页连接符：表示流程图在另一页的延续。当流程图太大而无法适应一张纸时，它们用于连接多页上的段。离页连接符符号有一个入口，而进入页连接符符号有一个出口。
    |'
- en: Table 4-1 Flowchart symbols and their functions
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 表4-1 流程图符号及其功能
- en: An example of a flowchart is shown in Figure 4–1\. The algorithm prompts the
    user to enter three numbers and then calculates their average value and displays
    it on the computer screen.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图4–1展示了流程图的示例。算法提示用户输入三个数字，然后计算它们的平均值并在计算机屏幕上显示。
- en: .![Image](img/chapter04-08.png)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](img/chapter04-08.png)'
- en: Figure 4–1 Flowchart for an algorithm that calculates and displays the average
    of three numbers
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图4–1 计算并显示三个数字平均值的算法流程图
- en: '![](img/remember.jpg)A flowchart always begins and ends with a Start/End symbol!'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](img/remember.jpg)流程图始终以Start/End符号开始和结束！'
- en: Exercise 4.7-1 Finding the Average Value of Three Numbers
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习4.7-1 找到三个数字的平均值
- en: Design an algorithm that calculates the average value of three numbers. Whenever
    the average value is below 10, a message “Fail!” must be displayed. Otherwise,
    if the average value is 10 or above, a message “Pass!” must be displayed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个算法，用于计算三个数字的平均值。每当平均值低于10时，必须显示消息“Fail!”。否则，如果平均值是10或以上，必须显示消息“Pass!”。
- en: Solution
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案
- en: In this problem, two different messages must be displayed, but only one can
    appear each time the algorithm is executed; the wording of the message depends
    on the average value. The flowchart for the algorithm is presented here.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，必须显示两个不同的消息，但每次算法执行时只能出现一个；消息的措辞取决于平均值。算法的流程图在此展示。
- en: '![Image](img/chapter04-09.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter04-09.png)'
- en: '![](img/notice.jpg)To save paper, you can prompt the user to enter all three
    numbers using one single oblique parallelogram.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](img/notice.jpg)为了节省纸张，你可以提示用户使用一个单独的斜平行四边形输入所有三个数字。'
- en: '![](img/remember.jpg)A Decision symbol always has one entrance and two exit
    paths!'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '![Image](img/remember.jpg)决策符号始终有一个入口和两个出口路径！'
- en: Of course it is very soon for you to start creating your own algorithms. This
    particular exercise is quite simple and is presented in this chapter as an exception,
    just for demonstration purposes. You need to learn more before you start creating
    your own algorithms or even Python programs. Just be patient! In a few chapters
    the big moment will come!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，很快你就可以开始创建自己的算法了。这个特定的练习相当简单，在本章中作为例外，仅用于演示目的。在开始创建自己的算法或甚至Python程序之前，你需要学习更多。只需耐心等待！在接下来的几章中，重大时刻将会到来！
- en: 4.8 What are ”Reserved Words”?
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.8 什么是“保留字”？
- en: In a computer language, a reserved word (or keyword) is a word that has a strictly
    predefined meaning—it is reserved for special use and cannot be used for any other
    purpose. For example, the words Start, End, Read, and Write in flowcharts have
    a predefined meaning. They are used to represent the beginning, the end, the data
    input, and the results output, respectively.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机语言中，保留字（或关键字）是一个具有严格预定义意义的词——它被保留用于特殊用途，不能用于其他任何目的。例如，流程图中的Start、End、Read和Write这些词具有预定义的意义。它们分别用于表示开始、结束、数据输入和结果输出。
- en: Reserved words exist in all high-level computer languages. In Python, there
    are many reserved words such as if, while, else, and for. However, each language
    has its own set of reserved words. For example, the reserved words else if in
    C++ are written as elif in Python.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 所有高级计算机语言都存在保留字。在Python中，有诸如if、while、else和for等许多保留字。然而，每种语言都有自己的保留字集合。例如，C++中的保留字else
    if在Python中写作elif。
- en: 4.9 What is the Difference Between a Statement and a Command?
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.9 陈述和命令的区别是什么？
- en: There is a big discussion on the Internet about whether there is, or is not,
    any difference between a statement and a command. Some people prefer to use the
    term “statement”, and some others the term “command”. For a novice programmer,
    there is no difference; both are instructions to the computer!
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于是否存在陈述和命令之间的区别，互联网上存在很大的讨论。有些人喜欢使用“陈述”这个词，而有些人则使用“命令”。对于初学者程序员来说，两者没有区别；两者都是对计算机的指令！
- en: 4.10 What is Structured Programming?
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.10 什么是结构化编程？
- en: The structured programming concept was formalized in 1966 by Corrado Böhm^([[4]](footnotes.html#Endnote_4))
    and Giuseppe Jacopini^([[5]](footnotes.html#Endnote_5)). They demonstrated theoretical
    computer program design using sequences, decisions, and iterations.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程的概念于1966年由Corrado Böhm^([[4]](footnotes.html#Endnote_4))和Giuseppe Jacopini^([[5]](footnotes.html#Endnote_5))正式化。他们通过序列、决策和迭代展示了理论计算机程序设计。
- en: 4.11 The Three Fundamental Control Structures
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.11 三种基本控制结构
- en: There are three fundamental control structures in structured programming.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化编程中有三种基本控制结构。
- en: '►Sequence Control Structure: This refers to the line-by-line execution, in
    which statements are executed sequentially, in the same order in which they appear
    in the program, without skipping any of them. It is also known as a sequential
    control structure.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ►顺序控制结构：这指的是逐行执行，其中语句按其在程序中出现的顺序依次执行，不跳过任何一条。它也被称为顺序控制结构。
- en: '►Decision Control Structure: Depending on whether a condition is true or false,
    the decision control structure may skip the execution of an entire block of statements
    or even execute one block of statements instead of another. It is also known as
    a selection control structure.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ►决策控制结构：根据条件是真是假，决策控制结构可能会跳过执行整个语句块，甚至执行一个语句块而不是另一个。它也被称为选择控制结构。
- en: '►Loop Control Structure: This is a control structure that allows the execution
    of a block of statements multiple times until a specified condition is met. It
    is also known as an iteration control structure or a repetition control structure.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ►循环控制结构：这是一种允许执行一个语句块多次，直到满足指定条件为止的控制结构。它也被称为迭代控制结构或重复控制结构。
- en: '![](img/notice.jpg)Every computer program around the world is written in terms
    of only these three control structures!'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)世界上所有的计算机程序都是基于这三种控制结构编写的！'
- en: Exercise 4.11-1 Understanding Control Structures Using Flowcharts
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 练习4.11-1 使用流程图理解控制结构
- en: Using flowcharts, give an example for each type of control structure.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用流程图，为每种控制结构提供一个示例。
- en: Solution
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 解答
- en: Example of a Sequence Control Structure
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序控制结构示例
- en: .![Image](img/chapter04-10.png)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: .![Image](img/chapter04-10.png)
- en: Example of a Decision Control Structure
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 决策控制结构示例
- en: '![Image](img/chapter04-11.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter04-11.png)'
- en: Example of a Loop Control Structure
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 循环控制结构示例
- en: '![Image](img/chapter04-12.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![Image](img/chapter04-12.png)'
- en: If you didn't quite understand the deeper meaning of these three control structures,
    don't worry, because upcoming chapters will analyze them very thoroughly. Patience
    is a virtue. All you have to do for now is wait!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有完全理解这三种控制结构的深层含义，不要担心，因为接下来的章节将非常彻底地分析它们。耐心是一种美德。你现在需要做的就是等待！
- en: 4.12 Your First Python Program
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.12 你的第一个Python程序
- en: Converting a flowchart to a computer language such as Python results in a Python
    program. A Python program is nothing more than a text file including Python statements.
    Python programs can even be written in your text editor application! Keep in mind,
    though, that using IDLE or Visual Studio Code to write Python programs is a much
    better solution due to all of their included features that can make your life
    easier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将流程图转换为如Python这样的计算机语言将产生一个Python程序。Python程序不过是一个包含Python语句的文本文件。你甚至可以在你的文本编辑器应用程序中编写Python程序！不过，请记住，使用IDLE或Visual
    Studio Code编写Python程序是一个更好的解决方案，因为它们包含的所有功能都可以使你的生活变得更轻松。
- en: '![](img/remember.jpg)A Python source code is saved on your hard disk with the
    default .py file extension.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '![记住](img/remember.jpg)Python源代码以默认的.py文件扩展名保存在您的硬盘上。'
- en: Here is a very simple algorithm that displays three messages on the screen.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的算法，它在屏幕上显示三条消息。
- en: .![Image](img/chapter04-13.png)
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: .![图像](img/chapter04-13.png)
- en: And here is the same algorithm written as a Python program.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是同样的算法，以Python程序的形式编写。
- en: print("Hello World!")
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello World!")
- en: print("Hallo Welt!")
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hallo Welt!")
- en: print("The End")
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: print("The End")
- en: 4.13 What is the Difference Between a Syntax Error, a Logic Error, and a Runtime
    Error?
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.13 语法错误、逻辑错误和运行时错误之间的区别是什么？
- en: 'When high-level language code is written or executed, three types of errors
    may occur: syntax errors, logic errors, and runtime errors.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写或执行高级语言代码时，可能会发生三种类型的错误：语法错误、逻辑错误和运行时错误。
- en: A syntax error is a mistake such as a misspelled keyword, a missing punctuation
    character, or a missing closing bracket. The syntax errors are detected by the
    compiler or the interpreter. If you try to execute a Python program that contains
    a syntax error, you will get an error message on your screen and the program won't
    execute. You must correct any errors and then try to execute the program again.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 语法错误是拼写错误、缺少标点符号或缺少闭合括号等错误。语法错误由编译器或解释器检测。如果你尝试执行包含语法错误的Python程序，你会在屏幕上收到错误消息，程序将不会执行。你必须纠正任何错误，然后再次尝试执行程序。
- en: '![](img/notice.jpg)Some IDEs, such as Visual Studio Code, detect these errors
    as you type and underline the erroneous statements with a wavy red line.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)一些IDE，如Visual Studio Code，会在你输入时检测这些错误，并用波浪形红线下划线标记错误的语句。'
- en: A logic error is an error that prevents your program from doing what you expected
    it to do. With logic errors you get no warning at all. Your code compiles and
    runs but the result is not the expected one. Logic errors are hard to detect.
    You must review your program thoroughly to find out where your error is. For example,
    consider a Python program that prompts the user to enter three numbers, and then
    calculates and displays their average value. In this program, however, the programmer
    made a typographical error (a “typo”); one of their statements divides the sum
    of the three numbers by 5, and not by 3 as it should. Of course the Python program
    executes as normal, without any error messages, prompting the user to enter three
    numbers and displaying a result, but obviously not the correct one! It is the
    programmer's responsibility to find and correct the erroneously written Python
    statement, not the computer, the interpreter or the compiler! Computers are not
    that smart after all!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑错误是阻止你的程序执行你期望它执行的操作的错误。在逻辑错误中，你根本不会收到任何警告。你的代码可以编译并运行，但结果并不是预期的。逻辑错误很难检测。你必须彻底审查你的程序，以找出错误所在。例如，考虑一个Python程序，该程序提示用户输入三个数字，然后计算并显示它们的平均值。然而，在这个程序中，程序员犯了一个打字错误（一个“typo”）；他们的一个语句将三个数字的总和除以5，而不是应该的3。当然，Python程序会像往常一样执行，没有任何错误消息，提示用户输入三个数字并显示一个结果，但显然不是正确的结果！找出并纠正错误编写的Python语句是程序员的职责，而不是计算机、解释器或编译器！毕竟，计算机并不那么聪明！
- en: A runtime error is an error that occurs during the execution of a program. A
    runtime error can cause a program to end abruptly or even cause system shut-down.
    Such errors are the most difficult errors to detect. There is no way to be sure,
    before executing the program, whether this error is going to happen, or not. You
    can suspect that it may happen though! For example, running out of memory or a
    division by zero causes a runtime error.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时错误是在程序执行过程中发生的错误。运行时错误可能导致程序突然终止，甚至导致系统关闭。这类错误是最难检测的。在执行程序之前，无法确定是否会发生此类错误。尽管如此，你可以怀疑它可能会发生！例如，内存不足或除以零会导致运行时错误。
- en: '![](img/notice.jpg)A logic error can be the cause of a runtime error!'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)逻辑错误可能是运行时错误的原因！'
- en: '![](img/notice.jpg)Logic errors and runtime errors are commonly referred to
    as "bugs", and are often found during the debugging process, before the software
    is released. When errors are found after a software has been released to the public,
    programmers often release patches, or small updates, to fix the errors.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![注意](img/notice.jpg)逻辑错误和运行时错误通常被称为“bug”，通常在软件发布前的调试过程中被发现。当软件发布后发现问题，程序员通常会发布补丁或小更新来修复错误。'
- en: 4.14 What “Debugging” Means
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.14 “调试”是什么意思
- en: Debugging is the process of finding and reducing the number of defects (bugs)
    in a computer program, in order to make it perform as expected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是寻找和减少计算机程序中缺陷（错误）的过程，以便使其按预期运行。
- en: There is a myth about the origin of the term “debugging”. In 1940, while Grace
    Hopper^([[6]](footnotes.html#Endnote_6)) was working on a Mark II Computer at
    Harvard University, her associates discovered a bug (a moth) stuck in a relay
    (an electrically operated switch). This bug was blocking the proper operation
    of the Mark II computer. So, while her associates where trying to remove the bug,
    Grace Hopper remarked that they were “debugging” the system!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“调试”一词起源有一个神话。1940年，当Grace Hopper^([[6]](footnotes.html#Endnote_6))在哈佛大学研究Mark
    II计算机时，她的同事发现了一只虫子（一只蛾）卡在继电器（一个电动开关）中。这个虫子阻碍了Mark II计算机的正常运行。因此，当她的同事试图移除虫子时，Grace
    Hopper评论说他们正在“调试”系统！
- en: 4.15 Commenting Your Code
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.15 注释你的代码
- en: When you write a small and easy program, anyone can understand how it works
    just by reading it line-by-line. However, long programs are difficult to understand,
    sometimes even by the same person who wrote them.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写一个简单易懂的程序时，任何人都可以通过逐行阅读来理解它是如何工作的。然而，长程序很难理解，有时即使是编写程序的人也难以理解。
- en: 'Comments are extra information that can be included in a program to make it
    easier to read and understand. Using comments, you can add explanations and other
    pieces of information, including:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注释是可以在程序中包含的额外信息，可以使程序更容易阅读和理解。使用注释，你可以添加解释和其他信息，包括：
- en: ►who wrote the program
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ►谁编写了程序
- en: ►when the program was created or last modified
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ►程序创建或最后修改的时间
- en: ►what the program does
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ►程序做什么
- en: ►how the program works
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ►程序是如何工作的
- en: '![](img/notice.jpg)Comments are for human readers. Compilers and interpreters
    ignore any comments you may add to your programs.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)注释是为了方便人类读者阅读。编译器和解释器会忽略你程序中添加的任何注释。'
- en: However, you should not over-comment. There is no need to explain every line
    of your program. Add comments only when a particular portion of your program is
    hard to follow.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你不应该过度注释。没有必要解释程序中的每一行。只有当程序中的某个特定部分难以理解时，才添加注释。
- en: 'In Python, you can add comments using the hash character ( # ) as shown here.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，你可以使用哈希字符（#）添加注释，如下所示。
- en: '#Created By Aristides S. Bouras'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '#由Aristides S. Bouras创建'
- en: '#Date created: 12/25/2003'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '#创建日期：2003年12月25日'
- en: '#Date modified: 04/03/2008'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '#修改日期：2008年4月3日'
- en: '#Description: This program displays some messages on the screen'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '#描述：此程序在屏幕上显示一些信息'
- en: print("Hello Zeus!")  #It displays a message on the screen
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello Zeus!")  #它在屏幕上显示一条信息
- en: '#Display a second message on the screen'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '#在屏幕上显示第二条信息'
- en: print("Hello Hera!")
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: print("Hello Hera!")
- en: '#This is a comment        print("The End")'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '#这是一个注释 print("The End")'
- en: As you can see in the preceding program, you can add comments above a statement
    or at the end of it, but not in front of it. Look at the last statement, which
    is supposed to display the message “The End”. This statement is never executed
    because it is considered part of the comment.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的程序中看到的，你可以在语句上方或语句末尾添加注释，但不能在语句前方添加。看看最后一个语句，它本应显示信息“结束”。这个语句永远不会被执行，因为它被认为是注释的一部分。
- en: '![](img/notice.jpg)Comments are not visible to the user of a program while
    the program runs.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![](img/notice.jpg)当程序运行时，注释对程序的用户是不可见的。'
- en: 4.16 User-Friendly Programs
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.16 用户友好的程序
- en: What is a user-friendly program? It's one the user considers a friend instead
    of an enemy, one that is easy for a novice user.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是用户友好的程序？它是用户认为它是朋友而不是敌人的程序，对新手用户来说很容易使用。
- en: If you want to write user-friendly programs you have to put yourself in the
    shoes of the user. Users want the computer to do their job their way, with a minimum
    of effort. Hidden menus, unclear labels and directions, and misleading error messages
    can all make a program user-unfriendly!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要编写用户友好的程序，你必须站在用户的角度思考。用户希望电脑按照他们的方式工作，以最小的努力完成工作。隐藏的菜单、不清晰的标签和指示，以及误导性的错误信息都可能使程序变得不友好！
- en: 'The law that best defines user-friendly designs is the Law of Least Astonishment:
    “The program should act in a way that least astonishes the user”. This law is
    also commonly referred to as the Principle of Least Astonishment (POLA).'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳定义用户友好设计的定律是“最小惊讶定律”：程序应该以最不令用户惊讶的方式行事。这个定律也通常被称为最小惊讶原则（POLA）。
- en: '4.17 Review Questions: True/False'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.17 复习问题：对/错
- en: Choose true or false for each of the following statements.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下每个陈述选择对或错。
- en: 1)A recipe for a meal is actually an algorithm.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 1)一份食谱实际上是一个算法。
- en: 2)Algorithms are used only in computer science.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 2)算法仅在计算机科学中使用。
- en: 3)An algorithm can run forever.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 3)一个算法可以无限期地运行。
- en: 4)In an algorithm, you can relocate a step in any position you wish.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 4)在算法中，你可以将任何步骤移动到任何你希望的位置。
- en: 5)An algorithm must produce the correct output values for at least one set of
    input values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 5)算法必须为至少一组输入值产生正确的输出值。
- en: 6)Computers can play chess.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 6)计算机可以下棋。
- en: 7)An algorithm can always become a computer program.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 7)一个算法总能成为一个计算机程序。
- en: 8)Programming is the process of creating a computer program.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 8)编程是创建计算机程序的过程。
- en: '9)There are always three parties involved in a computer program: the programmer,
    the computer, and the user.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 9)在计算机程序中，总是涉及三方：程序员、计算机和用户。
- en: 10)The programmer and the user can sometimes be the same person.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 10)程序员和用户有时可以是同一个人。
- en: 11)It is possible for a computer program to output no results.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 11)计算机程序可能不会输出任何结果。
- en: 12)A flowchart is a computer program.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 12)流程图是一种计算机程序。
- en: 13)A flowchart is composed of a set of geometric shapes.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 13)流程图由一组几何形状组成。
- en: 14)A flowchart is a method used to represent an algorithm.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 14)流程图是表示算法的一种方法。
- en: 15)To represent an algorithm, you can design a flowchart without using any Start/End
    symbols.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 15)为了表示一个算法，你可以设计一个流程图而不使用任何开始/结束符号。
- en: 16)You can design a flowchart without using any Process symbols.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 16)你可以设计一个流程图而不使用任何流程符号。
- en: 17)You can design a flowchart without using any Data input/output symbols.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 17)你可以设计一个流程图而不使用任何数据输入/输出符号。
- en: 18)A flowchart must always include at least one Decision symbol.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 18)流程图必须始终包含至少一个决策符号。
- en: 19)In a flowchart, a Decision symbol can have one, two, or three exit paths,
    depending on the given problem.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 19)在流程图中，决策符号可以有一个、两个或三个出口路径，具体取决于给定的问题。
- en: 20)Reserved words are all those words that have a strictly predefined meaning.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 20)保留字是所有具有严格预定义意义的单词。
- en: 21)Structured programming includes structured design.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 21)结构化编程包括结构化设计。
- en: 22)Python is a structured computer language.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 22)Python是一种结构化计算机语言。
- en: 23)The basic principle of structured programming is that it includes only four
    fundamental control structures.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 23)结构化编程的基本原则是它只包括四种基本控制结构。
- en: 24)One statement, written ten times, is considered a loop control structure.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 24)一条写十遍的语句被认为是循环控制结构。
- en: 25)Decision control structure refers to the line-by-line execution.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 25)决策控制结构指的是逐行执行。
- en: 26)A misspelled keyword is considered a logic error.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 26)拼写错误的密钥词被视为逻辑错误。
- en: 27)A Python program can be executed even though it contains logic errors.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 27)即使Python程序包含逻辑错误，它也可以执行。
- en: 28)If you leave an exclamation mark at the end of a Python statement, it is
    considered a syntax error.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 28)如果你在Python语句的末尾留下感叹号，它被视为语法错误。
- en: 29)If you leave an exclamation mark at the end of a Python statement, it cannot
    prevent the whole Python program from being executed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 29)如果你在Python语句的末尾留下感叹号，它不能阻止整个Python程序执行。
- en: 30)One of the advantages of structured programming is that no errors are made
    while writing a computer program.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 30)结构化编程的一个优点是在编写计算机程序时不会出错。
- en: 31)Logic errors are caught during compilation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 31)逻辑错误在编译期间被捕获。
- en: 32)Runtime errors are caught during compilation
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 32)运行时错误在编译期间被捕获。
- en: 33)Syntax errors are the most difficult errors to detect.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 33)语法错误是最难检测的错误。
- en: 34)A program that calculates the area of a triangle but outputs the wrong results
    contains logic errors.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 34)一个计算三角形面积但输出错误结果的程序包含逻辑错误。
- en: 35)When a program includes no output statements, it contains syntax errors.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 35)当程序不包含输出语句时，它包含语法错误。
- en: 36)A program must always contain comments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 36)一个程序必须始终包含注释。
- en: 37)If you add comments to a program, the computer can more easily understand
    it.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 37)如果你在程序中添加注释，计算机可以更容易地理解它。
- en: 38)You cannot add comments above a statement.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 38)你无法在语句上方添加注释。
- en: 39)Comments are not visible to the users of a program.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 39)注释对程序的用户是不可见的。
- en: 40)A program is called user-friendly if it can be used easily by a novice user.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 40)如果一个程序可以被新手用户轻松使用，那么它被称为用户友好型。
- en: 41)The acronym POLA stands for “Principle of Least Amusement”.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 41)缩写词POLA代表“最小娱乐原则”。
- en: '4.18 Review Questions: Multiple Choice'
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.18 复习题：多项选择题
- en: Select the correct answer for each of the following statements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 选择以下每个陈述的正确答案。
- en: 1)An algorithm is a strictly defined finite sequence of well-defined statements
    that provides the solution to
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 1)算法是一系列严格定义的有限序列的明确陈述，它提供了
- en: a)a problem.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个问题。
- en: b)a specific class of problems.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: b)一类特定的问题。
- en: c)both of the above are correct.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: c)以上两者都是正确的。
- en: 2)Which of the following is not a property that an algorithm must satisfy?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 2)以下哪项不是算法必须满足的特性？
- en: a)effectiveness
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: a)有效性
- en: b)fittingness
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: b)适宜性
- en: c)definiteness
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: c)确定性
- en: d)input
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: d)输入
- en: 3)A computer program is
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 3)计算机程序是
- en: a)an algorithm.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个算法。
- en: b)a sequence of instructions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: b)一系列指令。
- en: c)both of the above
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: c)以上两者都是
- en: 4)When someone writes a recipe, they are the
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 4)当有人编写一个食谱时，他们是
- en: a)“programmer”
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: a)“程序员”
- en: b)“user”
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: b)“用户”
- en: c)none of the above
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: c)以上都不是
- en: 5)Which of the following does not belong in the three main stages involved in
    creating an algorithm?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 5)以下哪项不属于创建算法涉及到的三个主要阶段之一？
- en: a)data protection
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: a)数据保护
- en: b)data input
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: b)数据输入
- en: c)results output
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: c)结果输出
- en: d)data processing
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: d)数据处理
- en: 6)A flowchart can be
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 6)流程图可以是
- en: a)presented on a piece of paper.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: a)展示在一张纸上。
- en: b)entered directly into a computer as is.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: b)直接输入到计算机中。
- en: c)both of the above
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: c)以上两者都是
- en: 7)A rectangle in a flowchart represents
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 7)流程图中的矩形表示
- en: a)an input/output operation.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: a)输入/输出操作。
- en: b)a processing operation.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: b)处理操作。
- en: c)a decision.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个决策。
- en: d)none of the above
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: d)以上都不是
- en: 8)Which of the following is/are control structures?
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 8)以下哪项是/是控制结构？
- en: a)a decision
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: a)一个决策
- en: b)a sequence
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: b)一个序列
- en: c)a loop
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: c)一个循环
- en: d)All of the above are control structures.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: d)以上所有都是控制结构。
- en: 9)Which of the following Python statements contains a syntax error?
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 9)以下哪个Python语句包含语法错误？
- en: a)print(Hello Poseidon)
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: a)print(Hello Poseidon)
- en: b)print("It's me! I contain a syntax error!!!")
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: b)print("It's me! I contain a syntax error!!!")
- en: c)print("Hello Athena")
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: c)print("Hello Athena")
- en: d)none of the above
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: d)以上都不是
- en: 10)Which of the following print statements is actually executed?
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 10)以下哪个打印语句实际上被执行了？
- en: a)print("Hello Apollo)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: a)print("Hello Apollo)
- en: b)#print("Hello Artemis")
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: b)#print("Hello Artemis")
- en: c)#This will be executed  print("Hello Ares")
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: c)#This will be executed  print("Hello Ares")
- en: 'd)print("Hello Aphrodite") #This will be executed'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 'd)print("Hello Aphrodite") #This will be executed'
- en: e)none of the above
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: e)以上都不是
