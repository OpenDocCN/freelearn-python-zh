- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Structuring Our Code and Add-Ons
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化我们的代码和插件
- en: The add-ons we have created so far consist of single Python files. That’s ok,
    but to deal with complexity, we can split our code into related modules contained
    in the same directory.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止创建的插件由单个 Python 文件组成。这没问题，但为了处理复杂性，我们可以将我们的代码拆分成同一目录中的相关模块。
- en: Writing modules that interact with each other rather than a single huge file
    makes design and maintenance easier, allowing us to shift our focus to single
    aspects of our task.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编写相互交互的模块而不是单个大文件，使得设计和维护更容易，使我们能够将注意力集中在任务的单一方面。
- en: The presence of non-code files, such as images and other media, can be another
    reason for adopting a folder structure. This is because sharing one folder is
    more practical than handling the Python script and the data separately.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 非代码文件（如图像和其他媒体）的存在可能是采用文件夹结构的另一个原因。这是因为共享一个文件夹比分别处理 Python 脚本和数据更实用。
- en: In this chapter, you will learn how to code across separate modules of a package
    and blend everything using the import system. The packaged add-on that we are
    going to create will be easier to distribute, read, and maintain, and it will
    be possible to grasp the functionality of its different parts by just looking
    at the filenames.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在包的不同模块之间进行编码，并使用导入系统将一切融合在一起。我们将创建的打包插件将更容易分发、阅读和维护，并且只需查看文件名就可以掌握其不同部分的功能。
- en: 'This chapter will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a Python package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Python 包
- en: Loading and refreshing code and assets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和刷新代码和资产
- en: Reading environment variables in your scripts
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的脚本中读取环境变量
- en: Using the Preferences system
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用首选项系统
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We will use Blender and Visual Studio Code in this chapter. The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用 Blender 和 Visual Studio Code。本章创建的示例可以在 [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch6)
    找到。
- en: Optionally, on Windows, we can use 7-Zip to create compressed archives. 7-Zip
    is a free application that can be downloaded from [https://www.7zip.org](https://www.7zip.org).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，在 Windows 上，我们可以使用 7-Zip 创建压缩存档。7-Zip 是一个免费应用程序，可以从 [https://www.7zip.org](https://www.7zip.org)
    下载。
- en: Folders, packages, and add-ons
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹、包和插件
- en: We know that an add-on consists of Python code accompanied by information for
    the Blender plugin system. While single-file Python scripts are called modules,
    a folder of scripts is called a package.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道插件由 Python 代码和 Blender 插件系统的信息组成。虽然单个文件 Python 脚本被称为模块，但脚本文件夹被称为包。
- en: Writing an add-on folder implies that we will store the Blender information
    at the package level, so we will create a directory and create the package information
    first.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 创建插件文件夹意味着我们将存储 Blender 信息在包级别，因此我们将首先创建一个目录并创建包信息。
- en: Creating a package folder and the init file
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建包文件夹和初始化文件
- en: 'Let’s create a folder for *this chapter* in our Python project. Then, in the
    `ch6` folder as our **Scripts Folder** and restart Blender. To make a package,
    we need to create a new folder rather than a new file. We can do that using the
    file manager or, like in the following steps, use the files bar of our programmer
    editor:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的 Python 项目中为*本章内容*创建一个文件夹。然后，在`ch6`文件夹中作为我们的**脚本文件夹**并重启 Blender。要创建一个包，我们需要创建一个新的文件夹而不是一个新的文件。我们可以使用文件管理器，或者像以下步骤中那样，使用我们的程序员编辑器的文件栏：
- en: Select `PythonScriptingBlender/ch6/addons`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `PythonScriptingBlender/ch6/addons`。
- en: 'Create a new folder by clicking the **New** **Folder** icon:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建文件夹**图标创建一个新文件夹：
- en: '![Figure 6.1: Creating folders in Visual Studio Code](img/Figure_6.1_B18375.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1：在 Visual Studio Code 中创建文件夹](img/Figure_6.1_B18375.jpg)'
- en: 'Figure 6.1: Creating folders in Visual Studio Code'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1：在 Visual Studio Code 中创建文件夹
- en: Name the new folder `structured_addon`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹命名为 `structured_addon`。
- en: 'A Python package contains a file named `__init__.py`. This is the **entry point**
    of the folder and Python runs it automatically when it imports a package. To create
    it, follow these steps:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Python 包包含一个名为 `__init__.py` 的文件。这是文件夹的**入口点**，Python 在导入包时会自动运行它。要创建它，请按照以下步骤操作：
- en: Select the `…/``ch6/addons/structured_addon` folder.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `…/``ch6/addons/structured_addon` 文件夹。
- en: 'Create a new file by clicking on the **New** **File** icon:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建文件**图标创建一个新文件：
- en: '![Figure 6.2: Creating a new file in Visual Studio Code](img/Figure_6.2_B18375.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：在Visual Studio Code中创建新文件](img/Figure_6.2_B18375.jpg)'
- en: 'Figure 6.2: Creating a new file in Visual Studio Code'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2：在Visual Studio Code中创建新文件
- en: Name the new file `__init__.py`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为 `__init__.py`。
- en: Open the file by double-clicking it.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件打开。
- en: When Blender searches for installed add-ons, it will look for the `bl_info`
    dictionary inside the `__init__.py` files of this folder. We will fill in this
    information in the usual way.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当Blender搜索已安装的插件时，它将在该文件夹的 `__init__.py` 文件中查找 `bl_info` 字典。我们将以通常的方式填写这些信息。
- en: Writing the init file
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写初始化文件
- en: 'This `bl_info` dictionary contains the usual attributes for add-on discovery:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `bl_info` 字典包含了用于插件发现的常用属性：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Providing a `register()` and an `unregister()` function will allow us to enable
    and disable the add-on:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提供一个 `register()` 和一个 `unregister()` 函数将允许我们启用和禁用插件：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we should be able to see our **Structured Add-on** if we restart Blender
    or refresh the add-ons list:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重新启动Blender或刷新插件列表，我们应该能够看到我们的 **结构化插件**：
- en: '![Figure 6.3: Structured Add-on listed in the “Learning” category](img/Figure_6.03_B18375.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：在“学习”类别中列出的结构化插件](img/Figure_6.03_B18375.jpg)'
- en: 'Figure 6.3: Structured Add-on listed in the “Learning” category'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：在“学习”类别中列出的结构化插件
- en: We are going to make it useful by adding some content using different `.``py`
    files.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过添加一些内容，使用不同的 `.py` 文件，使其变得有用。
- en: Guidelines for separating modules
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块分离的指南
- en: 'There is a trade-off between partitioning and centralizing the code: excessively
    atomized code risks being unclear and hard to maintain. So, even if there are
    no fixed rules about splitting a program, there are general criteria for writing
    modular code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码分区和集中之间有一个权衡：过度原子化的代码可能会变得不清晰且难以维护。因此，即使没有关于分割程序的确切规则，也有编写模块化代码的一般标准：
- en: Non-Python files such as *media* (images, sounds, and so on) have their subfolders
    according to their types
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非Python文件，如 *媒体*（图像、声音等），根据其类型有自己的子文件夹
- en: '*Generic code* used by unrelated classes can be considered a utility module
    and used like a library'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由无关类使用的 *通用代码* 可以被视为一个实用模块，并像库一样使用
- en: '*Specific code* relevant to a particular functionality should be a specific
    module'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与特定功能相关的 *特定代码* 应该是特定的模块
- en: '*UI* classes, such as panels and menus, can be separated by non-UI code'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*UI* 类，如面板和菜单，可以通过非UI代码进行分离'
- en: '*Operators* can be separated from non-operator code and split per category'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将 *操作符* 与非操作符代码分离，并按类别分割
- en: '*Import* statements relevant to only a part of a script might imply that entire
    sections could go to another file, thus reducing the number of imported libraries
    in one file'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅与脚本的一部分相关的 *导入* 语句可能意味着整个部分可以放入另一个文件中，从而减少一个文件中导入的库的数量
- en: 'We will put these concepts into practice and see how, starting with an example
    we are familiar with, the package architecture makes our code clearer and more
    effective:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把这些概念付诸实践，并看看从我们熟悉的例子开始，包架构如何使我们的代码更清晰、更有效：
- en: '![Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts
    together](img/Figure_6.04_B18375.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4：插件文件夹的执行 – __init__.py 将所有部分粘合在一起](img/Figure_6.04_B18375.jpg)'
- en: 'Figure 6.4: Execution of an add-on folder – __init__.py glues all the parts
    together'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：插件文件夹的执行 – __init__.py 将所有部分粘合在一起
- en: Writing the structured panel
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写结构化面板
- en: We wrote a user interface in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100),
    that relied on an external `.png` file to display an icon. That makes the tool
    difficult to share because Blender can only install either one `.py` or `.``zip`
    file.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [*第5章*](B18375_05.xhtml#_idTextAnchor100) 中编写了一个用户界面，它依赖于一个外部的 `.png` 文件来显示图标。这使得工具难以共享，因为Blender只能安装一个
    `.py` 或 `.zip` 文件。
- en: 'We can bundle pictures and code together if we structure it all as a folder.
    According to the guidelines summed up earlier, we can create the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将所有内容都作为文件夹结构化，我们可以将图片和代码捆绑在一起。根据前面总结的指南，我们可以创建以下内容：
- en: A subfolder for the *icon storage* (media files) named `pictures`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `pictures` 的 *图标存储*（媒体文件）的子文件夹
- en: A module for *icon loading* (generic functionality) named `img_load.py`
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `img_load.py` 的 *图标加载* 模块（通用功能）
- en: A module that contains the *panel* (UI separation) named `panel.py`
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 *面板*（UI分离）的模块名为 `panel.py`
- en: A module for add-on *preferences* (specific functionality) named `preferences.py`
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `preferences.py` 的插件 *首选项*（特定功能）模块
- en: A module to *reload* the import system (maintenance utility) named `_refresh_.py`
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`_refresh_.py`的模块，用于*重新加载*导入系统（维护工具）。
- en: In the next section, we will create a folder for storing the image files and
    the code for loading them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建一个用于存储图像文件及其加载代码的文件夹。
- en: Packing external images
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包外部图像
- en: If we use image files for our add-on, we can create a folder in the `structured_addon`
    directory and name it `pictures`. Since we are going to write a module for loading
    icons, this folder can contain a collection of image files.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为我们的插件使用图像文件，我们可以在`structured_addon`目录中创建一个名为`pictures`的文件夹。由于我们将编写一个加载图标的模块，这个文件夹可以包含一系列图像文件。
- en: 'In the `ch6\addons\structured_addon\pictures` folder from the examples, we
    have `pack_64.png`, a clipart representing a package, and `smile_64.png`, the
    smiley face from the previous chapter:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中的`ch6\addons\structured_addon\pictures`文件夹中，我们有`pack_64.png`，一个表示包的剪贴画，以及`smile_64.png`，来自上一章的笑脸：
- en: '![Figure 6.5: The pictures used for this add-on are stored in a folder](img/Figure_6.05_B18375.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5：用于此附加组件的图片存储在文件夹中](img/Figure_6.05_B18375.jpg)'
- en: 'Figure 6.5: The pictures used for this add-on are stored in a folder'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5：用于此附加组件的图片存储在文件夹中
- en: Once all our images are in this folder, we can write the code to load them.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有我们的图片都存放在这个文件夹中，我们就可以编写代码来加载它们。
- en: Writing an icon library
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写图标库
- en: In [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), we wrote a function that
    loads a specific image file from disk. That worked great. Now that we are loading
    two icons, we can just use the same routine twice.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第五章*](B18375_05.xhtml#_idTextAnchor100)中，我们编写了一个函数，用于从磁盘加载特定的图像文件。这工作得很好。现在我们正在加载两个图标，我们只需将相同的程序运行两次。
- en: But now that we have an entire module for loading images, we can write a more
    sophisticated solution that works for any number of icons since it doesn’t rely
    on hardcoded full paths.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们有一个用于加载图像的整个模块，我们可以编写一个更复杂的解决方案，它适用于任何数量的图标，因为它不依赖于硬编码的完整路径。
- en: 'This new loader scans the pictures folder for images. We will make sure that
    loading times are not increased by multiple calls from other modules so that we
    end up with a more flexible, yet still reliable, loader for custom images. Let’s
    create the module’s file, following the same steps as before:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的加载器会扫描图片文件夹中的图像。我们将确保不会因为其他模块的多次调用而增加加载时间，以便我们最终得到一个更灵活、但仍可靠的定制图像加载器。让我们按照之前的步骤创建模块的文件：
- en: Select the `…/``ch6/addons/structured_addon` folder.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`…/``ch6/addons/structured_addon`文件夹。
- en: Create a new file by clicking the **New** **File** icon.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建** **文件**图标创建一个新文件。
- en: Name the new file `img_loader.py`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`img_loader.py`。
- en: Open the file by double-clicking it.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击打开文件。
- en: This module will handle icon loading for the entire package.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块将处理整个包的图标加载。
- en: Loading pictures from a folder
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从文件夹中加载图片
- en: 'The `img_loader` module scrolls the image files from a folder, so we need to
    import the `os` package to access directories. And of course, `bpy.utils.previews`
    is needed for loading the images from the file and storing them as icons:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`img_loader`模块会从文件夹中滚动图像文件，因此我们需要导入`os`包来访问目录。当然，还需要`bpy.utils.previews`来从文件中加载图像并将它们存储为图标：'
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We use a global variable, a list, to store the Blender previews `Collection`.
    Following the Python naming convention, the variable name is uppercase since it’s
    global. Also, it starts with an underscore because it is not meant to be used
    in any other module:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个全局变量，一个列表，来存储Blender预览`Collection`。遵循Python命名约定，变量名是大写的，因为它是一个全局变量。此外，它以一个下划线开头，因为它不打算在其他任何模块中使用：
- en: '[PRE3]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We create the `register_icons()` function to load the icons from disk. It is
    like the `load_custom_icons` function from the first section of [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建`register_icons()`函数来从磁盘加载图标。它类似于[*第五章*](B18375_05.xhtml#_idTextAnchor100)第一部分中的`load_custom_icons`函数。
- en: 'If `_CUSTOM_ICONS` tests `True` to the `if` condition, the `return` statement
    will exit the function immediately. That prevents it from loading the icons repeatedly
    every time that the module is used. Otherwise, we create a new collection of icons
    via `previews.new()`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`_CUSTOM_ICONS`对`if`条件测试为`True`，则`return`语句将立即退出函数。这防止了每次模块使用时重复加载图标。否则，我们通过`previews.new()`创建一个新的图标集合：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Rather than hardcoding filenames, we load all the images contained in the `pictures`
    folder. We don’t want to load non-image files, so we store a list of our viable
    image extensions in the `img_extensions` variable. We are only using the `.png`
    and `.jpg` formats in this example but others, such as `.tif`, can be used:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是通过硬编码文件名来加载的，而是将`pictures`文件夹中包含的所有图片加载进来。我们不希望加载非图片文件，因此我们将我们可用的图片扩展名存储在`img_extensions`变量中。在这个例子中，我们只使用`.png`和`.jpg`格式，但也可以使用其他格式，例如`.tif`：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get the path to the pictures folder by adding `''pictures''` to the module’s
    path. When dealing with files, path functions from the `os` utilities are preferred
    to string manipulation since they ensure multi-platform compatibility. So, we
    build the `picture_path` variable using the `os.path.join` function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`'pictures'`添加到模块的路径中来获取图片文件夹的路径。在处理文件时，由于`os`实用工具中的路径函数确保了多平台兼容性，因此我们更倾向于使用路径函数而不是字符串操作。因此，我们使用`os.path.join`函数构建`picture_path`变量：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `os.listdir` function returns a list of all the filenames contained in
    a directory. We navigate the list with a `for` loop, and at each iteration, we
    separate the filename from the extension using the `os.path.splitext` function.
    Both lower and uppercase extensions are valid, but string comparison is a case-sensitive
    operation. We convert all file extensions into lowercase letters so that `.jpg`
    or `.png` files can be considered. When a file extension is not found in `img_extensions`,
    the file is skipped by the `continue` statement:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.listdir`函数返回一个包含目录中所有文件名的列表。我们使用`for`循环遍历列表，并在每次迭代中，使用`os.path.splitext`函数将文件名与其扩展名分开。扩展名的大小写都是有效的，但字符串比较是区分大小写的操作。我们将所有文件扩展名转换为小写字母，以便`.jpg`或`.png`文件可以被考虑。当文件扩展名不在`img_extensions`中时，文件将通过`continue`语句被跳过：'
- en: '[PRE7]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Bail out quickly or stick to it!
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 快速退出或坚持下去！
- en: 'Escaping one loop iteration using `continue`, an entire loop using `break`,
    or a function using `return` before it’s over is a valid technique to interrupt
    a procedure as soon as its conditions are not met. It avoids nesting too many
    `if` statements, but it is recommended to do that only at the beginning of an
    execution: having exit points at seemingly random points in the code makes it
    hard to read.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`continue`跳出一个循环迭代，使用`break`跳出整个循环，或者在使用`return`之前结束一个函数，这些都是当条件不满足时立即中断程序的有效技术。这避免了嵌套过多的`if`语句，但建议只在执行开始时这样做：在代码中随机位置设置退出点会使代码难以阅读。
- en: '`os.listdir` lists only the filenames and not their full disk paths. To get
    it, we must join `picture_path` and `img_file` together, using `os.path.join`
    again. We use `img_nam`e – that is, the filename without an extension – as the
    keyword for retrieving the icon from the collection:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.listdir`只列出文件名，而不是它们的完整磁盘路径。要获取它，我们必须使用`os.path.join`将`picture_path`和`img_file`结合起来。我们使用`img_name`（即没有扩展名的文件名）作为从集合中检索图标的键：'
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the `for` loop is over, we can store the collection in the `_CUSTOM_ICONS`
    list:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`for`循环结束，我们就可以将集合存储在`_CUSTOM_ICONS`列表中：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Using filenames as keywords is convenient as, for instance, `'smile_64'` will
    be the keyword for the `smile_64.png` file, but it can be ambiguous when our folder
    contains files with the same name but different extensions, such as `smile_64.jpg`.
    Our script will assume that the picture folder doesn’t contain pictures with the
    same filenames.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件名作为关键字很方便，例如`'smile_64'`将是`smile_64.png`文件的键，但当我们的文件夹包含具有相同名称但不同扩展名的文件时，例如`smile_64.jpg`，它可能会产生歧义。我们的脚本将假设图片文件夹不包含具有相同文件名的图片。
- en: With that, we have created the `register_icons()` function, which initializes
    the icon collection. Now, we need to add a function to clean it up when the add-on
    is disabled; otherwise, the leftover thumbnails in our computer’s RAM will interfere
    with subsequent executions.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们已经创建了`register_icons()`函数，它初始化图标集合。现在，我们需要添加一个函数来在附加组件被禁用时清理它；否则，我们电脑RAM中留下的缩略图将干扰后续执行。
- en: Unregistering icons
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取消注册图标
- en: When the add-on is disabled, we must discharge its icons from our computer’s
    memory.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加组件被禁用时，我们必须从我们电脑的内存中卸载其图标。
- en: 'To do that, we must define the `unregister_icons` function. In this function,
    we invoke `previews.remove()` and use `_CUSTOM_ICONS` as its argument. We also
    need to make sure that `_CUSTOM_ICONS` is set to `None` at the end of the function;
    otherwise, Python will keep invalid references to deleted icons and cause Blender
    to crash:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须定义`unregister_icons`函数。在这个函数中，我们调用`previews.remove()`并使用`_CUSTOM_ICONS`作为其参数。我们还需要确保在函数末尾将`_CUSTOM_ICONS`设置为`None`；否则，Python将保留对已删除图标的无效引用，导致Blender崩溃：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now that `img_loader` can load and unload icons, what we need is a getter to
    access `_CUSTOM_ICONS` from the other modules.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`img_loader`可以加载和卸载图标，我们需要的是一个获取器来从其他模块访问`_CUSTOM_ICONS`。
- en: Getting the collection
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取集合
- en: 'Python doesn’t forbid access to module members, even if we mark them as *private*
    using a name with leading underscores. So, we could access the `_CUSTOM_ICONS`
    variable by typing the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Python 并不允许访问模块成员，即使我们使用带前导下划线的名称将其标记为*私有*。因此，我们可以通过以下方式访问`_CUSTOM_ICONS`变量：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Still, we can add more control if we use a function to get the loaded icons:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果我们使用一个函数来获取已加载的图标，我们还可以添加更多控制：
- en: In the future, we can change `_CUSTOM_ICONS` to a dictionary or list. That would
    have no repercussions for other modules using the data if the function used to
    get them is changed accordingly.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未来，我们可以将`_CUSTOM_ICONS`更改为字典或列表。如果获取它们的函数相应地更改，这将对使用数据的其他模块没有影响。
- en: It makes it easy to check that the conditions are met. In this case, our call
    to `register_icons()` makes sure that the icons are registered in case they weren’t
    for some reason. This practice adheres to **defensive programming**, as it aims
    to make the script work even against unforeseen circumstances.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这使得检查条件是否满足变得容易。在这种情况下，我们的`register_icons()`调用确保图标已注册，以防万一由于某种原因没有注册。这种做法遵循**防御性编程**，因为它旨在使脚本即使在不可预见的情况下也能正常工作。
- en: 'It allows us to set *roadblocks* in case some vital condition was not met.
    For instance, we have added an `assert _CUSTOM_ICONS` statement that will cause
    an error if the variable has not been set, despite the recent call to `register_icons()`.
    This is an example of **offensive programming** because it stops the execution
    when something is wrong:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许我们在某些关键条件未满足的情况下设置*障碍*。例如，我们添加了一个`assert _CUSTOM_ICONS`语句，如果变量尚未设置，即使最近调用了`register_icons()`，它也会引发错误。这是一个**进攻性编程**的例子，因为它在出现错误时停止执行：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, the picture loader provides a code interface for loading, unloading, and
    getting all the icons from the pictures folder. The main module can import it
    via relative import.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图片加载器为从图片文件夹中加载、卸载和获取所有图标提供了一个代码接口。主模块可以通过相对导入导入它。
- en: Using relative imports
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用相对导入
- en: The `import` statement looks for modules installed in the Python search path,
    such as the built-in library or, in our case, the Blender API (`bpy`). Trying
    to import a module that is not in the search path halts the script with a `ModuleNotFoundError`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`import`语句会在Python搜索路径中查找已安装的模块，例如内置库或在我们的情况下，Blender API（`bpy`）。尝试导入不在搜索路径中的模块会导致脚本因`ModuleNotFoundError`而停止。'
- en: 'For modules that belong to the same package, we use a slightly different syntax
    that gives access to the other modules of the same package: a **relative** import
    statement.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属于同一包的模块，我们使用稍微不同的语法，以便访问同一包的其他模块：一个**相对**导入语句。
- en: In relative imports, the package is represented with a dot (`.`), and modules
    are imported using the `from . import` `module` syntax.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在相对导入中，包用点(`.`)表示，模块使用`from . import` `module`语法导入。
- en: 'So, in the import section of our `__init__.py` file, add the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的`__init__.py`文件的导入部分，添加以下内容：
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The register and unregister functions will invoke the `register_icons()` and
    `unregister_icons()` functions contained in the `img_loader` namespace, respectively:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注册和注销函数将分别调用`img_loader`命名空间中包含的`register_icons()`和`unregister_icons()`函数：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that the entire process of loading images is handled in one module, we can
    write the `.py` file of the *user interface*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在整个图像加载过程都在一个模块中处理，我们可以编写*用户界面*的`.py`文件。
- en: In the next section, we will see how, once we gain access to our icons system
    via a relative import of `img_loader`, we won’t have to worry about loading icon
    files anymore.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到，一旦我们通过`img_loader`的相对导入访问了我们的图标系统，我们就不再需要担心加载图标文件了。
- en: Adding a user interface
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户界面
- en: We have already created the `panel.py` module, which will contain all the *user
    interface* classes and functions, so this file is going to contain our panel class.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 `panel.py` 模块，该模块将包含所有 *用户界面* 类和函数，因此这个文件将包含我们的面板类。
- en: Writing the UI module
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写 UI 模块
- en: 'We will start importing the `bpy` module and our collection of icons via a
    relative import of `img_loader`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过 `img_loader` 的相对导入来开始导入 `bpy` 模块和我们的图标集合：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `OBJECT_PT_structured` class is derived from `Panel`. Like the one from
    [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100), it contains the `bl_*` identifiers
    required by Blender in its static section:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`OBJECT_PT_structured` 类是从 `Panel` 派生的。像第 5 章中的那个一样，它在静态部分包含了 Blender 所需的 `bl_*`
    标识符：'
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For now, our `draw` function is a few lines of code that display an icon, followed
    by text:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 `draw` 函数是几行代码，显示一个图标，然后是文本：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, we must write the functions for registering and unregistering the class
    from this module:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须编写从该模块注册和注销类的函数：
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Providing registration utilities inside the module relieves `__init__.py` from
    concerns about which classes are defined in `panel` and which ones should be registered/unregistered.
    It is like what we did in *Getting the collection* in section 2 of this chapter,
    *Packing* *external images*.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块内部提供注册实用工具，可以减轻 `__init__.py` 对哪些类在 `panel` 中定义以及哪些类应该注册/注销的担忧。这就像我们在本章第
    2 节 *获取集合* 中所做的，*打包* *外部图像*。
- en: These designs fall under the practice of **encapsulation** – that is, restricting
    direct access to the components of a module or object. Adhering to it is not inherently
    better, but it can help in keeping the code flexible and clean.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些设计属于 **封装** 的实践——也就是说，限制对模块或对象组件的直接访问。遵循它并不本质上更好，但它可以帮助保持代码灵活和整洁。
- en: Importing the UI
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入用户界面
- en: 'Inside `__init__.py`, we import `panel` from the `.` namespace, and invoke
    its `register_classes()` and `unregister_classes()` functions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__.py` 中，我们从 `.` 命名空间导入 `panel`，并调用其 `register_classes()` 和 `unregister_classes()`
    函数：
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, the `unregister` order is the reverse of the one in the `register`
    function. That is not relevant to the execution of the add-on, and it is followed
    here only for the sake of clarity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`unregister` 的顺序与 `register` 函数中的顺序相反。这与插件的执行无关，这里只为了清晰起见。
- en: We can test our code by enabling **Structured Panel** in the **Add-ons** list
    from the **Edit** | **Preferences** menu.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从 **编辑** | **首选项** 菜单中启用 **结构化面板** 来测试我们的代码。
- en: 'We can see the panel and our new icon in the object section:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在对象部分看到面板和我们的新图标：
- en: '![Figure 6.6: panel.py displays an icon via img_loader.py](img/Figure_6.06_B18375.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6：panel.py 通过 img_loader.py 显示图标](img/Figure_6.06_B18375.jpg)'
- en: 'Figure 6.6: panel.py displays an icon via img_loader.py'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6：panel.py 通过 img_loader.py 显示图标
- en: Now, we will add other elements and complete the panel.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加其他元素并完成面板。
- en: Completing the Objects panel
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完成对象面板
- en: 'A slightly simpler version of the panel displayed in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100),
    uses pretty much the same code. The maximum number of displayed objects is still
    stored in the `max_objects` static member, but it would work better if implemented
    as a preference of the add-on. We will do that in the *Using addon preferences*
    section, a few pages ahead in this chapter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B18375_05.xhtml#_idTextAnchor100) 中显示的面板的略微简化版本，几乎使用了相同的代码。显示的对象的最大数量仍然存储在
    `max_objects` 静态成员中，但如果将其实现为插件的偏好设置会更好。我们将在本章稍后的 *使用插件偏好设置* 部分这样做：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `draw` function displays a list of the scene objects:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw` 函数显示场景对象的列表：'
- en: '[PRE21]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This time, reloading the scripts does not reflect the changes in the preceding
    code: only the `__init__.py` file is refreshed on reload. We are going to cover
    explicitly reloading internal modules in the next section.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，重新加载脚本并没有反映前面代码中的更改：只有 `__init__.py` 文件在重新加载时被刷新。我们将在下一节中明确介绍重新加载内部模块。
- en: Reloading cached modules
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新加载缓存的模块
- en: 'When a module is imported, Python caches a copy of it for future access. Since
    the `__init__.py` file is the only one to be updated by the **Reload Scripts**
    operator, we are left with two options:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块被导入时，Python 会缓存它的一个副本以供将来访问。由于 `__init__.py` 文件是唯一一个由 **Reload Scripts**
    操作符更新的文件，我们只剩下两个选项：
- en: Close and restart Blender
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关闭并重新启动 Blender
- en: Explicitly call the `reload` function inside `__init__.py`
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `__init__.py` 中显式调用 `reload` 函数
- en: The latter is preferred over restarting the application as it takes less time.
    The `reload` function is part of the `importlib` module.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与重新启动应用程序相比，后者更受欢迎，因为它耗时更短。`reload` 函数是 `importlib` 模块的一部分。
- en: Reloading via importlib
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 `importlib` 进行重新加载
- en: The utilities contained in the `importlib` library interact with the import
    system, and the `reload` function forces the Python interpreter to reload a module
    from disk.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib` 库中的实用程序与导入系统交互，`reload` 函数强制 Python 解释器从磁盘重新加载一个模块。'
- en: 'If the `img_loader` module has changed and needs to be reloaded, we can use
    the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `img_loader` 模块已更改并需要重新加载，我们可以使用以下命令：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'So, to make sure that the changes to our add-on `.py` files are always applied,
    we can add these lines of code to `_init_.py`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了确保我们的附加功能 `.py` 文件中的更改始终得到应用，我们可以在 `_init_.py` 中添加以下代码行：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Reloading every relative module soon after it is imported will work, but leaving
    `reload` statements in published code impacts performance and is considered bad
    practice. Next, we will learn how to refresh inside a specific module of the add-on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入相对模块后不久重新加载它将有效，但将 `reload` 语句留在已发布的代码中会影响性能，并被视为不良实践。接下来，我们将学习如何在附加功能的特定模块中刷新。
- en: Implementing a refresh module
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现刷新模块
- en: Calling `reload` increases the loading time of an add-on and makes the code
    less readable. Many developers add reload calls while they work and remove them
    when they are finished. However, using packages, we can move the refresh logic
    to another module.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `reload` 会增加附加功能的加载时间，并使代码的可读性降低。许多开发者在工作时添加重新加载调用，完成时移除它们。然而，使用包，我们可以将刷新逻辑移动到另一个模块。
- en: To do that, we need to create a file in our add-on package and name it `_refresh_.py`.
    This module doesn’t contain any add-on functionality, but it helps while we edit
    our code by ensuring that all modules are reloaded from disk and are up to date.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要在我们的附加功能包中创建一个文件，并将其命名为 `_refresh_.py`。此模块不包含任何附加功能，但在我们编辑代码时，它有助于确保所有模块都从磁盘重新加载并保持最新。
- en: Reloading the package modules
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新加载包模块
- en: 'The refresh module makes use of the following elements:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 刷新模块使用了以下元素：
- en: The `reload` function from the `importlib` module
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`importlib` 模块中的 `reload` 函数'
- en: The `sys` module, which is used by `_refresh_` to reload an instance of itself
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_refresh_` 使用的 `sys` 模块，用于重新加载其自身的实例'
- en: The `bpy` module, to access Blender preferences
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bpy` 模块，用于访问 Blender 首选项'
- en: All the modules contained in the add-on
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加功能中包含的所有模块
- en: 'Those requirements translate into the following `import` statements:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求转化为以下 `import` 语句：
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The wildcard character, `*`, stands for all the modules contained in the current
    package (`.`). Now, we can write a function that reloads the add-on modules if
    Blender is set for development. We encountered the **Developer Extras** setting
    in the *Useful features for Python* section, at the beginning of [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033).
    They can be found by going to **Edit** | **Preferences** from the top menu bar
    in the **Interface** tab of the **Preferences** window:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符字符 `*` 代表当前包中包含的所有模块（`.`）。现在，我们可以编写一个函数，如果 Blender 设置为开发模式，则重新加载附加功能模块。我们在
    [*第 2 章*](B18375_02.xhtml#_idTextAnchor033) 的 *Python 有用功能* 部分遇到了 **开发者附加功能**
    设置，在首选项窗口的 **界面** 选项卡中，可以通过从顶部菜单栏的 **编辑** | **首选项** 来找到：
- en: '![Figure 6.7: Enabling Developer Extras in the Preferences window](img/Figure_6.07_B18375.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7：在首选项窗口中启用开发者附加功能](img/Figure_6.07_B18375.jpg)'
- en: 'Figure 6.7: Enabling Developer Extras in the Preferences window'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7：在首选项窗口中启用开发者附加功能
- en: We can assume that when **Developer Extras** is on, we want the **Reload Scripts**
    operator to reload our submodules as well.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以假设当**开发者附加功能**开启时，我们希望**重新加载脚本**操作符也重新加载我们的子模块。
- en: Using Developer Extras as a condition
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用开发者附加功能作为条件
- en: 'We need to find the full Python path of **Developer Extras** to read its value.
    To do that, follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要找到**开发者附加功能**的完整 Python 路径以读取其值。为此，请按照以下步骤操作：
- en: Make sure that **Developer Extras** is enabled.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保已启用**开发者附加功能**。
- en: Also, make sure that **User Tooltips** and **Python Tooltips** are enabled.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，请确保已启用**用户工具提示**和**Python 工具提示**。
- en: Hover your mouse pointer over the **Developer Extras** checkbox or label.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标指针悬停在 **开发者附加功能** 复选框或标签上。
- en: 'Leaving your mouse still, without clicking or moving it, displays a tooltip:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将鼠标停留在原地，不点击或移动它，会显示一个工具提示：
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'According to the API reference, `PreferencesView` is the `view` member of the
    `Preferences` class, which can be found at `bpy.context.preferences`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 根据API参考，`PreferencesView`是`Preferences`类的`view`成员，可以在`bpy.context.preferences`中找到：
- en: '[https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml](https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml](https://docs.blender.org/api/3.3/bpy.types.Preferences.xhtml)'
- en: '#bpy.types.Preferences.view'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '#bpy.types.Preferences.view'
- en: 'So, the full path of the **Developer Extras** setting is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，**开发者额外功能**设置的完整路径如下：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The value of `show_developer_ui` is either `True` or `False`. Using it as a
    condition, we exit `reload_modules` if **Developer Extras** is disabled:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`show_developer_ui`的值要么是`True`要么是`False`。使用它作为条件，如果**开发者额外功能**被禁用，我们将退出`reload_modules`：'
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we add a `reload` call for each `.py` file that we want to refresh. The
    first line reloads `_refresh_.py`, looking up the current filename in the system
    dictionary, `sys.modules`. This way, we can update changes in the `_refresh_`
    module itself. So, the full body of the `reload_modules` function looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们为每个我们想要刷新的`.py`文件添加一个`reload`调用。第一行重新加载`_refresh_.py`，在系统字典`sys.modules`中查找当前文件名。这样，我们可以更新`_refresh_`模块本身的变化。因此，`reload_modules`函数的完整体如下所示：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, enabling `__init__.py`, as that is the only file to be executed when scripts
    are reloaded. We must invoke `_refresh_.reload_modules()` in the import section:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启用`__init__.py`，因为这是脚本重新加载时唯一要执行的文件。我们必须在导入部分调用`_refresh_.reload_modules()`：
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Calling `OBJECT_PT_structured`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`OBJECT_PT_structured`：
- en: '![Figure 6.8: Our panel source code has been reloaded](img/Figure_6.08_B18375.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8：我们的面板源代码已被重新加载](img/Figure_6.08_B18375.jpg)'
- en: 'Figure 6.8: Our panel source code has been reloaded'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8：我们的面板源代码已被重新加载
- en: The limitation of three objects can be set in the `max_objects = 3` static member.
    However, there is a better place for hosting our add-on setting. In the next section,
    we are going to implement proper preferences for our add-on.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`max_objects = 3`静态成员中设置三个对象的限制。然而，有一个更好的地方可以存放我们的附加组件设置。在下一节中，我们将实现我们附加组件的正确首选项。
- en: Using add-on preferences
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用附加组件首选项
- en: Besides using Blender preferences, we can use `bpy.types.AddonPreferences` to
    display the add-on-specific custom settings under the add-on activation checkbox.
    It’s an interface, just like `bpy.types.Panel`, and we can add settings to its
    layout using its `draw` method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用Blender首选项外，我们还可以使用`bpy.types.AddonPreferences`在附加组件激活复选框下显示附加组件特定的自定义设置。它是一个接口，就像`bpy.types.Panel`一样，我们可以使用它的`draw`方法向其布局添加设置。
- en: 'The `bl_idname` attribute of `AddonPreferences` must match the Python name
    of the add-on. The usage of `__name__` for single files and `__package__` for
    folders makes our code easier to maintain: these variables always match the respective
    Python names, so changes in files and folders’ names would have no consequences.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddonPreferences`的`bl_idname`属性必须与附加组件的Python名称匹配。对于单个文件使用`__name__`和对于文件夹使用`__package__`可以使我们的代码更容易维护：这些变量始终匹配相应的Python名称，因此文件和文件夹名称的变化不会产生任何影响。'
- en: Creating preferences
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建首选项
- en: 'Since we are using multiple files, we will create `preferences.py` inside the
    folder of our `structured_addon`. It contains the `StructuredPreferences` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用多个文件，我们将在`structured_addon`文件夹内创建`preferences.py`。它包含`StructuredPreferences`类：
- en: '[PRE30]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we must add a `register_classes` and an `unregister_classes` function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加一个`register_classes`和一个`unregister_classes`函数：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can add `preferences` to the `import` section of `__init__.py`, which looks
    like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`preferences`添加到`__init__.py`的`import`部分，如下所示：
- en: '[PRE32]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, we must register the class from the preferences module alongside the
    others:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将首选项模块中的类与其它类一起注册：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We must also make sure that the preferences will be reloaded in `_refresh_.py`.
    This is what the `_reload_modules` function will look like:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须确保首选项将在`_refresh_.py`中重新加载。`_reload_modules`函数看起来是这样的：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If we use **Reload Scripts** now, we will see our preferences beneath the **Add-on**
    checkbox, in the **Add-Ons** list:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在使用**重新加载脚本**，我们将在**附加组件**复选框下方看到我们的首选项，在**附加组件**列表中：
- en: '![Figure 6.9: Add-ons settings displayed in the Preferences window](img/Figure_6.09_B18375.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9：在首选项窗口中显示的附加组件设置](img/Figure_6.09_B18375.jpg)'
- en: 'Figure 6.9: Add-ons settings displayed in the Preferences window'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9：在首选项窗口中显示的附加组件设置
- en: The preferences show up but are still empty. Next, we are going to add some
    values.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 首选项显示出来，但仍然是空的。接下来，我们将添加一些值。
- en: Populating the preferences
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 填充首选项
- en: 'We want to replace `OBJECT_PT_structured .max_objects` with a setting. It’s
    an integer number, so we will add an `IntProperty` to the `StructuredPreferences`
    class:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想用设置替换 `OBJECT_PT_structured .max_objects`。它是一个整数，因此我们将向 `StructuredPreferences`
    类添加一个 `IntProperty`：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now that it contains an integer property, `StructuredPreferences` can store
    the maximum displayed objects setting. To display this property to the user, we
    will add it to the layout in the `draw` method. A simple `layout.prop` instruction
    will be enough:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它包含一个整型属性，`StructuredPreferences` 可以存储最大显示对象设置。为了将此属性显示给用户，我们将在 `draw` 方法中将它添加到布局中。一个简单的
    `layout.prop` 指令就足够了：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'But we can also use `split` for a nicer appearance. A split layout creates
    a column for each new entry. Adding an empty widget, a `separator`, as the first
    element, creates an indentation:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们也可以使用 `split` 来获得更好的外观。一个分割布局为每个新条目创建一个列。添加一个空小部件，一个 `separator` 作为第一个元素，创建一个缩进：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Reloading the script will display **Max Objects** as an editable setting:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载脚本将显示 **最大对象数** 作为可编辑设置：
- en: '![Figure 6.10: Max Objects as a Preferences setting](img/Figure_6.10_B18375.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10：最大对象数作为首选项设置](img/Figure_6.10_B18375.jpg)'
- en: 'Figure 6.10: Max Objects as a Preferences setting'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10：最大对象数作为首选项设置
- en: 'This value is saved along with the other user preferences, and Blender remembers
    its value when the application is restarted. We aren’t using this setting yet:
    we need to adjust the code in our panel so that we can use it.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 此值将与其他用户首选项一起保存，并且 Blender 在应用程序重新启动时记住其值。我们目前还没有使用此设置：我们需要调整我们的面板中的代码，以便可以使用它。
- en: Using add-on preferences in code
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在代码中使用扩展首选项
- en: 'Python scripts can access the preferences of an add-on using one line of code:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Python 脚本可以通过一行代码访问扩展的首选项：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Notice how `preferences` is repeated at the end. It might seem redundant but
    it makes sense since `bpy.context.preferences.addons` refers to the application
    preferences, not the ones of the single add-on.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `preferences` 在末尾被重复。这可能看起来是多余的，但这是有意义的，因为 `bpy.context.preferences.addons`
    指的是应用程序首选项，而不是单个扩展的首选项。
- en: '`bpy.context.preferences.addons[ADDON_NAME]` returns the add-on as a Python
    object.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpy.context.preferences.addons[ADDON_NAME]` 返回扩展作为 Python 对象。'
- en: 'With that in mind, we will go back to the `OBJECT_PT_structured` class in the
    *user interface’s* `panel.py` module. Since we are going to use the value from
    the preferences, it should not have a `max_objects` static member anymore:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个前提下，我们将回到 `OBJECT_PT_structured` 类在 *用户界面* 的 `panel.py` 模块中的 `OBJECT_PT_structured`
    类。由于我们将使用首选项中的值，它不再应该有一个 `max_objects` 静态成员：
- en: '[PRE39]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, before we iterate the scene objects in the `draw` function, we must get
    our `add_on` and `preferences` from the context. Using `enumerate`, so that we
    can keep count of the objects while they are displayed, we stop the loop when
    the amount stored in `preferences.max_objects` is reached:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们迭代 `draw` 函数中的场景对象之前，我们必须从上下文中获取我们的 `add_on` 和 `preferences`。使用 `enumerate`，这样我们可以在显示对象时保持计数，当
    `preferences.max_objects` 中存储的数量达到时，我们停止循环：
- en: '[PRE40]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This time, we check `max_objects` with a greater or equal (`>=`) comparison
    because, since the enumeration starts from `0`, breaking after `i > max_objects`
    would display one more object.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们使用大于或等于 (`>=`) 的比较来检查 `max_objects`，因为枚举从 `0` 开始，在 `i > max_objects` 后中断会显示一个额外的对象。
- en: 'Just to be clear, using a separate module for the add-on preferences is not
    required – the entirety of the code written in this chapter could have been contained
    in a single, large `.py` file: we are just splitting the code for the sake of
    readability.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清楚起见，使用单独的模块为扩展首选项不是必需的——本章中编写的全部代码本可以包含在一个单独的大 `.py` 文件中：我们只是为了可读性而拆分代码。
- en: If our add-on contains operators, we can create modules for those as well.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的扩展包含操作符，我们也可以为它们创建模块。
- en: Adding operators
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加操作符
- en: Operators can be grouped into different files according to their purpose. For
    example, transform-related operators such as `ops_transform.py`, while our first
    few operators, `ops_collections.py` file. All those classes would be then registered
    by `__init__.py` and, if needed, added to the add-on interface via relative import.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符可以根据其目的分组到不同的文件中。例如，与转换相关的操作符，如 `ops_transform.py`，而我们的前几个操作符，`ops_collections.py`
    文件。所有这些类随后将通过 `__init__.py` 进行注册，如果需要，可以通过相对导入添加到扩展接口中。
- en: Another solution is creating one module for all the operators, which can be
    named `operators.py`. In this section, we will create an operators module for
    our add-on.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是为所有操作符创建一个模块，可以命名为 `operators.py`。在本节中，我们将为我们的扩展创建一个操作符模块。
- en: Writing the operators module
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写操作员模块
- en: 'In the `structured _addon` folder, we will create the `operators.py` module.
    It will contain our operator class: we will reuse the `bpy`, which is ubiquitous
    in Blender script, we will import the `random` module and use `randint` in the
    `add_random_location` function:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在`structured _addon`文件夹中，我们将创建`operators.py`模块。它将包含我们的操作员类：我们将重用Blender脚本中无处不在的`bpy`，我们将导入`random`模块并在`add_random_location`函数中使用`randint`：
- en: '[PRE41]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, we can proceed with the add-on class. It’s the same as in the *Displaying
    buttons* section in the previous chapter – `poll` returns `True` if there are
    selected objects, while `execute` runs `add_random_location`, with the operator’s
    amount and axis as arguments:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续添加附加类。它和前一章的*显示按钮*部分相同 - `poll`返回`True`表示有选中的对象，而`execute`运行`add_random_location`，以操作员的数量和轴作为参数：
- en: '[PRE42]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Like in the case of `panel.py`, we must add functions for registering the module’s
    classes:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`panel.py`的情况一样，我们必须添加注册模块类的函数：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, we can import `operators.py` into the other modules of the script.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将`operators.py`导入脚本的其他模块。
- en: Registering operator classes
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册操作员类
- en: 'To use our operator, we must import `operators.py` in `__init__.py`, whose
    `import` section will look like this:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的操作员，我们必须在`__init__.py`中导入`operators.py`，其`import`部分将如下所示：
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Of course, we can add and remove our operators with `operator.register_class`
    and `operator.unregister_class`. Since operators might be used as buttons, we
    call `operators.register_classes` before `panel.register_classes`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以使用`operator.register_class`和`operator.unregister_class`添加和删除我们的操作员。由于操作员可能用作按钮，我们在`panel.register_classes`之前调用`operators.register_classes`：
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will make `operators.py` to be effective when we reload the script, we
    must add `operators` to `_refresh_.reload_modules`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，当我们在重新加载脚本时，`operators.py`将生效，我们必须将`operators`添加到`_refresh_.reload_modules`中。
- en: Refreshing operators on reload
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新加载时刷新操作员
- en: 'Thanks to the work we did in the *Reloading cached modules* section, adding
    operators to the refreshed modules is easy: we add `reload(operators)` to the
    `reload_modules` function. The whole `_refresh_.py` file now looks like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了我们在*重新加载缓存模块*部分所做的努力，向刷新的模块添加操作员变得容易：我们在`reload_modules`函数中添加`reload(operators)`。现在整个`_refresh_.py`文件如下所示：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The only thing left to do is display the operator button in the panel.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是在面板中显示操作员按钮。
- en: Adding operator buttons
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加操作员按钮
- en: 'To add the `panel.py`, whose import section will look as follows:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加`panel.py`，其导入部分将如下所示：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Now, our panel can access the `TRANSFORM_OT_random_location` class using `operators`
    as a namespace, so we will add a new element to the `draw` method:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的面板可以使用`operators`作为命名空间访问`TRANSFORM_OT_random_location`类，因此我们将向`draw`方法添加一个新元素：
- en: '[PRE48]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Upon displaying the `F3` **Search Bar** area to look up and run **Reload Scripts**,
    our panel will display the **Add random** **Location** button:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示`F3` **搜索栏**区域查找并运行**重新加载脚本**时，我们的面板将显示**添加随机** **位置**按钮：
- en: '![Figure 6.11: Modular panel displaying operators via relative import](img/Figure_6.11_B18375.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图6.11：通过相对导入显示操作员的模块化面板](img/Figure_6.11_B18375.jpg)'
- en: 'Figure 6.11: Modular panel displaying operators via relative import'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.11：通过相对导入显示操作员的模块化面板
- en: 'Our add-on is finished. However, we could refine `panel.py` and add the same
    functionalities that we wrote for `VerySimplePanel` in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100),
    namely the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的附加组件完成了。然而，我们可以改进`panel.py`并添加我们在[*第5章*](B18375_05.xhtml#_idTextAnchor100)中为`VerySimplePanel`编写的相同功能，即以下内容：
- en: Color-coded entries for selected/active objects
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为选定的/活动对象着色的条目
- en: A **Delete** button with a context-sensitive label
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有上下文相关标签的**删除**按钮
- en: Implementing those is left as an exercise for you. In the next section, we will
    learn how to distribute our add-on folders to other users.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这些留作练习。在下一节中，我们将学习如何将我们的附加组件文件夹分发给其他用户。
- en: Packaging and installing add-ons
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 打包和安装附加组件
- en: We learned how to install single `.py` add-ons in the *Installing our add-ons*
    section of [*Chapter 3*](B18375_03.xhtml#_idTextAnchor049). To distribute an add-on
    that consists of more files, we must create a `.zip` archive of it. Most of you
    will be familiar with how a `.zip` file is a compressed archive that can contain
    more files or folders.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第3章*](B18375_03.xhtml#_idTextAnchor049)的*安装我们的附加组件*部分学习了如何安装单个`.py`附加组件。要分发由多个文件组成的附加组件，我们必须创建一个包含它的`.zip`存档。你们大多数人都会熟悉`.zip`文件是一个压缩存档，可以包含更多文件或文件夹。
- en: 'Blender can install folders from a standard `.zip` archive, but there are two
    requirements:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 可以从标准的 `.zip` 归档中安装文件夹，但有两条要求：
- en: The `.zip` file must contain the add-on as a first-level folder
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.zip` 文件必须包含插件作为一级文件夹'
- en: The name of the first-level folder must not contain any dot (`.`) as it won’t
    work with Python’s import system
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一级文件夹的名称不能包含任何点 (`.`)，因为它不会与 Python 的导入系统兼容。
- en: There are third-party tools, such as `.zip` files using the file utilities of
    your operating system. In this section, we will learn how to compress an add-on
    folder on **Windows** **OSX**, and **Ubuntu** systems.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 有第三方工具，例如使用操作系统的文件实用程序创建 `.zip` 文件。在本节中，我们将学习如何在 **Windows**、**OSX** 和 **Ubuntu**
    系统上压缩插件文件夹。
- en: Cleaning up bytecode
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理字节码
- en: 'If the `structured_addon.zip\structured_addon` folder contains a subfolder
    named `__pycache__`, make sure you delete it: you should not distribute the `.pyc`
    files it contains.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `structured_addon.zip\structured_addon` 文件夹包含名为 `__pycache__` 的子文件夹，请确保您删除它：您不应该分发它包含的
    `.pyc` 文件。
- en: Creating a .zip file using 7-Zip
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 7-Zip 创建 .zip 文件
- en: '**7-Zip** is a free compression utility for Windows. It is very lightweight
    and integrates with the file manager. Here are the steps to use it for packaging
    our add-ons:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**7-Zip** 是一款适用于 Windows 的免费压缩工具。它非常轻量级，并且与文件管理器集成。以下是使用它打包我们的插件步骤：'
- en: Download and install 7-Zip from [https://www.7-zip.org](https://www.7-zip.org).
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 [https://www.7-zip.org](https://www.7-zip.org) 下载并安装 7-Zip。
- en: Open **File Explorer**.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **文件资源管理器**。
- en: Navigate to the directory containing the `structured_addon` folder.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到包含 `structured_addon` 文件夹的目录。
- en: Right-click on the `structured_addon` folder to show the context menu.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `structured_addon` 文件夹以显示上下文菜单。
- en: Select **7-Zip** | **Add** **to “structured_addon.zip”**.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **7-Zip** | **添加** **到“structured_addon.zip”**。
- en: The `structured_addon.zip` file will be created alongside the original folder.
    If for some reason it is not possible to install 7-Zip or any other compression
    tool, we can still create `.zip` files using Windows File Explorer alone.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '`structured_addon.zip` 文件将与原始文件夹一起创建。如果由于某种原因无法安装 7-Zip 或任何其他压缩工具，我们仍然可以使用
    Windows 文件资源管理器单独创建 `.zip` 文件。'
- en: Creating a .zip file using Windows File Manager
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Windows 文件管理器创建 .zip 文件
- en: Open **File Explorer**.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **文件资源管理器**。
- en: Navigate to a folder where we want to create the add-on.
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到我们想要创建插件的文件夹。
- en: Display the context menu by right-clicking on the background.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击背景来显示上下文菜单。
- en: 'From the right-click menu, select `structured_addon.zip`:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右键菜单中选择 `structured_addon.zip`：
- en: '![Figure 6.12: Creating empty .zip files using Windows File Explorer](img/Figure_6.12_B18375.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12：使用 Windows 文件资源管理器创建空 .zip 文件](img/Figure_6.12_B18375.jpg)'
- en: 'Figure 6.12: Creating empty .zip files using Windows File Explorer'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12：使用 Windows 文件资源管理器创建空 .zip 文件
- en: 'So far, we have created a `.zip` file, but it is empty. Next, we will copy
    our add-on files there:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个 `.zip` 文件，但它仍然是空的。接下来，我们将把我们的插件文件复制到那里：
- en: Copy the `ch6\addons\structured_addon` folder to the clipboard by using *Ctrl*
    + *C* or right-clicking and selecting **Copy**.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 *Ctrl* + *C* 或右键单击并选择 **复制**，将 `ch6\addons\structured_addon` 文件夹复制到剪贴板。
- en: Double-click the `structured_addon.zip` archive to display its content.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `structured_addon.zip` 归档以显示其内容。
- en: Paste the `ch6\addons\structured_addon` folder into the archive via *Ctrl* +
    *V* or right-clicking and selecting **Paste**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 *Ctrl* + *V* 或右键单击并选择 **粘贴**，将 `ch6\addons\structured_addon` 文件夹粘贴到归档中。
- en: Creating a .zip file on Mac using Finder
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Mac 上使用 Finder 创建 .zip 文件
- en: 'Follow these steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: Right-click on the `structure_addon` folder in **Finder** or left-click without
    releasing the button. A menu will appear.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Finder** 中右键单击 `structure_addon` 文件夹或左键单击不释放按钮。将出现一个菜单。
- en: 'Select **Compress “structured_addon”** from the menu:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择 **压缩“structured_addon”**：
- en: '![Figure 6.13: Compressing folders on a Mac computer](img/Figure_6.13_B18375.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13：在 Mac 计算机上压缩文件夹](img/Figure_6.13_B18375.jpg)'
- en: 'Figure 6.13: Compressing folders on a Mac computer'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13：在 Mac 计算机上压缩文件夹
- en: Creating a .zip file using Gnome
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Gnome 创建 .zip 文件
- en: '`.zip` file using Gnome:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gnome 创建 `.zip` 文件：
- en: Right-click on the `structure_addon` folder in the File Browser.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件浏览器中右键单击 `structure_addon` 文件夹。
- en: Choose the **Compress…** option from the menu.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从菜单中选择 **压缩…** 选项。
- en: Confirm the filename and `.zip` extension of the archive.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确认归档的文件名和 `.zip` 扩展名。
- en: Click the **Create** button.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建** 按钮。
- en: Installing .zip add-ons
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 .zip 插件
- en: 'The steps for installing a compressed add-on are the same as those we learned
    about in the *Expanding Blender by creating a simple add-on* section of [*Chapter
    3*](B18375_03.xhtml#_idTextAnchor049):'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 安装压缩附加组件的步骤与我们在[*第3章*](B18375_03.xhtml#_idTextAnchor049)的*通过创建简单的附加组件扩展Blender*部分中学到的步骤相同：
- en: Open the **Preferences** window via **Edit** | **Preferences** from the top
    menu.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过顶部的菜单**编辑** | **首选项**打开**首选项**窗口。
- en: Select the **Add-ons** tab in the left column.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列中选择**附加组件**标签页。
- en: Click on the **Install** button at the top right of **Add-ons Preferences**.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**附加组件首选项**右上角的**安装**按钮。
- en: In the file browser, find the `structured_addon.zip` file.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件浏览器中找到`structured_addon.zip`文件。
- en: Click the **Install Add-on** button at the bottom.
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击底部的**安装附加组件**按钮。
- en: With that, we have gone through the complete development and release of our
    structured add-on. A modular approach is important in programming and works for
    relatively simple tools as well. Plus, it makes our scripts more manageable as
    they increase in complexity.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经完成了我们结构化附加组件的完整开发和发布。在编程中，模块化方法很重要，并且适用于相对简单的工具。此外，随着复杂性的增加，它使我们的脚本更容易管理。
- en: Summary
  id: totrans-320
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to set up a modular architecture for our code
    by splitting it into different files while keeping it coherent and clear. We also
    learned how to load files procedurally and how to write settings for our add-ons.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过将代码拆分为不同的文件来设置代码的模块化架构，同时保持其连贯性和清晰性。我们还学习了如何按程序加载文件以及如何为我们的附加组件编写设置。
- en: This approach confers interoperability and generical usefulness to our code
    and, by applying appropriate separation guidelines, eases our task in navigating
    the different parts of our tools.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法为我们的代码提供了互操作性和通用性，并且通过应用适当的分离指南，简化了我们导航工具不同部分的任务。
- en: In [*Chapter 7*](B18375_07.xhtml#_idTextAnchor171), we will learn how to animate
    with Python and change the animation settings with our scripts.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B18375_07.xhtml#_idTextAnchor171)中，我们将学习如何使用Python进行动画制作，并使用我们的脚本来更改动画设置。
- en: Questions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Can Blender add-ons consist of multiple files?
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Blender附加组件可以由多个文件组成吗？
- en: Which file of an add-on folder contains the info dictionary?
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 附加组件文件夹中的哪个文件包含信息字典？
- en: How does relative import work?
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 相对导入是如何工作的？
- en: Does reloading an add-on refresh all its modules?
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载附加组件是否会刷新所有模块？
- en: Where do we store the settings of an add-on?
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在哪里存储附加组件的设置？
- en: How do we show the add-on properties in the preferences?
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在首选项中显示附加组件属性？
- en: How do we distribute multi-file add-ons?
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何分发多文件附加组件？
