- en: Chapter 2. Graphics – the Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 图形 – 画布
- en: Any Kivy `Widget` contains a **`Canvas`** object. A Kivy **`Canvas`** is a set
    of drawing instructions that define the graphical representation of `Widget`.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何Kivy `Widget`都包含一个**`Canvas`**对象。Kivy的**`Canvas`**是一组绘图指令，定义了`Widget`的图形表示。
- en: Tip
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Be careful with the name because it tends to be confusing! A **`Canvas`** object
    is not what we draw on (for example, as it is in HTML5); it is a set of instructions
    to draw in the **coordinate space**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名称，因为它往往容易引起混淆！**`Canvas`**对象不是我们绘制的地方（例如，像HTML5中那样）；它是一组在**坐标空间**中绘图的指令。
- en: The coordinate space refers to the place in which we draw. All the Kivy widgets
    share the same coordinate space, and a `Canvas` instance, the instructions to
    draw on it. A coordinate space is not restricted to the size of the window or
    the application screen, which means that we can draw outside of the visible area.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标空间指的是我们绘制图形的地方。所有Kivy小部件共享相同的坐标空间，以及一个`Canvas`实例，即绘制在其上的指令。坐标空间不受窗口大小或应用程序屏幕大小的限制，这意味着我们可以在可见区域之外绘制。
- en: 'We will discuss how to draw and manipulate the representation of the widgets
    through the instructions we add to the `Canvas` object. Here is a list of the
    most important skills that we will cover:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论如何通过添加到`Canvas`对象（例如，按钮的画布）的指令来绘制和操作小部件的表示。以下是我们将要涵盖的最重要技能列表：
- en: Drawing basic geometric shapes (straight and curve lines, ellipses, and polygons)
    through **vertex instructions**
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**顶点指令**绘制基本几何形状（直线和曲线线、椭圆和多边形）
- en: Using colors, and rotating, translating, and scaling the coordinate space through
    the **context instructions**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色，并通过**上下文指令**旋转、平移和缩放坐标空间
- en: The difference between vertex and context instructions and how they complement
    each other
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点指令和上下文指令之间的区别以及它们如何相互补充
- en: The three different sets of instructions of `Canvas` that we can use to modify
    the order of execution of the graphics instructions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用来修改图形指令执行顺序的`Canvas`的三组不同指令
- en: Storing and retrieving the current coordinate space context through `PushMatrix`
    and `PopMatrix`
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过`PushMatrix`和`PopMatrix`存储和检索当前坐标空间上下文
- en: Using the Kivy canvas brings with it some technical challenges because Kivy
    integrates graphic processing with efficiency in mind. These challenges are not
    initially obvious, but there is nothing particularly difficult about them if we
    understand the underlying problem. This is why the next section is dedicated to
    introduce the main considerations that we face when we use the canvas.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kivy画布带来了一些技术挑战，因为Kivy在考虑效率的同时集成了图形处理。这些挑战最初可能不明显，但如果我们理解了根本问题，它们并没有什么特别困难。这就是为什么下一节将专门介绍我们在使用画布时面临的主要考虑因素。
- en: Understanding the canvas
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解画布
- en: 'Before studying the examples of this chapter, it is important to recapitulate
    the following particularities related to the graphics display:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习本章的示例之前，回顾以下与图形显示相关的特定性非常重要：
- en: The coordinate space refers to the place in which we draw, which is not restricted
    to the windows size
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标空间指的是我们绘制图形的地方，它并不局限于窗口大小
- en: A `Canvas` object is a set of instructions to draw in the coordinate space,
    not the place we draw in
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Canvas`对象是一组在坐标空间中绘图的指令，而不是我们绘制的地方'
- en: All `Widget` objects contain their own `Canvas` (canvases, which we will see
    later) but all of them share the same coordinate space, the one in the `App` object.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有`Widget`对象都包含它们自己的`Canvas`（我们稍后会看到），但它们都共享相同的坐标空间，即`App`对象中的那个。
- en: For example, if we add a rotation instruction to a specific `Canvas` instance
    (for example, the canvas of a button), then this will also affect all the subsequent
    graphics instructions that are going to display graphics in the coordinate space.
    It doesn't matter if the graphics belong to canvases of different widgets; they
    all share the same coordinate space.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们向特定的`Canvas`实例（例如，按钮的画布）添加旋转指令，那么这也会影响所有即将在坐标空间中显示图形的后继图形指令。无论图形属于不同小部件的画布，它们都共享相同的坐标空间。
- en: Therefore, we need to learn techniques to leave the coordinate space context
    in its original state after modifying it with graphics instructions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要学习技术，在用图形指令修改坐标空间后，将其恢复到原始状态。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: All the graphics instructions added to different `Canvas` objects, which at
    the same time belong to different `Widget` objects, affect the same coordinate
    space. It is our task to make sure that the coordinate space is in its original
    state after modifying it with the graphics instructions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到不同`Canvas`对象的所有图形指令，这些对象同时属于不同的`Widget`对象，影响相同的坐标空间。我们的任务是确保在用图形指令修改后，坐标空间保持其原始状态。
- en: Another important concept that we need to extend is the one of the **`Widget`**.
    We already know that widgets are the blocks that allow us to build interfaces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要扩展的另一个重要概念是**`Widget`**。我们已经知道，部件是允许我们构建界面的块。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A **`Widget`** is also a place marker (with its position and size), but not
    necessarily a placeholder. The instructions of the canvas of a widget are not
    restricted to the specific area of the widget but to the whole coordinate space.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Widget`**也是一个占位符（带有其位置和大小），但不一定是占位符。部件的画布指令不仅限于部件的特定区域，而是整个坐标空间。'
- en: This directly adds to the previous problem of sharing a coordinate space. Not
    only do we need to control the fact that we share a coordinate space, but also,
    we have no restrictions on where to draw. On one hand, this makes Kivy very efficient
    and gives us a lot of flexibility. On the other hand, this seems to be a lot to
    control. Fortunately, Kivy provides the necessary tools to easily work around
    the problem.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这直接增加了之前共享坐标空间的问题。我们不仅需要控制共享坐标空间的事实，而且我们没有对绘制位置的任何限制。一方面，这使得 Kivy 非常高效，并给我们提供了很多灵活性。另一方面，这似乎需要控制很多。幸运的是，Kivy
    提供了必要的工具，可以轻松地解决这个问题。
- en: The next section will present the available graphics instructions that can be
    added to the canvas in order to draw basic shapes. After this, we will explore
    graphic instructions that change the coordinate space context and exemplify the
    problems of sharing the coordinate space. The final section concentrates on illustrating
    the acquired knowledge inside the **Comic Creator**, where we learn the most common
    techniques to master the use of the canvas considering its particularities. By
    the end of this chapter, we will be in complete control of the graphics that are
    displayed on the screen.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将介绍可以添加到画布中以绘制基本形状的可用的图形指令。之后，我们将探索改变坐标空间上下文的图形指令，并举例说明共享坐标空间的问题。最后一部分专注于在**漫画创作者**中展示所获得的知识，在那里我们学习最常用的技术来掌握画布的使用，考虑到其特性。到本章结束时，我们将完全控制屏幕上显示的图形。
- en: Drawing basic shapes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制基本形状
- en: 'Before starting, let''s introduce the Python code that we will reuse in all
    the examples of this chapter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们介绍本章所有示例中都将重用的 Python 代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We created the subclass `DrawingSpace` from `RelativeLayout`. It could have
    been inherited from any `Widget` but using `RelativeLayout` is generally a good
    choice for graphics because we usually want to draw inside the widget, and that
    means relative to its position.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从`RelativeLayout`创建了子类`DrawingSpace`。它本可以从任何`Widget`继承，但使用`RelativeLayout`通常是图形的一个好选择，因为我们通常希望在部件内部绘制，这意味着相对于其位置。
- en: 'Let''s start with the canvas. There are basically two types of instructions
    that we can add to a canvas: vertex instructions and context instructions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从画布开始。基本上，我们可以添加到画布中的指令有两种：顶点指令和上下文指令。
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **vertex instructions** inherit from the **`VertexInstruction`** base class,
    and allow us to draw vector shapes in the coordinate space.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**顶点指令**继承自**`VertexInstruction`**基类，并允许我们在坐标空间中绘制矢量形状。'
- en: The **context instructions** (`Color`, `Rotate`, `Translate`, and `Scale`) inherit
    from the **`ContextInstruction`** base class, and let us apply transformations
    to the **coordinate space context**. By **coordinate space context**, we mean
    the conditions in which the shapes (specified in the vertex instructions) are
    drawn in the coordinate space.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文指令**（`Color`、`Rotate`、`Translate`和`Scale`）继承自**`ContextInstruction`**基类，并允许我们对**坐标空间上下文**应用变换。通过**坐标空间上下文**，我们指的是形状（在顶点指令中指定）在坐标空间中绘制的条件。'
- en: 'Basically, **vertex instructions** are what we draw and **context instructions**
    affect where and how we draw. The following is the screenshot for the first example
    of this chapter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，**顶点指令**是我们绘制的，而**上下文指令**影响我们绘制的位置和方式。以下是本章第一个示例的截图：
- en: '![Drawing basic shapes](img/B04244_02_01.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01.jpg)'
- en: In the preceding screenshot, the gray grid will simplify reading the coordinates
    that appear in the code. Also, the white letters associated with each cell will
    be used to refer to the shapes. Neither the grid nor the letters are part of the
    Kivy example. The preceding screenshot illustrates 10 basic figures that we learn
    to draw with vertex instructions. Almost all the available Kivy classes are represented
    in this example and we can create any 2D geometric shape with them. Since the
    vertex instructions use fixed coordinates, it is important to run this example
    with a screen size of 500 x 200 (`python drawing.py --size=500x200`) in order
    to visualize the shapes correctly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，灰色网格将简化读取代码中出现的坐标。此外，与每个单元格关联的白色字母将用于引用形状。网格和字母都不是 Kivy 示例的一部分。前面的屏幕截图展示了我们通过顶点指令学习绘制的
    10 个基本图形。几乎所有的可用 Kivy 类都包含在这个示例中，我们可以用它们创建任何 2D 几何形状。由于顶点指令使用固定坐标，因此以 500 x 200（`python
    drawing.py --size=500x200`）的屏幕尺寸运行此示例非常重要，以便正确地可视化形状。
- en: 'We will study the Kivy language (`drawing.kv`) with small code fragments associated
    to the respective figure (and coordinates) next to it, so it would be easier to
    follow. Let''s start with the shape **A** (rectangle):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究 Kivy 语言 (`drawing.kv`)，并附带与其相关的图形（和坐标）的小段代码，这样会更容易理解。让我们从形状 **A**（矩形）开始：
- en: '![Drawing basic shapes](img/B04244_02_01a.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01a.jpg)'
- en: 'Following is the code snippet for shape **A**:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为形状 **A** 的代码片段：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**`Rectangle`** is a good starting point because it resembles the way we set
    properties in widgets. We just have to set the **`pos`** and **`size`** properties.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**`矩形`** 是一个很好的起点，因为它与我们设置小部件属性的方式相似。我们只需设置 **`pos`** 和 **`size`** 属性。'
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **`pos`** and **`size`** properties of the vertex instructions are different
    from the `pos` and `size` properties of `Widget`, since they belong to the `VertexInstruction`
    base class. All the values to specify the properties of the vertex instructions
    are given in fixed values.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点指令的 **`pos`** 和 **`size`** 属性与 `Widget` 的 **`pos`** 和 **`size`** 属性不同，因为它们属于
    `VertexInstruction` 基类。指定顶点指令属性的所有值都是固定值。
- en: This means that we cannot use the `size_hint` or `pos_hint` properties as we
    did with the widgets in [Chapter 1](ch01.html "Chapter 1. GUI Basics – Building
    an Interface"), *GUI Basics – Building an Interface*. However, we can use the
    properties of `self` to achieve similar results (Line 18 and 19).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们无法像在 [第 1 章](ch01.html "第 1 章。GUI 基础 - 构建界面") *GUI 基础 - 构建界面* 中使用小部件那样使用
    `size_hint` 或 `pos_hint` 属性。然而，我们可以使用 `self` 的属性来实现类似的结果（第 18 行和第 19 行）。
- en: 'Let''s proceed with the shape **B** (Pac-Man-like figure):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续处理形状 **B**（类似 Pac-Man 的图形）：
- en: '![Drawing basic shapes](img/B04244_02_01b.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01b.jpg)'
- en: 'Following is the code snippet for shape **B**:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为形状 **B** 的代码片段：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The **`Ellipse`** works very similar to `Rectangle`, but it has three new properties:
    **`angle_start`**, **`angle_end`**, and **`segments`**. The first two properties
    specify the initial and final angle of the ellipse. The angle 0° is North (or
    12 o''clock) and they add up in the clockwise direction. So, the `angle_start`
    is 120° (90° + 30°), which is the lower jaw of the Pac-Man-like figure (Line 21).
    The `angle_end` value is 420° (360° + (90°-30°)), which is bigger than `angle_start`
    because we need Kivy to follow the clockwise direction to paint the `Ellipse`.
    If we specify a lower value than `angle_start`, Kivy will follow a counter clockwise
    direction, painting where the mouth of the Pac-Man is, instead of its body.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**`椭圆`** 与 `Rectangle` 非常相似，但它有三个新属性：**`angle_start`**、**`angle_end`** 和 **`segments`**。前两个属性指定椭圆的起始和结束角度。0°
    角度是北（或 12 点钟），它们按顺时针方向相加。因此，`angle_start` 是 120°（90° + 30°），这是类似 Pac-Man 的图形的下颚（第
    21 行）。`angle_end` 的值是 420°（360° + (90°-30°)），它比 `angle_start` 大，因为我们需要 Kivy 按顺时针方向绘制
    `Ellipse`。如果我们指定一个低于 `angle_start` 的值，Kivy 将按逆时针方向绘制，绘制 Pac-Man 的嘴巴而不是身体。'
- en: 'Let''s continue with the shape **C** (triangle):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续处理形状 **C**（三角形）：
- en: '![Drawing basic shapes](img/B04244_02_01c.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01c.jpg)'
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The triangle of shape **C** is actually another **`Ellipse`** that we obtain
    thanks to the **`segments`** property (Line 26). Let''s put it this way: if you
    have to draw an ellipse with three lines, the best you would end up with is a
    triangle. If you have four lines, you would end up with a rectangle. You actually
    need infinite lines for a perfect `Ellipse`, but a computer cannot process that
    (neither the screen has enough resolution to support this), so we need to stop
    at some point. The default `segments` are 180\. Notice that if you have a circle
    (that is, size: x,x), you will always get equilateral polygons (for example, a
    square if you specify just four `segments`).'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 形状 **C** 的三角形实际上是通过 **`segments`** 属性（第 26 行）获得的另一个 **`Ellipse`**。让我们这样表达：如果您必须用三条线绘制一个椭圆，您最终得到的最好的结果是一个三角形。如果您有四条线，您将得到一个矩形。实际上，您需要无限多条线才能得到完美的
    `Ellipse`，但计算机无法处理这一点（屏幕的分辨率也无法支持这一点），因此我们需要在某个地方停止。默认的 `segments` 是 180。请注意，如果您有一个圆（即大小：x,x），您将始终得到等边多边形（例如，如果您只指定四个
    `segments`，则得到一个正方形）。
- en: 'We can analyze shapes **D**, **E**, **F**, and **G** together:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以一起分析形状 **D**、**E**、**F** 和 **G**：
- en: '![Drawing basic shapes](img/B04244_02_01d.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01d.jpg)'
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**`Triangle`** (shape **D**), **`Quad`** (shape **E**), and **`Line`** (shape
    **F**) work similarly. Their **`points`** property (Lines 30, 32, and 34) indicates
    the corners of a triangle, quadrilateral, and a line, respectively. The **`points`**
    property is a sequence of coordinates in the format `(x1, y1, x2, y2)`. `Point`
    is also similar to these three shapes. It uses the **`points`** property (Line
    36) but in this case to indicate a sequence of points (shape **G**). It also uses
    the **`pointsize`** (Line 37) property to indicate the size of the `Points`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Triangle`**（形状 **D**）、**`Quad`**（形状 **E**）和 **`Line`**（形状 **F**）的工作方式类似。它们的
    **`points`** 属性（第 30、32 和 34 行）分别表示三角形、四边形和线的角。**`points`** 属性是一系列坐标，格式为 `(x1,
    y1, x2, y2)`。`Point` 也与这三个形状类似。它使用 **`points`** 属性（第 36 行），但在这个情况下用来表示一系列点（形状
    **G**）。它还使用 **`pointsize`**（第 37 行）属性来表示 `Points` 的大小。'
- en: 'Let''s proceed with the shape **H**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨形状 **H**：
- en: '![Drawing basic shapes](img/B04244_02_01e.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01e.jpg)'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**`Bezier`** is a curved line that uses the **`points`** property as a set
    of ''attractors'' of the curve line (there is a math formalism behind Bézier curves
    that we are not going to cover in this book because it is out of its scope, but
    you can find enough information in Wikipedia [http://en.wikipedia.org/wiki/Bézier_curve](http://en.wikipedia.org/wiki/B%C3%A9zier_curve)).
    The points are attractors because the line does not touch all of them (just the
    first and the last of them). The points of `Bezier` (Line 39) are at the same
    distance from each other as the points of the `Line` (Line 34), or the `Point`
    (Line 36); they were just translated 100 pixels to the right. You can visually
    compare the result of the Bezier curve (shape **H**), with the results of the
    `Line` (shape **G**) or the `Point` (shape **H**). We included two other properties
    **`dash_length`** (Line 41), for the length of the dashes of the discontinuous
    line, and **`dash_offset`** (Line 42) for the distance between the dashes.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**`贝塞尔`** 是一条曲线，它使用 **`points`** 属性作为曲线线的“吸引点”（贝塞尔曲线背后有一个数学形式，我们在这本书中不会涉及，因为它超出了范围，但您可以在维基百科中找到足够的信息
    [http://en.wikipedia.org/wiki/Bézier_curve](http://en.wikipedia.org/wiki/B%C3%A9zier_curve)）。这些点是吸引点，因为线并不触及所有点（只是它们中的第一个和最后一个）。`Bezier`
    的点（第 39 行）彼此之间的距离与 `Line` 的点（第 34 行）或 `Point` 的点（第 36 行）之间的距离相同；它们只是向右平移了 100
    像素。您可以直观地比较贝塞尔曲线（形状 **H**）的结果与 `Line`（形状 **G**）或 `Point`（形状 **H**）的结果。我们还包含了两个其他属性
    **`dash_length`**（第 41 行），用于表示断续线的长度，以及 **`dash_offset`**（第 42 行），用于表示划痕之间的距离。'
- en: 'Let''s cover the last shapes **I** and **J**:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨最后两个形状 **I** 和 **J**：
- en: '![Drawing basic shapes](img/B04244_02_01f.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_01f.jpg)'
- en: '[PRE6]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We added two **`Mesh`** instructions (Lines 43 and 47). A **`Mesh`** instruction
    is a compound of triangles and has many applications in computer graphics and
    games. There is not enough space in this book to cover the advanced techniques
    to use this instruction, but at the very least we will understand its basics and
    be able to draw flat polygons. The **`mode`** property is set to `triangle_fan`
    (Line 44), which means that the triangles of the mesh are filled with color, instead
    of, for example, just drawing the border.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个**`Mesh`**指令（第43行和第47行）。一个**`Mesh`**指令是由三角形组成的复合体，在计算机图形和游戏中有许多应用。本书中没有足够的空间来介绍使用此指令的高级技术，但至少我们将了解其基础知识，并能够绘制平面多边形。**`mode`**属性设置为`triangle_fan`（第44行），这意味着网格的三角形被填充了颜色，而不是例如只绘制边界。
- en: 'The **`vertices`** property is a tuple of coordinates. For the purpose of this
    example, we will just ignore all the 0s. This will leave us with four coordinates
    (or vertices) in line 45\. These points are relatively the same as shapes **F**,
    **G**, and **H**. Let''s imagine for the shape I how the triangles are created
    as we traverse them, left to right on the vertex list using three vertex points
    each time. The shape **I** is composed of two triangles. The first triangle uses
    the first, second, and third vertices; and the second triangle uses the first,
    third, and fourth vertices. In general, if we are in the i^(th) vertex of the
    list, a triangle is drawn using the first vertex, the (i-1)^(th) vertex, and the
    i^(th) vertex. The final mesh (shape **J**) presents another example. It contains
    three triangles that are surrounded by a blue line in the following screenshot:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**`vertices`**属性是一个坐标元组。为了本例的目的，我们将忽略所有的0。这将使我们剩下45行中的四个坐标（或顶点）。这些点与形状**F**、**G**和**H**相对相同。让我们想象一下，当我们从左到右遍历顶点列表时，形状**I**中的三角形是如何创建的，每次使用三个顶点。形状**I**由两个三角形组成。第一个三角形使用第一个、第二个和第三个顶点；第二个三角形使用第一个、第三个和第四个顶点。一般来说，如果我们位于列表的第i个顶点，则使用第一个顶点、第(i-1)个顶点和第i个顶点来绘制一个三角形。最终的网格（形状**J**）展示了另一个示例。它包含三个被以下截图中的蓝色线条包围的三角形：'
- en: '![Drawing basic shapes](img/B04244_02_02.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_02.jpg)'
- en: The **`indexes`** property contains a list with the same number of vertices
    (not counting the 0s) and instructs the order in which the vertices list is traversed,
    altering the triangles that compose the mesh.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**`indexes`**属性包含一个与顶点数量相同的列表（不计0），并指示顶点列表遍历的顺序，从而改变组成网格的三角形。'
- en: So far, all the polygons that we studied have been colored in. If we need to
    draw the border of the polygon, we should use **`Line`** instead. In principle,
    this seems easy for a basic shape such as a triangle, but how do we draw a circle
    with just points? Fortunately, `Line` has the appropriate properties to make things
    easier.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们研究过的所有多边形都已经着色完毕。如果我们需要绘制多边形的边界，我们应该使用**`Line`**。从原则上讲，对于像三角形这样的基本形状来说这似乎很简单，但如何只用点来画一个圆呢？幸运的是，`Line`具有使事情变得更容易的适当属性。
- en: 'The next example will show how you can build the figures in the following screenshot:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例将展示您如何构建以下截图中的图形：
- en: '![Drawing basic shapes](img/B04244_02_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![绘制基本形状](img/B04244_02_03.jpg)'
- en: Line examples
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 线条示例
- en: 'We have kept the gray coordinates and the letter to identify each cell in the
    screenshot. The Python code should be run in a screen size of 400 x 100: `python
    drawing.py --size=400x100`. The following is the `drawing.kv` code for the previous
    screenshot:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了灰色坐标和字母来识别截图中的每个单元格。Python代码应在400 x 100的屏幕尺寸下运行：`python drawing.py --size=400x100`。以下是为前一个截图的`drawing.kv`代码：
- en: '[PRE7]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the previous code, we added four **`Line`** instructions using specific properties.
    The first `Line` instruction (in line 54, shape **A**) is similar to our Pac-Man
    (line 20). The **`ellipse`** property (line 55) specifies `x`, `y`, `width`, `height`,
    `angle_start`, `angle_end`, and `segments`, respectively. The order of the parameters
    is difficult to remember so we should always keep the Kivy API next to us ([http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html](http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html)).
    We also set **`width`** of `Line` to make it thicker (line 56).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们使用特定的属性添加了四个**`Line`**指令。第一个`Line`指令（第54行，形状**A**）与我们的Pac-Man（第20行）相似。**`ellipse`**属性（第55行）分别指定了`x`、`y`、`width`、`height`、`angle_start`、`angle_end`和`segments`。参数的顺序难以记忆，因此我们应该始终将Kivy
    API放在我们身边（[http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html](http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html)）。我们还设置了`Line`的**`width`**使其更粗（第56行）。
- en: 'The second `Line` instruction (line 57, shape **B**) introduces a property
    that has no counterpart in the vertex instructions: **`circle`**. The difference
    with the `ellipse` property is that the first three parameters (line 58) define
    the center (150, 50) and radius (40) of `Circle`. The rest remains the same. The
    third `Line` (line 59, shape **C**) is defined by **`rectangle`** (line 60) and
    the parameters are simply `x`, `y`, `width`, and `height`. The last `Line` (line
    61, shape **D**) is the most flexible way to define polygons. We specified the
    points (line 62), as many as we want. The **`close`** property (line 63) connects
    the first and last points.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`Line`指令（第57行，形状**B**）引入了一个在顶点指令中没有对应属性的特性：**`circle`**。与`ellipse`属性的区别在于，前三个参数（第58行）定义了`Circle`的中心（150,
    50）和半径（40）。其余的保持不变。第三个`Line`（第59行，形状**C**）由**`rectangle`**（第60行）定义，参数简单为`x`、`y`、`width`和`height`。最后一个`Line`（第61行，形状**D**）是定义多边形最灵活的方式。我们指定了点（第62行），数量不限。**`close`**属性（第63行）连接了第一个和最后一个点。
- en: We covered most of the instructions and properties related to vertex instructions.
    We should be able to draw any geometrical shape in two dimensions with Kivy. If
    you want more details about each of the instructions, you should visit the Kivy
    API ([http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html](http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html)).
    Now, it is the turn of context instructions to decorate these boring black and
    white polygons.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们涵盖了与顶点指令相关的多数指令和属性。我们应该能够使用Kivy在二维空间中绘制任何几何形状。如果您想了解更多关于每个指令的详细信息，应该访问Kivy
    API（[http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html](http://kivy.org/docs/api-kivy.graphics.vertex_instructions.html)）。现在，轮到上下文指令来装饰这些单调的黑白多边形了。
- en: Adding images, colors, and backgrounds
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加图像、颜色和背景
- en: 'In this section, we will discuss how to add images and colors to our graphics
    and how to control which graphic comes on top of which one. We continue using
    the same Python code of the first section. This time, we run it with a 400 x 100
    screen size: `python drawing.py --size=400x100`. The following screenshot shows
    the final result of this section:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何将图像和颜色添加到我们的图形中，以及如何控制哪个图形位于哪个图形之上。我们继续使用第一节的相同Python代码。这次，我们以400
    x 100的屏幕尺寸运行它：`python drawing.py --size=400x100`。以下截图显示了本节的最终结果：
- en: '![Adding images, colors, and backgrounds](img/B04244_02_04.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![添加图像、颜色和背景](img/B04244_02_04.jpg)'
- en: Images and Colors
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图像和颜色
- en: 'The following is the corresponding `drawing.kv` code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`drawing.kv`代码：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code starts with `Ellipse` (line 67) and `Rectangle` (line 71). We used
    the **`source`** property, which inserts an image to decorate each polygon. The
    `kivy.png` image is 80 x 80 pixels with a white background (without any alpha/transparency
    channel). The result is shown in the first two columns of the "Images and Colors"
    screenshot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码从`Ellipse`（第67行）和`Rectangle`（第71行）开始。我们使用了**`source`**属性，它将图像插入到每个多边形中装饰。`kivy.png`图像是80
    x 80像素，背景为白色（没有任何alpha/透明度通道）。结果显示在“图像和颜色”截图的前两列中。
- en: 'In line 75, we used the context instruction **`Color`** to change the color
    (with the **`rgba`** property: red, green, blue, and alpha) of the coordinate
    space context. This means that the next vertex instruction will be drawn with
    the color changed by `rgba`. A context instruction basically changes the current
    coordinate space context. In the screenshot, you can see the thin blue bar (or
    very dark gray bar in the printed version of this book) at the bottom (line 77)
    that appears as transparent blue (line 76) instead of the default white (`1,1,1,1`)
    of the previous examples. We set the ends shape of the line, to a square with
    the **`cap`** property (line 80).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在第75行，我们使用了上下文指令**`Color`**来改变坐标空间上下文的颜色（使用**`rgba`**属性：红色、绿色、蓝色和透明度）。这意味着下一个顶点指令将以`rgba`改变的颜色绘制。上下文指令基本上是改变当前的坐标空间上下文。在截图（第77行）中，你可以看到底部（第77行）的细蓝色条（或本书打印版本的非常深灰色条）呈现为透明蓝色（第76行），而不是之前示例中的默认白色（`1,1,1,1`）。我们使用**`cap`**属性（第80行）设置了线的端点形状为方形。
- en: We changed the color again in line 81\. After this, we drew two more rectangles,
    one with the `kivy.png` image and another without it. In the preceding screenshot,
    you can see that the white part of the image has become as green, or light gray
    in the printed version of this book, as the basic `Rectangle` on the right.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第81行再次改变了颜色。之后，我们绘制了两个更多的矩形，一个带有`kivy.png`图像，另一个没有。在前面的截图（执行命令：`python drawing.py
    --size=300x100`）中，你可以看到图像的白色部分已经变成了绿色，或在本书的打印版本中为浅灰色，就像右侧的基本`Rectangle`一样。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The `Color` instruction acts as a light that illuminates the `kivy.png` image,
    it doesn't simply paint over it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Color`**指令就像一盏照亮`kivy.png`图像的光，它不仅仅是在其上绘画。'
- en: There is another important detail to notice in the screenshot. The blue (dark
    gray in the printed version) line at the bottom goes over the first two polygons
    and goes under the last two. The instructions are executed in order and this might
    bring some unwanted results. Kivy provides a solution to make this execution more
    flexible, and structured, which we will introduce in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在截图中有另一个重要的细节需要注意。底部蓝色的线（在打印版本中为深灰色）覆盖了前两个多边形，并在最后两个多边形下方。指令是按顺序执行的，这可能会带来一些不期望的结果。Kivy提供了一个解决方案，使这种执行更加灵活和结构化，我们将在下一节中介绍。
- en: Structuring graphic instructions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化图形指令
- en: 'Apart from the `canvas` instance, a Widget includes two other canvas instances:
    **`canvas.before`** and **`canvas.after`**.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`canvas`实例外，一个Widget还包括两个其他画布实例：**`canvas.before`**和**`canvas.after`**。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Widget` class has three sets of instructions (**`canvas.before`**, **`canvas`**,
    and **`canvas.after`**) to organize the order of execution. With them, we can
    control which elements will go to the background or stay on the foreground.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Widget`类有三个集合的指令（**`canvas.before`**、**`canvas`**和**`canvas.after`**）来组织执行顺序。通过它们，我们可以控制哪些元素将进入背景或保持在前景。'
- en: 'The following `drawing.kv` file shows an example of these three sets (lines
    92, 98, and 104) of instructions:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`drawing.kv`文件显示了这三个集合（第92、98和104行）的指令示例：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In each set, a rectangle of different color is drawn (lines 95, 101, and 107).
    Here is a diagram that illustrates the execution order of the canvases. The numbers
    on the top-left margin of each code block indicates the order of execution:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个集合中，都绘制了一个不同颜色的矩形（第95、101和107行）。以下是说明画布执行顺序的图解。每个代码块左上角的数字表示执行顺序：
- en: '![Structuring graphic instructions](img/B04244_02_05.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![结构化图形指令](img/B04244_02_05.jpg)'
- en: Execution order of the canvas
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 画布执行顺序
- en: 'Notice that we didn''t define any `canvas`, `canvas.before`, or `canvas.after`
    for `Button` but Kivy does internally. Since `Button` displays graphics on the
    screen (for example, it contains `Rectangle` associated with the **`background_color`**
    property), then it has instructions in its canvas sets. The final result is shown
    in the following screenshot (executed with: `python drawing.py --size=300x100`):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们没有为`Button`定义任何`canvas`、`canvas.before`或`canvas.after`，但Kivy内部确实有。由于`Button`在屏幕上显示图形（例如，它包含与**`background_color`**属性关联的`Rectangle`），因此它在其画布集合中有指令。最终结果如下截图所示（执行命令：`python
    drawing.py --size=300x100`）：
- en: '![Structuring graphic instructions](img/B04244_02_06.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![结构化图形指令](img/B04244_02_06.jpg)'
- en: Before and after canvas
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 画布前后
- en: The graphics of `Button` (the child) are covered up by the set of instructions
    in `canvas.after`. It is clear that the instructions of `canvas.before` and `canvas`
    are executed before the displaying `Button`, but what is executed between them?
    It is necessary when we work with inheritance, and we want to add instructions
    in the subclass that should be executed before the `canvas` set of instructions
    of the base class. Also, it is a convenience when we mix Python code and Kivy
    language rules. We will study some practical examples in the last section of this
    chapter related to the *Comic Creator*, and review the topic in [Chapter 4](ch04.html
    "Chapter 4. Improving the User Experience"), *Improving the User Experience*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`（子元素）的图形被`canvas.after`中的指令覆盖。很明显，`canvas.before`和`canvas`的指令在显示`Button`之前执行，但它们之间执行了什么？当我们在继承中工作时，我们想在子类中添加应该在基类的`canvas`指令集之前执行的指令，这是必要的。同时，当我们将Python代码和Kivy语言规则混合时，这也是一种便利。我们将在本章的最后部分研究一些与*漫画创作者*相关的实际例子，并在[第4章](ch04.html
    "第4章。改进用户体验")中回顾这个主题，*改进用户体验*。'
- en: For now, it is good enough to understand that we have three sets of instructions
    (`Canvas`) that provide some flexibility when we display graphics on the screen.
    Let's now explore some more context instructions related to transformations of
    the vertex instruction.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，理解我们有三组指令（`Canvas`）提供了一些在屏幕上显示图形时的灵活性就足够了。现在让我们探索一些与顶点指令变换相关的更多上下文指令。
- en: Rotating, translating, and scaling the coordinate space
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 旋转、平移和缩放坐标空间
- en: '**`Rotate`**, **`Translate`**, and **`Scale`** are context instructions that
    are applied to the vertex instructions, which are displayed in the coordinate
    space. They could bring unexpected results if we forget that the coordinate space
    is shared among all widgets, and it occupies the size of the window (actually
    bigger than that because there is no restriction on the coordinates and we can
    draw outside the window). First, we are going to understand the behavior of this
    instruction in this section and, in the next section, we can analyze the problems
    they bring in a deeper way, and learn techniques to make things easier.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Rotate`**、**`Translate`**和**`Scale`**是应用于顶点指令的上下文指令，这些指令在坐标空间中显示。如果我们忘记坐标空间是所有小部件共享的，并且它占据了窗口的大小（实际上比这还要大，因为坐标没有限制，我们可以在窗口外绘制），它们可能会带来意外的结果。首先，我们将在本节中了解这条指令的行为，在下一节中，我们可以更深入地分析它们带来的问题，并学习使事情变得更容易的技术。'
- en: 'Let''s start with the new `drawing.kv` code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从新的`drawing.kv`代码开始：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this code, the first thing we did is position the coordinates (0, 0) of `DrawingSpace`
    (`RelativeLayout`) in the center of the screen (line 116). We created `Rectangle`
    with the `kivi.png` figure, which we had previously modified to indicate the original
    **x** axis and **y** axis.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先做的事情是将`DrawingSpace`（`RelativeLayout`）的坐标（0, 0）定位在屏幕中心（第116行）。我们创建了一个带有`kivi.png`图形的`Rectangle`，我们之前已经修改过它来指示原始**x**轴和**y**轴。
- en: 'The result is presented in the top-right of the following screenshot (executed
    with `python drawing.py --size=200x200`):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 结果展示在以下截图的右上角（使用`python drawing.py --size=200x200`执行）：
- en: '![Rotating, translating, and scaling the coordinate space](img/B04244_02_07.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![旋转、平移和缩放坐标空间](img/B04244_02_07.jpg)'
- en: Rotate, Translate and Scale
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转、平移和缩放
- en: In the line 120, we applied the **`Rotate`** instruction by 90° on the z axis
    (line 122). The value is (x, y, z), which means we can use any vector in the 3D
    space. Think of this as nailing a pin to the bottom-left corner of `DrawingSpace`,
    which we then rotate in the counter clockwise direction.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在第120行，我们在z轴上（第122行）应用了90°的**`Rotate`**指令。值是（x, y, z），这意味着我们可以使用3D空间中的任何向量。想象一下，这是在`DrawingSpace`的左下角钉上一个钉子，然后我们逆时针旋转它。
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: By default, the pin nail of the rotation is always the coordinates (0, 0) but
    we can alter this behavior with the **`origin`** property.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，旋转的钉子总是坐标（0, 0），但我们可以通过**`origin`**属性改变这种行为。
- en: The top-left section of the screenshot ("Rotate, Translate, and Scale") shows
    the result after the rotation. We drew the same rectangle with red color (using
    the **`rgb`** property instead of the `rgba` property) to highlight it. After
    adding a rotation to the coordinate space context, we also modified the relative
    X-axis and Y-axis. Line 128 considers that the axes are rotated, and in order
    to translate the coordinate space down (usually Y-axis), it sets -100px to the
    X-axis. We drew the same `Rectangle` with green `Color` in the bottom left corner.
    Notice that the image still rotates and it will rotate as long as we don't bring
    the coordinate space context to its original angle.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 截图的左上部分（“旋转、平移和缩放”）显示了旋转后的结果。我们用红色（使用**`rgb`**属性而不是`rgba`属性）绘制了相同的矩形以突出显示。在向坐标空间上下文添加旋转之后，我们也修改了相对的X轴和Y轴。第128行考虑到轴是旋转的，为了将坐标空间向下平移（通常是Y轴），它将-100px设置到X轴上。我们在左下角用绿色`Color`绘制了相同的`Rectangle`。请注意，图像仍然在旋转，并且只要我们不将坐标空间上下文恢复到原始角度，它就会继续旋转。
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Context instructions are persistent until we change them back again. Another
    way to avoid this is working inside `RelativeLayout`. If you remember from the
    previous chapter, it allows us to work with coordinates relative to the widget.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文指令持续有效，直到我们再次更改它们。另一种避免这种情况的方法是在`RelativeLayout`内部工作。如果你还记得上一章，它允许我们使用相对于小部件的坐标进行操作。
- en: To scale or zoom out the image, we translated the coordinate space context (line
    133) to use the bottom-right section of the screenshot. Notice that we use the
    Y-axis instead of the X-axis, since the context is still rotated. The scaling
    is done in line 135, where the image will be reduced to half the width and half
    the height. The `Scale` instruction reduces towards the (0, 0) coordinate, which
    initially is at the bottom-left corner. However, after all these modifications
    of the context, we need to think where this coordinate is. First, we rotated the
    axis (line 120) so the X-axis is vertical and the Y-axis is horizontal. After
    translating the coordinate space down (line 127) and then right (line 133), the
    (0, 0) coordinate is in the bottom-right corner with the X-axis being the vertical
    one and the Y-axis being the horizontal one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要缩放或放大图像，我们将坐标空间上下文（第133行）平移到截图的右下角。请注意，我们使用Y轴而不是X轴，因为上下文仍然是旋转的。缩放操作在第135行进行，此时图像的宽度和高度将减半。`Scale`指令朝向（0,
    0）坐标缩放，最初位于左下角。然而，在所有这些上下文修改之后，我们需要考虑这个坐标在哪里。首先，我们旋转了轴（第120行），使X轴垂直，Y轴水平。然后，将坐标空间向下平移（第127行）和向右平移（第133行），（0,
    0）坐标位于右下角，X轴是垂直的，Y轴是水平的。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**`Scale`** uses proportions to the current size of the coordinate space context
    and not the original size. For example, to recover the original size, we should
    use `xyz: (2,2,0)` and not just `xyz: (1,1,0)`.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**`Scale`**使用当前坐标空间上下文的尺寸比例，而不是原始尺寸。例如，要恢复原始尺寸，我们应该使用`xyz: (2,2,0)`而不是仅仅使用`xyz:
    (1,1,0)`。'
- en: So far, in this chapter, we have discussed that a `Canvas` instance is a set
    of instructions that contains context instructions and vertex instructions. The
    context instructions apply changes (colors or transformation) to the coordinate
    space context that affects the conditions in which the vertex instructions are
    displayed in the coordinate space.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经讨论了`Canvas`实例是一组包含上下文指令和顶点指令的指令集。上下文指令应用于影响顶点指令在坐标空间中显示条件的坐标空间上下文。
- en: 'We will use some of the knowledge to add *Stickman* to our project in the next
    and final section of this chapter. We will introduce two important context instructions
    to deal with the issues of sharing the same coordinate space between widgets:
    `PushMatrix` and `PopMatrix`.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的下一部分和最后一部分中，将一些知识应用到我们的项目中，添加* Stickman*。我们将介绍两个重要的上下文指令来处理小部件之间共享相同坐标空间的问题：`PushMatrix`和`PopMatrix`。
- en: 'Comic Creator: PushMatrix and PopMatrix'
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 漫画创作者：PushMatrix和PopMatrix
- en: 'Let''s insert some graphics to the project we started in [Chapter 1](ch01.html
    "Chapter 1. GUI Basics – Building an Interface"), *GUI Basics – Building an Interface*.
    Before this, we need to recapitulate two important lessons of this chapter related
    to the coordinate space:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一些图形插入到我们在[第1章](ch01.html "第1章。GUI基础 - 构建界面")开始的项目中，*GUI基础 - 构建界面*。在此之前，我们需要回顾本章与坐标空间相关的两个重要课程：
- en: The coordinate space is not restricted to any position or size. It normally
    has its origin in the bottom-left corner of the screen. To avoid this, we use
    `RelativeLayout`, which internally performs a translation to the position of the
    `Widget`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 坐标空间不受任何位置或大小的限制。它通常以屏幕左下角为原点。为了避免这种情况，我们使用 `RelativeLayout`，它内部执行了一个平移到 `Widget`
    位置的变换。
- en: 'Once the coordinate space context is transformed by any instruction, it stays
    like that until we specify something different. `RelativeLayout` also addresses
    this problem with two contextual instructions, which we will study in this section:
    **`PushMatrix`** and **`PopMatrix`**.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦坐标空间上下文被任何指令变换，它就会保持这种状态，直到我们指定不同的内容。`RelativeLayout` 也通过两个上下文指令解决了这个问题，我们将在本节中研究这些指令：**`PushMatrix`**
    和 **`PopMatrix`**。
- en: 'We use `RelativeLayout` in this section to avoid the problems of the shared
    coordinate space, but we will also explain the alternatives to it when we are
    inside any other type of `Widget`. We will add a new file (`comicwidgets.kv`)
    to our project. In `comicreator.py`, we need to add our new file to `Builder`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用 `RelativeLayout` 来避免共享坐标空间的问题，但当我们处于任何其他类型的 `Widget` 内部时，我们也会解释它的替代方案。我们将向我们的项目中添加一个新文件（`comicwidgets.kv`）。在
    `comicreator.py` 中，我们需要将我们的新文件添加到 `Builder`：
- en: '[PRE11]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The file `comicwidgets.kv` will contain special widgets, which we will create
    for the project. In this chapter, we will add the `StickMan` class:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `comicwidgets.kv` 将包含特殊的小部件，我们将为项目创建这些小部件。在本章中，我们将添加 `StickMan` 类：
- en: '[PRE12]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On line 142, the `StickMan` subclass inherits from `RelativeLayout` to facilitate
    the positioning and use of context instructions. We defined `StickMan` of size
    48 x 48\. `StickMan` is composed of six lines that define the head, body, left
    leg, right leg, left arm, and right arm (line 147 to 163). You can see the result
    of `StickMan` three times in the following screenshot:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 142 行，`StickMan` 子类从 `RelativeLayout` 继承，以方便定位和使用上下文指令。我们定义了大小为 48 x 48 的
    `StickMan`。`StickMan` 由定义头部、身体、左腿、右腿、左臂和右臂的六条线组成（第 147 到 163 行）。您可以在以下屏幕截图中的三个地方看到
    `StickMan` 的结果：
- en: '![Comic Creator: PushMatrix and PopMatrix](img/B04244_02_08.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![漫画创作者：PushMatrix 和 PopMatrix](img/B04244_02_08.jpg)'
- en: Comic Creator
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 漫画创作者
- en: The first `StickMan` is part of the design of the last `ToolButton` and the
    other two appear in the *drawing space*; one of them is scaled. Notice that the
    code of the legs (lines 151 to 154) is exactly the same as the arms (lines 160
    to 163); the difference is that we translated the coordinate space upwards (lines
    155 and 156) and rotated it 180° in the x-axis (lines 157 to 159). With this,
    we saved ourselves some math to draw the *stickman*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个 `StickMan` 是最后一个 `ToolButton` 设计的一部分，而其他两个出现在 *绘图空间* 中；其中一个是缩放的。请注意，腿部的代码（第
    151 到 154 行）与手臂的代码（第 160 到 163 行）完全相同；区别在于我们将坐标空间向上平移（第 155 和 156 行）并在 x 轴上旋转
    180°（第 157 到 159 行）。这样，我们就节省了一些绘制 *stickman* 的数学计算。
- en: 'We translated and rotated the coordinate space context; therefore, we should
    undo these context changes so everything will remain as it was at the beginning.
    Instead of adding more instructions to `Translate` and `Rotate` back to the coordinate
    space context, we used two convenient Kivy instructions: **`PushMatrix`** and
    **`PopMatrix`**. At the beginning, we used a `PushMatrix` (line 146), which will
    save the current coordinate space context and, at the end, we used a `PopMatrix`
    (line 164) to return the context to its original state.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经转换并旋转了坐标空间上下文；因此，我们应该撤销这些上下文更改，以便一切都能保持最初的状态。我们不是向 `Translate` 和 `Rotate`
    指令添加更多指令以返回坐标空间上下文，而是使用了两个方便的 Kivy 指令：**`PushMatrix`** 和 **`PopMatrix`**。一开始，我们使用了
    `PushMatrix`（第 146 行），这将保存当前的坐标空间上下文，而在最后，我们使用了 `PopMatrix`（第 164 行）以将上下文恢复到原始状态。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**`PushMatrix`** saves the current coordinate space context and **`PopMatrix`**
    retrieves the last saved coordinate space context. Therefore, the transformation
    instructions (`Scale`, `Rotate`, and `Translate`) surrounded by **`PushMatrix`**
    and **`PopMatrix`** won''t affect the rest of the interface.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**`PushMatrix`** 保存当前的坐标空间上下文，而 **`PopMatrix`** 恢复最后保存的坐标空间上下文。因此，被 **`PushMatrix`**
    和 **`PopMatrix`** 包围的变换指令（`Scale`、`Rotate` 和 `Translate`）不会影响界面的其余部分。'
- en: 'We will extend this approach to add shapes to the other two instances of `ToolButton`
    (circle and line) in the top-left corner of `ToolBox`. We add this code in `toolbox.kv`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展这种方法，向 `ToolBox` 左上角的其他两个 `ToolButton` 实例（圆形和线条）添加形状。我们在 `toolbox.kv` 中添加此代码：
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `ToolButton` class (line 166), we used a `PushMatrix` (line 171) in the
    `canvas` set of instructions to save the current state of the coordinate space.
    Then, `Translate` (line 172) moves the graphic instructions to the position of
    `ToolButton` so we can use relative coordinates on each `ToolButton` (line 180
    to 190). Finally, `PopMatrix` (line 175) was added to `canvas.after` to restore
    the coordinate space.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ToolButton`类（第166行）中，我们在指令集的`canvas`中使用了`PushMatrix`（第171行）来保存坐标空间当前状态。然后，`Translate`（第172行）将图形指令移动到`ToolButton`的位置，这样我们就可以在每个`ToolButton`上使用相对坐标（第180行到第190行）。最后，在`canvas.after`中添加了`PopMatrix`（第175行）以恢复坐标空间。
- en: 'It is important to follow the execution order of the different canvases (instruction
    sets). For example, let''s slowly follow the execution order of the canvases of
    `ToolButton` that contains the circle (line 180): first, `canvas` of the `ToolButton`
    class that has `PushMatrix` and `Translate` (line 170); second, `canvas` of the
    `ToolButton` instance, which has the circle (line 181), and third, `canvas.after`
    of the base class, which has `PopMatrix` (line 174). We just implemented the same
    technique used for `RelativeLayout`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循不同画布（指令集）的执行顺序非常重要。例如，让我们逐步跟随包含圆圈（第180行）的`ToolButton`画布的执行顺序：首先，`ToolButton`类的`canvas`具有`PushMatrix`和`Translate`（第170行）；其次，`ToolButton`实例的`canvas`包含圆圈（第181行），最后，基类的`canvas.after`具有`PopMatrix`（第174行）。我们只是实现了与`RelativeLayout`相同的技巧。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**`RelativeLayout`** internally contains `PushMatrix` and `PopMatrix`. Therefore,
    we can add instructions safely inside it, which won''t affect the rest of the
    interface.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**`RelativeLayout`**内部包含`PushMatrix`和`PopMatrix`。因此，我们可以在其中安全地添加指令，而不会影响界面的其余部分。'
- en: 'Let''s conclude this chapter by scaling our *stickman* in the *drawing space*
    and illustrate one more particularity of the execution order of the canvases.
    The following is the code of `drawingspace.kv`:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在*绘图空间*中缩放我们的*stickman*来结束这一章，并说明画布执行顺序的另一个特性。以下是`drawingspace.kv`的代码：
- en: '[PRE14]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first `StickMan` was translated and rotated (lines 193 to 199), but not
    the second one (line 200). We discussed that the context instructions affect the
    coordinate space globally, but when we see the result in the screenshot ("Comic
    Creator"), we realize that the second instance was neither scaled nor translated
    by the lines 196 and 198\. What happened? The answer is not obvious. Is the answer
    related to `PushMatrix` and `PopMatrix` inside the canvas of the `StickMan` class
    (lines 146 and 164)? No, it isn't, because both of them are inside the same set
    of instructions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个`StickMan`被平移和旋转了（第193行到第199行），但第二个没有（第200行）。我们讨论了上下文指令会影响全局坐标空间，但当我们看到截图（“漫画创作者”）的结果时，我们意识到第二个实例没有被第196行和第198行的线条进行缩放或平移。发生了什么？答案并不明显。答案与`StickMan`类画布内的`PushMatrix`和`PopMatrix`有关吗？不是的，因为它们都在同一组指令中。
- en: The way we implemented `ToolButton` follows the way the `RelativeLayout` class
    is implemented. `StickMan` inherits from `RelativeLayout`, so there is actually
    another `PushMatrix` in `canvas.before` and its respective `PopMatrix` in `canvas.after`
    of the `StickMan` class (inherited from `RelativeLayout`). The instructions from
    lines 196 to 199 are executed after `PopMatrix` is executed in `canvas.before`
    of `RelativeLayout` and, therefore, the context is restored on the respective
    `PushMatrix` of `RelativeLayout`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现`ToolButton`的方式遵循`RelativeLayout`类的实现方式。`StickMan`继承自`RelativeLayout`，因此在`StickMan`类（从`RelativeLayout`继承）的`canvas.before`中实际上还有一个`PushMatrix`，以及相应的`canvas.after`中的`PopMatrix`。从第196行到第199行的指令是在`RelativeLayout`的`canvas.before`中的`PopMatrix`执行之后执行的，因此上下文在`RelativeLayout`的相应`PushMatrix`上得到恢复。
- en: Finally, notice that the instructions must be in `canvas.before` because they
    are added before the existent instructions, the ones that actually draw the *stickman*.
    In other words, if we simply add them in the canvas, then the *stickman* would
    be drawn before the translation and scaling.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意指令必须在`canvas.before`中，因为它们是在现有指令之前添加的，即那些实际绘制*stickman*的指令。换句话说，如果我们简单地在画布中添加它们，那么*stickman*将会在平移和缩放之前被绘制。
- en: The rest of the files of the *Comic Creator* `comiccreator.kv`, `generaloptions.kv`,
    and `statusbar.kv` were not modified, so we are not presenting them again. The
    context and vertex instructions are easy to understand. However, we must be very
    careful with the order of execution and make sure to leave the coordinate space
    context in its normal state after executing the desired vertex instructions. Finally,
    take into account that everything you see in the screen is displayed by an instruction
    (or instructions) inside the canvas, including, for example, `Label` texts and
    the `Button` backgrounds.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*漫画创作器*（`comiccreator.kv`），`generaloptions.kv`和`statusbar.kv`的其他文件没有修改，因此我们不再展示它们。上下文和顶点指令易于理解。然而，我们必须非常注意执行顺序，并确保在执行所需的顶点指令后，将坐标空间上下文保持在正常状态。最后，请注意，屏幕上显示的所有内容都是由画布内部的指令（或指令集）显示的，包括例如`Label`文本和`Button`背景。'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: 'This chapter explained the necessary concepts to understand the use of the
    canvas. We covered the use of vertex and context instructions, and how to manipulate
    the order of the execution of instructions. We covered how to deal with the transformation
    of `canvas`, either reversing all the transformations or using `RelativeLayout`.
    The following is the whole set of components we learnt to use, in this chapter:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了理解使用画布所必需的概念。我们涵盖了顶点和上下文指令的使用，以及如何操作指令执行的顺序。我们还介绍了如何处理`canvas`的转换，无论是反转所有转换还是使用`RelativeLayout`。以下是本章我们学习使用的全部组件：
- en: 'The vertex instructions (and many of their respective properties): `Rectangle`
    (`pos`, `size`), `Ellipse` (`pos`, `size`, `angle_start`, `angle_end`, `segments`),
    `Triangle` (`points`), `Quad` (`points`), `Point` (`points`, `pointsize`), `Line`
    (`points`, `ellipse`, `circle`, `rectangle`, `width`, `close`, `dash_lenght`,
    `dash_offset`, and `cap`), `Bezier` (`points`, `segments`, `dash_lenght`, and
    `dash_offset`,), and `Mesh` (`mode`, `vertices`, `indices`)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点指令（及其许多相关属性）：`Rectangle`（`pos`，`size`），`Ellipse`（`pos`，`size`，`angle_start`，`angle_end`，`segments`），`Triangle`（`points`），`Quad`（`points`），`Point`（`points`，`pointsize`），`Line`（`points`，`ellipse`，`circle`，`rectangle`，`width`，`close`，`dash_lenght`，`dash_offset`，和`cap`），`Bezier`（`points`，`segments`，`dash_lenght`和`dash_offset`），以及`Mesh`（`mode`，`vertices`，`indices`）
- en: The `source` property that applies to all the vertex instructions
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于所有顶点指令的`source`属性
- en: 'The three set of canvas instructions: `canvas.before`, `canvas`, and `canvas.after`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 三组画布指令：`canvas.before`，`canvas`和`canvas.after`
- en: 'The context instructions (and some of their properties): `Color` (`rgba`, `rgb`),
    `Rotate` (`angle`, `axis`,`origin`), `Translate` (`x`, `y`, `xy`), `Scale` (`xyz`),
    `PushMatrix`, and `PopMatrix`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文指令（及其一些属性）：`Color`（`rgba`，`rgb`），`Rotate`（`angle`，`axis`，`origin`），`Translate`（`x`，`y`，`xy`），`Scale`（`xyz`），`PushMatrix`和`PopMatrix`
- en: The list is quite comprehensive, but of course there are some remaining components
    that we can find in the Kivy API. The important part is that we discussed the
    concepts behind the use of the canvas. Feel free to play with the provided examples
    to reinforce the important concepts of this chapter. You should feel comfortable
    to put things together and enliven your interface, so you can actually draw with
    it. The next chapter will focus on event handling and manipulating Kivy objects
    directly from Python.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表相当全面，但当然还有一些剩余的组件可以在Kivy API中找到。重要的是我们讨论了使用画布背后的概念。请随意使用提供的示例来加强本章重要概念的理解。你应该感到舒适地将事物组合起来，使你的界面生动起来，这样你实际上可以用它来绘图。下一章将专注于事件处理和直接从Python操作Kivy对象。
