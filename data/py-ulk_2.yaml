- en: Chapter 2. Namespaces and Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 命名空间和类
- en: 'In the previous chapter, we covered how objects worked. In this chapter, we
    will explore how objects are made available to code via reference, specifically
    how namespaces work, what modules are, and how they are imported. We will also
    cover topics related to classes, such as language protocols, MRO, and abstract
    classes. We will discuss the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了对象的工作原理。在本章中，我们将探讨对象如何通过引用提供给代码，特别是命名空间的工作原理、模块是什么以及它们是如何导入的。我们还将涵盖与类相关的话题，例如语言协议、MRO和抽象类。我们将讨论以下主题：
- en: Namespaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名空间
- en: Imports and modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入和模块
- en: Class multiple inheritance, MRO, super
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的多重继承，MRO，super
- en: Protocols
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议
- en: Abstract classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类
- en: How referencing objects work – namespaces
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象引用的工作原理 - 命名空间
- en: '**Key 1: Interrelations between objects.**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键1：对象之间的相互关系。**'
- en: The scope is the visibility of a name within a code block. Namespace is mapping
    from names to objects. Namespaces are important in order to maintain localization
    and avoid name collision. Every module has a global namespace. Modules store mapping
    from variable name to objects in their `__dict__` attribute, which is a normal
    Python dictionary along with information to reload it, package information, and
    so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是名称在代码块中的可见性。命名空间是从名称到对象的映射。命名空间对于保持本地化和避免名称冲突非常重要。每个模块都有一个全局命名空间。模块在其`__dict__`属性中存储从变量名到对象的映射，这是一个普通的Python字典，并包含有关重新加载、包信息等信息。
- en: Every module's global namespace has an implicit reference to the built-in module;
    hence, objects that are in the built-in module are always available. We can also
    import other modules in the main script. When we use the syntax import module
    name, a mapping with module name to module object is created in the global namespace
    of the current module. For import statements with syntax such as `import modname
    as modrename`, mapping is created with a new name to module object.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块的全局命名空间都有一个对内置模块的隐式引用；因此，内置模块中的对象总是可用的。我们还可以在主脚本中导入其他模块。当我们使用`import module
    name`语法时，在当前模块的全局命名空间中创建了一个模块名到模块对象的映射。对于像`import modname as modrename`这样的导入语句，创建了一个新名称到模块对象的映射。
- en: We are always in the `__main__` module's global namespace when the program starts,
    as it is the module that imports all others. When we import a variable from another
    module, only an entry is created for that variable in the global namespace pointing
    at the referenced object. Now interestingly, if this variable references a function
    object, and if this function uses a global variable, then this variable will be
    searched in the global namespace of the module that the function was defined in,
    not in the module that we imported this function to. This is possible because
    functions have the `__globals__` attribute that points to its `__dict__` modules,
    or in short, its modules namespace.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序开始时，我们始终处于`__main__`模块的全局命名空间中，因为它是导入所有其他模块的模块。当我们从一个模块导入一个变量时，只在全局命名空间中为该变量创建一个条目，指向引用的对象。现在有趣的是，如果这个变量引用了一个函数对象，并且如果这个函数使用了一个全局变量，那么这个变量将在定义该函数的模块的全局命名空间中搜索，而不是在我们导入该函数的模块中。这是可能的，因为函数有`__globals__`属性，它指向其`__dict__`模块，或者简而言之，其模块命名空间。
- en: 'All modules that are loaded and referenced are cached in `sys.modules`. All
    imported modules are names pointing to objects in `sys.modules`. Let''s define
    a new module like this with the name `new.py`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 所有已加载和引用的模块都缓存在`sys.modules`中。所有导入的模块都是指向`sys.modules`中对象的名称。让我们这样定义一个名为`new.py`的新模块：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By importing this module in the interactive session, we can see how global
    namespaces work. When this module is reloaded, its namespace dictionary is updated,
    not recreated. Hence, if you attach anything new from the outside of the module
    to it, it will survive reload:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在交互会话中导入此模块，我们可以看到全局命名空间是如何工作的。当此模块被重新加载时，其命名空间字典被更新，而不是重新创建。因此，如果你将任何新内容从模块外部附加到它，它将存活下来：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If we use the functions that are defined in different modules to compose a class
    on runtime, such as using metaclasses, or class decorators, this can bring up
    surprises as each function could be using a different global namespace.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行时使用定义在不同模块中的函数来组合一个类，例如使用元类或类装饰器，这可能会带来惊喜，因为每个函数可能使用不同的全局命名空间。
- en: Locals are simple and they work in the way that you expect. Each function call
    gets its own copy of variables. Nonlocal variables make variables that are defined
    in the outer scope (not global namespace) accessible to the current code block.
    In the following code example, we can see how variables can be referenced in enclosed
    functions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量简单且按预期工作。每个函数调用都会获得自己的变量副本。非局部变量使得在当前代码块中可以访问外部作用域（非全局命名空间）中定义的变量。在下面的代码示例中，我们可以看到如何在嵌套函数中引用变量。
- en: 'Code blocks are able to reference variables that are defined in enclosing scopes.
    Hence, if a variable is not defined in a function but in an enclosing function,
    we are able to get its value. If, after referencing a variable in an outer scope,
    we assign a value to this variable in a code block, it will confuse the interpreter
    in finding the right variable, and we will get the value from the current local
    scope. If we assign a value to the variable, it defaults to the local variable.
    We can specify that we want to work with an enclosing variable using a nonlocal
    keyword:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 代码块能够引用在封装作用域中定义的变量。因此，如果一个变量不是在函数中定义的，而是在封装函数中定义的，我们就能获取它的值。如果我们在外部作用域中引用了一个变量，然后在代码块中为这个变量赋值，它将使解释器在寻找正确的变量时感到困惑，并且我们会从当前局部作用域中获取值。如果我们为变量赋值，它默认为局部变量。我们可以使用非局部关键字指定我们想要使用封装变量：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As variables are searched without any dictionary lookup for the local namespace,
    it is faster to look up variables inside a function with a small number of variables
    than to search in a global namespace. On similar lines, we will get a little speed
    boost if we pull objects that are referenced in loops in a function''s local namespace
    inside a function block:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在局部命名空间中搜索变量时无需进行字典查找，因此在函数中具有少量变量的函数中查找变量比在全局命名空间中搜索要快。类似地，如果我们将函数局部命名空间中引用的对象拉入函数块中，我们将会得到一点速度提升：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Functions with state – closures
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带状态的函数 – 闭包
- en: '**Key 2: Creating cheap state-remembering functions.**'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键2：创建廉价的记忆状态函数。**'
- en: 'A closure is a function that has access to variables in an enclosing scope,
    which has completed its execution. This means that referenced objects are kept
    alive until the function is in memory. The main utility of such a setup is to
    easily retain some state, or to create specialized functions whose functioning
    depends on the initial setup:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是一个可以访问已执行完毕的封装作用域中变量的函数。这意味着引用的对象会一直保持活跃状态，直到函数在内存中。这种设置的主要用途是轻松保留一些状态，或者创建依赖于初始设置的专用函数：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can do the same by creating a class and using the instance object to save
    state. The benefit with closures is that variables are stored in a `__closure__`
    tuple, and hence, they are fast to access. Less code is required to create a closure
    as compared to classes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过创建一个类并使用实例对象来保存状态来实现同样的功能。闭包的优点在于变量存储在`__closure__`元组中，因此它们可以快速访问。与类相比，创建闭包所需的代码更少：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'One such function is available from the standard library, named partial, that
    makes use of closure to create a new function that is always invoked with some
    predefined arguments:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库中有一个这样的函数可用，名为`partial`，它利用闭包创建一个新函数，该函数始终使用一些预定义的参数调用：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Understanding import and modules
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解导入和模块
- en: '**Key 3: Creating a custom loader for modules.**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键3：为模块创建自定义加载器。**'
- en: Import statements get references of other module objects in the current module's
    namespace. It consists of searching the module, executing code to create a module
    object, updating caches (`sys.modules`), updating modules namespace, and creating
    a reference to new module being imported.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 导入语句获取当前模块命名空间中其他模块对象的引用。它包括搜索模块、执行代码以创建模块对象、更新缓存（`sys.modules`）、更新模块命名空间，以及创建对新导入的模块的引用。
- en: 'The built-in `__import__` function searches and executes the module to create
    a module object. The `importlib` library has the implementation, and it also provides
    a customizable interface to the import mechanism. Various classes interact to
    get the job done. The `__import__` function should return a module object. For
    example, in the following example, we are creating a module finder, which checks
    for modules in any path that is given as an argument during construction. Here,
    an empty file named `names.py` should be present at the given path. We have loaded
    the module, then inserted its module object in `sys.modules` and added a function
    to this module''s global namespace:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`__import__`函数搜索并执行模块以创建模块对象。`importlib`库有其实现，并且它还提供了一个可定制的接口给导入机制。各种类相互作用以完成任务。`__import__`函数应该返回一个模块对象。例如，在以下示例中，我们创建了一个模块查找器，它检查在构造时作为参数给出的任何路径中的模块。在这里，应该在给定路径处有一个名为`names.py`的空文件。我们已经加载了该模块，然后将其模块对象插入到`sys.modules`中，并添加了一个函数到该模块的全局命名空间：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Customizing imports
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义导入
- en: 'If the module has an `__all__` attribute, only the names that are specified
    by the iterable in this attribute will be imported from module import `*`. Let''s
    assume that we created a module named `mymod.py`, as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模块有一个`__all__`属性，那么只有在这个属性中指定的可迭代名称将从模块导入`*`。假设我们创建了一个名为`mymod.py`的模块，如下所示：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will not be able to import `spidey` from `mymod` as it is not included in
    `__all__`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法从`mymod`导入`spidey`，因为它不包括在`__all__`中：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Class inheritance
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类继承
- en: We already discussed how instances and classes are created. We also discussed
    how attributes are accessed in a class. Let's dive deeper into how this works
    for multiple base classes. As type is searched for the presence of an attribute
    for an instance, if the type inherits from a number of classes, they all are searched
    as well. There is a defined pattern to this (**Method Resolution Order** (**MRO**)).
    This order plays an important role in determining the method in cases of multiple
    inheritance and diamond-shaped inheritance.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了实例和类的创建方式。我们也讨论了如何在类中访问属性。让我们深入了解这是如何适用于多个基类的。当类型搜索实例的属性存在时，如果类型从多个类继承，它们都会被搜索。有一个定义好的模式（**方法解析顺序**（**MRO**））。这个顺序在多重继承和菱形继承的情况下确定方法时起着重要作用。
- en: Method resolution order
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法解析顺序
- en: '**Key 4: Understanding MRO.**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 4：理解MRO。**'
- en: 'The methods are searched in the base classes of a class in predefined manner.
    This sequence or order is known as method resolution order. In Python 3, when
    an attribute is not found in a class, it is searched in all the base classes of
    that class. If the attribute is still not found, the base classes of the base
    classes are searched. This process goes on until we exhaust all base classes.
    This is similar to how if we have to ask a question, we will first go to our parents
    and then to uncles, and aunts (the same level base classes). If we still do not
    get an answer, we will approach grandparents. The following code snippet shows
    this sequence:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 方法以预定义的方式搜索类的基类。这个序列或顺序被称为方法解析顺序。在Python 3中，当在类中找不到属性时，它会在该类的所有基类中搜索。如果属性仍然没有找到，就会搜索基类的基类。这个过程会一直进行，直到我们耗尽所有基类。这类似于如果我们必须提问，我们首先会去找我们的父母，然后是叔叔和阿姨（同一级别的基类）。如果我们仍然得不到答案，我们会去找祖父母。以下代码片段显示了这一序列：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Super's superpowers
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 超类的超能力
- en: '**Key 6: Get superclass''s methods without a superclass definition.**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 6：在没有超类定义的情况下获取超类的方法。**'
- en: 'We mostly create subclasses to specialize methods or add a new functionality.
    We may need to add some feature, which is 80% the same as one in the base class.
    Then it will be natural to call base class''s method for that portion of functionality
    and add extra functionality in new method in the subclass. To call a method in
    superclass, we can either use its class name to access the method, or super it
    like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常创建子类来专门化方法或添加新的功能。我们可能需要添加一些功能，这80%与基类中的功能相同。然后，在子类的新方法中添加额外的功能并调用基类的方法将是自然的。要调用超类的方法，我们可以使用其类名来访问该方法，或者像这样使用super：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using language protocols in classes
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在类中使用语言协议
- en: All objects that provide a specific functionality have certain methods that
    facilitate that behavior, for example, you can create an object of type worker
    and expect it to have the `submit_work(function, kwargs)`, and is `_completed()`
    methods. Now, we can expect all objects that have these methods to be usable as
    workers in any application portion. Similarly, the Python language has defined
    some methods that are needed to add a certain functionality to an object. If an
    object possesses these methods, it has that functionality.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 所有提供特定功能的对象都有一些便于该行为的方法，例如，你可以创建一个类型为worker的对象，并期望它具有`submit_work(function,
    kwargs)`和`_completed()`方法。现在，我们可以期望所有具有这些方法的对象都可以在任何应用程序部分用作工作者。同样，Python语言定义了一些方法，这些方法用于向对象添加特定的功能。如果一个对象拥有这些方法，它就具有那种功能。
- en: 'We will discuss two very import protocols: iteration protocol, and context
    protocol.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论两个非常重要的协议：迭代协议和上下文协议。
- en: Iteration protocol
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代协议
- en: 'For iteration protocol, objects must possess the `__iter__` method. If the
    object possesses it, we can use the object anywhere that we use an iterator object.
    When we are using the iterator object in a `for` loop or passing it to the `iter`
    built-in function, we are calling its `__iter__` method. This method returns another
    or the same object that is responsible for maintaining the index during iteration,
    and this object that is returned from `__iter__` must have a `__next__` method
    that provides the next values in sequence and raises `StopIteration` on the finish
    of this sequence. In the following code snippet, the `BooksIterState` objects
    help retain the index that is used for iteration. If the books `__iter__` method
    returned self, then it would be difficult to maintain a state index when the object
    is accessed from two loops:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于迭代协议，对象必须具有`__iter__`方法。如果一个对象具有它，我们就可以在任何使用迭代器对象的地方使用该对象。当我们在一个`for`循环中使用迭代器对象或将它传递给内置的`iter`函数时，我们就是在调用它的`__iter__`方法。此方法返回另一个或相同的对象，该对象负责在迭代过程中维护索引，并且从`__iter__`返回的对象必须有一个`__next__`方法，该方法提供序列中的下一个值，并在序列结束时引发`StopIteration`异常。在以下代码片段中，`BooksIterState`对象帮助保留用于迭代的索引。如果书籍的`__iter__`方法返回自身，那么在从两个循环访问对象时维护状态索引将会很困难：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Context manager protocol
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器协议
- en: 'The objects providing context for execution are like try finally statements.
    If an object has the `__enter__` and `__exit__` methods, then this object can
    be used as a replacement of try finally statements. The most common uses are releasing
    locks and resources, or flushing and closing files. In the following example,
    we are creating a `Ctx` class to serve as context manager:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 提供执行上下文的对象类似于try finally语句。如果一个对象具有`__enter__`和`__exit__`方法，那么这个对象可以用作try finally语句的替代。最常见的用途是释放锁和资源，或者刷新和关闭文件。在以下示例中，我们创建一个`Ctx`类作为上下文管理器：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We can also use the `contextmanager` decorator of `contextlib` to easily create
    context managers like the one shown in the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`contextlib`模块的`contextmanager`装饰器轻松创建类似于以下代码所示的上下文管理器：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There are other methods that one should know, such as `__str__`, `__add__`,
    `__getitem__`, and so on, that define various functionalities of the objects.
    There is a list of them at the language reference''s `datamodel.html`. You should
    at least read it once to get to know what methods are available. Here is the link:
    [https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他一些方法也应该了解，例如`__str__`、`__add__`、`__getitem__`等等，这些方法定义了对象的各种功能。在语言参考的`datamodel.html`中有一个它们的列表。你应该至少阅读一次，以了解可用的方法。以下是链接：[https://docs.python.org/3/reference/datamodel.html#special-method-names](https://docs.python.org/3/reference/datamodel.html#special-method-names)。
- en: Using abstract classes
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象类
- en: '**Key 6: Making interfaces for conformity.**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键6：为一致性创建接口。**'
- en: 'Abstract classes are available via the standard `abc` library package. They
    are useful for the definition of interfaces and common functionality. These abstract
    classes can implement a portion of the interface and make the rest of the API
    mandatory for subclasses by defining their methods as abstract. Also, classes
    can be turned into subclasses of the abstract class by simply registering them.
    These classes are useful to make a set of classes conform to a single interface.
    Here is how to use them. Here, worker class defines an interface with two methods,
    do and `is_busy`, which each type of worker must implement. `ApiWorker` is the
    implementation for this interface:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以通过标准 `abc` 库包获得。它们在定义接口和通用功能方面非常有用。这些抽象类可以部分实现接口，并通过将方法定义为抽象的，使得其余的 API
    对子类来说是强制性的。此外，通过简单地注册，可以将类转换为抽象类的子类。这些类对于使一组类符合单一接口非常有用。以下是使用它们的示例。在这里，工作类定义了一个接口，包含两个方法：do
    和 `is_busy`，每种类型的工作者都必须实现。`ApiWorker` 是这个接口的实现：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Summary
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Now, we have seen how to manipulate namespaces, and to create custom module-loading
    classes. We can use multiple inheritance to create mixin classes in which each
    mixin class provides a new functionality to the subclass. Context manager and
    iterator protocols are very useful constructs to create clean code. We created
    abstract classes that can help us in setting up API contracts for classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了如何操作命名空间，以及如何创建自定义模块加载类。我们可以使用多重继承来创建混合类，其中每个混合类都为子类提供新的功能。上下文管理器和迭代器协议是非常有用的结构，可以创建干净的代码。我们创建了抽象类，可以帮助我们为类设置
    API 合同。
- en: In the next chapter, we will cover the functions and utilities that are available
    to us from a standard Python installation.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍从标准 Python 安装中可用的函数和实用工具。
