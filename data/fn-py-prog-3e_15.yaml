- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: A Functional Approach to Web Services
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务的功能方法
- en: We’ll step away from the topic of exploratory data analysis to look at web servers
    and web services. A web server is, to an extent, a cascade of functions. We can
    apply a number of functional design patterns to the problem of presenting web
    content. Our goal is to look at ways in which we can approach Representational
    State Transfer (REST). We want to build RESTful web services using functional
    design patterns.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将暂时离开探索性数据分析的主题，转向Web服务器和Web服务。Web服务器在某种程度上是一系列函数的级联。我们可以将许多功能设计模式应用于呈现Web内容的问题。我们的目标是探讨我们可以如何接近表示状态转移（REST）。我们希望使用功能设计模式构建RESTful
    Web服务。
- en: We don’t need to invent yet another Python web framework. Nor do we want to
    select from among the available frameworks. There are many web frameworks available
    in Python, each with a distinct set of features and advantages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要再发明另一个Python Web框架。我们也不想从可用的框架中选择。Python中有许多Web框架，每个框架都有其独特的一组特性和优势。
- en: The intent of this chapter is to present some principles that can be applied
    to most of the available frameworks. This will let us leverage functional design
    patterns for presenting web content.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目的是提出一些可以应用于大多数可用框架的原则。这将使我们能够利用功能设计模式来呈现Web内容。
- en: When we look at extremely large or complex datasets, we might want a web service
    that supports subsetting or searching. We might also want a website that can download
    subsets in a variety of formats. In this case, we might need to use functional
    designs to create RESTful web services to support these more sophisticated requirements.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看极大型或复杂的数据集时，我们可能需要一个支持子集或搜索的Web服务。我们也可能需要一个可以以各种格式下载子集的网站。在这种情况下，我们可能需要使用功能设计来创建支持这些更复杂要求的RESTful
    Web服务。
- en: Interactive web applications often rely on stateful sessions to make the site
    easier for people to use. A user’s session information is updated with data provided
    through HTML forms, fetched from databases, or recalled from caches of previous
    interactions. Because the stateful data must be fetched as part of each transaction,
    it becomes more like an input parameter or result value. This can lead to functional-style
    programming even in the presence of cookies and database updates.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式Web应用程序通常依赖于有状态的会话来使网站更容易使用。用户的会话信息会通过HTML表单提供的数据、从数据库中检索的数据或从先前交互的缓存中恢复的数据进行更新。由于有状态的数据必须作为每个事务的一部分进行检索，它更像是一个输入参数或结果值。这可能导致即使在存在cookies和数据库更新的情况下，也会出现功能式编程。
- en: 'In this chapter, we’ll look at several topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨几个主题：
- en: The general idea of the HTTP request and response model.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求和响应模型的一般概念。
- en: The Web Server Gateway Interface (WSGI) standard that Python applications use.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python应用程序使用的Web服务器网关接口（WSGI）标准。
- en: Leveraging WSGI, where it’s possible to define web services as functions. This
    fits with the HTTP idea of a stateless server.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用WSGI，在可能将Web服务定义为函数的地方。这与HTTP无状态服务器的理念相符。
- en: We’ll also look at ways to authorize client applications to make use of a web
    service.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将探讨授权客户端应用程序使用Web服务的方法。
- en: 15.1 The HTTP request-response model
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1 HTTP请求-响应模型
- en: 'The HTTP protocol is nearly stateless: a user agent (or browser) makes a request
    and the server provides a response. For services that don’t involve cookies, a
    client application can take a functional view of the protocol. We can build a
    client using the `http.client` or `urllib.request` module. An HTTP user agent
    can be implemented as a function like the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP协议几乎是无状态的：用户代理（或浏览器）发起请求，服务器提供响应。对于不涉及cookies的服务，客户端应用程序可以采用功能视图的协议。我们可以使用`http.client`或`urllib.request`模块构建客户端。HTTP用户代理可以像以下函数一样实现：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A program like wget or curl does this kind of processing using a URL supplied
    as a command-line argument. A browser does this in response to the user pointing
    and clicking; the URL is taken from the user’s actions, often the action of clicking
    on linked text or images.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于wget或curl这样的程序会使用作为命令行参数提供的URL进行此类处理。浏览器会在用户点击和指向时执行此操作；URL通常来自用户的操作，通常是点击链接文本或图像。
- en: Note that a page’s encoding is often described in two separate places in the
    response. The HTTP headers will often name the encoding in use. In this example,
    the default of `"utf-8"` is supplied in the rare case that the headers are incomplete.
    In addition, the HTML content can also provide encoding information. Specifically,
    a `<meta`` charset="utf-8">` tag can claim an encoding. Ideally, it’s the same
    as the encoding noted in the headers. Alternatively, a `<meta`` http-equiv...>`
    tag can provide an encoding.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个页面的编码通常在响应的两个不同位置进行描述。HTTP头通常会命名正在使用的编码。在这个例子中，当头信息不完整时，会提供默认的 `"utf-8"`
    编码。此外，HTML内容也可以提供编码信息。具体来说，一个 `<meta charset="utf-8">` 标签可以声明一个编码。理想情况下，它与头中注明的编码相同。或者，一个
    `<meta http-equiv...>` 标签可以提供编码。
- en: While HTTP processing is stateless, the practical considerations of user experience
    (UX) design lead to some implementation details that need to be stateful. For
    human users to feel comfortable, it’s essential for the server to know what they’ve
    been doing and retain a transaction state. This is implemented by making the client
    software (browser or mobile application) track cookies. To make cookies work,
    a response header provides the cookie data, and subsequent requests must return
    the saved cookies to the server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然HTTP处理是无状态的，但用户体验（UX）设计的实际考虑导致了一些需要保持状态的具体实现细节。为了使人类用户感到舒适，服务器必须知道他们做了什么，并保留事务状态。这是通过使客户端软件（浏览器或移动应用程序）跟踪cookie来实现的。为了使cookie起作用，响应头提供了cookie数据，后续请求必须将保存的cookie返回给服务器。
- en: An HTTP response will include a status code. In some cases, this status code
    will require additional actions on the part of the user agent. Many status codes
    in the 300-399 range indicate that the requested resource has been moved. The
    application or browser is then required to save details from the `Location` header
    and request a new URL. The 401 status code indicates that authentication is required;
    the user agent must make another request using the `Authorization` header that
    contains credentials for access to the server. The `urllib` library implementation
    handles this stateful client processing. The `http.client` library is similar,
    but doesn’t automatically follow 3xx redirect status codes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应将包括一个状态码。在某些情况下，这个状态码将需要用户代理采取额外的操作。300-399范围内的许多状态码表示请求的资源已移动。然后应用程序或浏览器需要从
    `Location` 头中保存详细信息并请求新的URL。401状态码表示需要认证；用户代理必须使用包含访问服务器凭证的 `Authorization` 头进行另一个请求。`urllib`
    库实现处理这种有状态客户端处理。`http.client` 库类似，但它不会自动遵循3xx重定向状态码。
- en: 'Looking at the other side of the protocol, a static content server can be stateless.
    We can use the `http.server` library for this, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看到协议的另一边，一个静态内容服务器可以是无状态的。我们可以使用 `http.server` 库来做这件事，如下所示：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We created a `server` object, and assigned it to the `httpd` variable. We provided
    the address, `localhost`, and port number `8080`. As part of accepting the request,
    the HTTP protocol will allocate another port; this is used to create an instance
    of the handler class. Listening on one port but doing the work on other ports
    allows a server to process numerous requests concurrently.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `server` 对象，并将其分配给 `httpd` 变量。我们提供了地址 `localhost` 和端口号 `8080`。作为接受请求的一部分，HTTP协议将分配另一个端口；这用于创建处理程序类的实例。在一个端口上监听但在其他端口上执行工作允许服务器并发处理多个请求。
- en: In this example, we provided `SimpleHTTPRequestHandler` as the class to instantiate
    with each request. This class must implement a minimal interface, which will send
    headers and then send the body of the response to the client. This particular
    class will serve files from the local directory. If we wish to customize this,
    we can create a subclass that implements methods such as `do_GET()` and `do_POST()`
    to alter the behavior.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们提供了 `SimpleHTTPRequestHandler` 类作为每个请求的实例化类。这个类必须实现一个最小接口，该接口将发送头信息，然后将响应体的内容发送给客户端。这个特定的类将从本地目录中提供文件。如果我们想自定义它，我们可以创建一个子类，该子类实现了如
    `do_GET()` 和 `do_POST()` 等方法来改变行为。
- en: The `HTTPServer` class has a `serve_forever()` method that saves having to write
    an explicit `while` statement. We’ve shown the `while` statement here to clarify
    that the server must, generally, be crashed with an interrupt signal if we need
    to stop it.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPServer` 类有一个 `serve_forever()` 方法，可以避免编写显式的 `while` 语句。我们在这里展示了 `while`
    语句，以明确指出，如果需要停止服务器，通常必须使用中断信号来崩溃服务器。'
- en: This example uses port number 8080, one that doesn’t require elevated privileges.
    Web servers generally use ports 80 and 443\. These require elevated privileges.
    Generally, it’s best to use a server like NGINX or Apache httpd to manage the
    privileged ports.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用端口号8080，这个端口号不需要提升权限。Web服务器通常使用端口号80和443，这些端口号需要提升权限。通常，最好使用像NGINX或Apache
    httpd这样的服务器来管理特权端口。
- en: 15.1.1 Injecting state through cookies
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.1 通过cookies注入状态
- en: The addition of cookies changes the overall relationship between a client and
    server to become stateful. Interestingly, it involves no change to HTTP. The state
    information is communicated through headers on the request and the reply. The
    server will send cookies to the user agent in response headers. The user agent
    will save and reply with cookies in request headers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: cookies的添加改变了客户端和服务器之间的整体关系，使其成为有状态的。有趣的是，这并不涉及对HTTP的任何更改。状态信息是通过请求和回复的头信息进行通信的。服务器将在响应头中向用户代理发送cookies。用户代理将保存cookies并在请求头中回复它们。
- en: The user agent or browser is required to retain a cache of cookie values, provided
    as part of a response, and include appropriate cookies in subsequent requests.
    The web server will look for cookies in the request header and provide updated
    cookies in the response header. The effect is to make the web server stateless;
    the state changes happen only in the client. Because a server sees cookies as
    additional arguments in a request and provides additional details in a response,
    this shapes our view of the function that responds to a request.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理或浏览器需要保留作为响应一部分提供的cookie值缓存，并在后续请求中包含适当的cookies。Web服务器将在请求头中查找cookies，并在响应头中提供更新的cookies。这种效果是使Web服务器无状态；状态变化仅发生在客户端。因为服务器将cookies视为请求中的附加参数，并在响应中提供额外的详细信息，这塑造了我们对于响应请求的功能的看法。
- en: Cookies can contain anything that fits in 4,096 bytes. They are often encrypted
    to avoid exposing web server details to other applications running on the client
    computer. Transmitting large cookies can be slow, and should be avoided. The best
    practice is to keep session information in a database, and provide only a database
    key in a cookie. This makes the session persistent, and allows session processing
    to be handled by any available web server, allowing load-balancing among servers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: cookies可以包含任何适合4,096字节的内容。它们通常被加密，以避免将Web服务器细节暴露给客户端计算机上运行的其它应用程序。传输大的cookies可能会很慢，应该避免。最佳实践是将会话信息保存在数据库中，并在cookie中只提供数据库键。这使得会话持久化，并允许会话处理由任何可用的Web服务器处理，从而实现服务器之间的负载均衡。
- en: The concept of a session is a feature of the web application software, not HTTP.
    A session is commonly implemented via a cookie to retain session information.
    When an initial request is made, no cookie is available, and a new session cookie
    is created. Every subsequent request will include the cookie’s value. A logged-in
    user will have additional details in their session cookie. A session can last
    as long as the server is willing to accept the cookie; a cookie could be valid
    forever, or expire after a few minutes.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 会话的概念是Web应用程序软件的一个特性，而不是HTTP。会话通常通过cookie实现，以保留会话信息。当发起初始请求时，没有可用的cookie，将创建一个新的会话cookie。每个后续请求都将包括cookie的值。登录用户将在他们的会话cookie中包含额外的详细信息。会话可以持续到服务器愿意接受cookie的时间；cookie可以是永久有效的，或者几分钟后过期。
- en: A RESTful approach to web services does not rely on sessions or cookies. Each
    REST request is distinct. In many cases, an `Authorization` header is provided
    with each request to provide credentials for authentication and authorization.
    This generally means that a separate client-facing application must create a pleasing
    user experience, often involving sessions. A common architecture is a front-end
    application, perhaps a mobile app or browser-based site to provide a view of the
    supporting RESTful web services.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful风格的Web服务不依赖于会话或cookies。每个REST请求都是独特的。在许多情况下，每个请求都会提供一个`Authorization`头，以提供认证和授权的凭据。这通常意味着必须有一个单独面向客户端的应用程序来创建令人愉悦的用户体验，这通常涉及到会话。常见的架构是一个前端应用程序，可能是一个移动应用程序或基于浏览器的网站，用于提供对支持RESTful
    Web服务的视图。
- en: We’ll focus on RESTful web services in this chapter. The RESTful approach fits
    well with stateless functional design patterns.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中关注RESTful Web服务。RESTful方法非常适合无状态的函数式设计模式。
- en: One consequence of sessionless REST processes is each individual REST request
    is separately authenticated. This generally means the REST service must also use
    Secure Socket Layer (SSL) protocols. The `HTTPS` scheme is required to transmit
    credentials securely from client to server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 无会话REST过程的后果之一是每个REST请求都是单独认证的。这通常意味着REST服务也必须使用安全套接字层（SSL）协议。`HTTPS`方案是用于从客户端到服务器安全传输凭证所必需的。
- en: 15.1.2 Considering a server with a functional design
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.2 考虑具有功能设计的服务器
- en: 'One core idea behind HTTP is that the server’s response is a function of the
    request. Conceptually, a web service should have a top-level implementation that
    can be summarized as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP背后的一个核心思想是服务器的响应是请求的函数。从概念上讲，网络服务应该有一个顶层实现，可以概括如下：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: While this is the essence of HTTP, it lacks a number of important details. First,
    an HTTP request isn’t a simple, monolithic data structure. It has some required
    parts and some optional parts. A request may have headers, a method (e.g., `GET`,
    `POST`, `PUT`, `PATCH`, etc.), a URL, and there may be attachments. The URL has
    several optional parts including a path, a query string, and a fragment identifier.
    The attachments may include input from HTML forms or uploaded files, or both.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是HTTP的本质，但它缺少许多重要细节。首先，HTTP请求不是一个简单的、单一的数据结构。它包含一些必需的部分和一些可选的部分。一个请求可能包含头部信息、一个方法（例如，`GET`、`POST`、`PUT`、`PATCH`等）、一个URL，并且可能有附件。URL包含几个可选部分，包括路径、查询字符串和片段标识符。附件可能包括来自HTML表单的输入或上传的文件，或者两者都有。
- en: Second, the response, similarly, has three parts to it. It has a status code,
    headers, and a response body. Our simplistic model of a `httpd()` function doesn’t
    cover these additional details.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，响应同样有三个部分。它有一个状态码、头部信息和响应体。我们简单的`httpd()`函数模型没有涵盖这些额外的细节。
- en: We’ll need to expand on this simplistic view to more accurately decompose web
    processing into useful functions.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要扩展这种简单观点，以便更准确地分解网络处理为有用的函数。
- en: 15.1.3 Looking more deeply into the functional view
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.3 深入探讨功能视图
- en: 'Both HTTP responses and requests have headers that are separate from the body.
    The request can also have some attached form data or other uploads. Therefore,
    we can more usefully think of a web server like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP响应和请求都有与主体分开的头部。请求还可以包含一些附加的表单数据或其他上传。因此，我们可以更有用地将Web服务器视为这样：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The request headers may include cookie values, which can be seen as adding more
    arguments. Additionally, a web server is often dependent on the OS environment
    in which it’s running. This OS environment data can be considered as yet more
    arguments being provided as part of the request.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头部可能包括cookie值，这可以被视为添加了更多的参数。此外，Web服务器通常依赖于其运行的操作系统环境。这些操作系统环境数据可以被视为作为请求一部分提供的更多参数。
- en: The Multipurpose Internet Mail Extension (MIME) types define the kinds of content
    that a web service might return. MIME describes a large but reasonably well-defined
    spectrum of content. This can include plain text, HTML, JSON, XML, or any of the
    wide variety of non-text media that a website might serve.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 多用途互联网邮件扩展（MIME）类型定义了网络服务可能返回的内容类型。MIME描述了一个大但相对定义良好的内容范围。这可以包括纯文本、HTML、JSON、XML或任何网站可能提供的大量非文本媒体。
- en: There are some common features of HTTP request processing that we’d like to
    reuse. This idea of reusable elements is what leads to the creation of web service
    frameworks that fill a spectrum from simple to sophisticated. The ways that functional
    designs allow us to reuse functions indicate that the functional approach can
    help in building web services.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求处理的一些常见特性是我们希望重用的。这种可重用元素的想法导致了从简单到复杂的各种网络服务框架的创建。功能设计允许我们重用函数的方式表明，功能方法有助于构建网络服务。
- en: 'We’ll look at functional design of web services by examining how we can create
    a pipeline of the various elements of a service response. We’ll do this by nesting
    the functions for request processing so that inner elements are free from the
    generic overheads, which are provided by outer elements. This also allows the
    outer elements to act as filters: invalid requests can yield error responses,
    allowing the inner function to focus narrowly on the application processing.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过检查我们如何创建服务响应的各种元素管道来研究网络服务的功能设计。我们将通过嵌套请求处理的函数来实现这一点，这样内部元素就可以免受外部元素提供的通用开销的影响。这也允许外部元素充当过滤器：无效的请求可以产生错误响应，从而使内部函数能够专注于应用程序处理。
- en: 15.1.4 Nesting the services
  id: totrans-46
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.1.4 嵌套服务
- en: 'We can look at web request-handling as a number of layered contexts. The foundation
    might cover session management: examining the request to determine if this is
    another request in an existing session or a new session. Built on this foundation,
    another layer can provide tokens used for form processing that can detect Cross-Site
    Request Forgeries (CSRF). Another layer on top of these might handle user authentication
    within a session.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将网络请求处理看作是一系列分层上下文。基础可能包括会话管理：检查请求以确定这是现有会话中的另一个请求还是新会话。在这个基础上，另一层可以提供用于表单处理的令牌，这些令牌可以检测跨站请求伪造（CSRF）。在这些之上，可能还有一层处理会话内的用户身份验证。
- en: 'A conceptual view of the functions explained previously is something like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对之前解释的功能的概念性视图可能如下所示：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The idea here is that each function can build on the results of the previous
    function. Each function either enriches the request or rejects it because it’s
    invalid. The `session()` function, for example, can use headers to determine if
    this is an existing session or a new session. The `csrf()` function will examine
    form input to ensure that proper tokens were used. The CSRF handling requires
    a valid session. The `authentication()` function can return an error response
    for a session that lacks valid credentials; it can enrich the request with user
    information when valid credentials are present.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是每个函数都可以建立在先前函数的结果之上。每个函数要么丰富请求，要么拒绝它，因为它无效。例如，`session()` 函数可以使用头部信息来确定这是一个现有会话还是一个新会话。`csrf()`
    函数将检查表单输入以确保使用了正确的令牌。CSRF 处理需要有效的会话。`authentication()` 函数可以为缺少有效凭证的会话返回错误响应；当存在有效凭证时，它可以丰富请求，添加用户信息。
- en: The `content()` function is free from worrying about sessions, forgeries, and
    non- authenticated users. It can focus on parsing the path to determine what kind
    of content should be provided. In a more complex application, the `content()`
    function may include a rather complex mapping from path elements to the functions
    that determine the appropriate content.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`content()` 函数无需担心会话、伪造和非认证用户。它可以专注于解析路径，以确定应提供哪种类型的内容。在更复杂的应用中，`content()`
    函数可能包括从路径元素到确定适当内容的函数的相当复杂的映射。'
- en: This nested function view suffers from a profound problem. The stack of functions
    is defined to be used in a specific order. The `csrf()` function must be done
    first to provide useful information to the `authentication()` function. However,
    we can imagine a high-security scenario where authentication must be done before
    the CSRF tokens can be checked. We don’t want to have to define unique functions
    for each possible web architecture.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套的函数视图存在一个深刻的问题。函数栈被定义为按照特定顺序使用。`csrf()` 函数必须首先执行，以便为 `authentication()`
    函数提供有用的信息。然而，我们可以想象一个高安全场景，其中在检查 CSRF 令牌之前必须先进行身份验证。我们不希望为每种可能的网络架构定义独特的函数。
- en: While each context must have a distinct focus, it would be more helpful to have
    a single, unified view of request and response processing. This allows pieces
    to be built independently. A useful website would be a composition of a number
    of disparate functions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然每个上下文都必须有一个独特的焦点，但有一个单一的、统一的请求和响应处理视图会更有帮助。这允许独立构建各个部分。一个有用的网站将是多个不同函数的组合。
- en: With a standardized interface, we can combine functions to implement the required
    features. This will fit the functional programming objectives of having succinct
    and expressive programs that provide web content. The WSGI standard provides a
    uniform way to build complex services as a composition of parts.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准化接口，我们可以组合函数以实现所需功能。这将符合函数式编程的目标，即编写简洁且表达力强的程序来提供网络内容。WSGI 标准提供了一种统一的方式来构建复杂服务，作为部分的组合。
- en: 15.2 The WSGI standard
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2 WSGI 标准
- en: 'The Web Server Gateway Interface (WSGI) defines a standard interface for creating
    a response to a web request. This is a common framework for most Python-based
    web servers. A great deal of information is present at the following link: [http://wsgi.readthedocs.org/en/latest/](http://wsgi.readthedocs.org/en/latest/).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Web 服务器网关接口（WSGI）定义了创建对网络请求响应的标准接口。这是大多数基于 Python 的网络服务器的通用框架。以下链接提供了大量信息：[http://wsgi.readthedocs.org/en/latest/](http://wsgi.readthedocs.org/en/latest/)。
- en: Some important background on WSGI can be found at [https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 WSGI 的一些重要背景信息可以在以下链接中找到：[https://www.python.org/dev/peps/pep-0333/](https://www.python.org/dev/peps/pep-0333/)。
- en: 'The Python library’s `wsgiref` package includes a reference implementation
    of WSGI. Each WSGI application has the same interface, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python 库的 `wsgiref` 包包含 WSGI 的参考实现。每个 WSGI 应用程序都具有相同的接口，如下所示：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `environ` parameter is a dictionary that contains all of the arguments of
    the request in a single, uniform structure. The headers, the request method, the
    path, and any attachments for forms or file uploads will all be in the environment
    dictionary. In addition to this, the OS-level context is also provided, along
    with a few items that are part of WSGI request handling.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`environ` 参数是一个字典，它包含请求的所有参数，以单一、统一的结构。头部、请求方法、路径以及表单或文件上传的任何附件都将包含在环境字典中。除了这些之外，还提供了
    OS 级别的上下文，以及一些属于 WSGI 请求处理的项。'
- en: The `start_response` parameter is a function that must be used to send the status
    and headers of a response. The portion of a WSGI server that has the final responsibility
    for building the response will use the given `start_response()` function and will
    also build the response document as the return value.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`start_response` 参数是一个必须使用的函数，用于发送响应的状态和头部信息。负责构建响应的 WSGI 服务器部分将使用提供的 `start_response()`
    函数，并将响应文档作为返回值构建。'
- en: The response returned from a WSGI application is a sequence of strings or string-like
    file wrappers that will be returned to the user agent. If an HTML template tool
    is used, then the sequence may have a single item. In some cases, such as using
    the Jinja2 templates to build HTML content, the template can be rendered lazily
    as a sequence of text chunks. This allows a server to interleave template filling
    with downloading to the user agent.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从 WSGI 应用程序返回的响应是一个字符串或类似字符串的文件包装器的序列，这些序列将被返回给用户代理。如果使用 HTML 模板工具，则序列可能只有一个项目。在某些情况下，例如使用
    Jinja2 模板构建 HTML 内容，模板可以延迟作为文本块的序列进行渲染。这允许服务器在向用户代理下载的同时混合模板填充。
- en: The `wsgiref` package does not have a complete set of type definitions. This
    is not a problem in general. For example, within the `werkzeug` package, the `werkzeug.wsgi`
    module has useful type definitions. Because the `werkzeug` package is generally
    installed with Flask, it is very handy for our purposes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`wsgiref` 包没有一组完整的类型定义。这通常不是问题。例如，在 `werkzeug` 包中，`werkzeug.wsgi` 模块包含有用的类型定义。由于
    `werkzeug` 包通常与 Flask 一起安装，因此对于我们的目的来说非常方便。'
- en: 'The `werkzeug.wsgi` module includes a stubs file with a number of useful type
    hints. These hints are not part of the working application; they’re only used
    by the mypy tool. We can study the following `werkzeug.wsgi` type hints for a
    WSGI application:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`werkzeug.wsgi` 模块包含一个具有多个有用类型提示的存根文件。这些提示不是工作应用程序的一部分；它们仅由 mypy 工具使用。我们可以研究以下
    `werkzeug.wsgi` 的 WSGI 应用程序类型提示：'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `WSGIEnvironment` type hint defines a dictionary with no useful boundaries
    on the values. It’s difficult to enumerate all of the possible types of values
    defined by the WSGI standard. Instead of an exhaustively complex definition, it
    seems better to use `Any`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`WSGIEnvironment` 类型提示定义了一个没有对值有有用边界的字典。很难列举出 WSGI 标准定义的所有可能类型的值。与其使用详尽的复杂定义，似乎更好的方法是使用
    `Any`。'
- en: The `StartResponse` type hint is the signature for the `start_response()` function
    provided to a WSGI application. This is defined as a `Protocol` to show the presence
    of an optional third parameter with exception information.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`StartResponse` 类型提示是提供给 WSGI 应用的 `start_response()` 函数的签名。这被定义为 `Protocol`
    以显示存在一个可选的第三个参数，用于异常信息。'
- en: An overall WSGI application, `WSGIApplication`, requires the environment and
    the `start_response()` function. The result is an iterable collection of bytes.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 WSGI 应用程序 `WSGIApplication` 需要环境和 `start_response()` 函数。结果是字节的可迭代集合。
- en: 'The idea behind these hints is to allow us to define an application as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些提示背后的想法是允许我们定义一个应用程序如下：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We’ve included a conditional `import` to provide the type hints only when running
    the mypy tool. Outside using the mypy tool, the type hints are provided as strings.
    This additional clarification can help explain the design of a complex collection
    of functions that respond to web requests.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们包括了一个条件 `import` 来提供类型提示，仅在运行 mypy 工具时使用。在不在使用 mypy 工具的情况下，类型提示作为字符串提供。这种额外的说明可以帮助解释一个复杂函数集合的设计，这些函数响应
    Web 请求。
- en: Each WSGI application needs to be designed as a collection of functions. The
    collection can be viewed as nested functions or as a chain of transformations.
    Each application in the chain will either return an error or will hand the request
    to another application that will determine the final result.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个WSGI应用程序都需要设计成函数的集合。这个集合可以看作是嵌套函数或变换链。链中的每个应用程序要么返回一个错误，要么将请求传递给另一个应用程序，该应用程序将确定最终结果。
- en: Often, the URL path is used to determine which of many alternative applications
    will be used. This will lead to a tree of WSGI applications that may share common
    components.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，URL路径用于确定将使用哪些许多替代应用程序中的哪一个。这会导致一个WSGI应用程序的树，这些应用程序可能共享公共组件。
- en: 'Here’s a very simple routing application that takes the first element of the
    URL path and uses this to locate another WSGI application that provides content:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个非常简单的路由应用程序，它接受URL路径的第一个元素，并使用它来定位提供内容的另一个WSGI应用程序：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This application will use the `wsgiref.util.shift_path_info()` function to tweak
    the environment. The change is a head/tail split on the request path, available
    in the `environ[’` `PATH_INFO’]` dictionary. The head of the path, up to the first
    `"/"`, will be assigned to the `SCRIPT_NAME` item in the environment; the `PATH_INFO`
    item will be updated to have the tail of the path. The returned value will also
    be the head of the path, the same value as `environ[’SCRIPT_NAME’]`. In the case
    where there’s no path to parse, the return value is `None` and no environment
    updates are made.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序将使用`wsgiref.util.shift_path_info()`函数调整环境。更改是对请求路径的头部/尾部分割，可在`environ[’PATH_INFO’]`字典中找到。路径的头部，直到第一个`"/"`，将被分配给环境中的`SCRIPT_NAME`项；`PATH_INFO`项将被更新以包含路径的尾部。返回值也将是路径的头部，与`environ[’SCRIPT_NAME’]`相同的值。在没有路径可解析的情况下，返回值是`None`，并且不进行环境更新。
- en: The `routing()` function uses the first item on the path to locate an application
    in the `SCRIPT_MAP` dictionary. We use `welcome_app` as a default in case the
    requested path doesn’t fit the mapping. This seems a little better than an HTTP
    `404`` NOT`` FOUND` error.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`routing()`函数使用路径上的第一个项目在`SCRIPT_MAP`字典中定位应用程序。如果请求的路径不符合映射，我们使用`welcome_app`作为默认值。这似乎比HTTP
    `404 NOT FOUND`错误要好一些。'
- en: This WSGI application is a function that chooses between a number of other WSGI
    functions. Note that the routing function doesn’t return a function; it provides
    the modified environment to the selected WSGI application. This is the typical
    design pattern for handing off the work from one function to another.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个WSGI应用程序是一个函数，它从多个其他WSGI函数中选择。请注意，路由函数不返回一个函数；它将修改后的环境提供给选定的WSGI应用程序。这是从函数到函数传递工作的典型设计模式。
- en: From this, we can see how a framework could generalize the path-matching process,
    using regular expressions. We can imagine configuring the `routing()` function
    with a sequence of regular expressions and WSGI applications, instead of a mapping
    from a string to the WSGI application. The enhanced `routing()` function application
    would evaluate each regular expression looking for a match. In the case of a match,
    any `match.groups()` function could be used to update the environment before calling
    the requested application.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以看到框架如何泛化路径匹配过程，使用正则表达式。我们可以想象配置`routing()`函数，使用一系列正则表达式和WSGI应用程序，而不是从字符串到WSGI应用程序的映射。增强的`routing()`函数将评估每个正则表达式以寻找匹配项。在匹配的情况下，可以使用任何`match.groups()`函数在调用请求的应用程序之前更新环境。
- en: 15.2.1 Raising exceptions during WSGI processing
  id: totrans-80
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.1 在WSGI处理期间引发异常
- en: 'One central feature of WSGI applications is that each stage along the chain
    is responsible for filtering the requests. The idea is to reject faulty requests
    as early in the processing as possible. When building a pipeline of independent
    WSGI applications, each stage has the following two essential choices:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI应用程序的一个核心特征是链中的每个阶段都负责过滤请求。其理念是在处理过程中尽早拒绝错误的请求。当构建一系列独立的WSGI应用程序时，每个阶段有两个基本选择：
- en: Evaluate the `start_response()` function to start a reply with an error status
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评估`start_response()`函数以启动带有错误状态的回复
- en: OR pass the request with an expanded environment to the next stage
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者将带有扩展环境的请求传递给下一个阶段
- en: 'Consider a WSGI application that provides small text files. A file may not
    exist, or a request may refer to a directory of files. We can define a WSGI application
    that provides static content as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个提供小型文本文件的WSGI应用程序。文件可能不存在，或者请求可能指向文件目录。我们可以定义一个提供静态内容的WSGI应用程序如下：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This application creates a `Path` object from the current working directory
    and an element of the path provided as part of the requested URL. The path information
    is part of the WSGI environment, in an item with the `’PATH_INFO’` key. Because
    of the way the path is parsed, it will have a leading ”/”, which we discard by
    using `environ[’PATH_INFO’][1:]`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序从当前工作目录和请求URL中提供的路径元素创建一个`Path`对象。路径信息是WSGI环境的一部分，在具有`’PATH_INFO’`键的项中。由于路径的解析方式，它将有一个前导的”/”，我们通过使用`environ[’PATH_INFO’][1:]`来丢弃它。
- en: 'This application tries to open the requested path as a text file. There are
    two common problems, both of which are handled as exceptions:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用程序尝试以文本文件的形式打开请求的路径。存在两个常见问题，这两个问题都作为异常处理：
- en: If the file is a directory, we’ll route the request to a different WSGI application,
    `index_app`, to present directory contents
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件是一个目录，我们将请求路由到不同的WSGI应用程序，即`index_app`，以展示目录内容
- en: If the file is simply not found, we’ll return an HTTP `404`` NOT`` FOUND` response
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件根本找不到，我们将返回HTTP `404` NOT FOUND响应
- en: Any other exceptions raised by this WSGI application will not be caught. The
    application that invoked this application should be designed with some generic
    error-response capability. If the application doesn’t handle the exceptions, a
    generic WSGI failure response will be used.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 此WSGI应用程序引发的任何其他异常都不会被捕获。调用此应用程序的应用程序应该设计有某种通用的错误响应能力。如果应用程序没有处理异常，将使用通用的WSGI失败响应。
- en: Our processing involves a strict ordering of operations. We must read the entire
    file so that we can create a proper HTTP Content-Length header.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的处理涉及操作的严格顺序。我们必须读取整个文件，以便我们可以创建适当的HTTP Content-Length头。
- en: This small application shows the WSGI idea of either responding or passing the
    request onto another application that forms the response. This respond-now-or-forward
    design pattern enables the building of multi-stage pipelines. Each stage either
    rejects the request, handles it completely, or passes it on to some other application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此小型应用程序展示了WSGI的响应或转发请求到另一个形成响应的应用程序的想法。这种立即响应或转发设计模式使得构建多阶段管道成为可能。每个阶段要么拒绝请求，要么完全处理它，要么将其传递给其他应用程序。
- en: These pipelines are often called middleware because they are between a base
    server (like NGINX) and the final web application or RESTful API. The idea is
    to use middleware to perform a series of common filters or mappings for each request.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这些管道通常被称为中间件，因为它们位于基础服务器（如NGINX）和最终Web应用程序或RESTful API之间。想法是使用中间件为每个请求执行一系列常见的过滤器或映射。
- en: 15.2.2 Pragmatic web applications
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.2.2 实用型Web应用程序
- en: The intent of the WSGI standard is not to define a complete web framework; the
    intent is to define a minimum set of standards that allows flexible interoperability
    of web-related processing. This minimum fits well with functional programming
    concepts.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI标准的意图不是定义一个完整的Web框架；意图是定义一组最小标准，允许灵活的Web相关处理互操作性。这个最小标准与函数式编程概念很好地匹配。
- en: A web application framework is focused on the needs of developers. It should
    offer numerous simplifications to providing web services. The foundational interface
    must be compatible with WSGI, so that it can be used in a variety of contexts.
    The developer’s view, however, will diverge from the minimal WSGI definitions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序框架专注于开发者的需求。它应该提供许多简化以提供Web服务。基础接口必须与WSGI兼容，以便可以在各种环境中使用。然而，开发者的观点将与最小的WSGI定义有所不同。
- en: Web servers such as Apache httpd or NGINX have adapters to provide a WSGI-compatible
    interface from the web server to Python applications. For more information on
    WSGI implementations, visit [https://wiki.python.org/moin/WSGIImplementations](https://wiki.python.org/moin/WSGIImplementations).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器，如Apache httpd或NGINX，有适配器，可以从Web服务器提供WSGI兼容的接口到Python应用程序。有关WSGI实现的更多信息，请访问[https://wiki.python.org/moin/WSGIImplementations](https://wiki.python.org/moin/WSGIImplementations)。
- en: Embedding our applications in a larger server allows us to have a tidy separation
    of concerns. We can use Apache httpd or NGINX to serve the static content, such
    as `.css`, `.js`, and image files. For HTML pages, though, a server like NGINX
    can use the `uwsgi` module to hand off requests to a pool of Python processes.
    This focuses Python on handling the interestingly complex HTML portions of the
    web content.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序嵌入到更大的服务器中，可以使我们实现关注点的整洁分离。我们可以使用Apache httpd或NGINX来提供静态内容，例如`.css`、`.js`和图像文件。然而，对于HTML页面，像NGINX这样的服务器可以使用`uwsgi`模块将请求传递给一组Python进程。这使Python专注于处理网页内容的有趣且复杂的HTML部分。
- en: Downloading static content requires little customization. There’s often no application-specific
    processing. This is best handled in a separate service that can be optimized to
    perform this fixed task.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下载静态内容需要很少的定制。通常没有特定于应用程序的处理。这最好在一个单独的服务中处理，该服务可以优化以执行此固定任务。
- en: The processing for dynamic content (often the HTML content of a web page) is
    where the interesting Python-based work happens. This work can be segregated to
    servers that are optimized to run this more complex application-specific computation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 动态内容的处理（通常是网页的HTML内容）是Python相关有趣工作的发生地。这项工作可以分离到优化运行这种更复杂的应用特定计算的服务器上。
- en: Separating the static content from the dynamic content to provide optimized
    downloads means that we must either create a separate media server, or define
    our website to have two sets of paths. For smaller sites, a separate `/media`
    path works out nicely. For larger sites, distinct media servers are required.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将静态内容与动态内容分离以提供优化的下载意味着我们必须创建一个单独的媒体服务器，或者定义我们的网站具有两组路径。对于较小的网站，单独的`/media`路径效果很好。对于较大的网站，则需要不同的媒体服务器。
- en: An important consequence of the WSGI definition is the `environ` dictionary
    is often updated with additional configuration parameters. In this way, some WSGI
    applications can serve as gateways to enrich the environment with information
    extracted from cookies, headers, configuration files, or databases.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: WSGI定义的一个重要后果是`environ`字典通常会更新额外的配置参数。通过这种方式，一些WSGI应用程序可以作为网关，从cookie、头部、配置文件或数据库中提取信息来丰富环境。
- en: 15.3 Defining web services as functions
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3 将网络服务定义为函数
- en: We’ll look at a RESTful web service, which can slice and dice a source of data
    and provide downloads as JSON, XML, or CSV files.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究一个RESTful网络服务，它可以切割和分割数据源，并提供JSON、XML或CSV文件的下载。
- en: 'The direct use of WSGI for this kind of application isn’t optimal because we
    need to create a great deal of ”boilerplate” processing for all the details of
    conventional website processing. A more effective approach is to use a more sophisticated
    web server like Flask, Django, Bottle, or any of the frameworks listed here: [https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks).
    These servers handle the conventional cases more completely, allowing us—as developers—to
    focus on the unique features of a page or site.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 直接使用WSGI进行此类应用程序不是最优的，因为我们需要为传统网站处理的全部细节创建大量的“样板”处理。更有效的方法是使用更复杂的网络服务器，如Flask、Django、Bottle或这里列出的任何框架：[https://wiki.python.org/moin/WebFrameworks](https://wiki.python.org/moin/WebFrameworks)。这些服务器处理传统情况更完整，使我们作为开发者能够专注于页面或网站的独特功能。
- en: 'We’ll use a simple dataset with four series of data pairs: the Anscombe Quartet.
    We looked at ways to read and parse this data in [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003). It’s a small
    set of data, but it can be used to show the principles of a RESTful web service.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个包含四个数据对序列的简单数据集：Anscombe四重奏。我们在[第3章](Chapter_03.xhtml#x1-510003)、[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)中探讨了读取和解析这些数据的方法。这是一个小的数据集，但它可以用来展示RESTful网络服务的原则。
- en: 'We’ll split our application into two tiers: a web tier, which will provide
    the visible RESTful web service, and a data service tier, which will manage the
    underlying data. We’ll look at the web tier first, as this provides a context
    in which the data service tier must operate.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把我们的应用程序分为两层：一个网络层，它将提供可见的RESTful网络服务，和一个数据服务层，它将管理底层数据。我们将首先查看网络层，因为这为数据服务层必须运行的环境提供了上下文。
- en: 'A request must include these two pieces of information:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 请求必须包含以下两块信息：
- en: The series of data that is desired. The idea is to slice up the pool of available
    information by filtering and extracting the desired subset.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所需的数据序列。想法是通过过滤和提取所需子集来切割可用的信息池。
- en: The output format that the user needs. This includes common serialization formats
    like HTML, CSV, JSON, and XML.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要的输出格式。这包括常见的序列化格式，如HTML、CSV、JSON和XML。
- en: The series selection is commonly done through the request path. We can request
    `/anscombe/I` or `/anscombe/II` to pick specific series from the quartet. Path
    design is important, and this seems to be the right way to identify the data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 系列选择通常是通过请求路径完成的。我们可以请求`/anscombe/I`或`/anscombe/II`来选择四重奏中的特定系列。路径设计很重要，这似乎是识别数据的正确方式。
- en: 'The following two underlying ideas help define paths:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个基本思想有助于定义路径：
- en: A URL defines a resource
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个URL定义了一个资源
- en: There’s no good reason for the URL to ever change
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有充分的理由让URL发生变化
- en: In this case, the dataset selectors of `I` or `II` aren’t dependent on publication
    dates or some organizational approval status, or other external factors. This
    design seems to create URLs that are timeless and absolute.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`I`或`II`的数据集选择器不依赖于发布日期或某些组织批准状态，或其他外部因素。这种设计似乎创建出永恒且绝对的URL。
- en: The output format, on the other hand, is not a first-class part of the URL.
    It is merely a serialization format, not the data itself. One choice is to name
    the format in the HTTP `Accept` header. In some cases, to make things easy to
    use from a browser, a query string can be used to specify the output format. One
    approach is to use the query to specify the serialization format. We might use
    `?form=json`, `?format=json`, or even `?output_serialization=json` at the end
    of the path to specify that the output serialization format should be JSON. The
    HTTP `Accept` header is preferred, but hard to experiment with using only a browser.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，输出格式不是URL的一部分。它仅仅是一个序列化格式，而不是数据本身。一个选择是在HTTP `Accept`头中命名格式。在某些情况下，为了使浏览器使用起来更方便，可以使用查询字符串来指定输出格式。一种方法是通过查询来指定序列化格式。我们可以在路径末尾使用`?form=json`、`?format=json`，甚至`?output_serialization=json`来指定输出序列化格式应为JSON。HTTP
    `Accept`头是首选的，但仅使用浏览器进行实验可能比较困难。
- en: 'A browser-friendly URL we can use will look like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用一个浏览器友好的URL，其形式如下：
- en: '[PRE10]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This would request a download of the third series in CSV format.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将请求以CSV格式下载第三系列。
- en: The OpenAPI Specification provides a way to define the family of URLs and the
    expected results. This specification is helpful because it serves as a clear,
    formal contract for the web server’s expected behavior. What’s most helpful about
    the OpenAPI specification is having a concrete list of paths, parameters, and
    responses. A good specification will include examples, helping the process of
    writing an acceptance test suite for the server.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI规范提供了一种定义URL家族和预期结果的方法。这个规范是有帮助的，因为它作为网络服务器预期行为的清晰、正式合同。OpenAPI规范最有帮助的是有一个具体的路径、参数和响应列表。一个好的规范将包括示例，有助于编写服务器的验收测试套件。
- en: Generally, the OpenAPI specification is provided by the web server to help clients
    properly use the available services. A URL like `"/openapi.yml"` or `"/openapi.json"`
    is suggested as a way to provide needed information about a web application.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，OpenAPI规范由网络服务器提供，以帮助客户端正确使用可用的服务。建议使用像`"/openapi.yml"`或`"/openapi.json"`这样的URL来提供关于网络应用程序所需的信息。
- en: 15.3.1 Flask application processing
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.1 Flask应用程序处理
- en: We’ll use the Flask framework because it provides an easy-to-extend web services
    process. It supports a function-based design, with a mapping from a request path
    to a view function that builds the response. The framework also makes use of decorators,
    providing a good fit with functional programming concepts.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Flask框架，因为它提供了一个易于扩展的Web服务过程。它支持基于函数的设计，将请求路径映射到构建响应的视图函数。该框架还利用了装饰器，与函数式编程概念相匹配。
- en: In order to bind all of the configuration and URL routing together, an overall
    `Flask` instance is used as a container. Our application will be an instance of
    the `Flask` class. As a simplification, each view function is defined separately
    and bound into the `Flask` instance via a routing table that maps URLs to functions.
    This routing table is built via decorators.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将所有配置和URL路由绑定在一起，使用一个总的`Flask`实例作为容器。我们的应用程序将是`Flask`类的一个实例。作为一种简化，每个视图函数都是单独定义的，并通过将URL映射到函数的路由表绑定到`Flask`实例。这个路由表是通过装饰器构建的。
- en: 'The core of the application is this collection of view functions. Generally,
    each view function needs to do three things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的核心是这个视图函数集合。通常，每个视图函数需要做三件事：
- en: Validate the request.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证请求。
- en: Perform the requested state change or data access.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行请求的状态更改或数据访问。
- en: Prepare a response.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备响应。
- en: Ideally, the view function does nothing more than this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，视图函数不做任何其他事情。
- en: 'Here’s the initial `Flask` object that will contain the routes and their functions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是初始的 `Flask` 对象，它将包含路由及其函数：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We’ve created the `Flask` instance and assigned it to the `app` variable. As
    a handy default, we’ve used the module’s name, `__name__`, as the name of the
    application. This is often sufficient. For complex applications, it may be better
    to provide a name that’s not specifically tied to a Python module or package name.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已创建 `Flask` 实例并将其分配给 `app` 变量。作为一个方便的默认值，我们使用了模块的名称，`__name__`，作为应用程序的名称。这通常足够。对于复杂的应用程序，可能更好的是提供一个不特定于
    Python 模块或包名称的名称。
- en: Most applications will need to have configuration parameters provided. In this
    case, the source data is a configurable value that might change.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要提供配置参数。在这种情况下，源数据是一个可能更改的可配置值。
- en: 'For larger applications, it’s often necessary to locate an entire configuration
    file. For this small application, we’ll provide the configuration value as a literal:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大的应用程序，通常有必要定位整个配置文件。对于这个小型应用程序，我们将提供配置值作为字面量：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Most of the view functions should be relatively small, focused functions that
    make use of other layers of the application. For this application, the web presentation
    depends on a data service tier to acquire and format the data. This leads to functions
    with the following three steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数视图函数应该是相对较小的、专注于其他应用层功能的函数。对于这个应用程序，网络表示依赖于数据服务层来获取和格式化数据。这导致以下三个步骤的函数：
- en: Validate the various inputs. This includes validating items like the path, any
    query parameters, form input data, uploaded files, header values, and even cookie
    values.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证各种输入。这包括验证路径、任何查询参数、表单输入数据、上传的文件、头部值，甚至是 cookie 值。
- en: If the method involves a state change like `POST`, `PUT`, `PATCH`, or `DELETE`,
    perform the state-changing operation. These will often return a ”redirect” response
    to a path that will display the results of the change. If the method involves
    a `GET` request, gather the requested data.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果该方法涉及状态更改，如 `POST`、`PUT`、`PATCH` 或 `DELETE`，则执行状态更改操作。这些操作通常会返回一个指向将显示更改结果的路径的“重定向”响应。如果该方法涉及
    `GET` 请求，则收集所需数据。
- en: Prepare the response.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备响应。
- en: What’s important about step 2 is all of the data manipulation is separate from
    the RESTful web application. The web presentation sits on a foundation of data
    access and manipulation. The web application is designed as a view or a presentation
    of the underlying structure.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 第 2 步的重要之处在于所有数据操作都与 RESTful 网络应用程序分离。网络表示建立在数据访问和操作的基础之上。网络应用程序被设计为一个视图或对底层结构的展示。
- en: 'We’ll look at two URL paths for the web application. The first path will provide
    an index of the available series in the Anscombe collection. The `view` function
    can be defined as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看网络应用程序的两个 URL 路径。第一个路径将提供 Anscombe 集合中可用系列索引。`view` 函数可以定义为以下内容：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function has the Flask `@app.route` decorator. This shows what URLs should
    be processed by this `view` function. There are a fair number of options and alternatives
    available here. The `view` function will be evaluated when a request matches one
    of the available routes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数具有 Flask 的 `@app.route` 装饰器。这表明哪些 URL 应由此 `view` 函数处理。这里有许多选项和替代方案可用。当请求与可用路由之一匹配时，将评估
    `view` 函数。
- en: 'The `format()` function definition will be shown in a little while. It locates
    the user’s desired format by looking in two places: the query string, after the
    `?` in the URL, and also in the `Accept` header. If the query string value is
    invalid, a 404 response will be created.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()` 函数的定义将在稍后展示。它通过查找两个地方来定位用户期望的格式：URL 中的查询字符串，即 `?` 后面，以及 `Accept`
    头部。如果查询字符串值无效，将创建一个 404 响应。'
- en: The `get_series_map()` function is an essential feature of the data service
    tier. This will locate the Anscombe series data and create a mapping from `Series`
    name to the data of the series.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_series_map()` 函数是数据服务层的一个基本功能。这将定位 Anscombe 系列数据，并将 `Series` 名称映射到系列数据。'
- en: The index information is in the form of a list-of-dict structure. This structure
    can be converted to JSON, CSV, and HTML without too much complication. Creating
    XML is a bit more difficult. The difficulty arises because the Python list and
    dictionary objects don’t have any specific class name, making it awkward to supply
    XML tags.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 索引信息以列表-of-dict结构的形式存在。这种结构可以不经过太多复杂地转换为JSON、CSV和HTML。创建XML则要困难一些。困难之处在于Python列表和字典对象没有特定的类名，这使得提供XML标签变得有些尴尬。
- en: The data preparation is performed in two parts. First, the index information
    is serialized in the desired format. Second, a Flask `Response` object is built
    using the bytes, an HTTP status code of 200, and a specific value for the `Content-Type`
    header.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 数据准备分为两部分进行。首先，索引信息以所需格式序列化。其次，使用字节、HTTP状态码200和`Content-Type`头部的特定值构建一个Flask
    `Response`对象。
- en: The `abort()` function stops process and returns an error response with the
    given code and reason information. For RESTful web services, it helps to add a
    small helper function to transform the result into JSON. The use of the `abort()`
    function during data validation and preparation makes it easy to end processing
    at the first problem with the request.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`abort()`函数停止进程并返回带有给定代码和原因信息的错误响应。对于RESTful Web服务，添加一个将结果转换为JSON的小型辅助函数很有帮助。在数据验证和准备期间使用`abort()`函数使得在请求的第一个问题时结束处理变得容易。'
- en: 'The `format()` function is defined as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`format()`函数定义如下：'
- en: '[PRE14]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This function looks for input from two attributes of the `request` object:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数从`request`对象的两个属性中查找输入：
- en: The `args` will have the argument values that are present after the ”?” in the
    URL
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`args`将包含URL中“？”之后出现的参数值'
- en: The `accept_mimetypes` will have the parsed values from the `Accept` header,
    allowing an application to locate a response that meets the client’s expectations
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`accept_mimetypes`将包含从`Accept`头部解析出的值，允许应用程序定位满足客户端期望的响应'
- en: The `request` object is a bit of thread-local storage with the details of the
    web request being made. It is used like a global variable, making some functions
    look a little awkward. The use of a global like `request` tends to obscure the
    actual parameters to this function. Using explicit parameters requires also providing
    the underlying type information, which is little more than visual clutter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`request`对象是带有正在进行的Web请求详细信息的线程局部存储。它被用作全局变量，使得一些函数看起来有些笨拙。像`request`这样的全局变量往往会掩盖此函数的实际参数。使用显式参数还需要提供底层类型信息，这不过是视觉上的杂乱。'
- en: 'The `series_view()` function to provide series data is defined as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 定义提供系列数据的`series_view()`函数如下：
- en: '[PRE15]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function has a similar structure to the previous `index_view()` function.
    The request is validated, the data acquired, and a response prepared. As with
    the previous function, the work is delegated to two other data access functions:
    `get_series_map()` and `anscombe_filter()`. These are separate from the web application,
    and could be part of a command-line application.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数结构与之前的`index_view()`函数类似。请求得到验证，数据获取，并准备响应。与之前的函数一样，工作被委托给另外两个数据访问函数：`get_series_map()`和`anscombe_filter()`。这些函数与Web应用程序分开，可能是命令行应用程序的一部分。
- en: Both of these functions depend on an underlying data access layer. We’ll look
    at those functions in the next section.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数都依赖于底层的数据访问层。我们将在下一节中查看这些函数。
- en: 15.3.2 The data access tier
  id: totrans-159
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.3.2 数据访问层
- en: 'The `get_series_map()` function is similar to the examples shown in the [Cleaning
    raw data with generator functions](Chapter_03.xhtml#x1-590006) section of [Chapter 3](Chapter_03.xhtml#x1-510003),
    [Functions, Iterators, and Generators](Chapter_03.xhtml#x1-510003). In this section,
    we’ll include some important changes. We’ll start with the following two `NamedTuple`
    definitions:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_series_map()`函数与第3章[使用生成器函数清理原始数据](Chapter_03.xhtml#x1-590006)部分中显示的示例类似，[函数、迭代器和生成器](Chapter_03.xhtml#x1-510003)。在本节中，我们将包括一些重要的更改。我们将从以下两个`NamedTuple`定义开始：'
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We’ve defined a `Pair` named tuple and provided a `@classmethod` to build instances
    of a `Pair`. This definition will automatically provide an `_asdict()` method
    that responds with a dictionary of the form `dict[str,`` Any]` containing the
    attribute names and values. This is helpful for serialization.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为`Pair`的命名元组，并提供了一个`@classmethod`来构建`Pair`的实例。此定义将自动提供一个`_asdict()`方法，该方法返回一个形式为`dict[str,
    Any]`的字典，包含属性名称和值。这对于序列化很有帮助。
- en: Similarly, we’ve defined a `Series` named tuple. The `create()` method can build
    a tuple from an iterable source of lists of values. The automatically provided
    `_asdict()` method can be helpful for serializing. For this application, however,
    we’ll make use of the `_as_listofdicts` method to create a list of dictionaries
    that can be serialized.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们定义了一个名为 `Series` 的命名元组。`create()` 方法可以从值列表的可迭代源构建一个元组。自动提供的 `_asdict()`
    方法对于序列化可能很有帮助。然而，对于这个应用程序，我们将使用 `_as_listofdicts` 方法来创建可以序列化的字典列表。
- en: 'The function to produce the mapping from series name to `Series` object has
    the following definition:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 从系列名称到 `Series` 对象的映射函数具有以下定义：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `get_series_map()` function opens the local data file, and applies the `row_iter()`
    function to each line of the file. This parses the line into a row of separate
    items. The `head_split_fixed()` function is used to remove the heading from the
    file. The result is a tuple-of-list structure, which is assigned the variable
    `raw_data`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_series_map()` 函数打开本地数据文件，并将 `row_iter()` 函数应用于文件的每一行。这会将行解析为单独的项目行。使用
    `head_split_fixed()` 函数从文件中移除标题。结果是元组列表结构，被分配给变量 `raw_data`。'
- en: From the `raw_data` structure, the `Series.create()` method is used to transform
    a sequence of values from the file into a `Series` object composed of individual
    `Pair` instances. The final step is to use a dictionary comprehension to collect
    the individual `Series` instances into a single mapping from series name to `Series`
    object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `raw_data` 结构中，使用 `Series.create()` 方法将文件中的值序列转换为由单个 `Pair` 实例组成的 `Series`
    对象。最后一步是使用字典推导式收集单个 `Series` 实例到一个从系列名称到 `Series` 对象的单个映射中。
- en: 'Since the output from the `get_series_map()` function is a mapping, we can
    do something like the following example to pick a specific series by name:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `get_series_map()` 函数的输出是一个映射，我们可以像以下示例那样通过名称选择特定的系列：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Given a key, for example, `’I’`, the series is a list of `Pair` objects that
    have the `x`, `y` values for each item in the series.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个键，例如，`‘I’`，该系列是一个包含 `Pair` 对象的列表，这些对象具有系列中每个项目的 `x`、`y` 值。
- en: Applying a filter
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用过滤器
- en: 'In this application, we’re using a very simple filter. The entire filter process
    is embodied in the following function:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用程序中，我们使用一个非常简单的过滤器。整个过滤器过程体现在以下函数中：
- en: '[PRE19]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We made this trivial expression into a function for three reasons:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个简单的表达式转换为函数有三个原因：
- en: The functional notation is slightly more consistent with other parts of the
    Flask application, and a bit more flexible than the subscript expression
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表示法与其他 Flask 应用程序的各个部分略微更一致，并且比下标表达式更灵活
- en: We can easily expand the filtering to do more
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以轻松扩展过滤功能以执行更多操作
- en: We can include separate unit tests for this function
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以为这个函数包含单独的单元测试
- en: While a simple lambda would work, it wouldn’t be quite as convenient to test.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的 lambda 函数可以工作，但测试起来可能不太方便。
- en: 'For error handling, we’ve done exactly nothing. We’ve focused on what’s sometimes
    called the happy path: an ideal sequence of events. Any problems that arise in
    this function will raise an exception. The WSGI wrapper function should catch
    all exceptions and return an appropriate status message and error response content.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于错误处理，我们实际上什么都没做。我们专注于有时被称为“快乐路径”的理想事件序列。在这个函数中出现的任何问题都会抛出异常。WSGI 包装函数应该捕获所有异常，并返回适当的状态消息和错误响应内容。
- en: 'For example, it’s possible that the `set_id` method will be wrong in some way.
    Rather than obsess over all the ways it could be wrong, we’ll allow Python to
    raise an exception. Indeed, this function follows Admiral Grace Murray Hopper’s
    advice that it’s better to seek forgiveness than to ask permission. This advice
    is materialized in code by avoiding permission-seeking: there are no preparatory
    `if` statements that seek to qualify the arguments as valid. There is only forgiveness
    handling: an exception will be raised and handled by evaluating the Flask `abort()`
    function.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`set_id` 方法可能以某种方式出错。而不是过分关注它可能出错的所有方式，我们将允许 Python 抛出异常。实际上，这个函数遵循 Grace
    Hopper 海军上将的建议，即寻求宽恕比请求许可更好。这个建议在代码中体现为避免请求许可：没有试图验证参数有效性的预备 `if` 语句。只有宽恕处理：将抛出异常，并通过评估
    Flask 的 `abort()` 函数来处理。
- en: Serializing the results
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 序列化结果
- en: Serialization is the conversion of Python data into a stream of bytes, suitable
    for transmission. Each format is best described by a simple function that serializes
    just that one format. A top-level generic serializer can then pick from a list
    of specific serializers.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将Python数据转换为字节流的过程，适合传输。每种格式最好通过一个简单的函数来描述，该函数仅序列化该格式。然后，顶层通用序列化器可以从一系列特定序列化器中选择。
- en: 'The general type hint for a serializer is this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化器的一般类型提示如下：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This definition avoids the specific `Series` definition. It uses a more general
    `list``[``dict``[``str``,` `Any``]]` type hint. This can be applied to the data
    of a `Series` as well as other items like the series labels.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义避免了具体的`Series`定义。它使用了一个更一般的`list[dict[str, Any]]`类型提示。这可以应用于`Series`的数据以及其他类似序列标签的项目。
- en: 'A mapping from MIME types to serializer functions will lead to the following
    mapping object:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从MIME类型到序列化器函数的映射将导致以下映射对象：
- en: '[PRE21]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This variable will be defined after the four functions it references. We’ve
    provided it here to act as context, showing where the serialization design is
    headed.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量将在引用的四个函数定义之后定义。我们在这里提供它作为上下文，展示序列化设计的发展方向。
- en: 'The top-level `serialize()` function can be defined as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 顶层`serialize()`函数可以定义如下：
- en: '[PRE22]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The overall `serialize()` function locates a specific serializer in the `SERIALIZERS`
    dictionary. This specific function fits the the `Serializer` type hint. The function
    will transform a `Series` object into bytes that can be downloaded to a web client
    application.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 总体上的`serialize()`函数在`SERIALIZERS`字典中定位一个特定的序列化器。这个特定的函数符合`Serializer`类型提示。该函数将`Series`对象转换为字节，可以下载到Web客户端应用程序。
- en: The `serialize()` function doesn’t do any data transformation. It maps a MIME
    type string to a function that does the hard work of transformation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`serialize()`函数不执行任何数据转换。它将MIME类型字符串映射到一个执行转换的函数。'
- en: 'We’ll look at some of the individual serializers below. It’s relatively common
    for Python processing to create strings. We can then encode the strings into bytes.
    To avoid repeating the encoding operation, we’ll define a decorator to compose
    the serialization with the bytes encoding. Here’s the decorator we can use:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一些单独的序列化器。在Python处理中创建字符串相对常见。然后我们可以将这些字符串编码为字节。为了避免重复编码操作，我们将定义一个装饰器来组合序列化和字节编码。以下是我们可以使用的装饰器：
- en: '[PRE23]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We’ve created a small decorator named `@to_bytes`. This will evaluate the given
    function and then encode the results using UTF-8 to get bytes. Note that the decorator
    changes the decorated function from having a return type of `str` to a return
    type of `bytes`. We used the `ParamSpec` hint to collect declared parameters for
    the decorated function. This ensures that tools like mypy can match the parameter
    specification for the decorated function with the base function.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`@to_bytes`的小型装饰器。这个装饰器将评估给定的函数，然后使用UTF-8编码结果以获取字节。请注意，装饰器将装饰函数的返回类型从`str`更改为`bytes`。我们使用了`ParamSpec`提示来收集装饰函数声明的参数。这确保了像mypy这样的工具可以将装饰函数的参数规范与基础函数相匹配。
- en: We’ll show how this is used with JSON and CSV serializers. The HTML and XML
    serialization involves a bit more programming, but no significant complexity.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示如何使用JSON和CSV序列化器来实现这一点。HTML和XML序列化涉及更多的编程，但并没有显著的复杂性。
- en: Serializing data with JSON or CSV formats
  id: totrans-197
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用JSON或CSV格式序列化数据
- en: The JSON and CSV serializers are similar because both rely on Python’s libraries
    to serialize. The libraries are inherently imperative, so the function bodies
    are sequences of statements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: JSON和CSV序列化器是相似的，因为两者都依赖于Python的库进行序列化。这些库本质上是命令式的，因此函数体是语句的序列。
- en: 'Here’s the JSON serializer:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是JSON序列化器的示例：
- en: '[PRE24]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We created a list-of-dicts structure and used the `json.dumps()` function to
    create a string representation. The JSON module requires a materialized list object;
    we can’t provide a lazy generator function. The `sort_keys=True` argument value
    is helpful for unit testing because the order is clearly stated and can be used
    to match expected results. However, it’s not required for the application and
    represents a bit of overhead.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个字典列表结构，并使用`json.dumps()`函数创建了一个字符串表示形式。JSON模块需要一个具体化的列表对象；我们不能提供一个惰性生成器函数。`sort_keys=True`参数值对于单元测试很有帮助，因为顺序被明确地说明了，并且可以用来匹配预期的结果。然而，它对于应用程序不是必需的，并且代表了一点点开销。
- en: 'Here’s the CSV serializer:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是CSV序列化器的示例：
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `csv` module’s readers and writers are a mixture of imperative and functional
    elements. We must create the writer, and properly create headings in a strict
    sequence. A client of this function can use the `_fields` attribute of the `Pair`
    named tuple to determine the column headings for the writer.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`csv` 模块的读取器和写入器是命令式和函数式元素的混合。我们必须创建写入器，并且必须按照严格的顺序正确创建标题。此函数的客户端可以使用 `Pair`
    命名元组的 `_fields` 属性来确定写入器的列标题。'
- en: The `writerows()` method of the writer will accept a lazy generator function.
    A client of this function can use the `_asdict()` method of a `NamedTuple` object
    to return a dictionary suitable for use with the CSV writer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: writer 对象的 `writerows()` 方法将接受一个惰性生成器函数。此函数的客户端可以使用 `NamedTuple` 对象的 `_asdict()`
    方法返回一个适合与 CSV 写入器一起使用的字典。
- en: Serializing data with XML and HTML
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 XML 和 HTML 序列化数据
- en: 'Serialization into XML has a goal of creating a document that looks like this:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据序列化为 XML 的目标是创建一个看起来像这样的文档：
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This XML document doesn’t include a reference to formal XML Schema Definition
    (XSD). It is, however, designed to parallel the named tuple definitions shown
    above.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 此 XML 文档不包括对正式 XML 架构定义 (XSD) 的引用。然而，它被设计成与上面显示的命名元组定义并行。
- en: One way to produce a document like this is to create a template and fill in
    the fields. This can be done with packages like Jinja or Mako. There are a number
    of sophisticated template tools to create XML or HTML pages. A number of these
    include the ability to embed iteration over a sequence of objects—like a list
    of dicts—in the template, separate from the function that initializes serialization.
    Visit [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)
    for a list of alternatives.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此类文档的一种方法是通过创建模板并填写字段。这可以使用 Jinja 或 Mako 等包来完成。有许多复杂的模板工具可以创建 XML 或 HTML 页面。其中许多包括在模板中嵌入对对象序列（如字典列表）的迭代的能力，而无需在初始化序列化的函数中执行。访问
    [https://wiki.python.org/moin/Templating](https://wiki.python.org/moin/Templating)
    获取替代方案列表。
- en: A more sophisticated serialization library could be helpful here. There are
    many to choose from. Visit [https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml)
    for a list of alternatives.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一个更复杂的序列化库可能会有所帮助。有许多可供选择。访问 [https://wiki.python.org/moin/PythonXml](https://wiki.python.org/moin/PythonXml)
    获取替代方案列表。
- en: Modern HTML is based on XML. Therefore, an HTML document can be built similarly
    to an XML document by filling the actual values into a template. HTML documents
    often have a great deal more overhead than XML documents. The additional complexity
    arises because in HTML, the document is expected to provide an entire web page
    with a great deal of context information.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现代 HTML 基于 XML。因此，可以通过将实际值填充到模板中来构建类似于 XML 文档的 HTML 文档。HTML 文档通常比 XML 文档有更多的开销。额外的复杂性源于在
    HTML 中，文档被期望提供一个包含大量上下文信息的完整网页。
- en: We’ve omitted the details for creating HTML or XML, leaving them as exercises
    for the reader.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了创建 HTML 或 XML 的细节，将其留给读者作为练习。
- en: 15.4 Tracking usage
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.4 跟踪使用
- en: RESTful APIs need to be used for secured connections. This means the server
    must use SSL, and the connection will be via HTTPS protocol. The idea is to manage
    the SSL certificates used by ”front-end” or client applications. In many web service
    environments, mobile applications and JavaScript-based interactive front-ends
    will have certificates allowing access to the back-end.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 需要用于安全连接。这意味着服务器必须使用 SSL，并且连接将通过 HTTPS 协议进行。其想法是管理“前端”或客户端应用程序使用的
    SSL 证书。在许多网络服务环境中，移动应用程序和基于 JavaScript 的交互式前端将拥有允许访问后端的证书。
- en: In addition to SSL, another common practice is to require an API key as part
    of each transaction. An API key can be used to authenticate access. It may also
    be used to authorize specific features. Most importantly, it’s essential for tracking
    actual usage. A consequence of tracking usage can be throttling requests if an
    API key is used too often in a given time period.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 SSL 之外，另一个常见的做法是在每个事务中要求一个 API 密钥。API 密钥可以用来验证访问。它也可以用来授权特定功能。最重要的是，它对于跟踪实际使用至关重要。跟踪使用的一个后果是，如果在一个给定的时间段内过度使用
    API 密钥，可能会限制请求。
- en: The variations in business models are numerous. For example, use of the API
    key could be a billable event and charges will be incurred. For other businesses,
    traffic must reach some threshold before payments are required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 商业模式的变体很多。例如，API 密钥的使用可能是一个可计费事件，并且将产生费用。对于其他业务，流量必须达到某个阈值，然后才需要支付。
- en: What’s important is non-repudiation of the use of the API. When a transaction
    is executed to make a state change, the API key can be used to identify the application
    making the request. This, in turn, means creating API keys that can act as a user’s
    authentication credentials. The key must be difficult to forge and relatively
    easy to verify.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要确保API使用的不可否认性。当执行交易以进行状态更改时，可以使用API密钥来识别发出请求的应用程序。这反过来意味着创建可以充当用户身份验证凭据的API密钥。密钥必须难以伪造，并且相对容易验证。
- en: 'One way to create API keys is to use a cryptographic random number to generate
    a difficult-to-predict key string. The `secrets` module can be used to generate
    unique API key values. Here’s an example of generating a unique key that can be
    assigned to clients to track activity:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 创建API密钥的一种方法是用加密随机数生成一个难以预测的密钥字符串。可以使用`secrets`模块生成唯一的API密钥值。以下是一个生成唯一密钥的示例，该密钥可以分配给客户端以跟踪活动：
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A base 64 encoding is used on the random bytes to create a sequence of characters.
    Using a multiple of three for the length will avoid any trailing `=` signs in
    the base 64 encoding. We’ve used the URL-safe base 64 encoding, which won’t include
    the `/` or `+` characters in the resulting string. This means the key can be used
    as part of a URL or can be provided in a header.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在随机字节上使用64进制编码来创建一串字符。使用三的倍数作为长度将避免在64进制编码中出现任何尾随的`=`符号。我们使用了URL安全的64进制编码，这意味着结果字符串中不会包含`/`或`+`字符。这意味着密钥可以用作URL的一部分，或者可以在标题中提供。
- en: A more elaborate method of generating a token won’t lead to more random data.
    The use of the `secrets` module assures that it is very difficult to counterfeit
    a key assigned to another user.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更复杂的方法生成令牌不会导致更随机的数据。使用`secrets`模块确保很难伪造分配给其他用户的密钥。
- en: The `secrets` module is notoriously hard to use as part of unit and integration
    test. In order to produce high-quality, secure values, it avoids having an explicit
    seed like the `random` module does. Since reproducible unit test cases can’t depend
    on the `secrets` module having reproducible results, a mock object should be used
    when testing. One consequence of this is creating a design that facilitates testing.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`secrets`模块作为单元和集成测试的一部分使用时，因其难以使用而闻名。为了生成高质量、安全的数据，它避免了像`random`模块那样有显式种子。由于可重复的单元测试用例不能依赖于`secrets`模块的可重复结果，因此在测试时应使用模拟对象。这一结果的后果是创建一个便于测试的设计。'
- en: As API keys are generated, they need to be sent to the users creating applications,
    and also kept in a database that’s part of the API service.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 随着API密钥的生成，它们需要发送给创建应用程序的用户，并保存在API服务的一部分数据库中。
- en: If a request includes a key that’s in the database, the associated user is responsible
    for the request. If the API request doesn’t include a known key, the request can
    be rejected with a `401`` UNAUTHORIZED` response.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果请求中包含数据库中的密钥，则关联的用户负责该请求。如果API请求不包含已知的密钥，则请求可以拒绝，并返回`401 UNAUTHORIZED`响应。
- en: This small database can be a text file that the server loads to map API keys
    to authorized privileges. The file can be read at startup and the modification
    time checked to see if the version cached in the server is still current. When
    a new key is available, the file is updated and the server will re-read the file.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小型数据库可以是一个文本文件，服务器在加载时将其映射到授权权限的API密钥。该文件可以在启动时读取，并检查修改时间以确定服务器缓存的版本是否仍然是最新的。当有新的密钥可用时，文件将被更新，服务器将重新读取该文件。
- en: See [https://swagger.io/docs/specification/2-0/authentication/api-keys/](https://swagger.io/docs/specification/2-0/authentication/api-keys/)
    for more information on API keys.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有关API密钥的更多信息，请参阅[https://swagger.io/docs/specification/2-0/authentication/api-keys/](https://swagger.io/docs/specification/2-0/authentication/api-keys/)。
- en: The essential check for a valid API key is so common that Flask provides a decorator
    to identify this function. Using `@app.before_app_request` marks a function that
    will be invoked before every view function. This function can establish the validity
    of the API key before allowing any processing.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对有效API密钥的基本检查如此常见，以至于Flask提供了一个装饰器来识别此功能。使用`@app.before_app_request`标记一个将在每个视图函数之前调用的函数。这个函数可以在允许任何处理之前确定API密钥的有效性。
- en: This API key-checking is often bypassed for a few paths. If, for example, the
    service will download its OpenAPI specification, the path should be handled without
    regard to the presence of an `API-Key` header. This often means a special-case
    check to see if `request.path` is `openapi.json` or one of the other common names
    for the specification.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API密钥检查通常被绕过了一些路径。例如，如果服务将下载其OpenAPI规范，则路径应在不考虑是否存在`API-Key`头的情况下处理。这通常意味着一个特殊情况检查，以查看`request.path`是否为`openapi.json`或其他规范常见名称之一。
- en: Similarly, a server may need to respond to requests based on the presence of
    CORS headers. See [https://www.w3.org/TR/cors/#http-cors-protocol](https://www.w3.org/TR/cors/#http-cors-protocol)
    for more information. This can make the `before_app_request()` function even more
    complex by adding another group of exceptions.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，服务器可能需要根据CORS头的存在来响应请求。有关更多信息，请参阅[https://www.w3.org/TR/cors/#http-cors-protocol](https://www.w3.org/TR/cors/#http-cors-protocol)。这可能会通过添加另一组异常使`before_app_request()`函数变得更加复杂。
- en: The good news is there are only two exceptions to requiring an `API-Key` header
    with every request. One is handling the OpenAPI specification and the other is
    the CORS preflight request. This is unlikely to change, and a few `if` statements
    are sufficient.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，只有两个例外需要在每个请求中都包含`API-Key`头。一个是处理OpenAPI规范，另一个是CORS预请求。这不太可能改变，几个`if`语句就足够了。
- en: 15.5 Summary
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.5 摘要
- en: In this chapter, we looked at ways in which we can apply functional design to
    the problem of serving content with REST-based web services. We looked at how
    the WSGI standard leads to somewhat functional overall applications. We also looked
    at how we can embed a more functional design into a WSGI context by extracting
    elements from the request for use by our application functions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将函数式设计应用于基于REST的Web服务的内容服务问题。我们探讨了WSGI标准如何导致整体应用在一定程度上具有函数性。我们还探讨了如何通过从请求中提取元素以供我们的应用程序函数使用，将更函数化的设计嵌入到WSGI上下文中。
- en: 'For simple services, the problem often decomposes into three distinct operations:
    getting the data, searching or filtering, and then serializing the results. We
    tackled this with three functions: `raw_data()`, `anscombe_filter()`, and `serialize()`.
    We wrapped these functions in a simple WSGI-compatible application to divorce
    the web services from the real processing around extracting and filtering the
    data.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的服务，问题通常分解为三个不同的操作：获取数据、搜索或过滤，然后序列化结果。我们通过三个函数来解决这个问题：`raw_data()`、`anscombe_filter()`和`serialize()`。我们将这些函数包装在一个简单的WSGI兼容应用程序中，以将Web服务与提取和过滤数据的实际处理分离。
- en: We also looked at the way that web services’ functions can focus on the happy
    path and assume that all of the inputs are valid. If inputs are invalid, the ordinary
    Python exception handling will raise exceptions. The WSGI wrapper function will
    catch the errors and return appropriate status codes and error content.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了Web服务函数如何专注于“快乐路径”并假设所有输入都是有效的。如果输入无效，普通的Python异常处理将引发异常。WSGI包装函数将捕获错误并返回适当的状态码和错误内容。
- en: We have not looked at more complex problems associated with uploading data or
    accepting data from forms to update a persistent data store. These are not significantly
    more complex than getting data and serializing the results.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有研究与上传数据或从表单中接受数据以更新持久数据存储相关的更复杂问题。这些问题并不比获取数据和序列化结果更复杂。
- en: For simple queries and data sharing, a small web service application can be
    helpful. We can apply functional design patterns and assure that the website code
    is succinct and expressive. For more complex web applications, we should consider
    using a framework that handles the details properly.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的查询和数据共享，一个小型网络服务应用程序可能会有所帮助。我们可以应用函数式设计模式，并确保网站代码简洁且易于理解。对于更复杂的网络应用程序，我们应该考虑使用一个能够正确处理细节的框架。
- en: In the next chapter, we’ll look at a more complete example of functional programming.
    This is a case study that applies some statistical measures to sample data to
    determine if the data are likely to be random, or potentially include some interesting
    relationship.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个更完整的函数式编程示例。这是一个案例研究，它将一些统计措施应用于样本数据，以确定数据是否可能是随机的，或者可能包含一些有趣的关系。
- en: 15.6 Exercises
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.6 练习
- en: This chapter’s exercises are based on code available from Packt Publishing on
    GitHub. See [https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习基于Packt Publishing在GitHub上提供的代码。请参阅[https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition](https://github.com/PacktPublishing/Functional-Python-Programming-3rd-Edition)。
- en: In some cases, the reader will notice that the code provided on GitHub includes
    partial solutions to some of the exercises. These serve as hints, allowing the
    reader to explore alternative solutions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，读者可能会注意到GitHub上提供的代码包括一些练习的部分解决方案。这些作为提示，允许读者探索替代解决方案。
- en: In many cases, exercises will need unit test cases to confirm they actually
    solve the problem. These are often identical to the unit test cases already provided
    in the GitHub repository. The reader should replace the book’s example function
    name with their own solution to confirm that it works.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，练习将需要单元测试用例来确认它们确实解决了问题。这些通常与GitHub仓库中已提供的单元测试用例相同。读者应将书籍中的示例函数名称替换为自己的解决方案以确认其工作。
- en: '15.6.1 WSGI application: welcome'
  id: totrans-243
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.1 WSGI应用程序：welcome
- en: In the [The WSGI standard](#x1-3180002) section of this chapter, a routing application
    was described. It showed three application routes, including paths starting with
    `/demo` and a special case for the path `/index.html`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[The WSGI standard](#x1-3180002)部分，描述了一个路由应用程序。它展示了三个应用程序路由，包括以`/demo`开头的路径和一个针对`/index.html`路径的特殊情况。
- en: Creating applications via WSGI can be challenging. Build a function, `welcome_app()`,
    that displays an HTML page with some links for the demo app and the static download
    app.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过WSGI创建应用程序可能具有挑战性。构建一个函数`welcome_app()`，该函数显示一个包含演示应用程序和静态下载应用程序链接的HTML页面。
- en: A unit test for this application should use a mocked `StartResponse` function,
    and a mocked environment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为此应用程序编写的单元测试应使用模拟的`StartResponse`函数和一个模拟的环境。
- en: '15.6.2 WSGI application: demo'
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.2 WSGI应用程序：demo
- en: In the [The WSGI standard](#x1-3180002) section of this chapter, a routing application
    was described. It showed three application routes, including paths starting with
    `/demo` and a special case for the `/index.html` path.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[The WSGI standard](#x1-3180002)部分，描述了一个路由应用程序。它展示了三个应用程序路由，包括以`/demo`开头的路径和一个针对`/index.html`路径的特殊情况。
- en: Build a function, `demo_app()`, to do some potentially useful activity. The
    intent here is to have a path that responds to an HTTP `POST` request to do some
    work, creating an entry in a log file. The result must be a redirect (status 303,
    usually) to a URL that uses the `static_text_app()` to download the log file.
    This behavior is described as Post/Redirect/Get, and allows for a good user experience
    when navigating back to a previous page. See [https://www.geeksforgeeks.org/post-redirect-get-prg-design-pattern/](https://www.geeksforgeeks.org/post-redirect-get-prg-design-pattern/)
    for more details on this design pattern.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个函数`demo_app()`，以执行一些可能有用的活动。这里的意图是有一个路径可以响应HTTP `POST`请求来完成一些工作，在日志文件中创建一个条目。结果必须是一个重定向（状态码303，通常）到使用`static_text_app()`下载日志文件的URL。这种行为被称为Post/Redirect/Get，当导航回上一个页面时，可以提供良好的用户体验。有关此设计模式的更多详细信息，请参阅[https://www.geeksforgeeks.org/post-redirect-get-prg-design-pattern/](https://www.geeksforgeeks.org/post-redirect-get-prg-design-pattern/)。
- en: 'Here are two examples of useful work that might be implemented by the demo
    application:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是演示应用程序可能实现的有用工作的两个示例：
- en: A `GET` request can present an HTML page with a form. The submit button on the
    form can make a `POST` request to do a computation of some kind.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`GET`请求可以显示一个带有表单的HTML页面。表单上的提交按钮可以将`POST`请求发送到执行某种计算的函数。
- en: A `POST` request can execute `doctest.testfile()` to run a unit test suite and
    collect the resulting log.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`POST`请求可以执行`doctest.testfile()`来运行单元测试套件并收集结果日志。
- en: 15.6.3 Serializing data with XML
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.3 使用XML序列化数据
- en: In the [Serializing data with XML and HTML](#x1-3270002) section of this chapter,
    we described two additional features of the RESTful API built using Flask.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[Serializing data with XML and HTML](#x1-3270002)部分，我们描述了使用Flask构建的RESTful
    API的两个附加功能。
- en: Extend the response in those examples to serialize the resulting data into XML
    in addition to CSV and JSON. One alternative to adding XML serialization is to
    download and install a library that will serialize `Series` and `Pair` objects.
    Another choice is to write a function that can work with a `list[dict[str,`` Any]]`
    object. Adding the XML serialization format also requires adding test cases to
    confirm the response has the expected format and content.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些示例中扩展响应，将结果数据序列化为 XML，除了 CSV 和 JSON。添加 XML 序列化的一个替代方案是下载并安装一个库，该库可以序列化 `Series`
    和 `Pair` 对象。另一个选择是编写一个可以与 `list[dict[str, Any]]` 对象一起工作的函数。添加 XML 序列化格式还需要添加测试用例来确认响应具有预期的格式和内容。
- en: 15.6.4 Serializing data with HTML
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 15.6.4 使用 HTML 序列化数据
- en: In the [Serializing data with XML and HTML](#x1-3270002) section of this chapter,
    we described two additional features of the RESTful API built using Flask.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的[使用 XML 和 HTML 序列化数据](#x1-3270002)部分，我们描述了使用 Flask 构建的 RESTful API 的两个附加功能。
- en: Extend the response in those examples to serialize the resulting data into HTML
    in addition to CSV and JSON. HTML serialization can be more complex than XML serialization
    because there is quite a bit of overhead in an HTML presentation of data. Rather
    than a representation of the `Pair` objects, it is common practice to include
    an entire HTML table structure that mirrors the CSV rows and columns. Adding the
    HTML serialization format also requires adding test cases to confirm the response
    has the expected format and content.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些示例中扩展响应，将结果数据序列化为 HTML，除了 CSV 和 JSON。HTML 序列化可能比 XML 序列化更复杂，因为数据在 HTML 展示中有很多开销。而不是
    `Pair` 对象的表示，通常的做法是包含一个完整的 HTML 表格结构，它反映了 CSV 的行和列。添加 HTML 序列化格式还需要添加测试用例来确认响应具有预期的格式和内容。
- en: Join our community Discord space
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and know more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
