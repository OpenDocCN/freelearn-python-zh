- en: Appendix B. Database API Reference
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录B.数据库API参考
- en: Django's database API is the other half of the model API discussed in Appendix
    A. Once you've defined a model, you'll use this API any time you need to access
    the database. You've seen examples of this API in use throughout the book; this
    appendix explains all the various options in detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Django的数据库API是附录A中讨论的模型API的另一半。一旦定义了模型，您将在需要访问数据库时使用此API。您已经在整本书中看到了此API的使用示例；本附录详细解释了各种选项。
- en: 'Throughout this appendix I''ll refer to the following models, which comprise
    a Weblog application:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本附录中，我将引用以下模型，这些模型组成了一个Weblog应用程序：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating objects
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建对象
- en: 'To represent database-table data in Python objects, Django uses an intuitive
    system: a model class represents a database table, and an instance of that class
    represents a particular record in the database table.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Python对象中表示数据库表数据，Django使用了一个直观的系统：模型类表示数据库表，该类的实例表示数据库表中的特定记录。
- en: To create an object, instantiate it using keyword arguments to the model class,
    then call `save()` to save it to the database.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建对象，请使用模型类的关键字参数进行实例化，然后调用`save()`将其保存到数据库中。
- en: 'Assuming models live in a file `mysite/blog/models.py`, here''s an example:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 假设模型位于文件`mysite/blog/models.py`中，这是一个示例：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This performs an `INSERT` SQL statement behind the scenes. Django doesn't hit
    the database until you explicitly call `save()`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这在幕后执行`INSERT` SQL语句。直到您明确调用`save()`之前，Django不会访问数据库。
- en: The `save()` method has no return value.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`save()`方法没有返回值。'
- en: To create and save an object in a single step, use the `create()` method.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要在单个步骤中创建和保存对象，请使用`create()`方法。
- en: Saving changes to objects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存对象的更改
- en: To save changes to an object that's already in the database, use `save()`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要保存已经在数据库中的对象的更改，请使用`save()`。
- en: 'Given a `Blog` instance `b5` that has already been saved to the database, this
    example changes its name and updates its record in the database:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设已经将`Blog`实例`b5`保存到数据库中，此示例更改其名称并更新数据库中的记录：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This performs an `UPDATE` SQL statement behind the scenes. Django doesn't hit
    the database until you explicitly call `save()`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这在幕后执行`UPDATE` SQL语句。Django直到您明确调用`save()`之前才会访问数据库。
- en: Saving ForeignKey and ManyToManyField fields
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存ForeignKey和ManyToManyField字段
- en: 'Updating a `ForeignKey` field works exactly the same way as saving a normal
    field-simply assign an object of the right type to the field in question. This
    example updates the `blog` attribute of an `Entry` instance `entry`, assuming
    appropriate instances of `Entry`, and `Blog` are already saved to the database
    (so we can retrieve them below):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`ForeignKey`字段的方式与保存普通字段的方式完全相同-只需将正确类型的对象分配给相关字段。此示例更新了`Entry`实例`entry`的`blog`属性，假设已经适当保存了`Entry`和`Blog`的实例到数据库中（因此我们可以在下面检索它们）：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Updating a `ManyToManyField` works a little differently-use the `add()` method
    on the field to add a record to the relation. This example adds the `Author` instance
    `joe` to the `entry` object:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`ManyToManyField`的方式略有不同-使用字段上的`add()`方法将记录添加到关系中。此示例将`Author`实例`joe`添加到`entry`对象中：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To add multiple records to a `ManyToManyField` in one go, include multiple
    arguments in the call to `add()`, like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次向`ManyToManyField`添加多条记录，请在调用`add()`时包含多个参数，如下所示：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Django will complain if you try to assign or add an object of the wrong type.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试分配或添加错误类型的对象，Django会发出警告。
- en: Retrieving objects
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索对象
- en: To retrieve objects from your database, construct a `QuerySet` via a `Manager`
    on your model class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要从数据库中检索对象，请通过模型类上的`Manager`构建`QuerySet`。
- en: A `QuerySet` represents a collection of objects from your database. It can have
    zero, one or many filters. Filters narrow down the query results based on the
    given parameters. In SQL terms, a `QuerySet` equates to a `SELECT` statement,
    and a filter is a limiting clause such as `WHERE` or `LIMIT`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySet`表示来自数据库的对象集合。它可以有零个、一个或多个过滤器。过滤器根据给定的参数缩小查询结果。在SQL术语中，`QuerySet`等同于`SELECT`语句，而过滤器是诸如`WHERE`或`LIMIT`的限制子句。'
- en: 'You get a `QuerySet` by using your model''s `Manager`. Each model has at least
    one `Manager`, and it''s called `objects` by default. Access it directly via the
    model class, like so:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用模型的`Manager`来获取`QuerySet`。每个模型至少有一个`Manager`，默认情况下称为`objects`。直接通过模型类访问它，就像这样：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Retrieving all objects
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索所有对象
- en: 'The simplest way to retrieve objects from a table is to get all of them. To
    do this, use the `all()` method on a `Manager`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从表中检索对象的最简单方法是获取所有对象。要做到这一点，使用`Manager`上的`all()`方法：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `all()` method returns a `QuerySet` of all the objects in the database.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`方法返回数据库中所有对象的`QuerySet`。'
- en: Retrieving specific objects with filters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用过滤器检索特定对象
- en: The `QuerySet` returned by `all()` describes all objects in the database table.
    Usually, though, you'll need to select only a subset of the complete set of objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`all()`返回的`QuerySet`描述了数据库表中的所有对象。通常，您需要选择完整对象集的子集。'
- en: 'To create such a subset, you refine the initial `QuerySet`, adding filter conditions.
    The two most common ways to refine a `QuerySet` are:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建这样的子集，您需要细化初始的`QuerySet`，添加过滤条件。细化`QuerySet`的两种最常见的方法是：
- en: '`filter(**kwargs)`. Returns a new `QuerySet` containing objects that match
    the given lookup parameters.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter(**kwargs)`。返回一个包含匹配给定查找参数的对象的新`QuerySet`。'
- en: '`exclude(**kwargs)`. Returns a new `QuerySet` containing objects that do not
    match the given lookup parameters.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exclude(**kwargs)`。返回一个包含不匹配给定查找参数的对象的新`QuerySet`。'
- en: The lookup parameters (`**kwargs` in the above function definitions) should
    be in the format described in *Field lookups* later in this chapter.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找参数（上述函数定义中的`**kwargs`）应该以本章后面描述的*字段查找*格式。
- en: Chaining filters
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 链接过滤器
- en: 'The result of refining a `QuerySet` is itself a `QuerySet`, so it''s possible
    to chain refinements together. For example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 细化`QuerySet`的结果本身是一个`QuerySet`，因此可以将细化链接在一起。例如：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This takes the initial `QuerySet` of all entries in the database, adds a filter,
    then an exclusion, then another filter. The final result is a `QuerySet` containing
    all entries with a headline that starts with `What`, that were published between
    January 30, 2005, and the current day.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要数据库中所有条目的初始`QuerySet`，添加一个过滤器，然后一个排除，然后另一个过滤器。最终结果是一个包含所有以`What`开头的标题的条目，发布日期在2005年1月30日和当天之间的`QuerySet`。
- en: Filtered querysets are unique
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤的查询集是唯一的
- en: Each time you refine a `QuerySet`, you get a brand-new `QuerySet` that is in
    no way bound to the previous `QuerySet`. Each refinement creates a separate and
    distinct `QuerySet` that can be stored, used, and reused.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每次细化`QuerySet`，您都会得到一个全新的`QuerySet`，它与以前的`QuerySet`没有任何关联。每次细化都会创建一个单独且独特的`QuerySet`，可以存储、使用和重复使用。
- en: 'Example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These three `QuerySets` are separate. The first is a base `QuerySet` containing
    all entries that contain a headline starting with What. The second is a subset
    of the first, with an additional criterion that excludes records whose `pub_date`
    is today or in the future. The third is a subset of the first, with an additional
    criterion that selects only the records whose `pub_date` is today or in the future.
    The initial `QuerySet` (`q1`) is unaffected by the refinement process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个`QuerySets`是独立的。第一个是一个基本的`QuerySet`，包含所有以What开头的标题的条目。第二个是第一个的子集，增加了一个额外的条件，排除了`pub_date`是今天或将来的记录。第三个是第一个的子集，增加了一个额外的条件，只选择`pub_date`是今天或将来的记录。初始的`QuerySet`（`q1`）不受细化过程的影响。
- en: QuerySets are lazy
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: QuerySets是惰性的
- en: '`QuerySets` are lazy-the act of creating a `QuerySet` doesn''t involve any
    database activity. You can stack filters together all day long, and Django won''t
    actually run the query until the `QuerySet` is *evaluated*. Take a look at this
    example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuerySets`是惰性的-创建`QuerySet`的行为不涉及任何数据库活动。您可以整天堆叠过滤器，Django实际上不会运行查询，直到`QuerySet`被*评估*。看看这个例子：'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Though this looks like three database hits, in fact it hits the database only
    once, at the last line (`print(q)`). In general, the results of a `QuerySet` aren't
    fetched from the database until you ask for them. When you do, the `QuerySet`
    is *evaluated* by accessing the database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看起来像是三次数据库访问，实际上只有一次，在最后一行（`print(q)`）访问数据库。通常情况下，只有在要求时，`QuerySet`的结果才会从数据库中获取。当您这样做时，通过访问数据库来*评估*`QuerySet`。
- en: Retrieving a single object with get
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用get检索单个对象
- en: '`filter()` will always give you a `QuerySet`, even if only a single object
    matches the query-in this case, it will be a `QuerySet` containing a single element.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter()`总是会给你一个`QuerySet`，即使只有一个对象匹配查询-在这种情况下，它将是包含单个元素的`QuerySet`。'
- en: 'If you know there is only one object that matches your query, you can use the
    `get()` method on a `Manager` which returns the object directly:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您知道只有一个对象与您的查询匹配，您可以在`Manager`上使用`get()`方法直接返回对象：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can use any query expression with `get()`, just like with `filter()`-again,
    see *Field lookups* in the next section of this chapter.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以像使用`filter()`一样使用`get()`的任何查询表达式-再次参见本章的下一节中的*字段查找*。
- en: Note that there is a difference between using `get()`, and using `filter()`
    with a slice of `[0]`. If there are no results that match the query, `get()` will
    raise a `DoesNotExist` exception. This exception is an attribute of the model
    class that the query is being performed on-so in the code above, if there is no
    `Entry` object with a primary key of 1, Django will raise `Entry.DoesNotExist`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用`get()`和使用`filter()`与`[0]`的切片之间存在差异。如果没有结果与查询匹配，`get()`将引发`DoesNotExist`异常。此异常是正在执行查询的模型类的属性-因此在上面的代码中，如果没有主键为1的`Entry`对象，Django将引发`Entry.DoesNotExist`。
- en: Similarly, Django will complain if more than one item matches the `get()` query.
    In this case, it will raise `MultipleObjectsReturned`, which again is an attribute
    of the model class itself.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果`get()`查询匹配多个项目，Django将抱怨。在这种情况下，它将引发`MultipleObjectsReturned`，这也是模型类本身的属性。
- en: Other queryset methods
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他查询集方法
- en: Most of the time you'll use `all()`, `get()`, `filter()`, and `exclude()` when
    you need to look up objects from the database. However, that's far from all there
    is; see the QuerySet API Reference at [https://docs.djangoproject.com/en/1.8/ref/models/querysets/](https://docs.djangoproject.com/en/1.8/ref/models/querysets/),
    for a complete list of all the various `QuerySet` methods.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，当您需要从数据库中查找对象时，您将使用`all()`、`get()`、`filter()`和`exclude()`。但这远非全部；请参阅[https://docs.djangoproject.com/en/1.8/ref/models/querysets/](https://docs.djangoproject.com/en/1.8/ref/models/querysets/)上的QuerySet
    API参考，了解所有各种`QuerySet`方法的完整列表。
- en: Limiting querysets
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制查询集
- en: Use a subset of Python's array-slicing syntax to limit your `QuerySet` to a
    certain number of results. This is the equivalent of SQL's `LIMIT` and `OFFSET`
    clauses.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的数组切片语法的子集来限制您的`QuerySet`到一定数量的结果。这相当于SQL的`LIMIT`和`OFFSET`子句。
- en: 'For example, this returns the first 5 objects (`LIMIT 5`):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这将返回前5个对象（`LIMIT 5`）：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This returns the sixth through tenth objects (`OFFSET 5 LIMIT 5`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回第六到第十个对象（`OFFSET 5 LIMIT 5`）：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Negative indexing (that is, `Entry.objects.all()[-1]`) is not supported.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持负索引（即`Entry.objects.all()[-1]`）。
- en: 'Generally, slicing a `QuerySet` returns a new `QuerySet`-it doesn''t evaluate
    the query. An exception is if you use the step parameter of Python slice syntax.
    For example, this would actually execute the query in order to return a list of
    every *second* object of the first 10:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，对`QuerySet`进行切片会返回一个新的`QuerySet`-它不会评估查询。一个例外是如果您使用Python切片语法的步长参数。例如，这实际上会执行查询，以返回前10个对象中每*第二个*对象的列表：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To retrieve a *single* object rather than a list (for example, `SELECT foo FROM
    bar LIMIT 1`), use a simple index instead of a slice.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索*单个*对象而不是列表（例如，`SELECT foo FROM bar LIMIT 1`），请使用简单的索引而不是切片。
- en: 'For example, this returns the first `Entry` in the database, after ordering
    entries alphabetically by headline:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这将按标题字母顺序返回数据库中的第一个`Entry`：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is roughly equivalent to:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致相当于：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note, however, that the first of these will raise `IndexError` while the second
    will raise `DoesNotExist` if no objects match the given criteria. See `get()`
    for more details.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 但是请注意，如果没有对象符合给定的条件，第一个将引发`IndexError`，而第二个将引发`DoesNotExist`。有关更多详细信息，请参见`get()`。
- en: Field lookups
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段查找
- en: 'Field lookups are how you specify the meat of an SQL `WHERE` clause. They''re
    specified as keyword arguments to the `QuerySet` methods `filter()`, `exclude()`,
    and `get()`. Basic lookups keyword arguments take the form `field__lookuptype=value`.
    (That''s a double-underscore). For example:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 字段查找是指定SQL `WHERE`子句的主要方式。它们被指定为`QuerySet`方法`filter()`、`exclude()`和`get()`的关键字参数。（这是一个双下划线）。例如：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'translates (roughly) into the following SQL:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 翻译（大致）成以下SQL：
- en: '[PRE18]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The field specified in a lookup has to be the name of a model field. There''s
    one exception though, in case of a `ForeignKey` you can specify the field name
    suffixed with `_id`. In this case, the value parameter is expected to contain
    the raw value of the foreign model''s primary key. For example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查找中指定的字段必须是模型字段的名称。不过有一个例外，在`ForeignKey`的情况下，可以指定带有`_id`后缀的字段名。在这种情况下，值参数预期包含外键模型主键的原始值。例如：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If you pass an invalid keyword argument, a lookup function will raise `TypeError`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递了无效的关键字参数，查找函数将引发`TypeError`。
- en: 'The complete list of field lookups are:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 字段查找的完整列表如下：
- en: '`exact`'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`精确的`'
- en: '`iexact`'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`忽略大小写的精确的`'
- en: '`contains`'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包含`'
- en: '`icontains`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`包含`'
- en: '`in`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`在…中`'
- en: '`gt`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大于`'
- en: '`gte`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`大于或等于`'
- en: '`lt`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`小于`'
- en: '`lte`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`小于或等于`'
- en: '`startswith`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以…开头`'
- en: '`istartswith`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以…开头`'
- en: '`endswith`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以…结尾`'
- en: '`iendswith`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`以…结尾`'
- en: '`range`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`范围`'
- en: '`year`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`年`'
- en: '`month`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`月`'
- en: '`day`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`天`'
- en: '`week_day`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`星期几`'
- en: '`hour`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`小时`'
- en: '`minute`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`分钟`'
- en: '`second`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`秒`'
- en: '`isnull`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`为空`'
- en: '`search`'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`搜索`'
- en: '`regex`'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`正则表达式`'
- en: '`iregex`'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iregex`'
- en: A complete reference, including examples for each field lookup can be found
    in the field lookup reference at [https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups](https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在字段查找参考中找到每个字段查找的完整参考和示例[https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups](https://docs.djangoproject.com/en/1.8/ref/models/querysets/#field-lookups)。
- en: Lookups that span relationships
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跨关系的查找
- en: Django offers a powerful and intuitive way to follow relationships in lookups,
    taking care of the SQL `JOIN`s for you automatically, behind the scenes. To span
    a relationship, just use the field name of related fields across models, separated
    by double underscores, until you get to the field you want.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一种强大且直观的方式来在查找中跟踪关系，自动在幕后为您处理SQL `JOIN`。要跨越关系，只需使用跨模型的相关字段的字段名称，用双下划线分隔，直到您找到想要的字段。
- en: 'This example retrieves all `Entry` objects with a `Blog` whose `name` is `''Beatles
    Blog''`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子检索所有`name`为`'Beatles Blog'`的`Blog`对象的`Entry`对象：
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This spanning can be as deep as you'd like.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这种跨度可以深入到您想要的程度。
- en: It works backwards, too. To refer to a reverse relationship, just use the lowercase
    name of the model.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以反向操作。要引用反向关系，只需使用模型的小写名称。
- en: 'This example retrieves all `Blog` objects which have at least one `Entry` whose
    `headline` contains `''Lennon''`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子检索所有至少有一个`Entry`的`headline`包含`'Lennon'`的`Blog`对象：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you are filtering across multiple relationships and one of the intermediate
    models doesn''t have a value that meets the filter condition, Django will treat
    it as if there is an empty (all values are `NULL`), but valid, object there. All
    this means is that no error will be raised. For example, in this filter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在多个关系中进行过滤，并且中间模型之一没有满足过滤条件的值，Django将把它视为一个空（所有值都为`NULL`），但有效的对象。这只意味着不会引发错误。例如，在这个过滤器中：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '(if there was a related `Author` model), if there was no `author` associated
    with an entry, it would be treated as if there was also no `name` attached, rather
    than raising an error because of the missing `author`. Usually this is exactly
    what you want to have happen. The only case where it might be confusing is if
    you are using `isnull`. Thus:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: （如果有一个相关的`Author`模型），如果一个条目没有与作者相关联，它将被视为没有附加名称，而不是因为缺少作者而引发错误。通常这正是您希望发生的。唯一可能令人困惑的情况是如果您使用`isnull`。因此：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'will return `Blog` objects that have an empty `name` on the `author` and also
    those which have an empty `author` on the `entry`. If you don''t want those latter
    objects, you could write:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回在`author`上有一个空的`name`的`Blog`对象，以及在`entry`上有一个空的`author`的`Blog`对象。如果您不想要后者的对象，您可以这样写：
- en: '[PRE24]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Spanning multi-valued relationships
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨多值关系
- en: When you are filtering an object based on a `ManyToManyField` or a reverse `ForeignKey`,
    there are two different sorts of filter you may be interested in. Consider the
    `Blog`/`Entry` relationship (`Blog` to `Entry` is a one-to-many relation). We
    might be interested in finding blogs that have an entry which has both `Lennon`
    in the headline and was published in 2008.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当您基于`ManyToManyField`或反向`ForeignKey`对对象进行过滤时，可能会对两种不同类型的过滤感兴趣。考虑`Blog`/`Entry`关系（`Blog`到`Entry`是一对多关系）。我们可能对找到有一个条目既在标题中有`Lennon`又在2008年发布的博客感兴趣。
- en: Or we might want to find blogs that have an entry with `Lennon` in the headline
    as well as an entry that was published in 2008\. Since there are multiple entries
    associated with a single `Blog`, both of these queries are possible and make sense
    in some situations.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可能想要找到博客中有一个标题中带有`Lennon`的条目以及一个在2008年发布的条目。由于一个`Blog`关联多个条目，这两个查询都是可能的，并且在某些情况下是有意义的。
- en: The same type of situation arises with a `ManyToManyField`. For example, if
    an `Entry` has a `ManyToManyField` called `tags`, we might want to find entries
    linked to tags called `music` and `bands` or we might want an entry that contains
    a tag with a name of `music` and a status of `public`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ManyToManyField`相同类型的情况也会出现。例如，如果`Entry`有一个名为`tags`的`ManyToManyField`，我们可能想要找到链接到名称为`music`和`bands`的标签的条目，或者我们可能想要一个包含名称为`music`和状态为`public`的标签的条目。
- en: To handle both of these situations, Django has a consistent way of processing
    `filter()` and `exclude()` calls. Everything inside a single `filter()` call is
    applied simultaneously to filter out items matching all those requirements.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这两种情况，Django有一种一致的处理`filter()`和`exclude()`调用的方式。单个`filter()`调用中的所有内容同时应用于过滤掉符合所有这些要求的项目。
- en: Successive `filter()` calls further restrict the set of objects, but for multi-valued
    relations, they apply to any object linked to the primary model, not necessarily
    those objects that were selected by an earlier `filter()` call.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 连续的`filter()`调用进一步限制对象集，但对于多值关系，它们适用于与主要模型链接的任何对象，不一定是由先前的`filter()`调用选择的对象。
- en: 'That may sound a bit confusing, so hopefully an example will clarify. To select
    all blogs that contain entries with both `Lennon` in the headline and that were
    published in 2008 (the same entry satisfying both conditions), we would write:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来有点混乱，所以希望通过一个例子来澄清。要选择包含标题中都有`Lennon`并且在2008年发布的条目的所有博客（同时满足这两个条件的相同条目），我们将写：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To select all blogs that contain an entry with `Lennon` in the headline as
    well as an entry that was published in 2008, we would write:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要选择包含标题中有`Lennon`的条目以及2008年发布的条目的所有博客，我们将写：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Suppose there is only one blog that had both entries containing `Lennon` and
    entries from 2008, but that none of the entries from 2008 contained `Lennon`.
    The first query would not return any blogs, but the second query would return
    that one blog.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 假设只有一个博客既包含`Lennon`的条目，又包含2008年的条目，但2008年的条目中没有包含`Lennon`。第一个查询将不会返回任何博客，但第二个查询将返回那一个博客。
- en: In the second example, the first filter restricts the queryset to all those
    blogs linked to entries with `Lennon` in the headline. The second filter restricts
    the set of blogs *further* to those that are also linked to entries that were
    published in 2008.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个例子中，第一个过滤器将查询集限制为所有链接到标题中有`Lennon`的条目的博客。第二个过滤器将进一步将博客集限制为那些还链接到2008年发布的条目的博客。
- en: The entries selected by the second filter may or may not be the same as the
    entries in the first filter. We are filtering the `Blog` items with each filter
    statement, not the `Entry` items.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个过滤器选择的条目可能与第一个过滤器中的条目相同，也可能不同。我们正在使用每个过滤器语句过滤`Blog`项，而不是`Entry`项。
- en: 'All of this behavior also applies to `exclude()`: all the conditions in a single
    `exclude()` statement apply to a single instance (if those conditions are talking
    about the same multi-valued relation). Conditions in subsequent `filter()` or
    `exclude()` calls that refer to the same relation may end up filtering on different
    linked objects.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些行为也适用于`exclude()`：单个`exclude()`语句中的所有条件都适用于单个实例（如果这些条件涉及相同的多值关系）。后续`filter()`或`exclude()`调用中涉及相同关系的条件可能最终会过滤不同的链接对象。
- en: Filters can reference fields on the model
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤器可以引用模型上的字段
- en: In the examples given so far, we have constructed filters that compare the value
    of a model field with a constant. But what if you want to compare the value of
    a model field with another field on the same model?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止给出的例子中，我们已经构建了比较模型字段值与常量的过滤器。但是，如果您想要比较模型字段的值与同一模型上的另一个字段呢？
- en: Django provides `F expressions` to allow such comparisons. Instances of `F()`
    act as a reference to a model field within a query. These references can then
    be used in query filters to compare the values of two different fields on the
    same model instance.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了`F表达式`来允许这样的比较。`F()`的实例充当查询中模型字段的引用。然后可以在查询过滤器中使用这些引用来比较同一模型实例上两个不同字段的值。
- en: 'For example, to find a list of all blog entries that have had more comments
    than pingbacks, we construct an `F()` object to reference the pingback count,
    and use that `F()` object in the query:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要查找所有博客条目中评论比pingbacks多的条目列表，我们构建一个`F()`对象来引用pingback计数，并在查询中使用该`F()`对象：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Django supports the use of addition, subtraction, multiplication, division,
    modulo, and power arithmetic with `F()` objects, both with constants and with
    other `F()` objects. To find all the blog entries with more than *twice* as many
    comments as pingbacks, we modify the query:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Django支持使用`F()`对象进行加法、减法、乘法、除法、取模和幂运算，既可以与常量一起使用，也可以与其他`F()`对象一起使用。要查找所有评论比pingbacks多*两倍*的博客条目，我们修改查询：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To find all the entries where the rating of the entry is less than the sum
    of the pingback count and comment count, we would issue the query:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要查找所有评分小于pingback计数和评论计数之和的条目，我们将发出查询：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can also use the double underscore notation to span relationships in an
    `F()` object. An `F()` object with a double underscore will introduce any joins
    needed to access the related object.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用双下划线符号来跨越`F()`对象中的关系。带有双下划线的`F()`对象将引入访问相关对象所需的任何连接。
- en: 'For example, to retrieve all the entries where the author''s name is the same
    as the blog name, we could issue the query:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要检索所有作者名称与博客名称相同的条目，我们可以发出查询：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'For date and date/time fields, you can add or subtract a `timedelta` object.
    The following would return all entries that were modified more than 3 days after
    they were published:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对于日期和日期/时间字段，您可以添加或减去一个`timedelta`对象。以下将返回所有在发布后3天以上修改的条目：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `F()` objects support bitwise operations by `.bitand()` and `.bitor()`,
    for example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`F()`对象支持按位操作，通过`.bitand()`和`.bitor()`，例如：'
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The pk lookup shortcut
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pk查找快捷方式
- en: For convenience, Django provides a `pk` lookup shortcut, which stands for primary
    key.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，Django提供了一个`pk`查找快捷方式，代表主键。
- en: 'In the example `Blog` model, the primary key is the `id` field, so these three
    statements are equivalent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例`Blog`模型中，主键是`id`字段，因此这三个语句是等价的：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The use of `pk` isn''t limited to `__exact` queries-any query term can be combined
    with `pk` to perform a query on the primary key of a model:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`pk`的使用不限于`__exact`查询-任何查询条件都可以与`pk`组合，以对模型的主键执行查询：'
- en: '[PRE34]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`pk` lookups also work across joins. For example, these three statements are
    equivalent:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`pk`查找也适用于连接。例如，这三个语句是等价的：'
- en: '[PRE35]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Escaping percent signs and underscores in LIKE statements
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在LIKE语句中转义百分号和下划线
- en: The field lookups that equate to `LIKE` SQL statements (`iexact`, `contains`,
    `icontains`, `startswith`, `istartswith`, `endswith`, and `iendswith`) will automatically
    escape the two special characters used in `LIKE` statements-the percent sign and
    the underscore. (In a `LIKE` statement, the percent sign signifies a multiple-character
    wildcard and the underscore signifies a single-character wildcard.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 等同于`LIKE` SQL语句的字段查找（`iexact`，`contains`，`icontains`，`startswith`，`istartswith`，`endswith`和`iendswith`）将自动转义`LIKE`语句中使用的两个特殊字符-百分号和下划线。（在`LIKE`语句中，百分号表示多字符通配符，下划线表示单字符通配符。）
- en: 'This means things should work intuitively, so the abstraction doesn''t leak.
    For example, to retrieve all the entries that contain a percent sign, just use
    the percent sign as any other character:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着事情应该直观地工作，所以抽象不会泄漏。例如，要检索包含百分号的所有条目，只需像对待其他字符一样使用百分号：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Django takes care of the quoting for you; the resulting SQL will look something
    like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Django会为您处理引用；生成的SQL将类似于这样：
- en: '[PRE37]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Same goes for underscores. Both percentage signs and underscores are handled
    for you transparently.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 下划线也是一样。百分号和下划线都会被透明地处理。
- en: Caching and querysets
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存和查询集
- en: Each `QuerySet` contains a cache to minimize database access. Understanding
    how it works will allow you to write the most efficient code.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`QuerySet`都包含一个缓存，以最小化数据库访问。了解它的工作原理将使您能够编写最有效的代码。
- en: In a newly created `QuerySet`, the cache is empty. The first time a `QuerySet`
    is evaluated-and, hence, a database query happens-Django saves the query results
    in the `QuerySet` class' cache and returns the results that have been explicitly
    requested (for example, the next element, if the `QuerySet` is being iterated
    over). Subsequent evaluations of the `QuerySet` reuse the cached results.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在新创建的`QuerySet`中，缓存是空的。第一次评估`QuerySet`时-因此，数据库查询发生时-Django会将查询结果保存在`QuerySet`类的缓存中，并返回已经明确请求的结果（例如，如果正在迭代`QuerySet`，则返回下一个元素）。后续的`QuerySet`评估将重用缓存的结果。
- en: 'Keep this caching behavior in mind, because it may bite you if you don''t use
    your `QuerySet` correctly. For example, the following will create two `QuerySet`,
    evaluate them, and throw them away:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住这种缓存行为，因为如果您没有正确使用您的`QuerySet`，它可能会给您带来麻烦。例如，以下操作将创建两个`QuerySet`，对它们进行评估，然后丢弃它们：
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That means the same database query will be executed twice, effectively doubling
    your database load. Also, there's a possibility the two lists may not include
    the same database records, because an `Entry` may have been added or deleted in
    the split second between the two requests.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着相同的数据库查询将被执行两次，有效地增加了数据库负载。此外，两个列表可能不包括相同的数据库记录，因为在两个请求之间的瞬间，可能已经添加或删除了`Entry`。
- en: 'To avoid this problem, simply save the `QuerySet` and reuse it:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，只需保存`QuerySet`并重复使用它：
- en: '[PRE39]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When querysets are not cached
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当查询集没有被缓存时
- en: Querysets do not always cache their results. When evaluating only *part* of
    the queryset, the cache is checked, but if it is not populated then the items
    returned by the subsequent query are not cached. Specifically, this means that
    limiting the queryset using an array slice or an index will not populate the cache.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 查询集并不总是缓存它们的结果。当仅评估查询集的*部分*时，会检查缓存，但如果它没有被填充，那么后续查询返回的项目将不会被缓存。具体来说，这意味着使用数组切片或索引限制查询集将不会填充缓存。
- en: 'For example, repeatedly getting a certain index in a queryset object will query
    the database each time:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，重复获取查询集对象中的某个索引将每次查询数据库：
- en: '[PRE40]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'However, if the entire queryset has already been evaluated, the cache will
    be checked instead:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果整个查询集已经被评估，那么将检查缓存：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here are some examples of other actions that will result in the entire queryset
    being evaluated and therefore populate the cache:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些其他操作的例子，这些操作将导致整个查询集被评估，因此填充缓存：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Complex lookups with Q objects
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Q对象进行复杂的查找
- en: Keyword argument queries-in `filter()`, and others.-are ANDed together. If you
    need to execute more complex queries (for example, queries with `OR` statements),
    you can use `Q objects`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数查询-在`filter()`和其他地方-会被AND在一起。如果您需要执行更复杂的查询（例如带有`OR`语句的查询），您可以使用`Q对象`。
- en: A `Q object` (`django.db.models.Q`) is an object used to encapsulate a collection
    of keyword arguments. These keyword arguments are specified as in Field lookups
    above.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q对象`（`django.db.models.Q`）是一个用于封装一组关键字参数的对象。这些关键字参数如上面的字段查找中所指定的那样。'
- en: 'For example, this `Q` object encapsulates a single `LIKE` query:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个`Q`对象封装了一个单一的`LIKE`查询：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '`Q` objects can be combined using the `&` and `|` operators. When an operator
    is used on two `Q` objects, it yields a new `Q` object.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`Q`对象可以使用`&`和`|`运算符进行组合。当两个`Q`对象上使用运算符时，它会产生一个新的`Q`对象。'
- en: 'For example, this statement yields a single `Q` object that represents the
    OR of two `"question__startswith"` queries:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个语句产生一个代表两个`"question__startswith"`查询的OR的单个`Q`对象：
- en: '[PRE44]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is equivalent to the following SQL `WHERE` clause:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于以下SQL `WHERE`子句：
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can compose statements of arbitrary complexity by combining `Q` objects
    with the `&` and `|` operators and use parenthetical grouping. Also, `Q` objects
    can be negated using the `~` operator, allowing for combined lookups that combine
    both a normal query and a negated (`NOT`) query:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用`&`和`|`运算符组合`Q`对象并使用括号分组来组成任意复杂的语句。此外，`Q`对象可以使用`~`运算符进行否定，从而允许组合查找结合了正常查询和否定（`NOT`）查询：
- en: '[PRE46]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Each lookup function that takes keyword-arguments (for example, `filter()`,
    `exclude()`, `get()`) can also be passed one or more `Q` objects as positional
    (not-named) arguments. If you provide multiple `Q` object arguments to a lookup
    function, the arguments will be ANDed together. For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个接受关键字参数的查找函数（例如`filter()`、`exclude()`、`get()`）也可以作为位置（非命名）参数传递一个或多个`Q`对象。如果向查找函数提供多个`Q`对象参数，则这些参数将被AND在一起。例如：
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '... roughly translates into the SQL:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '...大致翻译成SQL：'
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lookup functions can mix the use of `Q` objects and keyword arguments. All
    arguments provided to a lookup function (be the keyword arguments or `Q` objects)
    are ANDed together. However, if a `Q` object is provided, it must precede the
    definition of any keyword arguments. For example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 查找函数可以混合使用`Q`对象和关键字参数。提供给查找函数的所有参数（无论是关键字参数还是`Q`对象）都会被AND在一起。但是，如果提供了`Q`对象，它必须在任何关键字参数的定义之前。例如：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '... would be a valid query, equivalent to the previous example; but:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '...将是一个有效的查询，等同于前面的示例；但是：'
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '... would not be valid.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '...将无效。'
- en: Comparing objects
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较对象
- en: 'To compare two model instances, just use the standard Python comparison operator,
    the double equals sign: `==`. Behind the scenes, that compares the primary key
    values of two models.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要比较两个模型实例，只需使用标准的Python比较运算符，双等号：`==`。在幕后，这比较了两个模型的主键值。
- en: 'Using the `Entry` example above, the following two statements are equivalent:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的`Entry`示例，以下两个语句是等价的：
- en: '[PRE51]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If a model''s primary key isn''t called `id`, no problem. Comparisons will
    always use the primary key, whatever it''s called. For example, if a model''s
    primary key field is called `name`, these two statements are equivalent:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型的主键不叫`id`，没问题。比较将始终使用主键，无论它叫什么。例如，如果模型的主键字段叫`name`，这两个语句是等价的：
- en: '[PRE52]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Deleting objects
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除对象
- en: 'The delete method, conveniently, is named `delete()`. This method immediately
    deletes the object and has no return value. Example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 方便地，删除方法被命名为`delete()`。此方法立即删除对象，并且没有返回值。例如：
- en: '[PRE53]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: You can also delete objects in bulk. Every `QuerySet` has a `delete()` method,
    which deletes all members of that `QuerySet`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以批量删除对象。每个`QuerySet`都有一个`delete()`方法，用于删除该`QuerySet`的所有成员。
- en: 'For example, this deletes all `Entry` objects with a `pub_date` year of 2005:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这将删除所有`pub_date`年份为2005的`Entry`对象：
- en: '[PRE54]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Keep in mind that this will, whenever possible, be executed purely in SQL, and
    so the `delete()` methods of individual object instances will not necessarily
    be called during the process. If you've provided a custom `delete()` method on
    a model class and want to ensure that it is called, you will need to manually
    delete instances of that model (for example, by iterating over a `QuerySet` and
    calling `delete()` on each object individually) rather than using the bulk `delete()`
    method of a `QuerySet`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这将在可能的情况下纯粹在SQL中执行，因此在过程中不一定会调用单个对象实例的`delete()`方法。如果您在模型类上提供了自定义的`delete()`方法，并希望确保它被调用，您将需要手动删除该模型的实例（例如，通过迭代`QuerySet`并在每个对象上调用`delete()`）而不是使用`QuerySet`的批量`delete()`方法。
- en: 'When Django deletes an object, by default it emulates the behavior of the SQL
    constraint `ON DELETE CASCADE`-in other words, any objects which had foreign keys
    pointing at the object to be deleted will be deleted along with it. For example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当Django删除一个对象时，默认情况下会模拟SQL约束`ON DELETE CASCADE`的行为-换句话说，任何具有指向要删除的对象的外键的对象都将与其一起被删除。例如：
- en: '[PRE55]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This cascade behavior is customizable via the `on_delete` argument to the `ForeignKey`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此级联行为可以通过`ForeignKey`的`on_delete`参数进行自定义。
- en: 'Note that `delete()` is the only `QuerySet` method that is not exposed on a
    `Manager` itself. This is a safety mechanism to prevent you from accidentally
    requesting `Entry.objects.delete()`, and deleting *all* the entries. If you *do*
    want to delete all the objects, then you have to explicitly request a complete
    query set:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`delete()`是唯一不在`Manager`本身上公开的`QuerySet`方法。这是一个安全机制，可以防止您意外请求`Entry.objects.delete()`，并删除*所有*条目。如果*确实*要删除所有对象，则必须显式请求完整的查询集：
- en: '[PRE56]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Copying model instances
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复制模型实例
- en: 'Although there is no built-in method for copying model instances, it is possible
    to easily create new instance with all fields'' values copied. In the simplest
    case, you can just set `pk` to `None`. Using our blog example:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有内置的方法来复制模型实例，但可以轻松地创建具有所有字段值的新实例。在最简单的情况下，您可以将`pk`设置为`None`。使用我们的博客示例：
- en: '[PRE57]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Things get more complicated if you use inheritance. Consider a subclass of
    `Blog`:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用继承，情况会变得更加复杂。考虑`Blog`的子类：
- en: '[PRE58]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Due to how inheritance works, you have to set both `pk` and `id` to None:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继承的工作原理，您必须将`pk`和`id`都设置为None：
- en: '[PRE59]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This process does not copy related objects. If you want to copy relations,
    you have to write a little bit more code. In our example, `Entry` has a many to
    many field to `Author`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程不会复制相关对象。如果要复制关系，您需要编写更多的代码。在我们的示例中，`Entry`有一个到`Author`的多对多字段：
- en: '[PRE60]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Updating multiple objects at once
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次更新多个对象
- en: 'Sometimes you want to set a field to a particular value for all the objects
    in a `QuerySet`. You can do this with the `update()` method. For example:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您希望为`QuerySet`中的所有对象设置一个特定的值。您可以使用`update()`方法来实现这一点。例如：
- en: '[PRE61]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'You can only set non-relation fields and `ForeignKey` fields using this method.
    To update a non-relation field, provide the new value as a constant. To update
    `ForeignKey` fields, set the new value to be the new model instance you want to
    point to. For example:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 您只能使用此方法设置非关系字段和`ForeignKey`字段。要更新非关系字段，请将新值提供为常量。要更新`ForeignKey`字段，请将新值设置为要指向的新模型实例。例如：
- en: '[PRE62]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The `update()` method is applied instantly and returns the number of rows matched
    by the query (which may not be equal to the number of rows updated if some rows
    already have the new value).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()`方法会立即应用，并返回查询匹配的行数（如果某些行已经具有新值，则可能不等于更新的行数）。'
- en: 'The only restriction on the `QuerySet` that is updated is that it can only
    access one database table, the model''s main table. You can filter based on related
    fields, but you can only update columns in the model''s main table. Example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的`QuerySet`的唯一限制是它只能访问一个数据库表，即模型的主表。您可以基于相关字段进行过滤，但只能更新模型主表中的列。例如：
- en: '[PRE63]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Be aware that the `update()` method is converted directly to an SQL statement.
    It is a bulk operation for direct updates. It doesn''t run any `save()` methods
    on your models, or emit the `pre_save` or `post_save` signals (which are a consequence
    of calling `save()`), or honor the `auto_now` field option. If you want to save
    every item in a `QuerySet` and make sure that the `save()` method is called on
    each instance, you don''t need any special function to handle that. Just loop
    over them and call `save()`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`update()`方法会直接转换为SQL语句。这是一个用于直接更新的批量操作。它不会运行任何模型的`save()`方法，也不会发出`pre_save`或`post_save`信号（这是调用`save()`的结果），也不会遵守`auto_now`字段选项。如果您想保存`QuerySet`中的每个项目，并确保在每个实例上调用`save()`方法，您不需要任何特殊的函数来处理。只需循环遍历它们并调用`save()`：
- en: '[PRE64]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Calls to update can also use `F expressions` to update one field based on the
    value of another field in the model. This is especially useful for incrementing
    counters based upon their current value. For example, to increment the pingback
    count for every entry in the blog:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对更新的调用也可以使用`F表达式`来根据模型中另一个字段的值更新一个字段。这对于根据其当前值递增计数器特别有用。例如，要为博客中的每个条目递增pingback计数：
- en: '[PRE65]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'However, unlike `F()` objects in filter and exclude clauses, you can''t introduce
    joins when you use `F()` objects in an update-you can only reference fields local
    to the model being updated. If you attempt to introduce a join with an `F()` object,
    a `FieldError` will be raised:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，与在过滤和排除子句中使用`F()`对象不同，当您在更新中使用`F()`对象时，您不能引入连接-您只能引用要更新的模型本地字段。如果尝试使用`F()`对象引入连接，将引发`FieldError`：
- en: '[PRE66]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Related objects
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关对象
- en: When you define a relationship in a model (that is, a `ForeignKey`, `OneToOneField`,
    or `ManyToManyField`), instances of that model will have a convenient API to access
    the related object(s).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在模型中定义关系（即`ForeignKey`、`OneToOneField`或`ManyToManyField`）时，该模型的实例将具有便捷的API来访问相关对象。
- en: 'Using the models at the top of this page, for example, an `Entry` object `e`
    can get its associated `Blog` object by accessing the `blog` attribute: `e.blog`.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本页顶部的模型，例如，`Entry`对象`e`可以通过访问`blog`属性获取其关联的`Blog`对象：`e.blog`。
- en: (Behind the scenes, this functionality is implemented by Python descriptors.
    This shouldn't really matter to you, but I point it out here for the curious.)
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: （在幕后，这个功能是由Python描述符实现的。这对您来说并不重要，但我在这里指出它是为了满足好奇心。）
- en: 'Django also creates API accessors for the other side of the relationship-the
    link from the related model to the model that defines the relationship. For example,
    a `Blog` object `b` has access to a list of all related `Entry` objects via the
    `entry_set` attribute: `b.entry_set.all()`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Django还为关系的另一侧创建了API访问器-从相关模型到定义关系的模型的链接。例如，`Blog`对象`b`通过`entry_set`属性可以访问所有相关的`Entry`对象的列表：`b.entry_set.all()`。
- en: All examples in this section use the sample `Blog`, `Author` and `Entry` models
    defined at the top of this page.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有示例都使用本页顶部定义的示例`Blog`、`Author`和`Entry`模型。
- en: One-to-many relationships
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对多关系
- en: Forward
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 前向
- en: 'If a model has a `ForeignKey`, instances of that model will have access to
    the related (foreign) object via a simple attribute of the model. For example:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型具有`ForeignKey`，则该模型的实例将可以通过模型的简单属性访问相关（外键）对象。例如：
- en: '[PRE67]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'You can get and set via a foreign-key attribute. As you may expect, changes
    to the foreign key aren''t saved to the database until you call `save()`. Example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过外键属性进行获取和设置。正如您可能期望的那样，对外键的更改直到调用`save()`之前都不会保存到数据库。例如：
- en: '[PRE68]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If a `ForeignKey` field has `null=True` set (that is, it allows `NULL` values),
    you can assign `None` to remove the relation. Example:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ForeignKey`字段设置了`null=True`（即允许`NULL`值），则可以分配`None`来删除关系。例如：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Forward access to one-to-many relationships is cached the first time the related
    object is accessed. Subsequent accesses to the foreign key on the same object
    instance are cached. Example:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次访问相关对象时，可以缓存对一对多关系的前向访问。对同一对象实例上的外键的后续访问将被缓存。例如：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Note that the `select_related()` `QuerySet` method recursively prepopulates
    the cache of all one-to-many relationships ahead of time. Example:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`select_related()` `QuerySet` 方法会预先递归填充所有一对多关系的缓存。例如：
- en: '[PRE71]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Following relationships backward
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向后跟踪关系
- en: If a model has a `ForeignKey`, instances of the foreign-key model will have
    access to a `Manager` that returns all instances of the first model. By default,
    this `Manager` is named `foo_set`, where `foo` is the source model name, lowercased.
    This `Manager` returns `QuerySets`, which can be filtered and manipulated as described
    in the Retrieving objects section above.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模型具有`ForeignKey`，则外键模型的实例将可以访问返回第一个模型的所有实例的`Manager`。默认情况下，此`Manager`命名为`foo_set`，其中`foo`是源模型名称的小写形式。此`Manager`返回`QuerySets`，可以像上面的检索对象部分中描述的那样进行过滤和操作。
- en: 'Example:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE72]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can override the `foo_set` name by setting the `related_name` parameter
    in the `ForeignKey` definition. For example, if the `Entry` model was altered
    to `blog = ForeignKey(Blog, related_name=''entries'')`, the above example code
    would look like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`ForeignKey`定义中设置`related_name`参数来覆盖`foo_set`名称。例如，如果`Entry`模型被修改为`blog
    = ForeignKey(Blog, related_name='entries')`，上面的示例代码将如下所示：
- en: '[PRE73]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Using a custom reverse manager
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义反向管理器
- en: 'By default, the `RelatedManager` used for reverse relations is a subclass of
    the default manager for that model. If you would like to specify a different manager
    for a given query you can use the following syntax:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，用于反向关系的`RelatedManager`是该模型的默认管理器的子类。如果您想为给定查询指定不同的管理器，可以使用以下语法：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: If `EntryManager` performed default filtering in its `get_queryset()` method,
    that filtering would apply to the `all()` call.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`EntryManager`在其`get_queryset()`方法中执行默认过滤，则该过滤将应用于`all()`调用。
- en: 'Of course, specifying a custom reverse manager also enables you to call its
    custom methods:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，指定自定义的反向管理器也使您能够调用其自定义方法：
- en: '[PRE75]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Additional methods to handle related objects
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理相关对象的附加方法
- en: 'In addition to the `QuerySet` methods defined in *Retrieving objects* earlier,
    the `ForeignKey` `Manager` has additional methods used to handle the set of related
    objects. A synopsis of each is as follows (complete details can be found in the
    related objects reference at [https://docs.djangoproject.com/en/1.8/ref/models/relations/#related-objects-reference](https://docs.djangoproject.com/en/1.8/ref/models/relations/#related-objects-reference)):'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前*检索对象*中定义的`QuerySet`方法之外，`ForeignKey` `Manager`还有其他用于处理相关对象集合的方法。每个方法的概要如下（完整详情可以在相关对象参考中找到[https://docs.djangoproject.com/en/1.8/ref/models/relations/#related-objects-reference](https://docs.djangoproject.com/en/1.8/ref/models/relations/#related-objects-reference)）：
- en: '`add(obj1, obj2, ...)` Adds the specified model objects to the related object
    set'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`add(obj1, obj2, ...)` 将指定的模型对象添加到相关对象集合'
- en: '`create(**kwargs)` Creates a new object, saves it and puts it in the related
    object set. Returns the newly created object'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create(**kwargs)` 创建一个新对象，保存它并将其放入相关对象集合中。返回新创建的对象'
- en: '`remove(obj1, obj2, ...)` Removes the specified model objects from the related
    object set'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(obj1, obj2, ...)` 从相关对象集合中删除指定的模型对象'
- en: '`clear()` Removes all objects from the related object set'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clear()` 从相关对象集合中删除所有对象'
- en: '`set(objs)` Replace the set of related objects'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(objs)` 替换相关对象的集合'
- en: 'To assign the members of a related set in one fell swoop, just assign to it
    from any iterable object. The iterable can contain object instances, or just a
    list of primary key values. For example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性分配相关集合的成员，只需从任何可迭代对象中分配给它。可迭代对象可以包含对象实例，也可以只是主键值的列表。例如：
- en: '[PRE76]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this example, `e1` and `e2` can be full Entry instances, or integer primary
    key values.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`e1`和`e2`可以是完整的Entry实例，也可以是整数主键值。
- en: If the `clear()` method is available, any pre-existing objects will be removed
    from the `entry_set` before all objects in the iterable (in this case, a list)
    are added to the set. If the `clear()` method is *not* available, all objects
    in the iterable will be added without removing any existing elements.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clear()`方法可用，那么在将可迭代对象（在本例中是一个列表）中的所有对象添加到集合之前，`entry_set`中的任何现有对象都将被移除。如果`clear()`方法*不*可用，则将添加可迭代对象中的所有对象，而不会移除任何现有元素。
- en: Each reverse operation described in this section has an immediate effect on
    the database. Every addition, creation and deletion is immediately and automatically
    saved to the database.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中描述的每个反向操作都会立即对数据库产生影响。每次添加、创建和删除都会立即自动保存到数据库中。
- en: Many-to-many relationships
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多对多关系
- en: Both ends of a many-to-many relationship get automatic API access to the other
    end. The API works just as a backward one-to-many relationship, above.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 多对多关系的两端都自动获得对另一端的API访问权限。API的工作方式与上面的反向一对多关系完全相同。
- en: 'The only difference is in the attribute naming: The model that defines the
    `ManyToManyField` uses the attribute name of that field itself, whereas the reverse
    model uses the lowercased model name of the original model, plus `''_set''` (just
    like reverse one-to-many relationships).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别在于属性命名：定义`ManyToManyField`的模型使用该字段本身的属性名称，而反向模型使用原始模型的小写模型名称，再加上`'_set'`（就像反向一对多关系一样）。
- en: 'An example makes this easier to understand:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子可以更容易理解：
- en: '[PRE77]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Like `ForeignKey`, `ManyToManyField` can specify `related_name`. In the above
    example, if the `ManyToManyField` in `Entry` had specified `related_name='entries'`,
    then each `Author` instance would have an `entries` attribute instead of `entry_set`.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 与`ForeignKey`一样，`ManyToManyField`可以指定`related_name`。在上面的例子中，如果`Entry`中的`ManyToManyField`指定了`related_name='entries'`，那么每个`Author`实例将具有一个`entries`属性，而不是`entry_set`。
- en: One-to-one relationships
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一对一关系
- en: One-to-one relationships are very similar to many-to-one relationships. If you
    define a `OneToOneField` on your model, instances of that model will have access
    to the related object via a simple attribute of the model.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系与多对一关系非常相似。如果在模型上定义了`OneToOneField`，那么该模型的实例将通过模型的简单属性访问相关对象。
- en: 'For example:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE78]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The difference comes in reverse queries. The related model in a one-to-one
    relationship also has access to a `Manager` object, but that `Manager` represents
    a single object, rather than a collection of objects:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于反向查询。一对一关系中的相关模型也可以访问`Manager`对象，但该`Manager`代表单个对象，而不是一组对象：
- en: '[PRE79]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: If no object has been assigned to this relationship, Django will raise a `DoesNotExist`
    exception.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有对象分配给这个关系，Django将引发`DoesNotExist`异常。
- en: 'Instances can be assigned to the reverse relationship in the same way as you
    would assign the forward relationship:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实例可以被分配到反向关系，就像你分配正向关系一样：
- en: '[PRE80]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Queries over related objects
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 涉及相关对象的查询
- en: Queries involving related objects follow the same rules as queries involving
    normal value fields. When specifying the value for a query to match, you may use
    either an object instance itself, or the primary key value for the object.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及相关对象的查询遵循涉及正常值字段的查询相同的规则。在指定要匹配的查询值时，您可以使用对象实例本身，也可以使用对象的主键值。
- en: 'For example, if you have a Blog object `b` with `id=5`, the following three
    queries would be identical:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一个`id=5`的Blog对象`b`，那么以下三个查询将是相同的：
- en: '[PRE81]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Falling back to raw SQL
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回退到原始SQL
- en: If you find yourself needing to write an SQL query that is too complex for Django's
    database-mapper to handle, you can fall back on writing SQL by hand.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己需要编写一个对Django的数据库映射器处理过于复杂的SQL查询，你可以回退到手动编写SQL。
- en: Finally, it's important to note that the Django database layer is merely an
    interface to your database. You can access your database via other tools, programming
    languages or database frameworks; there's nothing Django-specific about your database.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，重要的是要注意，Django数据库层只是与您的数据库交互的接口。您可以通过其他工具、编程语言或数据库框架访问您的数据库；您的数据库与Django无关。
