- en: Chapter 4. Building an Application Like Twitter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。构建类似Twitter的应用程序
- en: In the previous chapters, we learned about better ways to write our code. Keeping
    those points in mind, it is high time that we get started with real Django project
    development and learn about views, models, and templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了编写代码的更好方法。牢记这些要点，现在是时候开始真正的Django项目开发，并了解视图、模型和模板。
- en: The first part of each section in this chapter will be about the basics and
    how things work in the particular subject it deals with. This will include proper
    practices, standard methods, and important terminology.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中每个部分的第一部分将介绍基础知识以及特定主题中的工作原理。这将包括适当的实践、标准方法和重要术语。
- en: The second part of each section will be the application of that concept in our
    mytweets Django application development. The first parts can be thought of as
    chapter descriptions of the subjects and the second parts as exercises in the
    form of our Django project, which is really going to be a unique learning experience.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分的第二部分将是我们的mytweets Django应用程序开发中该概念的应用。第一部分可以被视为主题的章节描述，第二部分可以被视为我们的Django项目形式的练习，这将是一个独特的学习体验。
- en: 'The following topics are covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: A word about Django terminology
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Django术语的说明
- en: Setting up the Basic Template Application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置基本模板应用程序
- en: Creating Django's template structure of the project
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Django项目的模板结构
- en: Setting up the basic bootstrap for the Application
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用程序的基本引导
- en: Creating the Main Page
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建主页
- en: Introduction to class-based views
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍基于类的视图
- en: Django settings for our mytweets project
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的mytweets项目的Django设置
- en: Generating user pages
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成用户页面
- en: Designing an initial database schema
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计初始数据库模式
- en: User registration and account management
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户注册和账户管理
- en: Creating a template for the Main Page
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为主页创建模板
- en: A word about Django terminology
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Django术语的说明
- en: Django is an MVC framework. However, throughout the code, the controller is
    called **view**, and the view is called **template**. The view in Django is the
    component which retrieves and manipulates the data, whereas the template is the
    component that presents data to the user. For this reason, Django is sometimes
    called a **Model Template View** (**MTV**) framework. This different terminology
    neither changes the fact that Django is an MVC framework, nor does it affect how
    applications are developed, but keep the terminology in mind to avoid possible
    confusion if you have worked with other MVC frameworks in the past.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Django是一个MVC框架。但是，在整个代码中，控制器被称为**视图**，视图被称为**模板**。Django中的视图是检索和操作数据的组件，而模板是向用户呈现数据的组件。因此，有时称Django为**模型模板视图**（**MTV**）框架。这种不同的术语既不改变Django是一个MVC框架的事实，也不影响应用程序的开发方式，但请记住这些术语，以避免可能的混淆，如果您以前使用过其他MVC框架。
- en: You can think of this chapter as an in-depth tour of the main Django components.
    You will learn how to create dynamic pages using views, how to store and manage
    data in the database using models, and how to simplify page generation using templates.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将本章视为主要Django组件的深入介绍。您将学习如何使用视图创建动态页面，如何使用模型存储和管理数据库中的数据，以及如何使用模板简化页面生成。
- en: While learning about these features, you will form a solid idea of how Django
    components work and interact with each other. Later chapters will explore these
    components more deeply, as we develop more features and add them to our application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习这些功能的同时，您将对Django组件如何工作和相互交互形成一个坚实的理解。随后的章节将更深入地探讨这些组件，因为我们开发更多功能并将它们添加到我们的应用程序中。
- en: Setting up a basic template application
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置基本模板应用程序
- en: Our project is going to be a microblogging site, where there will be a public
    page for every user, which will have a timeline of the tweets they have posted.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目将是一个微博网站，每个用户都将有一个公共页面，其中将显示他们发布的时间轴。
- en: The first thing that comes to mind after seeing the welcome page of the development
    server is to ask how we can change it. To create our own welcome page, we need
    to define an entry point to our application in the form of a URL and tell Django
    to call a particular Python function when a visitor accesses this URL. We will
    write this Python function ourselves and make it display our own welcome message.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在看到开发服务器的欢迎页面后，首先想到的是如何更改它。要创建我们自己的欢迎页面，我们需要定义一个URL形式的应用程序入口点，并告诉Django在访问此URL时调用特定的Python函数。我们将自己编写这个Python函数，并让它显示我们自己的欢迎消息。
- en: This section basically is a redo of the configuration we did in the previous
    chapter, but the intent is to place all the instructions together here so that
    the project bootstrapping requires fewer page look-ups.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本节基本上是对我们在上一章中进行的配置的重做，但意图是将所有说明放在一起，以便项目引导需要更少的页面查找。
- en: Creating a virtual environment
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建虚拟环境
- en: 'We will set up the virtual environment for Django to work properly by using
    the following command:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令设置Django的虚拟环境，以使其正常工作：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output will be as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We need to activate the virtual environment now and set up all the environment
    variables so that all Python installs will be routed to this environment directory
    without affecting other settings:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要激活虚拟环境并设置所有环境变量，以便所有Python安装都将被路由到此环境目录，而不会影响其他设置：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output will be as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Installing Django
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Django
- en: Although you have already installed Django, we will do this again because Django
    will be managed by `virtualenv`, which can't be messed up by other projects or
    users (or yourself) working elsewhere.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您已经安装了Django，但我们将再次进行安装，因为Django将由`virtualenv`管理，其他项目或用户（或您自己）在其他地方工作时不会被搞乱。
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You may get an error as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会收到以下错误：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If so, create your virtualenv environment within a path without spaces. It is
    most likely that, in the path to the location where you have created your virtual
    environment, there exists a directory whose name contains a space, for example,
    `/home/ratan/folder name with space$virtualenv django_env`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，请在不带空格的路径中创建您的虚拟环境。很可能，在您创建虚拟环境的位置存在一个包含空格的目录，例如，`/home/ratan/folder name
    with space$virtualenv django_env`。
- en: 'If so, change the directory name to something like the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，请将目录名称更改为以下内容：
- en: '`/home/ratan/folder_name_with_no_space$virtualenv django_env`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`/home/ratan/folder_name_with_no_space$virtualenv django_env`'
- en: We can proceed with the Django installation using the command `pip install django`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命令`pip install django`继续进行Django安装。
- en: 'The output will be as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, before we move to create our Django application, we will make sure Git
    is installed. Use the following command to find out the version of Git that we
    have installed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们开始创建Django应用程序之前，我们将确保Git已安装。使用以下命令查找我们安装的Git版本：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output will be as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This confirms that we have Git installed. Of course you must be wondering whether
    we are going to use version control in this project. The answer is yes: as we
    go along, we will version-control most of the project files.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这证实了我们已安装了Git。当然，你一定想知道我们是否会在这个项目中使用版本控制。答案是肯定的：随着项目的进行，我们将对大部分项目文件进行版本控制。
- en: Creating Django's template structure of the project
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Django项目的模板结构
- en: 'In this section, we will create the structure for the project, for example,
    creating a folder called `mytweets` for our project, installing the required package
    for our project, and so on. Run the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为项目创建结构，例如，为我们的项目创建一个名为`mytweets`的文件夹，安装所需的包等。运行以下命令：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will create the folder called `mytweets`, which we will be using as our
    project directory. In the current folder, we see two subfolders: `environment`
    and `mytweets`. The question right now is whether we are going to version control
    our environment folder. We are not, because those files are very specific to your
    current system. They are not going to help anyone to set up the same environment
    as ours. However, there is another way of doing this in Python: by using the `pip
    freeze` command. This actually takes a snapshot of all the current libraries installed
    in your Django application, and then you can save that list in a text file and
    version control it. Thus your fellow developer can download the same version of
    the libraries. That''s really a Pythonic way of doing it, isn''t it?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建名为`mytweets`的文件夹，我们将使用它作为我们的项目目录。在当前文件夹中，我们看到两个子文件夹：`environment`和`mytweets`。现在的问题是我们是否要对我们的环境文件夹进行版本控制。我们不会，因为这些文件非常特定于您当前的系统。它们不会帮助任何人设置与我们相同的环境。然而，在Python中还有另一种方法：使用`pip
    freeze`命令。这实际上会拍摄您的Django应用程序中当前安装的所有库的快照，然后您可以将该列表保存在文本文件中并进行版本控制。因此，您的同事开发人员可以下载相同版本的库。这真的是一种Pythonic的做法，不是吗？
- en: 'The most common method for you to install the new packages is by using the
    `pip` command. There are the three versions of the `pip install` command, they
    are as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 您安装新包的最常见方法是使用`pip`命令。`pip install`命令有三个版本，如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This is the default and installs the latest version of the package:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这是默认设置，并安装包的最新版本：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Using the `==` parameter, you can install a specific version of the package.
    In this case, that is 1.0.4\. Use the following command to install the package
    with a version number:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`==`参数，您可以安装特定版本的包。在这种情况下，即1.0.4。使用以下命令安装带有版本号的包：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Use the above command when you are not sure of the package version you are going
    to install but have an idea that you need the minimum version of the library.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不确定要安装的包版本但有一个想法需要库的最低版本时，请使用上述命令。
- en: 'It is very easy to use the `pip` command to install the libraries. You can
    do this by just typing the following into the command line:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`pip`命令安装库非常容易。您只需在命令行中输入以下内容即可：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now we need to freeze the libraries from the current project:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要冻结当前项目的库：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This command freezes the current libraries installed in the project along with
    the version number, if specified, and stores them in a file named `requirements.txt`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会冻结项目中当前安装的库以及版本号（如果指定），并将它们存储在名为`requirements.txt`的文件中。
- en: At this stage of our project, `pip freeze` command will look something like
    this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们项目的这个阶段，`pip freeze`命令将看起来像这样。
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To install these libraries back to your fresh environment along with the project,
    we can run the following command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要将这些库与项目一起安装回您的新环境中，我们可以运行以下命令：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Thus we can proceed with initializing only our code directory as a Git repository
    and changing the current path to `$cd mytweets`. Execute the following command
    to build a Git repository in your project folder:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以继续初始化我们的代码目录作为Git仓库，并将当前路径更改为`$cd mytweets`。执行以下命令在项目文件夹中构建Git仓库：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output will be as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If we run all commands on a Linux-based system for detailed directory listing
    we can see the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在基于Linux的系统上运行所有命令以获取详细的目录列表，我们可以看到以下输出：
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is the `.git` folder, which, as by its naming convention (starting with
    a dot), is hidden from the normal listing of the directory, that is, the directory
    where all Git-related files such as branches, commits, logs, and so on are stored.
    Deleting that particular directory will make your directory Git-free (free of
    version control) and as normal as any other directory in your current system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`.git`文件夹，根据其命名约定（以点开头），它在目录的正常列表中是隐藏的，即存储所有Git相关文件（如分支、提交、日志等）的目录。删除该特定目录将使您的目录无Git（无版本控制）并且与您当前系统中的任何其他目录一样正常。
- en: 'We can add all our current files in the directory to the staging area by using
    the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令将当前目录中的所有文件添加到暂存区：
- en: '[PRE20]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Use the following command for our first commit of the project:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令进行项目的第一次提交：
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output will be as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The first line (here, its master) says that we are in the master's branch and
    the others that follow are the files being committed.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行（这里是主分支）表示我们在主分支中，接下来的是被提交的文件。
- en: 'So far, we have set up the basic Django template and added it to our version
    control. The same thing can be verified with the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经设置了基本的Django模板并将其添加到了版本控制中。可以使用以下命令验证相同的事情：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output will be as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Instructions on setting up the author and generating `SSH` keys for a remote
    repository push can be found at the following links:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设置作者和为远程存储库推送生成`SSH`密钥的说明，请参阅以下链接：
- en: '[https://help.github.com/articles/set-up-git](https://help.github.com/articles/set-up-git)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://help.github.com/articles/set-up-git](https://help.github.com/articles/set-up-git)'
- en: '[https://help.github.com/articles/generating-ssh-keys](https://help.github.com/articles/generating-ssh-keys)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://help.github.com/articles/generating-ssh-keys](https://help.github.com/articles/generating-ssh-keys)'
- en: Setting up the basic Twitter Bootstrap for the application
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为应用程序设置基本的Twitter Bootstrap
- en: As introduced in the previous chapter, bootstrap is the basic framework for
    the user interface design. We will proceed with the second method mentioned, that
    is, by manually downloading the bootstrap files and linking them in the static
    folder.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章介绍的，bootstrap是用户界面设计的基本框架。我们将继续使用前面提到的第二种方法，即手动下载bootstrap文件并将其链接到静态文件夹中。
- en: 'The method we are skipping means that we are not going to execute the following
    command:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们跳过的方法意味着我们不会执行以下命令：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Detailed documentation for this implementation can be found at [http://django-bootstrap3.readthedocs.org/](http://django-bootstrap3.readthedocs.org/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此实现的详细文档，请参阅[http://django-bootstrap3.readthedocs.org/](http://django-bootstrap3.readthedocs.org/)。
- en: The method that we will be following is that of downloading the bootstrap files
    and placing them in the static folder of our project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要遵循的方法是下载bootstrap文件并将其放置在项目的静态文件夹中。
- en: 'To start with bootstrap, we have to start by downloading the static files from
    the following official bootstrap web address:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用bootstrap，我们必须从以下官方bootstrap网址下载静态文件：
- en: '[http://getbootstrap.com/](http://getbootstrap.com/)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://getbootstrap.com/](http://getbootstrap.com/)'
- en: 'When you visit this link, you will find a download button. After clicking on
    **Download**, click on **Download Bootstrap**. This will give you the bootstrap
    resource files in zipped format. This downloaded file will have a name something
    like `bootstrap-3.2.0-dist.zip`. Extract the content of this zip file. After extraction,
    the folder `bootstrap-3.2.0-dist` will have a structure as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当您访问此链接时，您将找到一个下载按钮。单击**下载**，然后单击**下载Bootstrap**。这将以压缩格式提供bootstrap资源文件。下载的文件将具有类似`bootstrap-3.2.0-dist.zip`的名称。解压此zip文件的内容。解压后，文件夹`bootstrap-3.2.0-dist`的结构如下：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Application-specific static files are stored in the `static` subdirectory within
    the application.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于应用程序的静态文件存储在应用程序的`static`子目录中。
- en: Django will also look in any directories listed in the `STATICFILES_DIRS` setting.
    Let's update our project settings to specify a static file directory in the `settings.py`
    file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Django还会查找`STATICFILES_DIRS`设置中列出的任何目录。让我们更新项目设置，指定`settings.py`文件中的静态文件目录。
- en: 'We can update our project''s `setting.py` file as follows to use Twitter bootstrap:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更新项目的`setting.py`文件如下以使用Twitter bootstrap：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the `static` variable will be the folder we will be keeping our bootstrap
    files in. We will create the `static` folder inside our current project directory
    and will copy all bootstrap's unzipped files to that folder.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`static`变量将是我们将保存bootstrap文件的文件夹。我们将在当前项目目录内创建`static`文件夹，并将所有解压缩的bootstrap文件复制到该文件夹中。
- en: For development purposes, we will keep most of the settings as there are, for
    example, the default database SQLite; we can later move this while deploying our
    test application to MySQL or any other database of our choice.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 出于开发目的，我们将保持大多数设置不变，例如默认数据库SQLite；稍后在部署测试应用程序到MySQL或我们选择的任何其他数据库时，我们可以将其移动。
- en: Now, before we actually use bootstrap in our projects, there are some underlying
    concepts we must know to understand bootstrap as a front-end framework.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实际在项目中使用bootstrap之前，我们必须了解一些基本概念，以理解bootstrap作为前端框架。
- en: 'Bootstrap designs the web pages based on the grid system, and there are three
    main components of this grid, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Bootstrap基于网格系统设计网页，该网格有三个主要组件，如下：
- en: '**Container**: A container is used for giving a base to the whole web page,
    that is, generally, all the components of the bootstrap will be direct or nested
    child objects of the container. In other words, containers provide the width constraints
    on responsive widths. When the screen resolution changes, it''s the container
    which is changing its width across the device screen. The rows and columns are
    percentage based so they get automatically modified.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：容器用于为整个网页提供基础，通常，bootstrap的所有组件将是容器的直接或嵌套子对象。换句话说，容器为响应式宽度提供宽度约束。当屏幕分辨率更改时，容器会在设备屏幕上改变其宽度。行和列是基于百分比的，因此它们会自动修改。'
- en: 'The container also provides a padding to the contents from browser edges so
    that they do not touch the side of the view area. The default padding is 15 px.
    You never need another container inside a container. The following image shows
    the structure of the container:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 容器还为内容提供了来自浏览器边缘的填充，以便它们不会触及视图区域的边缘。默认填充为15像素。您永远不需要在容器内部放置另一个容器。以下图片显示了容器的结构：
- en: '![Setting up the basic Twitter Bootstrap for the application](img/image00284.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![为应用程序设置基本的Twitter Bootstrap](img/image00284.jpeg)'
- en: '**Row**: A row is placed inside the container and contains the column. The
    hierarchy is `container` | `row` | `column` for bootstrap''s basic design. The
    row also acts like a wrapper for the columns, so in situations where columns are
    getting weird due to their default float left property, keep them separately grouped
    so that this problem is not reflected outside the row.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行**：行放置在容器内并包含列。Bootstrap的基本设计层次结构是`容器` | `行` | `列`。行也像列的包装器一样，因此在列由于默认的左浮动属性而变得奇怪的情况下，保持它们分开分组，以便这个问题不会反映在行外部。'
- en: Rows have 15 px of negative margin on each side, which pushes them out over
    the top of the container's 15 px padding. As a result, they are negated and the
    row touches the edge of the container, the negative margin is overlapped by padding.
    Thus, the row is not pushed by the container's padding. Never use a row outside
    a container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 行两侧有15像素的负边距，这将它们推出容器的15像素填充之上。因此，它们被否定，行与容器的边缘相接触，负边距被填充所覆盖。因此，行不会受到容器填充的推动。永远不要在容器外使用行。
- en: '![Setting up the basic Twitter Bootstrap for the application](img/image00285.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![为应用程序设置基本的Twitter Bootstrap](img/image00285.jpeg)'
- en: '**Column**: Columns have a 15 px padding. This means that the columns actually
    touch the edge of the row, which is already touching the edge of the container
    because of the negation property with the container discussed in the previous
    paragraph.'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**列**：列有15像素的填充。这意味着列实际上与行的边缘相接触，行已经与容器的边缘相接触，因为在前一段讨论的容器的否定属性。'
- en: Columns again have the 15 px padding, so the content of the columns is placed
    15 px away from the view edge of a container.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列再次有15像素的填充，因此列的内容与容器的视图边缘相距15像素。
- en: Therefore, we don't need a special first and last column with padding on the
    left and right. There is now a consistent 15 px gap across all columns.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要特殊的第一列和最后一列，左右都有填充。现在所有列之间都有一个一致的15像素间隙。
- en: Content inside the columns are pushed to the columns location and are also separated
    by 30 px of gutter between them. We can use rows inside the column for nested
    layouts.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列内的内容被推送到列的位置，并且它们之间也被30像素的间距分隔。我们可以在列内部使用行进行嵌套布局。
- en: '![Setting up the basic Twitter Bootstrap for the application](img/image00286.jpeg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![为应用程序设置基本的Twitter Bootstrap](img/image00286.jpeg)'
- en: Never use a column outside of a row.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要在行外使用列。
- en: With these points in mind, we can go ahead and design our first layout.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记这些要点，我们可以继续设计我们的第一个布局。
- en: URLs and views – creating the main page
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: URL和视图 - 创建主页
- en: 'A view in Django terminology is a regular Python function that responds to
    a page request by generating the corresponding page. To write our first Django
    view for the main page, we first need to create a Django application inside our
    project. You can think of an application as a container for views and data models.
    To create it, issue the following command within our `django_mytweets` folder:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django术语中，视图是一个普通的Python函数，通过生成相应的页面来响应页面请求。要为主页编写我们的第一个Django视图，我们首先需要在项目内创建一个Django应用程序。您可以将应用程序视为视图和数据模型的容器。要创建它，请在我们的`django_mytweets`文件夹内发出以下命令：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The syntax of application creation is very similar to that of project creation.
    We used the `startapp` command as the first parameter of the `python manage.py`
    command, and provided `tweets` as the name of our application.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序创建的语法与项目创建的语法非常相似。我们使用`startapp`命令作为`python manage.py`命令的第一个参数，并提供`tweets`作为我们应用程序的名称。
- en: 'After running this command, Django will create a folder named `tweets` inside
    the project folder with these three files:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令后，Django将在项目文件夹内创建一个名为`tweets`的文件夹，其中包含这三个文件：
- en: '`__init__.py`: This file tells Python that `tweets` is a Python package'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`：这个文件告诉Python`tweets`是一个Python包'
- en: '`views.py`: This file will contain our views'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`：这个文件将包含我们的视图'
- en: '`models.py`: This file will contain our data models'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py`：这个文件将包含我们的数据模型'
- en: 'Now let''s create the main page view. We will first create a `template` folder
    inside the project to keep all the HTML files:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建主页视图。我们将首先在项目内创建一个`template`文件夹，以保存所有HTML文件：
- en: '[PRE29]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now create a base HTML file inside it named `base.html` with the following
    content:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在其中创建一个名为`base.html`的基本HTML文件，内容如下：
- en: '[PRE30]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Our directory structure will look something like this now (use the `tree` command
    if you are on Linux OS):'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目录结构现在看起来像这样（如果您使用Linux操作系统，请使用`tree`命令）：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Introduction to class-based views
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍基于类的视图
- en: Class-based views are the new way of defining views in Django. They do not replace
    function-based views. They are just an alternative way to implement views as Python
    objects instead of functions. There are two advantages they have over function-based
    views. With a class-based view, different HTTP requests can be mapped to a different
    function, as opposed to a function-based view where the branching takes place
    based on the `request.method` parameter. Object-oriented techniques can be used
    to reuse the code component, such as **mixins** (multiple inheritance).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于类的视图是在Django中定义视图的新方法。它们不取代基于函数的视图。它们只是一种以Python对象而不是函数实现视图的替代方法。它们有两个优点，优于基于函数的视图。使用基于类的视图，不同的HTTP请求可以映射到不同的函数，而不是基于`request.method`参数进行分支的函数视图。可以使用面向对象的技术来重用代码组件，例如**混入**（多重继承）。
- en: Although we will be using class-based views for our project, to understand the
    exact difference between the two, here we will present the code for both.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将在项目中使用基于类的视图，但为了了解两者之间的确切区别，我们将在这里呈现两者的代码。
- en: We will have to update the `url.py` file of our project so that the `base.html`
    file will be served if the user requests the website.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不得不更新我们项目的`url.py`文件，以便在用户请求网站时提供`base.html`文件。
- en: '**Function-based view**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于函数的视图**：'
- en: 'Update the `view.py` file as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`view.py`文件：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Update the `urls.py` file as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新`urls.py`文件：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the development server by using the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行开发服务器：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We will see a response saying **I am called from a get Request**.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到一个响应，显示**我是从get请求中调用的**。
- en: '**Class-based view**:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于类的视图**：'
- en: 'Update the `views.py` file as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 更新`views.py`文件如下：
- en: '[PRE35]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will also generate the same result on the browser after the development
    server is hit. We will be using class-based views throughout the project.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发服务器被访问后，它也会在浏览器上生成相同的结果。我们将在整个项目中使用基于类的视图。
- en: What we have rendered is just a string, which was kind of simple. We have created
    a `base.html` file in our template folder and will now move ahead with our class-based
    view and render our `base.html` file.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所呈现的只是一个字符串，这有点简单。我们在模板文件夹中创建了一个`base.html`文件，现在将继续使用我们的基于类的视图并呈现我们的`base.html`文件。
- en: 'In Django, there is more than one way to render our page. We can render our
    page using any of these three functions: `render()`, `render_to_response()`, or
    `direct_to_template()`. However, let us first see what the difference between
    them is and which one we should be using:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，有多种方法可以呈现我们的页面。我们可以使用这三个函数中的任何一个来呈现我们的页面：`render()`，`render_to_response()`或`direct_to_template()`。但是，让我们首先看看它们之间的区别以及我们应该使用哪一个：
- en: '`render_to_response(template[, dictionary][, context_instance][, mimetype])`:
    The `render_to_response` command is the standard render function, and to use `RequestContext`,
    we will have to specify `context_instance=RequestContext(request)`.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render_to_response(template[, dictionary][, context_instance][, mimetype])`：`render_to_response`命令是标准的呈现函数，要使用`RequestContext`，我们必须指定`context_instance=RequestContext(request)`。'
- en: '`render(request, template[, dictionary][, context_instance][, content_type][,
    status][, current_app])`. This is the new shortcut for the `render_to_response`
    command and is available from version 1.3 of Django. This will automatically use
    `RequestContext`.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`render(request, template[, dictionary][, context_instance][, content_type][,
    status][, current_app])`。这是`render_to_response`命令的新快捷方式，从Django的1.3版本开始可用。这将自动使用`RequestContext`。'
- en: '`direct_to_template()`: This is a generic view. It automatically uses `RequestContext`
    and all its `context_processor` parameters.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`direct_to_template()`: 这是一个通用视图。它自动使用`RequestContext`和所有它的`context_processor`参数。'
- en: However, the `direct_to_template` command should be avoided as function-based
    generic views are deprecated.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，应该避免使用`direct_to_template`命令，因为基于函数的通用视图已被弃用。
- en: We will choose the second one, the `render()` function, for rendering our `base.html`
    template.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择第二个，`render()`函数，来呈现我们的`base.html`模板。
- en: 'The next step is the inclusion of the template folder in our Django application
    (the template folder we have created with the base file named `base.html`). To
    include the template, we will update the `settings.py` file in the following manner:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在我们的Django应用程序中包含模板文件夹（我们已经创建的带有名为`base.html`的基本文件的模板文件夹）。为了包含模板，我们将以以下方式更新`settings.py`文件：
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This defines the template directory and initializes the basic `TEMPLATE_LOADER`
    parameters.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了模板目录并初始化了基本的`TEMPLATE_LOADER`参数。
- en: Django settings for the mytweets project
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: mytweets项目的Django设置
- en: Let's update the `settings.py` file with the minimal settings that we need for
    our `mytweets` project. Before starting our mytweets application we will add many
    settings which we will see with the following changes. For more information on
    this file, visit [https://docs.djangoproject.com/en/1.6/topics/settings/](https://docs.djangoproject.com/en/1.6/topics/settings/).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用我们`mytweets`项目所需的最小设置更新`settings.py`文件。在启动我们的mytweets应用程序之前，我们将添加许多设置，我们将在以下更改中看到。有关此文件的更多信息，请访问[https://docs.djangoproject.com/en/1.6/topics/settings/](https://docs.djangoproject.com/en/1.6/topics/settings/)。
- en: For the full list of settings and their values, visit [https://docs.djangoproject.com/en/1.6/ref/settings/](https://docs.djangoproject.com/en/1.6/ref/settings/).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 有关设置及其值的完整列表，请访问[https://docs.djangoproject.com/en/1.6/ref/settings/](https://docs.djangoproject.com/en/1.6/ref/settings/)。
- en: 'Update the `settings.py` file of our project with the following content:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下内容更新我们项目的`settings.py`文件：
- en: '[PRE37]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now if we start our development server, our screen will look like the following
    screenshot:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们启动开发服务器，我们的屏幕将如下截图所示：
- en: '![Django settings for the mytweets project](img/image00287.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![mytweets项目的Django设置](img/image00287.jpeg)'
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In our `base.html` file, we have written `class="h1"` instead of `<h1></h1>`.
    This was knowingly done to check at runtime whether the bootstrap files are being
    loaded, that is, with the `Header 1` properties.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`base.html`文件中，我们写了`class="h1"`而不是`<h1></h1>`。这是故意为了在运行时检查是否加载了引导文件，即`Header
    1`属性。
- en: 'As you may have noticed, we haven''t passed any variables to the template,
    which is what roughly differentiates static pages and dynamic pages. Let''s get
    ahead and do that too. All we need is some changes in the `views.py` and `base.html`
    files, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们没有向模板传递任何变量，这大致区分了静态页面和动态页面。让我们继续做这个。我们只需要对`views.py`和`base.html`文件进行一些更改，如下所示：
- en: 'Changes in the `views.py` file:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`文件中的更改：'
- en: '[PRE38]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Changes in the `base.html` file
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`base.html`文件中的更改'
- en: '[PRE39]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We can see how simple it is. All we did is just create a map (called **dictionary**
    in Python) and assigned the `name` property to it as Django and added it in the
    `render()` function as a new parameter. It gets rendered to the base of the HTML
    and is easily called `{{name}}`. When it is rendered, it replaces itself with
    Django.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它有多简单。我们所做的只是创建一个映射（在Python中称为**字典**）并将`name`属性分配给它作为Django，并将其添加到`render()`函数中作为新参数。它被呈现到HTML的基础上，并且可以轻松地调用`{{name}}`。当它被呈现时，它会用Django替换自己。
- en: We will be committing all the changes we have made until now. Before we do that,
    let's create a `.gitignore` file. What this does is, whatever content there is
    in this file (or wildcard for the files that we have written inside the `.gitignore`
    file), it will prevent all of them from committing and will send them to the repository
    server.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提交我们到目前为止所做的所有更改。在这之前，让我们创建一个`.gitignore`文件。它的作用是，无论这个文件中有什么内容（或者我们在`.gitignore`文件中写入的文件的通配符），它都会阻止所有这些内容提交，并将它们发送到存储库服务器。
- en: How does it help? It helps in many important use cases. Suppose we don't want
    to put any local configuration files onto the production server. The `.gitignore`
    file can be a savior in such situations, as also in a case when `.py` files generate
    their `.pyc` files, which are compiled at runtime. We don't need those binary
    files on the server, as they will be separately generated each time the code changes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它如何帮助？它在许多重要的用例中都有帮助。假设我们不想将任何本地配置文件放到生产服务器上。在这种情况下，`.gitignore`文件可以成为救世主，也可以在`.py`文件生成它们的`.pyc`文件时使用，这些文件在运行时被编译。我们不需要在服务器上存储这些二进制文件，因为它们每次代码更改时都会单独生成。
- en: On the Linux command line, just type the `$vim .gitignore` command in the root
    folder of the project directory and write `*.pyc`. Then, save and exit in the
    usual way.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux命令行中，只需在项目目录的根文件夹中键入`$vim .gitignore`命令，然后写入`*.pyc`。然后，以通常的方式保存并退出。
- en: Now, if we execute the `$git status` command, we will not see any file with
    the `.pyc` extension, which means that Git has ignored tracking files that end
    with the `.pyc` extension.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行`$git status`命令，我们将看不到任何扩展名为`.pyc`的文件，这意味着Git已经忽略了以`.pyc`结尾的文件进行跟踪。
- en: 'The result of the `$git status` command is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`$git status`命令的结果如下：'
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is quite clear, as it should be. We have previously committed the `settings.py`
    and `urls.py` files, and now we've made some changes in them and the mentioned
    untracked files are not even added to Git for tracking.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当清楚的，正如应该的。我们之前已经提交了`settings.py`和`urls.py`文件，现在我们对它们进行了一些更改，而提到的未跟踪文件甚至没有被添加到Git进行跟踪。
- en: 'We can use the `git add .` command to add all the changes to the directory.
    However, to avoid any unwanted files being pushed to Git tracking, it is recommended
    that files be added one by one when we are in an advanced phase of development.
    For the current situation, adding files all in one go is fine. To add the required
    file to our project, use the following command:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`git add .`命令将所有更改添加到目录中。但是，为了避免将任何不需要的文件推送到Git跟踪，建议在开发的高级阶段逐个添加文件。对于当前的情况，一次性添加文件是可以的。要将所需的文件添加到我们的项目中，请使用以下命令：
- en: '[PRE41]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output will be as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE42]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Commit the changes with proper messages, such as "*basic bootstrap template
    added*":'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改并附上适当的消息，比如“*添加基本的引导模板*”：
- en: '[PRE43]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output will be as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE44]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Putting it all together – generating user pages
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容放在一起 - 生成用户页面
- en: So far, we have covered a lot of material, such as introduction to the concepts
    of views and templates. In the final section, we will write another view and make
    use of all the information that we have learned so far. This view will display
    a list of all the tweets that belong to a certain user.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了很多材料，比如介绍了视图和模板的概念。在最后一节中，我们将编写另一个视图，并利用到目前为止学到的所有信息。这个视图将显示属于某个用户的所有推文的列表。
- en: Familiarization with the Django models
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉Django模型
- en: Models are the standard Python classes with some added features. They are subclasses
    of `django.db.models.Model`. In the background, an **Object-Relational Mapper**
    (**ORM**) gets bound with these classes and their objects. This makes them communicate
    with the underlying database. ORM is one of the important features of Django,
    without which we will end up writing our own queries (SQL, if its MySQL) to access
    the database content. Each attribute of a model is represented by a database field.
    Without its fields, a model will be just like an empty container, with no meaning
    whatsoever.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是标准的Python类，具有一些附加功能。它们是`django.db.models.Model`的子类。在后台，**对象关系映射器**（**ORM**）与这些类及其对象绑定在一起。这使它们与底层数据库进行通信。ORM是Django的一个重要特性，没有它，我们将不得不编写自己的查询（如果是MySQL，则为SQL）来访问数据库内容。模型的每个属性都由数据库字段表示。没有字段，模型将只是一个空容器，毫无意义。
- en: The following are Django's model attributes explained with their intended use.
    A complete list of fields can be found on the stranded documentation at [https://docs.djangoproject.com/en/dev/ref/models/fields/](https://docs.djangoproject.com/en/dev/ref/models/fields/).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Django的模型属性及其预期用途的解释。完整的字段列表可以在[https://docs.djangoproject.com/en/dev/ref/models/fields/](https://docs.djangoproject.com/en/dev/ref/models/fields/)的标准文档中找到。
- en: 'Following is a partial table of these types:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这些类型的部分表：
- en: '| Field type | Description |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 字段类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `IntegerField` | An integer |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `IntegerField` | 一个整数 |'
- en: '| `TextField` | A large text field |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `TextField` | 一个大文本字段 |'
- en: '| `DateTimeField` | A date-and-time field |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `DateTimeField` | 一个日期和时间字段 |'
- en: '| `EmailField` | An e-mail field with 75 characters maximum |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `EmailField` | 一个最大长度为75个字符的电子邮件字段 |'
- en: '| `URLField` | A URL field with 200 characters maximum |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `URLField` | 一个最大长度为200个字符的URL字段 |'
- en: '| `FileField` | A file-upload field |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| `FileField` | 一个文件上传字段 |'
- en: Each model field takes a set of field-specific arguments. For example, if we
    want a field to be a `CharField` field, we must pass its `max_length` parameter
    as its argument, which is mapped to the field size in `varchar` to the database.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模型字段都带有一组特定于字段的参数。例如，如果我们想要一个字段是`CharField`字段，我们必须将其`max_length`参数作为其参数传递，该参数映射到数据库中`varchar`的字段大小。
- en: 'The following are the arguments that can be applied to all the field types
    (they are optional):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以应用于所有字段类型的参数（它们是可选的）：
- en: '`null`: By default, it is set to `false`. When set to `true`, the associated
    field is allowed to have a value of `null` stored in the database.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`null`：默认情况下，它设置为`false`。当设置为`true`时，允许将`null`的关联字段的值存储在数据库中。'
- en: '`blank`: By default, it is set to `false`. When set to `true`, the associated
    field is allowed to have a value of `blank` stored in the database.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blank`：默认情况下，它设置为`false`。当设置为`true`时，允许将`blank`的关联字段的值存储在数据库中。'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The difference between the `null` and `blank` parameters is that the `null`
    parameter is mainly database-related, whereas the `blank` parameter is used for
    validating the field. In other words, if the attribute is set to `false`, the
    empty value (`blank`) for the attribute will not get saved.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`null`和`blank`参数之间的区别在于，`null`参数主要与数据库相关，而`blank`参数用于验证字段。换句话说，如果属性设置为`false`，则属性的空值（`blank`）将不会被保存。'
- en: '`choices`: This can be a list or a tuple and must be iterable. If this is in
    the form of a tuple, the first element is the value that will get stored to the
    database and the second value is used for display in widget-like forms or `ModelChoiceField`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`choices`：这可以是一个列表或元组，并且必须是可迭代的。如果这是一个元组，第一个元素是将存储到数据库中的值，第二个值用于在小部件形式或`ModelChoiceField`中显示。'
- en: 'For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE45]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '`default`: Values that are assigned to the attribute every time an object of
    the class is instantiated.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default`：每次实例化类的对象时分配给属性的值。'
- en: '`help_text`: Help text displayed in the form of a widget.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help_text`：以小部件形式显示的帮助文本。'
- en: '`primary_key`: If set to `True`, this field is made primary key for the model.
    If there is no primary key in the model, Django will create an integer field and
    mark that as the primary key.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`primary_key`：如果设置为`True`，则该字段将成为模型的主键。如果模型中没有主键，Django将创建一个整数字段并将其标记为主键。'
- en: Relationships in models
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型中的关系
- en: 'There are three major types of relationships: many-to-one, many-to-many, and
    one-to-one.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种主要类型的关系：多对一，多对多和一对一。
- en: Many-to-one relationships
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对一关系
- en: In Django, the `django.db.models.ForeignKey` parameter is used to define a model
    as a foreign key to another model's attribute, which results in a many-to-many
    relationship.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django中，`django.db.models.ForeignKey`参数用于将一个模型定义为另一个模型属性的外键，从而产生多对多的关系。
- en: 'It is used as any other attribute of a model class, after including the class
    in which it is present. For example, if students study in a particular school,
    the relationship is that the school has many students but a student goes to only
    one school, making this a many-to-one relationship. Let''s take a look at the
    following code snippet:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 它被用作模型类的任何其他属性，包括它所在的类。例如，如果学生在特定学校学习，那么学校有很多学生，但学生只去一个学校，这是一个多对一的关系。让我们看一下以下代码片段：
- en: '[PRE46]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One-to-one relationships
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一对一关系
- en: One-to-one relationships are very similar to many-to-one relationships. The
    only difference is that reverse mapping results in a single object in the case
    of one-to-one as opposed to many-to-one relationships.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一关系与多对一关系非常相似。唯一的区别是，反向映射在一对一关系的情况下会导致单个对象，而不是多对一关系。
- en: 'For example:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding example, the `EntryDetail()` class has an attribute called
    `entry`, which is mapped one-to-one with the `Entry` model. This means that every
    `Entry` object has been mapped to the `EntryDetail` model.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`EntryDetail()`类有一个名为`entry`的属性，它与`Entry`模型一对一映射。这意味着每个`Entry`对象都映射到`EntryDetail`模型。
- en: Many-to-many relationships
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多对多关系
- en: As the name itself suggests, model attributes with many-to-many relationships
    provide access to both the models it's been pointed to (like backward one-to-many
    relationships). Attribute naming is the only significant difference between the
    two relationships.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称本身所示，具有多对多关系的模型属性提供对其指向的两个模型的访问（例如向后的一对多关系）。属性命名是这两种关系之间唯一的重要区别。
- en: 'This will be clearer if we go through the following example:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过以下示例来说明，这将更清楚：
- en: '[PRE48]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: With the idea of attribute and primary relationships, we can now straightaway
    create our projects model, which we will soon be doing in the coming sections.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有了属性和主要关系的想法，我们现在可以直接创建我们的项目模型，在接下来的部分中我们将很快做到这一点。
- en: If we are going to design the model for an application, we should break up the
    applications if it has too many models. If we have more than roughly 15 models
    in our application, we should think about the ways in which to break our application
    into smaller applications. This is because, with the existing 15-model application,
    we are probably doing way too many things. This doesn't go with the Django philosophy
    of an *app should do one thing and do it right*.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要为应用程序设计模型，如果模型太多，我们应该拆分应用程序。如果我们的应用程序中有超过大约15个模型，我们应该考虑如何将我们的应用程序拆分成更小的应用程序。这是因为，对于现有的15个模型应用程序，我们可能正在做太多事情。这与Django的哲学不符，即*应用程序应该只做一件事，并且做得正确*。
- en: Models – designing an initial database schema
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-设计初始数据库模式
- en: 'Coming back to our project, we will need two models in the initial phase: the
    `user` model and the `tweet` model. The `user` model will be used for storing
    the basic user details of the users that have accounts in our project.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的项目，我们在初始阶段将需要两个模型：`user`模型和`tweet`模型。`user`模型将用于存储在我们的项目中拥有帐户的用户的基本用户详细信息。
- en: Then comes the `tweet` model, which will store data related to the tweet, such
    as the tweet text, the user who has created that tweet, and other important details
    such as the timestamps of the tweet posted, and so on.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`tweet`模型，它将存储与推文相关的数据，例如推文文本，创建该推文的用户，以及推文发布的时间戳等其他重要细节。
- en: To list the tweets of a user, it will be better if we create a separate user
    application specific to all the users of our project. Our user models will be
    created by extending Django's `AbstractBaseUser` user model class.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出用户的推文，最好是创建一个专门针对项目中所有用户的用户应用程序。我们的用户模型将通过扩展Django的`AbstractBaseUser`用户模型类来创建。
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Changing the actual `user` class in your Django source tree and/or copying and
    altering the `auth` module is never recommended.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不建议更改Django源树中的实际`user`类和/或复制和修改`auth`模块。
- en: This will be the first application of using a framework for web development
    instead of writing the whole authentication by ourselves, which is pretty common
    to all web development scenarios. Django comes with predefined libraries so that
    we don't have to reinvent the wheel. It comes with both authentication and authorization
    together and is called the authentication system.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是使用框架进行Web开发的第一个应用程序，而不是自己编写整个身份验证，这对所有Web开发场景都是非常普遍的。Django带有预定义的库，因此我们不必重新发明轮子。它同时提供了认证和授权，并称为认证系统。
- en: Django's user objects
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Django的用户对象
- en: An additional configurable user model is shipped with Django 1.5, which is the
    easier method for storing user-specific data in the application.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: Django 1.5附带了一个可配置的用户模型，这是在应用程序中存储特定于用户的数据的更简单的方法。
- en: 'We will create a user application and then import the Django''s default user
    model into it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个用户应用程序，然后将Django的默认用户模型导入其中：
- en: '[PRE49]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will extend the Django user model according to our need in the current project
    by creating a custom `User()` class that inherits from the `AbstractBaseUser`
    class. Therefore, our `models.py` file will look like this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将根据当前项目的需要扩展Django用户模型，通过创建一个继承自`AbstractBaseUser`类的自定义`User()`类。因此，我们的`models.py`文件将如下所示：
- en: '[PRE50]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now that we have created our custom `user` class for the project, we can add
    all the basic attributes to this `user` class that we would like to be in the
    user model.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为项目创建了自定义的`user`类，我们可以向这个`user`类添加所有我们希望在用户模型中的基本属性。
- en: 'Now `models.py` looks like this:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`models.py`看起来是这样的：
- en: '[PRE51]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code snippet, the custom user model `email` field has a property
    `unique` that is set to `True`. This means that a user can only register once
    with the given e-mail address, the verification can be done on the registration
    page. You will see a `db_index` option also in the `username` attribute with value
    `True`, which will index the user table on the `username` attribute.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，自定义用户模型`email`字段具有一个设置为`True`的`unique`属性。这意味着用户只能使用给定的电子邮件地址注册一次，验证可以在注册页面上完成。您还将在`username`属性中看到一个`db_index`选项，其值为`True`，这将在`username`属性上为用户表建立索引。
- en: '`joined` is the `dateTimeField` parameter populated automatically when a new
    user profile is created; the `is_active` field is set to `True` by default when
    a new user account is created, and the `is_admin` field is initialized to `False`
    at the same time.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`joined`是`dateTimeField`参数，当创建新用户配置文件时会自动填充；当创建新用户帐户时，默认情况下`is_active`字段设置为`True`，同时`is_admin`字段初始化为`False`。'
- en: One more field is needed to make this almost the same as the default Django
    user model, which is the `username` field.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要一个字段，使其几乎与默认的Django用户模型相同，即`username`字段。
- en: 'Add the `USERNAME_FIELD` field in the `models.py` file as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在`models.py`文件中添加`USERNAME_FIELD`字段如下：
- en: '[PRE52]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '`USERNAME_FIELD` also works as the unique identifier for a user model in Django.
    We have mapped our `username` parameter with Django''s `username` field. This
    field must be unique (`unique=True`) in its definition, which our `username` field
    already is.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`USERNAME_FIELD`也作为Django中用户模型的唯一标识符。我们已经将我们的`username`参数映射到Django的`username`字段。这个字段在定义时必须是唯一的（`unique=True`），而我们的`username`字段已经是唯一的。'
- en: The `__unicode__()` method is also added as the definition that displays a human-readable
    representation of our user model object.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '`__unicode__()`方法也被添加为显示用户模型对象的人类可读表示的定义。'
- en: 'Thus, the final `models.py` file will look like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的`models.py`文件将如下所示：
- en: '[PRE53]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, after defining our user model, we can move ahead to design the tweet model.
    This is the same application that we created to check out the basic class-based
    view. We will add content to its `models.py` file, as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在定义了我们的用户模型之后，我们可以继续设计推文模型。这是我们创建的同一个应用程序，用于查看基本的基于类的视图。我们将向其`models.py`文件添加内容，如下所示：
- en: '[PRE54]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The tweet model is designed as to be as simplistic as possible for the user.
    The `attribute` parameter is a foreign key to the `User` object we have already
    created. The `text` attribute is the tweet content and it will mostly consist
    of plain text. The `created_Date` attribute, which is automatically added to the
    database when the `tweet` object is uninitialized, stores the name of the country
    from where the tweet has actually been posted. In most cases, it will be the same
    as the user's country. The `is_active` flag is used to represent the tweet's current
    status, whether it's active and can be displayed or has been deleted by the user.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 推文模型的设计尽可能简单，`attribute`参数是对我们已经创建的`User`对象的外键。`text`属性是推文内容，它将主要由纯文本组成。`created_Date`属性是在未初始化`tweet`对象时自动添加到数据库中的，它存储了实际发布推文的国家名称。在大多数情况下，它将与用户的国家相同。`is_active`标志用于表示推文的当前状态，即它是否处于活动状态并且可以显示，或者已被用户删除。
- en: We need to create the tables in the database for both the models we just created,
    `user_profile` and `tweet`. We will have to update the `INSTALLED_APPS` variable
    of your project's `settings.py` file to tell Django to include these two applications
    in the Django project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在数据库中为我们刚刚创建的两个模型`user_profile`和`tweet`创建表。我们将不得不更新项目的`settings.py`文件中的`INSTALLED_APPS`变量，以告诉Django在Django项目中包括这两个应用程序。
- en: 'Our updated `INSTALLED_APPS` variable will be as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新后的`INSTALLED_APPS`变量将如下所示：
- en: '[PRE55]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: You can see the last two entries we made to add our models.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到我们添加的最后两个条目以添加我们的模型。
- en: 'Now to create the database table for our project, we will run the command from
    our root project folder in the terminal:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了为我们的项目创建数据库表，我们将在终端中从根项目文件夹运行以下命令：
- en: '[PRE56]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The output will be as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE57]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You just installed Django''s auth system, which means you don''t have any superusers
    defined. You can see the following on the terminal:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 您刚刚安装了Django的auth系统，这意味着您没有定义任何超级用户。您可以在终端上看到以下内容：
- en: '[PRE58]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: As a result, our database has been populated with a table. There will appear
    a database file for our project called `db.sqlite3`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的数据库已填充了一个表。我们的项目中将出现一个名为`db.sqlite3`的数据库文件。
- en: As with Django 1.6, the administrator panel comes by default. All we need for
    our models to be available in Django's admin panel is to add the `admin.site.register`
    parameter with the model name as argument for both the applications.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django 1.6一样，默认情况下会出现管理员面板。我们的模型要在Django的管理面板中可用，只需为两个应用程序的模型名称添加`admin.site.register`参数作为参数。
- en: 'Thus, after addition of `admin.site.register(parameter)` to both the `admin.py`,
    that is, under `mytweets` and `user_profile` files will look as the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`admin.py`文件中添加`admin.site.register(parameter)`到`mytweets`和`user_profile`文件下将如下所示：
- en: 'The `admin.py` file of the `tweet` application would look as follows:'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tweet`应用程序的`admin.py`文件如下所示：'
- en: '[PRE59]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `admin.py` file of the `user_profile` application would look as follows:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_profile`应用程序的`admin.py`文件如下所示：'
- en: '[PRE60]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Start the server using the following command:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令启动服务器：
- en: '[PRE61]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Then visit the URL `http://127.0.0.1:8000/admin`; it will ask for login information.
    As you may remember, we have created the default user at the time of running the
    `$python manage.py syncdb` command; use the same username and password.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 然后访问URL`http://127.0.0.1:8000/admin`；它会要求登录信息。您可能还记得，我们在运行`$python manage.py
    syncdb`命令时创建了默认用户；使用相同的用户名和密码。
- en: 'After successful login, the admin dashboard looks like the following screenshot:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 成功登录后，管理面板看起来像以下截图：
- en: '![Django''s user objects](img/image00288.jpeg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00288.jpeg)'
- en: 'Let''s play with the admin dashboard and create a `user` and a `tweet` object
    that we will be using next for home page views. To add a new user to the project
    just click on the **Add** button in front of the user model box as shown in the
    following screenshot:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在管理面板中玩耍，并创建一个我们将在首页视图中使用的`user`和`tweet`对象。要向项目添加新用户，只需点击用户模型框前面的**添加**按钮，如下截图所示：
- en: '![Django''s user objects](img/image00289.jpeg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00289.jpeg)'
- en: 'Then fill up the details and save it. You will see a **"user successfully created"**
    message as shown in the following screenshot:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后填写详细信息并保存。您将看到如下截图中显示的**"用户创建成功"**消息：
- en: '![Django''s user objects](img/image00290.jpeg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00290.jpeg)'
- en: We will follow a similar process for creating a tweet. First go back to `http://127.0.0.1:8000/admin/`.
    Then, click on the **Add** button in front of the tweet box.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照类似的流程创建一条推文。首先返回到`http://127.0.0.1:8000/admin/`。然后，在推文框前面点击**添加**按钮。
- en: '![Django''s user objects](img/image00291.jpeg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00291.jpeg)'
- en: Compose a new tweet by filling out the boxes and selecting the user from the
    dropdown. This user list is already populated as we have mapped the user to the
    user object. As we keep on adding users, the dropdown will get populated with
    all the user objects.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过填写框并从下拉菜单中选择用户来撰写新推文。由于我们已将用户映射到用户对象，因此此用户列表已经填充。随着我们不断添加用户，下拉菜单将填充所有用户对象。
- en: '![Django''s user objects](img/image00292.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00292.jpeg)'
- en: 'Finally, after composing the tweet, click on the **Save** button. You will
    see the same screen shown in the following screenshot:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在撰写推文后，点击**保存**按钮。您将看到以下截图中显示的相同屏幕：
- en: '![Django''s user objects](img/image00293.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00293.jpeg)'
- en: If you look closely, the administrator listing page says every tweet is a `tweet`
    object, which is not very human-friendly. It can easily be customized for this
    case. In fact, the same rule is applicable for all the model base representations
    in the Django admin view or wherever they are displayed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察，管理员列表页面会显示每条推文都是一个`tweet`对象，这不太友好。实际上，对于Django管理视图中或任何其他地方显示的所有模型基础表示，都适用相同的规则。
- en: 'Add the following code snippet in the `admin.py` file of our project:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目的`admin.py`文件中添加以下代码片段：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Our admin view will now show the exact text instead of writing tweet object.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管理视图现在将显示确切的文本，而不是写入推文对象。
- en: '![Django''s user objects](img/image00294.jpeg)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![Django的用户对象](img/image00294.jpeg)'
- en: Creating a URL
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建URL
- en: 'Every user in our project will have a profile with a unique URL in the following
    format: `http://127.0.0.1:8000/user/<username>`. Here, the `username` variable
    is the owner of the tweets that we want to see. This URL is different from the
    first URL we added earlier because this contains a dynamic portion, so we will
    have to employ the power of regular expressions in order to express this URL.
    Open the `urls.py` file and edit it so that the URL table looks like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的每个用户都将具有以下格式的唯一URL的个人资料：`http://127.0.0.1:8000/user/<username>`。这里，`username`变量是我们想要查看推文的所有者。这个URL与我们之前添加的第一个URL不同，因为它包含一个动态部分，所以我们必须利用正则表达式的能力来表示这个URL。打开`urls.py`文件并编辑它，使URL表格如下所示：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The pattern here looks more complicated than the first one. The annotation `\w`
    means an alphanumeric character or the underscore. The `+` sign after it causes
    the regular expression to match one or more repetitions of what precedes the sign.
    So, in effect,`\w+` means any string that consists of alphanumeric characters
    and possibly the underscore. We have surrounded this portion of the regular expression
    with parentheses. This will cause Django to capture the string that matches this
    portion and pass it to the view.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的模式看起来比第一个更复杂。注释`\w`表示字母数字字符或下划线。其后的`+`符号会导致正则表达式匹配前面的内容的一个或多个重复。因此，实际上，`\w+`表示由字母数字字符和可能的下划线组成的任何字符串。我们用括号括起了正则表达式的这部分。这将导致Django捕获与这部分匹配的字符串并将其传递给视图。
- en: One last thing needs explaining before we see the view in action. The regular
    expression that we used will look a bit strange if you haven't used regular expressions
    before. It is a raw string that contains two characters, `^` and `$`. The annotation
    `r''` is the Python syntax for defining raw strings. If Python encounters such
    a raw string, backslashes and other escape sequences are retained in the string,
    rather than being interpreted in any way. In this syntax, backslashes are left
    in the string without change and escape sequences are not interpreted. This is
    useful while working with regular expressions because they often contain backslashes.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到视图生效之前，还有一件事需要解释。如果您以前没有使用过正则表达式，我们使用的正则表达式看起来可能有点奇怪。这是一个包含两个字符`^`和`$`的原始字符串。注释`r''`是Python定义原始字符串的语法。如果Python遇到这样的原始字符串，反斜杠和其他转义序列将保留在字符串中，而不会以任何方式解释。在这种语法中，反斜杠保留在字符串中而不会改变，转义序列不会被解释。这在处理正则表达式时非常有用，因为它们经常包含反斜杠。
- en: In regular expressions, `^` means the beginning of the string and `$` means
    the end of the string. So `^$` basically means a string that doesn't contain anything,
    that is, an empty string. Given that we are writing the view of the main page,
    the URL of the page is the root URL and it should indeed be empty.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在正则表达式中，`^`表示字符串的开头，`$`表示字符串的结尾。因此，`^$`基本上表示一个不包含任何内容的字符串，即空字符串。鉴于我们正在编写主页的视图，页面的URL是根URL，确实应该是空的。
- en: 'Python documentation of the `re` module covers regular expressions in detail.
    I recommend reading it if you want a thorough treatment of regular expressions.
    You can find the documentation online at [http://docs.python.org/lib/module-re.html](http://docs.python.org/lib/module-re.html).
    Here is a table that summarizes regular expression syntax for those who want a
    quick refresher:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`re`模块的Python文档详细介绍了正则表达式。如果您想对正则表达式进行彻底的处理，我建议阅读它。您可以在[http://docs.python.org/lib/module-re.html](http://docs.python.org/lib/module-re.html)上找到在线文档。以下是一个总结正则表达式语法的表格，供那些想要快速复习的人使用：'
- en: '| Symbol /expression | Matched string |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 符号/表达式 | 匹配的字符串 |'
- en: '| --- | --- |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `. (Dot)` | Any character |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| `. (Dot)` | 任何字符 |'
- en: '| `^ (Caret)` | Start of string |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| `^ (Caret)` | 字符串的开头 |'
- en: '| `$` | End of string |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| `$` | 字符串的结尾 |'
- en: '| `*` | 0 or more repetitions |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| `*` | 0次或多次重复 |'
- en: '| `+` | 1 or more repetitions |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| `+` | 1次或多次重复 |'
- en: '| `?` | 0 or 1 repetitions |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| `?` | 0或1次重复 |'
- en: '| `&#124;` | A &#124; B means A or B |'
  id: totrans-314
  prefs: []
  type: TYPE_TB
  zh: '| `&#124;` | A &#124; B 表示A或B |'
- en: '| `[a-z]` | Any lowercase character |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| `[a-z]` | 任何小写字符 |'
- en: '| `\w` | Any alphanumeric character or _ |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| `\w` | 任何字母数字字符或_ |'
- en: '| `\d` | Any digit |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| `\d` | 任何数字 |'
- en: We will now be creating a `Profile()` class with `GET` functions in the `view.py`
    file of our tweet application. The important thing to learn here is how the `get()`
    function handles the dynamic parameter passed through the URL, which is the `username`
    variable.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在我们的推文应用程序的`view.py`文件中创建一个带有`GET`函数的`Profile()`类。这里需要学习的重要事情是`get()`函数如何处理通过URL传递的动态参数，即`username`变量。
- en: 'The `view.py` of our tweet application would look as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的推文应用程序的`view.py`将如下所示：
- en: '[PRE64]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Templates – creating a template for the Main Page
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板 - 为主页创建模板
- en: We are almost done with the model creation for our project. We will now move
    ahead and create the view page.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了项目的模型创建。现在我们将继续创建视图页面。
- en: The first page we are going to create is the basic page which will list out
    all the tweets posted by a user. This can be a so-called public profile page that
    can be accessed without any authentication.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要创建的第一个页面是基本页面，它将列出用户发布的所有推文。这可以是一个所谓的公共个人资料页面，可以在没有任何身份验证的情况下访问。
- en: As you might have noticed, we have used a `profile.html` file in the `Profile`
    class of the `views.py` file, which belongs to our tweet application.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在`views.py`文件的`Profile`类中使用了`profile.html`文件，它属于我们的推文应用程序。
- en: 'The `views.py` file of our project will look as follows:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的`views.py`文件将如下所示：
- en: '[PRE65]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We will use the Bootstrap framework, which we have already imported in our `base.html`
    file, to design the `Profile.html` file.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用已经在我们的`base.html`文件中导入的Bootstrap框架来设计`Profile.html`文件。
- en: We will first restructure the `base.html` file which we created for our application.
    Now this `base.html` file will be used as a template or theme of our project.
    We will import this file across the project, which results in constant user interface
    across the project.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先重构我们为应用程序创建的`base.html`文件。现在这个`base.html`文件将被用作我们项目的模板或主题。我们将在整个项目中导入此文件，这将导致项目中的用户界面保持一致。
- en: We will just remove the `div` tag we placed inside the block content from our
    `base.html` file.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从我们的`base.html`文件中删除我们放在块内容中的`div`标签。
- en: We also need jQuery, which is a JavaScript library for complete functioning
    of bootstrap. It can be downloaded from [http://jquery.com/download/](http://jquery.com/download/).
    For our current project, we will download the latest version of jQuery in production-ready
    phase. We will be adding it before bootstrap's JavaScript import.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要jQuery，这是一个用于完全实现bootstrap功能的JavaScript库。可以从[http://jquery.com/download/](http://jquery.com/download/)下载。对于我们当前的项目，我们将在生产就绪阶段下载最新版本的jQuery。我们将在bootstrap的JavaScript导入之前添加它。
- en: 'The `base.html` file should look like this now:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`base.html`文件应该是这样的：
- en: '[PRE66]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this case the block is as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，块如下所示：
- en: '[PRE67]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This means that, whichever template we are going to extend the `base.html`
    file, currently in the `profile.html` file, the content of the `profile.html`
    file will be rendered between these block quotes. To understand this better, consider
    this: you have a header (in some cases, navigation bar) and footer on every page
    and the page content changes depending upon the view. With the preceding template,
    we generally need to place the header code before the block content and footer
    content below the block content.'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，无论我们要扩展哪个模板`base.html`文件，当前在`profile.html`文件中，`profile.html`文件的内容将在这些块引用之间呈现。为了更好地理解这一点，考虑这样做：每个页面都有页眉（在某些情况下是导航栏）和页脚，页面内容根据视图而变化。通过前面的模板，我们通常需要在块内容之前放置页眉代码，并在块内容下方放置页脚内容。
- en: Using a header is much easier now as we have the advantage of frontend framework.
    We will first choose the layout of our project. For simplicity, we will divide
    the whole page into three sections. The first will be the header, which will be
    constant as we navigate throughout the project. The same will apply to the bottom
    of the page, which is our footer.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用页眉要容易得多，因为我们有前端框架的优势。我们将首先选择项目的布局。为简单起见，我们将整个页面分为三个部分。第一个将是页眉，随着我们在整个项目中导航，它将是恒定的。同样的情况也适用于页面底部，即我们的页脚。
- en: '![Templates – creating a template for the Main Page](img/image00295.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![模板-为主页创建模板](img/image00295.jpeg)'
- en: 'To achieve the preceding layout, our bootstrap code will be built in this way:
    we will use bootstrap''s `navbar` for our header section as well as for the footer
    section. Then we will place the container `div` tag. Our updated code for the
    `base.html` file will be changed to the following:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现前面的布局，我们的bootstrap代码将以这种方式构建：我们将使用bootstrap的`navbar`作为页眉部分以及页脚部分。然后我们将放置容器`div`标签。我们的`base.html`文件的更新代码将更改为以下内容：
- en: '[PRE68]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `navbar` parameter will start in the body, but before the container, so
    that it can wrap the whole container. We use Django block content to render the
    rows which we will define in the extended templates, in this case, the `profile.html`
    file. The footer section comes in last, which is after the `endblock` statement.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '`navbar`参数将在主体中启动，但在容器之前，以便它可以包裹整个容器。我们使用Django块内容来呈现我们将在扩展模板中定义的行，在这种情况下是`profile.html`文件。页脚部分最后出现，这是在`endblock`语句之后。'
- en: 'This will render the following page:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现以下页面：
- en: '![Templates – creating a template for the Main Page](img/image00296.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![模板-为主页创建模板](img/image00296.jpeg)'
- en: Tip
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: 'Note that if you do not get the static file included, replace the `STATICFILES_DIRS`
    variable with the following in your `settings.p` `y` file:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果您没有包含静态文件，请在您的`settings.py`文件中用以下内容替换`STATICFILES_DIRS`变量：
- en: '[PRE69]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The design for the profile page is as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 个人资料页面的设计如下：
- en: '![Templates – creating a template for the Main Page](img/image00297.jpeg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![模板-为主页创建模板](img/image00297.jpeg)'
- en: This can easily be designed again with the help of a bootstrap component called
    `well`. The `well` or `wellbox` components are used with an element to give it
    an inset effect. The `profile.html` file will just extend the `base.html` file
    and only contain rows and further elements.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地再次设计，借助名为`well`的bootstrap组件。`well`或`wellbox`组件与元素一起使用，以产生内嵌效果。`profile.html`文件将只扩展`base.html`文件，并且只包含行和进一步的元素。
- en: 'The `profile.html` file of our project would look as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的`profile.html`文件如下所示：
- en: '[PRE70]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This will show the tweets of a user we pass via a parameter in the URL. The
    example we have taken is the user `ratancs`, who we created during the initial
    setup. You can see their tweets in the following screenshot:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示我们通过URL参数传递的用户的推文。我们采用的示例是用户`ratancs`，我们在初始设置期间创建的用户。您可以在以下截图中看到他们的推文：
- en: '![Templates – creating a template for the Main Page](img/image00298.jpeg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![模板-为主页创建模板](img/image00298.jpeg)'
- en: Summary
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We learned the basic terminology related to our Django project, what we need
    to set up the basic template structure of our project, and how to set up the bootstrap
    for our tweet-like application. We also saw how MVC works here and the role of
    URL and views while creating the main page.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了与我们的Django项目相关的基本术语，我们需要设置项目的基本模板结构，以及如何为我们的类似推文的应用程序设置bootstrap。我们还看到了MVC在这里的工作方式以及在创建主页时URL和视图的作用。
- en: Then, we introduced class-based views to generate user pages. We saw how models
    work in Django and how to design the database schema for the project. We also
    learned to build a user registration page, an account management page, and a template
    for the main page.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了基于类的视图来生成用户页面。我们看到了模型在Django中的工作方式，以及如何为项目设计数据库模式。我们还学会了构建用户注册页面、帐户管理页面和主页模板。
- en: We will learn to design the algorithm for building a hashtag model and the mechanism
    to use hashtags in your post in the following chapters.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习设计构建标签模型的算法，以及在接下来的章节中如何在您的帖子中使用标签的机制。
