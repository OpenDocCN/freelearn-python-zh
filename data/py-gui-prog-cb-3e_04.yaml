- en: Data and Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据和类
- en: In this chapter, we will save our GUI data into `tkinter` variables. We will
    also start using **object-oriented programming** (**OOP**), writing our own classes
    in Python. This will lead us to creating reusable OOP components. By the end of
    this chapter, you will know how to save data from the GUI into local `tkinter`
    variables. You will also learn how to display tooltips over widgets, which give
    the user additional information. Knowing how to do this makes our GUI more functional
    and easier to use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将把我们的GUI数据保存到`tkinter`变量中。我们还将开始使用**面向对象编程**（**OOP**），在Python中编写我们自己的类。这将引导我们创建可重用的OOP组件。到本章结束时，你将知道如何将GUI中的数据保存到本地的`tkinter`变量中。你还将学习如何显示工具提示，这会给用户额外的信息。了解如何做这一点可以使我们的GUI更功能化，更容易使用。
- en: 'Here is an overview of the Python modules for this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章Python模块的概述：
- en: '![](img/781646b9-8cac-45c5-b464-61edcf82442b.png)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/781646b9-8cac-45c5-b464-61edcf82442b.png)'
- en: 'In this chapter, we will use data and OOP classes using Python 3.7 and above.
    We will cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Python 3.7及以上版本的Python数据和OOP类。我们将涵盖以下食谱：
- en: How to use `StringVar()`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`StringVar()`
- en: How to get data from a widget
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从一个小部件获取数据
- en: Using module-level global variables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块级全局变量
- en: How coding in classes can improve the GUI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在类中编码可以提高GUI
- en: Writing callback functions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: Creating reusable GUI components
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可重用的GUI组件
- en: How to use StringVar()
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何使用StringVar()
- en: There are built-in programming types in `tkinter` that differ slightly from
    the Python types we are used to programming with. `StringVar()` is one such `tkinter`
    type. This recipe will show you how to use the `StringVar()` type.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`tkinter`中有一些内置的编程类型，与我们习惯编程的Python类型略有不同。`StringVar()`就是这样的`tkinter`类型。这个食谱将向你展示如何使用`StringVar()`类型。'
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, you will learn how to save data from the `tkinter` GUI into
    variables so we can use that data. We can set and get their values, which is very
    similar to how you would use the Java `getter`/`setter` methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何将`tkinter` GUI中的数据保存到变量中，这样我们就可以使用这些数据。我们可以设置和获取它们的值，这与你使用Java的`getter`/`setter`方法非常相似。
- en: 'Here are some of the types of code in `tkinter`:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`tkinter`中的一些代码类型：
- en: '| `strVar = StringVar()` | Holds a string; the default value is an empty string
    (`""`) |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `strVar = StringVar()` | 保存一个字符串；默认值是一个空字符串（`""`）|'
- en: '| `intVar = IntVar()` | Holds an integer; the default value is `0` |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| `intVar = IntVar()` | 保存一个整数；默认值是`0` |'
- en: '| `dbVar = DoubleVar()` | Holds a `float`; the default value is `0.0` |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `dbVar = DoubleVar()` | 保存一个`float`；默认值是`0.0` |'
- en: '| `blVar = BooleanVar()` | Holds a Boolean, it returns `0` for `False` and
    1 for `True` |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `blVar = BooleanVar()` | 保存一个布尔值，对于`False`返回`0`，对于`True`返回`1` |'
- en: Different languages call numbers with decimal points `float` or `double`. `tkinter`
    calls them `DoubleVar`, which is known in Python as the `float` data type. Depending
    on the level of precision, `float` and `double` data can be different. Here, we
    are translating `DoubleVar` of `tkinter` into a Python `float` type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的语言用`float`或`double`来表示小数点后的数字。`tkinter`将它们称为`DoubleVar`，在Python中这被称为`float`数据类型。根据精度的不同，`float`和`double`数据可能不同。在这里，我们将`tkinter`的`DoubleVar`转换为Python的`float`类型。
- en: This becomes clearer when we add a `DoubleVar` with a Python `float` and look
    at the resulting type, which is a Python `float` and no longer a `DoubleVar`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们添加一个带有Python `float`的`DoubleVar`并查看生成的类型时，这一点变得更加清晰，它是一个Python `float`，而不再是`DoubleVar`。
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做呢...
- en: We will create a `DoubleVar` of `tkinter` variable and add a `float` number
    literal to it using the `+` operator. After that, we will look at the resulting
    Python type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`tkinter`的`DoubleVar`变量，并使用`+`运算符向其中添加一个`float`数字字面量。之后，我们将查看生成的Python类型。
- en: 'Here are the steps to see the different `tkinter` data types:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 查看不同`tkinter`数据类型的步骤如下：
- en: Create a new Python module and name it `GUI_PyDoubleVar_to_Float_Get.py`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的Python模块，并将其命名为`GUI_PyDoubleVar_to_Float_Get.py`。
- en: 'At the top of the `GUI_PyDoubleVar_to_Float_Get.py` module, import `tkinter`:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GUI_PyDoubleVar_to_Float_Get.py`模块的顶部导入`tkinter`：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create an instance of the `tkinter` class:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`tkinter`类的实例：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create a `DoubleVar` and give it a value:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`DoubleVar`并给它赋值：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the final `GUI_PyDoubleVar_to_Float_Get.py`
    code and the output after running the code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了最终的`GUI_PyDoubleVar_to_Float_Get.py`代码和运行代码后的输出：
- en: '![](img/6c066496-f89c-4344-bb7d-7313ab6ff01e.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c066496-f89c-4344-bb7d-7313ab6ff01e.png)'
- en: We can do the same with `tkinter` with regards to strings.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用`tkinter`对字符串做同样的事情。
- en: 'We will create a new Python module as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下方式创建一个新的 Python 模块：
- en: Create a new Python module and name it `GUI_StringVar.py`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 模块并将其命名为 `GUI_StringVar.py`。
- en: 'At the top of the `GUI_StringVar.py` module, import `tkinter`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GUI_StringVar.py` 模块的顶部，导入 `tkinter`：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Create an instance of the `tkinter` class:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `tkinter` 类的实例：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Assign a `StringVar` of `tkinter` to the `strData` variable:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `tkinter` 的 `StringVar` 分配给 `strData` 变量：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Set the `strData` variable:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 `strData` 变量：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Get the value of the `strData` variable and save it in `varData`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取 `strData` 变量的值并将其保存到 `varData`：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Print out the current value of `strData`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出 `strData` 的当前值：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following screenshot shows the final `GUI_StringVar.py` code and the output
    after running the code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了最终的 `GUI_StringVar.py` 代码以及运行代码后的输出：
- en: '![](img/784fc4b2-11ca-4ab0-b5eb-facc47a2211e.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/784fc4b2-11ca-4ab0-b5eb-facc47a2211e.png)'
- en: 'Next, we will print the default values of, `IntVar`, `DoubleVar`, and `BooleanVar`
    types of `tkinter`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将打印 `tkinter` 的 `IntVar`、`DoubleVar` 和 `BooleanVar` 类型默认值：
- en: Open `GUI_StringVar.py` and save the module as `GUI_PyVar_defaults.py`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_StringVar.py` 并将模块保存为 `GUI_PyVar_defaults.py`。
- en: 'Add the following lines of code toward the bottom of this module:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此模块的底部添加以下代码行：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following screenshot shows the final `GUI_PyVar_defaults.py` code and the
    output after running the `GUI_PyVar_defaults.py` code file:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了最终的 `GUI_PyVar_defaults.py` 代码以及运行 `GUI_PyVar_defaults.py` 代码文件后的输出：
- en: '![](img/fecfbcdb-e903-4b25-b6af-10329205878b.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/fecfbcdb-e903-4b25-b6af-10329205878b.png)'
- en: 'The steps to print the default `tkinter` variable value are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 打印默认 `tkinter` 变量值的步骤如下：
- en: Create a new Python module and name it `GUI_PyVar_Get.py`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Python 模块并将其命名为 `GUI_PyVar_Get.py`。
- en: 'Type the following code into the module:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到模块中：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the code, optionally setting a breakpoint in your IDE in the final `print()`
    statement:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，可选地在 IDE 中的最终 `print()` 语句处设置断点：
- en: '![](img/b99d3c95-461a-4c20-87c0-f127a8011dba.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/b99d3c95-461a-4c20-87c0-f127a8011dba.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码以更好地理解它。
- en: How it works…
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the Eclipse PyDev console, toward the bottom of the screenshot for `GUI_StringVar.py`
    in *step 8*, we can see the output printed to the console, which is Hello StringVar.
    This shows us that we have to call the `get()` method to get the data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse PyDev 控制台中，在 *步骤 8* 的 `GUI_StringVar.py` 的截图底部，我们可以看到打印到控制台的信息，即 Hello
    StringVar。这表明我们必须调用 `get()` 方法来获取数据。
- en: As can be seen in the screenshot of `GUI_PyVar_defaults.py` in *step 3*, the
    default values do not get printed, as we would have expected when we are not calling
    `get()`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如 *步骤 3* 中的 `GUI_PyVar_defaults.py` 的截图所示，默认值没有打印出来，正如我们预期的那样，因为我们没有调用 `get()`。
- en: The online literature mentions default values, but we won't see those values
    until we call the `get` method on them. Otherwise, we just get a variable name
    that automatically increments (for example, `PY_VAR3`, as can be seen in the preceding
    screenshot of `GUI_PyVar_defaults.py`).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在线文献提到了默认值，但除非我们调用它们的 `get` 方法，否则我们看不到这些值。否则，我们只得到一个自动递增的变量名（例如，`PY_VAR3`，如前述
    `GUI_PyVar_defaults.py` 的截图所示）。
- en: Assigning the `tkinter` type to a Python variable does not change the outcome.
    We still do not get the default value until we call `get()` on this variable.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `tkinter` 类型分配给 Python 变量不会改变结果。我们仍然得不到默认值，直到我们在这个变量上调用 `get()`。
- en: The value is `PY_VAR0`, not the expected `0`, until we call the `get` method.
    Now we can see the default value. We did not call `set`, so we see the default
    value automatically assigned to each `tkinter` type once we call the `get` method
    on each type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 值是 `PY_VAR0`，而不是预期的 `0`，直到我们调用 `get` 方法。现在我们可以看到默认值。我们没有调用 `set`，所以我们看到一旦我们调用每个类型的
    `get` 方法，每个 `tkinter` 类型都会自动分配默认值。
- en: Note how the default value of `0` gets printed to the console for the `IntVar`
    instance that we saved in the `intData` variable. We can also see the values in
    the Eclipse PyDev debugger window at the top of the screenshot.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 注意默认值 `0` 被打印到控制台，这是我们在 `intData` 变量中保存的 `IntVar` 实例。我们还可以在截图顶部的 Eclipse PyDev
    调试器窗口中看到这些值。
- en: First, we import the `tkinter` module and alias it to the name `tk`. Next, we
    use this alias to create an instance of the `Tk` class by appending parentheses
    to `Tk`, which calls the constructor of the class. This is the same mechanism
    as calling a function; only here, we create an instance of a class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`tkinter`模块并将其别名为`tk`。接下来，我们使用这个别名通过在`Tk`后添加括号来创建`Tk`类的实例，这调用类的构造函数。这与调用函数的机制相同；只是在这里，我们创建了一个类的实例。
- en: Usually, we use this instance assigned to the `win` variable to start the main
    event loop later in the code, but here, we are not displaying a GUI; rather, we
    are demonstrating how to use the `StringVar` type of `tkinter`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们使用分配给`win`变量的这个实例在代码的稍后部分启动主事件循环，但在这里，我们不是显示GUI；而是在演示如何使用`tkinter`的`StringVar`类型。
- en: We still have to create an instance of `Tk()`. If we comment out this line,
    we will get an error from `tkinter`, so this call is necessary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要创建一个`Tk()`的实例。如果我们取消注释这一行，我们将从`tkinter`得到一个错误，所以这个调用是必要的。
- en: Then, we create an instance of the `StringVar` type `tkinter` and assign it
    to our Python `strData` variable. After that, we use our variable to call the `set()` method
    on `StringVar` and after setting it to a value, we get the value, save it in a
    new variable named `varData`, and then print out its value. We've successfully
    learned how to use `StringVar()`. Now let's move on to the next recipe.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`StringVar`类型的实例并将其分配给我们的Python变量`strData`。之后，我们使用我们的变量来调用`StringVar`上的`set()`方法，在设置值之后，我们获取该值，将其保存在名为`varData`的新变量中，然后打印其值。我们已经成功学习了如何使用`StringVar()`。现在让我们继续下一个菜谱。
- en: How to get data from a widget
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何从小部件获取数据
- en: When the user enters data, we want to do something with it in our code. This
    recipe shows how to capture data in a variable. In the previous recipe, we created
    several `tkinter` class variables. They were standalone. Now, we are connecting
    them to our GUI, using the data we get from the GUI, and storing them in Python
    variables.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户输入数据时，我们想在代码中对其进行处理。这个菜谱展示了如何在变量中捕获数据。在前一个菜谱中，我们创建了几个`tkinter`类变量。它们是独立的。现在，我们将它们连接到我们的GUI，使用从GUI获取的数据，并将它们存储在Python变量中。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the Python GUI we were building in [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml),
    *Look and Feel Customization*. We'll reuse and enhance the code from `GUI_progressbar.py`
    from that chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用我们在[第3章](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml)，“外观和感觉定制”中构建的Python
    GUI。我们将重用并增强该章节中的`GUI_progressbar.py`代码。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will assign a value from our GUI to a Python variable:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将GUI中的一个值分配给Python变量：
- en: Open `GUI_progressbar.py` from [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml), *Look
    and Feel Customization*, and save the module as `GUI_data_from_widget.py`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开[第3章](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml)，“外观和感觉定制”中的`GUI_progressbar.py`，并将其模块保存为`GUI_data_from_widget.py`。
- en: 'Add the following code toward the bottom of our module. Just above the main
    event loop, add `strData`:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的底部添加以下代码。在主事件循环上方添加`strData`：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add code to place the cursor into the name entry:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加代码将光标置于名称输入框中：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Start the GUI:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动GUI：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Running the code gives us the following result:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码给出以下结果：
- en: '![](img/3c8942f3-1f96-47ad-b9d0-f62602f76888.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3c8942f3-1f96-47ad-b9d0-f62602f76888.png)'
- en: We placed our code above the GUI main event loop, so the printing happens before
    the GUI becomes visible. We would have to place the code into a callback function
    if we wanted to print out the current value after displaying the GUI and changing
    the value of the `Spinbox` control.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放置在GUI主事件循环上方，所以打印发生在GUI变得可见之前。如果我们想在显示GUI并更改`Spinbox`控制器的值之后打印当前值，我们必须将代码放入回调函数中。
- en: 'We will retrieve the current value of the `Spinbox` control:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检索`Spinbox`控制器的当前值：
- en: 'We create our `Spinbox` widget using the following code, hard-coding the available
    values into it:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下代码创建`Spinbox`小部件，并将可用的值硬编码到其中：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also move the hard-coding of the data out of the creation of the `Spinbox`
    class instance and set it later:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以将数据的硬编码从`Spinbox`类实例的创建中移除，并在稍后设置它：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It does not matter how we create our widget and insert data into it because
    we can access this data by using the `get()` method on the instance of the widget.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何创建小部件并将数据插入其中并不重要，因为我们可以通过在部件的实例上使用`get()`方法来访问这些数据。
- en: Let's go behind the scenes to understand the code better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码。
- en: How it works…
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In order to get the values out of our GUI written using `tkinter`, we use the `get()`
    method of `tkinter` on an instance of the widget we wish to get the value from.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从使用`tkinter`编写的GUI中获取值，我们使用我们希望获取值的实例小部件的`get()`方法。
- en: In the preceding example, we used the `Spinbox` control, but the principle is
    the same for all widgets that have a `get()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`Spinbox`控件，但对于所有具有`get()`方法的小部件，原理是相同的。
- en: Once we have got the data, we are in a pure Python world, and `tkinter` did
    serve us well in building our GUI. Now that we know how to get the data out of
    our GUI, we can use this data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们获取了数据，我们就处于纯Python的世界，`tkinter`在构建我们的GUI方面做得很好。现在我们知道如何从我们的GUI中获取数据，我们可以使用这些数据。
- en: We've successfully learned how to get data from a widget. Now let's move on
    to the next recipe.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何从小部件获取数据。现在让我们继续下一个菜谱。
- en: Using module-level global variables
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模块级全局变量
- en: Encapsulation is a major strength in any programming language, enabling us to
    program using OOP. Python is both OOP-friendly as well as procedural. We can create
    `global` variables that are localized to the module they reside in. They are `global`
    only to this module, which is one form of encapsulation. Why do we want this?
    Because as we add more and more functionality to our GUI, we want to avoid naming
    conflicts that could result in bugs in our code.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 封装是任何编程语言的主要优势之一，它使我们能够使用面向对象编程（OOP）进行编程。Python既面向对象友好，也支持过程式编程。我们可以创建局部于它们所在模块的`global`变量。它们只对这个模块是全局的，这是封装的一种形式。我们为什么想要这样做呢？因为随着我们向GUI添加越来越多的功能，我们想要避免可能导致代码中错误的命名冲突。
- en: We do not want naming clashes creating bugs in our code! Namespaces are one
    way to avoid these bugs, and in Python, we can do this by using Python modules
    (which are unofficial namespaces).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望命名冲突在代码中产生错误！命名空间是避免这些错误的一种方法，在Python中，我们可以通过使用Python模块（这些是非官方的命名空间）来实现。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We can declare module-level **globals **in any module just above and outside
    functions.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在任何模块的任何函数上方和外部声明模块级**全局变量**。
- en: We then have to use the `global` Python keyword to refer to them. If we forget
    to use `global` in functions, we will accidentally create new local variables.
    This would be a bug and something we really do not want to do.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后必须使用Python的`global`关键字来引用它们。如果我们忘记在函数中使用`global`，我们将会意外地创建新的局部变量。这将是一个错误，是我们真的不想做的事情。
- en: Python is a dynamic, strongly typed language. We will notice bugs such as this
    (forgetting to scope variables with the `global` keyword) only at runtime.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种动态的强类型语言。我们将在运行时注意到像这样的错误（忘记使用`global`关键字来限定变量的作用域）。
- en: How to do it…
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add the following code to the GUI we used in the previous recipe, *How to get
    data from a widget*, creating a module-level global variable. We use the all-uppercase
    convention for constants:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到之前菜谱中使用的GUI，即*如何从小部件获取数据*，创建一个模块级全局变量。我们使用全部大写约定来表示常量：
- en: You can find more information in **PEP 8 -- Style Guide for Python Code** at [https://www.python.org/dev/peps/pep-0008/#constants](https://www.python.org/dev/peps/pep-0008/#constants).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.python.org/dev/peps/pep-0008/#constants](https://www.python.org/dev/peps/pep-0008/#constants)上的**PEP
    8 -- Python代码风格指南**中找到更多信息。
- en: Open `GUI_data_from_widget.py` and save the module as `GUI_const_42_print.py`.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_data_from_widget.py`并将其模块保存为`GUI_const_42_print.py`。
- en: 'Add the constant variable at the top and the `print` statement at the bottom
    of the module:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块顶部添加常量变量，并在底部添加`print`语句：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Running the code results in a printout of the `global`. Note 42 being printed
    to the Eclipse console (`GUI_const_42_print.py`):'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码会导致打印出`global`。注意42被打印到Eclipse控制台（`GUI_const_42_print.py`）：
- en: '![](img/18585c62-9166-43f4-8f70-eb68ae38d6bb.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/18585c62-9166-43f4-8f70-eb68ae38d6bb.png)'
- en: 'Add the `usingGlobal` function toward the bottom of the module:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将`usingGlobal`函数添加到模块底部：
- en: Open `GUI_const_42_print.py` and save the module as `GUI_const_42_print_func.py`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_const_42_print.py`并将其模块保存为`GUI_const_42_print_func.py`。
- en: 'Add the function and then call it:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加函数然后调用它：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following screenshot shows the final `GUI_const_42_print_func.py` code
    and the output after running the code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了最终的`GUI_const_42_print_func.py`代码和运行代码后的输出：
- en: '![](img/ec32da05-1b4b-4505-ac9f-a06e36e7bfc5.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ec32da05-1b4b-4505-ac9f-a06e36e7bfc5.png)'
- en: 'In the preceding code snippet, we use the module-level `global`. It is easy
    to make a mistake by *shadowing* the `global`, as demonstrated in the following
    code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用了模块级的`global`。很容易通过*遮蔽*全局变量来犯错误，如下面的代码所示：
- en: Open `GUI_const_42_print_func.py` and save the module as `GUI_const_42_777.py`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_const_42_print_func.py`并将模块保存为`GUI_const_42_777.py`。
- en: 'Add the declaration of the constant within the function:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数内添加常量的声明：
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following screenshot shows the final `GUI_const_42_777.py` code and the
    output after running the code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了最终的`GUI_const_42_777.py`代码和运行代码后的输出：
- en: '![](img/8319b1c4-856b-4f2f-bd19-476603bd1212.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8319b1c4-856b-4f2f-bd19-476603bd1212.png)'
- en: Note how 42 becomes 777, even though we are using the same variable name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意42变成了777，尽管我们使用的是相同的变量名。
- en: There is no compiler in Python that warns us if we override `global` variables
    in a local function. This can lead to difficulties in debugging at runtime.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Python中没有编译器会警告我们在局部函数中覆盖`全局`变量。这可能导致运行时调试困难。
- en: 'If we try to print out the value of the global variable, without using the `global` keyword,
    we get an error:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试在不使用`全局`关键字的情况下打印出全局变量的值，我们会得到一个错误：
- en: Open `GUI_const_42_777.py` and save the module as `GUI_const_42_777_global_print_error.py`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_const_42_777.py`并将模块保存为`GUI_const_42_777_global_print_error.py`。
- en: 'Comment out `global` and try to print:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉`全局`并尝试打印：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Run the code and observe the output:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/7fa827ff-bdd9-4ac9-8734-36731565d8d2.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7fa827ff-bdd9-4ac9-8734-36731565d8d2.png)'
- en: 'When we qualify our local variable with the `global` keyword, we can print
    out the value of the `global` variable and overwrite this value locally:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`全局`关键字限定我们的局部变量时，我们可以打印出`全局`变量的值并局部覆盖此值：
- en: Open `GUI_const_42_777_global.py`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_const_42_777_global.py`。
- en: 'Add the following code:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the code and observe the output:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/ebd144a8-b0dc-489d-a062-9a603ae6fe7b.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ebd144a8-b0dc-489d-a062-9a603ae6fe7b.png)'
- en: We might believe that the value of the global variable is local to our function.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能认为全局变量的值仅限于我们的函数。
- en: Open `GUI_const_42_777_global.py` and save as `GUI_const_42_777_global_shadowing.py`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_const_42_777_global.py`并将其保存为`GUI_const_42_777_global_shadowing.py`。
- en: Add `print('GLOBAL_CONST:', GLOBAL_CONS``T)` below the function.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数下方添加`print('GLOBAL_CONST:', GLOBAL_CONS``T)`。
- en: 'Run the code and observe the output:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察输出：
- en: '![](img/7cfb263b-4094-4eb2-9e8d-b97936b723f6.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7cfb263b-4094-4eb2-9e8d-b97936b723f6.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We define a `global` variable at the top of our module, and we print out its
    value later, toward the bottom of our module.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在模块的顶部定义了一个`全局`变量，并在模块的底部打印出它的值。
- en: That works. We then define a function and print out the value of the `global`
    within the function by using the `global` keyword. If we forget to use the `global`
    keyword, we are creating a new, local variable. When we change the value of the
    global inside the function, this actually changes the global variable. As we can
    see, even outside of our function the global value has changed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这有效。然后我们定义一个函数，并使用`全局`关键字在函数内打印出`全局`变量的值。如果我们忘记使用`全局`关键字，我们正在创建一个新的、局部的变量。当我们更改函数内全局变量的值时，这实际上会改变全局变量。正如我们所看到的，即使在我们的函数之外，全局值也发生了变化。
- en: '`global` variables can be very useful when programming small applications.
    They can help us make data available across methods and functions within the same
    Python module and, sometimes, the overhead of OOP is not justified.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写小型应用程序时，`全局`变量非常有用。它们可以帮助我们在同一Python模块内的方法和函数之间共享数据，有时，面向对象的额外开销是不必要的。
- en: As our programs grow in complexity, the benefit we gain from using globals can
    quickly diminish.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的程序变得越来越复杂，使用全局变量的好处可能会迅速减少。
- en: It is best to avoid globals and accidentally shadowing variables by using the
    same name in different scopes. We can use OOP instead of using global variables.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最好避免使用全局变量，并通过在不同作用域中使用相同的名称意外地覆盖变量。我们可以使用面向对象编程而不是使用全局变量。
- en: We have played around with `global` variables within procedural code and have
    learned how it can lead to hard-to-debug bugs. In the next recipe, we will move
    on to OOP, which can eliminate such bugs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在过程式代码中玩弄过`全局`变量，并了解到它可能导致难以调试的错误。在下一个菜谱中，我们将转向面向对象编程，这可以消除此类错误。
- en: How coding in classes can improve the GUI
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何通过类编程改进GUI
- en: So far, we have been coding in a procedural style. This is a quick scripting
    method we can do in Python. When our code gets larger and larger, we need to advance
    to coding in OOP.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在以过程式风格编写代码。这是我们可以用Python做的快速脚本方法。当我们的代码变得越来越大时，我们需要转向面向对象编程。
- en: Why?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？
- en: Because, among many other benefits, OOP allows us to move code around by using
    methods. Once we use classes, we no longer have to physically place the code above
    the code that calls it. This gives us great flexibility in organizing our code.
    We can write the related code next to the other code and no longer have to worry
    that the code will not run because the code does not sit above the code that calls
    it. We can take that to some rather fancy extremes by coding up modules that refer
    to methods that are not being created within that module. They rely on the runtime
    state having created those methods during the time the code runs.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因为，在许多其他好处中，面向对象编程（OOP）允许我们通过使用方法来移动代码。一旦我们使用了类，我们就不再需要物理地将代码放在调用它的代码上方。这给了我们在组织代码方面很大的灵活性。我们可以将相关代码写在与其他代码相邻的位置，并且不再需要担心代码无法运行，因为代码没有放在调用它的代码上方。我们可以通过编写引用该模块中未创建的方法的模块来达到一些相当高级的效果。它们依赖于在代码运行时已经创建了这些方法。
- en: If the methods we call have not been created by that time, we get a runtime
    error.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用的方法那时还没有被创建，我们会得到一个运行时错误。
- en: Getting ready
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will turn our entire procedural code into OOP very simply. We just turn it
    into a class, indent all the existing code, and prepend `self` to all variables.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将非常简单地把我们整个过程性代码转换为面向对象编程。我们只需将其转换为一个类，缩进所有现有代码，并将 `self` 前缀添加到所有变量上。
- en: It is very easy.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单。
- en: While at first it might feel a little bit annoying having to prepend everything
    with the `self` keyword, making our code more verbose (<q>hey, we are wasting
    so much paper…</q>), in the end it is worth it.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能觉得需要在每件事前都加上 `self` 关键字有点烦人，这使得我们的代码更加冗长（<q>嘿，我们浪费了这么多纸张…</q>），但最终这是值得的。
- en: How to do it…
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: Note that in the Eclipse IDE, the PyDev editor hints at coding problems by highlighting
    them in red on the right-hand side portion of the code editor.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 Eclipse IDE 中，PyDev 编辑器通过在代码编辑器的右侧部分用红色突出显示来提示编码问题。
- en: Open `GUI_const_42_777_global.py` and save the module as `GUI_OOP_classes.py`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_const_42_777_global.py` 并将模块保存为 `GUI_OOP_classes.py`。
- en: Highlight the entire code below the imports and indent it by four spaces.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高亮显示导入下面的整个代码，并缩进四个空格。
- en: Add `class OOP():` above the indented code.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在缩进的代码上方添加 `class OOP():`。
- en: 'Look at all of the red errors in the code editor on the right-hand side:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 看看右侧代码编辑器中所有的红色错误：
- en: '![](img/f853c7d0-376d-419c-9be3-7cda5f228967.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f853c7d0-376d-419c-9be3-7cda5f228967.png)'
- en: We have to prepend all the variables with the `self` keyword and also bind the
    functions to the class by using `self`, which officially and technically turns
    the functions into methods.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将所有变量都加上 `self` 关键字，并且通过使用 `self` 将函数绑定到类上，这在官方和技术上正式地将函数转换为方法。
- en: 'Let''s prefix everything with `self` to fix all of the red so we can run our
    code again:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用 `self` 前缀来修复所有的红色错误，这样我们就可以再次运行我们的代码：
- en: Open `GUI_OOP_classes.py` and save the module as `GUI_OOP_2_classes.py`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_OOP_classes.py` 并将模块保存为 `GUI_OOP_2_classes.py`。
- en: Add the `self` keyword wherever it is needed, for example, `click_me(self)`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在需要的地方添加 `self` 关键字，例如，`click_me(self)`。
- en: 'Run the code and observe it:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并观察它：
- en: '![](img/a6a8afb0-489a-487a-bdc8-80a7335a3ad6.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a6a8afb0-489a-487a-bdc8-80a7335a3ad6.png)'
- en: Once we do this for all of the errors highlighted in red, we can run our Python
    code again. The `click_me` function is now bound to the class and has officially
    become a method. We are no longer getting any errors that prevent the code from
    running.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们为所有高亮的红色错误做了这件事，我们就可以再次运行我们的 Python 代码。`click_me` 函数现在绑定到了类上，并正式成为了一个方法。我们不再得到任何阻止代码运行的错误。
- en: 'Now let''s add our `ToolTip` class from [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml), *Look
    and Feel Customization*, into this Python module:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将来自 [第 3 章](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml)，*外观和感觉定制* 的 `ToolTip`
    类添加到这个 Python 模块中：
- en: Open `GUI_OOP_2_classes.py`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_OOP_2_classes.py`。
- en: 'Add the `ToolTip` class from `GUI_tooltip.py` to the top of the following module''s
    `import` statements:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `GUI_tooltip.py` 中的 `ToolTip` 类添加到以下模块的 `import` 语句的顶部：
- en: '[PRE21]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入幕后，更好地理解代码。
- en: How it works…
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We are translating our procedural code into object-oriented code. First, we
    indented the entire code and defined the code to be part of a class, which we
    named `OOP`. In order to make this work, we have to use the `self` keyword for
    both variables and methods. Here is a brief comparison of our previous code with
    the new OOP code using a class:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将过程代码转换为面向对象的代码。首先，我们缩进整个代码，并定义代码是类的一部分，我们将其命名为`OOP`。为了使这可行，我们必须使用`self`关键字来表示变量和方法。以下是我们的旧代码与使用类的新OOP代码的简要比较：
- en: '[PRE22]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We moved the callback methods to the top of the module, inside the new `OOP`
    class. We moved all the widget-creation code into one rather long method, `create_widgets`,
    which we call in the initializer of the class. Technically, deep underneath the
    hood of the low-level code Python does have a constructor, yet Python frees us
    from any worries about this. It is taken care of for us. Instead, in addition
    to a real constructor, Python provides us with an initializer, `__init__(self)`.
    We are strongly encouraged to use this initializer. We can use it to pass in arguments
    to our class, initializing variables we wish to use inside our class instance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回调方法移动到模块顶部，在新的`OOP`类内部。我们将所有小部件创建代码移动到一个相当长的`create_widgets`方法中，我们在类的初始化器中调用这个方法。技术上，在底层代码的深处，Python确实有一个构造函数，但Python让我们免除了对此类问题的担忧。它由我们负责。除了真正的构造函数之外，Python还为我们提供了一个初始化器，`__init__(self)`。我们强烈建议使用这个初始化器。我们可以用它向我们的类传递参数，初始化我们希望在类实例内部使用的变量。
- en: In the end, we added the `ToolTip` class to the top of our module just below
    the `import` statements.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在模块顶部添加了`ToolTip`类，紧位于`import`语句之下。
- en: In Python, several classes can exist within the same Python module and the module
    name does not have to be the same as the class name.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，同一个Python模块中可以存在多个类，并且模块名称不必与类名称相同。
- en: Here, in this recipe, we can see that more than one class can live in the same
    Python module.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们可以看到，同一个Python模块中可以存在多个类。
- en: 'Cool stuff, indeed! Here are two screenshots of the two classes residing in
    the same module:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 确实很酷！以下是两个同一模块中驻留的两个类的屏幕截图：
- en: '![](img/56dfa16e-0c33-4574-8b94-2c90a679e929.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/56dfa16e-0c33-4574-8b94-2c90a679e929.png)'
- en: 'Both the `ToolTip` class and the `OOP` class reside within the same Python
    module, `GUI_OOP_2_classes.py`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToolTip`类和`OOP`类都位于同一个Python模块`GUI_OOP_2_classes.py`中：'
- en: '![](img/6555f80c-5f89-46ed-a9a4-7241103518ef.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6555f80c-5f89-46ed-a9a4-7241103518ef.png)'
- en: In this recipe, we advanced our procedural code into OOP code. Python enables
    us to write code in both a practical and a procedural style, like the C programming
    language style. At the same time, we have the option to code in an OOP style,
    like the Java, C#, and C++ style.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将我们的过程代码提升到了面向对象的代码。Python使我们能够以实用和过程式的方式编写代码，就像C编程语言风格一样。同时，我们有选择以面向对象的方式编码的选项，就像Java、C#和C++风格一样。
- en: We've successfully learned how coding in classes can improve the GUI. Now let's
    move on to the next recipe.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功地学习了如何在类中编码可以改进GUI。现在让我们继续下一个菜谱。
- en: Writing callback functions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写回调函数
- en: At first, callback functions can seem to be a little bit intimidating. You call
    the function, passing it some arguments, and then the function tells you that
    it is really very busy and it will call you back!
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，回调函数可能看起来有点令人畏惧。你调用函数，传递一些参数，然后函数告诉你它真的很忙，它将回叫你！
- en: 'You wonder: will this function ever call me back? And how long do I have to
    wait? In Python, even callback functions are easy and, yes, they usually do call
    you back. They just have to complete their assigned task first (<q>hey, it was
    you who coded them in the first place…</q>).'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：这个函数会回叫我吗？我需要等多久？在Python中，即使是回调函数也很容易，是的，它们通常会回叫你。它们只是必须首先完成分配的任务（“嘿，是你最初编写它们的…”）。
- en: Let's learn a little bit more about what happens when we code callbacks into
    our GUI. Our GUI is event-driven. After it has been created and displayed onscreen,
    it typically sits there waiting for an event to happen. It is basically waiting
    for an event to be sent to it. We can send an event to our GUI by clicking one
    of its buttons. This creates an event and, in a sense, we called our GUI by sending
    it a message.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解一下，当我们把回调函数编码到我们的GUI中时会发生什么。我们的GUI是事件驱动的。创建并显示在屏幕上后，它通常就坐在那里等待事件发生。它基本上是在等待一个事件发送给它。我们可以通过点击其按钮之一来向我们的GUI发送一个事件。这创建了一个事件，从某种意义上说，我们通过发送消息来调用我们的GUI。
- en: Now, what is supposed to happen after we send a message to our GUI? What happens
    after clicking the button depends on whether we created an event handler and associated
    it with this button. If we did not create an event handler, clicking the button
    will have no effect. The event handler is a callback function (or method, if we
    use classes). The callback method is also sitting there passively, like our GUI,
    waiting to be invoked. Once our GUI's button is clicked, it will invoke the callback.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们向我们的 GUI 发送消息后，会发生什么？点击按钮后会发生什么取决于我们是否创建了一个事件处理程序并将其与该按钮关联。如果我们没有创建事件处理程序，点击按钮将没有任何效果。事件处理程序是一个回调函数（或方法，如果我们使用类）。回调方法也像我们的
    GUI 一样被动地等待被调用。一旦我们的 GUI 的按钮被点击，它将调用回调。
- en: The callback often does some processing and, when done, it returns the result
    to our GUI.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 回调通常执行一些处理，完成后将结果返回到我们的 GUI。
- en: In a sense, we can see that our callback function is calling our GUI back.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们可以看到我们的回调函数正在调用我们的 GUI。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The Python interpreter runs through all the code in a module once, finding any
    syntax errors and pointing them out. You cannot run your Python code if you do
    not have the syntax right. This includes indentation (if not resulting in a syntax
    error, incorrect indentation usually results in a bug).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Python 解释器会遍历模块中的所有代码一次，寻找任何语法错误并指出。如果你的语法不正确，你无法运行你的 Python 代码。这包括缩进（如果不导致语法错误，不正确的缩进通常会导致错误）。
- en: On the next parsing round, the interpreter interprets our code and runs it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个解析循环中，解释器解析我们的代码并运行它。
- en: At runtime, many GUI events can be generated, and it is usually callback functions
    that add functionality to GUI widgets.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，可以生成许多 GUI 事件，通常回调函数会给 GUI 小部件添加功能。
- en: How to do it…
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点……
- en: 'Here is the callback for the `Spinbox` widget:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `Spinbox` 小部件的回调：
- en: Open `GUI_OOP_2_classes.py`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `GUI_OOP_2_classes.py` 文件。
- en: 'Observe the `_spin(self)` method in the code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察代码中的 `_spin(self)` 方法：
- en: '![](img/2e02ce01-c01f-4504-8ada-018d97f271aa.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e02ce01-c01f-4504-8ada-018d97f271aa.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解代码，以更好地理解它。
- en: How it works…
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: We create a callback method in the `OOP` class that gets called when we select
    a value from the `Spinbox` widget because we bind the method to the widget via
    the `command` argument (`command=self._spin`). We use a leading underscore to
    hint at the fact that this method is meant to be respected like a private Java
    method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `OOP` 类中创建一个回调方法，当我们在 `Spinbox` 小部件中选择一个值时会被调用，因为我们通过 `command` 参数（`command=self._spin`）将方法绑定到小部件。我们使用前导下划线来暗示这个方法意味着要像私有
    Java 方法一样被尊重。
- en: Python intentionally avoids language restrictions, such as private, public,
    friend, and so on. In Python, we use naming conventions instead. Leading and trailing
    double underscores surrounding a keyword are expected to be restricted to the
    Python language, and we are expected not to use them in our own Python code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Python 故意避免了语言限制，例如私有、公有、友元等。在 Python 中，我们使用命名约定。围绕关键字的前后双下划线通常被期望是 Python 语言的限制，并且我们期望不在自己的
    Python 代码中使用它们。
- en: However, we can use a leading underscore prefix with a variable name or function
    to provide a hint that this name is meant to be respected as a private helper.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以使用前导下划线前缀与变量名或函数来提供提示，表明这个名称意味着要像私有辅助程序一样被尊重。
- en: 'At the same time, we can postfix a single underscore if we wish to use what
    otherwise would be built-in Python names. For example, if we wished to abbreviate
    the length of a list, we could do the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，如果我们希望使用否则将是内置 Python 名称的名称，我们可以后缀一个单下划线。例如，如果我们想缩短列表的长度，我们可以这样做：
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Often, the underscore is hard to read and easy to overlook, so this might not
    be the best idea in practice.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，下划线难以阅读且容易忽略，所以在实践中这可能不是最好的主意。
- en: We've successfully learned how to write callback functions. Now let's move on
    to the next recipe.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功学习了如何编写回调函数。现在让我们继续下一个配方。
- en: Creating reusable GUI components
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重用的 GUI 组件
- en: We will create reusable GUI components using Python. In this recipe, we will
    keep it simple by moving our `ToolTip` class into its own module. Then, we will
    import and use it to display tooltips over several widgets of our GUI.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Python 创建可重用的 GUI 组件。在这个配方中，我们将通过将我们的 `ToolTip` 类移动到其自己的模块中来保持简单。然后，我们将导入并使用它来显示
    GUI 中几个小部件的工具提示。
- en: Getting ready
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are building our code from [Chapter 3](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml),
    *Look and Feel Customization*: `GUI_tooltip.py`. We will start by breaking out
    our `ToolTip` class into a separate Python module.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在从[第3章](ad17a5cd-0b92-4796-96b8-35151c3bbf44.xhtml)，*外观和感觉定制*：`GUI_tooltip.py`构建我们的代码。我们将首先将我们的`ToolTip`类分离到一个单独的Python模块中。
- en: How to do it…
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will create a new Python module and place the `ToolTip` class code into
    it and then import this module into our primary module:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Python模块，并将`ToolTip`类的代码放入其中，然后将其导入到我们的主模块中：
- en: Open `GUI_OOP_2_classes.py` and save the module as `GUI_OOP_class_imported_tooltip.py`.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`GUI_OOP_2_classes.py`并将模块保存为`GUI_OOP_class_imported_tooltip.py`。
- en: Break out the `ToolTip` code from `GUI_tooltip.py` into a new Python module
    and name the module `ToolTip.py`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GUI_tooltip.py`中的`ToolTip`代码分离到一个新的Python模块中，并命名为`ToolTip.py`。
- en: 'Import the `ToolTip` class into `GUI_OOP_class_imported_tooltip.py`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ToolTip`类导入到`GUI_OOP_class_imported_tooltip.py`：
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following code to `GUI_OOP_class_imported_tooltip.py`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`GUI_OOP_class_imported_tooltip.py`：
- en: '[PRE25]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Run the code and hover the mouse over the different widgets:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码并将鼠标悬停在不同的小部件上：
- en: '![](img/57a0d7d6-f7c0-4cf5-9732-470ec6d138bd.png)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/57a0d7d6-f7c0-4cf5-9732-470ec6d138bd.png)'
- en: 'This also works on the second tab:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这也适用于第二个标签页：
- en: '![](img/b764cef7-fe59-4565-978b-f470e2d52261.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b764cef7-fe59-4565-978b-f470e2d52261.png)'
- en: Let's go behind the scenes to understand the code better.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入幕后，更好地理解代码。
- en: How it works…
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: First, we created a new Python module and placed the `ToolTip` class into this
    new module. Then, we imported this `ToolTip` class into a different Python module.
    After that, we created several tooltips using the class.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个新的Python模块，并将`ToolTip`类放入这个新模块中。然后，我们将这个`ToolTip`类导入到另一个Python模块中。之后，我们使用这个类创建了几个工具提示。
- en: In the preceding screenshots, we can see several `ToolTip` messages being displayed.
    The one for the main window might appear a little bit annoying, so it is better
    not to display a `ToolTip` for the main window because we really wish to highlight
    the functionality of the individual widgets. The main window form has a title
    that explains its purpose; no need for a `ToolTip`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到几个`ToolTip`消息正在显示。对于主窗口的工具提示可能会显得有点烦人，所以最好不为主窗口显示`ToolTip`，因为我们真的希望突出各个小部件的功能。主窗口表单有一个标题来解释其目的；不需要`ToolTip`。
- en: Refactoring our common `ToolTip` class code out into its own module helps us
    reuse this code from other modules. Instead of copy/paste/modify, we use the **DRY** **principle** and
    our common code is located in only one place, so when we modify the code, all
    modules that import it will automatically get the latest version of our module.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们共同的`ToolTip`类代码重构到它自己的模块中，有助于我们从其他模块重用这段代码。而不是复制/粘贴/修改，我们使用**DRY**原则，并且我们的共同代码只位于一个地方，所以当我们修改代码时，所有导入它的模块都将自动获取我们模块的最新版本。
- en: '**DRY** is short for **Don''t Repeat Yourself**, and we will look at it again
    in a later chapter. We can do similar things by turning our Tab 3 image into a
    reusable component. To keep this recipe''s code simple, we removed Tab 3, but
    you can experiment with the code from the previous chapter.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**DRY**代表**不要重复自己**，我们将在后面的章节中再次讨论它。我们可以通过将我们的Tab 3图像转换成一个可重用组件来做类似的事情。为了使这个菜谱的代码简单，我们移除了Tab
    3，但你可以在前一章的代码上进行实验。'
