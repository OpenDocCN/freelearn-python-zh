- en: Chapter 1. Testing for Fun and Profit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：测试以乐趣和利润为目的
- en: '*You''re a programmer: a coder, a developer, or maybe a hacker! As such, it''s
    almost impossible that you haven''t had to sit down with a program that you were
    sure was ready for use—or worse yet, a program you knew was not ready—and put
    together a bunch of tests to prove it. It often feels like an exercise in futility,
    or at best a waste of time. We''ll learn how to avoid that situation, and make
    testing an easy and enjoyable process.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*你是一名程序员：一个编码者、开发者，或者可能是一名黑客！作为这样的角色，你几乎不可能没有坐下来检查一个你确信已经准备好使用的程序——或者更糟糕的是，一个你知道还没有准备好的程序——并编写一系列测试来证明它的正确性。这通常感觉像是一项徒劳的练习，或者最多是浪费时间。我们将学习如何避免这种情况，使测试变得简单且愉快。*'
- en: '*This book is going to show you a new way to test, a way that puts much of
    the burden of testing right where it should be: on the computer. Even better,
    your tests will help you to find problems early and tell you just where they are,
    so that you can fix them easily. You''ll love the easy, helpful methods of automated
    testing and test-driven development that you will learn about in this book.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*这本书将向你展示一种新的测试方法，这种方法将测试的大部分负担放在了它应该放的地方：计算机上。更好的是，你的测试将帮助你早期发现问题，并告诉你它们在哪里，这样你就可以轻松地修复它们。你将爱上这本书中你将学到的简单、有用的自动化测试和测试驱动开发方法。*'
- en: '*The Python language has some of the best tools available, when it comes to
    testing. As a result, we''ll learn how to make testing something that is easy,
    quick, and fun by taking advantage of those tools.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*当谈到测试时，Python 语言拥有一些最好的工具。因此，我们将通过利用这些工具，学习如何使测试变得容易、快捷且有趣。*'
- en: 'In this book, we''ll:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将：
- en: Study popular testing tools such as doctest, unittest, and Nose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究流行的测试工具，如 doctest、unittest 和 Nose。
- en: Learn about testing philosophies like unit testing and test-driven development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解测试哲学，如单元测试和测试驱动开发。
- en: Examine the use of mock objects and other useful testing secrets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查使用模拟对象和其他有用的测试秘诀。
- en: Learn how to integrate testing with the other tools that we use, and with our
    workflow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何将测试与其他我们使用的工具以及我们的工作流程相结合。
- en: Introduce some secondary tools that make it easier to use the major testing
    tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍一些辅助工具，使使用主要测试工具变得更加容易。
- en: How can testing help?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试如何帮助？
- en: 'This chapter started with a lot of grandiose claims, such as: You''ll enjoy
    testing. You''ll rely on it to help you kill bugs early and easily. Testing will
    stop being a burden for you, and become something that you want to do. You may
    be wondering how this is possible?'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章开始时提出了许多宏伟的声明，例如：你会喜欢测试。你会依赖它来帮助你早期和轻松地消灭虫子。测试将不再成为你的负担，而变成你愿意去做的事情。你可能想知道这是怎么可能的？
- en: Think back to the last annoying bug that you had to deal with. It could have
    been anything; a database schema mismatch, or a bad data structure.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下你最近遇到的最后一个令人烦恼的错误。它可能是什么；数据库模式不匹配，或者糟糕的数据结构。
- en: Remember what caused the bug? The one line of code with a subtle logic error?
    The function that didn't do what the documents said it would do? Whatever it was,
    keep it in mind.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 记住是什么导致了错误？那一行有细微逻辑错误的代码？那个没有按照文档说明执行的功能？无论是什么，都要记住。
- en: Imagine a small chunk of code that could have caught the bug, if it had been
    run at the right time, and informed you about it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果有一小块代码在正确的时间运行，就能捕捉到错误，并通知你。
- en: Now imagine that all of your code was accompanied by those little chunks of
    test code, and that they are quick and easy to execute.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，如果你的所有代码都伴随着那些小块的测试代码，并且它们执行起来既快又简单。
- en: How long would your bug have survived? Not very long at all.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你的错误会持续多久？不会很久。
- en: That gives you a basic understanding of what we'll be talking about in this
    book. There are many tools and refinements that can make the process quicker and
    easier. The basic idea is to tell the computer what you expect, using simple and
    easily-written chunks of code, and then have the computer double-check your expectations
    throughout the coding process. As expectations are easy to describe, you can write
    them down first, allowing the computer to shoulder much of the burden of debugging
    your code. As a result, you can move on to interesting things while the computer
    keeps a track of everything else.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这就为你提供了一个基本理解，我们将在这本书中讨论什么。有许多工具和改进可以使这个过程更快、更简单。基本思想是告诉计算机你期望什么，使用简单且易于编写的代码块，然后让计算机在整个编码过程中双重检查你的期望。由于期望容易描述，你可以先写下来，让计算机承担调试代码的大部分负担。因此，你可以在计算机跟踪其他一切的同时，继续做有趣的事情。
- en: When you're done, you'll have a code base that is highly tested and that you
    can be confident in. You will have caught your bugs early and fixed them quickly.
    The best part is that your testing was done by the computer based on what you
    told it you wanted the program to do. After all, why should you do it, when the
    computer can do it for you?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成时，你将拥有一个高度测试的代码库，你可以对其充满信心。你将能够尽早捕捉到错误并迅速修复它们。最好的部分是，你的测试是基于你告诉计算机程序应该做什么来进行的。毕竟，为什么你要亲自做，当计算机可以为你做的时候？
- en: I have programmed simple automated tests to catch everything from minor typos,
    to instances of database access code being left dangerously out of date after
    a schema change, and pretty much any other bug you can imagine. The tests caught
    the errors quickly, and pinpointed their locations. A great deal of effort and
    bother was avoided because they were there.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经编写了简单的自动化测试来捕捉从轻微的打字错误，到在模式更改后数据库访问代码被危险地留在了过时状态的情况，以及几乎任何你能想象到的其他错误。测试迅速捕捉到错误，并确定了它们的位置。由于它们的存在，避免了大量的努力和麻烦。
- en: Imagine the time that you'll save or spend on writing new features, instead
    of chasing old bugs. Better code, written more quickly, has a good cost/benefit
    ratio. Testing the right way really is both more fun and more profitable.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你将节省或花费在编写新功能上的时间，而不是追逐旧错误。编写更快的代码，有良好的成本效益比。正确地进行测试确实既有趣又有利可图。
- en: Types of testing
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: Testing is commonly divided into several categories, based on how complex the
    component being tested is. Most of our time will be focused on the lowest level—unit
    testing—because tests in the other categories operate on pretty much the same
    principles.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常根据被测试组件的复杂程度分为几个类别。我们的大部分时间将集中在最低级别——单元测试——因为其他类别的测试基本上遵循相同的原理。
- en: Unit testing
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit testing is testing of the smallest possible pieces of a program. Often,
    this means individual functions or methods. The keyword here is individual; something
    is a *unit* if it there's no meaningful way to divide it up further.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试是对程序可能的最小部分进行的测试。通常，这意味着单个函数或方法。这里的重点是单个；如果没有什么有意义的办法可以进一步分割它，那么它就是一个*单元*。
- en: Unit tests are used to test a single unit in isolation, verifying that it works
    as expected, without considering what the rest of the program would do. This protects
    each unit from inheriting bugs from mistakes made elsewhere, and makes it easy
    to narrow down on the actual problem.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用于单独测试单个单元，验证它是否按预期工作，而不考虑程序的其他部分会做什么。这保护每个单元免受其他地方犯下的错误的影响，并使得缩小到实际问题变得容易。
- en: By itself, unit testing isn't enough to confirm that a complete program works
    correctly, but it's the foundation upon which everything else is based. You can't
    build a house without solid materials, and you can't build a program without units
    that work as expected!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单独来看，单元测试不足以确认完整程序是否正确工作，但它是一切其他事物的基础。没有坚固的材料，你不能建造房子；没有按预期工作的单元，你不能建造程序！
- en: Integration testing
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: In integration testing, the boundaries of isolation are pushed further back,
    so that the tests encompass interactions between related units. Each test should
    still be run in isolation, to avoid inheriting problems from outside, but now
    the test checks whether the tested units behave correctly as a group.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在集成测试中，隔离的边界被进一步推后，因此测试涵盖了相关单元之间的交互。每个测试仍然应该单独运行，以避免从外部继承问题，但现在测试检查的是被测试的单元是否作为一个整体正确地表现。
- en: Integration testing can be performed with the same tools as unit testing. For
    this reason, newcomers to automated testing are sometimes lured into ignoring
    the distinction between unit testing and integration testing. Ignoring this distinction
    is dangerous, because such multipurpose tests often make assumptions about the
    correctness of some of the units that they involve. This means that the tester
    loses much of the benefit which automated testing would have granted. We're not
    aware of the assumptions we make until they bite us, so we need to consciously
    choose to work in a way that minimizes assumptions. That's one of the reasons
    why I refer to test-driven development as a *discipline*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试可以使用与单元测试相同的工具进行。因此，自动化测试的新手有时会被诱使忽视单元测试和集成测试之间的区别。忽视这个区别是危险的，因为这样的多功能测试通常会对它们所涉及的某些单元的正确性做出假设。这意味着测试者失去了自动化测试本应带来的许多好处。我们直到它们咬我们才会意识到我们做出的假设，因此我们需要有意识地选择以最小化假设的方式工作。这就是为什么我把测试驱动开发称为*纪律*的原因。
- en: System testing
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统测试
- en: System testing extends the boundaries of isolation even further, to the point
    where they don't even exist. System tests check parts of the program, after the
    whole thing has been plugged together. In a sense, system tests are an extreme
    form of integration tests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试将隔离的边界扩展得甚至更远，到了它们甚至不存在的地方。系统测试在将整个程序连接在一起之后检查程序的部分。从某种意义上说，系统测试是集成测试的一种极端形式。
- en: System tests are very important, but they're not very useful without integration
    tests and unit tests. You have to be sure of the pieces before you can be sure
    of the whole. If there's a subtle error somewhere, system testing will tell you
    that it exists, but not where it is or how to fix it. The odds are good that you've
    experienced that situation before; it's probably why you hate testing.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试非常重要，但没有集成测试和单元测试，它们几乎没有什么用处。在你能确信整体之前，你必须确信各个部分。如果某个地方存在细微的错误，系统测试会告诉你它存在，但不会告诉你它在哪或如何修复它。你很可能之前经历过这种情况；这可能是你讨厌测试的原因。
- en: You've got Python, right?
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你有Python，对吧？
- en: 'This book assumes that you have working knowledge of the Python programming
    language, and that you have a fully functional Python interpreter available. The
    assumption is that you have at least version 2.6 of Python, which you can download
    from [http://www.python.org/](http://www.python.org/). If you have an earlier
    version, don''t worry: there are sidebars that will help you navigate the differences.
    You''ll also need your favorite text editor.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 本书假设您对Python编程语言有实际的知识，并且您有一个功能齐全的Python解释器可用。假设您至少有Python 2.6版本，您可以从[http://www.python.org/](http://www.python.org/)下载。如果您有更早的版本，不用担心：这里有一些侧边栏可以帮助您了解差异。您还需要您最喜欢的文本编辑器。
- en: Summary
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned what this book is about and what to expect from
    it. We took a glance at the philosophy of automated testing and test-driven development.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了这本书的内容以及可以期待什么。我们简要地了解了自动化测试和测试驱动开发的哲学。
- en: 'We talked about the different types of tests that combine together to form
    a complete suite of tests for a program, namely: unit tests, integration tests,
    and system tests. We learned that unit tests are related to the fundamental components
    of a program (such as functions), integration tests cover larger swaths of a program
    (like modules), and system tests encompass testing a program in its entirety.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了不同类型的测试组合在一起形成一个完整的测试套件，即：单元测试、集成测试和系统测试。我们了解到单元测试与程序的基本组件（如函数）相关，集成测试覆盖程序更大的部分（如模块），而系统测试则涵盖整个程序的测试。
- en: We learned about how automated testing can help us, by moving the burden of
    testing mostly onto the computer. You can tell the computer how to check your
    code, instead of having to do the checks for yourself. That makes it convenient
    to check your code earlier and more often, saves you from overlooking the things
    that you would otherwise miss, and helps you quickly locate and fix bugs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何通过将测试的大部分负担转移到计算机上来，自动化测试能帮助我们。你可以告诉计算机如何检查你的代码，而不是自己亲自进行检查。这使得在早期和更频繁地检查代码变得方便，让你避免错过你本应注意到的事情，并帮助你快速定位和修复错误。
- en: We shed some light on test-driven development, the discipline of writing your
    tests first, and letting them tell you what needs to be done, in order to write
    the code you need.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对测试驱动开发进行了一些探讨，这是一种先编写测试，然后让它们告诉你需要做什么，以便编写所需代码的纪律。
- en: We also discussed the development environment that you'll need, in order to
    work through this book.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了您在阅读这本书的过程中所需的发展环境。
- en: Now that we've learned about the lay of the land (so to speak), we're ready
    to start writing tests—which is the topic of the next chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经了解了这片土地的情况（换句话说），我们现在准备开始编写测试——这是下一章的主题。
