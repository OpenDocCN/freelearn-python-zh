- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Using a Non-Relational Database
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非关系型数据库
- en: So far, we have learned that relational databases store data using table columns
    and rows. All these table records are structurally optimized and designed using
    different keys, such as primary, unique, and composite keys. The tables are connected
    using foreign/reference keys. Foreign key integrity plays a significant role in
    the table relationship of a database schema because it gives consistency and integrity
    to the data that’s persisted in the tables. [*Chapter 5*](B17975_05.xhtml#_idTextAnchor107),
    *Connecting to a Relational Database*, provided considerable proof that FastAPI
    can connect to relational databases using any of the present ORMs smoothly without
    lots of complexities. This time, we will focus on using non-relational databases
    as data storage for our FastAPI microservice application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解到关系型数据库使用表列和行来存储数据。所有这些表记录都是通过不同的键（如主键、唯一键和组合键）进行结构优化和设计的。表通过外键/参考键连接。外键完整性在数据库模式表的表关系方面起着重要作用，因为它为存储在表中的数据提供了一致性和完整性。[第
    5 章](B17975_05.xhtml#_idTextAnchor107)，*连接到关系型数据库*，提供了相当多的证据，表明 FastAPI 可以通过任何现有的
    ORM 平滑地连接到关系型数据库，而无需大量复杂性。这次，我们将专注于将非关系型数据库作为我们的 FastAPI 微服务应用程序的数据存储。
- en: If FastAPI uses ORM for relational databases, it uses **Object Document Mapping**
    (**ODM**) to manage data using non-relational data stores or **NoSQL** databases.
    There are no tables, keys, and foreign key constraints involved in ODM, but a
    JSON document is needed to hold the various pieces of information. Different NoSQL
    databases vary in the storage model type that’s used to store data. The simplest
    among these databases manages data as key-value pairs, such as **Redis**, while
    complicated databases utilize schema-free document structures easily mapped to
    objects. This is usually done in **MongoDB**. Some use columnar data stores such
    as **Cassandra**, while some have graph-oriented data storage such as **Neo4j**.
    However, this chapter will focus on the FastAPI-MongoDB connectivity and the different
    ODM we can apply to pursue data management with a document-based database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 FastAPI 使用 ORM 进行关系型数据库，它使用 **对象文档映射** (**ODM**) 来管理使用非关系型数据存储或 **NoSQL**
    数据库的数据。ODM 不涉及表、键和外键约束，但需要一个 JSON 文档来存储各种信息。不同的 NoSQL 数据库在存储模型类型上有所不同，用于存储数据。这些数据库中最简单的是将数据管理为键值对，例如
    **Redis**，而复杂的数据库则使用无模式的文档结构，这些结构可以轻松地映射到对象。这通常在 **MongoDB** 中完成。一些使用列式数据存储，如
    **Cassandra**，而一些则具有图导向的数据存储，如 **Neo4j**。然而，本章将重点介绍 FastAPI-MongoDB 连接以及我们可以应用的不同
    ODM，以实现基于文档的数据库的数据管理。
- en: The main objective of this chapter is to study, formalize, and scrutinize different
    ways to use MongoDB as a database for our FastAPI application. Building the repository
    layer and showcasing the CRUD implementation will be the main highlight.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标是研究、规范和审查不同的方法，以将 MongoDB 作为我们的 FastAPI 应用程序的数据库。构建存储库层和展示 CRUD 实现将是主要亮点。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the database environment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置数据库环境
- en: Applying the PyMongo driver for synchronous connections
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用 PyMongo 驱动程序进行同步连接
- en: Creating asynchronous CRUD transactions using Motor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Motor 创建异步 CRUD 事务
- en: Implementing CRUD transactions using MongoEngine
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoEngine 实现CRUD事务
- en: Implementing asynchronous CRUD transactions using Beanie
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Beanie 实现异步 CRUD 事务
- en: Building an asynchronous repository for FastAPI using ODMantic
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ODMantic 为 FastAPI 构建异步存储库
- en: Creating CRUD transactions using MongoFrames
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 MongoFrames 创建 CRUD 事务
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter focuses on an eBookstore web portal, *online book reselling system*,
    where users can sell and buy books from home through the internet. The virtual
    store allows users to view the *sellers' profiles*, *book catalogs*, *list of
    orders*, and *archive of purchases*. When it comes to the e-commerce side, the
    user can select their preferred books and add them to a cart. Then, they can check
    out the items as orders and pursue the payment transaction afterward. All the
    data is stored in a MongoDB database. The code for this chapter can be found at
    [https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)
    in the `ch06` project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍一个电子书店网络门户，*在线图书转售系统*，用户可以通过互联网在家买卖书籍。虚拟商店允许用户查看*卖家资料*、*图书目录*、*订单列表*和*购买档案*。在电子商务方面，用户可以选择他们偏好的书籍并将它们添加到购物车中。然后，他们可以检查订单并随后进行支付交易。所有数据都存储在MongoDB数据库中。本章的代码可以在[https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI](https://github.com/PacktPublishing/Building-Python-Microservices-with-FastAPI)的`ch06`项目中找到。
- en: Setting up the database environment
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置数据库环境
- en: Before we start discussing the application’s database connectivity, we need
    to download the appropriate MongoDB database server from [https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community).
    *online book reselling system* uses MongoDB 5.0.5 for a Windows platform. The
    installation will provide default service configuration details for the service
    name, data directory, and log directory. However, it is advised that you use different
    directory paths instead of the default ones.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论应用程序的数据库连接之前，我们需要从[https://www.mongodb.com/try/download/community](https://www.mongodb.com/try/download/community)下载适当的MongoDB数据库服务器。*在线图书转售系统*在Windows平台上使用MongoDB
    5.0.5。安装将提供默认的服务配置详细信息，包括服务名称、数据目录和日志目录。然而，建议您使用不同的目录路径而不是默认路径。
- en: After the installation, we can start the MongoDB server by running `/bin/mongod.exe`.
    This will automatically create a database directory called `/data/db` in the `C:/`
    drive (Windows). We can place the `/data/db` directory in some other location,
    but be sure to run the `mongod` command with the `--dbpath` option while specifying
    `<new path>/data/db`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以通过运行`/bin/mongod.exe`来启动MongoDB服务器。这将自动在`C:/`驱动器（Windows）中创建一个名为`/data/db`的数据库目录。我们可以将`/data/db`目录放置在其他位置，但请确保在运行`mongod`命令时使用`--dbpath`选项并指定`<new
    path>/data/db`。
- en: 'The MongoDB platform has utilities that can aid in managing database collections,
    and one of them is **MongoDB Compass**. It can provide a GUI experience that allows
    you to browse, explore, and easily manipulate the database and its collections.
    Also, it has built-in performance metrics, query views, and schema visualization
    features that can help with scrutinizing the correctness of the database structure.
    The following screenshot shows the dashboard for MongoDB Compass version 1.29.6:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB平台有可以辅助管理数据库集合的工具，其中之一是**MongoDB Compass**。它可以提供一个GUI体验，允许您浏览、探索并轻松操作数据库及其集合。此外，它还内置了性能指标、查询视图和模式可视化功能，有助于检查数据库结构的正确性。以下截图显示了MongoDB
    Compass版本1.29.6的仪表板：
- en: '![Figure 6.1 – The MongoDB Compass dashboard'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – MongoDB Compass仪表板'
- en: '](img/Figure_6.01_B17975.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – obrs数据库的类图](img/Figure_6.01_B17975.jpg)'
- en: Figure 6.1 – The MongoDB Compass dashboard
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – MongoDB Compass仪表板
- en: The preceding dashboard shows the document structure of the `profile` and list
    of books for sale.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的仪表板显示了`profile`和销售书籍列表的文档结构。
- en: 'Once the server and utility have been installed, we need to design the data
    collections for our database using the `obrs`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦服务器和实用工具安装完成，我们需要使用`obrs`为我们的数据库设计数据集合。
- en: '![Figure 6.2 – The class diagram for the obrs database'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.2 – obrs数据库的类图'
- en: '](img/Figure_6.02_B17975.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – MongoDB Compass仪表板](img/Figure_6.02_B17975.jpg)'
- en: Figure 6.2 – The class diagram for the obrs database
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – obrs数据库的类图
- en: Our application uses all the collections depicted in the preceding diagram to
    store all the information it captures from the client. Each context box represents
    one collection, with all the attributes and expected underlying transactions indicated
    inside the box. It also shows the associations that bind these collections, such
    as the one-to-one association between `login` and `profile` and the many-to-one
    association between `BookForSale` and `UserProfile`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用前面图中显示的所有集合来存储从客户端捕获的所有信息。每个上下文框代表一个集合，框内显示了所有属性和预期的底层事务。它还显示了将这些集合关联起来的关联，例如`login`和`profile`之间的一对一关联以及`BookForSale`和`UserProfile`之间的多对一关联。
- en: Now that the database server has been installed and designed, let us look at
    the different ways of establishing a connection from our FastAPI microservice
    application to its MongoDB database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在数据库服务器已经安装和设计好了，让我们看看从我们的FastAPI微服务应用程序到其MongoDB数据库的不同连接方式。
- en: Applying the PyMongo driver for synchronous connections
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用PyMongo驱动程序进行同步连接
- en: 'We will start by learning how the FastAPI application connects to MongoDB using
    the PyMongo database driver. This driver is equivalent to `psycopg2`, which allows
    us to access PostgreSQL without using any ORM. Some popular ODMs, such as MongoEngine
    and Motor, use PyMongo as their core driver, which gives us the reason to explore
    PyMongo first before we touch on issues regarding popular ODMs. Studying the driver’s
    behavior can provide baseline transactions that will show how an ODM builds the
    database connectivity, models, and CRUD transactions. But before we proceed with
    the details, we need to install the `pymongo` extension using `pip`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习FastAPI应用程序如何使用PyMongo数据库驱动程序连接到MongoDB。此驱动程序相当于`psycopg2`，它允许我们无需使用任何ORM即可访问PostgreSQL。一些流行的ODM（对象文档映射器），如MongoEngine和Motor，使用PyMongo作为其核心驱动程序，这让我们有理由在触及关于流行ODM的问题之前首先探索PyMongo。研究驱动程序的行为可以提供基线事务，这将展示ODM如何构建数据库连接、模型和CRUD事务。但在我们深入细节之前，我们需要使用`pip`安装`pymongo`扩展：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Setting up the database connectivity
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: PyMongo uses its `MongoClient` module class to connect to any MongoDB database.
    We instantiate it with the specified host and port to extract the client object,
    such as `MongoClient("localhost", "27017")`, or a database URI, such as `MongoClient('mongodb://localhost:27017/')`.
    Our application uses the latter to connect to its database. But if we instantiate
    without providing the parameters, it will use the default `localhost` and `27017`
    details.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: PyMongo使用其`MongoClient`模块类来连接到任何MongoDB数据库。我们通过指定主机和端口来实例化它，以提取客户端对象，例如`MongoClient("localhost",
    "27017")`，或数据库URI，例如`MongoClient('mongodb://localhost:27017/')`。我们的应用程序使用后者来连接到其数据库。但如果我们在实例化时未提供参数，它将使用默认的`localhost`和`27017`详情。
- en: 'After extracting the client object, we can use it to access the database through
    a dot (`.`) operator or `attribute-style access` if the database name follows
    the Python naming convention; for example, `client.obrs`. Otherwise, we can use
    the bracket symbols (`[]`) or dictionary-style access; for example, `client["obrs_db"]`.
    Once the database object has been retrieved, we can access the collections using
    the access rules. Note that a collection is equivalent to a table in a relational
    database, where the collated records, known as documents, are stored. The following
    code shows a generator function that’s used by the application to open database
    connectivity and access the necessary collections in preparation for the CRUD
    implementation:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在提取客户端对象之后，我们可以通过点操作符（`.`）或`attribute-style access`（属性式访问）来使用它访问数据库，前提是数据库名称遵循Python命名约定；例如，`client.obrs`。否则，我们可以使用方括号符号（`[]`）或字典式访问；例如，`client["obrs_db"]`。一旦检索到数据库对象，我们就可以使用访问规则来访问集合。请注意，集合在关系型数据库中相当于表，其中存储了称为文档的已排序记录。以下代码展示了应用程序用于打开数据库连接并访问准备CRUD实现所需集合的生成器函数：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A generator function such as `create_db_collections()` is preferred because
    the `yield` statement works perfectly when it comes to managing the database connection
    over the `return` statement. The `yield` statement suspends the function’s execution
    when it sends a value back to the caller but retains the state where the function
    can resume at the point where it left off. This feature is applied by the generator
    to close the database connection when it resumes the execution at the `finally`
    clause. The `return` statement, on the other hand, will not be applicable for
    this purpose because `return` will finish the whole transaction before it sends
    a value to the caller.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的生成器函数，如`create_db_collections()`，更受欢迎，因为`yield`语句在管理数据库连接时比`return`语句表现得更好。当`yield`语句向调用者发送一个值时，它会暂停函数的执行，但保留函数可以从中恢复执行的状态。这个特性被生成器应用于在`finally`子句中恢复执行时关闭数据库连接。另一方面，`return`语句不适用于此目的，因为`return`会在向调用者发送值之前完成整个事务。
- en: However, before we invoke the generator, let us scrutinize how PyMongo builds
    its model layer to pursue the necessary CRUD transactions.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们调用生成器之前，让我们仔细审查PyMongo如何构建其模型层以追求必要的CRUD事务。
- en: Building the model layer
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型层
- en: 'Documents in MongoDB are represented and collated as JSON-style structures,
    specifically BSON documents. A BSON document offers more data types than the JSON
    structure. We can use dictionaries to represent and persist these BSON documents
    in PyMongo. Once a dictionary has been persisted, the BSON-type document will
    look like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB中的文档以JSON风格的格式表示和整理，具体来说是BSON文档。BSON文档比JSON结构提供了更多的数据类型。我们可以使用字典来表示和持久化这些BSON文档在PyMongo中。一旦字典被持久化，BSON类型的文档将看起来像这样：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Common Python data types such as `str`, `int`, and `float` are supported by
    the BSON specification, but there are types such as `ObjectId`, `Decimal128`,
    `RegEx`, and `Binary` that are intrinsic only to the `bson` module. The specification
    only supports the `timestamp` and `datetime` temporal types. To install `bson`,
    use the following `pip` command:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的Python数据类型，如`str`、`int`和`float`，都由BSON规范支持，但有一些类型，如`ObjectId`、`Decimal128`、`RegEx`和`Binary`，仅限于`bson`模块。规范只支持`timestamp`和`datetime`时间类型。要安装`bson`，请使用以下`pip`命令：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Important note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: '**BSON** is short for **Binary JSON**, a serialized and binary encoding for
    JSON-like documents. The specification behind this is lightweight and flexible.
    The efficient encoding format is explained in more detail at [https://bsonspec.org/spec.html](https://bsonspec.org/spec.html).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**BSON**代表**Binary JSON**，是类似JSON文档的序列化和二进制编码。其背后的规范轻量级且灵活。高效的编码格式在[https://bsonspec.org/spec.html](https://bsonspec.org/spec.html)中解释得更详细。'
- en: '`ObjectId` is an essential data type in a MongoDB document because it serves
    as a *unique identifier* for the main document structure. It is a *12-byte* field
    that consists of a 4-byte UNIX *embedded timestamp*, the 3-byte *machine ID* of
    the MongoDB server, a 2-byte *process ID*, and a 3-byte *arbitrary value* for
    the ID’s increments. Conventionally, the declared field of the document, `_id`,
    always refers to the `ObjectId` value of the document structure. We can allow
    the MongoDB server to generate the _`id` object for the document or create an
    instance of the object type during persistence. When retrieved, `ObjectId` can
    be in *24 hexadecimal digit* or *string* format. Note that the `_id` field is
    the key indicator that a dictionary is ready to be persisted as a valid BSON document.
    Now, BSON documents can also be linked with one another using some associations.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObjectId`是MongoDB文档中的一个基本数据类型，因为它作为主文档结构的**唯一标识符**。它是一个**12字节**的字段，由一个4字节的UNIX**嵌入时间戳**、MongoDB服务器的3字节**机器ID**、2字节**进程ID**和3字节**任意值**组成，用于ID的增加。通常，文档中声明的字段`_id`始终指的是文档结构的`ObjectId`值。我们可以允许MongoDB服务器为文档生成`_id`对象，或者在持久化期间创建该对象类型的实例。当检索时，`ObjectId`可以是**24个十六进制数字**或**字符串**格式。请注意，`_id`字段是字典准备好作为有效BSON文档持久化的关键指标。现在，BSON文档也可以通过一些关联相互链接。'
- en: Establishing document associations
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立文档关联
- en: 'MongoDB has no concept of referential integrity constraints, but a relationship
    among documents is possible based on structures. There are two types of documents:
    *main* and *embedded* documents. A document has a *one-to-one association* with
    another if it is an embedded document of the other. Likewise, a document has a
    *many-to-one association* if a list in that document is linked to the main document
    structure.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB没有参照完整性约束的概念，但基于结构，文档之间可以存在关系。存在两种类型的文档：*主*文档和*嵌入*文档。如果一个文档是另一个文档的嵌入文档，则它与另一个文档具有*一对一关联*。同样，如果一个文档中的列表与主文档结构相关联，则该文档具有*多对一关联*。
- en: The previous purchase BSON document shows a sample of the principal `buyer`
    document with a one-to-one association with the `customer_status` embedded document
    and a many-to-one association with the `purchase_history` documents. As depicted
    from this sample document, embedded documents have no separate collection because
    they have no respective `_id` field to make them stand as primary documents.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的购买BSON文档显示了具有与`客户状态`嵌入文档一对一关联和与`购买历史记录`文档多对一关联的主要`买家`文档的样本。从该样本文档中可以看出，嵌入文档没有单独的集合，因为它们没有相应的主`_id`字段来使它们成为主文档。
- en: Using the BaseModel classes for transactions
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用BaseModel类进行事务
- en: 'Since PyMongo has no predefined model classes, the Pydantic models of FastAPI
    can be used to represent MongoDB documents with all the necessary validation rules
    and encoders. We can use the `BaseModel` classes to contain document details and
    pursue *insert*, *update*, and *delete* transactions since the Pydantic models
    are compatible with MongoDB documents. The following models are being used by
    our online book reselling application to store and retrieve the `buyer`, `purchase_history`,
    and `customer_status` document details:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PyMongo没有预定义的模型类，FastAPI的Pydantic模型可以用来表示MongoDB文档，并包含所有必要的验证规则和编码器。我们可以使用`BaseModel`类来包含文档细节，并执行*插入*、*更新*和*删除*事务，因为Pydantic模型与MongoDB文档兼容。以下模型正在我们的在线二手书销售应用程序中使用，以存储和检索`买家`、`购买历史记录`和`客户状态`文档细节：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For these request models to recognize the BSON data types, we should make some
    modifications to the default behavior of these models. Just like earlier in this
    chapter, where we added the `orm_mode` option, there is also a need to add a nested
    `Config` class to the `BaseModel` blueprint with the `arbitrary_types_allowed`
    option set to `True`. This additional configuration will recognize the BSON data
    types used in the attribute declaration, including compliance with the necessary
    underlying validation rules for the corresponding BSON data types used. Moreover,
    the `json_encoders` option should also be part of the configuration to convert
    the `ObjectId` property of the document into a string during a query transaction.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这些请求模型识别BSON数据类型，我们需要对这些模型的默认行为进行一些修改。就像在本章早期，我们添加了`orm_mode`选项一样，我们还需要在`BaseModel`蓝图上添加一个嵌套的`Config`类，并将`arbitrary_types_allowed`选项设置为`True`。这个额外的配置将识别在属性声明中使用的BSON数据类型，包括符合对应BSON数据类型所需的基本验证规则。此外，`json_encoders`选项也应包含在配置中，以便在查询事务期间将文档的`ObjectId`属性转换为字符串。
- en: Using Pydantic validation
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Pydantic验证
- en: However, some other types are too complex for `json_encoders` to process, such
    as the BSON `datettime` field being converted into a Python `datetime.date`. Since
    the ODM cannot automatically convert a MongoDB datetime into a Python `date` type,
    we need to create a custom validation and parse this BSON `datetime` through Pydantic’s
    `@validation` decorator. We must also use custom validators and parsers in the
    FastAPI services to convert all incoming Python date parameters into BSON datetime.
    This will be covered later.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，某些其他类型对于`json_encoders`来说过于复杂，无法处理，例如将BSON的`datettime`字段转换为Python的`datetime.date`。由于ODM无法自动将MongoDB的日期时间转换为Python的`date`类型，我们需要创建自定义验证并通过Pydantic的`@validation`装饰器解析这个BSON
    `datetime`。我们还需要在FastAPI服务中使用自定义验证器和解析器将所有传入的Python日期参数转换为BSON日期时间。这将在稍后进行介绍。
- en: '`@validator` creates a `class` method that accepts `class name` as the first
    parameter, not the instance, of the field(s) to be validated and parsed. Its second
    parameter is an option that specifies the field name or class attribute that needs
    to be converted into another data type, such as `date_purchased`, `date_shipped`,
    or `date_payment` of the `PurchaseRequestReq` model. The `pre` attribute of `@validator`
    tells FastAPI to process the class methods before any built-in validation can
    be done in the API service implementation. These methods are executed right after
    `APIRouter` runs its custom and built-in FastAPI validation rules for the request
    models, if there are any.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`@validator`创建一个接受字段（s）的`class name`作为第一个参数的方法，而不是要验证和解析的实例。它的第二个参数是一个选项，指定需要转换为其他数据类型（如`PurchaseRequestReq`模型的`date_purchased`、`date_shipped`或`date_payment`）的字段名或类属性。`@validator`的`pre`属性告诉FastAPI在API服务实现中执行任何内置验证之前先处理类方法。如果请求模型有任何自定义和内置的FastAPI验证规则，这些方法将在`APIRouter`运行其自定义和内置的FastAPI验证规则之后立即执行。'
- en: Note that these request models have been placed in the `/models/request/buyer.py`
    module of the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些请求模型已被放置在应用程序的`/models/request/buyer.py`模块中。
- en: Using the Pydantic @dataclass to query documents
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Pydantic的`@dataclass`查询文档
- en: 'Wrapping the queried BSON documents using the `BaseModel` model classes is
    still the best approach to implementing the query transaction. But since BSON
    has issues with the Python `datetime.date` fields, we cannot always utilize the
    request model classes that are used for the CRUD transaction by wrapping retrieved
    BSON documents. Sometimes, using the model yields an `"invalid date format (type=value_error.date)"`
    error because all the models have the Python `datetime.date` fields, whereas the
    incoming data has a BSON `datetime` or `timestamp`. Instead of adding more complexities
    to the request models, we should resort to another approach to extracting the
    documents – that is, utilizing the Pydantic `@dataclass`. The following data classes
    are defined for wrapping the extracted `buyer` documents:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BaseModel`模型类包装查询的BSON文档仍然是实现查询事务的最佳方法。但由于BSON与Python的`datetime.date`字段存在问题，我们并不能总是通过包装检索到的BSON文档来利用用于CRUD事务的请求模型类。有时，使用模型会导致出现`"invalid
    date format (type=value_error.date)"`错误，因为所有模型都有Python的`datetime.date`字段，而传入的数据有BSON的`datetime`或`timestamp`。为了避免在请求模型中增加更多复杂性，我们应该求助于另一种提取文档的方法——即利用Pydantic的`@dataclass`。以下数据类被定义为包装提取的`buyer`文档：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`@dataclass` is a decorator function that adds an `__init__()` to a Python
    class to initialize its attributes and other special functions, such as `__repr__()`.
    The `PurchasedHistory`, `PurchaseStatus`, and `Buyer` custom classes shown in
    the preceding code are typical classes that can be converted into request model
    classes. FastAPI supports both `BaseModel` and data classes when creating model
    classes. Apart from being under the `Pydantic` module, using `@dataclass` is not
    a replacement for using `BaseModel` when creating model classes. This is because
    the two components are different in terms of their flexibility, features, and
    hooks. `BaseModel` is configuration-friendly and can be adapted to many validation
    rules and type hints, while `@dataclass` has problems recognizing some `Config`
    attributes such as `extra`, `allow_population_by_field_name`, and `json_encoders`.
    If a data class requires some additional details, a custom class is needed to
    define these configurations and set the `config` parameter of the decorator. For
    instance, the `Config` class in the preceding code, which sets `arbitrary_types_allowed`
    to `True`, has been added to the three model classes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`@dataclass`是一个装饰器函数，它向Python类添加一个`__init__()`方法来初始化其属性和其他特殊函数，例如`__repr__()`。前面代码中显示的`PurchasedHistory`、`PurchaseStatus`和`Buyer`自定义类是典型的可以转换为请求模型类的类。FastAPI在创建模型类时支持`BaseModel`和数据类。除了位于`Pydantic`模块下外，使用`@dataclass`在创建模型类时并不是`BaseModel`的替代品。这是因为这两个组件在灵活性、特性和钩子方面有所不同。`BaseModel`易于配置，可以适应许多验证规则和类型提示，而`@dataclass`在识别某些`Config`属性方面存在问题，例如`extra`、`allow_population_by_field_name`和`json_encoders`。如果一个数据类需要一些额外的细节，就需要一个自定义类来定义这些配置并设置装饰器的`config`参数。例如，前面代码中的`Config`类，它将`arbitrary_types_allowed`设置为`True`，已被添加到三个模型类中。'
- en: Besides `config`, the decorator has other parameters such as `init`, `eq`, and
    `repr` that accept `bool` values to generate their respective hook methods. The
    `frozen` parameter enables exception handling concerning field type mismatches
    when set to `True`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `config`，装饰器还有其他参数，如 `init`、`eq` 和 `repr`，它们接受 `bool` 值以生成它们各自的钩子方法。当设置为
    `True` 时，`frozen` 参数启用有关字段类型不匹配的异常处理。
- en: When it comes to data parsing, transition, and conversion, `@dataclass` is always
    dependent on augmented validations, unlike `BaseModel`, which can process data
    type conversion simply by adding `json_encoders`. In the data classes shown previously,
    all the validators focus on BSON `datetime` to Python `datetime.date` conversion
    during the document retrieval process. These validations will occur before any
    custom or built-in validation in `APIRouter` because the `pre` parameter of the
    `@validator` decorator is set to `True`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到数据处理、转换时，`@dataclass` 总是依赖于增强验证，与可以通过添加 `json_encoders` 简单处理数据类型转换的 `BaseModel`
    不同。在之前展示的数据类中，所有验证器都集中在文档检索过程中的 BSON `datetime` 到 Python `datetime.date` 的转换。这些验证将在
    `APIRouter` 中的任何自定义或内置验证之前发生，因为 `@validator` 装饰器的 `pre` 参数被设置为 `True`。
- en: When dealing with default values, `BaseModel` classes can use typical type hints
    such as `Optional` or object instantiation such as `dict()` or `list()` to define
    the preconditional state of its complex attributes. With `@dataclass`, a `ValueError`
    exception is always thrown at compile time when type hints are applied to set
    default values of complex field types such as `list`, `dict`, and `ObjectId`.
    It requires the `field()` specifier from Python’s `dataclasses` module to set
    the default values of these fields, either by assigning an actual value through
    the specifier’s `default` parameter or invoking a function or lambda that returns
    a valid value through the `default_factory` parameter. The use of `field()` indicates
    that Pydantic’s `@dataclass` is an exact replacement of Python’s core data classes
    but with some additional features, such as the `config` parameter and the inclusion
    of the `@validator` components.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理默认值时，`BaseModel` 类可以使用典型的类型提示，如 `Optional`，或对象实例化，如 `dict()` 或 `list()`，来定义其复杂属性的预条件状态。使用
    `@dataclass`，当类型提示应用于设置复杂字段类型（如 `list`、`dict` 和 `ObjectId`）的默认值时，总是在编译时抛出 `ValueError`
    异常。它需要 Python 的 `dataclasses` 模块的 `field()` 指定器来设置这些字段的默认值，无论是通过指定器的 `default`
    参数分配实际值，还是通过 `default_factory` 参数调用函数或 lambda 来返回有效值。使用 `field()` 指示 Pydantic
    的 `@dataclass` 是 Python 核心数据类的精确替代，但有一些附加功能，例如 `config` 参数和包含 `@validator` 组件。
- en: Note that it is advised that all `@dataclass` models have default values when
    using type hints or `field()`, especially for embedded documents and for models
    with the `date` or `datetime` types, to avoid some missing constructor parameter(s)
    errors. On the other hand, an `@dataclass` can also create embedded structures
    in the `BaseModel` classes, for example, by defining attributes with the class
    types. This is highlighted in the `Buyer` model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，建议在使用类型提示或 `field()` 时，所有 `@dataclass` 模型都有默认值，特别是对于嵌入文档和具有 `date` 或 `datetime`
    类型的模型，以避免一些缺少构造函数参数的错误。另一方面，`@dataclass` 也可以在 `BaseModel` 类中创建嵌入结构，例如，通过定义具有类类型的属性。这在
    `Buyer` 模型中得到了强调。
- en: All these model classes have been placed in the `/models/data/pymongo.py` script.
    Let us now apply these data models to create the repository layer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模型类都放置在 `/models/data/pymongo.py` 脚本中。现在让我们应用这些数据模型来创建存储层。
- en: Implementing the repository layer
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现存储层
- en: PyMongo needs `collection` to build the repository layer of the application.
    Besides the `collection` object, the *insert*, *delete*, and *update* transactions
    will also need the `BaseModel` classes to contain all the details from the client
    and convert them into BSON documents after the transaction. Meanwhile, our query
    transactions will require the data classes to convert all BSON documents into
    JSON-able resources during the document retrieval process. Now, let us look at
    how a repository can be implemented using a PyMongo driver.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: PyMongo 需要 `collection` 来构建应用程序的存储层。除了 `collection` 对象外，`insert`、`delete` 和
    `update` 事务还需要 `BaseModel` 类来包含客户端的所有详细信息，并在事务后将它们转换为BSON文档。同时，我们的查询事务将需要数据类在文档检索过程中将所有BSON文档转换为可JSON化的资源。现在，让我们看看如何使用PyMongo驱动程序实现存储层。
- en: Building the CRUD transactions
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建CRUD事务
- en: 'The repository class in the following code block implements the CRUD transactions
    that aim to manage the `buyer`, `purchase_history`, and `customer_status` information
    based on basic specifications of the *online book reselling* system:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块中的仓库类实现了基于*在线二手书交易平台*基本规范的`buyer`、`purchase_history`和`customer_status`信息管理的CRUD事务：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let us examine `insert_buyer()`, which inserts details about a registered book
    buyer who had some previous transactions in the system as a `login` user. The
    PyMongo collection offers helper methods for processing CRUD transactions, such
    as `insert_one()`, which adds a single main document from its `Dict` parameter.
    It also has `insert_many()`, which accepts a valid list of dictionaries that can
    be persisted as multiple documents. These two methods can generate an `ObjectId`
    for the `_id` field of the BSON document during the insertion process. The buyer’s
    details are extracted from the `BuyerReq` Pydantic model.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查`insert_buyer()`，它插入有关在系统中作为`login`用户进行了一些先前交易的注册书买家的详细信息。PyMongo集合提供了处理CRUD事务的辅助方法，例如`insert_one()`，它从其`Dict`参数添加单个主要文档。它还有一个`insert_many()`，它接受一个有效的字典列表，可以作为多个文档持久化。这两个方法在插入过程中可以为BSON文档的`_id`字段生成`ObjectId`。买家的详细信息是从`BuyerReq`
    Pydantic模型中提取的。
- en: 'Next, `update_buyer()` shows how to update a specific document in the `buyer`
    collection:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`update_buyer()`展示了如何更新`buyer`集合中的特定文档：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The collection has an `update_one()` method that requires two parameters: a
    unique and valid field/value dictionary pair that will serve as the *search key*
    of the record search, and another dictionary pair with the predefined `$set` key
    with the dictionary of updated *details for replacement*. It also has `update_many()`,
    which can update multiple documents, given that the primary dictionary field/value
    parameter is not unique.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 集合有一个`update_one()`方法，需要两个参数：一个唯一且有效的字段/值字典对，将作为记录搜索的*搜索键*，以及另一个具有预定义的`$set`键的字典对，包含更新的*替换详情*。它还有一个`update_many()`，可以更新多个文档，前提是主要字典字段/值参数不是唯一的。
- en: '`delete_buyer()` is the transaction that deletes a `buyer` document using a
    unique and valid field/value pair such as `{"buyer_id": id}`. If this parameter
    or search key is a common/non-unique data, the collection offers `delete_many()`,
    which can delete multiple documents. Now, the following script shows how to implement
    query transactions in PyMongo'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_buyer()`是删除`buyer`文档的事务，使用唯一且有效的字段/值对，例如`{"buyer_id": id}`。如果此参数或搜索键是常见/非唯一数据，集合提供`delete_many()`，可以删除多个文档。现在，以下脚本展示了如何在PyMongo中实现查询事务'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When querying documents, PyMongo has a `find()` method, which retrieves all
    the documents in the collection, and `find_one()`, which can get a unique and
    single document. Both methods need two parameters: the conditional or logical
    query parameter in the form of a dictionary field/value pair and the set of fields
    that needs to appear in the record. `get_buyer()` in the previous code block shows
    how to retrieve a buyer document through the unique `buyer_id` field. The absence
    of its second parameter means the presence of all the fields in the result. Meanwhile,
    `get_all_buyer()` retrieves all the buyer documents without constraints. Constraints
    or filter expressions are formulated using BSON comparison operators, as shown
    in the following table:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询文档时，PyMongo有一个`find()`方法，用于检索集合中的所有文档，还有一个`find_one()`方法，可以获取一个唯一且单个文档。这两种方法都需要两个参数：以字典字段/值对形式表示的条件或逻辑查询参数，以及需要在记录中出现的字段集合。前一个代码块中的`get_buyer()`展示了如何通过唯一的`buyer_id`字段检索买家文档。其第二个参数的缺失意味着结果中包含所有字段。同时，`get_all_buyer()`在不加任何约束的情况下检索所有买家文档。约束或过滤表达式使用BSON比较运算符来制定，如下表所示：
- en: '![](img/Table_011.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_011.jpg)'
- en: 'For instance, retrieving buyer documents with *user_id greater than 5* requires
    the `buyers.find({"user_id": {"$gte": 5}})` query operation. If we need to build
    compound filters, we must apply the following logical operators:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，检索`user_id`大于5的买家文档需要使用`buyers.find({"user_id": {"$gte": 5}})`查询操作。如果我们需要构建复合过滤器，我们必须应用以下逻辑运算符：'
- en: '![](img/Table_021.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Table_021.jpg)'
- en: 'Retrieving buyer documents with *buyer_id less than 50* and *buyer_id greater
    than 10* will require the `find({''and'': [{''buyer_id'': {''$lt'': 50}}, {''user_id'':{''$gt'':10}}]})`
    query.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '检索`buyer_id`小于50且`buyer_id`大于10的买家文档需要使用`find({''and'': [{''buyer_id'': {''$lt'':
    50}}, {''user_id'':{''$gt'':10}}]})`查询。'
- en: Both methods return BSON documents that are not JSON-able components of the
    FastAPI framework. To convert the documents into JSON, the `bson.json_util` extension
    has a `dumps()` method that can convert a single document or list of documents
    into a JSON string. Both `get_all_buyer()` and `get_buyer()`convert every single
    document retrieved into JSON so that each can be mapped to the `Buyer` data class.
    The main objective of the mapping is to convert the `datetime` fields into Python
    `datetime.date` while utilizing the validators of the `Buyer` data class. The
    mapping will only be successful if the `loads()` method of the `json` extension
    is used to convert `str` into a `dict` data structure. After generating the list
    of `Buyer` data classes, the `asdict()` method of Python’s `dataclasses` module
    is needed to transform the list of `Buyer` data classes into a list of dictionaries
    to be consumed by `APIRouter`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都返回不是 FastAPI 框架可序列化为 JSON 的 BSON 文档。要将文档转换为 JSON，`bson.json_util` 扩展有一个
    `dumps()` 方法可以将单个文档或文档列表转换为 JSON 字符串。`get_all_buyer()` 和 `get_buyer()` 都将检索到的每个文档转换为
    JSON，以便每个文档都可以映射到 `Buyer` 数据类。映射的主要目标是转换 `datetime` 字段为 Python `datetime.date`，同时利用
    `Buyer` 数据类的验证器。映射只有在使用 `json` 扩展的 `loads()` 方法将 `str` 转换为 `dict` 数据结构时才会成功。在生成
    `Buyer` 数据类的列表后，需要 Python 的 `dataclasses` 模块的 `asdict()` 方法将 `Buyer` 数据类的列表转换为字典列表，以便由
    `APIRouter` 消费。
- en: Managing document association
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理文档关联
- en: 'Technically, there are two ways to construct a document association in PyMongo.
    The first one is to use the `DBRef` class of the `bison.dbref` module to link
    the parent and child documents. The only prerequisite is for both documents to
    have an `_id` value of the `ObjectId` type and have their respective collection
    exist. For instance, if `PurchaseHistoryReq` is a core document, we can insert
    one purchase record into the list through the following query:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PyMongo 中，技术上构建文档关联有两种方式。第一种是使用 `bison.dbref` 模块的 `DBRef` 类来链接父文档和子文档。唯一的前提是两个文档都必须有一个
    `ObjectId` 类型的 `_id` 值，并且它们各自的集合必须存在。例如，如果 `PurchaseHistoryReq` 是核心文档，我们可以通过以下查询将一条购买记录插入列表中：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, the first parameter of the `DBRef` constructor pertains to the name of
    the collection where the child document is placed, while the second one is the
    `ObjectId` property of the child document in string format. However, some people
    use an `ObjectId` instance instead of the string version. On the other hand, to
    find a specific `purchase_history` document from the `buyer` collection using
    `DBRef`, we can write our query like this:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`DBRef` 构造函数的第一个参数是子文档放置的集合名称，而第二个参数是子文档的 `ObjectId` 属性的字符串格式。然而，有些人使用 `ObjectId`
    实例而不是字符串版本。另一方面，要使用 `DBRef` 从 `buyer` 集合中查找特定的 `purchase_history` 文档，我们可以编写如下查询：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The second way is to add the whole BSON document structure to the `list` field
    of `buyer` through the `BuyerReq` model. This solution applies to embedded documents
    that do not have `_id` and `collection` but are essential to the core document.
    `add_purchase_history()` in the following code shows how this approach is applied
    to create a many-to-one association between the `purchase_history` and `buyer`
    documents:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是通过 `BuyerReq` 模型将整个 BSON 文档结构添加到 `buyer` 的 `list` 字段中。此解决方案适用于没有 `_id`
    和 `collection` 但对核心文档至关重要的嵌入式文档。以下代码中的 `add_purchase_history()` 展示了如何应用这种方法在 `purchase_history`
    和 `buyer` 文档之间创建多对一关联：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `add_customer_status()` method shows how to implement the second approach
    in building a one-to-one association between the `buyer` and `purchase_status`
    documents. The first approach, which involves using `DBRef`, can also be applied
    if `PurchaseStatusReq` is an independent core document.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_customer_status()` 方法展示了如何实现第二种方法，在 `buyer` 和 `purchase_status` 文档之间建立一对一关联。如果
    `PurchaseStatusReq` 是独立的核心文档，则涉及使用 `DBRef` 的第一种方法也可以应用。'
- en: The complete repository class can be found in the `/repository/pymongo/buyer.py`
    script file. Now, let us apply these CRUD transactions to our API services.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的仓库类可以在 `/repository/pymongo/buyer.py` 脚本文件中找到。现在，让我们将这些 CRUD 事务应用到我们的 API
    服务中。
- en: Running the transactions
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行事务
- en: Before executing the `BuyerRepository` transactions, the `create_db_collections()`
    generator should be injected into the API services using `Depends`. Since PyMongo
    has difficulty processing Python types that are not BSON-supported, such as `datettime.date`,
    custom validations and serializers are sometimes required to pursue some transactions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行`BuyerRepository`事务之前，应使用`Depends`将`create_db_collections()`生成器注入到API服务中。由于PyMongo难以处理非BSON支持的Python类型，例如`datetime.date`，有时需要自定义验证和序列化器来执行某些事务。
- en: Important note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The implementation of `@validator` inside `@dataclass` and `BaseModel` converts
    outgoing BSON `datetime` parameters into Python `date` during query retrieval.
    Meanwhile, the JSON encoder validation in this API layer converts incoming Python
    `date` values into BSON `datetime` values during the transition from the application
    to MongoDB.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在`@dataclass`和`BaseModel`内部的`@validator`实现将查询检索期间的输出BSON `datetime`参数转换为Python
    `date`。同时，在此API层中的JSON编码器验证在从应用程序到MongoDB的转换过程中将传入的Python `date`值转换为BSON `datetime`值。
- en: 'For instance, the `add_buyer()`, `update_buyer()`, and `add_purchase_history()`
    transaction methods in the following code require a custom serializer such as
    `json_serialize_date()` to transform the Python `datetime.date` value into the
    `datettime.datetime` type so that it complies with PyMongo’s BSON specification:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码中的`add_buyer()`、`update_buyer()`和`add_purchase_history()`事务方法需要自定义序列化器，如`json_serialize_date()`，以将Python
    `datetime.date`值转换为`datetime.datetime`类型，以便符合PyMongo的BSON规范：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `json_serialize_date()` function becomes part of the JSON serialization
    process of the `dumps()` method but only handles the temporal type conversion
    while transforming the `buyer` details into JSON objects. It is applied in the
    *INSERT* and *UPDATE* transactions of the repository class to extract the serialized
    JSON string equivalent of the `BuyerReq`, `PurchaseHistoryReq`, and `PurchaseStatusReq`
    models.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`json_serialize_date()`函数成为`dumps()`方法的JSON序列化过程的一部分，但仅处理在将`buyer`详细信息转换为JSON对象时的类型转换。它在存储库类的*INSERT*和*UPDATE*事务中应用，以提取`BuyerReq`、`PurchaseHistoryReq`和`PurchaseStatusReq`模型的序列化JSON字符串等效物。'
- en: 'Now, another custom converter is applied in the data retrievals of the `list_all_buyer()`
    and `get_buyer()` methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，另一个自定义转换器应用于`list_all_buyer()`和`get_buyer()`方法的数据检索：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The data models involved in our query transactions are data classes, so the
    results of the two preceding query methods have already been mapped and transformed
    into JSON format. However, unfortunately, they’re not JSON-able enough for the
    FastAPI framework. Aside from BSON `datetime` types, the PyMongo ODM cannot automatically
    convert `ObjectId` into a default type in Python, thus throwing `ValueError` during
    data retrieval from MongoDB. To fix this problem, `dumps()`needs a custom serializer,
    such as `json_serialize_oid()`, to convert all `ObjectId` parameters in MongoDB
    into FastAPI transitions. It also converts BSON `datetime` values into Python
    `date` values following the *ISO-8601* format. The valid JSON string from `dumps()`
    will enable the `loads()` method to produce a JSON-able result for the FastAPI
    services. The complete API services can be found in the `/api/buyer.py` script
    file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们查询事务中涉及的数据模型是数据类，因此前两个查询方法的结果已经映射并转换为JSON格式。然而，不幸的是，它们对于FastAPI框架来说并不足以进行JSON序列化。除了BSON
    `datetime`类型外，PyMongo ODM无法自动将`ObjectId`转换为Python中的默认类型，因此在从MongoDB检索数据时抛出`ValueError`。为了解决这个问题，`dumps()`需要一个自定义序列化器，如`json_serialize_oid()`，将MongoDB中的所有`ObjectId`参数转换为FastAPI转换。它还将BSON
    `datetime`值转换为遵循*ISO-8601*格式的Python `date`值。来自`dumps()`的有效JSON字符串将使`loads()`方法能够为FastAPI服务生成可JSON序列化的结果。完整的API服务可以在`/api/buyer.py`脚本文件中找到。
- en: After complying with all the requirements, PyMongo can help store and manage
    all the information using the MongoDB server. However, the driver only works for
    synchronous CRUD transactions. If we opt for an asynchronous way of implementing
    CRUD, we must always resort to the Motor driver.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在满足所有要求后，PyMongo可以帮助使用MongoDB服务器存储和管理所有信息。然而，该驱动程序仅适用于同步CRUD事务。如果我们选择异步方式实现CRUD，我们必须始终求助于Motor驱动程序。
- en: Creating async CRUD transactions using Motor
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Motor创建异步CRUD事务
- en: Motor is an asynchronous driver that relies on the AsyncIO environment of the
    FastAPI. It wraps PyMongo to produce non-blocking and coroutine-based classes
    and methods needed to create asynchronous repository layers. It is almost like
    PyMongo when it comes to most of the requirements except for the database connectivity
    and repository implementation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 电机是一个异步驱动器，它依赖于FastAPI的AsyncIO环境。它封装了PyMongo，以产生创建异步存储库层所需的非阻塞和基于协程的类和方法。在大多数需求方面，它几乎与PyMongo相同，除了数据库连接和存储库实现。
- en: 'But before we proceed, we need to install the `motor` extension using the following
    `pip` command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 但在继续之前，我们需要使用以下`pip`命令安装`motor`扩展：
- en: '[PRE14]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting up the database connectivity
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置数据库连接
- en: 'Using the `AsyncIO` platform of the FastAPI, the Motor driver opens a connection
    to the MongoDB database through its `AsyncIOMotorClient` class. When instantiated,
    the default connection credential is always `localhost` at port `27017`. Alternatively,
    we can specify the new details in `str` format through its constructor. The following
    script shows how to create a global `AsyncIOMotorClient` reference with the specified
    database credentials:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FastAPI的`AsyncIO`平台，Motor驱动器通过其`AsyncIOMotorClient`类打开到MongoDB数据库的连接。当实例化时，默认连接凭据始终是`localhost`的`27017`端口。或者，我们可以通过其构造函数指定新的详细信息，格式为`str`。以下脚本展示了如何使用指定的数据库凭据创建全局`AsyncIOMotorClient`引用：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The format of the database URI is a string with a colon (`:`) in between the
    details. Now, the application needs the following Motor methods to start the database
    transactions:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库URI的格式是一个包含冒号（`:`）分隔的详细信息的字符串。现在，应用程序需要以下Motor方法来启动数据库事务：
- en: '`create_async_db()`: A method for establishing the database connection and
    loading schema definitions'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_async_db()`: 用于建立数据库连接和加载模式定义的方法'
- en: '`close_async_db()`: A method for closing the connection'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`close_async_db()`: 用于关闭连接的方法'
- en: '`APIRouter` will require event handlers to manage these two core methods as
    application-level events. Later, we will register `create_async_db()` as a startup
    event and `close_async_db()` as a shutdown event. On the other hand, the `create_db_collections()`
    method creates some references to the `login` and `buyer` collections, which will
    be needed by the repository transactions later.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`APIRouter`将需要事件处理器来管理这两个核心方法作为应用级事件。稍后，我们将注册`create_async_db()`作为启动事件，将`close_async_db()`作为关闭事件。另一方面，`create_db_collections()`方法创建了对`login`和`buyer`集合的一些引用，这些引用将在后续的存储库事务中需要。'
- en: In general, creating the database connection and getting the reference to the
    document collections do not require the `async/await` expression since no I/O
    is involved in the process. These methods can be found in the `/db_config/motor_config.py`
    script file. It is time now to create Motor's repository layer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，创建数据库连接和获取文档集合的引用不需要`async/await`表达式，因为在这个过程中不涉及I/O。这些方法可以在`/db_config/motor_config.py`脚本文件中找到。现在是时候创建Motor的存储库层了。
- en: Creating the model layer
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型层
- en: PyMongo and Motor share the same approaches in creating both the request and
    data models. All base models, data classes, validators, and serializers used by
    PyMongo also apply to Motor connectivity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: PyMongo和Motor在创建请求和数据模型方面采用相同的方法。所有由PyMongo使用的基模型、数据类、验证器和序列化器也适用于Motor的连接。
- en: Building the asynchronous repository layer
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建异步存储库层
- en: 'When it comes to the CRUD implementation, both PyMongo and Motor have some
    slight differences in the syntax but a considerable difference in the performance
    of each transaction. Their helper methods for inserting, updating, and deleting
    documents, including the necessary method parameters, are all the same, except
    that Motor has the non-blocking versions. Invoking the non-blocking Motor methods
    inside the repository requires an async/await expression. Here is an asynchronous
    version of PyMongo’s `BuyerRepository`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到CRUD实现时，PyMongo和Motor在语法上略有不同，但在每个事务的性能上存在相当大的差异。它们用于插入、更新和删除文档的辅助方法，包括必要的方法参数，都是相同的，除了Motor有非阻塞版本。在存储库中调用非阻塞的Motor方法需要async/await表达式。以下是一个异步版本的PyMongo的`BuyerRepository`：
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`insert_buyer()` in the preceding code block is defined as `async` because
    `insert_one()` is a non-blocking operation that requires an `await` invocation.
    The same goes for `add_purchase_history()`, which updates the `purchase_history`
    embedded documents using the non-blocking `update_one()`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 前述代码块中的`insert_buyer()`被定义为`async`，因为`insert_one()`是一个非阻塞操作，需要`await`调用。同样，对于`add_purchase_history()`，它使用非阻塞的`update_one()`更新`purchase_history`嵌入文档：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `delete_many()` and `find_one()` operations are also invoked through an
    `await` expression. However, `find()` in Motor is not asynchronous and behaves
    differently than it does with PyMongo. The reason is that `find()` is not an I/O
    operation in Motor, and it returns an `AsyncIOMotorCursor` or asynchronous cursor,
    an iterable type that contains all the BSON documents. We apply `async` to the
    cursor when retrieving all its stored documents. The `get_all_buyer()` transaction
    in the preceding code shows how we call the `find()` operation and invoke the
    cursor to extract the necessary documents for JSON transformation. This repository
    class can be found in the `/repository/motor/buyer.py` script file. Let us now
    apply these CRUD transactions to our API services.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_many()`和`find_one()`操作也是通过`await`表达式调用的。然而，在Motor中，`find()`不是异步的，其行为与PyMongo不同。原因是`find()`在Motor中不是一个I/O操作，它返回一个`AsyncIOMotorCursor`或异步游标，这是一个包含所有BSON文档的可迭代类型。我们在检索所有存储的文档时将`async`应用于游标。前述代码中的`get_all_buyer()`事务展示了我们如何调用`find()`操作并调用游标以提取JSON转换所需的必要文档。这个仓库类可以在`/repository/motor/buyer.py`脚本文件中找到。现在让我们将这些CRUD事务应用到我们的API服务中。'
- en: Running the CRUD transactions
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行CRUD事务
- en: 'For the repository to work with `APIRouter`, we need to create two event handlers
    to manage the database connection and document collection retrieval. The first
    event, which is the startup event that the Uvicorn server executes before the
    application runs, should trigger the `create_async_db()` method’s execution to
    instantiate `AsyncIOMotorClient` and make references to the collections. The second
    event, which is the shutdown event, runs when the Uvicorn server is shutting down
    and should trigger the `close_async_db()` execution to close the connection. `APIRouter`
    has an `add_event_handler()` method to create these two event handlers. The following
    is a portion of the `APIRouter` script that shows how to prepare the database
    connection for the `BuyerRepository` transactions:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让仓库与`APIRouter`一起工作，我们需要创建两个事件处理器来管理数据库连接和文档集合检索。第一个事件是启动事件，Uvicorn服务器在应用程序运行之前执行，应该触发`create_async_db()`方法的执行以实例化`AsyncIOMotorClient`并对集合进行引用。第二个事件是关闭事件，当Uvicorn服务器关闭时运行，应该触发`close_async_db()`的执行以关闭连接。`APIRouter`有一个`add_event_handler()`方法来创建这两个事件处理器。以下是从`APIRouter`脚本中摘取的部分，展示了如何为`BuyerRepository`事务准备数据库连接：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `"startup"` and `"shutdown"` values are pre-built configuration values and
    not just any arbitrary string values used to indicate the type of event handlers.
    We will discuss these event handlers in more detail in [*Chapter 8*](B17975_08.xhtml#_idTextAnchor229),
    *Creating Coroutines, Events, and Message-Driven Transactions*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`"startup"`和`"shutdown"`值是预构建的配置值，而不仅仅是任何任意的字符串值，用于指示事件处理器的类型。我们将在[*第8章*](B17975_08.xhtml#_idTextAnchor229)《创建协程、事件和消息驱动事务》中更详细地讨论这些事件处理器。'
- en: 'After setting these events handlers, the API services can now invoke the repository
    transactions asynchronously using an await/async expression. The validations and
    serialization utilities that are applied in PyMongo can also be utilized here
    in this version of `BuyerRepository`. The collections will be available to the
    API services upon injecting `create_db_collections()` into the API services. The
    `add_buyer()` API service showcases the implementation of an asynchronous REST
    transaction using the Motor driver:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置这些事件处理器之后，API服务现在可以使用await/async表达式异步调用仓库事务。在PyMongo中应用的有效性和序列化工具也可以在这个版本的`BuyerRepository`中使用。在将`create_db_collections()`注入到API服务中后，集合将可供API服务使用。`add_buyer()`
    API服务展示了使用Motor驱动程序实现异步REST事务的实现：
- en: '[PRE19]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using PyMongo and Mongo drivers provides a minimal and exhaustive implementation
    of the MongoDB transactions. The core implementation of every CRUD transaction
    varies from one developer to another, and the approaches that are used to scrutinize
    and analyze the processes involved are managed in different ways. Also, there
    are no established standards for defining the document fields, such as *data uniqueness*,
    *the length of the field value*, *the value range*, and even the idea of adding
    a *unique ID*. To address these issues surrounding PyMongo and Motor, let us explore
    other ways of opening a connection to MongoDB to create CRUD transactions, such
    as using an **ODM**.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PyMongo和Mongo驱动程序提供了MongoDB事务的最小和详尽的实现。每个CRUD事务的核心实现因开发者而异，用于审查和分析涉及过程的方法也以不同的方式管理。此外，没有定义文档字段的标准，例如*数据唯一性*、*字段值长度*、*值范围*，甚至添加*唯一ID*的想法。为了解决围绕PyMongo和Motor的问题，让我们探索其他打开MongoDB连接以创建CRUD事务的方法，例如使用**ODM**。
- en: Implementing CRUD transactions using MongoEngine
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MongoEngine实现CRUD事务
- en: MongoEngine is an ODM that uses PyMongo to create an easy-to-use framework that
    can assist in managing MongoDB documents. It offers API classes that can help
    generate model classes using its field types and attribute metadata. It provides
    a declarative way of creating and structuring the embedded documents.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine是一个ODM，它使用PyMongo创建一个易于使用的框架，可以帮助管理MongoDB文档。它提供了API类，可以帮助使用其字段类型和属性元数据生成模型类。它提供了一种声明式的方式来创建和结构化嵌入文档。
- en: 'Before we explore this ODM, we need to install it using the following `pip`
    command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索这个ODM之前，我们需要使用以下`pip`命令来安装它：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Establishing database connection
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立数据库连接
- en: 'MongoEngine has one of the most straightforward ways to establish a connection.
    Its `mongoengine` module has a `connect()` helper method that connects to the
    MongoDB database when it’s given the appropriate database connections. Our application
    must have a generator method to create a reference to the database connection
    and close this created connection after the transactions expire. The following
    script showcases the MongoEngine database connectivity:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine有建立连接最直接的方法之一。它的`mongoengine`模块有一个`connect()`辅助方法，当提供适当的数据库连接时，它会连接到MongoDB数据库。我们的应用程序必须有一个生成器方法来创建数据库连接的引用，并在事务过期后关闭此创建的连接。以下脚本展示了MongoEngine数据库连接性：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `connect()` method has a mandatory first parameter, named `db`, which indicates
    the name of the database. The remaining parameters refer to the other remaining
    details of the database connection, such as `host`, `port`, `username`, and `password`.
    This configuration can be found in the `/db_config/mongoengine_config.py` script
    file. Let us now create data models for our MongoEngine repository.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`connect()`方法有一个强制性的第一个参数，名为`db`，它表示数据库名称。其余参数指的是数据库连接的其他详细信息，如`host`、`port`、`username`和`password`。此配置可以在`/db_config/mongoengine_config.py`脚本文件中找到。现在让我们为我们的MongoEngine存储库创建数据模型。'
- en: Building the model layer
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型层
- en: 'MongoEngine provides a convenient and declarative way of mapping BSON documents
    to the model classes through its `Document` API class. A model class must subclass
    `Document` to inherit the structure and properties of a qualified and valid MongoDB
    document. The following is a `Login` definition that’s been created using the
    `Document` API class:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine通过其`Document` API类提供了一个方便且声明式的方式来将BSON文档映射到模型类。一个模型类必须继承自`Document`以继承合格和有效MongoDB文档的结构和属性。以下是一个使用`Document`
    API类创建的`Login`定义：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Unlike PyMongo and the Motor drivers, MongoEngine can define class attributes
    using its `Field` classes and their properties. Some of its `Field` classes include
    `StringField`, `IntField`, `FloatField`, `BooleanField`, and `DateField`. These
    can declare the `str`, `int`, `float`, `bool`, and `datetime.date` class attributes,
    respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与PyMongo和Motor驱动程序不同，MongoEngine可以使用其`Field`类及其属性来定义类属性。其中一些`Field`类包括`StringField`、`IntField`、`FloatField`、`BooleanField`和`DateField`。这些可以分别声明`str`、`int`、`float`、`bool`和`datetime.date`类属性。
- en: Another convenient feature that this ODM has is that it can create `SequenceField`,
    which behaves the same as the `auto_increment` column field in a relational database
    or `Sequence` in an object-relational database. The `id` field of a model class
    should be declared as `SequenceField` so that it serves as the primary key of
    the document. Like in a typical sequence, this field has utilities to increment
    its value or reset it to zero, depending on what document record must be accessed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个这个 ODM 的便利功能是它可以创建 `SequenceField`，它在关系数据库中的行为与 `auto_increment` 列字段相同，或者在对象关系数据库中的
    `Sequence` 相同。模型类的 `id` 字段应声明为 `SequenceField`，以便作为文档的主键。像典型的序列一样，这个字段有增加其值或将其重置为零的实用程序，具体取决于必须访问哪个文档记录。
- en: 'Other than the field types, field classes can also provide field arguments
    to attributes such as `choices`, `required`, `unique`, `min_value`, `max_value`,
    `max_length`, and `min_length` to give constraints to the field values. The `choices`
    parameter, for instance, accepts an iterable of string values that will serve
    as an enumeration. The `required` parameter indicates whether the field always
    needs a field value, while the `unique` parameter means the field value has no
    duplicates in the collection. Violating the `unique` parameter will lead to the
    following error message:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字段类型外，字段类还可以为 `choices`、`required`、`unique`、`min_value`、`max_value`、`max_length`
    和 `min_length` 等属性提供字段参数，以对字段值施加约束。例如，`choices` 参数接受一个字符串值的可迭代对象，用作枚举。`required`
    参数表示字段是否始终需要字段值，而 `unique` 参数表示字段值在集合中没有重复。违反 `unique` 参数将导致以下错误消息：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`min_value` and `max_value`, on the other hand, indicate the minimum and maximum
    values for the numeric fields, respectively. `min_length` specifies the minimum
    length of a string value, while `max_length` sets the maximum string length. The
    `db_field` parameter, on the other hand, can also be applied when specifying another
    document field name instead of the class attribute name. The given `Login` class
    also has `username` and `password` fields defined to hold string values, an id
    primary key defined as `SequenceField`, and an embedded document field to establish
    document association.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`min_value` 和 `max_value` 分别表示数值字段的最低和最高值。`min_length` 指定字符串值的最低长度，而 `max_length`
    设置最大字符串长度。另一方面，`db_field` 参数在指定另一个文档字段名而不是类属性名时也可以应用。给定的 `Login` 类还定义了用于存储字符串值的
    `username` 和 `password` 字段，将主键定义为 `SequenceField`，并定义了一个嵌入文档字段以建立文档关联。'
- en: Creating document association
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文档关联
- en: 'The `profile` field of `Login` creates a one-to-one association between the
    `Login` document and `UserProfile`. But before the association can work, we need
    to define the `profile` field as being of the `EmbeddedDocumentField` type and
    `UserProfile` as being of the `EmbeddedDocument` type. The following is the complete
    blueprint of `UserProfile`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '`Login` 的 `profile` 字段在 `Login` 文档和 `UserProfile` 之间创建了一个一对一的关联。但在关联可以工作之前，我们需要将
    `profile` 字段定义为 `EmbeddedDocumentField` 类型，并将 `UserProfile` 定义为 `EmbeddedDocument`
    类型。以下是 `UserProfile` 的完整蓝图：'
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `EmbeddedDocument` API is a `Document` without an `id` and has no collection
    of its own. Subclasses of this API are model classes that have been created to
    be part of a core document structure, such as `UserProfile` being part of the
    `Login` details. Now, the field that refers to this document has a `required`
    property set to `False` since an embedded document can’t be present at all times.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmbeddedDocument` API 是一个没有 `id` 的 `Document`，并且没有自己的集合。这个 API 的子类是模型类，被创建为成为核心文档结构的一部分，例如
    `UserProfile` 是 `Login` 详细信息的一部分。现在，指向这个文档的字段有一个 `required` 属性设置为 `False`，因为嵌入文档并不总是存在。'
- en: On the other hand, a field declared as `EmbeddedDocumentList` is used to create
    a many-to-one association between documents. The preceding `UserProfile` class
    is strongly connected to a list of `BookForSale` embedded documents because of
    its declared `booksale` field. Again, the field type should always set its `required`
    property to `False` to avoid problems when dealing with empty values.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，声明为 `EmbeddedDocumentList` 的字段用于在文档之间创建多对一关联。由于声明的 `booksale` 字段，前面的 `UserProfile`
    类与一系列 `BookForSale` 嵌入文档紧密相连。再次强调，字段类型应始终将其 `required` 属性设置为 `False`，以避免处理空值时出现问题。
- en: Applying custom serialization and deserialization
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用自定义序列化和反序列化
- en: There are no built-in hooks for validation and serialization in this ODM. Every
    model class in the *online book reselling* application has implemented a `from_json()`
    class method that converts JSON details into a valid `Document` instance. When
    converting the BSON document into a JSON object, model classes must have the custom
    `to_json()` instance method, which builds the JSON structure and automatically
    transforms the BSON `datetime` into JSON-able `date` objects through formatting.
    Let us now create the repository layer using the model classes.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个ODM中没有内置的验证和序列化钩子。在*在线二手书交易*应用程序中，每个模型类都实现了`from_json()`类方法，该方法将JSON详情转换为有效的`Document`实例。当将BSON文档转换为JSON对象时，模型类必须具有自定义的`to_json()`实例方法，该方法构建JSON结构，并通过格式化自动将BSON
    `datetime`转换为可JSON化的`date`对象。现在让我们使用模型类创建仓库层。
- en: Implementing the CRUD transactions
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD事务
- en: 'MongoEngine provides the most convenient and straightforward approach to building
    the repository layer for the application. All its operations come from the `Document`
    model class and they are easy to use. `LoginRepository` uses the ODM to implement
    its CRUD transactions:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: MongoEngine提供了构建应用程序仓库层的最便捷和直接的方法。所有操作都来自`Document`模型类，并且易于使用。`LoginRepository`使用ODM来实现其CRUD事务：
- en: '[PRE25]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It only takes two lines for the `insert_login()` method to save the `Login`
    document. After creating the `Login` instance with the necessary document details,
    we simply call the `save()` method of the `Document` instance to pursue the insert
    transaction. When it comes to modifying some document values, the `Document` API
    class has an `update()` method that manages changes in state for every class attribute.
    But first, we need to find the document using the `objects()` utility method,
    which retrieves document structures from the collection. This `objects()` method
    can fetch a document by providing its parameter with an `id` field value or extracting
    a list of document records by supplying the method with a generic search expression.
    The instance of the retrieved document must invoke its `update()` method to pursue
    the modification of some, if not all, of its field values. The given `update_password()`
    method updates the password field of `Login`, which gives us a good template regarding
    how to pursue update operations on other field attributes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`insert_login()`方法仅需要两行代码来保存`Login`文档。在创建具有必要文档详情的`Login`实例后，我们只需调用`Document`实例的`save()`方法来执行插入事务。当涉及到修改某些文档值时，`Document`
    API类有一个`update()`方法来管理每个类属性的状态变化。但首先，我们需要使用`objects()`实用方法来查找文档，该方法从集合中检索文档结构。此`objects()`方法可以通过提供带有`id`字段值的参数来获取文档，或者通过向方法提供通用搜索表达式来提取文档记录列表。检索到的文档实例必须调用其`update()`方法来执行某些字段值（如果不是所有字段值）的修改。给定的`update_password()`方法更新了`Login`的密码字段，这为我们提供了一个关于如何对其他字段属性执行更新操作的优秀模板。'
- en: 'On the other hand, `delete_login()` shows how to delete a `Login` document
    from its collection after it searches for the object using a simple call to the
    instance’s `delete()` method. The following script shows how to perform query
    transactions in MongoEngine:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`delete_login()`展示了如何使用实例的简单`delete()`方法搜索对象后从其集合中删除`Login`文档。以下脚本展示了如何在MongoEngine中执行查询事务：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The only way to perform single- or multiple-document retrieval is to utilize
    the `objects()` method. There is no need to implement JSON converters for the
    query results because every `Document` model class has a `to_json()` method to
    provide the JSON-able equivalent of the instance. The given `get_all_login()`
    transaction uses list comprehension to create a list of JSON documents from the
    result of `objects()`, while the `get_login()` method invokes `to_json()` after
    extracting a single document.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 执行单文档或多文档检索的唯一方法是利用`objects()`方法。不需要为查询结果实现JSON转换器，因为每个`Document`模型类都有一个`to_json()`方法来提供实例的可JSON化等效物。给定的`get_all_login()`事务使用列表推导从`objects()`的结果创建JSON文档列表，而`get_login()`方法在提取单个文档后调用`to_json()`。
- en: Managing the embedded documents
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理嵌入式文档
- en: 'It is easier to implement document associations with an ODM than the core PyMongo
    and Motor database drivers. Since the operations of MongoEngine are comfortable
    to use, it takes only a few lines to manage the embedded documents. In the following
    `UserProfileRepository` script, `insert_profile()` shows how adding a `UserProfile`
    detail to the `Login` document can be done by performing a simple object search
    and an `update()` call:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ODM 实现文档关联比使用核心 PyMongo 和 Motor 数据库驱动程序更容易。由于 MongoEngine 的操作使用起来很舒适，因此只需几行代码就可以管理嵌入式文档。在下面的
    `UserProfileRepository` 脚本中，`insert_profile()` 展示了如何通过执行简单的对象搜索和 `update()` 调用来将
    `UserProfile` 细节添加到 `Login` 文档中：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Likewise, the given `add_book_sale()` transaction creates a many-to-one association
    between `BookForSale` and `UserProfile` using the same approach applied in `insert_profile()`
    with an additional List's `append()` operation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，给定的 `add_book_sale()` 事务使用与 `insert_profile()` 中相同的方法创建 `BookForSale` 和 `UserProfile`
    之间的多对一关联，并添加了一个列表的 `append()` 操作。
- en: 'Querying the embedded documents is also feasible in MongoEngine. The ODM has
    a `filter()` method that uses *field lookup syntax* to refer to a specific document
    structure or list of embedded documents. This field lookup syntax consists of
    the *field name of the embedded document*, followed by a *double underscore* in
    place of the dot in the usual object attribute access syntax. Then, it has *another
    double underscore* to cater to some *operators*, such as `lt`, `gt`, `eq`, and
    `exists`. In the following code, `get_all_profile()`uses the `profile__login_id__exists=True`
    field lookup to filter all `user_profile` embedded documents that have valid `login`
    structures. However, the `get_profile()` transaction does not need to use `filter()`
    and field lookups because it can simply access the specific login document to
    fetch its profile details:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoEngine 中查询嵌入式文档也是可行的。该 ODM 有一个 `filter()` 方法，它使用 *字段查找语法* 来引用特定的文档结构或嵌入式文档列表。这种字段查找语法由
    *嵌入式文档的字段名* 组成，后面跟着一个 *双下划线* 来代替通常对象属性访问语法中的点。然后，它还有一个 *另一个双下划线* 来适应一些 *运算符*，例如
    `lt`、`gt`、`eq` 和 `exists`。在下面的代码中，`get_all_profile()` 使用 `profile__login_id__exists=True`
    字段查找来过滤所有具有有效 `login` 结构的 `user_profile` 嵌入式文档。然而，`get_profile()` 事务不需要使用 `filter()`
    和字段查找，因为它可以直接访问特定的登录文档来获取其配置文件详细信息：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The preceding query transactions are just simple implementations compared to
    some other complex MongoEngine queries, which involve complicated embedded document
    structures that require complex field lookup syntax. Let us now apply the CRUD
    transactions to our API services.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些其他复杂的 MongoEngine 查询相比，前面的查询事务只是简单的实现，这些查询涉及复杂的嵌入式文档结构，需要复杂的字段查找语法。现在，让我们将
    CRUD 事务应用到我们的 API 服务中。
- en: Running the CRUD transactions
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 CRUD 事务
- en: CRUD will not work without passing our `create_db()` method to the *startup*
    event and `disconnect_db()` to the *shutdown* event. The former will open the
    MongoDB connection during the Uvicorn startup, while the latter will close it
    during server shutdown.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不在 *启动* 事件中传递我们的 `create_db()` 方法到 *启动* 事件，以及不在 *关闭* 事件中传递 `disconnect_db()`，则
    CRUD 将无法工作。前者将在 Uvicorn 启动期间打开 MongoDB 连接，而后者将在服务器关闭期间关闭它。
- en: 'The following script shows the application’s `profile` router with a `create_profile()`
    REST service that asks clients for a profile detail, given a specific login record,
    and pursues the insert transaction using `UserProfileRepository`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以下脚本显示了应用程序的 `profile` 路由器，其中包含一个 `create_profile()` REST 服务，该服务要求客户端提供一个配置文件详情，给定一个特定的登录记录，并使用
    `UserProfileRepository` 追踪插入事务：
- en: '[PRE29]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`create_profile()` is a standard API service that deals with MongoEngine’s
    synchronous `insert_profile()` transaction. When it comes to asynchronous REST
    services, it is not advisable to use MongoEngine because its platform only works
    with synchronous ones. In the next section, we will discuss an ODM that’s popular
    in building an asynchronous repository layer.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_profile()` 是一个标准的 API 服务，它处理 MongoEngine 的同步 `insert_profile()` 事务。当涉及到异步
    REST 服务时，不建议使用 MongoEngine，因为它的平台仅适用于同步服务。在下一节中，我们将讨论一个在构建异步存储层时流行的 ODM。'
- en: Implementing async transactions using Beanie
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Beanie 实现异步事务
- en: '**Beanie** is a non-boilerplate mapper that utilizes the core features of Motor
    and Pydantic. This ODM offers a more straightforward approach to implementing
    asynchronous CRUD transactions than its precursor, the Motor driver.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**Beanie** 是一个非模板映射器，它利用了 Motor 和 Pydantic 的核心功能。这个 ODM 提供了一种比其前身 Motor 驱动程序更直接的方法来实现异步
    CRUD 事务。'
- en: 'To use Beanie, we need to install it using the following `pip` command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Beanie，我们需要使用以下 `pip` 命令进行安装：
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Installing Beanie may uninstall the current version of your Motor module because
    it sometimes requires lower version of Motor module. Pursuing this will produce
    errors in your existing Motor transactions.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Beanie 可能会卸载你当前版本的 Motor 模块，因为它有时需要较低版本的 Motor 模块。继续这样做将在你的现有 Motor 事务中产生错误。
- en: Creating the database connection
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库连接
- en: 'Beanie uses the Motor driver to open a database connection to MongoDB. Instantiating
    the Motor’s `AsyncIOMotorClient` class with the database URL is the first step
    of configuring it. But what makes Beanie unique compared to other ODMs is how
    it pre-initializes and pre-recognizes the model classes that will be involved
    in a CRUD transaction. The ODM has an asynchronous `init_beanie()` helper method
    that initiates the model class initialization using the database name. Calling
    this method will also set up the collection-domain mapping, where all the model
    classes are registered in the `document_models` parameter of `init_beanie()`.
    The following script shows the database configuration that’s required to access
    our MongoDB database, `obrs`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie 使用 Motor 驱动程序打开到 MongoDB 的数据库连接。使用数据库 URL 实例化 Motor 的 `AsyncIOMotorClient`
    类是配置它的第一步。但与其它 ODM 相比，Beanie 的独特之处在于它如何预先初始化和识别将参与 CRUD 事务的模型类。该 ODM 有一个异步的 `init_beanie()`
    辅助方法，使用数据库名称来初始化模型类。调用此方法还将设置集合域映射，其中所有模型类都注册在 `init_beanie()` 的 `document_models`
    参数中。以下脚本展示了访问我们的 MongoDB 数据库 `obrs` 所需的数据库配置：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, `db_connect()` uses an async/await expression because its method invocation
    to `init_beanie()` is asynchronous. `db_disconnect()` will close the database
    connection by calling the `close()` method of the `AsyncIOMotorClient` instance.
    Both of these methods are executed as events, just like in MongoEngine. Their
    implementation can be found in the `/db_config/beanie_config.py` script file.
    Let us now create the model classes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`db_connect()` 使用了 async/await 表达式，因为它的方法调用 `init_beanie()` 是异步的。`db_disconnect()`
    将通过调用 `AsyncIOMotorClient` 实例的 `close()` 方法来关闭数据库连接。这两个方法都作为事件执行，就像在 MongoEngine
    中一样。它们的实现可以在 `/db_config/beanie_config.py` 脚本文件中找到。现在让我们创建模型类。
- en: Defining the model classes
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型类
- en: 'The Beanie ODM has a `Document` API class that’s responsible for defining its
    model classes, mapping them to MongoDB collections, and handling repository transactions,
    just like in MongoEngine. Although there is no `Field` directive for defining
    class attributes, the ODM supports Pydantic’s validation and parsing rules and
    `typing` extension for declaring models and their attributes. But it also has
    built-in validation and encoding features, which can be used together with Pydantic.
    The following script shows how to define Beanie model classes while it’s being
    configured:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie ODM 拥有一个 `Document` API 类，该类负责定义其模型类，将它们映射到 MongoDB 集合，并处理存储库事务，就像在 MongoEngine
    中一样。尽管没有用于定义类属性的 `Field` 指令，但 ODM 支持 Pydantic 的验证和解析规则以及 `typing` 扩展来声明模型及其属性。但它也具有内置的验证和编码功能，可以与
    Pydantic 一起使用。以下脚本展示了如何在配置过程中定义 Beanie 模型类：
- en: '[PRE32]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `id` attribute of the given `Document` classes automatically translates
    into an `_id` value. This serves as the primary key of the document. Beanie allows
    you to replace the default `ObjectId` type of `_id` with another type, such as
    `int`, which is not possible in other ODMs. And with Motor, this ODM needs custom
    JSON serializers because it has difficulty converting BSON `datetime` types into
    Python `datetime.date` types during CRUD transactions.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `Document` 类的 `id` 属性自动转换为 `_id` 值。这作为文档的主键。Beanie 允许你将默认的 `ObjectId` 类型的
    `_id` 替换为另一种类型，例如 `int`，这在其他 ODM 中是不可能的。并且与 Motor 一起，这个 ODM 需要自定义 JSON 序列化器，因为它在
    CRUD 事务期间难以将 BSON `datetime` 类型转换为 Python `datetime.date` 类型。
- en: A document in Beanie can be configured by adding the `Collection` and `Settings`
    nested classes. The `Collection` class can replace the default name of the collection
    where the model is supposed to be mapped. It can also provide indexes to document
    fields if needed. The `Settings` inner class, on the other hand, can override
    existing BSON encoders, apply caching, manage concurrent updates, and add validation
    when the document is being saved. These three model classes include the collection
    configuration in their definitions to replace the names of their respective collections
    with their class names.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie中的文档可以通过添加`Collection`和`Settings`嵌套类进行配置。`Collection`类可以替换模型应该映射到的默认集合名称。如果需要，它还可以为文档字段提供索引。另一方面，`Settings`内部类可以覆盖现有的BSON编码器，应用缓存，管理并发更新，并在保存文档时添加验证。这三个模型类在其定义中将集合配置包含在内，以用它们的类名替换各自的集合名称。
- en: Creating the document associations
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文档关联
- en: Python syntax, Pydantic rules, and API classes are used to establish links between
    documents in this mapper. To create a one-to-one association between `Order` and
    `Receipt`, for instance, we only need to set an `Order` field attribute that will
    link to a single `Receipt` instance. For many-to-one associations, such as the
    relationship between `Order` and `Cart`, the `Cart` document should only need
    a list field that will contain all the `Order` embedded documents.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个映射器中，使用Python语法、Pydantic规则和API类来建立文档之间的链接。例如，为了在`Order`和`Receipt`之间创建一对一的关联，我们只需要设置一个将链接到单个`Receipt`实例的`Order`字段属性。对于多对一关联，例如`Order`和`Cart`之间的关系，`Cart`文档只需要一个包含所有嵌入的`Order`文档的列表字段。
- en: However, the ODM has a `Link` type, which can be used to define class fields
    to generate these associations. Its CRUD operations, such as `save()`, `insert()`,
    and `update()`, strongly support these `Link` types, so long as the `link_rule`
    parameter is provided in their parameters. For query transactions, the `find()`
    method can include the `Link` documents during document fetching, given that its
    `fetch_links` parameter is set to `True`. Now, let us implement the repository
    layer using the model classes.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ODM有一个`Link`类型，可以用来定义类字段以生成这些关联。它的CRUD操作，如`save()`、`insert()`和`update()`，在提供`link_rule`参数的情况下，强烈支持这些`Link`类型。对于查询事务，如果将`fetch_links`参数设置为`True`，`find()`方法可以在获取文档时包括`Link`文档。现在，让我们使用模型类实现存储库层。
- en: Implementing the CRUD transactions
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD事务
- en: 'Implementing repositories with Beanie is similar to how it’s done with MongoEngine
    – that is, it uses short and direct CRUD syntax due to the convenient helper methods
    like create(), update(), and delete(), provided by the `Document` API class. However,
    the Beanie mapper creates an asynchronous repository layer because all the API
    methods that are inherited by the model classes are non-blocking. The following
    code for the `CartRepository` class shows a sample implementation of an asynchronous
    repository class using this Beanie ODM:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Beanie实现存储库与MongoEngine类似——也就是说，由于`Document` API类提供的方便的辅助方法（如create()、update()和delete()），它使用简短直接的CRUD语法。然而，Beanie映射器创建了一个异步存储库层，因为所有继承自模型类的API方法都是非阻塞的。以下`CartRepository`类的代码展示了使用这个Beanie
    ODM的异步存储库类的示例实现：
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `add_item()` method showcases the use of the asynchronous `insert()`method
    to persist a newly created `Cart` instance. The `Document` API also has a `create()`
    method that works like `insert()`. Another option is to use the `insert_one()`
    class method instead of the instance methods. Moreover, adding multiple documents
    is allowed in this ODM because an `insert_many()` operation exists to pursue that
    kind of insert.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`add_item()`方法展示了使用异步`insert()`方法持久化新创建的`Cart`实例。`Document` API还有一个`create()`方法，它的工作方式类似于`insert()`。另一个选择是使用`insert_one()`类方法而不是实例方法。此外，由于存在`insert_many()`操作，这个ODM允许添加多个文档。'
- en: Updating a document can be initiated using two methods, namely `set()` and `replace()`.`update_qty()`
    in the preceding script chooses the `set()` operation to update the current `qty`
    value of the items placed in a cart.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 更新文档可以使用两种方法，即`set()`和`replace()`。在前面的脚本中，`update_qty()`选择`set()`操作来更新放置在购物车中的项目的当前`qty`值。
- en: When it comes to document removal, the ODM only has the `delete()` method to
    pursue the transactions. This is present in the `delete_item()` transaction in
    the preceding code.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文档删除时，ODM只有`delete()`方法来追求事务。这在前面代码的`delete_item()`事务中是存在的。
- en: 'Retrieving a single document or a list of documents using this ODM is easy.
    No further serialization and cursor wrapping is needed during its query operations.
    When fetching a single document structure, the mapper provides the `get()` method
    if the fetching process only requires the `_id` field; it provides `find_one()`
    when the fetching process requires a conditional expression. Moreover, Beanie
    has a `find_all()` method that fetches all the documents without constraints and
    the `find()` method for retrieving data with conditions. The following code shows
    the query transaction for retrieving cart items from the database:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此ODM检索单个文档或文档列表非常简单。在其查询操作期间不需要进一步的序列化和光标包装。在获取单个文档结构时，如果获取过程只需要`_id`字段，映射器提供`get()`方法；如果获取过程需要条件表达式，则提供`find_one()`。此外，Beanie有一个`find_all()`方法，可以无约束地获取所有文档，以及用于有条件地检索数据的`find()`方法。以下代码显示了从数据库中检索购物车项的查询事务：
- en: '[PRE34]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Both the `find()` and `find_all()` operations are used in the methods to return
    a `FindMany` object that has a `to_list()` utility that returns a list of JSON-able
    documents. Let us now apply our CRUD transactions to the API services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在方法中使用`find()`和`find_all()`操作，以返回一个具有`to_list()`实用程序的`FindMany`对象，该实用程序返回一个可JSON化的文档列表。现在让我们将我们的CRUD事务应用到API服务中。
- en: Running the repository transactions
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行存储库事务
- en: 'The `CartRepository` methods will only run successfully if `db_connect()` from
    the configuration file is injected into the router. Although injecting it into
    each API service is acceptable, our solution prefers injecting the component into
    `APIRouter` using `Depends`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`CartRepository`方法只有在将配置文件中的`db_connect()`注入到路由器中时才能成功运行。虽然将其注入到每个API服务中是可以接受的，但我们的解决方案更喜欢使用`Depends`将组件注入到`APIRouter`中：'
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The asynchronous `add_cart_item()` service asynchronously inserts the cart account
    into the database using `CartRepository`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 异步的`add_cart_item()`服务使用`CartRepository`异步地将购物车账户插入到数据库中。
- en: Another asynchronous mapper that can integrate perfectly with FastAPI is *ODMantic*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个可以完美集成到FastAPI中的异步映射器是*ODMantic*。
- en: Building async repository for FastAPI using ODMantic
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ODMantic为FastAPI构建异步存储库
- en: The dependencies of Beanie and ODMantic come from Motor and Pydantic. ODMantic
    also utilizes Motor’s `AsyncIOMotorClient` class to open a database connection.
    It also uses Pydantic features for class attribute validation, Python’s typing
    extension for type hinting, and other Python components for management. But its
    edge over Beanie is that it complies with ASGI frameworks such as FastAPI.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: Beanie和ODMantic的依赖关系来自Motor和Pydantic。ODMantic还利用Motor的`AsyncIOMotorClient`类来打开数据库连接。它还使用Pydantic功能进行类属性验证，Python的类型扩展进行类型提示，以及其他Python组件进行管理。但它的优势在于它符合ASGI框架，如FastAPI。
- en: 'To pursue ODMantic, we need to install the extension using the following `pip`
    command:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要追求ODMantic，我们需要使用以下`pip`命令安装扩展：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Creating the database connection
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库连接
- en: 'Setting up the database connectivity in ODMantic is the same as what we do
    with the Beanie mapper, except that the setup includes creating an engine that
    will handle all its CRUD operations. This engine is `AIOEngine` from the `odmantic`
    module, which requires both the motor client object and the database name to be
    created successfully. The following is a complete implementation of the database
    connectivity needed by the ODMantic mapper:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在ODMantic中设置数据库连接与使用Beanie映射器所做的设置相同，但设置包括创建一个将处理所有CRUD操作引擎。这个引擎是来自`odmantic`模块的`AIOEngine`，它需要创建成功的同时具有motor客户端对象和数据库名称。以下是需要ODMantic映射器使用的数据库连接的完整实现：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We need to create event handlers in `APIRouter` to run `create_db_connection()`
    and `close_db_connection()` for our repository transactions to work. Let us now
    implement the model layer of the ODM.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`APIRouter`中创建事件处理器来运行`create_db_connection()`和`close_db_connection()`，以便我们的存储库事务能够工作。现在让我们实现ODM的模型层。
- en: Creating the model layer
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型层
- en: 'ODMantic has a `Model` API class that provides properties to model classes
    when subclassed. It relies on Python types and BSON specifications to define the
    class attributes. When transforming field types, such as converting a BSON `datetime`
    value into a Python `datetime.date` value, the mapper allows you to add custom
    `@validator` methods into the model classes to implement the appropriate object
    serializer. Generally, ODMantic relies on the `pydantic` module when it comes
    to data validation, unlike in the Beanie mapper. The following is a standard ODMantic
    model class definition:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ODMantic有一个`Model` API类，当子类化时，它为模型类提供属性。它依赖于Python类型和BSON规范来定义类属性。在转换字段类型时，例如将BSON
    `datetime`值转换为Python `datetime.date`值，映射器允许你在模型类中添加自定义的`@validator`方法以实现适当的对象序列化器。通常，ODMantic在数据验证方面依赖于`pydantic`模块，与Beanie映射器不同。以下是一个标准的ODMantic模型类定义：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: For advanced configurations, we can add a nested `Config` class to the model
    class to set these additional options, such as the `collection` option, which
    replaces the default name of the collection with a custom one. We can also configure
    some familiar options, such as `json_encoders`, to convert one field type into
    another supported one.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级配置，我们可以在模型类中添加一个嵌套的`Config`类来设置这些附加选项，例如`collection`选项，它用自定义名称替换集合的默认名称。我们还可以配置一些熟悉选项，例如`json_encoders`，将一个字段类型转换为另一个受支持的类型。
- en: Establishing document association
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立文档关联
- en: When creating associations, the typical Python approach of declaring fields
    so that they refer to an embedded document(s) is still applicable in this ODM.
    However, this ODM mapper has an `EmbeddedModel` API class to create a model with
    no `_id` field; this can be linked to another document. The `Model` classes, on
    the other hand, can define a field attribute that will refer to an `EmbeddedModel`
    class to establish a one-to-one association or a list of `EmbeddedModel` instances
    for a many-to-one association.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建关联时，尽管在这个对象文档映射（ODM）中仍然适用典型的Python方法，即声明字段以便它们引用嵌入的文档（s），但这个ODM映射器有一个`EmbeddedModel`
    API类来创建没有`_id`字段的模型；这可以链接到另一个文档。另一方面，`Model`类可以定义一个字段属性，该属性将引用`EmbeddedModel`类以建立一对一关联或多个`EmbeddedModel`实例的多个一对一关联。
- en: Implementing the CRUD transactions
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现CRUD事务
- en: 'Creating the repository layer using ODMantic always requires the engine object
    that was created in the startup event. This is because all the CRUD operations
    that are needed will come from this engine. The following `PurchaseRepository`
    shows the operations from the `AIOEngine` object that we need to create CRUD transactions:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ODMantic创建仓库层始终需要创建在启动事件中创建的引擎对象。这是因为所有需要的CRUD操作都将来自这个引擎。以下`PurchaseRepository`展示了我们需要创建CRUD事务的`AIOEngine`对象的操作：
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This `insert_purchase()` method shows the standard way to insert a record into
    the database using ODMantic. Through the engine’s `save()` method, we can persist
    one document at a time using the model class. `AIOEngine` also provides the `save_all()`
    method for inserting a list of multiple documents into the associated MongoDB
    collection.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`insert_purchase()`方法展示了使用ODMantic将记录插入数据库的标准方式。通过引擎的`save()`方法，我们可以使用模型类一次持久化一个文档。`AIOEngine`还提供了`save_all()`方法，用于将多个文档列表插入关联的MongoDB集合。
- en: 'Now, there is no specific way to update transactions, but ODMantic allows you
    to fetch the record that needs to be updated. The following code can be used to
    update a record using ODMantic:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，没有特定的方法来更新事务，但ODMantic允许你获取需要更新的记录。以下代码可以用来使用ODMantic更新记录：
- en: '[PRE40]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'After accessing and changing the field values, the fetched document object
    will be re-saved using the `save()` method to reflect the changes in physical
    storage. The complete process is implemented in the preceding `update_purchase()`
    transaction:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在访问和更改字段值之后，使用`save()`方法将获取的文档对象重新保存，以反映在物理存储中的更改。完整过程在先前的`update_purchase()`事务中实现：
- en: '[PRE41]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When it comes to document removal, you must fetch the document to be deleted.
    We pass the fetched document object to the `delete()` method of the engine to
    pursue the removal process. This implementation is shown in the `delete_purchase()`
    method.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到文档删除时，你必须获取要删除的文档。我们将获取的文档对象传递给引擎的`delete()`方法以继续删除过程。这种实现方式在`delete_purchase()`方法中展示。
- en: 'When fetching a single document so that it can be updated or deleted, `AIOEngine`
    has a `find_one()` method that requires two arguments: the model class name and
    the conditional expression, which involves either the `id` primary key or some
    non-unique fields. All the fields can be accessed like class variables. The following
    `get_purchase()` method retrieves a `Purchase` document with the specified `id`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要获取单个文档以便更新或删除时，`AIOEngine` 提供了一个 `find_one()` 方法，该方法需要两个参数：模型类名称和条件表达式，该表达式涉及
    `id` 主键或某些非唯一字段。所有字段都可以像类变量一样访问。以下 `get_purchase()` 方法检索具有指定 `id` 的 `Purchase`
    文档：
- en: '[PRE42]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The engine has a `find()` operation to retrieve all `Purchase` documents, for
    instance, from the database. It only needs an argument – the name of the model
    class. Let now apply our repository layer to the API services.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎有一个 `find()` 操作来检索所有 `Purchase` 文档，例如从数据库中。它只需要一个参数——模型类的名称。现在让我们将我们的存储库层应用到
    API 服务中。
- en: Running the CRUD transaction
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 CRUD 事务
- en: 'For the repository classes to run, all the router services must be asynchronous.
    Then, we need to create the startup and shutdown event handlers for `create_db_connection()`
    and `close_db_connection()`, respectively, to open the connection for repository
    transactions. Lastly, for the repository class to work, `create_db_engine()` must
    be injected into each API service to derive the engine object:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使存储库类运行，所有路由服务都必须是异步的。然后，我们需要为 `create_db_connection()` 和 `close_db_connection()`
    分别创建启动和关闭事件处理器，以打开存储库事务的连接。最后，为了使存储库类工作，`create_db_engine()` 必须注入到每个 API 服务中，以获取引擎对象：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At this point, we should know how to compare these mappers and drivers when
    it comes to the setup and procedures needed to manage MongoDB documents. Each
    has its strengths and weaknesses based on the code they produce and the performance,
    popularity, support, and complexity of its solution. Some may work on other requirements,
    while others may not. The final ODM we will cover focuses on being the lightest
    and least obtrusive mapper. It aims to fit into an existing application without
    generating syntax and performance problems.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该知道如何比较这些映射器和驱动程序在设置和程序方面的差异，这些差异是管理 MongoDB 文档所需的。每个都有其优点和缺点，这取决于它们产生的代码以及解决方案的性能、普及度、支持和复杂性。有些可能适用于其他要求，而有些可能不适用。我们将要介绍的最后一个
    ODM 专注于成为最轻量级和最不干扰的映射器。它的目标是适应现有应用程序，而不会产生语法和性能问题。
- en: Creating CRUD transactions using MongoFrames
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoFrames 创建 CRUD 事务
- en: If you are tired of using complicated and heavy-loaded ODMs, then MongoFrames
    is ideal for your requirements. MongoFrames is one of the newest ODMs and is very
    convenient to use, especially when building a new repository layer for an already
    existing complex and legacy FastAPI microservice application. But this mapper
    can only create synchronous and standard types of CRUD transactions.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你厌倦了使用复杂且负载沉重的 ODM，那么 MongoFrames 是满足你需求的不二之选。MongoFrames 是最新的 ODM 之一，使用起来非常方便，尤其是在为已经存在的复杂和遗留
    FastAPI 微服务应用程序构建新的存储库层时。但这个映射器只能创建同步和标准类型的 CRUD 事务。
- en: 'But before we proceed, let us install the extension module using `pip`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们继续之前，让我们使用 `pip` 安装扩展模块：
- en: '[PRE44]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Creating the database connection
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数据库连接
- en: 'The MongoFrames platform runs on top of PyMongo, which is why it cannot build
    an asynchronous repository layer. To create the database connection, it uses the
    `MongoClient` API class from the `pymongo` module, with the database URL in string
    format. Unlike in the other ODMs, where we create a client variable, in this mapper,
    we access the `variable _client` class from the `Frame` API class to refer to
    the client connection object. The following code shows `create_db_client()`, which
    will open the database connection for our app, and `disconnect_db_client()`, which
    will close this connection:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: MongoFrames 平台运行在 PyMongo 之上，这就是为什么它不能构建异步存储库层。为了创建数据库连接，它使用 `pymongo` 模块中的
    `MongoClient` API 类，数据库 URL 以字符串格式提供。与其他 ODM 不同，我们在其中创建一个客户端变量，在这个映射器中，我们通过 `Frame`
    API 类访问 `variable _client` 类来引用客户端连接对象。以下代码展示了 `create_db_client()`，它将为我们的应用程序打开数据库连接，以及
    `disconnect_db_client()`，它将关闭此连接：
- en: '[PRE45]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Just like in the previous ODMs, we need event handlers to execute these core
    methods to start building the model and repository layers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在之前的 ODM 中一样，我们需要事件处理器来执行这些核心方法，以开始构建模型和存储库层。
- en: Building the model layer
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建模型层
- en: 'The process of creating model classes in MongoFrames is called `Frame` API
    class to define the model classes. Once inherited, `Frame` does not require a
    model class to define its attributes. It uses the `_fields` property to contain
    all the necessary fields of the document without indicating any metadata. The
    following model classes are defined by the `Frame` API class:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MongoFrames 中创建模型类的过程称为 `Frame` API 类来定义模型类。一旦继承，`Frame` 不需要模型类来定义其属性。它使用
    `_fields` 属性来包含文档的所有必要字段，而不指示任何元数据。以下模型类是由 `Frame` API 类定义的：
- en: '[PRE46]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A `Frame` model class can wrap a document in dictionary form or in a `kwargs`
    that contains the key-value details of the document’s structure. It can also provide
    attributes and helper methods that can help pursue CRUD transactions. All the
    fields of the model class can be accessed through dot (`.`) notation, just like
    typical class variables.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Frame` 模型类可以包裹字典形式的文档或包含文档结构键值详情的 `kwargs`。它还可以提供属性和辅助方法，这些方法可以帮助执行 CRUD
    事务。模型类的所有字段都可以通过点（`.`）表示法访问，就像典型的类变量一样。
- en: Creating the document association
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建文档关联
- en: We need to define the `SubFrame` model before creating associations among these
    documents. A `SubFrame` model class is mapped to an embedded document structure
    and has no collection table of its own. The MongoFrames mapper provides operations
    that allow you to append, update, remove, and query the `SubFrame` class of the
    `Frame` instance. These operations will determine the type of association among
    documents since the field references of `Frame` do not have specific field types.
    The `Reference` document, for instance, will have a list of categories linked
    to its `categories` field because our transaction will build that association
    as designed. A `Book` document, on the other hand, will refer to a `Category`
    child document through its `category` field because a transaction will build that
    association at runtime. So, MongoFrames is both restrained and non-strict when
    it comes to defining the type of association among these documents.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建这些文档之间的关联之前，我们需要定义 `SubFrame` 模型。`SubFrame` 模型类映射到一个嵌入文档结构，并且没有自己的集合表。MongoFrames
    映射器提供了操作，允许您对 `Frame` 实例的 `SubFrame` 类进行追加、更新、删除和查询。这些操作将确定文档之间的关联类型，因为 `Frame`
    的字段引用没有特定的字段类型。例如，`Reference` 文档将有一个与它的 `categories` 字段链接的类别列表，因为我们的交易将按照设计构建这个关联。另一方面，一个
    `Book` 文档将通过其 `category` 字段引用一个 `Category` 子文档，因为交易将在运行时构建这个关联。所以，MongoFrames
    在定义这些文档之间关联类型时既受限制又非严格。
- en: Creating the repository layer
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建仓库层
- en: 'The `Frame` API class provides the model classes and the necessary helper methods
    to implement the asynchronous repository transactions. The following code shows
    an implementation of a repository class that uses MongoFrames to create its CRUD
    transactions:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frame` API 类提供了模型类和必要的辅助方法，以实现异步仓库事务。以下代码展示了使用 MongoFrames 创建 CRUD 事务的仓库类的实现：'
- en: '[PRE47]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The given `insert_book()` transaction inserts a book instance into its mapped
    collection. The `Frame` API provides an `insert()` method that saves the given
    model object into the database. It also has `insert_many()`, which inserts a list
    of multiple BSON documents or a list of model instances. The following script
    shows how to create an *UPDATE* transaction in MongoFrames:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `insert_book()` 事务将一个书籍实例插入其映射的集合中。`Frame` API 提供了一个 `insert()` 方法，该方法将给定的模型对象保存到数据库中。它还有一个
    `insert_many()` 方法，可以插入多个 BSON 文档或模型实例的列表。以下脚本展示了如何在 MongoFrames 中创建一个 *更新* 事务：
- en: '[PRE48]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The given `update_book()` transaction shows that the `Frame` model class also
    has an `update()` method, which recognizes and saves the changes reflected in
    the field values of a document object right after fetching them from the collection.
    A similar process is applied to the `delete_book()` process, which calls the `delete()`
    operation of the document object right after fetching it from the collection:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的 `update_book()` 事务表明 `Frame` 模型类还有一个 `update()` 方法，该方法在从集合中检索后立即识别并保存文档对象字段值中反映的变化。类似的流程应用于
    `delete_book()` 过程，它将在从集合中检索文档对象后立即调用文档对象的 `delete()` 操作：
- en: '[PRE49]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'When creating query transactions, the `Frame` API provides two class methods
    – the `many()` method, which extracts all BSON documents, and the `one()` method,
    which returns a single document object. Both operations can accept a query expression
    as an argument if there are any constraints. Moreover, MongoFrames has a `Q` query
    maker class that’s used to build conditionals in a query expression. The expression
    starts with `Q`, followed by dot (`.`) notation to define the field name or path
    – for example, `Q.categories.fiction` – followed by an operator (for example,
    `==`, `!=`, `>`, `>=`, `<`, or `<=`) and finally a value. The following code shows
    examples of the query transactions being translated using the MongoFrames ODM
    syntax:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建查询事务时，`Frame` API 提供了两个类方法——`many()` 方法，它提取所有 BSON 文档，以及 `one()` 方法，它返回单个文档对象。如果存在任何约束，这两个操作都可以接受一个查询表达式作为参数。此外，MongoFrames
    有一个 `Q` 查询构建器类，用于在查询表达式中构建条件。表达式以 `Q` 开头，后跟点（`.`）表示法来定义字段名或路径——例如，`Q.categories.fiction`——然后是一个运算符（例如，`==`、`!=`、`>`、`>=`、`<`
    或 `<=`），最后是一个值。以下代码展示了使用 MongoFrames ODM 语法进行查询事务翻译的示例：
- en: '[PRE50]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `get_book()` method shows how to extract a single `Book` document with a
    `Q` expression that filters the correct `id`, while `get_all_book()` retrieves
    all `Book` documents without any constraints.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_book()` 方法展示了如何使用 `Q` 表达式提取单个 `Book` 文档，该表达式过滤出正确的 `id`，而 `get_all_book()`
    则在没有任何约束的情况下检索所有 `Book` 文档。'
- en: The `many()` operator returns a list of `Frame` objects, while the `one()` operator
    returns a single `Frame` instance. To convert the result into JSON-able components,
    we need to invoke the `to_json_type()` method in each `Frame` instance.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`many()` 操作符返回一个 `Frame` 对象的列表，而 `one()` 操作符返回单个 `Frame` 实例。要将结果转换为可 JSON 化的组件，我们需要在每个
    `Frame` 实例中调用 `to_json_type()` 方法。'
- en: 'As explained earlier, adding embedded documents is determined by the operation
    and not by the model attributes. In the following `add_category()` transaction,
    it is clear that a `Category` object has been assigned to a `category` field of
    a `Book` instance, even if the field is not defined to refer to an embedded document
    of the `Category` type. Instead of throwing an exception, MongoFrame will update
    the `Book` document right after the `update()` call:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，嵌入文档的添加是由操作决定的，而不是由模型属性决定的。在以下 `add_category()` 事务中，很明显已经将一个 `Category`
    对象分配给了 `Book` 实例的 `category` 字段，即使该字段没有定义为引用 `Category` 类型的嵌入文档。而不是抛出异常，MongoFrame
    将在 `update()` 调用后立即更新 `Book` 文档：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Now, it is time to apply these CRUD transactions to our API services.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将这些 CRUD 事务应用到我们的 API 服务中了。
- en: Applying the repository layer
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用仓库层
- en: 'Our repository classes will not work if we do not inject the `create_db_client()`
    injectable into the router. The following solution injects the component into
    `APIRouter`, even if it is acceptable to inject it into each API service implementation:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有将 `create_db_client()` 注入器注入到路由器中，我们的仓库类将无法工作。以下解决方案将组件注入到 `APIRouter`
    中，即使将其注入到每个 API 服务实现中也是可接受的：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `create_book()` service uses `BookRepository` to insert book details into
    the MongoDB database. In general, MongoFrames has an easy setup because it requires
    fewer configuration details for creating the database connection, building the
    model layer, and implementing the repository transactions. Its platform can be
    adapted to the existing requirements of the application and can easily reflect
    changes if modifications need to be made to its mapping mechanisms.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_book()` 服务使用 `BookRepository` 将书籍详情插入到 MongoDB 数据库中。一般来说，MongoFrames
    设置起来很简单，因为它创建数据库连接、构建模型层和实现仓库事务所需的配置细节较少。其平台可以适应应用程序的现有需求，并且如果需要对其映射机制进行修改，可以轻松地反映变化。'
- en: Summary
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at various ways to manage data using MongoDB. We
    utilized MongoDB to store non-relational data for our *online book reselling system*
    since we expect the data to become large when information is exchanged between
    the book buyers and resellers. Additionally, the details involved in the transactions
    are mainly strings, floats, and integers, which are all order and purchase values
    that will be easier to mine and analyze if they’re stored in schema-less storage.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了使用 MongoDB 管理数据的各种方法。由于我们预计在书买家和转售商之间交换信息时数据量会变得很大，我们利用 MongoDB 来存储我们的
    *在线书籍转售系统* 中的非关系型数据。此外，交易中涉及到的细节主要是字符串、浮点数和整数，这些都是顺序和购买值，如果存储在无模式的存储中，将更容易进行挖掘和分析。
- en: This chapter took the non-relational data management roadmap for utilizing the
    data in sales forecasting, regression analysis of book readers’ demands, and other
    descriptive data analysis forms.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本章采用了非关系型数据管理路线图，用于在销售预测、书籍读者需求的回归分析以及其他描述性数据分析形式中利用数据。
- en: First, you learned how the PyMongo and Motor drivers connect the FastAPI application
    to the MongoDB database. After understanding the nuts and bolts of creating CRUD
    transactions using these drivers, you learned that ODM is the better option for
    pursuing MongoDB connectivity. We explored the features of MongoEngine, Beanie,
    ODMantic, and MongoFrames and studied their strengths and weaknesses as ODM mappers.
    All these ODMs can be integrated well with the FastAPI platform and provide the
    application with a standardized way to back up data.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你学习了如何使用 PyMongo 和 Motor 驱动程序将 FastAPI 应用程序连接到 MongoDB 数据库。在理解了使用这些驱动程序创建
    CRUD 事务的细节之后，你了解到 ODM 是追求 MongoDB 连接性的更好选择。我们探讨了 MongoEngine、Beanie、ODMantic 和
    MongoFrames 的功能，并研究了它们作为 ODM 映射器的优缺点。所有这些 ODM 都可以很好地与 FastAPI 平台集成，并为应用程序提供了一种标准化的数据备份方式。
- en: Now that we’ve spent two chapters covering data management, in the next chapter,
    we will learn how to secure our FastAPI microservice applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经用两章的篇幅涵盖了数据管理，在下一章中，我们将学习如何确保我们的 FastAPI 微服务应用程序的安全。
