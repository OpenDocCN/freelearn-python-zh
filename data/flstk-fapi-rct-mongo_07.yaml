- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Building a Backend with FastAPI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FastAPI构建后端
- en: In the previous chapters, you learned the basic mechanics of authentication
    and authorization, and now you are ready to implement it and secure a web API,
    built with FastAPI. In this chapter, you will put this knowledge to good use and
    create a simple, yet fully functional REST API showcasing used cars and their
    pictures.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了认证和授权的基本机制，现在你准备好实现它并保护一个用FastAPI构建的Web API了。在本章中，你将充分利用这些知识，创建一个简单但功能齐全的REST
    API，展示二手车及其图片。
- en: In this chapter, you will learn about the following actions, which can be thought
    of as a loosely coupled blueprint when creating a REST API with FastAPI.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解以下操作，这些操作可以被视为在用FastAPI创建REST API时的一个松散耦合的蓝图。
- en: 'This chapter will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Connecting the FastAPI instance to MongoDB Atlas by using the Python Motor driver
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用Python Motor驱动程序将FastAPI实例连接到MongoDB Atlas
- en: Defining the Pydantic models according to the specification and initial creation
    of the FastAPI application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据规范定义Pydantic模型，并初始化FastAPI应用程序
- en: Creating the API router and implementing CRUD operations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建API路由并实现CRUD操作
- en: Securing the API with a JWT
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用JWT保护API
- en: Deployment to Render
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署到Render
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter are similar to those defined earlier. You
    will work with:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求与之前定义的要求相似。你将使用以下内容进行工作：
- en: Python 3.11.7 or higher
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 3.11.7或更高版本
- en: Visual Studio Code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code
- en: An account on MongoDB Atlas
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB Atlas的介绍
- en: Later on, you will need to create an account on the image-hosting service **Cloudinary**
    (free) and the **Render** platform for hosting the API (also a free tier account).
    Again, you will use HTTPie for manually testing the API endpoints that you are
    going to implement.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要在图像托管服务**Cloudinary**（免费）和API托管平台**Render**（也是一个免费层账户）上创建账户。再次，你将使用HTTPie手动测试你将要实现的API端点。
- en: Let’s start by understanding the application to be developed and what the backend
    will require.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先了解将要开发的应用程序以及后端需要什么。
- en: Introducing the application
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍应用程序
- en: 'It is much easier to start working with a framework while having a specific
    problem that needs solving, even if the requirements are somewhat vague. The task
    at hand is rather simple: you need to create a REST API backend for storing and
    retrieving data about used cars for a fictional car sales company.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在有一个具体问题需要解决的情况下开始使用框架要容易得多，即使要求有些模糊。当前的任务相当简单：你需要为一家虚构的汽车销售公司创建一个用于存储和检索二手车数据的REST
    API后端。
- en: The data structure that describes a vehicle is rather simple but can become
    more complicated as soon as you delve into the details such as engine models,
    interior colors, types of suspension, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 描述车辆的这种数据结构相当简单，但一旦你深入研究细节，如发动机型号、内饰颜色、悬挂类型等，它可能会变得更加复杂。
- en: 'In your first simple **create**, **read**, **update**, **delete** (**CRUD**)
    application, you will keep the resource data limited. A car will be described
    by the following fields:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的第一个简单的**创建**、**读取**、**更新**、**删除**（**CRUD**）应用程序中，你将保持资源数据有限。一辆车将由以下字段描述：
- en: '`Brand`: The brand of the car (Ford, Renault, etc.), represented by a *string*'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`品牌`：汽车品牌（福特、雷诺等），用一个*字符串*表示'
- en: 'Make or model: For example, Fiesta or Clio, represented by a *string*'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 型号或型号：例如，Fiesta或Clio，用一个*字符串*表示
- en: '`Year`: The year of production, an *integer* limited to a reasonable range
    (1970–2024)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`年份`：生产年份，一个限制在合理范围内的*整数*（1970–2024）'
- en: '`Cm3`: The displacement of the engine, proportional to the power of the engine,
    a ranged *integer*'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Cm3`：发动机排量，与发动机功率成正比，一个范围*整数*'
- en: '`kW`: Power of the engine in kW, an *integer*'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kW`：发动机功率，以kW为单位的*整数*'
- en: '`Km`: How many kilometers the car has travelled, an *integer* in the hundreds
    of thousands range'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Km`：汽车行驶的公里数，一个位于数十万范围内的*整数*'
- en: '`Price`: The price in euros'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`价格`：欧元价格'
- en: 'An image URL: This is optional'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个图片URL：这是可选的
- en: An essential feature of every car sales website is the presence of images, so
    you will implement an image-uploading pipeline with one of the leading services
    for image hosting and processing—**Cloudinary**. Later, you will aid the employees
    even more by generating compelling copy text for each car model, which will make
    the API richer while showcasing FastAPI’s simplicity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 每个汽车销售网站的一个基本功能是存在图片，因此您将使用领先的图像托管和处理服务之一——**Cloudinary**——实现一个图像上传管道。稍后，您将为员工提供更多帮助，为每个汽车型号生成吸引人的文案，这将使
    API 更加丰富，同时展示 FastAPI 的简洁性。
- en: Creating an Atlas instance and a collection
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Atlas 实例和集合
- en: Log in to your Atlas account, and create a new database called `carBackend`
    inside a collection named `cars`. You can refer to [*Chapter 2*](B22406_02.xhtml#_idTextAnchor026),
    *Setting Up the Database with MongoDB*. After creating the database and the collection,
    take note of the MongoDB connection string and save it in a text file for later,
    when you will be creating your secret environment keys.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 登录您的 Atlas 账户，并在名为 `cars` 的集合中创建一个名为 `carBackend` 的新数据库。您可以参考[*第 2 章*](B22406_02.xhtml#_idTextAnchor026)，*使用
    MongoDB 设置数据库*。在创建数据库和集合后，注意 MongoDB 连接字符串并将其保存在文本文件中，以备后用，当您创建秘密环境密钥时。
- en: Setting up the Python environment
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Python 环境
- en: 'After creating the MongoDB database on Atlas and connecting it, it is time
    for you to set up a brand new Python virtual environment and install the requirements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Atlas 上创建 MongoDB 数据库并连接后，现在是时候为您设置一个新的 Python 虚拟环境并安装需求了：
- en: 'First, create a plain text file called `requirements.txt` and insert the following
    lines in it:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `requirements.txt` 的纯文本文件，并在其中插入以下行：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The package versioning is important if you want to be able to reproduce exactly
    the code used in this book and you can always refer to the `requirements.txt`
    file in the book’s repository. Run the `pip` installation command that reads the
    previously defined requirements file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想要能够精确地重现本书中使用的代码，则包版本控制很重要，并且您始终可以参考书中存储库中的 `requirements.txt` 文件。运行之前定义的需求文件中的
    `pip` 安装命令：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Your environment is ready. Now, armed with the knowledge of Python type hints
    and Pydantic from [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051), *Python Type
    Hints and Pydantic*, you will model this relatively simple car data structure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您的环境已准备就绪。现在，凭借从[*第 3 章*](B22406_03.xhtml#_idTextAnchor051)，*Python 类型提示和 Pydantic*中学到的
    Python 类型提示和 Pydantic 知识，您将构建这个相对简单的汽车数据结构。
- en: Defining the Pydantic models
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Pydantic 模型
- en: 'Let’s begin with the first Pydantic model, for a single car. Here, one of the
    main problems that need to be solved upfront is how to serialize and define the
    MongoDB `ObjectID` key in Pydantic. While there are different ways of representing
    the `ObjectID`, the simplest and the one currently recommended by MongoDB is to
    cast the `ObjectID` to a string. You can refer to the following documentation
    for further details: [https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/](https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个 Pydantic 模型开始，针对单一车辆。在这里，需要提前解决的一个主要问题是如何在 Pydantic 中序列化和定义 MongoDB
    的 `ObjectID` 键。虽然表示 `ObjectID` 的方法有很多种，但最简单且目前由 MongoDB 推荐的方法是将 `ObjectID` 转换为字符串。您可以参考以下文档以获取更多详细信息：[https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/](https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/)。
- en: MongoDB uses the field name `_id` for the identifier. In Python, since attributes
    that start with an underscore have a special meaning, you cannot use the original
    field name for model population.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 使用 `_id` 字段作为标识符。在 Python 中，由于以下划线开头的属性具有特殊含义，您不能使用原始的字段名进行模型填充。
- en: Pydantic aliases provide a simple and elegant solution; you can name the field
    `id` but also give it an alias of `_id` and set the `populate_by_name` flag to
    `True`, as shown in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051), *Python Type
    Hints* *and Pydantic*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Pydantic 别名提供了一个简单而优雅的解决方案；您可以命名字段为 `id`，但也可以将其别名为 `_id`，并将 `populate_by_name`
    标志设置为 `True`，如[*第 3 章*](B22406_03.xhtml#_idTextAnchor051)，*Python 类型提示和 Pydantic*中所示。
- en: Finally, you will need to cast the `ObjectID` as a string. To do so, you will
    use a simple Python annotation, and the Pydantic `BeforeValidator` module.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要将 `ObjectID` 转换为字符串。为此，您将使用简单的 Python 注解和 Pydantic 的 `BeforeValidator`
    模块。
- en: 'Create a folder named `Chapter7` and a `models.py` file inside of it, and start
    with the imports and the `ObjectID` type:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter7` 的文件夹，并在其中创建一个 `models.py` 文件，然后开始编写导入和 `ObjectID` 类型：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After the imports, and creating a new type, `PyObjectId`, which will be used
    to represent MongoDB’s original `ObjectID` as a string, continue populating the
    model:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入之后，创建一个新的类型 `PyObjectId`，它将用于将 MongoDB 的原始 `ObjectID` 作为字符串表示，继续填充模型：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These fields should be very familiar if you read the chapter on Pydantic; you
    are simply declaring the car fields, marking all of them as required, and setting
    some reasonable limits on the numerical quantities (`cm3`, `km`, `price`, and
    `year`).
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你阅读了 Pydantic 的章节，这些字段应该非常熟悉；你只是在声明汽车字段，将所有字段标记为必需，并对数值量（`cm3`、`km`、`price`
    和 `year`）设置一些合理的限制。
- en: Bear in mind that the number of car brands is limited, so it is possible and
    probably advisable to create an **enumerated** type for the brand name, but in
    this case, you will keep things simple.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，汽车品牌数量有限，因此创建一个 **枚举** 类型的品牌名称是有可能的，也是建议的，但在这个例子中，你将保持简单。
- en: 'Add two convenient field validators that act as modifiers. You want to return
    the title of every car brand and model:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个方便的字段验证器作为修饰符。你希望返回每个汽车品牌和型号的标题：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To complete the model, finally, add a configuration dictionary that will allow
    it to be populated by name and allow arbitrary types:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了完成模型，添加一个配置字典，允许它通过名称填充并允许任意类型：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can now test the model by adding the following (temporary) lines at the
    end of the file, outside of the class definition, and running it:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以通过在文件末尾添加以下（临时）行来测试模型，在类定义之外运行它：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run the `models.py` file:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `models.py` 文件：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, it’s time to define other models for updating a single instance and getting
    a list of cars. The `update` model will need to allow only specific fields to
    be changed. In theory, only the `price` should be updatable since cars are pretty
    immutable objects in their own right, but this system will allow for some ambiguity
    and situations in which the inserted data is just wrong and needs to be manually
    corrected via the API.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，是时候定义其他模型以更新单个实例和获取汽车列表了。`update` 模型需要只允许更改特定字段。理论上，只有 `price` 应该是可更新的，因为汽车本身是相当不可变的对象，但这个系统将允许一些模糊性和需要通过
    API 手动纠正的错误数据的情况。
- en: 'After deleting or commenting out the testing lines from `models.py`, proceed
    with creating the `UpdateCarModel` model:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在从 `models.py` 中删除或注释掉测试行之后，继续创建 `UpdateCarModel` 模型：
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The remaining part of the class is identical to the `CarModel` class and will
    be omitted for brevity.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类的剩余部分与 `CarModel` 类相同，为了简洁起见将省略。
- en: 'Finally, the `ListCarsModel` class will be very simple, as it only needs to
    handle a list of `CarModel` classes:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，`ListCarsModel` 类将非常简单，因为它只需要处理 `CarModel` 类的列表：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: With the models now in place, you are ready to make a simple test and see how
    `ListCarsModel` works.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在模型已经就绪，你可以进行简单的测试，看看 `ListCarsModel` 是如何工作的。
- en: 'Create a new testing file called `test_models.py`, add the following lines
    in order to create two different car models and a list, and then print a model
    dump:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `test_models.py` 的新测试文件，按照顺序添加以下行以创建两个不同的汽车模型和一个列表，然后打印模型转储：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you run the `test_models.py` file with Python, the output should be the
    following:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你用 Python 运行 `test_models.py` 文件，输出应该是以下内容：
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The models, at least an initial iteration of them (and MongoDB is excellent
    for iterative data modeling), are complete, so you can start scaffolding your
    FastAPI application structure in the next section.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 模型，至少是它们的初始迭代（MongoDB 在迭代数据建模方面非常出色），现在已经完成，所以你可以在下一节开始构建你的 FastAPI 应用程序结构。
- en: Scaffolding a FastAPI application
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建FastAPI应用程序
- en: '`Motor` driver. Initially, you will only create a generic and minimal FastAPI
    application, and gradually add functionality.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`Motor` 驱动器。最初，你将只创建一个通用的最小 FastAPI 应用程序，并逐步添加功能。'
- en: You will begin by storing the secret environment data—in your case, just the
    MongoDB Atlas database URL—into a `.env` file. These values should be always kept
    outside the reach of the repositories. You want to be able to connect to your
    MongoDB database and verify whether the connection is successful.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你将开始将秘密环境数据——在你的情况下，只是 MongoDB Atlas 数据库 URL——存储到 `.env` 文件中。这些值应该始终保持在存储库之外。你希望能够连接到你的
    MongoDB 数据库并验证连接是否成功。
- en: Creating a .env file to keep the secrets
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 .env 文件以保存秘密
- en: 'For managing values that should be kept secret and out of the version control
    system, you will use an environment file (`.env`). Perform the following steps
    to set up the environment variables and exclude them from the version control:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应保持秘密并排除在版本控制系统之外的价值，您将使用一个环境文件（`.env`）。执行以下步骤以设置环境变量并将它们排除在版本控制之外：
- en: 'First, create a `.env` file and, inside it, put your secret connection string
    in the following format, without quotes:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `.env` 文件，并在其中以以下格式放入您的秘密连接字符串，无需引号：
- en: '[PRE12]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `.env` file will later host other secret files for external services that
    you might need to use in your API development.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此 `.env` 文件将后来托管其他外部服务可能需要的秘密文件，您可能在 API 开发中使用。
- en: 'Now, create a `.gitignore` file, and populate it with the basic entries: directories
    and files that are not to be tracked by Git. Open a file, name it `.gitignore`,
    and insert the following:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个 `.gitignore` 文件，并填充基本条目：Git 不应跟踪的目录和文件。打开一个文件，命名为 `.gitignore`，并插入以下内容：
- en: '[PRE13]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are numerous examples of Python-related `.gitignore` files on the web,
    so feel free to look around, but this will be more than sufficient for our purposes.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网上有很多与 Python 相关的 `.gitignore` 文件示例，所以请随意查找，但这将足以满足我们的需求。
- en: 'Now, you can put the working directory under version control with the following
    Git commands:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下 Git 命令将工作目录置于版本控制之下：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a Pydantic configuration with pydantic_settings
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 pydantic_settings 创建 Pydantic 配置
- en: In the next steps, you will use the previously created environment variables
    and provide them to the `pydantic_settings`—the Pydantic class for managing application
    settings, covered in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051)*, Python
    Type Hints and Pydantic*. This class will later be easily invoked wherever the
    environment variables will be necessary.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的步骤中，您将使用之前创建的环境变量，并将它们提供给 `pydantic_settings`——这是用于管理应用程序设置的 Pydantic 类，在[*第
    3 章*](B22406_03.xhtml#_idTextAnchor051)*，Python 类型提示和 Pydantic* 中有介绍。这个类将在需要环境变量的任何地方轻松调用。
- en: 'After this preparatory work, create a `config.py` file that will leverage the
    `pydantic_settings` package for managing your settings, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这项准备工作后，创建一个名为 `config.py` 的文件，该文件将利用 `pydantic_settings` 包来管理您的设置，如下所示：
- en: 'Create a configuration file, aptly named `config.py`, which you will use for
    reading the settings of the application. You will be able to change them easily
    later when you introduce some automated testing or make different settings for
    production, a different database, and so on. Paste the following code into `config.py`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个配置文件，命名为 `config.py`，您将使用它来读取应用程序的设置。当您引入一些自动化测试或为生产环境、不同的数据库等设置不同的设置时，您将能够轻松地更改它们。将以下代码粘贴到
    `config.py` 文件中：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, you will use these configuration settings to get the environment data to
    connect to the MongoDB Atlas instance.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您将使用这些配置设置来获取环境数据以连接到 MongoDB Atlas 实例。
- en: 'Finally, you can start scaffolding the actual application file by creating
    a new Python file, named `app.py`. In this file, first, instantiate a FastAPI
    instance and create a root route with a simple message:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您可以通过创建一个名为 `app.py` 的新 Python 文件来开始构建实际的应用程序文件。在这个文件中，首先实例化一个 FastAPI 实例，并创建一个带有简单消息的根路由：
- en: '[PRE16]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should be able to run this bare-bones application in the terminal with
    your server of choice:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该能够在终端中使用您选择的任何服务器运行这个裸骨应用程序：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The simple root message is available at `127.0.0.1:8000` and you have the application
    running.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的根消息在 `127.0.0.1:8000` 上可用，并且应用程序正在运行。
- en: Connecting to Atlas
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接到 Atlas
- en: Now it is time to connect it to Atlas. To do so, you will use the **Lifespan
    Events** of FastAPI, which is the newer way of handling events that need to occur
    only once before the application starts up and begins receiving requests. Lifespan
    Events also allow you to handle events that should fire only after the application
    finishes handling requests.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候将其连接到 Atlas 了。为此，您将使用 FastAPI 的 **生命周期事件**，这是在应用程序启动并开始接收请求之前需要只发生一次的事件处理的新方法。生命周期事件还允许您处理在应用程序完成请求处理后应该触发的其他事件。
- en: Note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The FastAPI website has excellent documentation about the topic: [https://fastapi.tiangolo.com/advanced/events/](https://fastapi.tiangolo.com/advanced/events/).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 网站关于此主题有出色的文档：[https://fastapi.tiangolo.com/advanced/events/](https://fastapi.tiangolo.com/advanced/events/)。
- en: 'For the use case in this chapter, you will use an **asynchronous context manager**
    that will allow you to yield the application instance, and fire events before
    and after the application starts. Follow these steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章的使用案例，您将使用一个**异步上下文管理器**，这将允许您提供应用程序实例，并在应用程序启动前后触发事件。按照以下步骤操作：
- en: 'To showcase how this works, edit the `app.py` file:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了展示这是如何工作的，编辑`app.py`文件：
- en: '[PRE18]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you start the application with the same command as shown previously and then
    shut it down with *Ctrl+C*, you will see that the `print` statements display messages
    in the console.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您使用之前显示的相同命令启动应用程序，然后使用*Ctrl+C*关闭它，您将看到`print`语句在控制台显示消息。
- en: The `lifespan` event async context is the mechanism you will use to connect
    to your Atlas instance, through the use of the settings.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`lifespan`事件异步上下文是您将通过设置连接到您的Atlas实例的机制。'
- en: 'Again, open up the `app.py` file, add the configuration settings, change the
    `lifespan` function, and bring in the `Motor` driver:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开`app.py`文件，添加配置设置，更改`lifespan`函数，并引入`Motor`驱动程序：
- en: '[PRE19]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If you start the application now, you should receive a message similar to the
    following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您现在启动应用程序，您应该会收到以下类似的消息：
- en: '[PRE20]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You have implemented quite a lot in this setup:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个设置中，您已经实现了很多内容：
- en: You have created the FastAPI instance, the backbone of your API.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已创建了FastAPI实例，这是您API的骨干。
- en: You have set the environment variables with `pydantic_settings` and they are,
    thus, manageable and maintainable.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已使用`pydantic_settings`设置了环境变量，因此它们是可管理和可维护的。
- en: You have connected to the Atlas cluster that you have set up.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已连接到您设置的Atlas集群。
- en: You have also “attached“ the MongoDB database to the application, so you will
    be able to access it conveniently from the API routers through the request.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还“附加”了MongoDB数据库到应用程序，因此您将能够通过请求方便地从API路由器中访问它。
- en: Now, let's start implementing the routes for the **CRUD** operations, starting
    from a solid and expansible setup.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始实现**CRUD**（创建、读取、更新和删除）操作的路线，从一个稳固且可扩展的设置开始。
- en: CRUD operations
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CRUD操作
- en: The four basic operations at the heart of almost every web application are often
    referred by the acronym **CRUD** (**create**, **read**, **update**, and **delete**).
    These operations enable users to interact with data by creating new resources,
    retrieving one or more instances of existing resources, and modifying and deleting
    resources. Here, a more formal definition of APIs is used, but resources, in this
    case, are simply cars.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每个Web应用程序核心的四个基本操作通常被称为**CRUD**（创建、读取、更新和删除）的缩写。这些操作使用户能够通过创建新资源、检索现有资源的一个或多个实例以及修改和删除资源来与数据交互。在这里，使用了一个更正式的API定义，但资源在这种情况下只是汽车。
- en: 'FastAPI is strongly tied to web standards, so these operations map to specific
    HTTP request methods: `POST` is used for creating new instances, `GET` is for
    reading one or more cars, `PUT` is for updating, and `DELETE` is for deleting
    resources. In your case, the resources are represented by `cars`, which map to
    MongoDB documents.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI与网络标准紧密相连，因此这些操作映射到特定的HTTP请求方法：`POST`用于创建新实例，`GET`用于读取一个或多个汽车，`PUT`用于更新，而`DELETE`用于删除资源。在您的案例中，资源由`cars`表示，它们映射到MongoDB文档。
- en: Set up the API router
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置API路由器
- en: After having the application ready and serving a basic root endpoint, the environment
    variables set up, and the connection to the Atlas MongoDB database in place, you
    are now ready to start implementing the endpoints.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序准备就绪并开始服务基本根端点，设置了环境变量，并建立了与Atlas MongoDB数据库的连接后，您现在可以开始实现端点。
- en: In fact, in the following sections, we will add a router for users; this will
    be needed to enable you to associate individual cars with particular users/salespersons,
    and to allow for some basic authentication and authorization.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在接下来的章节中，我们将添加一个用户路由器；这将使您能够将单个汽车与特定的用户/销售人员关联起来，并允许进行一些基本的身份验证和授权。
- en: 'Like most modern web frameworks (Express.js, Flask, etc.), FastAPI allows you
    to structure and group endpoints into API routers. `APIRouter` is a module designed
    to handle a group of operations related to a single type of object or resource:
    in your case, cars, and later, users.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数现代Web框架（Express.js、Flask等）一样，FastAPI允许您将端点结构化和分组到API路由器中。`APIRouter`是一个模块，用于处理与单一类型对象或资源相关的一组操作：在您的案例中，是汽车，稍后是用户。
- en: 'Perform the following steps to create the API router for managing cars:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建用于管理汽车的API路由器：
- en: Create a dedicated folder inside your app directory and name it `/routers`.
    This directory will contain all the API routers . Inside it, create an empty `__init__.py`
    file to turn the folder into a Python package.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的应用程序目录内创建一个专门的文件夹，并命名为 `/routers`。该目录将包含所有 API 路由器。在其内部，创建一个空的 `__init__.py`
    文件，将文件夹转换为 Python 包。
- en: Now, create a file named `/routers/cars.py`. This will be the first router in
    this app but, potentially, you could add more should the application grow. It
    is a convention to name the routers according to the resources they manage.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `/routers/cars.py` 的文件。这将是该应用程序中的第一个路由器，但如果有必要，随着应用程序的增长，您可以添加更多。按照惯例，根据它们管理的资源命名路由器。
- en: 'Inside `/routers/cars.py`, begin scaffolding the router:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/routers/cars.py` 内部，开始构建路由器：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `APIRouter` instantiation is very similar to the creation of the main FastAPI
    instance—it can be thought of as a small FastAPI application that becomes an integral
    part of the main app, as well as its automated documentation.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`APIRouter` 的实例化与创建主 FastAPI 实例非常相似——它可以被视为一个小的 FastAPI 应用程序，它成为主应用程序的一个组成部分，以及其自动文档。'
- en: '`APIRouter` by itself doesn’t have any functionality—it needs to be plugged
    into the main application (`app.py`) in order to perform its tasks.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`APIRouter` 本身没有任何功能——它需要连接到主应用程序 (`app.py`) 才能执行其任务。'
- en: 'Before proceeding, let’s modify the `app.py` file and plug the newly created
    `APIRouter` in:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续之前，让我们修改 `app.py` 文件并将新创建的 `APIRouter` 插入其中：
- en: '[PRE22]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You have created your first `APIRouter` that will be handling operations regarding
    cars and you have connected it, through the `app.py` file, to the main FastAPI
    instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了第一个 `APIRouter`，它将处理有关汽车的操作，并且您已经通过 `app.py` 文件将其连接到主 FastAPI 实例。
- en: Now, you will add functionality to the `APIRouter` by implementing handlers
    for various operations.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将通过实现各种操作的处理器来为 `APIRouter` 添加功能。
- en: The POST handler
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: POST 处理器
- en: 'Now, with the `APIRouter` connected, you can return to the `/routers/cars.py`
    file and create the first endpoint, a `POST` request handler for creating new
    instances:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与 `APIRouter` 连接后，您可以返回到 `/routers/cars.py` 文件并创建第一个端点，一个用于创建新实例的 `POST`
    请求处理器：
- en: '[PRE23]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The code is rather simple and self-explanatory as it uses the previously defined
    Pydantic model (`CarModel`), which is flexible enough to be reused (through the
    alias) as the input and output model.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 代码相当简单且易于理解，因为它使用了之前定义的 Pydantic 模型 (`CarModel`)，该模型足够灵活，可以通过别名作为输入和输出模型重用。
- en: The line that creates the document to be inserted from the model uses a couple
    of Pydantic features, which are covered in [*Chapter 3*](B22406_03.xhtml#_idTextAnchor051),
    *Python Type Hints and Pydantic*, namely, the *alias* and the *excluded* fields.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建从模型插入文档的行使用了几个 Pydantic 功能，这些功能在 [*第 3 章*](B22406_03.xhtml#_idTextAnchor051)，*Python
    类型提示和 Pydantic* 中有介绍，即 *别名* 和 *排除* 字段。
- en: 'Now, launch the application:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，启动应用程序：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In another terminal, still inside the working directory of your project and
    with the virtual environment activated, test the endpoint with **HTTPie**:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，仍然位于您项目的当前工作目录内，并且虚拟环境已激活，使用 **HTTPie** 测试端点：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Your terminal should output the following response:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您的终端应该输出以下响应：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You have created the first endpoint—you can test it further with HTTPie, or
    with the interactive documentation at `http://127.0.0.1:8000/docs`, and try inserting
    some invalid data, such as a year greater than 2024 or something similar.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您已创建了第一个端点——您可以使用 HTTPie 或 `http://127.0.0.1:8000/docs` 上的交互式文档进一步测试它，并尝试插入一些无效数据，例如年份大于
    2024 或类似的数据。
- en: The endpoint should respond with informative JSON that will quickly direct you
    to the problem or provide feedback to the end user. Now, you will create the `GET`
    handlers for viewing the cars inside your database.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 端点应该返回包含信息的 JSON，这将迅速引导您找到问题或向最终用户提供反馈。现在，您将创建用于查看数据库中汽车的 `GET` 处理器。
- en: Handling the GET requests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理 GET 请求
- en: For viewing resources—cars—in your system, you will use the HTTP `GET` method.
    FastAPI makes very good use of HTTP verb semantics and closely follows web standards
    and good practices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看系统中的资源——汽车，您将使用 HTTP `GET` 方法。FastAPI 充分利用 HTTP 动词语义，并紧密遵循网络标准和良好实践。
- en: 'Follow these steps:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'First, return the whole collection of cars—if you have played around with the
    `POST` endpoint, you might already have a couple of them inserted. Continuing
    the `/routers/cars.py` file, let’s add the `GET` handler:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，返回整个汽车集合——如果你已经玩过`POST`端点，你可能已经插入了几辆。继续编辑`/routers/cars.py`文件，让我们添加`GET`处理器：
- en: '[PRE27]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Test this endpoint with HTTPie:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用HTTPie测试此端点：
- en: '[PRE28]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: After running the preceding command, you should get all the cars inserted up
    to this point, in a nice JSON structure. The function signature and the decorator
    are similar to the `POST` endpoint.
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行前面的命令后，你应该会得到到目前为止插入的所有汽车，以一个漂亮的JSON结构呈现。函数签名和装饰器与`POST`端点相似。
- en: 'Instead of using `async` `for`, which can be a bit counterintuitive at first
    if you are not used to it, you could also swap the population of the empty results
    list with the following:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不使用`async` `for`（如果你不习惯，一开始可能会觉得有点反直觉），你也可以用以下方式交换空结果列表的填充：
- en: '[PRE29]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, you could use the `to_list()` method to get the results in a list. If
    you wish to dive deeper into the `Motor` documentation on handling cursors, their
    page is a bit dry but complete: [https://motor.readthedocs.io/en/stable/api-tornado/cursors.html](https://motor.readthedocs.io/en/stable/api-tornado/cursors.html).'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，你可以使用`to_list()`方法将结果获取为一个列表。如果你希望深入了解处理游标的`Motor`文档，他们的页面可能有点枯燥但内容完整：[https://motor.readthedocs.io/en/stable/api-tornado/cursors.html](https://motor.readthedocs.io/en/stable/api-tornado/cursors.html)。
- en: Later, you will learn how to manually add pagination, since the collection will
    hopefully grow to hundreds of cars, as you will not want to send the user hundreds
    of results immediately. Now, create the `GET` endpoint for finding a single car
    by its ID.
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后，你将学习如何手动添加分页，因为集合可能会增长到数百辆汽车，你不会希望立即向用户发送数百个结果。现在，创建一个通过ID查找单个汽车的`GET`端点。
- en: 'In the same `/routers/cars.py` file, add the following `GET` handler:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个`/routers/cars.py`文件中，添加以下`GET`处理器：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The logic of the endpoint is contained in the line that checks whether the
    collection contains a car with the desired ID and the ID is supplied via a path
    parameter. The Python walrus operator (`:=`), also known as the assignment expression,
    makes your code more concise: if the car is found (it is not `None`), it is returned
    and the operand of the truthiness check—the car instance itself—is passed on;
    otherwise, the code proceeds to finish with an HTTP exception.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 端点的逻辑包含在检查集合是否包含具有所需ID的汽车，并且ID是通过路径参数提供的这一行。Python的walrus运算符（`:=`），也称为赋值表达式，使你的代码更加简洁：如果找到汽车（它不是`None`），则返回，并将真值检查的操作数——汽车实例本身——传递下去；否则，代码将继续执行并抛出HTTP异常。
- en: 'Again, for the HTTPie command for testing, you will need to look up an ID and
    provide it as a path parameter (your ID value will be different from the following):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，对于HTTPie测试命令，你需要查找一个ID并将其作为路径参数提供（你的ID值将不同于以下）：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You have implemented two of the most important result listing methods that
    map to a `GET` HTTP method: retrieving a list of all items and a specific single
    item. Other `GET` endpoints can retrieve queries based on MongoDB aggregations,
    simpler queries, and filtering, but these two cover the basics.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经实现了映射到`GET` HTTP方法的最重要两种结果列出方法：检索所有项的列表和特定单个项。其他`GET`端点可以基于MongoDB聚合、简单查询和过滤来检索查询，但这两个涵盖了基础。
- en: Now, let’s complete the API with the `UPDATE` and `DELETE` methods.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过`UPDATE`和`DELETE`方法完成API。
- en: Updating and deleting records
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新和删除记录
- en: 'Now you will tackle the most complex endpoint—the `PUT` method that will be
    used for updating the car instance. Again, in the same `/routers/cars.py` file,
    after the `GET` routes, continue editing:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将处理最复杂的端点——用于更新汽车实例的`PUT`方法。同样，在同一个`/routers/cars.py`文件中，在`GET`路由之后，继续编辑：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first part of the endpoint function analyzes the provided user data and
    checks which fields should be updated, by merely acknowledging their presence
    in the provided `UpdateCarModel` Pydantic model. If the field is present in the
    request body, its value is passed to the `update` dictionary.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 端点函数的第一部分分析提供的用户数据，并检查哪些字段应该被更新，只需通过确认它们在提供的`UpdateCarModel` Pydantic模型中的存在即可。如果字段在请求体中存在，其值将被传递到`update`字典中。
- en: 'Thus, you get a transformed `car` object that, if not empty, will then be fed
    to the `find_one_and_update()` function of MongoDB:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你得到一个转换后的`car`对象，如果不为空，则将其传递给MongoDB的`find_one_and_update()`函数：
- en: '[PRE33]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The update result simply performs the asynchronous update and returns the updated
    document by leveraging PyMongo’s `ReturnDocument.AFTER` to return the document
    after the update has been performed.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 更新结果简单地执行异步更新，并利用PyMongo的`ReturnDocument.AFTER`在更新完成后返回更新后的文档。
- en: 'Finally, you must also take into account the case in which none of the fields
    is set for updating, and simply return the original document if it is found:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你还需要考虑这样一种情况：在更新时没有任何字段被设置，如果发现这种情况，就简单地返回原始文档：
- en: '[PRE34]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The endpoint provides two possibilities of a `404` exception in case the document
    is not found: when there are fields to be updated and when there are not.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 端点提供了两种`404`异常的可能性：当有字段需要更新时，以及当没有字段需要更新时。
- en: 'Now, finish the implementation of the basic CRUD functionality with the method
    for deleting cars:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用删除汽车的方法完成基本CRUD功能的实现：
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is probably the simplest endpoint; if the car with the ID is found, it
    is deleted and the appropriate HTTP status is returned on an empty (`No` `Content`)
    response.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单的端点；如果找到具有该ID的汽车，它将被删除，并在空（`No` `Content`）响应上返回适当的HTTP状态。
- en: 'This concludes the basic CRUD functionality, but before going on, let’s tackle
    another aspect that, while not part of the basic functionality, will incur in
    every real-life project: result pagination.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了基本的CRUD功能，但在继续之前，让我们解决另一个方面的问题，虽然它不是基本功能的一部分，但将在每个实际项目中出现：结果分页。
- en: Result pagination
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结果分页
- en: Every application that works with data and users must have an appropriate way
    to enable and facilitate their communication. Slamming hundreds of results into
    the browser isn’t exactly the best solution.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每个与数据和用户打交道的应用程序都必须有一种适当的方式来启用和促进他们的沟通。将数百个结果强行推入浏览器并不是最佳解决方案。
- en: Results pagination with MongoDB, as well as other databases, is achieved with
    the help of the `skip` and `limit` parameters.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB以及其他数据库进行结果分页是通过`skip`和`limit`参数实现的。
- en: 'In this case, you will create a simple frontend-friendly pagination system
    with a custom Pydantic model that will provide two additional JSON properties:
    the current page and the `has_more` flag, to indicate whether there are more result
    pages.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你将创建一个简单的、对前端友好的分页系统，使用自定义的Pydantic模型，该模型将提供两个额外的JSON属性：当前页和`has_more`标志，以指示是否有更多结果页。
- en: This pattern matches the pagination UI with the arrows and page numbers that
    indicate the total number of results to the user.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式将分页UI与箭头和页码匹配，这些箭头和页码向用户指示结果总数。
- en: 'Start by commenting out the existing `GET` route. Open the `models.py` file
    and add the following model:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，注释掉现有的`GET`路由。打开`models.py`文件并添加以下模型：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This model inherits the `CarCollection` model and adds the two desired fields
    – this pattern is useful when dealing with large and complex models.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此模型继承自`CarCollection`模型并添加了两个所需的字段——当处理大型且复杂的模型时，此模式非常有用。
- en: 'In the `cars.py` file, after instantiating `APIRouter`, add a hardcoded constant
    that will define the number of default results per page:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cars.py`文件中，在实例化`APIRouter`后，添加一个硬编码的常量，该常量将定义每页默认的结果数：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now you will update (or better, replace entirely) the `get all` method in the
    `routers/cars.py` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将更新（或者更好，完全替换）`routers/cars.py`文件中的`get all`方法：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The first part of the function is very similar to the previous version, but
    we have two new parameters: `page` and `limit` (the number of results per page).
    Now, create the actual pagination:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第一部分与上一个版本非常相似，但我们有两个新的参数：`page`和`limit`（每页的结果数）。现在，创建实际的分页：
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The bulk of the work is handled directly by MongoDB, with the `limit` and `skip`
    parameters. The endpoint needs the total number of cars in the collection in order
    to provide information on the remaining results and their existence.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分工作直接由MongoDB处理，使用`limit`和`skip`参数。端点需要集合中汽车的总数，以便提供有关剩余结果及其存在的信息。
- en: This endpoint will work just like the previous one so, to properly test it,
    open MongoDB Compass and import some data. The accompanying GitHub repository
    contains a file named `cars.csv` with 1,249 cars.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 此端点将像之前的端点一样工作，因此为了正确测试它，请打开MongoDB Compass并导入一些数据。附带的GitHub仓库包含一个名为`cars.csv`的文件，其中包含1,249辆汽车。
- en: 'After importing this data, you can perform a `GET` request like the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入这些数据后，你可以执行以下`GET`请求：
- en: '[PRE40]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output should contain a list of cars, as in the previous case, but also
    the indication of the page and whether there are more results:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应包含汽车列表，就像上一个案例一样，但也要指明页面和是否有更多结果：
- en: '[PRE41]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since you are already pulling the total document count from the database, you
    could extend this pagination model to include either the total number of cars
    in the database or the total number of pages given the current pagination. That
    would be a good exercise that showcases how easy it is to extend and modify the
    FastAPI setup.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你已经在从数据库中提取总文档计数，你可以扩展此分页模型以包括数据库中的汽车总数或根据当前分页提供的总页数。这将是一个很好的练习，展示了如何轻松扩展和修改FastAPI设置。
- en: You have successfully created a fully functional REST API with FastAPI. Now,
    let’s further enhance the application by providing image-uploading functionality.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用FastAPI成功创建了一个功能齐全的REST API。现在，让我们通过提供图像上传功能来进一步增强应用程序。
- en: Uploading images to Cloudinary
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上传图像到Cloudinary
- en: While FastAPI is perfectly capable of serving static files – through the `StaticFiles`
    module ([https://fastapi.tiangolo.com/tutorial/static-files/](https://fastapi.tiangolo.com/tutorial/static-files/))
    – you will rarely want to use your server space and bandwidth to store images
    or videos.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FastAPI完全能够通过`StaticFiles`模块([https://fastapi.tiangolo.com/tutorial/static-files/](https://fastapi.tiangolo.com/tutorial/static-files/))提供静态文件服务，但你很少会想用你的服务器空间和带宽来存储图像或视频。
- en: Many specialized services can take care of digital asset media management and,
    in this section, you will learn how to work with one of the premier players in
    the area—**Cloudinary**.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 许多专业服务可以处理数字资产媒体管理，在本节中，你将学习如何与该领域的主要参与者之一——**Cloudinary**合作。
- en: Cloudinary, as its name suggests, is a cloud-based service that provides various
    solutions for digital media assets and web and mobile applications. These services
    include uploading and storing images and videos, and these are precisely the functions
    that we are going to use now.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，Cloudinary是一个基于云的服务，为数字媒体资产和Web和移动应用程序提供各种解决方案。这些服务包括上传和存储图像和视频，这正是我们现在将要使用的功能。
- en: However, Cloudinary and other similar specialized services offer much more (image
    and video manipulations, filters, automatic cropping and formatting, and real-time
    transformations) and they might be an excellent fit for many media workflows,
    especially very heavy ones.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Cloudinary和其他类似的专业服务提供了更多（图像和视频处理、过滤器、自动裁剪和格式化以及实时转换）的功能，它们可能非常适合许多媒体工作流程，尤其是非常繁重的工作流程。
- en: To be able to use the service, you will first need to create a free account
    by following the instructions at [https://cloudinary.com/users/register_free](https://cloudinary.com/users/register_free).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用该服务，你首先需要通过[https://cloudinary.com/users/register_free](https://cloudinary.com/users/register_free)上的说明创建一个免费账户。
- en: After successfully signing up and logging in, you will automatically get assigned
    a product environment key, visible in the top-left corner. For your purposes,
    you will only interact through the Python API as you need to be able to upload
    images to your environment through FastAPI.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功注册并登录后，你将自动分配一个产品环境密钥，位于左上角。就你的用途而言，你将通过Python API进行交互，因为你需要能够通过FastAPI将图像上传到你的环境。
- en: 'To get started with the Python API, or any other for that matter, in addition
    to this environment key, you will need two more pieces of information: the *API
    key* and the *API secret*. Both can be obtained from the **Settings** page ([console.cloudinary.com./settings](http://console.cloudinary.com./settings))
    and by selecting **API Keys** from the left menu.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Python API，或者任何其他API，除了这个环境密钥外，你还需要另外两块信息：*API密钥*和*API密钥*。这两者都可以从**设置**页面([console.cloudinary.com./settings](http://console.cloudinary.com./settings))通过选择左侧菜单中的**API密钥**获取。
- en: 'Copy the API key and API secret, or create new ones and copy them into your
    existing `.``env` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 复制API密钥和API密钥，或者创建新的并复制到现有的`.``env`文件中：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The environment name is mapped as `CLOUDINARY_CLOUD_NAME`, while the secret
    key and API key are prepended by `CLOUDINARY`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 环境名称映射为`CLOUDINARY_CLOUD_NAME`，而密钥和API密钥则由`CLOUDINARY`前缀。
- en: 'You will also need to modify the `config.py` file to accommodate the new variables:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要修改`config.py`文件以适应新的变量：
- en: '[PRE43]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The next step is to install the `cloudinary` Python package:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是安装`cloudinary`Python包：
- en: '[PRE44]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another thing you can do is add it to your `requirements.txt` file, which,
    at this point, should look like this:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以将其添加到你的 `requirements.txt` 文件中，此时它应该看起来像这样：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The Cloudinary documentation is much richer when it comes to JavaScript, and
    there seem to be a couple of quirks when setting up the upload client, but the
    essence is simple.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 JavaScript 时，Cloudinary 文档更为丰富，设置上传客户端时似乎有几个怪癖，但本质上是简单的。
- en: Updating the models
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新模型
- en: 'First, you will update the `models.py` file to accommodate the new field –
    a string that will store the URL of the uploaded image from Cloudinary:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要更新 `models.py` 文件以适应新的字段——一个将存储从 Cloudinary 上传的图片 URL 的字符串：
- en: 'Open the `models.py` file and add just one line in the `CarModel` class, after
    the other fields and before the validators:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `models.py` 文件，并在其他字段和验证器之后仅添加一行到 `CarModel` 类中：
- en: '[PRE46]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: At this point, you should open `cars` collection, as you will create a new,
    empty one. Now, comment out the previous route for the `POST` handler in the `cars.py`
    file and create a new one taking into account the image uploading process.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，你应该打开 `cars` 集合，因为你将创建一个新的、空的集合。现在，在 `cars.py` 文件中注释掉之前的 `POST` 处理器路由，并创建一个新的路由，考虑到图像上传过程。
- en: 'Cloudinary provides a simple utility module called `uploader` that needs to
    be imported, along with the `cloudinary` module itself. After the existing imports,
    add the following lines (`cars.py`):'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cloudinary 提供了一个简单的实用模块，称为 `uploader`，需要导入，以及 `cloudinary` 模块本身。在现有的导入之后，添加以下行（`cars.py`）：
- en: '[PRE47]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: These lines import `cloudinary` and the `uploader` package, while the `# noqa`
    line prevents code linters from removing the line upon saving (as it is imported
    from a package that is already imported as a whole).
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些行导入了 `cloudinary` 和 `uploader` 包，而 `# noqa` 行防止代码检查器在保存时删除该行（因为它是从已整体导入的包中导入的）。
- en: The next step is configuring your Cloudinary instance, and you can do it in
    the `/routers/cars.py` file for convenience, although this could be made application-wide.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是配置你的 Cloudinary 实例，你可以为了方便在 `/routers/cars.py` 文件中这样做，尽管这也可以是应用级别的。
- en: To be able to read the environment variables, you will need to instantiate the
    `Settings` class again in the same file and pass the variables to the `cloudinary`
    configuration object.
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了能够读取环境变量，你需要在同一文件中再次实例化 `Settings` 类，并将变量传递给 `cloudinary` 配置对象。
- en: 'Open the cars router and modify it. The first part of the `/routers/cars.py`
    file should now look like this:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 cars 路由器并对其进行修改。现在 `/routers/cars.py` 文件的前一部分应该看起来像这样：
- en: '[PRE48]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Now, you must treat the `POST` handler differently, since it will accept a
    form and a file (your car picture) and not JSON anymore. You will need to accept
    the form data:'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，你必须以不同的方式处理 `POST` 处理器，因为它将接受表单和一个文件（你的汽车图片），而不是 JSON。你需要接受表单数据：
- en: '[PRE49]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: All the `CarModel` fields are now mapped to form fields with names, while the
    picture is defined as an `UploadFile` and expects a file.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有 `CarModel` 字段现在都映射到具有名称的表单字段，而图片被定义为 `UploadFile` 并期望一个文件。
- en: 'Continue with the same function, and add the uploading functionality:'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 继续使用相同的函数，并添加上传功能：
- en: '[PRE50]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The code that handles the actual upload is very simple: just a call to `uploader`
    with the received file and there are numerous options, transformations, and filters
    that you could use.'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 处理实际上传的代码非常简单：只需调用 `uploader` 并传入接收到的文件，你可以使用许多选项、转换和过滤器。
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The Cloudinary documentation covers in detail the available transformations:
    [https://cloudinary.com/documentation/transformations_intro](https://cloudinary.com/documentation/transformations_intro).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: Cloudinary 文档详细介绍了可用的转换：[https://cloudinary.com/documentation/transformations_intro](https://cloudinary.com/documentation/transformations_intro).
- en: In your case, you are just cropping the image and setting a maximum width. Cloudinary
    will return a URL once the picture is uploaded, and that URL will be part of the
    model, along with the data we used previously.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的情况下，你只是裁剪图片并设置最大宽度。Cloudinary 会在图片上传后返回一个 URL，这个 URL 将成为模型的一部分，以及我们之前使用的其他数据。
- en: 'Finally, you can construct a Pydantic model of the car and pass it to the MongoDB
    `cars` collection:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以构建一个 Pydantic 模型来表示汽车，并将其传递给 MongoDB 的 `cars` 集合：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can test the endpoint through the interactive documentation that FastAPI
    serves on `127.0.0.1:8000/docs`; just select an image and pass it to the file
    field that is present in the `POST` handler for the root route, and don’t forget
    to fill the remaining fields or there will be an error—just like dealing with
    JSON.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过FastAPI在`127.0.0.1:8000/docs`上提供的交互式文档测试端点；只需选择一张图片并将其传递给根路由的`POST`处理程序中的文件字段，别忘了填写剩余的字段，否则会出现错误——就像处理JSON一样。
- en: 'You can also test the route with HTTPie, but first provide an image and name
    it accordingly:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用HTTPie测试路由，但首先提供一张图片并相应地命名它：
- en: '[PRE52]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: After having the `Cars` API router ready, now you will create the second router
    for handling users.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在准备好`Cars` API路由器之后，现在你将创建第二个路由器来处理用户。
- en: Adding the user model
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加用户模型
- en: You have successfully created a REST API powered by the Cloudinary image hosting
    and processing power and, following a similar procedure, you could easily integrate
    other third-party services into your API, making your application more complex
    and powerful.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经成功创建了一个由Cloudinary图像托管和处理能力驱动的REST API，并且通过类似的过程，你可以轻松地将其他第三方服务集成到你的API中，使你的应用程序更加复杂和强大。
- en: Without authentication, however, it would be very risky to deploy even the simplest
    API online. For instance, a malicious user (or even a kid willing to pull some
    pranks) could easily “bomb” your API with images that you wouldn’t want displayed
    and in quantities that would quickly fill your free quota. Therefore, before committing
    your API to GitHub and deploying it—in this case, to Render.com—you will add a
    user model and a JWT-based authentication scheme very similar to the one shown
    in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105), *Authentication* *and Authorization*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有认证，将即使是简单的API部署到线上也是非常危险的。例如，一个恶意用户（甚至是一个愿意恶作剧的孩子）可以轻易地用你不想显示的图片“轰炸”你的API，并且数量足以迅速填满你的免费配额。因此，在将你的API提交到GitHub并部署——在这种情况下，到Render.com——之前，你将添加一个用户模型和一个与[*第6章*](B22406_06.xhtml#_idTextAnchor105)中展示的非常相似的基于JWT的认证方案，*认证*
    *和授权*。
- en: In the following section, you will create a simple user model and allow users
    to log in to the application, in order to perform some operations otherwise unavailable
    – namely, creating, updating, and deleting resources (cars). You will begin by
    abstracting the authentication logic into a class.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将创建一个简单的用户模型，并允许用户登录到应用程序，以便执行一些其他情况下不可用的操作——即创建、更新和删除资源（汽车）。你将从将认证逻辑抽象成一个类开始。
- en: Creating the authentication functionality
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建认证功能
- en: 'In this section, you will implement an authentication class, similar to the
    one used in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105), *Authentication and
    Authorization*, that will abstract the functionalities needed for authentication
    and authorization—password encryption, JWT encoding and decoding, and the dependency
    that will be used for protecting routes. Follow these steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将实现一个认证类，类似于在[*第6章*](B22406_06.xhtml#_idTextAnchor105)中使用的，*认证和授权*，该类将抽象出认证和授权所需的功能——密码加密、JWT编码和解码，以及用于保护路由的依赖项。请按照以下步骤操作：
- en: 'First, create a file called `authentication.py` in the root folder of your
    project and import the modules needed for authentication:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在你的项目根目录下创建一个名为`authentication.py`的文件，并导入所需的认证模块：
- en: '[PRE53]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Next, implement an `AuthHandler` class that will provide all the needed functionality
    for hashing and verifying passwords and encoding and decoding tokens:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，实现一个`AuthHandler`类，它将提供所有必要的功能来散列和验证密码以及编码和解码令牌：
- en: '[PRE54]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, you will end the file with the `auth_wrapper` function, which will
    be injected as a dependency into the FastAPI endpoints that require an authenticated
    user:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你将在文件末尾添加`auth_wrapper`函数，该函数将被注入到需要认证用户的FastAPI端点中：
- en: '[PRE55]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The authentication class is nearly identical to the one defined in [*Chapter
    6*](B22406_06.xhtml#_idTextAnchor105)*, Authentication and Authorization*—it provides
    methods for password hashing and verification, for JWT encoding and decoding,
    and a handy `auth_wrapper` method that is used as a dependency injection.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 认证类几乎与在[*第6章*](B22406_06.xhtml#_idTextAnchor105)*认证和授权*中定义的相同——它提供了密码散列和验证、JWT编码和解码的方法，以及一个方便的`auth_wrapper`方法，用作依赖注入。
- en: With the `authentication.py` file ready, add the user model, very similar to
    the one defined in the previous chapter, bearing in mind that this model could
    be much more complex.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `authentication.py` 文件准备好后，添加用户模型，它与上一章中定义的模型非常相似，请注意，此模型可能更加复杂。
- en: 'In the `models.py` file, edit the `CarModel` class and add another field—`user_id`.
    That way, you will be able to associate an inserted car with a particular user
    and require a valid user for every creation operation:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `models.py` 文件中，编辑 `CarModel` 类并添加另一个字段——`user_id`。这样，您就可以将插入的汽车与特定用户关联起来，并要求每个创建操作都有效用户：
- en: '[PRE56]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The model for updating the car will not need the `user_id` field as you do
    not want to make that field editable. Now, after all the car models, let’s add
    the user-related models in the same `models.py` file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新汽车的模型不需要 `user_id` 字段，因为您不希望使该字段可编辑。现在，在所有汽车模型之后，让我们在同一个 `models.py` 文件中添加与用户相关的模型：
- en: '[PRE57]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The three models correspond to the three ways you will be accessing the user
    data: the full model with all the data, the login and registration model, and
    the current user that should return `_id` and the username.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 三种模型对应于您将访问用户数据的三种方式：包含所有数据的完整模型、登录和注册模型，以及应返回 `_id` 和用户名的当前用户。
- en: Creating the User router
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建用户路由器
- en: After the Pydantic models are set up, create a new router for users and allow
    some basic operations such as registration, logging in, and verifying the user
    based on the JWT.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 Pydantic 模型之后，为用户创建一个新的路由器，并允许一些基本操作，例如注册、登录和基于 JWT 验证用户。
- en: 'Open the file named `users.py` inside the `routers` folder and add the imports:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `routers` 文件夹内名为 `users.py` 的文件并添加导入：
- en: '[PRE58]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `authhandler` class encapsulates all of your authentication logic and you
    will see this functionality in the endpoint functions.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`authhandler` 类封装了所有的身份验证逻辑，您将在端点函数中看到此功能。'
- en: 'Let’s create the registration route:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建注册路由：
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The endpoint performs the same functionality as shown in [*Chapter 6*](B22406_06.xhtml#_idTextAnchor105),
    *Authentication and Authorization*, except, this time, you are working with a
    real MongoDB collection. The login functionality is also very similar:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 端点执行与[*第 6 章*](B22406_06.xhtml#_idTextAnchor105)中所示的功能相同，*身份验证和授权*，但这次，您正在处理一个真实的
    MongoDB 集合。登录功能也非常相似：
- en: '[PRE60]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: If a user is not found by `username` or the password doesn’t match, the endpoint
    responds with an HTTP `401` status and throws a generic message; otherwise, a
    username and a token are returned.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到用户或密码不匹配，端点将响应 HTTP `401` 状态并抛出一个通用消息；否则，将返回用户名和令牌。
- en: 'The final endpoint consists of a `/me` route—a route that will be used periodically
    by the frontend (React) to check the existing JWT and its validity:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 最终端点由一个 `/me` 路由组成——该路由将由前端（React）定期使用以检查现有的 JWT 及其有效性：
- en: '[PRE61]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'With the `users` router finished, let’s plug it into the `app.py` file, just
    below the `cars` router:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成 `users` 路由器后，将其连接到 `app.py` 文件，位于 `cars` 路由器下方：
- en: '[PRE62]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The `cars.py` file, which contains the `APIRouter` for managing the cars, will
    have to be updated to take into account the newly added user data. The creation
    endpoint will now look like the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 包含管理汽车的 `APIRouter` 的 `cars.py` 文件将需要更新以考虑新添加的用户数据。创建端点现在将如下所示：
- en: '[PRE63]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The user data is provided through dependency injection and `auth_wrapper`.
    The rest of the function is largely unaltered—you just need the `user_id` value
    from the logged-in user:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 用户数据通过依赖注入和 `auth_wrapper` 提供。函数的其余部分基本未更改——您只需要登录用户的 `user_id` 值：
- en: '[PRE64]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The API is now quite complete; it handles data of varying complexity and can
    handle images using a top-quality cloud service. However, before deploying your
    API to an online cloud platform for the world to see, there is one more thing
    that needs to be done: setting up the **cross-origin resource sharing** (**CORS**)
    middleware.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: API 现在相当完整；它处理各种复杂性的数据，并可以使用顶级云服务处理图像。然而，在将您的 API 部署到在线云平台供全世界查看之前，还有一件事需要做：设置
    **跨源资源共享**（**CORS**）中间件。
- en: FastAPI middleware and CORS
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FastAPI 中间件和 CORS
- en: The concept of middleware is common in almost every reputable web framework,
    and FastAPI is no exception. Middleware is just a function that accepts requests
    before they are handed over to the path operations for processing and also responds
    before they are returned.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件的概念在几乎每个值得信赖的 Web 框架中都很常见，FastAPI 也不例外。中间件只是一个在将请求传递给路径操作处理之前接受请求的函数，并在它们返回之前进行响应。
- en: This simple concept is quite powerful and has many uses—a middleware can check
    for specific headers that contain authentication data (such as a bearer token)
    and accept or deny requests accordingly, it can be used for rate limiting (often
    with the Redis key-value database), and so on.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的概念非常强大，有众多用途——一个中间件可以检查包含认证数据（例如令牌）的特定头信息，并根据情况接受或拒绝请求，它可以用于速率限制（通常与 Redis
    键值数据库一起使用），等等。
- en: 'Creating middleware in FastAPI is based on *Starlette’s* middleware, like most
    web-related concepts in FastAPI, and the documentation provides some nice examples:
    [https://fastapi.tiangolo.com/tutorial/middleware/](https://fastapi.tiangolo.com/tutorial/middleware/).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FastAPI 中创建中间件基于 *Starlette* 的中间件，就像 FastAPI 中大多数与网络相关的概念一样，文档提供了一些很好的示例：[https://fastapi.tiangolo.com/tutorial/middleware/](https://fastapi.tiangolo.com/tutorial/middleware/)。
- en: In your application, you will use a ready-made middleware to enable the FastAPI-based
    backend—which will be running on one machine—to communicate with a frontend (in
    your case, React) running on a different origin.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中，你将使用现成的中间件来启用基于 FastAPI 的后端——该后端将运行在一台机器上——与运行在不同源的前端（在你的情况下，React）进行通信。
- en: 'CORS refers to the policy that is applied when you incur situations when the
    backend and frontend reside on different origins and, by default, it is very restrictive—
    allowing only sharing data (such as calling JavaScript fetch functions) between
    systems using the same origin: the combination of a protocol (HTTP, for instance),
    domain (such as [www.packt.com](http://www.packt.com)) and a port (for example,
    `3000` or `80`).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: CORS 指的是当后端和前端位于不同的源时应用的政策，默认情况下它非常严格——只允许使用相同源的系统之间共享数据（例如调用 JavaScript fetch
    函数）：协议（例如 HTTP）、域名（例如 [www.packt.com](http://www.packt.com)）和端口号（例如 `3000` 或 `80`）的组合。
- en: By default, the policy blocks all communication, so if you were to deploy your
    backend as it is currently, you couldn’t reach it from a React.js or Next.js application
    running even on the same machine but a different port.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该策略阻止所有通信，所以如果你像现在这样部署你的后端，你将无法从运行在同一台机器但不同端口的 React.js 或 Next.js 应用程序中访问它。
- en: FastAPI’s solution for this task is achieved through middleware, and it allows
    granular precision.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: FastAPI 解决这个任务的方案是通过中间件实现的，并且它允许细粒度的精确控制。
- en: 'In your `app.py` file, import the following to import the CORS middleware:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 `app.py` 文件中，导入以下内容以导入 CORS 中间件：
- en: '[PRE65]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'After having imported the middleware, you need to configure it. After instantiating
    the FastAPI instance with the lifespan, add the middleware:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 导入中间件后，你需要对其进行配置。在用生命周期实例化 FastAPI 实例后，添加中间件：
- en: '[PRE66]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is a catch-all CORS setup that should be avoided in production, but it
    will be enough for our purposes and this example backend. The square brackets
    contain lists of allowed methods (such as `POST`, `GET`, and so on), origins,
    headers, and whether credentials should be allowed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个通用的 CORS 设置，在生产环境中应避免使用，但对我们目的和这个示例后端来说已经足够了。方括号包含允许的方法列表（例如 `POST`、`GET`
    等）、源、头信息和是否允许凭据。
- en: You can restart the Uvicorn server and check that it works like before. Now,
    you will deploy the backend on a cloud platform.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重新启动 Uvicorn 服务器并检查它是否像以前一样工作。现在，你将在云平台上部署后端。
- en: Deployment to Render.com
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Render.com
- en: '*Render.com* is one of numerous modern cloud platforms that simplify deploying
    and managing web applications, APIs, static sites, and other types of software
    projects. It provides developers with an intuitive and simple interface and powerful
    automation tools and pipelines.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '*Render.com* 是众多简化部署和管理 Web 应用程序、API、静态网站和其他类型软件项目的现代云平台之一。它为开发者提供了一个直观且简单的界面，以及强大的自动化工具和管道。'
- en: 'There are many ways to deploy a FastAPI instance: Vercel (known mainly as the
    company behind Next.js), Fly.io, Ralway, Heroku, and so on.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 部署 FastAPI 实例的方法有很多：Vercel（主要作为 Next.js 背后的公司）、Fly.io、Ralway、Heroku 等等。
- en: In this case, we will choose Render.com as it provides a simple, fast, streamlined
    deployment procedure, and has a free tier and excellent documentation.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将选择 Render.com，因为它提供了一个简单、快速、简化的部署流程，并提供免费层和优秀的文档。
- en: 'The deployment process can be broken into steps, and you will review each one
    of them briefly; it is also useful to visit their FastAPI-dedicated page if you
    wish to get up to speed: [https://docs.render.com/deploy-fastapi](https://docs.render.com/deploy-fastapi).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 部署过程可以分为几个步骤，您将简要地审查每一个；如果您希望快速了解，也可以访问他们的FastAPI专用页面：[https://docs.render.com/deploy-fastapi](https://docs.render.com/deploy-fastapi)。
- en: 'Here are the steps:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤：
- en: Set up a GitHub repo for your backend.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为您的后端设置一个GitHub仓库。
- en: Again, make sure that your `.gitignore` file contains entries for the `.env`
    file, as well as the `env/` directory for the Python environment—you do not want
    to accidentally commit the secrets and passwords to a public repository, nor do
    you want to upload the entire virtual environment content.
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次确保您的`.gitignore`文件包含`.env`文件的条目，以及Python环境的`env/`目录——您不希望意外地将机密和密码提交到公共仓库，也不希望上传整个虚拟环境的内容。
- en: 'If you haven’t committed the last changes to your backend, do it now with the
    following commands:'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您还没有将后端最后的更改提交，现在就使用以下命令进行提交：
- en: '[PRE67]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Now head to [github.com](http://github.com), use your credentials to log in,
    and create a new repository. Name it however you see fit; in this example, we
    will use the name `FastAPIbackendCh7`.
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，前往[github.com](http://github.com)，使用您的凭证登录，并创建一个新的仓库。您可以随意命名；在这个例子中，我们将使用名称`FastAPIbackendCh7`。
- en: Set up a Render.com account.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置Render.com账户。
- en: 'Now, head over to [render.com](http://render.com) and create a free account.
    You can log in with your GitHub account and then navigate to the dashboard link:
    [dashboard.render.com](http://dashboard.render.com).'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，前往[render.com](http://render.com)并创建一个免费账户。您可以使用GitHub账户登录，然后导航到仪表板链接：[dashboard.render.com](http://dashboard.render.com)。
- en: Locate the **New +** button and select **Web Service**. On the next prompt,
    select **Build and deploy from a Git repository** and click **Next**.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 定位到**新+**按钮，选择**网络服务**。在下一个提示中，选择**从Git仓库构建和部署**并点击**下一步**。
- en: Select the GitHub repository.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择GitHub仓库。
- en: In the right-hand menu, select the **GitHub Configure** account and you will
    be taken to GitHub asking you to install Render. Choose your account, the one
    you used for the backend repository origin, and proceed to select the repo. This
    will allow Render to know which repository to pull.
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在右侧菜单中选择**GitHub Configure**账户，您将被带到GitHub，要求您安装Render。选择您的账户，即您用于后端仓库源的那个账户，然后继续选择仓库。这将使Render知道要拉取哪个仓库。
- en: Configure the web service.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置网络服务。
- en: 'This is the most important and complex step of the process. Render is informed
    which repository is involved, and now it has to get all the data necessary for
    the web service to be deployed. We will examine them one by one:'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是整个过程中最重要且最复杂的步骤。Render已经知道涉及哪个仓库，现在它必须获取部署网络服务所需的所有数据。我们将逐一检查：
- en: '`main`, especially if it is the only branch, as in our case.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`main`，尤其是在我们的案例中它是唯一分支的情况下。'
- en: '`/`.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/`.'
- en: '**Runtime**: You will be using Python 3; it should be picked up automatically
    by Render.'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时**：您将使用Python 3；它应该会被Render自动识别。'
- en: '**Build command**: The command that sets up the environment – in your case,
    the Python 3 virtual environment, so it should be the following:'
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建命令**：设置环境的命令——在您的案例中，是Python 3虚拟环境，因此应该是以下命令：'
- en: '[PRE68]'
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '`80`), the command should be as follows:'
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`80`），命令应该是以下这样：'
- en: '[PRE69]'
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`.env` file, one by one: `DB_URL` and `DB_NAME` for MongoDB, and three Cloudinary
    variables.'
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.env`文件，一个接一个：`DB_URL`和`DB_NAME`用于MongoDB，以及三个Cloudinary变量。'
- en: After checking that you have entered all the settings and variables, you can
    finally click the blue **Create Web** **Service** button.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在确认您已经输入了所有设置和变量后，您最终可以点击蓝色的**创建网络服务**按钮。
- en: 'The final settings page will look similar to the following images. The settings
    page is quite long and you will have to scroll a bit, but the first thing that
    has to be specified are the name of the service and the region:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的设置页面将类似于以下图片。设置页面相当长，您可能需要滚动一下，但首先必须指定的是服务的名称和区域：
- en: '![](img/B22406_07_01.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22406_07_01.png)'
- en: 'Figure 7.1: The Render web service general settings page'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：Render网络服务常规设置页面
- en: After setting the name and the region, you will see your selected repository
    and the branch to be deployed (**main**, in your case). You can leave the root
    directory empty by default.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置名称和区域后，您将看到您选择的仓库和要部署的分支（在您的案例中是**main**）。您可以将根目录默认留空。
- en: '![](img/B22406_07_02.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B22406_07_02.png)'
- en: 'Figure 7.2: The repository and the branch settings'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：仓库和分支设置
- en: Next, you will specify the build and the start command. The build command is
    the one that installs your Python environment, while the start command starts
    the web service – your API.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将指定构建和启动命令。构建命令是安装您的Python环境的那一个，而启动命令则是启动您的网络服务——您的API。
- en: '![](img/B22406_07_03.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22406_07_03.png)'
- en: 'Figure 7.3: The build and start commands'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：构建和启动命令
- en: 'The last step before starting the actual deployment command is to pass the
    environment variables to Render.com:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际的部署命令之前，最后一步是将环境变量传递给Render.com：
- en: '![](img/B22406_07_04.png)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B22406_07_04.png)'
- en: 'Figure 7.4: The environment variables'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B22406_07_04.png)'
- en: After initiating the deployment procedure, you will have to wait a bit—the service
    will have to create a new Python environment, install all the required dependencies,
    and start the service. After the process is complete, you can click on the URL
    on the page (in your case, it will be [https://farm2ch7.onrender.com](https://farm2ch7.onrender.com)
    you will have to use another address) and you can check your API online.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动部署流程后，您需要稍等片刻——服务将需要创建一个新的Python环境，安装所有必需的依赖项，并启动服务。在过程完成后，您可以在页面上的URL上点击（在您的例子中，将是[https://farm2ch7.onrender.com](https://farm2ch7.onrender.com)，您将需要使用另一个地址）并在线检查您的API。
- en: Your API is now live on the internet and ready to receive requests. It is worth
    mentioning that due to the recent rise of FastAPI’s popularity, more and more
    hosting and `.``env` files.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您的API现在已经在互联网上上线，并准备好接收请求。值得一提的是，由于FastAPI最近越来越受欢迎，越来越多的托管服务和`.env`文件。
- en: Summary
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have taken a simple business requirement and turned it
    into a fully functional API deployed on the internet.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将一个简单的业务需求转变为一个完全功能性的API，并部署到了互联网上。
- en: You have created the Pydantic models and applied some constraints on the data
    structure, learned how to connect to a MongoDB Atlas instance, and developed a
    basic, yet fully functional, CRUD functionality FASTAPI service.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您创建了Pydantic模型，并对数据结构应用了一些约束，学习了如何连接到MongoDB Atlas实例，并开发了一个基本但功能齐全的CRUD功能FASTAPI服务。
- en: You have learned how to model entities (in your case, cars and users) through
    Pydantic and how to make the data flow seamlessly to and from your database of
    choice – MongoDB – through simple pythonic FastAPI endpoints.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学会了如何通过Pydantic来建模实体（在您的例子中，是汽车和用户），以及如何通过简单的Pythonic FastAPI端点，将数据无缝地流向和从您选择的数据库——MongoDB——中流动。
- en: You have managed the secret keys – for connecting to MongoDB Atlas and Cloudinary
    – through `pydantic_settings` and you have crafted simple, yet flexible models
    that can easily accommodate more requirements, be expanded or include more functionality.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过`pydantic_settings`管理了密钥——用于连接到MongoDB Atlas和Cloudinary——并精心设计了简单而灵活的模型，这些模型可以轻松地适应更多需求，进行扩展或增加更多功能。
- en: The service is now ready to be used in the frontend – ultimately, giving life
    to a full-stack web application.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 服务现在已准备好在前端使用——最终，赋予全栈Web应用生命。
- en: In the next chapter, you will add a simple user model to this same API and build
    a React frontend that will consume the FastAPI backend.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，您将向这个API添加一个简单的用户模型，并构建一个React前端，该前端将消费FastAPI后端。
