- en: Paint Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 涂鸦应用
- en: We used the Canvas widget to define a custom widget in [Chapter 5](73aef6b5-11e2-4cb9-bb4a-5c96bf81dfcc.xhtml),
    *Building an Audio Player*. The Canvas widget is truly one of Tkinter's highlights.
    It is an incredibly powerful and flexible widget. Let's, therefore, devote most
    of this chapter to looking at the Canvas widget in detail.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第5章](73aef6b5-11e2-4cb9-bb4a-5c96bf81dfcc.xhtml)，“构建音频播放器”中使用了Canvas小部件来定义一个自定义小部件。Canvas小部件确实是Tkinter的亮点之一。它是一个非常强大且灵活的小部件。因此，让我们将本章的大部分内容用于详细探讨Canvas小部件。
- en: We will now develop a paint application. The application will let the user draw freehand
    lines, straight lines, circles, rectangles, arcs, and other polygons. It will also
    let the user define new complex shapes.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将开发一个绘图应用程序。该应用程序将允许用户绘制手绘线条、直线、圆形、矩形、弧线和其他多边形。它还将允许用户定义新的复杂形状。
- en: In addition to exploring the Canvas widget, we will also develop a tiny GUI framework
    on top of the Tkinter interface. As you will see, frameworks are a great way to
    maximize code reuse. This makes them a powerful tool for **Rapid ****Application
    Development (RAD)**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了探索 Canvas 小部件，我们还将基于 Tkinter 接口开发一个微型的 GUI 框架。正如您将看到的，框架是最大化代码重用的一种很好的方式。这使得它们成为快速应用开发（RAD）的强大工具。**快速应用开发（RAD）**。
- en: 'Some of the key learning objectives for this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的一些关键学习目标如下：
- en: Master the Canvas widget API
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握 Canvas 小部件 API
- en: Learn to build and use custom GUI frameworks for maximum code reuse and rapid
    application development
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习构建和使用自定义GUI框架以实现最大程度地代码复用和快速应用开发
- en: Learn to use the `colorchooser` module of Tkinter
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 Tkinter 的 `colorchooser` 模块
- en: Learn to use the ttk ComboBox widget
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用 ttk ComboBox 小部件
- en: Get to know available widget methods
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解可用的小部件方法
- en: Reinforce things that we have learned in previous projects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 巩固我们在先前项目中学习到的知识
- en: Overview of the application
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用概述
- en: 'In its final form, our paint application would look as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最终形态下，我们的油漆应用程序将如下所示：
- en: '![](img/caaa69fc-faea-49ba-ab31-c4950c8a1e36.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/caaa69fc-faea-49ba-ab31-c4950c8a1e36.png)'
- en: There are no external library requirements for this chapter, so let's dive into
    the code.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有外部库的要求，因此让我们直接进入代码部分。
- en: Creating a tiny framework
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个微型框架
- en: So why do we need another framework on top of Tkinter? If we need to build just a
    single program, we need not build a framework. However, if we find ourselves writing
    the same boilerplate code over and over again, a framework is what we need. That
    is, a framework is a tool that lets us easily generate generic and often-used patterns
    with ease.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么我们还需要在Tkinter之上再添加一个框架呢？如果我们只需要构建一个单独的程序，我们其实不需要构建一个框架。然而，如果我们发现自己反复地编写相同的样板代码，那么我们就需要框架。也就是说，框架是一个工具，它让我们能够轻松地生成通用的和经常使用的模式。
- en: Consider, for example, menus used in programs. A menu is such a common element
    in most programs, yet we need to handcraft each menu item every time we sit down to
    write a program. What if we could further abstract to simplify menu generation?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一下程序中使用的菜单。菜单在大多数程序中都是一个常见的元素，然而每次我们坐下来编写程序时，都需要手动制作每个菜单项。如果我们能进一步抽象以简化菜单生成会怎样呢？
- en: This is where frameworks come in handy.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是框架派上用场的地方。
- en: Say you have a program that has 10 different top-level menus. Say each of the
    top-level menus has five menu items. We will have to then write 50 lines of code
    simply to display these 50 menu items. You have to link each of them manually
    to other commands besides having to set tons of options for each of them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个程序，它有10个不同的顶级菜单。假设每个顶级菜单有五个菜单项。那么我们不得不写上50行代码仅仅是为了显示这50个菜单项。你不仅要手动将它们链接到其他命令，还要为每个菜单项设置大量的选项。
- en: If we keep doing this for all our widgets, our GUI programming becomes an exercise in
    typing. Every extra line of code that you write adds to the program complexity, making
    it more difficult for someone else to read, maintain, modify, and/or debug the
    code.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对所有的小部件都这样做，我们的GUI编程就变成了打字练习。你写的每一行额外代码都会增加程序的复杂性，使得其他人阅读、维护、修改和/或调试代码变得更加困难。
- en: This is where using a custom framework comes to our aid. Let's develop a tiny framework
    that makes menu generation easy for us.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用自定义框架能帮到我们的地方。让我们开发一个微型的框架，使菜单生成对我们来说变得简单易行。
- en: 'We create a file, `framework.py`, and create a new class, `Framework`, to the
    file. Every class that uses this framework must inherit from this class and should
    pass the root window as an argument to this class by calling the super method
    as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个文件，`framework.py`，并在该文件中创建一个新的类，`Framework`。每个使用此框架的类都必须继承这个类，并且应该通过调用super方法将根窗口作为参数传递给这个类，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This will make all methods defined in the `Framework` class available to the inheriting
    class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使在`Framework`类中定义的所有方法对继承类可用。
- en: We will now define a method, `build_menu`, which takes a tuple in an expected format
    as input and automatically creates the menu for us. Let's define an arbitrary rule
    that each group of menu items must be represented by a single entry in a tuple.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将定义一个方法，`build_menu`，它接受一个预期格式的元组作为输入，并自动为我们创建菜单。让我们定义一个任意规则，即菜单项的每一组必须由元组中的一个单独条目来表示。
- en: 'Furthermore, we come up with a rule that each item in the tuple must be presented
    in the following format:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们制定了一条规则，即元组中的每个项目都必须按照以下格式呈现：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`MenuSeparator` is denoted by a string `''sep''`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`MenuSeparator` 用字符串 `''sep''` 表示。'
- en: An alternative representation of menu definition could be specifying it as a
    tuple instead of a string definition, which is like asking the user to already
    split the definition rather than us having to extract the menu definition from
    a string.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单定义的另一种表示方法可以是将其指定为一个元组，而不是字符串定义，这就像是要求用户预先分割定义，而不是我们不得不从字符串中提取菜单定义。
- en: 'For instance, passing this tuple as an argument to the `build_menu` method
    should generate three menus as shown in the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将这个元组作为参数传递给`build_menu`方法应该会生成如下代码所示的三种菜单：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Take a look at the following screenshot:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下截图：
- en: '![](img/178dbd61-7fd6-4922-8257-8deab81bf4b2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/178dbd61-7fd6-4922-8257-8deab81bf4b2.png)'
- en: The first item of the string (before dash (`-`)) represents the top-level menu button.
    Each subsequent part of the string separated by a forward slash (`/`)  represents
    one menu item, its accelerator key, and the attached command callback.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串的第一个项目（破折号`-`之前的部分）代表顶级菜单按钮。字符串中每个由正斜杠(`/`)分隔的后续部分代表一个菜单项、其快捷键以及附加的命令回调函数。
- en: The position of the ampersand symbol (`&`) represents the position of the shortcut
    key to be underlined. If we encounter the string `sep`, we add a menu separator.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 符号的位置代表需要加下划线的快捷键位置。如果我们遇到字符串 `sep`，我们添加一个菜单分隔符。'
- en: 'Now that we have defined the rules, the code for `build_menu` is as follows: (see
    the `framework.py` code):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了规则，`build_menu` 函数的代码如下：（参见 `framework.py` 代码）：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The description of the code is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的描述如下：
- en: The method, `build_menu`, operates on a tuple by the name `menu_definition`, which
    must specify all desired menus and menu items in the exact format, as previously
    discussed.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该`build_menu`方法通过名为`menu_definition`的元组进行操作，必须按照之前讨论的精确格式指定所有所需的菜单和菜单项。
- en: It iterates through each item in the tuple, splitting the item based on the dash
    (`–`) delimiter, building the top-menu button for each item left to the dash (`-`
    ) delimiter.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它遍历元组中的每个项目，根据破折号（`–`）分隔符拆分项目，为破折号（`-`）分隔符左侧的每个项目构建顶部菜单按钮。
- en: It then splits the second part of the string based on the comma (`,`) delimiter.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后根据逗号（`,`）分隔符将字符串的第二部分进行分割。
- en: It then iterates through this second part, creating menu items for each of the
    parts, adding the accelerator key, command callback, and underline key using another
    method, `_add_menu_command`.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后它遍历这一部分，为每个部分创建菜单项，使用另一个方法 `_add_menu_command` 添加加速键、命令回调和下划线键。
- en: The `_add_menu_command` method iterates through the string and adds a separator
    if it finds the string `sep`. If not, it next searches for an ampersand (`&`)
    in the string. If it finds one, it calculates its index position and assigns it
    to the underline variable. It then replaces the ampersand value with an empty string,
    because we do not want to display the ampersand in our menu item.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_add_menu_command` 方法遍历字符串，如果找到字符串 `sep`，则添加一个分隔符。如果没有找到，它将在字符串中搜索下一个和号（`&`）。如果找到了一个，它将计算其索引位置并将其分配给下划线变量。然后，它将和号值替换为空字符串，因为我们不希望在菜单项中显示和号。'
- en: If an ampersand is not found in a string, the code assigns `None` to the underline
    variable.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果字符串中未找到与号（&），则代码将`None`赋值给下划线变量。
- en: Finally, the code adds a command callback, accelerator key, and underline value
    to the menu item. Note that our framework adds only the accelerator key label.
    It is the developer's responsibility to bind events to the bound keys.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，代码为菜单项添加了一个命令回调、快捷键和下划线值。请注意，我们的框架仅添加了快捷键标签。将事件绑定到键上是由开发者负责的。
- en: Our demonstration of making GUI frameworks ends here. We can now use this method
    to define literally hundreds of menus simply by adding one new line for each group
    of menus.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的GUI框架制作演示到此结束。现在我们可以通过为每组菜单添加一行新内容，简单地定义 literally hundreds of 菜单。
- en: However, this is a rather rudimentary framework. The rules for defining items
    are completely arbitrary. The choice of delimiters means that we can no longer
    use the dash (`-`), slash (`/`), and ampersand (`&`) characters that we have used
    as delimiters in any menus that we define using this framework.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个相当基础的框架。定义条目的规则是完全任意的。分隔符的选择意味着我们不能再使用作为我们使用此框架定义的任何菜单的分隔符的破折号（`-`）、斜杠（`/`）和和号（`&`）字符。
- en: Our framework does not lay down rules for any other widgets. In fact, this definition
    is not even sufficient to generate other types of menu such as cascading menus,
    check button menus, or radio button menus. We will, however, not extend the framework further,
    as it is sufficient to have developed the concept behind framework design and usage
    and that is all we need to use in our paint application.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的框架并未为任何其他小部件设定规则。实际上，这个定义甚至不足以生成其他类型的菜单，例如级联菜单、复选框菜单或单选按钮菜单。然而，我们不会进一步扩展框架，因为已经开发出了框架设计和使用的概念，而这正是我们在绘图应用程序中需要使用的所有内容。
- en: We have also included a small test in the `framework.py` file. If you execute
    the file as a standalone program, it should pop up a window and define some menus for
    testing.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`framework.py`文件中包含了一个小测试。如果你将该文件作为一个独立程序执行，它应该会弹出一个窗口并定义一些用于测试的菜单。
- en: Fully-fledged frameworks use more structured markup languages to represent rules.
    XML is one of the most popular choices for writing GUI frameworks. You can find
    an example of a full-blown XML-based Tkinter RAD (tkRAD) framework here: [https://github.com/muxuezi/tkRAD](https://github.com/muxuezi/tkRAD).
    A simple menu implementation using the preceding framework can be seen here:[ https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py](https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的框架使用更结构化的标记语言来表示规则。XML 是编写 GUI 框架中最受欢迎的选择之一。您可以在以下链接中找到一个基于 XML 的完整 Tkinter
    RAD (tkRAD) 框架的示例：[https://github.com/muxuezi/tkRAD](https://github.com/muxuezi/tkRAD)。使用此框架的一个简单菜单实现可以在此处查看：[https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py](https://github.com/muxuezi/tkRAD/blob/master/xml/rad_xml_menu.py).
- en: Using a framework for smaller programs may be overkill, but they are invaluable assets
    for large programs. Hopefully, you should now be able to appreciate the benefits
    of using frameworks for larger programs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 使用框架来编写小型程序可能有些过度，但对于大型程序来说，它们是无价之宝。希望你现在能够欣赏到使用框架来编写大型程序的益处。
- en: Now that we have the code for `build_menu`, we can extend it to add as many
    menu items as required without having to write repetitive and similar code for
    each of them.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`build_menu`的代码，我们可以扩展它以添加所需的任意数量的菜单项，而无需为每个菜单项编写重复且类似的代码。
- en: This ends our first iteration. We will use this tiny framework to define the
    menu for our drawing program in the next step.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们第一次迭代的结束。在下一步中，我们将使用这个小巧的框架来定义我们的绘图程序的菜单。
- en: Setting up a broad GUI structure
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置一个广泛的GUI结构
- en: 'Let''s now set up the broad GUI elements of our program. We will create a `PaintApplication`
    class in `6.01.py`. Since we want to draw the menu using our framework, we import
    the framework into our file and inherit from the `Framework` class as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在设置程序的大致GUI元素。我们将在`6.01.py`中创建一个`PaintApplication`类。由于我们想使用我们的框架来绘制菜单，我们将框架导入到我们的文件中，并如下继承自`Framework`类：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `__init__` method calls another method, `create_gui`, which is responsible
    for creating the basic GUI structure for our program.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__` 方法调用了另一个方法，`create_gui`，该方法负责为我们程序创建基本的 GUI 结构。'
- en: 'The `create_gui` method simply delegates the task to five separate methods,
    each being responsible for creating one section of the GUI as follows (see code
    `6.01.py`):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_gui` 方法简单地将任务委托给五个独立的方法，每个方法负责创建 GUI 的一个部分，具体如下（参见代码 `6.01.py`）：'
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These five methods together build a structure as shown in the following screenshot
    (see code `6.01.py`):'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这五种方法共同构建了一个结构，如下面的截图所示（参见代码 `6.01.py`）：
- en: '![](img/453f9f3d-5ab0-4f15-ab85-cb14575c2383.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/453f9f3d-5ab0-4f15-ab85-cb14575c2383.png)'
- en: 'We have written similar code in all previous chapters, hence we will not reproduce the
    code for these five methods here. Note, however, a few things about the code in `6.01.py`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的所有章节中都编写了类似的代码，因此在这里我们将不会重复这些五种方法的代码。然而，请注意关于`6.01.py`中代码的以下几点：
- en: Since we want to use the framework, we inherit from the `Framework` class and
    call its `__init__` method using `` `super()` ``
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们想使用该框架，我们继承自`Framework`类并使用`super()`调用其`__init__`方法
- en: The `create_menu` method specifies the tuple for our menu definition and calls
    the `build_menu` method defined earlier in our framework
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_menu` 方法指定了我们的菜单定义的元组，并调用我们在框架中之前定义的 `build_menu` 方法'
- en: 'We define a lot of empty methods that will be implemented later. Each empty
    method is added as a command callback to individual menu items. The empty methods
    defined here are:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了许多将在以后实现的方法。每个空方法都被添加为单个菜单项的命令回调。这里定义的空方法有：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This gives us a broad GUI structure for our program. Next, we will look at interacting with
    the drawing canvas.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们程序提供了一个广泛的GUI结构。接下来，我们将探讨如何与绘图画布进行交互。
- en: Dealing with mouse events
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理鼠标事件
- en: When we draw in a paint program, we use a mouse as the primary input device.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在绘画程序中绘制时，我们使用鼠标作为主要输入设备。
- en: 'There are primarily two kinds of mouse event that cause changes on the drawing canvas
    and are therefore of interest:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 主要有两种鼠标事件会在绘图画布上引起变化，因此值得关注：
- en: Click and release
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击并释放
- en: Click, drag, and release
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击、拖动并释放
- en: There is also a third event in which we have limited interest—the mouse movements
    with no buttons clicked. Our interest is limited there since an unclicked motion
    normally does not cause any changes on the canvas.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一种第三种事件，我们对它的兴趣有限——那就是没有点击按钮的鼠标移动。由于未点击的移动通常不会在画布上引起任何变化，所以我们对此的兴趣有限。
- en: We ignore right-click and wheel-scroll as we will not be using them in our program.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忽略右键点击和滚轮滚动，因为我们不会在我们的程序中使用它们。
- en: In both the preceding cases, we need to know where the mouse was first clicked
    and where it was released. For click and release, this could be the same location.
    For click, drag, and release this will normally be different locations.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种先前情况下，我们需要知道鼠标最初点击的位置以及释放的位置。对于点击和释放，这两个位置可能是相同的。对于点击、拖动和释放，通常这两个位置是不同的。
- en: 'Accordingly, we define four attributes to keep track of the coordinates for
    these two locations (see code `6.02.py`):'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了四个属性来跟踪这两个位置的坐标（参见代码`6.02.py`）：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Our immediate goal then is to bind our mouse events in such a way that any click
    or drag gives us the value of these four start and end coordinates.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的目标是将鼠标事件绑定，以便任何点击或拖动都能给我们提供这四个起始和结束坐标的值。
- en: The coordinates of the Canvas widget begin at the top-left corner ((`0, 0`)
    is the top-corner).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件的坐标从左上角开始（`0, 0`是顶部角落）。
- en: 'The Canvas widget uses two coordinate systems:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件使用两个坐标系：
- en: The **window coordinate system**, which is always `0, 0` for the leftmost corner,
    no matter where you scroll down or up the canvas
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**窗口坐标系**，其始终以左上角为`0, 0`，无论你在画布上下滚动多少'
- en: The **canvas coordinate system**, which specifies where the items are actually
    drawn on the canvas
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布坐标系**，它指定了项目实际上在画布上的绘制位置'
- en: 'We will mostly be interested in the canvas coordinate system, but mouse events
    emit data on the window coordinate system. To convert from the window coordinate
    system to the canvas coordinate system we can use the following methods:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关注画布坐标系，但鼠标事件会发出窗口坐标系统上的数据。要将窗口坐标系转换为画布坐标系，我们可以使用以下方法：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s now modify our `__init__` method to also call a method, `bind_mouse`.
    We define the `bind_mouse` method as follows (see code `6.02.py`):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在修改我们的`__init__`方法，使其也调用一个方法，`bind_mouse`。我们定义`bind_mouse`方法如下（见代码`6.02.py`）：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We then define the first three methods that were bound just now. We ignore
    the unpressed motion for now by making an empty method. Remember that we are interested in
    getting the start and end coordinates, which are acquired as follows (see code `6.02.py`):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后定义了刚才所提到的前三种方法。目前我们通过创建一个空方法来忽略未按下的运动。请记住，我们感兴趣的是获取起始和结束坐标，这些坐标的获取方式如下（参见代码`6.02.py`）：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have temporarily added two `print` statements to show these four values on
    the console (see code `6.02.py`).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暂时添加了两个`print`语句来在控制台显示这四个值（参见代码`6.02.py`）。
- en: Now that we have the location of the start and end mouse events, we can act
    upon those events to do all kinds of activities on the canvas.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了鼠标开始和结束事件的坐标位置，我们可以对这些事件进行操作，在画布上执行各种活动。
- en: Adding toolbar buttons
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加工具栏按钮
- en: 'Next, we need to add 16 buttons to the left toolbar. Furthermore, depending
    on which button is clicked, different options would show up in the top bar as
    shown here:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在左侧工具栏中添加16个按钮。此外，根据点击的是哪个按钮，顶部栏将显示不同的选项，如下所示：
- en: '![](img/09a714e8-a7fb-4040-9a3a-2eebacdd4b95.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/09a714e8-a7fb-4040-9a3a-2eebacdd4b95.png)'
- en: We do not want our code structure to be too bloated by conditional logic to
    switch among these 16 functions. Therefore, we will call these methods dynamically.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望我们的代码结构因为需要在16个函数之间切换而变得过于臃肿，因此我们将动态调用这些方法。
- en: 'We first begin by defining a tuple of all 16 function names (see code `6.01.py`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个包含所有16个函数名称的元组（参见代码`6.01.py`）：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Doing so ensures that we do not have to call each method explicitly from our
    code. We can instead use the index of the tuple to retrieve the method name and
    call it dynamically using the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可以确保我们不需要从代码中显式地调用每个方法。我们可以使用元组的索引来检索方法名称，并通过以下方式动态调用它：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This makes sense here because we would eventually add more features to our drawing
    program by simply extending the `toolbar_functions` tuple.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这在这里是有道理的，因为我们最终将通过简单地扩展`toolbar_functions`元组来为我们的绘图程序添加更多功能。
- en: 'We further define an attribute, `selected_tool_bar_function`, which will keep track
    of which button was last clicked. We initialize it to the first button ( `draw_line`
    ) as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进一步定义一个属性，`selected_tool_bar_function`，它将跟踪哪个按钮是最后被点击的。我们将其初始化为第一个按钮（`draw_line`）如下：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we create a folder named `icons` and add icons for all these 16 toolbar buttons.
    The icons have been named the same as the corresponding function name.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个名为 `icons` 的文件夹，并为所有这16个工具栏按钮添加图标。这些图标的命名与对应的功能名称相同。
- en: Maintaining this consistency allows us to use the same tuple to loop over and
    build our toolbar buttons. This style of programming is what you could call programming
    using **conventions over configuration**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 保持这种一致性使我们能够使用相同的元组来遍历并构建我们的工具栏按钮。这种编程风格可以称之为**约定优于配置**的编程。
- en: 'We next create the method that makes the actual buttons (see code `6.03.py`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来创建生成实际按钮的方法（参见代码`6.03.py`）：
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The preceding code creates all the buttons and adds command callbacks to the
    buttons as highlighted. We accordingly define the command callback as follows
    (see code `6.03.py`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了所有按钮并将命令回调添加到按钮中，如所示。因此，我们相应地定义命令回调如下（参见代码`6.03.py`）：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding method sets the value of `selected_tool_bar_function`. Next,
    it calls two methods that are defined as follows (see code `6.03.py`):'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法设置了`selected_tool_bar_function`的值。接下来，它调用了以下定义的两个方法（参见代码`6.03.py`）：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We need to remove any existing options currently displaying in the top bar before we
    can display options for the newly selected button. The `winfo_children` method used
    just now returns a list of all widgets that are children of this widget.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够显示新选按钮的选项之前，需要移除顶部栏中当前显示的所有选项。刚才使用的 `winfo_children` 方法返回的是这个部件所有子部件的列表。
- en: 'Now that we have removed all items from the top bar, we define the selected
    tool icon on the top bar:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经从顶部栏中移除了所有项目，我们定义了顶部栏上选定的工具图标：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Currently, this method only calls one other method to display the selected tool
    icon in the top bar. We will, however, use this method as the central place for
    adding options to the top bar later in the chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此方法仅调用另一个方法来在顶部栏中显示所选工具图标。然而，我们将在本章的后续部分将此方法用作添加选项到顶部栏的中心位置。
- en: 'We do not discuss the `show_selected_tool_icon_in_top_bar` method here as it simply
    adds a label with an icon to the top bar (see code `6.03.py`):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不讨论`show_selected_tool_icon_in_top_bar`方法，因为它只是将带有图标的标签添加到顶部栏（参见代码`6.03.py`）：
- en: '![](img/889c4325-4549-4330-b166-e8127b7fe0e7.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/889c4325-4549-4330-b166-e8127b7fe0e7.png)'
- en: Now, if you go and run the code `6.03.py`, it should display all 16 buttons
    in the left toolbar. Furthermore, clicking on any one of the buttons should display
    the selected button in the top bar, as shown in the preceding screenshot.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行代码`6.03.py`，它应该会在左侧工具栏中显示所有16个按钮。此外，点击任何一个按钮都应该在顶部栏中显示所选的按钮，如图中所示的前一个截图。
- en: The `winfo_children()` method used earlier is an example of widget methods that
    are available to be called on all widgets. Several useful widget methods are defined
    in Tkinter.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 之前使用的 `winfo_children()` 方法是所有小部件都可以调用的部件方法的一个例子。Tkinter 中定义了几个有用的部件方法。
- en: 'In addition to the widget methods that are available on all widgets, some methods
    are only available on the top-level window. You can get a list of all such available
    methods and their descriptions by typing the following in your Python 3 console:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有小部件都有的小部件方法外，还有一些方法仅在顶层窗口中可用。您可以通过在您的 Python 3 控制台中输入以下内容来获取所有这些可用方法及其描述的列表：
- en: '`**>>> import tkinter**`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**>>> 导入 tkinter**`'
- en: '`**>>> help (tkinter.Misc)**`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**>>> help (tkinter.Misc)**`'
- en: '`**>>> help (tkinter.Wm)**`'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**>>> help(tkinter.Wm)**`'
- en: These are available online at [http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm) and
    at [http://effbot.org/tkinterbook/wm.htm](http://effbot.org/tkinterbook/wm.htm).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源可在[http://effbot.org/tkinterbook/widget.htm](http://effbot.org/tkinterbook/widget.htm)和[http://effbot.org/tkinterbook/wm.htm](http://effbot.org/tkinterbook/wm.htm)在线获取。
- en: You are encouraged to take a look at all these available methods.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您查看所有这些可用的方法。
- en: Next, we will extend our program to actually draw items on the canvas.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将扩展我们的程序，以便实际上在画布上绘制项目。
- en: Drawing items on the canvas
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布上绘制项目
- en: Objects added to the canvas are called **items**. New items are added to the
    canvas using different create methods such as `create_line`, `create_arc`, `create_oval`, `create_rectangle`,
    `create_polygon`, `create_text`, `create_bitmap`, and `create_image`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到画布上的对象被称为**项目**。使用不同的创建方法如`create_line`、`create_arc`、`create_oval`、`create_rectangle`、`create_polygon`、`create_text`、`create_bitmap`和`create_image`可以将新项目添加到画布上。
- en: Items added to the canvas are placed in a stack. New items are added on top
    of items already on the canvas. Every time you add an item using one of the various create
    methods, it returns a unique item handle or an item ID that is a unique integer.
    This item handle can be used to refer to and manipulate the added item.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到画布上的项目将被放置在堆栈中。新项目被添加到画布上已有的项目之上。每次您使用各种创建方法之一添加一个项目时，它都会返回一个唯一的项句柄或一个唯一的整数项ID。这个项句柄可以用来引用和操作添加的项目。
- en: 'In addition to an item handle, items can have the following item specifiers:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目处理程序外，项目还可以具有以下项目指定符：
- en: '`tags` are specifiers that we can add to one or more items'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tags` 是我们可以添加到一项或多项内容的指定符'
- en: '`ALL` (or the string all) matches all items on the canvas'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALL`（或字符串all）匹配画布上的所有项目'
- en: CURRENT (or `current`) matches the item under the mouse pointer if any
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前（或 `current`）匹配鼠标指针下的项目（如果有）
- en: We can use any of the preceding item specifiers for methods that act on canvas
    items.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面提到的任何项目指定符来指定作用于画布项的方法。
- en: 'To add a tag to an item, you specify the tag (which is a string) as its configurable option,
    either at the time of creating the object or later using the `itemconfig` method or
    the `addtag_withtag` method, as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要给一个项目添加标签，您需要指定标签（它是一个字符串）作为其配置选项，无论是在创建对象时还是在之后使用`itemconfig`方法或`addtag_withtag`方法，如下所示：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You can add multiple tags to an item at once by passing in the tags as a tuple
    of strings, as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过传入字符串元组作为标签，一次性给一个项目添加多个标签，如下所示：
- en: '[PRE19]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To get all tags associated with an item handle, use `gettags` as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取与项目处理程序关联的所有标签，请按以下方式使用`gettags`：
- en: '[PRE20]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This returns a tuple of all tags associated with that item handle.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回与该项目句柄相关联的所有标签的元组。
- en: 'To get the item handles for all items that have a given tag, use `find_withtag`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取所有具有给定标签的项的句柄，请使用 `find_withtag`：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This returns a tuple of item handles for all items with a tag of spam.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有带有垃圾邮件标签的项目句柄的元组。
- en: 'Given this information, let''s code the functionality for the first six buttons,
    as shown in the following screenshot:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这些信息，让我们编写前六个按钮的功能代码，如图所示：
- en: '![](img/ee68d097-34fc-4234-9390-1c6051bc4948.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ee68d097-34fc-4234-9390-1c6051bc4948.png)'
- en: 'More specifically, we will code the functionality for the following function
    names that we have already defined earlier in the tuple `tool_bar_functions`:
     `"draw_line"`, `"draw_oval"`, `"draw_rectangle"`, `"draw_arc"`, and `"draw_triangle",
    "draw_star"`'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将为以下在之前定义的元组 `tool_bar_functions` 中已经定义的功能名称编写代码：`"draw_line"`，`"draw_oval"`，`"draw_rectangle"`，`"draw_arc"`，以及
    `"draw_triangle"` 和 `"draw_star"`。
- en: 'Here''s the code for `draw_ line` (see code `6.04.py`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`draw_line`函数的代码（参见代码`6.04.py`）：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This uses the `create_line` method and draws a line from the start *x*, *y*
    coordinates to the end *x*, *y* coordinates. We have defined four new attributes
    for handling four different properties of the line:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了`create_line`方法，并从起始的*x*, *y*坐标绘制一条线到结束的*x*, *y*坐标。我们定义了四个新的属性来处理线的四个不同属性：
- en: '`fill`: Line color. Default is `black`, initialized as red in our program.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fill`: 线条颜色。默认为 `black`，在我们的程序中初始化为红色。'
- en: '`width`: Default is `1`, initialized as `2` in our program.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`: 默认值为 `1`，在我们的程序中初始化为 `2`。'
- en: '`arrow`: Default is `None`. The available choices are: `None`, `First`, `Last`,
    `Both`.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`箭头`: 默认为 `None`。可用的选项有：`None`、`First`、`Last`、`Both`。'
- en: '`dash`: A `dash` pattern, which is a list of segment lengths. Only the odd segments
    are drawn.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`破折号`: 一种`破折号`模式，表示一系列线段长度。只有奇数线段会被绘制。'
- en: We will later provide options for changing these four values from the top bar
    and hence these have been added as class attributes.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后提供从顶部栏更改这四个值的选项，因此这些值已被添加为类属性。
- en: Also note that since `create_line` (and all create methods) return the item
    handle for the created item, we store it in an attribute named `current_item`.
    This gives us access to the last created item, which we will soon put to good
    use.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，由于 `create_line`（以及所有创建方法）返回创建项的项句柄，我们将其存储在一个名为 `current_item` 的属性中。这使得我们可以访问最后创建的项，我们很快就会将其用于良好。
- en: 'Next, here''s the code for `draw_ oval` (see code `6.04.py`):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，这是`draw_oval`函数的代码（参见代码`6.04.py`）：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is identical to the code for `draw_line`, except that we added a new attribute named
    outline that takes care of the outline color.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`draw_line`的代码相同，除了我们添加了一个名为outline的新属性，用于处理轮廓颜色。
- en: We will not discuss the code for `create_rectangle` and `create_arc`, which
    are almost identical to the code of `draw_oval` discussed here (see code `6.04.py`).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不会讨论`create_rectangle`和`create_arc`的代码，这些代码几乎与这里讨论的`draw_oval`代码相同（参见代码`6.04.py`）。
- en: 'Let''s now discuss the `create_polygon` method. This method can be used to
    create all sorts of interesting shapes. Let''s begin with the simple case of drawing
    an equilateral triangle (see code `6.04.py`):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论 `create_polygon` 方法。这个方法可以用来创建各种有趣的形状。让我们从一个简单的例子开始，绘制一个等边三角形（参见代码 `6.04.py`）：
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The preceding code first converts the changes in the *x*, *y* coordinates from
    the Cartesian coordinate system to the polar coordinates represented by an angle
    and a radius. It then calculates the *x*, *y* coordinates for all three edges
    of the triangle using the following formula:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先将 *x*、*y* 坐标系中的变化从笛卡尔坐标系转换为由角度和半径表示的极坐标系。然后，使用以下公式计算三角形所有三边的 *x*、*y* 坐标：
- en: '[PRE25]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Once we have the x, y coordinates for all three vertices of the triangle, we
    call the `create_polygon` method to draw the triangle.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们得到了三角形三个顶点的 x, y 坐标，我们就调用 `create_polygon` 方法来绘制三角形。
- en: 'Let''s now use the `create_polygon` method to make stars. A star (and many
    other polygons) can be thought of as a collection of points or spokes on two concentric
    circles, as shown in the following figure:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用 `create_polygon` 方法来绘制星星。星星（以及许多其他多边形）可以想象成两个同心圆上的点或辐条集合，如下面的图所示：
- en: '![](img/b7a716e9-86ca-45b5-9edc-3230898586b4.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7a716e9-86ca-45b5-9edc-3230898586b4.png)'
- en: 'The star shown in the preceding figure has five spokes. We will later allow the
    user to change the number of spokes. Therefore, let''s start by defining a class attribute
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前图中显示的星星有五个辐条。我们稍后会让用户能够更改辐条的数量。因此，让我们首先定义一个类属性如下：
- en: '[PRE26]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The shape of the star is also determined by the ratio of the radius of the
    inner circle to the radius of the outer circle, as in the preceding figure. This
    is called the **spoke ratio**. This ratio is 2 for a standard star. Changing this
    ratio can also produce all sorts of interesting star shapes. However, we will
    keep it at `2` for our example. Given these rules, the code for `draw_star` is
    defined as follows (see code `6.04.py`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 星星的形状也由内圆半径与外圆半径的比值决定，正如前图所示。这个比值被称为**辐条比**。对于标准星，这个比值是2。改变这个比值也可以产生各种有趣的星星形状。然而，在我们的例子中，我们将保持这个比值在`2`。根据这些规则，`draw_star`函数的代码定义如下（参见代码`6.04.py`）：
- en: '[PRE27]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code is heavily commented for you to understand. This is very
    similar to the code we used to draw triangles.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码注释丰富，以便您理解。这与我们用来绘制三角形的代码非常相似。
- en: Now, instead of having points on one circle (as for triangles), we have points
    on two circles. We again use the same technique to first convert the *x*, *y*
    coordinates from mouse events to polar coordinates. Once we have the polar coordinates,
    it is easy to move the points in the circle.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再像三角形那样在一个圆上有点，而是在两个圆上有点。我们再次使用同样的技术，首先将鼠标事件中的 *x*，*y* 坐标转换为极坐标。一旦我们得到极坐标，移动圆上的点就变得容易了。
- en: We then move the points by a given angle and change back to Cartesian coordinates.
    We keep appending all the points to an empty list called **points**. Once we have
    all the points, the last line calls the `create_polygon` method of the canvas
    object to draw the star.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将点按照给定的角度移动，并转换回笛卡尔坐标系。我们持续将所有点追加到一个名为 **points** 的空列表中。一旦我们有了所有点，最后一行调用画布对象的
    `create_polygon` 方法来绘制星星。
- en: Now we have all the methods to create these six shapes. But they need to be called
    from somewhere for the drawing to happen. And we have already decided that they
    would be called dynamically.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了创建这六个形状的所有方法。但是，它们需要从某个地方被调用，以便绘图能够发生。而且，我们已经决定它们将会被动态调用。
- en: Accordingly, we define a method, `execute_selected_method`, which takes the
    string for the selected toolbar function, converts the string into a callable
    function, and executes it dynamically.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个方法，`execute_selected_method`，它接受所选工具栏功能的字符串，将字符串转换为可调用的函数，并动态执行它。
- en: 'The code is as follows (see code `6.04.py`):'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 代码如下（见代码 `6.04.py`）：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This method, `getattr`, provides a reference to a method from the given string
    at runtime. A second argument provides a fallback mechanism whereby if the method object
    from the first argument is not found, a reference to the second method is provided.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法 `getattr` 在运行时提供了一个对给定字符串中方法的引用。第二个参数提供了一个回退机制，如果第一个参数中的方法对象未找到，则提供第二个方法的引用。
- en: 'This helps us gracefully handle situations where a dynamically created method
    does not exist. We simply define the fallback method as an empty method to handle
    those cases (see code `6.04.py`):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们优雅地处理动态创建的方法不存在的情况。我们只需将这些情况的处理方法定义为空方法即可（参见代码`6.04.py`）：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So now we have a method to execute the selected method dynamically. Where do we
    plug in this method?
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在有一个方法来动态执行所选的方法。我们把这个方法插在哪里呢？
- en: Since the drawing must begin when the mouse is clicked, we call the `execute_selected_method` method
    once from the `on_mouse_button_pressed` method.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于绘图必须在鼠标点击时开始，我们从`on_mouse_button_pressed`方法中调用一次`execute_selected_method`方法。
- en: The drawing must continue while the mouse is dragged in a clicked position.
    So we call this method again from the `on_mouse_button_pressed_motion` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在鼠标被拖动到点击位置时，绘图必须继续。因此，我们从`on_mouse_button_pressed_motion`方法中再次调用此方法。
- en: 'However, although we want to keep the last drawn object during the mouse motion, we
    want to remove all other items except for the last drawn item. We therefore modify
    `on_mouse_button_pressed_motion` as follows (see code `6.04.py`):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们希望在鼠标移动过程中保留最后绘制的对象，但我们希望移除除最后绘制的对象之外的所有其他项目。因此，我们修改了`on_mouse_button_pressed_motion`函数，如下所示（参见代码`6.04.py`）：
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, if you run `6.04.py`, the top six buttons on the toolbar should function
    as shown in the following screenshot:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行 `6.04.py`，工具栏上最上面的六个按钮应该像以下截图所示那样工作：
- en: '![](img/d5ad7fda-4953-41b4-bd99-c123934d08ed.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d5ad7fda-4953-41b4-bd99-c123934d08ed.png)'
- en: Adding a color palette
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加颜色调色板
- en: We can now draw basic shapes in our paint program. However, we still cannot change
    the colors of these shapes. Before we allow users to change colors, we must provide
    a way for them to select colors.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的绘图程序中绘制基本形状。然而，我们仍然不能改变这些形状的颜色。在我们允许用户更改颜色之前，我们必须提供一个让他们选择颜色的方法。
- en: 'We will, therefore, provide a color chooser, letting the user select two different colors:
    the foreground color and the background color.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将提供一个颜色选择器，让用户选择两种不同的颜色：前景色和背景色。
- en: '![](img/54e3e6b6-85b9-4f36-ac1e-50396b64626c.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/54e3e6b6-85b9-4f36-ac1e-50396b64626c.png)'
- en: While we are at it, let's also add a label showing the *x*, *y* coordinate of
    the mouse over the canvas, as highlighted in the preceding screenshot.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们进行时，也可以添加一个标签来显示鼠标在画布上悬停时的 *x*、*y* 坐标，正如前一个截图中所突出显示的。
- en: Let's begin with the color palette. The two color palettes are nothing but two
    small rectangle items placed on a canvas. To show these two rectangles, we define
    a method, `create_color_palette` and call it from the existing `create_gui` method.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从调色板开始。这两个调色板不过是放置在画布上的两个小矩形项目。为了展示这两个矩形，我们定义了一个方法，`create_color_palette`，并从现有的`create_gui`方法中调用它。
- en: 'The code for `create_color_palette` is as follows (see code `6.05.py`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_color_palette` 函数的代码如下（参见代码 `6.05.py`）：'
- en: '[PRE31]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The method ends by calling a method named `bind_color_palette`, which is defined
    as follows (see code `6.05.py`):'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法以调用名为 `bind_color_palette` 的方法结束，该方法定义如下（见代码 `6.05.py`）：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding code simply binds the mouse click to two not yet defined methods, `set_background_color`,
    and `set_foreground_color`, using the `tag_bind` method of the Canvas widget.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码简单地使用Canvas小部件的`tag_bind`方法将鼠标点击绑定到两个尚未定义的方法，`set_background_color`和`set_foreground_color`。
- en: 'Here''s the signature of the `tag_bind` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`tag_bind`方法的签名：
- en: '[PRE33]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The method adds an event binding to all matching items. Note that the bindings
    apply to the items, not the tag. For example, if you add the existing tag to new
    items after a call to `tag_bind,` the new items will not automatically bind to
    the event.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法为所有匹配项添加事件绑定。请注意，这些绑定应用于项，而不是标签。例如，如果你在调用`tag_bind`之后将现有标签添加到新项中，新项将不会自动绑定到事件。
- en: Next, let's define the method that actually opens a color picker and sets the foreground
    and background colors based on user-selected colors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个实际打开颜色选择器并根据用户选择的颜色设置前景色和背景色的方法。
- en: 'Tkinter comes with a built-in `colorchooser` module that we import into our namespace
    as follows (see code `6.06.py`):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'Tkinter自带一个内置的`colorchooser`模块，我们将其导入到我们的命名空间中，如下所示（参见代码`6.06.py`):'
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To open a color chooser, we need to call its `askcolor` method, as shown here:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要打开颜色选择器，我们需要调用它的`askcolor`方法，如下所示：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Upon clicking OK, the color chooser returns a tuple of the form:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“确定”后，颜色选择器返回一个形式为的元组：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Where the first item of the tuple is another tuple comprising the RGB values
    of the chosen color and the last item of the tuple represents the hexadecimal
    color code of the chosen color, if the Cancel button is clicked, it returns `None`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当元组的第一个元素是包含所选颜色的RGB值的另一个元组，而元组的最后一个元素代表所选颜色的十六进制颜色代码时，如果点击了取消按钮，它将返回`None`。
- en: 'We then use the preceding method to set the foreground and background colors as
    follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用前面的方法来设置前景和背景颜色如下：
- en: '[PRE37]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This concludes coding the color chooser for our paint program. However, note
    that the colors you choose will simply change the value of the foreground and background
    attributes. It will not change the color of items drawn on the canvas. We will
    do that in a separate iteration.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们画图程序中颜色选择器的编码。然而，请注意，您所选择的颜色将仅改变前景和背景属性的值。它不会改变画布上绘制项目的颜色。我们将在单独的迭代中完成这一点。
- en: Finally, let's define the methods that show the current mouse position in a
    label.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们定义显示当前鼠标位置在标签中的方法。
- en: 'We create two new methods (see code `6.05.py`):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两种新的方法（参见代码`6.05.py`）：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And we call the `show_current_coordinates` from our existing `on_mouse_unpressed_motion`
    method as follows (see code `6.05.py`):'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从现有的 `on_mouse_unpressed_motion` 方法中调用 `show_current_coordinates` 如下（参见代码
    `6.05.py`）：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Adding top bar options for draw methods
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加绘图方法顶部栏选项
- en: Each of the 16 toolbar buttons can have its own option. Just like we called
    the functions related to the toolbar buttons dynamically, we will again call methods to
    display options for the top bar dynamically.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工具栏上的16个按钮都可以有自己的选项。就像我们动态调用与工具栏按钮相关的函数一样，我们还将再次调用方法来动态显示顶栏的选项。
- en: So we decide that the method for handling the top bar options would be named
    by appending the string `_options` to the existing method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们决定处理顶部栏选项的方法将通过在现有方法后附加字符串 `_options` 来命名。
- en: Suppose we want to display the options for the `draw_line` method, it would
    be defined in the method called `draw_line_options`. Similarly, we have to define
    methods such as `draw_arc_options`, `draw_star_options`, and others.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要显示`draw_line`方法的选项，它将在名为`draw_line_options`的方法中定义。同样，我们还需要定义诸如`draw_arc_options`、`draw_star_options`等其他方法。
- en: 'We achieve this dynamic call in the `display_options_in_the_top_bar` method
    as follows (see code `6.06.py`):'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '我们在`display_options_in_the_top_bar`方法中实现这种动态调用，具体如下（参见代码`6.06.py`):'
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, with that code in place, every time a toolbar button is clicked the program
    will look for a method named by appending the `_options` string to the current
    method related to the button. If it finds one, it will be executed. If not found,
    the fallback function `function_not_defined` will be called, which is an empty
    method to silently ignore the absence of a method.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了这段代码，每次点击工具栏按钮时，程序都会寻找一个通过在当前按钮相关的方法名称后附加`_options`字符串来命名的方法。如果找到了，它将被执行。如果没有找到，将调用后备函数`function_not_defined`，这是一个空方法，用于静默忽略方法的缺失。
- en: The Canvas widget lets you specify the fill color, outline color, and border
    width for most shapes as their configurable options.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: Canvas小部件允许您指定大多数形状的填充颜色、轮廓颜色和边框宽度作为它们的可配置选项。
- en: In addition to these, the Canvas widget also has several other configurable
    options for many of these basic shapes. For instance, for a line, you can specify
    whether it will have an arrowhead shape at the end or it will be dashed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，Canvas小部件还有许多其他可配置选项，用于这些基本形状。例如，对于一条线，你可以指定它是否在末端有箭头形状，或者是否为虚线。
- en: 'We need to display the following top options for the first six buttons:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在前六个按钮中显示以下顶级选项：
- en: '![](img/6f0f28f9-1107-41cd-9a4b-da0391babbc5.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f0f28f9-1107-41cd-9a4b-da0391babbc5.png)'
- en: 'As can be seen, we need to create Combobox widgets for fill, outline, width,
    arrow, and dash. We first import the `ttk` module into our namespace and then
    create the Combobox widget as shown in the following code (see code `6.06.py`):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如所示，我们需要创建用于填充、轮廓、宽度、箭头和虚线的 Combobox 小部件。我们首先将 `ttk` 模块导入到我们的命名空间中，然后创建如以下代码所示的小部件
    Combobox（参见代码 `6.06.py`）：
- en: '[PRE41]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The ttk Combobox widget binds to another method called `set_fill`, which is defined
    as follows (`6.06.py`):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 'ttk Combobox 小部件绑定到另一个名为 `set_fill` 的方法，该方法定义如下 (`6.06.py`):'
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We define a similar `combobox` for the `width`, `outline`, `arrow`, and `dash`
    properties. We also define a `combobox` to allow the user to change the number
    of spokes in the star.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`width`、`outline`、`arrow`和`dash`属性定义了一个类似的`combobox`。我们还定义了一个`combobox`，允许用户更改星形中的辐条数量。
- en: Since the code for all these methods is pretty similar to the code we have just
    discussed, we do not explore it here (`6.06.py`)*.*
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些方法的代码与我们刚刚讨论的代码非常相似，我们在这里不对其进行探讨 (`6.06.py`)*.*
- en: 'Finally, we add the required comboboxes to each of the six options methods as
    follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所需的组合框添加到六个选项方法中的每一个，具体如下：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: There's similar code for all the other five toolbar buttons (see code `6.06.py`).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他五个工具栏按钮也有类似的代码（参见代码`6.06.py`）。
- en: Now, if you run code `6.06.py`, it should display options for the first six
    buttons.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行代码`6.06.py`，它应该显示前六个按钮的选项。
- en: When you change the options, the change is reflected in all subsequent drawings
    on the canvas.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更改选项时，更改将在画布上的所有后续绘图中得到反映。
- en: However, there is a small bug in our code. What if someone has chosen the fill color
    as the foreground color? And then they change the foreground color from the color
    palette. Although this changes the value of the foreground attribute, it does
    not change the value of the fill attribute. Our program will keep using the old
    foreground value for fill.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的代码中存在一个小错误。如果有人将填充颜色选为了前景颜色怎么办？然后他们从颜色调色板中更改了前景颜色。尽管这改变了前景属性的值，但它并没有改变填充属性的值。我们的程序将继续使用旧的填充颜色值。
- en: 'In order to fix this bug, we modify the code for `set_background_color` and
    `set_foreground_color` to call two new methods:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个错误，我们修改了`set_background_color`和`set_foreground_color`的代码，使其调用两个新的方法：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The two methods are kept in a `try…except` block because not every toolbar button will
    have a fill and outline options `combobox`. Even if a toolbar button has the fill
    or outline `combobox`, it may not be selected to use the foreground or background
    color.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法被放在一个 `try…except` 块中，因为并非每个工具栏按钮都会有一个填充和轮廓选项的 `combobox`。即使一个工具栏按钮有填充或轮廓
    `combobox`，它也可能没有被选中来使用前景或背景颜色。
- en: 'Lastly, since we want the `draw_line` options to populate the top bar immediately when
    the program starts, we add the following two lines to the `create_gui` method
    (see the `6.06.py` code):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们希望`draw_line`选项在程序启动时立即填充顶部栏，我们在`create_gui`方法中添加了以下两行代码（参见`6.06.py`代码）：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This concludes this iteration. We will add functionality to a few other toolbar
    buttons in the next iteration.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这次迭代到此结束。我们将在下一个迭代中为几个其他工具栏按钮添加功能。
- en: Drawing irregular lines and super shapes
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制不规则线条和超级形状
- en: 'Let''s now add the capability to draw irregular or continuous free-flowing
    lines. We will also add the ability to draw a variety of interesting shapes on
    the drawing canvas, as shown here:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在添加绘制不规则或连续自由流动线条的功能。我们还将添加在绘图画布上绘制各种有趣形状的能力，如图所示：
- en: '![](img/ba682999-dcd5-4bab-9997-8d476a59be74.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ba682999-dcd5-4bab-9997-8d476a59be74.png)'
- en: As a reminder, all our buttons are linked to dynamically call functions defined
    in our `tool_bar_functions` tuple. Furthermore, we can specify unique options
    for a given function by adding the `_options` string to the function name.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，我们所有的按钮都链接到在`tool_bar_functions`元组中定义的动态函数。此外，我们可以通过在函数名中添加`_options`字符串来为特定的函数指定唯一选项。
- en: Drawing irregular lines
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制不规则线条
- en: To add the capability to draw irregular lines, we just need to define the method named
    `draw_irregular_line`. To specify options that appear in the top bar, we need
    to define the method named `draw_irregular_line_options`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加绘制不规则线条的功能，我们只需定义名为 `draw_irregular_line` 的方法。要指定出现在顶部栏中的选项，我们需要定义名为 `draw_irregular_line_options`
    的方法。
- en: 'We define the `draw_irregular_line` method as follows (see code `6.07.py`):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `draw_irregular_line` 方法定义为如下（参见代码 `6.07.py`）：
- en: '[PRE46]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding code is similar to the code for `draw_line`, except that it adds
    an extra line that binds mouse-clicked movements to a new method that replaces the
    start *x*, *y* coordinates with the end *x*, *y* coordinates and again calls back
    the `draw_irregular_line` method, thereby drawing in a continuous manner.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与`draw_line`函数的代码类似，但增加了一条额外的线，将鼠标点击的移动绑定到一个新方法，该方法用结束的*x*，*y*坐标替换开始的*x*，*y*坐标，并再次调用`draw_irregular_line`方法，从而以连续的方式绘制。
- en: 'The options that show in the top bar are defined using the following method (see
    code `6.07.py`):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部栏中显示的选项是通过以下方法定义的（参见代码`6.07.py`）：
- en: '[PRE47]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we can draw irregular lines on the canvas. However, since we have modified the
    mouse binding, all other methods will also start to draw in a continuous manner.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以画不规则的线条在画布上了。然而，由于我们修改了鼠标绑定，所有其他方法也将开始以连续的方式绘制。
- en: We, therefore, need to rebind the buttons back to their original bindings. We
    do that by modifying `on_tool_bar_button_clicked` to call `bind_mouse`, which then
    restores the mouse binding to its original behavior.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要将按钮重新绑定到它们原始的绑定上。我们通过修改`on_tool_bar_button_clicked`函数来调用`bind_mouse`函数，然后该函数将鼠标绑定恢复到其原始行为。
- en: Adding an event binding to more than one method wipes away the previous binding,
    whereby the new binding replaces any existing binding.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 将事件绑定添加到多个方法中会清除之前的绑定，新绑定将替换任何现有的绑定。
- en: 'Alternatively, you can use `add="+"` as an additional argument to keep more
    than one binding to the same event, as follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用`add="+"`作为附加参数来保持对同一事件的多个绑定，如下所示：
- en: '`mywidget.bind("<SomeEvent>", method1, add="+")`'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`mywidget.bind("<SomeEvent>", method1, add="+")`'
- en: '`mywidget.bind("<SameEvent>", method2, add="+")`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`mywidget.bind("<SameEvent>", method2, add="+")`'
- en: This will bind the same event to `method1` and `method2`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使相同的事件绑定到`method1`和`method2`。
- en: Drawing super shapes
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制超级形状
- en: We call these shapes super shapes because we can build many interesting shapes
    using a single mathematical formula called **Super Formula**. See [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    for more details on the formula.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这些形状称为超级形状，因为我们可以使用一个名为**超级公式**的单个数学公式构建许多有趣的形状。有关公式的更多详细信息，请参阅[https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)。
- en: 'The super formula takes six input arguments: `a`, `b`, `m`, `n1`, `n2`, and
    `n3`. Varying these five arguments produces varied shapes found in nature such
    as the shapes of shells, starfish, flowers, and more.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 超级公式包含六个输入参数：`a`、`b`、`m`、`n1`、`n2`和`n3`。改变这五个参数会产生自然界中发现的多种形状，例如贝壳、海星、花朵等形状。
- en: 'We do not get into why or how this formula works. All we do is write a method that,
    given these five arguments, returns the coordinates for unique shapes. We then pass
    these coordinates to our `create_polygon` method to create these shapes on the canvas.
    The method that returns these points is defined as follows (see code `6.07.py`):'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不深入探讨这个公式的原理或运作方式。我们只是编写了一个方法，给定这五个参数，它会返回独特形状的坐标。然后我们将这些坐标传递给我们的`create_polygon`方法，在画布上创建这些形状。返回这些点的这个方法定义如下（见代码`6.07.py`）：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The method uses a custom-defined `float_range` method, since Python''s built-in range
    method does not allow for float step sizes. The `float_range` generator method
    is defined as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法使用自定义的 `float_range` 方法，因为 Python 的内置 `range` 方法不允许使用浮点步长。`float_range` 生成器方法定义如下：
- en: '[PRE49]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Next, we define the `draw_super_shape` method, which creates a polygon with
    the calculated points (see code `6.07.py`):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`draw_super_shape`方法，该方法使用计算出的点创建一个多边形（参见代码`6.07.py`）：
- en: '[PRE50]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now we want to provide a different set of five parameters to the super formula.
    We define a new file named `supershapes.py` with a dictionary named `super_shapes`*with*
    different shapes represented by a shape name and five parameters as follows:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们希望向超级公式提供一组不同的五个参数。我们定义一个新的文件名为 `supershapes.py`，其中包含一个名为 `super_shapes`
    的字典，该字典以形状名称和五个参数的形式表示不同的形状，如下所示：
- en: '[PRE51]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We also define an attribute (see code `6.07.py`):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了一个属性（参见代码`6.07.py`）：
- en: '[PRE52]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we define a `combobox` to let the user select from among the shapes defined previously
    (`6.07.py`):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`combobox`，让用户从之前定义的形状中选择（`6.07.py`）：
- en: '[PRE53]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'And we define a method that sets the selected shape for the value of `selected_super_shape` (see
    code `6.07.py`):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一种方法，用于设置`selected_super_shape`的选定形状值（参见代码`6.07.py`）：
- en: '[PRE54]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Finally, we define the `draw_super_shapes_options` that shows all of the options
    we want to show in the top option bar (see code `6.07.py`):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了`draw_super_shapes_options`，它显示了我们在顶部选项栏中想要显示的所有选项（参见代码`6.07.py`）：
- en: '[PRE55]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This concludes the iteration. You can now run `*6.07.py*` and draw irregular
    lines as well as all of the super shapes that we have defined in the `supershapes.py`
    file. In fact, you can extend the `super_shapes` dictionary to add many more shapes
    simply by changing the values for the five parameters. You can look at [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    for values of parameters that create interesting shapes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了迭代。现在你可以运行 `*6.07.py*` 并绘制不规则线条以及我们在 `supershapes.py` 文件中定义的所有超形状。实际上，你只需通过更改五个参数的值，就可以扩展
    `super_shapes` 字典来添加更多形状。你可以查看 [https://en.wikipedia.org/wiki/Superformula](https://en.wikipedia.org/wiki/Superformula)
    了解创建有趣形状的参数值。
- en: Adding functionality to the remaining buttons
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向剩余的按钮添加功能
- en: 'We will now code the features related to the remaining toolbar buttons:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编写与剩余工具栏按钮相关的功能代码：
- en: '![](img/06165595-3c77-46e0-814f-956f4ac6326d.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06165595-3c77-46e0-814f-956f4ac6326d.png)'
- en: 'Specifically, we will code the following functions: `draw_text`, `delete_item`, `fill_item`,
    `duplicate_item`, `move_to_top`, `drag_item`, `enlarge_item_size`, and `reduce_item_size`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将编写以下函数：`draw_text`、`delete_item`、`fill_item`、`duplicate_item`、`move_to_top`、`drag_item`、`enlarge_item_size`和`reduce_item_size`。
- en: 'Let''s start with the code for `draw_text`. When a user clicks on the `draw_text`
    button, we want to show the following options in the top bar:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`draw_text`的代码开始。当用户点击`draw_text`按钮时，我们希望在顶部栏显示以下选项：
- en: '![](img/7f2e7aeb-8e78-4705-bf80-ea7f455c42a6.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7f2e7aeb-8e78-4705-bf80-ea7f455c42a6.png)'
- en: The user can enter text in the textbox and specify its font size and fill color.
    Once the user presses the Go button, the text appears on the center of the canvas.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以在文本框中输入文本并指定其字体大小和填充颜色。一旦用户按下“Go”按钮，文本就会出现在画布的中央。
- en: 'Let us, therefore, define the `draw_text_options` method as follows (see code
    `6.08.py`):'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将`draw_text_options`方法定义为如下（参见代码`6.08.py`）：
- en: '[PRE56]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code is self-explanatory. The Go button is attached to a command callback
    named `on_create_text_button_clicked`, which is defined as follows (see code `6.08.py`):'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码一目了然。Go按钮连接到一个名为`on_create_text_button_clicked`的命令回调，其定义如下（参见代码`6.08.py`）：
- en: '[PRE57]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Our `draw_text` method is now functional. Next, let's code the `delete_item`
    method.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `draw_text` 方法现在已可用。接下来，让我们编写 `delete_item` 方法。
- en: The operations that we want to do now are slightly different from their predecessors. Earlier,
    we were creating items on the canvas. Now we have to target items already present
    on the canvas.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在想要进行的操作与它们的 predecessors 略有不同。以前，我们在画布上创建项目。现在，我们必须针对画布上已经存在的项目。
- en: The item that needs to be targeted is the one on which the user clicks with
    their mouse. Fortunately, getting the item handle for the item under the mouse
    is very easy using the current tag.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 需要被定位的目标项是用户用鼠标点击的那个。幸运的是，使用当前标签获取鼠标下方的目标项句柄非常简单。
- en: 'Accordingly, the code for `delete_item` is as follows (see code `6.08.py`):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`delete_item` 函数的代码如下（参见代码 `6.08.py`）：
- en: '[PRE58]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Now, if you select the Delete button from the toolbar and click on any item
    on the canvas, that item is deleted.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您从工具栏中选择删除按钮并点击画布上的任何项目，该项目将被删除。
- en: 'Next, let''s code the `fill_item` and `fill_item_options` methods (see code
    `6.08.py`):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们编写`fill_item`和`fill_item_options`方法（参见代码`6.08.py`）：
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We had to use a `try…except` block because some canvas items such as lines
    and text do not have an outline option:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不使用`try…except`块，因为一些画布项目如线条和文本没有轮廓选项：
- en: '[PRE60]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Next, we code the `duplicate_item` method. In order to duplicate an item we
    need to know three things:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写`duplicate_item`方法。为了复制一个项目，我们需要知道以下三件事：
- en: Type of item—if the item is a `line`, `oval`, `arc`, `rectangle`, or `polygon`
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目类型——如果项目是`直线`、`椭圆`、`弧线`、`矩形`或`多边形`
- en: The coordinates for the item
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该项目的坐标
- en: The configurations of the item
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目配置
- en: 'We can get the type of item as a string using the type method as follows: `canvas.type(item_specifier)`'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`type`方法将项目类型作为字符串获取，如下所示：`canvas.type(item_specifier)`
- en: This returns a string such as `line`, `oval`, `arc`, `rectangle`, or `polygon`.
    In order to recreate an item of the same type, we need to append the string `create_`
    to the returned type and call the method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个如`line`、`oval`、`arc`、`rectangle`或`polygon`这样的字符串。为了重新创建相同类型的项，我们需要将字符串`create_`附加到返回的类型上并调用该方法。
- en: 'The coordinates of a given item can be obtained by calling the coordinates
    method as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用坐标方法，可以获取给定项目的坐标，如下所示：
- en: '`` `coordinates = canvas.coords("item_specifier")` ``'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '`` `coordinates = canvas.coords("item_specifier")` ``'
- en: 'The configurations for an item can be obtained as a dictionary using the following
    command:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 获取一个项目的配置可以通过以下命令以字典的形式获得：
- en: '`canvas.itemconfig(item_specifier)`'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.itemconfig(item_specifier)`'
- en: 'This returns all the configurations for an item, whether specified or not specified.
    For example, here''s a sample of a dictionary returned by calling the preceding
    method on a canvas item:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个项目的所有配置，无论是否指定。例如，以下是调用前面方法在画布项目上返回的字典的一个示例：
- en: '[PRE61]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Clearly, we do not require those configuration values that are empty or zero.
    We, therefore, write a method that filters out all unnecessary configurations:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们不需要那些为空或为零的配置值。因此，我们编写了一个方法来过滤掉所有不必要的配置：
- en: '[PRE62]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now that we know how to fetch all required elements to duplicate a canvas item, here''s
    the code for `duplicate_item` (see code `6.08.py`):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何获取所有必要的元素来复制画布项目，以下是`duplicate_item`函数的代码（参见代码`6.08.py`）：
- en: '[PRE63]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Finally, the last line calls a `wrapper` function that actually runs the function
    that duplicates the canvas item (see code `6.08.py`):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一行调用了一个`包装器`函数，该函数实际上运行了复制画布项的函数（参见代码`6.08.py`）：
- en: '[PRE64]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, if you create an item, select the duplicate item button, and click on
    the item, a duplicate item is created. However, since we do not want the duplicate
    item to be created exactly on top of the existing item, we offset its coordinates
    by `10` pixels from the coordinates of the item being duplicated. This offsetting
    is done in the line:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您创建一个项目，选择复制项目按钮，然后点击该项目，就会创建一个复制项目。然而，由于我们不希望复制项目正好位于现有项目上方，我们将其坐标从被复制的项目坐标偏移`10`像素。这种偏移是在以下行中完成的：
- en: '[PRE65]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Now, if you create an item on the canvas, select the duplicate item button,
    and click on the item, its duplicate is created at an offset of `10` pixels from
    the original item.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你在画布上创建一个项目，选择复制项目按钮，然后点击该项目，它的副本将在原始项目偏移`10`像素的位置创建。
- en: 'Next, we code the `move_to_top` method. We have already discussed that items added
    to the canvas are added on top of each other. What if we want to move an item
    previously added to the canvas? The following figure shows what it means to move
    an item on top of another:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们编写`move_to_top`方法。我们已经讨论过，添加到画布上的项目是逐个叠加的。如果我们想移动之前添加到画布上的一个项目呢？以下图示展示了将一个项目移动到另一个项目之上的含义：
- en: '![](img/c7f21151-ab49-479a-b1f3-632fe00dc550.png)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7f21151-ab49-479a-b1f3-632fe00dc550.png)'
- en: 'We use the `tag_raise` and `tag_lower` methods to move items higher and lower in
    the stack. We use `tag_raise` to define the `move_to_top` method as follows (see
    code `6.08.py`):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`tag_raise`和`tag_lower`方法来移动栈中的项目上下移动。我们使用`tag_raise`来定义`move_to_top`方法如下（参见代码`6.08.py`）：
- en: '[PRE66]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The preceding code raises the clicked item highest up in the item's stack.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将点击的项目在项目堆栈中提升到最高位置。
- en: 'When you draw multiple items on the canvas, the items are placed in a stack.
    By default, new items get added on top of items previously drawn on the canvas.
    You can, however, change the stacking order using:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在画布上绘制多个项目时，这些项目会被放置在一个堆栈中。默认情况下，新项目会被添加到之前绘制在画布上的项目之上。然而，你可以通过以下方式更改堆栈顺序：
- en: '`canvas.tag_raise(item)`.'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`canvas.tag_raise(item)`.'
- en: If multiple items match, they are all moved, with their relative order preserved. However,
    this method will not change the stacking order for any new window item that you
    draw within the canvas.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个项目匹配，它们都会被移动，并保持它们相对的顺序。然而，这种方法不会改变您在画布内绘制的任何新窗口项目的堆叠顺序。
- en: Then there are the `find_above` and `find_below` methods that you can use to
    find items above or below an item in the canvas stacking order.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有 `find_above` 和 `find_below` 方法，您可以使用这些方法在画布堆叠顺序中查找位于某个项目上方或下方的项目。
- en: 'Next, we will define the `drag_item` method. This method uses the move method
    to change the coordinates of a given item (see code `6.08.py`):'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义`drag_item`方法。此方法使用移动方法来改变给定项的坐标（参见代码`6.08.py`）：
- en: '[PRE67]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Since we want the drag to occur continuously and not as a jump from one place to
    another, we temporarily bind the mouse binding to update the start and end coordinates
    like we did when we defined the `draw_irregular_line` method.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望阻力连续发生而不是从一个地方跳跃到另一个地方，我们暂时将鼠标绑定绑定到更新起始和结束坐标，就像我们在定义`draw_irregular_line`方法时做的那样。
- en: 'Finally, we define two methods to enlarge and reduce item size. We will use
    the `canvas.scale` method to increase and reduce item size by 20%:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们定义了两种方法来放大和缩小项目大小。我们将使用`canvas.scale`方法将项目大小增加和减少20%：
- en: '[PRE68]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note that, immediately upon item resize, we reconfigure the scroll region option
    to update the scroll bar.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在项目大小调整后，我们立即重新配置滚动区域选项以更新滚动条。
- en: 'The `bbox` method returns the bounding box for an item. The syntax is:  `.canvas.bbox(item_specifier)`.
    This returns the bounding box as a tuple of length 4\. If the item-specifier is
    omitted, the bounding box for all items is returned.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`bbox` 方法返回一个项目的边界框。语法是：`.canvas.bbox(item_specifier)`。这返回一个长度为4的元组作为边界框。如果省略了项目指定符，则返回所有项目的边界框。'
- en: Note that bounding box values are approximate and may differ from the real value
    by a few pixels.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，边界框的值是近似的，可能比实际值相差几个像素。
- en: This concludes the iteration. All the buttons in the left toolbar are now functional
    (see code `6.08.py`).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了迭代。左侧工具栏中的所有按钮现在都已启用（参见代码`6.08.py`）。
- en: Adding functionality to menu items
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向菜单项添加功能
- en: Recall that, at the time of creating our menu using the `Framework` class, we
    created empty methods that were linked to our menu items. We will now modify those
    empty methods to make them functional (see code `6.09.py` )
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在创建我们的菜单时使用`Framework`类，我们创建了与菜单项相关联的空方法。现在，我们将修改这些空方法，使它们变得可用（参见代码`6.09.py`）
- en: 'File | New Menu:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 | 新菜单：
- en: 'The canvas delete method can be used to delete an item, given an item-specifier.
    Here we use `ALL` to delete all items from the canvas:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 画布删除方法可以用于删除一个项目，给定一个项目指定符。在这里，我们使用`ALL`来删除画布上的所有项目：
- en: '[PRE69]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'File | Save, File | Save As:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '文件 | 保存, 文件 | 另存为:'
- en: Tkinter lets you save canvas objects as a postscript file using the command
    `postscript()`. Note, however, that the resulting postscript file cannot save
    images or any widgets embedded on the canvas. Furthermore, note that the pickling
    of Tkinter widgets or saving to `.jpg` or `.png` formats is not possible. This
    is one of the major limitations of Tkinter.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter 允许您使用 `postscript()` 命令将画布对象保存为 postscript 文件。请注意，然而，生成的 postscript
    文件无法保存画布上的图像或任何嵌入的控件。此外，请注意，Tkinter 控件的 pickling 或保存为 `.jpg` 或 `.png` 格式是不可能的。这是
    Tkinter 的主要限制之一。
- en: 'Here''s the code for the save and save as features (see code `6.09.py`):'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是保存和另存为功能的代码（参见代码`6.09.py`）：
- en: '[PRE70]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: We do not discuss the Close and About menu as we have coded similar menus in
    all our previous projects (see code `6.09.py`).
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有讨论“关闭”和“关于”菜单，因为我们已经在所有之前的项目中编码了类似的菜单（见代码`6.09.py`）。
- en: 'Edit | Undo:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '编辑 | 撤销:'
- en: 'Recall that all items added to the canvas are stored in a stack. We can access
    the stack using the canvas command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，所有添加到画布上的项目都存储在堆栈中。我们可以使用画布命令来访问堆栈：
- en: '[PRE71]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Using this, we implement a very basic undo operation, which lets us delete the
    last drawn item on the canvas.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能，我们实现了一个非常基础的撤销操作，它允许我们删除画布上最后绘制的项目。
- en: 'Accordingly, the code for adding the undo feature is as follows (see code `6.09.py`):'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '因此，添加撤销功能的代码如下（参见代码`6.09.py`):'
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note that this will not undo any styling changes such as changes in color, width,
    outline, and so on. In fact, it will only be able to delete the last item from
    the stack.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不会撤销任何样式更改，例如颜色、宽度、轮廓等变化。实际上，它只能删除堆栈中的最后一个项目。
- en: We can implement a fully-fledged undo stack by saving all actions in a suitable
    data structure, but that would be an exercise worth its own chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过保存所有操作到一个合适的数据结构中来实现一个完整的撤销栈，但这将是一个值得单独成章的练习。
- en: 'In addition to the find method we used here, the Canvas widget has a method
    named:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在这里使用的查找方法外，Canvas小部件还有一个名为：
- en: '[PRE73]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: It returns the item handle for the item closest to the given position on the
    canvas. This means that if there is only one item on the canvas, it will be selected
    regardless of how near or how far you click from it.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回画布上给定位置最近的项的手柄。这意味着如果画布上只有一个项，无论你点击得有多近或多远，它都会被选中。
- en: 'If, on the other hand, you want objects only within a certain area, you can
    use:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 如果，另一方面，你只想在某个特定区域内使用对象，你可以使用：
- en: '[PRE74]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This returns all items that overlap the given rectangle, or that are completely enclosed
    by it.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回所有与给定矩形重叠或完全被其包围的项目。
- en: Now that we have a hold on the item to be manipulated, we can proceed to do whatever
    we want with the item.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了要操作的项目，我们可以继续进行我们想要对项目做的任何操作。
- en: For a complete list of canvas methods, please see [http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看完整的画布方法列表，请参阅[http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html](http://infohost.nmt.edu/tcc/help/pubs/tkinter/web/canvas-methods.html).
- en: 'View | Zoom in, View | Zoom out:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 查看视图 | 放大视图，查看视图 | 缩小视图：
- en: 'Finally, we define these two methods using the `canvas.scale` method. We have
    already used the scale methods earlier to enlarge and reduce individual items.
    Here, we simply use the method on the `ALL` item-specifier, as in the following
    code (see code `6.09.py`):'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用 `canvas.scale` 方法定义了这两种方法。我们之前已经使用过缩放方法来放大和缩小单个项目。在这里，我们只需在 `ALL` 项目指定器上使用该方法，如下代码所示（参见代码
    `6.09.py`）：
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: That concludes the iteration and the chapter.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了迭代和这一章节。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To summarize, in this chapter, we began by creating a custom GUI framework on
    top of Tkinter.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中，我们首先在Tkinter之上创建了一个自定义的GUI框架。
- en: We saw how GUI frameworks can be used to generate boilerplate code for our programs,
    thereby ensuring maximum code reuse and rapid application development.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用GUI框架来生成我们程序的样板代码，从而确保最大程度的代码复用和快速应用开发。
- en: Next, we explored the Canvas widget in detail. We saw how to create various
    canvas items. Then, we saw how we could manipulate the attributes of these canvas
    items using tag or ID.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们详细探讨了 Canvas 小部件。我们了解了如何创建各种画布项目。然后，我们看到了如何使用标签或 ID 来操作这些画布项目的属性。
- en: We saw the `colorchooser` module of Tkinter in action. We worked with the ttk
    Combobox widget. We also looked at common methods that are available on all Tkinter
    widgets.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了 Tkinter 的 `colorchooser` 模块在实际中的应用。我们使用了 ttk Combobox 小部件。我们还查看了一些所有 Tkinter
    小部件都有的常用方法。
- en: We also saw the benefits of writing programs that use convention over configuration
    to ease the logical flow of the program.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也看到了编写使用约定而非配置来简化程序逻辑流程的程序的好处。
- en: QA section
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: QA部分
- en: Before you proceed to the next chapter, make sure you can answer these questions
    to your
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在你继续阅读下一章之前，请确保你能回答这些问题
- en: 'satisfaction:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 满意度：
- en: What are software frameworks?  Why are they used?
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是软件框架？为什么它们会被使用？
- en: When is it beneficial to use software frameworks instead of writing code from
    scratch?
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在什么情况下使用软件框架而不是从头编写代码是有益的？
- en: What is a structured markup language? Can you a list a few of them?
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是结构化标记语言？你能列举一些吗？
- en: What is the convention over configuration software design paradigm?
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是约定优于配置的软件设计范式？
- en: What are tags used for in the context of  Tkinter's Canvas widget?
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Tkinter的Canvas小部件的上下文中，标签有什么用途？
- en: Further reading
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Read the complete documentation for the Tkinter Canvas widget. You can find
    the documentation by typing the following command in a Python command shell:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读Tkinter Canvas小部件的完整文档。您可以通过在Python命令行中输入以下命令来找到文档：
- en: '[PRE76]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
