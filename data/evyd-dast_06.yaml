- en: 'Chapter 6. Dictionaries: Keyed Collections'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。字典：键值集合
- en: A **dictionary** is an abstract data structure that can be described as a collection
    of keys and associated values, where each key only appears once within the collection.
    This associated relationship between the keys and values is why dictionaries are
    sometimes referred to as **associative arrays**. Dictionaries are also known as
    **maps**, or more specifically, **hash maps** for **hash table**-based dictionaries
    and **tree maps** for **search tree**-based dictionaries. The four most common
    functions associated with a dictionary are **add**, **update**, **get**, and **remove**.
    Other common operations include **contains**, **count**, **reassign**, and **set**.
    Each of these operations will be examined in detail later in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**字典**是一种抽象数据结构，可以被描述为一个键的集合及其相关值的集合，其中每个键在集合中只出现一次。这种键和值之间的关联关系是为什么字典有时被称为**关联数组**。字典也被称为**映射**，或者更具体地说，对于基于**哈希表**的字典称为**哈希映射**，对于基于**搜索树**的字典称为**树映射**。与字典相关联的四个最常见函数是**添加**、**更新**、**获取**和**删除**。其他常见操作包括**包含**、**计数**、**重新分配**和**设置**。这些操作将在本章后面详细探讨。'
- en: The mapped, or associative, nature of dictionaries allows for extremely efficient
    insert, search, and update operations. By specifying the key when creating, editing,
    or getting a value, most operations in a well-designed dictionary have a minimal
    **O**(*1*) cost. Perhaps, it's because of this efficiency that dictionaries are
    one of the most common data structures you will encounter in your day-to-day development
    experience.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 字典的映射或关联性质使得插入、搜索和更新操作非常高效。通过在创建、编辑或获取值时指定键，大多数在设计良好的字典中的操作都具有最小的**O(1**)成本。也许正因为这种效率，字典是你日常开发经验中最常见的几种数据结构之一。
- en: You might be wondering why something described as a collection of associated
    keys and values should be referred to as a dictionary. This name is an analogy
    with a physical dictionary, where each word (key) has an associated definition
    (value). If this is still a little too abstract, consider a valet service. When
    you pull up a car to an event, you step out of your car and someone hands you
    a little ticket before driving away with your vehicle. This ticket represents
    your car, and only your car. There are no other tickets with the same identifier
    as the one you are now holding. Therefore, there is only one-way to get your car
    back is presenting this specific ticket to the valet service. Once you do so,
    someone rolls up with your vehicle, you hand them a tip, and then you drive away.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，为什么描述为键值对的集合应该被称为字典。这个名字是类比于物理字典，其中每个单词（键）都有一个相关的定义（值）。如果这仍然有点抽象，可以考虑一个代客泊车服务。当你把车停在活动地点时，你从车里出来，有人在你离开前给你一张小票，然后开车离开。这张小票代表你的车，只代表你的车。没有其他带有相同标识符的小票与你现在持有的相同。因此，唯一能够取回你的车的方式就是向代客泊车服务出示这张特定的小票。一旦你这样做，有人就会带着你的车过来，你给他们小费，然后你开车离开。
- en: This process is a concrete example of the dictionary data structure. Each ticket
    represents a *key*, while each vehicle represents a *value* of some type. Each
    key is unique and uniquely identifies one specific value. When your code calls
    for a value, the valet service is the *collection* that uses the key to locate
    and return the value you are looking for. Tipping your development machine is
    optional.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程是字典数据结构的一个具体例子。每张小票代表一个**键**，而每辆车代表某种类型的**值**。每个键都是唯一的，并且唯一地标识一个特定的值。当你的代码调用一个值时，代客泊车服务就是使用键来定位和返回你正在寻找的值的**集合**。给你的开发机器小费是可选的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition of a dictionary data structure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字典数据结构的定义
- en: Initializing dictionaries
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化字典
- en: Hash tables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表
- en: Common dictionary operations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的字典操作
- en: Case study - arcade ticket totals
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究 - 游艺厅票券总额
- en: Hash table based dictionaries
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于哈希表的字典
- en: Search tree based dictionaries
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于搜索树的字典
- en: Initializing dictionaries
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化字典
- en: Dictionaries are so commonplace that it's no wonder that each of the languages
    we are examining supports them with concrete implementations. Here are some examples
    of initializing a dictionary, adding a few key/value pairs to the collection,
    and then removing one of those pairs from the collection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 字典如此普遍，难怪我们正在检查的每种语言都通过具体的实现来支持它们。以下是一些初始化字典、向集合中添加几个键值对，然后从集合中删除这些对之一的示例。
- en: '**C#**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides a concrete implementation of the dictionary data structure through
    the `Dictionary<TKey, TValue>` class. Since this class is generic, the caller
    may define the types used for both the keys and values. Here is an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: C# 通过 `Dictionary<TKey, TValue>` 类提供了字典数据结构的具体实现。由于这个类是泛型的，调用者可以定义用于键和值的类型。以下是一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example initializes a new dictionary where the keys will be `string` types,
    and the values will be `int` types:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例初始化了一个新的字典，其中键将是 `string` 类型，值将是 `int` 类型：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Java**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Java provides a `Dictionary<K, V>` class, but it has been recently deprecated
    in favor of any class that implements the `Map<K, V>` interface. Here, we''ll
    look at an example of the `HashMap<K, V>` class. This class extends `AbstractMap<K,
    V>` and implements the `Map<K, V>` interface:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了一个 `Dictionary<K, V>` 类，但最近已经弃用，转而使用实现了 `Map<K, V>` 接口的任何类。在这里，我们将查看
    `HashMap<K, V>` 类的一个示例。这个类扩展了 `AbstractMap<K, V>` 并实现了 `Map<K, V>` 接口：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This class is called `HashMap` because it is a concrete, hash table based implementation
    of a map. It is interesting to note that Java will not permit primitives to be
    used as either the keys or the values in a `HashMap` class, so in our preceding
    example, we are substituting String types for our values.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类被称为 `HashMap`，因为它是一个具体的、基于哈希表的映射实现。值得注意的是，Java 不允许在 `HashMap` 类中使用原始数据类型作为键或值，因此在我们前面的例子中，我们用
    String 类型替换了我们的值。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Hash tables**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希表**'
- en: Since one of Java's dictionary implementations is called a **hash map**, this
    seems like a good time to introduce **hash tables**, which are sometimes referred
    to as hash maps. Hash tables use a **hash function** to map data to indexed positions
    in an array. Technically, a hash function is any function that can be used to
    plot data of a random size to data of a static size.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Java 的一个字典实现被称为 **哈希表**，这似乎是介绍 **哈希表** 的好时机，有时也称为哈希表。哈希表使用 **哈希函数** 将数据映射到数组中的索引位置。技术上讲，哈希函数是任何可以将随机大小的数据绘制到静态大小的数据的函数。
- en: 'In well-designed hash tables, the search, insert, and delete functions have
    an **O**(1) cost, as the complexity is independent of the number of elements the
    collection contains. In many situations, hash tables are much more efficient in
    comparison to arrays, lists, or other lookup data structures. This is the reason
    they are so frequently used to build dictionaries. This is also the reason they
    are commonly used in database indexing, caches, and as the foundation of the **set**
    data structure. We will discuss sets in more detail in [Chapter 7](part0041_split_000.html#173722-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 7. Sets: No Duplicates"), *Sets: No Duplicates*.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计良好的哈希表中，搜索、插入和删除函数的成本为 **O**(1)，因为复杂性不依赖于集合中元素的数量。在许多情况下，与数组、列表或其他查找数据结构相比，哈希表要高效得多。这就是它们经常被用来构建字典的原因。这也是它们通常用于数据库索引、缓存以及作为
    **集合** 数据结构基础的原因。我们将在第 7 章 [Chapter 7](part0041_split_000.html#173722-77f2b5b248f04368a6f723b0e9357ef3
    "第 7 章。集合：无重复") 中更详细地讨论集合。*集合：无重复*。
- en: In truth, hash tables are a data structure unto themselves, although they are
    most commonly used to create associative arrays. So, why then are we not examining
    the hash table data structure in more depth? In most languages, a dictionary is
    preferred over a hash table for similar applications. This is because dictionaries
    are **generically typed**, while hash tables rely on the language's root object
    type to assign values internally, such as C#'s `object` type. While hash tables
    permit virtually any object to be used as a key or value, a generically typed
    dictionary will limit the caller to assigning only objects of the declared types
    as the key or value of an element. This approach is both type-safe as well as
    more efficient because values do not need to be **boxed** and **unboxed** (cast)
    every time a value is updated or retrieved.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，哈希表是一种数据结构，尽管它们最常用于创建关联数组。那么，我们为什么不对哈希表数据结构进行更深入的探讨呢？在大多数语言中，对于类似的应用，字典比哈希表更受欢迎。这是因为字典是
    **泛型类型化的**，而哈希表依赖于语言的根对象类型来内部分配值，例如 C# 的 `object` 类型。虽然哈希表允许几乎任何对象用作键或值，但泛型类型的字典将限制调用者只能将声明的类型对象作为元素的键或值。这种方法既类型安全又更高效，因为值不需要在每次更新或检索值时进行
    **装箱** 和 **拆箱**（类型转换）。
- en: That being said, do not make the mistake of assuming that a dictionary is simply
    a hash table by another name. It is true that a hash table roughly corresponds
    to some variation of `Dictionary<object, object>`, but it is a different class
    with different functionality and methods.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，不要犯下这样一个错误：认为字典仅仅是另一种名称的哈希表。确实，哈希表大致对应于`Dictionary<object, object>`的一些变体，但它是一个不同的类，具有不同的功能和方法。
- en: '**Objective-C**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C provides immutable as well as mutable dictionary classes, `NSDictionary`
    and `NSMutableDictionary`, respectively. Since we''ll be working with a mutable
    dictionary in our example later, let''s just examine `NSDictionary` here. `NSDictionary`
    can be initialized with a literal array of *1.*..*n* key/value pairs using the
    `@{K : V, K : V}` syntax. There are also two common initializer methods. The first
    is `dictionaryWithObjectsAndKeys:`, which accepts an array of object/key pairs
    terminated by `nil`. The second is `dictionaryWithObjects:forKeys:`, which accepts
    an array of objects and a second array of keys. Similar to Java''s `HashMap`,
    Objective-C''s `NSDictionary` and `NSMutableDictionary` class clusters do not
    permit scalar data to be used as keys or values:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 'Objective-C提供了不可变和可变的字典类，分别是`NSDictionary`和`NSMutableDictionary`。由于我们将在后面的示例中使用可变字典，所以我们在这里只考察`NSDictionary`。`NSDictionary`可以使用`@{K
    : V, K : V}`语法初始化一个字面量数组，其中包含*1.*..*n*个键/值对。还有两种常见的初始化方法。第一种是`dictionaryWithObjectsAndKeys:`，它接受一个以`nil`结尾的对象/键对数组。第二种是`dictionaryWithObjects:forKeys:`，它接受一个对象数组和第二个键数组。与Java的`HashMap`类似，Objective-C的`NSDictionary`和`NSMutableDictionary`类簇不允许使用标量数据作为键或值：'
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You might notice that the `dictionaryWithObjects:forKeys:` approach is more
    verbose, making it slightly more readable. However, you must take extra care to
    ensure that your keys and values are correctly mapped to one another.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到`dictionaryWithObjects:forKeys:`方法更冗长，这使得它稍微易于阅读。然而，你必须格外小心，确保你的键和值正确地映射到对方。
- en: '**Swift**'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Dictionaries in Swift are created using the `Dictionary` class. Swift dictionaries
    are mutable when initialized as variables using `var`, but can also be created
    as immutable by initializing them as constants using `let`. Keys used in the dictionary
    can be either integers or strings. The `Dictionary` class can also accept values
    of any type, including those types normally considered primitives in other languages,
    since these are actually named types in Swift and are defined in the Swift standard
    library using structures. In either case, both your key and value types must be
    declared when the collection is initialized, and these cannot be changed later.
    Since we''ll be working with a variable, or mutable, dictionary later, we''ll
    initialize a constant immutable collection here:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的字典是通过`Dictionary`类创建的。当使用`var`初始化为变量时，Swift字典是可变的，但也可以通过使用`let`初始化为常量来创建不可变字典。字典中使用的键可以是整数或字符串。`Dictionary`类还可以接受任何类型的值，包括在其他语言中通常被认为是原生的类型，因为这些在Swift中实际上是命名类型，并且使用结构体在Swift标准库中定义。在任一情况下，都必须在初始化集合时声明你的键和值类型，并且之后不能更改。由于我们将在后面使用一个变量或可变字典，所以我们在这里初始化一个常量不可变集合：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We will examine **structures** in more detail later in [Chapter 8](part0047_split_000.html#1CQAE2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 8. Structs: Complex Types"), *Structs: Complex Types*.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](part0047_split_000.html#1CQAE2-77f2b5b248f04368a6f723b0e9357ef3 "第8章。结构体：复杂类型")中更详细地考察**结构体**，*结构体：复杂类型*。
- en: Dictionary operations
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字典操作
- en: 'Not all concrete implementations of the dictionary data structures expose the
    same operational methods. However, the more common operations should be available
    or made available as needed by the developer. Here are some operations:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有字典数据结构的具体实现都公开了相同的操作方法。然而，更常见的操作应该是可用的，或者根据开发者的需要提供。以下是一些操作：
- en: '**add**: The add operation, sometimes referred to as an insert, introduces
    a new key/value pair into the collection. Add operations have an **O**(*1*) cost.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**add**：add操作，有时称为插入，向集合中引入一个新的键/值对。add操作具有**O(1**)的成本。'
- en: '**get**: The get operation, sometimes called a **lookup**, returns the value
    mapped to a given key. If no value is found for the given key, some dictionaries
    will raise an *exception*. By specifying the key, get operations have an **O**(*1*)
    cost.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**get**：get操作，有时称为**查找**，返回与给定键关联的值。如果找不到给定键的值，某些字典将引发一个*异常*。通过指定键，get操作具有**O(1**)的成本。'
- en: '**update**: The update operation allows the caller to modify a value that is
    already a part of the collection. Not all dictionary implementations provide a
    defined update method, but rather support updating a value via *reference*. This
    means the object can be modified directly once it has been pulled from the dictionary
    using a get operation. By specifying the key, update operations have an **O**(*1*)
    cost.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新**：更新操作允许调用者修改集合中已经存在的值。并非所有字典实现都提供定义明确的更新方法，而是通过*引用*支持更新值。这意味着一旦使用获取操作从字典中取出对象，就可以直接修改它。通过指定键，更新操作的成本为**O**(*1*)。'
- en: '**remove**: The remove, or *delete*, operation will remove a key/value pair
    from the collection given a valid key. Most dictionaries will gracefully ignore
    a specified key that does not exist. By specifying the key, remove operations
    have an **O**(1) cost.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移除**：移除或*删除*操作将根据有效的键从集合中删除键/值对。大多数字典将优雅地忽略指定的不存在键。通过指定键，移除操作的成本为**O**(1)。'
- en: '**contains**: The contains operation returns a Boolean value, identifying whether
    a given key can be found in the collection. Contains operations must iterate through
    the collection of keys in the dictionary to search for a match. Therefore, this
    operation has a worst-case cost of **O**(*n*).'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含**：包含操作返回一个布尔值，标识给定的键是否可以在集合中找到。包含操作必须遍历字典中的键集合以搜索匹配项。因此，此操作的最坏情况成本为**O**(*n*)。'
- en: '**count**: Count, sometimes referred to as *size*, can be either a method or
    simply a property of the collection that returns the number of key/value elements
    within the dictionary. Count is typically a simple property on the collection
    and, therefore, has an **O**(*1*) cost.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数**：计数，有时被称为*大小*，可以是集合的一个方法，也可以是集合的一个属性，它返回字典中键/值元素的数量。计数通常是集合上的一个简单属性，因此，其成本为**O**(*1*)。'
- en: '**reassign**: A reassign operation allows for assigning a new value to an existing
    key. This operation is somewhat less common in many implementations as the update
    operation serves as the reassign operation. By specifying the key, reassign operations
    have an **O**(*1*) cost.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新分配**：重新分配操作允许将新值分配给现有键。在许多实现中，此操作不如更新操作常见，因为更新操作充当重新分配操作。通过指定键，重新分配操作的成本为**O**(*1*)。'
- en: '**set**: The set operation is sometimes seen as a single replacement for both
    add and reassign operations. Set will either insert a new key/value pair if the
    key does not already exist, or it will reassign the value to the specified key.
    There is no need to support set, add, and reassign operations within the same
    implementation. As with add and update, set operations have an **O**(*1*) cost.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：集合操作有时被视为添加和重新分配操作的单一替代方案。如果键不存在，则集合将插入一个新的键/值对，或者它将重新分配指定键的值。不需要在同一实现中支持集合、添加和重新分配操作。与添加和更新一样，集合操作的成本为**O**(*1*)。'
- en: 'Case study: arcade ticket totals'
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究：游艺厅票券总额
- en: '**Business problem**: an arcade manager wants to cut costs by eliminating physical
    tickets from her games. Tickets are very costly and wasteful, since they must
    be thrown away or recycled once a customer has redeemed them. She has decided
    to introduce an electronic point system that allows customers to earn points rather
    than tickets, and store the points digitally. Once she has the hardware in place
    to support the changeover, she needs a mobile app that allows her and her customers
    to efficiently track their current point totals.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务问题**：一位游艺厅经理希望通过消除游戏中的实体票券来降低成本。票券成本很高且浪费，因为一旦顾客兑换后，它们就必须被丢弃或回收。她决定引入一个电子积分系统，允许顾客通过积分而不是票券来赚取积分，并将积分数字化存储。一旦她安装了支持转换的硬件，她需要一个移动应用程序，允许她和她的顾客高效地跟踪他们的当前积分总额。'
- en: This app has several key requirements. First, it should store data for the customer
    based solely on the name they provide during check-in. Second, it must keep a
    running total of all points earned, lost, and redeemed. Third, it must be capable
    of showing the customer's points and the total number of customers in the arcade
    at any given time. Finally, it should allow for the removal of individual customer
    records or all customer records at once. Based on these requirements, the developer
    decides that a dictionary will be the most efficient way to track all customer
    points, so the core class's functionality will be based on that data structure.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序有几个关键要求。首先，它应该仅根据客户在登记时提供的姓名存储客户数据。其次，它必须保持所有获得、损失和兑换的积分的累计总数。第三，它必须能够显示任何给定时间点的客户的积分和游艺厅中的客户总数。最后，它应该允许删除单个客户记录或一次性删除所有客户记录。基于这些要求，开发者决定使用字典来跟踪所有客户积分将是最有效的方法，因此核心类的功能将基于这种数据结构。
- en: '**C#**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# provides the generic collection `Dictionary<TKey, TValue>`. This class provides
    all of the basic operations we would expect to see in a concrete dictionary implementation,
    with the added benefit of generic type casting:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: C#提供了泛型集合`Dictionary<TKey, TValue>`。这个类提供了我们预期在具体字典实现中看到的所有基本操作，并且增加了泛型类型转换的优势：
- en: '[PRE5]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Using `Dictionary<TKey, TValue>`, we create one private field for our class
    called `_points`. Our constructor instantiates this field, giving us the underlying
    data structure to build our `PointsDictionary` class on:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Dictionary<TKey, TValue>`，我们为我们的类创建了一个名为`_points`的私有字段。我们的构造函数实例化这个字段，为我们提供了构建`PointsDictionary`类的基础数据结构：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `UpdateCustomerPoints(string customerName, int points)` method provides
    the core *update* functionality for our class. This method first confirms that
    the key exists in our collection. If the key does not exist, the method immediately
    returns `0`. Otherwise, we use subscript notation to both get the key and update
    the key's value. Using subscript notation once again, we finally return the updated
    value to the caller.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCustomerPoints(string customerName, int points)`方法为我们这个类提供了核心的*更新*功能。该方法首先确认键是否存在于我们的集合中。如果键不存在，该方法立即返回`0`。否则，我们使用下标符号来同时获取键并更新键的值。再次使用下标符号，我们最终将更新后的值返回给调用者。'
- en: 'We keep this method private, choosing to create several additional update methods
    that are more fitting to our business requirements. These public methods, discussed
    later, will expose the update functionality to the caller:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个方法设为私有，选择创建几个更适合我们业务需求的额外更新方法。稍后讨论的这些公共方法将向调用者公开更新功能：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The two `RegisterCustomer()` methods provide the *add* functionality to our
    class. In both cases, we require a customer name to act as the key. If a returning
    customer checks in with a previous balance, we want to acknowledge it so that
    our class overloads the method. Ultimately, the overloaded method calls `Dictionary<TKey,
    TValue>.Add(T)` to insert a new record into the collection:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 两个`RegisterCustomer()`方法为我们这个类提供了*添加*功能。在两种情况下，我们都需要一个客户名称作为键。如果返回的客户在登记时带有之前的余额，我们希望承认这一点，因此我们的类会重载该方法。最终，重载的方法调用`Dictionary<TKey,
    TValue>.Add(T)`来将新记录插入到集合中：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Our *get* functionality is introduced by the `GetCustomerPoints(string customerName)`
    method. In this method, we use `TryGetValue()` to safely confirm that the `customerName`
    key exists and to get the value at the same time. If the key does not exist, the
    app handles the issue gracefully and does not assign any value to `points`. The
    method then returns whatever value is currently set in `points`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的*获取*功能是通过`GetCustomerPoints(string customerName)`方法引入的。在这个方法中，我们使用`TryGetValue()`来安全地确认`customerName`键是否存在，并同时获取其值。如果键不存在，应用程序会优雅地处理这个问题，并且不会为`points`分配任何值。然后，该方法返回`points`中当前设置的任何值：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we come to the public update methods, `AddCustomerPoints(string customerName,
    int points)`, `RemoveÇustomerPoints(string customerName, int points)`, and `RedeemCustomerPoints(string
    customerName, int points)`. Each of these methods calls the private `UpdateCustomerPoints(string
    customerName, int points)` method, but first it negates `points` in the case of
    the latter two:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看公共更新方法，`AddCustomerPoints(string customerName, int points)`、`RemoveCustomerPoints(string
    customerName, int points)`和`RedeemCustomerPoints(string customerName, int points)`。每个这些方法都调用私有的`UpdateCustomerPoints(string
    customerName, int points)`方法，但在调用之前，后两种情况会先对`points`取反：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `CustomerCheckout(string customerName)` method introduces the collection''s
    *remove* functionality. The method first records the final value for the customer
    key, and then calls `Dictionary<TKey, TValue>.Remove(T)` to delete the customer''s
    key from the collection. Finally, it returns the customer''s last point value
    to the caller:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerCheckout(string customerName)` 方法引入了集合的 *remove* 功能。该方法首先记录客户键的最终值，然后调用
    `Dictionary<TKey, TValue>.Remove(T)` 从集合中删除客户的键。最后，它将客户的最后积分值返回给调用者：'
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `Dictionary<TKey, TValue>` interface conveniently provides the `ContainsKey()`
    method, which the `CustomerExists(string customerName)` method uses to introduce
    our class'' *contains* functionality:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dictionary<TKey, TValue>` 接口提供了一个方便的 `ContainsKey()` 方法，该方法被 `CustomerExists(string
    customerName)` 方法用来引入我们类的 *contains* 功能：'
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Using the `Count` field on the `Dictionary<TKey, TValue>` class, `CustomersOnPremises()`
    provides the *count* functionality:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Dictionary<TKey, TValue>` 类的 `Count` 字段，`CustomersOnPremises()` 提供了 *count*
    功能：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Finally, as per our business requirements, we need a way to remove all of the
    objects from the collection. The `ClosingTime()` method uses the `Dictionary<TKey,
    TValue>.Clear()` method to accomplish this task.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据我们的业务需求，我们需要一种方法来从集合中移除所有对象。`ClosingTime()` 方法使用 `Dictionary<TKey, TValue>.Clear()`
    方法来完成这个任务。
- en: '**Java**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'As mentioned previously, Java supplies a `Dictionary` class, but it has been
    deprecated in favor of any class that implements `Map<K, V>` interface. The `HashMap<K,
    V>` implements the interface and provides a dictionary based on a hash table.
    As with the previous C# example, the `HashMap<K, V>` class exposes all the basic
    operations we would expect to see in a concrete implementation of a dictionary:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Java 提供了一个 `Dictionary` 类，但它已被弃用，转而使用实现 `Map<K, V>` 接口的任何类。`HashMap<K,
    V>` 实现了该接口，并基于哈希表提供字典。与先前的 C# 示例一样，`HashMap<K, V>` 类公开了我们预期在字典的具体实现中看到的所有基本操作：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'An instance of `HashMap<K, V>` becomes the core of our Java `PointsDictionary`
    class. Again, we name the private field `_points`, while our constructor instantiates
    the collection. You may note that we are not explicitly declaring types when we
    instantiate the `_points` collection. In Java, it is not necessary to explicitly
    declare types at instantiation when we have already defined the key and value
    types at declaration. You can declare the types if you really want to, but this
    will generate a warning in the compiler:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap<K, V>` 的实例成为我们 Java `PointsDictionary` 类的核心。再次强调，我们命名私有字段为 `_points`，而我们的构造函数实例化了集合。你可能注意到，当我们实例化
    `_points` 集合时，我们没有显式声明类型。在 Java 中，当我们已经在声明时定义了键和值类型时，实例化时不需要显式声明类型。如果你真的想声明类型，这将在编译器中生成警告：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `UpdateCustomerPoints(string customerName, int points)` method provides
    the core *update* functionality for our class. This method first confirms that
    the key exists in our collection. If the key does not exist, the method immediately
    returns `0`. Otherwise, we use `put()` and `get()` to update the key''s value.
    Using `get()` once again, we finally return the updated value to the caller:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateCustomerPoints(string customerName, int points)` 方法为我们这个类提供了核心的 *update*
    功能。该方法首先确认键是否存在于我们的集合中。如果键不存在，该方法立即返回 `0`。否则，我们使用 `put()` 和 `get()` 来更新键的值。再次使用
    `get()`，我们最终将更新后的值返回给调用者：'
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The two `RegisterCustomer()` methods provide the *add* functionality to our
    class. In both cases, we require a customer name to act as the key. If a returning
    customer is checking in with a previous balance, we want to acknowledge it so
    that our class overloads the method. Ultimately, the overloaded method calls `HashMap<K,
    V>.put(E)` to insert a new record into the collection:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两个 `RegisterCustomer()` 方法为我们这个类提供了 *add* 功能。在两种情况下，我们都需要一个客户名称作为键。如果一个返回的客户有之前的余额，我们希望承认这一点，以便我们的类重载该方法。最终，重载的方法调用
    `HashMap<K, V>.put(E)` 将新记录插入到集合中：
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our *get* functionality is introduced by the `GetCustomerPoints(string customerName)`
    method. In this method, we use the `get()` method, checking that the return value
    is not null, to safely confirm that the `customerName` key exists. Using a ternary
    operator, we return `0` if it does not or the value if it does:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *get* 功能是通过 `GetCustomerPoints(string customerName)` 方法引入的。在这个方法中，我们使用 `get()`
    方法，并检查返回值是否不为 null，以安全地确认 `customerName` 键是否存在。使用三元运算符，如果不存在则返回 `0`，如果存在则返回值：
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we come to the public update methods, `AddCustomerPoints(String customerName,
    int points)`, `RemoveÇustomerPoints(String customerName, int points)`, and `RedeemCustomerPoints(String
    customerName, int points)`. Each of these methods calls the private `UpdateCustomerPoints(String
    customerName, int points)` method, but first it negates `points` in the case of
    the latter two:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看公共更新方法，`AddCustomerPoints(String customerName, int points)`、`RemoveCustomerPoints(String
    customerName, int points)` 和 `RedeemCustomerPoints(String customerName, int points)`。这些方法中的每一个都会调用私有的
    `UpdateCustomerPoints(String customerName, int points)` 方法，但在后两种情况下，它首先会取反 `points`：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `CustomerCheckout(String customerName)` method introduces the collection''s
    *remove* functionality. The method first records the final value for the customer
    key and then calls `HashMap<K, V>.remove(E)` to delete the customer''s key from
    the collection. Finally, it returns the customer''s last point value to the caller:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomerCheckout(String customerName)` 方法引入了集合的 *remove* 功能。该方法首先记录客户键的最终值，然后调用
    `HashMap<K, V>.remove(E)` 从集合中删除客户的键。最后，它将客户的最后积分值返回给调用者：'
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `HashMap<K, V>` method conveniently provides the `containsKey()` method,
    which the `CustomerExists(String customerName)` method uses to introduce our class''
    *contains* functionality:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`HashMap<K, V>` 方法提供了一个方便的 `containsKey()` 方法，`CustomerExists(String customerName)`
    方法使用它来引入我们类的 *contains* 功能：'
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Using the `size()` field on the `HashMap<K, V>` class, `CustomersOnPremises()`
    provides the *count* functionality:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `HashMap<K, V>` 类的 `size()` 字段，`CustomersOnPremises()` 提供了 *count* 功能：
- en: '[PRE22]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Finally, per our business requirements, we need a way to remove all of the objects
    from the collection. The `ClosingTime()` method uses the `HashMap<K, V>.clear()`
    method to accomplish this task.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据我们的业务需求，我们需要一种方法来从集合中移除所有对象。`ClosingTime()` 方法使用 `HashMap<K, V>.clear()`
    方法来完成这项任务。
- en: '**Objective-C**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'For our Objective-C example, we will use the `NSMutableDictionary` class cluster
    to represent our collection. The `NSMutableDictionary` class cluster does not
    expose all of the basic operations we would expect to see in a concrete implementation
    of a dictionary, but those that are not readily available are very simple to replicate.
    It is important to note that Objective-C does not allow scalar values to be added
    to instances of the `NSDictionary` or `NSMutableDictionary` collections. Therefore,
    since we are trying to store integers for our values, we will have to place each
    of the `NSInteger` scalars in `NSNumber` wrappers before they can be added to
    the collection. Unfortunately, this adds some overhead to our implementation as
    all of these values must be boxed and unboxed as they are inserted or retrieved
    from the collection:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 Objective-C 示例，我们将使用 `NSMutableDictionary` 类簇来表示我们的集合。`NSMutableDictionary`
    类簇并没有暴露我们预期在字典的具体实现中看到的所有基本操作，但那些不直接可用的操作非常简单就可以复制。重要的是要注意，Objective-C 不允许将标量值添加到
    `NSDictionary` 或 `NSMutableDictionary` 集合的实例中。因此，由于我们试图存储整数作为值，我们必须在将它们添加到集合之前，将每个
    `NSInteger` 标量放入 `NSNumber` 包装器中。不幸的是，这给我们的实现增加了一些开销，因为所有这些值都必须在插入或从集合中检索时装箱和拆箱：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Using the class cluster `NSMutableDictionary`, we create an ivar for our class
    called `_points`. Our initializer instantiates this dictionary, giving us the
    underlying data structure to build our `PointsDictionary` class on:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类簇 `NSMutableDictionary`，我们为我们的类创建了一个名为 `_points` 的实例变量。我们的初始化器实例化了这个字典，为我们提供了构建
    `PointsDictionary` 类的基础数据结构：
- en: '[PRE24]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `updatePoints:forCustomer:` method provides the core *update* functionality
    for our class. This method first confirms that the key exists in our collection
    by calling our `customerExists:` method. If the key does not exist, the method
    immediately returns `0`. Otherwise, the method uses `objectForKey:` to get the
    stored `NSNumber` object. From this, we immediately extract the `NSInteger` value
    by calling `integerValue` on the object. Next, the value is adjusted and updated
    in the dictionary using `setValue:forKey:`. Using `objectForKey:` once again,
    we finally return the updated value to the caller:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePoints:forCustomer:` 方法为我们类提供了核心的 *update* 功能。该方法首先通过调用我们的 `customerExists:`
    方法来确认键是否存在于我们的集合中。如果键不存在，该方法立即返回 `0`。否则，该方法使用 `objectForKey:` 来获取存储的 `NSNumber`
    对象。从这个对象中，我们立即通过调用对象的 `integerValue` 来提取 `NSInteger` 值。接下来，值在字典中使用 `setValue:forKey:`
    调整并更新。再次使用 `objectForKey:`，我们最终将更新的值返回给调用者：'
- en: '[PRE25]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `registerCustomer:` methods provide the *add* functionality to our class.
    In both cases, we require a customer name to act as the key. If a returning customer
    is checking in with a previous balance, we want to acknowledge it so that our
    class overloads the method in `registerCustomer:withPreviousBalance:`. Ultimately,
    the overloaded method is calls `setObject:forKey:` to insert a new key/value pair
    into the dictionary:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerCustomer:` 方法为我们的类提供了 *添加* 功能。在两种情况下，我们都需要一个客户名称作为键。如果一个回头客在结账时带有之前的余额，我们希望确认这一点，以便我们的类在
    `registerCustomer:withPreviousBalance:` 中重载该方法。最终，重载的方法调用 `setObject:forKey:`
    将新的键/值对插入字典中：'
- en: '[PRE26]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Our *get* functionality is introduced by the `getCustomerPoints:` method. In
    this method, we use `objectForKey:` to get the `NSNumber` object for the passed
    key and assign it to `rawPoints`. Next, the method checks that `rawPoints` is
    not `nil` and returns `integerValue` of `rawPoints` if it is available, or 0 otherwise:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *获取* 功能是通过 `getCustomerPoints:` 方法引入的。在这个方法中，我们使用 `objectForKey:` 获取传递的键的
    `NSNumber` 对象，并将其分配给 `rawPoints`。接下来，该方法检查 `rawPoints` 是否不为 `nil`，如果可用，则返回 `rawPoints`
    的 `integerValue`，否则返回 0：
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, we come to the public update methods, `addPoints:toCustomer:`, `removePoints:fromCustomer:`
    and `redeemPoints:forCustomer:`. Each of these methods calls the private `updatePoints:forCustomer:`
    method, but first, it negates `points` in the case of the latter two:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看公共更新方法，`addPoints:toCustomer:`, `removePoints:fromCustomer:` 和 `redeemPoints:forCustomer:`。这些方法中的每一个都调用私有的
    `updatePoints:forCustomer:` 方法，但在后者两种情况下，它首先对 `points` 取反：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `customerCheckout:`, method introduces the collection''s *remove* functionality.
    The method first records the final value for the customer key, and then calls
    `removeObjectForKey:` to delete the customer''s key from the collection. Finally,
    it returns the customer''s last point value to the caller:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`customerCheckout:` 方法引入了集合的 *删除* 功能。该方法首先记录客户键的最终值，然后调用 `removeObjectForKey:`
    从集合中删除客户的键。最后，它将客户的最后积分值返回给调用者：'
- en: '[PRE29]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `NSMutableDictionary` class cluster does not provide a mechanism for determining
    whether a key exists in the collection. A simple workaround is to just call `objectForKey:`;
    and if the returned value is `nil`, the key does not exist, and `nil` evaluates
    to `NO`. Based on this principle, therefore, our `customerExists:` method simply
    returns `objectForKey:`, allowing the return value to be evaluated as a `BOOL`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSMutableDictionary` 类簇不提供一种机制来确定集合中是否存在键。一个简单的解决方案是直接调用 `objectForKey:`；如果返回的值是
    `nil`，则表示键不存在，`nil` 评估为 `NO`。基于这个原则，因此我们的 `customerExists:` 方法简单地返回 `objectForKey:`，允许返回值被评估为
    `BOOL`：'
- en: '[PRE30]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Using the `count` property on the `NSDictionary` class, `customersOnPremises`
    provides the *count* functionality:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NSDictionary` 类的 `count` 属性，`customersOnPremises` 提供了 *计数* 功能：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Finally, as per our business requirements, we need a way to remove all of the
    objects from the collection. The `closingTime` method uses the `removeAllObjects`
    method to accomplish this task.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据我们的业务需求，我们需要一种方法来从集合中删除所有对象。`closingTime` 方法使用 `removeAllObjects` 方法来完成这项任务。
- en: '**Swift**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Swift provides the `Dictionary` class which, like Objective-C''s `NSMutableDictionary`,
    does not expose all of the operations we would expect to see in a concrete implementation
    of a dictionary data structure. Again, these missing functions are simple to replicate.
    It is worth noting the difference between the Swift dictionary''s value type and
    its Objective-C counterpart. Since primitives in Swift are wrapped in `structs`,
    we have no problem adding `Int` objects to our collection:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供的 `Dictionary` 类，与 Objective-C 的 `NSMutableDictionary` 类一样，并不暴露我们在字典数据结构的具体实现中期望看到的所有操作。同样，这些缺失的功能很容易复制。值得注意的是
    Swift 字典的值类型与其 Objective-C 对应类型之间的区别。由于 Swift 中的原始类型被包装在 `structs` 中，我们可以毫无问题地将
    `Int` 对象添加到我们的集合中：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Using the `Dictionary` class, we create a private property for our class called
    `_points`. Since our property is declared and instantiated simultaneously and
    there is no other custom code requiring instantiation, we can exclude the explicit
    public initializer and rely on the default initializer:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Dictionary` 类，我们为我们的类创建了一个私有属性，称为 `_points`。由于我们的属性是声明和实例化同时进行的，且没有其他自定义代码需要实例化，我们可以排除显式的公共初始化器，并依赖于默认初始化器：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `updatePointsForCustomer()` method provides the core *update* functionality
    for our class. This method first confirms that the key exists in our collection
    by calling our `customerExists()` method. If the key does not exist, the method
    immediately returns `0`. Otherwise, the method uses subscript notation to get
    the stored value. Next, the value is adjusted and updated in the dictionary, again
    using subscript notation. Finally, we return the updated value to the caller:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`updatePointsForCustomer()` 方法为我们类的核心 *更新* 功能提供支持。该方法首先通过调用我们的 `customerExists()`
    方法来确认键是否存在于我们的集合中。如果键不存在，该方法立即返回 `0`。否则，该方法使用下标符号来获取存储的值。接下来，该值在字典中进行调整和更新，同样使用下标符号。最后，我们将更新后的值返回给调用者：'
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `registerCustomer()` methods provide the *add* functionality to our class.
    In both cases, we require a customer name to act as the key. If a returning customer
    checks in with a previous balance, we want to acknowledge it so that our class
    overloads the method in `registerCustomerWithPreviousBalance()`. Ultimately, the
    overloaded method uses subscript notation to insert a new key/value pair into
    the dictionary:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`registerCustomer()` 方法为我们类提供了 *添加* 功能。在两种情况下，我们都需要一个客户名称作为键。如果返回的客户带有之前的余额登记入住，我们希望承认这一点，以便我们的类在
    `registerCustomerWithPreviousBalance()` 中重载该方法。最终，重载的方法使用下标符号将新的键/值对插入到字典中：'
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Our *get* functionality is introduced by the `getCustomerPoints()` method.
    In this method, we use subscript notation to get the value for our key, but then
    we confirm the return value is not `nil` before returning the value. If the value
    is not `nil`, our method returns the value; otherwise, it returns `0`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 *获取* 功能是通过 `getCustomerPoints()` 方法引入的。在这个方法中，我们使用下标符号来获取键的值，但在返回值之前，我们确认返回值不是
    `nil`。如果值不是 `nil`，我们的方法返回该值；否则，它返回 `0`：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Next, we come to the public update methods, `addPointsToCustomer()`, `removePointsFromCustomer()`,
    and `redeemPointsForCustomer()`. Each of these methods calls the private `updatePointsForCustomer()`
    method, but first, it negates `points` in the case of the latter two:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看公共更新方法，`addPointsToCustomer()`、`removePointsFromCustomer()` 和 `redeemPointsForCustomer()`。这些方法中的每一个都调用私有的
    `updatePointsForCustomer()` 方法，但在调用之前，它对后两种情况下的 `points` 进行取反：
- en: '[PRE37]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `customerCheckout()` method introduces the collection''s *remove* functionality.
    The method first records the final value for the customer key, and then calls
    `removeObjectForKey:` to delete the customer''s key from the collection. Finally,
    it returns the customer''s last point value to the caller:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`customerCheckout()` 方法引入了集合的 *移除* 功能。该方法首先记录客户键的最终值，然后调用 `removeObjectForKey:`
    从集合中删除客户的键。最后，它将客户的最后积分值返回给调用者：'
- en: '[PRE38]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Similar to `NSMutableDictionary`, `Dictionary` does not provide a mechanism
    for determining whether a key exists in the collection. Luckily, our workaround
    from Objective-C works just fine in Swift as well. Our method uses subscript notation,
    and if the returned value is `nil`, the key does not exist, and `nil` evaluates
    to `false`. Based on this principle, therefore, our `customerExists()` method
    simply returns `_points[cusrtomerName]`, allowing the return value to be evaluated
    as `Bool`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `NSMutableDictionary` 类似，`Dictionary` 不提供一种机制来确定集合中是否存在键。幸运的是，我们的 Objective-C
    中的解决方案在 Swift 中同样适用。我们的方法使用下标符号，如果返回的值是 `nil`，则键不存在，`nil` 评估为 `false`。因此，基于这个原则，我们的
    `customerExists()` 方法简单地返回 `_points[cusrtomerName]`，允许返回值被评估为 `Bool`：
- en: '[PRE39]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Using the `count` property on the `Dictionary` class, `customersOnPremises()`
    provides the *count* functionality:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Dictionary` 类的 `count` 属性，`customersOnPremises()` 提供了 *计数* 功能：
- en: '[PRE40]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, per our business requirements we need a way to remove all of the objects
    from the collection. The `closingTime()` method uses the `Dictionary.removeAll()`
    method to accomplish this task.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，根据我们的业务需求，我们需要一种方法来从集合中移除所有对象。`closingTime()` 方法使用 `Dictionary.removeAll()`
    方法来完成这项任务。
- en: Advanced topics
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题
- en: 'Now that we have examined how dictionaries are used in common applications,
    we should take some time to examine how dictionaries are implemented under the
    hood. The majority of dictionaries come in two distinct flavors: hash table based
    and search tree based. Although the mechanics of the two approaches are similar,
    and they typically share many of the same methods and functionality, the inner
    workings and ideal applications for each type are very different.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经考察了字典在常见应用中的使用方式，我们应该花些时间来探讨字典在底层是如何实现的。大多数字典分为两种不同的类型：基于哈希表和基于搜索树。尽管这两种方法的机制相似，并且它们通常共享许多相同的方法和功能，但每种类型的内部工作原理和理想应用却非常不同。
- en: Hash table based dictionaries
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于哈希表的字典
- en: The most common implementation of a dictionary is the **hash table based** associative
    array. When properly implemented, the hash table approach is extremely efficient
    and allows for **O**(1) complexity searches, inserts, and deletes. In each of
    the languages we are examining, the basic dictionary classes are based on hash
    tables by default. The general concept of a hash table based dictionary is that
    mapping for a specified key is stored at an index of an array, where the index
    is obtained by applying a hash function to the key. Callers then examine the same
    index of the array for the specified key and use the binding that is stored there
    to retrieve the value of the element.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 字典最常见的一种实现方式是基于哈希表的关联数组。当正确实现时，哈希表方法非常高效，允许进行**O**(1)复杂度的搜索、插入和删除操作。在我们考察的每种语言中，基本的字典类默认都是基于哈希表的。基于哈希表的字典的一般概念是，指定键的映射存储在数组的索引中，该索引是通过将哈希函数应用于键获得的。调用者随后检查数组中相同索引处的指定键，并使用存储在该处的绑定来检索元素的值。
- en: Hash table based dictionaries have one drawback, the hash function has the potential
    to create **collisions**, or it can sometimes attempt to map two keys to the same
    index. Therefore, hash table based implementations must have a mechanism in place
    to resolve these conflicts. Many **collision resolution strategies** exist, but
    the details of these are beyond the scope of this text.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 基于哈希表的字典有一个缺点，即哈希函数有可能产生**冲突**，或者有时会尝试将两个键映射到相同的索引。因此，基于哈希表的实现必须有一种机制来解决这个问题。存在许多**冲突解决策略**，但这些细节超出了本文的范围。
- en: Search tree based dictionaries
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于搜索树的字典
- en: 'A less common implementation of a dictionary is the **search tree based** associative
    array. Dictionaries based on search trees are well suited to sorting keys and
    values by some criteria or property of the value, plus they can be built to work
    more efficiently with custom key or value types. Another advantage of a search
    tree based implementation is the addition of operations beyond the basic functions
    described earlier, such as the ability to find a mapping whose key is similar
    to a specified key. These advantages come at a price, however, in that, the basic
    operations in search tree based implementations have a higher cost, while the
    collections themselves are more restrictive on the types of data they can work
    with. Sorting operations relating to search tree based dictionaries will be discussed
    in more detail in [Chapter 12](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 12. Sorting: Bringing Order Out Of Chaos"), *Sorting: Bringing Order
    Out Of Chaos*.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字典较少见的实现方式是基于搜索树的关联数组。基于搜索树的字典非常适合按某些标准或值的属性对键和值进行排序，并且可以构建以更高效地处理自定义键或值类型。基于搜索树的实现的一个优点是增加了超出先前描述的基本函数的操作，例如找到与指定键相似的映射的能力。然而，这些优点是有代价的，因为基于搜索树的实现的基本操作成本更高，而集合本身对可以处理的数据类型有更严格的限制。有关基于搜索树的字典的排序操作将在[第12章](part0069_split_000.html#21PMQ2-77f2b5b248f04368a6f723b0e9357ef3
    "第12章。排序：从混乱中带来秩序")*排序：从混乱中带来秩序*中更详细地讨论。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned the basic definition of the dictionary, or associative
    array, data structure. You learned how to initialize dictionaries, and we examined
    the hash table data structure upon which most concrete dictionary implementations
    are based. We discussed the various common operations found in dictionaries, including
    their operational costs. Following this, we examined a case study where dictionaries
    would be very beneficial. Finally, we looked at two varying implementations of
    dictionaries, including the hash table based dictionary and the search tree based
    dictionary.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了字典或关联数组的基
