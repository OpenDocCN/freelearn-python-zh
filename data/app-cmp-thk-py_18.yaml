- en: '*Chapter 15*: Applied Computational Thinking Problems'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第15章*：应用计算思维问题'
- en: 'In this chapter, we will be providing examples in multiple areas for applications
    of the Python programming language and computational thinking. We will be exploring
    multiple areas, such as humanities, linguistics, cryptography, and more. We will
    use what we''ve learned so far about **computational thinking** and the **Python**
    programming language to do the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将提供多个领域的Python编程语言和计算思维应用示例。我们将探索多个领域，如人文学科、语言学、密码学等。我们将利用我们迄今为止学到的关于**计算思维**和**Python**编程语言的知识来做以下事情：
- en: Analyze historical speeches
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析历史演讲
- en: Write stories
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写故事
- en: Calculate text readability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算文本可读性
- en: Find the most efficient route
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到最有效的路线
- en: Implement cryptography
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现密码学
- en: Implement cybersecurity
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现网络安全
- en: Create a chatbot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建聊天机器人
- en: This chapter is unlike the others, as we will be focused exclusively on presenting
    the problems and providing algorithmic solutions after evaluating each scenario.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这一章与其他章节不同，因为我们将专注于提出问题并在评估每种情况后提供算法解决方案。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need the latest version of Python installed to run the code in this
    chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装最新版本的Python才能运行本章中的代码。
- en: 'You will need the following libraries and packages installed for Python:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要为Python安装以下库和软件包：
- en: '**NLTK**'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NLTK**'
- en: '**Cairos**'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cairos**'
- en: '**Pandas**'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pandas**'
- en: '**Matplotlib**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Matplotlib**'
- en: '**Seaborn**'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Seaborn**'
- en: 'You can find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter15](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter15)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章中使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter15](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter15)
- en: Problem 1 – Using Python to analyze historical speeches
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题1 - 使用Python分析历史演讲
- en: History is quite fascinating, and there are many reasons why we would look at
    writing algorithms to evaluate historical data and contexts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 历史非常迷人，我们有很多原因要编写算法来评估历史数据和背景。
- en: For this problem, we want to analyze some historical text. In particular, we
    are going to take a look at *Abraham Lincoln's second inaugural speech*. Our goal
    is to find some frequencies of words. There are many reasons why we'd want to
    perform some straightforward text analysis, especially for historical texts. We
    may want to compare them, understand underlying themes, and so on.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们想要分析一些历史文本。特别是，我们将研究*亚伯拉罕·林肯的第二次就职演讲*。我们的目标是找到一些单词的频率。有很多原因我们想要进行一些简单的文本分析，特别是对于历史文本。我们可能想要进行比较，了解潜在的主题等等。
- en: For our algorithm, we are going to use a fairly simple design using the `nltk`
    package. Because the installation of some of the components is a bit different
    to what we've done so far, we'll provide some information in case your packages
    have not been installed.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的算法，我们将使用`nltk`包的一个相当简单的设计。由于一些组件的安装与我们迄今为止所做的有些不同，我们将提供一些信息，以防您的软件包尚未安装。
- en: In the Python shell, if you are in the active console, create a new file and
    import `nltk` after installing the main package (using `pip install nltk`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python shell中，如果您在活动控制台中，创建一个新文件并在安装主要软件包后导入`nltk`（使用`pip install nltk`）。
- en: 'Please note you should not be in the active **Shell** window. If you see `>>>`
    at the beginning of the line, click the **File** | **New File** option and then
    enter the following code instruction line for your empty shell:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您不应该在活动的**Shell**窗口中。如果您在行首看到`>>>`，请单击**文件** | **新建文件**选项，然后输入以下代码指令行以创建空的shell：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Notice from the preceding code that you''ll also open the downloader in `nltk`.
    The preceding code will bring up a window as shown in the following screenshot
    (please note that the `nltk` library takes approximately 7 MB of memory, while
    installing the additional packages will require memory as well, with each ranging
    from a few KB to 14 to 15 MB):'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，您还将在`nltk`中打开下载器。前面的代码将弹出一个窗口，如下面的屏幕截图所示（请注意，`nltk`库大约需要7MB的内存，而安装额外的软件包也需要内存，每个软件包的范围从几KB到14到15MB不等）：
- en: '![Figure 15.1 – NLTK Downloader'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.1 - NLTK下载器'
- en: '](image/Figure_15.01_B15413.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.01_B15413.jpg)'
- en: Figure 15.1 – NLTK Downloader
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1 - NLTK下载器
- en: As you can see, my packages are all installed. If yours are not, select **all**,
    and then click the **Download** button at the bottom left-hand corner of that
    window. Once the packages are installed, you can close the window.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我的软件包都已安装。如果您的软件包尚未安装，请选择**全部**，然后单击该窗口左下角的**下载**按钮。软件包安装完成后，您可以关闭该窗口。
- en: 'Because our problem is fairly simple, we''ll skip much of the computational
    thinking process for this particular section. We are only trying to get frequencies
    of words used in the speech. So let''s dive directly into the algorithm and see
    how we''ll use the `nltk` package to get what we need, including a visual representation
    of the data:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的问题相当简单，所以我们将跳过这个特定部分的大部分计算思维过程。我们只是试图获得演讲中使用的单词的频率。所以让我们直接进入算法，看看我们将如何使用`nltk`包来获得我们需要的内容，包括数据的可视化表示：
- en: First, we'll need to import `nltk` and the `word_tokenize` function. The `word_tokenize`
    function allows us to divide the speech into individual words and/or punctuation
    marks. We'll need the speech text. In this case, the speech is copied into the
    algorithm. You could potentially import the file into the algorithm and do it
    that way.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要导入`nltk`和`word_tokenize`函数。`word_tokenize`函数允许我们将演讲分成单个单词和/或标点符号。我们需要演讲文本。在这种情况下，演讲被复制到算法中。您也可以将文件导入算法并以这种方式进行操作。
- en: The `sent_tokenize` function is short for sentence tokenization. In the same
    way as word tokenization breaks down the text by words and punctuation marks,
    the sentence tokenization function allows breaking the text into full sentences.
    The output would contain sentences in a list separated by commas.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`sent_tokenize` 函数是句子标记化的缩写。与单词标记化类似，句子标记化函数允许将文本分成完整的句子。输出将包含一个由逗号分隔的句子列表。'
- en: 'Important Note:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: It is important to know that all quotation marks have been escaped using `\'`
    or `\"`, respectively, in order to maintain the original text without creating
    an error in our code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道，所有引号都已经使用 `\'` 或 `\"` 进行了转义，以保持原始文本而不在我们的代码中创建错误。
- en: 'The following algorithm contains everything we need in order to do the analysis
    of Abraham Lincoln''s second inaugural speech:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下算法包含了我们需要的一切，以便分析亚伯拉罕·林肯的第二次就职演说：
- en: ch15_historicalTextAnalysis.py
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ch15_historicalTextAnalysis.py
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The entire text of the speech is contained in the GitHub repository file. For
    length purposes, we''ve only included half of that text here. Please note that
    the output we''ll share after the algorithm and explanations will correspond to
    the truncated speech, but the visual plot will include the data from the entire
    speech. The `[…]`, seen in the following code at the end of the `text` definition,
    is simply used to show that there is additional text that goes there:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 演讲的整个文本包含在GitHub存储库文件中。出于长度目的，我们在这里只包含了其中一半的文本。请注意，我们将在算法和解释之后分享的输出将对应于截断的演讲，但可视化图将包含整篇演讲的数据。在
    `text` 定义的末尾看到的 `[…]` 仅用于显示那里有额外的文本。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now that we''ve defined the text that we want analyzed, as shown in the preceding
    code snippet, we can tell the algorithm that we want to *tokenize* the text, that
    is, we want it divided into words. The algorithm will print out a list that contains
    each individual word or punctuation symbol separated by a comma, as shown in the
    following code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们想要分析的文本，如前面的代码片段所示，我们可以告诉算法我们想要对文本进行*标记化*，也就是说，我们希望将其分成单词。算法将打印出一个包含每个单词或标点符号的列表，用逗号分隔，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After we have our list of words, we want to get the frequency distribution
    of the words. To do so, we''ll import the package from `nltk.probability`, as
    shown in the following code snippet:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们有了单词列表之后，我们想要得到单词的频率分布。为此，我们将从 `nltk.probability` 导入包，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Once we have the distribution, we''ll want a visual plot of this data, so we''ll
    use `matplotlib` to create our distribution plot, as shown in the following code
    snippet:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了分布，我们就希望得到这些数据的可视化图表，因此我们将使用 `matplotlib` 来创建我们的分布图，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That''s the entire algorithm we''ll need. When we run the algorithm, this is
    what our output looks like:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要的整个算法。当我们运行算法时，我们的输出如下：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Recall that `word tokenization` only included the truncated text. However,
    the frequency information and the plot that follow are for the entire speech.
    The `ch15_historicalTextAnalysis.py` GitHub file includes the full speech:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请回想一下，`单词标记化` 只包括了截断的文本。然而，随后的频率信息和图表是针对整篇演讲的。`ch15_historicalTextAnalysis.py`
    GitHub 文件包含了完整的演讲：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following screenshot shows the frequency distribution visual plot for this
    algorithm:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕截图显示了该算法的频率分布可视化图：
- en: '![Figure 15.2 – Frequency distribution plot for Abraham Lincoln''s second inaugural
    address'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.2 - 亚伯拉罕·林肯第二次就职演说的频率分布图'
- en: '](image/Figure_15.02_B15413.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.02_B15413.jpg)'
- en: Figure 15.2 – Frequency distribution plot for Abraham Lincoln's second inaugural
    address
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2 - 亚伯拉罕·林肯第二次就职演说的频率分布图
- en: Once we have this information, we can start to look more closely at the words
    that were used most frequently. When working with this kind of analysis, you may
    want to consider removing some of the words, such as **to**, **a**, and **the**,
    as they would be irrelevant to our analysis. However, words such as **years**
    and **Union** may be relevant to our analysis.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这些信息，我们就可以开始更仔细地查看最常用的单词。在进行这种分析时，您可能希望考虑删除一些单词，比如**to**、**a**和**the**，因为它们对我们的分析没有意义。但是，像**years**和**Union**这样的单词可能与我们的分析相关。
- en: There are many adjustments that can be made for this algorithm, but for now,
    we've managed to at least get a frequency distribution plot for a historical speech.
    Now, we'll move on to the next problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法可以进行许多调整，但目前，我们至少已经成功为一个历史演讲制作了一个频率分布图。现在，我们将继续下一个问题。
- en: Problem 2 – Using Python to write stories
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题2 - 使用Python编写故事
- en: Let's look at a fairly simple problem. In this section, we want to create an
    algorithm that produces a story based on input from a user. We can make this as
    simple as we want, or add some options. But let's dig into what this is.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个相当简单的问题。在这一部分，我们想要创建一个基于用户输入的算法来生成一个故事。我们可以尽可能简单，或者添加一些选项。但让我们深入了解一下这是什么。
- en: Defining, decomposing, and planning a story
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义、分解和规划故事
- en: 'First of all, *what is it we''re trying to create?* Well, a story. Because
    of the nature of this problem, we''re going to start in reverse, with a sample
    of the output we want to achieve, that is, a sample story. Let''s take a look
    at a quick story generated by our algorithm before we actually get into the algorithm:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*我们要创造什么？* 好吧，一个故事。由于这个问题的性质，我们将从反向开始，用我们想要实现的输出样本开始，也就是一个样本故事。在我们真正进入算法之前，让我们先看一下我们的算法生成的一个快速故事：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding output was created by an algorithm that substituted names, locations,
    time of day, pet, and pet name. It's a short story, but this is something that
    can be used in much wider applications, such as using input to write social media
    posts, and filling in information for things such as invitations, forms, and more.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出是由一个算法创建的，该算法替换了名字、地点、时间、宠物和宠物名字。这是一个简短的故事，但这是可以在更广泛的应用中使用的东西，比如使用输入来撰写社交媒体帖子，并为邀请、表格等填写信息。
- en: So let's work backward a bit to write our algorithm. *And why did I start at
    the end this time?* Well, in this case, we know what we want from the end result.
    You could write your story. You could have an example of that wedding invitation
    template you need to fill in, or the form. Now we have to figure out how to get
    the input and then output what we wanted.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们倒退一点来编写我们的算法。*为什么这次我从结尾开始呢？*嗯，在这种情况下，我们知道我们想要的结果。您可以编写您的故事。您可以有一个需要填写的婚礼邀请模板的示例，或者表格。现在我们必须弄清楚如何获取输入，然后输出我们想要的内容。
- en: 'From the story shown, here are the things we can get original input for:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从所示的故事中，这是我们可以获得原始输入的事情：
- en: Character name
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色的名字
- en: Town name
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 城镇名称
- en: Type of pet
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宠物的类型
- en: Name of pet
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宠物的名字
- en: Part of town visited
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参观的城镇的一部分
- en: Time of day
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一天中的时间
- en: Favorite color
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 喜欢的颜色
- en: 'When we write our algorithm, we''ll need to get all the aforementioned inputs.
    Let''s take a look at the algorithm found in the `ch15_storyTime.py` file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写我们的算法时，我们需要获取所有上述输入。让我们来看看`ch15_storyTime.py`文件中的算法：
- en: 'We will need inputs from the user, so we want to use a `print` statement and
    input requests that include instructions for what is needed:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要用户的输入，所以我们想使用一个`print`语句和包含所需指令的输入请求：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding code snippet grabs all the inputs from the user so we can write
    our story.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段从用户那里获取所有输入，这样我们就可以写我们的故事了。
- en: 'Once we have those, we have to `print` our story. Notice that we wrote it in
    simple terms, using `%s` so we could replace it with the corresponding inputs.
    We also used backslashes so that we can see our code on multiple lines, rather
    than have it in one long line:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了这些，我们就必须`print`我们的故事。请注意，我们用简单的术语写了它，使用`％s`，这样我们就可以用相应的输入替换它。我们还使用反斜杠，这样我们就可以在多行上看到我们的代码，而不是将其放在一行上：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s run that code one more time and see what our story says now:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次运行那段代码，看看我们的故事现在说了什么：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that details such as character and settings have changed. In an education
    learning environment, such a simple algorithm can be a great tool for showing
    students how to interact with stories and identify key information in them.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，角色和设置等细节已经发生了变化。在教育学习环境中，这样一个简单的算法可以成为一个很好的工具，用来向学生展示如何与故事互动并识别其中的关键信息。
- en: While this is a three-sentence story, these algorithms can be much more complex,
    providing an opportunity to write fantastic original stories with user input.
    If you wanted to try some of this out, you could even put conditions for which
    phrases you would use based on some of the input, such as changing the sentences
    used based on the length of the name entered, for example. *Have some fun with
    the code and writing some stories!*
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个三句故事，但这些算法可以更加复杂，为用户输入提供了编写出色原创故事的机会。如果您想尝试一些内容，甚至可以根据一些输入条件更改使用的短语，例如根据输入的名称长度更改使用的句子。*用代码和写一些故事来玩一玩吧！*
- en: Problem 3 – Using Python to calculate text readability
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题3-使用Python计算文本可读性
- en: In this section, we'll look at an application relating to linguistics, specifically
    the readability level of any text. We will be using Martin Luther King's **I Have
    a Dream** speech in the code snippets that follow. You can substitute this for
    any text file, so long as you change the location of the file and filename to
    be accurately reflected in the code. The full code can be found in the `ch15_Readability.py`
    file.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将看一个与语言学相关的应用，具体来说是任何文本的可读性水平。我们将在接下来的代码片段中使用马丁·路德·金的**我有一个梦**演讲。您可以用任何文本文件替换它，只要您在代码中准确反映文件和文件名的位置。完整的代码可以在`ch15_Readability.py`文件中找到。
- en: Before we get into the code, let's talk first about what we're looking for and
    why it's important. Learning about the readability of texts can help us make decisions
    about whether or not to include them in a presentation, a school grade level,
    and much more. The **Flesch-Kincaid score** is used to determine readability and
    was developed in the 1940s.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入代码之前，让我们先谈谈我们要寻找的内容以及为什么它很重要。了解文本的可读性可以帮助我们决定是否将其包含在演示文稿中，学校年级水平等等。**弗莱施-金凯德分数**用于确定可读性，并于1940年代开发。
- en: Rudolf Flesch created it when working as a consultant with the Associated Press
    in an effort to improve the readability of newspapers. Originally called the **Flesch
    Reading Ease**, it was modernized into what is currently used by the US Navy.
    Rather than getting a score that then had to be converted into a grade level,
    the Flesch-Kincaid score now provides a grade-level score.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Rudolf Flesch在与美联社合作期间创建了它，以改善报纸的可读性。最初被称为**弗莱施阅读易度**，它被现代化为目前美国海军使用的形式。现在，弗莱施-金凯德分数提供了一个年级水平分数，而不是得到一个分数，然后必须将其转换为年级水平。
- en: 'While we won''t be using the formula, it is important to know the background
    of what we''re using. The Flesch Reading Ease formula is given by the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会使用这个公式，但了解我们使用的背景很重要。弗莱施阅读易度公式如下：
- en: '![](image/Formula_B15413_15_001.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_15_001.jpg)'
- en: 'The Flesch-Kincaid grade-level formula is given by the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 弗莱施-金凯德年级公式如下：
- en: '![](image/Formula_B15413_15_002.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](image/Formula_B15413_15_002.jpg)'
- en: The thing about the preceding formulas is that they exist in the readability
    package available for Python. If we import the package, we are able to perform
    a readability analysis with a fairly simple bit of code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的公式的事实是，它们存在于Python可用的可读性包中。如果我们导入这个包，我们就能用一小段相当简单的代码进行可读性分析。
- en: 'Let''s take a look at the code we''ll need in order to perform a readability
    analysis for the Martin Luther King speech:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看我们需要执行马丁·路德·金演讲的可读性分析所需的代码：
- en: 'Firstly, remember to change the path for your file in the code and then import
    the necessary packages for the code:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，记得在代码中更改文件的路径，然后导入代码所需的必要包：
- en: ch15_readability.py
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ch15_readability.py
- en: '[PRE12]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: From the preceding code, you'll see that we imported the `readability` package
    into our program. If you need to install the library/package, you can use `pip
    install readability` to do so.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，您会看到我们将`readability`包导入到我们的程序中。如果您需要安装库/包，可以使用`pip install readability`来安装。
- en: Once we have the requisite libraries, we can open the file we want to analyze.
    We also want to tell the algorithm to read the text, which I've called `text_up`
    here for text upload, so I don't forget that I am reading an open file. This is
    the text we've opened from the file location in the preceding code. Finally, we
    ask the program to analyze the text using the `Readability` function. Notice that
    we saved that to `r`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了必要的库，我们就可以打开要分析的文件。我们还希望告诉算法读取文本，我在这里称之为`text_up`，以便上传文本，这样我就不会忘记我正在读取一个打开的文件。这是我们从前面的代码中打开的文本。最后，我们要求程序使用`Readability`函数分析文本。请注意，我们将其保存到`r`中。
- en: 'After we''ve done all of that, we can `print` our grade level with the following
    code snippet:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们完成所有这些之后，我们可以使用以下代码片段`print`我们的年级水平：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we run our algorithm, our output is fairly simple as well. Take a look
    at the following output:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行我们的算法时，输出也是非常简单的。看一下以下输出：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now that you know how to verify the readability of any text, try to perform
    the analysis on other types of texts, including poems, stories, speeches, songs,
    and more.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何验证任何文本的可读性，尝试对其他类型的文本执行分析，包括诗歌、故事、演讲、歌曲等。
- en: Problem 4 – Using Python to find most efficient route
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题4 - 使用Python找到最有效的路线
- en: For this problem, when learning about algorithms, we will use a common algorithm—the
    **Travelling Salesman Problem** (**TSP**). Let's set up the problem itself.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，在学习算法时，我们将使用一个常见的算法——**旅行推销员问题**（**TSP**）。让我们来设置问题本身。
- en: A salesman needs to travel to a set number of cities or locations. Let's say
    the salesman has 10 locations to go to. They could go to those 10 locations in
    a lot of different orders. Our goal with this algorithm is to create the best
    possible, most efficient route to hit those locations.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一个推销员需要前往一定数量的城市或地点。假设推销员有10个地点要去。他们可以以许多不同的顺序去这10个地点。我们这个算法的目标是创建最佳的、最有效的路线，以到达这些地点。
- en: Note that for this particular scenario, as we will do in the next problem, we'll
    employ straightforward analysis by using the four elements of the computational
    thinking process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于这种特定情况，就像我们将在下一个问题中所做的那样，我们将使用计算思维过程的四个元素进行简单的分析。
- en: Defining the problem (TSP)
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义问题（TSP）
- en: This problem is a little more complex than how it appears initially. Think of
    it this way. If we have 10 destinations and we are calculating round-trip permutations
    to check the fastest routes, we're left with more than 300,000 possible permutations
    and combinations. As a reminder, a permutation takes order into consideration,
    while a combination does not.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题比起最初的样子要复杂一些。可以这样想。如果我们有10个目的地，我们正在计算往返排列以检查最快的路线，我们将得到超过300,000个可能的排列和组合。提醒一下，排列考虑顺序，而组合则不考虑。
- en: For example, the numbers *3344* and *3434* are two different permutations. However,
    they are only counted as one combination because the order of the numbers does
    not matter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数字*3344*和*3434*是两种不同的排列。但是，它们只被计为一种组合，因为数字的顺序并不重要。
- en: 'But back to our problem. All we need to know is that we want to create an algorithm
    that will take us to our destinations in the most efficient way. We have to identify
    the cities to be visited and identify the way we''ll travel as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 但回到我们的问题。我们只需要知道我们想要创建一个算法，以最有效的方式带我们到达目的地。我们必须确定要访问的城市，并确定我们将如何旅行。
- en: There are five cities in total, namely, **New York** (**NYC**), **Philadelphia**,
    **Baltimore**, **Chicago**, and **Cleveland**.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总共有五个城市，分别是**纽约**（**NYC**）、**费城**、**巴尔的摩**、**芝加哥**和**克利夫兰**。
- en: We will use one vehicle because we're using TSP instead of a **vehicle routing
    problem** (**VRP**).
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用一辆车，因为我们使用的是TSP而不是**车辆路径问题**（**VRP**）。
- en: The first city is 0, which is NYC. The distance between NYC and itself is 0.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个城市是0，也就是纽约。纽约和自身之间的距离是0。
- en: Now let's look at the pattern.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下模式。
- en: Recognizing the pattern (TSP)
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别模式（TSP）
- en: For each city, there will be a total of five distances, with the distance to
    itself equal to 0\. We are going to need an array, or lists, for all the distances
    for each city. We will need to create a model in order to access the data in our
    algorithm. We'll look at that while designing the algorithm. First, let's talk
    about generalizing the pattern a bit.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个城市，将有五个距离，到自身的距离等于0。我们将需要一个数组或列表，用于存储每个城市的所有距离。我们需要创建一个模型，以便在我们的算法中访问数据。我们将在设计算法时进行讨论。首先，让我们稍微概括一下模式。
- en: Generalizing (TSP)
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概括（TSP）
- en: For this particular problem, we'll enter the cities manually into the algorithm
    itself. One thing you may want to consider is how to get input from a user in
    order to create the arrays necessary with the distances.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的问题，我们将手动将城市输入到算法中。您可能需要考虑的一件事是如何从用户那里获取输入，以便创建必要的包含距离的数组。
- en: You could also create a database for the distances between major cities that
    you can access from a `.csv` file so that the data for cities that a person inputs
    can be found there, which can then be added to our model. There are many additions
    to this particular algorithm and this isn't a problem that can be solved in just
    one way. For now, we're going to stay with a defined set of cities so that we
    can create our algorithm.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建一个数据库，记录主要城市之间的距离，可以从`.csv`文件中访问，这样输入的城市数据可以在其中找到，然后添加到我们的模型中。对于这个特定算法，有许多补充，这不是一个只有一种解决方法的问题。现在，我们将使用一组定义好的城市，以便创建我们的算法。
- en: As an aside, we have referred to the source code from [https://developers.google.com/optimization/routing/tsp](https://developers.google.com/optimization/routing/tsp)
    for this problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们已经参考了来自[https://developers.google.com/optimization/routing/tsp](https://developers.google.com/optimization/routing/tsp)的源代码。
- en: Designing the algorithm (TSP)
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计算法（TSP）
- en: 'It''s time to see what we''ve been talking about. Let''s start with NYC and
    construct that array first. The other arrays are created in the same way. All
    distances are in miles and have been approximated and rounded based on **Google
    Maps** data, given as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候看看我们一直在谈论的东西了。让我们从纽约开始，首先构建那个数组。其他数组以相同的方式创建。所有距离都是以英里为单位，并根据**Google Maps**的数据进行了近似和四舍五入，如下所示：
- en: Distance from NYC to NYC is 0.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从纽约到纽约的距离是0。
- en: Distance from NYC to Philadelphia is 95.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从纽约到费城的距离是95。
- en: Distance from NYC to Baltimore is 192.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从纽约到巴尔的摩的距离是192。
- en: Distance from NYC to Chicago is 789.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从纽约到芝加哥的距离是789。
- en: Distance from NYC to Cleveland is 462.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从纽约到克利夫兰的距离是462。
- en: 'The following table shows the distances from each city to each other and itself:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了每个城市到其他城市及其自身的距离：
- en: '![Table 15.1 – Distances from one city to another'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '![表15.1 - 从一个城市到另一个城市的距离'
- en: '](image/Table_15.1.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Table_15.1.jpg)'
- en: Table 15.1 – Distances from one city to another
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 表15.1 - 从一个城市到另一个城市的距离
- en: 'So, as you can in the preceding table, if we were to write these distances
    as an array, we would use the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如您在上表中所见，如果我们将这些距离写成一个数组，我们将使用以下代码：
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For Philadelphia, we would have the following array:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于费城，我们将有以下数组：
- en: '[PRE16]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For Baltimore, we would have the following array:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于巴尔的摩，我们将有以下数组：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For Chicago, we would have the following array:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于芝加哥，我们将有以下数组：
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And finally, for Cleveland, we would have the following array:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于克利夫兰，我们将有以下数组：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that we will give indexes to each of the cities in order to identify them.
    NYC is *0*, Philadelphia is *1*, Baltimore is *2*, Chicago is *3*, and Cleveland
    is *4*. Let''s see what the algorithm looks like for this problem (note that the
    **OR-Tools library** is used to optimize vehicle routes, linear programming, constraint
    programming, and more):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们将为每个城市分配索引以便识别它们。纽约是*0*，费城是*1*，巴尔的摩是*2*，芝加哥是*3*，克利夫兰是*4*。让我们看看这个问题的算法是什么样子的（请注意，**OR-Tools库**用于优化车辆路线、线性规划、约束规划等）：
- en: 'First, let''s start by importing the packages and libraries we''ll need. The
    full file for this algorithm is `ch15_travel.py` and available on GitHub:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们开始导入我们需要的包和库。这个算法的完整文件是`ch15_travel.py`，可以在GitHub上找到：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Remember that this algorithm would need to get a new distance matrix if you
    are planning to visit more cities and/or different cities. That is the only piece
    of the code you''d need to alter. The snippet of code that you will need to adjust
    each time is the matrix under `create_data_model()`, as shown in the following
    code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果您计划访问更多的城市和/或不同的城市，这个算法需要获取一个新的距离矩阵。这是您需要更改的代码的唯一部分。您每次需要调整的代码片段是`create_data_model()`下的矩阵，如下面的代码片段所示：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After we''ve defined our data model, we''ll need to print a solution. The following
    function provides that information:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们定义了数据模型之后，我们需要打印一个解决方案。以下函数提供了该信息：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see from the preceding code, we are creating a function so that we
    can print the solutions based on our arrays and the distances in those arrays.
    Recall that you will identify the point of origin, that is, the city you're leaving
    from. Then we run the algorithm to gather the information and create our `print`
    statement.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从上述代码中所见，我们正在创建一个函数，以便我们可以根据我们的数组和这些数组中的距离打印解决方案。请记住，您将确定出发点，也就是您要离开的城市。然后我们运行算法来收集信息并创建我们的`print`语句。
- en: 'Finally, we''ll need to define our `main()` function in order to run our algorithm.
    The `main()` function tells the algorithm to go ahead and create that data model
    we had defined, and then store it as data. We then create the routing model to
    find our solution. Take a look at the following code snippet:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要定义我们的`main()`函数以运行我们的算法。`main()`函数告诉算法继续创建我们已经定义的数据模型，并将其存储为数据。然后我们创建路由模型来找到我们的解决方案。请看以下代码片段：
- en: '[PRE23]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code shows how we define our `main()` function. As a note, a `main()`
    function can be named anything we want. When using multiple functions, we sometimes
    use `main()` to identify the function that will be outputting what we originally
    wanted from the algorithm. For this problem, we're creating a `main()` function
    that will identify the best route for our travels.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码显示了我们如何定义我们的`main()`函数。需要注意的是，`main()`函数可以被命名为任何我们想要的名称。在使用多个函数时，我们有时使用`main()`来标识最初从算法中输出我们想要的功能。对于这个问题，我们正在创建一个`main()`函数，它将确定我们旅行的最佳路线。
- en: 'Now let''s take a look at what we get for our output when we run this code.
    The code provides us with the `Objective` total of miles and the route we should
    take for the trip. Here''s the output:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看当我们运行这段代码时，我们得到了什么输出。该代码为我们提供了里程的“目标”总数以及我们应该采取的行程路线。以下是输出：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As you can see, our trip from NYC and going back to NYC would be most efficient
    if we followed the route in this order: NYC | Philadelphia | Baltimore | Cleveland
    | Chicago | NYC.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从纽约到纽约的行程，如果我们按照以下顺序进行，将会是最有效的：纽约 | 费城 | 巴尔的摩 | 克利夫兰 | 芝加哥 | 纽约。
- en: 'This is not the only approach for the travel problem. It is also not necessarily
    the most user-friendly approach if we wanted to run this multiple times a day,
    for example, for different travelers. To do that, you''d want to automate a lot
    more of this, as mentioned earlier in the example. Some things you might consider
    are as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是旅行问题的唯一方法。如果我们想要一天运行多次这个问题，或者为不同的旅行者运行，这也不一定是最用户友好的方法。为了做到这一点，您需要自动化更多的内容，就像前面的例子中提到的那样。您可能要考虑的一些事情如下：
- en: Being able to input cities
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够输入城市
- en: Having a calculator that grabs information to determine distances
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个抓取信息以确定距离的计算器
- en: Using an automated process for creating the distance matrix
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自动化过程创建距离矩阵
- en: '*But for now, you''ve seen a TSP in action!* We will look at a new problem
    in the next section.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，你已经看到TSP在行动中了！我们将在下一节中看一个新问题。
- en: Problem 5 – Using Python for cryptography
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题5 – 使用Python进行密码学
- en: '**Cryptography** is what we use to code and decode messages. We used a simple
    **Caesar cipher** in [*Chapter 9*](B15413_09_Final_SK_ePub.xhtml#_idTextAnchor134),
    *Understanding Input and Output to Design a Solution Algorithm*. For this problem,
    we''re going to use some of the packages available in Python to encrypt and decode
    information.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**密码学**是我们用来编码和解码消息的工具。在[*第9章*](B15413_09_Final_SK_ePub.xhtml#_idTextAnchor134)中，我们使用了一个简单的**凯撒密码**，*理解输入和输出以设计解决方案算法*。对于这个问题，我们将使用Python中可用的一些包来加密和解码信息。'
- en: Note that for this particular scenario, we'll use the straightforward analysis
    from using the four elements of the computational thinking process. While we don't
    always follow them exactly, this particular problem lends itself to a fairly straightforward
    use.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于这种特定情况，我们将使用计算思维过程的四个元素进行直接分析。虽然我们并不总是完全遵循它们，但这个特定问题本身就很适合进行相当直接的使用。
- en: Defining the problem (cryptography)
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义问题（密码学）
- en: You are working on a classified project and need to encrypt your information
    to maintain its safety.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在从事一个机密项目，需要加密您的信息以保证其安全性。
- en: Recognizing the pattern (cryptography)
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别模式（密码学）
- en: Python has a cryptography package that can be installed, much like when we installed
    other libraries, such as **Pandas** and **NumPy**. In our problem, one of the
    main things we need to know is that we may need to continue to encrypt messages.
    We may also want to decode messages that we receive, but we are going to focus
    on the encryption side of things first.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个可以安装的密码学包，就像我们安装其他库（如**Pandas**和**NumPy**）一样。在我们的问题中，我们需要知道的主要事情之一是，我们可能需要继续加密消息。我们可能还想解码我们收到的消息，但我们首先要专注于加密方面。
- en: Generalizing (cryptography)
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛化（密码学）
- en: When we design our algorithm, we'll want something we can continue to use throughout
    the life of our project with little effort. That is, any time we want to encrypt
    a new message, we can run the algorithm and input the message rather than add
    the message itself to the algorithm body every time. This is the generalized pattern
    for our particular problem. *That means we're ready to design.*
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计我们的算法时，我们希望能够在项目的整个生命周期中持续使用某些东西，而不需要太多的努力。也就是说，每当我们想要加密新消息时，我们可以运行算法并输入消息，而不是每次都将消息本身添加到算法体中。这是我们特定问题的通用模式。*这意味着我们已经准备好设计了。*
- en: Designing the algorithm (cryptography)
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计算法（密码学）
- en: 'To write our algorithm, let''s first take a look at what we''ll need to do:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写我们的算法之前，让我们首先看一下我们需要做的事情：
- en: Define the letters.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义字母。
- en: Change all the letters to lowercase to run our algorithm.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有字母改为小写以运行我们的算法。
- en: Define the required functions—`encryption`, `decoding`, and `main`.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义所需的函数——`加密`、`解码`和`main`。
- en: Call the cryptography `main` function.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用密码学的`main`函数。
- en: 'Tip:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：
- en: The full algorithm for this problem can be found in the `ch15_cryptographyA.py`
    file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的完整算法可以在`ch15_cryptographyA.py`文件中找到。
- en: 'We will start designing our algorithm by following these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下步骤开始设计我们的算法：
- en: 'Let''s begin by defining our letters. The following code snippet defines our
    letters, and then renders each letter in lowercase:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先定义我们的字母。下面的代码片段定义了我们的字母，然后将每个字母转换为小写：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we define our encryption function. This function will take two arguments—`message`
    and `key`. The `message` function will be user-defined, which will be done in
    the `main` function. For now, we''ll use an empty message by adding empty quotes
    (`''''`) as the definition of the `encryptedM` variable, as shown in the following
    code snippet:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义我们的加密函数。这个函数将接受两个参数——`message`和`key`。`message`函数将由用户定义，在`main`函数中完成。现在，我们将通过在`encryptedM`变量的定义中添加空引号（`''`）来使用空消息，如下面的代码片段所示：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice that we iterate over the letters in the message we want to encrypt, and
    then we use the key that the user defines in the `main` function and encrypt the
    message. This function then returns the encrypted message.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们迭代要加密的消息中的字母，然后我们使用用户在`main`函数中定义的密钥来加密消息。然后这个函数返回加密的消息。
- en: '*But why haven''t we defined the* `main` *function yet if that''s where we
    are getting the inputs?* Because the `main` function will require the other two
    functions to either encrypt or decode the message. So bear with us; we''ll get
    to that `main` function soon.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是为什么我们还没有定义* `main` *函数，如果那是我们获取输入的地方？*因为`main`函数将需要另外两个函数来加密或解码消息。所以请耐心等待；我们很快就会到达`main`函数。'
- en: 'Now let''s take a look at the decoding function. This is what we''ll use when
    we have an encrypted message and want to know what the original message was:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来看一下解码函数。当我们有一个加密的消息并想知道原始消息是什么时，我们将使用这个函数：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code shows the function that we'll use to decode our messages.
    It uses the characters in the message and the encryption key to then decode the
    message. Note that you cannot decode a message if you don't have the original
    key, unless you have the time to sit and try each one of the keys, that is.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码显示了我们将用来解码消息的函数。它使用消息中的字符和加密密钥来解码消息。请注意，如果没有原始密钥，您就无法解码消息，除非您有时间坐下来尝试每一个密钥。
- en: Finally, we'll need that `main` function we keep referring to. This is the function
    that takes all the inputs needed in order for this algorithm to run. Here are
    the three things necessary for it to run correctly—the message to be encrypted
    or decoded; the key, which can be any number in the range 1 to 26; and whether
    we are encrypting or decoding.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要那个我们一直在提到的`main`函数。这个函数需要所有必要的输入，以便这个算法能够正确运行。以下是它正确运行所需的三件事情——要加密或解码的消息；密钥，可以是1到26范围内的任何数字；以及我们是在加密还是解码。
- en: 'Here is the `main` function:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`main`函数：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice from the preceding code that we defined a `main` function. At the end
    of the code, we called that function. *Don't forget to call that* `main` *function
    in the algorithm!* That's how you get the algorithm to run.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看到，我们定义了一个`main`函数。在代码的结尾，我们调用了该函数。*不要忘记在算法中调用*`main`*函数！*这是让算法运行的方法。
- en: 'Here is a sample output when we try to encrypt the input message, `the name
    of the dog is King Kong,` using a key of `9` to encrypt the message:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用密钥`9`加密输入消息`the name of the dog is King Kong`时，这是一个样本输出：
- en: '[PRE29]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we obtain the encrypted text, `cqnwjvnxocqnmxprbrwpxwp,` as
    the cipher text, and now we've created an algorithm that can encrypt or decode
    any message. Let's now move on to a new problem.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们获得了加密文本`cqnwjvnxocqnmxprbrwpxwp`作为密文，现在我们已经创建了一个可以加密或解密任何消息的算法。现在让我们继续解决一个新问题。
- en: Problem 6 – Using Python in cybersecurity
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题6–在网络安全中使用Python
- en: For this problem, we've decided to perform a fairly short cybersecurity check.
    First, let's talk about cybersecurity. The market for cybersecurity is expected
    to grow by 10% by 2027, according to a *Grand View Research* report.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，我们决定进行一个相当简短的网络安全检查。首先，让我们谈谈网络安全。根据*Grand View Research*的报告，预计到2027年，网络安全市场将增长10%。
- en: Translating that to the job market is a little tricky. Currently in the United
    States, for example, there are more cybersecurity needs for the market than people
    or jobs available. That job market growth is expected to be slightly above 30%
    between 2018 and 2028\. So learning a bit about cybersecurity and cryptography
    won't hurt.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些内容转化为就业市场有点棘手。例如，在美国，网络安全的需求比市场上的人员或工作岗位更多。预计到2028年，该岗位市场增长率将略高于30%。因此，学习一些关于网络安全和密码学的知识是有益的。
- en: 'For this particular problem, we are going to explore a few things. First, let''s
    talk about **hashing**. In cybersecurity, hashing means those really long strings
    of numbers and letters that replace things such as passwords. For example, if
    you entered a password of `password1` (please don''t do that, never use `password`
    as a password), the hashing process would replace it with something that looks
    more like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的问题，我们将探讨一些事情。首先，让我们谈谈**哈希**。在网络安全中，哈希意味着那些用数字和字母组成的非常长的字符串，用来替代密码之类的东西。例如，如果您输入了密码`password1`（请不要这样做，永远不要使用`password`作为密码），哈希过程会将其替换为看起来更像这样的东西：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we are creating cryptography algorithms, we have to add random data, which
    we call **salts**. Salts just provide additional input and help us make passwords
    more secure when storing them.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建密码算法时，我们必须添加随机数据，我们称之为**盐**。盐只是提供额外的输入，并在存储密码时帮助我们使密码更安全。
- en: 'When we use hashing in Python, we can use the `uuid` library. **UUID** stands
    for **Universal Unique Identifier**. The `uuid` library is used when we want to
    generate random, 128-bit objects as IDs. *But what are we really talking about?*
    Let''s take a look at the algorithm found in the `ch15_hashing.py` file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中使用哈希时，我们可以使用`uuid`库。**UUID**代表**通用唯一标识符**。当我们想要生成随机的128位对象作为ID时，就会使用`uuid`库。*但我们到底在谈论什么？*
    让我们来看看`ch15_hashing.py`文件中的算法：
- en: 'We will import libraries first:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先我们要导入库：
- en: '[PRE31]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We are importing two libraries that will allow us to save our passwords using
    salting and hashing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在导入两个库，这将允许我们使用加盐和哈希保存我们的密码。
- en: 'In the next code snippet from the file, we define the function to hash our
    password:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件的下一个代码片段中，我们定义了对密码进行哈希的函数：
- en: '[PRE32]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We salted the password using our `uuid` package, and then returned the hash
    using the secure hash algorithm 1, `sha1`. This is only one of the algorithms
    we can use. We could have used others, such as **SHA-256**, **SHA-384**, and more.
    The `sha1` hash has an output size of 160, while `sha256` has an output size of
    256\. Both `sha1` and `sha256` have block sizes of 512 bits, while `sha384` has
    a block size of 1,024 bits.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的`uuid`包对密码进行了加盐处理，然后使用安全哈希算法1 `sha1`返回了哈希值。这只是我们可以使用的算法之一。我们还可以使用其他算法，比如**SHA-256**，**SHA-384**等。`sha1`哈希的输出大小为160，而`sha256`的输出大小为256。`sha1`和`sha256`的块大小都为512位，而`sha384`的块大小为1,024位。
- en: All of this becomes relevant when choosing the hash we'll use, how secure they
    are, and so on. We used `sha1` here more for *nostalgia*, but it is not as secure
    as `sha256` and `sha384`. When attacked, `sha1` will fail against a prolonged
    attack. The other two will hold out for longer, but are still not the best ones.
    Hashes such as **shake128** and **shake256** have more success against such attacks.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择我们将使用的哈希以及它们的安全性等方面，所有这些都变得相关。我们在这里使用`sha1`更多是出于*怀旧*，但它不像`sha256`和`sha384`那样安全。在受到攻击时，`sha1`将无法抵御长时间的攻击。另外两者能够更长时间地抵挡，但仍然不是最好的选择。像**shake128**和**shake256**这样的哈希对抗这种攻击更成功。
- en: 'Let''s now look at the `check` function. We always want to confirm a password
    by asking for it to be entered twice. The following snippet of code defines what
    the algorithm will do when it receives the second password:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看一下`check`函数。我们总是希望通过要求两次输入密码来确认密码。以下代码片段定义了当接收到第二个密码时算法将执行的操作：
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now let''s ask for some input. First, we''ll ask for the password. Because
    we''re curious about what the program is doing, we''ll print the hashed password,
    but you can omit that line when we are building this into a site or other application.
    After that, we ask to verify the password and provide output for the user so they
    know whether they match, in which case, we''d probably want them to try again.
    For now, this algorithm either confirms it or lets the user know that it is now
    confirmed:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们要求一些输入。首先，我们会要求输入密码。因为我们对程序的操作很感兴趣，所以我们会打印出哈希密码，但在构建成网站或其他应用程序时，您可以省略该行。之后，我们要求验证密码，并为用户提供输出，以便他们知道它们是否匹配，如果匹配，我们可能会希望他们再试一次。目前，该算法要么确认它，要么让用户知道它现在已经确认：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After running the program, we get the following output:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后，我们得到以下输出：
- en: '![Figure 15.3 – Output for a salted and hashed password confirmation'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.3–加盐和哈希密码确认的输出'
- en: '](image/Figure_15.03_B15413.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.03_B15413.jpg)'
- en: Figure 15.3 – Output for a salted and hashed password confirmation
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3–盐化和哈希密码确认的输出
- en: As you can see from the preceding screenshot, the password was confirmed by
    the system.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从上述截图中所见，密码被系统确认了。
- en: Now let's see what happens when we enter two different passwords. Let's take
    a look at the following screenshot for that:![Figure 15.4 – Output for a salted
    and hashed password with confirmation fail
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看当我们输入两个不同的密码时会发生什么。让我们看一下以下的截图：![图15.4–带有确认失败的盐化和哈希密码的输出
- en: '](image/Figure_15.04_B15413.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.04_B15413.jpg)'
- en: Figure 15.4 – Output for a salted and hashed password with confirmation fail
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4–带有确认失败的盐化和哈希密码的输出
- en: As you can see, the program asks the user to try again. However, the algorithm
    doesn't provide a way to do that unless the process is restarted. We can let it
    live like that or we can add conditions so that the program runs one more time,
    or two more times, or an infinite number of times, until a confirmation is reached.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，程序要求用户再试一次。然而，除非重新启动过程，算法并没有提供这样的方式。我们可以让它保持这样，或者我们可以添加条件，使程序再次运行一次，或者两次，或者无限次，直到确认达成为止。
- en: Now let's take a look at what happens if we run the algorithm using `sha256`
    instead of `sha1`. The following screenshot shows the result when a password is
    confirmed using `sha256`:![Figure 15.5 – Output when sha1 is replaced with sha256
    in the algorithm for confirming a password
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们看看如果我们使用`sha256`而不是`sha1`来运行算法会发生什么。以下截图显示了使用`sha256`确认密码时的结果：![图15.5–在确认密码的算法中用sha1替换sha256时的输出
- en: '](image/Figure_15.05_B15413.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.05_B15413.jpg)'
- en: Figure 15.5 – Output when sha1 is replaced with sha256 in the algorithm for
    confirming a password
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5–在确认密码的算法中用sha256替换sha1时的输出
- en: Notice that the hash has a longer length as regards the `sha256` algorithm.
    When we are working with cryptography, random and long are always helpful. It
    is easier to crack a password that is not random, such as `password` or `mycat`,
    than it is to crack a password that is very long and contains random numbers and
    letters. That's why we try to store data in ways that safeguard it against attacks.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意哈希值在`sha256`算法方面的长度更长。在使用密码学时，随机和长总是有帮助的。破解一个不随机的密码，比如`password`或`mycat`，要比破解一个非常长并包含随机数字和字母的密码更容易。这就是为什么我们试图以能够保护数据免受攻击的方式存储数据。
- en: 'Let''s take a look at what we could do to provide one more chance for someone
    to enter the password. At the end of the algorithm, let''s add some code after
    the last line:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们可以做些什么来为某人提供再次输入密码的机会。在算法结束时，让我们在最后一行之后添加一些代码：
- en: '[PRE35]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice that the last statement in our preceding snippet states `'Please try
    again later'`. This lets users know that if they want to save a password, they'll
    have to start the process again. The algorithm has, at that point, stopped.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们之前片段中的最后一句话是“请稍后重试”。这让用户知道，如果他们想要保存密码，他们将不得不重新开始这个过程。算法在那时停止了。
- en: 'If we place the preceding code after our `else`, `print()` statement, then
    the algorithm will run one more time. The following screenshot shows the output
    when a user tries a second time:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们将上述代码放在我们的`else`、`print()`语句之后，那么算法将再运行一次。以下截图显示了用户再次尝试时的输出：
- en: '![Figure 15.6 – Output after running an algorithm with an incorrect match first'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.6–在首次运行算法时输出不匹配后'
- en: '](image/Figure_15.06_B15413.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.06_B15413.jpg)'
- en: Figure 15.6 – Output after running an algorithm with an incorrect match first
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6–在首次运行算法时输出不匹配后
- en: Before we move on from this example, notice that the hashed passwords provided
    are different even though our new password entered was `test` on both occasions.
    As we mentioned, the hashed password is created each time. Otherwise, everyone
    would know what the passwords were stored because `test` would be the same so
    long as we'd used the same hash, in this case, `sha256`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从这个例子中继续之前，请注意，尽管我们两次输入的新密码都是`test`，但提供的哈希密码是不同的。正如我们提到的，哈希密码是每次创建的。否则，每个人都会知道密码是如何存储的，因为只要我们使用相同的哈希，比如`sha256`，`test`就会是相同的。
- en: There is a lot more to explore in cybersecurity and cryptography. This is just
    a taste of how we can encrypt information.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络安全和密码学中还有很多可以探索的内容。这只是我们如何加密信息的一个味道。
- en: Problem 7 – Using Python to create a chatbot
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题7–使用Python创建一个聊天机器人
- en: It's time to create a simple chatbot. You've probably interacted with at least
    a dozen of these chatbots in the last few years. When you go to some websites,
    you might get a *person* who wants to chat with you and asks you a few simple
    questions, such as how you're doing, and what they can help you with. For most
    of those sites, the *person* is not a person, but a chatbot.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候创建一个简单的聊天机器人了。在过去几年里，你可能至少与十几个这样的聊天机器人互动过。当你访问一些网站时，你可能会遇到一个“人”想和你聊天，并问你一些简单的问题，比如你最近怎么样，以及他们能帮你什么。对于大多数网站来说，“人”并不是真人，而是一个聊天机器人。
- en: In some instances, the chatbots will then direct you to an actual human being.
    But most of the time, they'll just answer your questions by pointing you in the
    direction of the available answers on their website.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，聊天机器人会将你引导到一个真正的人。但大多数时候，它们只会通过指向他们网站上可用答案的方向来回答你的问题。
- en: 'We''re going to create something like those chatbots here. There are some components
    we''ll need before we get started. One of them is an `intents` file. That file,
    which should be a `.json` file, contains the greetings and responses that the
    bot will be using and/or responding to. Here''s a sample of what the intents content
    looks like:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里创建类似那些聊天机器人的东西。在我们开始之前，有一些组件是我们需要的。其中之一是一个`intents`文件。这个文件应该是一个`.json`文件，包含了机器人将使用和/或回应的问候和回应。以下是`intents`内容的样本：
- en: '[PRE36]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, this is just a group of possible responses. The more data we
    give the `.json` file, the more robust and accurate our bot will be.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这只是一组可能的响应。我们给`.json`文件提供的数据越多，我们的机器人就会越强大和准确。
- en: We should note that the `intents.json` file will need to be edited in a **JSON
    Editor**. There is an online editor you can use at [https://jsoneditoronline.org](https://jsoneditoronline.org)
    where you can create your own, or edit an existing, file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，`intents.json`文件需要在**JSON编辑器**中进行编辑。您可以在[https://jsoneditoronline.org](https://jsoneditoronline.org)上使用一个在线编辑器来创建自己的文件，或者编辑现有的文件。
- en: '*Why would we need a bot?* There are a wide variety of uses for something like
    this, from creating and posting messages to social media to providing a customer
    with a bot that asks whether they require assistance as they visit a web page,
    for example. These are only some of the things we can do with a chatbot.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们为什么需要一个机器人？* 这样的东西有各种各样的用途，从创建和发布社交媒体上的消息到为客户提供一个询问他们是否需要帮助的机器人，例如当他们访问网页。这些只是我们可以用聊天机器人做的一些事情。'
- en: 'Now let''s take a look at an algorithm that creates a chatbot. The full file
    can be found in the repository. We''ve commented and described what goes on in
    some of the sections in snippets:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一个创建聊天机器人的算法。完整的文件可以在存储库中找到。我们已经在一些片段中进行了注释和描述了发生的事情：
- en: 'Let''s start by importing the libraries here:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从这里导入库开始：
- en: ch15_chatBot.py
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ch15_chatBot.py
- en: '[PRE37]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: From the preceding code, note that you do not have to download the `nltk` modules
    each time. However, it won't hurt to have this code. The system won't install
    multiple copies each time; it will just identify that they are there and not install
    them a second time.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，您不必每次下载`nltk`模块。但是拥有这段代码也不会有害。系统不会每次安装多个副本；它只会识别它们已经存在，并且不会第二次安装它们。
- en: 'Let''s continue grabbing what we need from our libraries and packages:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续从我们的库和软件包中获取我们需要的东西：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now that we have what we need, we have to look at our `.json` file. That file
    contains those intents, as mentioned earlier in this problem. We''ll need to not
    only open that file, but also divide the components and sort them in ways that
    our algorithm can understand. Take a look at the following code snippet:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经得到了我们需要的东西，我们必须查看我们的`.json`文件。该文件包含了前面提到的意图。我们不仅需要打开该文件，还需要将组件分开并以我们的算法能够理解的方式进行排序。看一下以下代码片段：
- en: '[PRE39]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Remember that the program won't run unless you specify the right location for
    the file you are trying to access, in this case, the `.json` file. Also notice
    this time that we are opening it in a slightly different manner, as shown in the
    preceding snippet. Opening the file like this, which is not the same as when we
    open `.csv` files with Pandas, means we do not need to use the double `\\` in
    the paths.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，除非您指定要访问的文件的正确位置，否则程序将无法运行，在这种情况下是`.json`文件。还要注意，这次我们以稍微不同的方式打开它，如前面的代码片段所示。以这种方式打开文件，与我们用Pandas打开`.csv`文件不同，意味着我们不需要在路径中使用双`\\`。
- en: 'Now let''s tell the algorithm what to do with that file:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们告诉算法如何处理该文件：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we are tokenizing our information, that is, we're breaking down everything
    into words and then adding them to lists. This is what makes it possible to process
    the information. After we split them up, we are going to group them by what the
    words mean.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在对我们的信息进行标记化，也就是说，我们正在将所有内容分解成单词，然后将它们添加到列表中。这就是使处理信息成为可能的东西。在我们将它们分开后，我们将根据单词的含义对它们进行分组。
- en: 'The words are then sorted, as can be seen in the following code snippet:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后这些单词被排序，如下面的代码片段所示：
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Notice in the preceding code that we used `pickle()`. Pickle is a method in
    Python that we can use to serialize data (or deserialize it). The method is used
    to then replace current file data so that it can be used as converted.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的代码中，我们使用了`pickle()`。Pickle是Python中的一个方法，我们可以使用它来序列化数据（或反序列化）。然后使用该方法替换当前文件数据，以便可以将其用作转换。
- en: Now that we have done all of that, we need to create our training model. We
    won't go through all the sections of that process here, but the entire code can
    be found in the GitHub repository file. Remember that you first train, then create,
    and then compile the model.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了所有这些，我们需要创建我们的训练模型。我们不会在这里逐个讨论该过程的所有部分，但整个代码可以在GitHub存储库文件中找到。请记住，您首先要训练，然后创建，然后编译模型。
- en: 'Once we have run through that process, we save the model so that we can use
    it. But now let''s look at the chatbot functions:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成了这个过程，我们就会保存模型以便我们可以使用它。但现在让我们看看聊天机器人的功能：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The first three functions work to create responses for the chatbot and also
    make predictions. Those classes will matter for how we get those responses from
    our bot. Let's think about it this way—if I say hello, I wouldn't want the chatbot
    to say goodbye. That would be rude. But remember that our bot is only as good
    as our training is. So if we don't have enough in the `.json` file and do not
    train the model correctly, the bot will be fairly useless.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个函数用于为聊天机器人创建响应并进行预测。这些类将影响我们如何从我们的机器人那里获得这些响应。让我们这样考虑——如果我说你好，我不希望聊天机器人说再见。那将是不礼貌的。但请记住，我们的机器人只有我们的训练好，它才会有多好。因此，如果我们在`.json`文件中没有足够的内容，并且没有正确训练模型，那么机器人将是相当无用的。
- en: 'Now let''s define how we get the responses:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义如何获取响应：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: As you can see from the preceding code snippet, the bot will craft a response
    and return it. We'll be calling those things in the next few pieces of code in
    our file.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中可以看到，机器人将制作一个响应并返回它。我们将在我们的文件中的下几个代码片段中调用这些内容。
- en: 'But we''ll skip that here and go into the look of our chatbot:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但我们将在这里跳过这一点，进入我们聊天机器人的外观：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that we established some critical information in the preceding snippet.
    We established the size of the window and blocked it from being resized.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在前面的代码片段中建立了一些关键信息。我们确定了窗口的大小并阻止了其调整大小。
- en: 'In the next code snippet, we''ll establish the background, add `scrollbar`,
    and establish the look of the **Send** button:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个代码片段中，我们将建立背景，添加`滚动条`，并确定**发送**按钮的外观：
- en: '[PRE45]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'So this is it, in a nutshell. *We created a chatbot!* *But what does it look
    like when it runs?* Take a look at the output:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是全部。*我们创建了一个聊天机器人！* *但是当它运行时会是什么样子呢？* 看一下输出：
- en: '![Figure 15.7 – The chatbot window'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.7 - 聊天机器人窗口'
- en: '](image/Figure_15.07_B15413.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.07_B15413.jpg)'
- en: Figure 15.7 – The chatbot window
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7 - 聊天机器人窗口
- en: Notice our components, the scrollbar on the left, the pink **Send** button,
    and the title of our chatbot. And notice too that the maximize button is grayed
    out. That's because we said we don't want the window resized.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们的组件，左侧的滚动条，粉色的**发送**按钮，以及我们聊天机器人的标题。还要注意最大化按钮是灰色的。这是因为我们说过我们不希望窗口被调整大小。
- en: 'In addition, when we click the **Send** button, we want the user to know whether
    it was clicked. Otherwise, you could click it multiple times if you are unsure.
    That''s why the active background color is changed in the code. The following
    screenshot shows what the button looks like when active:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当我们点击**发送**按钮时，我们希望用户知道它是否被点击。否则，如果不确定，您可能会多次点击它。这就是为什么代码中活动的背景颜色会改变。下面的截图显示了按钮在活动状态下的外观：
- en: '![Figure 15.8 – Active Send button'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.8 - 活动的发送按钮'
- en: '](image/Figure_15.08_B15413.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.08_B15413.jpg)'
- en: Figure 15.8 – Active Send button
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8 - 活动的发送按钮
- en: Many chatbots have features like this one so that we avoid errors with the code.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 许多聊天机器人都有类似的功能，以避免代码错误。
- en: 'Once we''ve said hello, the bot will respond. Before we move away from this
    problem, let''s take a look at a quick conversation with the chatbot in the following
    screenshot:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们打招呼，机器人就会回应。在我们离开这个问题之前，让我们看一下下面截图中与聊天机器人的快速对话：
- en: '![Figure 15.9 – The chatbot window with responses'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '![图15.9 - 带有响应的聊天机器人窗口'
- en: '](image/Figure_15.09_B15413.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_15.09_B15413.jpg)'
- en: Figure 15.9 – The chatbot window with responses
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9 - 带有响应的聊天机器人窗口
- en: As you can see, a few lines of code and a file can be used to create an interactive
    experience with a chatbot.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，几行代码和一个文件可以用来创建与聊天机器人的交互体验。
- en: Feel free to play around with the code to add some flair, create a different
    `intents.json` file, and make it more relevant to what you need.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 随意玩弄代码，添加一些特色，创建一个不同的`intents.json`文件，并使其更符合您的需求。
- en: Summary
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've had a chance to explore Python in a few but very different
    applications while looking at actual problems.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有机会在查看实际问题的同时，探索Python在一些非常不同的应用中的应用。
- en: In previous chapters, we learned about the computational thinking process, along
    with the elements of decomposition, pattern recognition, pattern generalization,
    and algorithm design, which make the algorithms make sense. When we tackle problems
    from clients or just while creating a script as a hobby, we have to go through
    the process necessary to define what we're creating with our algorithm. This critical
    process will ensure that we are designing the best possible algorithms we can.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们学习了计算思维过程，以及分解、模式识别、模式概括和算法设计的要素，这些使算法有意义。当我们解决来自客户的问题或者只是在业余时间创建脚本时，我们必须经历必要的过程来定义我们用算法创建的东西。这个关键过程将确保我们设计出尽可能好的算法。
- en: In this chapter, we learned how to read from files, upload files, create ciphers
    and decoders, use algorithms to write stories with user input, and develop the
    most effective travel plan when given the cities we'll visit. In addition, we
    also created a basic chatbot, which can interact and adapt based on the user input.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学会了如何从文件中读取、上传文件、创建密码和解码器、使用算法根据用户输入编写故事，并在给定我们将访问的城市时制定最有效的旅行计划。此外，我们还创建了一个基本的聊天机器人，它可以根据用户输入进行交互和适应。
- en: In the next chapter, we will continue our exploration of Python and computational
    thinking with additional application problems in data analysis in scientific applications,
    housing, stock market analyses, and more.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索Python和计算思维，在科学应用、房地产、股票市场分析等领域中解决数据分析的附加应用问题。
