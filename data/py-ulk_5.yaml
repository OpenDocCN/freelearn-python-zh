- en: Chapter 5. Elegance with Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。设计模式之美
- en: In this chapter, we are going to learn some design patterns that will help us
    in writing better software, which is reusable and tidy. But, the biggest help
    is that they let developers think on an architectural level. They are solutions
    to recurring problems. While learning them is very helpful for compiled languages
    such as C and C++ because they are actually solutions to problems, in Python,
    developers often "just write code" without needing any design pattern due to the
    dynamism in the language and conciseness of code. This is largely true for developers
    whose first language is Python. My advice is to learn design patterns to be able
    to process information and design at an architectural level rather than function
    and classes.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习一些设计模式，这些模式将帮助我们编写更好的软件，使软件可重用且整洁。但是，最大的帮助是它们让开发者能够在架构层面进行思考。它们是针对重复问题的解决方案。虽然学习它们对于C和C++等编译语言非常有帮助，因为它们实际上是解决问题的方案，但在Python中，由于语言的动态性和代码的简洁性，开发者通常“只是编写代码”，不需要任何设计模式。这对于以Python为第一语言的开发者来说尤其如此。我的建议是学习设计模式，以便能够在架构层面而不是函数和类层面处理信息和设计。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Observer pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者模式
- en: Strategy pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略模式
- en: Singleton pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: Template pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板模式
- en: Adaptor pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: Facade pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面模式
- en: Flyweight pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: Command pattern
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令模式
- en: Abstract factory
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Registry pattern
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册模式
- en: State pattern
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态模式
- en: Observer pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 观察者模式
- en: '**Key 1: Spreading information to all listeners.**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键1：向所有听众传播信息。**'
- en: 'This is the basic pattern in which an object tells other objects about something
    interesting. It is very useful in GUI applications, pub/sub applications, and
    those applications where we need to notify a lot of loosely-coupled application
    components about a change occurring at one source node. In the following code,
    `Subject` is the object to which other objects register themselves for events
    via `register_observer`. The `observer` objects are the listening objects. The
    `observers` start observing the function that registers the `observers` object
    to `Subject` object. Whenever there is an event to `Subject` it cascades the event
    to all `observers`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是基本模式，其中一个对象告诉其他对象一些有趣的事情。它在GUI应用程序、pub/sub应用程序以及需要通知大量松散耦合的应用程序组件关于一个源节点发生变化的那些应用程序中非常有用。在以下代码中，`Subject`是其他对象通过`register_observer`注册自己的事件的对象。`observer`对象是监听对象。`observers`开始观察将`observers`对象注册到`Subject`对象的函数。每当`Subject`有事件发生时，它将事件级联到所有`observers`：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output for the preceding code is as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Strategy pattern
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 策略模式
- en: '**Key 2: Changing the behavior of an algorithm.**'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键2：改变算法的行为。**'
- en: 'Sometimes, the same piece of code must have different behavior for different
    invocation by different clients. For example, time-conversion for all countries
    must handle daylight-savings time in some countries and change their strategy
    in these cases. The main use is to switch the implementation. In this pattern,
    algorithm''s behavior is selected on runtime. As Python is a dynamic language,
    it is trivial to assign functions to variables and change them on runtime. Similar
    to the following code segment, there are two implementations to calculate tax,
    namely, `tax_simple`, and `tax_actual`. For the following code snippet, `tax_cal`
    references clients that are used. The implementation can be changed by changing
    reference to the implementing function:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，同一块代码必须对不同客户端的不同调用有不同的行为。例如，所有国家的时区转换必须处理某些国家的夏令时，并在此类情况下更改其策略。主要用途是切换实现。在这个模式中，算法的行为是在运行时选择的。由于Python是一种动态语言，将函数分配给变量并在运行时更改它们是微不足道的。类似于以下代码段，有两种实现来计算税，即`tax_simple`和`tax_actual`。对于以下代码片段，`tax_cal`引用了使用的客户端。可以通过更改对实现函数的引用来更改实现：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But the issue with the preceding implementation is that at one time all clients
    will see the same strategy for tax calculation. We can improve this using a class
    that selects the implementation based on request parameters. In the following
    example, in the `TaxCalculator` class''s instance, the strategy is determined
    for each call to it on runtime. If the request is for India `IN`, Tax is calculated
    as per the Indian standard, and if request is for `US`, it is calculated as per
    the US standard:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但前面实现的问题是，在某一时刻，所有客户端都将看到相同的税务计算策略。我们可以通过一个根据请求参数选择实现的类来改进这一点。在下面的示例中，在 `TaxCalculator`
    类的实例中，策略是在运行时对它的每次调用确定的。如果请求是印度 `IN`，则按照印度标准计算税务，如果请求是 `US`，则按照美国标准计算：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码的输出如下：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Singleton pattern
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: '**Key 3: Providing the same view to all.**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键 3：为所有人提供相同的视图。**'
- en: The singleton pattern maintains the same state for all instances of a class.
    When we change an attribute at one place in a program, it is reflected in all
    references to this instance. As modules are globally shared, we can use them as
    singleton methods, and the variables defined in them are the same everywhere.
    But, there are similar issues in that as the module is reloaded, there may be
    more singleton classes that are needed. We can also create a singleton pattern
    using metaclasses in the following manner. The `six` is a third-party library
    to help in writing the same code that is runnable on Python 2 and Python 3.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式保持类所有实例的相同状态。当我们在一个程序中的某个地方更改一个属性时，它将反映在所有对这个实例的引用中。由于模块是全局共享的，我们可以将它们用作单例方法，并且它们中定义的变量在所有地方都是相同的。但是，也存在类似的问题，即当模块被重新加载时，可能需要更多的单例类。我们还可以以下方式使用元类创建单例模式。`six`
    是一个第三方库，用于帮助编写在 Python 2 和 Python 3 上可运行的相同代码。
- en: 'In the following code, `Singleton` metaclass has a registry dictionary where
    the instance corresponding to each new class is stored. When any class asks for
    a new instance, this class is searched for in the registry, and if found, the
    old instance is passed. Otherwise, a new instance is created, stored in registry,
    and returned. This can be seen in the following code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，`Singleton` 元类有一个注册字典，其中存储了每个新类对应的实例。当任何类请求一个新的实例时，这个类在注册表中搜索，如果找到，则传递旧实例。否则，创建一个新的实例，存储在注册表中，并返回。这可以在下面的代码中看到：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the output of the preceding code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出是前面代码的结果：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Template pattern
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板模式
- en: '**Key 4: Refining algorithm to use case.**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键 4：细化算法以适应用例。**'
- en: 'In this pattern, we define the skeleton of an algorithm in a method called
    the `template` method, which defers some of its steps to subclasses. How we do
    this is as follows, we analyze the procedure, and break it down to logical steps,
    which are different for different use cases. Now, we may or may not implement
    the default implementation of these steps in the main class. The subclasses of
    the main class will implement the steps that are not implemented in the main class,
    and they may skip some generic steps implementation. In the following example,
    `AlooDish` is base class with the `cook` template method. It applies to normal
    Aloo fried dishes, which have a common cooking procedure. Each recipe is a bit
    different in ingredients, time to cook, and so on. Two variants, `AlooMatar`,
    and `AlooPyaz`, define some set of steps differently than others:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们使用名为“模板方法”的方法来定义算法的骨架，其中将一些步骤推迟到子类中。我们这样做的方式如下，我们分析程序，将其分解为逻辑步骤，这些步骤对于不同的用例是不同的。现在，我们可以在主类中实现这些步骤的默认实现，也可能不实现。主类的子类将实现主类中没有实现的步骤，并且它们可能跳过一些通用步骤的实现。在下面的示例中，`AlooDish`
    是具有 `cook` 模板方法的基本类。它适用于正常的土豆炒菜，这些菜有共同的烹饪程序。每个食谱在原料、烹饪时间等方面都有所不同。两种变体 `AlooMatar`
    和 `AlooPyaz` 定义了与其他不同的步骤集：
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the output of the preceding example code:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的输出是前面示例代码的结果：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adaptor pattern
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: '**Key 5: Bridging class interfaces.**'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键 5：桥接类接口。**'
- en: 'This pattern is used to adapt a given class to a new interface. It solves the
    problem for an interface mismatch. To demonstrate this, let''s assume that we
    have an API function that creates a competition to run different animals. Animals
    should have a `running_speed` function, which tells their speed to compare them.
    `Cat` is one such class. Now, if we have a `Fish` class in a different library,
    which also wants to participate in the function, it must be able to know its `running_speed`
    function. As changing the implementation of `Fish` is not good option, we can
    create an `adaptor` class that can adapt the `Fish` class to run by providing
    the necessary bridge:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式用于将给定的类适配到新的接口。它解决了接口不匹配的问题。为了演示这一点，让我们假设我们有一个API函数用于创建比赛以运行不同的动物。动物应该有一个`running_speed`函数，它告诉它们的速度以便进行比较。`Cat`是这样一个类。现在，如果我们有一个位于不同库中的`Fish`类，它也想参加这个函数，它必须能够知道它的`running_speed`函数。由于改变`Fish`的实现不是一个好的选择，我们可以创建一个`适配器`类，它可以通过提供必要的桥梁来适配`Fish`类以运行：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output of the preceding code is follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Facade pattern
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外观模式
- en: '**Key 6: Hiding system complexity for a simpler interface.**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 6：隐藏系统复杂性以实现更简单的接口。**'
- en: 'In this pattern, a main class called facade exports a simpler interface to
    client classes and encapsulates the complexity of interaction with many other
    classes of the system. It is like a gateway to a complex set of functionality,
    such as in the following example, the `WalkingDrone` class hides the complexity
    of synchronization of the `Leg` classes and provides a simpler interface to client
    classes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，一个称为外观的主要类向客户端类导出一个更简单的接口，并封装了与系统许多其他类的交互复杂性。它就像一个通往复杂功能集的门户，如下例所示，`WalkingDrone`类隐藏了`Leg`类的同步复杂性，并为客户端类提供了一个更简单的接口：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This code will give us the following output:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将给出以下输出：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Flyweight pattern
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 享元模式
- en: '**Key 7: Consuming less memory with shared objects.**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 7：使用共享对象减少内存消耗。**'
- en: A flyweight design pattern is useful to save memory. When we have lots of object
    count, we store references to previous similar objects and provide them instead
    of creating new objects. In the following example, we have a `Link` class used
    by the browser, which stores the link data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 享元设计模式有助于节省内存。当我们有很多对象计数时，我们存储对先前相似对象的引用，并提供它们而不是创建新对象。在以下示例中，我们有一个浏览器使用的`Link`类，它存储链接数据。
- en: 'The browser uses this data, and there may be a lot of data that is associated
    with pictures referenced by the link, such as image content, size, and so on,
    and images can be reused over the page. Hence, the nodes using it only store a
    flyweight `BrowserImage` object to decrease the memory footprint. When the link
    class tries to create a new `BrowserImage` instance, the `BrowserImage` class
    checks whether it has an instance in its `_resources` mapping for the resource
    path. If it does, it will just pass the old instance:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器使用这些数据，并且可能与链接引用的图片关联大量数据，例如图片内容、大小等，图片可以在页面上重复使用。因此，使用它的节点仅存储一个轻量级的`BrowserImage`对象以减少内存占用。当链接类尝试创建一个新的`BrowserImage`实例时，`BrowserImage`类会检查其`_resources`映射中是否有该资源路径的实例。如果有，它将只传递旧实例：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the preceding code is follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Command pattern
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令模式
- en: '**Key 8: Easy-execution management for commands.**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键点 8：命令的简单执行管理。**'
- en: 'In this pattern, we encapsulate information that is needed to execute a command
    in an object so that command itself can have further capabilities, such as undo,
    cancel, and metadata that are needed at a later point of time. For example, let''s
    create a simple `Chef` in a restaurant, users can issue orders (commands), commands
    here have metadata that are needed to cancel them. This is similar to a notepad
    app where each user action is recorded with an undo method. This makes coupling
    loose between caller and the invoker, shown as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个模式中，我们封装了执行命令所需的信息，以便命令本身可以具有进一步的能力，例如撤销、取消和后续时间点所需的元数据。例如，让我们在一家餐厅中创建一个简单的`Chef`，用户可以发出订单（命令），这里的命令具有用于取消它们的元数据。这类似于记事本应用，其中每个用户操作都会记录一个撤销方法。这使得调用者和执行者之间的耦合变得松散，如下所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码的输出如下：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Abstract factory
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: 'This design pattern creates an interface to create a family of interrelated
    objects without specifying their concrete class. It is similar to a superfactory.
    Its advantage is that we can add further variants, and clients will not have to
    worry further about the interface or actual classes for the new variants. It is
    helpful in supporting various platforms, windowing systems, data types, and so
    on. In the following example, the `Animal` class is the interface that the client
    will know about for any animal instance. `AnimalFactory` is the abstract factory
    that `DogFactory` and `CatFactory` implement. Now, on the runtime by user input,
    or configuration file, or runtime environment check, we can decide whether we
    will have all `Dog` or `Cat` instances. It is very convenient to add a new class
    implementation, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计模式创建了一个接口，用于创建一系列相互关联的对象，而不指定它们的具体类。它类似于一个超级工厂。它的优点是我们可以添加更多的变体，并且客户端无需进一步担心接口或新变体的实际类。它在支持各种平台、窗口系统、数据类型等方面非常有帮助。在以下示例中，`Animal`类是客户端将了解的任何动物实例的接口。`AnimalFactory`是`DogFactory`和`CatFactory`实现的抽象工厂。现在，在运行时通过用户输入、配置文件或运行时环境检查，我们可以决定是否将所有实例都设置为`Dog`或`Cat`。添加新的类实现非常方便，如下所示：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The preceding code will give us the following output:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将给出以下输出：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Registry pattern
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册模式
- en: '**Key 9: Adding functionality from anywhere in code to class.**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键9：从代码的任何位置向类添加功能。**'
- en: 'This is one of my favorite patterns and comes to help a lot. In this pattern,
    we register classes to a registry, which tracks the naming to functionality. Hence,
    we can add functionality to the main class from anywhere in the code. In the following
    code, `Convertor` tracks all convertors from dictionary to Python objects. We
    can easily add further functionalities to the system using the `convertor.register`
    decorator from anywhere in the code, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我的最爱之一，并且非常有帮助。在这个模式中，我们将类注册到注册表中，该注册表跟踪命名到功能。因此，我们可以从代码的任何位置向主类添加功能。在以下代码中，`Convertor`跟踪所有从字典到Python对象的转换器。我们可以很容易地从代码的任何位置使用`convertor.register`装饰器向系统添加更多功能，如下所示：
- en: '[PRE20]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The following is the output for the preceding code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对前面代码的输出：
- en: '[PRE21]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: State pattern
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态模式
- en: '**Key 10: Changing execution based on state.**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**关键10：根据状态改变执行。**'
- en: 'State machines are very useful for an algorithm whose vector-flow of control
    depends on the state of the application. Similar to when parsing a log output
    with sections, you may want to change the parser logic on every next section.
    It is also very useful to write code for network servers/clients who enable certain
    commands in a certain scope:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机对于控制流的向量依赖于应用程序状态的算法非常有用。类似于在解析带有部分的日志输出时，你可能希望在下一个部分更改解析器逻辑。对于编写允许在特定范围内执行某些命令的网络服务器/客户端代码也非常有用：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This will give us the following output:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下输出：
- en: '[PRE23]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we saw various design patterns that can help us better organize
    the code, and in some cases, increase performance. The good thing about patterns
    is they let you think beyond classes, and they provide strategy for architecture
    of your application. As closing advice for this chapter, do not code to use design
    pattern; when you code and see a good fit, only then use design pattern.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了各种可以帮助我们更好地组织代码的设计模式，在某些情况下，还可以提高性能。模式的好处是它们让你能够超越类去思考，并为你的应用程序架构提供策略。作为本章的结束语，不要为了使用设计模式而编码；当你编码并看到良好的匹配时，再使用设计模式。
- en: Now, we will go onto testing, which is a must for any serious development effort.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进行测试，这对于任何严肃的开发工作都是必须的。
