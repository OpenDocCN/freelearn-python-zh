- en: Chapter 6. Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 网络服务
- en: In[Chapter 5](ch05.html "Chapter 5. A Photoblog Application"), we defined the
    data access layer and the entities our application would manipulate. In this chapter,
    we will explain how we can articulate our photoblog application by using web services
    as an API to access and operate the entities we have defined. We will introduce
    the concept of web services based on the REST principles as well as the Atom Publishing
    Protocol and explain how we can implement them using CherryPy. By the end of this
    chapter, you should understand how web services can enhance and extend the capacities
    of your web application while providing a simple entry point for third-party applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章. 照片博客应用程序")中，我们定义了数据访问层和我们的应用程序将要操作的对象。在本章中，我们将解释如何通过使用网络服务作为API来访问和操作我们定义的对象，从而阐述我们的照片博客应用程序。我们将介绍基于REST原则、Atom发布协议的网络服务概念，并解释如何使用CherryPy实现它们。到本章结束时，你应该了解网络服务如何增强和扩展你的网络应用程序的能力，同时为第三方应用程序提供一个简单的入口点。
- en: Traditional Web Development
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统网络开发
- en: 'Most web applications use the same base URI to handle the serving of resources
    and the manipulation of resources. For instance, it''s common to find something
    such as the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数网络应用程序使用相同的基URI来处理资源的提供和资源的操作。例如，以下内容很常见：
- en: '| URI | Request Body | HTTP Method | Operation |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| URI | 请求体 | HTTP方法 | 操作 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `/album/` | N/A | GET | Fetch all albums |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| `/album/` | N/A | GET | 获取所有专辑 |'
- en: '| `/album/?id=12` | N/A | GET | Fetch the album with the ID 12 |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| `/album/?id=12` | N/A | GET | 获取ID为12的专辑 |'
- en: '| `/album/edit?id=12` | N/A | GET | Return a form to perform an action on a
    resource |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| `/album/edit?id=12` | N/A | GET | 返回一个表单以对资源执行操作 |'
- en: '| `/album/create` | title=Friends | POST | Create an album |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `/album/create` | title=Friends | POST | 创建专辑 |'
- en: '| `/album/delete` | id=12 | POST | Delete the album with the ID 12 |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `/album/delete` | id=12 | POST | 删除ID为12的专辑 |'
- en: '| `/album/update` | id=12&title=Family | POST | Update the album with the ID
    12 |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `/album/update` | id=12&title=Family | POST | 更新ID为12的专辑 |'
- en: 'Within an application hosted with CherryPy, this could be translated into:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在CherryPy托管的应用程序中，这可以翻译为：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although this methodology is valid, it is not the best choice when it needs
    to open itself to different kinds of user agents (browser, robot, service, etc.).
    For instance, imagine we decide to provide a fat client application to manipulate
    albums. In such a case, the HTML page returned by the page handlers would be useless;
    XML or JSON data would be more relevant. We may also want to offer part of our
    application as a service for third-party applications.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法是有效的，但当需要向不同类型的用户代理（浏览器、机器人、服务等）开放时，它并不是最佳选择。例如，假设我们决定提供一个肥客户端应用程序来操作专辑。在这种情况下，页面处理器返回的HTML页面将毫无用处；XML或JSON数据将更相关。我们可能还希望将我们应用程序的一部分作为服务提供给第三方应用程序。
- en: One notable example is the service provided by flickr, ([http://www.flickr.com/](http://www.flickr.com/))
    the online photo-management application, which allows someone to query the flickr
    service ([http://www.flickr.com/services/api/](http://www.flickr.com/services/api/))
    for their data in many contexts like getting current photos, activities, blog
    posts, comments, etc. in different formats. Thanks to these web services a large
    set of third-party applications have grown to extend flickr users' experience
    from a web application or even from a fat client application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的例子是flickr提供的服务，([http://www.flickr.com/](http://www.flickr.com/))一个在线照片管理应用程序，它允许用户在许多上下文中查询flickr服务（[http://www.flickr.com/services/api/](http://www.flickr.com/services/api/)），如获取当前照片、活动、博客文章、评论等，以不同的格式。多亏了这些网络服务，大量第三方应用程序得以扩展，从而从网络应用程序或甚至从肥客户端应用程序中扩展flickr用户的体验。
- en: Separation of Concerns
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: 'The issue with the previous design example is the lack of **separation of concerns**.
    As Tim Bray said about the Web (please refer to [http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST](http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST)
    for more details):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的设计示例的问题在于缺乏**关注点分离**。正如Tim Bray关于网络的看法（请参阅[http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST](http://www.tbray.org/ongoing/When/200x/2006/03/26/On-REST)以获取更多详细信息）：
- en: '*You have a lot of things in the system, identified by URIs*.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统中有很多东西，通过URI来标识*。'
- en: '*There are two kinds of operations against a resource in the system: those
    that can change its state, and those that can''t*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*系统中对资源有两种操作：那些可以改变其状态的和那些不能的*。'
- en: From the first statement we put a *name* on anything that can pass through the
    system; we call it a resource. Examples of resources could be a picture, a poem,
    results of a basketball game, temperature in Australia, etc. We also learn that
    each resource should be identified in a non-equivocal way. From Tim's second statement
    we realize that we should logically separate in our design—operations that are
    read-only and those that can change the resource.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 从第一个陈述中，我们给任何可以通过系统传递的事物命名；我们称之为资源。资源的例子可以是图片、诗歌、篮球比赛的结果、澳大利亚的温度等。我们还了解到，每个资源都应该以非歧义的方式被识别。从Tim的第二点陈述中，我们意识到在设计上应该逻辑上分离——只读操作和可以更改资源的操作。
- en: An important corollary of these distinctions is that we would like to let the
    client inform the server about the content type that it would prefer to receive.
    In our example, our page handlers solely return HTML pages while it would be more
    flexible to check what the client can handle and send it the best representation
    of the resource.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些区分的一个重要推论是我们希望让客户端通知服务器它希望接收的内容类型。在我们的例子中，我们的页面处理程序仅返回HTML页面，而检查客户端可以处理的内容并发送资源最佳表示将更加灵活。
- en: 'Web application developers should consider the following principles:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用程序开发者应考虑以下原则：
- en: Anything is a resource.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何事物都是资源。
- en: A resource has one or several identifiers but one identifier can lead to only
    one resource.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源有一个或多个标识符，但一个标识符只能指向一个资源。
- en: A resource has one or many representations that the client can request.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源有一个或多个客户端可以请求的表示形式。
- en: Operations on resources are divided into those that alter the state of the resource
    and those that do not.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源操作分为改变资源状态和不改变资源状态的那些。
- en: 'Based on these elements we can redefine our design as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些元素，我们可以重新定义我们的设计如下：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: By doing so we allow any kind of user agent to manipulate a resource by requesting
    the `AlbumManager` exposed handlers. A browser would still fetch an HTML representation
    of an album from the `Album` page handlers. You might argue that a browser would
    not know what is to be done with the returned XML or JSON data from the `AlbumManager`
    page handlers. The missing piece of information here is that submission of the
    HTML form and the handling of its response would be performed by some client-side
    scripting code via JavaScript that would be able to process the XML or JSON chunk
    of data accordingly. We will go through this technique in more detail in[Chapter
    7](ch07.html "Chapter 7. The Presentation Layer").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们允许任何类型的用户代理通过请求公开的`AlbumManager`处理程序来操作资源。浏览器仍然会从`Album`页面处理程序获取专辑的HTML表示。你可能会争辩说，浏览器不知道如何处理从`AlbumManager`页面处理程序返回的XML或JSON数据。这里缺失的信息是，HTML表单的提交及其响应的处理将由一些客户端脚本代码通过JavaScript执行，该代码能够相应地处理XML或JSON数据块。我们将在第7章（ch07.html
    "第7章。表示层"）中更详细地介绍这项技术。
- en: The principles defined above are the basis of what are referred to today as
    **web services**. A web service is an API provided by a web application so that
    heterogeneous user agents can interact with the application through formats other
    than HTML. There are different ways to create web services via REST, SOAP, XML-RPC,
    Atom, etc. For the purpose of this book we will review REST and the Atom Publishing
    Protocol as web services for the photoblog application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义的原则是今天所说的**网络服务**的基础。网络服务是网络应用程序提供的API，以便异构用户代理可以通过HTML以外的格式与应用程序交互。通过REST、SOAP、XML-RPC、Atom等方式可以创建不同的网络服务。为了本书的目的，我们将回顾REST和Atom发布协议作为照片博客应用程序的网络服务。
- en: REST
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REST
- en: '**Representational State Transfer** (**REST**) is an architecture style for
    distributed hypermedia systems described by Roy T. Fielding in his dissertation
    Architectural Styles and the Design of Network-based Software Architectures in
    2000.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示性状态转移**（**REST**）是Roy T. Fielding在2000年他的论文《架构风格和网络软件架构设计》中描述的分布式超媒体系统的架构风格。'
- en: 'REST is based on the following elements:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST基于以下元素：
- en: '*Resource:* A resource is the abstract concept of anything. For instance, it
    can be an image, a blog entry, the current rate between two currencies, a sport
    result, a mathematical equation, etc.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源:* 资源是任何事物的抽象概念。例如，它可以是图片、博客条目、两种货币之间的当前汇率、体育结果、数学方程式等。'
- en: '*Resource identifier:* Allows components of the distributed system to identify
    a resource in a unique way.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源标识符:* 允许分布式系统的组件以独特的方式识别资源。'
- en: '*Representation:* A representation of the resource is simply data.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表示:* 资源的一个表示仅仅是数据。'
- en: '*Representation metadata:* Information about the representation itself.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*表示元数据:* 关于表示本身的信息。'
- en: '*Resource metadata:* Information about the resource.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*资源元数据:* 关于资源的信息。'
- en: '*Control data:* Information about the messages passing through the system between
    components.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*控制数据:* 系统中组件之间传递的消息信息。'
- en: REST also suggests that each message flowing should be **stateless** meaning
    that it should contain enough information for its processing by the next component
    within the system and thus should not depend on previous or following messages.
    Each message is self-contained. This is achieved through the use of resource metadata
    and representation metadata.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: REST还建议每个流动的消息应该是**无状态的**，这意味着它应该包含足够的信息供系统中的下一个组件处理，因此不应依赖于之前的或后续的消息。每个消息都是自包含的。这是通过使用资源元数据和表示元数据来实现的。
- en: These are the elements describing REST but they are not tied to any underlying
    protocol. The most commonly used case of REST can be found within the Web and
    is implemented using the HTTP protocol. In spite of that REST can be implemented
    using other protocols in other environments.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是描述REST的元素，但它们并不绑定到任何底层协议。最常用的REST用例可以在Web中找到，并使用HTTP协议实现。尽管如此，REST可以在其他环境和其他协议中使用。
- en: 'HTTP is a good candidate to implement REST for the following reasons:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP是实施REST的好候选，以下是一些原因：
- en: It is the base of the Web, which is a distributed hypermedia system.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是网络的基础，这是一个分布式超媒体系统。
- en: It is stateless.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是无状态的。
- en: Each request can contain enough information to be processed independently of
    the rest of the system.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个请求都可以包含足够的信息，可以独立于系统中的其余部分进行处理。
- en: The content-type and accept headers used by HTTP provide the means to represent
    a single resource through different representations.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP使用的`Content-Type`和`Accept`头部提供了通过不同表示形式来表示单个资源的手段。
- en: URIs are powerful and common resource identifiers.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URI是强大且常见的资源标识符。
- en: Uniform Resource Identifier
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 统一资源标识符
- en: REST is about naming resources on a network and providing a unified mechanism
    to perform operations on these resources. That's why REST tells us that a resource
    is identified by at least one identifier. When implementing a REST infrastructure
    based on the HTTP protocol, these identifiers are defined as **Uniform Resource
    Identifiers** (**URIs**).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: REST是关于在网络上命名资源并提供对这些资源执行操作的统一机制。这就是为什么REST告诉我们资源至少由一个标识符来识别。当基于HTTP协议实现REST架构时，这些标识符被定义为**统一资源标识符**（**URI**）。
- en: 'Two common subsets of the URI set are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: URI集合的两个常见子集是：
- en: '**Uniform Resource Locator** (**URL**), such as: [http://www.cherrypy.org/](http://www.cherrypy.org/)'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一资源定位符**（**URL**），例如：[http://www.cherrypy.org/](http://www.cherrypy.org/)'
- en: '**Uniform Resource Name** (**URN**), such as:'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一资源名称**（**URN**），例如：'
- en: '[PRE2]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The interesting aspect of URLs is that they contain enough information to locate
    the resource on the network. Thus in the given URL we know that to locate the
    resource we need to use the HTTP protocol associated to the HTTP scheme hosted
    on the host [www.cherrypy.org](http://www.cherrypy.org) at the path `/`. (Note,
    however, that not everyone in the Web community thinks that this multiplexing
    of capabilities is a positive aspect of URLs but this discussion is out of the
    scope of this book.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: URL的有趣之处在于它们包含足够的信息来定位网络上的资源。因此，在给定的URL中，我们知道要定位资源，我们需要使用与HTTP方案关联的HTTP协议，该协议托管在主机[www.cherrypy.org](http://www.cherrypy.org)上的路径`/`。（然而，请注意，并非Web社区中的每个人都认为这种能力的多路复用是URL的积极方面，但这次讨论超出了本书的范围。）
- en: HTTP Methods
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP方法
- en: If URIs offer the way to name resources, HTTP methods provide the means by which
    we can operate on those resources. Let's review the most common methods (also
    referred to as verbs) in HTTP 1.1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URI提供了命名资源的方式，HTTP方法提供了我们可以对这些资源进行操作的手段。让我们回顾HTTP 1.1中最常见的方法（也称为动词）。
- en: '| HTTP Method | Idempotent | Operation |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| HTTP方法 | 允许幂等 | 操作 |'
- en: '| --- | --- | --- |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `HEAD` | Yes | Retrieves the resource metadata. The response is the same
    as the one to a GET minus the body. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `HEAD` | 是 | 获取资源元数据。响应与GET相同，但无主体。 |'
- en: '| `GET` | Yes | Retrieves resource metadata and content. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 是 | 获取资源元数据和内容。 |'
- en: '| `POST` | No | Requests the server to create a new resource using the data
    enclosed in the request body. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 否 | 请求服务器使用请求体中的数据创建一个新的资源。 |'
- en: '| `PUT` | Yes | Requests the server to replace an existing resource with the
    one enclosed in the request body. The server cannot apply the enclosed resource
    to a resource not identified by that URI. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 是 | 请求服务器用请求体中包含的资源替换现有的资源。服务器不能将包含的资源应用于未由该URI标识的资源。 |'
- en: '| `DELETE` | Yes | Requests the server to remove the resource identified by
    that URI. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 是 | 请求服务器删除由该URI标识的资源。 |'
- en: '| `OPTIONS` | Yes | Requests the server to return details about capabilities
    either globally or specifically towards a resource. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `OPTIONS` | 是 | 请求服务器返回有关能力的信息，无论是全局的还是特定于资源的。 |'
- en: The idempotent column of the table indicates whether the request using that
    particular HTTP method will have the same side-effects with two consecutive identical
    calls.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的幂等列表示使用该特定HTTP方法的请求是否会有与两个连续相同调用相同的副作用。
- en: By default CherryPy handlers reflect the path of the Request-URI and the handler
    matches one element of the URI, but as we have seen CherryPy's dispatcher can
    be changed not to look for the handler within the URI but from the request metadata
    such as the HTTP method used.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，CherryPy处理程序反映请求-URI的路径，处理程序与URI的一个元素匹配，但正如我们所看到的，CherryPy的分发器可以被更改，使其不是在URI中查找处理程序，而是从请求元数据（如使用的HTTP方法）中查找。
- en: 'Let''s review an example applied to the photoblog application:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一个应用于照片博客应用程序的例子：
- en: '[PRE3]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's explain what each HTTP method does in this context.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释在这个上下文中每个HTTP方法的作用。
- en: '`GET:` This returns the representation of the requested resource depending
    on the `Accept` header. Our application allows `application/xml, application/atom+xml,
    text/json`, or `text/x-json`. We use a function called `accept`, which returns
    the acceptable header found or raises a `cherrypy.HTTPError (406, ''Not Acceptable'')`
    error immediately to inform the user agent that our application cannot deal with
    its request. Then we verify if the resource still exists; if not, we raise a `cherrypy.NotFound`
    error, which is a shortcut to `cherrypy.HTTPError(404, ''Not Found'')`. Once we
    have our pre-conditions checked, we return the requested representation of the
    resource.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET:` 这返回请求资源的表示形式，取决于`Accept`头。我们的应用程序允许`application/xml, application/atom+xml,
    text/json`或`text/x-json`。我们使用一个名为`accept`的函数，它返回找到的可接受头或立即引发一个`cherrypy.HTTPError
    (406, ''Not Acceptable'')`错误，通知用户代理我们的应用程序无法处理其请求。然后我们验证资源是否仍然存在；如果不存在，我们引发一个`cherrypy.NotFound`错误，这是`cherrypy.HTTPError(404,
    ''Not Found'')`的快捷方式。一旦我们检查了先决条件，我们就返回资源的请求表示。'
- en: Note that this is equivalent to the `index()` method with the default dispatcher.
    Bear in mind though that there is no equivalent to the `default()` method when
    using the method dispatcher.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这相当于默认分发器的`index()`方法。但请记住，当使用方法分发器时，没有`default()`方法的等效方法。
- en: '`POST:` The HTTP `POST` method allows a user agent to create a new resource.
    The first step is to check if the photoblog that will handle that resource exists.
    Then we create the resource and we return a status code `201 Created` along with
    the `Location` header indicating the URI to retrieve the newly created resource.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST:` HTTP `POST` 方法允许用户代理创建一个新的资源。第一步是检查将要处理该资源的照片博客是否存在。然后我们创建资源，并返回状态码`201
    Created`以及`Location`头，指示检索新创建资源的URI。'
- en: '`PUT:` The HTTP `PUT` method allows the user agent to replace a resource with
    the one provided in the request body. It is often considered as an update operation.
    Although RFC 2616 does not forbid `PUT` to also create a new resource, we will
    not use it that way in our application as we will explain later.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT:` HTTP `PUT` 方法允许用户代理用请求体中提供的一个资源替换资源。这通常被认为是一个更新操作。尽管RFC 2616没有禁止`PUT`也创建一个新的资源，但我们将不会在我们的应用程序中以这种方式使用它，我们将在后面解释。'
- en: '`DELETE:` The `DELETE` method requests the server to remove the resource. A
    response to this method can either be `200 OK` or `204 No Content`. The latter
    informs the user agent that it should not change its current state since the response
    has no body.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE:` `DELETE` 方法请求服务器删除资源。对此方法的响应可以是`200 OK`或`204 No Content`。后者通知用户代理它不应更改其当前状态，因为响应没有主体。'
- en: The (lack of) difference between `POST` and `PUT` has long been a source of
    discussion among web developers. Some consider that having two methods is misleading.
    Let's try to understand why they are distinct and why we need both.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST`和`PUT`之间的（缺乏）差异长期以来一直是网络开发者讨论的来源。有些人认为有两个方法是有误导性的。让我们尝试理解它们为什么是不同的，为什么我们需要两者。'
- en: '`POST` request:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 请求：'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`POST` response:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`POST` 响应：'
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`PUT` request:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`请求：'
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`PUT` response:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`响应：'
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: At first look, two requests seem fairly similar but in fact they have a very
    important difference, which is the requested URI.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 初看，两个请求似乎相当相似，但实际上它们有一个非常重要的区别，那就是请求的URI。
- en: One can `POST` data to a URI where a process may or may not create a resource
    whereas in the case of `PUT` the URI is one of the resources itself and the content
    sent is the new representation of the resource. In that case, if the resource
    does not exist yet at that URI, the server can create it if it has been implemented
    to do so; otherwise the server can return an HTTP error message indicating it
    is not fulfilling the request. In a nutshell, client POST data to a process but
    PUT the new representation of the resource identified by the request URI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将数据`POST`到URI，其中可能或可能不会创建资源，而在`PUT`的情况下，URI本身就是资源之一，发送的内容是资源的新表示。在这种情况下，如果资源在该URI上尚不存在，服务器可以创建它，如果它已经实现这样做的话；否则，服务器可以返回一个HTTP错误消息，表明它没有满足请求。简而言之，客户端将数据`POST`到进程，但将请求URI标识的资源的新表示`PUT`。
- en: One of the root causes of the problem is the fact that many web applications
    rely only on the `POST` method to achieve any operation on a resource, whether
    creating, updating, or deleting it. This is notably the case because these applications
    often offer only HTML forms, which only support `GET` and `POST`, to perform those
    operations.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 问题的一个根本原因是许多Web应用程序仅依赖于`POST`方法来实现对资源的任何操作，无论是创建、更新还是删除。这尤其是因为这些应用程序通常只提供HTML表单，这些表单只支持`GET`和`POST`来执行这些操作。
- en: Considering the fact that more and more web applications take advantage of separation
    of concerns and handle submission through client code via JavaScript or external
    services, it is likely that the use of the `PUT` and `DELETE` methods increasing,
    though it might be a problem in some environments where firewall policies forbid
    `PUT` and `DELETE` requests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到越来越多的Web应用程序利用关注点分离并通过JavaScript或外部服务通过客户端代码处理提交，`PUT`和`DELETE`方法的使用很可能会增加，尽管在某些环境中可能会成为问题，因为防火墙策略禁止`PUT`和`DELETE`请求。
- en: Putting it Together
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合
- en: 'Our photoblog application will provide a REST interface for the following entities:
    Album, Film, and Entry. Because of the information they carry, their relationship,
    and their design we can provide the same interface independent of the entity itself.
    Therefore we refactor the `Album` class and create a `Resource` class that will
    centralize the implementation of each operation. Each entity-service interface
    will simply pass the information to the `Resource` class and let it deal with
    the hard work. We thus avoid the duplication of code.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的博客应用程序将为以下实体提供REST接口：专辑、电影和条目。由于它们携带的信息、它们之间的关系以及它们的设计，我们可以提供与实体本身无关的相同接口。因此，我们重构了`Album`类并创建了一个`Resource`类，该类将集中实现每个操作。每个实体服务接口只需将信息传递给`Resource`类，让它处理繁重的工作。因此，我们避免了代码的重复。
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then let''s redefine our `AlbumRESTService` class to exploit the `Resource`
    class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们重新定义我们的`AlbumRESTService`类以利用`Resource`类：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have now a RESTful interface that will handle the Album resource. Both the
    Film and Photo entities will be managed the same way. This means that our application
    will now support requests such as:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个将处理专辑资源的RESTful接口。电影和照片实体将以相同的方式进行管理。这意味着我们的应用程序现在将支持以下请求：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In each of these calls the URI is the unique identifier or name of a resource
    and the HTTP method is the operation to carry out on that resource.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些调用中的每一个，URI都是资源的唯一标识符或名称，而HTTP方法是执行在该资源上的操作。
- en: REST Interface through CherryPy
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过CherryPy的REST接口
- en: Until now, we have described services that our photoblog application will support
    without detailing how to achieve it through CherryPy.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了我们的照片博客应用程序将支持的服务，但没有详细说明如何通过CherryPy实现。
- en: 'As we have seen in the previous sections HTTP REST relies on HTTP methods to
    inform a web application of the kind of operation a user agent wishes to carry
    out. In order to implement REST through CherryPy for our photoblog application
    we will use the HTTP method dispatcher as reviewed in[Chapter 4](ch04.html "Chapter 4. CherryPy
    in Depth") to handle incoming requests to the service classes defined above, something
    along these lines:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中看到的，HTTP REST依赖于HTTP方法来通知Web应用用户代理希望执行的操作类型。为了通过CherryPy实现我们的照片博客应用中的REST，我们将使用HTTP方法分发器，正如在[第4章](ch04.html
    "第4章. CherryPy深入")中回顾的那样，来处理对上述服务类的传入请求，大致如下：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This implies that requests applying to a URI path such as `/service/rest/album/`
    will be applied in a REST spirit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着针对URI路径如`/service/rest/album/`的请求将在REST精神下执行。
- en: REST is quite a common term but building true RESTful applications can be a
    difficult task. The difficulty resides in defining a sensible and meaningful URI
    set associated with the application resources. In other words, the difficult part
    lies in the designing of the API. This section should have introduced you to the
    principles behind REST but developing the architecture of a large system around
    REST requires a high-level understanding of the resources dealt with, their naming
    convention, and their relationship.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: REST是一个相当常见的术语，但构建真正的RESTful应用可能是一项艰巨的任务。困难在于定义与应用资源相关的一个合理且有意义的服务URI集。换句话说，困难的部分在于API的设计。本节应该已经向您介绍了REST背后的原则，但围绕REST开发大型系统的架构需要高度理解所处理资源、它们的命名约定以及它们之间的关系。
- en: Atom Publishing Protocol
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Atom发布协议
- en: In the previous section we have introduced REST and showed how it can be used
    as a service for web applications. In this section we will introduce the **Atom
    Publishing Protocol** (**APP**), which at the time of writing this book was on
    its way to becoming a new IETF standard. This means that some aspects of this
    section might no longer be up to date by the time you read them.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们介绍了REST并展示了它如何作为Web应用的服务使用。在本节中，我们将介绍**Atom发布协议**（**APP**），在撰写本书时，它正在成为新的IETF标准。这意味着本节的一些方面可能在您阅读时可能已经不再是最新的。
- en: APP has arisen from the Atom community as an application-level protocol on top
    of HTTP to allow the publishing and editing of web resources. The unit of messages
    between an APP server and a client is based on the Atom XML-document format defined
    in RFC 4287.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: APP作为一种基于HTTP的应用层协议，起源于Atom社区，允许发布和编辑Web资源。APP服务器和客户端之间的消息单元基于RFC 4287中定义的Atom
    XML文档格式。
- en: Although APP is not specified as being an implementation of the REST principles,
    the protocol does follow the same ideas, which give it a RESTful aspect. Therefore,
    many of the principles of the previous section will apply here; but first let's
    overview the Atom XML-document format.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然APP没有指定为REST原则的实现，但该协议遵循相同的思想，使其具有RESTful特性。因此，前一部分的许多原则也适用于这里；但首先让我们概述一下Atom
    XML文档格式。
- en: Atom XML-Document Format
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Atom XML文档格式
- en: 'The Atom XML-document format describes a set of information through two top-level
    elements:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Atom XML文档格式通过两个顶级元素描述了一组信息：
- en: 'Feed: A feed consists of:'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 源：一个源由以下内容组成：
- en: metadata (sometimes referred as the *head* of the feed)
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据（有时被称为源的头）
- en: zero or more entries
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个或多个条目
- en: 'Entry: An entry is made up of:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条目：一个条目由以下内容组成：
- en: metadata
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元数据
- en: some content
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些内容
- en: 'Example of an Atom 1.0 feed document as per RFC4287:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个符合RFC4287的Atom 1.0源文档示例：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A web application can serve Atom documents for subscription thus providing a
    way for user agents to syndicate themselves to information the application developer
    chooses to provide.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用可以为订阅提供Atom文档，从而为用户代理提供一种将自己同步到应用开发者选择提供的信息的方式。
- en: 'Our photoblog application will provide Atom feeds of the following entities:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的摄影博客应用将提供以下实体的Atom源：
- en: 'Photoblog: Each entry of the feed will link to an album feed of the blog.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 照片博客：每个博客的条目将链接到博客的相册条目。
- en: 'Album: Each entry of the feed will link to a film feed of the album.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相册：每个博客的条目将链接到相册的电影条目。
- en: 'Film: Each entry will relate to a photo of the film.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电影：每个条目将关联到一张电影照片。
- en: We will not explain every element of an Atom document but review a few of the
    most common ones.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会解释Atom文档的每个元素，但会回顾一些最常见的元素。
- en: '`id, title`, and `updated` are compulsory elements in any feed or entry.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`、`title`和`updated`是任何源或条目中的强制元素。'
- en: '`id` must be an IRI as defined in RFC 3987 as a complement to URIs'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`必须是RFC 3987中定义的IRI，作为URI的补充'
- en: '`updated` must follow RFC 3339\. RFC 4287 says that this element only needs
    to be updated when the modification is semantically significant.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`updated`必须遵循RFC 3339。RFC 4287表示，该元素只有在修改具有语义意义时才需要更新。'
- en: '`author` is compulsory within an Atom feed whether in the `feed` element, `entry`
    element, or both. However, entries of a feed can inherit the feed `author` element
    if they do not provide one.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`author`在Atom源中是强制性的，无论是在`feed`元素、`entry`元素还是在两者中。然而，如果条目没有提供，则条目可以继承源`author`元素。'
- en: '`link` is not mandatory but is recommended and very useful to provide the following:'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`link`不是强制的，但推荐使用，并且非常有用，可以提供以下信息：'
- en: the URI of the resource associated to the entry or the feed using `rel="self"`
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rel="self"`指定与条目或源关联的资源URI
- en: the URI of alternative representations of the resource using `rel="alternate"`
    and specifying the media-type of the resource
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rel="alternate"`指定资源替代表示的URI，并指定资源的媒体类型
- en: the URI to related resources using `rel="related"`
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`rel="related"`来指定相关资源的URI
- en: '`content` should be present at most once. Either the content of an entry is
    inlined within the entry as text, escaped HTML or XHTML, or the content is referenced
    by the `src` attribute providing the URI of the actual content.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`content`最多只能出现一次。一个条目的内容可以是内联在条目中的文本、转义HTML或XHTML，或者通过`src`属性引用，提供实际内容的URI。'
- en: 'Thus we will have for a film feed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于电影源，我们将有：
- en: '[PRE13]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Atom format is commonly used in the blog environment to allow users to subscribe
    to it. However, thanks to its flexibility and extensibility the Atom format is
    now used in different contexts such as publishing, archiving, and exporting content.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Atom格式在博客环境中被广泛使用，以允许用户订阅它。然而，由于其灵活性和可扩展性，Atom格式现在被用于不同的环境中，如发布、存档和导出内容。
- en: APP Implementation
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: APP实现
- en: The aim of providing an **Atom Publishing Protocol** (APP) implementation within
    the photoblog application is to introduce the protocol and to provide two different
    services demonstrating the benefits of the separation of concerns. Because APP
    is not yet a standard and because at the time of writing this book it was under
    a fairly good amount of discussion, it is possible that by the time you read this
    section our implementation will no longer be compliant. However, there is minimum
    risk as the current version of the protocol draft, i.e. 13, seems stable enough
    regarding its main characteristics.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在照片博客应用程序中提供**Atom发布协议**（APP）实现的目的是介绍该协议，并提供两个不同的服务，以展示关注点分离的好处。由于APP尚未成为标准，并且由于在撰写本书时它正处于相当多的讨论中，因此有可能在我们阅读本节时，我们的实现可能不再符合标准。然而，风险最小，因为当前协议草案的版本，即13，就其主要特性而言似乎足够稳定。
- en: The Atom Publishing Protocol defines a set of operations between an APP service
    and a user-agent using HTTP and its mechanisms and the Atom XML-document format
    as the unit of messages.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Atom发布协议定义了一组操作，这些操作通过HTTP及其机制以及Atom XML文档格式作为消息单元，在APP服务和用户代理之间进行。
- en: 'APP first defines a service document, which provides the user agent with the
    URI of the different collections served by the APP service. It is of the form:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: APP首先定义一个服务文档，它为用户代理提供APP服务所提供的不同集合的URI。其形式为：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once a user agent has fetched that service document it knows there are two `collections`
    available. The first `collection` informs the user-agent that it will only accept
    Atom documents that have a category matching the one defined. The second `collection`
    will only accept data with the `image/png` or `image/jpeg` MIME types.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户代理获取了该服务文档，它就知道有两个`集合`可用。第一个`集合`通知用户代理它将只接受具有与定义匹配类别的Atom文档。第二个`集合`将只接受`image/png`或`image/jpeg`MIME类型的数据。
- en: '**Collections** are the containers of what APP refers to as members. The operation
    of creating a member is done against a collection but operations of retrieving,
    updating, and deleting are done against that member itself and not the collection.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是APP所指成员的容器。创建成员的操作是在集合上完成的，而检索、更新和删除操作是在该成员本身上完成的，而不是在集合上。'
- en: A collection is represented as an Atom feed in which entries are referred as
    to members. The critical addition to the Atom entry is the use of an Atom link
    with the `rel` attribute set to `edit` to describe the member resource. By setting
    this attribute to this value we indicate that the `href` attribute of the link
    element references the URL of the member resource that can be retrieved, edited,
    and deleted at that URI. An Atom entry containing such a link element is called
    a **member** of a collection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 集合表示为Atom源，其中条目被称为成员。对Atom条目的关键补充是使用具有`rel`属性设置为`edit`的Atom链接来描述成员资源。通过将此属性设置为该值，我们表明链接元素的`href`属性引用的是可以检索、编辑和删除的成员资源的URL。包含此类链接元素的Atom条目称为集合的**成员**。
- en: APP specifies how to perform the basic CRUD operations against a member of a
    collection or the collection itself by using HTTP methods as described in the
    following table.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: APP通过以下表格中描述的HTTP方法指定如何对集合的成员或集合本身执行基本的CRUD操作。
- en: '| Operation | HTTP Method | Status Code | Returned Content |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | HTTP方法 | 状态码 | 返回内容 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Retrieve | `GET` | `200` | An Atom entry representing the resource |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 获取 | `GET` | `200` | 代表资源的Atom条目 |'
- en: '| Create | `POST` | `201` | An Atom entry representing the resourceThe URI
    of the newly created resource via the Location and Content-Location headers |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 创建 | `POST` | `201` | 代表资源的Atom条目，通过Location和Content-Location头部的URI表示新创建的资源'
- en: '| Update | `PUT` | `200` | An Atom entry representing the resource |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 更新 | `PUT` | `200` | 代表资源的Atom条目 |'
- en: '| Delete | `DELETE` | `200` | None |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 删除 | `DELETE` | `200` | 无 |'
- en: When creating or updating a resource, the APP server is free to modify part
    of the resource such as its `id`, its `updated` value, etc. Therefore user agents
    should not rely on their version of the resource and always synchronize with the
    server.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建或更新资源时，APP服务器可以自由修改资源的一部分，例如其`id`、其`updated`值等。因此，用户代理不应依赖于其资源版本，而应始终与服务器同步。
- en: Although members of a collection are Atom entries, it is not compulsory to create
    a new member by submitting an Atom entry. APP supports any media type as long
    as it is allowed through the `app:accept` element of an `app:collection` element.
    That element takes a comma-separated list of media types specifying to the client
    which content types the collection will process on POST requests.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管集合的成员是Atom条目，但不必通过提交Atom条目来创建新成员。APP支持任何媒体类型，只要它通过`app:collection`元素的`app:accept`元素允许即可。该元素接受一个以逗号分隔的媒体类型列表，指定客户端集合将处理POST请求的内容类型。
- en: If you `POST` a PNG image to a collection that accepts it, the server will create
    at least two resources.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将PNG图像`POST`到接受它的集合，服务器将创建至少两个资源。
- en: A member resource, which can be seen as the metadata of the image
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成员资源，可以看作是图像的元数据
- en: A media resource
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 媒体资源
- en: Remember that an APP server has total control over the content sent and therefore
    it is imaginable that an APP server could convert the PNG content to JPEG before
    storing it. A client cannot assume that the content or resource sent will be copied,
    as done by a server. In any case the server returns the member resource when creation
    has succeeded (please refer to the APP specification for detailed examples) and
    this is precisely what makes APP so powerful, since whichever type of resource
    a server says it handles APP ensures that metadata will be generated under the
    form of an Atom entry.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，APP服务器对发送的内容拥有完全控制权，因此可以想象APP服务器在存储之前将PNG内容转换为JPEG。客户端不能假设发送的内容或资源会被复制，就像服务器所做的那样。在任何情况下，服务器在创建成功时返回成员资源（请参阅APP规范以获取详细示例），这正是APP如此强大的原因，因为无论服务器声称处理哪种类型的资源，APP都确保会以Atom条目的形式生成元数据。
- en: In addition to defining an interface to manipulate members within a collection,
    APP provides support for paging when a collection gets too big. This allows the
    user agent to request a given range of members within a collection. We will not
    explain this feature but you can review the APP specification if you are interested
    in this feature.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义一个接口来操作集合内的成员外，APP还提供了当集合变得过大时的分页支持。这允许用户代理请求集合中给定范围的成员。我们不会解释此功能，但如果您对此功能感兴趣，可以查看APP规范。
- en: Furthermore, since the photoblog application will follow the REST principles
    as closely as possible for implementing APP, we invite you to refer yourself to
    the REST section for more specific details on how APP uses REST principles.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于照片博客应用将尽可能遵循REST原则来实现APP，我们邀请您参考REST部分，以获取关于APP如何使用REST原则的更具体细节。
- en: In this section, we have briefly presented the Atom Publishing Protocol, a protocol
    based on the Atom XML-document format to allow the publishing of heterogeneous
    data types. In spite of not yet being an official standard, APP already interests
    many organizations and it is quite likely you will find it in more and more applications.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们简要介绍了原子发布协议（Atom Publishing Protocol），这是一种基于Atom XML文档格式的协议，允许发布异构数据类型。尽管它还不是官方标准，但APP已经引起了许多组织的兴趣，并且很可能你会在越来越多的应用中找到它。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has introduced you to the concept of web services, which defines
    the idea of offering an API via common web protocols such as HTTP. By providing
    such APIs your web application becomes much more flexible, powerful, and extensible.
    Web services are not a must-have feature though and not every web application
    would offer them. Our photoblog application, in its spirit of demonstrating some
    of the common modern web techniques, uses them as an example rather than as a
    compulsory feature. However, by reviewing the code of our photoblog application
    you will understand some of the interesting benefits of web services, which will
    hopefully give you ideas for your own applications.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向您介绍了网络服务（web services）的概念，它定义了通过常见的网络协议（如HTTP）提供API的想法。通过提供这样的API，您的网络应用变得更加灵活、强大和可扩展。尽管网络服务不是必需的功能，并不是每个网络应用都会提供它们。我们的照片博客应用，在其展示一些常见现代网络技术的精神下，将它们用作示例而不是强制性的功能。然而，通过审查我们的照片博客应用的代码，您将了解网络服务的一些有趣的好处，这可能会为您自己的应用提供灵感。
