- en: Chapter 1. Our Espionage Toolkit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. 我们的间谍工具包
- en: The job of espionage is to gather and analyze data. This requires us to use
    computers and software tools.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍的工作是收集和分析数据。这要求我们使用计算机和软件工具。
- en: The ordinary *desktop* tools (word processor, spreadsheet, and so on) will not
    measure up for the kinds of jobs we need to tackle. For serious data gathering,
    analysis, and dissemination, we need more powerful tools. As we look at automating
    our data gathering, we can't easily use a desktop tool that requires manual pointing
    and clicking. We want a tool that can be left to run autonomously working for
    us without anyone sitting at a desk.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的桌面工具（文字处理器、电子表格等）无法满足我们需要应对的工作类型。对于严肃的数据收集、分析和传播，我们需要更强大的工具。当我们考虑自动化数据收集时，我们无法轻易使用需要手动点击的桌面工具。我们希望有一个可以自主运行为我们工作的工具，而不需要有人在桌前操作。
- en: 'One of the most powerful data analysis tools we can use is Python. We''re going
    to step through a series of examples of real data collection and analysis using
    Python. This chapter will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用的最强大的数据分析工具之一是Python。我们将通过一系列使用Python进行实际数据收集和分析的示例来逐步介绍。本章将涵盖以下主题：
- en: Firstly, we're going to download and install the latest and greatest Python
    release.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们将下载并安装最新的Python版本。
- en: We're going to supplement Python with the `easy_install` (or `pip`) tools to
    help us gather additional software tools in the later chapters.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在后续章节中用`easy_install`（或`pip`）工具来补充Python，帮助我们收集额外的软件工具。
- en: We'll look at Python's internal help system briefly.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将简要地查看Python的内部帮助系统。
- en: We'll look at how Python works with numbers. After all, a secret agent's job
    of collecting data is going to involve numbers.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将探讨Python如何处理数字。毕竟，特工收集数据的工作将涉及数字。
- en: We'll spend some time on the first steps of writing Python applications. We'll
    call our applications scripts as well as modules.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将花一些时间来学习编写Python应用程序的第一步。我们将把我们的应用程序称为脚本以及模块。
- en: We'll break file input and output into several sections. We will have a quick
    overview as well as an in-depth look at ZIP archive files. In the later chapters,
    we'll look at more kinds of files.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把文件输入和输出分成几个部分。我们将有一个快速概述，以及深入查看ZIP存档文件。在后续章节中，我们将查看更多类型的文件。
- en: Our big mission will be to apply our skills for recovering a lost password for
    a ZIP file. This won't be easy, but we should have covered enough of the basics
    to be successful.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的大任务是应用我们的技能来恢复ZIP文件的丢失密码。这不会很容易，但我们应该已经掌握了足够的基础知识来成功完成。
- en: This will give us enough Python skills so that we can advance to more complex
    missions in the next chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们具备足够的Python技能，以便我们可以在下一章中进入更复杂的任务。
- en: Getting the tools of the trade – Python 3.3
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取行业工具 - Python 3.3
- en: The first step toward using Python is getting the Python language onto our computer.
    If your computer uses Mac OS X or Linux, you may already have Python available.
    At the time of this writing, it's Python 2.7, not 3.3\. In this case, we will
    need to install Python 3.3 in addition to Python 2.7 we already have.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python的第一步是将Python语言安装到我们的计算机上。如果你的计算机使用Mac OS X或Linux，你可能已经安装了Python。在撰写本文时，它是Python
    2.7，而不是3.3。在这种情况下，我们除了已经安装的Python 2.7之外，还需要安装Python 3.3。
- en: Windows agents generally don't have any version of Python, and need to install
    Python 3.3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Windows特工通常没有Python的任何版本，需要安装Python 3.3。
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Python 3 is not *Python 2.7 plus a few features*. Python 3 is a distinct language.
    We don't cover Python 2.7 in this book. The examples won't work in Python 2\.
    Really.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3不是“Python 2.7加上一些特性”。Python 3是一种独立的语言。本书不涵盖Python 2.7。示例在Python 2中真的无法工作。
- en: Python downloads are available at [http://www.python.org/download/](http://www.python.org/download/).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python下载可在[http://www.python.org/download/](http://www.python.org/download/)找到。
- en: Locate the proper version for your computer. There are many pre-built binaries
    for Windows, Linux, and Mac OS X. Linux agents should focus on the binary appropriate
    to their distribution. Each download and install will be a bit different; we can't
    cover all the details.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 找到适合你计算机的正确版本。Windows、Linux和Mac OS X有许多预构建的二进制文件。Linux特工应关注适合其发行版的二进制文件。每个下载和安装都会略有不同；我们无法涵盖所有细节。
- en: There are several implementations of Python. We'll focus on CPython. For some
    missions, you might want to look at Jython, which is Python implemented using
    the Java Virtual Machine. If you're working with other .NET products, you might
    need Iron Python. In some cases, you might be interested in PyPy, which is Python
    implemented in Python. (And, yes, it seems circular and contradictory. It's really
    interesting, but well outside our focus.)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有几种实现方式。我们将关注 CPython。对于某些任务，你可能想看看 Jython，它是使用 Java 虚拟机实现的 Python。如果你在使用其他
    .NET 产品，你可能需要 Iron Python。在某些情况下，你可能对 PyPy 感兴趣，它是用 Python 实现的 Python。（是的，这似乎是循环和矛盾的。它真的很有趣，但超出了我们的关注范围。）
- en: Python isn't the only tool. It's the starting point. We'll be downloading additional
    tools in the later chapters. It seems like half of our job as a secret agent is
    locating the tools required to crack open a particularly complex problem. The
    other half is actually getting the information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Python 不仅仅是一个工具。它是起点。在后面的章节中，我们将下载额外的工具。似乎我们作为秘密特工的工作有一半是寻找解决特定复杂问题所需的工具。另一半则是获取信息。
- en: Windows secrets
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Windows 的秘密
- en: Download the Windows installer for Python 3.3 (or higher) for your version of
    Windows. When you run the installer, you'll be asked a number of questions about
    where to install it and what to install.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的 Windows 版本下载 Python 3.3（或更高版本）的安装程序。当你运行安装程序时，你将需要回答一系列关于安装位置和安装内容的问题。
- en: It's essential that Python be installed in a directory with a simple name. Under
    Windows, the common choice is `C:\Python33`. Using the Windows directories with
    spaces in their name (`Program Files`, `My Documents`, or `Documents and Settings`)
    can cause confusion.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将 Python 安装在具有简单名称的目录中。在 Windows 中，常见的选项是 `C:\Python33`。使用名称中包含空格的 Windows
    目录（如 `Program Files`、`My Documents` 或 `Documents and Settings`）可能会导致混淆。
- en: Be sure to install the Tcl/Tk components too. This will assure that you have
    all the elements required to support IDLE. **IDLE** is a handy text editor that
    comes with Python. For Windows agents, this is generally bundled into the installation
    kit. All you need to do is be sure it has a check mark in the installation wizard.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要安装 Tcl/Tk 组件。这将确保你拥有支持 IDLE 所需的所有元素。**IDLE** 是 Python 附带的方便的文本编辑器。对于 Windows
    用户，这通常包含在安装包中。你只需要确保在安装向导中勾选了它。
- en: With Windows, the `python.exe` program doesn't have a version number as part
    of its name. This is atypical.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 系统中，`python.exe` 程序的名称中不包含版本号，这是不寻常的。
- en: Mac OS X secrets
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Mac OS X 的秘密
- en: In Mac OS X, there is already a Python installation, usually Python 2.7\. This
    must be left intact.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 中，已经有一个 Python 安装，通常是 Python 2.7。这必须保持完整。
- en: Download the Mac OS X installer for Python 3.3 (or higher). When you run this,
    you will be adding a second version of Python. This means that many add-on modules
    and tools must be associated with the proper version of Python. This requires
    a little bit of care. It's not good to use the vaguely-named tool like `easy_install`.
    It's important to use the more specific `easy_install-3.3`, which identifies the
    version of Python you're working with.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 下载适用于 Mac OS X 的 Python 3.3（或更高版本）安装程序。当你运行这个程序时，你将添加 Python 的第二个版本。这意味着许多附加模块和工具必须与
    Python 的正确版本相关联。这需要一点小心。使用模糊命名的工具如 `easy_install` 并不好。重要的是使用更具体的 `easy_install-3.3`，它可以识别你正在使用的
    Python 版本。
- en: The program named `python` is usually going to be an alias for `python2.7`.
    This, too, must be left intact. We'll always explicitly use `python3` (also known
    as `python3.3`) for this book. You can confirm this by using the shell command.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 命名为 `python` 的程序通常是一个指向 `python2.7` 的别名。这也必须保持完整。在这本书中，我们始终会明确使用 `python3`（也称为
    `python3.3`）。你可以通过使用 shell 命令来确认这一点。
- en: Note that there are several versions of Tcl/Tk available for Mac OS X. The Python
    website directs you to a specific version. At the time of this writing, this version
    was ActiveTCL 8.5.14 from ActiveState software. You'll need to install this, too.
    This software allows us to use IDLE.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Mac OS X 有几个版本的 Tcl/Tk 可用。Python 网站会指导你到特定的版本。在撰写本文时，这个版本是 ActiveTCL 8.5.14，来自
    ActiveState 软件。你也需要安装这个版本。这款软件允许我们使用 IDLE。
- en: Visit [http://www.activestate.com/activetcl/downloads](http://www.activestate.com/activetcl/downloads)
    for the proper version.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [http://www.activestate.com/activetcl/downloads](http://www.activestate.com/activetcl/downloads)
    获取正确的版本。
- en: Getting more tools – a text editor
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取更多工具 – 文本编辑器
- en: To create Python applications, we're going to need a proper programmers' text
    editor. A word processor won't do because the files created by a word processor
    are too complex. We need simple text. Our emphasis is on simplicity. Python3 works
    in Unicode without bolding or italicizing the content. (Python 2 didn't work as
    well with Unicode. This is one of the reasons to leave it behind.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Python应用程序，我们需要一个合适的程序员文本编辑器。文字处理器是不够的，因为文字处理器创建的文件太复杂了。我们需要简单的文本。我们强调的是简单性。Python3在Unicode下工作，不需要加粗或斜体内容。（Python
    2与Unicode的兼容性不是很好。这也是我们放弃它的原因之一。）
- en: If you've worked with text editors or **integrated development environments**
    (**IDEs**), you may already have a favorite. Feel free to use it. Some of the
    popular IDEs have Python support.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经使用过文本编辑器或**集成开发环境**（**IDEs**），你可能已经有一个喜欢的。请随意使用它。一些流行的IDE支持Python。
- en: Python is called a dynamic language. It's not always simple to determine what
    names or keywords are legal in a given context. The Python compiler doesn't perform
    a lot of static checking. An IDE can't easily prompt with a short list of all
    legal alternatives. Some IDEs do take a stab at having logical suggestions, but
    they're not necessarily complete.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Python被称为动态语言。在特定上下文中确定哪些名称或关键字是合法的并不总是简单。Python编译器不执行很多静态检查。IDE不能轻易地提供一个所有合法替代品的简短列表。一些IDE尝试提供逻辑建议，但它们并不一定是完整的。
- en: If you haven't worked with a programmer's editor (or an IDE), your first mission
    is to locate a text editor you can work with. Python includes an editor named
    IDLE that is easy to use. It's a good place to start.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有使用过程序员编辑器（或IDE），你的第一个任务是找到一个你可以使用的文本编辑器。Python包含一个名为IDLE的编辑器，它易于使用。这是一个很好的开始地方。
- en: 'The Active State Komodo Edit might be suitable ([http://komodoide.com/komodo-edit/](http://komodoide.com/     komodo-edit/)). It''s a lightweight version of a commercial product. It''s got
    some very clever ways to handle the dynamic language aspects of Python.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Active State Komodo Edit可能很合适([http://komodoide.com/komodo-edit/](http://komodoide.com/komodo-edit/))。它是商业产品的轻量级版本。它有一些非常巧妙的方式来处理Python动态语言方面。
- en: There are many other code editors. Your first training mission is to locate
    something you can work with. You're on your own. We have faith in you.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多其他的代码编辑器。你的第一个训练任务是找到一个你可以使用的。你将独立完成。我们对你有信心。
- en: Getting other developer tools
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取其他开发者工具
- en: Most GNU/Linux agents have various C compilers and other developer tools available.
    Many Linux distributions are already configured to support developers, so the
    tools are already there.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数GNU/Linux代理都有各种C编译器和其他开发者工具可用。许多Linux发行版已经配置为支持开发者，因此工具已经准备好了。
- en: Mac OS X agents will usually need Xcode. Get it from [https://developer.apple.com/xcode/downloads/](https://developer.apple.com/xcode/downloads/).
    Every Mac OS X agent should have this.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Mac OS X代理通常需要Xcode。从[https://developer.apple.com/xcode/downloads/](https://developer.apple.com/xcode/downloads/)获取它。每个Mac
    OS X代理都应该有这个。
- en: When installing this, be sure to also install the command line developer tools.
    This is another big download above and beyond the basic Xcode download.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装此软件时，请确保还安装了命令行开发者工具。这又是一个比基本Xcode下载更大的下载。
- en: Windows agents will generally find that pre-built binaries are available for
    most packages of interest. If, in a rare case, that pre-built code isn't available,
    tools such as Cygwin may be necessary. See [http://www.cygwin.com](http://www.cygwin.com).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Windows代理通常会发现大多数感兴趣的软件包都有预构建的二进制文件。如果，在极少数情况下，预构建的代码不可用，可能需要使用Cygwin等工具。请参阅[http://www.cygwin.com](http://www.cygwin.com)。
- en: Getting a tool to get more Python components
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取更多Python组件的工具
- en: 'In order to effectively and simply download additional Python modules, we often
    use a tool to get tools. There are two popular ways to add Python modules: PIP
    and the `easy_install` script.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地简单地下载额外的Python模块，我们经常使用一个获取工具的工具。有两种流行的方法可以添加Python模块：PIP和`easy_install`脚本。
- en: To install `easy_install`, go to [https://pypi.python.org/pypi/setuptools/3.6](https://pypi.python.org/pypi/setuptools/3.6).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装`easy_install`，请访问[https://pypi.python.org/pypi/setuptools/3.6](https://pypi.python.org/pypi/setuptools/3.6)。
- en: The `setuptools` package will include the `easy_install` script, which we'll
    use to add modules to Python.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`setuptools`软件包将包括`easy_install`脚本，我们将使用它来添加Python模块。'
- en: If you've got multiple versions of Python installed, be sure to download and
    then install the correct easy install version for Python 3.3\. This means that
    you'll generally be using the `easy_install-3.3` script to add new software tools.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您安装了多个版本的 Python，请确保下载并安装正确的 Python 3.3 版本的 easy install。这意味着您通常将使用 `easy_install-3.3`
    脚本来添加新的软件工具。
- en: To install PIP, go to [https://pypi.python.org/pypi/pip/1.5.6](https://pypi.python.org/pypi/pip/1.5.6).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装 PIP，请访问 [https://pypi.python.org/pypi/pip/1.5.6](https://pypi.python.org/pypi/pip/1.5.6)。
- en: We'll be adding the `Pillow` package in [Chapter 3](ch03.html "Chapter 3. Encoding
    Secret Messages with Steganography"), *Encoding Secret Messages with Steganography*.
    We'll also be adding the `Beautiful Soup` package in [Chapter 4](ch04.html "Chapter 4. Drops,
    Hideouts, Meetups, and Lairs"), *Drops, Hideouts, Meetups, and Lairs*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [第 3 章](ch03.html "第 3 章。使用隐写术编码秘密信息") *使用隐写术编码秘密信息* 中添加 `Pillow` 包。我们还将添加
    `Beautiful Soup` 包在 [第 4 章](ch04.html "第 4 章。投递点、藏身之处、聚会和巢穴") *投递点、藏身之处、聚会和巢穴*
    中。
- en: The Python 3.4 distribution should include the PIP tool. You don't need to download
    it separately.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.4 分发应包括 PIP 工具。您不需要单独下载它。
- en: Confirming our tools
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认我们的工具
- en: To be sure we have a working Python tool, it's best to check things from the
    command prompt. We're going to do a lot of our work using the command prompt.
    It involves the least overhead and is the most direct connection to Python.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们有一个工作的 Python 工具，最好从命令提示符进行检查。我们将使用命令提示符来完成大部分工作。这涉及最少的开销，并且是与 Python
    最直接的联系。
- en: 'The Python 3.3 program shows a startup message that looks like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3.3 程序显示一个启动信息，如下所示：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've shown the operating system's prompt (`MacBookPro-SLott:Secret Agent's
    Python slott$`), the command we entered (`python3`), and the response from Python.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了操作系统的提示（`MacBookPro-SLott:Secret Agent's Python slott$`），我们输入的命令（`python3`），以及
    Python 的响应。
- en: Python provides three lines of introduction followed by its own `>>>` prompt.
    The first line shows that it's Python 3.3.4\. The second line shows the tools
    used to build Python (GCC 4.2.1). The third line provides some hints about things
    we might do next.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了三条介绍信息，随后是其自己的 `>>>` 提示符。第一行显示它是 Python 3.3.4。第二行显示构建 Python 所使用的工具（GCC
    4.2.1）。第三行提供了关于我们可能接下来要做什么的一些提示。
- en: We've interacted with Python. Things are working.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经与 Python 交互。一切正常。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以将文件直接通过电子邮件发送给您。
- en: Feel free to enter `copyright`, `credits`, and `license` at the `>>>` prompt.
    They may be boring, but they serve as confirmation that things are working.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 随意输入 `版权`, `致谢`, 和 `许可` 到 `>>>` 提示符。它们可能很无聊，但它们作为确认事情正在工作的依据。
- en: It's important to note that these objects (`copyright`, `credits`, and `license`)
    are not commands or verbs in the Python language. They're global variables that
    were created as a convenience for first-time Python agents. When evaluated, they
    display blocks of text.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这些对象（`版权`, `致谢`, 和 `许可`）在 Python 语言中不是命令或动词。它们是作为方便首次使用 Python 的代理而创建的全局变量。当评估时，它们会显示文本块。
- en: 'There are two other startup objects we''ll use: `exit` and `help`. These provide
    little messages that remind us to use the `help()` and `exit()` functions.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会使用另外两个启动对象：`exit` 和 `help`。这些提供了一些提示信息，提醒我们使用 `help()` 和 `exit()` 函数。
- en: How do we stop?
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们该如何停止？
- en: 'We can always enter `exit` to get a reminder on how to exit from interactive
    Python, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终输入 `exit` 来获取如何从交互式 Python 中退出的提示，如下所示：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Use `exit()` or *Ctrl* + *D* (that is **EOF** (**end-of-file**)) to exit.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exit()` 或 *Ctrl* + *D*（即 **EOF** （文件结束标志））来退出。
- en: Windows agents will see that they must use *Ctrl* + *Z* and `Return` to exit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Windows 代理将看到他们必须使用 *Ctrl* + *Z* 和 `Return` 来退出。
- en: Python is a programming language that also has an interactive prompt of `>>>`.
    To confirm that Python is working, we're responding to that prompt, using a feature
    called the **Read-Execute-Print Loop** (**REPL**).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种编程语言，它也有一个 `>>>` 的交互式提示符。为了确认 Python 是否工作，我们正在响应那个提示符，使用一个称为 **读取-执行-打印循环**
    （**REPL**）的功能。
- en: In the long run, we'll be writing scripts to process our data. Our data might
    be an image or a secret message. The end of a script file will exit from Python.
    This is the same as pressing *Ctrl* + *D* (or *Ctrl* + *Z* and `Return`) to send
    the EOF sequence.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，我们将编写脚本来处理我们的数据。我们的数据可能是一张图片或一条秘密信息。脚本文件的结尾将退出 Python。这与按下 *Ctrl* + *D*（或在
    Windows 上为 *Ctrl* + *Z* 和 `Return`）发送 EOF 序列相同。
- en: Using the help() system
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 help() 系统帮助
- en: Python has a help mode, which is started with the `help()` function. The `help()`
    function provides help on a specific topic. Almost anything you see in Python
    can be the subject of help.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有一个帮助模式，它通过 `help()` 函数启动。`help()` 函数提供特定主题的帮助。在 Python 中看到的大部分内容都可以作为帮助的主题。
- en: For pieces of Python syntax, such as the `+` operator, you'll need to use a
    string meaning you should enclose the syntax in quotes. For example, `help("+")`
    will provide detailed help on operator precedence.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 语法片段，如 `+` 运算符，你需要使用一个字符串表示，你应该在引号中包含语法。例如，`help("+")` 将提供关于运算符优先级的详细帮助。
- en: For other objects (such as numbers, strings, functions, classes, and modules)
    you can simply ask for help on the object itself; quotes aren't used. Python will
    locate the class of the object and provide help on the class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他对象（如数字、字符串、函数、类和模块），你只需直接在对象本身上请求帮助；不需要使用引号。Python 将定位对象的类并提供关于该类的帮助。
- en: 'For example, `help(3)` will provide a lot of detailed, technical help on integers,
    as shown in the following snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`help(3)` 将提供关于整数的许多详细的技术帮助，如下面的片段所示：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When using the `help()` module from the command line, the output will be presented
    in pages. At the end of the first page of output, we see a new kind of non-Python
    prompt. This is usually `:`, but on Windows it may be `-- More --`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当从命令行使用 `help()` 模块时，输出将以分页形式呈现。在输出第一页的末尾，我们看到一种新的非 Python 提示符。这通常是 `:`, 但在
    Windows 上可能是 `-- More --`。
- en: Python normally prompts us with `>>>` or `...`. A non-Python prompt must come
    from one of the help viewers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Python 通常以 `>>>` 或 `...` 提示我们。非 Python 提示符必须来自帮助查看器之一。
- en: Mac OS and GNU/Linux secrets
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mac OS 和 GNU/Linux 秘籍
- en: In POSIX-compatible OSes, we'll be interacting with a program named `less`;
    it will prompt with `:` for all but the last page of your document. For the last
    page, it will prompt with `(END)`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 POSIX 兼容的操作系统上，我们将与一个名为 `less` 的程序交互；对于文档的最后一页之外的所有页面，它将以 `:` 提示。对于最后一页，它将以
    `(END)` 提示。
- en: This program is very sophisticated; you can read more about it on Wikipedia
    at [http://en.wikipedia.org/wiki/Less_(Unix)](http://en.wikipedia.org/wiki/Less_(Unix)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序非常复杂；你可以在维基百科上了解更多信息：[http://en.wikipedia.org/wiki/Less_(Unix)](http://en.wikipedia.org/wiki/Less_(Unix))。
- en: 'The four most important commands are as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是最重要的四个命令：
- en: '`q`: This command is used to quit the `less` help viewer'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`q`：此命令用于退出 `less` 帮助查看器'
- en: '`h`: This command is used to get help on all the commands that are available'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`：此命令用于获取所有可用命令的帮助'
- en: '`˽`: This command is used to enter a space to see the next page'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`˽`：此命令用于进入空格以查看下一页'
- en: '`b`: This command is used to go back one page'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b`：此命令用于返回上一页'
- en: Windows secrets
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows 秘籍
- en: In Windows, we'll usually interact with a program named `more`; it will prompt
    you with `-- More --`. You can read more about it on Wikipedia from [http://en.wikipedia.org/wiki/More_(command)](http://en.wikipedia.org/wiki/More_(command)).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Windows 上，我们通常会与一个名为 `more` 的程序交互；它将以 `-- More --` 提示你。你可以在维基百科上了解更多关于它的信息：[http://en.wikipedia.org/wiki/More_(command)](http://en.wikipedia.org/wiki/More_(command))。
- en: 'The three important commands here are: `q`, `h`, and ˽.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里三个重要的命令是：`q`、`h` 和 ˽。
- en: Using the help mode
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用帮助模式
- en: When we enter `help()` with no object or string value, we wind up in help mode.
    This uses Python's `help>` prompt to make it very clear that we're getting help,
    not entering Python statements. To go back to ordinary Python programming mode,
    and enter `quit`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们不带对象或字符串值输入 `help()` 时，我们将进入帮助模式。这使用 Python 的 `help>` 提示符来清楚地表明我们正在获取帮助，而不是输入
    Python 语句。要返回普通 Python 编程模式，并输入 `quit`。
- en: The prompt then changes back to `>>>` to confirm that we can go back to entering
    code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提示符随后将变回 `>>>` 以确认我们可以返回输入代码。
- en: Your next training mission is to experiment with the `help()` function and help
    mode before we can move on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，你的下一个训练任务是在使用 `help()` 函数和帮助模式之前进行实验。
- en: Background briefing – math and numbers
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景简报 – 数学与数字
- en: We'll review basics of Python programming before we start any of our more serious
    missions. If you already know a little Python, this should be a review. If you
    don't know any Python, this is just an overview and many details will be omitted.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始任何更严肃的任务之前，我们将回顾Python编程的基础知识。如果你已经对Python有所了解，这将是一个复习。如果你对Python一无所知，这只是一个概述，许多细节将被省略。
- en: 'If you''ve never done any programming before, this briefing may be a bit too
    brief. You might want to get a more in-depth tutorial. If you''re completely new
    to programming, you might want to look over this page for additional tutorials:
    [https://wiki.python.org/moin/BeginnersGuide/NonProgrammers](https://wiki.python.org/moin/BeginnersGuide/NonProgrammers).
    For more help to start with expert Python programming, go to [http://www.packtpub.com/expert-python-programming/book](http://www.packtpub.com/expert-python-programming/book).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未进行过任何编程，这份简介可能有点过于简略。你可能需要获取更深入的教程。如果你对编程一无所知，你可能想查看此页以获取额外的教程：[https://wiki.python.org/moin/BeginnersGuide/NonProgrammers](https://wiki.python.org/moin/BeginnersGuide/NonProgrammers)。若要开始学习专家级Python编程，请访问
    [http://www.packtpub.com/expert-python-programming/book](http://www.packtpub.com/expert-python-programming/book)。
- en: The usual culprits
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见的错误
- en: Python provides the usual mix of arithmetic and comparison operators. However,
    there are some important wrinkles and features. Rather than assuming you're aware
    of them, we'll review the details.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Python提供了常规的算术和比较运算符。然而，有一些重要的细节和特性。我们不会假设你已经了解它们，我们将回顾这些细节。
- en: 'The conventional arithmetic operators are: `+`, `-`, `*`, `/`, `//`, `%`, and
    `**`. There are two variations on division: an exact division (`/`) and an integer
    division (`//`). You must choose whether you want an exact, floating-point result,
    or an integer result:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的算术运算符有：`+`、`-`、`*`、`/`、`//`、`%` 和 `**`。在除法上有两种变体：精确除法（`/`）和整数除法（`//`）。你必须选择你想要精确的浮点结果还是整数结果：
- en: '[PRE3]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The exact division (`/`) produces a `float` result from two integers. The integer
    division produces an integer result. When we use `float` values, we expect exact
    division to produce `float`. Even with two floating-point values, the integer
    division produces a rounded-down floating-point result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 精确除法（`/`）从两个整数产生一个 `float` 结果。整数除法产生一个整数结果。当我们使用 `float` 值时，我们期望精确除法产生 `float`。即使对于两个浮点值，整数除法也会产生一个向下取整的浮点结果。
- en: We have this extra division operator to avoid having to use wordy constructs
    such as `int(a/b)` or `math.floor(a/b)`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有这个额外的除法运算符，以避免使用诸如 `int(a/b)` 或 `math.floor(a/b)` 这样的冗长构造。
- en: 'Beyond conventional arithmetic, there are some additional **bit fiddling**
    operators that are available: `&`, `|`, `^`, `>>`, `<<`, and `~`. These operators
    work on integers (and sets). These are emphatically not Boolean operators; they
    don''t work on the narrow domain of `True` and `False`. They work on the individual
    bits of an integer.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规的算术运算外，还有一些额外的**位操作**运算符可用：`&`、`|`、`^`、`>>`、`<<` 和 `~`。这些运算符作用于整数（和集合）。这些运算符绝对不是布尔运算符；它们不作用于
    `True` 和 `False` 的狭窄领域。它们作用于整数的各个位。
- en: We'll use binary values with the `0b` prefix to show what the operators do,
    as shown in the following code. We'll look at details of this `0b` prefix later.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用带有 `0b` 前缀的二进制值来展示运算符的作用，如下面的代码所示。我们将在稍后详细讨论这个 `0b` 前缀。
- en: '[PRE4]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `&` operator does bitwise `AND`. The `^` operator does bitwise exclusive
    `OR` (`XOR`). The `|` operator does inclusive `OR`. The `~` operator is the complement
    of the bits. The result has many 1 bits and is shown as a negative number.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`&` 运算符执行位运算 `AND`。`^` 运算符执行位运算的排他 `OR`（`XOR`）。`|` 运算符执行包含 `OR`。`~` 运算符是位的补码。结果有多个
    `1` 位，并以负数的形式显示。'
- en: 'The `<<` and `>>` operators are for doing left and right shifts of the bits,
    as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`<<` 和 `>>` 运算符用于执行位的左移和右移，如下面的代码所示：'
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It may not be obvious, but shifting left `x` bits is like multiplying it by
    `2**x`, except it may operate faster. Similarly, shifting right by b bits amounts
    to division by `2**b`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能并不明显，但将 `x` 位左移相当于将其乘以 `2**x`，不过它可能运行得更快。同样，右移 `b` 位相当于除以 `2**b`。
- en: 'We also have all of the usual comparison operators: `<`, `<=`, `>`, `>=`, `==`,
    and `!=`.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有所有常规的比较运算符：`<`、`<=`、`>`、`>=`、`==` 和 `!=`。
- en: 'In Python, we can combine comparison operators without including the `AND`
    operator:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以组合比较运算符而不包括 `AND` 运算符：
- en: '[PRE6]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This simplification really does implement our conventional mathematical understanding
    of how comparisons can be written. We don't need to say `7 <= 11 and 11 < 17`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简化实际上实现了我们传统的数学理解，即比较可以如何书写。我们不需要说 `7 <= 11 and 11 < 17`。
- en: 'There''s another comparison operator that''s used in some specialized situations:
    `is`. The `is` operator will appear, for now, to be the same as `==`. Try it.
    `3 is 3` and `3 == 3` seem to do the same thing. Later, when we start using the
    `None` object, we''ll see the most common use for the `is` operator. For more
    advanced Python programming, there''s a need to distinguish between two references
    to the same object (`is`) and two objects which claim to have the same value (`==`).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些特定情况下，还有一个比较运算符被使用：`is`。目前，`is` 运算符看起来与 `==` 相同。试试看。`3 is 3` 和 `3 == 3` 好像做了同样的事情。稍后，当我们开始使用
    `None` 对象时，我们会看到 `is` 运算符最常见的使用。对于更高级的 Python 编程，需要区分对同一对象的两个引用（`is`）和两个声称具有相同值的对象（`==`）。
- en: The ivory tower of numbers
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字的象牙塔
- en: Python gives us a variety of numbers, plus the ability to easily add new kinds
    of numbers. We'll focus on the built-in numbers here. Adding new kinds of numbers
    is the sort of thing that takes up whole chapters in more advanced books.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给我们提供了各种数字，以及轻松添加新类型数字的能力。在这里，我们将关注内置数字。添加新类型的数字是更高级书籍中占据整个章节的内容。
- en: Python ranks the numbers into a kind of tower. At the top are numbers with fewest
    features. Each subclass extends that number with more and more features. We'll
    look at the tower from bottom up, starting with the integers that have the most
    features, and moving towards the complex numbers that have the least features.
    The following sections cover the various kinds of numbers we'll need to use.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将数字排列成一种塔状结构。在顶部是具有最少特征的数字。每个子类都通过添加更多特征来扩展该数字。我们将从底部向上查看这座塔，从具有最多特征的整数开始，然后转向具有最少特征的复数。以下各节将介绍我们将需要使用的各种数字。
- en: Integer numbers
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数数字
- en: 'We can write integer values in base 10, 16, 8, or 2\. Base 10 numbers don''t
    need a prefix, the other bases will use a simple two-character prefix, as shown
    in the following snippet:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用十进制、十六进制、八进制或二进制来表示整数值。十进制数字不需要前缀，其他基数将使用一个简单的双字符前缀，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We also have functions that will convert numbers into handy strings in different
    bases. We can use the `hex()`, `oct()`, and `bin()` functions to see a value in
    base 16, 8, or 2.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有将数字转换为不同基数的方便字符串的函数。我们可以使用 `hex()`、`oct()` 和 `bin()` 函数来查看基于 16、8 或 2 的值。
- en: 'The question of integer size is common. Python integers don''t have a maximum
    size. They''re not artificially limited to 32 or 64 bits. Try this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 整数大小的问题很常见。Python 的整数没有最大值。它们不是人为地限制在 32 或 64 位。试试这个：
- en: '[PRE8]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Large numbers work. They may be a bit slow, but they work perfectly fine.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大数字是有效的。它们可能有点慢，但它们工作得非常好。
- en: Rational numbers
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有理数
- en: 'Rational numbers are not commonly used. They must be imported from the standard
    library. We must import the `fractions`.`Fraction` class definition. It looks
    like this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有理数并不常用。它们必须从标准库中导入。我们必须导入 `fractions`.`Fraction` 类定义。它看起来是这样的：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we have the `Fraction` class defined, we can use it to create numbers.
    Let's say we were sent out to track down a missing device. Details of the device
    are strictly need-to-know. Since we're new agents, all that HQ will release to
    us is the overall size in square inches.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了 `Fraction` 类，我们就可以使用它来创建数字。假设我们被派去追踪一个丢失的设备。设备的详细信息是严格需要知道的。由于我们是新特工，总部只向我们发布了设备的总面积（平方英寸）。
- en: 'Here''s an exact calculation of the area of a device we found. It is measured
    as 4⅞" multiplied by 2¼":'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们找到的设备的面积的确切计算。它测量为 4⅞" 乘以 2¼"：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Okay, the area is 351/32, which is—what?—in real inches and fractions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，面积是 351/32，这在实际英寸和分数中是——什么？
- en: 'We can use Python''s `divmod()` function to work this out. The `divmod()` function
    gives us a quotient and a remainder, as shown in the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Python 的 `divmod()` 函数来解决这个问题。`divmod()` 函数会给我们一个商和一个余数，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's about 5 × 2, so the value seems to fit within our rough approximation.
    We can transmit that as the proper result. If we found the right device, we'll
    be instructed on what to do with it. Otherwise, we might have blown the assignment.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 大约是 5 × 2，所以这个值似乎符合我们的粗略估计。我们可以将其作为正确的结果传输。如果我们找到了正确的设备，我们会被告知如何处理它。否则，我们可能已经破坏了任务。
- en: Floating-point numbers
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: 'We can write floating-point values in common or scientific notation as follows:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用常规或科学记数法写出浮点值，如下所示：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The presence of the decimal point distinguishes an integer from a float.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 小数点的存在区分了整数和浮点数。
- en: These are ordinary double-precision floating-point numbers. It's important to
    remember that floating-point values are only approximations. They usually have
    a 64-bit implementation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是普通的双精度浮点数。重要的是要记住，浮点值只是近似值。它们通常有64位的实现。
- en: 'If you''re using CPython, they''re explicitly based on the C compiler that
    was shown in the `sys.version` startup message. We can also get information from
    the `platform` package as shown in the following code snippet:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用CPython，它们明确基于在`sys.version`启动消息中显示的C编译器。我们还可以从`platform`包中获取信息，如下面的代码片段所示：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This tells us which compiler was used. That, in turn, can tell us what floating-point
    libraries were used. This may help determine which underlying mathematical libraries
    are in use.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们使用了哪个编译器。反过来，这可以告诉我们使用了哪些浮点库。这可能有助于确定正在使用的底层数学库。
- en: Decimal numbers
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十进制数
- en: 'We need to be careful with money. *Words to live by: the accountants watching
    over spies are a tight-fisted bunch*.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要小心对待金钱。*生活箴言：监管间谍的会计师是一群吝啬鬼*。
- en: 'What''s important is that floating-point numbers are an approximation. We can''t
    rely on approximations when working with money. For currency, we need exact decimal
    values, nothing else will do. Decimal numbers can be used with the help of an
    extension module. We''ll import the `decimal.Decimal` class definition to work
    with currency. It looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，浮点数是一个近似值。我们在处理金钱时不能依赖于近似值。对于货币，我们需要精确的十进制值，其他任何东西都不行。可以使用扩展模块来使用十进制数。我们将导入`decimal.Decimal`类定义来处理货币。它看起来是这样的：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The informant we bribed to locate the device wants to be paid 50,000 Greek Drachma
    for the information on the missing device. When we submit our expenses, we'll
    need to include everything, including the cab fare (23.50 dollars) and the expensive
    lunch we had to buy her (12,900 GRD).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收买的线人为了找到设备而索要50000希腊德拉克马作为丢失设备的情报费。当我们提交费用时，我们需要包括一切，包括出租车费（23.50美元）和我们必须为她购买的昂贵午餐（12,900
    GRD）。
- en: '*Why wouldn''t the informant accept Dollars or Euros? We don''t want to know,
    we just want their information*. Recently, Greek Drachma were trading at 247.616
    per dollar.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '*为什么线人不愿意接受美元或欧元？我们不想知道，我们只想得到他们的信息*。最近，希腊德拉克马对美元的汇率为247.616。'
- en: What's the exact budget for the information? In drachma and dollars?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 信息的确切预算是多少？以德拉克马和美元计算？
- en: 'First, we will convert currency exact to the mil (1000 of a dollar):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将货币精确转换为美分的千分之一（美元的1000分之一）：
- en: '[PRE15]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The tab for our lunch, converted from drachma to dollars, is calculated as
    follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们午餐的账单，从德拉克马转换成美元，计算如下：
- en: '[PRE16]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: What? How is that mess going to satisfy the accountants?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？这个混乱如何能让会计师满意？
- en: 'All those digits are a consequence of exact division: we get a lot of decimal
    places of precision; not all of them are really relevant. We need to formalize
    the idea of *rounding off* the value so that the government accountants will be
    happy. The nearest penny will do. In the `Decimal` method, we''ll use the `quantize`
    method. The term **quantize** refers to rounding up, rounding down, and truncating
    a given value. The `decimal` module offers a number of quantizing rules. The default
    rule is `ROUND_HALF_EVEN`: round to the nearest value; in the case of a tie, prefer
    the even value. The code looks as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些数字都是精确除法的结果：我们得到了很多小数位数的精度；并不是所有的它们都真正相关。我们需要正式化“四舍五入”值的概念，这样政府会计师才会满意。最接近的美分即可。在`Decimal`方法中，我们将使用`quantize`方法。术语**quantize**指的是对给定值进行舍入、截断。`decimal`模块提供了一系列量化规则。默认规则是`ROUND_HALF_EVEN`：四舍五入到最近的值；在出现平局的情况下，优先选择偶数值。代码如下：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Notice that the division involved an integer and a decimal. Python's definition
    of decimal will quietly create a new decimal number from the integer so that the
    math will be done using decimal objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，涉及的除法是一个整数和一个小数。Python对十进制的定义会默默地从一个整数创建一个新的十进制数，这样数学运算就会使用十进制对象进行。
- en: 'The cab driver charged us US Dollars. We don''t need to do much of a conversion.
    So, we will add this amount to the final amount, as shown in the following code:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 出租车司机收了我们美元。我们不需要做太多的转换。因此，我们将把这个金额加到最终金额中，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Wait. We seem to be off by a penny. Why didn't we get 277.53 dollars as an answer?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 等等。我们似乎差了一分钱。为什么我们没有得到277.53美元作为答案？
- en: Rounding. The basic rule is called *round half up*. Each individual amount (`52.10`
    and `201.93`) had a fraction of a penny value rounded up. (The more detailed values
    were `52.097` and `201.926`.) When we computed the sum of the drachma before converting,
    the total didn't include the two separately rounded-up half-penny values.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 四舍五入。基本规则称为*四舍六入五成双*。每个单独的金额（`52.10`和`201.93`）都有一分钱的零头四舍五入。（更详细的价值是`52.097`和`201.926`。）在我们将德拉克马相加并在转换之前计算时，总数不包括两个分别四舍五入的五分钱值。
- en: We have a very fine degree of control over this. There are a number of rounding
    schemes, and there are a number of ways to define when and how to round. Also,
    some algebra may be required to see how it all fits together.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对此有非常精细的控制。有许多舍入方案，有许多定义何时以及如何舍入的方法。此外，可能需要一些代数运算来了解它们是如何结合在一起的。
- en: Complex numbers
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复数
- en: 'We also have complex numbers in Python. They''re written with two parts: a
    real and an imaginary value, as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python中也有复数。它们由两部分组成：实部和虚部，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we mix complex values with most other kinds of numbers, the results will
    be complex. The exception is decimal numbers. But why would we be mixing engineering
    data and currency? If any mission involves scientific and engineering data, we
    have a way to deal with the complex values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将复数与其他大多数类型的数字混合，结果将是复数。例外的是十进制数字。但我们为什么要将工程数据和货币混合呢？如果任何任务涉及科学和工程数据，我们有一种处理复数的方法。
- en: Outside the numbers
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在数字之外
- en: Python includes a variety of data types, which aren't numbers. In the *Handling
    text and strings* section, we'll look at Python strings. We'll look at collections
    in [Chapter 2](ch02.html "Chapter 2. Acquiring Intelligence Data"), *Acquiring
    Intelligence Data*.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Python包含各种数据类型，它们不是数字。在*处理文本和字符串*部分，我们将查看Python字符串。我们将在[第2章](ch02.html "第2章。获取智能数据")，*获取智能数据*中查看集合。
- en: 'Boolean values, `True` and `False`, form their own little domain. We can extract
    a Boolean value from most objects using the `bool()` function. Here are some examples:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值`True`和`False`形成自己的小域。我们可以使用`bool()`函数从大多数对象中提取布尔值。以下是一些例子：
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The general pattern is that most objects have a value `True` and a few exceptional
    objects have a value `False`. Empty collections, `0`, and `None` have a value
    `False`. Boolean values have their own special operators: `and`, `or`, and `not`.
    These have an additional feature. Here''s an example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一般模式是大多数对象具有`True`的值，而少数异常对象具有`False`的值。空集合、`0`和`None`具有`False`的值。布尔值有自己的特殊运算符：`and`、`or`和`not`。这些运算符有一个附加功能。以下是一个例子：
- en: '[PRE21]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When we evaluate `True and 0`, both sides of the `and` operator are evaluated;
    the right-hand value was the result. But when we evaluated `False and 0`, only
    the left-hand side of `and` was evaluated. Since it was already `False`, there
    was no reason to evaluate the right-hand side.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们评估`True and 0`时，`and`运算符的两边都会被评估；右侧的值是结果。但当评估`False and 0`时，只有`and`的左侧被评估。由于它已经是`False`，就没有必要评估右侧了。
- en: The `and` and `or` operators are *short-circuit* operators. If the left side
    of `and` is `False`, that's sufficient and the right-hand side is ignored. If
    the left-hand side of `or` is `True`, that's sufficient and the right-hand side
    is ignored.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`and`和`or`运算符是*短路*运算符。如果`and`的左侧是`False`，那就足够了，右侧将被忽略。如果`or`的左侧是`True`，那就足够了，右侧将被忽略。'
- en: 'Python''s rules for evaluation follow mathematic practice closely. Arithmetic
    operations have the highest priority. Comparison operators have a lower priority
    than arithmetic operations. The logical operators have a very low priority. This
    means that `a+2 > b/3 or c==15` will be done in phases: first the arithmetic,
    then the comparison, and finally the logic.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Python的评估规则与数学实践紧密相关。算术运算具有最高优先级。比较运算符的优先级低于算术运算。逻辑运算符的优先级非常低。这意味着`a+2 > b/3
    or c==15`将分阶段完成：首先算术运算，然后比较运算，最后逻辑运算。
- en: Mathematical rules are followed by arithmetic rules. `**` has a higher priority
    than `*`, `/`, `//`, or `%`. The `+` and `–` operators come next. When we write
    `2*3+4`, the `2*3` operation must be performed first. The bit fiddling is even
    lower in priority. When you have a sequence of operations of the same priority
    (`a+b+c`), the computations are performed from left to right. If course, if there's
    any doubt, it's sensible to use parenthesis.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 数学规则遵循算术规则。`**`的优先级高于`*`、`/`、`//`或`%`。`+`和`–`运算符接下来。当我们写`2*3+4`时，必须首先执行`2*3`操作。位操作甚至更低。当你有一系列相同优先级的操作（`a+b+c`）时，计算是从左到右进行的。当然，如果有任何疑问，使用括号是明智的。
- en: Assigning values to variables
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将值赋给变量
- en: We've been using the REPL feature of our Python toolset. In the long run, this
    isn't ideal. We'll be much happier writing scripts. The point behind using a computer
    for intelligence gathering is to automate data collection. Our scripts will require
    assignment to variables. It will also require explicit output and input.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用Python工具集的REPL功能。从长远来看，这并不理想。我们将更乐意编写脚本。使用计算机进行情报收集的目的是自动化数据收集。我们的脚本将需要将变量赋值。它还需要显式输出和输入。
- en: We've shown the simple, obvious assignment statement in several examples previously.
    Note that we don't declare variables in Python. We simply assign values to variables.
    If the variable doesn't exist, it gets created. If the variable does exist, the
    previous value is replaced.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在几个例子中展示了简单的、明显的赋值语句。请注意，在Python中我们不需要声明变量。我们只是将值赋给变量。如果变量不存在，它就会被创建。如果变量已存在，其先前值将被替换。
- en: 'Let''s look at some more sophisticated technology for creating and changing
    variables. We have multiple assignment statements. The following code will assign
    values to several variables at once:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些更复杂的技术来创建和更改变量。我们有多个赋值语句。以下代码将一次性为几个变量赋值：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ve set two variables, `length` and `width`. However, we also made a small
    mistake. The length isn''t the larger value; we''ve switched the values of `length`
    and `width`. We can swap them very simply using a multiple assignment statement
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了两个变量，`length`和`width`。然而，我们也犯了一个小错误。长度并不是较大的值；我们交换了`length`和`width`的值。我们可以非常简单地使用多重赋值语句来交换它们，如下所示：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This works because the right-hand side is computed in its entirety. In this
    case, it's really simple. Then all of the values are broken down and assigned
    to the named variables. Clearly, the number of values on the right have to match
    the number of variables on the left or this won't work.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为右侧是整体计算的。在这种情况下，这真的很简单。然后所有值都被分解并分配给命名变量。显然，右侧的值的数量必须与左侧变量的数量相匹配，否则这不会起作用。
- en: 'We also have *augmented* assignment statements. These couple an arithmetic
    operator with the assignment statement. The following code is an example of `+=`:
    using assignment augmented with addition. Here''s an example of computing a sum
    from various bits and pieces:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有*增强型*赋值语句。这些将算术运算符与赋值语句结合在一起。以下代码是`+=`的一个例子：使用带有加法的赋值增强。这里有一个从各个部分计算总和的例子：
- en: '[PRE24]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We don't have to write `total = total +...`. Instead, we can simply write `total
    += ...`. It's a nice clarification of what our intent is.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必写`total = total +...`。相反，我们可以简单地写`total += ...`。这很好地阐明了我们的意图。
- en: All of the arithmetic operators are available as augmented assignment statements.
    We might have a hard time finding a use for `%=` or `**=`, but the statements
    are part of the language.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的算术运算符都可作为增强型赋值语句使用。我们可能很难找到`%=`或`**=`的用途，但语句是语言的一部分。
- en: 'The idea of a nice clarification should lead to some additional thinking. For
    example, the variable named `conversion` is a perfectly opaque name. Secrecy for
    data is one thing: we''ll look at ways to encrypt data. Obscurity through shabby
    processing of that data often leads to a nightmarish mess. Maybe we should have
    called it something that defines more clearly what it means. We''ll revisit this
    problem of obscurity in some examples later on.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅的澄清的想法应该导致一些额外的思考。例如，名为`conversion`的变量是一个完全晦涩难懂的名字。对数据的保密是一回事：我们将探讨加密数据的方法。通过糟糕的数据处理来隐藏数据通常会导致噩梦般的混乱。也许我们应该给它起一个更清楚地定义其含义的名字。我们将在后面的例子中重新审视这个晦涩的问题。
- en: Writing scripts and seeing output
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写脚本并查看输出
- en: Most of our missions will involve gathering and analyzing data. We won't be
    creating a very sophisticated **User Interface** (**UI**). Python has tools for
    building websites and complex **graphical user interfaces** (**GUIs**). The complexity
    of those topics leads to entire books to cover GUI and web development.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大多数任务将涉及收集和分析数据。我们不会创建一个非常复杂的**用户界面**（**UI**）。Python有用于构建网站和复杂**图形用户界面**（**GUIs**）的工具。这些主题的复杂性导致有整本书来涵盖GUI和Web开发。
- en: We don't want to type each individual Python statement at the `>>>` prompt.
    That makes it easy to learn Python, but our goal is to create programs. In GNU/Linux
    parlance, our Python application programs can be called **scripts**. This is because
    Python programs fit the definition for a *scripting* language.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在`>>>`提示符中逐个输入Python语句。这使学习Python变得容易，但我们的目标是创建程序。在GNU/Linux术语中，我们的Python应用程序程序可以被称为**脚本**。这是因为Python程序符合**脚本语言**的定义。
- en: For our purposes, we'll focus on scripts that use the **command-line interface**
    (**CLI**) Everything we'll write will run in a simple terminal window. The advantage
    of this approach is speed and simplicity. We can add graphic user interfaces later.
    Or we can expand the essential core of a small script into a web service, once
    it works.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的，我们将专注于使用**命令行界面**（**CLI**）的脚本。我们将写的一切都将在一个简单的终端窗口中运行。这种方法的优势是速度和简单性。我们可以在以后添加图形用户界面。或者，一旦脚本工作，我们可以将其基本核心扩展为网络服务。
- en: What is an application or a script? A script is simply a plain text file. We
    can use any text editor to create this file. A word processor is rarely a good
    idea, since word processors aren't good at producing plain text files.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序或脚本是什么？脚本只是一个纯文本文件。我们可以使用任何文本编辑器来创建这个文件。很少建议使用文字处理器，因为文字处理器不擅长生成纯文本文件。
- en: If we're not working from the `>>>` REPL prompt, we'll need to explicitly display
    the output. We'll display output from a script using the `print()` function.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不是从`>>>` REPL提示符工作，我们需要显式地显示输出。我们将使用`print()`函数从脚本中显示输出。
- en: Here's a simple script we can use to produce a receipt for bribing (*encouraging*)
    our informant.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的脚本，我们可以用它来为贿赂（*鼓励*）我们的线人生成收据。
- en: 'From decimal import `Decimal`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 从`decimal`导入`Decimal`：
- en: '[PRE25]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let's break this script down so that we can follow it. Reading a script is a
    lot like putting a tail on an informant. We want to see where the script goes
    and what it does.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这个脚本，以便我们可以跟随它。阅读脚本就像给线人加上尾巴一样。我们想看看脚本会去哪里，它会做什么。
- en: First, we imported the `Decimal` definition. This is essential for working with
    currency. We defined a value, `PENNY`, that we'll use to round off currency calculations
    to the nearest penny. We used a name in all caps to make this variable distinctive.
    It's not an ordinary variable; we should *never* see it on the left-hand side
    of an assignment statement again in the script.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入了`Decimal`定义。这对于处理货币是必不可少的。我们定义了一个值，`PENNY`，我们将用它来将货币计算四舍五入到最近的分。我们使用全大写字母的名称来使这个变量与众不同。它不是一个普通变量；在脚本中我们不应该再看到它在赋值语句的左侧。
- en: We created the currency conversion factor, and named it `grd_usd`. That's a
    name that seems meaningful than `conversion` in this context. Note that we also
    added a small suffix to our amount names. We used names such as `lunch_grd`, `bribe_grd`,
    and `cab_usd` to emphasize which currency is being used. This can help prevent
    head-scrambling problems.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了货币转换系数，并将其命名为`grd_usd`。这个名字在这个上下文中似乎比`conversion`更有意义。请注意，我们还为我们的金额名称添加了一个小的后缀。我们使用了诸如`lunch_grd`、`bribe_grd`和`cab_usd`这样的名称来强调正在使用哪种货币。这可以帮助防止混淆问题。
- en: Given the `grd_usd` conversion factor, we created two more variables, `lunch_usd`
    and `bribe_usd`, with the amounts converted to dollars and rounded to the nearest
    penny. If the accountants want to fiddle with the conversion factor—perhaps they
    can use a different bank than us spies—they can tweak the number and prepare a
    different receipt.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`grd_usd`转换系数，我们创建了两个额外的变量，`lunch_usd`和`bribe_usd`，金额已转换为美元并四舍五入到最近的分。如果会计师想要调整转换系数——也许他们可以使用不同于我们的间谍的银行——他们可以调整数字并准备不同的收据。
- en: The final step was to use the `print()` function to write the receipt. We printed
    the three items we spent money on, showing the amounts in GRD and USD. We also
    computed the total. This will help the accountants to properly reimburse us for
    the mission.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用`print()`函数来编写收据。我们打印了我们在上面花费金钱的三个项目，显示了GRD和USD的金额。我们还计算了总额。这将帮助会计师正确报销我们的任务。
- en: We'll describe the output as *primitive but acceptable*. After all, they're
    only accountants. We'll look into pretty formatting separately.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将描述输出为 *原始但可接受*。毕竟，他们只是会计。我们将单独探讨格式化。
- en: Gathering user input
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集用户输入
- en: 'The simplest way to gather input is to copy and paste it into the script. That''s
    what we did previously. We pasted the Greek Drachma conversion into the script:
    `grd_usd= Decimal(''247.616'')`. We could annotate this with a comment to help
    the accountants make any changes.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 收集输入的最简单方法是将其复制并粘贴到脚本中。这就是我们之前所做的那样。我们将希腊德拉克马转换粘贴到脚本中：`grd_usd= Decimal('247.616')`。我们可以用注释来帮助会计进行任何更改。
- en: 'Additional comments come at the end of the line, after a `#` sign. They look
    like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 行尾的附加注释以 `#` 符号开始。它们看起来像这样：
- en: '[PRE26]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This extra text is part of the application, but it doesn't actually do anything.
    It's a note to ourselves, our accountants, our handler, or the person who takes
    over our assignments when we disappear.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这段额外的文本是应用程序的一部分，但它实际上并没有做什么。这是给我们自己、我们的会计、我们的处理者或在我们消失时接管我们任务的那些人的备注。
- en: This kind of data line is easy to edit. But sometimes the people we work with
    want more flexibility. In that case, we can gather this value as input from a
    person. For this, we'll use the `input()` function.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这种数据行很容易编辑。但有时我们合作的人希望有更多的灵活性。在这种情况下，我们可以从一个人那里收集这个值作为输入。为此，我们将使用 `input()`
    函数。
- en: 'We often break user input down into two steps like this:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常将用户输入分解为两个步骤，如下所示：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The first line will write a prompt and wait for the user to enter the amount.
    The amount will be a string of characters, assigned to the variable `entry`. Python
    can't use the characters directly in arithmetic statements, so we need to explicitly
    convert them to a useful numeric type.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将写入一个提示并等待用户输入金额。金额将是一个字符字符串，分配给变量 `entry`。Python 不能直接在算术语句中使用这些字符，因此我们需要明确地将它们转换为有用的数值类型。
- en: The second line will try to convert the user's input to a useful `Decimal` object.
    We have to emphasize the `try` part of this. If the user doesn't enter a string
    that represents valid `Decimal` number, there will be a major crisis. Try it.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行将尝试将用户的输入转换为有用的 `Decimal` 对象。我们必须强调这个 `try` 部分。如果用户没有输入表示有效 `Decimal` 数字的字符串，将发生重大危机。试试看。
- en: 'The crisis will look like this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 危机看起来会是这样：
- en: '[PRE28]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Rather than this, enter a good number. We entered `123.%$6`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样做，输入一个良好的数字。我们输入了 `123.%$6`。
- en: The bletch starting with `Traceback` indicates that Python raised an exception.
    A crisis in Python always results in an exception being raised. Python defines
    a variety of exceptions to make it possible for us to write scripts that deal
    with these kinds of crises.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `Traceback` 开头的错误信息表明 Python 抛出了一个异常。Python 中的危机总是导致抛出异常。Python 定义了各种异常，以便我们能够编写处理这些危机的脚本。
- en: Once we've seen how to deal with crises, we can look at string data and some
    simple clean-up steps that can make the user's life a little easier. We can't
    fix their mistakes, but we can handle a few common problems that stem from trying
    to type numbers on a keyboard.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解了如何处理危机，我们就可以看看字符串数据以及一些简单的清理步骤，这些步骤可以使用户的生活变得轻松一些。我们无法修复他们的错误，但我们可以处理一些源于在键盘上尝试输入数字的常见问题。
- en: Handling exceptions
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异常
- en: An exception such as `decimal.InvalidOperation` is raised when the `Decimal`
    class can't parse the given string to create a valid `Decimal` object. What can
    we do with this exception?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Decimal` 类无法解析给定的字符串以创建有效的 `Decimal` 对象时，会引发 `decimal.InvalidOperation` 异常。对于这个异常我们能做什么？
- en: We can ignore it. In that case, our application program crashes. It stops running
    and the agents using it are unhappy. Not really the best approach.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以忽略它。在这种情况下，我们的应用程序程序会崩溃。它停止运行，使用它的代理会感到不高兴。这并不是最好的方法。
- en: 'Here''s the basic technique for catching an exception:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获异常的基本技术如下：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We've wrapped the `Decimal()` conversion and assignment in a `try:` statement.
    If every statement in the `try:` block works, the `grd_usd` variable will be set.
    If, on the other hand, a `decimal.InvalidOperation` exception is raised inside
    the `try:` block, the `except` clause will be processed. This writes a message
    and does not set the `grd_usd` variable.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Decimal()` 转换和赋值包裹在 `try:` 语句中。如果 `try:` 块中的每个语句都正常工作，则 `grd_usd` 变量将被设置。另一方面，如果在
    `try:` 块内部抛出 `decimal.InvalidOperation` 异常，则将处理 `except` 子句。这将写入一条消息，并且不会设置 `grd_usd`
    变量。
- en: 'We can handle an exception in a variety of ways. The most common kind of exception
    handling will clean up in the event of some failure. For example, a script that
    attempts to create a file might delete the useless file if an exception was raised.
    The problem hasn''t been solved: the program still has to stop. But it can stop
    in a clean, pleasant way instead of a messy way.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用各种方式处理异常。最常见的异常处理类型是在某些失败的情况下进行清理。例如，尝试创建文件的脚本可能会在抛出异常时删除无用的文件。问题还没有解决：程序仍然必须停止。但它可以以一种干净、愉快的方式停止，而不是以一种混乱的方式。
- en: We can also handle an exception by computing an alternate answer. We might be
    gathering information from a variety of web services. If one doesn't respond in
    time, we'll get a timeout exception. In this case, we may try an alternate web
    service.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以通过计算一个替代答案来处理异常。我们可能从各种网络服务中收集信息。如果其中一个没有及时响应，我们将得到超时异常。在这种情况下，我们可能会尝试另一个网络服务。
- en: In another common exception-handling case, we may reset the state of the computation
    so that an action can be tried again. In this case, we'll wrap the exception handler
    in a loop that can repeatedly ask the user for input until they provide a valid
    number.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个常见的异常处理情况中，我们可能会重置计算的状态，以便可以再次尝试某个操作。在这种情况下，我们将异常处理程序包裹在一个循环中，该循环可以反复要求用户输入，直到他们提供一个有效的数字。
- en: These choices aren't exclusive and some handlers can perform combinations of
    the previous exception handlers. We'll look at the third choice, trying again,
    in detail.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选择不是互斥的，一些处理程序可以执行之前异常处理程序的组合。我们将详细查看第三个选择，即再次尝试。
- en: Looping and trying again
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环尝试
- en: 'Here''s a common recipe for getting input from the user:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个从用户获取输入的常见方法：
- en: '[PRE30]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We'll add a tail to this and follow it around for a bit. The goal is to get
    a valid decimal value for our currency conversion, `grd_usd`. We'll initialize
    that variable as Python's special `None` object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个尾巴并跟随它一段时间。目标是获取我们货币转换的有效十进制值`grd_usd`。我们将该变量初始化为Python的特殊`None`对象。
- en: 'The `while` statement makes a formal declaration of our intent. We''re going
    to execute the body of the `while` statement while the `grd_usd` variable remains
    set to `None`. Note that we''re using the `is` operator to compare `grd_usd` to
    `None`. We''re emphasizing a detail here: there''s only one `None` object in Python
    and we''re using that single instance. It''s technically possible to tweak the
    definition of `==`; we can''t tweak the definition of `is`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`语句正式声明了我们的意图。我们将执行`while`语句的主体，直到`grd_usd`变量保持为`None`。注意，我们使用`is`运算符将`grd_usd`与`None`进行比较。我们在这里强调一个细节：Python中只有一个`None`对象，我们正在使用那个单一实例。技术上可以调整`==`的定义；我们不能调整`is`的定义。'
- en: At the end of the `while` statement, `grd_usd is None` must be `False`; we can
    say `grd_usd is not None`. When we look at the body of the statement, we can see
    that only one statement sets `grd_usd`, so we're assured that it must be a valid
    `Decimal` object.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`语句的末尾，`grd_usd is None`必须为`False`；我们可以说`grd_usd is not None`。当我们查看语句的主体时，我们可以看到只有一个语句设置了`grd_usd`，因此我们可以确信它必须是一个有效的`Decimal`对象。
- en: Within the body of the `while` statement, we've used our exception-handling
    recipe. First, we prompt and get some input, setting the `entry` variable. Then,
    inside the `try` statement, we attempt to convert the string to a `Decimal` value.
    If that conversion works, then `grd_usd` will have that `Decimal` object assigned.
    The object will not be `None` and the loop will terminate. Victory!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`语句的主体中，我们使用了我们的异常处理方法。首先，我们提示并获取一些输入，设置`entry`变量。然后，在`try`语句中，我们尝试将字符串转换为`Decimal`值。如果转换成功，则`grd_usd`将分配那个`Decimal`对象。该对象不会是`None`，循环将终止。胜利！
- en: If the conversion of entry to a `Decimal` value fails, the exception will be
    raised. We'll print a message, and leave `grd_usd` alone. It will still have a
    value of `None`. The loop will continue until a valid value is entered.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将输入转换为`Decimal`值失败，将会抛出异常。我们会打印一条消息，并保持`grd_usd`不变。它仍然将保持`None`的值。循环将继续，直到输入一个有效的值。
- en: Python has other kinds of loops, we'll get to them later in this chapter.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Python还有其他类型的循环，我们将在本章的后面讨论。
- en: Handling text and strings
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文本和字符串
- en: 'We''ve glossed over Python''s use of string objects. Expressions such as `Decimal(''247.616'')`
    and `input(GRD conversion: )` involve string literal values. Python gives us several
    ways to put strings into our programs; there''s a lot of flexibility available.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经简要介绍了Python对字符串对象的使用。例如 `Decimal(''247.616'')` 和 `input(GRD conversion:
    )` 的表达式涉及字符串字面值。Python 给我们几种方法将字符串放入程序中；有很多灵活性可用。'
- en: 'Here are some examples of strings:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些字符串的例子：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We've used single quotes and apostrophes to create short strings. These must
    be complete within a single line of programming. We used triple quotes and triple
    apostrophes to create long strings. These strings can stretch over multiple lines
    of a program.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用单引号和撇号来创建短字符串。这些必须在程序的单行内完整。我们使用三引号和三撇号来创建长字符串。这些字符串可以跨越程序的多行。
- en: Note that Python echoes the strings back to us with a `\n` character to show
    the line break. This is called a **character escape**. The `\` character escapes
    the normal meaning of `n`. The sequence `\n` doesn't mean `n`; `\n` means the
    often invisible newline character. Python has a number of escapes. The newline
    character is perhaps the most commonly used escape.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Python 使用 `\n` 字符回显字符串以显示换行。这被称为**字符转义**。`\` 字符转义了 `n` 的正常意义。序列 `\n` 并不意味着
    `n`；`\n` 意味着通常不可见的换行符。Python 有许多转义字符。换行符可能是最常用的转义字符。
- en: Sometimes we'll need to use characters which aren't present on our computer
    keyboards. For example, we might want to print one of the wide variety of Unicode
    special characters.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要使用不在我们电脑键盘上的字符。例如，我们可能想要打印各种Unicode特殊字符之一。
- en: 'The following example works well when we know the Unicode number for a particular
    symbol:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例在我们知道特定符号的Unicode数字时效果很好：
- en: '[PRE32]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following example is better because we don''t need to know the obscure
    code for a symbol:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例更好，因为我们不需要知道符号的晦涩代码：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Converting between numbers and strings
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介于数字和字符串之间的转换
- en: 'We have two kinds of interesting string conversions: strings to numbers and
    numbers to strings.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种有趣的字符串转换：字符串转数字和数字转字符串。
- en: 'We''ve seen functions such as `Decimal()` to convert a string to a number.
    We also have the functions: `int(), float(), fractions.Fraction()`, and `complex()`.
    When we have numbers that aren''t in base 10, we can also use `int()` to convert
    those, as shown in the following code:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了像 `Decimal()` 这样的函数，可以将字符串转换为数字。我们还有其他函数：`int()`, `float()`, `fractions.Fraction()`
    和 `complex()`。当我们有不是十进制基数的数字时，我们也可以使用 `int()` 来转换，如下面的代码所示：
- en: '[PRE34]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We can create strings from numbers too. We can use functions such as `hex()`,
    `oct()`, and `bin()` to create strings in base 16, 8, and 2\. We also have the
    `str()` function, which is the most general-purpose function to convert any Python
    object into a string of some kind.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从数字创建字符串。我们可以使用 `hex()`, `oct()`, 和 `bin()` 函数来创建基数为16、8和2的字符串。我们还有 `str()`
    函数，这是将任何Python对象转换为某种字符串的最通用函数。
- en: More valuable than these is the `format()` method of a string. This performs
    a variety of value-to-string conversions. It uses a conversion format specification
    or template string to define what the resulting string will look like.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 比这些更有价值的是字符串的 `format()` 方法。它执行各种值到字符串的转换。它使用转换格式指定或模板字符串来定义结果字符串的形状。
- en: 'Here''s an example of using `format()` to convert several values into a single
    string. It uses a rather complex format specification string:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用 `format()` 将几个值转换成单个字符串的例子。它使用了一个相当复杂的格式指定字符串：
- en: '[PRE35]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The format string has three conversion specifications: `{0:12s}`, `{1:6.2f}`,
    and `{2:8.0f}`. It also has some literal text, mostly spaces, but `USD` and `GRD`
    are part of the background literal text into which the data will be merged.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 格式字符串有三个转换指定：`{0:12s}`, `{1:6.2f}`, 和 `{2:8.0f}`。它还有一些文本，主要是空格，但 `USD` 和 `GRD`
    是背景文本的一部分，数据将被合并到其中。
- en: 'Each conversion specification has two parts: the item to convert and the format
    for that item. These two parts separated by a `:` inside `{}`. We''ll look at
    each conversion:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 每个转换指定有两个部分：要转换的项目和该项目的格式。这两个部分用 `{}` 内的 `:` 分隔。我们将逐一查看每个转换：
- en: The item `0` is converted using the `12s` format. This format produces a twelve-position
    string. The string `lunch` was padded out to 12 positions.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 `0` 使用 `12s` 格式进行转换。这个格式产生一个12位的字符串。字符串 `lunch` 被填充到12位。
- en: The item `1` is converted using the `6.2f` format. This format produces a six-position
    string. There will be two positions to the right of the decimal point. The value
    of `lunch_usd` was formatted using this.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 `1` 使用 `6.2f` 格式进行转换。这种格式生成一个六位字符串。小数点右侧将有两位。`lunch_usd` 的值就是使用这种方式进行格式化的。
- en: The item `2` is converted using an `8.0f` format. This format produces an eight-position
    string with no positions to the right of the decimal point. The value of `lunch_grd`
    was formatted using this specification.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目 `2` 使用 `8.0f` 格式进行转换。这种格式生成一个没有小数点右侧位置的八位字符串。`lunch_grd` 的值就是按照这个规范进行格式化的。
- en: 'We can do something like the following to improve our receipt:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做一些类似以下的事情来改进我们的收据：
- en: '[PRE36]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We''ve used two parallel format specifications. The `receipt_1` string can
    be used to format a label and a single dollar value. The `receipt_2` string can
    be used to format a label and two numeric values: one in dollars and the other
    in Greek Drachma.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了两个并行的格式规范。`receipt_1` 字符串可以用来格式化标签和单个美元值。`receipt_2` 字符串可以用来格式化标签和两个数值：一个以美元为单位，另一个以希腊德拉克马为单位。
- en: 'This makes a better-looking receipt. That should keep the accountants off our
    back and let us focus on the real work: working on data files and folders.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这使收据看起来更好。这应该能让会计们远离我们，让我们专注于真正的工作：处理数据文件和文件夹。
- en: Parsing strings
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解析字符串
- en: 'String objects can also be decomposed or parsed into substrings. We could easily
    write an entire chapter on all the various parsing methods that string objects
    offer. A common transformation is to strip extraneous whitespace from the beginning
    and end of a string. The idea is to remove spaces and tabs (and a few other nonobvious
    characters). It looks like this:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串对象也可以被分解或解析成子字符串。我们可以轻松地写一整章关于字符串对象提供的所有各种解析方法。一个常见的转换是从字符串的开始和结束处去除多余的空白字符。想法是去除空格和制表符（以及一些其他不明显字符）。它看起来像这样：
- en: '[PRE37]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We''ve applied the `input()` function to get a string from the user. Then we''ve
    applied the `strip()` method of that string object to create a new string, stripped
    bare of whitespace characters. We can try it from the `>>>` prompt like this:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经应用了 `input()` 函数从用户那里获取一个字符串。然后我们应用了该字符串对象的 `strip()` 方法来创建一个新的字符串，去除了所有空白字符。我们可以像这样从
    `>>>` 提示符尝试它：
- en: '[PRE38]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This shows how a string with junk was pared down to the essentials. This can
    simplify a user's life; a few extra spaces won't be a problem.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了如何将包含杂项的字符串简化为基本要素。这可以简化用户的生活；一些额外的空格不会成问题。
- en: 'Another transformation might be to split a string into pieces. Here''s just
    one of the many techniques available:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种转换可能是将字符串分割成片段。这里只是众多可用技术中的一种：
- en: '[PRE39]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Let''s look at this in detail. First, it''s a multiple-assignment statement,
    where three variables are going to be set: `amount`, `space`, and `currency`.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看。首先，这是一个多赋值语句，其中三个变量将被设置：`amount`、`space` 和 `currency`。
- en: 'The expression, `"123.45 USD".partition(" ")`, works by applying the `partition()`
    method to a literal string value. We''re going to partition the string on the
    space character. The `partition()` method returns three things: the substring
    in front of the partition, the partition character, and the substring after the
    partition.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 `"123.45 USD".partition(" ")` 通过应用 `partition()` 方法到字面字符串值来实现。我们将字符串分割在空格字符上。`partition()`
    方法返回三样东西：分割前的子字符串、分割字符和分割后的子字符串。
- en: 'The actual partition variable may also be assigned an empty string, `''''`.
    Try this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的分割变量也可以被分配一个空字符串，`''`。试试这个：
- en: '[PRE40]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: What are the values for `amount`, `space`, and `currency`?
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`amount`、`space` 和 `currency` 的值是多少？'
- en: If you use `help(str)`, you'll see all of the various kinds of things a string
    can do. The names that have `__` around them map to Python operators. `__add__()`,
    for example, is how the `+` operator is implemented.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 `help(str)`，你会看到字符串可以执行的所有各种类型的事情。周围有 `__` 的名字映射到 Python 操作符。例如，`__add__()`
    是 `+` 操作符的实现方式。
- en: Organizing our software
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织我们的软件
- en: Python gives us a number of ways to organize software into conceptual units.
    Long, sprawling scripts are hard to read, repair, or extend. Python offers us
    packages, modules, classes, and functions. We'll see different organizing techniques
    throughout our agent training. We'll start with function definition.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Python 给我们提供了多种方式来将软件组织成概念单元。长而杂乱的脚本难以阅读、修复或扩展。Python 提供了包、模块、类和函数。我们将在整个代理训练过程中看到不同的组织技术。我们将从函数定义开始。
- en: 'We''ve used a number of Python''s built-in functions in the previous sections.
    Defining our own function is something we do with the `def` statement. A function
    definition allows us to summarize (and in some cases generalize) some processing.
    Here''s a simple function we can use to get a decimal value from a user:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了许多Python的内置函数。定义我们自己的函数是通过`def`语句完成的。函数定义使我们能够总结（在某些情况下是一般化）一些处理。以下是一个我们可以用来从用户获取十进制值的简单函数：
- en: '[PRE41]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This follows the design we showed previously, packaged as a separate function.
    This function will return a proper `Decimal` object: the value of the `value`
    variable. We can use our `get_decimal()` function like this:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了我们之前展示的设计，作为一个单独的函数打包。此函数将返回一个合适的`Decimal`对象：`value`变量的值。我们可以像这样使用我们的`get_decimal()`函数：
- en: '[PRE42]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Python allows a great deal of variability in how argument values are supplied
    to functions. One common technique is to have an optional parameter, which can
    be provided using a keyword argument. The `print()` function has this feature,
    we can name a file by providing a keyword argument value.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许在向函数提供参数值时有很大的灵活性。一种常见的技术是提供一个可选参数，可以使用关键字参数提供。`print()`函数具有此功能，我们可以通过提供关键字参数值来命名一个文件。
- en: '[PRE43]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If we don't provide the `file` parameter, the `sys.stdout` file is used by default.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不提供`file`参数，默认情况下将使用`sys.stdout`文件。
- en: 'We can do this in our own functions with the following syntax:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法在我们的函数中这样做：
- en: '[PRE44]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We defined our `report` function to have two parameters. The `grd_usd` parameter
    is required. The `target` parameter has a default value, so it's optional.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了我们的`report`函数，它有两个参数。`grd_usd`参数是必需的。`target`参数有一个默认值，因此它是可选的。
- en: We're also using a global variable, `PENNY`. This was something we set outside
    the function. The value is usable inside the function.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个全局变量，`PENNY`。这是我们在函数外部设置的。该值在函数内部可用。
- en: 'The four `print()` functions provide the file parameter using the keyword syntax:
    `file=target`. If we provided a value for the `target` parameter, that will be
    used; if we did not provide a value for `target`, the default value of the `sys.stdout`
    file will be used. We can use this function in several ways. Here''s one version:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 四个`print()`函数使用关键字语法提供文件参数：`file=target`。如果我们为`target`参数提供了值，则将使用该值；如果没有提供`target`参数的值，则将使用`sys.stdout`文件的默认值。我们可以以多种方式使用此函数。以下是一个版本：
- en: '[PRE45]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We provided the `grd_usd` parameter value positionally: it''s first. We didn''t
    provide a value for the `target` parameter; the default value will be used.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按位置提供了`grd_usd`参数值：它是第一个。我们没有为`target`参数提供值；将使用默认值。
- en: 'Here''s another version:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个版本：
- en: '[PRE46]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this example, we used the keyword parameter syntax for both the `grd_usd`
    and `target` parameters. Yes, the `target` parameter value recapitulated the default
    value. We'll look at how to create our own files in the next section.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们为`grd_usd`和`target`参数都使用了关键字参数语法。是的，`target`参数的值重复了默认值。我们将在下一节中查看如何创建我们自己的文件。
- en: Working with files and folders
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与文件和文件夹一起工作
- en: Our computer is full of files. One of the most important features of our operating
    system is the way it handles files and devices. Python gives us an outstanding
    level of access to various kinds of files.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计算机充满了文件。我们操作系统最重要的特性之一是它处理文件和设备的方式。Python为我们提供了对各种类型文件的高水平访问。
- en: However, we've got to draw a few lines. All files consist of bytes. This is
    a reductionist view that's not always helpful. Sometimes those bytes represent
    Unicode characters which makes reading the file is relatively easy. Sometimes
    those bytes represent more complex objects which makes reading the file may be
    quite difficult.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须画几条线。所有文件都由字节组成。这是一种还原论的观点，并不总是有帮助的。有时这些字节代表Unicode字符，这使得读取文件相对容易。有时这些字节代表更复杂的对象，这使得读取文件可能相当困难。
- en: Pragmatically, files come in a wide variety of physical formats. Our various
    desktop applications (word processors, spread sheets, and so on) all have unique
    formats for the data. Some of those physical formats are proprietary products,
    and this makes them exceptionally difficult to work with. The contents are obscure
    (not secure) and the cost of ferreting out the information can be extraordinary.
    We can always resort to examining the low-level bytes and recovering information
    that way.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，文件有各种各样的物理格式。我们的各种桌面应用程序（文字处理器、电子表格等）都有独特的数据格式。其中一些物理格式是专有产品，这使得它们特别难以处理。内容是神秘的（不安全的），而挖掘信息可能需要高昂的成本。我们总是可以求助于检查低级字节并以此方式恢复信息。
- en: Many applications work with files in widely standardized formats. This makes
    our life much simpler. The format may be complex, but the fact that it conforms
    to a standard means that we can recover all of the data. We'll look at a number
    of standardized formats for subsequent missions. For now, we need to get the basics
    under our belts.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序都使用广泛标准化的文件格式。这使得我们的生活变得更加简单。格式可能很复杂，但符合标准的事实意味着我们可以恢复所有数据。我们将探讨后续任务中的一些标准化格式。目前，我们需要掌握基础知识。
- en: Creating a file
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建文件
- en: 'We''ll start by creating a text file that we can work with. There are several
    interesting aspects to working with files. We''ll focus on the following two aspects:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个我们可以工作的文本文件。与文件一起工作有几个有趣的方面。我们将关注以下两个方面：
- en: Creating a `file` object. The `file` object is the Python view of an operating
    system resource. It's actually rather complex, but we can access it very easily.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`文件`对象。`文件`对象是Python对操作系统资源的视图。实际上它相当复杂，但我们可以非常容易地访问它。
- en: 'Using the file context. A file has a particular life: open, read or write,
    and then close. To be sure that we close the file and properly disentangle the
    OS resources from the Python object, we''re usually happiest using a file as a
    context manager. Using a `with` statement guarantees that the file is properly
    closed.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件上下文。文件有特定的生命周期：打开、读取或写入，然后关闭。为了确保我们关闭文件并正确地将操作系统资源从Python对象中分离出来，我们通常更喜欢将文件用作上下文管理器。使用`with`语句可以保证文件被正确关闭。
- en: 'Our general template, with `open("message1.txt", "w")` as target, for creating
    a file looks like this:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建文件的通用模板，以`open("message1.txt", "w")`为目标，看起来像这样：
- en: '[PRE47]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We'll open the file with the `open()` function. In this case, the file is opened
    in write mode. We've used the `print()` function to write some data into the file.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`open()`函数打开文件。在这种情况下，文件以写入模式打开。我们使用了`print()`函数将一些数据写入文件。
- en: Once the program finishes the indented context of the `with` statement, the
    file is properly closed and the OS resources are released. We don't need to explicitly
    close the `file` object.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦程序完成`with`语句的缩进上下文，文件将被正确关闭，操作系统资源将被释放。我们不需要显式关闭`文件`对象。
- en: 'We can also use something like this to create our file:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用类似的方法来创建我们的文件：
- en: '[PRE48]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note the important difference here. The `print()` function automatically ends
    each line with a `\n` character. The `write()` method of a file object doesn't
    add anything.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的重要区别。`print()`函数自动在每个行尾添加一个`\n`字符。文件对象的`write()`方法不添加任何内容。
- en: In many cases, we may have more complex physical formatting for a file. We'll
    look at JSON or CSV files in a later section. We'll also look at reading and writing
    image files in [Chapter 3](ch03.html "Chapter 3. Encoding Secret Messages with
    Steganography"), *Encoding Secret Messages with Steganography*.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，文件可能具有更复杂的物理格式。我们将在后面的章节中查看JSON或CSV文件。我们还将查看在[第3章](ch03.html "第3章。使用隐写术编码秘密信息")中读取和写入图像文件，*使用隐写术编码秘密信息*。
- en: Reading a file
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取文件
- en: 'Our general template for reading a file looks like this:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 我们读取文件的通用模板看起来像这样：
- en: '[PRE49]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This will create the `file` object, but it will be in read mode. If the file
    doesn't exist, we'll get an exception. The `read()` function will slurp the entire
    file into a single block of text. Once we're done reading the content of the file,
    we're also done with the `with` context. The file can be closed and the resources
    can be released. The text variable that we created will have the file's contents
    ready for further processing.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个`文件`对象，但它将以读取模式打开。如果文件不存在，我们将得到一个异常。`read()`函数将整个文件吸入一个单独的文本块。一旦我们完成读取文件内容，我们也完成了`with`上下文。文件可以被关闭，资源可以被释放。我们创建的文本变量将包含文件内容，以便进行进一步处理。
- en: 'In many cases, we want to process the lines of the text separately. For this,
    Python gives us the `for` loop. This statement interacts with files to iterate
    through each line of the file, as shown in the following code:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们想要单独处理文本的行。为此，Python为我们提供了`for`循环。这个语句与文件交互，遍历文件的每一行，如下面的代码所示：
- en: '[PRE50]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The output looks a bit odd, doesn't it?
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来有点奇怪，不是吗？
- en: It's double-spaced because each line read from the file contains a `\n` character
    at the end. The `print()` function automatically includes a `\n` character. This
    leads to double-spaced output.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 它是双倍间距的，因为从文件中读取的每一行末尾都包含一个`\n`字符。`print()`函数自动包含一个`\n`字符。这导致输出是双倍间距的。
- en: We have two candidate fixes. We can tell the `print()` function not to include
    a `\n` character. For example, `print(line, end="")` does this.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个候选的修复方案。我们可以告诉`print()`函数不要包含`\n`字符。例如，`print(line, end="")`就是这样做的。
- en: A slightly better fix is to use the `rstrip()` method to remove the trailing
    whitespace from the right-hand end of line. This is slightly better because it's
    something we'll do often in a number of contexts. Attempting to suppress the output
    of the extra `\n` character in the `print()` function is too specialized to this
    one situation.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微好一点的修复方案是使用`rstrip()`方法从行的右侧移除尾随空格。这稍微好一些，因为我们在多个上下文中经常会这样做。试图抑制`print()`函数中额外的`\n`字符的输出过于特定于这种情况。
- en: 'In some cases, we may have files where we need to filter the lines, looking
    for particular patterns. We might have a loop that includes conditional processing
    via the `if` statement, as shown in the following code:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要过滤文件中的行，寻找特定的模式。我们可能有一个包含通过`if`语句进行条件处理的循环，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This shows a typical structure for text processing programs. First, we open
    the file via a `with` statement context; this assures us that the file will be
    closed properly no matter what happens.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了文本处理程序的典型结构。首先，我们通过`with`语句上下文打开文件；这确保无论发生什么情况，文件都将被正确关闭。
- en: 'We use the `for` statement to iterate through all lines of the file. Each line
    has a two-step process: the `rstrip()` method removes trailing whitespace, the
    `partition()` method breaks the line around the keyword `Size`.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`for`语句遍历文件的所有行。每一行都有一个两步的过程：`rstrip()`方法移除尾随空格，`partition()`方法在关键字`Size`周围分割行。
- en: The `if` statement defines a condition (`keyword != ''`) and some processing
    that's done only if the condition is `True`. If the condition is `False` (the
    value of `keyword` is `''`), the indented body of the `if` statement is silently
    skipped.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句定义了一个条件（`keyword != ''''`）以及仅在条件为`True`时执行的一些处理。如果条件为`False`（`keyword`的值为`''''`），则`if`语句的缩进主体将被静默跳过。'
- en: The assignment and `if` statements form the body of the `for` statement. These
    two statements are executed once for every line in the file. When we get to the
    end of the `for` statement, we can be assured that all lines were processed.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值和`if`语句构成了`for`语句的主体。这两个语句在文件的每一行上执行一次。当我们到达`for`语句的末尾时，我们可以确信所有行都已处理。
- en: We have to note that we can create an exception to the usual *for all lines*
    assumption about processing files with the `for` statement. We can use the `break`
    statement to exit early from the loop, breaking the usual assumption. We'd prefer
    to avoid the `break` statement, making it easy to see that a `for` statement works
    for all lines of a file.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意，我们可以使用`break`语句提前退出循环，打破常规的假设。我们更愿意避免使用`break`语句，这样就可以很容易地看到`for`语句适用于文件的每一行。
- en: At the end of the `for` statement, we're done processing the file. We're done
    with the `with` context, too. The file will be closed.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 在`for`语句的末尾，我们完成了对文件的加工。我们也完成了`with`上下文。文件将被关闭。
- en: Defining more complex logical conditions
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义更复杂的逻辑条件
- en: What if we have more patterns than what we're looking for? What if we're processing
    more complex data?
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们寻找的图案比我们预期的多呢？如果我们正在处理更复杂的数据呢？
- en: 'Let''s say we''ve got something like this in a file:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在文件中有类似以下的内容：
- en: '[PRE52]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We''re looking for two keywords: `Rendezvous` and `Pay`. Python gives us the
    `elif` clause as part of the `if` statement. This clause provides a tidy way to
    handle multiple conditions gracefully. Here''s a script to parse a message to
    us from the headquarters:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在寻找两个关键字：`Rendezvous`和`Pay`。Python将`elif`子句作为`if`语句的一部分提供。这个子句提供了一种优雅地处理多个条件的方法。以下是一个解析总部发来的信息的脚本：
- en: '[PRE53]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We''re searching the contents in the file for two pieces of information: the
    rendezvous location and the amount we can use to bribe our contact. In effect,
    we''re going to summarize this file down to two short facts, discarding the parts
    we don''t care about.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在搜索文件内容中的两块信息：会合地点和我们可以用以贿赂联系人的金额。实际上，我们将总结这个文件为两个简短的事实，丢弃我们不关心的部分。
- en: As with the previous examples, we're using a `with` statement to create a processing
    context. We're also using the `for` statement to iterate through all lines of
    the file.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的示例一样，我们使用`with`语句创建一个处理上下文。我们还使用`for`语句遍历文件的所有行。
- en: We've used a two-step process to clean each line. First, we used the `lower()`
    method to create a string in lowercase. Then we used the `rstrip()` method to
    remove any trailing whitespace from the line.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用两步过程来清理每一行。首先，我们使用`lower()`方法创建一个字符串的小写版本。然后我们使用`rstrip()`方法从行中删除任何尾随空格。
- en: We applied the `partition()` method to the cleaned line twice. One partition
    looked for `pay` and the other partition looked for `rendezvous`. If the line
    could be partitioned on `pay`, the `pay` variable (and `pay_data`) would have
    values not equal to a zero-length string. If the line could be partitioned on
    `rendezvous`, then the `meet` variable (and `meet_data`) would have values not
    equal to a zero-length string. The `else, if` is abbreviated `elif` in Python.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对清理后的行应用了`partition()`方法两次。一个分区查找`pay`，另一个分区查找`rendezvous`。如果行可以在`pay`上分区，则`pay`变量（和`pay_data`）的值不会等于空字符串。如果行可以在`rendezvous`上分区，则`meet`变量（和`meet_data`）的值不会等于空字符串。Python中的`else,
    if`被缩写为`elif`。
- en: If none of the previous conditions are true, we don't need to do anything. We
    don't need an `else:` clause. But we decided to include the `else:` clause in
    case we later needed to add some processing. For now, there's nothing more to
    do. In Python, the `pass` statement does nothing. It's a syntactic placeholder;
    a thing to write when we must write something.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前面的所有条件都不成立，我们就不需要做任何事情。我们不需要`else:`子句。但我们决定包含`else:`子句，以防我们以后需要添加一些处理。目前，没有更多的事情要做。在Python中，`pass`语句什么都不做。它是一个语法占位符；当我们必须写点东西时可以写的东西。
- en: Solving problems – recovering a lost password
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决问题——恢复丢失的密码
- en: We'll apply many of our techniques to writing a program to help us poke around
    inside a locked ZIP file. It's important to note that any competent encryption
    scheme doesn't encrypt a password. Passwords are, at worst, reduced to a hash
    value. When someone enters a password, the hash values are compared. The original
    password remains essentially unrecoverable except by guessing.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用许多技术来编写一个程序，帮助我们探索锁定ZIP文件内部。重要的是要注意，任何合格的加密方案都不会加密密码。密码在最坏的情况下，被简化为散列值。当有人输入密码时，会比较散列值。原始密码基本上是无法恢复的，除非通过猜测。
- en: We'll look at a kind of brute-force password recovery scheme. It will simply
    try all of the words in a dictionary. More elaborate guessing schemes will use
    dictionary words and punctuation to form longer and longer candidate passwords.
    Even more elaborate guessing will include *leet speak* replacements of characters.
    For example, using `1337 sp3@k` instead of `leet speak`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一种暴力破解密码的方案。它将简单地尝试字典中的所有单词。更复杂的猜测方案将使用字典单词和标点符号来形成越来越长的候选密码。更复杂的猜测甚至包括字符的*leet
    speak*替换。例如，使用`1337 sp3@k`代替`leet speak`。
- en: 'Before we look into how ZIP files work, we''ll have to find a usable word corpus.
    A common stand-in for a corpus is a spell-check dictionary. For GNU/Linux or Mac
    OS X computers, there are several places a dictionary can be found. Three common
    places are: `/usr/dict/words`, `/usr/share/dict/words`, or possibly `/usr/share/myspell/dicts`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们研究ZIP文件的工作原理之前，我们必须找到一个可用的词库。一个常见的词库替代品是拼写检查字典。对于GNU/Linux或Mac OS X计算机，可以在几个地方找到字典。三个常见的地方是：`/usr/dict/words`、`/usr/share/dict/words`，或者可能是`/usr/share/myspell/dicts`。
- en: Windows agents may have to search around a bit for similar dictionary resources.
    Look in `%AppData%\Microsoft\Spelling\EN` as a possible location. The dictionaries
    are often a `.dic` file. There may also be an associated .`aff` (affix rules)
    file, with additional rules for building words from the stem words (or lemmas)
    in the `.dic` file.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: Windows代理可能需要搜索类似字典资源。查看`%AppData%\Microsoft\Spelling\EN`作为可能的存储位置。字典通常是`.dic`文件。也可能有一个相关的`.aff`（词缀规则）文件，其中包含从`.dic`文件中的词根（或词元）构建单词的额外规则。
- en: If we can't track down a usable word corpus, it may be best to install a standalone
    spell checking program, along with its dictionaries. Programs such as aspell,
    ispell, Hunspell, Open Office, and LibreOffice contain extensive collections of
    spelling dictionaries for a variety of languages.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们找不到可用的词汇语料库，最好安装一个独立的拼写检查程序及其词典。例如，aspell、ispell、Hunspell、Open Office和LibreOffice包含各种语言的广泛拼写词典集合。
- en: There are other ways to get various word corpora. One way is to search all of
    the text files for all of the words in all of those files. The words we used to
    create a password may be reflected in words we actually use in other files.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他方法可以获得各种词汇语料库。一种方法是在所有这些文件中搜索所有单词。我们用来创建密码的单词可能反映在我们实际使用的其他文件中的单词。
- en: Another good approach is to use the Python **Natural Language Toolkit** (**NLTK**),
    which has a number of resources for handling natural language processing. As this
    manual was going to press, a version has been released which works with Python3\.
    See [https://pypi.python.org/pypi/nltk](https://pypi.python.org/pypi/nltk). This
    library provides lexicons, several wordlist corpora, and word stemming tools that
    are far better than simplistic spell-checking dictionaries.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个好方法是使用Python的**自然语言工具包**（**NLTK**），它提供了处理自然语言处理的多种资源。当这本手册即将出版时，已经发布了一个与Python3兼容的版本。请参阅[https://pypi.python.org/pypi/nltk](https://pypi.python.org/pypi/nltk)。这个库提供了词典、几个单词列表语料库和比简单的拼写检查词典更好的单词词干工具。
- en: Your mission is to locate a dictionary on your computer. If you can't find one,
    then download a good spell-check program and use its dictionary. A web search
    for `web2 (Webster's Second International)` may turn up a usable corpus.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是找到你电脑上的词典。如果你找不到，那么下载一个好的拼写检查程序并使用它的词典。通过搜索`web2（韦伯斯特第二国际）`可能找到可用的语料库。
- en: Reading a word corpus
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阅读词汇语料库
- en: The first thing we need to do is read our spell-check corpus. We'll call it
    a corpus—a body of words—not a dictionary. The examples will be based on **web2
    (Webster's Second International) all 234,936 words worth**. This is generally
    available in BSD Unix and Mac OS X.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是阅读我们的拼写检查语料库。我们将称之为语料库——一组词汇，而不是词典。示例将基于**web2（韦伯斯特第二国际）中的全部234,936个单词**。这通常在BSD
    Unix和Mac OS X中可用。
- en: 'Here''s a typical script that will examine a corpus:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个典型的脚本，它将检查语料库：
- en: '[PRE54]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We've opened the corpus file and read all of the lines. The word was located
    by stripping whitespace from the line; this removes the trailing `\n` character.
    An `if` statement was used to filter the 10-letter words. There are 30,878 of
    those, from abalienate to Zyzzogeton.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经打开了语料库文件并读取了所有行。通过从行中去除空白字符找到了单词；这移除了尾随的`\n`字符。使用`if`语句过滤了10个字母的单词。共有30,878个这样的单词，从abalienate到Zyzzogeton。
- en: This little script isn't really part of any larger application. It's a kind
    of technology spike—something we're using to nail down a detail. When writing
    little scripts like this, we'll often skip careful design of classes or functions
    and just slap some Python statements into a file.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小程序实际上并不是任何大型应用程序的一部分。它是一种技术尖峰——我们用它来锁定细节。在编写这样的小程序时，我们通常会跳过类或函数的仔细设计，只是将一些Python语句放入文件中。
- en: 'In POSIX-compliant OSes, we can do two more things to make a script easy to
    work with. First, we can add a special comment on the very first line of the file
    to help the OS figure out what to do with it. The line looks like this:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在POSIX兼容的操作系统上，我们可以做两件事来使脚本更容易使用。首先，我们可以在文件的非常第一行添加一个特殊注释，以帮助操作系统确定如何处理它。该行看起来像这样：
- en: '[PRE55]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This tells the OS how to handle the script. Specifically, it tells the OS to
    use the `env` program. The `env` program will then locate our installation of
    Python 3\. Responsibility will be handed off to the `python3` program.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉操作系统如何处理脚本。具体来说，它告诉操作系统使用`env`程序。然后`env`程序将定位我们的Python 3安装。责任将转交给`python3`程序。
- en: The second step is to mark the script as executable. We use the OS command,
    `chmod +x some_file.py`, to mark a Python file as an executable script.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是将脚本标记为可执行。我们使用操作系统命令`chmod +x some_file.py`将Python文件标记为可执行脚本。
- en: If we've done these two steps, we can execute a script by simply typing its
    name at the command prompt.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们已经完成了这两个步骤，我们只需在命令提示符下键入其名称即可执行脚本。
- en: In Windows, the file extension (`.py`) is associated with the Python program.
    There is an **Advanced Settings** panel that defines these file associations.
    When you installed Python, the association was built by the installer. This means
    that you can enter the name of a Python script and Windows will search through
    the directories named in your `PATH` value and execute that script properly.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows中，文件扩展名（`.py`）与Python程序相关联。有一个**高级设置**面板定义了这些文件关联。当您安装Python时，这个关联是由安装程序建立的。这意味着您可以直接输入Python脚本的名称，Windows会搜索您的`PATH`值中命名的目录，并正确执行该脚本。
- en: Reading a ZIP archive
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取ZIP归档
- en: 'We''ll use Python''s `zipfile` module to work with a ZIP archive. This means
    we''ll need to use `import zipfile` before we can do anything else. Since a ZIP
    archive contains multiple files, we''ll often want to get a listing of the available
    files in the archive. Here''s how we can survey an archive:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Python的`zipfile`模块来处理ZIP归档。这意味着在我们可以做其他任何事情之前，我们需要使用`import zipfile`。由于ZIP归档包含多个文件，我们通常会想要获取归档中可用的文件列表。以下是调查归档的方法：
- en: '[PRE56]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: We've opened the archive, creating a file processing context. We then used the
    archive's `printdir()` method to dump the members of the archive.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了归档，创建了一个文件处理上下文。然后我们使用了归档的`printdir()`方法来输出归档的成员。
- en: 'We can''t, however, extract any of the files because the ZIP archive was encrypted
    and we lost the password. Here''s a script that will try to read the first member:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们无法提取任何文件，因为ZIP归档被加密了，我们丢失了密码。以下是一个尝试读取第一个成员的脚本：
- en: '[PRE57]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We've created a file processing context using the open archive. We used the
    `infolist()` method to get information on each member. The `archive.infolist()[0]`
    statement will pick item zero from the list, that is, the first item.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用打开的归档创建了一个文件处理上下文。我们使用归档的`infolist()`方法获取每个成员的信息。`archive.infolist()[0]`语句将从列表中选取第一个项目，即第一个项目。
- en: 'We tried to create a file processing context for this specific member. Instead
    of seeing the content of the member, we get an exception. The details will vary,
    but your exception message will look like this:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试为这个特定成员创建一个文件处理上下文。而不是看到成员的内容，我们得到了一个异常。细节会有所不同，但您的异常信息将类似于以下内容：
- en: '[PRE58]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The hexadecimal number (`0x1007e78e8`) may not match your output, but you'll
    still get an error trying to read an encrypted ZIP file.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制数（`0x1007e78e8`）可能不匹配您的输出，但您尝试读取加密的ZIP文件时仍会出错。
- en: Using brute-force search
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用暴力搜索
- en: 'To recover the files, we''ll need to resort to brute-force search for a workable
    password. This means inserting our corpora reading loop into our archive processing
    context. It''s a bit of flashy copy-and-paste that leads to a script like the
    following:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 为了恢复文件，我们需要求助于暴力搜索以找到一个可行的密码。这意味着将我们的语料库读取循环插入到我们的归档处理上下文中。这是一些闪亮的复制粘贴操作，导致以下脚本：
- en: '[PRE59]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ve imported two libraries: `zipfile` as well as `zlib`. We added `zlib`
    because it turns out that we''ll sometimes see `zlib.error` exceptions when guessing
    passwords. We created a context for our open archive file. We used the `infolist()`
    method to get names of members and fetched just the first file from that list.
    If we can read one file, we can read them all.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了两个库：`zipfile`以及`zlib`。我们添加`zlib`是因为我们发现，在猜测密码时，有时会看到`zlib.error`异常。我们为打开的归档文件创建了一个上下文。我们使用`infolist()`方法获取成员的名称，并从该列表中获取第一个文件。如果我们能读取一个文件，我们就能读取所有文件。
- en: 'Then we opened our corpus file, and created a file processing context for that
    file. For each line in the corpora, we used two methods of the line: the `strip()`
    method will remove the trailing `"\n"`, and the `encode("ASCII")` method will
    transform the line from Unicode characters to ASCII bytes. We need this because
    ZIP library passwords are ASCII bytes, not proper Unicode character strings.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们打开了我们的语料库文件，并为该文件创建了一个文件处理上下文。对于语料库中的每一行，我们使用了两种方法：`strip()`方法将删除尾随的`"\n"`，而`encode("ASCII")`方法将把行从Unicode字符转换为ASCII字节。我们需要这样做，因为ZIP库密码是ASCII字节，而不是正确的Unicode字符字符串。
- en: The `try:` block attempts to open and read the first member. We created a file
    processing context for this member within the archive. We tried to read the member.
    If anything goes wrong while we are trying to read the encrypted member, an exception
    will be raised. The usual culprit, of course, is attempting to read the member
    with the wrong password.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`try:` 块尝试打开并读取第一个成员。我们在归档中为这个成员创建了一个文件处理上下文。我们尝试读取成员。如果在尝试读取加密成员的过程中发生任何错误，将会引发异常。当然，通常的罪魁祸首是尝试用错误的密码读取成员。'
- en: If everything works well, then we guessed the correct password. We can print
    the recovered password, as well as the text of the member as a confirmation.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，那么我们就猜对了正确的密码。我们可以打印出恢复的密码，以及成员的文本作为确认。
- en: Note that we've used a `break` statement to end the corpora processing `for`
    loop. This changes the `for` loop's semantics from `for all words` to `there exists
    a word`. The `break` statement means the loop ends as soon as a valid password
    is found. No further words in the corpus need to be processed.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经使用 `break` 语句来结束语料库处理的 `for` 循环。这改变了 `for` 循环的语义，从 `for all words` 变为
    `there exists a word`。`break` 语句意味着一旦找到有效的密码，循环就会结束。不需要进一步处理语料库中的其他单词。
- en: We've listed three kinds of exceptions that might be raised from attempting
    to use a bad password. It's not obvious why different kinds of exceptions may
    be raised by wrong passwords. But it's easy to run some experiments to confirm
    that a variety of different exceptions really are raised by a common underlying
    problem.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们列出了三种可能因尝试使用不良密码而引发的异常。为什么不同类型的异常可能由错误的密码引发并不明显。但进行一些实验来确认确实存在一个共同的根本问题引发了各种不同的异常是很容易的。
- en: Summary
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we saw the basics of our espionage toolkit: Python and our
    text editor of choice. We''ve worked with Python to manipulate numbers, strings,
    and files. We saw a number of Python statements: assignment, `while`, `for`, `if`,
    `elif`, `break`, and `def`. We saw how an expression (such as `print("hello world")`)
    can be used as a Python statement.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了我们间谍工具包的基础：Python 和我们选择的文本编辑器。我们已经使用 Python 来操作数字、字符串和文件。我们看到了许多 Python
    语句：赋值、`while`、`for`、`if`、`elif`、`break` 和 `def`。我们看到了一个表达式（例如 `print("hello world")`）如何被用作
    Python 语句。
- en: We also looked at the Python API for processing a ZIP file. We saw how Python
    works with popular file-archive formats. We even saw how to use a simple corpus
    of words to recover a simple password.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了处理 ZIP 文件的 Python API。我们看到了 Python 如何与流行的文件归档格式协同工作。我们甚至看到了如何使用简单的单词语料库来恢复简单的密码。
- en: Now that we have the basics, we're ready for more advanced missions. The next
    thing we've got to do is start using the World Wide Web (WWW) to gather information
    and carry it back to our computer.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基础知识，我们准备进行更高级的任务。接下来，我们必须开始使用万维网（WWW）来收集信息并将其带回我们的电脑。
