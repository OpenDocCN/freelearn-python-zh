- en: Chapter 4. Extending the Framework
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 扩展框架
- en: This chapter is a bit different from all the previous chapters because it focuses
    on external libraries that provide interaction between the Robot Framework and
    the other software over which Robot Framework runs. This is important as the integration
    with other leading software is the cornerstone of this framework. Therefore, we
    need to be aware of the various libraries that are present as well as know how
    to create a custom library for the framework if there is not any.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章与所有前面的章节都略有不同，因为它侧重于提供 Robot Framework 与 Robot Framework 运行的其他软件之间交互的外部库。这对于与其他领先软件的集成是这个框架的基石。因此，我们需要了解现有的各种库，以及如果不存在任何库，如何为框架创建自定义库。
- en: Until now, all the examples have only used the `log` function present in the
    built-in library as this was the easiest way to demonstrate output on running
    the framework. While this was easy to understand, it didn't explain how acceptance
    testing is supposed to work in real world scenarios.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有示例都只使用了内置库中的 `log` 函数，因为这是最容易演示框架运行时输出的方式。虽然这很容易理解，但它并没有解释在现实世界场景中验收测试应该如何工作。
- en: 'In this chapter, various third-party libraries are covered, which extend the
    Robot Framework in myriad ways. Briefly put, the following would be covered in
    this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，将介绍各种第三方库，这些库以多种方式扩展了 Robot Framework。简而言之，本章将涵盖以下内容：
- en: Web application testing through Selenium
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Selenium 进行 Web 应用程序测试
- en: Debugging Selenium-based Robot Framework code through the REPL shell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 REPL shell 调试基于 Selenium 的 Robot Framework 代码
- en: Testing Java-based desktop applications through the Swing library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Swing 库测试基于 Java 的桌面应用程序
- en: Introduction to image-based automation through Sikuli
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 Sikuli 介绍基于图像的自动化
- en: Creation of a custom Robot Framework library for Sikuli
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 Sikuli 创建自定义 Robot Framework 库
- en: Overview of other libraries that assist in writing acceptance tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他辅助编写验收测试的库概述
- en: To demonstrate the integration with a third-party library, we will finally proceed
    with using the Sikuli tool to capture and replay the mouse and keyboard actions,
    and using image-based computer vision to create a fully-fledged acceptance testing
    solution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示与第三方库的集成，我们最终将使用 Sikuli 工具来捕获和回放鼠标和键盘操作，并使用基于图像的计算机视觉来创建一个完整的验收测试解决方案。
- en: Testing the web applications
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Web 应用程序
- en: Today, most of the commonly used software in use are present on the Web as it
    has become the common medium to interact with huge amount of users worldwide.
    Creation of a web-based solution is not only getting easier by the day (as new
    technologies are coming up and the old ones are getting matured, optimized, and
    obsolete), but the connectivity, ease of use, and sophistication for web application
    clients are also increasing. Thus, the web applications which interact with the
    world today have almost negligible lead time between their development and end
    user interaction. Acceptance testing thus becomes essential as changes in the
    software must be validated quickly to ensure basic correctness and existence of
    basic functionality before they go live into the production.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，大多数常用的软件都以网络形式存在，因为网络已成为与全球大量用户互动的通用媒介。创建基于网络的解决方案不仅越来越容易（随着新技术的发展，旧技术逐渐成熟、优化和过时），而且网络应用程序客户端的连通性、易用性和复杂性也在增加。因此，今天与世界互动的网络应用程序在开发和最终用户互动之间几乎没有可忽略的领先时间。因此，验收测试变得至关重要，因为软件的变化必须迅速得到验证，以确保在它们投入生产之前基本正确性和基本功能的存在。
- en: Selenium
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Selenium
- en: Selenium is a web browser automation tool that provides recording and playback
    facilities. It can be used to create simple scripts that can automate actions
    on browser and web pages by using various objects present in the browser. As it
    is a leading web browsing automation tool, there are various resources available
    for it. As a browser runner, various browsers have Selenium as a plugin/extension
    and can be installed within the browser itself. However, while running the custom
    examples, a Selenium-based server is required, which is present in an embedded
    JAR file that can be called directly. Originally, it came with a remote controller,
    which required a Selenium remote control server that managed browsers' web requests
    from the browsers. However, owing to the popular requests to simplify the development
    requirements, Selenium2 was created that used WebDriver to manage the browsers
    directly and perform operations, such as file upload and popup management directly
    from the browser. Through the use of WebDriver, the Selenium tests can be made
    more flexible and made to work in browsers that were not possible to be used by
    Selenium before.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Selenium是一个网页浏览器自动化工具，它提供了录制和回放功能。它可以用来创建简单的脚本，通过使用浏览器中的各种对象来自动化浏览器和网页上的操作。作为领先的网页浏览自动化工具，它有许多资源可用。作为浏览器运行器，各种浏览器都有Selenium作为插件/扩展，并且可以在浏览器内部安装。然而，在运行自定义示例时，需要一个基于Selenium的服务器，它存在于一个嵌入的JAR文件中，可以直接调用。最初，它附带了一个远程控制器，需要一个Selenium远程控制服务器来管理来自浏览器的浏览器请求。然而，由于简化开发需求的普遍请求，Selenium2被创建出来，它使用WebDriver直接管理浏览器并执行操作，如文件上传和弹出窗口管理，直接从浏览器执行。通过使用WebDriver，Selenium测试可以变得更加灵活，并且可以在Selenium之前无法使用的浏览器中运行。
- en: The Robot Framework Selenium library
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Robot Framework Selenium库
- en: This library provides a bridge between the Robot Framework and the Selenium
    WebDriver engine. Through this, various Selenium commands can be issued directly
    from the Robot Framework test files. There exist separate libraries for Selenium1
    as well as Selenium2 and depending upon the Selenium version, one can choose an
    appropriate library. There is no need to despair though, as Selenium2 library
    is largely built upon the contents of the Selenium library. One thing to be noted
    is that if Selenium is running with a separate server (an embedded Jetty server),
    then remote control driver is needed, otherwise the WebDriver can easily be chosen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此库在Robot Framework和Selenium WebDriver引擎之间提供了一个桥梁。通过它，可以直接从Robot Framework测试文件中发出各种Selenium命令。也存在针对Selenium1和Selenium2的单独库，根据Selenium的版本，可以选择合适的库。不过，无需绝望，因为Selenium2库在很大程度上是基于Selenium库的内容构建的。需要注意的是，如果Selenium与一个单独的服务器（一个嵌入的Jetty服务器）一起运行，则需要远程控制驱动器，否则WebDriver可以轻松选择。
- en: 'To install this library, `pip` can be used and depending upon the set up, sudo/admin
    privileges may be required:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装此库，可以使用`pip`，并且根据设置，可能需要sudo/admin权限：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The detailed documentation is present at [http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html](http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html),
    which can be quite handy while developing these applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 详细文档位于[http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html](http://rtomac.github.io/robotframework-selenium2library/doc/Selenium2Library.html)，在开发这些应用程序时非常有用。
- en: Running web-based tests
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行基于Web的测试
- en: 'In the example, a small website has been created using flask, which is a Python-based
    micro framework to create dynamic websites. To run the example, flask would be
    required at the local Python setup, which can be installed as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，使用基于Python的微框架Flask创建了一个小型网站，这是一个用于创建动态网站的框架。要运行示例，需要在本地Python设置中安装Flask，可以按照以下方式安装：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After installing flask, traverse to the `flaskApp` directory via command line
    and run the demo website by running its main controller file:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Flask后，通过命令行切换到`flaskApp`目录，并通过运行其主控制器文件来运行演示网站：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This starts up the flask on `localhost:5000`, and displays the following window:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在`localhost:5000`上启动Flask，并显示以下窗口：
- en: '![Running web-based tests](img/3033OS_04_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![运行基于Web的测试](img/3033OS_04_01.jpg)'
- en: On entering wrong username/password an error is displayed on the same page.
    Here, the contents of the form are not persisted and only the presence of an error
    message indicates that a wrong username/password combination has been tried previously.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入错误的用户名/密码时，同一页面上会显示错误信息。在这里，表单的内容不会被保留，只有错误信息的出现才表明之前尝试过错误的用户名/密码组合。
- en: 'The following screenshot shows the error when a wrong username/password combination
    is tried:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了尝试错误用户名/密码组合时的错误：
- en: '![Running web-based tests](img/3033OS_04_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![运行基于 Web 的测试](img/3033OS_04_02.jpg)'
- en: 'The application redirects to the respective page if the login is successful,
    which also provides a confirmation text mentioning the successful login as well
    as provides a URL for logging again, if there is any need to do that again, as
    shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果登录成功，应用程序将重定向到相应的页面，该页面还提供了一条确认文本，说明登录成功，并提供了一个 URL，以便在需要再次登录时使用，如下面的截图所示：
- en: '![Running web-based tests](img/3033OS_04_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![运行基于 Web 的测试](img/3033OS_04_03.jpg)'
- en: Using the Selenium2Library
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Selenium2Library
- en: 'To perform the same task through the Robot Framework, following test can be
    written with the help of `robotframework-selenium2 library`, which was discussed
    previously:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过 Robot Framework 执行相同任务，可以使用之前讨论过的 `robotframework-selenium2 library` 编写以下测试：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This test assumes that the Selenium browser is already set up. There are a
    few variables in use that are quite obvious by their names. The test code is explained
    as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试假设 Selenium 浏览器已经设置好。使用了一些变量，其名称非常明显。以下是测试代码的解释：
- en: On start of the test case, go to the specified URL.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在测试用例开始时，转到指定的 URL。
- en: Assert that the title of the page is `My Application.`
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言页面标题为 `My Application.`。
- en: Assert that the page contains the desired elements.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言页面包含所需的元素。
- en: Enter the valid user in the **Name** text field.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**名称**文本框中输入有效的用户名。
- en: Enter the valid password in the **Password** text field.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**密码**文本框中输入有效的密码。
- en: Instruct Selenium to click on the **Submit** button, the browser then issues
    the form action.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指示 Selenium 点击 **提交** 按钮，浏览器随后发出表单操作。
- en: As a result, the browser is redirected to another page, the URL of which is
    checked.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，浏览器被重定向到另一个页面，检查该页面的 URL。
- en: To see and run this full test, you are encouraged to check out the test code
    as well as view the Selenium library. Similarly, you can also assert contents
    in various pages for some specific text as a form of testing by using the `page
    should contain` keyword.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看和运行此完整测试，建议查看测试代码以及查看 Selenium 库。同样，您也可以使用 `page should contain` 关键字来测试各个页面中的特定文本内容。
- en: Debugging through the REPL shell
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过 REPL shell 进行调试
- en: 'If you are starting with the Selenium library, you will face problems in setting
    up the entire Selenium setup. Thankfully, there is a tool that helps you run the
    test operations one at a time. This is known as the debug-library and is an REPL
    shell. **REPL** (**Read Evaluate Print Loop**) like any other console, only accepts
    a single line and presents its output before requiring the next line. This is
    quite similar to shells present in various other languages. Its source code is
    present at:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你刚开始使用 Selenium 库，你会在设置整个 Selenium 环境时遇到问题。幸运的是，有一个工具可以帮助你一次运行一个测试操作。这个工具被称为
    debug-library，它是一个 REPL shell。**REPL**（**读取-评估-打印循环**）就像任何其他控制台一样，只接受一行输入，并在要求输入下一行之前显示其输出。这与其他语言的
    shell 非常相似。它的源代码位于：
- en: '[https://github.com/xyb/robotframework-debuglibrary](https://github.com/xyb/robotframework-debuglibrary)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/xyb/robotframework-debuglibrary](https://github.com/xyb/robotframework-debuglibrary)'
- en: 'To install this on a machine running Python with its packaging manager, use
    the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行 Python 且具有其包管理器的机器上安装此工具，请使用以下命令：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After installing this, a command, `rfshell` is available. You can use it to
    perform basic operations and Selenium-specific tasks. The following screenshot
    shows an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装此工具后，将可用一个命令 `rfshell`。您可以使用它执行基本操作和 Selenium 特定任务。以下截图显示了示例：
- en: '![Debugging through the REPL shell](img/3033OS_04_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![通过 REPL shell 进行调试](img/3033OS_04_04.jpg)'
- en: As soon as `exit` is entered in the shell, it exits and a report HTML file is
    generated at the `home` folder of the user.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在 shell 中输入 `exit`，它就会退出，并在用户的 `home` 文件夹中生成一个报告 HTML 文件。
- en: Note
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that there is no log or XML file generated anywhere for this.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此操作不会在任何地方生成日志或 XML 文件。
- en: Testing desktop applications
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试桌面应用程序
- en: Acceptance testing can also be implemented in desktop-based applications, making
    the Robot Framework tests far more applicable rather than just catering to the
    needs of some specific problem or a framework alone.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试也可以在基于桌面的应用程序中实现，这使得 Robot Framework 测试不仅适用于解决某些特定问题，而且更加适用。
- en: Testing through objects – Java Swing
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过对象进行测试 – Java Swing
- en: 'Swing library is a fully featured library that can be used to test Java Swing-based
    applications. As this works on Java platform, this needs Jython runtime. To run
    an acceptance test over a swing application, two things are required in the `classpath`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Swing库是一个功能齐全的库，可用于测试基于Java Swing的应用程序。由于它运行在Java平台上，因此需要Jython运行时。要对Swing应用程序进行验收测试，`classpath`中需要两个东西：
- en: Swing library JAR
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swing库JAR
- en: The actual swing application bundled as a JAR
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际捆绑为JAR的Swing应用程序
- en: 'On having the necessary files, the test can be used. The classpath can be set
    prior to the Jython command, or prefixed with the command itself like the following
    example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有必要的文件后，可以使用测试。可以在Jython命令之前设置classpath，或者像以下示例那样将其作为命令的前缀：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, the `swinglibrary` is version 1.6.0 and the system under test is bundled
    as `myApp.jar`, and the Robot Framework files are present in the `testsuites`
    folder. The application is then visible to the Robot Framework test file and can
    be accessed through its fully packaged Java Swing name. The settings table of
    the test scripts will require the `swinglibrary` to be loaded in order to provide
    all the Swing library specific keywords.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`swinglibrary`的版本是1.6.0，而系统测试捆绑为`myApp.jar`，Robot Framework文件位于`testsuites`文件夹中。然后，应用程序对Robot
    Framework测试文件可见，可以通过其完全打包的Java Swing名称访问。测试脚本的设置表需要加载`swinglibrary`，以便提供所有Swing库特定的关键字。
- en: A Swing test
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个Swing测试
- en: 'Given the following application, the test will cover adding and deleting items
    to and from the given **Todo List**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下应用程序，测试将涵盖向给定的**待办事项列表**添加和删除项目：
- en: '![A Swing test](img/3033OS_04_05.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![一个Swing测试](img/3033OS_04_05.jpg)'
- en: Just by looking at this Swing application, it is not distinguishable which text
    field, table, or any other UI element is talked about, so black box testing will
    not be successful in this case and we need some internals, such as various component
    names to interact with them. This might feel similar to Selenium as both the libraries
    provide object-based testing that requires knowledge of the internals of the system
    under test by the tests themselves.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过查看此Swing应用程序，无法区分所讨论的是哪个文本字段、表格或任何其他UI元素，因此在这种情况下黑盒测试不会成功，我们需要一些内部信息，例如各种组件名称来与之交互。这可能会让人联想到Selenium，因为这两个库都提供基于对象的测试，测试本身需要了解被测系统的内部结构。
- en: 'Following is the test required to cover various use cases this UI has to offer:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的测试是覆盖此UI提供的各种用例所需的：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This can be explained briefly as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简要解释如下：
- en: Run the Java application through the `Start Application` keyword using the fully
    qualified name of the Java application (that is, the package and the class name)
    which is needed to run the application from the JAR file
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Java应用程序的完全限定名称（即包和类名）通过`Start Application`关键字运行Java应用程序，这是从JAR文件运行应用程序所需的
- en: Select the correct window, which also ascertains that the application has the
    desired window
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择正确的窗口，这也确保了应用程序具有所需的窗口
- en: Check for other basic assumptions, such as the state of various elements
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查其他基本假设，例如各种元素的状态
- en: Perform various UI operations through intuitively named keywords for the same
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过直观命名的关键字执行各种UI操作
- en: After typing text and clicking on the **Add Todo** button, the `todolist` size
    should increase
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在输入文本并点击**添加待办事项**按钮后，`todolist`的大小应该增加
- en: Similarly, other operations for the UI can be performed. Like other external
    libraries, it is helpful to have its library documentation by the side while writing
    tests in this library.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以执行其他UI操作。像其他外部库一样，在编写测试时旁边有它的库文档是有帮助的。
- en: Testing through images
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过图像进行测试
- en: This section covers image-based testing, which is different from what has been
    covered so far. In image-based testing, the user interface is treated as a black
    box and no object internals of the applications are exposed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本节涵盖基于图像的测试，这与迄今为止所涵盖的内容不同。在基于图像的测试中，用户界面被视为黑盒，不暴露应用程序的对象内部结构。
- en: Sikuli
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sikuli
- en: 'Sikuli is a leading tool that performs automation through computer vision,
    that is, recognition of images on the screen. As a human being, we can distinguish
    an object''s properties by looking at it, but this is not straightforward in case
    of computers as computers can only match binary or textual information. Thus,
    there is a need for computer vision or knowing if a given image is present on
    a larger screen or not. In simple sense, Sikuli uses the user-supplied screenshot
    images to perform action over various items and displays the generated script
    visually in the Sikuli IDE. Following is one such script to do a search:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Sikuli是一个领先的通过计算机视觉进行自动化的工具，即识别屏幕上的图像。作为人类，我们可以通过观察来区分一个对象的属性，但在计算机的情况下并不简单，因为计算机只能匹配二进制或文本信息。因此，需要计算机视觉或知道给定的图像是否出现在更大的屏幕上。简单来说，Sikuli使用用户提供的截图图像来执行对各种项目的操作，并在Sikuli
    IDE中以可视化的方式显示生成的脚本。以下是一个进行搜索的脚本示例：
- en: '![Sikuli](img/3033OS_04_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![Sikuli](img/3033OS_04_06.jpg)'
- en: 'As is evident from the image, the script does the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如图像所示，脚本执行以下操作：
- en: Check if the Chrome browser icon exists on the screen
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查屏幕上是否存在Chrome浏览器图标
- en: Click on the Chrome browser to open it
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击Chrome浏览器以打开它
- en: Wait for the browser window to open up and display the URL
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待浏览器窗口打开并显示URL
- en: Go to [google.com](http://google.com) in the URL bar, which will open up the
    Google home page
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在URL栏中转到[google.com](http://google.com)，这将打开Google首页
- en: Wait for the Google search buttons to show up
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待Google搜索按钮出现
- en: Perform the desired query in the appropriate text field
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的文本字段中执行所需的查询
- en: Verify the results obtained
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证获得的结果
- en: The Sikuli page should appear on the first page of results
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sikuli页面应出现在结果的第一页
- en: 'However, behind the scenes, the following Python script is generated in the
    folder where this Sikuli script is saved:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在幕后，以下Python脚本在保存此Sikuli脚本的文件夹中生成：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Apart from this Python script (or its HTML equivalent), there exist various
    images that are referenced in the test. The important thing is that at runtime,
    Sikuli runs computer vision software at its core that determines whether it gets
    a match for the image in the screen and acts accordingly. There is absolutely
    no need for having any knowledge of internals of the software under test. While
    this might seem counterintuitive at first, the lack of control over components
    and objects is compensated through image-based testing that liberates the test
    from the system under test, and the tests can thus operate over a wide variety
    of software platforms, from different desktop applications, mobile emulators,
    mainframe terminals, web-based, and remote applications using only the contents
    displayed on the screen as a basis for its input and decision making ability,
    just like a human being which is performing manual automated acceptance testing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个Python脚本（或其HTML等价物）之外，测试中还引用了各种图像。重要的是，在运行时，Sikuli在其核心运行计算机视觉软件，以确定屏幕上是否存在与图像匹配的内容，并据此采取行动。完全没有必要了解正在测试的软件的内部结构。虽然一开始这可能看起来有些反直觉，但通过基于图像的测试来弥补对组件和对象的控制不足，从而将测试从测试系统中解放出来，因此测试可以在各种软件平台上运行，从不同的桌面应用程序、移动模拟器、主机终端、基于Web的应用程序和远程应用程序，只需将屏幕上显示的内容作为其输入和决策能力的依据，就像进行手动自动化验收测试的人类一样。
- en: Creating a custom Sikuli library
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建自定义Sikuli库
- en: Out of the box, the Robot Framework seems like a complex framework and creation
    of an external user library looks like a tedious task. However, there are times
    when requirements dictate the need of acceptance test solutions for this. Fortunately,
    open source solutions like Sikuli have an extensible application platform that
    is also very well documented. The custom integration of Sikuli with Robot Framework
    is created and demonstrated by *Mykhailo Moroz* ([http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html](http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html)).
    The approach used in this method is discussed in the following section.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始，Robot Framework看起来像是一个复杂的框架，而创建外部用户库似乎是一项繁琐的任务。然而，有时需求会要求为这种需求提供验收测试解决方案。幸运的是，像Sikuli这样的开源解决方案有一个可扩展的应用平台，并且文档也非常完善。Sikuli与Robot
    Framework的定制集成是由*Mykhailo Moroz*创建并展示的([http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html](http://blog.mykhailo.com/2011/02/how-to-sikuli-and-robot-framework.html))。该方法中使用的策略将在下一节中讨论。
- en: In order to use the Sikuli as a test validation engine, its API ([http://doc.sikuli.org/javadoc](http://doc.sikuli.org/javadoc))
    has to be exposed first, which can be done via a clever hack that uses the Python
    classes used internally in Sikuli. Since this will work in Jython environment,
    there is a need to have `sikuli-script.jar` in the classpath and create a wrapper
    around the Sikuli API in order to use various methods. The Sikuli API contains
    a `Screen` class that has various methods.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Sikuli 作为测试验证引擎使用，必须首先公开其 API ([http://doc.sikuli.org/javadoc](http://doc.sikuli.org/javadoc))，这可以通过使用
    Sikuli 内部使用的 Python 类的巧妙技巧来完成。由于这将工作在 Jython 环境中，因此需要在类路径中包含 `sikuli-script.jar`
    并创建一个围绕 Sikuli API 的包装器，以便使用各种方法。Sikuli API 包含一个具有各种方法的 `Screen` 类。
- en: 'To make these methods present in the `Screen` class global, these methods are
    manually pushed into the internal global directory and are overridden by customized
    individual methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些方法在 `Screen` 类中全局可用，这些方法被手动推入内部全局目录，并由自定义的单独方法覆盖：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This lookup is then used to pass the values from the customized methods into
    the native code that is present internally in the Sikuli engine. For instance,
    the `click` method can be implemented as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此查找随后用于将自定义方法中的值传递到 Sikuli 引擎内部存在的本地代码。例如，`click` 方法可以如下实现：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This wrapper allows the creation of simple Python scripts that can run in Jython
    environment without requiring the Sikuli X test runner. As there is already `sikuli-script.jar`
    in the classpath, the tests so created can run without the Sikuli IDE, or in the
    headless mode.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此包装器允许创建简单的 Python 脚本，这些脚本可以在 Jython 环境中运行，而无需 Sikuli X 测试运行器。由于类路径中已经存在 `sikuli-script.jar`，因此创建的测试可以在没有
    Sikuli IDE 或在无头模式下运行。
- en: As these scripts can run independently in the Jython environment, these can
    be run through Jybot that can employ various Robot Framework scripts that can
    call these script functions. This creates a solution to drive a collection of
    multiple Sikuli scripts as test cases in such an order that performs a large task
    through the collection of different small scripts.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些脚本可以在 Jython 环境中独立运行，因此可以通过 Jybot 运行它们，Jybot 可以使用各种 Robot Framework 脚本调用这些脚本函数。这创建了一个解决方案，通过收集不同的小型脚本执行大量任务，以这种方式驱动多个
    Sikuli 脚本作为测试用例：
- en: 'To run this example, we need to have the following prerequisites:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此示例，我们需要以下先决条件：
- en: The Robot Framework installed correctly with the Jython runtime
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Robot Framework 正确安装，并带有 Jython 运行时
- en: Sikuli is installed properly and `sikuli-home` environment variable points to
    its root folder
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sikuli 已正确安装，并且 `sikuli-home` 环境变量指向其根文件夹
- en: 'The following commands in the batch file runs the application by setting up
    the environment needed for all the softwares involved:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 批处理文件中的以下命令通过设置所有涉及软件所需的环境来运行应用程序：
- en: '[PRE11]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Since, we are using different Sikuli scripts as different test cases, we will
    import these as custom tests in our Robot Framework test files, which are kept
    in the `testlib` folder in order to keep things simple in this example:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用不同的 Sikuli 脚本作为不同的测试用例，因此我们将这些脚本作为自定义测试导入我们的 Robot Framework 测试文件中，这些文件保存在
    `testlib` 文件夹中，以使示例中的事情保持简单：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `library` file is actually a customized Sikuli script written in Python
    that calls the Sikuli API to work as a headless Sikuli instance:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`library` 文件是一个用 Python 编写的自定义 Sikuli 脚本，它调用 Sikuli API 以作为无头 Sikuli 实例运行：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To make these tests image-based, you can call functions such as `click`, `validate`,
    `type`, and so on, with the path to the sample image file used as its input argument.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这些测试基于图像，你可以调用 `click`、`validate`、`type` 等函数，并将用于输入参数的样本图像文件的路径作为其输入参数：
- en: 'Apart from the `test` and `library` files, there is a `sikuliwrapper.py` file,
    which provides Sikuli methods into these library file invocations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `test` 和 `library` 文件外，还有一个 `sikuliwrapper.py` 文件，它将这些 Sikuli 方法提供到库文件调用中：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Similarly, other Sikuli API calls can also be wrapped to provide an easy interface
    to the library file, which in turn is called by the Robot Framework test.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，其他 Sikuli API 调用也可以被包装起来，为库文件提供一个易于使用的接口，反过来，库文件又被 Robot Framework 测试调用：
- en: 'However, in case of image-based testing, failures should be descriptive. To
    do this, screenshot can be taken at the instance when something fails or succeeds,
    which requires you to create a custom logger:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在基于图像的测试中，失败应该是有描述性的。为此，可以在失败或成功发生的实例时截取屏幕截图，这需要你创建一个自定义记录器：
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'These are the essential files required to properly run and log the Sikuli-based
    applications easily with the Robot Framework. The output can be viewed in the
    following example by opening notepad and running the application:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是运行和记录基于 Sikuli 的应用程序所需的必要文件，可以轻松地使用 Robot Framework。输出可以在以下示例中查看，通过打开记事本并运行应用程序：
- en: '![Creating a custom Sikuli library](img/3033OS_04_07.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义 Sikuli 库](img/3033OS_04_07.jpg)'
- en: Other noteworthy libraries
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他值得注意的库
- en: There are various other libraries that extend the capabilities of the Robot
    Framework in areas that are not normally seen as candidates for acceptance tests,
    but will benefit from test automation, if done in the right way. Some of these
    libraries are as follows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着许多其他库，它们扩展了 Robot Framework 在通常不被视为验收测试候选区域的功能。如果以正确的方式进行，这些库将受益于测试自动化。以下是一些这些库的例子。
- en: Testing network protocols
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试网络协议
- en: 'Rambock is a test library that provides an easy way to test various network
    packets, protocols, and message templates:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Rambock 是一个测试库，它提供了一种简单的方式来测试各种网络数据包、协议和消息模板：
- en: '[https://github.com/robotframework/Rammbock](https://github.com/robotframework/Rammbock)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[Robotframework Rammbock 库](https://github.com/robotframework/Rammbock)'
- en: It allows you to specify the custom protocol, its client and servers; messages,
    and both the traditional as well as custom protocols can be tested.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许你指定自定义协议、其客户端和服务器；消息，以及传统和自定义协议都可以进行测试。
- en: Testing the web services
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试网络服务
- en: 'Suds is a lightweight. but dynamic SOAP Python client for consuming web services:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Suds 是一个轻量级但动态的 SOAP Python 客户端，用于消费网络服务：
- en: '[https://github.com/ombre42/robotframework-sudslibrary](https://github.com/ombre42/robotframework-sudslibrary)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[Robotframework Suds 库](https://github.com/ombre42/robotframework-sudslibrary)'
- en: Testing the database
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据库
- en: 'The database persistence and contents can be tested through the `robotframework-databaselibrary`.
    Here the database is queried to find out its state and perform things, such as
    running the SQL scripts:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `robotframework-databaselibrary` 测试数据库的持久性和内容。在这里，数据库被查询以找出其状态并执行一些操作，例如运行
    SQL 脚本：
- en: '[http://franz-see.github.io/Robotframework-Database-Library](http://franz-see.github.io/Robotframework-Database-Library)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[Robotframework 数据库库](http://franz-see.github.io/Robotframework-Database-Library)'
- en: 'A similar library exists for interacting through JDBC, which is handy especially
    for databases that otherwise are not supported for testing:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 存在着一个类似的库，用于通过 JDBC 进行交互，这对于不支持测试的数据库来说特别有用：
- en: '[https://github.com/ThomasJaspers/robotframework-dblibrary](https://github.com/ThomasJaspers/robotframework-dblibrary)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[Robotframework 数据库库](https://github.com/ThomasJaspers/robotframework-dblibrary)'
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, a lot of external tools and libraries were discussed that extend
    the capabilities of the Robot Framework. First the web application testing was
    demonstrated through Selenium and its REPL shell that is handy to debug applications.
    Next, Java-based desktop application testing through the use of object-based testing
    was demonstrated. The Sikuli application and image-based testing was explained
    along with an in-depth case study which further explored the extensibility of
    its API to create a Robot Framework-friendly solution. Finally, some of the other
    popular libraries were listed.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，讨论了许多外部工具和库，它们扩展了 Robot Framework 的功能。首先，通过 Selenium 和其方便的 REPL shell 展示了网络应用程序测试，该
    shell 用于调试应用程序。接下来，通过使用基于对象的测试展示了基于 Java 的桌面应用程序测试。解释了 Sikuli 应用程序和基于图像的测试，以及一个深入案例研究，该研究进一步探讨了其
    API 的可扩展性，以创建一个对 Robot Framework 友好的解决方案。最后，列出了一些其他流行的库。
- en: In the next chapter, we will look into test reporting operations to understand
    what the different outputs generated and how can we perform various desired operations
    with generated reports and customize test outputs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨测试报告操作，以了解生成的不同输出以及如何使用生成的报告执行各种所需的操作，并自定义测试输出。
