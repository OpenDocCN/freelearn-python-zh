- en: Lights, Indicators, and Displaying Information
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 灯光、指示灯和显示信息
- en: In the previous chapter, we explored and learned how to use an optocoupler,
    transistor, and relay circuit and how these three components work together to
    create a common relay control module. We also covered how to measure the current
    usage of a load using a multimeter so that you can make an informed decision on
    what method or component should be used to switch or control an external load.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨并学习了如何使用光耦、晶体管和继电器电路，以及这三个组件如何共同工作以创建一个常见的继电器控制模块。我们还介绍了如何使用万用表测量负载的电流使用量，以便您可以就应该使用什么方法或组件来开关或控制外部负载做出明智的决定。
- en: In this chapter, we will cover two alternative ways of making color with RGB
    LEDs and create a simple application to monitor your Raspberry Pi's CPU temperature
    and display the result on an OLED display. We will conclude by seeing how we can
    combine PWM and buzzers to create sound.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍使用RGB LED制作颜色的两种替代方法，并创建一个简单的应用程序来监视树莓派的CPU温度，并在OLED显示屏上显示结果。最后，我们将看到如何结合PWM和蜂鸣器来发出声音。
- en: After you complete this chapter, you will have the knowledge, experience, and
    code examples that you can adapt to your own projects for those situations you
    need to display information to users, make a noise, or simply dazzle them with
    lights! Furthermore, what you learn will be adaptable to other types of compatible
    displays and lighting devices if you wish to explore these topics further.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将拥有知识、经验和代码示例，可以根据自己的项目需求来调整，以便在需要向用户显示信息、发出声音或简单地用灯光吸引他们的情况下使用。此外，您所学到的内容也可以适用于其他类型的兼容显示屏和照明设备，如果您希望进一步探索这些主题的话。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Making color with an RGB LED
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RGB LED制作颜色
- en: Controlling a multi-color APA102 LED strip with SPI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SPI控制多色APA102 LED灯带
- en: Using an OLED display
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OLED显示屏
- en: Making sound with buzzers and PWM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用蜂鸣器和PWM发出声音
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的练习，您需要以下内容：
- en: Raspberry Pi 4 Model B
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: A minimum of Python version 3.5
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少需要Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    a Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your
    Python version is 3.5 or higher.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望，只要您的Python版本是3.5或更高，代码示例应该可以在树莓派3型B或不同版本的Raspbian OS上无需修改即可运行。
- en: You will find this chapter's source code in the `chapter08` folder in the GitHub
    repository available here: [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处的GitHub存储库的`chapter08`文件夹中找到本章的源代码：[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a Terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令来设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependencies are installed from `requirements.txt`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: '**Pillow**: Python Imaging Library (PIL) ([https://pypi.org/project/Pillow](https://pypi.org/project/Pillow))'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pillow**：Python Imaging Library（PIL）（[https://pypi.org/project/Pillow](https://pypi.org/project/Pillow)）'
- en: '**Luma LED Matrix Library**  ([https://pypi.org/project/luma.led_matrix](https://pypi.org/project/luma.led_matrix))'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Luma LED Matrix Library**（[https://pypi.org/project/luma.led_matrix](https://pypi.org/project/luma.led_matrix)）'
- en: '**Luma OLED Library** ([https://pypi.org/project/luma.oled](https://pypi.org/project/luma.oled))'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Luma OLED Library**（[https://pypi.org/project/luma.oled](https://pypi.org/project/luma.oled)）'
- en: 'The electronic components we will need for this chapter''s exercises include
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习所需的电子元件包括以下内容：
- en: 1 x passive buzzer (rated for 5 volts)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 无源蜂鸣器（额定电压5伏）
- en: 1 x 1N4001 Diode
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 1N4001二极管
- en: 1 x 2N7000 MOSFET
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 2N7000 MOSFET
- en: 2 x 15Ω,  200Ω, 1kΩ & 100kΩ Resistors
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 15Ω、200Ω、1kΩ和100kΩ电阻
- en: '1 x RGB LED with a common cathode (datasheet: [https://pdf1.alldatasheet.com/datasheet-pdf/view/292386/P-TEC/PL16N-WDRGB190503.html](https://pdf1.alldatasheet.com/datasheet-pdf/view/292386/P-TEC/PL16N-WDRGB190503.html))'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 带有共阳的RGB LED（数据表：[https://pdf1.alldatasheet.com/datasheet-pdf/view/292386/P-TEC/PL16N-WDRGB190503.html](https://pdf1.alldatasheet.com/datasheet-pdf/view/292386/P-TEC/PL16N-WDRGB190503.html)）
- en: 1 x SSD1306 OLED display (with an I2C interface) or another model compatible
    with the Luma OLED Python library (datasheet (Driver IC): [https://www.alldatasheet.com/datasheet-pdf/pdf/1179026/ETC2/SSD1306.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1179026/ETC2/SSD1306.html))
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x SSD1306 OLED显示屏（带有I2C接口）或另一款与Luma OLED Python库兼容的型号（数据表（驱动IC）：[https://www.alldatasheet.com/datasheet-pdf/pdf/1179026/ETC2/SSD1306.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1179026/ETC2/SSD1306.html)）
- en: 1 x APA102 RGB LED strip (datasheet (Single APA102 Module): [https://www.alldatasheet.com/datasheet-pdf/pdf/1150589/ETC2/APA102.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1150589/ETC2/APA102.html))
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x APA102 RGB LED灯带（数据表（单个APA102模块）：[https://www.alldatasheet.com/datasheet-pdf/pdf/1150589/ETC2/APA102.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1150589/ETC2/APA102.html)）
- en: 1 x logic level shifter/converter module
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 逻辑电平转换模块
- en: 1 x external power supply (for example, a 3.3V/5V breadboard power supply)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 外部电源（例如3.3V/5V面包板电源）
- en: Let's make a start by looking at how we can use PWM to set the color of an RGB
    LED.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看如何使用PWM来设置RGB LED的颜色。
- en: Making color with an RGB LED and PWM
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RGB LED和PWM制作颜色
- en: In this section, we will learn how to use **Pulse-Width Modulation** (**PWM**) together
    with an RGB LED to create different colors. As a reminder, PWM is a technique
    to create a variable voltage, which when applied to an LED and resistor pair can
    be used to change the brightness of an LED. We first discussed PWM and used it
    to change the brightness of an LED back in [Chapter 2](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml),
    *Getting Started with Python and IoT.* We then covered PWM in greater depth in [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting your Raspberry Pi
    to the Physical World.*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用**脉宽调制**（**PWM**）与RGB LED一起创建不同的颜色。作为提醒，PWM是一种创建可变电压的技术，当应用于LED和电阻对时，可以用来改变LED的亮度。我们首先在[第2章](9436dfb5-3c70-4aff-9f64-512b7843b0cb.xhtml)中讨论了PWM并用它来改变LED的亮度，*使用Python和物联网入门*。然后我们在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中更深入地讨论了PWM，*将树莓派连接到物理世界*。
- en: 'An RGB LED is three single-color LEDs (red, green, and blue) in a single package,
    as illustrated in *Figure 8.1*:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: RGB LED是一个单一包装中的三个单色LED（红色、绿色和蓝色），如*图8.1*所示：
- en: '![](assets/f070fce3-0a47-417c-87d2-e245b799a904.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f070fce3-0a47-417c-87d2-e245b799a904.png)'
- en: Figure 8.1 – RGB LED varieties
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 - RGB LED品种
- en: 'You will notice that two types are shown:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到显示了两种类型：
- en: '**Common Cathode**: The red, green, and blue LEDs share a common *cathode*
    leg, meaning that the common leg is what connects to the negative or ground voltage
    source—cathode = negative.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共阴极**：红色、绿色和蓝色LED共享一个公共的*阴极*腿，这意味着共腿连接到负电压或地面电压源 - 阴极 = 负极。'
- en: '**Common Anode**: The red, green, and blue LEDs share a common *anode* leg,
    meaning that the common leg is what connects to the positive voltage source—anode
    = positive.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**共阳极**：红色、绿色和蓝色LED共享一个公共的*阳极*腿，这意味着共腿连接到正电压源 - 阳极 = 正极。'
- en: The common leg will be the longest of the four legs. If the longest leg is closest
    to the flat side of the LED's casing, it's a common cathode type. On the other
    hand, if the longest leg is nearer the lip (and hence furthest from the flat side),
    it's a common anode type.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 共腿将是四条腿中最长的。如果最长的腿最靠近LED外壳的平面一侧，那么它是共阴极类型。另一方面，如果最长的腿靠近唇部（因此离平面一侧最远），那么它是共阳极类型。
- en: We learned previously in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)*,
    Connecting Your Raspberry Pi to the Physical World*, how to set the brightness
    of a single LED using PWM, but what happens if we vary the brightness of the three
    individual colors in an RGB LED? We mix the individual colors to create new colors!
    Let's create a circuit and start mixing.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)*，将树莓派连接到物理世界*中学习了如何使用PWM来设置单个LED的亮度，但是如果我们改变RGB
    LED中三种单独颜色的亮度会发生什么？我们混合单独的颜色来创建新的颜色！让我们创建一个电路并开始混合。
- en: Creating the RGB LED circuit
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建RGB LED电路
- en: In this section, we will create a simple circuit to control an RGB LED, and
    we will be using a *common cathode*RGB LED (that is, the three individual LEDs
    share a common GND connection).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个简单的电路来控制RGB LED，并且我们将使用*共阴极*RGB LED（即，三个单独的LED共享一个公共的GND连接）。
- en: 'We will start by building the circuit as shown in *Figure 8.2 *on our breadboard:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先按照面包板上显示的*图8.2*构建电路：
- en: '![](assets/bb06186f-03a0-49d4-8b16-d5edc1007a8b.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/bb06186f-03a0-49d4-8b16-d5edc1007a8b.png)'
- en: Figure 8.2 – Common cathode RGB LED schematic
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 - 共阴极RGB LED原理图
- en: 'Following is the accompanying breadboard layout for this schematic that we
    are about to build:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们即将构建的原理图的伴随面包板布局：
- en: '![](assets/739266af-9e65-4f61-bd26-4e51ca24b4ac.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/739266af-9e65-4f61-bd26-4e51ca24b4ac.png)'
- en: Figure 8.3 – Common cathode RGB LED circuit
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 - 共阴极RGB LED电路
- en: 'Here are the steps to follow, which match the numbered black circles in *Figure
    8.3*:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤，这些步骤与*图8.3*中编号的黑色圆圈相匹配：
- en: Start by placing the RGB LED into your breadboard, taking care to orientate
    the LED regarding the positioning of its cathode leg.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将RGB LED放入面包板中，注意LED的阴极腿的定位。
- en: Position the 200Ω resistor (R1). One end of this resistor connects to the *red*
    leg of the LED.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置200Ω电阻（R1）。这个电阻的一端连接到LED的*红色*腿。
- en: Position the first 15Ω resistor (R2). One end of this resistor connects to the
    *blue* leg of the LED.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置第一个15Ω电阻（R2）。这个电阻的一端连接到LED的*蓝色*腿。
- en: Position the second 15Ω resistor (R3). One end of this resistor connects to
    the *green* leg of the LED.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 放置第二个15Ω电阻（R3）。这个电阻的一端连接到LED的*绿色*腿。
- en: Connect a ground pin on your Raspberry Pi to the negative power rail.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的一个地引脚连接到负电源轨道。
- en: Connect GPIO 16 on your Raspberry Pi to the other end of the 200Ω resistor (R1)
    you placed at *step 2*.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GPIO 16连接到您在*步骤2*中放置的200Ω电阻（R1）的另一端。
- en: Connect the cathode leg of the RGB LED to the negative power rail.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将RGB LED的阴极腿连接到负电源轨道。
- en: Connect GPIO 20 on your Raspberry Pi to the other end of the 15Ω resistor (R2)
    you placed at *step 3*.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GPIO 20连接到您在*步骤3*中放置的15Ω电阻（R2）的另一端。
- en: Connect GPIO 21 on your Raspberry Pi to the other end of the 15Ω resistor (R3)
    you placed at *step 4*.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GPIO 21连接到您在*步骤4*中放置的15Ω电阻（R3）的另一端。
- en: Before we test our RGB LED circuit, let's briefly recap how we arrived at the
    200Ω and 15Ω resistors in this circuit. The 200Ω resistor (R1) was derived using
    the same process we covered in [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml),
    *Electronics 101 for the Software Engineer*. The 15Ω resistors for R2 and R3 are
    derived using the same process, with the difference being that the *typical forward
    voltage* used in the calculations for the blue and green LED was 3.2-volts. If
    you study the sample datasheet, you will notice that the forward voltage for the
    blue and green LEDs lists a maximum forward voltage of 4.0 volts. Even at the
    typical value of 3.2 volts, we are very close to the 3.3 volts of a Raspberry
    Pi GPIO pin. If you are unlucky to get an RGB LED needing more than 3.3 volts
    for its blue or green LED, it will not work—though I have never come across one...yet.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们测试RGB LED电路之前，让我们简要回顾一下我们是如何得到这个电路中的200Ω和15Ω电阻的。200Ω电阻（R1）是使用我们在[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)中介绍的相同过程得出的，*软件工程师的电子学101*。R2和R3的15Ω电阻是使用相同的过程得出的，不同之处在于用于蓝色和绿色LED计算的*典型正向电压*为3.2伏特。如果你研究样本数据表，你会注意到蓝色和绿色LED的正向电压列出了最大正向电压为4.0伏特。即使在典型值3.2伏特下，我们也非常接近树莓派GPIO引脚的3.3伏特。如果你不幸需要超过3.3伏特的蓝色或绿色LED的RGB
    LED，它将无法工作——尽管我从未遇到过这种情况...至少目前还没有。
- en: Now we are ready to test our RGB LED.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备测试我们的RGB LED。
- en: Running and exploring the RGB LED code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和探索RGB LED代码
- en: 'Now that you have your circuit ready, let''s run our example code. Our example
    will light up the LED and make it alternate different colors. Here are the steps
    to follow:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你的电路已经准备好了，让我们运行我们的示例代码。我们的示例将点亮LED并使其交替显示不同的颜色。以下是要遵循的步骤：
- en: Run the code in the `chapter08/rgbled_common_cathode.py` file and you should
    observe the RGB LED cycling colors. Take note of the first three colors, which
    should be red, green, and then blue.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`chapter08/rgbled_common_cathode.py`文件，你应该会看到RGB LED循环显示颜色。请注意前三种颜色，应该是红色、绿色，然后是蓝色。
- en: To use a **common anode** RGB LED, it needs to be wired differently than shown
    in *Figure 8.2—*the common anode leg must go to the +3.3V pin on your Raspberry
    Pi, while the GPIO connections remain the same. The other change is in code where
    we need to invert the PWM signals—you will find a file called `rgbled_common_anode.py`
    in the `chapter08` folder with the differences commented.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用**共阳**RGB LED，它需要与*图8.2*中显示的方式不同地接线——共阳腿必须连接到树莓派的+3.3V引脚，而GPIO连接保持不变。另一个变化是在代码中我们需要反转PWM信号——你会在`chapter08`文件夹中找到一个名为`rgbled_common_anode.py`的文件，其中包含了已注释的差异。
- en: If your first three colors are not red, green, and then blue, your RGB LED may
    have its legs in a different order than the RGB LED's pictured in *Figure 8.1 *and
    the circuit in *Figure 8.2*. What you will need to do is change the GPIO pin numbering
    in the code (see the following code snippets) and re-run the code until the color
    order is correct.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你的前三种颜色不是红色、绿色，然后是蓝色，你的RGB LED可能与*图8.1*中显示的RGB LED的引脚顺序不同，以及*图8.2*中的电路。你需要做的是更改代码中的GPIO引脚编号（参见以下代码片段）并重新运行代码，直到颜色顺序正确为止。
- en: After the red, green, and then blue cycle, the RGB LED will animate a rainbow
    of colors before the program completes.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在红色、绿色和蓝色循环之后，RGB LED将以彩虹色动画显示，然后程序完成。
- en: 'Let''s discuss the interesting sections of the code and see how it works:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论代码的有趣部分并看看它是如何工作的：
- en: 'In line (1), we are importing `getrgb` from the `PIL.ImageColor` module. `getrgb`
    provides us with a convenient way to convert common color names such as red or
    hex values such as `#FF0000` into their RGB component values such as (255, 0,
    0):'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们从`PIL.ImageColor`模块导入`getrgb`。`getrgb`为我们提供了一种方便的方法，将常见的颜色名称（如红色）或HEX值（如`#FF0000`）转换为它们的RGB分量值（如(255,
    0, 0)）：
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Starting at line (2), we explicitly configure PWM for each of the GPIO pins
    (the duty cycle range of 255 and frequency of 8,000 are the PiGPIO defaults).
    The PWM duty cycle range of 0 to 255 maps perfectly into the RGB component color
    value range of 0...255, which we will see shortly is how we set the individual
    brightness of each color LED.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 从第2行开始，我们明确为每个GPIO引脚配置PWM（占空比范围为255，频率为8000是PiGPIO的默认值）。PWM占空比范围从0到255完美地映射到RGB分量颜色值范围0...255，我们很快就会看到这是我们如何设置每个颜色LED的亮度的方法。
- en: 'In the following code, in line (3), we have the `set_color()` definition, which
    is responsible for setting the color of our RGB LED. The `color` parameter can
    be either a common color name such as `yellow`, a HEX value such as `#FFFF00`,
    or one of the many formats that `getrgb()` can parse (see the `rgbled_common_cathode.py` source
    file for a list of common formats):'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，在第3行，我们有`set_color()`的定义，它负责设置我们的RGB LED的颜色。`color`参数可以是一个常见的颜色名称，比如`yellow`，也可以是一个HEX值，比如`#FFFF00`，或者`getrgb()`可以解析的许多格式之一（请参阅`rgbled_common_cathode.py`源文件，了解常见格式的列表）：
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In line (4), we see how to use PWM with the individual GPIO pins to set the
    RBG LED''s color. Continuing with yellow as our example, we see the following:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4行，我们看到如何使用PWM与单独的GPIO引脚来设置RBG LED的颜色。继续以黄色为例，我们看到以下内容：
- en: '`GPIO_RED` is set to a duty cycle of 0.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO_RED`被设置为0的占空比。'
- en: '`GPIO_GREEN` is set to a duty cycle of 255.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO_GREEN`被设置为255的占空比。'
- en: '`GPIO_BLUE` is set to a duty cycle of 255.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GPIO_BLUE`被设置为255的占空比。'
- en: A duty cycle value for green and blue of 255 means that these LEDs are fully
    on and, as we know, mixing green and blue makes yellow.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 绿色和蓝色的占空比值为255意味着这些LED完全开启，正如我们所知，混合绿色和蓝色会得到黄色。
- en: 'As you browse the source file, you will encounter another two functions at
    lines (6) and (7):'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览源文件时，你会在第6行和第7行遇到另外两个函数：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both of these methods delegate to `set_color()`. `color_cycle()` loops through
    the list of colors provided as its `color` parameter, while `rainbow_example()` generates
    and loops through a range of colors to produce the rainbow sequence. These functions
    are what generated the light sequences when we ran the code in *step 1*.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都委托给`set_color()`。`color_cycle()`循环遍历其`color`参数提供的颜色列表，而`rainbow_example()`生成并循环遍历一系列颜色以产生彩虹序列。这些函数是我们在*步骤1*中运行代码时生成光序列的原因。
- en: 'Our RGB LED circuit comes with limitations and drawbacks:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的RGB LED电路有一些限制和缺点：
- en: Firstly, we need three GPIO pins per RGB LED.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，每个RGB LED需要三个GPIO引脚。
- en: Secondly, we're restricting the current to 8mA with the resistors so we cannot
    achieve maximum potential brightness of the individual LEDs (we would need ~20mA
    for full brightness).
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，我们通过电阻将电流限制在8mA，因此无法实现单个LED的最大亮度（我们需要约20mA才能实现全亮度）。
- en: While we could introduce transistors (or an appropriate multi-channel LED driver
    IC) to increase the current, our circuit would quickly become cumbersome! Luckily,
    there is another way we can create color with LEDs, and that is with addressable
    LEDs, which we'll look at next.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以引入晶体管（或适当的多通道LED驱动IC）来增加电流，但我们的电路很快就会变得笨重！幸运的是，我们还有另一种方法可以用LED创建颜色，那就是可寻址LED，我们将在下一节中讨论。
- en: Controlling a multi-color APA102 LED strip with SPI
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SPI控制多色APA102 LED灯带
- en: The APA102 is an addressable multi-color (RGB) LED that is controlled using
    a **Serial Peripheral Interface** (**SPI**). In simplistic terms, we *send instructions*
    to the LED asking it what color to display rather than individually controlling
    each of the three red-green-blue legs of the LED using PWM as we did in the previous
    example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: APA102是一种可寻址的多色（RGB）LED，使用**串行外围接口**（SPI）进行控制。简单来说，我们向LED发送指令询问它要显示什么颜色，而不是像在上一个例子中那样使用PWM单独控制LED的三个红绿蓝引脚。
- en: If you need a quick refresher on SPI, we covered it back in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*. We will also discuss SPI
    further the context of the APA102, the Raspberry Pi, and Python after we explore
    APA102 specific code shortly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要快速回顾SPI，我们在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)中已经涵盖了它，*将您的树莓派连接到物理世界*。我们还将在探索APA102特定代码后讨论SPI，树莓派和Python的更多内容。
- en: APA102 LEDs can also be connected or chained together to create LED strips or
    LED matrices to create dynamic and multi-LED lighting and display solutions. Irrespective
    of how the LEDs are arranged, we control them using a common technique where we
    send multiple sets of instructions to a chain of APA102 LEDs. Each individual
    LED consumes one instruction and passes the rest on to be consumed by upstream
    LEDs. We will see this idea in action as we work with an APA102 LED strip shortly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: APA102 LED也可以连接或串联在一起，以创建LED灯带或LED矩阵，从而创建动态和多LED的照明和显示解决方案。无论LED如何排列，我们都使用一种常见的技术来控制它们，即向一系列APA102
    LED发送多组指令。每个单独的LED消耗一个指令，并将其余的传递给上游LED消耗。我们将在不久的将来使用APA102 LED灯带时看到这个想法。
- en: APA102 LEDs also go by the name Super LEDs, DotStar LEDs, and sometimes Next
    Generation NeoPixels. There is also another addressable LED, the WS2812, also
    known as a NeoPixel. While similar in principle and operation, WS2812 RGB LEDs
    are not compatible with the APA102.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: APA102 LED也被称为超级LED、DotStar LED，有时也被称为下一代NeoPixels。还有另一种可寻址LED，WS2812，也被称为NeoPixel。虽然原理和操作类似，但WS2812
    RGB LED与APA102不兼容。
- en: Let's create a circuit and run the code to control our APA102 LED strip.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个电路并运行代码来控制我们的APA102 LED灯带。
- en: Creating the APA102 circuit
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建APA102电路
- en: 'In this section, we will create our APA102 circuit, as shown in the following
    diagram. We will do this on our breadboard in two parts:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建我们的APA102电路，如下图所示。我们将在面包板上分两部分完成这个过程：
- en: '![](assets/d28ea265-a718-48c5-927d-fded677b51d3.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d28ea265-a718-48c5-927d-fded677b51d3.png)'
- en: Figure 8.4 – APA102 LED strip circuit schematic
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 - APA102 LED灯带电路原理图
- en: 'Let''s get started on the first part, which will be to place the components
    and wire up the *low-voltage* side of a logic level converter:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始第一部分，即放置元件并连接逻辑电平转换器的*低电压*端：
- en: '![](assets/44daf804-c0b2-4276-b54e-e35faa2b4c98.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/44daf804-c0b2-4276-b54e-e35faa2b4c98.png)'
- en: Figure 8.5 – APA102 LED circuit (part 1 of 2)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 - APA102 LED电路（1/2）
- en: 'Here are the steps to follow. The step numbers match the numbered black circles
    in *Figure 8.5*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是要遵循的步骤。步骤编号与*图8.5*中编号的黑色圆圈相匹配：
- en: Place the logic level converter (logic level shifter) into the breadboard, positioning
    the *low-voltage* side toward your Raspberry Pi. Different logic level converters
    may have different labeling, however, it should be clear which is the low-voltage
    side. In our illustration, one side has an **LV** (**Low Voltage**) terminal while
    the other has an **HV** (**High Voltage**) terminal, which distinguishes the sides.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑电平转换器（逻辑电平转换器）放入面包板中，将*低电压*端朝向树莓派。不同的逻辑电平转换器可能有不同的标记，但是低电压端应该是清楚的。在我们的示例中，一侧有一个**LV**（低电压）端子，另一侧有一个**HV**（高电压）端子，用于区分两侧。
- en: Connect the negative rails on the left-hand side and right-hand side power rails.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接左侧和右侧电源轨道上的负轨。
- en: Connect a 3.3-volt pin on your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的3.3伏特引脚连接到左侧电源轨道的正轨。
- en: Connect the LV terminal on the logic level converter into the positive rail
    of the left-hand side power rail.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑电平转换器上的LV端子连接到左侧电源轨道的正轨。
- en: Connect the **MOSI** (**Master Out Slave In**) pin on your Raspberry Pi to the
    A2 terminal on the logic level converter.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的**MOSI**（主输出从输入）引脚连接到逻辑电平转换器上的A2端子。
- en: Connect the **SLCK** (**Serial Clock**) pin on your Raspberry Pi to the A1 terminal
    on the logic level converter.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的**SLCK**（串行时钟）引脚连接到逻辑电平转换器上的A1端子。
- en: Connect the GND terminal on the logic level converter to the negative rail on
    the left-hand side power rail.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑电平转换器上的GND端子连接到左侧电源轨的负轨。
- en: Connect the negative rail on the left-hand side power rail to a GND pin on your
    Raspberry Pi.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左侧电源轨上的负轨连接到树莓派的GND引脚。
- en: 'Now that we have wired the *low-voltage* side of the logic level converter
    to our Raspberry Pi, next we will wire the *high-voltage* side to the APA102 LED
    strip. As a reminder, Raspberry Pi GPIO pins operate at 3.3 volts (hence it''s
    the *low* voltage) while the APA102 operates at 5 volts (hence it''s the *high*
    voltage):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将逻辑电平转换器的*低电压*端连接到了树莓派，接下来我们将把*高电压*端连接到APA102 LED灯带。作为提醒，树莓派的GPIO引脚工作在3.3伏（因此是*低*电压），而APA102工作在5伏（因此是*高*电压）：
- en: '![](assets/ce067e34-2bd9-49c3-bb37-593b62ef468b.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ce067e34-2bd9-49c3-bb37-593b62ef468b.png)'
- en: Figure 8.6 – APA102 LED circuit (part 2 of 2)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – APA102 LED电路（2/2）
- en: 'Here are the steps to follow for the second part of our build. The step numbers
    match the numbered black circles in *Figure 8.6*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们搭建的第二部分的步骤。步骤编号与*图8.6*中编号的黑色圆圈相匹配：
- en: Connect the HV terminal of the logic level converter to the positive rail of
    the right-hand side power rail.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑电平转换器的HV端子连接到右侧电源轨的正轨。
- en: Place a jumper wire from terminal B2 to an unused row on your breadboard (in
    the illustration, this is shown at hole G16).
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从B2端子到面包板上未使用的一行放置一根跳线（在插图中，这显示在孔G16处）。
- en: Place another jumper wire from terminal B1 to an unused row on your breadboard
    (in the illustration, this is shown at hole H14).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从B1端子到面包板上未使用的一行放置另一根跳线（在插图中，这显示在孔H14处）。
- en: Connect the GND terminal on the high-voltage side of the logic level converter
    to the negative rail of the right-hand side power rail.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将逻辑电平转换器高电压端的GND端子连接到右侧电源轨的负轨。
- en: Connect the positive output of your power supply to the positive rail of the
    right-hand side power rail.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源的正输出连接到右侧电源轨的正轨。
- en: Connect the negative output of your power supply to the negative rail of the
    right-hand side power rail.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源的负输出连接到右侧电源轨的负轨。
- en: Connect the VCC terminal or wire of your APA102 LED strip to the positive rail
    of the right-hand side power rail.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将APA102 LED灯带的VCC端子或导线连接到右侧电源轨的正轨。
- en: Your APA102 must be connected the correct way around. You will notice the arrows
    on the APA102 LED strip shown in *Figure 8.4.* These arrows indicate the direction
    of the data flow. Make sure your APA102 LED strip arrows match the illustration
    (that is, the arrows are pointing away from the breadboard).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您的APA102必须正确连接。您会注意到APA102 LED灯带上的箭头，如*图8.4*所示。这些箭头表示数据流的方向。确保您的APA102 LED灯带箭头与插图相匹配（即箭头指向面包板的反方向）。
- en: If your APA102 does not have the arrows, look at the naming of the terminals.
    One side of an LED strip may have CI/DI (I = Input), while the other side has
    DO/CO (O = Output). It's the *Input* side we need to connect to the logic level
    converter.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的APA102没有箭头，请查看端子的命名。LED灯带的一侧可能有CI/DI（I = 输入），而另一侧有DO/CO（O = 输出）。我们需要连接的是*输入*端。
- en: Connect the **CI** (**Clock Input**) terminal or wire of your APA102 LED strip
    to the wire you placed at *step 3* that connects back to the B1 terminal of the
    logic level converter.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将APA102 LED灯带的**CI**（时钟输入）端子或导线连接到您在*步骤3*中放置的连接回逻辑电平转换器的B1端子的导线。
- en: Connect the **DI** (**Data Input**) terminal or wire of your APA102 LED strip
    to the wire you placed at *step 2* that connects back to the B2 terminal of the
    logic level converter.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将APA102 LED灯带的**DI**（数据输入）端子或导线连接到您在*步骤2*中放置的连接回逻辑电平转换器的B2端子的导线。
- en: Finally, connect the GND terminal or wire of your APA102 LED strip to the negative
    rail of the right-hand side power rail.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将APA102 LED灯带的GND端子或导线连接到右侧电源轨的负轨。
- en: Well done! You have now completed your APA102 LED strip circuit. As you completed
    this circuit build, you will have noticed that we are using a logic level converter.
    This is because the APA102 requires 5-volt logic to operate *properly*. The APA102
    datasheet explicitly mentions the minimum logic voltage to be 0.7 VDD, which is
    0.7 x 5 volts = 3.5 volts, which is higher than the Raspberry Pi's 3.3-volt logic-level.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您现在已经完成了APA102 LED灯带电路。在完成这个电路搭建时，您会注意到我们使用了逻辑电平转换器。这是因为APA102需要5伏逻辑电才能*正常*运行。APA102的数据表明明确提到最小逻辑电压为0.7
    VDD，即0.7 x 5伏=3.5伏，这高于树莓派的3.3伏逻辑电平。
- en: If you need a refresher on logic-levels and logic-level conversion, refer back
    to [Chapter 6](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml), *Electronics 101 for
    the Software Engineer.*
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要关于逻辑电平和逻辑电平转换的复习，请参考[第6章](2aba4d00-7883-42da-95fa-bcec2da3dd54.xhtml)，*软件工程师的电子学101*。
- en: Let's consider the situation (in case you were wondering) that 3.3 volts is
    only slightly less than 3.5 volts—surely, that's close enough? You can try and
    control an APA102 with 3.3-volts, and it *may* give you some level of success.
    However, you *may* also experience some random effects and confusion—for example,
    random LEDs not turning on or off as expected, flickering LEDs, or LEDs displaying
    with the wrong color. Unfortunately, the APA102 is one of the 5-volt logic devices
    that are not 3.3-volt compatible, so we must take the extra step and use a logic
    level converter to meet its 3.5-volt minimum logic-level requirements.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下（如果您在想）3.3伏只比3.5伏略低一点——这肯定够接近了吧？您可以尝试用3.3伏来控制APA102，它*可能*会带来一定程度的成功。然而，您*可能*也会遇到一些随机效果和混乱，例如，随机LED未按预期开启或关闭，LED闪烁，或LED显示错误的颜色。不幸的是，APA102是不兼容3.3伏的5伏逻辑设备之一，因此我们必须采取额外的步骤，使用逻辑电平转换器来满足其3.5伏最小逻辑电平要求。
- en: Now that you have built your APA102 circuit, next we will discuss the considerations
    we need to think about to power this circuit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经建立了APA102电路，接下来我们将讨论我们需要考虑的问题，以便为这个电路供电。
- en: Powering the APA102 circuit
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为APA102电路供电
- en: In [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)*, Turning Things
    On and Off*, we discussed the importance of knowing the current requirements of
    a "load" that you are using. Let's apply that learning to our APA102 LED strip
    so we can power it correctly. Our example is assuming a LED strip containing 60
    LEDs, however, you will need to adjust the calculations based on the number of
    LEDs on your strip.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)*，打开和关闭东西*中，我们讨论了了解您正在使用的“负载”的电流要求的重要性。让我们将这个知识应用到我们的APA102
    LED灯带上，以便我们可以正确地为其供电。我们的示例假设LED灯带包含60个LED，但是您需要根据灯带上LED的数量调整计算。
- en: 'By the way of example, we have the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，我们有以下内容：
- en: An APA102 LED strip with 60 LEDs.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含60个LED的APA102 LED灯带。
- en: Each LED uses (on average) a maximum of 25mA (from the datasheet and confirmed
    by measurement).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个LED使用（平均）最大25mA（来自数据表并经过测量确认）。
- en: The LED strip consumes approximately 15mA when idle (no LED is lit).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LED灯带在空闲时消耗大约15mA（没有LED亮起）。
- en: A single RGB LED uses its maximum current when it is set to the color white,
    which is when each individual LED (red, green, and blue) are at their full brightness.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 单个RGB LED在设置为白色时使用其最大电流，这是当每个LED（红色、绿色和蓝色）都处于最大亮度时。
- en: 'Using the preceding values, we can calculate our expected maximum current requirement
    for 60 LEDs, which is just over 1.5 amps:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的值，我们可以计算出60个LED的预期最大电流需求，这超过了1.5安培：
- en: '![](assets/4e230bdf-ed28-4f87-bd8b-c7ca23dfb257.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/4e230bdf-ed28-4f87-bd8b-c7ca23dfb257.png)'
- en: If we work in the assumption that we are using a breadboard power supply, then
    if we conservatively assume that our breadboard power suppler can only supply
    around 700mA maximum, we cannot realistically turn on all LEDs on a 60 LED strip
    to full white. If we do, then (depending on the power supply) it could turn off
    if its internal overload protection kicks in, it might go up in a puff of smoke,
    or it might limit its output current, which we may observe as the LEDs looking
    reddish rather than white.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们假设我们使用的是面包板电源供应，那么如果我们保守地假设我们的面包板电源供应最多只能提供大约700mA，我们实际上不能将60个LED灯带上的所有LED都设置为全白。如果这样做，那么（取决于电源供应）它可能会在其内部过载保护启动时关闭，它可能会冒烟，或者它可能会限制其输出电流，这可能会导致LED看起来呈红色而不是白色。
- en: 'Let''s work backward to work out the safe number of LEDs that we can power
    from a 700mA power supply:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逆向工作，计算出我们可以从700mA电源供应中供电的LED的安全数量：
- en: '![](assets/1ac25844-39c3-4b04-8e3b-3a01459ef227.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1ac25844-39c3-4b04-8e3b-3a01459ef227.png)'
- en: If we then subtract 2 LEDs (50mA) as a small safety buffer, we get 25 LEDs.
    Remember this number (or the number you calculate) as we will need it next when
    we run our example code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们然后减去2个LED（50mA）作为一个小的安全缓冲区，我们得到25个LED。记住这个数字（或者您计算的数字），因为我们在运行示例代码时将需要它。
- en: After calculating the number of safe LEDs you can use with your power supply,
    we are now ready to configure and run our Python example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 计算出您可以使用的安全LED数量后，我们现在准备配置和运行我们的Python示例。
- en: Configuring and running the APA102 LED strip code
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置和运行APA102 LED灯带代码
- en: 'Now that you have your circuit ready and our LED strip''s expected current
    usage, let''s configure and light up our LED strip:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的电路已经准备好，我们知道LED灯带的预期电流使用情况，让我们配置并点亮LED灯带：
- en: 'Edit the `chapter08/apa102_led_strip.py` file and look for the following line
    near the top of the file. Adjust the number to be the number of safe LEDs you
    calculated previously, or the number of LEDs on your strip if it had a suitably
    capable power supply:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`chapter08/apa102_led_strip.py`文件，并在文件顶部附近查找以下行。将数字调整为您之前计算的安全LED数量，或者如果您的灯带有足够能力的电源供应，则调整为灯带上的LED数量：
- en: '[PRE4]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Save your edits and run the code. If everything is connected correctly, you
    should observe the LEDs on the strip cycle through the colors red, green, and
    blue and then perform a few different light sequences.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存您的编辑并运行代码。如果一切连接正确，您应该观察到LED灯带循环显示红色、绿色和蓝色，然后执行一些不同的光序列。
- en: If your LED strip is not working, check out the *APA102 LED strip troubleshooting
    tips* later in the section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的LED灯带没有工作，请查看本节后面的*APA102 LED灯带故障排除提示*。
- en: If your strip does not show red, green, and blue in that order, then you would need
    to adjust code to set the correct order—I'll show you where in the code you can
    adjust the LED ordering when we come to that section of code shortly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的灯带没有按照红、绿和蓝的顺序显示，那么您需要调整代码以设置正确的顺序——我将向您展示在代码的哪个部分可以调整LED的顺序。
- en: With our safe number of LEDs now configured in code, let's walk through the
    code to see how it works.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们在代码中配置了安全数量的LED，让我们走一遍代码，看看它是如何工作的。
- en: APA102 LED strip code walkthrough
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: APA102 LED灯带代码演示
- en: 'Starting at line (1) in the following code, we have the imports. We will be
    using a Python `deque` collection instance (I''ll just refer to is as an array
    for simplicity) to model in-memory the APA102 LED strip—we will build up and manipulate
    the order of colors we want each individual LED on to display in this array before
    applying it to the LED strip. We then import the `getrgb` function from the PIL
    library for working with color formats (as we did in the preceding RGB LED example):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下代码的第一行开始，我们有导入。我们将使用Python的`deque`集合实例（我只是简单地称之为数组）来在内存中模拟APA102 LED灯带——在将其应用于LED灯带之前，我们将在这个数组中构建和操作我们希望每个LED显示的颜色顺序。然后我们从PIL库中导入`getrgb`函数，用于处理颜色格式（就像我们在前面的RGB
    LED示例中所做的那样）：
- en: '[PRE5]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lastly, the three `luma` imports are for the APA102 LED strip control. Luma
    is a mature high-level library for working with a range of common display devices
    using Python. It has support for LCDs, LED strips and matrices, and much more,
    including OLED displays, which we will cover later in this chapter.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，三个`luma`导入是用于APA102 LED灯带控制。Luma是一个成熟的高级库，用于使用Python处理各种常见的显示设备。它支持LCD、LED灯带和矩阵等，还包括我们将在本章后面介绍的OLED显示器。
- en: We can only scratch the surface of what can be done with the Luma library in
    this chapter, so I encourage you to explore its documentation and range of examples—you'll
    find links in the *Further reading* section at the end of this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只能浅尝Luma库的功能，所以我鼓励您探索其文档和各种示例——您将在本章末尾的*进一步阅读*部分找到链接。
- en: 'Next, we come to line (3) in the following code, where we assign `color_buffer`
    to an instance of `deque` that is initialized with the same number of elements
    as there are LEDs in our strip. Each element defaults to black (that is, the LED
    is off):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来到下面代码的第3行，我们将`color_buffer`分配给`deque`的一个实例，该实例初始化为与我们条带中的LED数量相同的元素数。每个元素默认为黑色（即LED关闭）：
- en: '[PRE6]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In line (4) in the following code, we start to create our software interface
    to the APA102\. Here, we are creating a `spi()` instance representing the default
    hardware SPI0 interface on the Raspberry Pi. To use this interface, your APA102
    must be connected to the SPI pins on your Raspberry Pi, which are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面代码的第4行中，我们开始创建我们的APA102的软件接口。在这里，我们创建了一个代表树莓派上默认硬件SPI0接口的`spi()`实例。要使用此接口，您的APA102必须连接到树莓派上的SPI引脚，如下所示：
- en: DI connected to MOSI
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DI连接到MOSI
- en: CI connected to SCLK
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI连接到SCLK
- en: 'In the following code snippet `port=0` and `device=0` relate to the SPI0 interface:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，`port=0`和`device=0`与SPI0接口相关：
- en: '[PRE7]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `bus_speed_hz` parameter sets the speed of the SPI interface and, for our
    examples, we lower it from its default value of 8,000,000 to 2,000,000 just to
    ensure that your logic level converter will work. Not all logic level converters
    are the same, and they will have a maximum speed at which they can convert logic
    levels. If the SPI interface operates faster than the logic level converter can
    convert, our circuit will not work.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`bus_speed_hz`参数设置了SPI接口的速度，对于我们的示例，我们将其从默认值8,000,000降低到2,000,000，只是为了确保您的逻辑电平转换器能够工作。并非所有逻辑电平转换器都相同，它们将具有可以转换逻辑电平的最大速度。如果SPI接口的操作速度快于逻辑电平转换器可以转换的速度，我们的电路将无法工作。'
- en: In line (5) in the following code—which is commented out—we have a software
    alternative to hardware SPI known as big-banging, which will work on any GPIO
    pins at the expense of speed. It's similar to the software versus hardware PWM
    trade-off we discussed back in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World:*
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中的第5行（已注释掉）中，我们有一个软件替代硬件SPI的选择，称为大砰，它可以在任何GPIO引脚上工作，但速度会受到影响。这类似于我们在第5章中讨论过的软件与硬件PWM的权衡，*将您的树莓派连接到物理世界*：
- en: '[PRE8]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In line (6) in the preceding code, we created an instance of the `apa102` class
    specifying the `serial` instance we just created, and the number of LEDs in our
    strip. From this point forward in code, to interact with our APA102 LED strip,
    we use the `device` instance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的第6行中，我们创建了一个`apa102`类的实例，指定了我们刚刚创建的`serial`实例和我们条带中LED的数量。从此刻开始，在代码中与APA102
    LED条带进行交互，我们将使用`device`实例。
- en: 'To initialize our LED strip, in line (7) in the following code, we call `device.clear()` 
    and set the default global contrast to 128 (so, half brightness). You can adjust
    this level to find a brightness that you are comfortable with, remembering that
    more contrast/brightness means more current usage. Note that previously when we
    calculated the number of safe LEDs, the 25mA per LED used in the calculations
    assumed maximum brightness (that is, 255):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化我们的LED条带，在下面代码的第7行中，我们调用`device.clear()`并将默认全局对比度设置为128（即半亮度）。您可以调整此级别以找到您满意的亮度，记住更多的对比度/亮度意味着更多的电流使用。请注意，先前在计算安全LED数量时，计算中使用的每个LED的25mA假定最大亮度（即255）：
- en: '[PRE9]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In line (8) in the following code, we have the `set_color()` function. We use
    this function to set individual or all elements to a specified color in the `color_buffer`
    array. This is how we build up in-memory the color arrangements we want our APA102
    LED strip to display:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面代码的第8行中，我们有`set_color()`函数。我们使用此函数在`color_buffer`数组中将单个或所有元素设置为指定的颜色。这是我们在内存中构建APA102
    LED条带要显示的颜色排列的方法：
- en: '[PRE10]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we will jump to line (12) in the following code block to the `update()`
    function. This function loops through `color_buffer` and, using the Luma `device`
    instance representing our APA102, it feeds the device the colors to display using
    `draw.point((led_pos, 0), fill=color)`. This is the magic of the Luma library—it
    shields us from the lower level APA102 and SPI data and hardware protocols by
    giving us a very simple software interface to use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将跳转到下面代码块的第12行，到`update()`函数。这个函数循环遍历`color_buffer`，并使用代表我们APA102的Luma
    `device`实例，使用`draw.point((led_pos, 0), fill=color)`来向设备提供要显示的颜色。这就是Luma库的魔力——它通过给我们一个非常简单的软件接口，使我们免受较低级别APA102和SPI数据和硬件协议的影响。
- en: If you want to learn more about lower level SPI use and protocols, then APA102
    is a good place to start. Start by reading the APA102 datasheet for its data protocol,
    then find a simple APA102 module on [pypi.org](http://pypi.org) or GitHub and
    review its code. There is also an APA102 example that can be found on the PiGPIO
    website—a link is included in the *Further reading* section.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多关于较低级别SPI使用和协议的知识，那么APA102是一个很好的起点。首先阅读APA102的数据协议的数据表，然后在[pypi.org](http://pypi.org)或GitHub上找到一个简单的APA102模块并查看其代码。在PiGPIO网站上也可以找到一个APA102的示例，*进一步阅读*部分中包含了链接。
- en: 'It''s important to remember that `update()` needs to be called after you make
    changes to `color_buffer`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在对`color_buffer`进行更改后需要调用`update()`：
- en: '[PRE11]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If, for some reason, you find your LED strip colors are not in the standard
    red, green, and blue order then the preceding commented-out section of code can
    be used to change the color order. I've never encountered a non-standard APA102,
    but I have read about addressable RGB LEDs having non-standard ordering, so I
    thought I'd just drop that bit of code in, just in case.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现LED灯带颜色不是标准的红、绿和蓝顺序，那么上面注释掉的代码部分可以用来改变颜色顺序。我从未遇到过非标准APA102，但我读到过可寻址的RGB
    LED具有非标准顺序，所以我想我还是把那部分代码放进来，以防万一。
- en: 'Moving on to lines (9), (10), and (11), we have three functions that simply
    manipulate `color_buffer`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第（9）、（10）和（11）行，我们有三个简单操作`color_buffer`的函数：
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`push_color(color)` in line (9) pushes a new color into `color_buffer` at index
    0 while `set_pattern()` in line (10) fills `color_buffer` with a repeating color
    pattern sequence. `rotate_colors()` in line (11) rotates the colors in `color_buffer` (and
    wraps them around—the last one becomes for the first one). You can rotate backward
    by using a count value < 0.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`push_color(color)` 在第（9）行将一个新颜色推入`color_buffer`的索引0，而第（10）行的`set_pattern()`用重复的颜色模式序列填充`color_buffer`。第（11）行的`rotate_colors()`旋转`color_buffer`中的颜色（并将它们包装起来——最后一个变成第一个）。你可以通过使用小于0的计数值向后旋转。'
- en: 'Finally, toward the end of the source code, we have the following functions
    that provide the examples you saw when you run the file. These functions use combinations
    of the functions discussed previously to control the LED strip:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在源代码的末尾，我们有以下函数，提供了你运行文件时看到的示例。这些函数使用之前讨论过的函数的组合来控制LED灯带：
- en: '`cycle_colors(colors=("red", "green", "blue"), delay_secs=1)`'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cycle_colors(colors=("red", "green", "blue"), delay_secs=1)`'
- en: '`pattern_example()`'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pattern_example()`'
- en: '`rotate_example(colors=("red", "green", "blue"), rounds=2, delay_secs=0.02)`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate_example(colors=("red", "green", "blue"), rounds=2, delay_secs=0.02)`'
- en: '`rainbow_example(rounds=1, delay_secs=0.01)`'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rainbow_example(rounds=1, delay_secs=0.01)`'
- en: We will complete our coverage of the APA102 with a few concluding notes on its
    use of the SPI interface.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一些结论性的笔记来完成对APA102使用SPI接口的覆盖。
- en: Discussion of APA102 and the SPI interface
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: APA102和SPI接口的讨论
- en: If you cast your mind back to [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml),
    *Connecting Your Raspberry Pi to the Physical World*, where we discussed **Serial
    Peripheral Interface** (**SPI**), you may remember that we mentioned it uses four
    wires for data transfer. However, if you consider our circuit in *Figure 8.6*,
    we're only using two wires (DI and CI), not four. What's going on?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果回想一下[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)，*将树莓派连接到物理世界*，我们讨论了**串行外围接口**
    (**SPI**)，你可能记得我们提到它使用四根导线进行数据传输。然而，如果你考虑我们在*图8.6*中的电路，我们只使用了两根导线（DI和CI），而不是四根。怎么回事？
- en: 'Here is the SPI mapping for the APA102:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是APA102的SPI映射：
- en: '**Master-Out-Slave-In** (**MOSI**) on your Raspberry Pi connects to **Data
    In** (**DI**) on the APA102\. Here, your Raspberry Pi is the *master* sending
    data to the *slave* APA102 LEDs on the strip.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派上的**Master-Out-Slave-In** (**MOSI**) 连接到APA102上的**Data In** (**DI**)。在这里，你的树莓派是*主*，向*从*APA102灯带发送数据。
- en: '**Master-In-Slave-Out** (**MISO**) is not connected because the APA102 does
    not need to send data back to the Raspberry Pi.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Master-In-Slave-Out** (**MISO**) 没有连接，因为APA102不需要将数据发送回树莓派。'
- en: SCLK on your Raspberry Pi connect to the **Clock In** (**CI**) on the APA102.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派上的SCLK连接到APA102上的**Clock In** (**CI**)。
- en: '**Client Enable/Slave Select** (**CE/SS**) is not connected.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Client Enable/Slave Select** (**CE/SS**) 没有连接。'
- en: The last line CE/SS of importance and worthy of further discussion. A CE/SS
    channel is used by a master device to tell a specific slave device that it's about
    to receive data. It's this mechanism that allows a single SPI master to control
    multiple SPI slaves.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行重要的CE/SS值得进一步讨论。CE/SS通道由主设备用于告诉特定的从设备它即将接收数据。正是这种机制允许单个SPI主控制多个SPI从。
- en: But, we're not (and cannot) use CE/SS it with the APA102 because we have nowhere
    to connect the CE/SS pins to. The implication of this is that the APA102 is always
    listing for instructions from a master, effectively hogging the SPI channel.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们不会（也不能）使用CE/SS与APA102，因为我们没有地方连接CE/SS引脚。这意味着APA102总是在等待来自主设备的指令，实际上占用了SPI通道。
- en: 'If we are using an APA102 (or any device that has no CE/SS), then we cannot
    connect more than one SPI device to a master''s hardware SPI, unless we take extra
    steps. Some of the options are as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用APA102（或任何没有CE/SS的设备），那么除非我们采取额外的步骤，否则我们不能将多个SPI设备连接到主硬件SPI。以下是一些选项：
- en: Use big-banging on generic GPIO pins if the performance reduction does not have
    adverse effects.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果性能降低没有不良影响，可以在通用GPIO引脚上使用大爆破。
- en: Enable hardware SPI1 on your Raspberry Pi. It's not enabled by default and requires
    editing `/boot/config.txt`. You'll find instructions and tips if you search the
    web for *Raspberry Pi enable SPI1*.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在树莓派上启用硬件SPI1。它默认情况下是未启用的，需要编辑`/boot/config.txt`。如果搜索*Raspberry Pi enable SPI1*，你会在网上找到指南和提示。
- en: Find a logic level converter that includes an enable pin and write code to manually
    control this pin as a proxy CE/SS.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到一个包括使能引脚的逻辑电平转换器，并编写代码手动控制这个引脚作为代理CE/SS。
- en: We will conclude this section on the APA102 with a few troubleshooting tips.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一些故障排除提示来结束关于APA102的部分。
- en: APA102 LED strip troubleshooting tips
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: APA102 LED灯带故障排除提示
- en: 'If you cannot get your APA102 to light up or if you find that random LEDs are
    not turning on or off or they are displaying unexpected colors or random flickers,
    try the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法点亮APA102，或者发现随机LED未开启或关闭，或者显示意外颜色或随机闪烁，请尝试以下操作：
- en: 'The APA102 needs 5-volt logic: Make sure you are using a logic level converter
    and that is connected the correct way around—HV to 5 volts and LV to 3.3 volts.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: APA102需要5伏逻辑电平：确保你使用的是逻辑电平转换器，并且连接正确——HV连接到5伏，LV连接到3.3伏。
- en: Ensure that the DI/CI side of the APA102 is connected to the logic level converter.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保APA102的DI/CI端连接到逻辑电平转换器。
- en: Make sure your power source can supply enough current. As an example, under-supply
    of current or voltage can make white look more like red.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的电源可以提供足够的电流。例如，电流或电压的不足可能会使白色看起来更像红色。
- en: Make sure the ground of your power supply is connected to a ground pin on your
    Raspberry Pi.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的电源的地线连接到树莓派上的地线引脚。
- en: If you are using big banging, move to hardware SPI.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您正在使用大幅振荡，请转移到硬件SPI。
- en: 'If using the hardware SPI (that is, creating an instance of the `spi()` class),
    try the following:'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用硬件SPI（也就是创建`spi()`类的实例），请尝试以下操作：
- en: If you are receiving the error *SPI device not found*, make sure SPI has been
    enabled in the Raspbian OS. We covered this in [Chapter 1](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml),
    **Setting Up Your Development Environment.**
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您收到错误消息*SPI设备未找到*，请确保在Raspbian OS中已启用SPI。我们在[第1章](fea8bc67-63b9-4cbc-9c02-82b4b9bbe5e0.xhtml)中介绍了这一点，**设置您的开发环境**。
- en: If you have been using GPIO 8,9, 10, or 11 previously for general I/O, then
    either disable and re-enable the SPI interface as per the preceding point or reboot
    your Raspberry Pi to reset the hardware SPI interface.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您之前已经使用GPIO 8、9、10或11进行常规I/O操作，那么要么按照前面的方法禁用并重新启用SPI接口，要么重新启动树莓派以重置硬件SPI接口。
- en: 'Try lowering the SPI bus speed in case your logic level converter cannot keep
    up—that is, it cannot convert 3.3-volt to 5-volt signals as fast as the SPI interface
    is producing them (hint: lower the `bus_speed_hz` parameter in `serial = spi(port=0,
    device=0, bus_speed_hz=2000000)` to 1,000,000 or 500,000).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您的逻辑电平转换器无法跟上SPI总线速度，请尝试降低SPI总线速度——也就是说，它无法将3.3伏转换为5伏的信号，就像SPI接口产生它们一样（提示：将`serial
    = spi(port=0, device=0, bus_speed_hz=2000000)`中的`bus_speed_hz`参数降低到1,000,000或500,000）。
- en: Connect the APA102's DI and CI directly to SDA and SCLK on the Raspberry Pi.
    The goal here is to bypass the logic level converter to rule it out as the problem.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将APA102的DI和CI直接连接到树莓派上的SDA和SCLK。这里的目标是绕过逻辑电平转换器，以排除它作为问题的可能性。
- en: Well done! This was a lengthy and detailed section on the APA102\. We covered
    a lot of concepts in addition to the APA102 itself, including how to calculate
    the power requirements of a LED strip and an introduction to the Luma library,
    which can be used to control a host of different lighting and display devices
    besides the APA102\. Then, we concluded with practical troubleshooting tips in
    case your APA102 circuit, setup, or code did not work on the first go.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！这是关于APA102的一个冗长而详细的部分。除了APA102本身之外，我们还涵盖了许多概念，包括如何计算LED灯带的功率需求以及Luma库的介绍，该库可以用于控制APA102之外的许多不同的照明和显示设备。然后，我们总结了在您的APA102电路、设置或代码第一次运行时的实际故障排除提示。
- en: All of this knowledge and experience will be adaptable to similar lighting projects
    you undertake and SPI-based projects in general. In particular, it will be a helpful
    reference to calculate the power requirements of lighting projects and troubleshoot
    circuits and code when they do not work. It also provides the basic foundations
    that we will be building on in the next section where we look at how to interface
    an OLED display with our Raspberry Pi.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些知识和经验都将适用于您进行的类似照明项目和SPI-based项目。特别是，它将是一个有用的参考，用于计算照明项目的功率需求，并在它们不起作用时排除电路和代码的故障。它还提供了我们将在下一节中构建的基本基础，我们将在其中研究如何将OLED显示器与我们的树莓派接口。
- en: Using an OLED display
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OLED显示器
- en: An **OLED** or **Organic LED** display is a type of technology used to make
    screens. Our example will be using an SSD1306, which is a monochrome 128x64 pixel
    display, however, the information will apply to other OLED displays too.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**OLED**或**有机发光二极管**显示器是一种用于制作屏幕的技术。我们的示例将使用SSD1306，这是一种单色128x64像素显示器，但是这些信息也适用于其他OLED显示器。'
- en: Our sample program will read your Raspberry Pi's CPU temperature and display
    it on the OLED display together with a thermometer icon. We will be assuming the
    OLED will connect using an I2C interface, however, an SPI interface device should
    also be compatible if you use an `spi()` instance (like in the APA102 example)
    for the `serial` object. The ability to change the interacting method used by
    the Luma library means you can reuse existing code with compatible display devices
    with minimal code changes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例程序将读取您的树莓派的CPU温度，并将其与温度计图标一起显示在OLED显示器上。我们将假设OLED将使用I2C接口连接，但是，如果您使用`spi()`实例（就像在APA102示例中）用于`serial`对象，那么SPI接口设备也应该是兼容的。Luma库更改交互方法的能力意味着您可以在最小更改代码的情况下重用现有代码与兼容的显示设备。
- en: We will commence by connecting the OLED display to the Raspberry Pi and verifying
    that it is connected.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先连接OLED显示器到树莓派并验证它是否连接。
- en: Connecting the OLED display
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接OLED显示器
- en: 'Let''s connect your OLED display to your Raspberry Pi, as shown in *Figure
    8.7*:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将您的OLED显示器连接到您的树莓派，如*图8.7*所示：
- en: '![](assets/6889ef9e-92f6-4c85-a9b3-43397896bbf5.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6889ef9e-92f6-4c85-a9b3-43397896bbf5.png)'
- en: 'Figure 8.7 – I2C OLED display circuit**IMPORTANT NOTE ON POWERING YOUR OLED**:
    Our circuit, shown in *Figure 8.6*, and the associated discussion uses a 5-volt
    power supply. If you consult the SSD1306 OLED datasheet mentioned at the beginning
    of this chapter, you will discover that it mentions a minimum supply voltage of
    7 volts. Furthermore, you will find other sources and SSD1306 OLED modules that
    indicate different voltage requirements. **Please consult the documentation or
    place of purchase to obtain the correct operating voltage for your OLED and adjust
    the supply voltage as required (*steps 7* and *8* in the following list).**'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.7* - I2C OLED显示电路**关于为您的OLED供电的重要说明**：我们的电路，如*图8.6*所示，并且相关讨论使用了5伏的电源。如果您查阅本章开头提到的SSD1306
    OLED数据表，您将发现它提到了最低供电电压为7伏。此外，您将找到其他来源和SSD1306 OLED模块，它们指出了不同的电压要求。**请查阅文档或购买地点，以获取您的OLED的正确工作电压，并根据需要调整供电电压（*步骤7*和*8*）。**'
- en: 'You can connect the OLED with the following steps, which correspond to the
    numbered black circles in *Figure 8.7*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按照以下步骤连接OLED，这些步骤对应于*图8.7*中编号的黑色圆圈：
- en: Connect the negative rails on the left-hand side and right-hand side power rails.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接左侧和右侧电源轨道上的负极。
- en: Connect the SDA1 (Data) pin of your Raspberry Pi into a vacant row on your breadboard.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的树莓派的SDA1（数据）引脚连接到面包板上的一个空行。
- en: Connect the SDA (Data) terminal or wire of your OLED display into the same row
    use used for *step 2*.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的OLED显示屏的SDA（数据）端子或线连接到用于*步骤2*的同一行。
- en: Connect the SCL1 (Clock) pin of your Raspberry Pi into a vacant row on your
    breadboard.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的树莓派的SCL1（时钟）引脚连接到面包板上的一个空行。
- en: Connect the SCL (Clock) terminal or wire of your OLED display into the same
    row use used for *step 4*.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的OLED显示屏的SCL（时钟）端子或线连接到用于*步骤4*的同一行。
- en: Connect a GND Pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的树莓派的GND引脚连接到左侧电源轨道的负极。
- en: Connect the positive output of a 5-volt power supply to the positive rail of
    the right-hand side power rail.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将5伏电源的正输出连接到右侧电源轨道的正极。
- en: Connect the negative output of a 5-volt power supply to the negative rail of
    the right-hand side power rail.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将5伏电源的负输出连接到右侧电源轨道的负极。
- en: Connect the GND terminal or wire of your OLED display to the negative rail of
    the right-hand side power rail.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的OLED显示屏的GND端子或线连接到右侧电源轨道的负极。
- en: Connect the VCC terminal or wire of your OLED display (it might also be named
    VDD, Vin, V+, or something similar indicating a voltage input) to the positive
    rail of the right-hand side power rail.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的OLED显示屏的VCC端子或线（也可能被命名为VDD、Vin、V+或类似表示电压输入的名称）连接到右侧电源轨道的正极。
- en: Good job! This completes our OLED circuit. As you can see, we are powering the
    OLED from a 5-volt power supply, however, the SDA (Data)/SLC (Clock) channels
    are connected directly to your Raspberry Pi. Unlike the APA102 LED strip we used
    in the previous section, the SSD1306 OLED is 3.3-volt logic compatible, hence,
    we do not need a logic level converter to convert logic level voltages on the
    clock and data channels.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！这完成了我们的OLED电路。正如你所看到的，我们正在用5伏电源为OLED供电，然而，SDA（数据）/SLC（时钟）通道直接连接到你的树莓派上。与我们在上一节中使用的APA102
    LED灯带不同，SSD1306 OLED兼容3.3伏逻辑，因此，在时钟和数据通道上我们不需要逻辑电平转换器来转换逻辑电平电压。
- en: 'Let''s briefly consider the current requirements for the SSD1306 OLED. My testing
    resulted in the following current measurements:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要考虑一下SSD1306 OLED的电流要求。我的测试结果如下：
- en: 'Black screen: ~3mA'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑屏：~3mA
- en: 'White screen (every pixel on): ~27mA'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白屏（每个像素都亮）：~27mA
- en: At a maximum current usage of ~27mA, you can try connecting the +5V to the Raspberry
    Pi's 5-volt pin, but remember this will take reserve current away from your Raspberry
    Pi (and it may reset when you run the code if your Raspberry Pi's power supply
    is not adequate).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在最大电流使用量为~27mA的情况下，你可以尝试将+5V连接到树莓派的5伏引脚，但请记住这将从你的树莓派中取走保留电流（如果你的树莓派的电源供应不足，可能会在运行代码时重置）。
- en: If you need a recap on current measurement using a digital multimeter, please
    refer to [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)*, Turning Things
    On and Off*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要回顾使用数字万用表进行电流测量，请参考[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)*，打开和关闭*。
- en: With your OLED connected to your Raspberry Pi's SDA and SCL pins next, we will
    verify that it has been detected by your Raspberry Pi using the `i2cdetect` utility.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将你的OLED连接到树莓派的SDA和SCL引脚，然后我们将使用`i2cdetect`实用程序验证树莓派是否检测到了它。
- en: Verifying whether the OLED display is connected
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证OLED显示屏是否连接
- en: 'Previously, in [Chapter 5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)*, Connecting
    Your Raspberry Pi to the Physical World,* we used the `i2cdetect` command-line
    tool to check whether an I2C device was connected and to verify its I2C address.
    Check that your Raspberry Pi can see your OLED display by running the following
    in a Terminal:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)*，将你的树莓派连接到物理世界*中，我们使用了`i2cdetect`命令行工具来检查I2C设备是否连接，并验证其I2C地址。通过在终端中运行以下命令来检查你的树莓派是否能看到你的OLED显示屏：
- en: '[PRE13]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If your OLED is connected, you will see the following output, which tells us
    that the OLED was detected and has the hex address, `0x3C`:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的OLED已连接，你将看到以下输出，告诉我们OLED已被检测到，并具有十六进制地址`0x3C`：
- en: '[PRE14]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If your address is different, that's okay, we just need to adjust the address
    in code which we will do next.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的地址不同，没关系，我们只需要在代码中调整地址，接下来我们将这样做。
- en: Configuring and running the OLED example
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置和运行OLED示例
- en: 'The code we are about to explore is contained in the `chapter08/oled_cpu_temp.py` file.
    Please review this file to get an overall view of what it contains before continuing:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将探讨的代码包含在`chapter08/oled_cpu_temp.py`文件中。在继续之前，请先查看这个文件，以获得它包含的内容的整体视图：
- en: 'If the OLED I2C address you obtained in the preceding was different to `0x3C`,
    find the following line in the source code and update the address parameter to
    match your OLED I2C address:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在前面得到的OLED I2C地址与`0x3C`不同，请在源代码中找到以下行，并更新地址参数以匹配你的OLED I2C地址：
- en: '[PRE15]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the program, and you should observe the CPU temperature and a thermometer
    icon drawn on the OLED display.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序，你应该看到OLED显示屏上绘制的CPU温度和温度计图标。
- en: Once you have configured your OLED display address in code and confirmed the
    example works on your OLED, we are ready to review the code and learn how it works.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在代码中配置了你的OLED显示屏地址并确认了示例在你的OLED上运行正常，我们就准备好审查代码并学习它是如何工作的。
- en: OLED code walkthrough
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: OLED代码演示
- en: Commencing with the imports, in line (1), we import classes from the **PIL**
    (**Pillow**) module, which we use to create the image we want to render on the
    OLED display. We also import several other classes from the Luma module related
    to our SSD1306 OLED and its I2C interface (SPI is also imported for reference).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从导入开始，在第（1）行，我们从**PIL**（**Pillow**）模块中导入类，用于创建我们想要在OLED显示屏上呈现的图像。我们还从Luma模块中导入与我们的SSD1306
    OLED及其I2C接口相关的几个其他类（SPI也被导入以供参考）。
- en: 'We see how to create an I2C instance in line (2) representing the interface
    that our OLED is connected to. Commented out is an SPI alternative. In line (3),
    we create an instance of `ssd1306` that represents our OLED display and assign
    it to the `device` variable. If you are using a different OLED display than the
    SSD1306, you will need to identify and adjust the `ssd1306` import line, and the
    device instance created in line (3):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到如何在第（2）行创建一个代表我们OLED连接的接口的I2C实例。被注释掉的是SPI替代方案。在第（3）行，我们创建了一个代表我们OLED显示器的`ssd1306`实例，并将其分配给`device`变量。如果您使用的OLED显示器与SSD1306不同，您需要识别和调整`ssd1306`导入行以及第（3）行创建的设备实例：
- en: '[PRE16]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In line (4), we encounter the `get_cpu_temp()` function, which calls a command-line
    utility to retrieve your Raspberry Pi''s CPU temperature before parsing and returning
    the result that we will use shortly to construct our display image:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（4）行，我们遇到了`get_cpu_temp()`函数，该函数调用一个命令行实用程序来检索树莓派的CPU温度，然后解析并返回结果，我们将很快用来构建我们的显示图像：
- en: '[PRE17]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the following code in line (5), we define temperature thresholds that influence
    the icon we show on our OLED display. We will also use the high threshold to make
    the OLED display blink to help to create a visual attention-grabber.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（5）行的以下代码中，我们定义了影响我们OLED显示器上显示图标的温度阈值。我们还将使用高阈值使OLED显示屏闪烁，以帮助创建视觉吸引力。
- en: 'In line (6), we load in three thermometer images and scale them down starting
    at line (7) to a size that is workable with the 128x64 pixel dimensions of our
    SSD1306 OLED:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（6）行，我们加载了三个温度计图像，并从第（7）行开始将它们缩小到与我们的SSD1306 OLED的128x64像素尺寸相适应的大小：
- en: '[PRE18]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we define two variables starting at line (8) in the following. `refresh_secs`
    is the rate at which we check the CPU temperature and update the OLED display
    while `high_alert` is used to flag a breach of the maximum temperature threshold
    and start the screen blinking:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从以下第（8）行开始定义了两个变量。`refresh_secs`是我们检查CPU温度并更新OLED显示屏的速率，而`high_alert`用于标记最高温度阈值的违反并开始屏幕闪烁：
- en: '[PRE19]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `while` loop, in line (9), we see the use of the PIL module. Here, we
    are creating a blank image using the same dimensions as the OLED device (that
    is, 128x64 for the SSD1306) and storing it in the `canvas` variable. In subsequent
    code, we manipulate this in-memory canvas image before sending it to the SSD1306
    for rendering.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在`while`循环中，在第（9）行，我们看到了PIL模块的使用。在这里，我们使用与OLED设备相同尺寸（即SSD1306的128x64）创建了一个空白图像，并将其存储在`canvas`变量中。在随后的代码中，我们会在内存中操作这个画布图像，然后将其发送到SSD1306进行渲染。
- en: The draw instance created in line (10) is a PIL helper class that we use for
    drawing on the canvas. We use this instance for placing a bounding rectangle around
    the canvas and will use it later to add text to the canvas. The `draw` instance
    can also be used to draw many other shapes including lines, arcs, and circles.
    A link to the PIL API documentation can be found in the *Further reading* section.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（10）行创建的draw实例是我们用于在画布上绘制的PIL辅助类。我们使用这个实例来在画布上放置一个边界矩形，并稍后用它来向画布添加文本。`draw`实例还可以用于绘制许多其他形状，包括线条、弧线和圆形。PIL
    API文档的链接可以在*进一步阅读*部分找到。
- en: 'The block of code starting at line (11) in the following is what will make
    our OLED display blink when `high_alert` is `True`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码从第（11）行开始的代码块将使我们的OLED显示在`high_alert`为`True`时闪烁：
- en: '[PRE20]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Starting at line (12), we compare the temperature reading we obtained from
    `get_cpu_temp()` to the threshold values defined earlier. Depending on the result,
    we change the thermometer image that will be shown, and for a high threshold breach,
    we set `high_alert = True`. Setting `high_alert` to `True` will cause the OLED
    display to blink on the next loop iteration:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 从第（12）行开始，我们将从`get_cpu_temp()`获得的温度读数与之前定义的阈值进行比较。根据结果，我们更改将显示的温度计图像，并且对于高阈值违规，我们将`high_alert
    = True`。将`high_alert`设置为`True`将导致OLED显示在下一个循环迭代中闪烁：
- en: '[PRE21]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We start constructing our display starting at line (13) in the following. We
    calculate `image_xy` to be a point at which our thermometer image would be centered
    on the display and then offset that point using the `image_x_offset` and `image_x_offset`
    variables to move the image into the position we want it rendered.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从以下第（13）行开始构建我们的显示。我们计算`image_xy`是我们的温度计图像在显示器上居中的点，然后使用`image_x_offset`和`image_x_offset`变量来偏移该点，以将图像移动到我们希望它呈现的位置。
- en: 'In line (14), we then paste our thermometer image onto the canvas:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（14）行，我们将温度计图像粘贴到画布上：
- en: '[PRE22]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Moving on to line (15) in the following code block, we create the text we want
    to display on our OLED screen and use the same technique as for the image to position
    the text on the canvas in line (17). Notice the use of `draw.textsize()` to obtain
    the pixel dimensions of the text.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码块的第（15）行，我们创建了要显示在OLED屏幕上的文本，并使用与图像相同的技术在第（17）行将文本定位在画布上。请注意使用`draw.textsize()`来获取文本的像素尺寸。
- en: In line (16), we set `font = None` to use a default system font for the example
    because I cannot be entirely sure what fonts you have available on your Raspberry
    Pi. The line after line (16) that is commented out shows an example of using a
    custom font.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（16）行，我们设置`font = None`，以便在示例中使用默认系统字体，因为我无法完全确定您的树莓派上有哪些字体可用。在第（16）行之后被注释掉的行显示了使用自定义字体的示例。
- en: Run the `fc-list` command in a Terminal to see a list of fonts installed on
    your Raspberry Pi.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端中运行`fc-list`命令，可以查看树莓派上安装的字体列表。
- en: 'Finally, in line (18), we draw the text on the canvas:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第（18）行，我们在画布上绘制文本：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We have now reached the tail-end of the while loop. In line (19) in the following
    code, we use the `device` instance that represents the SSD1306 OLED display to
    display `canvas`. The `canvas.convert(device.mode)` call converts the canvas image
    that we created into a format usable by the SSD1306:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了while循环的尾端。在以下代码的第（19）行，我们使用代表SSD1306 OLED显示器的`device`实例来显示`canvas`。`canvas.convert(device.mode)`调用将我们创建的画布图像转换为SSD1306可用的格式：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Before we complete our exploration of OLEDs, I want to point you to more examples. The
    Luma library contains an extensive range of examples covering many aspects of
    using an OLED display. A link to the examples can be found in *Further reading*.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成对OLED的探索之前，我想向您指出更多示例。Luma库包含许多示例，涵盖了使用OLED显示器的许多方面。可以在*进一步阅读*中找到示例的链接。
- en: OLED displays are low cost, small in size, and light on power consumption, so
    you frequently find them used in battery-operated devices. If you want to explore
    other display options for your Raspberry Pi, you might like to investigate the
    range of Raspberry Pi TFT displays that are available (just search for that term
    on sites such as eBay.com or Banggood.com). These are full-color mini-monitors
    for your Raspberry Pi, and there are even touch-screen options available.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: OLED显示器成本低廉，体积小，耗电量低，因此经常用于电池操作设备。如果您想探索树莓派的其他显示选项，您可能想调查一下可用的树莓派TFT显示器范围（只需在eBay.com或Banggood.com等网站上搜索该术语）。这些是树莓派的全彩迷你监视器，甚至还有触摸屏选项可用。
- en: This now concludes our coverage of lighting and displays with our Raspberry
    Pi and Python. The knowledge you have learned so far will enable you to use and
    correctly power your own simple LED lighting projects and leverage a range of
    OLED displays for those projects where you wish to display textual and graphical
    information to users.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就结束了关于使用树莓派和Python进行照明和显示的覆盖范围。到目前为止，您所学到的知识将使您能够使用和正确供电自己的简单LED照明项目，并利用各种OLED显示器，用于那些您希望向用户显示文本和图形信息的项目。
- en: To conclude the exercises for this chapter, next, we will revisit **Pulse-Width-Modulation**
    (**PWM**) briefly and see how we can use it to generate sound.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，接下来，我们将简要回顾**脉宽调制（PWM）**，并看看我们如何使用它来产生声音。
- en: Making sound with buzzers and PWM
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用蜂鸣器和PWM发出声音
- en: In the final section of this chapter, we will walk through an example of how
    to make simple sound and music with PWM. Our sample program is going to play a
    musical scale on the buzzer, and we will be using a music score format called **Ring
    Tone Text Transfer Language (RTTTL****)**, which was developed by Nokia in the
    pre-smartphone era for creating ringtones. As we learn, we can use a simple Python
    library to parse an RTTTL music score and turn its notes into a PWM frequency
    and duration that can then be used to associate a buzzer to create an auditable
    tune.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一节中，我们将演示如何使用PWM制作简单的声音和音乐。我们的示例程序将在蜂鸣器上演奏一个音阶，并且我们将使用一种名为**Ring Tone
    Text Transfer Language (RTTTL)**的音乐记谱格式，这是由诺基亚在智能手机时代之前开发用于创建手机铃声的。随着我们的学习，我们可以使用一个简单的Python库来解析RTTTL音乐记谱，并将其音符转换为PWM频率和持续时间，然后可以用来关联蜂鸣器以创建可听的旋律。
- en: 'To make a sound with PWM, we need a form of a speaker, and we will be using
    what is known as a *passive* buzzer. Buzzers come in two basic forms:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用PWM发出声音，我们需要一种形式的扬声器，我们将使用所谓的*被动*蜂鸣器。蜂鸣器有两种基本形式：
- en: '**Active buzzers**: These buzzers contain an internal oscillator that generates
    a single set tone. All you need to do us apply a DC voltage to an active buzzer
    and it will make a noise.'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主动蜂鸣器**：这些蜂鸣器包含一个内部振荡器，可以产生单一的音调。您只需要给主动蜂鸣器施加直流电压，它就会发出声音。'
- en: '**Passive buzzers**: These do not contain any internal smarts to make them
    work, so the oscillating must be done by the controlling device. The upside of
    this is that we can set and change the tone as we wish, and we can achieve this
    using PWM.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**被动蜂鸣器**：这些蜂鸣器不包含任何内部智能来使它们工作，因此振荡必须由控制设备完成。这样做的好处是我们可以根据需要设置和更改音调，并且我们可以使用PWM来实现这一点。'
- en: Now that we understand a little about how to make sound with buzzers, let's
    continue and create our sound-making circuit.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了如何使用蜂鸣器发出声音，让我们继续创建我们的发声电路。
- en: Building the RTTTL circuit
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 建立RTTTL电路
- en: 'In this section, we will be building a circuit to drive a passive buzzer. This
    circuit, shown in *Figure 8.8 *is very similar to the MOSFET circuit that we covered
    in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning Things On
    and Off*, only this time with a buzzer connected as the load:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将建立一个驱动被动蜂鸣器的电路。这个电路如*图8.8*所示，与我们在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中介绍的MOSFET电路非常相似，只是这次连接了一个蜂鸣器作为负载：
- en: '![](assets/5a02879c-e8f4-4c24-8cd1-5a8ccfe81786.png)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a02879c-e8f4-4c24-8cd1-5a8ccfe81786.png)'
- en: Figure 8.8 – Buzzer driver circuit Schematic
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 - 蜂鸣器驱动电路原理图
- en: 'We will start our circuit build by placing the components onto our breadboard:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过将组件放入面包板来开始我们的电路构建：
- en: '![](assets/a7c35a01-e8c2-4653-9f5c-98b42b39728c.png)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a7c35a01-e8c2-4653-9f5c-98b42b39728c.png)'
- en: Figure 8.9 – Buzzer driver circuit (part 1 of 2)
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 - 蜂鸣器驱动电路（1/2）的一部分
- en: 'The following step numbers match the numbered black circles in *Figure 8.9*:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤编号与*图8.9*中编号的黑色圆圈相匹配：
- en: Place the MOSFET onto the breadboard, paying attention to the orientation of
    the component with regards to the legs. Please see *Figure 7.7 *in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning
    Things On and Off*, if you need help to identify the MOSFET's legs.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MOSFET放在面包板上，注意组件与引脚的方向。如果您需要帮助识别MOSFET的引脚，请参阅[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中的*图7.7*，*打开和关闭设备*。
- en: Place the 100kΩ resistor (R2) into your breadboard. One end of this resistor
    shares the same row as the MOSFET's Gate (G) leg.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将100kΩ电阻（R2）放入面包板中。这个电阻的一端与MOSFET的栅极（G）腿共享同一排。
- en: Place the 1kΩ resistor (R1) into your breadboard. One end of this resistor also
    shares the same row as the MOSFET's Gate (G) leg.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将1kΩ电阻（R1）放入面包板中。这个电阻的一端也与MOSFET的栅极（G）腿共享同一排。
- en: Place the diode into your breadboard, with the cathode leg (the leg at the end
    with the band) pointing toward the end of the breadboard.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二极管放入面包板中，带有阴极腿（带子朝向的一端）指向面包板的一端。
- en: Connect the positive wire of your buzzer into the same row shared by the diode's
    cathode leg.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蜂鸣器的正极线连接到与二极管阴极腿共享的同一排中。
- en: Connect the negative wire of your buzzer into a vacant breadboard row.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蜂鸣器的负极线连接到一个空闲的面包板行。
- en: 'Now that we have laid the components, let''s wire them up:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了组件，让我们将它们连接起来：
- en: '![](assets/f6815d35-5956-4932-a710-2648ef690ed6.png)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f6815d35-5956-4932-a710-2648ef690ed6.png)'
- en: Figure 8.10 – Buzzer driver circuit (part 2 of 2)
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 蜂鸣器驱动电路（第2部分）
- en: The following step numbers match the numbered black circles in *Figure 8.10:*
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤编号与*图8.10*中编号的黑色圆圈相匹配：
- en: Connect the negative rail of the left-hand side power rail to the 1kΩ resistor
    (R2).
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左侧电源轨的负极连接到1kΩ电阻（R2）。
- en: Connect the Source leg (S) of the MOSFET to the negative rail of the left-hand
    side power rail.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MOSFET的源腿（S）连接到左侧电源轨的负极。
- en: Connect the negative rail of the left-hand side power rail to a GND pin on your
    Raspberry Pi.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左侧电源轨的负极连接到树莓派上的GND引脚。
- en: Connect the end of the 100kΩ resistor (R1) to GPIO 12/PWM0 on your Raspberry
    Pi. As a reminder, GPIO 12 in its alternative function is channel PWM0, a hardware
    PWM pin.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将100kΩ电阻（R1）的末端连接到树莓派的GPIO 12/PWM0上。提醒一下，GPIO 12在其替代功能中是通道PWM0，是一个硬件PWM引脚。
- en: Connect the Drain leg (D) of the MOSFET to the anode leg of the diode.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将MOSFET的漏极（D）连接到二极管的阳极腿。
- en: Connect the anode leg of the diode to the negative wire of your buzzer.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将二极管的阳极腿连接到蜂鸣器的负极线。
- en: Connect the buzzer's positive wire/diode's cathode leg into the positive rail
    of the right-hand side power rail.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将蜂鸣器的正极线/二极管的阴极腿连接到右侧电源轨的正极。
- en: Connect the negative rails of the left-hand side and right-hand side power rails.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接左侧和右侧电源轨的负极。
- en: Connect the positive output of the power supply to the positive rail of the
    right-hand side power rail.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源供应的正极输出连接到右侧电源轨的正极。
- en: Connect the negative output of the power supply to the negative rail of the
    right-hand side power rail.
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源供应的负极输出连接到右侧电源轨的负极。
- en: Now that you have completed this circuit build, we will proceed and run our
    Python example, which will make some music!
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成了这个电路搭建，我们将继续运行我们的Python示例，这将制作一些音乐！
- en: Running the RTTTL music example
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行RTTTL音乐示例
- en: Run the code in the `chapter08/passive_buzzer_rtttl.py` file, and your buzzer
    will play a simple musical scale.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`chapter08/passive_buzzer_rtttl.py`文件中的代码，您的蜂鸣器将播放一个简单的音阶。
- en: 'The code to perform this is quite simple. In line (1) in the following code,
    we are using the `rtttl` module to parse an RTTTL music score into a series of
    notes defined by frequency and duration. Our score is stored in the `rtttl_score`
    variable:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此操作的代码非常简单。在以下代码的第（1）行中，我们使用`rtttl`模块将RTTTL音乐乐谱解析为由频率和持续时间定义的一系列音符。我们的乐谱存储在`rtttl_score`变量中：
- en: '[PRE25]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, in line (2), we loop through the parsed notes in `rtttl_score` and extract
    the frequency and duration:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第（2）行，我们循环遍历`rtttl_score`中解析的音符，并提取频率和持续时间：
- en: '[PRE26]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In line (3), we set the frequency on the buzzer's GPIO pin using PWM, and hold
    the note for its duration at line (4) before continuing to the next note.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（3）行，我们使用PWM在蜂鸣器的GPIO引脚上设置频率，并在第（4）行保持音符的持续时间，然后继续到下一个音符。
- en: In line (3), note that we are using PiGPIO's `hardware_PWM()` and that `BUZZER_GPIO` *must* be
    a hardware compatible PWM pin. PiGPIO's hardware-timed PWM (which is available
    on any GPIO pin) is not suitable for music creation because it is restricted to
    a discrete range of frequencies. If you need a refresher on PWM techniques, revisit [Chapter
    5](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml), *Connecting Your Raspberry Pi
    to the Physical World.*
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在第（3）行，请注意我们正在使用PiGPIO的`hardware_PWM()`，并且`BUZZER_GPIO` *必须* 是一个硬件兼容的PWM引脚。
    PiGPIO的硬件定时PWM（可用于任何GPIO引脚）不适用于音乐创作，因为它受限于一系列离散的频率。如果您需要PWM技术的复习，请重新阅读[第5章](45ff8333-2eb2-47f1-86d9-31ccecf39de5.xhtml)，*将您的树莓派连接到物理世界*。
- en: Making music with RTTTL is very electronic-sounding, so to speak, and is a popular
    technique with resource-limited microcontrollers. However, remember that, with
    our Raspberry Pi, we have more than enough resources and the built-in hardware
    to play rich media such as MP3s.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RTTTL制作音乐听起来非常电子化，并且是资源有限的微控制器中的一种流行技术。但是，请记住，对于我们的树莓派来说，我们有足够的资源和内置硬件来播放丰富的媒体，如MP3。
- en: Try a web search for *RTTTL Songs* and you'll find many scores for songs, retro
    computer games, and TV and movie themes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在网络上搜索*RTTTL歌曲*，您会找到许多歌曲、复古电脑游戏和电视电影主题的乐谱。
- en: If you want to explore playing and controlling MP3s via Python, you'll find
    many resources, tutorials, and examples across the web. Unfortunately, there are
    many ways to achieve this task (including changes across different versions of
    Raspbian OS), so it can be a bit finicky at times getting your Raspberry Pi and
    Raspbian OS set up and configured reliably. If you go down this route, my recommendation
    is to explore playing MP3s and controlling audio (that is, changing volume) on
    the command line first. Once you have a stable and reliable setup, then proceed
    to explore a Python-based way.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想通过Python探索播放和控制MP3，您会发现网络上有许多资源、教程和示例。不幸的是，有许多方法可以实现这个任务（包括Raspbian OS的不同版本之间的更改），因此有时在可靠地设置和配置您的Raspberry
    Pi和Raspbian OS时可能会有点棘手。如果您选择这条路线，我的建议是首先在命令行上探索播放MP3和控制音频（即更改音量）。一旦您有了稳定可靠的设置，然后再探索基于Python的方法。
- en: Summary
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to use PWM to set the color of an RGB LED and
    that a standalone single RGB LED requires three dedicated GPIO pins to work—one
    for each of the colors, red, green, and blue. We then explored another type of
    RGB LED, the APA102, which is a 2-wire SPI controllable device that can be chained
    together to create LED lighting strips. Next, we learned how to use an OLED display
    by creating an example application that displayed your Raspberry Pi's CPU temperature.
    We concluded with an example of using PWM together with a passive buzzer to make
    sound by parsing an RTTTL music score.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用PWM来设置RGB LED的颜色，以及独立的单个RGB LED需要三个专用的GPIO引脚来工作——分别用于红色、绿色和蓝色。然后，我们探索了另一种类型的RGB
    LED，即APA102，它是一种2线SPI可控设备，可以串联在一起创建LED灯带。接下来，我们学习了如何使用OLED显示器，创建了一个示例应用程序，显示了树莓派的CPU温度。最后，我们通过解析RTTTL音乐乐谱，使用PWM和被动蜂鸣器制作声音。
- en: What you have learned in this chapter will allow you to add visual and auditable
    feedback to your own projects. You will also be able to extend your learning to
    other types of displays with relative ease, as the Luma library we have used is
    capable of working with a range of other display types and models in addition
    to the APA102 LED strip and SSD1306 OLED devices we used in this chapter.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中学到的知识将使您能够为自己的项目添加可视和可审计的反馈。您还将能够相对容易地将您的学习扩展到其他类型的显示器，因为我们在本章中使用的Luma库能够与APA102
    LED灯带和SSD1306 OLED设备以外的其他显示器类型和型号一起工作。
- en: In the next chapter, we will be looking at components and techniques to measure
    environmental conditions including temperature, humidity, and light.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将研究用于测量环境条件（包括温度、湿度和光照）的组件和技术。
- en: Questions
  id: totrans-333
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter''s material. You will find the answers in the *Assessments*
    section of the book:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的结束，这里有一些问题供您测试对本章材料的了解。您将在书的*评估*部分找到答案：
- en: Your APA102 LED strip is set to show all LEDs as white, but instead, all of
    the LEDs look reddish. What could be the problem?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的APA102 LED灯带设置为显示所有LED为白色，但实际上所有LED看起来都是红色的。可能是什么问题？
- en: What limitation does the APA102 place on SPI?
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: APA102对SPI有什么限制？
- en: Your APA102 does not work when you use a logic level converter but appears to
    work when you connect it directly to the MOSI and SCK pins on your Raspberry Pi
    (hence bypassing the logic level converter). What are some possible causes of
    the problem?
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您使用逻辑电平转换器时，您的APA102无法工作，但当您直接连接到树莓派的MOSI和SCK引脚时（因此绕过逻辑电平转换器），它似乎可以工作。问题的一些可能原因是什么？
- en: What is the basic process for creating and displaying an image on an OLED display
    using the Luma OLED library?
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Luma OLED库在OLED显示器上创建和显示图像的基本过程是什么？
- en: What is RTTTL?
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是RTTTL？
- en: Further reading
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'An APA102 is a good choice to commence your learning on lower level data protocol
    and communication. After reviewing the APA102 datasheet for its data protocol
    (see the link under *Technical requirements* at the start of this chapter), the
    next logical step is to review some lower-level code. The APA102 example for PiGPIO
    is a one such starting point, but you''ll find others on PyPi.org:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: APA102是一个很好的选择，可以开始学习较低级别的数据协议和通信。在查看APA102数据协议的数据表后（请参见本章开头的*技术要求*下的链接），下一个逻辑步骤是查看一些较低级别的代码。
    PiGPIO的APA102示例是一个起点，但您会在PyPi.org上找到其他示例：
- en: '[http://abyz.me.uk/rpi/pigpio/examples.html#Python_test-APA102_py](http://abyz.me.uk/rpi/pigpio/examples.html#Python_test-APA102_py)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://abyz.me.uk/rpi/pigpio/examples.html#Python_test-APA102_py](http://abyz.me.uk/rpi/pigpio/examples.html#Python_test-APA102_py)'
- en: 'The Luma suite of libraries offers many high-level modules for integrating
    common display with a Raspberry Pi beyond the APA102 and SSD1306 OLED we covered
    in this chapter. Furthermore, Luma contains an extensive range of examples:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Luma系列库提供了许多高级模块，用于将常见显示器与树莓派集成，超出了本章中涵盖的APA102和SSD1306 OLED。此外，Luma还包含大量的示例：
- en: Luma: [https://pypi.org/project/luma.core](https://pypi.org/project/luma.core)
    (follow the links for different display types)
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Luma: [https://pypi.org/project/luma.core](https://pypi.org/project/luma.core)（按照不同显示类型的链接）
- en: Luma examples on GitHub: [https://github.com/rm-hull/luma.examples](https://github.com/rm-hull/luma.examples)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub上的Luma示例：[https://github.com/rm-hull/luma.examples](https://github.com/rm-hull/luma.examples)
- en: 'Luma uses a PIL (Python Imaging Library)/Pillow comparable API for drawing
    and manipulating displays. We specifically used `ImageDraw` in our OLED example.
    You will find the PIL API documentation at the following link:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: Luma使用PIL（Python Imaging Library）/Pillow兼容的API来绘制和操作显示器。我们在我们的OLED示例中特别使用了`ImageDraw`。您可以在以下链接找到PIL
    API文档：
- en: '[https://pillow.readthedocs.io](https://pillow.readthedocs.io)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://pillow.readthedocs.io](https://pillow.readthedocs.io)'
- en: 'If you would like to explore the RTTTL format further, its Wikipedia site is
    an excellent starting point:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步探索RTTTL格式，可以从其维基百科网站开始：
- en: RTTTL [https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language](https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language)
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RTTTL [https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language](https://en.wikipedia.org/wiki/Ring_Tone_Transfer_Language)
