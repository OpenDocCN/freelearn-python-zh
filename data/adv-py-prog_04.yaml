- en: '*Chapter 3*: Fast Array Operations with NumPy, Pandas, and Xarray'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第3章*: 使用NumPy、Pandas和Xarray进行快速数组操作'
- en: NumPy is the *de facto* standard for scientific computing in Python. It offers
    flexible multidimensional arrays that allow you to perform fast and concise mathematical
    calculations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy是Python中科学计算的*事实上的*标准。它提供了灵活的多维数组，允许您进行快速简洁的数学计算。
- en: NumPy provides common data structures and algorithms designed to express complex
    mathematical operations using a concise syntax. The multidimensional array, `numpy.ndarray`,
    is internally based on C arrays. Apart from the performance benefits, this choice
    allows NumPy code to easily interface with the existing C and FORTRAN routines;
    NumPy helps bridge the gap between Python and the legacy code written using those
    languages.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了通用的数据结构和算法，旨在使用简洁的语法表达复杂的数学运算。多维数组`numpy.ndarray`在内部基于C数组。除了性能优势外，这种选择还允许NumPy代码轻松地与现有的C和FORTRAN例程接口；NumPy帮助弥合了Python与使用这些语言编写的旧代码之间的差距。
- en: In this chapter, we will learn how to create and manipulate NumPy arrays. We
    will also explore the NumPy broadcasting feature, which is used to rewrite complex
    mathematical expressions efficiently and succinctly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何创建和操作NumPy数组。我们还将探索NumPy的广播功能，该功能用于高效简洁地重写复杂的数学表达式。
- en: '**pandas** is a tool that relies heavily on NumPy and provides additional data
    structures and algorithms targeted toward data analysis. We will introduce the
    main pandas features and their usage. We will also learn how to achieve high performance
    using pandas data structures and vectorized operations.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**pandas**是一个高度依赖NumPy的工具，提供了针对数据分析的额外数据结构和算法。我们将介绍pandas的主要特性和用法。我们还将学习如何使用pandas数据结构和向量化操作达到高性能。'
- en: Both NumPy and pandas are insufficient in many use cases concerning labeled,
    multidimensional data. The xarray library combines the best features from the
    other two tools and offers further optimized data processing functionalities.
    We will discuss the motivation for this tool and study the performance improvements
    it offers via explicit examples.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在涉及标签化、多维数据的许多用例中，NumPy和pandas都显得不足。xarray库结合了其他两个工具的最佳特性，并提供了进一步优化的数据处理功能。我们将讨论这个工具的动机，并通过具体的例子研究它提供的性能改进。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Getting started with NumPy
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用NumPy
- en: Rewriting the particle simulator in NumPy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NumPy重写粒子模拟器
- en: Reaching optimal performance with numexpr
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用numexpr达到最佳性能
- en: Working with database-style data with pandas
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pandas处理数据库风格的数据
- en: High-performance labeled data with xarray
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用xarray进行高性能标签化数据
- en: Technical requirement
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be accessed by going to this book's GitHub
    repository at [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/Chapter03](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/Chapter03).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过访问本书的GitHub仓库[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/Chapter03](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/Chapter03)来获取本章的代码文件。
- en: Getting started with NumPy
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用NumPy
- en: The NumPy library revolves around its multidimensional array object, `numpy.ndarray`.
    NumPy arrays are collections of elements of the same data type; this fundamental
    restriction allows NumPy to pack the data in a way that allows for high-performance
    mathematical operations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy库围绕其多维数组对象`numpy.ndarray`展开。NumPy数组是相同数据类型元素的集合；这种基本限制使得NumPy能够以允许高性能数学运算的方式打包数据。
- en: Creating arrays
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建数组
- en: 'Let''s explore NumPy''s functionalities by following these steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤探索NumPy的功能：
- en: 'You can create NumPy arrays using the `numpy.array` function. It takes a list-like
    object (or another array) as input and, optionally, a string expressing its data
    type. You can interactively test array creation using an IPython shell, as follows:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用`numpy.array`函数创建NumPy数组。它接受一个类似列表的对象（或另一个数组）作为输入，并且可选地接受一个表示其数据类型的字符串。您可以使用IPython
    shell交互式测试数组创建，如下所示：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Every NumPy array has an associated data type that can be accessed using the
    `dtype` attribute. If we inspect the `a` array, we will find that its `dtype`
    is `int64`, which stands for 64-bit integer:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个NumPy数组都有一个关联的数据类型，可以使用`dtype`属性访问。如果我们检查`a`数组，我们会发现它的`dtype`是`int64`，代表64位整数：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We may decide to convert those integer numbers into the `float` type. To do
    this, we can either pass the `dtype` argument at array initialization or cast
    the array to another data type using the `astype` method. These two ways to select
    a data type are shown in the following code:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能决定将这些整数数字转换为`float`类型。为此，我们可以在数组初始化时传递`dtype`参数，或者使用`astype`方法将数组转换为另一种数据类型。以下代码展示了这两种选择数据类型的方法：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create an array with two dimensions (an array of arrays), we can perform
    the required initialization using a nested sequence, as follows:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个二维数组（一个数组数组），我们可以使用嵌套序列执行所需的初始化，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An array that''s created in this way has two dimensions, which are called `ndarray.shape`
    attribute:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以这种方式创建的数组有两个维度，称为`ndarray.shape`属性：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Arrays can also be reshaped, so long as the product of the shape dimensions
    is equal to the total number of elements in the array (that is, the total number
    of elements is conserved). For example, we can reshape an array containing 16
    elements in the following ways: `(2, 8)`, `(4, 4)`, or `(2, 2, 4)`. To reshape
    an array, we can either use the `ndarray.reshape` method or assign a new value
    to the `ndarray.shape` tuple. The following code illustrates the use of the `ndarray.reshape`
    method:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组也可以重塑，只要形状维度的乘积等于数组中的总元素数（即，总元素数保持不变）。例如，我们可以以下列方式重塑包含16个元素的数组：`(2, 8)`、`(4,
    4)`或`(2, 2, 4)`。要重塑数组，我们可以使用`ndarray.reshape`方法或将新值赋给`ndarray.shape`元组。以下代码说明了`ndarray.reshape`方法的使用：
- en: '[PRE5]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Thanks to this property, you can freely add dimensions of size `1`. You can
    reshape an array with 16 elements to `(16, 1)`, `(1, 16)`, `(16, 1, 1)`, and so
    on. In the next section, we will extensively use this feature to implement complex
    operations through *broadcasting*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个特性，您可以自由地添加大小为`1`的维度。您可以将包含16个元素的数组重塑为`(16, 1)`、`(1, 16)`、`(16, 1, 1)`等。在下一节中，我们将广泛使用这个特性通过*广播*来实现复杂操作。
- en: 'NumPy provides convenience functions, as shown in the following code, to create
    arrays filled with zeros, ones, or with no initial value (in this case, their
    actual value is meaningless and depends on the memory state). Those functions
    take the array shape as a tuple and, optionally, its `dtype`:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy提供了如以下代码所示的便利函数，用于创建填充零、一或无初始值（在这种情况下，它们的实际值没有意义，取决于内存状态）的数组。这些函数接受数组形状作为元组，并可选地接受其`dtype`：
- en: '[PRE6]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our examples, we will use the `numpy.random` module to generate random floating-point
    numbers in the `(0, 1)` interval. `numpy.random.rand` will take a shape and return
    an array of random numbers with that shape:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用`numpy.random`模块在`(0, 1)`区间内生成随机浮点数。`numpy.random.rand`将接受一个形状并返回具有该形状的随机数数组：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Sometimes, it is convenient to initialize arrays that have the same shape as
    that of some other array. For that purpose, NumPy provides some handy functions,
    such as `zeros_like`, `empty_like`, and `ones_like`. These functions can be used
    as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时，初始化与某个其他数组具有相同形状的数组是方便的。为此目的，NumPy提供了一些实用的函数，例如`zeros_like`、`empty_like`和`ones_like`。以下是如何使用这些函数的示例：
- en: '[PRE8]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These functions will return arrays with the specified values, whose shapes match
    exactly with that of array `a`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将返回具有指定值的数组，其形状与数组`a`的形状完全匹配。
- en: Accessing arrays
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问数组
- en: 'The NumPy array interface is, at a shallow level, similar to that of Python
    lists. NumPy arrays can be indexed using integers and iterated using a `for` loop:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组接口在浅层上与Python列表类似。NumPy数组可以使用整数索引，并使用`for`循环迭代：
- en: '[PRE9]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, explicitly looping over an array is, most of the time, not the most
    efficient way to access its elements. In this section, we will learn how to take
    advantage of NumPy's API to fully utilize its efficiency.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数情况下，显式地遍历数组并不是访问其元素最高效的方法。在本节中，我们将学习如何利用NumPy的API充分利用其效率。
- en: Indexing and slicing
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引和切片
- en: 'Indexing and slicing refer to the act of accessing elements within an array
    that are at certain locations or satisfy some condition that we are interested
    in. In NumPy, array elements and sub-arrays can be conveniently accessed by using
    multiple values separated by commas inside the subscript operator, `[]`. Let''s
    get started:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 索引和切片指的是访问数组中位于特定位置或满足某些我们感兴趣条件的元素的行为。在NumPy中，可以通过在索引运算符`[]`中使用逗号分隔的多个值方便地访问数组元素和子数组。让我们开始吧：
- en: 'If we take a `(3,3)` array (an array containing three triplets) and we access
    the element with an index of `0`, we can obtain the first row, as follows:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们取一个`(3,3)`的数组（包含三个三元组的数组）并使用索引`0`访问元素，我们可以获得第一行，如下所示：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can index the row again by adding another index separated by a comma. To
    get the second element of the first row, we can use the `(0, 1)` index. An important
    observation is that the `A[0, 1]` notation is shorthand for `A[(0, 1)]`; that
    is, we are indexing using a *tuple*! Both versions are shown in the following
    snippet:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过添加另一个以逗号分隔的索引来再次通过行索引。要获取第一行的第二个元素，我们可以使用`(0, 1)`索引。一个重要的观察是，`A[0, 1]`表示法是`A[(0,
    1)]`的简写；也就是说，我们正在使用*元组*进行索引！以下代码片段展示了这两种版本：
- en: '[PRE11]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'NumPy allows you to slice arrays into multiple dimensions. If we slice on the
    first dimension, we can obtain a collection of triplets, as follows:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy允许你将数组切片到多个维度。如果我们对第一个维度进行切片，我们可以获得一组三元组，如下所示：
- en: '[PRE12]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we slice the array again on the second dimension with `0:2`, we are extracting
    the first two elements from the collection of triplets shown earlier. This results
    in an array whose shape is `(2, 2)`, as shown in the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们再次对第二个维度使用`0:2`进行切片，我们正在从之前显示的三元组集合中提取前两个元素。这结果是一个形状为`(2, 2)`的数组，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Intuitively, you can update the values in the array using both *numerical indexes*
    and *slices*. An example of this is illustrated in the following code snippet:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直观地讲，你可以使用*数值索引*和*切片*来更新数组中的值。以下代码片段展示了这一点的示例：
- en: '[PRE14]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Indexing with the slicing syntax is very fast because, unlike lists, it doesn''t
    produce a copy of the array. In NumPy''s terminology, it returns a *view* of the
    same memory area. If we take a slice of the original array, and then we change
    one of its values, the original array will be updated as well. The following code
    illustrates an example of this feature:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用切片语法进行索引非常快，因为与列表不同，它不会生成数组的副本。在NumPy术语中，它返回相同内存区域的*视图*。如果我们从原始数组中取一个切片，然后改变其值之一，原始数组也会被更新。以下代码演示了这一功能的示例：
- en: '[PRE15]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is important to be extra careful when mutating NumPy arrays. Since views
    share data, changing the values of a view can result in hard-to-find bugs. To
    prevent side effects, you can set the `a.flags.writeable = False` flag, which
    will prevent the array or any of its views from being accidentally mutated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在修改NumPy数组时，需要格外小心。由于视图共享数据，改变视图的值可能会导致难以发现的错误。为了防止副作用，你可以设置`a.flags.writeable
    = False`标志，这将防止数组或其任何视图被意外修改。
- en: 'Let''s look at another example that shows how the slicing syntax can be used
    in a real-world setting. Let''s define an `r_i` array, as shown in the following
    line of code, which contains a set of 10 coordinates (*x*, *y*). Its shape will
    be `(10, 2)`:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看另一个示例，说明切片语法如何在现实世界的设置中使用。让我们定义一个`r_i`数组，如下面的代码行所示，它包含一组10个坐标（*x*，*y*）。它的形状将是`(10,
    2)`：
- en: '[PRE16]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you have a hard time distinguishing arrays that differ in the axes order,
    for example, between an array of shape `(10, 2)` and shape `(2, 10)`, it is useful
    to think that every time you say the word *of*, you should introduce a new dimension.
    An array with 10 elements *of* size two will be `(10, 2)`. Conversely, an array
    with two elements *of* size 10 will be `(2, 10)`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你难以区分轴顺序不同的数组，例如，形状为`(10, 2)`和形状为`(2, 10)`的数组，那么每次你说到“of”这个词时，应该引入一个新的维度。一个包含10个大小为2的元素的数组将是`(10,
    2)`。相反，一个包含2个大小为10的元素的数组将是`(2, 10)`。
- en: 'A typical operation we may be interested in is extracting the *x* component
    from each coordinate. In other words, you want to extract the `(0, 0)`, `(1, 0)`,
    and `(2, 0)`, items, resulting in an array with a shape of `(10,)`. It is helpful
    to think that the first index is *moving* while the second one is *fixed* (at
    `0`). With this in mind, we will slice every index on the first axis (the moving
    one) and take the first element (the fixed one) on the second axis, as shown in
    the following line of code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能感兴趣的一个典型操作是从每个坐标中提取*x*分量。换句话说，你想要提取`(0, 0)`、`(1, 0)`和`(2, 0)`项，结果是一个形状为`(10,)`的数组。有助于思考的是，第一个索引是*移动的*，而第二个索引是*固定的*（在`0`）。有了这个想法，我们将切片第一个轴（移动的轴）上的每个索引，并在第二个轴（固定的轴）上取第一个元素，如下面的代码行所示：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'On the other hand, the following expression will keep the first index fixed
    and the second index moving, returning the first (*x*, *y*) coordinate:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下表达式将保持第一个索引固定，第二个索引移动，返回第一个(*x*，*y*)坐标：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Slicing all the indexes over the last axis is optional; using `r_i[0]` has the
    same effect as using `r_i[0, :]`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个轴上对所有索引进行切片是可选的；使用`r_i[0]`与使用`r_i[0, :]`具有相同的效果。
- en: Fancy indexing
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 花式索引
- en: 'NumPy allows you to index an array using another NumPy array made up of either
    integer or Boolean values. This is a feature called **fancy indexing**:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy允许你使用由整数或布尔值组成的另一个NumPy数组来索引一个数组。这是一个称为**花式索引**的功能：
- en: 'If you index an array (say, `a`) with another array of integers (say, `idx`),
    NumPy will interpret the integers as indexes and will return an array containing
    their corresponding values. If we index an array containing 10 elements with `np.array([0,
    2, 3])`, we obtain an array of shape `(3,)` containing the elements at positions
    `0`, `2`, and `3`. The following code illustrates this concept:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你用一个整数数组（例如，`idx`）索引一个数组（例如，`a`），NumPy将解释这些整数为索引，并返回一个包含它们对应值的数组。如果我们用`np.array([0,
    2, 3])`索引包含10个元素的数组，我们得到一个形状为`(3,)`的数组，包含位置`0`、`2`和`3`的元素。以下代码说明了这个概念：
- en: '[PRE19]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use fancy indexing on multiple dimensions by passing an array for each
    dimension. If we want to extract the `(0, 2)` and `(1, 2)` elements, we have to
    pack all the indexes acting on the first axis in one array, and the ones acting
    on the second axis in another. This can be seen in the following code:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以通过为每个维度传递一个数组来在多个维度上使用花式索引。如果我们想提取`(0, 2)`和`(1, 2)`的元素，我们必须将作用于第一个轴的所有索引打包在一个数组中，将作用于第二个轴的索引打包在另一个数组中。这可以在以下代码中看到：
- en: '[PRE20]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can also use normal lists as index arrays, but not tuples. For example,
    the following two statements are equivalent:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以使用普通的列表作为索引数组，但不能使用元组。例如，以下两个语句是等价的：
- en: '[PRE21]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'However, if you use a tuple, NumPy will interpret the following statement as
    an index on multiple dimensions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你使用一个元组，NumPy将解释以下语句为对多个维度的索引：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The index arrays are not required to be one-dimensional; we can extract elements
    from the original array in any shape. For example, we can select elements from
    the original array to form a `(2,2)` array, as shown here:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 索引数组不一定要是一维的；我们可以以任何形状从原始数组中提取元素。例如，我们可以从原始数组中选择元素以形成一个`(2,2)`的数组，如下所示：
- en: '[PRE23]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The array slicing and fancy indexing features can be combined. This is useful,
    for instance, when we want to swap the *x* and *y* columns in a coordinate array.
    In the following code, the first index will be running over all the elements (a
    slice) and, for each of those, we extract the element in position `1` (the *y*)
    first and then the one in position `0` (the *x*):'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组的切片和花式索引功能可以结合使用。这在需要交换坐标数组中的*x*和*y*列时非常有用。在下面的代码中，第一个索引将遍历所有元素（一个切片），然后对于每一个元素，我们首先提取位置`1`（即*y*）的元素，然后是位置`0`（即*x*）的元素：
- en: '[PRE24]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the index array is of the `bool` type, the rules are slightly different.
    The `bool` array will act as a *mask*; every element corresponding to `True` will
    be extracted and put in the output array. This is shown in the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当索引数组是`bool`类型时，规则略有不同。`bool`数组将作为*掩码*；每个对应于`True`的元素将被提取并放入输出数组中。以下代码展示了这一点：
- en: '[PRE25]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The same rules apply when dealing with multiple dimensions. Furthermore, if
    the index array has the same shape as the original array, the elements corresponding
    to `True` will be selected and put in the resulting array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理多个维度时，同样适用这些规则。此外，如果索引数组与原始数组具有相同的形状，则对应于`True`的元素将被选中并放入结果数组中。
- en: 'Indexing in NumPy is a reasonably fast operation. When speed is critical, you
    can use the slightly faster `numpy.take` and `numpy.compress` functions to squeeze
    out a little more performance. The first argument of `numpy.take` is the array
    we want to operate on, while the second is the list of indexes we want to extract.
    The last argument is `axis`; if this is not provided, the indexes will act on
    the flattened array; otherwise, they will act along the specified axis:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: NumPy中的索引是一个相对快速的运算。当速度至关重要时，你可以使用稍微快一点的`numpy.take`和`numpy.compress`函数来挤出更多性能。`numpy.take`的第一个参数是我们想要操作的数组，第二个参数是我们想要提取的索引列表。最后一个参数是`axis`；如果没有提供，索引将作用于展平后的数组；否则，它们将沿着指定的轴操作：
- en: '[PRE26]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The similar but faster version for Boolean arrays is `numpy.compress`, which
    works in the same way. The use of `numpy.compress` is shown here:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于布尔数组，有一个类似但更快的版本是`numpy.compress`，它以相同的方式工作。`numpy.compress`的使用如下所示：
- en: '[PRE27]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As we can see, `compress` gives us a slight speed improvement, which will prove
    useful if you are dealing with large-sized arrays.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`compress` 给我们带来了一点点速度提升，这在处理大型数组时将非常有用。
- en: Broadcasting
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播
- en: The true power of NumPy lies in its fast mathematical operations. The approach
    that's used by NumPy is to avoid stepping into the Python interpreter by performing
    element-wise calculations using optimized C code. **Broadcasting** is a clever
    set of rules that enables fast array calculations for arrays of similar (but not
    equal!) shapes. Let's see how that goes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的真正力量在于其快速的数学运算。NumPy 使用的策略是通过使用优化的 C 代码进行逐元素计算来避免进入 Python 解释器。**广播**
    是一组巧妙的规则，它使得相似（但不完全相同！）形状的数组能够进行快速的数组计算。让我们看看这是如何实现的。
- en: 'Whenever you perform an arithmetic operation on two arrays (such as a product),
    if the two operands have the same shape, the operation will be applied in an element-wise
    fashion. For example, upon multiplying two `(2,2)` arrays, the operation will
    be done between pairs of corresponding elements, producing another `(2, 2)` array,
    as shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对两个数组（如乘法）执行算术运算时，如果两个操作数具有相同的形状，操作将以逐元素的方式进行。例如，在乘以两个 `(2, 2)` 的数组时，操作将在对应元素对之间进行，产生另一个
    `(2, 2)` 的数组，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the shapes of the operands don''t match, NumPy will attempt to match them
    using broadcasting rules. If one of the operands is a *scalar* (for example, a
    number), it will be applied to every element of the array, as shown in the following
    code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数的形状不匹配，NumPy 将尝试使用广播规则来匹配它们。如果一个操作数是 *标量*（例如，一个数字），它将被应用到数组的每一个元素上，如下面的代码所示：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the operand is another array, NumPy will try to match the shapes starting
    from the last axis. For example, if we want to combine an array of shape `(3,
    2)` with one of shape `(2,)`, the second array will be repeated three times to
    generate a `(3, 2)` array. In other words, the array is *broadcasted* along a
    dimension to match the shape of the other operand, as shown in the following diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果操作数是另一个数组，NumPy 将尝试从最后一个轴开始匹配形状。例如，如果我们想要将一个形状为 `(3, 2)` 的数组与一个形状为 `(2,)`
    的数组组合，第二个数组将被重复三次以生成一个 `(3, 2)` 的数组。换句话说，数组在某个维度上被 *广播* 以匹配另一个操作数的形状，如下面的图所示：
- en: '![Figure 3.1 – Illustration of array broadcasting ](img/Figure_3.1_B17499.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 数组广播的说明](img/Figure_3.1_B17499.jpg)'
- en: Figure 3.1 – Illustration of array broadcasting
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 数组广播的说明
- en: If the shapes don't match – for example, when combining a `(3, 2)` array with
    a `(2, 2)` array – NumPy will throw an exception.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果形状不匹配——例如，当将一个 `(3, 2)` 的数组与一个 `(2, 2)` 的数组组合时——NumPy 将会抛出一个异常。
- en: 'If one of the axis''s sizes is 1, the array will be repeated over this axis
    until the shapes match. To illustrate this point, let''s consider that we have
    an array of the following shape:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果轴的大小为1，数组将在这个轴上重复，直到形状匹配。为了说明这一点，让我们考虑我们有一个以下形状的数组：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let''s consider that we want to broadcast it with an array of shape `(5,
    1, 2)`; the array will be repeated on the second axis 10 times, as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考虑我们想要与形状为 `(5, 1, 2)` 的数组进行广播；数组将在第二个轴上重复10次，如下所示：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Earlier, we saw that it is possible to freely reshape arrays to add axes of
    size 1\. Using the `numpy.newaxis` constant while indexing will introduce an extra
    dimension. For instance, if we have a `(5, 2)` array and we want to combine it
    with one of shape `(5, 10, 2)`, we can add an extra axis in the middle, as shown
    in the following code, to obtain a compatible `(5, 1, 2)` array:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们看到了可以自由地重塑数组以添加大小为1的轴。在索引时使用 `numpy.newaxis` 常量将引入一个额外的维度。例如，如果我们有一个 `(5,
    2)` 的数组，并且我们想要与一个形状为 `(5, 10, 2)` 的数组组合，我们可以在中间添加一个额外的轴，如下面的代码所示，以获得兼容的 `(5, 1,
    2)` 数组：
- en: '[PRE32]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This feature can be used, for example, to operate on all possible combinations
    of the two arrays. One of these applications is the *outer product*. Let''s consider
    that we have the following two arrays:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性可以用来操作两个数组的所有可能的组合。其中一个应用就是外积。让我们考虑以下两个数组：
- en: '[PRE33]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The outer product is a matrix containing the product of all the possible combinations
    *(i, j)* of the two array elements, as shown in the following snippet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 外积是一个矩阵，包含两个数组元素所有可能的组合 *(i, j)* 的乘积，如下面的代码片段所示：
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To calculate this using NumPy, we will repeat the `[a1, a2, a3]` elements in
    one dimension, the `[b1, b2, b3]` elements in another dimension, and then take
    their element-wise product, as shown in the following diagram:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 NumPy 计算这个，我们将 `[a1, a2, a3]` 元素在一个维度上重复，将 `[b1, b2, b3]` 元素在另一个维度上重复，然后取它们的逐元素乘积，如下面的图所示：
- en: '![Figure 3.2 – Illustration of an outer product ](img/Figure_3.2_B17499.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.2 – 外积的示意图](img/Figure_3.2_B17499.jpg)'
- en: Figure 3.2 – Illustration of an outer product
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 – 外积的示意图
- en: 'Using code, our strategy will be to transform the `a` array from shape `(3,)`
    into shape `(3, 1)`, and the `b` array from shape `(3,)` into shape `(1, 3)`.
    These two arrays are broadcasted in the two dimensions and get multiplied together
    using the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用代码，我们的策略是将 `a` 数组从形状 `(3,)` 转换为形状 `(3, 1)`，将 `b` 数组从形状 `(3,)` 转换为形状 `(1, 3)`。这两个数组在两个维度上广播，并使用以下代码相乘：
- en: '[PRE35]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This operation is very fast and extremely effective as it avoids Python loops
    and can process a high number of elements at speeds comparable with pure C or
    FORTRAN code.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这种操作非常快且非常有效，因为它避免了 Python 循环，并且可以以与纯 C 或 FORTRAN 代码相当的速度处理大量元素。
- en: Mathematical operations
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数学运算
- en: NumPy includes the most common mathematical operations available for broadcasting
    by default, ranging from simple algebra to trigonometry, rounding, and logic.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 默认包含用于广播的最常见的数学运算，范围从简单的代数到三角学、舍入和逻辑。
- en: 'For instance, to take the square root of every element in the array, we can
    use `numpy.sqrt`, as shown in the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要计算数组中每个元素的平方根，我们可以使用 `numpy.sqrt`，如下面的代码所示：
- en: '[PRE36]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The comparison operators are useful when we''re trying to filter certain elements
    based on a condition. Imagine that we have an array of random numbers from `0`
    to `1`, and we want to extract all the numbers greater than `0.5`. We can use
    the `>` operator on the array to obtain a `bool` array, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符在尝试根据条件过滤某些元素时非常有用。想象一下，我们有一个从 `0` 到 `1` 的随机数字数组，我们想要提取所有大于 `0.5` 的数字。我们可以在数组上使用
    `>` 运算符来获得一个 `bool` 数组，如下所示：
- en: '[PRE37]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The resulting `bool` array can then be reused as an index to retrieve the elements
    that are greater than `0.5`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `bool` 数组然后可以被用作索引来检索大于 `0.5` 的元素：
- en: '[PRE38]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'NumPy also implements methods such as `ndarray.sum`, which takes the sum of
    all the elements on an axis. If we have an array of shape `(5, 3)`, we can use
    the `ndarray.sum` method to sum the elements on the first axis, the second axis,
    or over all the elements of the array, as illustrated in the following snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 还实现了 `ndarray.sum` 等方法，该方法对轴上的所有元素求和。如果我们有一个形状为 `(5, 3)` 的数组，我们可以使用 `ndarray.sum`
    方法对第一轴、第二轴或数组的所有元素求和，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note that by summing the elements over an axis, we eliminate that axis. From
    the preceding example, the sum on axis `0` produces an array of shape `(3,)`,
    while the sum on axis `1` produces an array of shape `(5,)`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通过在一个轴上求和元素，我们消除了该轴。从前面的例子中，轴 `0` 上的求和产生了一个形状为 `(3,)` 的数组，而轴 `1` 上的求和产生了一个形状为
    `(5,)` 的数组。
- en: Calculating the norm
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算范数
- en: 'We can review the basic concepts illustrated in this section by calculating
    the *norm* of a set of coordinates. The norm of a pair of coordinates is an important
    concept in linear algebra and is often interpreted as the magnitude of the corresponding
    line segment. For a two-dimensional vector, the norm is defined as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过计算一组坐标的 *范数* 来回顾本节中展示的基本概念。一对坐标的范数是线性代数中的一个重要概念，通常被解释为对应线段的长度。对于二维向量，范数定义为如下：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Given an array of 10 coordinates (*x*, *y*), we want to find the norm of each
    coordinate. We can calculate the norm by performing these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个包含 10 个坐标 (*x*, *y*) 的数组，我们想要找到每个坐标的范数。我们可以通过以下步骤来计算范数：
- en: Square the coordinates, obtaining an array that contains `(x**2, y**2)` elements.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对坐标进行平方，得到一个包含 `(x**2, y**2)` 元素的数组。
- en: Sum those with `numpy.sum` over the last axis.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `numpy.sum` 对最后一个轴上的元素求和。
- en: Take the square root, element-wise, with `numpy.sqrt`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `numpy.sqrt` 对元素逐个开平方。
- en: 'The final expression can be compressed into a single line:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的表达式可以压缩成一行：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can verify that this method of calculating `norm` gives us the correct answer
    while having compact code.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以验证这种方法计算 `范数` 给出了正确的答案，同时代码紧凑。
- en: Rewriting the particle simulator in NumPy
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 NumPy 重写粒子模拟器
- en: 'In this section, we will optimize our particle simulator by rewriting some
    parts of it in NumPy. From the profiling we did in [*Chapter 1*](B17499_01_Final_SS_ePub.xhtml#_idTextAnchor015),
    *Benchmarking and Profiling*, we found that the slowest part of our program is
    the following loop, which is contained in the `ParticleSimulator.evolve` method:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过用NumPy重写其部分来优化我们的粒子模拟器。从我们在[*第1章*](B17499_01_Final_SS_ePub.xhtml#_idTextAnchor015)中进行的配置文件分析，*基准测试和性能分析*，我们发现我们程序中最慢的部分是以下循环，它包含在`ParticleSimulator.evolve`方法中：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You may have noticed that the body of the loop acts solely on the current particle.
    If we had an array containing the particle positions and angular speed, we could
    rewrite the loop using a broadcasted operation. In contrast, the loop's steps
    depend on the previous step and cannot be parallelized in this way.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到循环的主体仅对当前粒子起作用。如果我们有一个包含粒子位置和角速度的数组，我们可以使用广播操作重写循环。相比之下，循环的步骤依赖于前一步，不能以这种方式并行化。
- en: 'So, it is natural to store all the array coordinates in an array of shape `(nparticles,
    2)` and the angular speed in an array of shape `(nparticles,)`, where `nparticles`
    is the number of particles. We''ll call those arrays `r_i` and `ang_vel_i`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将所有数组坐标存储在形状为`(nparticles, 2)`的数组中，并将角速度存储在形状为`(nparticles,)`的数组中是很自然的，其中`nparticles`是粒子数。我们将这些数组称为`r_i`和`ang_vel_i`：
- en: '[PRE43]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The velocity direction, which is perpendicular to the vector (*x*, *y*), was
    defined as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 速度方向，垂直于向量(*x*, *y*)，被定义为以下：
- en: '[PRE44]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The norm can be calculated using the strategy illustrated in the *Calculating
    the norm* section under the *Getting started with NumPy* heading:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用在“*NumPy入门*”标题下的“*计算范数*”部分中说明的策略来计算范数：
- en: '[PRE45]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the (*-y*, *x*) components, we need to swap the *x* and *y* columns in
    `r_i` and then multiply the first column by `-1`, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对于(*-y*, *x*)分量，我们需要在`r_i`中交换*x*和*y*列，然后将第一列乘以`-1`，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'To calculate the displacement, we need to compute the product of `v_i`, `ang_vel_i`,
    and `timestep`. Since `ang_vel_i` is of shape `(nparticles,)`, it needs a new
    axis to operate with `v_i` of shape `(nparticles, 2)`. We will do that using `numpy.newaxis`,
    as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算位移，我们需要计算`v_i`、`ang_vel_i`和`timestep`的乘积。由于`ang_vel_i`的形状为`(nparticles,)`，它需要一个新轴来与形状为`(nparticles,
    2)`的`v_i`操作。我们将使用`numpy.newaxis`来完成这项工作，如下所示：
- en: '[PRE47]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Outside the loop, we have to update the particle instances with the new coordinates,
    *x* and *y*, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环外部，我们必须按照以下方式更新粒子实例的新坐标，*x*和*y*：
- en: '[PRE48]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To summarize, we will implement a method called `ParticleSimulator.evolve_numpy`
    and benchmark it against the pure Python version, renamed as `ParticleSimulator.evolve_python`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们将实现一个名为`ParticleSimulator.evolve_numpy`的方法，并将其与重命名为`ParticleSimulator.evolve_python`的纯Python版本进行基准测试：
- en: '[PRE49]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We will also update the benchmark to conveniently change the number of particles
    and the simulation method, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将更新基准测试，以便方便地更改粒子数量和模拟方法，如下所示：
- en: '[PRE50]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Let''s run the benchmark in an IPython session:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在IPython会话中运行基准测试：
- en: '[PRE51]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have made some improvements, but it doesn''t look like a huge speed boost.
    The power of NumPy is revealed when handling big arrays. If we increase the number
    of particles, we will note a more significant performance boost:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一些改进，但看起来并没有大幅提升速度。NumPy的强大之处在于处理大型数组。如果我们增加粒子数量，我们将注意到更明显的性能提升：
- en: '[PRE52]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The plot in the following diagram was produced by running the benchmark with
    different particle numbers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下图中所示的曲线是通过运行不同粒子数的基准测试产生的：
- en: '![Figure 3.3 – The running time growth of pure Python versus NumPy ](img/Figure_3.3_B17499.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 纯Python与NumPy的运行时间增长](img/Figure_3.3_B17499.jpg)'
- en: Figure 3.3 – The running time growth of pure Python versus NumPy
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 纯Python与NumPy的运行时间增长
- en: The plot shows that both implementations scale linearly with particle size,
    but the runtime in the pure Python version grows much faster than the NumPy version;
    at greater sizes, we have a greater NumPy advantage. In general, when using NumPy,
    you should try to pack things into large arrays and group the calculations using
    the broadcasting feature.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 曲线显示，两种实现都与粒子大小成线性关系，但纯Python版本的运行时间增长速度远快于NumPy版本；在更大的尺寸上，我们有一个更大的NumPy优势。一般来说，当使用NumPy时，你应该尝试将事物打包到大型数组中，并使用广播功能分组计算。
- en: Reaching optimal performance with numexpr
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用numexpr达到最佳性能
- en: When handling complex expressions, NumPy stores intermediate results in memory.
    David M. Cooke wrote a package called `numexpr`, which optimizes and compiles
    array expressions on the fly. It works by optimizing the usage of the CPU cache
    and by taking advantage of multiple processors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理复杂表达式时，NumPy 会将中间结果存储在内存中。David M. Cooke 编写了一个名为 `numexpr` 的包，该包在运行时优化和编译数组表达式。它是通过优化
    CPU 缓存的使用并利用多个处理器来工作的。
- en: 'Its usage is generally straightforward and is based on a single function: `numexpr.evaluate`.
    The function takes a string containing an array expression as its first argument.
    The syntax is basically identical to that of NumPy. For example, we can calculate
    a simple `a + b * c` expression in the following way:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用通常很简单，基于一个单一的功能：`numexpr.evaluate`。该函数将包含数组表达式的字符串作为其第一个参数。语法基本上与 NumPy
    相同。例如，我们可以以下这种方式计算一个简单的 `a + b * c` 表达式：
- en: '[PRE53]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `numexpr` package increases performance in almost all cases, but to get
    a substantial advantage, you should use it with large arrays. An application that
    involves a large array is the calculation of a *distance matrix*. In a particle
    system, a distance matrix contains all the possible distances between the particles.
    To calculate it, we should calculate all the vectors connecting any two particles,
    `(i,j)`, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`numexpr` 包在几乎所有情况下都能提高性能，但要获得实质性的优势，你应该使用它来处理大型数组。一个涉及大型数组的应用是计算 *距离矩阵*。在一个粒子系统中，距离矩阵包含粒子之间所有可能距离。为了计算它，我们应该计算连接任何两个粒子
    `(i,j)` 的所有向量，如下所示：'
- en: '[PRE54]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then, we must calculate the length of this vector by taking its norm, as shown
    in the following code:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须通过取其范数来计算这个向量的长度，如下面的代码所示：
- en: '[PRE55]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We can write this in NumPy by employing the usual broadcasting rules (the operation
    is similar to the outer product):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用通常的广播规则（操作类似于外积）在 NumPy 中编写这个表达式：
- en: '[PRE56]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Finally, we must calculate the norm over the last axis using the following
    line of code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须使用以下代码行来计算最后一个轴上的范数：
- en: '[PRE57]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Rewriting the same expression using the `numexpr` syntax is extremely easy.
    The `numexpr` package (aliased `ne` in our following code) doesn''t support slicing
    in its array expression; therefore, we first need to prepare the operands for
    broadcasting by adding an extra dimension, as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `numexpr` 语法重写相同的表达式非常简单。`numexpr` 包（在我们的代码中别名为 `ne`）不支持在数组表达式中进行切片；因此，我们首先需要通过添加一个额外的维度来准备广播的操作数，如下所示：
- en: '[PRE58]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: At this point, we should try to pack as many operations as possible into a single
    expression to allow significant optimization.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该尝试将尽可能多的操作打包到一个表达式中，以允许进行显著的优化。
- en: 'Most of the NumPy mathematical functions are also available in `numexpr`. However,
    there is a limitation – the reduction operations (the ones that reduce an axis,
    such as `sum`) have to happen last. Therefore, we have to calculate the sum first,
    then step out of `numexpr`, and finally calculate the square root in another expression:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 NumPy 数学函数也都在 `numexpr` 中可用。然而，有一个限制——减少操作（比如 `sum`）必须在最后发生。因此，我们必须先计算总和，然后退出
    `numexpr`，最后在另一个表达式中计算平方根：
- en: '[PRE59]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `numexpr` compiler will avoid redundant memory allocation by not storing
    intermediate results. When possible, it will also distribute the operations over
    multiple processors. In the `distance_matrix.py` file, you will find two functions
    that implement the two versions – `distance_matrix_numpy` and `distance_matrix_numexpr`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`numexpr` 编译器将通过不存储中间结果来避免冗余内存分配。在可能的情况下，它还会将操作分布到多个处理器上。在 `distance_matrix.py`
    文件中，你会找到两个实现这两个版本——`distance_matrix_numpy` 和 `distance_matrix_numexpr`——的函数：'
- en: '[PRE60]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: By simply converting the expressions to use `numexpr`, we were able to obtain
    a 4.5x increase in performance over standard NumPy. The `numexpr` package can
    be used every time you need to optimize a NumPy expression that involves large
    arrays and complex operations, and you can do so while making minimal changes
    to the code.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地将表达式转换为使用 `numexpr`，我们能够获得比标准 NumPy 高出 4.5 倍的性能提升。`numexpr` 包可以在你需要优化涉及大型数组和复杂操作的
    NumPy 表达式时使用，并且你可以在对代码进行最小更改的情况下做到这一点。
- en: Overall, we have seen that NumPy, in combination with numexpr, offers powerful
    APIs when it comes to working with multidimensional data. However, in many use
    cases, data is only two-dimensional but is *labeled* in the sense that the data
    axes include explicit information about the type of data they contain. This is
    the case for data extracted from database tables. In such situations, pandas is
    the most popular and one of the best libraries in Python for this, as we will
    see next.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我们已经看到，NumPy与numexpr结合使用时，在处理多维数据时提供了强大的API。然而，在许多用例中，数据只有二维，但在某种意义上是*标记的*，即数据轴包含有关它们包含的数据类型的显式信息。这是从数据库表中提取的数据的情况。在这种情况下，pandas是Python中最受欢迎的，也是最好的库之一，我们将在下面看到。
- en: Working with database-style data with pandas
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用pandas处理数据库风格的数据
- en: pandas is a library that was originally developed by Wes McKinney. It was designed
    to analyze datasets in a seamless and performant way. In recent years, this powerful
    library has seen incredible growth and a huge adoption by the Python community.
    In this section, we will introduce the main concepts and tools provided in this
    library, and we will use them to increase the performance of various use cases
    that can't otherwise be addressed with NumPy's vectorized operations and broadcasting.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: pandas是一个由Wes McKinney最初开发的库。它被设计用来以无缝和高效的方式分析数据集。近年来，这个强大的库经历了令人难以置信的增长，并且被Python社区广泛采用。在本节中，我们将介绍这个库中提供的主要概念和工具，并将使用它们来提高无法使用NumPy的矢量化操作和广播解决的问题的性能。
- en: pandas fundamentals
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: pandas基础知识
- en: While NumPy deals mostly with arrays, pandas's main data structures are `pandas.Series`,
    `pandas.DataFrame`, and `pandas.Panel`. In the rest of this chapter, we will abbreviate
    `pandas` to `pd`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然NumPy主要处理数组，但pandas的主要数据结构是`pandas.Series`、`pandas.DataFrame`和`pandas.Panel`。在本章的其余部分，我们将把`pandas`简写为`pd`。
- en: The main difference between a `pd.Series` object and an `np.array` is that a
    `pd.Series` object associates a specific *key* with each element of an array.
    Let's see how this works in practice with an example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series`对象与`np.array`的主要区别在于，`pd.Series`对象将特定的`*key*`与数组中的每个元素关联起来。让我们通过一个例子来看看这在实践中是如何工作的。'
- en: 'Let''s assume that we are trying to test a new blood pressure drug and we want
    to store, for each patient, whether the patient''s blood pressure improved after
    administering the drug. We can encode this information by associating each subject
    ID (represented by an integer) with `True` if the drug was effective and `False`
    otherwise:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在尝试测试一种新的降压药物，并且我们希望为每位患者存储，在服用药物后患者的血压是否有所改善。我们可以通过将每个受试者ID（用一个整数表示）与`True`关联来表示药物有效，否则与`False`关联来编码此信息：
- en: 'We can create a `pd.Series` object by associating an array of keys – the patients
    – to the array of values that represent the drug''s effectiveness. This array
    of keys can be passed to the `Series` constructor using the `index` argument,
    as shown in the following snippet:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过将代表药物有效性的值数组和代表患者的键数组关联起来来创建一个`pd.Series`对象。这个键数组可以通过`index`参数传递给`Series`构造函数，如下面的代码片段所示：
- en: '[PRE61]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Associating a set of integers from *0* to *N* with a set of values can technically
    be implemented with `np.array` since, in this case, the key will simply be the
    position of the element in the array. In pandas, keys are not limited to integers;
    they can also be strings, floating-point numbers, and generic (hashable) Python
    objects. For example, we can easily turn our IDs into strings with little effort,
    as shown in the following code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一组从`0`到`N`的整数与一组值关联，在技术上可以使用`np.array`实现，因为在这种情况下，键将简单地是数组中元素的索引位置。在pandas中，键不仅限于整数；它们也可以是字符串、浮点数和通用的（可哈希的）Python对象。例如，我们可以轻松地将我们的ID转换为字符串，如下面的代码所示：
- en: '[PRE62]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: An interesting observation is that, while NumPy arrays can be thought of as
    a contiguous collection of values similar to Python lists, the pandas `pd.Series`
    object can be thought of as a structure that maps keys to values, similar to Python
    dictionaries.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的观察是，虽然NumPy数组可以被看作是类似于Python列表的连续值集合，但pandas的`pd.Series`对象可以被看作是一个将键映射到值的结构，类似于Python字典。
- en: What if you want to store the initial and final blood pressure for each patient?
    In pandas, you can use a `pd.DataFrame` object to associate multiple data with
    each key.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想存储每位患者的初始和最终血压呢？在pandas中，你可以使用一个`pd.DataFrame`对象来将多个数据与每个键关联。
- en: '`pd.DataFrame` can be initialized, similarly to a `pd.Series` object, by passing
    a dictionary of columns and an index. In the following example, we will see how
    to create `pd.DataFrame` containing four columns that represent the initial and
    final measurements of systolic and diastolic blood pressure for our patients:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame` 可以通过传递一个包含列和索引的字典来初始化，类似于 `pd.Series` 对象。在下面的示例中，我们将看到如何创建包含四个列的
    `pd.DataFrame`，这些列代表我们患者的收缩压和舒张压的初始和最终测量值：'
- en: '[PRE63]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Equivalently, you can think of `pd.DataFrame` as a collection of `pd.Series`.
    It is possible to directly initialize `pd.DataFrame` using a dictionary of `pd.Series`
    instances:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，你可以将 `pd.DataFrame` 视为一个 `pd.Series` 的集合。直接使用 `pd.Series` 实例的字典初始化 `pd.DataFrame`
    是可能的：
- en: '[PRE64]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To inspect the content of a `pd.DataFrame` or `pd.Series` object, you can use
    the `pd.Series.head` and `pd.DataFrame.head` methods, which print the first few
    rows of the dataset:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查 `pd.DataFrame` 或 `pd.Series` 对象的内容，你可以使用 `pd.Series.head` 和 `pd.DataFrame.head`
    方法，这些方法将打印数据集的前几行：
- en: '[PRE65]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Just like a `pd.DataFrame` can be used to store a collection of `pd.Series`,
    you can use a `pd.Panel` to store a collection of `pd.DataFrames`. We will not
    cover the usage of `pd.Panel` as it is not used as often as `pd.Series` and `pd.DataFrame`.
    To learn more about `pd.Panel`, make sure that you refer to the excellent documentation
    at [http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel](http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `pd.DataFrame` 可以用来存储 `pd.Series` 的集合一样，你可以使用 `pd.Panel` 来存储 `pd.DataFrame`
    的集合。我们不会介绍 `pd.Panel` 的用法，因为它不像 `pd.Series` 和 `pd.DataFrame` 那样常用。要了解更多关于 `pd.Panel`
    的信息，请确保参考优秀的文档[http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel](http://pandas.pydata.org/pandas-docs/stable/dsintro.html#panel)。
- en: Indexing Series and DataFrame objects
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 索引 Series 和 DataFrame 对象
- en: 'In many instances, we might want to access certain elements stored inside a
    `pd.Series` or a `pd.DataFrame` object. In the following steps, we will see how
    we can index these objects:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能想要访问存储在 `pd.Series` 或 `pd.DataFrame` 对象内部的一些元素。在以下步骤中，我们将看到我们如何索引这些对象：
- en: 'Retrieving data from a `pd.Series`, given its *key*, can be done intuitively
    by indexing the `pd.Series.loc` attribute:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据其 *键* 从 `pd.Series` 中检索数据可以通过索引 `pd.Series.loc` 属性直观地完成：
- en: '[PRE66]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is also possible to access the elements, given their *position* in the underlying
    array, using the `pd.Series.iloc` attribute:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以使用 `pd.Series.iloc` 属性，根据它们在底层数组中的 *位置* 访问元素：
- en: '[PRE67]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Indexing `pd.DataFrame` works similarly. For example, you can use `pd.DataFrame.loc`
    to extract a row by key, and you can use `pd.DataFrame.iloc` to extract a row
    by position:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pd.DataFrame` 的索引工作方式类似。例如，你可以使用 `pd.DataFrame.loc` 通过键提取一行，你也可以使用 `pd.DataFrame.iloc`
    通过位置提取一行：'
- en: '[PRE68]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'An important aspect is that the return type in this case is a `pd.Series`,
    where each column is a new key. To retrieve a specific row and column, you can
    use the following code. The `loc` attribute will index both the row and the column
    by key, while the `iloc` version will index the row and the column by an integer:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重要的一个方面是，在这种情况下返回的类型是 `pd.Series`，其中每一列都是一个新键。要检索特定的行和列，你可以使用以下代码。`loc` 属性将根据键索引行和列，而
    `iloc` 版本将根据整数索引行和列：
- en: '[PRE69]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Retrieving a column from a `pd.DataFrame` by name can be achieved by regular
    indexing or attribute access. To retrieve a column by position, you can either
    use `iloc` or use the `pd.DataFrame.column` attribute to retrieve the name of
    the column:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称从 `pd.DataFrame` 中检索列可以通过常规索引或属性访问来实现。要按位置检索列，你可以使用 `iloc` 或使用 `pd.DataFrame.column`
    属性来检索列名：
- en: '[PRE70]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: These methods also support more advanced indexing, similar to those of NumPy,
    such as `bool`, lists, and `int` arrays.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法还支持类似于 NumPy 的更高级的索引，例如 `bool`、列表和 `int` 数组。
- en: Now, it's time for some performance considerations. There are some differences
    between an index in pandas and a dictionary. For example, while the keys of a
    dictionary cannot contain duplicates, pandas indexes can contain repeated elements.
    This flexibility, however, comes at a cost – if we try to access an element in
    a non-unique index, we may incur substantial performance loss – the access will
    be *O*(*N*), like a linear search, rather than *O*(1), like a dictionary.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候考虑一些性能问题了。在 pandas 中，索引和字典之间有一些区别。例如，虽然字典的键不能包含重复项，但 pandas 的索引可以包含重复元素。然而，这种灵活性是有代价的——如果我们尝试访问非唯一索引中的元素，我们可能会遭受巨大的性能损失——访问将是
    *O*(*N*)，类似于线性搜索，而不是 *O*(1)，类似于字典。
- en: 'A way to mitigate this effect is to sort the index; this will allow pandas
    to use a binary search algorithm with a computational complexity of *O*(*log*(*N*)),
    which is much better. This can be accomplished using the `pd.Series.sort_index`
    function, as shown in the following code (the same applies for `pd.DataFrame`):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 减缓这种效果的一种方法是排序索引；这将允许 pandas 使用具有 *O*(*log*(*N*)) 计算复杂度的二分搜索算法，这要好得多。这可以通过使用
    `pd.Series.sort_index` 函数实现，如下面的代码所示（同样适用于 `pd.DataFrame`）：
- en: '[PRE71]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The timings for the different versions are summarized in the following table.
    If you''d like to rerun this benchmarking yourself, please refer to `Chapter03/Pandas.ipynb`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 不同版本的计时总结在以下表格中。如果您想自己重新运行此基准测试，请参阅 `Chapter03/Pandas.ipynb`：
- en: '![Table 3.1 – Performance analysis for pandas indexing ](img/Table__3.1_B17499.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![表 3.1 – pandas 索引性能分析](img/Table__3.1_B17499.jpg)'
- en: Table 3.1 – Performance analysis for pandas indexing
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 – pandas 索引性能分析
- en: Database-style operations with pandas
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 pandas 进行数据库式操作
- en: You may have noted that the *tabular* data is similar to what is usually stored
    in a database. A database is usually indexed using a primary key, and the various
    columns can have different data types, just like in a `pd.DataFrame`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，*表格*数据类似于通常存储在数据库中的数据。数据库通常使用主键进行索引，而不同的列可以有不同的数据类型，就像在 `pd.DataFrame`
    中一样。
- en: The efficiency of the index operations in pandas makes it suitable for database-style
    manipulations, such as counting, joining, grouping, and aggregations.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 的索引操作效率使其适合进行数据库式操作，如计数、连接、分组和聚合。
- en: Mapping
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射
- en: pandas supports element-wise operations, just like NumPy (after all, `pd.Series`
    stores their data using `np.array`).
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 支持元素级操作，就像 NumPy 一样（毕竟，`pd.Series` 使用 `np.array` 存储其数据）。
- en: 'For example, it is possible to apply transformation very easily to both `pd.Series`
    and `pd.DataFrame`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以非常容易地将转换应用于 `pd.Series` 和 `pd.DataFrame`：
- en: '[PRE72]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'You can also perform element-wise operations between two `pd.Series` objects
    in a way similar to NumPy. An important difference is that the operands will be
    matched by key, rather than by position; if there is a mismatch in the index,
    the resulting value will be set to `NaN`. Both scenarios are exemplified in the
    following example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以以类似于 NumPy 的方式在两个 `pd.Series` 对象之间执行元素级操作。一个重要的区别是操作数将通过键匹配，而不是通过位置；如果索引不匹配，则结果值将被设置为
    `NaN`。以下示例展示了这两种情况：
- en: '[PRE73]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: For added flexibility, pandas offers the `map`, `apply`, and `applymap` methods,
    which can be used to apply specific transformations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加灵活性，pandas 提供了 `map`、`apply` 和 `applymap` 方法，可用于应用特定的转换。
- en: 'The `pd.Series.map` method can be used to execute a function for each value
    and return a `pd.Series` containing each result. In the following example, we
    can see how to apply the `superstar` function to each element of a `pd.Series`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.Series.map` 方法可以用于对每个值执行函数，并返回包含每个结果的 `pd.Series`。在以下示例中，我们可以看到如何将 `superstar`
    函数应用于 `pd.Series` 的每个元素：'
- en: '[PRE74]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `pd.DataFrame.applymap` function is the equivalent of `pd.Series.map`,
    but for `DataFrames`:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`pd.DataFrame.applymap` 函数是 `pd.Series.map` 的等价函数，但用于 `DataFrames`：'
- en: '[PRE75]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Finally, the `pd.DataFrame.apply` function can apply the passed function to
    each column or each row, rather than element-wise. This selection can be performed
    with the argument axis, where a value of `0` (the default) corresponds to columns
    and `1` corresponds to rows. Also, note that the return value of `apply` is a
    `pd.Series`:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pd.DataFrame.apply` 函数可以将传递的函数应用于每一列或每一行，而不是逐元素。此选择可以通过 `axis` 参数执行，其中 `0`（默认值）对应于列，`1`
    对应于行。此外，请注意 `apply` 的返回值是一个 `pd.Series`：
- en: '[PRE76]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'pandas also supports efficient `numexpr`-style expressions with the convenient
    `eval` method. For example, if we want to calculate the difference between the
    final and initial blood pressure, we can write the expression as a string, as
    shown in the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 还支持使用方便的 `eval` 方法进行高效的 `numexpr`-style 表达式。例如，如果我们想计算最终和初始血压之间的差异，我们可以将表达式作为字符串编写，如下面的代码所示：
- en: '[PRE77]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'It is also possible to create new columns using the assignment operator in
    the `pd.DataFrame.eval` expression. Note that if the `inplace=True` argument is
    used, the operation will be applied directly to the original `pd.DataFrame`; otherwise,
    the function will return a new DataFrame. In the following example, we are computing
    the difference between `sys_final` and `sys_initial`, and we store it in the `sys_delta`
    column:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 `pd.DataFrame.eval` 表达式中的赋值运算符创建新列。请注意，如果使用 `inplace=True` 参数，操作将直接应用于原始的
    `pd.DataFrame`；否则，函数将返回一个新的 DataFrame。在下面的例子中，我们正在计算 `sys_final` 和 `sys_initial`
    之间的差异，并将其存储在 `sys_delta` 列中：
- en: '[PRE78]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Grouping, aggregations, and transforms
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组、聚合和转换
- en: 'One of the most appreciated features of pandas is its simple and concise method
    of grouping, transforming, and aggregating data. To demonstrate this concept,
    let''s extend our dataset by adding two new patients that we didn''t administer
    the treatment to (this is usually called a *control group*). We will also include
    a column, `drug_admst`, which records whether the patient was administered the
    treatment:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 最受赞赏的特性之一是其简单且简洁的分组、转换和聚合数据的方法。为了演示这个概念，让我们通过添加两个我们没有给予治疗的新的病人来扩展我们的数据集（这通常被称为
    *对照组*）。我们还将包括一个列，`drug_admst`，该列记录了病人是否接受了治疗：
- en: '[PRE79]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'At this point, we may be interested to know how the blood pressure changed
    between the two groups. You can group the patients according to `drug_amst` using
    the `pd.DataFrame.groupby` function. The return value will be the `DataFrameGroupBy`
    object, which can be iterated to obtain a new `pd.DataFrame` for each value of
    the `drug_admst` column:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可能对知道两组之间的血压变化感兴趣。你可以使用 `pd.DataFrame.groupby` 函数根据 `drug_amst` 对病人进行分组。返回值将是
    `DataFrameGroupBy` 对象，可以迭代以获得每个 `drug_admst` 列值的新的 `pd.DataFrame`：
- en: '[PRE80]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Iterating the `DataFrameGroupBy` object is rarely necessary because, thanks
    to method chaining, it is possible to calculate group-related properties directly.
    For example, we may want to calculate the mean, max, or standard deviation for
    each group. All those operations that summarize the data in some way are called
    aggregations and can be performed using the `agg` method. The result of `agg`
    is another `pd.DataFrame` that relates the grouping variables and the result of
    the aggregation, as illustrated in the following code:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代 `DataFrameGroupBy` 对象通常是不必要的，因为得益于方法链式调用，可以直接计算与分组相关的属性。例如，我们可能想要计算每个分组的平均值、最大值或标准差。所有以某种方式总结数据的操作都称为聚合，可以使用
    `agg` 方法执行。`agg` 的结果是一个新的 `pd.DataFrame`，它关联了分组变量和聚合结果，如下面的代码所示：
- en: '[PRE81]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is also possible to perform processing on the DataFrame groups that do not
    represent a summarization. One common example of such an operation is filling
    in missing values. Those intermediate steps are called **transforms**.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以对不表示汇总的 DataFrame 组进行处理。这类操作的一个常见例子是填充缺失值。这些中间步骤被称为 **转换**。
- en: 'We can illustrate this concept with an example. Let''s assume that we have
    a few missing values in our dataset, and we want to replace those values with
    the average of the other values in the same group. This can be accomplished using
    a transform, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个例子来说明这个概念。假设我们的数据集中有一些缺失值，我们想要用同一组中其他值的平均值来替换这些值。这可以通过以下方式使用转换来完成：
- en: '[PRE82]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Joining
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: '`H1`, `H2`, and `H3` labels, and we can store the address and identifier of
    the hospital in a `hospital` table:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`H1`、`H2` 和 `H3` 标签，并且我们可以将医院的地址和标识符存储在 `hospital` 表中：'
- en: '[PRE83]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Now, we want to find the city where the measure was taken for each patient.
    We need to *map* the keys from the `hospital_id` column to the city stored in
    the `hospitals` table.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要找到每个病人所采取的测量值的所在城市。我们需要将 `hospital_id` 列中的键映射到 `hospitals` 表中存储的城市。
- en: 'This can be implemented in Python using dictionaries:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用 Python 中的字典来实现：
- en: '[PRE84]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'This algorithm runs efficiently with an *O*(*N*) time complexity, where *N*
    is the size of `hospital_id`. pandas allows you to encode the same operation using
    simple indexing; the advantage is that the join will be performed in heavily optimized
    Cython and with efficient hashing algorithms. The preceding simple Python expression
    can easily be converted into pandas in this way:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法以 *O*(*N*) 的时间复杂度高效运行，其中 *N* 是 `hospital_id` 的大小。pandas 允许你使用简单的索引来编码相同的操作；优点是连接将在高度优化的
    Cython 和高效的哈希算法下执行。前面的简单 Python 表达式可以很容易地转换为 pandas 的这种方式：
- en: '[PRE85]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'More advanced joins can also be performed with the `pd.DataFrame.join` method,
    which will produce a new `pd.DataFrame` that will attach the hospital information
    for each patient:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的连接也可以使用`pd.DataFrame.join`方法执行，这将生成一个新的`pd.DataFrame`，为每个患者附加医院信息：
- en: '[PRE86]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: This concludes our discussion on pandas. In the next section, we will talk about
    xarray, the state-of-the-art tool for working with multidimensional labeled data
    in Python.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对pandas的讨论。在下一节中，我们将讨论xarray，这是在Python中处理多维标记数据的顶尖工具。
- en: High-performance labeled data with xarray
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用xarray进行高性能标记数据
- en: With NumPy, we can manipulate multidimensional numerical data and perform mathematical
    computations that are highly optimized by low-level C and FORTRAN code. On the
    other hand, we have seen that pandas allows us to work with labeled, categorical
    data that resembles data tables using database-like operations.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 使用NumPy，我们可以操作多维数值数据并执行由底层C和FORTRAN代码高度优化的数学计算。另一方面，我们看到了pandas允许我们使用类似数据库的操作处理标记的分类数据，这些数据类似于数据表。
- en: 'These two tools complement each other: NumPy does not allow categorical data
    to be mixed in with numerical values, while pandas is mostly limited to two-dimensional,
    database-like datasets. Combining these tools can help address many data processing
    needs, but when we are faced with big, multidimensional data that is also labeled,
    many performance-related problems arise.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个工具相互补充：NumPy不允许将分类数据与数值值混合，而pandas主要限于二维、类似数据库的数据集。结合这些工具可以帮助解决许多数据处理需求，但当我们面对大型的、多维的、标记的数据时，许多性能相关的问题就会出现。
- en: In the last section of this chapter, we will discuss xarray, a library that
    combines the best of both the NumPy and the pandas worlds and offers one of the
    best tools for working with labeled multidimensional data. We will explore some
    of its most prominent features while noting the improvements we achieve with xarray
    over other Python libraries.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将讨论xarray，这是一个结合了NumPy和pandas最佳特性的库，并为处理标记的多维数据提供了最佳工具之一。我们将探索其最突出的特性，同时注意我们在xarray与其他Python库相比所取得的改进。
- en: Analyzing ![](img/Formula_3_B17499.png) concentration
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析![](img/Formula_3_B17499.png)浓度
- en: To guide our discussion, we will be using the carbon dioxide concentration data,
    which was collected concerning the volcano Mauna Loa in Hawaii. The dataset is
    a time series of monthly measurements of the ![](img/Formula_3_B174991.png) level,
    starting from 1958 to this day. We have prepared a cleaned version of this dataset
    for you, which is included in the code repository for this book in the `monthly_co2.csv`
    file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引导我们的讨论，我们将使用收集有关夏威夷莫纳罗亚火山二氧化碳浓度数据，该数据集是从1958年开始的月度测量值的时间序列，一直持续到今天。我们为您准备了一个清洗后的数据集版本，它包含在这本书的代码库中的`monthly_co2.csv`文件中。
- en: 'The data has three simple columns:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 数据有三个简单的列：
- en: The year of measurement
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量年份
- en: The month of measurement
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量月份
- en: The measurement itself
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量本身
- en: 'Our goal is to analyze this dataset and visualize any time-related trends.
    Since we are already familiar with using pandas to work with a `.csv` file, let''s
    proceed with the library to start:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是分析这个数据集并可视化任何时间相关的趋势。由于我们已经熟悉使用pandas处理`.csv`文件，让我们继续使用这个库开始：
- en: '[PRE87]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Make sure that the data file is in the same directory as this code. You may
    remember that this will read in the file and store the data in a `DataFrame` object.
    Here, we are using the first two columns (by using the `index_col=[0, 1]` argument)
    as the index of this `DataFrame` object. Finally, we print out the first five
    rows of this dataset, which look as follows:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 确保数据文件与该代码在同一目录下。你可能记得这将读取文件并将数据存储在`DataFrame`对象中。在这里，我们使用前两列（通过使用`index_col=[0,
    1]`参数）作为这个`DataFrame`对象的索引。最后，我们打印出这个数据集的前五行，如下所示：
- en: '[PRE88]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here, we can see that in March `1958`, the ![](img/Formula_3_B174992.png) level
    was `315.70`, and that the following month's measurement was `317.45`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到在1958年3月，![](img/Formula_3_B174992.png)的浓度是`315.70`，而下一个月的测量值是`317.45`。
- en: 'The first thing we''d like to look at is a simple line graph corresponding
    to the `co2` column, which is simply the graph of the ![](img/Formula_3_B174992.png)
    level as a function of time (in `month`). With the help of Matplotlib, the go-to
    plotting tool in Python, we can do this very easily:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想看的是与`co2`列相对应的简单折线图，这个图简单地表示了![](img/Formula_3_B174992.png)水平随时间（按`月份`）的变化。借助Matplotlib，Python中常用的绘图工具，我们可以非常容易地做到这一点：
- en: '[PRE89]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The preceding code will produce the following output:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将产生以下输出：
- en: '![Figure 3.4 – Monthly co2 level ](img/Figure_3.4_B17499.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图3.4 – 每月co2水平](img/Figure_3.4_B17499.jpg)'
- en: Figure 3.4 – Monthly ![](img/Formula_3_B174993.png) level
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.4 – 每月![](img/Formula_3_B174993.png)水平
- en: 'We can notice two very distinct trends:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到两个非常明显的变化趋势：
- en: The first is the *global* increasing trend, which roughly goes from 320 to 420
    during our timeline.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一项是*全球*上升趋势，在大约320到420之间。
- en: The second looks like a *seasonal* zigzag trend, which is present locally and
    repeats itself every year.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个看起来像一种*季节性*的锯齿状趋势，它在局部存在，并且每年都会重复。
- en: 'To verify this intuition, we can inspect the average data across the years,
    which will tell us that the ![](img/Formula_3_B174993.png) level has been rising
    as a global trend. We can also compute the average measurement for each month
    and consider how the data changed from January to December. To accomplish this,
    we will utilize the `groupby` function by computing the yearly averages and plotting
    them:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证这种直觉，我们可以检查跨年度的平均数据，这将告诉我们![](img/Formula_3_B174993.png)水平作为一个全球趋势正在上升。我们还可以计算每个月的平均测量值，并考虑数据从一月到十二月的变动。为了完成这项任务，我们将利用`groupby`函数通过计算年度平均值并绘制它们：
- en: '[PRE90]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This gives us the following output:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们以下输出：
- en: '![Figure 3.5 – Yearly co2 level, averaged across months ](img/Figure_3.5_B17499.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图3.5 – 年度co2水平，按月平均](img/Figure_3.5_B17499.jpg)'
- en: Figure 3.5 – Yearly ![](img/Formula_3_B174992.png) level, averaged across months
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 – 按月平均的年度![](img/Formula_3_B174992.png)水平
- en: 'Just as we expected, we can see the global rising trend of the ![](img/Formula_3_B174992.png)
    level:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预期的，我们可以看到![](img/Formula_3_B174992.png)水平的全球上升趋势：
- en: '[PRE91]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Similarly, the preceding code generates the following average-by-month data:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，上述代码生成了以下按月平均数据：
- en: '![Figure 3.6 – Monthly co2 level, averaged across years ](img/Figure_3.6_B17499.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6 – 按年平均的每月co2水平](img/Figure_3.6_B17499.jpg)'
- en: Figure 3.6 – Monthly ![](img/Formula_3_B174992.png) level, averaged across years
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 – 每月![](img/Formula_3_B174992.png)水平，按年平均
- en: 'The seasonal trend we suspected now becomes clear: the ![](img/Formula_3_B174992.png)
    level tends to rise during the summer and fall between fall and winter.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们怀疑的季节性趋势现在变得清晰：![](img/Formula_3_B174992.png)水平倾向于在夏季上升，并在秋季和冬季之间下降。
- en: 'So far, we have been using pandas to manipulate our data. Even with this minimal
    example, we can notice a few things:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用pandas来处理我们的数据。即使在这个最小示例中，我们也能注意到一些事情：
- en: Loading the data, specifically the `co2` column, as a NumPy array would be inappropriate
    since we would lose information about the year and month each measurement was
    made. pandas is the better choice here.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据，特别是`co2`列，作为NumPy数组加载是不合适的，因为我们将会失去关于每年和每月测量信息。在这里，pandas是更好的选择。
- en: On the other hand, the `groupby` function can be unintuitive and costly to work
    with. Here, we simply want to compute the *average-by-month and average-by-year
    measurements*, but that requires us to group our data by the `month` column and
    then by `year`. Although pandas takes care of this grouping for us behind the
    scenes, it is an expensive operation, especially if we are working with a significantly
    large dataset.
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一方面，`groupby`函数可能不太直观，且成本较高。在这里，我们只想计算*按月和按年测量*的平均值，但这需要我们按`月份`列分组，然后按`年份`分组。尽管pandas在幕后为我们处理了这种分组，但这是一种昂贵的操作，尤其是如果我们处理的数据集非常大时。
- en: To bypass this inefficiency, we can think of representing the `co2` column as
    a two-dimensional NumPy array, where the rows represent years and the columns
    represent months, and each cell in the array holds the measurement. Now, to compute
    the averages we want, we could simply calculate the mean along each of the two
    axes, which we know NumPy can do efficiently. However, once again, we lose the
    expressiveness of the labeled `month` and `year` data we have under pandas.
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了绕过这种低效性，我们可以考虑将 `co2` 列表示为一个二维 NumPy 数组，其中行代表年份，列代表月份，数组中的每个单元格都包含一个测量值。现在，为了计算我们想要的平均值，我们可以简单地沿着两个轴中的每一个计算平均值，我们知道
    NumPy 可以高效地做到这一点。然而，我们又失去了在 pandas 中拥有的标记 `month` 和 `year` 数据的表达能力。
- en: This dilemma we are currently facing is similar to the one that motivated the
    development of xarray, the premiere tool in Python for working with labeled, multidimensional
    data. The idea is to extend NumPy's support for fast, multidimensional array computations
    and allow dimensions (or axes) to have labels, which is one of the main selling
    points of pandas.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前面临的这个困境与推动 xarray 发展的困境类似，xarray 是 Python 中处理标记多维数据的顶级工具。其想法是扩展 NumPy 对快速多维数组计算的支持，并允许维度（或轴）有标签，这是
    pandas 的主要卖点之一。
- en: The xarray library
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: xarray 库
- en: 'xarray is developed and actively maintained by PyData and a part of the NumFOCUS
    project. To use the library, you must head to [http://xarray.pydata.org/en/stable/installing.html](http://xarray.pydata.org/en/stable/installing.html)
    for more details on how to install it. To continue with our example of the ![](img/Formula_3_B174992.png)
    concentration level, we will feed the data we have into a `Dataset` object in
    xarray using the following code:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: xarray 是由 PyData 开发并积极维护的，它是 NumFOCUS 项目的一部分。要使用这个库，你必须前往 [http://xarray.pydata.org/en/stable/installing.html](http://xarray.pydata.org/en/stable/installing.html)
    获取更多关于如何安装的详细信息。为了继续我们关于 ![](img/Formula_3_B174992.png) 浓度级别的例子，我们将使用以下代码将我们拥有的数据输入到
    xarray 的 `Dataset` 对象中：
- en: '[PRE92]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'If we were to print this object out in a Jupyter notebook, the output would
    be formatted nicely:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 Jupyter 笔记本中打印出这个对象，输出将会格式化得很好：
- en: '![Figure 3.7 – A Dataset instance of xarray, printed in Jupyter ](img/Figure_3.7_B17499.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – xarray 的 Dataset 实例，在 Jupyter 中打印](img/Figure_3.7_B17499.jpg)'
- en: Figure 3.7 – A Dataset instance of xarray, printed in Jupyter
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – xarray 的 Dataset 实例，在 Jupyter 中打印
- en: xarray was able to infer that `month` and `year` (the index columns in `DataFrame`)
    should be the dimension, as indicated by the `co2` data we care about, which is
    now a two-dimensional array indexed by `year` and `month`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: xarray 能够推断出 `month` 和 `year`（`DataFrame` 中的索引列）应该是维度，正如我们关心的 `co2` 数据所指示的，它现在是一个由
    `year` 和 `month` 索引的两维数组。
- en: xarray makes interacting and inspecting its objects easy and interactive; you
    can inspect the values of the coordinates and data variables further by clicking
    on the icons highlighted in the preceding screenshot.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: xarray 使得与其对象交互和检查变得容易且交互式；你可以通过点击前一个截图中的突出显示的图标来进一步检查坐标和数据变量的值。
- en: 'We mentioned earlier that xarray combines the best features of NumPy and pandas;
    this is best illustrated via the slicing/indexing interface it provides. For example,
    let''s say that we''d like to extract the measurements within the first 10 years
    of the dataset. For the first 5 months, we could apply NumPy-style slicing to
    the `''co2''` variable of the `ds` object:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，xarray 结合了 NumPy 和 pandas 的最佳特性；这最好通过它提供的切片/索引接口来展示。例如，假设我们想提取数据集中前 10
    年的测量值。对于前 5 个月，我们可以对 `ds` 对象的 `'co2'` 变量应用 NumPy 风格的切片：
- en: '[PRE93]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'This gives us a `DataArray` object containing the requested values:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这给我们提供了一个包含所需值的 `DataArray` 对象：
- en: '![Figure 3.8 – A DataArray instance of xarray, printed in Jupyter ](img/Figure_3.8_B17499.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – xarray 的 DataArray 实例，在 Jupyter 中打印](img/Figure_3.8_B17499.jpg)'
- en: Figure 3.8 – A DataArray instance of xarray, printed in Jupyter
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – xarray 的 DataArray 实例，在 Jupyter 中打印
- en: 'While NumPy slicing can be flexible, it does not offer much expressiveness
    for labeled data: we would have to know that the first axis of the implied multidimensional
    array is `year`, that the second is `month`, and that `ds[''co2''][:10, :5]` doesn''t
    explicitly say which years we are selecting for.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 NumPy 切片可以很灵活，但它对标记数据的表达能力有限：我们必须知道隐含的多维数组的第一个轴是 `year`，第二个轴是 `month`，并且
    `ds['co2'][:10, :5]` 并没有明确说明我们选择了哪些年份。
- en: 'As such, we could use the `sel` function, which roughly offers the same functionality
    as pandas filtering. To select the values within the example year of `1960`, we
    can simply use the following code:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以使用`sel`函数，它大致提供了与pandas过滤相同的功能。为了选择`1960`示例年份内的值，我们可以简单地使用以下代码：
- en: '[PRE94]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: This explicitly tells us that we are selecting `1960` along the `year` axis.
    For more examples of the different APIs the library offers, you can check out
    the documentation at [http://xarray.pydata.org/en/stable/api.html](http://xarray.pydata.org/en/stable/api.html).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这明确地告诉我们，我们正在选择`1960`沿着`year`轴。要查看库提供的不同API的更多示例，您可以查看[http://xarray.pydata.org/en/stable/api.html](http://xarray.pydata.org/en/stable/api.html)上的文档。
- en: Improved performance
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进的性能
- en: Now, we will consider the performance improvements that xarray offers. Recall
    that our goal is to compute the average measurement, first for each year to visualize
    the global trend, and then for each month for the seasonal trend. To do this,
    we can simply call the `mean` function while specifying the appropriate (labeled!)
    dimension.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将考虑xarray提供的性能提升。回想一下，我们的目标是计算平均测量值，首先对每年进行计算以可视化全球趋势，然后对每月进行计算以观察季节性趋势。为此，我们只需调用`mean`函数并指定适当的（标记的！）维度。
- en: 'First, to obtain the average-by-year, we must compute the mean across the `month`
    dimension:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了获得按年的平均值，我们必须在`month`维度上计算均值：
- en: '[PRE95]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'This returns another `Dataset` object containing the computed values:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回另一个包含计算值的`Dataset`对象：
- en: '![Figure 3.9 – Taking the average across a dimension in xarray ](img/Figure_3.9_B17499.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图3.9 – 在xarray中跨维度取平均值](img/Figure_3.9_B17499.jpg)'
- en: Figure 3.9 – Taking the average across a dimension in xarray
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 – 在xarray中跨维度取平均值
- en: From here, we can simply access the `co2` variable and pass the array to the
    `plot` function of Matplotlib to replicate *Figure 3.5*. For *Figure 3.6*, we
    can follow the same procedure using `ds.mean(dim='year')`.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里，我们可以简单地访问`co2`变量并将数组传递给Matplotlib的`plot`函数来复制*图3.5*。对于*图3.6*，我们可以使用`ds.mean(dim='year')`遵循相同的程序。
- en: The advantage we are gaining here is the expressiveness in our code. If we were
    using NumPy, we would need to specify the `'month'`, `'year'`). This might lead
    to hard-to-find bugs if you confuse which axis is which type of data in NumPy.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里获得的优势是代码的表达性。如果我们使用NumPy，我们需要指定`'month'`和`'year'`。这可能会导致难以发现的错误，如果您在NumPy中混淆了哪个轴是哪种类型的数据。
- en: 'Furthermore, the code is simpler and can take advantage of the optimized mean
    operation, which is managed under the hood by xarray, compared to the expensive
    `groupby` function from pandas. To see this, we can benchmark the two ways of
    computing the average-by-year that we have. First, we have the pandas way:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，代码更简单，可以利用xarray底层管理的优化均值操作，与pandas中昂贵的`groupby`函数相比。为了看到这一点，我们可以对两种计算按年平均的方法进行基准测试。首先，我们有pandas的方式：
- en: '[PRE96]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Then, we have the xarray way:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有xarray的方式：
- en: '[PRE97]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Here, we can see a clear performance improvement, achieved almost for free by
    passing our data to xarray!
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到明显的性能提升，几乎不花任何代价就通过将我们的数据传递给xarray实现的！
- en: Plotting with xarray
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用xarray进行绘图
- en: Labeled multidimensional arrays are ubiquitous in time series (where one of
    the dimensions is time), geospatial data (where some dimensions represent the
    coordinates on a map), or data that is both geospatial and time-dependent. In
    these data analysis tasks, data visualization is crucial; as such, xarray makes
    it easy to implement and call complex plotting functions on its data.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 标记的多维数组在时间序列（其中一个维度是时间）、地理空间数据（其中一些维度表示地图上的坐标）或既是地理空间又是时间依赖的数据中普遍存在。在这些数据分析任务中，数据可视化至关重要；因此，xarray使得在其数据上实现和调用复杂的绘图函数变得容易。
- en: 'Let''s look at this through a quick example. First, we will read in an example
    dataset we have prepared for you, saved in a file named `2d_measurement.npy`,
    which can be read into a Python program using NumPy:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个快速示例来看看这一点。首先，我们将读取我们为您准备的一个示例数据集，该数据集以`2d_measurement.npy`文件名保存，可以使用NumPy将其读入Python程序：
- en: '[PRE98]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: As you can see, it is a 100x100x3 array. Let's say that this dataset contains
    a specific type of measurement, taken over a 100x100 grid of a two-dimensional
    space (corresponding to the first two axes) at three specific timestamps (corresponding
    to the third axis).
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它是一个100x100x3的数组。假设这个数据集包含一种特定的测量类型，在二维空间（对应于前两个轴）的100x100网格上（对应于第三个轴）的三个特定时间戳处进行测量。
- en: We would like to visualize these measurements as three squares, where each square
    represents a specific time stamp, and each pixel in each square represents the
    intensity of the corresponding measurement.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将这些测量值可视化成三个正方形，其中每个正方形代表一个特定的时间戳，每个正方形中的每个像素代表相应测量值的强度。
- en: 'To do this in Matplotlib, we could use the `imshow` function, which takes in
    a two-dimensional array and plots it as an image. So, we would iterate through
    the three timestamps that we have and plot the corresponding grids one by one,
    as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在Matplotlib中实现这一点，我们可以使用`imshow`函数，它接受一个二维数组并将其作为图像绘制。因此，我们会遍历三个时间戳，并逐个绘制相应的网格，如下所示：
- en: '[PRE99]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The index, `i`, iterates through the three indices of the third axis in the
    `measures` array. Again, we can see that this indexing scheme is not very expressive
    and readable. Here, we are also using the `colorbar` function to add a color bar
    to each of the plots.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 索引`i`遍历`measures`数组中第三轴的三个索引。再次，我们可以看到这种索引方案不太具有表达性和可读性。在这里，我们还在每个图表上使用`colorbar`函数添加颜色条。
- en: 'The preceding code produces the following output:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码生成了以下输出：
- en: '![Figure 3.10 – Regular imshow from Matplotlib ](img/Figure_3.10_B17499.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10 – Matplotlib的常规imshow](img/Figure_3.10_B17499.jpg)'
- en: Figure 3.10 – Regular imshow from Matplotlib
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 – Matplotlib的常规imshow
- en: Although there is noise in the measurements, we can observe some global trends;
    specifically, we seem to have low-intensity measurements in the lower-left corner
    in the first plot, in the center in the second, and in the top-right corner in
    the third. As the final note, something we might want to change about this plot
    is making the three color bars have the same range, which may be hard to do with
    Matplotlib.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测量值中存在噪声，但我们仍能观察到一些全局趋势；具体来说，在第一张图中，似乎在左下角有低强度的测量值，在第二张图中在中心，在第三张图中在右上角。作为最后的注意事项，我们可能想要改变的是使三个颜色条具有相同的范围，这可能使用Matplotlib很难实现。
- en: 'Now, let''s see how we can produce this plot using xarray. First, we must convert
    the NumPy array into a `DataArray` object:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用xarray生成此图表。首先，我们必须将NumPy数组转换为`DataArray`对象：
- en: '[PRE100]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Here, we are also specifying the names for the three dimensions: `''x''`, `''y''`,
    and `''time''`. This will allow us to manipulate the data more expressively, as
    we saw previously. To plot out the 2D grids, we can use the similarly named `imshow`
    method:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们还在指定三个维度的名称：`'x'`、`'y'`和`'time'`。这将允许我们以更具有表达性的方式操作数据，就像我们之前看到的那样。为了绘制二维网格，我们可以使用同名的`imshow`方法：
- en: '[PRE101]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This results in the following output:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下输出：
- en: '![Figure 3.11 – Specialized imshow from xarray ](img/Figure_3.11_B17499.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11 – xarray的专用imshow](img/Figure_3.11_B17499.jpg)'
- en: Figure 3.11 – Specialized imshow from xarray
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11 – xarray的专用imshow
- en: 'The plotting function is much simpler than the for loop we had earlier. Furthermore,
    with minimal code, xarray has taken care of many different aesthetics-related
    aspects of this plot:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 绘图函数比我们之前使用的for循环要简单得多。此外，xarray通过最少的代码处理了此图表的许多与美学相关的方面：
- en: First, the plots have their titles and x- and y-axis labels automatically created.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，图表会自动创建标题以及x轴和y轴的标签。
- en: Second, by using a common color range, the fact that the measurements at the
    second timestamp are lower than those in the other two is now more obvious. This
    demonstrates that functions and methods in xarray are optimized to make working
    with labeled multidimensional data more efficient.
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，通过使用共同的色彩范围，现在更明显地看出在第二个时间戳的测量值低于其他两个。这表明xarray中的函数和方法经过优化，以便更有效地处理带标签的多维数据。
- en: 'On the topic of plotting, many data scientists work with map data. xarray nicely
    integrates with the popular Cartopy library for geospatial data processing and
    offers many plotting functionalities that incorporate world and country maps.
    More details can be found in their documentation: [http://xarray.pydata.org/en/stable/plotting.html](http://xarray.pydata.org/en/stable/plotting.html).'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在绘图的话题上，许多数据科学家处理地图数据。xarray很好地与流行的Cartopy库集成，用于地理空间数据处理，并提供了许多包含世界和地图的绘图功能。更多详细信息可以在他们的文档中找到：[http://xarray.pydata.org/en/stable/plotting.html](http://xarray.pydata.org/en/stable/plotting.html)。
- en: Summary
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to manipulate NumPy arrays and how to write
    fast mathematical expressions using array broadcasting. This knowledge will help
    you write more concise, expressive code and, at the same time, obtain substantial
    performance gains. We also introduced the `numexpr` library to further speed up
    NumPy calculations with minimal effort.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何操作NumPy数组，以及如何使用数组广播编写快速数学表达式。这些知识将帮助您编写更简洁、更具表现力的代码，同时获得实质性的性能提升。我们还介绍了`numexpr`库，以最小的努力进一步加快NumPy的计算速度。
- en: pandas implements efficient data structures that are useful when analyzing large
    datasets. In particular, pandas shines when the data is indexed by non-integer
    keys and provides very fast hashing algorithms.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: pandas实现了高效的数据结构，这在分析大型数据集时非常有用。特别是，当数据以非整数键索引时，pandas表现得尤为出色，并提供了非常快速的哈希算法。
- en: NumPy and pandas work well when handling large, homogenous inputs, but they
    are not suitable when the expressions become complex and the operations cannot
    be expressed using the tools provided by these libraries. xarray comes in handy
    as an alternative option where we need to work with labeled, multidimensional
    data.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型、同质输入时，NumPy和pandas表现良好，但当表达式变得复杂且无法使用这些库提供的工具表达操作时，它们就不太适合了。xarray作为一个备选方案，在需要处理标记的多维数据时非常有用。
- en: In combination, the three libraries offer Python users powerful APIs and flexible
    functionalities to work with a wide range of data. By keeping them in your toolbox,
    you are well situated to tackle most data processing and engineering tasks using
    Python.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用这三个库，为Python用户提供强大的API和灵活的功能，以处理各种数据。将它们保留在您的工具箱中，您将能够使用Python处理大多数数据处理和工程任务。
- en: In other cases, we can also leverage Python capabilities as a glue language
    by interfacing it with C using the Cython package, as we will see in the next
    chapter.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们还可以通过使用Cython包与C接口，利用Python作为粘合语言的能力，正如我们将在下一章中看到的。
- en: Questions
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name the advantages NumPy has over Python-native lists when working with multidimensional
    data.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当处理多维数据时，NumPy与Python原生列表相比有哪些优势？
- en: What are some of the database-style operations that pandas offers in its API?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: pandas在其API中提供了哪些数据库式操作？
- en: What problems does xarray address and why can they not be addressed by NumPy
    or pandas?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: xarray解决了哪些问题，为什么这些问题不能由NumPy或pandas解决？
- en: Further reading
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'An overview tutorial on NumPy and pandas: [https://cloudxlab.com/blog/numpy-pandas-introduction/](https://cloudxlab.com/blog/numpy-pandas-introduction/)'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy和pandas概述教程：[https://cloudxlab.com/blog/numpy-pandas-introduction/](https://cloudxlab.com/blog/numpy-pandas-introduction/)
- en: 'Data structures in xarray: [https://towardsdatascience.com/basic-data-structures-of-xarray-80bab8094efa](https://towardsdatascience.com/basic-data-structures-of-xarray-80bab8094efa)'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: xarray中的数据结构：[https://towardsdatascience.com/basic-data-structures-of-xarray-80bab8094efa](https://towardsdatascience.com/basic-data-structures-of-xarray-80bab8094efa)
