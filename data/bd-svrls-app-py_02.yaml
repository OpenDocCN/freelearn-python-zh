- en: Building a Serverless Application in AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS中构建无服务器应用程序
- en: This chapter will introduce the concept of serverless applications using AWS
    Lambda as the tool of choice. This will help you understand the concept, intuition,
    and working components involved in a serverless tool. It will also explain the
    nuances involved in security, user-controls, and versioning code inside Lambda.
    You will be guided via hands-on tutorials and lessons for understanding and learning
    to use AWS Lambda. So, it is recommended that you follow along this chapter with
    a laptop and an AWS account setup to easily execute the given instructions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍使用AWS Lambda作为首选工具的无服务器应用程序的概念。这将帮助您了解无服务器工具中涉及的概念、直觉和工作组件。它还将解释Lambda内部涉及的安全、用户控制和代码版本控制的细微差别。您将通过动手教程和课程来指导理解和学习使用AWS
    Lambda。因此，建议您使用笔记本电脑和设置好的AWS账户跟随本章，以便轻松执行给定的指令。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Triggers in AWS Lambda
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS Lambda中的触发器
- en: Lambda functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数
- en: Functions as containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数作为容器
- en: Configuring functions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置函数
- en: Testing Lambda functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试Lambda函数
- en: Versioning Lambda functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda函数的版本控制
- en: Creating deployment packages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建部署包
- en: Triggers in AWS Lambda
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AWS Lambda中的触发器
- en: 'Serverless functions are on-demand computational concepts. So, there has to
    be an event that needs to trigger a Lambda function so that the entire computational
    process is started. AWS Lambda has several events which can act as a trigger.
    Almost all services of AWS can act as AWS Lambda''s triggers. Here is the list
    of services that you can use for generating events for Lambda to respond to:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数是按需计算概念。因此，必须有一个事件来触发Lambda函数，以便启动整个计算过程。AWS Lambda有几个事件可以作为触发器。几乎所有的AWS服务都可以作为AWS
    Lambda的触发器。以下是您可以为Lambda生成事件并使其响应的服务列表：
- en: API Gateway
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API Gateway
- en: AWS IoT
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS IoT
- en: CloudWatch Events
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudWatch Events
- en: CloudWatch Logs
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudWatch Logs
- en: CodeCommit
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeCommit
- en: Cognito Sync Trigger
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cognito Sync触发器
- en: DynamoDB
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DynamoDB
- en: Kinesis
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kinesis
- en: S3
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: S3
- en: SNS
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SNS
- en: 'The triggers page of AWS Lambda looks like this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Lambda的触发器页面看起来如下：
- en: '![](img/00007.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00007.jpeg)'
- en: 'Let''s take a look at some of the following important and widely-used triggers
    that are available, and understand how they can be leveraged as FaaS in the serverless
    paradigm. They are as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下一些重要且广泛使用的触发器，并了解它们如何在无服务器范式中被利用作为FaaS。它们如下：
- en: '**API Gateway**: This trigger can be used to create efficient, scalable, and
    serverless APIs. One scenario where a serverless API makes sense would be while
    building a querying interface for S3\. Let us assume that we have a bunch of text
    files in an S3 bucket. Whenever a user hits the API with a query parameter, which
    can be some word that we want to search in the text files in the bucket, the API
    Gateway''s trigger will launch a Lambda function that executes the computational
    logic and workload for executing the query. The Lambda function that we want our
    API to trigger can be specified at the API creation time. The trigger will be
    created accordingly in the corresponding Lambda function''s console. This is what
    it looks like:'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API Gateway**：此触发器可用于创建高效、可扩展和无服务器的API。一个无服务器API有意义的场景是在构建S3的查询界面时。假设我们在S3桶中有一堆文本文件。每当用户使用查询参数调用API时，该参数可以是我们在桶中的文本文件中想要搜索的某个词，API
    Gateway的触发器将启动一个Lambda函数，该函数执行查询的计算逻辑和工作负载。我们想要我们的API触发的Lambda函数可以在API创建时指定。触发器将在相应的Lambda函数控制台中相应地创建。这看起来是这样的：'
- en: '![](img/00008.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00008.jpeg)'
- en: '**CloudWatch**: It events mostly help the user in setting the cron scheduling
    for Lambda. The CloudWatch Logs trigger is useful whenever a user wants to execute
    a computational workload depending on some keyword in the Cloudwatch Logs. However,
    the CloudWatch Alarms cannot trigger Lambda directly via the CloudWatch trigger.
    They have to be sent via a notification system, such as the **AWS Simple Notification
    Service** (**AWS SNS**). This is how you can create a cron execution in AWS Lambda.
    In the following screenshot, the Lambda function is set to execute every minute:'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CloudWatch**：它的事件主要帮助用户为Lambda设置cron调度。CloudWatch Logs触发器在用户想要根据Cloudwatch
    Logs中的某些关键字执行计算工作负载时非常有用。然而，CloudWatch Alarms不能直接通过CloudWatch触发器触发Lambda。它们必须通过通知系统发送，例如**AWS简单通知服务**（**AWS
    SNS**）。这就是您如何在AWS Lambda中创建cron执行的方式。在下面的屏幕截图中，Lambda函数被设置为每分钟执行一次：'
- en: '![](img/00009.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00009.jpeg)'
- en: '**S3**: This is a document store of AWS. So, whenever a file is added, removed,
    or changed, an event will be sent to AWS Lambda when added as a trigger. So, if
    you want to do some computational workload on a file as soon as the file gets
    uploaded, then this trigger helps to do that. This is what an S3''s event structure
    looks like:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S3**：这是AWS的文档存储。因此，每当添加、删除或更改文件时，如果将其作为触发器添加，则会向AWS Lambda发送事件。所以，如果您想在文件上传后立即对文件进行一些计算工作负载，那么这个触发器可以帮助您实现。这是S3事件结构的示例：'
- en: '![](img/00010.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00010.jpeg)'
- en: '**AWS SNS**: The SNS service of AWS helps users to send notifications to other
    systems. This service can also be used for catching CloudWatch Alarms and sending
    the notifications to a Lambda function for computational execution. This is what
    a sample SNS event looks like:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS SNS**：AWS的SNS服务帮助用户向其他系统发送通知。此服务还可以用于捕获CloudWatch警报并将通知发送到Lambda函数以进行计算执行。这是一个示例SNS事件的示例：'
- en: '![](img/00011.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00011.jpeg)'
- en: Lambda functions
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda函数
- en: '**Lambda functions** are the core operating parts of a serverless architecture.
    They contain the code which is supposed to be executed. These functions are executed
    whenever the trigger attached to it has been set off. We have already learned
    about some of the most popular Lambda triggers in the previous section.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**Lambda函数**是无服务器架构的核心操作部分。它们包含要执行的代码。这些函数在触发器被触发时执行。我们已经在上一节中学习了关于一些最流行的Lambda触发器的知识。'
- en: Whenever a Lambda function is triggered, it creates a container with the respective
    settings set by the user. We'll learn more about the container in our next section.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每当Lambda函数被触发时，它会创建一个容器，并设置用户设置的相应设置。我们将在下一节中了解更多关于容器的内容。
- en: The spinning up of containers takes a bit of time, which may result in a latency
    whenever a fresh invocation of a Lambda function is done, as it takes time to
    set up the environment and bootstrap the settings mentioned by the user in the
    Advanced settings tab. So, to overcome this latency, AWS thaws a container for
    some time for reuse in case of another Lambda invocation within the thawing time.
    So, using a thawed or a ready-made Lambda function helps in overcoming the latency
    problem. However, the same global namespace of the thawed container would be reused
    for the new invocation too.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '容器的启动需要一些时间，这可能导致在Lambda函数的新调用时出现延迟，因为它需要设置环境和启动高级设置选项卡中提到的用户设置。因此，为了克服这种延迟，AWS在解冻时间内解冻容器一段时间，以便在解冻时间内再次调用Lambda时重用。因此，使用解冻或现成的Lambda函数有助于克服延迟问题。然而，解冻容器的相同全局命名空间也将被用于新的调用。 '
- en: So, if the Lambda function has any global variables that get manipulated inside
    the function, it is a good idea to convert them into local namespaces, as the
    manipulated global namespace variables will be reused, leading to faulty execution
    results of the Lambda function.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果Lambda函数中存在任何在函数内部被操作的全球变量，将它们转换为局部命名空间是一个好主意，因为被操作的全球命名空间变量将被重用，从而导致Lambda函数的执行结果出现故障。
- en: 'The user needs to specify the technical details for the Lambda function in
    the Advanced Settings tab, which include the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 用户需要在高级设置选项卡中指定Lambda函数的技术细节，包括以下内容：
- en: 'Memory (MB): This is the maximum memory that the Lambda function needs to be
    allocated for the purpose of your function. The CPU of the container would be
    assigned accordingly.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存（MB）：这是Lambda函数为您的函数分配的最大内存。容器会相应地分配CPU。
- en: 'Timeout: The maximum amount of time the function needs to execute before the
    container gets automatically stopped.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超时：函数在容器自动停止之前需要执行的最大时间。
- en: 'DLQ Resource: This is a dead-letter setting to AWS Lambda. The user can add
    either an SQS queue or an SNS topic for configuring this. Lambda functions get
    asynchronously retried for at least five times on failure.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DLQ资源：这是AWS Lambda的死亡信使设置。用户可以添加一个SQS队列或一个SNS主题来配置此设置。Lambda函数在失败时至少会异步重试五次。
- en: 'VPC: This enables the Lambda function to access components or services in some
    particular VPCs. The Lambda function executes in a default VPC of its own.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VPC：这使Lambda函数能够访问某些特定VPC中的组件或服务。Lambda函数在其默认VPC中执行。
- en: 'KMS key: If there are any environment variables entered along with the Lambda
    function, this helps us encrypt them using an **AWS Key Management Service** (**KMS**)
    by default.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: KMS密钥：如果有任何环境变量与Lambda函数一起输入，则默认情况下，这有助于我们使用**AWS密钥管理服务**（**KMS**）来加密它们。
- en: 'The Lambda function''s Advanced settings page looks like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda函数的高级设置页面看起来是这样的：
- en: '![](img/00012.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00012.jpeg)'
- en: Functions as containers
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为容器
- en: For understanding the concept of functions being executed as/inside containers,
    we need to properly understand the concept of containers. To cite the definition
    of a container from the Docker documentation ([https://www.docker.com/what-docker](https://www.docker.com/what-docker))[:](https://www.docker.com/what-docker)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解函数作为/在容器中执行的概念，我们需要正确理解容器的概念。以下是从Docker文档中引用的容器定义（[https://www.docker.com/what-docker](https://www.docker.com/what-docker)）[:](https://www.docker.com/what-docker)
- en: 'A container image is a lightweight, stand-alone, executable package of a piece
    of software that includes everything needed to run it: code, runtime, system tools,
    system libraries, settings.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像是一个轻量级、独立、可执行的软件包，包括运行它所需的一切：代码、运行时、系统工具、系统库、设置。
- en: What is available for both Linux and Windows based applications; containerized
    software will always run the same, regardless of the environment.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 适用于基于Linux和Windows的应用程序；容器化软件将始终在相同的环境中运行。
- en: Containers isolate software from its surroundings (for example, differences
    between development and staging environments) and help reduce conflicts between
    teams running different software on the same infrastructure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 容器将软件与其周围环境隔离开来（例如，开发和预发布环境之间的差异），并有助于减少在相同基础设施上运行不同软件的团队之间的冲突。
- en: 'So, the concept of containers is that they are self-sustainable isolated environments
    just like the containers in a container ship that can be hosted and be worked
    upon any host OS, the host OS being the host ship in our analogy. The figurative
    depiction of the analogy would look something like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，容器的概念是它们是自给自足的隔离环境，就像集装箱船中的集装箱一样，可以在任何主机操作系统上托管并工作，在这个类比中，主机操作系统就是主机船。这个类比的形象描述可能看起来像这样：
- en: '![](img/00013.jpeg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00013.jpeg)'
- en: 'Similar to the aforementioned analogy, AWS Lambda''s functions are also launched
    inside a unique container for each function. So, let us understand this topic
    in more detail, point by point:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述类比类似，AWS Lambda的函数也是在每个函数中启动的独立容器。因此，让我们更详细地了解这个主题，一点一点地：
- en: The Lambda function can be in the form of a single code file or in the form
    of a **deployment package**. The deployment package is a zipped file that includes
    the core function file along with the libraries which would be used by the function.
    We shall be learning in detail about how to create the deployment package in the
    *Creating deployment packages* section of this chapter.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda函数可以是单个代码文件的形式，也可以是**部署包**的形式。部署包是一个包含核心函数文件以及函数将使用的库的压缩文件。我们将在本章的“创建部署包”部分详细学习如何创建部署包。
- en: Whenever a function is triggered or started, AWS spins up an EC2 instance with
    the AWS Linux operating system for running the function. The configuration of
    the instance would be dependent on the ones provided by the user in the Advanced
    settings tab of the Lambda function.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当函数被触发或启动时，AWS都会启动一个带有AWS Linux操作系统的EC2实例来运行函数。实例的配置将取决于用户在Lambda函数的高级设置选项卡中提供的配置。
- en: There is a maximum time limit of 300 seconds, or 5 minutes, for a function to
    execute successfully, after which the container would be destroyed. So, this needs
    to be kept in mind while designing the Lambda functions and/or the deployment
    packages.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数成功执行的最大时间限制为300秒，或5分钟，之后容器将被销毁。因此，在设计Lambda函数和/或部署包时需要记住这一点。
- en: Configuring functions
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置函数
- en: 'In this section, we will go through the ways of configuring Lambda functions
    and understand all the settings in great detail. Like in the previous section,
    we will learn about each configuration and its settings, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍配置Lambda函数的方法，并详细了解所有设置。就像在上一节中一样，我们将学习每个配置及其设置，如下所示：
- en: 'You can go to the page of AWS Lambda by selecting it from the drop-down menu
    that is present in the top-left corner of the AWS console. This can be done as
    follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过选择位于AWS控制台右上角的下拉菜单中的AWS Lambda来进入AWS Lambda页面。操作方法如下：
- en: '![](img/00014.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00014.jpeg)'
- en: 'Once the Lambda option is selected, it redirects the user to the AWS Lambda
    console, which looks something like this:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择Lambda选项后，它将用户重定向到AWS Lambda控制台，其外观如下：
- en: '![](img/00015.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00015.jpeg)'
- en: 'For creating a function, you need to click on the orange Create a function
    button on the right. This will open a console for the function creation. This
    looks something like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了创建一个函数，您需要在右侧点击橙色“创建一个函数”按钮。这将打开一个用于创建函数的控制台。它看起来大致如下：
- en: '![](img/00016.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00016.jpeg)'
- en: 'Let''s create a function from scratch in order to understand the configurations
    better. So, for doing that, click on the Author from scratch button on the top-right
    corner. After clicking it, the user will be directed to Lambda''s first-run console,
    which looks something like this:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从零开始创建一个函数，以便更好地理解配置。因此，为了做到这一点，请点击右上角的“从零开始创建”按钮。点击后，用户将被引导到Lambda的第一个运行控制台，其外观类似于以下：
- en: '![](img/00017.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00017.jpeg)'
- en: 'This page has three configurations which the user can select, which are Name,
    Role, and Existing role. The Name value is where the user can enter the name of
    the Lambda function. The Role value is how you can define permissions in the AWS
    environment. The Role value''s drop-down list would contain the following options:
    Choose an existing role, Create new role from template(s), and Create a custom
    role. They can be seen as follows:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此页面有三个用户可以选择的配置，它们是名称、角色和现有角色。名称值是用户可以输入Lambda函数名称的地方。角色值是您如何在AWS环境中定义权限的方式。角色值的下拉列表将包含以下选项：选择一个现有角色、从模板创建新角色和创建自定义角色。它们如下所示：
- en: '![](img/00018.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00018.jpeg)'
- en: 'The Choose an existing role option will enable us to select an already existing
    role with pre-configured permissions. The second option helps the user with creating
    a role from pre-baked templates. The Create a custom role option allows the user
    to create a role with permissions from scratch. The list of pre-baked roles looks
    like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个现有角色选项将使我们能够选择一个已经存在的、具有预配置权限的角色。第二个选项帮助用户从预定义模板中创建角色。创建自定义角色选项允许用户从头开始创建具有权限的角色。预定义角色的列表看起来如下：
- en: '![](img/00019.jpeg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00019.jpeg)'
- en: 'Select one from the pre-baked templates for the sake of this tutorial. By pressing Create
    function in the lower-right part of the screen, we will land on the Lambda function''s
    creation page, which looks similar to this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了本教程的目的，请从预定义模板中选择一个。通过在屏幕的右下角按下“创建函数”，我们将进入Lambda函数的创建页面，其外观类似于以下：
- en: '![](img/00020.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00020.jpeg)'
- en: 'The preceding page indicates that we have successfully created an AWS Lambda
    function. We shall now explore the advanced settings of this function. They are
    present in the lower part of the same console. They will look something like this:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前一个页面表明我们已经成功创建了一个AWS Lambda函数。现在我们将探索这个函数的高级设置。它们位于同一控制台的下半部分。它们看起来大致如下：
- en: '![](img/00021.jpeg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00021.jpeg)'
- en: We shall now try to understand each of those parts in detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将尝试详细理解这些部分的每一个。
- en: 'The unfurled Environment variables section contains text boxes to enter the
    key-value pair of environment variables that will be used by our function. One
    can also optionally mention details on the encryption setting that we want to
    have for the environment variables. The encryption needs to be done via **AWS
    KMS** (**Key Management Service**). The unfurled settings box of the environment
    variables looks something like this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开的环境变量部分包含用于输入将要由我们的函数使用的键值对环境变量的文本框。还可以选择性地提及我们希望对环境变量采用的加密设置详情。加密需要通过**AWS
    KMS**（**密钥管理服务**）来完成。环境变量的展开设置框看起来大致如下：
- en: '![](img/00022.jpeg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00022.jpeg)'
- en: 'The next settings section is Tags. This is similar to the tagging feature of
    all the available AWS services for easy service discovery purposes. So, similar
    to all AWS services''s tags, this also needs just a key and a value. The unfurled
    Tags section looks something like this:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个设置部分是标签。这与所有可用AWS服务的标签功能类似，用于便于服务发现。因此，类似于所有AWS服务的标签，这也只需要一个键和一个值。展开的标签部分看起来大致如下：
- en: '![](img/00023.jpeg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00023.jpeg)'
- en: 'The next section that will be visible after the Tags section is the Execution
    role section, in which the user can set the **Identity Access Management (IAM)**
    role for the execution of the Lambda function. As we have already discussed what
    IAM roles are previously in the book, we will not be covering that again here.
    If the user has not set the role when creating the function itself, they can always
    set that here. The section will be visible in the Lambda console as follows:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签部分之后可见的下一个部分是执行角色部分，用户可以在此为 Lambda 函数的执行设置 **身份访问管理（IAM**）角色。由于我们已经在书中讨论过
    IAM 角色是什么，因此我们在此不再重复。如果用户在创建函数时没有设置角色，他们始终可以在此设置。在 Lambda 控制台中，该部分将如下所示：
- en: '![](img/00024.jpeg)'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/00024.jpeg)'
- en: The next section is the Basic settings section, which includes settings such
    as the memory of the Lambda container, time-out for the container, and the description
    for the Lambda function. The memory of the container can range from 128 MB to
    1,536 MB. The user can choose any value within that range and will be billed accordingly.
    The time-out can be set from 1 second to 300 seconds, which is 5 minutes. The
    time-out is the time which the Lambda function and its container would run before
    being stopped or terminated. The next setting is the Description value of the
    Lambda function, which acts as the metadata of a Lambda function. The section
    looks like this in the console:![](img/00025.jpeg)
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分是基本设置部分，包括 Lambda 容器的内存、容器的超时时间和 Lambda 函数的描述等设置。容器的内存可以从 128 MB 到 1,536
    MB 不等。用户可以选择该范围内的任何值，并据此计费。超时时间可以从 1 秒到 300 秒，即 5 分钟。超时时间是 Lambda 函数及其容器在停止或终止之前运行的时间。下一个设置是
    Lambda 函数的描述值，它充当 Lambda 函数的元数据。在控制台中，本部分看起来如下所示：![](img/00025.jpeg)
- en: The next section is the Network section, which is also about the network settings
    of the Lambda function related to **AWS's Virtual Private Cloud** (**VPC**) and
    related subnets. Even if No VPC is selected as an option, AWS Lambda runs in its
    own secure VPC. However, if your Lambda function accesses or deals with any other
    service which is in a particular VPC or in a subnet, the corresponding information
    needs to be added in this section so that the network allows traffic from the
    Lambda function's container. This section looks like this in the console:![](img/00026.jpeg)The
    sensitive information in the preceding screenshot, such as the IP address and
    the ID of the VPC, are masked for security purposes.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分是网络部分，它也是关于 Lambda 函数与 **AWS 的虚拟私有云**（**VPC**）及其相关子网的网络设置。即使选择“无 VPC”作为选项，AWS
    Lambda 也会在其自己的安全 VPC 中运行。然而，如果您的 Lambda 函数访问或处理任何位于特定 VPC 或子网中的其他服务，则需要在本部分添加相应的信息，以便网络允许
    Lambda 函数容器进行流量传输。在控制台中，本部分看起来如下所示：![](img/00026.jpeg)出于安全考虑，前一个截图中的敏感信息，如 IP
    地址和 VPC ID，已被屏蔽。
- en: The next section is the Debugging and error handling section. This section enables
    the user to set up measures for ensuring fault tolerance and exception handling
    of the Lambda function. This includes the **Dead Letter Queue** (**DLQ**) settings.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分是调试和错误处理部分。本部分允许用户为 Lambda 函数设置确保容错性和异常处理的措施。这包括 **死信队列**（**DLQ**）设置。
- en: 'Lambda automatically retries failed executions for asynchronous invocations.
    So, the payloads that were not processed would be automatically forwarded to the
    DLQ resource. The DLQ settings look like this in the Lambda console:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 会自动重试异步调用中失败的执行。因此，未处理的数据包将自动转发到 DLQ 资源。在 Lambda 控制台中，DLQ 设置如下：
- en: '![](img/00027.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00027.jpeg)'
- en: 'The user can also enable active tracing for the Lambda functions, which would
    help in detailed monitoring of the Lambda container. This setting in the Debugging
    and error handling section of the Lambda console looks like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 用户还可以为 Lambda 函数启用活动跟踪，这将有助于详细监控 Lambda 容器。在 Lambda 控制台的调试和错误处理部分中，此设置如下所示：
- en: '![](img/00028.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00028.jpeg)'
- en: Testing Lambda functions
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试 Lambda 函数
- en: 'Just like every other software system and programming paradigm, proper testing
    of Lambda functions and serverless architectures is very important before deploying
    into production. We will try to understand the testing of Lambda functions in
    the following points:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如每个其他软件系统和编程范式一样，在部署到生产之前对 Lambda 函数和无服务器架构进行适当的测试非常重要。以下我们将尝试理解 Lambda 函数的测试：
- en: 'In the top-most bar of the Lambda console, one can observe the Save and test
    option, which is represented by an orange button. This button saves the Lambda
    function and then runs the configured tests on that function. This looks something
    like this in the console:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Lambda 控制台的顶部栏中，可以观察到“保存并测试”选项，该选项由一个橙色按钮表示。此按钮保存 Lambda 函数，然后在该函数上运行配置的测试。在控制台中的外观如下：
- en: '![](img/00029.jpeg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00029.jpeg)'
- en: 'Also, in the same bar, there exists a drop-down menu that reads Select a test
    event…. This contains a list of testing events available for testing Lambda functions.
    The drop-down looks like this:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在同一栏中，还存在一个下拉菜单，显示为“选择测试事件……”。这包含可用于测试 Lambda 函数的测试事件列表。下拉菜单的外观如下：
- en: '![](img/00030.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00030.jpeg)'
- en: 'Now, for further configuration of test events for the Lambda function, the
    user needs to select the Configure test events option in the drop-down. This will
    open a popup with the test events menu, which looks like this:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了进一步配置 Lambda 函数的测试事件，用户需要在下拉菜单中选择“配置测试事件”选项。这将打开一个包含测试事件菜单的弹出窗口，其外观如下：
- en: '![](img/00031.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00031.jpeg)'
- en: 'That would open the basic Hello World template, which has three pre-configured
    JSON format test events, or edge cases. However, depending on what the Lambda
    function does, one can select some other test event. The available list of testing
    templates can be seen in the Event template drop-down menu. The list in the drop-down
    looks something like this:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开基本的 Hello World 模板，该模板预配置了三个 JSON 格式的测试事件或边缘情况。然而，根据 Lambda 函数的功能，可以选择其他测试事件。可用的测试模板列表可在事件模板下拉菜单中查看。下拉菜单中的列表如下：
- en: '![](img/00032.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00032.jpeg)'
- en: 'For example, let''s imagine we are building a pipeline that involves the Lambda
    function getting started whenever an image file is added to an S3 bucket, and
    the function does some image processing tasks and puts it back to some data store.
    The test event of the S3 Put notification looks something like this:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，让我们想象我们正在构建一个管道，该管道涉及 Lambda 函数在图像文件添加到 S3 存储桶时启动，该函数执行一些图像处理任务并将其放回某些数据存储中。S3
    Put 通知的测试事件看起来大致如下：
- en: '![](img/00033.jpeg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00033.jpeg)'
- en: 'After selecting or creating a test event, the user can select the Create option
    in the bottom-right corner of the event creation console, wherein you shall be
    asked to enter a name for the event. After entering the necessary details, the
    user will be re-directed back to the Lambda console. Now, when you check the TestEvent drop-down
    in the Lambda console, you can see the saved test event in the list. This can
    be verified as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择或创建测试事件后，用户可以在事件创建控制台的右下角选择“创建”选项，此时您将被要求输入事件的名称。在输入必要的详细信息后，用户将返回 Lambda
    控制台。现在，当您检查 Lambda 控制台中的 TestEvent 下拉菜单时，您可以在列表中看到已保存的测试事件。这可以通过以下方式验证：
- en: '![](img/00034.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00034.jpeg)'
- en: As I have named the event as **TestEvent**, the test is visible by the same
    name in the events drop-down menu.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我将事件命名为**TestEvent**，因此在事件下拉菜单中，测试可通过相同名称可见。
- en: 'Additionally, when we take a closer look at the event structure of S3 in the
    test event, we can observe the meta-details that are being made available to the
    Lambda function. The event structure looks like this:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当我们更仔细地查看测试事件中的 S3 事件结构时，我们可以观察到提供给 Lambda 函数的元详细信息。事件结构如下：
- en: '![](img/00035.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00035.jpeg)'
- en: Versioning Lambda functions
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 函数版本控制
- en: 'The concept of the **Version Control System** (**VCS**) is for controlling
    and managing versions of code. This functionality is available directly from the
    main Lambda console. Let''s try and learn how to version our Lambda functions:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**版本控制系统**（**VCS**）的概念是用于控制和管理工作代码的版本。此功能可直接从主 Lambda 控制台使用。让我们尝试学习如何对 Lambda
    函数进行版本控制：'
- en: 'The first option in the Actions drop-down in the Lambda console is the Publish
    new version option. This option can be seen here:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda 控制台操作下拉菜单中的第一个选项是“发布新版本”选项。此选项在此处可见：
- en: '![](img/00036.jpeg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00036.jpeg)'
- en: 'When the Publish new version option is selected, the versioning popup of the
    Lambda console would be seen on the console. This would ask about the name for
    the new version of your Lambda function. The popup looks something like this:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择“发布新版本”选项时，Lambda 控制台的版本控制弹出窗口将在控制台中显示。这将询问您 Lambda 函数新版本的名称。弹出窗口的外观如下：
- en: '![](img/00037.jpeg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00037.jpeg)'
- en: 'After clicking the Publish button, you will be re-directed to the main Lambda
    console. The successfully created Lambda version in the console looks something
    like this:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击发布按钮后，您将被重定向到主Lambda控制台。控制台中成功创建的Lambda版本看起来如下：
- en: '![](img/00038.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00038.jpeg)'
- en: 'In the bottom half of the page, the following message can be noticed: Code
    and handler editing is only available for the $LATEST version. This means that
    one can only edit the code in the version named $LATEST.  The versioned version
    of Lambda functions are read-only and cannot be edited and manipulated. When something
    goes wrong or when the user wants to revert back or refer to a previous version,
    that version will overlay the $LATEST version to make edits possible. The message
    looks like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面下半部分，可以注意到以下信息：代码和处理器编辑仅适用于$LATEST版本。这意味着只能编辑命名为$LATEST的版本的代码。Lambda函数的版本化版本是只读的，不能编辑和操作。当出现错误或用户想要回滚或参考以前的版本时，该版本将覆盖$LATEST版本以进行编辑。信息看起来如下：
- en: '![](img/00039.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00039.jpeg)'
- en: 'When the Click here to go to $LATEST link is clicked, the user will be re-directed
    to the $LATEST version of the function, which can be edited and manipulated by
    the user. The console of the $LATEST version of the Lambda function looks like
    this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当点击“点击此处转到$LATEST”链接时，用户将被重定向到函数的$LATEST版本，用户可以对其进行编辑和操作。Lambda函数的$LATEST版本的控制台看起来如下：
- en: '![](img/00040.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00040.jpeg)'
- en: Creating deployment packages
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建部署包
- en: 'Lambda functions that have external libraries as dependencies can be packaged
    as deployment packages and be uploaded into the AWS Lambda console. This is very
    similar to creating a virtual environment in Python. So in this section, we shall
    learn and understand the process of creating Python deployment for using in the
    Lambda functions. We shall try and understand the process of creating deployment
    packages in detail, as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于外部库的Lambda函数可以作为部署包打包并上传到AWS Lambda控制台。这与在Python中创建虚拟环境非常相似。因此，在本节中，我们将学习和理解创建用于Lambda函数的Python部署的过程。我们将详细尝试理解创建部署包的过程，如下所示：
- en: Deployment packages are generally in the format of ZIP packages. The contents
    of the ZIP package is exactly the same as a normal library of any programming
    language.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署包通常以ZIP包的格式存在。ZIP包的内容与任何编程语言的正常库完全相同。
- en: 'The package structure should be such that the library folders and the function
    file are in the same destination or in the same hierarchy inside the folder structure
    of the deployment package. The layout looks something like this:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包的结构应该是这样的，即库文件夹和函数文件位于同一个目标位置或部署包文件夹结构中的同一层次。布局看起来如下：
- en: '![](img/00041.jpeg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00041.jpeg)'
- en: 'The Python libraries can be installed by using the `pip install <library_name>
    -t <path_of_the_target_folder>` command. This will install the package inside
    the target folder. This can be done as in the following screenshot:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用`pip install <library_name> -t <path_of_the_target_folder>`命令安装Python库。这将把包安装到目标文件夹中。这可以通过以下截图中的方式完成：
- en: '![](img/00042.jpeg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00042.jpeg)'
- en: 'Now, when we have the entire deployment package''s folder along with the library
    folders ready, we need to zip all of the folders including the Lambda function
    file before uploading it into the console. The following screenshot shows how
    the zipping needs to be done as per the folder hierarchy:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当我们有了整个部署包文件夹以及库文件夹准备就绪后，我们需要在将其上传到控制台之前，将所有文件夹包括Lambda函数文件进行压缩。以下截图显示了按照文件夹层次结构进行压缩的方式：
- en: '![](img/00043.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00043.jpeg)'
- en: 'Now, as the zipped package is ready, we shall be trying to upload the package
    to the Lambda console for processing. For uploading a Lambda package, we need
    to select the drop-down list of the Code entry type option in the console. The
    selection looks like this in the Lambda console:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当压缩包准备就绪后，我们将尝试将包上传到Lambda控制台进行处理。对于上传Lambda包，我们需要在控制台中选择代码输入类型选项的下拉列表。在Lambda控制台中，选择看起来如下：
- en: '![](img/00044.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00044.jpeg)'
- en: 'Once the Upload a .ZIP file option is selected, the uploader will become visible,
    where the user can directly upload the deployment package or even upload it via
    an S3 bucket. The wizard would look like this in the Lambda console:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦选择了“上传ZIP文件”选项，上传器将变得可见，用户可以直接上传部署包，甚至可以通过S3存储桶上传。在Lambda控制台中，向导看起来如下：
- en: '![](img/00045.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00045.jpeg)'
- en: 'As mentioned previously, the user can choose to upload the deployment package
    via an S3 file location too. This wizard looks like this in the Lambda console:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，用户可以选择通过S3文件位置上传部署包。在Lambda控制台中，此向导看起来是这样的：
- en: '![](img/00046.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00046.jpeg)'
- en: 'The deployment package''s naming should be aligned with the values entered
    in the handler part of the settings. The deployment package''s name and the Lambda
    function file''s name are separated by a dot (`.`) and arranged in that order.
    This can be explicitly seen in the following screenshot:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署包的命名应与设置中处理器部分输入的值保持一致。部署包的名称与Lambda函数文件的名称之间用点（`.`）分隔，并按此顺序排列。这可以在以下屏幕截图中明确看到：
- en: '![](img/00047.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/00047.jpeg)'
- en: '`index` should be the name of the Lambda function''s file name deployment package.
    The `handler` function file is the name of the core function handler inside, which
    is the Lambda function. As AWS''s documentation states:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`index` 应该是Lambda函数文件名部署包的名称。`handler` 函数文件是内部核心功能处理器的名称，即Lambda函数。如AWS文档所述：'
- en: The module-name export value in your function". For example, index.handler would
    call exports.handler in index.py.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 您函数中的模块名称导出值"。例如，index.handler将调用index.py中的exports.handler。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the concepts of how triggers work for AWS Lambda
    and how to select triggers depending on the problem statement and time intervals,
    in case of cron job triggers. We understood what Lambda functions are, along with
    understanding their functionalities and settings related to memory, VPCs, security,
    and fault tolerance. We also learned about the way container reuse is done under
    the hood specifically for AWS Lambda. Then, we covered event-driven functions
    and how they are implemented under the hood, the concept of containers, and their
    uses and applications in the domain of software engineering in general. Most importantly,
    from the concepts we learned regarding containers, we can now appreciate the options
    for choosing containers for running the Lambda functions.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了AWS Lambda触发器的工作原理以及如何根据问题陈述和时间间隔选择触发器，特别是在cron作业触发器的情况下。我们了解了Lambda函数是什么，以及它们的功能和与内存、VPC、安全性和容错性相关的设置。我们还了解了AWS
    Lambda内部容器重用的方式。然后，我们介绍了事件驱动函数及其在底层是如何实现的，容器概念及其在软件工程领域的应用和用途。最重要的是，从我们学到的容器概念中，我们现在可以欣赏到为运行Lambda函数选择容器的选项。
- en: After that, we talked about all the configuration settings available in the
    AWS Lambda dashboard, which are necessary to build and run a Lambda function from
    start to finish without any settings-related problems. We also learned about and
    understood the security settings inside Lambda so that the necessary VPC details
    and security keys settings are taken care of when configuring our Lambda functions.
    This was followed by testing Lambda functions depending on the choice of trigger
    selected. We learned what the responses of various AWS services look like, as
    they are the inputs for the Lambda functions. We then learned how to write custom
    hand-made tests for custom testing purposes.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '之后，我们讨论了AWS Lambda仪表板中所有可用的配置设置，这些设置对于从头到尾构建和运行Lambda函数而没有任何设置相关问题是必要的。我们还了解并理解了Lambda内部的安全设置，以便在配置我们的Lambda函数时考虑到必要的VPC细节和安全密钥设置。这之后是对根据所选触发器选择的Lambda函数进行测试。我们了解了各种AWS服务的响应看起来像什么，因为它们是Lambda函数的输入。然后我们学习了如何编写用于自定义测试目的的自定义测试。 '
- en: Following that, we saw how versioning happens for the AWS Lambda functions.
    We learned the differences between past and present versions. We also learned
    that the present version is immutable, unlike the past versions, and also how
    to revert to past versions without much effort. We also learned how to create
    deployment packages for functions that have dependencies on external packages,
    which are not included in Python's standard library. We came across the function
    code naming nuances, including the filename and the method handler names, followed
    by the two ways deployment packages can be uploaded to the Lambda console; one
    being a manual upload and the other being from an S3 file location.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们了解了 AWS Lambda 函数的版本控制过程。我们学习了过去版本和当前版本之间的区别。我们还了解到，当前版本是不可变的，与过去的版本不同，并且我们也学会了如何不费太多力气地回滚到过去的版本。我们还学习了如何为依赖于外部包（这些包不包括在
    Python 的标准库中）的函数创建部署包。我们还遇到了函数代码命名的细微差别，包括文件名和方法处理程序名称，随后是两种将部署包上传到 Lambda 控制台的方式；一种是通过手动上传，另一种是从
    S3 文件位置上传。
- en: In the next chapter, we will be gaining a detailed understanding of the different
    triggers available in the Lambda console and how to use them. We will also learn
    about implementing them in Python code. We will understand the event structures
    and the responses from different AWS services and use that to build our Lambda
    functions. We will understand how to integrate each trigger into a Lambda function
    and do a specific task in Python. Finally, we will also be learning about ideas
    and best practices on how to move your existing infrastructures to serverless
    using the serverless paradigm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解 Lambda 控制台中可用的不同触发器以及如何使用它们。我们还将学习如何在 Python 代码中实现它们。我们将理解事件结构和来自不同
    AWS 服务的响应，并利用这些信息来构建我们的 Lambda 函数。我们将了解如何将每个触发器集成到 Lambda 函数中，并在 Python 中执行特定任务。最后，我们还将学习关于如何使用无服务器范式将现有基础设施迁移到无服务器的想法和最佳实践。
