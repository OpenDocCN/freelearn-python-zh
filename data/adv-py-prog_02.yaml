- en: '*Chapter 1*: Benchmarking and Profiling'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：基准测试和性能分析'
- en: Recognizing the slow parts of your program is the single most important task
    when it comes to speeding up your code. In most cases, the code that causes the
    application to slow down is a very small fraction of the program. By identifying
    these critical sections, you can focus on the parts that need the most improvement
    without wasting time in micro-optimization.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到加速代码时，识别程序中的慢速部分是最重要的任务。在大多数情况下，导致应用程序变慢的代码只是程序的一小部分。通过识别这些关键部分，你可以专注于需要最多改进的部分，而无需在微优化上浪费时间。
- en: '**Profiling** is a technique that allows us to pinpoint the most resource-intensive
    parts of an application. A **profiler** is a program that runs an application
    and monitors how long each function takes to execute, thus detecting the functions
    on which your application spends most of its time.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能分析**是一种技术，它允许我们定位应用程序中最资源密集的部分。**分析器**是一个程序，它运行应用程序并监控每个函数的执行时间，从而检测到应用程序花费最多时间的函数。'
- en: Python provides several tools to help us find these bottlenecks and measure
    important performance metrics. In this chapter, we will learn how to use the standard
    `cProfile` module and the `line_profiler` third-party package. We will also learn
    how to profile the memory consumption of an application through the `memory_profiler`
    tool. Another useful tool that we will cover is **KCachegrind**, which can be
    used to graphically display the data produced by various profilers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Python 提供了多个工具来帮助我们找到这些瓶颈并测量重要的性能指标。在本章中，我们将学习如何使用标准的 `cProfile` 模块和 `line_profiler`
    第三方包。我们还将学习如何通过 `memory_profiler` 工具来分析应用程序的内存消耗。我们还将介绍另一个有用的工具 **KCachegrind**，它可以用来图形化显示各种分析器产生的数据。
- en: Finally, **benchmarks** are small scripts used to assess the total execution
    time of your application. We will learn how to write benchmarks and use them to
    accurately time your programs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，**基准测试**是用于评估应用程序总执行时间的小脚本。我们将学习如何编写基准测试并使用它们来准确计时程序。
- en: 'The topics we will cover in this chapter are listed here:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涉及的主题如下：
- en: Designing your application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计你的应用程序
- en: Writing tests and benchmarks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写测试和基准测试
- en: Writing better tests and benchmarks with `pytest-benchmark`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `pytest-benchmark` 编写更好的测试和基准测试
- en: Finding bottlenecks with `cProfile`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `cProfile` 寻找瓶颈
- en: Optimizing our code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化我们的代码
- en: Using the `dis` module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `dis` 模块
- en: Profiling memory usage with `memory_profiler`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `memory_profiler` 分析内存使用情况
- en: By the end of the chapter, you will have gained a solid understanding of how
    to optimize a Python program and will be armed with practical tools that facilitate
    the optimization process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将获得如何优化 Python 程序的坚实基础，并将拥有便于优化过程的实用工具。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow the content of this chapter, you should have a basic understanding
    of Python programming and be familiar with core concepts such as variables, classes,
    and functions. You should also be comfortable with working with the command line
    to run Python programs. Finally, the code for this chapter can be found in the
    following GitHub repository: [https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter01).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章的内容，你应该对 Python 编程有基本的了解，并熟悉诸如变量、类和函数等核心概念。你应该也熟悉使用命令行来运行 Python 程序。最后，本章的代码可以在以下
    GitHub 仓库中找到：[https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter01](https://github.com/PacktPublishing/Advanced-Python-Programming-Second-Edition/tree/main/Chapter01)。
- en: Designing your application
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计你的应用程序
- en: In the early development stages, the design of a program can change quickly
    and may require large rewrites and reorganizations of the code base. By testing
    different prototypes without the burden of optimization, you are free to devote
    your time and energy to ensure that the program produces correct results and that
    the design is flexible. After all, who needs an application that runs fast but
    gives the wrong answer?
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在早期开发阶段，程序的设计可能会快速变化，可能需要大量重写和组织代码库。通过在无需优化的负担下测试不同的原型，你可以自由地投入时间和精力来确保程序产生正确的结果，并且设计是灵活的。毕竟，谁需要运行速度快但给出错误答案的应用程序？
- en: 'The mantras that you should remember when optimizing your code are outlined
    here:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化代码时应记住的咒语如下：
- en: '**Make it run**: We have to get the software in a working state and ensure
    that it produces the correct results. This exploratory phase serves to better
    understand the application and to spot major design issues in the early stages.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使其运行**：我们必须使软件处于工作状态，并确保它产生正确的结果。这个探索阶段有助于更好地理解应用程序，并在早期阶段发现主要的设计问题。'
- en: '**Make it right**: We want to ensure that the design of the program is solid.
    Refactoring should be done before attempting any performance optimization. This
    really helps separate the application into independent and cohesive units that
    are easy to maintain.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使其正确**：我们希望确保程序的设计是稳固的。在进行任何性能优化之前，应该先进行重构。这实际上有助于将应用程序分解成独立且易于维护的单元。'
- en: '**Make it fast**: Once our program is working and well structured, we can focus
    on performance optimization. We may also want to optimize memory usage if that
    constitutes an issue.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使其快速**：一旦我们的程序运行良好且结构合理，我们就可以专注于性能优化。如果内存使用成为问题，我们可能还想优化内存使用。'
- en: In this section, we will write and profile a *particle simulator* test application.
    A **simulator** is a program that considers some particles and simulates their
    movement over time according to a set of laws that we impose. These particles
    can be abstract entities or correspond to physical objects—for example, billiard
    balls moving on a table, molecules in a gas, stars moving through space, smoke
    particles, fluids in a chamber, and so on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写并分析一个 *粒子模拟器* 测试应用程序。**模拟器** 是一个程序，它考虑一些粒子，并根据我们施加的一组定律模拟它们随时间的变化。这些粒子可以是抽象实体，也可以对应于物理对象——例如，在桌面上移动的台球、气体中的分子、在空间中移动的恒星、烟雾粒子、室内的流体等等。
- en: Building a particle simulator
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建粒子模拟器
- en: Computer simulations are useful in fields such as physics, chemistry, astronomy,
    and many other disciplines. The applications used to simulate systems are particularly
    performance-intensive, and scientists and engineers spend an inordinate amount
    of time optimizing their code. In order to study realistic systems, it is often
    necessary to simulate a very high number of bodies, and every small increase in
    performance counts.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机模拟在物理学、化学、天文学以及许多其他学科中非常有用。用于模拟系统的应用程序特别注重性能，科学家和工程师花费大量时间优化他们的代码。为了研究现实系统，通常需要模拟大量的物体，任何小的性能提升都至关重要。
- en: In our first example, we will simulate a system containing particles that constantly
    rotate around a central point at various speeds, just like the hands of a clock.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，我们将模拟一个包含粒子围绕中心点以不同速度不断旋转的系统，就像时钟的指针一样。
- en: 'The necessary information to run our simulation will be the starting positions
    of the particles, the speed, and the rotation direction. From these elements,
    we have to calculate the position of the particle in the next instant of time.
    An example system is shown in the following diagram. The origin of the system
    is the `(0, 0)` point, the position is indicated by the *x*, *y* vector, and the
    velocity is indicated by the *vx*, *vy* vector:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的模拟所需的信息将是粒子的起始位置、速度和旋转方向。从这些元素中，我们必须计算出粒子在下一个时间点的位置。以下图示了一个示例系统。系统的原点是
    `(0, 0)` 点，位置由 *x*、*y* 向量表示，速度由 *vx*、*vy* 向量表示：
- en: '![Figure 1.1 – An example of a particle system ](img/Figure_1.1_B17499.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 粒子系统的示例](img/Figure_1.1_B17499.jpg)'
- en: Figure 1.1 – An example of a particle system
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 粒子系统的示例
- en: 'The basic feature of a circular motion is that the particles always move perpendicular
    to the direction connecting the particle and the center. To move the particle,
    we simply change the position by taking a series of very small steps (which correspond
    to advancing the system for a small interval of time) in the direction of motion,
    as shown in the following diagram:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 圆周运动的基本特征是粒子始终沿着连接粒子与中心的连线垂直运动。要移动粒子，我们只需通过一系列非常小的步骤（这相当于在运动方向上推进系统一小段时间间隔）来改变其位置，如下面的图所示：
- en: '![Figure 1.2 – Movement of a particle ](img/Figure_1.2_B17499.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 粒子的运动](img/Figure_1.2_B17499.jpg)'
- en: Figure 1.2 – Movement of a particle
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 粒子的运动
- en: 'We will start by designing the application in an `Particle` class that stores
    the particle positions, `x` and `y`, and their angular velocity, `ang_vel`, as
    illustrated in the following code snippet:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过以下代码片段设计一个 `Particle` 类，该类存储粒子的位置 `x` 和 `y` 以及它们的角速度 `ang_vel`，如下所示：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that we accept positive and negative numbers for all the parameters (the
    sign of `ang_vel` will simply determine the direction of rotation).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们接受所有参数的正负数（`ang_vel`的符号将简单地确定旋转方向）。
- en: 'Another class, called `ParticleSimulator`, will encapsulate the laws of motion
    and will be responsible for changing the positions of the particles over time.
    The `__init__` method will store a list of `Particle` instances, and the `evolve`
    method will change the particle positions according to our laws. The code is illustrated
    in the following snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个类，称为`ParticleSimulator`，将封装运动定律，并负责随时间改变粒子的位置。`__init__`方法将存储一个`Particle`实例的列表，而`evolve`方法将根据我们的定律改变粒子位置。以下代码片段展示了代码：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We want the particles to rotate around the position corresponding to the `x=0`
    and `y=0` coordinates, at a constant speed. The direction of the particles will
    always be perpendicular to the direction from the center (refer to *Figure 1.1*
    in this chapter). To find the direction of the movement along the *x* and *y*
    axes (corresponding to the Python `v_x` and `v_y` variables), it is sufficient
    to use these formulae:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望粒子围绕对应于`x=0`和`y=0`坐标的位置以恒定速度旋转。粒子的方向将始终垂直于从中心的方向（参见图1.1）。为了找到沿*x*轴和*y*轴的运动方向（对应于Python中的`v_x`和`v_y`变量），只需使用以下公式：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: If we let one of our particles move, after a certain time *t*, it will reach
    another position following a circular path. We can approximate a circular trajectory
    by dividing the time interval, *t*, into tiny time steps, *dt*, where the particle
    moves in a straight line tangentially to the circle. (Note that higher-order curves
    could be used rather than straight lines for better accuracy, but we will stick
    with lines as the simplest approximation.) The final result is just an approximation
    of a circular motion.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们让我们的一个粒子移动，经过一定的时间*t*，它将沿着圆形路径到达另一个位置。我们可以通过将时间间隔*t*分成极小的时间步长*dt*来近似圆形轨迹，其中粒子沿圆的切线直线移动。（注意，可以使用更高阶的曲线而不是直线以提高精度，但我们将坚持使用直线作为最简单的近似。）最终结果只是圆形运动的近似。
- en: 'In order to avoid a strong divergence, such as the one illustrated in the following
    diagram, it is necessary to take very small time steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免如以下图所示的大时间步长引起的强烈发散，有必要采取非常小的时间步长：
- en: '![Figure 1.3 – Undesired divergence in particle motion due to large time steps
    ](img/Figure_1.3_B17499.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – 由于大时间步长导致的粒子运动中的不期望发散](img/Figure_1.3_B17499.jpg)'
- en: Figure 1.3 – Undesired divergence in particle motion due to large time steps
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 由于大时间步长导致的粒子运动中的不期望发散
- en: 'In a more schematic way, we have to carry out the following steps to calculate
    the particle position at time *t*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以更简图的方式，我们必须执行以下步骤来计算时间*t*时的粒子位置：
- en: Calculate the direction of motion (`v_x` and `v_y`).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算运动方向（`v_x`和`v_y`）。
- en: Calculate the displacement (`d_x` and `d_y`), which is the product of the time
    step, angular velocity, and direction of motion.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算位移（`d_x`和`d_y`），它是时间步长、角速度和运动方向的乘积。
- en: Repeat *Steps 1* and *2* enough times to cover the total time *t*.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复*步骤1*和*步骤2*足够多次，以覆盖总时间*t*。
- en: 'The following code snippet shows the full `ParticleSimulator` implementation:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了完整的`ParticleSimulator`实现：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: And with that, we have finished building the foundation of our particle simulator.
    Next, we will see it in action by visualizing the simulated particles.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就完成了粒子模拟器的基础构建。接下来，我们将通过可视化模拟的粒子来看到它的实际应用。
- en: Visualizing the simulation
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化模拟
- en: We can use the `matplotlib` library here to visualize our particles. This library
    is not included in the Python standard library, but it can be easily installed
    using the `pip install matplotlib` command.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`matplotlib`库在这里可视化我们的粒子。这个库不包括在Python标准库中，但可以使用`pip install matplotlib`命令轻松安装。
- en: Alternatively, you can use the Anaconda Python distribution ([https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/)),
    which includes `matplotlib` and most of the other third-party packages used in
    this book. Anaconda is free and is available for Linux, Windows, and Mac.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用Anaconda Python发行版([https://store.continuum.io/cshop/anaconda/](https://store.continuum.io/cshop/anaconda/))，它包括`matplotlib`以及本书中使用的其他大多数第三方包。Anaconda是免费的，并且适用于Linux、Windows和Mac。
- en: To make an interactive visualization, we will use the `matplotlib.pyplot.plot`
    function to display the particles as points and the `matplotlib.animation.FuncAnimation`
    class to animate the evolution of the particles over time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个交互式可视化，我们将使用`matplotlib.pyplot.plot`函数显示粒子作为点，并使用`matplotlib.animation.FuncAnimation`类来动画化粒子随时间的演化。
- en: 'The `visualize` function takes a `ParticleSimulator` particle instance as an
    argument and displays the trajectory in an animated plot. The steps necessary
    to display the particle trajectory using the `matplotlib` tools are outlined here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`visualize`函数接受一个`ParticleSimulator`粒子实例作为参数，并在动画图中显示轨迹。使用`matplotlib`工具显示粒子轨迹所需的步骤在此概述：'
- en: Set up the axes and use the `plot` function to display the particles. The `plot`
    function takes a list of *x* and *y* coordinates.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置坐标轴并使用`plot`函数显示粒子。`plot`函数接受一个包含*x*和*y*坐标的列表。
- en: Write an initialization function, `init`, and a function, `animate`, that updates
    the *x* and *y* coordinates using the `line.set_data` method. Note that in `init`,
    we need to return the line data in the form of `line`, due to syntactic reasons.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个初始化函数`init`和一个函数`animate`，使用`line.set_data`方法更新*x*和*y*坐标。注意，由于语法原因，在`init`中我们需要以`line`的形式返回线数据。
- en: Create a `FuncAnimation` instance by passing the `init` and `animate` functions
    and the `interval` parameters, which specify the update interval, and `blit`,
    which improves the update rate of the image.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过传递`init`和`animate`函数以及指定更新间隔的`interval`参数，以及`blit`参数来提高图像更新率，创建一个`FuncAnimation`实例。
- en: 'Run the animation with `plt.show()`, as illustrated in the following code snippet:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`plt.show()`运行动画，如下面的代码片段所示：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To test this code, we define a small function, `test_visualize`, that animates
    a system of three particles rotating in different directions. Note in the following
    code snippet that the third particle completes a round three times faster than
    the others:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这段代码，我们定义了一个小的函数`test_visualize`，它动画化了一个由三个粒子组成的系统，这些粒子以不同的方向旋转。注意在下面的代码片段中，第三个粒子比其他粒子快三倍完成一圈：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `test_visualize` function is helpful to graphically understand the system
    time evolution. Simply close the animation window when you'd like to terminate
    the program. With this program in hand, in the following section, we will write
    more test functions to properly verify program correctness and measure performance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_visualize`函数有助于图形化地理解系统的演化时间。当你想终止程序时，只需简单地关闭动画窗口。有了这个程序，在接下来的部分，我们将编写更多的测试函数，以正确验证程序的正确性和测量性能。'
- en: Writing tests and benchmarks
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试和基准测试
- en: Now that we have a working simulator, we can start measuring our performance
    and tune up our code so that the simulator can handle as many particles as possible.
    As a first step, we will write a test and a benchmark.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个工作的模拟器，我们可以开始测量我们的性能并调整我们的代码，以便模拟器可以处理尽可能多的粒子。作为第一步，我们将编写一个测试和一个基准测试。
- en: We need a test that checks whether the results produced by the simulation are
    correct or not. Optimizing a program commonly requires employing multiple strategies;
    as we rewrite our code multiple times, bugs may easily be introduced. A solid
    test suite ensures that the implementation is correct at every iteration so that
    we are free to go wild and try different things with the confidence that, if the
    test suite passes, the code will still work as expected. More specifically, what
    we are implementing here are called unit tests, which aim to verify the intended
    logic of the program regardless of the implementation details, which may change
    during optimization.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个测试来检查模拟产生的结果是否正确。优化程序通常需要采用多种策略；随着我们多次重写代码，错误可能会轻易引入。一个稳固的测试套件确保在每次迭代中实现都是正确的，这样我们就可以自由地尝试不同的事情，并充满信心地认为，如果测试套件通过，代码仍然会按预期工作。更具体地说，我们在这里实现的是单元测试，其目的是验证程序意图的逻辑，而不考虑实现细节，这些细节在优化过程中可能会发生变化。
- en: 'Our test will take three particles, simulate them for `0.1` time units, and
    compare the results with those from a reference implementation. A good way to
    organize your tests is using a separate function for each different aspect (or
    unit) of your application. Since our current functionality is included in the
    `evolve` method, our function will be named `test_evolve`. The following code
    snippet shows the `test_evolve` implementation. Note that, in this case, we compare
    floating-point numbers up to a certain precision through the `fequal` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将使用三个粒子，模拟它们`0.1`时间单位，并将结果与参考实现的结果进行比较。组织测试的一个好方法是使用一个单独的函数来处理应用程序的每个不同方面（或单元）。由于我们当前的功能包含在`evolve`方法中，我们的函数将被命名为`test_evolve`。下面的代码片段显示了`test_evolve`的实现。请注意，在这种情况下，我们通过`fequal`函数比较浮点数，直到一定的精度：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `assert` statements will raise an error if the included conditions are not
    satisfied. Upon running the `test_evolve` function, if you notice no error or
    output printed out, that means all the conditions are met.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`assert`语句中的条件不满足，将会引发错误。运行`test_evolve`函数后，如果你没有注意到任何错误或输出打印出来，这意味着所有条件都已满足。
- en: A test ensures the correctness of our functionality but gives little information
    about its running time. A **benchmark** is a simple and representative use case
    that can be run to assess the running time of an application. Benchmarks are very
    useful to keep score of how fast our program is with each new version that we
    implement.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 测试确保我们的功能正确，但关于其运行时间提供的信息很少。**基准测试**是一个简单且具有代表性的用例，可以运行以评估应用程序的运行时间。基准测试对于跟踪我们实现的新版本中程序的速度非常有用。
- en: 'We can write a representative benchmark by instantiating a thousand `Particle`
    objects with random coordinates and angular velocity and feeding them to a `ParticleSimulator`
    class. We then let the system evolve for `0.1` time units. The code is illustrated
    in the following snippet:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过实例化带有随机坐标和角速度的千个`Particle`对象，并将它们提供给`ParticleSimulator`类来编写一个代表性的基准测试。然后我们让系统演化`0.1`时间单位。代码在下面的片段中展示：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the benchmark program implemented, we now need to run it and keep track
    of the time needed for the benchmark to complete execution, which we will see
    next. (Note that when you run these tests and benchmarks on your own system, you
    are likely to see different numbers listed in the text, which is completely normal
    and dependent on your system configurations and Python version.)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现基准程序，我们现在需要运行它并跟踪基准完成执行所需的时间，我们将在下一部分看到。请注意，当你在自己的系统上运行这些测试和基准时，你可能会看到文本中列出的不同数字，这是完全正常的，并且取决于你的系统配置和Python版本。
- en: Timing your benchmark
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计时你的基准测试
- en: 'A very simple way to time a benchmark is through the Unix `time` command. Using
    the `time` command, as follows, you can easily measure the execution time of an
    arbitrary process:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过Unix的`time`命令来计时基准测试是一种非常简单的方法。使用`time`命令，如下所示，你可以轻松地测量任意过程的执行时间：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `time` command is not available for Windows. To install Unix tools such
    as `time` on Windows, you can use the `cygwin` shell, downloadable from the official
    website ([http://www.cygwin.com/](http://www.cygwin.com/)). Alternatively, you
    can use similar PowerShell commands, such as `Measure-Command` ([https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command](https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command)),
    to measure execution time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`time`命令在Windows上不可用。要在Windows上安装如`time`之类的Unix工具，你可以使用从官方网站下载的`cygwin` shell（[http://www.cygwin.com/](http://www.cygwin.com/)）。或者，你可以使用类似的PowerShell命令，如`Measure-Command`（[https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command](https://msdn.microsoft.com/en-us/powershell/reference/5.1/microsoft.powershell.utility/measure-command)），来测量执行时间。'
- en: 'By default, `time` displays three metrics, as outlined here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`time`显示三个指标，如下所述：
- en: '`real`: The actual time spent running the process from start to finish, as
    if it were measured by a human with a stopwatch.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`real`：从开始到结束运行过程的实际时间，就像它被一个使用秒表的人测量一样。'
- en: '`user`: The cumulative time spent by all the **central processing units** (**CPUs**)
    during the computation.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`：所有**中央处理器**（**CPUs**）在计算过程中花费的累积时间。'
- en: '`sys`: The cumulative time spent by all the CPUs during system-related tasks,
    such as memory allocation.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sys`：所有CPUs在系统相关任务（如内存分配）中花费的累积时间。'
- en: Note
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Sometimes, `user` and `sys` might be greater than `real`, as multiple processors
    may work in parallel.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，`user` 和 `sys` 可能大于 `real`，因为多个处理器可能并行工作。
- en: '`time` also offers richer formatting options. For an overview, you can explore
    its manual (using the `man time` command). If you want a summary of all the metrics
    available, you can use the `-v` option.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`time` 还提供了更丰富的格式化选项。要了解概述，您可以查看其手册（使用 `man time` 命令）。如果您想查看所有可用的指标摘要，可以使用
    `-v` 选项。'
- en: The Unix `time` command is one of the simplest and most direct ways to benchmark
    a program. For an accurate measurement, the benchmark should be designed to have
    a long enough execution time (in the order of seconds) so that the setup and teardown
    of the process are small compared to the execution time of the application. The
    `user` metric is suitable as a monitor for the CPU performance, while the `real`
    metric also includes the time spent on other processes while waiting for **input/output**
    (**I/O**) operations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的 `time` 命令是衡量程序性能最简单和最直接的方法之一。为了获得准确的测量结果，基准测试应该设计得足够长，以便执行时间（以秒为单位）远大于进程的设置和拆除时间。`user`
    指标适合作为监控 CPU 性能的指标，而 `real` 指标还包括在等待 **输入/输出**（**I/O**）操作时花费的时间。
- en: Another convenient way to time Python scripts is the `timeit` module. This module
    runs a snippet of code in a loop for *n* times and measures the total execution
    time. Then, it repeats the same operation *r* times (by default, the value of
    *r* is `3`) and records the time of the best run. Due to this timing scheme, `timeit`
    is an appropriate tool to accurately time small statements in isolation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方便计时 Python 脚本的方法是 `timeit` 模块。此模块将代码片段在循环中运行 *n* 次，并测量总执行时间。然后，它重复相同的操作
    *r* 次（默认情况下，*r* 的值为 `3`）并记录最佳运行时间。由于这种计时方案，`timeit` 是准确计时独立小语句的合适工具。
- en: The `timeit` module can be used as a Python package, from the command line or
    from *IPython*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit` 模块可以用作 Python 包，从命令行或从 *IPython* 使用。'
- en: IPython is a Python shell design that improves the interactivity of the Python
    interpreter. It boosts tab completion and many utilities to time, profile, and
    debug your code. We will use this shell to try out snippets throughout the book.
    The IPython shell accepts `%` symbol—that enhance the shell with special behaviors.
    Commands that start with `%%` are called **cell magics**, which can be applied
    on multiline snippets (termed as **cells**).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 是一种改进 Python 解释器交互性的 Python shell 设计。它增强了自动补全和许多用于计时、分析和调试代码的实用工具。我们将使用此
    shell 在整本书中尝试代码片段。IPython shell 接受 `%` 符号——这增强了 shell 的特殊行为。以 `%%` 开头的命令称为 **cell
    magics**，可以应用于多行片段（称为 **cells**）。
- en: IPython is available on most Linux distributions through `pip` and is included
    in Anaconda. You can use IPython as a regular Python shell (`ipython`), but it
    is also available in a Qt-based version (`ipython qtconsole`) and as a powerful
    browser-based interface (`jupyter notebook`).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: IPython 大多数 Linux 发行版中都通过 `pip` 提供，并包含在 Anaconda 中。您可以将 IPython 用作常规 Python
    shell (`ipython`)，但它也提供基于 Qt 的版本 (`ipython qtconsole`) 和强大的基于浏览器的界面 (`jupyter
    notebook`)。
- en: 'In IPython and `-n` and `-r` options. If not specified, they will be automatically
    inferred by `timeit`. When invoking `timeit` from the command line, you can also
    pass some setup code, through the `-s` option, which will execute before the benchmark.
    In the following snippet, the `IPython` command line and Python module version
    of `timeit` are demonstrated:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IPython 和 `-n` 和 `-r` 选项中。如果没有指定，它们将由 `timeit` 自动推断。从命令行调用 `timeit` 时，您还可以通过
    `-s` 选项传递一些设置代码，这将执行基准测试之前。在以下代码片段中，演示了 `IPython` 命令行和 Python 模块版本的 `timeit`：
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that while the command line and IPython interfaces automatically infer
    a reasonable number of loops `n`, the Python interface requires you to explicitly
    specify a value through the `number` argument.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，虽然命令行和 IPython 接口会自动推断一个合理的循环次数 `n`，但 Python 接口需要您通过 `number` 参数显式指定一个值。
- en: Writing better tests and benchmarks with pytest-benchmark
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 pytest-benchmark 编写更好的测试和基准
- en: The Unix `time` command is a versatile tool that can be used to assess the running
    time of small programs on a variety of platforms. For larger Python applications
    and libraries, a more comprehensive solution that deals with both testing and
    benchmarking is `pytest`, in combination with its `pytest-benchmark` plugin.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Unix 的 `time` 命令是一种多功能的工具，可以用于评估各种平台上小型程序的运行时间。对于更大的 Python 应用程序和库，一个更全面的解决方案，同时处理测试和基准测试的是
    `pytest`，结合其 `pytest-benchmark` 插件。
- en: In this section, we will write a simple benchmark for our application using
    the `pytest` testing framework. For those who are, the `pytest` documentation,
    which can be found at [http://doc.pytest.org/en/latest/](http://doc.pytest.org/en/latest/),
    is the best resource to learn more about the framework and its uses.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用 `pytest` 测试框架为我们的应用程序编写一个简单的基准测试。对于那些想要了解更多关于框架及其用途的人，`pytest` 文档是最佳资源，可以在
    [http://doc.pytest.org/en/latest/](http://doc.pytest.org/en/latest/) 找到。
- en: You can install `pytest` from the console using the `pip install pytest` command.
    The benchmarking plugin can be installed, similarly, by issuing the `pip install
    pytest-benchmark` command.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `pip install pytest` 命令从控制台安装 `pytest`。同样，可以通过发出 `pip install pytest-benchmark`
    命令来安装基准测试插件。
- en: 'A testing framework is a set of tools that simplifies writing, executing, and
    debugging tests, and provides rich reports and summaries of the test results.
    When using the `pytest` framework, it is recommended to place tests separately
    from the application code. In the following example, we create a `test_simul.py`
    file that contains the `test_evolve` function:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 测试框架是一组工具，它简化了编写、执行和调试测试，并提供了丰富的测试结果报告和摘要。当使用 `pytest` 框架时，建议将测试与应用程序代码分开。在下面的例子中，我们创建了一个
    `test_simul.py` 文件，其中包含 `test_evolve` 函数：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `pytest` executable can be used from the command line to discover and run
    tests contained in Python modules. To execute a specific test, we can use the
    `pytest path/to/module.py::function_name` syntax. To execute `test_evolve`, we
    can type the following command in a console to obtain simple but informative output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从命令行使用 `pytest` 可执行文件来发现和运行包含在 Python 模块中的测试。要执行特定的测试，我们可以使用 `pytest path/to/module.py::function_name`
    语法。要执行 `test_evolve`，我们可以在控制台中输入以下命令以获得简单但信息丰富的输出：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we have a test in place, it is possible for you to execute your test as
    a benchmark using the `pytest-benchmark` plugin. If we change our `test` function
    so that it accepts an argument named `benchmark`, the `pytest` framework will
    automatically pass the `benchmark` resource as an argument (in `pytest` terminology,
    these resources are called `benchmark` resource can be called by passing the function
    that we intend to benchmark as the first argument, followed by the additional
    arguments. In the following snippet, we illustrate the edits necessary to benchmark
    the `ParticleSimulator.evolve` function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了测试，您就可以使用 `pytest-benchmark` 插件将测试作为基准来执行。如果我们更改 `test` 函数，使其接受一个名为 `benchmark`
    的参数，`pytest` 框架将自动将 `benchmark` 资源作为参数传递（在 `pytest` 术语中，这些资源被称为 `benchmark` 资源可以通过传递我们打算基准测试的函数作为第一个参数，然后是额外的参数。在下面的代码片段中，我们说明了基准测试
    `ParticleSimulator.evolve` 函数所需的编辑：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To run the benchmark, it is sufficient to rerun the `pytest test_simul.py::test_evolve`
    command. The resulting output will contain detailed timing information regarding
    the `test_evolve` function, as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行基准测试，只需重新运行 `pytest test_simul.py::test_evolve` 命令即可。生成的输出将包含有关 `test_evolve`
    函数的详细时间信息，如下所示：
- en: '![Figure 1.4 – Output from pytest ](img/Figure_1.4_B17499.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – pytest 的输出](img/Figure_1.4_B17499.jpg)'
- en: Figure 1.4 – Output from pytest
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – pytest 的输出
- en: For each test collected, `pytest-benchmark` will execute the `benchmark` function
    several times and provide a statistic summary of its running time. The preceding
    output shown is very interesting as it shows how running times vary between runs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于收集到的每个测试，`pytest-benchmark` 将多次执行 `benchmark` 函数，并提供其运行时间的统计摘要。前面显示的输出非常有趣，因为它显示了运行时间之间的变化。
- en: In this example, the benchmark in `test_evolve` was run `34` times (`Rounds`
    column), its timings ranged between `29` and `41` `Min` and `Max`), and the `Average`
    and `Median` times were fairly similar at about `30` ms, which is actually very
    close to the best timing obtained. This example demonstrates how there can be
    substantial performance variability between runs and that, as opposed to taking
    timings with one-shot tools such as `time`, it is a good idea to run the program
    multiple times and record a representative value, such as the minimum or the median.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`test_evolve` 中的基准测试运行了 `34` 次（`Rounds` 列），其时间在 `29` 到 `41` 分钟之间（`Min`
    和 `Max`），平均时间和中位数时间大约在 `30` 毫秒，实际上非常接近获得的最佳时间。这个例子展示了运行之间可能会有很大的性能变化，并且与使用 `time`
    这样的单次工具获取时间相比，多次运行程序并记录一个代表性值（如最小值或中位数）是一个好主意。
- en: '`pytest-benchmark` has many more features and options that can be used to take
    accurate timings and analyze the results. For more information, consult the documentation
    at [http://pytest-benchmark.readthedocs.io/en/stable/usage.html](http://pytest-benchmark.readthedocs.io/en/stable/usage.html).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`pytest-benchmark` 有更多功能和选项，可用于进行精确计时和分析结果。有关更多信息，请参阅[http://pytest-benchmark.readthedocs.io/en/stable/usage.html](http://pytest-benchmark.readthedocs.io/en/stable/usage.html)上的文档。'
- en: Finding bottlenecks with cProfile
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 cProfile 查找瓶颈
- en: After assessing the correctness and timing of the execution time of the program,
    we are ready to identify the parts of the code that need to be tuned for performance.
    We typically aim to identify parts that are small compared to the size of the
    program.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在评估程序执行的正确性和时间后，我们准备识别需要调整性能的代码部分。我们通常旨在识别与程序大小相比较小的部分。
- en: 'Two profiling modules are available through the Python standard library, as
    outlined here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库中提供了两个分析模块，如下概述：
- en: '**The profile module**: This module is written in pure Python and adds significant
    overhead to the program execution. Its presence in the standard library is due
    to its vast platform support and the ease with which it can be extended.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析模块**：此模块是用纯 Python 编写的，给程序执行增加了显著的开销。它在标准库中的存在归功于其广泛的支持平台和易于扩展。'
- en: '`profile`. It is written in C, has a small overhead, and is suitable as a general-purpose
    profiler.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`profile`。它是用 C 编写的，开销小，适合作为通用分析器。'
- en: 'The `cProfile` module can be used in three different ways, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 模块可以以三种不同的方式使用，如下所示：'
- en: From the command line
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行
- en: As a Python module
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为 Python 模块
- en: With IPython
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IPython
- en: '`cProfile` does not require any change in the source code and can be executed
    directly on an existing Python script or function. You can use `cProfile` from
    the command line in this way:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 不需要更改源代码，可以直接在现有的 Python 脚本或函数上执行。您可以通过以下方式从命令行使用 `cProfile`：'
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This will print a long output containing several profiling metrics of all of
    the functions called in the application. You can use the `-s` option to sort the
    output by a specific metric. In the following snippet, the output is sorted by
    the `tottime` metric, which will be described here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印出包含应用程序中所有调用函数的多个分析指标的长时间输出。您可以使用 `-s` 选项按特定指标排序输出。在以下代码片段中，输出按 `tottime`
    指标排序，该指标将在下面进行描述：
- en: '[PRE14]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The data produced by `cProfile` can be saved in an output file by passing the
    `-o` option. The format that `cProfile` uses is readable by the `stats` module
    and other tools. The usage of the`-o` option is shown here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 生成数据可以通过传递 `-o` 选项保存到输出文件。`cProfile` 使用的格式可由 `stats` 模块和其他工具读取。`-o`
    选项的使用示例如下：'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The usage of `cProfile` as a Python module requires invoking the `cProfile.run`
    function in the following way:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `cProfile` 作为 Python 模块使用需要以以下方式调用 `cProfile.run` 函数：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can also wrap a section of code between method calls of a `cProfile.Profile`
    object, as shown here:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将代码段包裹在 `cProfile.Profile` 对象的方法调用之间，如下所示：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`cProfile` can also be used interactively with IPython. The `%prun` magic command
    lets you profile an individual function call, as illustrated in the following
    screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 还可以与 IPython 交互式使用。`%prun` 魔法命令允许您分析单个函数调用，如下面的屏幕截图所示：'
- en: '![Figure 1.5 – Using cProfile within IPython ](img/Figure_1.5_B17499.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 在 IPython 中使用 cProfile](img/Figure_1.5_B17499.jpg)'
- en: Figure 1.5 – Using cProfile within IPython
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 在 IPython 中使用 cProfile
- en: 'The `cProfile` output is divided into five columns, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`cProfile` 输出分为五列，如下所示：'
- en: '`ncalls`: The number of times the function was called.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ncalls`：函数被调用的次数。'
- en: '`tottime`: The total time spent in the function without taking into account
    the calls to other functions.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tottime`：在函数中花费的总时间，不考虑对其他函数的调用。'
- en: '`cumtime`: The time spent in the function including other function calls.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cumtime`：包括其他函数调用在内的函数耗时。'
- en: '`percall`: The time spent for a single call of the function—this can be obtained
    by dividing the total or cumulative time by the number of calls.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`percall`：函数单次调用的耗时——这可以通过将总时间或累积时间除以调用次数获得。'
- en: '`filename:lineno`: The filename and corresponding line numbers. This information
    is not available when calling C extension modules.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filename:lineno`：文件名和相应的行号。当调用 C 扩展模块时，此信息不可用。'
- en: The most important metric is `tottime`, the actual time spent in the function
    body excluding subcalls, which tells us exactly where the bottleneck is.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的指标是 `tottime`，即不包括子调用的函数体实际花费的时间，这告诉我们瓶颈的确切位置。
- en: Unsurprisingly, the largest portion of time is spent in the `evolve` function.
    We can imagine that the loop is the section of the code that needs performance
    tuning. `cProfile` only provides information at the function level and does not
    tell us which specific statements are responsible for the bottleneck. Fortunately,
    as we will see in the next section, the `line_profiler` tool is capable of providing
    line-by-line information of the time spent in the function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，大部分时间都花在了 `evolve` 函数上。我们可以想象，循环是代码中需要性能调优的部分。`cProfile` 只提供函数级别的信息，并不告诉我们哪些具体的语句导致了瓶颈。幸运的是，正如我们将在下一节中看到的，`line_profiler`
    工具能够提供函数中每一行花费的时间信息。
- en: Analyzing the `cProfile` text output can be daunting for big programs with a
    lot of calls and subcalls. Some visual tools aid the task by improving navigation
    with an interactive, graphical interface.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 分析 `cProfile` 文本输出对于具有大量调用和子调用的程序来说可能令人望而生畏。一些可视化工具通过改进交互式图形界面来辅助任务。
- en: Graphically analyzing profiling results
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图形化分析性能分析结果
- en: KCachegrind is a `cProfile`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind 是一个 `cProfile`。
- en: KCachegrind is available in the Ubuntu 16.04 official repositories. The Qt port,
    QCacheGrind, can be downloaded for Windows from [http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/).
    Mac users can compile QCacheGrind using MacPorts ([http://www.macports.org/](http://www.macports.org/))
    by following the instructions present in the blog post at [http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html](http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind 可在 Ubuntu 16.04 的官方仓库中找到。Qt 版本的 QCacheGrind 可以从 [http://sourceforge.net/projects/qcachegrindwin/](http://sourceforge.net/projects/qcachegrindwin/)
    下载用于 Windows。Mac 用户可以通过遵循博客文章 [http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html](http://blogs.perl.org/users/rurban/2013/04/install-kachegrind-on-macosx-with-ports.html)
    中的说明来使用 MacPorts 编译 QCacheGrind。
- en: KCachegrind can't directly read the output files produced by `cProfile`. Luckily,
    the `pyprof2calltree` third-party Python module is able to convert the `cProfile`
    output file into a format readable by KCachegrind.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: KCachegrind 不能直接读取 `cProfile` 生成的输出文件。幸运的是，`pyprof2calltree` 这个第三方 Python 模块能够将
    `cProfile` 输出文件转换为 KCachegrind 可读的格式。
- en: You can install `pyprof2calltree` from the `pip install pyprof2calltree` command.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 `pip install pyprof2calltree` 命令中安装 `pyprof2calltree`。
- en: 'To best show the KCachegrind features, we will use another example with a more
    diversified structure. We define a recursive function, `factorial`, and two other
    functions that use `factorial`, named `taylor_exp` and `taylor_sin`. They represent
    the polynomial coefficients of the Taylor approximations of `exp(x)` and `sin(x)`
    and are illustrated in the following code snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最好地展示 KCachegrind 的功能，我们将使用一个具有更复杂结构的另一个示例。我们定义了一个递归函数 `factorial` 和两个其他使用
    `factorial` 的函数，分别命名为 `taylor_exp` 和 `taylor_sin`。它们代表了 `exp(x)` 和 `sin(x)` 的泰勒近似的多项式系数，并在以下代码片段中展示：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To access profile information, we first need to generate a `cProfile` output
    file, as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问性能分析信息，我们首先需要生成一个 `cProfile` 输出文件，如下所示：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we can convert the output file with `pyprof2calltree` and launch KCachegrind
    by running the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `pyprof2calltree` 转换输出文件，并通过运行以下代码启动 KCachegrind：
- en: '[PRE20]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output is shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示在以下屏幕截图中：
- en: '![Figure 1.6 – Profiling output generated by pyprof2calltree and displayed
    by KCachegrind ](img/Figure_1.6_B17499.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 由 pyprof2calltree 生成的性能分析输出并由 KCachegrind 显示](img/Figure_1.6_B17499.jpg)'
- en: Figure 1.6 – Profiling output generated by pyprof2calltree and displayed by
    KCachegrind
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 由 pyprof2calltree 生成的性能分析输出并由 KCachegrind 显示
- en: 'The screenshot shows the KCachegrind UI. On the left, we have an output fairly
    similar to `cProfile`. The actual column names are slightly different: `cProfile`
    module''s `cumtime` value and `tottime`. The values are given in percentages by
    clicking on the **Relative** button on the menu bar. By clicking on the column
    headers, you can sort them by the corresponding property.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 截图显示了 KCachegrind 的用户界面。在左侧，我们有一个与 `cProfile` 相当接近的输出。实际的列名略有不同：`cProfile` 模块的
    `cumtime` 值和 `tottime`。通过在菜单栏上点击 **Relative** 按钮来以百分比的形式显示这些值。通过点击列标题，可以按相应的属性进行排序。
- en: On the top right, a click on the `factorial` function. The one on the left corresponds
    to the calls made by `taylor_exp` and the one on the right to the calls made by
    `taylor_sin`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在右上角点击`factorial`函数。左侧的对应于`taylor_exp`的调用，右侧的对应于`taylor_sin`的调用。
- en: On the bottom right, you can display another diagram, a `taylor_exp` calls `factorial`
    `taylor_sin` calls `factorial` `factorial` calls itself **187250** times.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在右下角，你可以显示另一个图表，`taylor_exp`调用`factorial`，`taylor_sin`调用`factorial`，`factorial`自身调用**187250**次。
- en: You can navigate to the `taylor_exp` will cause the graph to change, showing
    only the contribution of `taylor_exp` to the total cost.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以导航到`taylor_exp`，这将导致图表改变，只显示`taylor_exp`对总成本的贡献。
- en: '`.dot` diagram representing a call graph.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dot`图表示调用图。'
- en: Profiling line by line with line_profiler
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用line_profiler逐行分析
- en: Now that we know which function we have to optimize, we can use the `line_profiler`
    module that provides information on how time is spent in a line-by-line fashion.
    This is very useful in situations where it's difficult to determine which statements
    are costly. The `line_profiler` module is a third-party module that is available
    on PyPI and can be installed by following the instructions at [https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪个函数需要优化，我们可以使用`line_profiler`模块，该模块以逐行方式提供时间花费的信息。这在难以确定哪些语句代价高昂的情况下非常有用。`line_profiler`模块是一个第三方模块，可在PyPI上找到，可以通过遵循[https://github.com/rkern/line_profiler](https://github.com/rkern/line_profiler)上的说明进行安装。
- en: 'In order to use `line_profiler`, we need to apply a `@profile` decorator to
    the functions we intend to monitor. Note that you don''t have to import the `profile`
    function from another module as it gets injected into the global namespace when
    running the `kernprof.py` profiling script. To produce profiling output for our
    program, we need to add the `@profile` decorator to the `evolve` function, as
    follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用`line_profiler`，我们需要在打算监控的函数上应用`@profile`装饰器。注意，你不需要从其他模块导入`profile`函数，因为它在运行`kernprof.py`分析脚本时会被注入到全局命名空间中。为了生成我们程序的配置文件输出，我们需要将`@profile`装饰器添加到`evolve`函数中，如下所示：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `kernprof.py` script will produce an output file and print the result of
    the profiling on the standard output. We should run the script with two options,
    as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernprof.py`脚本将生成一个输出文件，并在标准输出上打印配置文件的结果。我们应该使用以下两个选项运行脚本：'
- en: '`-l` to use the `line_profiler` function'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-l`参数来使用`line_profiler`函数
- en: '`-v` to immediately print the results on screen'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-v`参数立即在屏幕上打印结果
- en: 'The usage of `kernprof.py` is illustrated in the following line of code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`kernprof.py`的使用在以下代码行中说明：'
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It is also possible to run the profiler in an IPython shell for interactive
    editing. You should first load the `line_profiler` extension that will provide
    the `lprun` magic command. Using that command, you can avoid adding the `@profile`
    decorator, as illustrated in the following screenshot:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以在IPython壳中运行分析器以进行交互式编辑。你应该首先加载`line_profiler`扩展，这将提供`lprun`魔法命令。使用该命令，你可以避免添加`@profile`装饰器，如下面的截图所示：
- en: '![Figure 1.7 – Using line_profiler within IPython ](img/Figure_1.7_B17499.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 在IPython中使用line_profiler](img/Figure_1.7_B17499.jpg)'
- en: Figure 1.7 – Using line_profiler within IPython
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 在IPython中使用line_profiler
- en: 'The output is quite intuitive and is divided into six columns, as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 输出非常直观，分为六个列，如下所示：
- en: '`Line #`: The number of the line that was run'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行号`: 被运行的行的编号'
- en: '`Hits`: The number of times that line was run'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调用次数`: 该行被运行的次数'
- en: '`Time`: The execution time of the line in microseconds (`Time`)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`时间`: 该行的执行时间，以微秒为单位（`时间`）'
- en: '`Per Hit`: Time/hits'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`每次调用时间`: 时间/调用次数'
- en: '`% Time`: Fraction of the total time spent executing that line'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`% 时间`: 执行该行所花费的总时间的比例'
- en: '`Line Contents`: The content of the line'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`行内容`: 该行的内容'
- en: By looking at the `for` loop body with a cost of around 10-20 percent each.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`for`循环体，每次大约消耗10-20%的代价。
- en: Optimizing our code
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我们的代码
- en: Now that we have identified where exactly our application is spending most of
    its time, we can make some changes and assess the resulting improvement in performance.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了我们的应用程序大部分时间都花在了哪里，我们可以做一些更改，并评估性能的改进。
- en: 'There are different ways to tune up our pure Python code. The way that typically
    produces the most significant results is to improve the *algorithms* used. In
    this case, instead of calculating the velocity and adding small steps, it will
    be more efficient (and correct, as it is not an approximation) to express the
    equations of motion in terms of radius, `r`, and angle, `alpha`, (instead of `x`
    and `y`), and then calculate the points on a circle using the following equation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以调整我们的纯Python代码。通常产生最显著结果的方法是改进所使用的**算法**。在这种情况下，我们不是计算速度并添加小步骤，而是更有效（并且正确，因为它不是近似）用半径`r`和角度`alpha`（而不是`x`和`y`）来表示运动方程，然后使用以下方程计算圆上的点：
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Another optimization method lies in minimizing the number of instructions. For
    example, we can precalculate the `timestep * p.ang_vel` factor that doesn't change
    with time. We can exchange the loop order (first, we iterate on particles, then
    we iterate on time steps) and put the calculation of the factor outside the loop
    on the particles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种优化方法在于最小化指令的数量。例如，我们可以预先计算`timestep * p.ang_vel`这个因子，它不会随时间变化。我们可以交换循环顺序（首先，我们对粒子进行迭代，然后对时间步进行迭代）并将因子的计算放在粒子循环之外。
- en: 'The line-by-line profiling also showed that even simple assignment operations
    can take a considerable amount of time. For example, the following statement takes
    more than 10 percent of the total time:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 行程分析还显示，即使是简单的赋值操作也可能花费相当多的时间。例如，以下语句占用了总时间的超过10%：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can improve the performance of the loop by reducing the number of assignment
    operations performed. To do that, we can avoid intermediate variables by rewriting
    the expression into a single, slightly more complex statement (note that the right-hand
    side gets evaluated completely before being assigned to the variables), as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过减少执行赋值操作的数量来提高循环的性能。要做到这一点，我们可以通过将表达式重写为一个稍微复杂一点的单一语句来避免中间变量，如下所示（注意，右侧在赋值给变量之前会被完全评估）：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This leads to the following code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了以下代码：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After applying the changes, we should verify that the result is still the same
    by running our test. We can then compare the execution times using our benchmark,
    as follows:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 应用更改后，我们应该通过运行我们的测试来验证结果是否仍然相同。然后我们可以使用我们的基准来比较执行时间，如下所示：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, we obtained only a modest increment in speed by making a pure
    Python micro-optimization.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们通过进行纯Python微优化只获得了微小的速度提升。
- en: Using the dis module
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`dis`模块
- en: In this section, we will dig into the Python internals to estimate the performance
    of individual statements. In the CPython interpreter, Python code is first converted
    to an intermediate representation, the **bytecode**, and then executed by the
    Python interpreter.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将深入研究Python内部机制，以估计单个语句的性能。在CPython解释器中，Python代码首先被转换为中间表示形式，即**字节码**，然后由Python解释器执行。
- en: 'To inspect how the code is converted to bytecode, we can use the `dis` Python
    module (`dis` stands for `dis.dis` function on the `ParticleSimulator.evolve`
    method, like this:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查代码如何转换为字节码，我们可以使用`dis` Python模块（`dis`代表`ParticleSimulator.evolve`方法上的`dis.dis`函数，如下所示：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will print, for each line in the function, a list of bytecode instructions.
    For example, the `v_x = (-p.y)/norm` statement is expanded in the following set
    of instructions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为函数中的每一行打印出字节码指令的列表。例如，`v_x = (-p.y)/norm`语句在以下指令集中展开：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`LOAD_FAST` loads a reference of the `p` variable onto the stack and `LOAD_ATTR`
    loads the `y` attribute of the item present on top of the stack. The other instructions,
    `UNARY_NEGATIVE` and `BINARY_TRUE_DIVIDE`, simply do arithmetic operations on
    top-of-stack items. Finally, the result is stored in `v_x` (`STORE_FAST`).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`LOAD_FAST`将`p`变量的引用加载到栈上，`LOAD_ATTR`将栈顶元素的`y`属性加载到栈上。其他指令，如`UNARY_NEGATIVE`和`BINARY_TRUE_DIVIDE`，只是对栈顶元素进行算术运算。最后，结果存储在`v_x`中（`STORE_FAST`）。'
- en: By analyzing the `dis` output, we can see that the first version of the loop
    produces `51` bytecode instructions, while the second gets converted into `35`
    instructions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分析`dis`输出，我们可以看到循环的第一个版本产生了`51`条字节码指令，而第二个版本被转换成了`35`条指令。
- en: The `dis` module helps discover how the statements get converted and serves
    mainly as an exploration and learning tool of the Python bytecode representation.
    For a more comprehensive introduction and discussion on the Python bytecode, refer
    to the *Further reading* section at the end of this chapter.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`dis`模块有助于发现语句是如何转换的，主要用作Python字节码表示的探索和学习工具。有关Python字节码的更全面介绍和讨论，请参阅本章末尾的*进一步阅读*部分。'
- en: To improve our performance even further, we can keep trying to figure out other
    approaches to reduce the number of instructions. It's clear, however, that this
    approach is ultimately limited by the speed of the Python interpreter, and it
    is probably not the right tool for the job. In the following chapters, we will
    see how to speed up interpreter-limited calculations by executing fast specialized
    versions written in a lower-level language (such as C or Fortran).
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步提高我们的性能，我们可以继续尝试找出其他方法来减少指令的数量。然而，很明显，这种方法最终受限于Python解释器的速度，可能不是这项工作的正确工具。在接下来的章节中，我们将看到如何通过执行用更低级语言（如C或Fortran）编写的快速专用版本来加速受解释器限制的计算。
- en: Profiling memory usage with memory_profiler
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`memory_profiler`进行内存使用分析
- en: In some cases, high memory usage constitutes an issue. For example, if we want
    to handle a huge number of particles, we will incur a memory overhead due to the
    creation of many `Particle` instances.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，高内存使用构成一个问题。例如，如果我们想处理大量的粒子，由于创建了大量的`Particle`实例，我们将产生内存开销。
- en: The `memory_profiler` module summarizes, in a way similar to `line_profiler`,
    the memory usage of a process.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory_profiler`模块以一种类似于`line_profiler`的方式总结了进程的内存使用情况。'
- en: The `memory_profiler` package is also available on PyPI. You should also install
    the `psutil` module ([https://github.com/giampaolo/psutil](https://github.com/giampaolo/psutil))
    as an optional dependency that will make `memory_profiler` considerably faster.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`memory_profiler`包也可在PyPI上找到。您还应该安装`psutil`模块（[https://github.com/giampaolo/psutil](https://github.com/giampaolo/psutil)），作为可选依赖项，这将使`memory_profiler`的速度大大提高。'
- en: Just as with `line_profiler`, `memory_profiler` also requires the instrumentation
    of the source code by placing a `@profile` decorator on the function we intend
    to monitor. In our case, we want to analyze the `benchmark` function.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如与`line_profiler`一样，`memory_profiler`也要求通过在我们要监控的函数上放置`@profile`装饰器来对源代码进行仪器化。在我们的例子中，我们想要分析`benchmark`函数。
- en: 'We can slightly change `benchmark` to instantiate a considerable amount (`100000`)
    of `Particle` instances and decrease the simulation time, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微改变`benchmark`来实例化大量的`Particle`实例（`100000`），并减少模拟时间，如下所示：
- en: '[PRE30]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can use `memory_profiler` from an IPython shell through the `%mprun` magic
    command, as shown in the following screenshot:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在IPython shell中使用`%mprun`魔法命令来使用`memory_profiler`，如下面的截图所示：
- en: '![Figure 1.8 – Output from memory_profiler ](img/Figure_1.8_B17499.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – `memory_profiler`的输出](img/Figure_1.8_B17499.jpg)'
- en: Figure 1.8 – Output from memory_profiler
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – `memory_profiler`的输出
- en: It is possible to run `memory_profiler` from the shell using the `mprof run`
    command after adding the `@profile` decorator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了`@profile`装饰器后，可以使用`mprof run`命令从shell中运行`memory_profiler`。
- en: From the `Increment` column, we can see that 100,000 `Particle` objects take
    `23.7 MiB` of memory.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 从`增量`列中，我们可以看到100,000个`粒子`对象占用`23.7 MiB`的内存。
- en: 1 **mebibyte** (**MiB**) is equivalent to 1,048,576 bytes. It is different from
    1 **megabyte** (**MB**), which is equivalent to 1,000,000 bytes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 1 **兆字节**（**MiB**）相当于1,048,576字节。它与1 **兆字节**（**MB**）不同，后者相当于1,000,000字节。
- en: 'We can use `__slots__` on the `Particle` class to reduce its memory footprint.
    This feature saves some memory by avoiding storing the variables of the instance
    in an internal dictionary. This strategy, however, has a small limitation—it prevents
    the addition of attributes other than the ones specified in `__slots__`. You can
    see this feature in use in the following code snippet:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`Particle`类上使用`__slots__`来减少其内存占用。这个特性通过避免在内部字典中存储实例变量来节省一些内存。然而，这种策略有一个小的限制——它阻止添加`__slots__`中未指定的属性。您可以在以下代码片段中看到这个特性的使用：
- en: '[PRE31]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We can now rerun our benchmark to assess the change in memory consumption.
    The result is displayed in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以重新运行我们的基准测试来评估内存消耗的变化。结果如下面的截图所示：
- en: '![Figure 1.9 – Improvement in memory consumption ](img/Figure_1.9_B17499.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 内存消耗的改进](img/Figure_1.9_B17499.jpg)'
- en: Figure 1.9 – Improvement in memory consumption
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 内存消耗的改进
- en: By rewriting the `Particle` class using `__slots__`, we can save about 10 MiB
    of memory.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`__slots__`重写`Particle`类，我们可以节省大约10 MiB的内存。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we introduced the basic principles of optimization and applied
    those principles to a test application. When optimizing an application, the first
    thing to do is test and identify the bottlenecks in the application. We saw how
    to write and time a benchmark using the `time` Unix command, the Python `timeit`
    module, and the full-fledged `pytest-benchmark` package. We learned how to profile
    our application using `cProfile`, `line_profiler`, and `memory_profiler`, and
    how to analyze and navigate the profiling data graphically with KCachegrind.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了优化的基本原理，并将这些原理应用于一个测试应用。在优化一个应用时，首先要做的是测试并识别应用中的瓶颈。我们看到了如何使用`time`
    Unix命令、Python的`timeit`模块以及完整的`pytest-benchmark`包来编写和计时基准测试。我们学习了如何使用`cProfile`、`line_profiler`和`memory_profiler`来分析我们的应用，以及如何使用KCachegrind图形化地分析和导航分析数据。
- en: Speed is undoubtedly an important component of any modern software. The techniques
    we have learned in this chapter will allow you to systematically tackle the problem
    of making your Python programs more efficient from different angles. Further,
    we have seen that these tasks can take advantage of Python built-in/native packages
    and do not require any special external tools.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 速度无疑是任何现代软件的重要组件。在本章中我们学到的技术将使您能够系统地从不同角度解决使Python程序更高效的问题。此外，我们看到了这些任务可以利用Python内置/本地包，而不需要任何特殊的外部工具。
- en: In the next chapter, we will explore how to improve performance using algorithms
    and data structures available in the Python standard library. We will cover scaling
    and sample usage of several data structures, and learn techniques such as caching
    and memorization. We will also introduce Big O notation, which is a common computer
    science tool to analyze the running time of algorithms and data structures.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用Python标准库中可用的算法和数据结构来提高性能。我们将涵盖几个数据结构的扩展和示例用法，并学习诸如缓存和记忆等技术。我们还将介绍大O符号，这是计算机科学中常用的工具，用于分析算法和数据结构的运行时间。
- en: Questions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Arrange the following three items in order of importance when building a software
    application: correctness (the program does what it is supposed to do), efficiency
    (the program is optimized in speed and memory management), and functionality (the
    program runs).'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建软件应用时，按照重要性顺序排列以下三项：正确性（程序执行了它应该执行的操作）、效率（程序在速度和内存管理方面进行了优化）和功能（程序运行）。
- en: How could `assert` statements be used in Python to check for the correctness
    of a program?
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Python中使用`assert`语句来检查程序的正确性？
- en: What is a benchmark in the context of optimizing a software program?
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在优化软件程序的情况下，基准测试是什么？
- en: How could `timeit` magic commands be used in Python to estimate the speed of
    a piece of code?
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何在Python中使用`timeit`魔术命令来估计代码的速度？
- en: List three different types of information that are recorded and returned by
    `cProfile` (included as output columns) in the context of profiling a program.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出在程序分析上下文中，`cProfile`（包括输出列）记录并返回的三种不同类型的信息。
- en: On a high level, what is the role of the `dis` module in optimization?
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在优化的高层次上，`dis`模块在优化中扮演什么角色？
- en: In the `exercise.py` file, we write a simple function, `close()`, that checks
    whether a pair of particles are close to each other (with 1e-5 tolerance). In
    `benchmark()`, we randomly initialize two particles and call `close()` after running
    the simulation. Make a guess of what takes most of the execution time in `close()`,
    and profile the function via `benchmark()` using `cProfile`; does the result confirm
    your guess?
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`exercise.py`文件中，我们编写了一个简单的函数`close()`，该函数检查一对粒子是否彼此靠近（具有1e-5的容差）。在`benchmark()`中，我们随机初始化两个粒子，并在运行模拟后调用`close()`。猜测`close()`中占执行时间最多的是什么，并通过`benchmark()`使用`cProfile`对函数进行剖析；结果是否证实了你的猜测？
- en: Further reading
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Profilers in Python: [https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的分析器：[https://docs.python.org/3/library/profile.html](https://docs.python.org/3/library/profile.html)
- en: 'Using PyCharm''s profiler: [https://www.jetbrains.com/help/pycharm/profiler.html](https://www.jetbrains.com/help/pycharm/profiler.html)'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyCharm的分析器：[https://www.jetbrains.com/help/pycharm/profiler.html](https://www.jetbrains.com/help/pycharm/profiler.html)
- en: 'A beginner-friendly introduction to bytecode in Python: [https://opensource.com/article/18/4/introduction-python-bytecode](https://opensource.com/article/18/4/introduction-python-bytecode)'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python字节码的入门介绍：[https://opensource.com/article/18/4/introduction-python-bytecode](https://opensource.com/article/18/4/introduction-python-bytecode)
