- en: Building Robots
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建机器人
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Building a Rover-Pi robot with forward driving motors
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用前向驱动电机构建Rover-Pi机器人
- en: Using advanced motor control
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用高级电机控制
- en: Building a six-legged Pi-Bug robot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个六足 Pi-Bug 机器人
- en: Controlling servos directly with ServoBlaster
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用 ServoBlaster 控制伺服电机
- en: Avoiding objects and obstacles
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免物体和障碍物
- en: Getting a sense of direction
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获得方向感
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A little computer with a "brain the size of a planet" (to quote Douglas Adams,
    the author of *Hitchhiker's Guide to the Galaxy*) would be perfect as the brain
    of your own robotic creation. In reality, the Raspberry Pi probably provides far
    more processing power than a little robot or rover needs; however, its small size,
    excellent connectivity, and fairly low-power requirements mean that it is ideally
    suited.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一台拥有“像行星一样大的大脑”的小型电脑（引用自道格拉斯·亚当斯所著的《银河系漫游指南》），作为您自己机器人创造的头脑将非常完美。现实中，树莓派可能提供的处理能力远超过一个小型机器人或探测车所需的；然而，其小巧的尺寸、优秀的连接性和相对较低的能量需求意味着它非常适合。
- en: This chapter will focus on exploring the various ways we can combine motors
    or servos to produce robotic movement, use sensors to gather information, and
    allow our creation to act upon it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点探讨我们可以结合电机或伺服机构以产生机器人运动的各种方法，使用传感器来收集信息，并允许我们的创造物对其做出反应。
- en: Be sure to check out the *Appendix,* *Hardware and Software List*; it lists
    all of the items used in this chapter and the places you can obtain them from.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看*附录*，*硬件和软件列表*；它列出了本章中使用的所有物品以及你可以从哪里获取它们。
- en: Building a Rover-Pi robot with forward driving motors
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用前向驱动电机构建Rover-Pi机器人
- en: Creating robots does not need to be an expensive hobby. A small, rover-type
    robot can be constructed using household items for the chassis (the base everything
    is attached to), and a couple of small driving motors can be used to move it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 制作机器人不必是一项昂贵的爱好。可以使用家用物品来构建一个小型、漫游车型的机器人底盘（即所有部件都连接到的基座），并且可以使用几个小型驱动电机来移动它。
- en: 'A Rover-Pi robot is a small, buggy-type robot that has two wheels and a skid
    or caster at the front to allow it to turn. One such robot is shown in the following
    image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Rover-Pi 机器人是一种小型、四足型机器人，它有两个轮子和一个在前端的滑轮或万向轮，以便它能够转向。以下图片展示了一个这样的机器人：
- en: '![](img/bafe4de4-9f36-4a25-ad0e-a4a59bc345d0.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bafe4de4-9f36-4a25-ad0e-a4a59bc345d0.png)'
- en: A home-built Rover-Pi robot
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自制的Rover-Pi机器人
- en: While it may not be in the same league as a Mars exploration rover, as you will
    see, there is plenty for you to experiment with.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它可能无法与火星探测车相提并论，正如您将看到的，您有很多可以实验的内容。
- en: You can also purchase one of many inexpensive robot kits that contain most of
    what you need in a single package (see the *There's more...* section at the end
    of this example).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以购买众多价格低廉的机器人套件之一，这些套件包含您所需的大部分组件，只需一个包装（参见本例末尾的*更多内容...*部分）。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'The rover that we will build will need to contain the elements shown in the
    following diagram:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要建造的探测器需要包含以下图中所示的各种元素：
- en: '![](img/95cd43ca-57d0-4cb8-9f58-cd4b7627a6d1.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/95cd43ca-57d0-4cb8-9f58-cd4b7627a6d1.png)'
- en: The separate parts of the Rover-Pi robot
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Rover-Pi机器人的各个部分
- en: 'The elements are discussed in detail as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 元素将按以下方式详细讨论：
- en: '**Chassis**: This example uses a modified, battery-operated push nightlight
    (although any suitable platform can be used). Remember that the larger and heavier
    your robot is, the more powerful the driving motors will need to be to move it.
    Alternatively, you can use one of the chassis kits listed in the *There''s more...*
    section. A suitable push nightlight is shown in the following photo:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**底盘**: 本例使用了一个经过修改的、电池供电的推式夜灯（尽管可以使用任何合适的平台）。请记住，你的机器人越大、越重，驱动电机就需要越强大才能移动它。或者，你也可以使用在“更多内容...”部分列出的底盘套件之一。以下照片展示了一个合适的推式夜灯：'
- en: '![](img/8c391727-19e1-4f95-a1cb-2c22e2b11a3f.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8c391727-19e1-4f95-a1cb-2c22e2b11a3f.png)'
- en: This push nightlight forms the basic chassis of a Rover-Pi robot
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个推动式夜灯构成了Rover-Pi机器人的基本底盘
- en: '**Front skid or caster**: This can be as simple as a large paper clip (76 mm/3
    inches) bent into shape, or a small caster wheel. A skid works best when it is
    on a smooth surface, but it may get stuck on the carpet. A caster wheel works
    well on all surfaces, but sometimes, it can have problems turning.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前滑或转向轮**: 这可以简单到将一个大的回形针（76 mm/3 英寸）弯曲成形状，或者使用一个小转向轮。滑块在光滑表面上工作时效果最佳，但可能会在地毯上卡住。转向轮在所有表面上都能很好地工作，但有时可能会在转向时出现问题。'
- en: '**Wheels, motors,** **and gears**: The wheel movement of the Rover-Pi robot
    is a combination of the motor, gears, and wheels. The gears are helpful, as they
    allow a fast-spinning motor to turn the wheels at a slower speed and more force
    (torque); this will allow for better control of our robot. A unit that combines
    the wheels, motors, and gears in a single unit is shown in the following photo:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮子、电机、齿轮**：Rover-Pi机器人的轮子运动是电机、齿轮和轮子的组合。齿轮很有帮助，因为它们允许高速旋转的电机以较慢的速度和更大的力量（扭矩）转动轮子；这将使我们能够更好地控制我们的机器人。以下照片展示了将轮子、电机和齿轮组合成单个单元的单元：'
- en: '![](img/c889b0cd-b66c-4320-9c4f-30e407900480.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c889b0cd-b66c-4320-9c4f-30e407900480.png)'
- en: These wheels, with built-in geared motors, are ideal for small rovers
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这些带有内置齿轮电机的轮子非常适合小型漫游车
- en: '**Battery/power source**: The Rover-Pi robot will be powered using four AA
    batteries, fitted into the bay of the chassis. Alternatively, a standard battery
    holder can be used, or even a long wire connected to a suitable power supply.
    It is recommended that you power the motors from a supply independent from the
    Raspberry Pi. This will help to avoid a situation in which the Raspberry Pi suddenly
    loses power when driving the motors, which require a big jump in current to move.
    Alternatively, you can power the Raspberry Pi with the batteries using a 5V regulator.
    The following image shows a chassis with four AA batteries:'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电池/电源**: Rover-Pi 机器人将使用四个 AA 电池供电，这些电池被安装到底盘的凹槽中。另外，可以使用标准的电池夹，或者甚至是一根连接到合适电源的长电线。建议您使用与
    Raspberry Pi 独立的电源为电机供电。这有助于避免在驱动电机时，由于电机需要大电流跳跃来移动，导致 Raspberry Pi 突然断电的情况。另外，您也可以使用
    5V 稳压器用电池为 Raspberry Pi 供电。以下图片展示了一个带有四个 AA 电池的底盘：'
- en: '![](img/e267b815-edb5-4a07-9fce-c463c4fb6e0f.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e267b815-edb5-4a07-9fce-c463c4fb6e0f.png)'
- en: Four AA batteries provide a power source to drive the wheels
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 四节AA电池为驱动轮提供电源
- en: '**Motor driver/controller**: Motors will require a voltage and current greater
    than the GPIO can handle. Therefore, we will use a **Darlington array module**
    (which uses a **ULN2003** chip). See the *There''s more...* section at the end
    of this example for more details on how this particular module works. The following
    photo shows a Darlington array module:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机驱动/控制器**：电机需要比GPIO能够处理的电压和电流更大的电压和电流。因此，我们将使用**达林顿阵列模块**（该模块使用**ULN2003**芯片）。请参阅本例末尾的*更多内容...*部分，以获取有关该特定模块如何工作的更多详细信息。以下照片显示了一个达林顿阵列模块：'
- en: '![](img/89b8f536-48c5-4789-82e6-843f383a4908.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89b8f536-48c5-4789-82e6-843f383a4908.png)'
- en: This Darlington array module, available at http://www.dx.com, can be used to
    drive small motors
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这款达尔顿阵列模块可在http://www.dx.com购买，可用于驱动小型电机
- en: '**Small cable ties or wire ties**: This will allow us to attach items, such
    as a motor or a controller, to the chassis. The following photo shows the use
    of cable ties:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**小型电缆扎带或线扎带**：这将使我们能够将诸如电机或控制器之类的物品固定在底盘上。以下照片展示了电缆扎带的使用：'
- en: '![](img/cbabca2d-a3d8-4ac5-a6a1-fdcf4b410098.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbabca2d-a3d8-4ac5-a6a1-fdcf4b410098.png)'
- en: We use cable ties to secure the motors and wheels to the chassis
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用电缆扎带将电机和轮子固定在底盘上
- en: '**The Raspberry Pi connection**: The easiest setup is to attach the control
    wires to the Raspberry Pi using long cables, so that you can easily control your
    robot directly using an attached screen and keyboard. Later, you can consider
    mounting the Raspberry Pi on the robot and controlling it remotely (or even autonomously,
    if you include sensors and intelligence to make sense of them).'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**树莓派连接**：最简单的设置是将控制线通过长线连接到树莓派上，这样您就可以通过连接的屏幕和键盘轻松直接控制您的机器人。稍后，您可以考虑将树莓派安装在机器人上，并远程（或者甚至自主地，如果您包括传感器和智能来理解它们）控制它。'
- en: In this chapter, we will use the `wiringpi2` Python library to control the GPIO;
    see [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml), *Sensing and Displaying
    Real-World Data*, for details on how to install it using a Python package manager
    (`pip`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用`wiringpi2` Python库来控制GPIO；有关如何使用Python包管理器（`pip`）安装它的详细信息，请参阅[第10章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)，*感知和显示现实世界数据*。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to create a small Rover-Pi robot:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建一个小型Rover-Pi机器人：
- en: At the front of the chassis, you will need to mount the skid by bending the
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底盘前方，您需要通过弯曲来安装滑块
- en: 'paperclip/wire into a V shape. Attach the paperclip/wire to the front of the
    chassis by drilling small holes on either side, threading cable ties through the
    holes around the wire, and pulling tightly to secure. The fitted wire skid should
    look similar to the one shown in the following photo:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将回形针/电线弯成V形。通过在底盘两侧钻小孔，将回形针/电线固定在底盘前方，通过孔将电缆扎带穿过电线周围，并拉紧以固定。安装好的电线滑块应与以下照片中所示类似：
- en: '![](img/15f491a6-7324-409e-bd1f-8c1b5bd4ba56.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/15f491a6-7324-409e-bd1f-8c1b5bd4ba56.png)'
- en: Wire skid fitted to the front of the Rover-Pi robot
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 安装在Rover-Pi机器人前端的电缆滑轨
- en: Before you mount the wheels, you need to work out the approximate center of
    gravity of the chassis (do this with the batteries fitted in the chassis, as they
    will affect the balance). Get a feel of where the center is by trying to balance
    the unit on two fingers on either side and finding out how far forward or backward
    the chassis tilts. For my unit, this was about 1 cm (approximately one-third of
    an inch) back from the center. You should aim to place the wheel axles slightly
    behind this so that the rover will rest slightly forward on the skid. Mark the
    location of the wheels on the chassis.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装车轮之前，你需要计算出底盘的大致重心位置（在底盘内安装电池时进行此操作，因为它们会影响平衡）。通过尝试用两只手指分别平衡底盘，并找出底盘向前或向后倾斜的距离来感受重心的位置。对于我的设备，这个位置大约在中心后1厘米（大约三分之一英寸）。你应该将车轮轴稍微放在这个位置之后，这样漫游车就会稍微向前倾斜在滑板上。在底盘上标记车轮的位置。
- en: 'Drill three holes on each side to mount the wheels using the cable ties. If
    the cable ties aren''t long enough, you can join two together by pulling the end
    of one through the end of the other (only pull through far enough for the tie
    to grip so that it extends the tie). The following diagram shows how you can use
    the cable ties:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每侧钻三个孔，使用电缆扎带安装车轮。如果电缆扎带不够长，你可以通过将一个扎带的末端穿过另一个扎带的末端来连接它们（只拉到扎带能够抓住的程度，以便延长扎带）。以下图示展示了如何使用电缆扎带：
- en: '![](img/865c1168-1f2a-4f4c-824f-fd9670b66fab.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/865c1168-1f2a-4f4c-824f-fd9670b66fab.png)'
- en: Securely fix the motors to the chassis
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将电机牢固地固定在底盘上
- en: Next, test the motors by inserting the batteries into the unit; then, disconnect
    the wires that originally connected to the bulb, and touch them to the motor contacts.
    Determine which connection on the motor should be positive and which should be
    negative for the motor to move the robot forward (the top of the wheel should
    move forward when the robot is facing forwards). Connect red and black wires to
    the motor (on mine, black equals negative at the top of the motor, and red equals
    positive at the bottom), ensuring that the wires are long enough to reach anywhere
    on the chassis (around 14 cm, that is, approximately 5.5 inches, is enough for
    the nightlight).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过将电池插入单元来测试电机；然后，断开原本连接到灯泡的电线，并将它们接触到电机触点上。确定电机上哪个连接应该是正极，哪个应该是负极，以便电机使机器人向前移动（当机器人面向前方时，轮子的顶部应该向前移动）。将红色和黑色电线连接到电机上（在我的电机上，黑色在电机顶部代表负极，红色在底部代表正极），确保电线足够长，可以到达底盘上的任何位置（大约14厘米，即约5.5英寸，对于夜灯来说已经足够了）。
- en: 'The Rover-Pi robot components should be wired up as shown in the following
    diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 罗伏-派机器人组件应按照以下图示进行接线：
- en: '![](img/656be4cb-1881-424a-a309-1648d435aa04.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/656be4cb-1881-424a-a309-1648d435aa04.png)'
- en: The wiring layout of the Rover-Pi robot
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Rover-Pi机器人的布线布局
- en: 'To make the connections, perform the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了建立联系，请执行以下步骤：
- en: Connect the black wires of the motors to the **OUT 1** (left) and **OUT 2**
    (right) output of the Darlington module, and connect the red wires to the last
    pin (the COM connection).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电机的黑色线连接到达林顿模块的**OUT 1**（左侧）和**OUT 2**（右侧）输出，并将红色线连接到最后一个引脚（COM连接）。
- en: Next, connect the battery wires to the **GND**/**V-** and **V+** connections
    at the bottom of the module.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将电池线连接到模块底部的**GND**/**V-**和**V+**连接处。
- en: Finally, connect the **GND** from the GPIO connector (**Pin 6**) to the same
    **GND** connection.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将GPIO连接器（**引脚6**）的**GND**连接到相同的**GND**连接。
- en: Test the motor control by connecting 3.3V (GPIO **Pin 1**) to **IN1** or **IN2,**
    to simulate a GPIO output. When you're happy, connect GPIO **Pin 16** to **IN1**
    (for left) and GPIO **Pin 18** to **IN2** (for right).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将3.3V（GPIO **Pin 1**）连接到**IN1**或**IN2**来测试电机控制，以模拟GPIO输出。当你满意时，将GPIO **Pin
    16**连接到**IN1**（用于左侧）和GPIO **Pin 18**连接到**IN2**（用于右侧）。
- en: 'The wiring should now match the details given in the following table:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 线路现在应与以下表格中给出的细节相匹配：
- en: '| **Raspberry Pi GPIO** | **Darlington module** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派GPIO** | **达林顿模块** |'
- en: '| --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Pin 16: Left | IN1 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 16：左侧 | IN1 |'
- en: '| Pin 18: Right | IN2 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 18：右 | IN2 |'
- en: '| Pin 6: GND | GND/V- (marked with -) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 6: GND | GND/V-（标记为 -） |'
- en: '| **Motor 4 x AA battery Darlington module** |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| **4 x AA电池达林顿模块** |  |'
- en: '| Positive side of battery | V+ (marked with +) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 电池的正面 | V+（标记为+） |'
- en: '| Negative side of battery | GND/V- (marked with -) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 电池的负面 | GND/V-（标记为-） |'
- en: '| **Motors** |  |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **电机** |  |'
- en: '| Left motor: black wire | OUT 1 (top pin in white socket) |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 左电机：黑色电线 | OUT 1（白色插座中的顶部插针） |'
- en: '| Right motor: black wire | OUT 2 (second pin in white socket) |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 右侧电机：黑色电线 | OUT 2（白色插座中的第二个插孔） |'
- en: '| Both motors: red wires | COM (last pin in white socket) |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 两个电机：红色电线 | COM（白色插座中的最后一个引脚） |'
- en: 'Use the following `rover_drivefwd.py` script to test the control:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 `rover_drivefwd.py` 脚本进行控制测试：
- en: '[PRE0]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Remember that `wiringpi2` should be installed before running the scripts in
    this chapter (see [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*, Sensing
    and Displaying Real-World Data*).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 记住在使用本章中的脚本之前应该安装`wiringpi2`（参见[第10章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*，感知和显示现实世界数据*）。
- en: 'Run the previous code using the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行前面的代码：
- en: '[PRE1]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The script will prompt you with the following message:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本将提示您以下信息：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can enter a series of commands to follow; for example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以输入一系列命令来执行；例如：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding command will instruct the Rover-Pi robot to perform a series
    of movements: forward (`f`), right (`r`), pause (`#`), and left (`l`).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令将指导Rover-Pi机器人执行一系列动作：前进（`f`）、向右（`r`）、暂停（`#`）和向左（`l`）。
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once you have built the robot and wired up the wheels to the motor controller,
    you can work out how to control it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你搭建好机器人并将轮子连接到电机控制器，你就可以研究如何控制它。
- en: Start by importing `time` (which will allow you to put pauses in the motor control)
    and `wiringpi2` (to allow control of the GPIO pins). Use `wiringpi2` here, since
    it makes it much easier to make use of I/O expanders and other I²C devices, if
    you want to later on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先导入`time`模块（这将允许你在电机控制中添加暂停）和`wiringpi2`模块（以允许控制GPIO引脚）。在这里使用`wiringpi2`，因为它使得使用I/O扩展器和其他I²C设备变得更加容易，如果你以后需要的话。
- en: Define values to use for setting the pins `ON`/`OFF`, for the direction `IN`/`OUT`,
    as well as the duration of each motor `STEP`. Also, define which `PINS` are wired
    to the motor controls, and our movements, `FWD`, `RIGHT`, and `LEFT`. The movement
    is defined in such a way that by switching both motors `ON`, you will move forward,
    and by switching just one motor `ON`, you will turn. By setting these values at
    the start of the file using variables, our code is easier to maintain and understand.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 定义用于设置引脚`ON`/`OFF`、方向`IN`/`OUT`以及每个电机`STEP`持续时间的值。同时，定义哪些`PINS`连接到电机控制，以及我们的移动，`FWD`、`RIGHT`和`LEFT`。移动的定义方式是，通过同时开启两个电机，你会向前移动，而只开启一个电机，你会转向。通过在文件开头使用变量设置这些值，我们的代码更容易维护和理解。
- en: We define a `motor` class that will allow us to reuse it in other code, or easily
    swap it with alternative `motor` classes so that we can use other hardware if
    we want to. We set the default pins we are using and our `steptime` value (the
    `steptime` object defines how long we drive the motor(s) for in each step). However,
    both can still be specified when initializing the object, if desired.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个`motor`类，这将允许我们在其他代码中重用它，或者轻松地将其与替代的`motor`类进行交换，以便如果我们想使用其他硬件时可以使用。我们设置了我们正在使用的默认引脚和我们的`steptime`值（`steptime`对象定义了在每一步中我们驱动电机（s）的时间）。然而，如果需要，这两个值在初始化对象时仍然可以指定。
- en: Next, we call `GPIOsetup()`; it selects the physical pin numbering mode (so
    we can refer to the pins as they are located on the board). We also set all of
    the pins we are using to output.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 `GPIOsetup()`；它选择物理引脚编号模式（因此我们可以按照它们在板上的位置来引用引脚）。我们还设置我们使用的所有引脚为输出模式。
- en: 'Finally, for the `motor` class, we define the following three functions:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`电机`类，我们定义了以下三个函数：
- en: The first function we define (called `off()`) will allow us to switch off the
    motors, so we cycle through the pins list and set each GPIO pin to low (and therefore
    switch the motors off).
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义的第一个函数（称为`off()`）将允许我们关闭电机，因此我们将遍历引脚列表并将每个GPIO引脚设置为低电平（从而关闭电机）。
- en: The `drive()` function allows us to provide a list of drive actions (a combination
    of `ON` and `OFF` for each of the GPIO pins). Again, we cycle through each of
    the pins and set them to the corresponding drive action, wait for the step time,
    and then switch the motors off using the `off()` function.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drive()` 函数允许我们提供一组驱动动作列表（每个 GPIO 引脚的 `ON` 和 `OFF` 组合）。同样，我们遍历每个引脚，并将它们设置为相应的驱动动作，等待步进时间，然后使用
    `off()` 函数关闭电机。'
- en: The last function we define (called `cmd()`) simply allows us to send `char`
    (a single character) and use it to select the set of drive actions we want to
    use (`FWD`, `RIGHT` or `LEFT`, or wait (`#`)).
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义的最后一个函数（称为`cmd()`）仅仅允许我们发送`char`（单个字符）并使用它来选择我们想要使用的驱动动作集合（`FWD`、`RIGHT`或`LEFT`，或者等待（`#`））。
- en: 'For testing, `main()` allows us to specify a list of actions that need to be
    performed from the command line using the following command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，`main()` 允许我们使用以下命令从命令行指定需要执行的一系列操作：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Using `os.environ` (by importing the `os` module so we can use it), we can check
    for `CMD` in the command and use it as our list of drive actions. If no `CMD`
    command has been provided, we can use the `input()` function to directly prompt
    for a list of drive actions. To use the `motor` class, we set `roverPi=motor()`;
    this allows us to call the `cmd()` function (of the motor class) with each character
    from the list of drive actions.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `os.environ`（通过导入 `os` 模块以便使用它），我们可以在命令中检查 `CMD`，并将其用作我们的驱动动作列表。如果没有提供 `CMD`
    命令，我们可以使用 `input()` 函数直接提示输入驱动动作列表。要使用 `motor` 类，我们设置 `roverPi=motor()`；这允许我们使用驱动动作列表中的每个字符调用（电机类的）`cmd()`
    函数。
- en: There's more...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Your robot should be limited only by your own creativity. There are lots of
    suitable chassis options, other motors, wheels, and ways to control and drive
    the wheels. You should experiment and test things to determine which combinations
    work best together. That is all part of the fun!
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你的机器人应该只受限于你自己的创造力。有许多合适的底盘选项、其他电机、轮子和控制及驱动轮子的方式。你应该进行实验和测试，以确定哪些组合效果最佳。这些都是乐趣的一部分！
- en: Darlington array circuits
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 达尔林顿阵列电路
- en: Darlington transistors are a low-cost way to drive high powered devices, such
    as motors, or even relays. They consist of two transistors arranged in a series,
    where one feeds the other (allowing the gain in the current to be multiplied).
    That is, if the first transistor has a gain of 20, and the second one also has
    a gain of 20, together, they will provide an overall gain of 400.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 达尔林顿晶体管是一种驱动高功率设备（如电机或甚至继电器）的低成本方法。它们由两个串联排列的晶体管组成，其中一个晶体管向另一个晶体管供电（允许电流增益相乘）。也就是说，如果第一个晶体管的增益为20，第二个晶体管的增益也为20，那么它们共同将提供400的总增益。
- en: 'This means that 1 mA on the base pin (1) in the following diagram will allow
    you to drive up to 400 mA through the Darlington transistor. The Darlington transistor''s
    electrical symbol is shown in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在以下图中，基极引脚（1）上的1 mA电流可以使你通过达林顿晶体管驱动高达400 mA的电流。达林顿晶体管的电气符号在以下图中显示：
- en: '![](img/191e59cf-7f88-477c-8a19-aea25cd5e912.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/191e59cf-7f88-477c-8a19-aea25cd5e912.png)'
- en: The electrical symbol for a Darlington transistor shows how two transistors
    are packaged together
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 达林顿晶体管的电气符号展示了两个晶体管是如何封装在一起的
- en: 'The ULN2003 chip is used in the previous module and provides seven NPN Darlington
    transistors (an eight-way version, ULN2803, is also available if more output is
    required or to use with two stepper motors). The following diagram shows how a
    Darlington array can be used to drive motors:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ULN2003芯片在之前的模块中使用，并提供七个NPN达林顿晶体管（如果需要更多输出或与两个步进电机一起使用，还可以使用八通道版本，即ULN2803）。以下图示展示了如何使用达林顿阵列来驱动电机：
- en: '![](img/d26fc7b8-0679-423e-950f-92f6079a2ada.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d26fc7b8-0679-423e-950f-92f6079a2ada.png)'
- en: A Darlington array being used to drive two small motors
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用达林顿阵列驱动两个小型电机
- en: Each output from the chip can supply a maximum of 500 mA at up to 50V (enough
    to power most small motors). However, with extended use, the chip may overheat,
    so a heat sink is recommended when driving larger motors. An internal diode, connected
    across each Darlington for protection, is built into the chip. This is needed
    because when the motor moves without being driven (this can occur due to the natural
    momentum of the motor), it will act like a generator. A reverse voltage called
    **back EMF** is created, which would destroy the transistor if it wasn't dissipated
    back through the diode.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片每个输出端可提供最大500 mA的电流，电压高达50V（足以驱动大多数小型电机）。然而，随着使用时间的延长，芯片可能会过热，因此在驱动大型电机时建议使用散热片。芯片内部集成了用于保护的二极管，每个达林顿晶体管之间都连接了一个。这是必要的，因为当电机在没有驱动的情况下移动时（这可能是由于电机的自然惯性引起的），它会像一个发电机一样工作。会产生一个称为**反电动势**的逆电压，如果不通过二极管耗散，将会损坏晶体管。
- en: One disadvantage of the chip is that the positive supply voltage must always
    be connected to the common pin (COM), so each output is only able to sink current.
    That is, it will only drive the motor in one direction, with the positive voltage
    on COM and the negative voltage on the OUT pins. Therefore, we will need a different
    solution if we wish to drive our Rover-Pi robot in different directions (see the
    next example in the *Using advanced motor control* recipe).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 芯片的一个缺点是正电源电压必须始终连接到公共引脚（COM），因此每个输出只能吸收电流。也就是说，它只能驱动电机单向运行，COM引脚上为正电压，OUT引脚上为负电压。因此，如果我们希望以不同的方向驱动我们的Rover-Pi机器人，我们需要一个不同的解决方案（参见*使用高级电机控制*菜谱中的下一个示例）。
- en: These chips can also be used to drive certain types of stepper motors. One of
    the modules from [http://www.dx.com](http://www.dx.com) includes a stepper motor
    as a part of the kit. Although the gearing is for very slow movement, at around
    12 seconds per rotation (too slow for a rover), it is still interesting to use
    (for a clock, perhaps).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些芯片也可以用来驱动某些类型的步进电机。来自[http://www.dx.com](http://www.dx.com)的一个模块将步进电机作为套件的一部分。尽管齿轮是为了非常缓慢的运动设计的，大约每转12秒（对于漫游车来说太慢了），但对于时钟来说仍然很有趣（或许）。
- en: Transistor and relay circuits
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 晶体管和继电器电路
- en: Relays are able to handle much more highly powered motors, since they are mechanical
    switches controlled by an electromagnetic coil that physically moves the contacts
    together. However, they require a reasonable amount of current to be turned on
    – usually more than 3.3V. To switch even small relays, we need around 60 mA at
    5V (more than is available from the GPIO), so we will still need to use some additional
    components to switch it.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 继电器能够处理功率更高的电机，因为它们是由电磁线圈控制的机械开关，该线圈会物理地移动触点。然而，它们需要相当大的电流才能开启——通常超过3.3V。为了切换即使是小型的继电器，我们需要大约60
    mA的5V电流（这超过了GPIO提供的电流），因此我们仍然需要使用一些额外的组件来切换它。
- en: 'We can use the Darlington array (as used previously) or a small transistor
    (any small transistor, such as the 2N2222, will be fine) to provide the current
    and voltage required to switch it. The following circuit will allow us to do that:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用达林顿阵列（如之前所述）或一个小型晶体管（任何小型晶体管，例如2N2222，都将是合适的）来提供切换所需的电流和电压。以下电路将使我们能够做到这一点：
- en: '![](img/d0503f39-881f-4f37-9084-64bbdc8a4bde.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0503f39-881f-4f37-9084-64bbdc8a4bde.png)'
- en: The transistor and relay circuit used to drive external circuits
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 用于驱动外部电路的晶体管和继电器电路
- en: Much like a motor, a relay can also generate EMF spikes, so a protection diode
    is needed to avoid any reverse voltage on the transistor.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 就像电机一样，继电器也可以产生电磁感应峰值，因此需要一个保护二极管来避免晶体管上出现任何反向电压。
- en: This is a very useful circuit, not just for driving motors, but for any external
    circuit; the physical switch allows it to be independent and electrically isolated
    from the Raspberry Pi controlling it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的电路，不仅适用于驱动电机，而且适用于任何外部电路；物理开关允许它与控制它的Raspberry Pi独立且电隔离。
- en: As long as the relay is rated correctly, you can drive DC or AC devices through
    it.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 只要正确选择继电器，您就可以通过它驱动直流或交流设备。
- en: You can use some relays to control items powered by the mains. However, this
    should be done only with extreme caution and proper electrical training. Electricity
    from the mains can kill or cause serious harm.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用一些继电器来控制由主电源供电的设备。然而，这只能非常谨慎地进行，并且需要适当的电气培训。主电源的电力可能致命或造成严重伤害。
- en: PiBorg has a ready-made module named the **PicoBorg** that will allow the switching
    of up to four relays. It uses devices called **metal-oxide-semiconductor field-effect
    transistor** (**MOSFETs**), which are essentially high-power versions of transistors
    that function with the same principle as discussed previously.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: PiBorg 拥有一个名为 **PicoBorg** 的现成模块，该模块允许切换多达四个继电器。它使用被称为 **金属氧化物半导体场效应晶体管** (**MOSFETs**)
    的设备，这些设备本质上是在之前讨论过的相同原理下工作的晶体管的高功率版本。
- en: Tethered or untethered robots
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绑定或非绑定机器人
- en: An important choice when designing your own Rover-Pi robot is to decide if you
    want to make it fully self-contained, or if you are happy to have a tether (a
    long control/power cable connected to the Rover-Pi). Using a tether, you can keep
    the weight of the Rover-Pi robot down, which means the small motors will be able
    to move the unit with ease. This will allow you to keep the Raspberry Pi separate
    from the main unit so that it can remain connected to a screen and keyboard for
    easy programming and debugging. The main disadvantage is that you will need a
    long, umbilical-like connection to your Rover-Pi robot (with a wire for each control
    signal) that may impede its movement. However, as we will see later, you may only
    need three or four wires to provide all of the control you need (see the *Using
    I/O expanders* section in the next recipe).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计自己的Rover-Pi机器人时，一个重要的选择是决定你是否希望使其完全独立，或者你是否愿意有一个连接（一根连接到Rover-Pi的长控制/电源电缆）。使用连接线，你可以降低Rover-Pi机器人的重量，这意味着小型电机可以轻松地移动单元。这将允许你将Raspberry
    Pi与主单元分开，以便它可以连接到屏幕和键盘，便于编程和调试。主要的缺点是，你将需要一个长长的脐带状连接到你的Rover-Pi机器人（每个控制信号都有一根线），这可能会阻碍其移动。然而，正如我们稍后将会看到的，你可能只需要三根或四根线就能提供你所需要的所有控制（参见下一道菜谱中的*使用I/O扩展器*部分）。
- en: If you intend to mount the Raspberry Pi directly on the Rover-Pi robot, you
    will need a suitable power supply, such as a phone charger battery pack. If the
    battery pack has two USB ports, then you may be able to use it as a power source
    to drive both the Raspberry Pi and the motors. The unit must be able to maintain
    the supplies independently, as any power spike caused by driving the motors could
    reset the Raspberry Pi.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算直接将 Raspberry Pi 安装在 Rover-Pi 机器人上，你需要一个合适的电源，例如手机充电电池组。如果电池组有两个 USB 端口，那么你可能能够将其用作电源来驱动
    Raspberry Pi 和电机。该单元必须能够独立维持供应，因为驱动电机可能引起的任何电源尖峰都可能导致 Raspberry Pi 重置。
- en: Remember that if the Raspberry Pi is now attached to the robot, you will need
    a means to control it. This could be a USB Wi-Fi dongle that allows a remote connection
    via SSH (and so on), or a wireless keyboard (that uses RF/Bluetooth), or even
    the GPIO D-Pad from [Chapter 9](7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml)*,*
    *Using Python to Drive Hardware*, which can be used for direct control.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果树莓派现在连接到了机器人，你需要一种控制它的方法。这可能是一个允许通过SSH远程连接的USB Wi-Fi外置设备（等等），或者是一个使用RF/蓝牙的无线键盘，甚至可以是来自[第9章](7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml)*,*
    *使用Python驱动硬件*中的GPIO D-Pad，它可以用来进行直接控制。
- en: 'However, the more you mount on the chassis, the harder the motors will need
    to work to move. You may find that stronger motors are required, rather than the
    little ones used here. A Rover-Pi robot powered by a USB battery pack is shown
    in the following photo:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你安装在底盘上的东西越多，电机就需要更努力地工作才能移动。你可能发现需要更强的电机，而不是这里使用的那些小电机。以下照片展示了一个由USB电池组供电的Rover-Pi机器人：
- en: '![](img/cd3e2b82-820b-4567-8188-4dfbf9c5f28b.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cd3e2b82-820b-4567-8188-4dfbf9c5f28b.png)'
- en: A battery-powered Raspberry Rover-Pi robot being controlled via Wi-Fi (cable
    management is optional)
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 一款由电池供电的Raspberry Rover-Pi机器人，可通过Wi-Fi（可选电缆管理）进行控制
- en: Rover kits
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索者套件
- en: 'If you don''t fancy making your own chassis, there are also a number of pre-made
    rover chassis available. They are as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想自己制作底盘，也有许多现成的漫游车底盘可供选择。具体如下：
- en: 2WD Magician Robot Chassis from [https://www.sparkfun.com/](https://www.sparkfun.com/)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [https://www.sparkfun.com/](https://www.sparkfun.com/) 的 2WD 魔术师机器人底盘
- en: 4-Motor Smart Car Chassis from [http://www.dx.com/](http://www.dx.com/)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4-Motor Smart Car Chassis from [http://www.dx.com/](http://www.dx.com/)
- en: 2-Wheel Smart Car Model from [http://www.dx.com/](http://www.dx.com/)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 [http://www.dx.com/](http://www.dx.com/) 的 2-Wheel 智能汽车模型
- en: '![](img/9b82efda-c4a1-4664-b20b-89df3bd606cc.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b82efda-c4a1-4664-b20b-89df3bd606cc.png)'
- en: The TiddlyBot shows how multiple components can be integrated together within
    a single platform, as shown in my modified version
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: TiddlyBot 展示了如何在单个平台上集成多个组件，正如我在修改版本中所展示的那样
- en: A particularly nice robot setup is the TiddlyBot (from [http://www.PiBot.org](http://www.PiBot.org)),
    which combines multiple sensors, continuous servos, an onboard battery pack, and
    the Raspberry Pi camera. An SD card is set up so the TiddlyBot acts as a Wi-Fi
    hotspot, hosting a simple drag and drop programming platform with a remote control
    interface.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特别出色的机器人设置是TiddlyBot（来自[http://www.PiBot.org](http://www.PiBot.org)），它集成了多个传感器、连续伺服系统、内置电池组和Raspberry
    Pi摄像头。SD卡已设置，使TiddlyBot充当Wi-Fi热点，提供带有远程控制界面的简单拖放编程平台。
- en: 'This shows how simple components such as the ones described in this chapter
    can be combined into a complete system:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了如何将本章描述的简单组件组合成一个完整的系统：
- en: '![](img/30dba40d-cbf7-40e9-8848-52235a04ab63.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/30dba40d-cbf7-40e9-8848-52235a04ab63.png)'
- en: The TiddlyBot GUI provides a cross-platform drag and drop interface, as well
    as Python support
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: TiddlyBot 图形用户界面提供了一个跨平台的拖放界面，以及 Python 支持
- en: Be sure to check out the *Appendix,* *Hardware and Software List*; it lists
    all of the items used in this chapter and the places you can obtain them from.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要查看*附录*，*硬件和软件列表*；它列出了本章中使用的所有物品以及你可以从哪里获取它们。
- en: Using advanced motor control
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用高级电机控制
- en: The previous driving circuits are not suitable for driving motors in more than
    one direction (as they only switch the motor on or off). However, using a circuit
    named an H-bridge, you can switch and control the motor's direction, too.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的驱动电路不适用于驱动多方向运行的电机（因为它们只能控制电机的开启或关闭）。然而，使用名为H桥的电路，你还可以切换和控制电机的方向。
- en: 'The switch combinations are shown in the following diagram:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 开关组合在以下图中展示：
- en: '![](img/881f7600-1cd8-424b-825b-c7ba093b61ae.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/881f7600-1cd8-424b-825b-c7ba093b61ae.png)'
- en: The direction of the motor can be controlled by different switch combinations
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 电机方向可以通过不同的开关组合来控制
- en: Using a different combination of switching, we can change the direction of the
    motor by switching the positive and negative supply to the motor (**SW1** and
    **SW4** activate the motor, and **SW2** and **SW3** reverse the motor). However,
    not only do we need four switching devices for each motor, but since the ULN2X03
    devices and PiBorg's PicoBorg module can only sink current, equivalent devices
    would be required to source current (to make up the top section of switches).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用不同的切换组合，我们可以通过切换电机的正负电源来改变电机的方向（**SW1** 和 **SW4** 激活电机，而 **SW2** 和 **SW3**
    使电机反转）。然而，我们不仅需要为每个电机配备四个切换装置，而且由于 ULN2X03 设备和 PiBorg 的 PicoBorg 模块只能吸收电流，因此还需要等效的设备来提供电流（以构成开关的上部部分）。
- en: Fortunately, there are purpose-built H-bridge chips, such as L298N, that contain
    the previous circuit inside them to provide a powerful and convenient way to control
    motors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，存在专门设计的H桥芯片，例如L298N，它们内部包含之前的电路，从而提供了一种强大且便捷的方式来控制电机。
- en: Getting ready
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'We shall replace the previous Darlington array module with the H-bridge motor
    controller shown in the following image:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用以下图片中显示的H桥电机控制器替换之前的达林顿阵列模块：
- en: '![](img/f87ecfb3-c480-432a-960c-98b82371d5b5.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f87ecfb3-c480-432a-960c-98b82371d5b5.png)'
- en: The H-bridge motor controller allows for directional control of motors
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: H桥电机控制器允许对电机进行方向控制
- en: The datasheet of L298N is available at [http://www.st.com/resource/en/datasheet/l298.pdf](http://www.st.com/resource/en/datasheet/l298.pdf).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: L298N的数据表可在[http://www.st.com/resource/en/datasheet/l298.pdf](http://www.st.com/resource/en/datasheet/l298.pdf)获取。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The unit will need to be wired as follows (this will be similar for other H-bridge
    type controllers, but check with the relevant datasheet if unsure).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该单元需要按照以下方式接线（这与其他类型的H-bridge控制器类似，但如有疑问，请查阅相关数据表）。
- en: 'The following table shows how the motors and motor power supply connect to
    the H-bridge controller module:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了电机和电机电源如何连接到H桥控制器模块：
- en: '| **The motor side of the module – connecting to the battery and motors** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **模块的电机侧 – 连接到电池和电机** |'
- en: '| **Motor A** | **VMS** | **GND** | **5V OUT** | **Motor B** |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **电机A** | **VMS** | **地** | **5V 输出** | **电机B** |'
- en: '| Left motor red wire | Left motor black wire | Battery positive | Battery
    GND | None | Right motor red wire | Right motor black wire |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 左电机红色线 | 左电机黑色线 | 电池正极 | 电池地线 | 无 | 右电机红色线 | 右电机黑色线 |'
- en: 'The following table shows how the H-bridge controller module connects to the
    Raspberry Pi:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了H桥控制器模块如何连接到树莓派：
- en: '| **Control side of the module – connecting to the Raspberry Pi GPIO header**
    |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| **模块控制端 – 连接到树莓派GPIO引脚头** |'
- en: '| **ENA** | **IN1** | **IN2** | **IN3** | **IN4** | **ENB** | **GND** | **5V**
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| **ENA** | **IN1** | **IN2** | **IN3** | **IN4** | **ENB** | **GND** | **5V**
    |'
- en: '| None | Pin 15 | Pin 16 | Pin 18 | Pin 22 | None | Pin 6 | None |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 引脚 15 | 引脚 16 | 引脚 18 | 引脚 22 | 无 | 引脚 6 | 无 |'
- en: It is recommended that you keep the pull-up resistor jumpers on (UR1-UR4) and
    allow the motor supply to power the onboard voltage regulator, which will in turn
    power the L298N controller (jumper 5V_EN). The onboard regulator (the 78M05 device)
    can supply up to 500 mA, enough for the L298N controller plus any additional circuits,
    such as an I/O expander (see the *There's more...* section for more information).
    Both the ENA and ENB pins should be disconnected (the motor output will stay enabled
    by default).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您保持上拉电阻跳线（UR1-UR4）开启状态，并允许电机电源为板载电压调节器供电，该调节器反过来将为L298N控制器（跳线5V_EN）供电。板载调节器（78M05器件）可提供高达500
    mA的电流，足以满足L298N控制器以及任何额外的电路，例如I/O扩展器（更多信息请参阅*更多内容...*部分）。ENA和ENB引脚应断开连接（默认情况下，电机输出将保持启用状态）。
- en: You will need to make the following changes to the previous `rover_drivefwd.py`
    script (you can save it as `rover_drive.py`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要对之前的 `rover_drivefwd.py` 脚本进行以下修改（您可以将其保存为 `rover_drive.py`）。
- en: 'At the top of the file, redefine `PINS`, as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部，重新定义`PINS`，如下所示：
- en: '[PRE5]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And update the control patterns, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并更新控制模式，如下所示：
- en: '[PRE6]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need to add the backwards command to `cmd()`, as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将反向命令添加到`cmd()`函数中，如下所示：
- en: '[PRE7]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we can update the prompt that we have within the `main()` function
    to include `b` (backwards) as an option, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在`main()`函数内部的提示中添加`b`（反向）作为一个选项，如下所示：
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The H-bridge motor controller recreates the previous switching circuit with
    additional circuitry to ensure that the electronic switches cannot create a short
    circuit (by not allowing **SW1** and **SW3** or **SW2** and **SW4** to be enabled
    at the same time).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: H桥电机控制器通过增加额外的电路来重现先前的开关电路，以确保电子开关不会造成短路（通过不允许**SW1**和**SW3**或**SW2**和**SW4**同时启用）。
- en: 'The H-bridge motor controller''s switching circuit is shown in the following
    diagram:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: H-桥电机控制器的开关电路如下所示：
- en: '![](img/af7d428f-5369-4292-87cd-9f650af08322.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/af7d428f-5369-4292-87cd-9f650af08322.png)'
- en: An approximation of the H-bridge switching circuit (in motor off state)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: H-桥开关电路的近似（在电机关闭状态下）
- en: 'The input (**IN1** and **IN2**) will produce the following action on the motors:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输入（**IN1** 和 **IN2**）将在电机上产生以下动作：
- en: '| **IN1****IN2** | **0** | **1** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **IN1****IN2** | **0** | **1** |'
- en: '| 0 | Motor off | Motor backwards |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 电机关闭 | 电机倒退 |'
- en: '| 1 | Motor forwards | Motor off |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 电机前进 | 电机关闭 |'
- en: As we did in the previous recipe, we can move forward by driving both motors
    forward; however, now we can drive them both backwards (to move backwards), as
    well as in opposite directions (allowing us to turn the Rover-Pi robot on the
    spot).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一道菜谱中所做的那样，我们可以通过同时驱动两个电机向前移动；然而，现在我们还可以将它们都向后驱动（以向后移动），以及以相反的方向驱动（使我们能够原地转动Rover-Pi机器人）。
- en: There's more...
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can achieve finer control of the motors using a **pulse width modulated**
    (**PWM**) signal and expand the available input/output using an I/O expander.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**脉冲宽度调制**（**PWM**）信号来对电机实现更精细的控制，并使用I/O扩展器来扩展可用的输入/输出。
- en: Motor speed control using PWM control
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PWM控制进行电机速度控制
- en: 'Currently, the Rover-Pi robot motors are controlled by being switched on and
    off; however, if the robot is moving too fast (for example, if you have fitted
    bigger motors or used higher gearing), we can make use of the **ENA** and **ENB**
    input on the controller. If these are set low, the motor output is disabled, and
    if set high, it is enabled again. Therefore, by driving them with a PWM signal,
    we can control the speed of the motors. We could even set slightly different PWM
    rates (if required) to compensate for any differences in the motors/wheels or
    surface to drive them at slightly different speeds, as shown in the following
    diagram:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Rover-Pi机器人的电机是通过开关控制来控制的；然而，如果机器人移动速度过快（例如，如果你安装了更大的电机或使用了更高的齿轮比），我们可以利用控制器上的**ENA**和**ENB**输入。如果这些设置较低，则禁用电机输出，如果设置为高，则再次启用。因此，通过用PWM信号驱动它们，我们可以控制电机的速度。我们甚至可以设置略微不同的PWM速率（如果需要），以补偿电机/车轮或表面的任何差异，从而以略微不同的速度驱动它们，如下面的图示所示：
- en: '![](img/8e07deb5-6fa5-4f0e-9758-fd94920bc0d4.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e07deb5-6fa5-4f0e-9758-fd94920bc0d4.png)'
- en: A PWM signal controls the ratio of the ON and OFF times
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: PWM信号控制着开启和关闭时间的比例
- en: A PWM signal is a digital on/off signal that has different amounts of **ON**
    time compared to **OFF** time. A motor driven with a 50:50, `ON:OFF` signal would
    drive a motor with half the power of an ON signal at 100 percent, and would therefore
    run more slowly. Using different ratios, we can drive the motors at different
    speeds.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: PWM信号是一种数字式的开/关信号，其**开**时间与**关**时间不同。使用50:50的`开:关`信号的电机驱动将使电机以100%开信号功率的一半运行，因此运行速度会较慢。通过使用不同的比率，我们可以使电机以不同的速度运行。
- en: We can use the hardware PWM of the Raspberry Pi (GPIO pin 12 can use the PWM
    driver).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用树莓派的硬件PWM（GPIO引脚12可以使用PWM驱动器）。
- en: The PWM driver normally provides one of the audio channels of the analog audio
    output. Sometimes, this generates interference; therefore, it is suggested that
    you disconnect any devices connected to the analog audio socket.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: PWM 驱动器通常提供模拟音频输出的一个音频通道。有时，这会产生干扰；因此，建议您断开连接到模拟音频插座的任何设备。
- en: 'The hardware PWM function is enabled in `wiringpi2` by setting the pin mode
    to `2` (which is the value of `PWM`) and specifying the on time (represented as
    `ON_TIME`) as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`wiringpi2`中通过将引脚模式设置为`2`（即`PWM`的值）并指定开启时间（表示为`ON_TIME`）如下启用硬件PWM功能：
- en: '[PRE9]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: However, this is only suitable for joint PWM motor control (as it is connected
    to both ENA and ENB), since there is only the one available hardware PWM output.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仅适用于联合PWM电机控制（因为它连接到ENA和ENB），因为只有一个可用的硬件PWM输出。
- en: 'Another alternative is to use the software PWM function of `wiringpi2`. This
    creates a crude PWM signal using software; depending on your requirements, this
    may be acceptable. The code for generating a software PWM signal on GPIO Pin 7
    and GPIO Pin 11 is as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用`wiringpi2`的软件PWM功能。这通过软件生成一个粗略的PWM信号；根据您的需求，这可能是可以接受的。在GPIO引脚7和GPIO引脚11上生成软件PWM信号的代码如下：
- en: '[PRE10]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The previous code sets both pins to 100 Hz, with GPIO Pin 7 set to an on time
    of 2 ms (and an off time of 8 ms) and GPIO Pin 11 set to 7.5 ms/2.5 ms.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将两个引脚都设置为100 Hz，其中GPIO引脚7设置为开启时间为2 ms（关闭时间为8 ms），GPIO引脚11设置为7.5 ms/2.5
    ms。
- en: To adjust the PWM timings, use `wiringpi2.softPwmWrite(PWM_PIN_ENA,ON_TIME2)`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要调整PWM定时，请使用`wiringpi2.softPwmWrite(PWM_PIN_ENA,ON_TIME2)`。
- en: The accuracy of the PWM signal may be interrupted by other system processes,
    but it can control a small micro servo, even if it's slightly jittery.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: PWM信号的精度可能会被其他系统进程中断，但它可以控制一个小型微服，即使它略有抖动。
- en: Using I/O expanders
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用I/O扩展器
- en: As we saw previously (in [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,
    Sensing and Displaying Real-World Data*), `wiringpi2` allows us to easily adjust
    our code to make use of I/O expanders using I²C. In this case, it can be useful
    to add additional circuits, such as sensors and LED status indicators, and perhaps
    even displays and control buttons, to assist with debugging and controlling the
    Rover-Pi robot as you develop it.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见（在[第10章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*，感知与显示现实世界数据*），`wiringpi2`
    允许我们轻松调整代码以利用 I²C 使用 I/O 扩展器。在这种情况下，添加额外的电路可能很有用，例如传感器和 LED 状态指示器，甚至可能还有显示屏和控制按钮，以帮助你在开发过程中调试和控制
    Rover-Pi 机器人。
- en: It can be particularly helpful if you intend to use it as a tethered device,
    since you will only require three wires to connect back to the Raspberry Pi (I²C
    Data GPIO Pin 3, I²C Clock GPIO Pin 5, and Ground GPIO Pin 6), with I²C VCC being
    provided by the motor controller 5V output.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算将其用作固定连接的设备，这将特别有用，因为您只需要三根线就可以连接回树莓派（I²C 数据 GPIO 引脚 3、I²C 时钟 GPIO 引脚 5
    和地 GPIO 引脚 6），I²C VCC 由电机控制器的 5V 输出提供。
- en: 'As shown in the earlier example, add defines for the I²C address and pin base,
    as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，添加I²C地址和引脚基的宏定义，如下所示：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, in `gpiosetup()`, set up the MCP23017 device using the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `gpiosetup()` 函数中，使用以下代码设置 MCP23017 设备：
- en: '[PRE12]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Ensure that any pin references you make are numbered 100-115 (to refer to the
    I/O expander pins A0-7 and B0-7) with `AF_BASE` added (which is the pin offset
    for the I/O expander).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您所引用的任何引脚编号为100-115（以引用I/O扩展器的引脚A0-7和B0-7），并添加`AF_BASE`（这是I/O扩展器的引脚偏移量）。
- en: Building a six-legged Pi-Bug robot
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建一个六足 Pi-Bug 机器人
- en: 'Controlling motors is very useful for creating vehicle-like robots, but creating
    more naturally behaving robot components (such as servos) can provide excellent
    results. There are many creative designs of insect-like robots, or even biped
    designs (with humanoid-like legs) that use servos to provide natural joint movements.
    The design in this example uses three servos, but these principles and concepts
    can be easily applied to far more complex designs, to control legs/arms that use
    multiple servos. The Pi-Bug robot is shown in the following photo:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 控制电机对于创建类似车辆的机器人非常有用，但创建更自然行为的机器人组件（例如伺服电机）可以提供出色的结果。有许多类似昆虫的机器人创意设计，甚至还有双足设计（具有类似人腿的设计），它们使用伺服电机提供自然的关节运动。本例中的设计使用了三个伺服电机，但这些原则和概念可以轻松应用于更复杂的设计，以控制使用多个伺服电机的腿/手臂。以下照片展示了Pi-Bug机器人：
- en: '![](img/ed9160f7-9a28-49f7-aa44-7570e062ab06.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed9160f7-9a28-49f7-aa44-7570e062ab06.png)'
- en: The six-legged Pi-Bug robot uses a servo driver to control three servos to scuttle
    around
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 六足 Pi-Bug 机器人使用伺服驱动器来控制三个伺服电机，在周围爬行
- en: Getting ready
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'You will need the following hardware:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下硬件：
- en: '**A PWM driver module**: A driver module, such as the Adafruit 16-Channel 12-bit
    PWM/Servo Driver, will be needed. This uses a PCA9685 device; see the datasheet
    at [http://www.adafruit.com/datasheets/PCA9685.pdf](http://www.adafruit.com/datasheets/PCA9685.pdf)
    for details.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PWM 驱动模块**：需要一个驱动模块，例如 Adafruit 16-Channel 12-bit PWM/Servo 驱动器。这个模块使用 PCA9685
    设备；有关详细信息，请参阅[http://www.adafruit.com/datasheets/PCA9685.pdf](http://www.adafruit.com/datasheets/PCA9685.pdf)数据表。'
- en: '**Three micro servos**: The MG90S 9g Metal Gear Servos provide a reasonable
    amount of torque at a low cost.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**三个微型伺服电机**：MG90S 9g金属齿轮伺服电机以低廉的成本提供合理的扭矩。'
- en: '**A heavy gauge wire**: This will form the legs; three giant paper clips (76
    mm/3 inches) are ideal for this.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗重的导线**：这将形成腿的部分；三个巨大的回形针（76毫米/3英寸）非常适合这个用途。'
- en: '**A light gauge wire/cable ties**: These will be used to connect the legs to
    the servos and to mount the servos to the main board.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻质线缆夹具**：这些将用于将腿部连接到伺服电机，并将伺服电机安装到主板上。'
- en: '**A small section of plywood or fiberboard**: Holes can be drilled into this,
    and the servos can be mounted on it.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一小块胶合板或纤维板**：可以在其上钻孔，并将伺服电机安装在其上。'
- en: 'You will need to have `wiringpi2` installed to control the PWM module, and
    it will be useful to install the I²C tools for debugging. See [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,*
    *Sensing and Displaying Real-World Data*, for details on how to install `wiringpi2`
    and the I²C tools. The I²C connections are shown in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装`wiringpi2`来控制PWM模块，并且安装I²C工具进行调试将非常有用。有关如何安装`wiringpi2`和I²C工具的详细信息，请参阅[第10章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*，*“感知和显示现实世界数据”*。以下图表显示了I²C连接：
- en: '![](img/cbaa7e3f-bce7-4e6e-9416-ea11985823d6.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbaa7e3f-bce7-4e6e-9416-ea11985823d6.png)'
- en: I²C connections on the Raspberry Pi GPIO header
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi GPIO 头上的 I²C 连接
- en: How to do it...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The Pi-Bug robot uses three servos, one on either side and one in the middle.
    Mount each servo by drilling a hole on either side of the servo body, looping
    a wire or cable ties through it, and pulling to hold the servo tightly.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Pi-Bug 机器人使用三个伺服电机，两侧各一个，中间一个。通过在伺服电机身体两侧各钻一个孔，将电线或电缆绑带穿过孔中，然后拉紧以固定伺服电机。
- en: Bend the paper clip wire into a suitable shape to form the Pi-Bug robot's legs,
    and add a small kink that will allow you to wire the legs securely to the servo
    arms. It is recommended that you run the program first, with the Pi-Bug robot
    set to the home position `h`, before you screw the servo arms in place. This will
    ensure that the legs are located in the middle.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 将纸夹的金属丝弯曲成合适的形状以形成 Pi-Bug 机器人的腿部，并添加一个小弯折，这样你可以将腿部安全地连接到伺服臂上。建议你在将伺服臂固定到位之前，首先运行程序，并将
    Pi-Bug 机器人设置为初始位置 `h`。这将确保腿部位于中间位置。
- en: 'The following diagram shows the components on the Pi-Bug robot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 Pi-Bug 机器人的组件：
- en: '![](img/685df7fb-978b-4972-a039-6687ed5887af.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/685df7fb-978b-4972-a039-6687ed5887af.png)'
- en: The layout of components on the Pi-Bug robot
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: Pi-Bug机器人的组件布局
- en: 'Create the following `servoAdafruit.py` script to control the servos:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下用于控制伺服电机的 `servoAdafruit.py` 脚本：
- en: '[PRE13]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the following `bug_drive.py` script to control the Pi-Bug robot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下`bug_drive.py`脚本以控制Pi-Bug机器人：
- en: '[PRE14]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We explain the previous script functions by exploring how the servos are controlled
    using a PWM. Next, we will see how the servo class provides the methods to control
    the PCA9685 device. Finally, we will look at how the movements of the three servos
    combine to produce forward and turning motions for the Pi-Bug robot itself.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过探索如何使用PWM来控制伺服电机来解释之前的脚本函数。接下来，我们将看到伺服类提供了哪些方法来控制PCA9685设备。最后，我们将研究三个伺服电机的运动如何组合，为Pi-Bug机器人本身产生前进和转向动作。
- en: Controlling the servos
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制伺服电机
- en: 'To control the servos used for the Pi-Bug robot, we require a special control
    signal that will determine the angle that the servo is required to move to. We
    will send the servo a PWM signal, where the duration of the on time will allow
    us to control the angle of the servo arm (and thereby, allow us to control the
    Pi-Bug robot''s legs). The following diagram shows how a PWM signal can be used
    to control the angle of the servo:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制用于Pi-Bug机器人的伺服电机，我们需要一个特殊的控制信号，该信号将决定伺服电机需要移动到的角度。我们将向伺服电机发送一个PWM信号，其中开启时间的持续时间将允许我们控制伺服臂的角度（从而，允许我们控制Pi-Bug机器人的腿部）。以下图示展示了如何使用PWM信号来控制伺服电机的角度：
- en: '![](img/9a9a4381-b5a5-4511-b506-a25d11c08280.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9a9a4381-b5a5-4511-b506-a25d11c08280.png)'
- en: The angle of the servo is controlled by the duration of the up time of the PWM
    signal
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机的角度由PWM信号的上升时间持续时间控制
- en: 'Most servos will have an angular range of approximately 180 degrees and a mid-position
    of 90 degrees. A PWM frequency of 50 Hz will have a period of 20 ms, and the mid-position
    of 90 degrees typically corresponds to an **Up Time** of 1.5 ms, with a range
    of +/- 0.5 ms to 0.4 ms for near 0 degrees and near 180 degrees. Each type of
    servo will be slightly different, but you should be able to adjust the code to
    suit if required. The following diagram shows how you can control the servo angle
    using different PWM Up Times:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数伺服电机的角度范围大约为180度，中间位置为90度。50 Hz的PWM频率将有一个周期为20 ms，90度的中间位置通常对应于**上升时间**为1.5
    ms，对于接近0度和接近180度的范围，其变化范围为±0.5 ms至0.4 ms。每种类型的伺服电机可能会有所不同，但如果需要，你应该能够调整代码以适应。以下图表显示了您如何使用不同的PWM上升时间来控制伺服电机的角度：
- en: '![](img/eb6c51ea-bcd6-4172-bc8e-cbc08088dc50.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb6c51ea-bcd6-4172-bc8e-cbc08088dc50.png)'
- en: The servo angle is controlled by sending a PWM Up Time between 1 ms and 2 ms
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服角度通过发送1毫秒到2毫秒之间的PWM上升时间来控制
- en: Another type of servo is called a **continuous servo** (not used here). It allows
    you to control the rotation speed instead of the angle, and will rotate at a constant
    speed depending on the PWM signal that has been applied. Both servo types have
    internal feedback loops that will continuously drive the servo until the required
    angle or speed is reached.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种伺服类型被称为**连续伺服**（此处未使用）。它允许您控制旋转速度而不是角度，并且会根据已应用的PWM信号以恒定速度旋转。这两种伺服类型都具有内部反馈回路，会持续驱动伺服直到达到所需的角或速度。
- en: Although it is theoretically possible to generate these signals using software,
    you will find that any tiny interruption by other processes on the system will
    interfere with the signal timing; this, in turn, will produce an erratic response
    from the servo. This is why we use a hardware PWM controller, which only needs
    to be set with a specific up and down time, to then automatically generate the
    required signal for us.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从理论上讲可以使用软件生成这些信号，但你将发现系统上其他进程的任何微小中断都会干扰信号时序；反过来，这会导致伺服机构产生不规律的反应。这就是我们使用硬件PWM控制器的原因，它只需要设置特定的上升和下降时间，然后就能自动为我们生成所需的信号。
- en: The servo class
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伺服类
- en: The servo code is based on the PWM driver that Adafruit uses for their module;
    however, it is not Python 3 friendly, so we need to create our own version. We
    will use `wiringpi2` I²C driver to initialize and control the I²C PWM controller.
    We define the registers that we will need to use (see the datasheet for the PCA9685
    device), as well as its default bus address, `0x40` (PWMADR), and a PWM frequency
    of 50 Hz (PWMHZ).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服代码基于Adafruit为他们模块使用的PWM驱动器；然而，它并不兼容Python 3，因此我们需要创建自己的版本。我们将使用`wiringpi2`
    I²C驱动器来初始化和控制I²C PWM控制器。我们定义了我们将需要使用的寄存器（请参阅PCA9685设备的数据表），以及其默认总线地址，`0x40`（PWMADR），以及50
    Hz（PWMHZ）的PWM频率。
- en: 'Within our servo class, we initialize the I²C driver in `wiringpi2` and set
    up our `devPWM` device on the bus. Next, we initialize the PWM device itself (using
    `pwmInit()`). We have to calculate the **prescaler** required for the device to
    convert the onboard 25 MHz clock to a 50 Hz signal to generate the PWM frequency
    we need; we will use the following formula:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的伺服类中，我们在 `wiringpi2` 中初始化 I²C 驱动器，并在总线上设置我们的 `devPWM` 设备。接下来，我们初始化 PWM 设备本身（使用
    `pwmInit()`）。我们必须计算设备所需的**预分频器**，以便将板载 25 MHz 时钟转换为 50 Hz 信号，以生成我们需要的 PWM 频率；我们将使用以下公式：
- en: '![](img/104d3ec4-d744-42af-a7a2-12c2173d007c.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/104d3ec4-d744-42af-a7a2-12c2173d007c.png)'
- en: The prescale register value sets the PWM frequency using a 12-bit value to scale
    the 25 MHz clock
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 预缩放寄存器值使用12位值缩放25 MHz时钟来设置PWM频率
- en: The prescale value is loaded into the device, and a device reset is triggered
    to enable it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 预缩放值被加载到设备中，并触发设备重置以启用它。
- en: Next, we create a function to allow the PWM `ON` and `OFF` times to be controlled.
    The `ON` and `OFF` times are 12-bit values (0-4096), so each value is split into
    upper and lower bytes (8-bits each) that need to be loaded into two registers.
    For the `L` (low) registers, we mask off the upper 8 bits using `&0xFF`, and for
    the `H` (high) registers, we shift down by 8 bits to provide the higher 8 bits.
    Each PWM channel will have two registers for the on time and two for the off time,
    so we can multiply the addresses of the first PWM channel registers by 4 and the
    channel number to get the addresses of any of the others.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个函数来允许控制PWM的`ON`和`OFF`时间。`ON`和`OFF`时间是12位值（0-4096），因此每个值被分成高字节和低字节（每个8位），这些字节需要加载到两个寄存器中。对于`L`（低）寄存器，我们使用`&0xFF`屏蔽掉高8位，而对于`H`（高）寄存器，我们向下移位8位以提供高8位。每个PWM通道将有两个寄存器用于`ON`时间和两个用于`OFF`时间，因此我们可以将第一个PWM通道寄存器的地址乘以4和通道号，以获取其他任何通道的地址。
- en: 'To test our `servo` class, we define the minimum and maximum ranges of the
    servos, which we calculate as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的`伺服`类，我们定义了伺服器的最小和最大范围，计算方法如下：
- en: The PWM frequency of 50 Hz has a 20 ms period (*T=1/f*)
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50 Hz 的 PWM 频率的周期为 20 ms (*T=1/f*)
- en: The ON/OFF times range from 0-4,096 (so 0 ms to 20 ms)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开关时间范围从0-4,096（即0毫秒到20毫秒）
- en: Now, we can calculate the control values for 0 degrees (1 ms) and 180 degrees
    (2 ms)
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以计算0度（1毫秒）和180度（2毫秒）的控制值
- en: 'as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: 1 ms (servo min) is equal to 4,096/20 ms, which is 204.8
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 毫秒（伺服最小值）等于 4,096/20 毫秒，即 204.8
- en: 2 ms (servo max) is equal to 4,096/10 ms, which is 409.6
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 毫秒（伺服最大值）等于 4,096/10 毫秒，即 409.6
- en: We round the values to the nearest whole number.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将数值四舍五入到最接近的整数。
- en: Learning to walk
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习走路
- en: 'The Pi-Bug robot uses a common design that allows three servos to be used to
    create a small, six-legged robot. The servos at the two ends provide forward and
    backward movement, while the servo in the middle provides the control. The following
    photo shows the mounted servos:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Pi-Bug 机器人采用了一种常见的设计，允许使用三个伺服电机来创建一个小型、六足的机器人。两端伺服电机提供前进和后退运动，而中间的伺服电机提供控制。以下照片展示了安装好的伺服电机：
- en: '![](img/85460822-6d89-418f-88f8-769d2b59e31b.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/85460822-6d89-418f-88f8-769d2b59e31b.png)'
- en: The servos are mounted upside-down on the underside of the board
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机被安装在电路板的底部，方向是颠倒的
- en: The following table assumes that the left and right servos are mounted upside-down
    on the underside of the board, with the middle servo fitted vertically. You will
    have to adjust the code if mounted differently.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格假设左右伺服电机安装在电路板的底部，且方向颠倒，中间伺服电机垂直安装。如果安装方式不同，您将需要调整代码。
- en: 'The following table shows the servo movements used to walk forward:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了用于前进的伺服运动：
- en: '| **Direction** | **Middle (servoM)** | **Left (servoL)** | **Right (servoR)**
    |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| **方向** | **中间（伺服M）** | **左侧（伺服L）** | **右侧（伺服R）** |'
- en: '| **home** | `MID`/Middle | `MID`/Middle | `MID`/Middle |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| **主页** | `MID`/中间 | `MID`/中间 | `MID`/中间 |'
- en: '| **fwdStep1** | `TR`/Right side up | `ACW`/Legs forward | `ACW`/Legs backward
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| **fwdStep1** | `TR`/向上 | `ACW`/腿向前 | `ACW`/腿向后 |'
- en: '| **fwdStep2** | `TL`/Left side up | `CW`/Legs backward | `CW`/Legs forward
    |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **fwdStep2** | `TL`/左侧向上 | `CW`/腿向后 | `CW`/腿向前 |'
- en: 'The following diagram shows how the movement makes the Pi-Bug robot step forward:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了运动如何使 Pi-Bug 机器人向前迈步：
- en: '![](img/f9edd774-480d-49bf-86ca-5eda4224fddd.png)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9edd774-480d-49bf-86ca-5eda4224fddd.png)'
- en: The Pi-Bug robot moving forward
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Pi-Bug 机器人向前移动
- en: While it may seem a little confusing at first, when you see the robot moving,
    it should make more sense.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一开始可能有些令人困惑，但当你看到机器人移动时，应该会更容易理解。
- en: For the first forward step, we move the middle servo (`servoM`) clockwise so
    that the left side of the Pi-Bug robot is lifted off the ground by the movement
    of the remaining middle leg. We can then move the left servo (`servoL`) to move
    the legs on the left side forward (ready for movement later; they are not touching
    the ground at this point). Now, by moving the right servo (`servoR`), we can move
    the legs on the right backwards (allowing the Pi-Bug robot to be pushed forward
    on that side).
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一次前进步，我们将中间伺服器（`servoM`）顺时针移动，这样Pi-Bug机器人的左侧就能通过剩余中间腿的运动离开地面。然后，我们可以移动左侧伺服器（`servoL`）来将左侧的腿向前移动（为后续移动做准备；此时它们并未接触地面）。现在，通过移动右侧伺服器（`servoR`），我们可以将右侧的腿向后移动（允许Pi-Bug机器人在那一侧被推向前方）。
- en: The second forward step is the same, except that we use the middle servo (`servoM`)
    to lift the right side off the ground. Again, we move the legs that are off the
    ground forward (ready for next time) and then move the legs on the other side
    backward (allowing that side of the Pi-Bug robot to move forward). By repeating
    the forward steps, the Pi-Bug robot will move forward; or, by swapping the sides
    that are being lifted up by the middle servo (`servoM`), it will move backward.
    The result is a rather bug-like scuttle!
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个前进步骤与之前相同，只是我们使用中间伺服器（`servoM`）将右侧抬起离地。同样，我们将离地的腿向前移动（为下一次做准备），然后将另一侧的腿向后移动（允许Pi-Bug机器人的那一侧向前移动）。通过重复前进步骤，Pi-Bug机器人将向前移动；或者，通过交换由中间伺服器（`servoM`）抬起的两侧，它将向后移动。结果是相当像虫子一样快速地爬行！
- en: 'To make the Pi-Bug robot turn, we perform a similar action, except that just
    like the advanced motor control for the Rover-Pi robot, we move one side of the
    robot forward and the other side backward. The following table shows the servo
    movements used to turn right:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Pi-Bug 机器人转向，我们执行类似动作，只不过就像 Rover-Pi 机器人的高级电机控制一样，我们让机器人的一侧前进，另一侧后退。下表显示了用于向右转动的伺服器运动：
- en: '| **Direction** | **Middle (servoM)** | **Left (servoL)** | **Right (servoR)**
    |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| **方向** | **中间（伺服M）** | **左侧（伺服L）** | **右侧（伺服R）** |'
- en: '| **home** | `MID`/Middle | `MID`/Middle | `MID`/Middle |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| **主页** | `MID`/中间 | `MID`/中间 | `MID`/中间 |'
- en: '| **rightStep1** | `TL`/Left side up | `CW`/Legs backward | `ACW`/Legs backward
    |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| **rightStep1** | `TL`/左侧向上 | `CW`/向后腿 | `ACW`/向后腿 |'
- en: '| **rightStep2** | `TR`/Right side up | `ACW`/Legs forward | `CW`/Legs forward
    |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| **rightStep2** | `TR`/向上 | `ACW`/腿向前 | `CW`/腿向前 |'
- en: 'The steps to turn the Pi-Bug robot to the right are shown in the following
    diagram:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Pi-Bug 机器人转向右侧的步骤如下所示：
- en: '![](img/a64bb9a8-0b80-4333-a2d9-2badd060b548.png)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a64bb9a8-0b80-4333-a2d9-2badd060b548.png)'
- en: The Pi-Bug robot making a right turn
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Pi-Bug 机器人向右转
- en: To turn right, we lift the left side of the Pi-Bug robot off the ground, but
    this time, we move the legs on both sides backward. This allows the right side
    of the Pi-Bug robot to move forward. The second half of the step lifts the right
    side off the ground, and we move the legs forward (which will push the left side
    of the Pi-Bug robot backward). In this manner, the bug will turn as it steps;
    again, just by swapping the sides that are being lifted, we can change the direction
    that the Pi-Bug robot will turn in.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要向右转，我们需要将 Pi-Bug 机器人的左侧抬起离地，但这次，我们将两边的腿向后移动。这允许 Pi-Bug 机器人的右侧向前移动。步子的后半部分抬起右侧离地，然后我们向前移动腿（这将推动
    Pi-Bug 机器人的左侧向后）。这样，虫子就会在行走时转向；再次强调，只需交换被抬起的两侧，我们就可以改变 Pi-Bug 机器人将转向的方向。
- en: The Pi-Bug code for walking
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pi-Bug 行走代码
- en: The code for the Pi-Bug robot has been designed to provide the same interface
    as the Rover-Pi robot so that they can be interchanged easily. You should notice
    that each class consists of the same four functions (`__init__()`, `off()`, `drive()`,
    and `cmd()`). The `__init__()` function defines the set of pins we will control,
    the `steptime` value of the walking action (this time, the gap between movements),
    and the previously defined servo module.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: Pi-Bug机器人的代码被设计成提供与Rover-Pi机器人相同的接口，以便它们可以轻松互换。你应该注意到每个类都包含相同的四个函数（`__init__()`,
    `off()`, `drive()`, 和 `cmd()`）。`__init__()`函数定义了我们将要控制的引脚集合，行走动作的`steptime`值（这次，动作之间的间隔），以及之前定义的服务器模块。
- en: Once again, we have an `off()` function that provides a function that can be
    called to set the servos in their middle positions (which is very useful for when
    you need to fit the legs in position, as described previously in the home position).
    The `off()` function uses the `drive()` function to set each servo to the `MID`
    position. The `MID` value is halfway between `servoMin` and `servoMax` (1.5 ms
    to give a position of 90 degrees).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们有一个 `off()` 函数，它提供了一个可以被调用的函数来设置伺服电机到中间位置（这在需要将腿部调整到位时非常有用，正如之前在初始位置中所述）。`off()`
    函数使用 `drive()` 函数将每个伺服电机设置到 `MID` 位置。`MID` 值位于 `servoMin` 和 `servoMax` 之间的一半（1.5
    ms 以给出 90 度的位置）。
- en: The `drive()` function is just like the previous motor control version; it cycles
    through each of the actions required for each servo, as defined in the various
    movement patterns (`FWD`, `BWD`, `LEFT`, and `RIGHT`) we discussed previously.
    However, to reproduce the required pattern of movement, we cycle through each
    servo twice, while inserting a small delay whenever we move the middle servo (`servoM`).
    This allows time for the servo to move and provide the necessary tilt to lift
    the other legs off the ground before allowing them to move.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`drive()` 函数与之前的电机控制版本类似；它按照我们在之前讨论的各种运动模式（`FWD`、`BWD`、`LEFT` 和 `RIGHT`）中定义的，循环执行每个伺服所需的动作。然而，为了重现所需的运动模式，我们在移动中间伺服（`servoM`）时，会将其循环两次，并在每次移动中间伺服时插入一个小的延迟。这为伺服移动并给出必要的倾斜，以便在允许它们移动之前将其他腿从地面上抬起提供了时间。'
- en: We define each of the servo commands as a **clockwise** (**CW**) or **anticlockwise/counterclockwise**
    (**ACW**) movement of the servo arm. Since the servos are mounted upside down,
    an ACW (CW, if viewed from above) movement of the left servo (`servoL`) will bring
    the legs forwards, while the same direction of movement on the right servo (`servoR`)
    will move the legs backward (which is fwdStep1 in the previous diagram). In this
    way, each of the patterns can be defined.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个伺服命令定义为伺服臂的**顺时针**（**CW**）或**逆时针/逆时**（**ACW**）运动。由于伺服器是倒置安装的，左伺服器（`servoL`）的ACW（如果从上方看是CW）运动会使腿部向前移动，而在右伺服器（`servoR`）上相同方向的运动会使腿部向后移动（这在之前的图中是fwdStep1）。这样，每种模式都可以被定义。
- en: 'Once again, we provide a test function using the following command that allows
    a list of instructions to either be defined from the command line or directly
    entered at the prompt:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 一次又一次，我们使用以下命令提供了一个测试函数，该命令允许从命令行或直接在提示符中定义一系列指令：
- en: '[PRE15]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This includes the addition of `h` to return to the `home` position, if desired.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括如果需要，添加 `h` 以返回 `home` 位置。
- en: Controlling servos directly with ServoBlaster
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接使用 ServoBlaster 控制伺服电机
- en: The previous recipe demonstrated using a dedicated servo controller to handle
    the control of the servos used by the Pi-Bug. This has the advantage that any
    disturbances in the processing taking place on the Raspberry Pi do not cause interference
    with the delicate servo control (since the controller will continue to send the
    correct signals).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方展示了使用专门的伺服控制器来处理 Pi-Bug 所使用的伺服电机的控制。这具有优势，即 Raspberry Pi 上正在进行的处理中的任何干扰都不会干扰微妙的伺服控制（因为控制器将继续发送正确的信号）。
- en: However, the Raspberry Pi is also capable of direct servo control. To achieve
    this, we will make use of Richard Hurst's ServoBlaster, which is a multiple servo
    driver.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，树莓派也具备直接伺服控制的能力。为了实现这一点，我们将利用理查德·赫斯特的ServoBlaster，这是一个多伺服驱动器。
- en: 'In this recipe, we will control four servos attached to the MeArm, a simple
    laser-cut robot arm; however, you can choose to fit servos to whatever device
    you like:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将控制连接到MeArm的四个伺服电机，这是一个简单的激光切割机器人臂；然而，你可以选择将伺服电机安装到你喜欢的任何设备上：
- en: '![](img/5b56d39c-96aa-4889-b22d-c05a890fe6c0.png)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5b56d39c-96aa-4889-b22d-c05a890fe6c0.png)'
- en: The MeArm is a simple robot arm powered by four miniature servos
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: MeArm 是一个由四个微型伺服电机驱动的简单机械臂
- en: Getting ready
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'Most common servos will have three wires and a three pin connector, as follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数伺服电机将有三根线和三个引脚的连接器，如下所示：
- en: '| **Black/Brown** | **Red** | **Orange/White/Yellow/Blue** |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| **黑色/棕色** | **红色** | **橙色/白色/黄色/蓝色** |'
- en: '| Ground | Positive supply (typically 5V for small servos) | Signal |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 地线 | 正电源（通常为小型伺服电机的5V） | 信号 |'
- en: While it is usually possible to power the servos directly from the Raspberry
    Pi 5V pins on the GPIO header, they can draw a significant amount of current when
    moving. Unless you have a very good power supply, this can cause the Raspberry
    Pi to reset unexpectedly, risking corrupting the SD card. Therefore, it is recommended
    that you power them separately; for example, with an additional USB power supply
    and cable connected to the ground and positive supply.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然通常可以直接从Raspberry Pi的GPIO引脚上的5V引脚为伺服器供电，但在移动时它们会消耗相当大的电流。除非你有一个非常好的电源，否则这可能会导致Raspberry
    Pi意外重启，从而风险损坏SD卡。因此，建议你为它们单独供电；例如，使用一个额外的USB电源和连接到地线和正电源的电缆。
- en: 'By default, the servos can be wired as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，伺服电机可以按照以下方式接线：
- en: '| **Servo** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | All GND | All Power |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **伺服** | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 所有 GND | 所有 电源 |'
- en: '| **Raspberry Pi****GPIO Pin** |  |  |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| **树莓派** **GPIO引脚** |  |  |'
- en: '| 7 | 11 | 12 | 13 | 15 | 16 | 19 | 22 | 6 | No Connect |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 11 | 12 | 13 | 15 | 16 | 19 | 22 | 6 | 无连接 |'
- en: '| **5V Power Supply** |  | GND | +5V |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| **5V电源** |  | GND | +5V |'
- en: 'We will assume that we are controlling four servos (0, 1, 2, and 3) that will
    be fitted to the MeArm or a similar device later:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设我们正在控制四个伺服电机（0、1、2和3），这些伺服电机将在稍后安装到MeArm或类似设备上：
- en: '![](img/70d2d538-68f3-415d-a1a3-98da85d94d5e.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70d2d538-68f3-415d-a1a3-98da85d94d5e.jpg)'
- en: 'To install ServoBlaster, start by downloading the source files from the Git
    repository:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装ServoBlaster，首先从Git仓库下载源文件：
- en: '[PRE16]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unzip and open the `matplotlib-master` folder, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 解压并打开`matplotlib-master`文件夹，操作如下：
- en: '[PRE17]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We will use the user space daemon (which is located in the user directory)
    that is called `servod`. Before we can use it, we should compile it with this
    command:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用位于用户目录中的用户空间守护进程（称为`servod`）。在我们能够使用它之前，我们应该使用以下命令来编译它：
- en: '[PRE18]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There should be no errors, showing the following text:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 应该没有错误，显示以下文本：
- en: '[PRE19]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For usage information, use the following command:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用信息，请使用以下命令：
- en: '[PRE20]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now we can test a servo; first, start the `servod` daemon (with a timeout of
    2,000 ms to switch the servo off after it has moved):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以测试一个伺服电机；首先，启动`servod`守护进程（设置超时时间为2,000毫秒，以便伺服电机移动后关闭）：
- en: '[PRE21]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can move the servo''s position to 0% of the servo''s range:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将伺服电机的位置移动到伺服电机范围的0%。
- en: '[PRE22]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, update the servo to 50%, causing the servo to rotate to 90 degrees (servo
    mid-point):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将伺服电机更新到50%，使伺服电机旋转到90度（伺服中点）：
- en: '[PRE23]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As recommended by the MeArm build instructions, the servos should be connected
    and calibrated before building the arm, to ensure that each servo is able to move
    the arm in its correct range. This is done by ensuring that each servo is powered
    up and commanded to its mid-point position (50%/90 degrees), and the servo-arm
    is fitted at the expected orientation:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如MeArm构建说明中所建议，在构建机械臂之前，应该连接并校准伺服电机，以确保每个伺服电机能够在其正确范围内移动机械臂。这是通过确保每个伺服电机都接通电源并被指令移动到中点位置（50%/90度），并且伺服电机臂被安装到预期的方向上完成的：
- en: '![](img/a72d289d-55cb-4a78-b14c-5ebf7f2e81f0.png)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a72d289d-55cb-4a78-b14c-5ebf7f2e81f0.png)'
- en: Each of the servos should be calibrated in the correct position before you fit
    them on the MeArm
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在将伺服电机安装到MeArm之前，每个伺服电机都应该在正确的位置进行校准。
- en: You can now set each of the MeArm servos (0, 1, 2, and 3) to their mid-points
    (by commanding each, in turn, to 50%) before building and fitting them to a completed
    arm.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以在构建和将它们安装到完成的手臂之前，将每个 MeArm 伺服电机（0、1、2 和 3）设置为它们的中间位置（通过依次命令每个电机到 50%）。
- en: 'The servos could be used to control a wide range of alternative devices other
    than the MeArm, but your servos will probably need to be calibrated in a similar
    manner:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机可以用来控制除MeArm之外的各种替代设备，但你的伺服电机可能需要以类似的方式进行校准：
- en: '![](img/234797d3-42ad-4871-b5b1-69bbaa211114.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/234797d3-42ad-4871-b5b1-69bbaa211114.png)'
- en: The precision control of servos means they can be used for a variety of applications,
    for example, controlling simulated hands
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 伺服电机的精度控制意味着它们可以用于各种应用，例如，控制模拟手
- en: How to do it...
  id: totrans-330
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create the following `servo_control.py` script:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建以下 `servo_control.py` 脚本：
- en: '[PRE24]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the script:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行脚本：
- en: '[PRE25]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You can control the servos fitted to the MeArm (or whatever you are using)
    as prompted:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以按照提示控制安装在 MeArm（或您所使用的任何设备）上的伺服电机：
- en: '[PRE26]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The script starts by importing the `curses` and `os` modules. A standard Python
    `input()` command would require the *Enter* key to be pressed after each key press
    before we could act upon it. However, as we will see shortly, the `curses` module
    simply allows us to scan for keyboard presses and respond to them immediately.
    We use the `os` module to call the ServoBlaster commands, as we would via the
    Terminal.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本首先导入`curses`和`os`模块。标准的Python `input()`命令需要在每次按键后按下*Enter*键，我们才能对其做出反应。然而，正如我们很快就会看到的，`curses`模块仅仅允许我们扫描键盘按键并立即对其做出响应。我们使用`os`模块来调用ServoBlaster命令，就像我们在终端中做的那样。
- en: First, we define our setup, such as the servo mappings, calibration positions,
    min/max ranges, our control keys, and the `STEP` size in degrees for each control
    command. We also define our parameters for our requested angle (in degrees) to
    target PWM signal up time (in milliseconds) calculation.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的设置，例如伺服映射、校准位置、最小/最大范围、我们的控制键，以及每个控制命令的`STEP`大小（以度为单位）。我们还定义了我们的参数，用于计算所需角度（以度为单位）到目标PWM信号持续时间（以毫秒为单位）的计算。
- en: For these particular servos, an up time of 1 ms is equal to 0 degrees and 2.5
    ms is 180 degrees, so we have an offset (`OFFSET`) of 1 ms and a scale (`DEG2MS`)
    of 180 degrees/1.5 ms.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些特定的伺服电机，1毫秒的运行时间等于0度，而2.5毫秒等于180度，因此我们有一个1毫秒的偏移量（`OFFSET`）和180度/1.5毫秒的缩放比例（`DEG2MS`）。
- en: Therefore, our required up time (in milliseconds) can be calculated as *OFFSET
    + (degrees*DEG2MS)*. Finally, we define the `SERVOD` command line and servo `IDLE`
    timeout to initialize the ServoBlaster user daemon. Within `initialize ()`, we
    use `os.system()` to start the `servod` daemon, as we did before.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们所需的正常运行时间（以毫秒为单位）可以计算为 *OFFSET + (degrees*DEG2MS)*。最后，我们定义 `SERVOD` 命令行和伺服
    `IDLE` 超时以初始化 ServoBlaster 用户守护进程。在 `initialize ()` 函数中，我们使用 `os.system()` 启动
    `servod` 守护进程，就像我们之前做的那样。
- en: In order to detect key presses, we call the `main()` function of the script
    from `curses.wrapper()`, allowing `term` to control the terminal input and output.
    We use `term.nodelay(1)` so that when we do check for any key presses (using `term.getch()`),
    execution will continue normally. We use `term.addstr(text)` to show the user
    the control keys and then update the display via `term.refresh()`. The remaining
    script checks the terminal for key presses and the result assigned to `c`. If
    no key was pressed, then `term.getch()` returns `-1`; otherwise, the ASCII equivalent
    value is returned, and we can check for it in each of the dictionaries we defined
    for control keys. We will use `KEY_MORE` and `KEY_LESS` to change the servo positions,
    and `KEY_CMD` (`c` or `x`) to allow us to set all the servos to their calibrated
    position or to exit cleanly. Finally, we display any useful debugging information
    (if `DEBUG` is set to `True`) using `term.addstr()`, and ensure that it is displayed
    at (1,0) in the terminal (one line down from the top).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测按键，我们调用脚本中的`main()`函数，通过`curses.wrapper()`，使`term`能够控制终端的输入和输出。我们使用`term.nodelay(1)`，这样当我们检查是否有按键按下（使用`term.getch()`）时，执行将继续正常进行。我们使用`term.addstr(text)`向用户显示控制键，然后通过`term.refresh()`更新显示。剩余的脚本会检查终端是否有按键按下，并将结果赋值给`c`。如果没有按键按下，则`term.getch()`返回`-1`；否则，返回ASCII等效值，我们可以在我们为控制键定义的每个字典中检查它。我们将使用`KEY_MORE`和`KEY_LESS`来改变伺服位置，使用`KEY_CMD`（`c`或`x`）来允许我们将所有伺服设置到校准位置或干净地退出。最后，如果`DEBUG`设置为`True`，我们使用`term.addstr()`显示任何有用的调试信息，并确保它在终端的（1,0）位置显示（从顶部向下数一行）。
- en: For normal control, the position of the servos will be controlled using the
    `updateServo()` function, which adjusts the current position (stored in the POS
    array) by the required change (either `+STEP` or `-STEP`). We ensure the new position
    is within the MAX/MIN limits defined, and report if we've hit them. The servo
    is then instructed to move to the required position using `setServo()`, specifying
    the needed PWM up time in micro seconds.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于常规控制，伺服电机的位置将通过`updateServo()`函数进行控制，该函数通过所需的改变（无论是`+STEP`还是`-STEP`）调整当前位置（存储在POS数组中）。我们确保新位置在定义的MAX/MIN限制内，并报告是否已达到这些限制。然后，伺服电机被指令通过`setServo()`移动到所需位置，指定所需的PWM上升时间（以微秒为单位）。
- en: The last function, `calibrate()`, called when *C* is pressed, simply sets each
    of the servos to the angle defined in the `CAL` array (using `setServo()`) and
    ensures that the current position is kept up to date.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个函数，当按下 *C* 键时调用 `calibrate()`，它简单地设置每个伺服电机到 `CAL` 数组中定义的角度（使用 `setServo()`），并确保当前位置保持最新。
- en: Using an infrared remote control with your Raspberry Pi
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用红外遥控器与你的树莓派配合使用
- en: It is often useful to control robots remotely. An easy way to add additional
    input is to make
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 远程控制机器人通常很有用。添加额外输入的一个简单方法是通过制作
- en: use of an **infrared** (**IR**) receiver and a standard remote control. Fortunately,
    the receiver is
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个**红外**（**IR**）接收器和标准遥控器。幸运的是，接收器是
- en: well supported.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 得到充分支持。
- en: We will use a module called `lirc` to capture and decode IR signals from a standard
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `lirc` 的模块来捕获和解码来自标准
- en: remote control.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 遥控器。
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备中
- en: 'LIRC supports many types of IR detectors, such as Energenie''s PiMote IR board;
    however, since we only need to receive IR signals, we can use a simple (TSOP38238)
    IR detector:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: LIRC支持许多类型的红外探测器，例如Energenie的PiMote红外板；然而，由于我们只需要接收红外信号，我们可以使用一个简单的（TSOP38238）红外探测器：
- en: '![](img/0bc8bc96-656d-4a9d-914b-e1acf33f9e95.png)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bc8bc96-656d-4a9d-914b-e1acf33f9e95.png)'
- en: The three pins of the TSOP38238 IR receiver can fit directly onto the Raspberry
    Pi header
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: TSOP38238红外接收器的三个引脚可以直接安装在Raspberry Pi的引脚头上
- en: 'Install the following packages using the `apt-get` command:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`apt-get`命令安装以下软件包：
- en: '[PRE27]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following to `/boot/config.txt`. This will enable the driver and define
    the pin the receiver is fitted on (BCM GPIO24):'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `/boot/config.txt` 文件中。这将启用驱动程序并定义接收器所安装的引脚（BCM GPIO24）：
- en: '[PRE28]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Perform a restart of the Raspberry Pi so that the configuration takes effect:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 重启 Raspberry Pi 以使配置生效：
- en: '[PRE29]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We should now find that the IR device is located at `/dev/lirc0`. We can observe
    the output of the receiver if we point a remote control at it and press some buttons
    after using the following command (use *Ctrl* + *Z* to exit):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该会发现红外设备位于 `/dev/lirc0`。如果我们用遥控器指向它并在使用以下命令后按一些按钮，我们可以观察到接收器的输出（使用 *Ctrl*
    + *Z* 退出）：
- en: '[PRE30]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `lirc0` resource may report as busy:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`lirc0` 资源可能报告为忙碌：'
- en: '`mode2: could not open /dev/lirc0`'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode2: 无法打开 /dev/lirc0`'
- en: '`mode2: default_init(): Device or resource busy`'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`mode2: default_init(): 设备或资源忙碌`'
- en: 'Then we will need to stop the `lirc` service:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要停止`lirc`服务：
- en: '`sudo /etc/init.d/lirc stop`'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo /etc/init.d/lirc stop`'
- en: 'It will give the following response:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 它将给出以下响应：
- en: '`[ ok ] Stopping lirc (via systemctl): lirc.service`'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ ok ] 停止lirc（通过systemctl）：lirc.service`'
- en: 'When you are ready, you can start the service again:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好后，你可以再次启动服务：
- en: '`sudo /etc/init.d/lirc start`'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo /etc/init.d/lirc start`'
- en: 'This will give the following response:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给出以下响应：
- en: '`[ ok ] Starting lirc (via systemctl): lirc.service`'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`[ ok ] 启动 lirc (通过 systemctl): lirc.service`'
- en: 'You will see output similar to the following (if not, ensure that you have
    connected the receiver connected to the correct pins on the Raspberry Pi GPIO):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到类似以下输出（如果不是，请确保你已经将接收器连接到Raspberry Pi GPIO的正确引脚上）：
- en: '[PRE31]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now that we know our device is working, we can configure it.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们的设备正在工作，我们可以对其进行配置。
- en: How to do it...
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The global LIRC configurations are stored in `/etc/lirc`. We are interested
    in the following files:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 全球 LIRC 配置存储在 `/etc/lirc` 目录中。我们关注以下文件：
- en: '`hardware.conf`: Defines where our IR sensor is installed and the overall setting
    for our sensor.'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hardware.conf`: 定义了我们的红外传感器安装位置以及传感器的整体设置。'
- en: '`lircd.conf`: The remote control configuration file; this contains the recorded
    outputs for your remote control''s keys and maps them to specific key symbols.
    You can often obtain pre-recorded files from [lirc.sourceforge.net/remotes](http://lirc.sourceforge.net/remotes/),
    or you can record a custom one, as shown next.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lircd.conf`: 遥控器配置文件；此文件包含您遥控器按键的记录输出，并将它们映射到特定的按键符号。您通常可以从 [lirc.sourceforge.net/remotes](http://lirc.sourceforge.net/remotes/)
    获取预录制的文件，或者您可以记录一个自定义的，如下所示。'
- en: '`lircrc`: This file provides mapping of each of the key symbols to specific
    commands or keyboard mappings.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lircrc`: 此文件提供了每个按键符号到特定命令或键盘映射的映射。'
- en: All of the LIRC configurations stored in `/etc/lirc` are available for all users;
    however, if required, different configurations can be defined for each user by
    placing them in specific home folders (for example, `/home/pi/.config/`), allowing
    the defaults to be overridden.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在 `/etc/lirc` 中的所有 LIRC 配置对所有用户都可用；然而，如果需要，可以通过将它们放置在特定的家目录中（例如，`/home/pi/.config/`）为每个用户定义不同的配置，从而覆盖默认设置。
- en: 'There are three steps to setting up the sensor, one for each of the LIRC configuration
    files:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 设置传感器有三个步骤，每个步骤对应一个LIRC配置文件：
- en: 'First, ensure that `hardware.conf` is set up. For our sensor, we must ensure
    that the following is set:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确保`hardware.conf`文件已设置。对于我们的传感器，我们必须确保以下设置正确：
- en: '[PRE32]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Next, obtain a `lircd.conf` file; or, if you do not have one for your remote,
    we can generate it. The following process will now take you through detecting
    each of the individual keys on the remote. For the purpose of this recipe, we
    only need to map eight keys (to control the four servos from the previous recipe).
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，获取一个 `lircd.conf` 文件；或者，如果您没有为您的遥控器准备一个，我们可以为您生成。接下来的过程将引导您检测遥控器上的每个单独的按键。为了本菜谱的目的，我们只需要映射八个按键（以控制前一个菜谱中的四个伺服器）。
- en: 'If you want map additional keys, use the following command to find out the
    full list of valid key symbols:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想映射额外的键，请使用以下命令来查找所有有效键符号的完整列表：
- en: '[PRE33]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| `KEY_UP` | `KEY_RIGHT` | `KEY_VOLUMEUP` | `KEY_CHANNELUP` |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| `KEY_UP` | `KEY_RIGHT` | `KEY_VOLUMEUP` | `KEY_CHANNELUP` |'
- en: '| `KEY_DOWN` | `KEY_LEFT` | `KEY_VOLUMEDOWN` | `KEY_CHANNELDOWN` |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| `KEY_DOWN` | `KEY_LEFT` | `KEY_VOLUMEDOWN` | `KEY_CHANNELDOWN` |'
- en: '![](img/c9c935d6-a742-43f6-b81e-875aa5beef9e.png)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c9c935d6-a742-43f6-b81e-875aa5beef9e.png)'
- en: We can use the volume, channel, and direction buttons on this Goodman's remote
    as our MeArm controller
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个Goodman遥控器上的音量、通道和方向按钮作为我们的MeArm控制器
- en: 'First, we will need to stop the `lirc` service, which, if it was running, would
    be using the `/dev/lirc0` device:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要停止`lirc`服务，如果它正在运行，则会使用`/dev/lirc0`设备：
- en: '[PRE34]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Next, start the capture process using the following commands:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令开始捕获过程：
- en: '[PRE35]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![](img/783e39cf-b484-4d0a-949d-287aa984310b.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/783e39cf-b484-4d0a-949d-287aa984310b.png)'
- en: Record each button on the remote using the irrecord tool
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用irrecord工具记录遥控器上的每个按钮
- en: 'Now that we have captured the required keys, we ensure that the name of the
    remote is set (by default, it will be set to the name of the `lirc.conf` file
    when the buttons are captured):'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经捕获了所需的密钥，我们确保远程设备的名称已设置（默认情况下，当捕获按钮时，它将设置为`lirc.conf`文件的名称）：
- en: '[PRE36]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Set the name of the remote in the file; for example, `Goodmans`:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中设置远程名称；例如，`Goodmans`：
- en: '[PRE37]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Finally, we can replace the configuration in the `/etc/lirc` folder:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以替换 `/etc/lirc` 文件夹中的配置：
- en: '[PRE38]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We can confirm the key symbols that are mapped to the remote using the `irw`
    program, as follows:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`irw`程序来确认映射到遥控器的关键符号，如下所示：
- en: '`irw`'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`irw`'
- en: 'This will report the details of the key pressed and the remote control as defined:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 这将报告按键细节和远程控制，其定义如下：
- en: '[PRE39]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, we can map the keys to specific commands; in this case, we will map them
    to the keys we used for controlling the MeArm servos. Create a new `/etc/lirc/lircrc`
    file:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将键映射到特定的命令；在这种情况下，我们将它们映射到我们用于控制MeArm伺服电机的键上。创建一个新的`/etc/lirc/lircrc`文件：
- en: '[PRE40]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Replace it with the following content:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换它：
- en: '[PRE41]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To apply the configuration, you may need to restart the service (or, if that
    doesn''t work, try restarting the Raspberry Pi):'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用配置，您可能需要重新启动服务（或者，如果这不起作用，尝试重新启动树莓派）：
- en: '[PRE42]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When we run the `servo_control.py` script in the previous recipe, the remote
    should control the arm directly.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在上一道菜谱中运行`servo_control.py`脚本时，遥控器应能直接控制机械臂。
- en: There's more...
  id: totrans-416
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'LIRC supports several helper programs, of which `irxevent` is just one:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: LIRC支持多个辅助程序，其中`irxevent`只是其中之一：
- en: '| `remote` | By default, LIRC supports some simple controls; for example:` 
    prog=remote``  button=KEY_UP``  config=UP`This will provide simple cursor control
    from a remote (UP, DOWN, LEFT, RIGHT, and also ENTER) that are perfect for simple
    menu control. |'
  id: totrans-418
  prefs: []
  type: TYPE_TB
  zh: '| `remote` | 默认情况下，LIRC 支持一些简单的控制；例如：`  prog=remote``  button=KEY_UP``  config=UP`这将提供从遥控器（向上、向下、向左、向右，以及也包含
    ENTER）的简单光标控制，非常适合简单的菜单控制。 |'
- en: '| [http://www.lirc.org/html/configure.html#lircrc_format](http://www.lirc.org/html/configure.html#lircrc_format)
    |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.lirc.org/html/configure.html#lircrc_format](http://www.lirc.org/html/configure.html#lircrc_format)
    |'
- en: '| `irxevent` | Emulates button clicks and key presses within X applications.
    You can specify that the key event occurs in the `CurrentWindow` or in a specific
    window by name, that is, `leafpad`. This only works if you are running from the
    graphical desktop environment (or using X forwarding). |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| `irxevent` | 模拟在 X 应用程序中的按钮点击和按键操作。您可以指定按键事件发生在 `CurrentWindow` 或特定名称的窗口中，即
    `leafpad`。这仅在您从图形桌面环境运行（或使用 X 转发）时才有效。 |'
- en: '| [http://www.lirc.org/html/irxevent.html](http://www.lirc.org/html/irxevent.html)
    |'
  id: totrans-421
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.lirc.org/html/irxevent.html](http://www.lirc.org/html/irxevent.html)
    |'
- en: '| `irpty` | Converts infrared remote commands into keystrokes for controlling
    a particular program:`  rog=irpty``  button=KEY_EXIT``  config=x`Start it by specifying
    the `lircrc` configuration and program you want to control:`irpty /etc/lirc/lircrc
    -- leafpad` |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| `irpty` | 将红外遥控命令转换为控制特定程序的按键：`rog=irpty` `button=KEY_EXIT` `config=x` 通过指定`lircrc`配置和要控制程序启动它：`irpty
    /etc/lirc/lircrc -- leafpad` |'
- en: '| [http://www.lirc.org/html/irpty.html](http://www.lirc.org/html/irpty.html)
    |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.lirc.org/html/irpty.html](http://www.lirc.org/html/irpty.html)
    |'
- en: '| `irexec` | Allows commands to be run directly from the remote control:  `prog=irexec`` 
    button=KEY_POWER``  config=sudo halt #Power Down` |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| `irexec` | 允许直接从遥控器运行命令：`prog=irexec` `button=KEY_POWER` `config=sudo halt
    #关机` |'
- en: '| [http://www.lirc.org/html/irexec.html](http://www.lirc.org/html/irexec.html)
    |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| [http://www.lirc.org/html/irexec.html](http://www.lirc.org/html/irexec.html)
    |'
- en: 'You can test any part of the `lircrc` file by using `ircat` with the required
    `prog`:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用带有所需`prog`的`ircat`来测试`lircrc`文件的任何部分：
- en: '[PRE43]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The preceding command will report the following:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将报告以下内容：
- en: '[PRE44]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Finally, if you have a suitable IR Transmitter LED attached (including a protective
    resistor/switching transistor), you can also use LIRC to send infrared signals
    from the Raspberry Pi. For this, you can use the `irsend` command, for example:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您已连接合适的红外发射器LED（包括保护电阻/开关晶体管），您也可以使用LIRC从Raspberry Pi发送红外信号。为此，您可以使用`irsend`命令，例如：
- en: '[PRE45]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The IR output channel is enabled within the `/boot/config.txt` file (assuming
    connected to GPIO Pin 19):'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 红外输出通道在`/boot/config.txt`文件中已启用（假设连接到GPIO引脚19）：
- en: '[PRE46]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Avoiding objects and obstacles
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免物体和障碍物
- en: To avoid obstacles, you can place sensors around the robot's perimeter to activate
    whenever an object is encountered. Depending on how you want your robot to behave,
    one avoidance strategy is to just reverse any action last taken (with an additional
    turn for forward/backward actions) that caused one of the sensors to be activated.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免障碍，你可以在机器人的周围放置传感器，以便在遇到物体时自动激活。根据你希望机器人如何行动，一种避免策略是简单地反转最后采取的任何动作（对于前进/后退动作，还需要额外转向），以使其中一个传感器被激活。
- en: Getting ready
  id: totrans-436
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: 'You will need some micro switches to be triggered when there is an impact with
    objects. Depending on the type you have, you need to place enough switches to
    detect any object around the outside (if required, you can use an additional length
    of wire to extend the reach of the switch). Shown in the following photo are two
    possible sensors that will cause the switch to activate when the spring or the
    metal arm hits an object. You need to determine which contacts of the switch open
    or close the circuit (this will depend on the device):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 当与物体发生碰撞时，你需要一些微动开关来触发。根据你拥有的类型，你需要放置足够的开关来检测周围任何物体（如果需要，你可以使用额外的电线长度来扩展开关的感应范围）。以下照片展示了两种可能的传感器，当弹簧或金属臂撞击物体时，这些传感器将导致开关激活。你需要确定哪个开关的触点会打开或关闭电路（这取决于设备）：
- en: '![](img/6c4ecd33-151e-4c9f-a299-4f13e54fd0b2.png)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6c4ecd33-151e-4c9f-a299-4f13e54fd0b2.png)'
- en: Small micro switches can be used as collision sensors
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 小型微动开关可以用作碰撞传感器
- en: How to do it...
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Connect the switches to the GPIO using a method similar to the one we used
    in [Chapter 9](7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml)*, Using Python to Drive
    Hardware*, for the D-Pad controller. A circuit diagram of the switches is as follows:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与我们在[第9章](7cf87b89-8982-4d64-852c-ddfcbf742be5.xhtml)*使用Python驱动硬件*中使用的方法类似的方法，将开关连接到GPIO，用于D-Pad控制器。以下是开关的电路图：
- en: '![](img/3d949ca7-470c-4300-8e42-02432a483bdc.png)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3d949ca7-470c-4300-8e42-02432a483bdc.png)'
- en: The switches should include current limiting resistors (1K ohm is ideal)
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 开关应包括限流电阻（1K欧姆是理想的）
- en: 'How you connect to the Raspberry Pi''s GPIO will depend on how your motor/servo
    drive is wired up. For example, a Rover-Pi robot with an H-bridge motor controller
    can be wired up as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何连接到树莓派的GPIO将取决于你的电机/伺服驱动器的接线方式。例如，一个配备H桥电机控制器的Rover-Pi机器人可以这样接线：
- en: '| **Control side of the module – connecting to the Raspberry Pi GPIO header**
    |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| **模块控制端 – 连接到树莓派GPIO引脚头** |'
- en: '| **ENA** | **IN1** | **IN2** | **IN3** | **IN4** | **ENB** | **GND** | **5V**
    |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| **ENA** | **IN1** | **IN2** | **IN3** | **IN4** | **ENB** | **GND** | **5V**
    |'
- en: '| None | Pin 15 | Pin 16 | Pin 18 | Pin 22 | None | Pin 6 | None |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| 无 | 引脚 15 | 引脚 16 | 引脚 18 | 引脚 22 | 无 | 引脚 6 | 无 |'
- en: Four additional proximity/collision sensors can be connected to the Raspberry
    Pi GPIO
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 四个额外的接近/碰撞传感器可以连接到树莓派的GPIO
- en: 'as follows:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如下所示：
- en: '| **Proximity/collision sensors – connecting to the Raspberry Pi GPIO header**
    |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| **接近/碰撞传感器 – 连接到Raspberry Pi的GPIO引脚头** |'
- en: '| **R_FWD** | **L_FWD** | **R_BWD** | **L_BWD** | **GND** |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| **R_FWD** | **L_FWD** | **R_BWD** | **L_BWD** | **GND** |'
- en: '| Pin 7 | Pin 11 | Pin 12 | Pin 13 | Pin 6 |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 引脚 7 | 引脚 11 | 引脚 12 | 引脚 13 | 引脚 6 |'
- en: If you wired it differently, you can adjust the pin numbers within the code,
    as required. If you require additional pins, then any of the multipurpose pins,
    such as RS232 RX/TX (pins 8 and 10) or the SPI/I²C, can be used as normal GPIO
    pins, too; just set them as input or output, as normal. Normally, we just avoid
    using them, as they are often more useful for expansion and other things, so it
    is sometimes useful to keep them available.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以不同的方式连接，你可以在代码中调整引脚编号，以满足需求。如果你需要额外的引脚，那么任何多功能引脚，例如RS232 RX/TX（引脚8和10）或SPI/I²C，也可以用作正常的GPIO引脚；只需将它们设置为输入或输出，就像平常一样。通常，我们只是避免使用它们，因为它们通常对扩展和其他用途更有用，所以有时保持它们可用是有用的。
- en: You can even use a single GPIO pin for all your sensors if you are just using
    the following example code, since the action is the same, regardless of which
    sensor is triggered. However, by wiring each one separately, you can adjust your
    strategy based on where the obstacle is around the robot or provide additional
    debug information about which sensor has been triggered.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是使用以下示例代码，甚至可以用单个GPIO引脚来连接所有传感器，因为无论哪个传感器被触发，动作都是相同的。然而，通过为每个传感器单独布线，你可以根据障碍物在机器人周围的位置调整你的策略，或者提供有关哪个传感器被触发的额外调试信息。
- en: 'Create the following `avoidance.py` script:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `avoidance.py` 脚本：
- en: '[PRE47]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-457
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We import `rover_drive` to control the robot (if we are using a Pi-Bug robot,
    `bug_drive` can be used) and `wiringpi2` so that we can use the GPIO to read the
    sensors (defined as `PINS`). We define `opCmds`, which uses a Python dictionary
    to allocate new commands in response to the original command (using `opCmds[char]`,
    where `char` is the original command).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`rover_drive`来控制机器人（如果我们使用Pi-Bug机器人，可以使用`bug_drive`）以及`wiringpi2`，以便我们可以使用GPIO来读取传感器（定义为`PINS`）。我们定义了`opCmds`，它使用Python字典来根据原始命令分配新的命令（使用`opCmds[char]`，其中`char`是原始命令）。
- en: We create a new class called `sensor` and set up each of the switches as GPIO
    input (each with an internal pull-ups set). Now, whenever we make a movement (as
    earlier, from the list of requested commands in the `main()` function), we check
    to see if any of the switches have been triggered (by calling `mySensor.checkSensor()`).
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为 `sensor` 的新类，并将每个开关设置为 GPIO 输入（每个都设置了内部上拉电阻）。现在，每当进行移动（如之前所述，从 `main()`
    函数中请求的命令列表），我们都会检查是否有任何开关被触发（通过调用 `mySensor.checkSensor()`）。
- en: If a switch was tripped, we stop the current movement, and then move in the
    opposite direction. However, if we are moving forward when one of the sensors
    is triggered, we move backward, and then turn. This allows the robot to gradually
    turn away from the object that is blocking its path and continue its movement
    in another direction. Similarly, if we are moving backwards and a sensor is triggered,
    we move forward, and then turn. By combining simple object avoidance with directional
    information, the robot can be commanded to navigate around as desired.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开关被跳闸，我们停止当前的运动，然后向相反方向移动。然而，如果我们向前移动时其中一个传感器被触发，我们就向后移动，然后转向。这允许机器人逐渐避开阻挡其路径的物体，并继续向另一个方向移动。同样，如果我们向后移动并且传感器被触发，我们就向前移动，然后转向。通过结合简单的物体避障和方向信息，可以指挥机器人按照所需的方向导航。
- en: There's more...
  id: totrans-461
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are also ways to detect objects that are near the robot without actually
    making physical contact with them. One such way is to use ultrasonic sensors,
    commonly used for vehicle reversing/parking sensors.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 也有方法可以检测到机器人附近的对象，而无需与它们进行实际的身体接触。其中一种方法就是使用超声波传感器，这种传感器通常用于车辆倒车/停车传感器。
- en: Ultrasonic reversing sensors
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超声波倒车传感器
- en: 'Ultrasonic sensors provide an excellent way to measure the distance of the
    robot from obstacles (providing a measurement of between 2 cm and 20 cm) and are
    available at most electrical hobby stores (see the *Appendix,* *Hardware and Software
    List*). The ultrasonic module functions by sending a short burst of ultrasonic
    pulses and then measures the time it takes for the receiver to detect the echo.
    The module then produces a pulse on the echo output that is equal to the time
    measured. This time is equal to the distance traveled divided by the speed of
    sound (340.29 m/sec or 34,029 cm/s), which is the distance from the sensor to
    the object and back again. An ultrasonic module is shown in the following photo:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 超声波传感器提供了一种测量机器人与障碍物距离的绝佳方法（提供2厘米到20厘米的测量范围），并且大多数电子爱好者商店都有销售（见*附录*，*硬件和软件列表*）。超声波模块通过发送一短串超声波脉冲，然后测量接收器检测回波所需的时间来工作。模块随后在回波输出端产生一个脉冲，其时间等于测量的时间。这个时间等于行进距离除以声速（340.29米/秒或34,029厘米/秒），即从传感器到物体再返回的距离。以下照片展示了超声波模块：
- en: '![](img/5d02e95d-f125-4da5-ab66-252cec0fd22c.png)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d02e95d-f125-4da5-ab66-252cec0fd22c.png)'
- en: The HC-SR04 ultrasonic sensor module
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: HC-SR04超声波传感器模块
- en: The sensor requires 5V to power it; it has an input that will receive the trigger
    pulse and an output that the echo pulse will be sent on. While the module works
    with a 3.3V trigger pulse, it responds with a 5V signal on the echo line; so,
    it requires some extra resistors to protect the Raspberry Pi's GPIO.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 该传感器需要5V电压供电；它有一个输入端用于接收触发脉冲，以及一个输出端用于发送回波脉冲。虽然该模块可以使用3.3V触发脉冲工作，但在回波线上它会以5V信号响应；因此，需要一些额外的电阻来保护树莓派的GPIO。
- en: 'The following circuit diagram shows the connection of the sensor output:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以下电路图显示了传感器输出的连接：
- en: '![](img/01c01599-3614-410a-994b-7fb5289a8149.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01c01599-3614-410a-994b-7fb5289a8149.png)'
- en: The sensor echo output must be connected to the Raspberry Pi via a potential
    divider
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器回波输出必须通过分压器连接到树莓派
- en: 'The resistors **R[t]** and **R[b]** create a potential divider; the aim is
    to drop the echo voltage from 5V to around 3V (but not less than 2.5V). Use the
    following equation from [Chapter 10](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,*
    *Sensing and Displaying Real-World Data*, to obtain the output voltage:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 电阻器 **R[t]** 和 **R[b]** 构成一个分压器；目的是将回声电压从 5V 降低到大约 3V（但不少于 2.5V）。使用来自 [第 10
    章](18a915b2-803e-465d-a84a-0b9accdb54f2.xhtml)*,* *感知与显示现实世界数据* 的以下公式来获取输出电压：
- en: '![](img/f410e1fe-d1d4-41e6-80a1-babfe64aa7ab.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f410e1fe-d1d4-41e6-80a1-babfe64aa7ab.png)'
- en: The output voltage (Vout) of the potential divider is calculated using this
    equation
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此公式计算分压器的输出电压（Vout）
- en: This means that we should aim for an **R[t]** to **R[b]** ratio of 2:3 to give
    3V (and not lower than 1:1, which would give 2.5V); that is, **R[t]** equals 2K
    ohm and **R[b]** equals 3K ohm, or 330 ohm and 470 ohm will be fine.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该将**R[t]**到**R[b]**的比率设定为2:3以获得3V（且不低于1:1，这将给出2.5V）；也就是说，**R[t]**等于2K欧姆，**R[b]**等于3K欧姆，或者330欧姆和470欧姆都是可以的。
- en: If you have a voltage meter, you can check it (with everything else disconnected).
    Connect the top of the potential divider to GPIO Pin 2 (5V) and the bottom to
    GPIO Pin 6 (GND), and measure the voltage from the middle (it should be around
    3V).
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个电压表，你可以检查它（其他所有设备都断开连接）。将分压器的顶部连接到GPIO引脚2（5V），底部连接到GPIO引脚6（GND），然后测量中间的电压（应该大约是3V）。
- en: 'Create the following `sonic.py` script:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `sonic.py` 脚本：
- en: '[PRE48]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: First, we define the `TRIGGER` and `ECHO` pins, the length of the trigger pulse,
    and also the speed of sound (340.29 m/s). The `TRIGGER` pin is set as an output,
    and the `ECHO` as an input (we will not need a pull-up or pull-down resistor,
    since the module already has one).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义了`TRIGGER`和`ECHO`引脚，触发脉冲的长度，以及声速（340.29 m/s）。`TRIGGER`引脚被设置为输出，而`ECHO`引脚作为输入（由于模块已经内置了上拉或下拉电阻，我们不需要额外的上拉或下拉电阻）。
- en: The `pulse()` function will send a short trigger pulse (10 microseconds); then
    it will time the duration of the echo pulse. We then calculate the total distance
    traveled by dividing the duration by the speed of sound (the distance to the object
    is just half of this value).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '`pulse()` 函数将发送一个短暂的触发脉冲（10 微秒）；然后它将测量回声脉冲的持续时间。我们随后通过将持续时间除以声速（到物体的距离只是这个值的一半）来计算总行程距离。'
- en: Unfortunately, the sensor can get confused with certain types of objects; it
    will either detect echoes that bounce off a nearby object before being reflected
    back, or not pick up narrow items, such as chair legs. However, combined with
    localized collision sensors, the ultrasonic sensor can aid with the general navigation
    and avoidance of the larger objects.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，传感器可能会对某些类型的物体产生混淆；它要么会检测到反射回来的物体附近的回声，要么无法拾取狭窄的物品，例如椅子腿。然而，结合局部碰撞传感器，超声波传感器可以帮助进行一般导航和避开大型物体。
- en: An improvement to this setup would be to mount the sonic sensor on top of a
    servo, thereby allowing you to make a sensor sweep of the robot's surroundings.
    By making multiple sweeps, taking distance measurements, and tracking the angle
    of the servo, you could build an internal map of the robot's surroundings.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对这个设置的一个改进是将超声波传感器安装在伺服电机上，这样你就可以对机器人的周围环境进行传感器扫描。通过进行多次扫描，测量距离，并跟踪伺服电机的角度，你可以构建机器人周围环境的内部地图。
- en: Getting a sense of direction
  id: totrans-482
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获得方向感
- en: In order to navigate your robot around the environment, you will need to keep
    track of which way your robot is facing. You can estimate the angle that your
    robot turns at by measuring the angle that it turned at in a fixed time period.
    For wheeled robots, you can also measure the rotation of each wheel using a rotary
    encoder (a device that provides a count of the wheel's rotations). However, as
    you make the robot take multiple turns, the direction the robot is facing becomes
    more and more uncertain, as differences in the surfaces and the grip of the wheels
    or legs cause differences in the angles that the robot is turning at.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在环境中导航你的机器人，你需要跟踪机器人面向的方向。你可以通过测量在固定时间段内机器人转过的角度来估计机器人转动的角度。对于轮式机器人，你也可以使用旋转编码器（一种提供轮子旋转计数的设备）来测量每个轮子的旋转。然而，随着机器人进行多次转弯，机器人面向的方向变得越来越不确定，因为表面和轮子或腿的抓地力差异导致机器人转动的角度不同。
- en: Fortunately, we can use an electronic version of a compass; it allows us to
    determine the direction that the robot is facing by providing an angle from magnetic
    north. If we know which direction the robot is facing, we can receive commands
    requesting a particular angle and ensure that the robot moves towards it. This
    allows the robot to perform controlled movements and navigate as required.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以使用指南针的电子版本；它通过提供一个从磁北方向的角度，使我们能够确定机器人面向的方向。如果我们知道机器人面向哪个方向，我们就可以接收请求特定角度的命令，并确保机器人朝那个方向移动。这使机器人能够进行受控运动并按要求进行导航。
- en: When given a target angle, we can determine which direction we need to turn
    towards, until we reach it.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定一个目标角度时，我们可以确定需要转向哪个方向，直到达到它。
- en: Getting ready
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: You will need a magnetometer device, such as PiBorg's **XLoBorg** module (which
    is a
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要一个磁力计设备，例如 PiBorg 的 **XLoBorg** 模块（它是一个
- en: 'combined I²C magnetometer and accelerometer). In this example, we will only
    focus on the magnetometer (the smaller chip on the left) output. The XLoBorg module
    is shown in the following photo:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 结合了I²C磁力计和加速度计）。在这个例子中，我们将只关注磁力计（左侧较小的芯片）的输出。XLoBorg模块在以下照片中展示：
- en: '![](img/fad81355-fd55-4cb3-986b-220373177798.png)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fad81355-fd55-4cb3-986b-220373177798.png)'
- en: The PiBorg XLoBorg module contains a three-axis magnetometer and accelerometer
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: PiBorg XLoBorg模块包含一个三轴磁力计和加速度计
- en: This device can be used with both types of robot, and the angle information
    received from the module can be used to determine which direction the robot needs
    to move in.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 此设备可用于两种类型的机器人，并且从模块接收到的角度信息可以用来确定机器人需要移动的方向。
- en: 'The module is designed to connect directly to the GPIO header, which will block
    all the remaining pins. So, in order to use other GPIO devices, a GPIO splitter
    (such as the PiBorg **TriBorg**) can be used. Alternatively, you can use Dupont
    female to male patch wires to connect just the I²C pins. The connections to be
    made are shown in the following table:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块设计为直接连接到GPIO引脚头，这将阻塞所有剩余的引脚。因此，为了使用其他GPIO设备，可以使用GPIO分线器（例如PiBorg **TriBorg**）。或者，您可以使用杜邦公对母排线仅连接I²C引脚。以下表格显示了需要建立的连接：
- en: '![](img/98584627-1d19-42db-a142-07ed4d9f1039.png)'
  id: totrans-493
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/98584627-1d19-42db-a142-07ed4d9f1039.png)'
- en: Connections to manually wire the XLoBorg module to the Raspberry Pi (using standard
    I²C connections)
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 将 XLoBorg 模块手动连接到 Raspberry Pi（使用标准 I²C 连接）的连接
- en: When viewed from the underside, the PiBorg XLoBorg pins are mirrored compared
    to the Raspberry Pi GPIO header.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 从底部看，PiBorg XLoBorg引脚与Raspberry Pi GPIO引脚相比是镜像的。
- en: How to do it...
  id: totrans-496
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a Python 3-friendly version of the XLoBorg library (`XLoBorg3.py`) using
    `wiringpi2`, as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `wiringpi2` 创建一个兼容 Python 3 的 XLoBorg 库版本 (`XLoBorg3.py`)，具体如下：
- en: '[PRE49]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: How it works...
  id: totrans-499
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The script is based on the XLoBorg library available for the XLoBorg module,
    except that we use WiringPi2, which is Python 3-friendly, to perform the I²C actions.
    Just like our motor/servo drivers, we also define it as a class, so that we can
    drop it into our code and easily replace it with alternative devices if required.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本基于适用于XLoBorg模块的XLoBorg库，除了我们使用Python 3兼容的WiringPi2来执行I²C操作之外。就像我们的电机/伺服驱动器一样，我们也将其定义为类，这样我们就可以将其放入我们的代码中，并在需要时轻松地用其他设备替换它。
- en: We import `wiringpi2`, `time`, and a library called `struct` (which allows us
    to quickly unpack a block of data read from the device into separate items).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入`wiringpi2`、`time`以及一个名为`struct`的库（该库允许我们将从设备读取的数据块快速解包成单独的项目）。
- en: We create the `compass` class, which will include the `__init__()`, `initCompass()`,
    and `readCompassRaw()` functions. The `readCompassRaw()` function is the equivalent
    of the standard XLoBorg `ReadCompassRaw()` function provided by their library.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了`compass`类，该类将包括`__init__()`、`initCompass()`和`readCompassRaw()`函数。`readCompassRaw()`函数等同于他们库中提供的标准XLoBorg
    `ReadCompassRaw()`函数。
- en: The `__init__()` function sets up the I²C bus with `wiringpi2` and registers
    the `degMAG` device on the bus address `0x0E`. The `initCompass()` function sets
    the `CTRL_REG1` and `CTRL_REG2` registers of the device with the settings required
    to quickly get raw readings from the device.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()` 函数使用 `wiringpi2` 设置 I²C 总线，并在总线地址 `0x0E` 上注册 `degMAG` 设备。`initCompass()`
    函数设置设备的 `CTRL_REG1` 和 `CTRL_REG2` 寄存器，以所需的设置从设备快速获取原始读数。'
- en: More details on the MAG3110 registers are available at [http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf](http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf).
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于MAG3110寄存器的详细信息可在[http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf](http://www.freescale.com/files/sensors/doc/data_sheet/MAG3110.pdf)找到。
- en: The `readCompassRaw()` function reads the data registers of the device in a
    single block (using the custom function `readBlockData()`). It reads all of the
    18 registers of the device (`0x00` through to `0x11`). The sensor readings we
    need are contained within the registers `0x01` to `0x06`, which contain the *x*,
    *y*, and *z* readings, split into upper and lower bytes (8-bit values). The `struct.pack()`
    and `struct.unpack()` functions provide an easy way to package them together and
    re-split them as separate words (16-bit values).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`readCompassRaw()` 函数以单个块的形式（使用自定义函数 `readBlockData()`）读取设备的数据寄存器。它读取设备中的所有
    18 个寄存器（从 `0x00` 到 `0x11`）。我们需要的传感器读数包含在寄存器 `0x01` 到 `0x06` 中，这些寄存器包含 *x*、*y*
    和 *z* 读数，分为高字节和低字节（8 位值）。`struct.pack()` 和 `struct.unpack()` 函数提供了一种简单的方法将它们打包在一起，并重新拆分为单独的字（16
    位值）。'
- en: We can test our script by creating a `myCompass` object from the `compass` class
    and reading the sensor values using `myCompass.readCompassRaw()`. You will see
    the raw *x*, *y*, and *z* values from the device, just as you would from the standard
    XLoBorg library.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从`compass`类创建一个`myCompass`对象，并使用`myCompass.readCompassRaw()`来读取传感器值来测试我们的脚本。您将看到来自设备的原始*x*、*y*和*z*值，就像您从标准的XLoBorg库中看到的那样。
- en: As you will find, these values aren't of much use on their own, since they are
    uncalibrated
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您会发现的那样，这些值本身并没有太大的用处，因为它们未经校准
- en: and only give you RAW readings from the magnetometer. What we need is a far
    more useful angle, relative to magnetic north (see the following *There's more...*
    section for details on how to do this).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 只为你提供磁力计的原始读数。我们需要的是一个相对于磁北的更实用的角度（有关如何操作的详细信息，请参阅以下 *还有更多...* 部分）。
- en: There's more...
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: So far, the basic library allows us to see the strength of the magnetic field
    on each of the three axes around the sensor (up/down, left/right, and forward/backward).
    While we can see that these values will change as we move the sensor around, this
    is not enough to steer our robot. First, we need to calibrate the sensor, and
    then determine the direction of the robot from the readings of the *x* and *y*
    axes.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，基本库使我们能够看到传感器周围三个轴（上下、左右和前后）上磁场的强度。虽然我们可以看到这些值会随着我们移动传感器而变化，但这还不足以引导我们的机器人。首先，我们需要校准传感器，然后根据*x*轴和*y*轴的读数确定机器人的方向。
- en: Calibrating the compass
  id: totrans-511
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 校准指南针
- en: The compass needs to be calibrated in order to report values that are centered
    and equalized. This is needed because there are magnetic fields all around; by
    calibrating the sensor, we can cancel out the effect of any localized fields.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 罗盘需要校准以便报告中心化和均衡的值。这是必要的，因为周围存在磁场；通过校准传感器，我们可以消除任何局部磁场的影响。
- en: By measuring the readings of the compass on all axes, we can determine the minimum
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 通过测量所有轴向上的指南针读数，我们可以确定最小
- en: and maximum values for each axis. This will allow us to calculate the mid-point
    of the readings, and also the scaling, so that each axis will read the same value
    whenever it is facing the same way.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 并且为每个轴设置最大值。这将使我们能够计算读数的中间值，以及缩放比例，以便每个轴在朝向相同方向时都能读取相同的值。
- en: 'Add the following code at the top of the file (after the `import` statements):'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部添加以下代码（在`import`语句之后）：
- en: '[PRE50]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add the following code to `__init__(self)` of the `compass` class:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到`compass`类的`__init__(self)`方法中：
- en: '[PRE51]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Add a new function named `calibrateCompass()` within the `compass` class, as
    follows:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compass`类中添加一个名为`calibrateCompass()`的新函数，如下所示：
- en: '[PRE52]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add another new function named `readCompass()` in the `compass` class, as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在`compass`类中添加另一个名为`readCompass()`的新函数，如下所示：
- en: '[PRE53]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you look closely at the readings (if you use `readCompass()`), you will now
    find that all of the readings have the same range and are centered around the
    same values.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察读数（如果你使用`readCompass()`），你现在会发现所有的读数都具有相同的范围，并且都集中在相同的数值周围。
- en: Calculating the compass bearing
  id: totrans-524
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算罗盘方位
- en: 'The XLoBorg library only provides access to the RAW values of the MAG3110 device,
    which provides a measure of how strong the magnetic field on each of the axes
    is. To determine the direction of the sensor, we can use the readings from the
    *x* and *y* axes (assuming that we have mounted and calibrated the sensor horizontally).
    The readings of the *x* and *y* axes are proportional to the magnetic field in
    each direction around the sensor, as shown in the following diagram:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: XLoBorg库仅提供对MAG3110设备的原始值访问，该设备可以测量每个轴上磁场的强度。为了确定传感器的方向，我们可以使用*x*轴和*y*轴的读数（假设我们已经水平安装并校准了传感器）。*x*轴和*y*轴的读数与传感器周围每个方向的磁场成正比，如下所示图示：
- en: '![](img/75844b13-7dc2-475d-8bfb-219ae254be4b.png)'
  id: totrans-526
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75844b13-7dc2-475d-8bfb-219ae254be4b.png)'
- en: The magnetometer measures the strength of the magnetic field on each axis
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 磁强计测量每个轴向上的磁场强度
- en: 'The angle at which we turned away from the north can be calculated with the
    formula shown in the following diagram:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 我们偏离北方的角度可以通过以下图中所示的公式进行计算：
- en: '![](img/2b819cd7-6306-41ea-bb1b-a6e88bb69683.png)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b819cd7-6306-41ea-bb1b-a6e88bb69683.png)'
- en: The angle we are pointing towards (that is relative to magnetic north) can be
    calculated using the measurements *Rx* and *Ry*
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所指的方向角（相对于磁北）可以通过测量 *Rx* 和 *Ry* 来计算
- en: 'We can now obtain the `compass` angle by adding the `readCompassAngle()` function
    to our `compass` class, as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过将`readCompassAngle()`函数添加到我们的`compass`类中，来获取`指南针`角度，如下所示：
- en: '[PRE54]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We also need to add the following `import` with the other `import` statements:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加以下`import`语句，与其它`import`语句一起：
- en: '[PRE55]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: We use the math function, `math.atan2()`, to calculate our angle (`atan2` will
    return with the angle relative to the *x* axis of the coordinates `read[1]` and
    `read[2]` – the angle we want). The angle is in radians, which means that one
    full turn is defined as 2Pi, rather than 360 degrees. We convert it back to degrees
    by multiplying it by 360 and dividing by 2Pi. Since we wish to have our angle
    between the range of 0 to 360 degrees (rather than -180 to 180 degrees), we must
    ensure that it is positive by adding the equivalent of a full circle (2Pi) to
    any negative values.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用数学函数 `math.atan2()` 来计算我们的角度（`atan2` 将返回相对于坐标 `read[1]` 和 `read[2]` 的 *x*
    轴的角度——即我们想要的角度）。角度以弧度为单位，这意味着一个完整的旋转被定义为 2Pi，而不是 360 度。我们通过将其乘以 360 并除以 2Pi 来将其转换回度。由于我们希望角度在
    0 到 360 度的范围内（而不是 -180 到 180 度），我们必须通过向任何负值添加相当于一个完整圆（2Pi）的值来确保它是正的。
- en: With the sensor calibrated and the angle calculated, we should now have the
    proper compass bearing to use on our robot. To compare, you can see the result
    of using the uncalibrated value in our calculation by calling the function with
    `readCompassAngle (cal=False)`.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 传感器校准完成且角度计算后，我们现在应该已经拥有了在机器人上使用的正确罗盘方位。为了比较，您可以通过调用函数`readCompassAngle (cal=False)`来查看使用未校准值计算的结果。
- en: Saving the calibration
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保存校准
- en: Having calibrated the sensor once in its current position, it would be inconvenient
    to have to calibrate it each and every time that you ran the robot. Therefore,
    you can add the following code to your library to automatically save your calibration
    and read it from a file the next time you run your robot. To create a new calibration,
    either delete or rename `mag.cal` (which is created in the same folder as your
    script), or create your `compass` object `compass(newCal=True)`.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前位置对传感器进行一次校准后，每次运行机器人时都需要重新校准将会很不方便。因此，你可以将以下代码添加到你的库中，以自动保存你的校准并在下次运行你的机器人时从文件中读取它。要创建一个新的校准，你可以删除或重命名`mag.cal`（它位于你的脚本相同的文件夹中），或者创建你的`compass`对象`compass(newCal=True)`。
- en: 'Add the following code near the top of the file (after the `imports` statements):'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件顶部附近添加以下代码（在`导入`语句之后）：
- en: '[PRE56]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Change `__init__(self)` to `__init__(self,newCal=False)`.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `__init__(self)` 改为 `__init__(self,newCal=False)`.
- en: 'Also, consider the following line:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 还要考虑以下行：
- en: '[PRE57]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Change the previous line to the following line:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 将上一行改为以下行：
- en: '[PRE58]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Add `readCal()` to the `compass` class, as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `readCal()` 添加到 `compass` 类中，如下所示：
- en: '[PRE59]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Add `writeCal()` to the `compass` class, as follows:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `writeCal()` 方法添加到 `compass` 类中，如下所示：
- en: '[PRE60]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Driving the robot using the compass
  id: totrans-550
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指南针驾驶机器人
- en: Now, all that remains for us to do is use the compass bearing to steer our robot
    to the desired angle.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们剩下的任务就是利用指南针的方位来引导我们的机器人到达期望的角度。
- en: 'Create the following `compassDrive.py` script:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 创建以下 `compassDrive.py` 脚本：
- en: '[PRE61]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We import the modules that we previously created: `XLoBorg3`, `rover_drive`
    (for the Rover-Pi robot, or the alternative `bug_drive`, as required), and `time`.
    Next, we create a function that will return `LEFT`, `RIGHT`, or `DONE`, based
    on the given target angle (requested by the user) and the current angle (read
    from the `compass` class). If the compass angle is within 180 degrees less than
    the target angle, then we turn `LEFT`. Similarly, if it is within 180 degrees,
    we turn `RIGHT`. Finally, if the compass angle is within the margin (+10 degrees/-10
    degrees), then we are `DONE`. By using `angle%360` (which gives us the remainder
    from dividing the angle by 360), we ensure the angles are all 0-360 (that is,
    -90 becomes 270).'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入之前创建的模块：`XLoBorg3`、`rover_drive`（用于Rover-Pi机器人，或者根据需要使用替代的`bug_drive`），以及`time`。接下来，我们创建一个函数，该函数将根据给定的目标角度（由用户请求）和当前角度（从`compass`类读取）返回`LEFT`、`RIGHT`或`DONE`。如果指南针角度在目标角度180度以内，则我们转向`LEFT`。同样，如果它在180度以内，我们转向`RIGHT`。最后，如果指南针角度在误差范围内（+10度/-10度），则我们完成`DONE`。通过使用`angle%360`（它给出了角度除以360的余数），我们确保所有角度都在0-360度（即-90度变为270度）。
- en: For the `main()` function, we create `myCompass` (an `XLoBorg.compass` object)
    and `myBot` (a `drive.motor()` object); these allow us to determine the direction
    we are facing in, and provide us with a way to drive in the desired direction.
    Within the `main` loop, we prompt for a target angle, find the current angle that
    our robot is facing at, and then continue to turn towards the required angle until
    we reach it (or reach somewhere near enough to that angle).
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`main()`函数，我们创建了`myCompass`（一个`XLoBorg.compass`对象）和`myBot`（一个`drive.motor()`对象）；这些使我们能够确定我们面对的方向，并为我们提供了一种按照期望方向行驶的方法。在`main`循环中，我们要求输入目标角度，找到我们的机器人当前面对的角度，然后继续转向所需的角度，直到达到该角度（或者达到接近该角度的地方）。
