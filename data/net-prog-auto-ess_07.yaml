- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Error Handling and Logging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理和日志记录
- en: 'We described how Python and Go run and how they access the network in the previous
    chapter; however, we missed two important points when building our network automation
    solution: how we report program execution events and how we handle errors.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们描述了Python和Go的运行方式以及它们如何访问网络；然而，在构建我们的网络自动化解决方案时，我们遗漏了两个重要的点：如何报告程序执行事件以及如何处理错误。
- en: These two topics are not as easy as they seem, and they are, most of the time,
    implemented in the system poorly. Some network developers might not do it properly
    because of lack of knowledge, but there are also some developers that don’t do
    it properly because of time constraints and extra time needed for coding.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个主题并不像它们看起来那么简单，而且它们大多数时候在系统中都实现得不好。一些网络开发者可能由于知识不足而没有正确地做到这一点，但也有一些开发者由于时间限制和编码所需额外时间而没有正确地做到这一点。
- en: But are these activities really important? Let’s examine these in this chapter.
    First, let’s investigate how and why we handle errors and then why and how we
    do event logging.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但这些活动真的重要吗？让我们在本章中探讨这些问题。首先，让我们研究我们如何以及为什么处理错误，然后研究我们为什么以及如何进行事件记录。
- en: 'Here are the topics we are going to cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Writing code for error handling
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写错误处理代码
- en: Logging events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录事件
- en: Adding logging to your code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的代码中添加日志记录
- en: After reading this chapter, you will be able to add effectively code to handle
    errors and log events in your network development.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你将能够有效地添加代码来处理错误并在你的网络开发中记录事件。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code described in this chapter is stored in the GitHub repository
    at [https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中描述的源代码存储在GitHub仓库[https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07](https://github.com/PacktPublishing/Network-Programming-and-Automation-Essentials/tree/main/Chapter07)中。
- en: Writing code for error handling
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写错误处理代码
- en: To see how important handling errors is, we have to think of our system as a
    whole, including inputs and output. Our code by itself might never experience
    an error; however, when integrated with other systems, it might cause unpredictable
    outputs, or might just crash and stop working.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解处理错误的重要性，我们必须将我们的系统作为一个整体来考虑，包括输入和输出。我们的代码本身可能永远不会遇到错误；然而，当与其他系统集成时，它可能会产生不可预测的输出，或者可能只是崩溃并停止工作。
- en: Therefore, handling errors is important to cope with the unpredictability of
    inputs and protect your code to avoid wrong outputs or crashes. But how do we
    do that?
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，处理错误对于应对输入的不确定性以及保护你的代码以避免错误输出或崩溃至关重要。但我们如何做到这一点呢？
- en: First, we need to identify our inputs, and then we create a series of different
    combinations of values that are sent to our inputs. The behavior of these input
    combinations are then evaluated by running our code. For a function, we do that
    by adding unit tests, as we discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127).
    For the system, we add integration tests and end-to-end testing. Additional techniques
    were also discussed in [*Chapter 5*](B18165_05.xhtml#_idTextAnchor127).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定我们的输入，然后我们创建一系列不同的值组合，这些值被发送到我们的输入。然后通过运行我们的代码来评估这些输入组合的行为。对于一个函数，我们通过添加单元测试来实现，正如我们在[*第五章*](B18165_05.xhtml#_idTextAnchor127)中讨论的那样。对于系统，我们添加集成测试和端到端测试。在[*第五章*](B18165_05.xhtml#_idTextAnchor127)中也讨论了其他一些技术。
- en: But what is the correct way to write code for handling errors? It will depend
    on the language.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但编写处理错误的代码的正确方法是什么？这取决于语言。
- en: Writing code to handle errors is quite different in Go compared to Python. Let’s
    see how we do this effectively in Go then in Python.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中编写处理错误的代码与Python相比有很大不同。让我们看看我们如何在Go中有效地做到这一点，然后再在Python中做到这一点。
- en: Adding error handling in Go
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Go中添加错误处理
- en: The design of the Go language requires explicitly checking errors when they
    occur, which is different from throwing exceptions and then catching them like
    in Python. In Go, errors are just values returned by functions, which makes Go
    coding a bit more verbose and perhaps more repetitive. With Python, you would
    not need to check errors, as an exception would be raised, but in Go, you have
    to check the errors. But on the other hand, Go error handling is much simpler
    compared to Python.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的设计要求在发生错误时显式检查错误，这与Python中抛出异常然后捕获它们的方式不同。在Go中，错误只是函数返回的值，这使得Go编码更加冗长，也许更加重复。在Python中，你不需要检查错误，因为会抛出异常，但在Go中，你必须检查错误。但另一方面，与Python相比，Go的错误处理要简单得多。
- en: 'Errors in Go are created by using an `error` type interface, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的错误是通过使用`error`类型接口创建的，如下所示：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see in the preceding code, the error implementation in Go is quite
    simple by using a method called `Error()` that returns an error message as a string.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，Go中的错误实现通过使用名为`Error()`的方法来返回错误消息作为字符串，相当简单。
- en: The correct way to construct an error in your code is by using either the `errors`
    or `fmt` standard libraries
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中构建错误的正确方式是使用`errors`或`fmt`标准库。
- en: The following are two examples of using each of them for a division-by-zero
    function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是两个使用每个函数进行除以零函数的示例。
- en: 'Using the `errors` library looks as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`errors`库的示例如下：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `fmt` library looks as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fmt`库的示例如下：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding two examples produce the same results. For instance, if you call
    any of the two functions with `fmt.Println(divide(10, 0))`, it will print the
    following output: `0 divided by zero` `not valid`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例产生相同的结果。例如，如果你调用这两个函数中的任何一个并使用`fmt.Println(divide(10, 0))`，它将打印以下输出：`0
    divided by zero` `not valid`。
- en: The major difference between `fmt.Errorf` and `errors.New` is the possibility
    of formatting the string and adding values. Another point is that `errors.New`
    is faster because it does not invoke the formatter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`fmt.Errorf`和`errors.New`之间的主要区别在于格式化字符串和添加值的可能性。另一个点是`errors.New`更快，因为它没有调用格式化器。'
- en: If you are looking to create custom errors, stack traces, and more advanced
    error features, consider using the `errors` library or third-party libraries such
    as the popular `pkg/errors` ([https://pkg.go.dev/github.com/pkg/errors](https://pkg.go.dev/github.com/pkg/errors))
    or `golang.org/x/xerrors` ([https://pkg.go.dev/golang.org/x/xerrors](https://pkg.go.dev/golang.org/x/xerrors)).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建自定义错误、堆栈跟踪和更高级的错误功能，请考虑使用`errors`库或第三方库，如流行的`pkg/errors` ([https://pkg.go.dev/github.com/pkg/errors](https://pkg.go.dev/github.com/pkg/errors))
    或 `golang.org/x/xerrors` ([https://pkg.go.dev/golang.org/x/xerrors](https://pkg.go.dev/golang.org/x/xerrors))。
- en: Let’s focus now on the best practices when writing code for error handling in
    Go. The following are the top best practices.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在关注编写Go中错误处理代码的最佳实践。以下是一些最佳实践。
- en: Return errors last and values to 0
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最后返回错误，并将值设为0
- en: 'When creating a function that returns several values, the error should be placed
    as the last argument returned. When returning values with errors, use 0 when it
    is a number and `empty string` for strings, as in the following example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个返回多个值的函数时，错误应该放在返回值的最后一个参数。当返回带有错误的值时，如果是数字则使用0，如果是字符串则使用`empty string`，如下例所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, the value of the string returned is empty and the
    value of `int` returned is 0\. These values are just suggestions, because when
    an error is returned, the calling statement will first check whether there is
    an error before assigning the returned variables. Therefore, the values returned
    with an error are irrelevant.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，返回的字符串值为空，返回的`int`值为0。这些值只是建议，因为当返回错误时，调用语句会首先检查是否存在错误，然后再分配返回的变量。因此，带有错误的返回值是不相关的。
- en: Add only information that the caller does not have
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 只添加调用者没有的信息
- en: 'When creating the error message, do not add information that is already known
    by the caller of your function. The following example illustrates this problem:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建错误消息时，不要添加调用者已经知道的信息。以下示例说明了这个问题：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see in the preceding example, the value of `q` was returned in the
    error message. But that is not necessary, because the caller of the `divide` function
    has this value.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述示例所示，`q`的值被返回在错误消息中。但这不是必要的，因为`divide`函数的调用者已经有了这个值。
- en: When creating errors to return in your function, do not include any arguments
    passed in the function, as this is known by the caller. This can lead to information
    duplication.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的函数中创建要返回的错误时，不要包含任何传递给函数的参数，因为这是调用者所知道的。这可能导致信息重复。
- en: Use lowercase and do not end with punctuation
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用小写且不要以标点符号结尾
- en: Always use lowercase as your error message will be concatenated with other messages
    when returning. Most of the time, you should also not use any punctuation, because
    the error messages will probably be linked together, and punctuation will end
    up looking odd in the middle of the error message.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总是使用小写，因为错误信息将在返回时与其他消息连接。大多数时候，您也不应使用任何标点符号，因为错误信息可能会链接在一起，标点符号最终会在错误信息中间看起来很奇怪。
- en: The exception of the lowercase rule is when you are referring to the names of
    functions or methods that already have capital letters.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 小写规则的一个例外是当您引用已经具有大写字母的函数或方法名称时。
- en: Add a colon to the error message
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在错误信息中添加冒号
- en: 'A colon (`:`) is used whenever you want to add information from another error
    message of a call made inside your code. Let’s use the following code as an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 冒号（`:`）用于您想要添加来自代码内部调用产生的另一个错误信息的任何信息时。以下代码将作为示例：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the `connect` function encapsulates a call to `ssh.Dial`.
    We can add the context of the error to the error message by indicating which call
    generated the error by adding the name of the call or some information about `ssh.Dial`,
    using a colon to separate it if necessary. Note that the `config` and `host` arguments
    are known by the caller of the `connect` function and therefore should not be
    added to the error message.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，`connect` 函数封装了对 `ssh.Dial` 的调用。我们可以通过添加调用名称或有关 `ssh.Dial` 的信息来将错误上下文添加到错误信息中，如果需要，使用冒号分隔。请注意，`config`
    和 `host` 参数由 `connect` 函数的调用者知道，因此不应添加到错误信息中。
- en: Use defer, panic, and recover
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 defer、panic 和 recover
- en: Go has important mechanisms to control how the program flows during errors.
    That is mostly useful when using goroutines, because one might cause the program
    to crash, and you might need to be extra careful to avoid unclosed software pipes
    and software caches; and avoid unfreed memory and unclosed file descriptors
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Go 有重要的机制来控制程序在错误发生时的流程。这主要用于使用 goroutines，因为一个错误可能会导致程序崩溃，您可能需要格外小心以避免未关闭的软件管道和软件缓存；以及避免未释放的内存和未关闭的文件描述符。
- en: defer
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: defer
- en: 'Go `defer` is used to push the execution to a list that is only executed after
    the surrounding function has returned or when it crashes. The main intention of
    `defer` is to perform a cleanup. Consider the following example of a function
    that copies data from one file to another and then removes it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的 `defer` 用于将执行推送到一个列表，该列表仅在周围函数返回或崩溃后执行。`defer` 的主要目的是执行清理。考虑以下示例，该示例将数据从文件复制到另一个文件，然后删除它：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding example, if an error occurs in `os.Create`, the function would
    return before calling `src.Close()`, which means the file has not been closed
    properly.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前例中，如果 `os.Create` 发生错误，函数会在调用 `src.Close()` 之前返回，这意味着文件没有被正确关闭。
- en: 'The way to avoid having to add the `close` statement repetitively throughout
    the code is to use `defer`, like the following example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 避免在代码中重复添加 `close` 语句的方法是使用 `defer`，如下例所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see in the preceding example, `defer` is used just after a successful
    `os.Open` and after a successful `os.Create`. Therefore, if there is an error,
    or if the function ends, it will invoke `dst.Close()` first and then `src.Close()`
    in a reverse order, like in a **Last In, First Out** (**LIFO**) queue.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`defer` 在成功的 `os.Open` 和成功的 `os.Create` 之后使用。因此，如果发生错误或函数结束，它将首先调用 `dst.Close()`，然后以相反的顺序调用
    `src.Close()`，就像一个 **后进先出**（**LIFO**）队列一样。
- en: Let’s see how to use `panic` now.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用 `panic`。
- en: panic
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: panic
- en: 'When writing code, if you don’t want to handle an error, you can use `panic`
    to indicate that you want to stop immediately. In Go, `panic` can be called in
    your program by explicitly writing it, but it is also called automatically during
    runtime if an error occurs. The following is a list of the major runtime errors
    that can occur:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，如果您不想处理错误，可以使用 `panic` 来立即停止。在 Go 中，可以通过显式编写来调用 `panic`，但在运行时如果发生错误，它也会自动调用。以下是可以发生的重大运行时错误列表：
- en: Out-of-bounds memory access, including arrays
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越界内存访问，包括数组
- en: Assertion of a wrong type
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误类型断言
- en: Attempting to call a function using a variable with a `nil` pointer
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试使用`nil`指针调用函数
- en: Sending data to a closed channel or file descriptor
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向已关闭的通道或文件描述符发送数据
- en: Division by zero
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零除
- en: Therefore, `panic` is only used in your code when you are not planning to handle
    the error or are dealing with errors that are not yet understood.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`panic`仅在你不打算处理错误或处理尚未理解的错误时才用于你的代码中。
- en: It is important to note that before exiting the function and passing the `panic`
    message, the program will still run all `defer` statements that were stacked earlier
    in the function.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在退出函数并传递`panic`消息之前，程序仍然会运行在函数中之前堆叠的所有`defer`语句。
- en: 'Here is an example of using `panic` to exit the program after receiving a negative
    value as an argument:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用`panic`在接收到负值作为参数后退出程序示例：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s run this program and check the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行这个程序并检查输出：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that the output does not print `done`, because `panic` is called inside
    the `squareRoot` function, before the instruction to print.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出没有打印`done`，因为`panic`是在`squareRoot`函数中调用的，在打印指令之前。
- en: 'Say we add `defer` to the function as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们按照以下方式将`defer`添加到函数中：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The output will be as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将如下所示：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note that the `ending the function` print statement was placed before sending
    the `panic` message. That is because, as we explained, the `defer` stack is executed
    before returning the function by `panic`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`ending the function`打印语句是在发送`panic`消息之前放置的。这是因为，正如我们解释的，`defer`栈在`panic`返回函数之前执行。
- en: Let’s now see how we can use `recover`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何使用`recover`。
- en: recover
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: recover
- en: In Go, `recover` is the last piece of error flow control necessary to handle
    errors. It is used to handle a `panic` situation and regain control. It should
    only be used inside a `defer` function call. In a normal call, `recover` will
    return a `nil` value, but in the `panic` situation, it will return the value given
    to `panic`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go中，`recover`是处理错误所需的最后一块错误流控制。它用于处理`panic`情况并恢复控制。它应该只在使用`defer`函数调用时使用。在正常调用中，`recover`将返回一个`nil`值，但在`panic`情况下，它将返回`panic`给出的值。
- en: 'As an example, let’s consider the following program:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们考虑以下程序：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you run the preceding program, you will get the following `panic` message:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的程序，你会得到以下`panic`消息：
- en: '[PRE13]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from this output, you have no control of the `panic` situation.
    It will basically crash the program without the possibility to handle the error
    properly. This is undesirable in most production software, especially using multiple
    goroutines.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如从这个输出中可以看出，你对`panic`情况没有控制权。它基本上会崩溃程序，没有机会正确处理错误。这在大多数生产软件中是不理想的，尤其是在使用多个goroutine时。
- en: 'Therefore, to properly handle the `panic` situation, you should add a `defer`
    function to test whether it is a `panic` situation by using `recover`, as in the
    following example:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了正确处理`panic`情况，你应该添加一个`defer`函数来测试是否是`panic`情况，使用`recover`，如下例所示：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After adding the `defer` function as in the preceding example, the output will
    be as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了与前面示例相同的`defer`函数之后，输出将如下所示：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, adding a `recover` test inside the `defer` function will allow
    you to handle unexpected `panic` situations, avoiding your program crashing unexpectedly
    without doing a proper cleanup or fixing the error.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在`defer`函数内添加一个`recover`测试将允许你处理意外的`panic`情况，避免程序意外崩溃，没有进行适当的清理或修复错误。
- en: Now that we have investigated how to handle Go errors, let’s have a look at
    Python error handling.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经研究了如何处理Go错误，让我们看看Python的错误处理。
- en: Adding error handling in Python
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Python中添加错误处理
- en: Python handles errors differently than Go. Python does not require your function
    to return error values. In Python, errors are thrown during runtime and they are
    called exceptions. To handle exceptions, your code has to catch them properly
    and avoid raising them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Python处理错误的方式与Go不同。Python不需要你的函数返回错误值。在Python中，错误在运行时抛出，它们被称为异常。为了处理异常，你的代码必须正确捕获它们并避免引发它们。
- en: Catching exceptions
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'In Python, there are built-in exceptions that are raised by many runtime errors.
    The list of built-in exceptions is quite long and can be found here: [https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html).
    As an example, the division-by-zero error is called a `ZeroDivisionError` exception.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，有许多运行时错误会引发内置异常。内置异常的列表相当长，可以在以下位置找到：[https://docs.python.org/3/library/exceptions.html](https://docs.python.org/3/library/exceptions.html)。例如，除以零错误被称为`ZeroDivisionError`异常。
- en: 'To handle the error, you need to catch the exception and then handle it by
    using the `try`, `except`, `else`, and `finally` Python statements. To create
    an example of how to handle the exception for division by zero, let’s first run
    the following program without catching an exception:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理错误，您需要捕获异常，然后使用`try`、`except`、`else`和`finally` Python语句来处理它。为了创建一个处理除以零异常的示例，让我们首先运行以下程序而不捕获异常：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you run the preceding program, it will generate the following output:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的程序，它将生成以下输出：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, the program crashes and shows the error message as `Traceback`
    on the screen, with details of where the error occurs and the name of the exception,
    in this case, `ZeroDivisionError`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，程序崩溃并在屏幕上显示错误消息作为`Traceback`，其中包含错误发生的位置和异常名称的详细信息，在这种情况下是`ZeroDivisionError`。
- en: 'Now, let’s update the Python code to catch this exception and handle the error
    more gracefully, like the following code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更新Python代码以捕获此异常并更优雅地处理错误，如下所示：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if you run the program, it will print the error gracefully without crashing
    it, as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您运行程序，它将优雅地打印错误而不会崩溃，如下所示：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: So, whenever you think there is a possibility for the function to raise an exception
    by an error, use the `try` and `except` statements, as shown in the preceding
    example.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每当您认为函数可能会通过错误引发异常时，请使用`try`和`except`语句，正如前一个示例所示。
- en: 'In addition to `try` and `except` statements, Python also allows using `else`
    and `finally` statements to add more flow control of the error handling. They
    are not mandatory as the flow can be controlled outside the `try`/`except` statement,
    but they are sometimes useful. The following is the same example of adding the
    `else` and `finally` statements:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`try`和`except`语句之外，Python还允许使用`else`和`finally`语句来添加更多的错误处理流程控制。它们不是强制的，因为流程可以在`try`/`except`语句之外控制，但有时它们很有用。以下是在相同示例中添加`else`和`finally`语句的代码：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you run this program, it will generate the following output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此程序，它将生成以下输出：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the `else` statement is only executed if no exception was raised in
    the `try` clause. The `finally` statement is always executed, regardless of whether
    an exception was raised or not in the `try` clause.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有当`try`子句中没有引发异常时，`else`语句才会执行。`finally`语句总是执行，无论`try`子句中是否引发了异常。
- en: Now that we have seen how to catch an exception in Python, let’s discuss how
    to choose the exception we want to catch.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何在Python中捕获异常，让我们讨论如何选择我们想要捕获的异常。
- en: Choosing more specific exceptions
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择更具体的异常
- en: 'In Python, exceptions are hierarchical and always start with the exception
    called `BaseException`. As an example, division by zero exhibits the following
    hierarchy:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，异常是有层次的，并且始终以名为`BaseException`的异常开始。例如，除以零展示了以下层次结构：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The exceptions hierarchy is quite useful, because your code can catch either
    a higher-level exception or a more specific one. With division by zero, you could
    catch the `ArithmeticError` exception instead of `ZeroDivisionError`. However,
    it’s a good practice sometimes to catch the more specific exception instead of
    a higher-level one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 异常层次结构非常有用，因为您的代码可以捕获更高层次的异常或更具体的异常。对于除以零的情况，您可以捕获`ArithmeticError`异常而不是`ZeroDivisionError`。然而，有时捕获更具体的异常而不是更高层次的异常是一种好的实践。
- en: More specific exceptions are more desirable to be caught inside functions and
    libraries, because if you catch generic exceptions inside the function, you might
    mask the problem when another part of the code calls your function. So, it will
    depend on where you are catching and how you are handling it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体的异常更希望在函数和库内部捕获，因为如果您在函数内部捕获通用异常，那么当代码的另一个部分调用您的函数时，可能会掩盖问题。因此，这取决于您在哪里捕获以及如何处理它。
- en: We now have a good idea how to handle errors in Go and Python. Let’s discuss
    how to add logging to our code.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对如何在Go和Python中处理错误有了很好的了解。让我们讨论如何将日志记录添加到我们的代码中。
- en: Logging events
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记录事件
- en: In computer software, logging is a well-known technique used to help troubleshoot
    a problem, record milestones, understand behavior, retrieve information, and check
    historical events, among other useful actions. Despite these advantages, not many
    developers add proper logging to their code. In fact, some developers do nothing
    and add logging only when the program has problems and needs debugging.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机软件中，日志记录是一种众所周知的技巧，用于帮助调试问题、记录里程碑、理解行为、检索信息和检查历史事件，以及其他有用的操作。尽管有这些优势，但许多开发人员并没有在他们的代码中添加适当的日志记录。事实上，一些开发人员什么都不做，只有在程序出现问题时才添加日志记录以进行调试。
- en: In network automation, logging is even more important, because network elements
    are normally distributed and rely heavily on logging to be able to be audited
    in case of a problem or if an improvement is needed. Adding logging to your code
    is a good practice that will be appreciated by several levels of engineering,
    such as network operators, network planners, network security, and network designers,
    among others.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络自动化中，日志记录甚至更为重要，因为网络元素通常是分布式的，并且严重依赖日志记录以便在出现问题时或需要改进时进行审计。将日志添加到您的代码中是一种良好的实践，将受到多个工程级别的赞赏，例如网络操作员、网络规划师、网络安全和网络设计师等。
- en: But one important point here that must be observed is that time synchronization
    between network elements is mandatory to allow logging to be useful. Protocols
    such as the **Network Time Protocol** (**NTP**) or **Precision Time Protocol**
    (**PTP**) must be used throughout the network.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个重要观点必须注意，那就是网络元素之间的时间同步是强制性的，以便使日志变得有用。必须在整个网络中使用诸如**网络时间协议**（**NTP**）或**精确时间协议**（**PTP**）之类的协议。
- en: A good practice to use logging is to use the Unix logging reference called `syslog`,
    firstly published as an informational RFC in RFC3164 and then as a standard document
    in RFC5424 ([https://www.rfc-editor.org/rfc/rfc3164](https://www.rfc-editor.org/rfc/rfc3164)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志的一个良好实践是使用名为`syslog`的Unix日志参考，它最初作为RFC3164的信息性RFC发布，后来作为RFC5424的标准文档。([https://www.rfc-editor.org/rfc/rfc3164](https://www.rfc-editor.org/rfc/rfc3164))
- en: For our network automation code, we do not need to follow all the details in
    the `syslog` protocol standard, but we are going to use it as a guide for logging
    useful information based on severity level.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的网络自动化代码，我们不需要遵循`syslog`协议标准的所有细节，但我们将根据严重程度级别将其用作记录有用信息的指南。
- en: Let’s now talk about some levels of information we want when logging events.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈在记录事件时我们希望记录的一些信息级别。
- en: Severity levels
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 严重程度级别
- en: 'The RFC5424 `syslog` protocol has defined eight levels of severity, which are
    described in *Section 6.2.1* of RFC5424 ([https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1](https://www.rfc-editor.org/rfc/rfc5424#section-6.2.1)).
    They are mentioned in the following list with a brief explanation of what kind
    of information message is intended to be added to each one:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: RFC5424的`syslog`协议定义了八个严重程度级别，这些级别在RFC5424的*第6.2.1节*中描述。以下列表中提到了这些级别，并简要说明了打算添加到每个级别的信息消息类型：
- en: '`Emergency`: The system is not operational and there is no possible recovery.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`紧急`: 系统无法运行，且无法恢复。'
- en: '`Alert`: Immediate attention is required.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警报`: 需要立即关注。'
- en: '`Critical`: Something bad is happening and quick attention is required to fix
    it.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`关键`: 发生了不好的事情，需要快速关注以修复它。'
- en: '`Error`: Failure is occurring but does not need urgent attention.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`错误`: 正在发生故障，但不需要紧急关注。'
- en: '`Warning or Warn`: Indicates that something is wrong and might cause an error
    in the future, such as software not updated.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`警告或Warn`: 表明有问题，可能会在未来导致错误，例如软件未更新。'
- en: '`Notice`: An important milestone that has been reached and might indicate a
    future warning, such as configuration not saved or resource utilization limit
    not set.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`通知`: 已达到一个重要里程碑，可能表明未来的警告，例如配置未保存或资源利用率限制未设置。'
- en: '`Informational or Info`: Normal operational milestone messages. Used later
    for audit and investigation.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`信息性或Info`: 正常操作里程碑消息。用于以后的审计和调查。'
- en: '`Debug`: Used by developers to troubleshoot a problem or to investigate possible
    improvements.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`调试`: 由开发人员用于调试问题或调查可能的改进。'
- en: Although these eight levels are defined in the `syslog` protocol, they are quite
    ambiguous and open to different interpretations. For instance, `Alert` and `Emergency`
    might be different for different developers when writing code, as is the case
    with other levels, such as `Notice` and `Informational`. Therefore, some network
    developers prefer to use less levels with easier interpretation. The number will
    depend on how the network operates, but varies between three and five levels.
    For Go and Python, the number of levels will depend on the library you are using
    to create the log messages. Some might have more levels than others.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这八个级别在 `syslog` 协议中定义，但它们相当模糊，容易产生不同的解释。例如，`Alert` 和 `Emergency` 对于不同的开发者在编写代码时可能会有所不同，其他级别如
    `Notice` 和 `Informational` 也是如此。因此，一些网络开发者更喜欢使用较少的级别，这些级别更容易理解。具体数量将取决于网络的运行方式，但通常在三个到五个级别之间。对于
    Go 和 Python，级别的数量将取决于你用来创建日志消息的库。有些库可能比其他库有更多的级别。
- en: Now, let’s investigate how to add log events to your code using Go and Python.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们研究如何使用 Go 和 Python 将日志事件添加到你的代码中。
- en: Adding logging to your code
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在你的代码中添加日志
- en: Adding event logging in your code will be different in Go and in Python and
    will vary depending on the library used in your code. But the idea for both languages
    is to divide the information into severity levels, as done in `syslog`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的代码中添加事件日志在 Go 和 Python 中会有所不同，并且会根据你代码中使用的库而变化。但两种语言的想法都是将信息划分为严重性级别，就像在
    `syslog` 中做的那样。
- en: The severity log levels will also vary depending on the library used. Python
    and Go have standard log libraries, but you are also able to use third-party libraries
    to log events in both languages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 严重性日志级别也会根据所使用的库而有所不同。Python 和 Go 都有标准的日志库，但你也可以使用第三方库来在两种语言中记录事件。
- en: One important point here is that when writing the code, you will decide whether
    there is a need to add a logging event line. The line of logging added must carry
    some information that will signal to the program which level of severity the message
    is. Therefore, important messages such as failures will have priority over less-important
    messages, such as debugging. Ideally, the decision about which level of logging
    should be exposed is normally made by adding input arguments to your program that
    allow setting the log level. So, if you are running the program for debugging,
    it will generate much more information compared to a normal operation.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的一个重要点是，在编写代码时，你将决定是否需要添加一个日志事件行。添加的日志行必须携带一些信息，这将向程序发出信号，表明消息的严重性级别。因此，像失败这样重要的消息将比像调试这样不太重要的消息有更高的优先级。理想情况下，关于应该公开哪个日志级别的决定通常是通过向程序添加允许设置日志级别的输入参数来做出的。所以，如果你在调试程序运行时，它将生成比正常操作多得多的信息。
- en: Let’s now see how we can add logging events to our code in Go and then we check
    how to do it in Python.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何在 Go 代码中添加日志事件，然后我们检查如何在 Python 中实现。
- en: Adding event logging in Go
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Go 中添加事件日志
- en: The Go language has a standard library for logging that comes with the Go installation,
    but it is quite limited. For more advanced logging capabilities in Go, you might
    want to use third-party libraries for logging.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言有一个标准的日志库，它随 Go 安装一起提供，但它相当有限。如果你想在 Go 中实现更高级的日志功能，你可能需要使用第三方日志库。
- en: Let’s see how we can use the standard library and then check other popular third-party
    libraries.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用标准库，然后检查其他流行的第三方库。
- en: Using standard Go logging
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标准的 Go 日志
- en: 'The standard logging library in Go can be imported using `log` in the `import`
    statement. By default, Go standard logging does not provide any severity levels,
    but it has some helper functions that can help create logs. The helper functions
    are listed here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的标准日志库可以通过在 `import` 语句中使用 `log` 来导入。默认情况下，Go 标准日志不提供任何严重性级别，但它有一些辅助函数可以帮助创建日志。辅助函数在此列出：
- en: '`Print`, `Printf`, and `Println`: These functions print the message passed
    to them in the terminal using `stderr`'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Print`、`Printf` 和 `Println`：这些函数使用 `stderr` 在终端打印传递给它们的消息'
- en: '`Panic`, `Panicf`, and `Panicln`: These are like `Print`, but they call `Panic`
    after printing the log message'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Panic`、`Panicf` 和 `Panicln`：这些像 `Print` 一样工作，但在打印日志消息后会调用 `Panic`'
- en: '`Fatal`, `Fatalf`, and `Fatalln`: These also work like `Print`, but they call
    `os.Exit(1)` after printing the log message'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fatal`、`Fatalf` 和 `Fatalln`：这些也像 `Print` 一样工作，但在打印日志消息后会调用 `os.Exit(1)`'
- en: 'The following is a simple example of using the standard Go logging library:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用标准 Go 日志库的简单示例：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Running this program will print the following output without errors:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序将无错误地打印以下输出：
- en: '[PRE24]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If for any reason it is not possible to retrieve the current user, it will call
    `Fatalf`, which will call `os.Exit(1)` after printing the failed message.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于任何原因无法检索当前用户，它将调用 `Fatalf`，在打印失败信息后，将调用 `os.Exit(1)`。
- en: 'Now, let’s show a more complex example of how to create severity levels using
    the standard logging library and saving it to a file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们展示一个更复杂的示例，说明如何使用标准日志库创建严重性级别并将其保存到文件中：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding example, we created five levels of severity that can be used
    to write to a file as required. Note that in Go, the `init()` function is executed
    before the `main()` function. If you want to use these log definitions within
    other packages, remember to use capitalization of the variables; otherwise, the
    variables will be local to this package; for example, `errorLog` should be `ErrorLog`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们创建了五个严重性级别，可以根据需要将它们写入文件。请注意，在 Go 中，`init()` 函数在 `main()` 函数之前执行。如果您想在其他包中使用这些日志定义，请记住使用变量的大写；否则，变量将仅限于此包；例如，`errorLog`
    应该是 `ErrorLog`。
- en: Also, if you want to set a log level to avoid `Debug` or `Info` messages, you
    will have to pass an argument to your program and suppress lower levels of severity
    depending on the level set. Using the Go standard logging library, you will have
    to do that on your own.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果您想设置日志级别以避免 `Debug` 或 `Info` 消息，您必须向程序传递一个参数，并根据设置的级别抑制较低级别的严重性。使用 Go 标准日志库，您必须自己这样做。
- en: Now, let’s investigate a third-party logging library that is very popular with
    Go developers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调查一个在 Go 开发者中非常受欢迎的第三方日志库。
- en: Using logrus
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 logrus
- en: Perhaps one of the most popular libraries for logging in Go, `logrus` is a structured
    logging library with several logging capabilities. `logrus` has seven log levels
    and is compatible with the standard logging library. By default, the library allows
    you to set the log level, so it won’t create noise if you don’t want to see debugging
    information.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 也许在 Go 中最受欢迎的日志库之一是 `logrus`，它是一个具有多个日志功能的结构化日志库。`logrus` 有七个日志级别，并且与标准日志库兼容。默认情况下，该库允许您设置日志级别，因此如果您不想看到调试信息，它不会产生噪音。
- en: 'Here is a simple example of using `logrus` and setting the log level to `Error`,
    which means lower-level logs will not show, such as `Warning`, `Info,` or `Debug`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 `logrus` 并将日志级别设置为 `Error` 的简单示例，这意味着不会显示低级别的日志，例如 `Warning`、`Info`
    或 `Debug`：
- en: '[PRE26]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Running the preceding example will only show the following output in the terminal:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例将在终端中仅显示以下输出：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because the level of severity is set to `ErrorLevel`, none of the less-significant
    log messages will be displayed – in the example, the calls for `log.Info` and
    `log.Debug`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于严重性级别设置为 `ErrorLevel`，不会显示任何不太重要的日志消息——在示例中，对 `log.Info` 和 `log.Debug` 的调用。
- en: '`logrus` is very flexible and powerful with plenty of examples of usage on
    the internet. More details on `logrus` can be found at [https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`logrus` 非常灵活且功能强大，互联网上有许多使用示例。有关 `logrus` 的更多详细信息，请参阅 [https://github.com/sirupsen/logrus](https://github.com/sirupsen/logrus)。'
- en: 'If you want to use more logging libraries in Go, here is a compiled list of
    third-party log libraries: [https://awesome-go.com/logging/](https://awesome-go.com/logging/).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在 Go 中使用更多日志库，这里有一个第三方日志库的编译列表：[https://awesome-go.com/logging/](https://awesome-go.com/logging/)。
- en: Now, let’s check how we add logging to our code using Python.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查如何使用 Python 将日志添加到我们的代码中。
- en: Add event logging in Python
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Python 中添加事件日志
- en: In comparison to Go, Python has added many more features to the standard logging
    library. Despite the better support, the Python community has also developed many
    third-party logging libraries.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Go 相比，Python 为标准日志库添加了许多更多功能。尽管支持更好，但 Python 社区也开发了多个第三方日志库。
- en: Let’s have a look at the standard library and then a popular third-party library
    for Python.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 的标准库和流行的第三方库。
- en: Using standard logging for Python
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标准日志库进行 Python
- en: The standard logging library comes with five severity levels and an extra level
    that is used to indicate the level was not set by the logger. Each level has a
    number associated with it that can be used to interpret the priority level, where
    lower numbers have lower priority. The levels are `CRITICAL` (50), `ERROR` (40),
    `WARNING` (30), `INFO` (20), `DEBUG` (10), and `NOTSET` (0).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 标准日志库包含五个严重级别和一个额外的级别，用于指示级别未由记录器设置。每个级别都与一个数字相关联，可以用来解释优先级级别，其中数字越小，优先级越低。级别包括
    `CRITICAL`（50）、`ERROR`（40）、`WARNING`（30）、`INFO`（20）、`DEBUG`（10）和 `NOTSET`（0）。
- en: The `NOTSET` level is useful when using log hierarchies, allowing a non-root
    logger to delegate the level to its parent.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOTSET` 级别在使用日志层次结构时很有用，允许非根记录器将级别委派给其父记录器。'
- en: 'The following is an example of using Python standard logging:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 Python 标准日志的示例：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the preceding program will produce the following line in the output
    file called `file-log.txt`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的程序将在名为 `file-log.txt` 的输出文件中产生以下行：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As illustrated in the preceding code, setting the level to `logging.ERROR` will
    not allow the lower-level log messages to be written in the file. The program
    just ignores the `logging.debug()`, `logging.info()`, and `logging.warning()`
    calls.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码所示，将级别设置为 `logging.ERROR` 将不允许在文件中写入低级别的日志消息。程序只是忽略了 `logging.debug()`、`logging.info()`
    和 `logging.warning()` 调用。
- en: Another important point is to show how easier it is to use standard logging
    in Python. The preceding example shows that you just need one call to `logging.basicConfig`
    to set almost everything you need, from the formatter to the level of severity.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要点是展示在 Python 中使用标准日志的简便性。前述示例表明，您只需调用一次 `logging.basicConfig` 就可以设置几乎您需要的所有内容，从格式化程序到严重级别。
- en: 'In addition to being easy to use, the Python community has created great tutorials
    and documentation for the standard logging library. Here are the three main references
    for the documentation and advanced utilization info:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 除了易于使用之外，Python 社区还为标准日志库创建了优秀的教程和文档。以下是文档和高级使用信息的三个主要参考：
- en: '[https://docs.python.org/3/library/logging](https://docs.python.org/3/library/logging)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/library/logging](https://docs.python.org/3/library/logging)'
- en: '[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/howto/logging.html](https://docs.python.org/3/howto/logging.html)'
- en: '[https://docs.python.org/3/howto/logging-cookbook.html](https://docs.python.org/3/howto/logging-cookbook.html)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.python.org/3/howto/logging-cookbook.html](https://docs.python.org/3/howto/logging-cookbook.html)'
- en: In essence, the Python standard logging library is quite complete, and you won’t
    need to use a third-party library for most of your work. However, there are some
    nice and interesting features in one popular third-party library for Python called
    `loguru`. Let’s see how to use it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Python 标准日志库非常完整，您在大多数工作中不需要使用第三方库。然而，有一个名为 `loguru` 的流行第三方库提供了许多有趣和有用的功能。让我们看看如何使用它。
- en: Using Python loguru
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Python loguru
- en: Python `loguru` provides a few more features than the standard Python logging
    library and has the aim of being easier to use and configure. For instance, using
    `loguru`, you will be able to set file rotation on the log file, use a more advanced
    string formatter, and use decorators to catch exceptions on functions, and it
    is thread and multiprocessing safe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Python `loguru` 提供了比标准 Python 日志库更多的功能，并旨在使其更容易使用和配置。例如，使用 `loguru`，您将能够设置日志文件的文件轮换，使用更高级的字符串格式化程序，并使用装饰器在函数上捕获异常，并且它是线程和进程安全的。
- en: It also has interesting features that can allow you to add extra information
    to the logging by using a `patch` method (more on the `patch` method at [https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch](https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有一些有趣的功能，允许您通过使用 `patch` 方法（更多关于 `patch` 方法的信息请参阅 [https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch](https://loguru.readthedocs.io/en/stable/api/logger.html#loguru._logger.Logger.patch)）来添加额外的日志信息。
- en: 'The following is a simple example using `loguru`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用 `loguru` 的简单示例：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Running the preceding example will create a file with the date and time with
    log messages that will rotate if it reaches 1 MB in size. The output written in
    the file will look as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的示例将创建一个包含日期和时间的文件，其中包含日志消息，如果文件大小达到 1 MB，则将进行轮换。文件中的输出将如下所示：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: More detailed documentation can be found at [https://loguru.readthedocs.io](https://loguru.readthedocs.io)
    and the source code at [https://github.com/Delgan/loguru](https://github.com/Delgan/loguru).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 更详细的文档可以在[https://loguru.readthedocs.io](https://loguru.readthedocs.io)找到，源代码在[https://github.com/Delgan/loguru](https://github.com/Delgan/loguru)。
- en: Summary
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: After reading this chapter, you are probably more aware of why we need to handle
    errors and why we need to create proper event logging. You also should be more
    familiar with the differences between how Go and Python handle errors. Furthermore,
    you saw the differences in how to use standard libraries and third-party libraries
    for event logging. From now on, your network automation code design will have
    a special section on logging and error handling.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章之后，你可能更加清楚为什么我们需要处理错误以及为什么我们需要创建适当的事件记录。你也应该更加熟悉Go和Python在处理错误方面的差异。此外，你还看到了在使用标准库和第三方库进行事件记录方面的差异。从现在开始，你的网络自动化代码设计将包含一个专门关于日志记录和错误处理的章节。
- en: In the next chapter, we are going to talk about how we can scale our code and
    how our network automation solution can interact with large networks.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何扩展我们的代码以及我们的网络自动化解决方案如何与大型网络交互。
