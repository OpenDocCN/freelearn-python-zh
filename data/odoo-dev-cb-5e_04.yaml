- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Application Models
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用模型
- en: This chapter will guide you through some small enhancements to an existing add-on
    module. You already registered your add-on module in the Odoo instance in [*Chapter
    3*](B20997_03.xhtml#_idTextAnchor083), *Creating Odoo Add-On Modules*. Now, you
    will explore the database aspects of the module in more depth. You will learn
    how to create a new model (database table), add new fields, and apply constraints.
    You will also discover how to use inheritance in Odoo to modify existing models.
    In this chapter, you will use the same module that you created in the previous
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导您对现有扩展模块进行一些小的改进。您已经在 [*第 3 章*](B20997_03.xhtml#_idTextAnchor083)，*创建 Odoo
    扩展模块* 中注册了您的扩展模块。现在，您将更深入地探索模块的数据库方面。您将学习如何创建新的模型（数据库表），添加新的字段，并应用约束。您还将发现如何使用
    Odoo 中的继承来修改现有模型。在本章中，您将使用上一章中创建的相同模块。
- en: 'This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Defining the model representation and order
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义模型表示和顺序
- en: Adding data fields to a model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加数据字段
- en: Adding a float field with configurable precision
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加可配置精度的浮点字段
- en: Adding a monetary field to a model
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加货币字段
- en: Adding relational fields to a model
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加关系字段
- en: Adding a hierarchy to a model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加层次结构
- en: Adding constraint validations to a model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加约束验证
- en: Adding computed fields to a model
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向模型添加计算字段
- en: Exposing related fields stored in other models
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暴露存储在其他模型中的相关字段
- en: Adding dynamic relations using reference fields
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用引用字段添加动态关系
- en: Adding features to a model using inheritance
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承向模型添加功能
- en: Using abstract models for reusable model features
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象模型实现可重用模型功能
- en: Copying the model definition using inheritance
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承复制模型定义
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Before proceeding with the examples in this chapter, make sure you have the
    module that we developed in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083), *Creating
    Odoo Add-On Modules*, and that it is properly installed and configured.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续本章的示例之前，请确保您已安装并配置了我们在 [*第 3 章*](B20997_03.xhtml#_idTextAnchor083)，*创建 Odoo
    扩展模块* 中开发的模块。
- en: Defining the model representation and order
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义模型表示和顺序
- en: A model refers to a representation of a database table. A model defines the
    structure and behavior of a database table, including fields, relationships, and
    various methods. Models are defined in Python code using Odoo’s **object-relational
    mapping** (**ORM**) system. ORM allows developers to interact with the database
    using Python classes and methods, rather than writing raw SQL queries.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 模型指的是数据库表的表示。模型定义了数据库表的结构和行为，包括字段、关系和多种方法。模型使用 Odoo 的 **对象关系映射**（**ORM**）系统在
    Python 代码中定义。ORM 允许开发人员使用 Python 类和方法与数据库交互，而不是编写原始 SQL 查询。
- en: Model attributes are the features of a model that will be defined when we create
    a new model; otherwise, we use the attributes of the model that already exists.
    Models use structural attributes with an underscore prefix to define their behavior.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模型属性是在创建新模型时将要定义的模型特征；否则，我们使用已存在的模型的属性。模型使用带下划线前缀的结构属性来定义其行为。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `my_hostel` instance should already contain a Python file called `models/hostel.py`,
    which defines a basic model. We will edit it to add new class-level attributes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_hostel` 实例应该已经包含一个名为 `models/hostel.py` 的 Python 文件，该文件定义了一个基本模型。我们将编辑它以添加新的类级别属性。'
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'By utilizing these attributes effectively, developers can create well-organized,
    reusable, and maintainable code in Odoo, leading to a more efficient and robust
    application. The following are the attributes that can be used on a model:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过有效地利用这些属性，开发人员可以在 Odoo 中创建组织良好、可重用和可维护的代码，从而实现更高效和健壮的应用程序。以下是可以用于模型上的属性：
- en: '`_name` : The `name` attribute is the most important one, as it determines
    the internal global identifier and the database table name. The model name is
    expressed in dot notation within the module namespace. For instance, `name="hostel.hostel"`
    will create the `hostel_hostel` table in the database:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_name` : `name` 属性是最重要的一个，因为它决定了内部全局标识符和数据库表名。模型名在模块命名空间内以点表示法表达。例如，`name="hostel.hostel"`
    将在数据库中创建 `hostel_hostel` 表：'
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`_table`: We can define the SQL table name utilized by the model if ‘`_auto`’
    is enabled:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_table`：如果启用了‘`_auto`’，我们可以定义模型使用的 SQL 表名：'
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`_description`: To assign a descriptive title to the model that reflects its
    purpose and functionality, insert the following code snippet:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_description`：为了给模型分配一个反映其目的和功能的描述性标题，请插入以下代码片段：'
- en: '[PRE2]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you don’t use `_description` for your model, Odoo will show a warning in
    the logs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有为您的模型使用`_description`，Odoo将在日志中显示警告。
- en: '`_order`: The default field for ordering the search results is ‘`id`’. However,
    this can be changed so that we can use the fields of our choice, by providing
    an `_order` attribute with a string containing a comma-separated list of field
    names. A field name can be followed by the `desc` keyword to sort it in descending
    order. To order the records by `id` in descending order, followed by names in
    ascending order, use the following code syntax:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_order`：默认的搜索结果排序字段是`''id''`。但是，可以通过提供一个包含逗号分隔的字段名称列表的字符串的`_order`属性来更改它，以便我们可以使用我们选择的字段。字段名称后可以跟`desc`关键字以降序排序。要按`id`降序排序，然后按名称升序排序记录，请使用以下代码语法：'
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Only fields stored in the database can be used. Non-stored computed fields can’t
    be used to sort records. The syntax for the `_order` string is similar to the
    `SQL ORDER BY` clauses, although it’s stripped down. For instance, special clauses,
    such as `NULLS FIRST`, are not allowed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 只能使用存储在数据库中的字段。无法使用非存储的计算字段对记录进行排序。`_order`字符串的语法类似于`SQL ORDER BY`子句，尽管它被简化了。例如，不允许使用特殊子句，如`NULLS
    FIRST`。
- en: '`_rec_name`: This is used to set the field that’s used as a representation
    or title for the records. The default field for `rec_name` is the name field.
    `_rec_name` is the display name of the record used by Odoo’s `rec_name` and set
    `hostel_code` as a representative of the model, use the following code syntax:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_rec_name`：此属性用于设置用作记录表示或标题的字段。`rec_name`的默认字段是名称字段。`_rec_name`是Odoo的`rec_name`使用的记录显示名称，并将`hostel_code`设置为模型的代表，使用以下代码语法：'
- en: '[PRE4]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If your model doesn’t have a name field and you haven’t specified `_rec_name`
    either, your display name will be a combination of the model name and record ID,
    like this – `(``hostel.hostel, 1)`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的模型没有名称字段，并且您也没有指定`_rec_name`，则您的显示名称将是模型名称和记录ID的组合，如下所示 - `(``hostel.hostel,
    1)`。
- en: '`_rec_names_search`: This is used to search specific records by mentioned field
    values. It is similar to using the `name_search` function. You can directly use
    this attribute instead of using the `name_search` method. To do so, use the following
    code syntax:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`_rec_names_search`：此属性用于通过提到的字段值搜索特定记录。它与使用`name_search`函数类似。您可以直接使用此属性而不是使用`name_search`方法。为此，请使用以下代码语法：'
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There’s more…
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: All models have a `display_name` field that shows the record representation
    in a human-readable format, which has been automatically added to all models since
    version 8.0\. The default `_compute_display_name()` method uses the `_rec_name`
    attribute to determine which field contains the data for the display name. To
    customize the display name, you can override the `_compute_display_name()` method
    and provide your logic. The method should return a list of tuples, each containing
    the record ID and the Unicode string representation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有模型都有一个`display_name`字段，它以人类可读的格式显示记录表示，自8.0版本以来已自动添加到所有模型中。默认的`_compute_display_name()`方法使用`_rec_name`属性来确定哪个字段包含显示名称的数据。要自定义显示名称，您可以重写`_compute_display_name()`方法并提供您的逻辑。该方法应返回一个包含记录ID和Unicode字符串表示的元组的列表。
- en: 'For example, to have the hostel name and hostel code in the representation,
    such as `Youth Hostel (YHG015)`, we can define the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了在表示中包含宿舍名称和宿舍代码，例如`Youth Hostel (YHG015)`，我们可以定义以下内容：
- en: 'Take a look at the following example. This will add a release date to the record’s
    name:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例。这将向记录的名称添加一个发布日期：
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After adding the preceding code, your `display_name` record will be updated.
    Suppose you have a record with the name `Bell House Hostel` and its code is `BHH101`;
    then, the preceding `_compute_display_name()` method will generate a name such
    as `Bell House` `Hostel (BHH101)`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加前面的代码后，您的`display_name`记录将被更新。假设您有一个名为`Bell House Hostel`的记录，其代码为`BHH101`；那么，前面的`_compute_display_name()`方法将生成一个如`Bell
    House Hostel (BHH101)`的名称。
- en: 'When we’re done, our `hostel.py` file should appear as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成时，我们的`hostel.py`文件应如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Your `<form>` view in the `hostel.xml` file will look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您的`hostel.xml`文件中的`<form>`视图将如下所示：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We should then upgrade the module to activate these changes in Odoo.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该升级模块以在Odoo中激活这些更改。
- en: 'To update the module, execute the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新模块，执行以下操作：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, search for the `my_hostel` module and upgrade it via the dropdown, as
    shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，搜索`my_hostel`模块，并通过下拉菜单升级它，如图下所示：
- en: '![Figure 4.1 – The option to update the module](img/B20997_04_1.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 更新模块的选项](img/B20997_04_1.jpg)'
- en: Figure 4.1 – The option to update the module
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 更新模块的选项
- en: Alternatively, you can also use the `-u my_hostel` command in the command line.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以在命令行中使用`-u my_hostel`命令。
- en: Adding data fields to a model
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向模型添加数据字段
- en: A field represents a column in a database table and defines the structure of
    the data that can be stored in that column. Fields in Odoo models are used to
    specify the attributes and characteristics of the data that the model will store.
    Each field has a data type (e.g., `Char`, `Integer`, `Float`, or `Date`) and various
    attributes that determine how the field behaves.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 字段代表数据库表中的一列，并定义了可以存储在该列中的数据结构。Odoo 模型中的字段用于指定模型将存储的数据的属性和特征。每个字段都有一个数据类型（例如，`Char`、`Integer`、`Float`或`Date`）以及确定字段行为的各种属性。
- en: In this section, you will explore the various data types that fields can support
    and how to add them to a model.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将探索字段可以支持的各种数据类型以及如何将它们添加到模型中。
- en: Getting ready
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe assumes that you have an instance ready with the `my_hostel` add-on
    module available, as described in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo* *Add-On Modules*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱假设您已经有一个带有`my_hostel`附加模块的实例，如[*第 3 章*](B20997_03.xhtml#_idTextAnchor083)，*创建
    Odoo 附加模块*中所述。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The `my_hostel` add-on module should already have `models/hostel.py`, defining
    a basic model. We will edit it to add new fields:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`my_hostel`附加模块应该已经包含`models/hostel.py`，定义了一个基本模型。我们将编辑它以添加新字段：'
- en: 'Use the minimal syntax to add fields to the `Hostel` model:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用最小语法向`Hostel`模型添加字段：
- en: '[PRE10]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We have added new fields to the model. We still need to add these fields to
    the form view in order to reflect these changes in the user interface. Refer to
    the following code to add fields to the form view:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经向模型添加了新字段。我们还需要将这些字段添加到表单视图中，以便在用户界面中反映这些更改。请参考以下代码以向表单视图添加字段：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Upgrading the module will make these changes effective in the Odoo model.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 升级模块将使这些更改在 Odoo 模型中生效。
- en: How it works...
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To add fields to models, you need to define an attribute of the corresponding
    type in their Python classes. The available types of non-relational fields are
    as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要向模型添加字段，您需要在它们的 Python 类中定义相应类型的属性。非关系字段的可用类型如下：
- en: '**Char**: Stores string values.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字符**：存储字符串值。'
- en: '**Text**: Stores multiline string values.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文本**：存储多行字符串值。'
- en: '**Selection**: Stores one value from a list of predefined values and descriptions.
    This has a list of values and description pairs. The value that is selected is
    what gets stored in the database, and it can be a string or an integer. The description
    is automatically translatable.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**：存储从预定义值和描述的列表中选择的一个值。它包含值和描述对的列表。所选的值将存储在数据库中，可以是字符串或整数。描述是自动可翻译的。'
- en: Note
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Odoo does not display the description if the value is zero for integer keys.
    The `Selection` field also accepts a function reference as its `selection` attribute
    instead of a list. This allows you to dynamically generate lists of options. You
    can find an example relating to this in the *Adding dynamic relations using reference
    fields* recipe in this chapter, where a `selection` attribute is also used.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整数字段的值为零，Odoo 不会显示描述。`选择`字段也接受函数引用作为其`选择`属性，而不是列表。这允许您动态生成选项列表。您可以在本章的*使用引用字段添加动态关系*食谱中找到一个相关示例，其中也使用了`选择`属性。
- en: '**Html**: Stores rich text in the HTML format.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTML**：以 HTML 格式存储富文本。'
- en: '**Binary**: Stores binary files, such as images or documents.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二进制**：存储二进制文件，如图像或文档。'
- en: '`True`/`False` values.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`True`/`False`值。'
- en: '`fields.Date.today()` to set the default value to the current date.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`fields.Date.today()`将默认值设置为当前日期。
- en: '`datetime` values as Python datetime objects in UTC time. Use `fields.Date.now()`
    to set the default value to the current time.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`datetime`值作为 UTC 时间的 Python datetime 对象。使用`fields.Date.now()`将默认值设置为当前时间。
- en: '**Integer**: Stores integer values.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整数**：存储整数值。'
- en: '**Float**: Stores numeric values with optional precision (total digits and
    decimal digits).'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**浮点数**：存储具有可选精度的数值（总位数和小数位数）。'
- en: '**Monetary**: Stores an amount in a specific currency. This will be explained
    further in the *Adding a monetary field to a model* recipe in this chapter.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**货币**：以特定货币存储金额。这将在本章的 *将货币字段添加到模型* 菜谱中进一步解释。'
- en: '*Step 1* of this recipe shows the minimal syntax to add to each field type.
    The field definitions can be expanded to add other optional attributes, as shown
    in *step 2*. Here’s an explanation of the field attributes that were used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*步骤 1* 显示了添加到每种字段类型的最小语法。字段定义可以扩展以添加其他可选属性，如 *步骤 2* 所示。以下是已使用字段属性的说明：'
- en: '`string` is the field’s title and is used in UI view labels. It is optional.
    If not set, a label will be derived from the field name by adding a title case
    and replacing the underscores with spaces.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`string` 是字段的标题，并用于 UI 视图标签。它是可选的。如果没有设置，将根据字段名称推导标签，通过添加标题大小写并替换下划线为空格。'
- en: '`translate`, when set to `True`, makes the field translatable. It can hold
    a different value, depending on the user interface language.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置为 `True` 时，`translate` 使得字段可翻译。它的值可能因用户界面语言而异。
- en: '`default` is the default value. It can also be a function that is used to calculate
    the default value – for example, `default=_compute_default`, where `_compute_default`
    is a method that was defined on the model before the field definition.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default` 是默认值。它也可以是一个用于计算默认值的函数——例如，`default=_compute_default`，其中 `_compute_default`
    是在字段定义之前在模型上定义的方法。'
- en: '`help` is an explanation text that’s displayed in the UI tooltips.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`help` 是在 UI 工具提示中显示的解释文本。'
- en: '`groups` makes the field available only to some security groups. It is a string
    containing a comma-separated list of XML IDs for security groups. This is addressed
    in more detail in [*Chapter 10*](B20997_10.xhtml#_idTextAnchor549), *Security
    Access*.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`groups` 使得字段仅对某些安全组可用。它是一个包含以逗号分隔的安全组 XML ID 列表的字符串。这将在[*第10章*](B20997_10.xhtml#_idTextAnchor549)
    *安全访问*中更详细地说明。'
- en: '`copy` flags whether the field value is copied when the record is duplicated.
    By default, it is `True` for non-relational and `Many2one` fields, and `False`
    for `One2many` and computed fields.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`copy` 标志表示在记录复制时是否复制字段值。默认情况下，对于非关系和 `Many2one` 字段为 `True`，对于 `One2many` 和计算字段为
    `False`。'
- en: '`index`, when set to `True`, creates a database index for the field, which
    sometimes allows for faster searches. It replaces the deprecated `select=1` attribute.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当设置为 `True` 时，`index` 为字段创建数据库索引，这有时可以允许更快的搜索。它替换了已弃用的 `select=1` 属性。
- en: The `readonly` flag makes the field read-only by default in the user interface.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`readonly` 标志使得字段在用户界面中默认为只读。'
- en: The `required` flag makes the field mandatory by default in the user interface.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`required` 标志使得字段在用户界面中默认为必填项。'
- en: The various whitelists that are mentioned here are defined in `odoo/fields.py`.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这里提到的各种白名单在 `odoo/fields.py` 中定义。
- en: The `company_dependent` flag makes the field store different values for each
    company. It replaces the deprecated `Property` field type.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`company_dependent` 标志使得字段为每个公司存储不同的值。它替换了已弃用的 `Property` 字段类型。'
- en: The value isn’t stored on the model table. It is registered as ``ir.property``.
    When the value of the `company_dependent` field is needed, an ``ir.property``
    is searched and linked to the current company (and the current record if one property
    exists). If the value is changed on the record, it either modifies the existing
    property for the current record (if one exists) or creates a new one for the current
    company and `res_id`. If the value is changed on the company side, it will impact
    all records on which the value hasn’t been changed.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值不存储在模型表上。它注册为 ``ir.property``。当需要 `company_dependent` 字段的值时，将搜索 ``ir.property``
    并将其链接到当前公司（如果存在一个属性，则还包括当前记录）。如果记录上的值被更改，它将修改当前记录的现有属性（如果存在）或为当前公司和 `res_id` 创建一个新的属性。如果公司侧的值被更改，它将影响所有尚未更改值的记录。
- en: '`group_operator` is an aggregate function used to display results in the group
    by mode.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_operator` 是一个聚合函数，用于在按组模式显示结果。'
- en: Possible values for this attribute include `count`, `count_distinct`, `array_agg`,
    `bool_and`, `bool_or`, `max`, `min`, `avg`, and `sum`. Integer, float, and monetary
    field types have the default `sum` value for this attribute. This field is used
    by the `:meth:~odoo.models.Model.read_group` method to group rows based on this
    field.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此属性的可能的值包括 `count`、`count_distinct`、`array_agg`、`bool_and`、`bool_or`、`max`、`min`、`avg`
    和 `sum`。整数、浮点数和货币字段类型对此属性的默认值为 `sum`。此字段由 `:meth:~odoo.models.Model.read_group`
    方法用于根据此字段分组行。
- en: 'The supported aggregate functions are as follows:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 支持的聚合函数如下：
- en: '`array_agg`: Concatenates all values, including nulls, into an array'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array_agg`：将所有值（包括空值）连接到一个数组中'
- en: '`count`: Counts the number of rows'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：计算行数'
- en: '`count_distinct`: Counts the number of distinct rows'
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count_distinct`：计算不同行数'
- en: '`bool_and`: Returns `true` if all values are `true`, and `false` otherwise'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool_and`：如果所有值都是 `true`，则返回 `true`，否则返回 `false`'
- en: '`bool_or`: Returns `true` if at least one value is `true`, and `false` otherwise'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bool_or`：如果至少有一个值是 `true`，则返回 `true`，否则返回 `false`'
- en: '`max`: Returns the maximum value of all values'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max`：返回所有值的最大值'
- en: '`min`: Returns the minimum value of all values'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`：返回所有值的最小值'
- en: '`avg`: Returns the average (arithmetic mean) of all values'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`avg`：返回所有值的平均值'
- en: '`sum`: Returns the sum of all values'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sum`：返回所有值的总和'
- en: '`Store`: This is for whether the field is stored in the database (the default
    is `True`, and `False` for computed fields).'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Store`：用于确定字段是否存储在数据库中（默认为 `True`，对于计算字段为 `False`）。'
- en: '`group_expand`: This function is used to expand `read_group` results when grouping
    on the current field:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group_expand`：此函数用于在按当前字段分组时扩展 `read_group` 结果：'
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `sanitize` flag is employed within HTML fields to systematically remove
    potentially insecure tags from their content. Activation of this flag results
    in a comprehensive cleansing of the input. For users seeking more nuanced control
    over HTML sanitization, there are additional attributes available. It is important
    to note that these attributes are effective only when the sanitize flag is enabled.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 HTML 字段中使用 `sanitize` 标志来系统地从其内容中移除可能不安全的标签。激活此标志会导致对输入进行彻底的清洁。对于寻求对 HTML
    清洁有更细致控制的用户，还有其他一些属性可用。重要的是要注意，这些属性仅在启用 `sanitize` 标志时有效。
- en: 'If you need finer control in HTML sanitization, there are a few more attributes
    that you can use, which only work if `sanitize` is enabled:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在 HTML 清洁中实现更精细的控制，可以使用一些额外的属性，但这些属性仅在启用 `sanitize` 时有效：
- en: '`sanitize_tags=True`, to remove tags that are not part of a whitelist (this
    is the default)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitize_tags=True`，用于移除不属于白名单的标签（这是默认设置）'
- en: '`sanitize_attributes=True`, to remove attributes of the tags that are not part
    of a whitelist'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitize_attributes=True`，用于移除不属于白名单的标签属性'
- en: '`sanitize_style=True`, to remove style properties that are not part of a whitelist'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sanitize_style=True`，用于移除不属于白名单的样式属性'
- en: '`strip_style=True`, to remove all style elements'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip_style=True`，用于移除所有样式元素'
- en: '`strip_class=True`, to remove the class attributes'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`strip_class=True`，用于移除类属性'
- en: Finally, we updated the form view according to the newly added fields in the
    model. We placed all fields in form view, but you can place them anywhere you
    want. Form views are explained in more detail in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们根据模型中新添加的字段更新了表单视图。我们将所有字段放置在表单视图中，但您可以将它们放置在任何您想要的位置。表单视图在[*第9章*](B20997_09.xhtml#_idTextAnchor446)，*后端视图*中有更详细的解释。
- en: There’s more...
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `Date` and `Datetime` field objects expose a few utility methods that can
    be convenient for Date and Datetime:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`Date` 和 `Datetime` 字段对象公开了一些实用方法，这些方法对于日期和 datetime 非常方便：'
- en: 'For `Date`, we have the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Date`，我们有以下内容：
- en: '`fields.Date.to_date(string_value)` parses the string into a date object.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Date.to_date(string_value)` 将字符串解析为日期对象。'
- en: '`fields.Date.to_string(date_value)` converts the Python Date object to a string.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Date.to_string(date_value)` 将 Python 日期对象转换为字符串。'
- en: '`fields.Date.today()` returns the current day in a string format. This is appropriate
    for use with default values.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Date.today()` 以字符串格式返回当前日期。这适用于使用默认值。'
- en: '`fields.Date.context_today(record, timestamp)` returns the day of the timestamp
    (or the current day, if the timestamp is omitted) in a string format, according
    to the time zone of the record’s (or record set’s) context.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Date.context_today(record, timestamp)` 以字符串格式返回时间戳的日期（如果省略时间戳，则为当前日期），根据记录（或记录集）的上下文时区。'
- en: 'For `Datetime`, we have the following:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Datetime`，我们有以下内容：
- en: '`fields.Datetime.to_datetime(string_value)` parses the string into a datetime
    object.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Datetime.to_datetime(string_value)` 将字符串解析为 datetime 对象。'
- en: '`fields.Datetime.to_string(datetime_value)` converts the datetime object to
    a string.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Datetime.to_string(datetime_value)` 将 datetime 对象转换为字符串。'
- en: '`fields.Datetime.now()` returns the current day and time in a string format.
    This is appropriate to use for default values.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Datetime.now()` 以字符串格式返回当前日期和时间。这适用于使用默认值。'
- en: '`fields.Datetime.context_timestamp(record, timestamp)` converts a timestamp-naive
    datetime object into a time zone-aware datetime object. using the time zone in
    the context of a record. This is not suitable for default values but can be used
    for instances when you’re sending data to an external system.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fields.Datetime.context_timestamp(record, timestamp)` 将一个无时区信息的 datetime 对象转换为具有时区信息的
    datetime 对象。使用记录上下文中的时区。这不适合作为默认值，但可以在向外部系统发送数据时使用。'
- en: In addition to the basic fields, there are also few relational fields such as
    `Many2one`, `One2many`, and `Many2many`. These are covered in the *Adding relational
    fields to a model* recipe in this chapter.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基本字段外，还有一些关系字段，如 `Many2one`、`One2many` 和 `Many2many`。这些内容在本章的 *向模型添加关系字段*
    菜谱中有详细说明。
- en: You can also create fields with values that are computed automatically by using
    the `compute` field attribute to define the computation function. This is covered
    in the *Adding computed fields to a model* recipe of this chapter.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用 `compute` 字段属性来定义计算函数，从而创建具有自动计算值的字段。这在本章的 *向模型添加计算字段* 菜谱中有详细说明。
- en: 'Some fields are added by default in Odoo models, so you should avoid using
    these names for your fields. These are as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 模型中默认添加了一些字段，因此你应该避免使用这些名称作为你的字段名称。具体如下：
- en: '`id` (the record’s automatically generated identifier)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`id`（记录自动生成的标识符）'
- en: '`create_date` (the record creation timestamp)'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_date`（记录创建的时间戳）'
- en: '`create_uid` (the user who created the record)'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create_uid`（创建记录的用户）'
- en: '`write_date` (the last recorded timestamp edit)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_date`（最后记录的时间戳编辑）'
- en: '`write_uid` (the user who last edited the record)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`write_uid`（最后编辑记录的用户）'
- en: The automatic creation of these log fields can be disabled by setting the `_log_access=False`
    model attribute.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过设置 `_log_access=False` 模型属性来禁用这些日志字段的自动创建。
- en: 'Another special column that can be added to a model is `active`. It must be
    a `Boolean` field, allowing users to mark records as inactive. It is used to enable
    the `archive`/`unarchive` feature on the records. Its definition is as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 可以添加到模型中的另一个特殊列是 `active`。它必须是一个 `Boolean` 字段，允许用户将记录标记为非活动状态。它用于在记录上启用 `archive`/`unarchive`
    功能。其定义如下：
- en: '[PRE13]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'By default, only records with `active` set to `True` are visible. To retrieve
    them, we need to use a domain filter with `[(''active'', ''='', False)]`. Alternatively,
    if the `''active_test'': False` value is added to the environment’s context, ORM
    will not filter out inactive records.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，只有将 `active` 设置为 `True` 的记录是可见的。要检索它们，我们需要使用 `[(''active'', ''='', False)]`
    域过滤器。或者，如果将 `''active_test'': False` 值添加到环境上下文中，ORM 不会过滤掉非活动记录。'
- en: In some cases, you may not be able to modify the context to get both the active
    and the inactive records. If so, you can use the `['|', ('active', '=', True),
    ('active', '=',` `False)]` domain.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，你可能无法修改上下文以获取活动和非活动记录。如果是这样，你可以使用 `['|', ('active', '=', True), ('active',
    '=', False)]` 域。
- en: Tip
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`[(''active'', ''in'' (True, False))]` does not work as you might expect. Odoo
    explicitly looks for an `(''active'', ''='', False)` clause in the domain. It
    will default to restricting the search to active records only.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`[(''active'', ''in'' (True, False))]` 并不会像你预期的那样工作。Odoo 明确在域中寻找 `(''active'',
    ''='', False)` 条件。它将默认只限制搜索到活动记录。'
- en: Adding a float field with configurable precision
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加具有可配置精度的浮点字段
- en: When using `float` fields, we may want to let the end user configure the decimal
    precision that will be used. In this recipe, we will add a `hostel_rating` field
    to the `hostel` model, with user-configurable decimal precision.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `float` 字段时，我们可能希望让最终用户配置将要使用的十进制精度。在本菜谱中，我们将向 `hostel` 模型添加一个 `hostel_rating`
    字段，并允许用户配置十进制精度。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前一个菜谱中的 `my_hostel` 扩展模块。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to apply dynamic decimal precision to the model’s
    `hostel_rating` field:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以将动态十进制精度应用于模型的 `hostel_rating` 字段：
- en: Create a data folder and add a `data.xml` file. Inside this file, add the following
    record for the decimal precision model. This will add a new configuration.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个数据文件夹并添加一个 `data.xml` 文件。在此文件中，为十进制精度模型添加以下记录。这将添加一个新的配置。
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Activate **Developer Mode** from the link in the **Settings** menu (refer to
    the *Activating the Odoo developer tools* recipe in [*Chapter 1*](B20997_01.xhtml#_idTextAnchor020),
    *Installing the Odoo Development Environment*). This will enable the **Settings**
    | **Technical** menu.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**设置**菜单中的链接激活**开发者模式**（参考[*第1章*](B20997_01.xhtml#_idTextAnchor020)，*安装Odoo开发环境*中的*激活Odoo开发者工具*配方）。这将启用**设置**
    | **技术**菜单。
- en: Access the decimal precision configurations. To do this, open the **Settings**
    top menu and select **Technical** | **Database Structure** | **Decimal Accuracy**.
    We should see a list of the currently defined settings.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问小数精度配置。为此，打开**设置**顶部菜单并选择**技术** | **数据库结构** | **小数精度**。我们应该能看到当前定义的设置列表。
- en: '![Figure 4.2 – Creating new decimal precision](img/B20997_04_2.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 创建新的小数精度](img/B20997_04_2.jpg)'
- en: Figure 4.2 – Creating new decimal precision
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 创建新的小数精度
- en: 'To add the `model` field using this decimal precision setting, edit the `models/hostel.py`
    file by adding the following code:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用此小数精度设置添加`model`字段，请通过编辑`models/hostel.py`文件并添加以下代码：
- en: '[PRE15]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When you add a string value to the `digits` attribute of the field, Odoo looks
    up that string in the decimal accuracy model’s `Usage` field and returns a tuple,
    with 16-digit precision and the number of decimals that were defined in the configuration.
    Using the field definition, instead of having it hardcoded, we allow the end user
    to configure it according to their needs.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当您向字段的`digits`属性添加一个字符串值时，Odoo会在小数精度模型的`Usage`字段中查找该字符串，并返回一个元组，具有16位精度和配置中定义的小数位数。使用字段定义，而不是将其硬编码，我们允许最终用户根据其需求进行配置。
- en: Adding a monetary field to a model
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向模型添加货币字段
- en: To work with monetary values and currencies in a model, we can use Odoo to provide
    special support for working with monetary values and currencies in its models,
    through the use of specific field types and features. Odoo’s special support for
    monetary values and currencies simplifies the handling of financial data, ensuring
    accuracy, consistency, and compliance with currency-related requirements.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模型中处理货币值和货币，我们可以使用Odoo通过使用特定的字段类型和功能来提供对货币值和货币的特殊支持。Odoo对货币值和货币的特殊支持简化了财务数据的处理，确保准确性、一致性和符合货币相关要求。
- en: Getting ready
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the same `my_hostel` add-on module from the previous recipe.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前配方中的相同`my_hostel`附加模块。
- en: How to do it…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: We need to add a currency field along with a monetary field to store the currency
    for the amounts.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个货币字段以及一个货币字段来存储金额的货币。
- en: 'We will add `models/hostel_room.py`, to add the necessary fields:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加`models/hostel_room.py`，以添加必要的字段：
- en: 'Create the field to store the currency for the amounts:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建字段以存储金额的货币：
- en: '[PRE16]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the monetary field to store the amount:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加货币字段以存储金额：
- en: '[PRE17]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a security file for the new model and a form view to show it in the
    UI. Upgrade the add-on module to apply the changes. The monetary field will appear
    like this:'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为新模型创建一个安全文件和一个表单视图以在UI中显示它。升级附加模块以应用更改。货币字段将显示如下：
- en: "![Figure 4.3 – The currenc\uFEFFy symbol in the monetary field](img/B20997_04_3.jpg)"
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – 货币字段中的货币符号](img/B20997_04_3.jpg)'
- en: Figure 4.3 – The currency symbol in the monetary field
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – 货币字段中的货币符号
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Odoo can display `monetary` fields correctly in the user interface because they
    have a second field that indicates their currency. This field is similar to a
    float field.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo可以正确地在用户界面中显示`货币`字段，因为它们有一个表示其货币的第二个字段。这个字段类似于一个浮点字段。
- en: The currency field is usually named `currency_id`, but we can use any other
    name as long as we specify it with the optional `currency_field` parameter.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 货币字段通常命名为`currency_id`，但我们可以使用任何其他名称，只要我们使用可选的`currency_field`参数指定它。
- en: If your currency information is stored in a field named `currency_id`, you don’t
    need to specify the `currency_field` attribute for the monetary field.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的货币信息存储在名为`currency_id`的字段中，您不需要为货币字段指定`currency_field`属性。
- en: This is helpful when you have to store amounts in different currencies in the
    same record. For example, if you want to have the currency of the sale order and
    the company, you can create two fields as `fields.Many2one(res.currency)` and
    use one for each amount.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要在同一记录中存储不同货币的金额时，这很有用。例如，如果您想有销售订单和公司的货币，您可以创建两个字段作为`fields.Many2one(res.currency)`，并为每个金额使用一个。
- en: The currency definition (the `decimal_precision` field of the `res.currency
    model`) determines the decimal precision for the amount.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 货币定义（`res.currency model` 的 `decimal_precision` 字段）决定了金额的小数精度。
- en: Adding relational fields to a model
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向模型添加关系字段
- en: 'Relational fields are used to represent relations between Odoo models. There
    are three types of relations:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 关系字段用于表示 Odoo 模型之间的关系。有三种类型的关系：
- en: '`many-to-one`, or `m2o` for'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`多对一`，或简称为 `m2o`'
- en: '`one-to-many`, or `o2m` for short'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`一对一`，或简称为 `o2m`'
- en: '`many-to-many`, or `m2m` for short'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`多对多`，或简称为 `m2m`'
- en: To illustrate this, let’s consider the hostel room model. A room belongs to
    a single hostel, so the relation between the hostel and the room is `m2o`. However,
    a hostel can have multiple rooms, so the opposite relationship is `o2m`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们考虑宿舍房间模型。一个房间属于一个单独的宿舍，因此宿舍和房间之间的关系是 `m2o`。然而，一个宿舍可以有多个房间，所以相反的关系是
    `o2m`。
- en: We can also have a `m2m` relationship. For instance, a room can offer various
    amenities and amenities can be available in different rooms. This is a bidirectional
    `m2m` relationship.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以有一个 `m2m` 关系。例如，一个房间可以提供各种便利设施，便利设施可以在不同的房间中可用。这是一个双向的 `m2m` 关系。
- en: Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中的 `my_hostel` 附加模块。
- en: How to do it...
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will edit the `models/hostel_room.py` file to add these fields:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编辑 `models/hostel_room.py` 文件以添加这些字段：
- en: 'Add the `m2o` field for the hostel in `Hostel Room`:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Hostel Room` 中添加 `m2o` 字段：
- en: '[PRE18]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We want to create a `o2m` field for a student that links to a room.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想为一名学生创建一个链接到房间的 `o2m` 字段。
- en: First, we need a new model for hostel students. We will make a `hostel_student.py`
    file and add some basic fields to the hostel student model. Then, we will add
    a `room_id` `m2o` field to connect the student and room models.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的宿舍学生模型。我们将创建一个 `hostel_student.py` 文件，并向宿舍学生模型添加一些基本字段。然后，我们将添加一个
    `room_id` `m2o` 字段来连接学生和房间模型。
- en: 'Finally, we will add an `o2m` field, `student_ids`, of the `hostel.student`
    model to the `hostel.room` model:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将向 `hostel.room` 模型添加一个 `o2m` 字段，`student_ids`，来自 `hostel.student` 模型：
- en: '[PRE19]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We will create a new file, `hostel_amenities.py`. Add the following code to
    the file:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的文件，`hostel_amenities.py`。将以下代码添加到该文件中：
- en: '[PRE20]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we will add an `m2m` field of amenities to the `hostel.room` model. Add
    the following code to `hostel_room.py`:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将向 `hostel.room` 模型添加一个便利设施的 `m2m` 字段。将以下代码添加到 `hostel_room.py` 文件中：
- en: '[PRE21]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, upgrade the add-on module, and the new fields should be available in the
    model. They won’t be visible in the views until they are added to them. We will
    add new fields to the `hostel_room.xml` file.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，升级附加模块，新字段应该可以在模型中找到。除非将它们添加到视图中，否则它们在视图中是不可见的。我们将向 `hostel_room.xml` 文件中添加新字段。
- en: We can confirm their addition by inspecting the `model` fields in **Settings**
    | **Technical** | **Database Structure** | **Models** in **Developer** mode.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查 **设置** | **技术** | **数据库结构** | **模型** 中的 **开发者** 模式下的 `model` 字段来确认它们的添加。
- en: How it works…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: An `m2o` field stores the database ID of another record in a column of the model’s
    table. This creates a foreign key constraint in the database, which ensures that
    the stored ID is a valid reference to a record in another table. By default, these
    relationship fields do not have a database index, but you can add one by setting
    the `index=True` attribute.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`m2o` 字段存储模型表列中另一个记录的数据库 ID。这将在数据库中创建一个外键约束，确保存储的 ID 是对另一个表中记录的有效引用。默认情况下，这些关系字段没有数据库索引，但您可以通过设置
    `index=True` 属性来添加一个。'
- en: You can also specify what happens when the record that is referenced by an `m2o`
    field is deleted. The `ondelete` attribute controls this behavior. For instance,
    what should happen to students when their room record is deleted? The default
    option is `'set null'`, which means the field will have an empty value. Another
    option is `'restrict'`, which means the related record cannot be deleted. A third
    option is `'cascade'`, which means the linked record will be deleted as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以指定当引用 `m2o` 字段的记录被删除时会发生什么。`ondelete` 属性控制这种行为。例如，当学生的房间记录被删除时，应该发生什么？默认选项是
    `'set null'`，这意味着字段将具有空值。另一个选项是 `'restrict'`，这意味着相关的记录不能被删除。第三个选项是 `'cascade'`，这意味着链接的记录也将被删除。
- en: 'You can also use `context` and `domain` for other relational fields. These
    attributes are mainly useful on the client side, and they provide default values
    for the views of the related records that are accessed through a field:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以为其他关系字段使用 `context` 和 `domain`。这些属性主要在客户端有用，并为通过字段访问的相关记录视图提供默认值：
- en: '`context` sets some variables in the client context when you click on a field
    to see the related record’s view. For example, you can use it to set default values
    for new records that are created in that view.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`context` 在您点击字段以查看相关记录视图时，在客户端上下文中设置一些变量。例如，您可以使用它为此视图中创建的新记录设置默认值。'
- en: '`domain` is a filter that limits the list of related records that you can choose
    from.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain` 是一个过滤器，限制了您可以从中选择的关联记录列表。'
- en: You can learn more about `context` and `domain` in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[*第 9 章*](B20997_09.xhtml#_idTextAnchor446) *后端视图*中了解更多关于 `context` 和 `domain`
    的信息。
- en: An `o2m` field is the opposite of an `m2o` field, and it lets you access a list
    of related records from a model. Unlike other fields, it does not have a column
    in the database table. It is just a convenient way to display these related records
    in views. To use an `o2m` field, you need to have a corresponding `m2o field`
    in the other model. In our example, we added an `o2m` field to the room model.
    The `student_ids` `o2m` field has a reference to the `room_id` field of the `hostel.room`
    model.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`o2m` 字段是 `m2o` 字段的相反，它允许您从模型访问相关记录列表。与其他字段不同，它不在数据库表中具有列。它只是方便地在视图中显示这些相关记录的一种方式。要使用
    `o2m` 字段，您需要在其他模型中有一个相应的 `m2o` 字段。在我们的示例中，我们在房间模型中添加了一个 `o2m` 字段。`student_ids`
    `o2m` 字段引用了 `hostel.room` 模型的 `room_id` 字段。'
- en: A `m2m` field does not have a column in the model’s table. Instead, it uses
    another table in the database to store the relationship between two models. This
    table has two columns for the IDs of the related records. When you link a room
    and its amenity with an `m2m` field, a new record is created in this table with
    the room’s ID and the amenity’s ID.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`m2m` 字段在模型的表中没有列。相反，它使用数据库中的另一个表来存储两个模型之间的关系。此表有两个列，用于存储相关记录的 ID。当您使用 `m2m`
    字段将房间及其设施链接起来时，在此表中创建一个新记录，包含房间的 ID 和设施的 ID。'
- en: Odoo creates the relationship table for you. By default, the name of the relationship
    table is made from the names of the two models, sorted alphabetically, with a
    `_rel` suffix. You can change this name with the `relation` attribute.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo 会为您创建关系表。默认情况下，关系表的名称是由两个模型的名称组成，按字母顺序排序，并带有 `_rel` 后缀。您可以使用 `relation`
    属性更改此名称。
- en: You should use the `relation` attribute when the names of the two models are
    too long for the default name. PostgreSQL has a limit of 63 characters for database
    identifiers. So, if the names of the two models are more than 23 characters each,
    you should set a shorter name with the `relation` attribute. We will explain this
    more in the next section.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个模型的名称对于默认名称来说太长时，您应该使用 `relation` 属性。PostgreSQL 对数据库标识符的长度限制为 63 个字符。因此，如果两个模型的名称每个都超过
    23 个字符，您应该使用 `relation` 属性设置一个较短的名称。我们将在下一节中进一步解释这一点。
- en: There’s more...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You can also use the `auto_join` attribute for `m2o` fields. This attribute
    lets ORM use SQL joins on this field. This means that ORM does not check the user
    access control and record access rules for this field. This can help with performance
    issues in some cases, but it is better to avoid it.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以为 `m2o` 字段使用 `auto_join` 属性。此属性允许 ORM 在此字段上使用 SQL 连接。这意味着 ORM 不会检查此字段的用户访问控制和记录访问规则。在某些情况下，这可以帮助解决性能问题，但最好避免这样做。
- en: We have seen the simplest way to define the relational fields. Now, let’s look
    at the attributes that are specific to these fields.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了定义关系字段的最简单方法。现在，让我们看看这些字段特有的属性。
- en: 'These are the attributes for the `o2m` field:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 `o2m` 字段的属性：
- en: '`comodel_name`: This is the name of the model that the field relates to. You
    need this attribute for all relational fields. You can write it without the keyword,
    as the first argument.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comodel_name`：这是字段所关联的模型的名称。您需要此属性用于所有关系字段。您可以不带关键字作为第一个参数来编写它。'
- en: '`inverse_name`: This is only for the `o2m` fields. It is the name of the `m2o`
    field in the other model that links back to this model.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inverse_name`：这仅适用于 `o2m` 字段。它是其他模型中链接回此模型的 `m2o` 字段的名称。'
- en: '`limit`: This is for the `o2m` and `m2m` fields. It sets a maximum number of
    records to read and display in the user interface.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit`：这是针对`o2m`和`m2m`字段的。它设置用户界面中读取和显示的最大记录数。'
- en: 'These are the attributes for the `m2m` field:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是`m2m`字段的属性：
- en: '`comodel_name`: This is the name of the model that the field relates to. It
    is the same as for the `o2m` field.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comodel_name`：这是字段关联的模型的名称。它与`o2m`字段相同。'
- en: '`relation`: This is the name of the table in the database that stores the relationship.
    You can use this attribute to change the default name.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`relation`：这是数据库中存储关系的表的名称。您可以使用此属性来更改默认名称。'
- en: '`column1`: This is the name of column 1 in the relation table that links to
    this model.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column1`：这是关系表中链接到此模型的第1列的名称。'
- en: '`column2`: This is the name of column 2 in the relation table that links to
    the other model.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`column2`：这是关系表中链接到其他模型的第2列的名称。'
- en: Odoo typically handles the creation and management of these attributes automatically.
    It can identify and utilize an existing relation table for an inverse `m2m` field.
    However, there are specific scenarios where manual intervention is required.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo通常自动处理这些属性的创建和管理。它可以识别并利用现有关系表来处理逆`m2m`字段。然而，在某些特定场景中需要手动干预。
- en: When dealing with multiple `m2m` fields between the same two models, it becomes
    necessary to assign distinct relation table names for each field.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理同一两个模型之间的多个`m2m`字段时，有必要为每个字段分配不同的关系表名称。
- en: In cases where the names of the two models exceed PostgreSQL’s limit of 63 characters
    for database object names, you must set these attributes yourself. The default
    relation table name is typically `<model1>_<model2>rel`. However, this table includes
    a primary key index with a longer name (`<model1><model2>rel<model1>id<model2>_id_key`),
    which also needs to adhere to the 63-character limit. Therefore, if the combined
    names of the two models surpass this limit, you must opt for a shorter relation
    table name.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在两个模型的名称超过PostgreSQL对数据库对象名称的63个字符限制的情况下，您必须自己设置这些属性。默认的关系表名称通常是`<model1>_<model2>rel`。然而，此表包含一个较长的名称的索引（`<model1><model2>rel<model1>id<model2>_id_key`），这也需要遵守63个字符的限制。因此，如果两个模型的组合名称超过此限制，您必须选择较短的关系表名称。
- en: Adding a hierarchy to a model
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为模型添加层次结构
- en: You can use an `m2o` field to represent hierarchies, where each record has a
    parent record and many child records in the same model. However, Odoo also provides
    improved support for this type of field by using the `nested set model` ([https://en.wikipedia.org/wiki/Nested_set_model](https://en.wikipedia.org/wiki/Nested_set_model)).
    When activated, queries using the `child_of` operator in their domain filters
    will run significantly faster.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`m2o`字段来表示层次结构，其中每个记录都有一个父记录和同一模型中的多个子记录。然而，Odoo还通过使用`嵌套集模型`([https://en.wikipedia.org/wiki/Nested_set_model](https://en.wikipedia.org/wiki/Nested_set_model))来提供对此类字段的支持。当激活时，在域过滤器中使用`child_of`运算符的查询将显著加快。
- en: Staying with the `Hostel` example, we will build a hierarchical category tree
    that can be used to categorize hostels.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 以“宿舍”为例，我们将构建一个可以用于分类宿舍的层次结构分类树。
- en: Getting ready
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前一个菜谱中的`my_hostel`附加模块。
- en: How to do it...
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will add a new Python file, `models/hostel_categ.py`, for the category tree,
    as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为分类树添加一个新的Python文件，`models/hostel_categ.py`，如下所示：
- en: 'To load the new Python code file, add the following line to `models/__init__.py`:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要加载新的Python代码文件，请将以下行添加到`models/__init__.py`：
- en: '[PRE22]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: from odoo import models, fields, api
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: from odoo import models, fields, api
- en: 'class HostelCategory(models.Model):'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'class HostelCategory(models.Model):'
- en: _name = "hostel.category"
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: _name = "hostel.category"
- en: name = fields.Char('Category')
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: name = fields.Char('类别')
- en: parent_id = fields.Many2one(
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: parent_id = fields.Many2one(
- en: '''hostel.category'','
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''hostel.category'','
- en: string='Parent Category',
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: string='父类别',
- en: ondelete='restrict',
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ondelete='restrict',
- en: index=True)
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: index=True)
- en: parent_path = fields.Char(index=True)
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: parent_path = fields.Char(index=True)
- en: child_ids = fields.One2many(
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: child_ids = fields.One2many(
- en: '''hostel.category'', ''parent_id'','
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''hostel.category'', ''parent_id'','
- en: string='Child Categories')
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: string='子类别')
- en: '[PRE23]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To enable the special hierarchy support, also add the following code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了启用特殊的层次结构支持，还需要添加以下代码：
- en: '[PRE24]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To add a check to prevent looping relations, add the following line to the
    model:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加检查以防止循环关系，请将以下行添加到模型中：
- en: '[PRE25]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, we need to assign a category to a hostel. To do this, we will add a new
    `m2o` field to the `hostel.hostel` model:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要为一家旅舍分配一个类别。为此，我们将在`hostel.hostel`模型中添加一个新的`m2o`字段：
- en: '[PRE26]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, a module upgrade will make these changes effective.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，模块升级将使这些更改生效。
- en: To display the `hostel.category` model in the user interface, you will need
    to add menus, views, and security rules. For more details, refer to [*Chapter
    3*](B20997_03.xhtml#_idTextAnchor083), *Creating Odoo Add-On Modules*. Alternatively,
    you can access all code at [https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要在用户界面中显示`hostel.category`模型，您需要添加菜单、视图和安全性规则。有关更多详细信息，请参阅[*第3章*](B20997_03.xhtml#_idTextAnchor083)，*创建Odoo附加模块*。或者，您也可以访问所有代码[https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Odoo-17-Development-Cookbook-Fifth-Edition/tree/main/Chapter04)。
- en: How it works…
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We want to create a new model with hierarchical relations. This means that
    each record can have a parent record and many child records in the same model.
    Here are the steps to do this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建一个新的具有层次关系的模型。这意味着每个记录都可以在同一模型中有一个父记录和多个子记录。以下是完成此操作的步骤：
- en: We create an `m2o` field to reference the parent record. We use `index=True`
    to make this field indexed in the database for faster queries. We also use `ondelete='cascade'`
    or `ondelete='restrict'` to control what happens when the parent record is deleted.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个`m2o`字段来引用父记录。我们使用`index=True`来使此字段在数据库中索引，以便更快地进行查询。我们还使用`ondelete='cascade'`或`ondelete='restrict'`来控制当父记录被删除时会发生什么。
- en: We create a `o2m` field to access all the child records of a record. This field
    does not add anything to the database, but it is a convenient way to get the child
    records. We add a special support for hierarchies by using `parent_store=True`
    in the model attribute. This makes the queries using the `child_of` operator faster,
    but it also makes the write operations slower. We also add a helper field called
    `parent_path` to store data for hierarchical searches. If we use a different name
    from `parent_id` for the parent field, we need to specify it with `parent_name`
    in the model attribute.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个`o2m`字段来访问一个记录的所有子记录。这个字段不会向数据库添加任何内容，但它是一种方便获取子记录的方法。我们通过在模型属性中使用`parent_store=True`来添加对层次结构的特殊支持。这使得使用`child_of`运算符的查询更快，但同时也使得写操作变慢。我们还添加了一个名为`parent_path`的辅助字段来存储用于层次结构搜索的数据。如果我们为父字段使用与`parent_id`不同的名称，我们需要在模型属性中使用`parent_name`来指定它。
- en: We prevent cyclic dependencies in the hierarchy by using the `_check_recursion`
    method from `models.Model`. This avoids us having a record that is both an ancestor
    and a descendant of another record, which can cause infinite loops.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过使用`models.Model`中的`_check_recursion`方法来防止层次结构中的循环依赖。这避免了我们有一个既是另一个记录的祖先又是后代的记录，这可能导致无限循环。
- en: We add a `category_id` field with `Many2one` type to the hostel.hostel model,
    so that we can assign a category to each hostel. This is just to complete our
    example.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`hostel.hostel`模型中添加了一个`category_id`字段，类型为`Many2one`，以便我们可以为每个旅舍分配一个类别。这只是为了完成我们的示例。
- en: There’s more…
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: You should use this technique for hierarchies that do not change much but are
    read and queried a lot. This is because the nested set model in the database needs
    to update the `parent_path` column (and the related database indexes) for all
    records when a category is added, deleted, or moved. This can be slow and costly,
    especially when there are many concurrent transactions.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该使用这种技术来处理层次结构变化不大但读取和查询频繁的情况。这是因为数据库中的嵌套集模型需要在添加、删除或移动类别时更新所有记录的`parent_path`列（和相关数据库索引）。这可能会很慢且成本高昂，尤其是在有大量并发事务的情况下。
- en: If you have a hierarchy that changes a lot, you might get better performance
    by using the standard `parent_id` and `child_ids` relationships. This way, you
    can avoid table-level locks.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的层次结构经常变化，您可能会通过使用标准的`parent_id`和`child_ids`关系获得更好的性能。这样，您可以避免表级锁定。
- en: Adding constraints validations to a model
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向模型添加约束验证
- en: 'We want to make sure that our models do not have invalid or inconsistent data.
    Odoo has two kinds of constraints to do this:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想确保我们的模型没有无效或不一致的数据。Odoo有两种类型的约束来完成这项工作：
- en: '`Database-level constraints`: These are the constraints that PostgreSQL supports.
    The most common ones are the `UNIQUE` constraints, which prevent duplicate values.
    We can also use `CHECK` and `EXCLUDE` constraints for other conditions. These
    constraints are fast and reliable, but they are limited by what PostgreSQL can
    do.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`数据库级别的约束`：这是PostgreSQL支持的约束。最常见的是`UNIQUE`约束，它防止重复值。我们还可以使用`CHECK`和`EXCLUDE`约束来满足其他条件。这些约束快速且可靠，但它们受限于PostgreSQL能做什么。'
- en: '`Server-level constraints`: These are the constraints that we write in Python
    code. We can use these constraints when the database-level ones are not enough
    for our needs. These constraints are more flexible and powerful, but they are
    slower and more complex.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`服务器级别的约束`：这是我们编写的Python代码中的约束。当数据库级别的约束不足以满足我们的需求时，我们可以使用这些约束。这些约束更灵活且功能强大，但它们较慢且更复杂。'
- en: Getting ready
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
    We will use the hostel room model and add some constraints to it. We will use
    the hostel room model from [*Chapter* *3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo Add-On Modules*, and add some constraints to it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前配方中的`my_hostel`附加模块。我们将使用宿舍房间模型并向其添加一些约束。我们将使用来自[*第3章*](B20997_03.xhtml#_idTextAnchor083)的宿舍房间模型，*创建Odoo附加模块*，并向其添加一些约束。
- en: We will use a `UNIQUE` constraint to ensure that room numbers are not repeated.
    We will also add a Python model constraint to check that the rent amount is positive.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个`UNIQUE`约束来确保房间号码不会重复。我们还将添加一个Python模型约束来检查租金金额是否为正。
- en: How to do it...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'SQL constraints are defined through the `_sql_constraints` model attribute.
    This attribute is assigned a list of triples containing strings `(name`, `sql_definition`,
    `message)`, where `name` is a valid SQL constraint name, `sql_definition` is a
    `table_constraint` expression, and `message` is the error message. We can add
    the following code to the `hostel.room` model:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SQL约束是通过`_sql_constraints`模型属性定义的。此属性被分配一个包含字符串`(name`, `sql_definition`, `message)`的三元组列表，其中`name`是有效的SQL约束名称，`sql_definition`是`table_constraint`表达式，`message`是错误消息。我们可以在`hostel.room`模型中添加以下代码：
- en: '[PRE27]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'A Python constraint is a method that checks a condition on a set of records.
    We use the `constrains()` decorator to mark the method as a constraint and to
    indicate which fields are involved in the condition. The constraint is automatically
    checked when any of these fields are changed. The method should raise an exception
    if the condition is not met:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个检查记录集中条件的方法。我们使用`constrains()`装饰器标记方法为约束，并指示哪些字段参与了条件。当这些字段中的任何一个被更改时，将自动检查约束。如果条件不满足，方法应抛出异常：
- en: '[PRE28]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: You need to upgrade the add-on module and restart the server after you make
    these changes to the code file.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在对代码文件进行这些更改后，您需要升级附加模块并重新启动服务器。
- en: Note
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you add SQL constraints to the existing model through model inheritance,
    make sure you don’t have rows that violate the constraints. If you have such rows,
    then SQL constraints will not be added, and an error will be generated in the
    log.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你通过模型继承将SQL约束添加到现有模型中，请确保没有违反约束的行。如果你有此类行，则不会添加SQL约束，并在日志中生成错误。
- en: For more information on PostgreSQL constraints in general and table constraints
    in particular, take a look at [http://www.postgresql.org/docs/current/static/ddl-constraints.html](http://www.postgresql.org/docs/current/static/ddl-constraints.html).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 有关PostgreSQL约束的一般信息和特定于表的约束的更多信息，请参阅[http://www.postgresql.org/docs/current/static/ddl-constraints.html](http://www.postgresql.org/docs/current/static/ddl-constraints.html)。
- en: How it works…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We can use Python code to validate our models and prevent invalid data. To
    do this, we use two things:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Python代码来验证我们的模型并防止无效数据。为此，我们使用两个东西：
- en: A method that checks a condition on a set of records. We use the `constrains()`
    decorator to mark the method as a constraint and to indicate which fields are
    involved in the condition. The constraint is automatically checked when any of
    these fields are changed.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 一个检查记录集中条件的方法。我们使用`constrains()`装饰器标记方法为约束，并指示哪些字段参与了条件。当这些字段中的任何一个被更改时，将自动检查约束。
- en: A `ValidationError` exception that we raise when the condition is not met. This
    exception shows an error message to the user and stops the operation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件不满足时，我们抛出的`ValidationError`异常。此异常向用户显示错误消息并停止操作。
- en: Adding computed fields to a model
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向模型添加计算字段
- en: We may want to create a field that depends on the values of other fields in
    the same record or in related records. For instance, we can calculate the total
    amount by multiplying a unit price by a quantity. In Odoo models, we can use computed
    fields to do this.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要创建一个字段，该字段依赖于同一记录或相关记录中其他字段的值。例如，我们可以通过将单价乘以数量来计算总额。在Odoo模型中，我们可以使用计算字段来完成这项工作。
- en: To demonstrate how computed fields work, we will add one to the Hostel Room
    model that computes the availability of rooms based on student occupancy.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示计算字段的工作原理，我们将在宿舍房间模型中添加一个计算字段，该字段根据学生入住情况计算房间可用性。
- en: We can also make computed fields editable and searchable. We will show you how
    to do this in our example as well.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使计算字段可编辑和可搜索。我们将在我们的示例中向您展示如何做到这一点。
- en: Getting ready
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中的`my_hostel`附加模块。
- en: How to do it...
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will modify the `models/hostel_room.py` code file to include a new field
    and the methods that implement its logic:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改`models/hostel_room.py`代码文件，以包含一个新字段及其实现逻辑的方法：
- en: 'A computed field’s value usually relies on the values of other fields in the
    same record. ORM requires the developer to declare those dependencies on the `compute`
    method using the `depends()` decorator. ORM uses the given dependencies to recompute
    the field whenever any of its dependencies change. Start by adding the new fields
    to the `Hostel` `Rooms` model:'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算字段的值通常依赖于同一记录中其他字段的值。ORM要求开发者在`compute`方法中使用`depends()`装饰器声明这些依赖关系。ORM使用给定的依赖关系，在任何一个依赖关系发生变化时重新计算字段。首先，将新字段添加到`Hostel`
    `Rooms`模型中：
- en: '[PRE29]'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: By default, computed fields are read-only because the user should not enter
    a value.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，计算字段是只读的，因为用户不应输入值。
- en: 'However, in some cases, it might be helpful to allow the user to set a value
    directly. For example, in our hostel student scenario, we will add an admission
    date, discharge date, and duration. We would like the user to be able to enter
    either the duration or the discharge date and have the other value updated accordingly:'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，允许用户直接设置值可能是有帮助的。例如，在我们的宿舍学生场景中，我们将添加入学日期、出院日期和持续时间。我们希望用户能够输入持续时间或出院日期，其他值将相应更新：
- en: '[PRE30]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: A compute method assigns a value to the field, while an inverse method assigns
    values to the field’s dependencies.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算方法将值分配给字段，而逆方法将值分配给字段的依赖关系。
- en: Note that the inverse method is invoked when the record is saved, while the
    compute method is invoked whenever any of its dependencies change.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，当记录保存时调用逆方法，而计算方法在其依赖关系中的任何一个发生变化时都会被调用。
- en: 'Computed fields are not stored in the database by default. One solution is
    to store the field with the `store=True` attribute:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算字段默认情况下不存储在数据库中。一种解决方案是将字段存储为具有`store=True`属性：
- en: '[PRE31]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As computed fields are not stored in the database by default, it is not possible
    to search on a computed field unless we use the `store=True` attribute or add
    a `search` method.
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于计算字段默认情况下不存储在数据库中，除非我们使用`store=True`属性或添加一个`search`方法，否则无法对计算字段进行搜索。
- en: How it works...
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A computed field looks like a regular field, except that it has a `compute`
    attribute that specifies the name of the method that computes its value.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 计算字段看起来像一个普通字段，但它有一个`compute`属性，该属性指定了计算其值的方法的名称。
- en: However, computed fields are not the same as regular fields internally. Computed
    fields are calculated on the fly at runtime, and because of that, they are not
    stored in the database, so you cannot search or write on them by default. You
    need to do some extra work to enable writing and search support for them. Let’s
    see how to do it.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，计算字段在内部并不等同于普通字段。计算字段在运行时即时计算，因此它们不存储在数据库中，所以默认情况下无法对它们进行搜索或写入。您需要做一些额外的工作来启用对它们的写入和搜索支持。让我们看看如何做。
- en: The computation method is calculated on the fly at runtime, but ORM uses caching
    to avoid recalculating it unnecessarily every time its value is accessed. So,
    it needs to know what other fields it relies on. It uses the `@depends` decorator
    to determine when its cached values should be invalidated and recalculated.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 计算方法在运行时即时计算，但ORM使用缓存来避免每次访问其值时都无必要地重新计算。因此，它需要知道它依赖于哪些其他字段。它使用`@depends`装饰器来确定何时应该使缓存的值无效并重新计算。
- en: Make sure that the compute method always assigns a value to the computed field.
    Otherwise, an error will occur. This can happen when you have conditions in your
    code that sometimes fail to assign a value to the computed field. This can be
    hard to debug.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 确保计算方法始终为计算字段分配一个值。否则，将发生错误。这可能会发生在您的代码中有条件有时未能为计算字段分配值的情况下。这可能很难调试。
- en: Write support can be added by implementing the `inverse` method. This uses the
    value assigned to the computed field to update the source fields. Of course, this
    only works for simple calculations. However, there are still cases where it can
    be helpful. In our example, we make it possible to set the discharge date by editing
    the duration days, since `Duration` is a computed field.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现`inverse`方法可以添加写入支持。这使用分配给计算字段的值来更新源字段。当然，这仅适用于简单计算。然而，仍然有一些情况下它可能很有帮助。在我们的例子中，我们通过编辑持续时间天数来使设置排放日期成为可能，因为`Duration`是一个计算字段。
- en: The `inverse` attribute is optional; if you don’t want to make the computed
    field editable, you can skip it.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '`inverse`属性是可选的；如果您不想使计算字段可编辑，可以跳过它。'
- en: It is also possible to make a non-stored computed field searchable by setting
    the `search` attribute to the method name (similar to `compute` and `inverse`).
    Like `inverse`, `search` is also optional; if you don’t want to make the computed
    field searchable, you can skip it.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以通过将`search`属性设置为方法名（类似于`compute`和`inverse`）来使非存储计算字段可搜索。与`inverse`一样，`search`也是可选的；如果您不想使计算字段可搜索，可以跳过它。
- en: However, this method is not supposed to perform the actual search. Instead,
    it receives the operator and value used to search on the field as parameters and
    is supposed to return a domain, with the alternative search conditions to use.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法不应该执行实际的搜索。相反，它接收用于在字段上搜索的操作符和值作为参数，并应该返回一个域，其中包含要使用的替代搜索条件。
- en: The optional `store=True` flag stores the field in the database. In this case,
    after being computed, the field values are stored in the database, and from then
    on, they are retrieved in the same way as regular fields, instead of being recomputed
    at runtime. Thanks to the `@api.depends` decorator, ORM will know when these stored
    values need to be recomputed and updated. You can think of it as a persistent
    cache. It also has the benefit of making the field usable for search conditions,
    including sorting and grouping by operations. If you use `store=True` in your
    compute field, you no longer need to implement the `search` method because the
    field is stored in a database, and you can search/sort based on it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的`store=True`标志将字段存储在数据库中。在这种情况下，计算后，字段值存储在数据库中，并且从那时起，它们以与常规字段相同的方式检索，而不是在运行时重新计算。多亏了`@api.depends`装饰器，ORM将知道何时需要重新计算和更新这些存储值。您可以将它视为持久缓存。它还有使字段可用于搜索条件的好处，包括排序和按操作分组。如果您在计算字段中使用`store=True`，则不再需要实现`search`方法，因为该字段存储在数据库中，并且可以基于它进行搜索/排序。
- en: The `compute_sudo=True` flag is for cases where the computations need to be
    done with higher privileges. This might be needed when the computation needs to
    use data that may not be accessible to the end user.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '`compute_sudo=True`标志用于需要以更高权限执行计算的情况。这可能是在计算需要使用可能对最终用户不可访问的数据时所需的。'
- en: Note
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The default value of `compute_sudo` changed in Odoo v13\. Before Odoo v13, the
    value of `compute_sudo` was `False`, but in v13, the default value of `compute_sudo`
    depends on the store attribute. If the `store` attribute is `True`, then `compute_sudo`
    is `True`; otherwise, it is `False`. However, you can always override it by explicitly
    setting `compute_sudo` in your field definition.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在Odoo v13中，`compute_sudo`的默认值发生了变化。在Odoo v13之前，`compute_sudo`的值是`False`，但在v13中，`compute_sudo`的默认值取决于`store`属性。如果`store`属性是`True`，则`compute_sudo`是`True`；否则，它是`False`。但是，您可以通过在字段定义中显式设置`compute_sudo`来始终覆盖它。
- en: There’s more...
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Odoo v13 introduced a new caching mechanism for ORM. Previously, the cache
    was based on the environment, but now, in Odoo v13, there is one global cache.
    So, if you have a computed field that relies on context values, then you may get
    the wrong values sometimes. To solve this problem, you need to use the `@api.depends_context`
    decorator. Refer to the following example:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo v13为ORM引入了一种新的缓存机制。以前，缓存是基于环境的，但现在，在Odoo v13中，有一个全局缓存。因此，如果您有一个依赖于上下文值的计算字段，有时您可能会得到错误值。为了解决这个问题，您需要使用`@api.depends_context`装饰器。请参考以下示例：
- en: '[PRE32]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You can see in the preceding example that our computation uses `company_id`
    from the context. By using `company_id` in the `depends_context` decorator, we
    ensure that the field value will be recomputed based on the value of `company_id`
    in the context.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在前面的例子中看到，我们的计算使用了上下文中的`company_id`。通过在`depends_context`装饰器中使用`company_id`，我们确保字段值将根据上下文中`company_id`的值重新计算。
- en: Exposing related fields stored in other models
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露存储在其他模型中的相关字段
- en: Odoo clients can only read data from the server for the fields that belong to
    the model they are querying. They cannot access data from related tables using
    dot notation as server-side code can.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo客户端只能读取他们查询的模型所属的字段数据。他们不能像服务器端代码那样使用点符号访问相关表中的数据。
- en: However, we can make the data from related tables available to the clients by
    adding it as related fields. This is what we will do to get the hostel of the
    room in the student model.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以通过添加相关字段来使相关表中的数据对客户端可用。这就是我们将如何获取学生模型中房间的宿舍。
- en: Getting ready
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中的`my_hostel`附加模块。
- en: How to do it...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Edit the `models/hostel_student.py` file to add the new `related` field.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`models/hostel_student.py`文件以添加新的`related`字段。
- en: 'Ensure that we have a field for the hostel room, and then, we add a new relation
    field to link the student with their hostel:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 确保我们有一个宿舍房间字段，然后，我们添加一个新的关联字段来将学生与他们的宿舍联系起来：
- en: '[PRE33]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Finally, we need to upgrade the add-on module for the new field to be available
    in the model.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要升级附加模块，以便新字段可以在模型中使用。
- en: How it works...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A related field is a special type of field that references another field from
    a different record. To create a related field, we need to specify the `related`
    attribute and give it a string that shows the path of fields to follow. For example,
    we can create a related field that shows the hostel of the room of a student by
    following the `room_id.hostel_id` path.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 相关字段是一种特殊类型的字段，它引用来自不同记录的另一个字段。要创建相关字段，我们需要指定`related`属性，并给出一个显示要跟随的字段路径的字符串。例如，我们可以创建一个显示学生房间宿舍的相关字段，通过遵循`room_id.hostel_id`路径。
- en: There’s more...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Related fields are, in fact, computed fields. They just provide a convenient
    shortcut syntax to read field values from related models. As they are computed
    fields, this means that the `store` attribute is also available. As a shortcut,
    they also have all the attributes from the referenced field, such as `name` and
    `translatable`, as required.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 相关字段实际上是计算字段。它们只是提供了一个方便的快捷语法来从相关模型中读取字段值。由于它们是计算字段，这意味着`store`属性也是可用的。作为快捷方式，它们还具有所需的所有引用字段属性，例如`name`和`translatable`。
- en: Additionally, they support a `related_sudo` flag, similar to `compute_sudo`;
    when set to `True`, the field chain is traversed without checking the user access
    rights.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它们支持一个`related_sudo`标志，类似于`compute_sudo`；当设置为`True`时，字段链在遍历时不检查用户访问权限。
- en: Using related fields in a `create()` method can affect performance, as the computation
    of these fields is delayed until the end of their creation. So, if you have an
    `o2m` relationship, such as in the `sale.order` and `sale.order.line` models,
    and you have a related field on the line model referring to a field on the order
    model, you should explicitly read the field on the order model during record creation,
    instead of using the related field shortcut, especially if there are a lot of
    lines.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在`create()`方法中使用相关字段可能会影响性能，因为这些字段的计算被延迟到它们创建的末尾。因此，如果你有一个`o2m`关系，例如在`sale.order`和`sale.order.line`模型中，并且你在行模型上有一个指向订单模型字段的关联字段，你应该在记录创建期间显式地读取订单模型上的字段，而不是使用关联字段快捷方式，尤其是当有很多行时。
- en: Adding dynamic relations using reference fields
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用引用字段添加动态关系
- en: With relational fields, we need to decide the relation’s target model (or co-model)
    beforehand. However, sometimes, we may need to leave that decision to the user
    and first choose the model we want and then the record we want to link it to.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关系字段，我们需要事先决定关系的目标模型（或共同模型）。然而，有时我们可能需要将此决定留给用户，首先选择我们想要的模型，然后选择我们想要链接的记录。
- en: With Odoo, this can be achieved using reference fields.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Odoo，这可以通过引用字段实现。
- en: Getting ready
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中的`my_hostel`附加模块。
- en: How to do it...
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Edit the `models/hostel.py` file to add the new related field:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`models/hostel.py`文件以添加新的相关字段：
- en: 'First, we need to add a helper method to dynamically build a list of selectable
    target models:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个辅助方法来动态构建可选择的目标模型列表：
- en: '[PRE34]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then, we need to add the reference field and use the previous function to provide
    a list of selectable models:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加引用字段并使用之前的函数提供可选择的模型列表：
- en: '[PRE35]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since we are changing the model’s structure, a module upgrade is needed to activate
    these changes.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在更改模型的结构，因此需要模块升级以激活这些更改。
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Reference fields are similar to `m2o` fields, except that they allow the user
    to select the model to link to.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 引用字段类似于`m2o`字段，但它们允许用户选择要链接到的模型。
- en: The target model is selectable from a list that’s provided by the `selection`
    attribute. The `selection` attribute must be a list of two-element tuples, where
    the first is the model’s internal identifier and the second is a text description
    for it.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 目标模型可以从由`selection`属性提供的列表中选择。`selection`属性必须是一个包含两个元素的元组的列表，其中第一个是模型的内部标识符，第二个是对它的文本描述。
- en: 'Here’s an example:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE36]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: However, rather than providing a fixed list, we can use the most common models.
    For simplicity, we used all the models that have the messaging feature. Using
    the `_referencable_models` method, we provided a model list dynamically.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，而不是提供一个固定的列表，我们可以使用最常用的模型。为了简单起见，我们使用了具有消息功能的全部模型。使用`_referencable_models`方法，我们动态地提供了一个模型列表。
- en: Our recipe started by providing a function to browse all the model records that
    can be referenced, to dynamically build a list that will be provided to the `selection`
    attribute. Although both forms are allowed, we declared the function name inside
    quotes, instead of directly referencing the function without quotes. This is more
    flexible, and it allows for the referenced function to be defined only later in
    code, for example, which is something that is not possible when using a direct
    reference.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的配方从提供一个函数开始，该函数可以浏览所有可引用的模型记录，以动态构建一个将提供给`selection`属性的列表。尽管两种形式都是允许的，但我们声明了带引号的函数名，而不是直接引用不带引号的函数。这更加灵活，并允许在代码中稍后定义引用的函数，例如，这是在使用直接引用时不可能做到的。
- en: The function needs the `@api.model` decorator because it operates on the model
    level, not on the record set level.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数需要`@api.model`装饰器，因为它在模型级别上操作，而不是在记录集级别上。
- en: While this feature looks nice, it comes with a significant execution overhead.
    Displaying the reference fields for a large number of records (for instance, in
    a list view) can create heavy database loads, as each value has to be looked up
    in a separate query. It is also unable to take advantage of database referential
    integrity, unlike regular relation fields.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个功能看起来不错，但它带来了显著的执行开销。在大量记录（例如，在列表视图中）显示引用字段可能会创建沉重的数据库负载，因为每个值都需要在单独的查询中进行查找。与常规关系字段不同，它也无法利用数据库引用完整性。
- en: Adding features to a model using inheritance
  id: totrans-368
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承向模型添加功能
- en: Odoo boasts a robust feature that significantly enhances its flexibility and
    functionality, which is particularly beneficial for businesses seeking tailored
    solutions. This feature enables the integration of module add-ons, allowing them
    to augment the capabilities of existing modules without the need to alter their
    underlying codebase. This is achieved through the addition or modification of
    fields and methods, as well as the extension of current methods with supplementary
    logic. This modular approach not only facilitates a customizable and scalable
    system but also ensures that upgrades and maintenance remain streamlined, preventing
    the complexities typically associated with custom modifications.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: Odoo拥有一个强大的功能，可以显著增强其灵活性和功能性，这对于寻求定制解决方案的企业尤其有益。此功能允许集成模块附加组件，使它们能够增强现有模块的功能，而无需修改其底层代码库。这是通过添加或修改字段和方法，以及通过扩展当前方法并添加补充逻辑来实现的。这种模块化方法不仅促进了可定制和可扩展的系统，而且还确保了升级和维护保持流畅，防止了与自定义修改通常相关的复杂性。
- en: 'The official documentation describes three kinds of inheritance in Odoo:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 官方文档描述了Odoo中的三种继承方式：
- en: Class inheritance (extension)
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类继承（扩展）
- en: Prototype inheritance
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型继承
- en: Delegation inheritance
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托继承
- en: We will see each one of these in a separate recipe. In this recipe, we will
    see class inheritance (extension). This is used to add new fields or methods to
    existing models.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在单独的配方中看到这些内容。在这个配方中，我们将看到类继承（扩展）。这是用来向现有模型添加新字段或方法的。
- en: We’ll expand the existing partner model, `res.partner`, to include it in a computed
    field that calculates how many hostel rooms are assigned to each user. This will
    help determine which section each room is assigned to and which user occupies
    it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展现有的合作伙伴模型 `res.partner`，使其包含一个计算每个用户分配了多少宿舍房间的计算字段。这将有助于确定每个房间分配给哪个部分以及哪个用户占用它。
- en: Getting ready
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前一个菜谱中的 `my_hostel` 附加模块。
- en: How to do it...
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We will extend the built-in partner model. If you remember, we already inherited
    the `res.parnter` model in the *Adding relational fields to a model* recipe in
    this chapter. To keep the explanation as simple as possible, we will reuse the
    `res.partner` model in the `models/hostel_book.py` code file:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展内置的合作伙伴模型。如果您记得，我们已经在本章的 *向模型添加关系字段* 菜谱中继承了 `res.parnter` 模型。为了使解释尽可能简单，我们将在
    `models/hostel_book.py` 代码文件中重用 `res.partner` 模型：
- en: 'First, we will ensure that the `authored_book_ids` inverse relation is in the
    partner model and add the computed field:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将确保 `authored_book_ids` 反向关系在合作伙伴模型中，并添加计算字段：
- en: '[PRE37]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, add the method that’s needed to compute the book count:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加计算书籍数量的所需方法：
- en: '[PRE38]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, we need to upgrade the add-on module for the modifications to take
    effect.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要升级附加模块以使修改生效。
- en: How it works...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When a model class is defined with the `_inherit` attribute, it adds modifications
    to the inherited model, rather than replacing it.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `_inherit` 属性定义模型类时，它向继承的模型添加修改，而不是替换它。
- en: This means that fields defined in the inheriting class are added or changed
    on the parent model. At the database layer, ORM adds fields to the same database
    table.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在继承类中定义的字段被添加或更改到父模型中。在数据库层，ORM 将字段添加到同一数据库表中。
- en: Fields are also incrementally modified. This means that if the field already
    exists in the superclass, only the attributes declared in the inherited class
    are modified; the other ones are kept as they are in the parent class.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 字段也逐步修改。这意味着如果字段已经在超类中存在，则仅修改继承类中声明的属性；其他属性保持与父类中相同。
- en: Methods defined in the inheriting class replace methods in the parent class.
    If you don’t invoke the parent method with the `super` call, the parent’s version
    of the method will not be executed, and we will lose the features. So, whenever
    you add a new logic by inheriting existing methods, you should include a statement
    with `super` to call its version in the parent class. This is discussed in more
    detail in [*Chapter 5*](B20997_05.xhtml#_idTextAnchor238), *Basic* *Server-Side
    Development*.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 继承类中定义的方法将替换父类中的方法。如果您不使用 `super` 调用父方法，则父方法的版本将不会执行，我们将失去功能。因此，每次您通过继承现有方法添加新逻辑时，都应该包含一个带有
    `super` 的语句来调用其父类中的版本。这将在 [*第 5 章*](B20997_05.xhtml#_idTextAnchor238) 的 *基本* *服务器端开发*
    中更详细地讨论。
- en: This recipe will add new fields to the existing model. If you also want to add
    these new fields to existing views (the user interface), refer to the *Changing
    existing views –* *view inheritance* recipe in [*Chapter 9*](B20997_09.xhtml#_idTextAnchor446),
    *Backend Views*.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱将为现有模型添加新字段。如果您还希望将这些新字段添加到现有视图中（用户界面），请参阅 [*第 9 章*](B20997_09.xhtml#_idTextAnchor446)
    的 *更改现有视图 –* *视图继承* 菜谱，*后端视图*。
- en: Copying the model definition using inheritance
  id: totrans-391
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用继承复制模型定义
- en: We saw class inheritance (extension) in the previous recipe. Now, we will see
    `hostel.room` model.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前一个菜谱中看到了类继承（扩展）。现在，我们将看到 `hostel.room` 模型。
- en: Getting ready
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用前一个菜谱中的 `my_hostel` 附加模块。
- en: How to do it...
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Prototype inheritance is executed by using the `_name` and `_inherit` class
    attributes at the same time. Perform the following steps to generate a copy of
    the `hotel.room` model:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 原型继承是通过同时使用 `_name` 和 `_inherit` 类属性来执行的。执行以下步骤以生成 `hotel.room` 模型的副本：
- en: Add a new file called `hostel_room_copy.py` to the `/``my_hostel/models/` directory.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `/my_hostel/models/` 目录下添加一个名为 `hostel_room_copy.py` 的新文件。
- en: 'Add the following content to the `hostel_room_copy.py` file:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 `hostel_room_copy.py` 文件中：
- en: '[PRE39]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Import a new file reference into the `/my_library/models/__init__.py` file.
    Following the changes, your `__init__.py` file will look like this:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件引用导入 `/my_library/models/__init__.py` 文件。在更改之后，您的 `__init__.py` 文件将看起来像这样：
- en: '[PRE40]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Finally, we need to upgrade the add-on module for the modifications to take
    effect.
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要升级附加模块以使修改生效。
- en: To check the new model’s definition, go to the `hostel.room.copy` model here.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要检查新模型的定义，请转到这里的 `hostel.room.copy` 模型。
- en: Tip
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: In order to see menus and views for the new model, you need to add the XML definition
    of views and menus. To learn more about views and menus, refer to the *Adding
    menu items and views recipe* in [*Chapter 3*](B20997_03.xhtml#_idTextAnchor083),
    *Creating Odoo* *Add-On Modules*.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看新模型的菜单和视图，你需要添加视图和菜单的 XML 定义。要了解更多关于视图和菜单的信息，请参考 [*第 3 章*](B20997_03.xhtml#_idTextAnchor083)
    中的 *添加菜单项和视图食谱*，*创建 Odoo* *附加模块*。
- en: How it works...
  id: totrans-406
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By using `_name` with the `_inherit` class attribute at the same time, you can
    copy the definition of the model. When you use both attributes in the model, Odoo
    will copy the model definition of `_inherit` and create a new model with the `_name`
    attribute.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 通过同时使用 `_name` 和 `_inherit` 类属性，你可以复制模型的定义。当你在这两个属性中使用模型时，Odoo 将复制 `_inherit`
    的模型定义，并创建一个具有 `_name` 属性的新模型。
- en: In our example, Odoo will copy the definition of the `Hostel.room` model and
    create a new model, `hostel.room.copy`. The new `hostel.room.copy` model has its
    own database table with its own data that is totally independent from the `hostel.room`
    parent model. Since it still inherits from the partner model, any subsequent modifications
    to it will also affect the new model.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，Odoo 将复制 `Hostel.room` 模型的定义并创建一个新的模型，名为 `hostel.room.copy`。新的 `hostel.room.copy`
    模型拥有自己的数据库表和独立于 `hostel.room` 父模型的自己的数据。由于它仍然继承自合作伙伴模型，对它的任何后续修改也将影响新的模型。
- en: Prototype inheritance copies all the properties of the parent class. It copies
    fields, attributes, and methods. If you want to modify them in the child class,
    you can simply do so by adding a new definition to the child class. For example,
    the `hostel.room` model has the `_name_get` method. If you want to use a different
    version of `_name_get` in the child, you need to redefine the method in the `hostel.room.copy`
    model.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 原型继承复制父类的所有属性。它复制字段、属性和方法。如果你想在子类中修改它们，你只需在子类中添加一个新的定义即可。例如，`hostel.room` 模型有
    `_name_get` 方法。如果你想在子类中使用不同的 `_name_get` 版本，你需要重新定义 `hostel.room.copy` 模型中的方法。
- en: Note
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Prototype inheritance does not work if you use the same model name in the `_inherit`
    and `_name` attributes. If you do use the same model name in the `_inherit` and
    `_name` attributes, it will just behave like a normal extension inheritance.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 `_inherit` 和 `_name` 属性中使用相同的模型名称，原型继承将不起作用。如果你确实在 `_inherit` 和 `_name`
    属性中使用相同的模型名称，它将表现得像正常的扩展继承。
- en: There’s more…
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the official documentation, this is called prototype inheritance, but in
    practice, it is rarely used. The reason for this is that delegation inheritance
    usually answers to that need in a more efficient way, without the need to **duplicate
    data structures**. For more information on this, you can refer to the next recipe,
    Using delegation inheritance to copy features to another model.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方文档中，这被称为原型继承，但在实践中，它很少被使用。原因是委托继承通常以更有效的方式满足这种需求，而不需要**复制数据结构**。有关更多信息，请参考下一道食谱，使用委托继承将功能复制到另一个模型。
- en: Using delegation inheritance to copy features to another model
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用委托继承将功能复制到另一个模型
- en: The third type of inheritance is Delegation inheritance. Instead of `_inherit`,
    it uses the `_inherits` class attribute. There are cases where, rather than modifying
    an existing model, we want to create a new model based on an existing one to use
    the features it already has. We can copy a model’s definitions with prototype
    inheritance, but this will generate duplicate data structures. If you want to
    copy a model’s definitions without duplicating data structures, then the answer
    lies in Odoo’s delegation inheritance, which uses the `_inherits` model attribute
    (note the additional `s`).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种继承类型是委托继承。它不使用 `_inherit`，而是使用 `_inherits` 类属性。有些情况下，我们不想修改现有的模型，而是想基于现有的模型创建一个新的模型来使用它已有的功能。我们可以使用原型继承复制模型定义，但这将生成重复的数据结构。如果你想在复制模型定义时不重复数据结构，那么答案就在
    Odoo 的委托继承中，它使用 `_inherits` 模型属性（注意额外的 `s`）。
- en: Traditional inheritance is quite different from the similarly named concept
    in object-oriented programming. Delegation inheritance, in turn, is similar, in
    that a new model can be created to include the features from a parent model. It
    also supports polymorphic inheritance, where we inherit from two or more other
    models.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 传统继承与面向对象编程中同名概念的差异很大。委托继承，反过来，在创建一个新模型以包含父模型的功能方面是相似的。它还支持多态继承，其中我们可以从两个或更多其他模型继承。
- en: We operate a hostel that accommodates both rooms and students. To better manage
    our accommodations, it’s essential to integrate student-related information into
    our system. Specifically, for each student, we require comprehensive identification
    and address details, similar to those captured in the partner model. Additionally,
    it’s crucial to maintain records related to room allocation, including the start
    and end dates of each student’s stay and their card number.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运营一个既提供房间又容纳学生的宿舍。为了更好地管理我们的住宿，将学生相关信息整合到我们的系统中至关重要。具体来说，对于每个学生，我们需要全面的身份和地址信息，类似于合作伙伴模型中捕获的信息。此外，维护与房间分配相关的记录也非常关键，包括每个学生入住的开始和结束日期以及他们的卡号。
- en: Directly adding these fields to the existing partner model isn’t an ideal approach,
    as it would unnecessarily clutter the model with student-specific data that is
    irrelevant for non-student partners. A more effective solution would be to enhance
    the partner model by creating a new model that inherits from it and introduces
    the additional fields required to manage student information. This approach ensures
    a cleaner, more organized, and functionally efficient system to cater to our hostel’s
    unique needs.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 直接将这些字段添加到现有的合作伙伴模型中并不是一个理想的方法，因为这会在模型中无谓地添加与学生特定的数据，这些数据对于非学生合作伙伴来说是不相关的。一个更有效的解决方案是通过创建一个新的模型来增强合作伙伴模型，该模型从它继承并引入了管理学生信息所需的所有额外字段。这种方法确保了一个更干净、更有组织、功能更高效的系统，以满足我们宿舍的独特需求。
- en: Getting ready
  id: totrans-419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用之前菜谱中的 `my_hostel` 附加模块。
- en: How to do it...
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The new library member model should be in its own Python code file, but to
    keep the explanation as simple as possible, we will reuse the `models/hostel_student.py`
    file:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 新的图书馆会员模型应该有自己的 Python 代码文件，但为了尽可能简化说明，我们将重用 `models/hostel_student.py` 文件：
- en: 'Add the new model, inheriting from `res.partner`:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加继承自 `res.partner` 的新模型：
- en: '[PRE41]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, we will add the fields that are specific to each student:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加每个学生特有的字段：
- en: '[PRE42]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now, we should upgrade the add-on module to activate the changes.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将升级附加模块以激活更改。
- en: How it works...
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `_inherits` model attribute sets the parent models that we want to inherit
    from. In this case, we just have one – `res.partner`. Its value is a key-value
    dictionary, where the keys are the inherited models and the values are the field
    names that were used to link to them. These are `m2o` fields that we must also
    define in the model. In our example, `partner_id` is the field that will be used
    to link with the `Partner` parent model.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '`_inherits` 模型属性设置了我们想要继承的父模型。在这种情况下，我们只有一个——`res.partner`。其值是一个键值字典，其中键是继承的模型，值是用于链接它们的字段名称。这些是必须也在模型中定义的
    `m2o` 字段。在我们的例子中，`partner_id` 是将用于与 `Partner` 父模型链接的字段。'
- en: 'To better understand how this works, let’s look at what happens at a database
    level when we create a new member:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解它是如何工作的，让我们看看当我们创建一个新会员时在数据库级别上会发生什么：
- en: A new record is created in the `res_partner` table.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `res_partner` 表中创建了一个新记录。
- en: A new record is created in the `hostel_student` table.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `hostel_student` 表中创建了一个新记录。
- en: The `partner_id` field of the `hostel_student` table is set to the ID of the
    `res_partner` record that is created for it
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostel_student` 表的 `partner_id` 字段被设置为为其创建的 `res_partner` 记录的 ID。'
- en: The member record is automatically linked to a new partner record. It’s just
    an `m2o` relationship, but the delegation mechanism adds some magic so that the
    partner’s fields are seen as if they belong to the member record, and a new partner
    record is also automatically created with the new member.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 会员记录自动链接到一个新的合作伙伴记录。这只是一个 `m2o` 关系，但委托机制添加了一些魔法，使得合作伙伴的字段看起来就像属于会员记录一样，并且也会自动创建一个新的合作伙伴记录。
- en: You may be interested to know that this automatically created partner record
    has nothing special about it. It’s a regular partner, and if you browse the partner
    model, you will be able to find that record (without the additional member data,
    of course). All members are partners, but only some partners are also members.
    So, what happens if you delete a partner record that is also a member? You decide
    by choosing the `ondelete` value for the relation field. For `partner_id`, we
    used `cascade`. This means that deleting the partner will also delete the corresponding
    member. We could have used the more conservative setting, `restrict`, to prohibit
    deleting the partner while it has a linked member. In this case, only deleting
    the member will work.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，这个自动创建的合作伙伴记录并没有什么特别之处。它是一个普通的合作伙伴，如果你浏览合作伙伴模型，你将能够找到那条记录（当然，不包括额外的成员数据）。所有成员都是合作伙伴，但只有一些合作伙伴也是成员。那么，如果你删除了一个也是成员的合作伙伴记录会发生什么呢？你可以通过为关系字段选择`ondelete`值来决定。对于`partner_id`，我们使用了`cascade`。这意味着删除合作伙伴也会删除相应的成员。我们本来可以使用更保守的设置`restrict`来禁止在合作伙伴有链接成员的情况下删除合作伙伴。在这种情况下，只有删除成员才会生效。
- en: It’s important to note that delegation inheritance only works for fields, not
    for methods. So, if the partner model has a `do_something()` method, the members
    model will not automatically inherit it.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，委托继承仅适用于字段，不适用于方法。所以，如果合作伙伴模型有一个`do_something()`方法，成员模型将不会自动继承它。
- en: There’s more...
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is a shortcut for this inheritance delegation. Instead of creating an
    `_inherits` dictionary, you can use the `delegate=True` attribute in the `m2o`
    field definition. This will work exactly like the `_inherits` option. The main
    advantage is that this is simpler. In the given example, we performed the same
    inheritance delegation as in the previous one, but in this case, instead of creating
    an `_inherits` dictionary, we used the `delegate=True` option in the `partner_id`
    field:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种继承委托有一个快捷方式。你不需要创建一个`_inherits`字典，你可以在`m2o`字段定义中使用`delegate=True`属性。这将与`_inherits`选项完全一样。主要优势是这更简单。在给定的例子中，我们执行了与上一个例子相同的继承委托，但在这个例子中，我们不是创建一个`_inherits`字典，而是在`partner_id`字段中使用了`delegate=True`选项：
- en: '[PRE43]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: A noteworthy case of delegation inheritance is the users model, `res.users`.
    It inherits from partners (`res.partner`). This means that some of the fields
    that you can see on the user are actually stored in the partner model (notably,
    the `name` field). When a new user is created, we also get a new, automatically
    created partner.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 委托继承的一个值得注意的案例是用户模型，`res.users`。它从合作伙伴（`res.partner`）继承。这意味着用户上可以看到的一些字段实际上存储在合作伙伴模型中（特别是`name`字段）。当创建新用户时，我们也会得到一个新的、自动创建的合作伙伴。
- en: We should also mention that traditional inheritance with `_inherit` can also
    copy features into a new model, although in a less efficient way. This was discussed
    in the *Adding features to a model using* *inheritance* recipe.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该提到，使用`_inherit`的传统继承也可以将功能复制到新模型中，尽管效率较低。这在*使用继承向模型添加功能*的菜谱中已经讨论过。
- en: Using abstract models for reusable model features
  id: totrans-442
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象模型实现可重用模型功能
- en: Sometimes, there is a particular feature that we want to be able to add to several
    different models. Repeating the same code in different files is a bad programming
    practice; it would be better to implement it once and reuse it.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望能够在几个不同的模型中添加特定的功能。在不同的文件中重复相同的代码是一种不良的编程实践；最好是实现一次并重用它。
- en: Abstract models allow us to create a generic model that implements some features
    that can then be inherited by regular models, in order to make that feature available.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象模型允许我们创建一个通用的模型，该模型实现了一些功能，然后这些功能可以被常规模型继承，以便使该功能可用。
- en: As an example, we will implement a simple archive feature. This adds the `active`
    field to the model (if it doesn’t exist already) and makes an archive method available
    to toggle the `active` flag. This works because `active` is a magic field. If
    it is present in a model by default, the records with `active=False` will be filtered
    out from the queries. We will then add it to the `hostel` `room` model.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 作为例子，我们将实现一个简单的存档功能。这将在模型中添加`active`字段（如果尚未存在）并使存档方法可用以切换`active`标志。这是因为`active`是一个魔法字段。如果它默认存在于模型中，则带有`active=False`的记录将被从查询中过滤出来。然后我们将它添加到`hostel`
    `room`模型中。
- en: Getting ready
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will continue using the `my_hostel` add-on module from the previous recipe.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续使用上一个菜谱中的`my_hostel`附加模块。
- en: How to do it...
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The archive feature certainly deserves its own add-on module, or at least its
    own Python code file. However, to keep the explanation as simple as possible,
    we will cram it into the `models/hostel_room.py` file:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 存档功能确实值得拥有自己的附加模块，或者至少是自己的Python代码文件。然而，为了使解释尽可能简单，我们将它塞入`models/hostel_room.py`文件中：
- en: 'Add the abstract model for the archive feature. It must be defined in the library
    book model, where it will be used:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加存档功能的抽象模型。它必须在库书籍模型中定义，在那里它将被使用：
- en: '[PRE44]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we will edit the Hostel Room model to inherit the archive model:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将编辑宿舍房间模型以继承存档模型：
- en: '[PRE45]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: An upgrade of the add-on module is required in order for the changes to be activated.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了激活更改，需要升级附加模块。
- en: How it works...
  id: totrans-455
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: An abstract model is created by a class based on `models.AbstractModel`, instead
    of the usual `models.Model`. It has all the attributes and capabilities of regular
    models; the difference is that ORM will not create an actual representation for
    it in the database. This means that it can’t have any data stored in it. It only
    serves as a template for a reusable feature that will be added to regular models.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象模型是通过基于`models.AbstractModel`的类创建的，而不是通常的`models.Model`。它具有常规模型的所有属性和能力；区别在于ORM不会在数据库中为它创建实际表示。这意味着它不能存储任何数据。它仅作为将添加到常规模型的可重复使用功能的模板。
- en: Our archive abstract model is quite simple. It just adds the `active` field
    and a method to toggle the value of the `active` flag, which we expect to be used
    later, via a button on the user interface. When a model class is defined with
    the `_inherit` attribute, it inherits the attribute methods of those classes,
    and the attribute methods that are defined in the current class add modifications
    to those inherited features.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的存档抽象模型相当简单。它只是添加了`active`字段和一个用于切换`active`标志值的方法，我们预计将来将通过用户界面上的按钮使用它。当一个模型类使用`_inherit`属性定义时，它将继承这些类的属性方法，而当前类中定义的属性方法将对继承的功能进行修改。
- en: The mechanism at play here is the same as that of a regular model extension
    (as per the *Adding features to a model using inheritance* recipe). You may have
    noticed that `_inherit` uses a list of model identifiers instead of a string with
    one model identifier. In fact, `_inherit` can have both forms. Using the list
    form allows us to inherit from multiple (usually `Abstract`) classes. In this
    case, we inherit just one, so a text string would be fine. A list was used instead,
    for illustration purposes.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这里所涉及的机制与常规模型扩展（如根据*使用继承向模型添加功能*的配方）相同。你可能已经注意到`_inherit`使用的是模型标识符的列表，而不是单个模型标识符的字符串。实际上，`_inherit`可以同时采用这两种形式。使用列表形式允许我们从多个（通常是`Abstract`）类中继承。在这种情况下，我们只继承了一个，所以使用文本字符串就足够了。这里使用列表是为了说明。
- en: There’s more...
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: A noteworthy built-in abstract model is `mail.thread`, which is provided by
    the `mail (Discuss)` add-on module. On models, it enables the discussion features
    that power the message wall that’s seen at the bottom of many forms.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，内置的抽象模型之一是`mail.thread`，它由`mail (Discuss)`附加模块提供。在模型上，它启用了许多表单底部看到的消息墙的讨论功能。
- en: Other than `AbstractModel`, a third model type is available – `models.TransientModel`.
    This has a database representation like `models.Model`, but the records that are
    created there are supposed to be temporary and regularly purged by a server-scheduled
    job. Other than that, transient models work just like regular models.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`AbstractModel`之外，还有一种第三种模型类型可用——`models.TransientModel`。它具有与`models.Model`类似的数据库表示，但创建在该处的记录应该是临时的，并且由服务器计划的任务定期清除。除此之外，临时模型的工作方式与常规模型相同。
- en: '`models.TransientModel` is useful for more complex user interactions, known
    as **wizards**. A wizard is used to request inputs from the user. In [*Chapter
    8*](B20997_08.xhtml#_idTextAnchor388), *Advanced Server-Side Development Techniques*,
    we will explore how to use these for advanced user interaction.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`models.TransientModel`对于更复杂的用户交互非常有用，这种交互被称为**向导**。向导用于从用户那里获取输入。在[*第8章*](B20997_08.xhtml#_idTextAnchor388)
    *高级服务器端开发技术*中，我们将探讨如何使用这些技术进行高级用户交互。'
