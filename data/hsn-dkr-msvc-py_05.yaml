- en: Build, Run, and Test Your Service Using Docker
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker构建、运行和测试您的服务
- en: Having designed a working RESTful microservice in the previous chapter, we'll
    see in this chapter how to use it in *the Docker way*, encapsulating the service
    into a self-contained container so that it's immutable and can be deployed on
    its own. This chapter describes very explicitly the dependencies of the service
    and the ways it can be used. The main way to run a service is to run it as a web
    server, but other operations are possible, such as running unit tests, generating
    reports, and others. We'll see also how to deploy the service on your local computer
    for testing and how to share it through an image repository.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中设计了一个工作的RESTful微服务，本章将介绍如何以*Docker方式*使用它，将服务封装到一个自包含的容器中，使其不可变，并且可以独立部署。本章非常明确地描述了服务的依赖关系和使用方式。运行服务的主要方式是作为Web服务器运行，但也可以进行其他操作，比如运行单元测试，生成报告等。我们还将看到如何在本地计算机上部署服务进行测试，以及如何通过镜像仓库共享服务。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Building your service with a Dockerfile
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建您的服务
- en: Operating with an immutable container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作不可变的容器
- en: Configuring your service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的服务
- en: Deploying the Docker service locally
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地部署Docker服务
- en: Pushing your Docker image to a remote registry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的Docker镜像推送到远程注册表
- en: By the end of the chapter, you'll know how to operate with Docker, create a
    basic service, build an image, and run it. You'll also know how to share the image
    to be run on another computer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，您将了解如何使用Docker操作，创建基本服务，构建镜像并运行它。您还将了解如何共享镜像以在另一台计算机上运行。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need to install Docker, version 18.09 or above. See the
    official documentation ([https://docs.docker.com/install/](https://docs.docker.com/install/))
    for how to do so for your platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要安装Docker，版本为18.09或更高版本。请参阅官方文档([https://docs.docker.com/install/](https://docs.docker.com/install/))，了解如何在您的平台上进行安装。
- en: If you install Docker in Linux, you may have to configure the server to run
    for non-root access. Check the documentation at [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Linux上安装Docker，可能需要配置服务器以允许非root访问。请查看文档：[https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/)。
- en: 'Check the version with the following command:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令检查版本：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You need to install Docker Compose version 1.24.0 or above as well. Note that,
    in some installations, such as macOS, this is automatically installed for you.
    Check the installation instructions in the Docker documentation ([https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)):'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要安装Docker Compose版本1.24.0或更高版本。请注意，在某些安装中，如macOS，这是自动为您安装的。请查看Docker文档中的安装说明：[https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is available on GitHub, in this directory: [https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter03).
    There's a copy of `ThoughtsBackend` presented in [Chapter 2](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml),
    *Creating a REST Service with Python*, but the code is slightly different. We
    will look at the differences in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以在GitHub上找到，位于此目录：[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter03](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/tree/master/Chapter03)。在[第2章](8f5b60ee-fa8e-42ff-aa6c-fb27d4bd574a.xhtml)中介绍了`ThoughtsBackend`的副本，*使用Python创建REST服务*，但代码略有不同。我们将在本章中看到这些差异。
- en: Building your service with a Dockerfile
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dockerfile构建您的服务
- en: It all starts with a container. As we said in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml),
    *Making the Move – Design, Plan, and Execute*, containers are a packetized bundle
    of software, encapsulated in a standard way. They are units of software that can
    be run independently, as they are totally self-contained. To make a container,
    we need to build it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都始于一个容器。正如我们在[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中所说的，*迁移-设计、计划和执行*，容器是一种标准化的软件包，以标准方式封装的软件包。它们是可以独立运行的软件单元，因为它们是完全自包含的。要创建一个容器，我们需要构建它。
- en: Remember our description of a container as a process surrounded by its own filesystem.
    Building a container constructs this filesystem.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们描述容器为一个被其自己的文件系统包围的进程吗？构建容器会构建这个文件系统。
- en: To build a container with Docker, we need a definition of its content. The filesystem
    is created by applying layer after layer. Each Dockerfile, the recipe for generating
    a container, contains a definition of steps to generate a container.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Docker构建容器，我们需要定义其内容。文件系统是通过逐层应用来创建的。每个Dockerfile，即生成容器的配方，都包含了生成容器的步骤的定义。
- en: 'For example, let''s create a very simple Dockerfile. Create a file called `example.txt`
    with some example text and another called `Dockerfile.simple` with the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个非常简单的Dockerfile。创建一个名为`example.txt`的文件，其中包含一些示例文本，另一个名为`Dockerfile.simple`，内容如下：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now build it using the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用以下命令构建它：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This creates a Docker image that only contains the `example.txt` file. It's
    not very useful, but quite small—only 11 bytes. That's because it inherits from
    the empty container, `scratch`. It then copies the `example.txt` file inside the
    location in the `/example.txt` container.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个只包含`example.txt`文件的Docker镜像。这并不是很有用，但非常小-只有11个字节。这是因为它继承自空容器`scratch`，然后将`example.txt`文件复制到容器中的`/example.txt`位置。
- en: Let's take a look at the `docker build` command. The Dockerfile is defined with
    the `-f` parameter, the tag of the resulting image is defined with `--tag `, and
    the `context` parameter is defined as dot (`.`). The `context` parameter is the
    reference to where to look for the files defined in the steps in the Dockerfile.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`docker build`命令。使用`-f`参数定义Dockerfile，使用`--tag`定义结果镜像的标签，使用`context`参数定义为点（`.`）。`context`参数是指在Dockerfile中的步骤中查找文件的引用。
- en: The image also has the image ID `f961aef9f15c`, which is assigned automatically.
    This is a hash of the contents of the filesystem. We'll see later why this is
    relevant.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像还具有自动分配的镜像ID`f961aef9f15c`。这是文件系统内容的哈希值。稍后我们将看到这为什么是相关的。
- en: Executing commands
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行命令
- en: The previous container was not very exciting. It is definitively possible to
    create your own container totally from scratch, but, typically, you'll look for
    a baseline that contains some sort of Linux distribution that allows you to do
    something useful with the container.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的容器并不是很令人兴奋。完全可以从头开始创建自己的容器，但通常情况下，您会寻找一个包含某种Linux发行版的基线，以便您可以在容器中执行一些有用的操作。
- en: As we saw with the `FROM` command, we can start with a previous container. We
    will use the Alpine Linux ([https://alpinelinux.org/](https://alpinelinux.org/))
    distribution throughout the book, though other distributions are available, such
    as Ubuntu and CentOS. Check out the article at [https://sweetcode.io/linux-distributions-optimized-hosting-docker/](https://sweetcode.io/linux-distributions-optimized-hosting-docker/) for
    distributions aimed at Docker containers.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在`FROM`命令中看到的，我们可以从以前的容器开始。我们将在整本书中使用Alpine Linux（[https://alpinelinux.org/](https://alpinelinux.org/)）发行版，尽管还有其他发行版可用，如Ubuntu和CentOS。查看这篇文章[https://sweetcode.io/linux-distributions-optimized-hosting-docker/](https://sweetcode.io/linux-distributions-optimized-hosting-docker/)，了解针对Docker容器的发行版。
- en: Why Alpine Linux? It is arguably the most popular distribution for Docker systems
    because it has a very small footprint and it's aimed at security. It is well-maintained
    and regularly updated and patched. It also has a complete package management system
    that allows you to install most of the common tools for web services easily. The
    base image is only around 5 MB in size and contains a working Linux operating
    system.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么选择Alpine Linux？它可以说是Docker系统中最受欢迎的发行版，因为它的占用空间非常小，旨在提高安全性。它得到了很好的维护，并定期更新和修补。它还具有完整的软件包管理系统，可以轻松安装大多数常见的Web服务工具。基础镜像的大小只有大约5MB，并包含一个可用的Linux操作系统。
- en: It has a couple of quirks when working with it, such as using its own package
    management, called `apk`, but it's easy to use and is almost a straight-on drop
    replacement for common Linux distributions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用时，它有一些怪癖，比如使用自己的包管理，称为`apk`，但它很容易使用，几乎可以直接替代常见的Linux发行版。
- en: 'The following Dockerfile will inherit from the base `alpine` container and
    add the `example.txt` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Dockerfile将继承自基础`alpine`容器，并添加`example.txt`文件：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This container allows us to run commands, as the usual command-line utilities
    are included:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器允许我们运行命令，因为通常的命令行实用程序都包括在内：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Note how the `cat /opt/example.txt` command line gets executed. This is actually
    happening inside the container. We print the result in `stdout` in our `stdout` console.
    However, if there''s a file created, as the container stops, the file is not saved
    in our local filesystem, but only inside container:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`cat /opt/example.txt`命令行的执行。这实际上是在容器内部发生的。我们在`stdout`控制台中打印结果。但是，如果有文件被创建，当容器停止时，该文件不会保存在我们的本地文件系统中，而只保存在容器内部：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The file is actually saved in a stopped container. Once the container has finished
    its run, it remains stopped by Docker until removed. You can see the stopped container
    with the `docker ps -a` command. A stopped container is not very interesting,
    though its filesystem is saved on disk.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 文件实际上是保存在一个已停止的容器中。一旦容器完成运行，它将被Docker保持停止状态，直到被移除。您可以使用`docker ps -a`命令查看已停止的容器。尽管已停止的容器并不是很有趣，但它的文件系统已保存在磁盘上。
- en: When running web services, the command being run won't stop; it will keep running
    until stopped. Remember what we said before about a container being a process
    with a filesystem attached. The command running is the key to the container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行Web服务时，正在运行的命令不会停止；它将一直运行，直到停止。记住我们之前说过的，容器是一个附加了文件系统的进程。正在运行的命令是容器的关键。
- en: 'You can add a default command, which will be executed when no command is given,
    by adding the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过添加以下内容来添加默认命令，当没有给出命令时将执行该命令：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Make it run automatically by using the following command:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令使其自动运行：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Defining a standard command makes the container really simple. Just run it and
    it will do whatever it is configured to do. Remember to include a default command
    in your containers.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 定义标准命令使容器变得非常简单。只需运行它，它将执行其配置的任何操作。记得在您的容器中包含一个默认命令。
- en: 'We can also execute a shell in the container and interact with it. Remember
    to add the `-it` flag to keep the connection properly open, `-i` to keep `stdin`
    open, and `-t` to create a pseudo Terminal, you can remember it as interactive
    Terminal:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在容器中执行shell并与其交互。记得添加`-it`标志以保持连接正常打开，`-i`保持`stdin`打开，`-t`创建伪终端，您可以将其记住为交互式终端：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is very useful when finding out problems or performing exploratory tests.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在发现问题或执行探索性测试时非常有用。
- en: Understanding the Docker cache
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Docker缓存
- en: One of the main points of confusion when building images is understanding how
    the Docker layers work.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 构建镜像时，构建图层的工作原理是构建镜像时的一个主要困惑点。
- en: 'Each of the commands on a Dockerfile is executed consecutively and on top of
    the previous layer. If you are comfortable with Git, you''ll notice that the process
    is similar. Each layer only stores the changes to the previous step:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile上的每个命令都是按顺序执行的，并在前一个图层的基础上执行。如果您熟悉Git，您会注意到这个过程是类似的。每个图层只存储对上一步的更改：
- en: '![](img/14605f6c-28fa-4b09-be18-960f278ac5f0.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](img/14605f6c-28fa-4b09-be18-960f278ac5f0.png)'
- en: This allows Docker to cache quite aggressively, as any layer before a change
    is already calculated. For example, in this example, we update the available packages
    with `apk update`, then install the `python3` package, before copying the `example.txt`
    file. Any changes to the `example.txt` file will only execute the last two steps
    over layer `be086a75fe23`. This speeds up the rebuilding of images.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得Docker可以进行非常积极的缓存，因为任何更改之前的层已经计算过了。例如，在这个例子中，我们使用`apk update`更新可用的软件包，然后安装`python3`软件包，然后复制`example.txt`文件。对`example.txt`文件的任何更改只会在层`be086a75fe23`上执行最后两个步骤。这加快了镜像的重建速度。
- en: It also means that you need to construct your Dockerfiles carefully to not invalidate
    the cache. Start with the operations that change very rarely, such as installing
    the project dependencies, and finish with the ones that change more often, such
    as adding your code. The annotated Dockerfile for our example has indications
    about the usage of the cache.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着您需要仔细构建您的Dockerfile，以免使缓存无效。从很少更改的操作开始，比如安装项目依赖，然后进行更频繁更改的操作，比如添加您的代码。我们的示例的带注释的Dockerfile有关于缓存使用的指示。
- en: This also means that an image will never get smaller in size, adding a new layer
    even if the layer removes data, as the previous layer is still stored on the disk.
    If you want to remove cruft from a step, you'll need to do so in the same step.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，即使层删除了数据，图像的大小也永远不会变小，因为前一个层仍然存储在磁盘上。如果要从一个步骤中删除不需要的数据，需要在同一个步骤中进行。
- en: Keeping your containers small is quite important. In any Docker system, the
    tendency is to have a bunch of containers and lots of images. Big images for no
    reason will fill up repositories quickly. They'll be slow to download and push,
    and also slow to start, as the container is copied around in your infrastructure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 保持容器的小是非常重要的。在任何Docker系统中，倾向于有大量的容器和大量的镜像。没有理由的大图像会很快填满仓库。它们下载和推送都会很慢，并且在您的基础设施中复制容器时也会很慢。
- en: There's another practical consideration. Containers are a great tool to simplify
    and reduce your service to the minimum. With a bit of investment, you'll have
    great results and keep small and to-the-point containers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有另一个实际的考虑。容器是简化和减少服务到最低程度的好工具。通过一点投资，您将获得很好的结果，并保持小而简洁的容器。
- en: There are several practices for keeping your images small. Other than being
    careful to not install extra elements, the main ones are creating a single, complicated
    layer that installs and uninstalls, and multi-stage images. Multi-stage Dockerfiles
    are a way of referring to a previous intermediate layer and copying data from
    there. Check the Docker documentation ([https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种保持图像小的做法。除了小心不安装额外的元素之外，主要的做法是创建一个单一的、复杂的层，安装和卸载，以及多阶段图像。多阶段Dockerfile是一种引用先前中间层并从中复制数据的方式。查看Docker文档（[https://docs.docker.com/develop/develop-images/multistage-build/](https://docs.docker.com/develop/develop-images/multistage-build/)）。
- en: Compilers, in particular, tend to get a lot of space. When possible, try to
    use precompiled binaries. You can use a multi-stage Dockerfile to compile in one
    container and then copy the binaries to the running one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器，特别是倾向于占用大量空间。如果可能的话，尽量使用预编译的二进制文件。您可以使用多阶段Dockerfile在一个容器中进行编译，然后将二进制文件复制到正在运行的容器中。
- en: 'You can learn more about the differences between the two strategies in this
    article: [https://pythonspeed.com/articles/smaller-python-docker-images/](https://pythonspeed.com/articles/smaller-python-docker-images/).'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这篇文章中了解两种策略之间的区别：[https://pythonspeed.com/articles/smaller-python-docker-images/](https://pythonspeed.com/articles/smaller-python-docker-images/)。
- en: A good tool to analyze a particular image and the layers that compose it is
    `dive` ([https://github.com/wagoodman/dive](https://github.com/wagoodman/dive)).
    It will also discover ways that an image can be reduced in size.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 分析特定图像及其组成层的好工具是`dive`（[https://github.com/wagoodman/dive](https://github.com/wagoodman/dive)）。它还会发现图像可以缩小的方法。
- en: We'll create a multi-stage container in the next step.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一步创建一个多阶段容器。
- en: Building a web service container
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建web服务容器
- en: 'We have a specific objective, to create a container that is capable of running
    our microservice, `ThoughtsBackend`. To do so, we have a couple of requirements:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个具体的目标，那就是创建一个能够运行我们的微服务`ThoughtsBackend`的容器。为此，我们有一些要求：
- en: We need to copy our code to the container.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将我们的代码复制到容器中。
- en: The code needs to be served through a web server.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码需要通过web服务器提供。
- en: So, in broad strokes, we need to create a container with a web server, add our
    code, configure it so it runs our code, and serve the result when starting the
    container.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，大致上，我们需要创建一个带有web服务器的容器，添加我们的代码，配置它以运行我们的代码，并在启动容器时提供结果。
- en: We will store most of the configuration files inside subdirectories in the `./docker`
    directory.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把大部分配置文件存储在`./docker`目录的子目录中。
- en: As a web server, we will use uWSGI ([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)).
    uWSGI is a web server capable of serving our Flask application through the WSGI
    protocol. uWSGI is quite configurable, has a lot of options, and is capable of
    serving HTTP directly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个web服务器，我们将使用uWSGI（[https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)）。uWSGI是一个能够通过WSGI协议为我们的Flask应用提供服务的web服务器。uWSGI非常灵活，有很多选项，并且能够直接提供HTTP服务。
- en: A very common configuration is to have NGINX in front of uWSGI to serve static
    files, as it's more efficient for that. In our specific use case, we don't serve
    many static files, as we're running a RESTful API, and, in our main architecture,
    as described in [Chapter 1](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml), *Making
    the Move – Design, Plan, and Execute*, there's already a load balancer on the
    frontend and a dedicated static files server. This means we won't be adding an
    extra component for simplicity. NGINX usually communicates to uWSGI using the
    `uwsgi` protocol, which is a protocol specifically for the uWSGI server, but it
    can also do it through HTTP. Check the NGINX and uWSGI documentation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常见的配置是在uWSGI前面放置NGINX来提供静态文件，因为对于这一点来说更有效率。在我们特定的用例中，我们不提供太多静态文件，因为我们正在运行一个RESTful
    API，并且在我们的主要架构中，如[第1章](ddb0a00a-6c5b-4ffe-b403-0f5f9f7a7df2.xhtml)中所述，*进行移动-设计，计划和执行*，前端已经有一个负载均衡器和一个专用的静态文件服务器。这意味着我们不会为了简单起见添加额外的组件。NGINX通常使用`uwsgi`协议与uWSGI通信，这是专门为uWSGI服务器设计的协议，但也可以通过HTTP进行通信。请查看NGINX和uWSGI文档。
- en: 'Let''s take a look at the `docker/app/Dockerfile` file. It has two stages;
    the first one is to compile the dependencies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`docker/app/Dockerfile`文件。它有两个阶段；第一个是编译依赖项：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This stage does the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个阶段执行以下步骤：
- en: Names the stage `compile-image`, inheriting from Alpine.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将阶段命名为`compile-image`，继承自Alpine。
- en: Installs `python3`.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`python3`。
- en: Installs the build dependencies, including the `gcc` compiler and Python headers
    (`python3-dev`).
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装构建依赖项，包括`gcc`编译器和Python头文件（`python3-dev`）。
- en: Creates a new virtual environment. We will install all the Python dependencies
    here.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的虚拟环境。我们将在这里安装所有的Python依赖项。
- en: The virtual environment gets activated.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 激活虚拟环境。
- en: Installs uWSGI. This step compiles it from code.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装uWSGI。这一步从代码中编译它。
- en: You can also install the included uWSGI package in the Alpine distribution,
    but I found the compiled package to be more complete and easier to configure,
    as the Alpine `uwsgi` package requires you to install other packages such as `uwsgi-python3`,
    `uwsgi-http`, and so on, then enable the plugin in the uWSGI config. The size
    difference is minimal. This also allows you to use the latest uWSGI version and
    not depend on the one in your Alpine distribution.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在Alpine发行版中安装包含的uWSGI包，但我发现编译的包更完整，更容易配置，因为Alpine的`uwsgi`包需要您安装其他包，如`uwsgi-python3`，`uwsgi-http`等，然后在uWSGI配置中启用插件。大小差异很小。这还允许您使用最新的uWSGI版本，而不依赖于Alpine发行版中的版本。
- en: Copy the `requirements.txt` file and install all the dependencies. This will
    compile and copy the dependencies to the virtual environment.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制`requirements.txt`文件并安装所有依赖项。这将编译并复制依赖项到虚拟环境中。
- en: 'The second stage is preparing the running container. Let''s take a look:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是准备运行容器。让我们来看一下：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'It carries out the following actions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下操作：
- en: Labels the image as `runtime-image` and inherits from Alpine, as previously.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将镜像标记为`runtime-image`，并像之前一样继承自Alpine。
- en: Installs Python and other requirements for the runtime.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装Python和运行时的其他要求。
- en: Note that any runtime required for compilation needs to be installed. For example,
    we install `libffi` in the runtime and `libffi-dev` to compile, required by the
    `cryptography` package. A mismatch will raise a runtime error when trying to access
    the (non-present) libraries. The `dev` libraries normally contain the runtime
    libraries.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，需要安装用于编译的任何运行时。例如，我们在运行时安装了`libffi`和`libffi-dev`来编译，这是`cryptography`包所需的。如果不匹配，尝试访问（不存在的）库时会引发运行时错误。`dev`库通常包含运行时库。
- en: Copy the uWSGI configuration and script to start the service. We'll take a look
    at that in a moment.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制uWSGI配置和启动服务的脚本。我们稍后会看一下。
- en: Create a user to run the service, and set it as the default using the `USER`
    command.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用户来运行服务，并使用`USER`命令将其设置为默认用户。
- en: This step is not strictly necessary as, by default, the root user will be used.
    As our containers are isolated, gaining root access in one is inherently more
    secure than in a real server. In any case, it's good practice to not configure
    our public-facing service accessing as root and it will remove some understandable
    warnings.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步并不是严格必要的，因为默认情况下会使用root用户。由于我们的容器是隔离的，在其中获得root访问权限比在真实服务器中更安全。无论如何，最好的做法是不要将我们的面向公众的服务配置为root用户，并且这样做会消除一些可以理解的警告。
- en: Copy the virtual environment from the `compile-image` image. This installs all
    the compiled Python packages. Note that they are copied with the user to run the
    service, to have access to them. The virtual environment is activated.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`compile-image`镜像中复制虚拟环境。这将安装所有编译的Python包。请注意，它们是与运行服务的用户一起复制的，以便访问它们。虚拟环境已激活。
- en: Copy the application code.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制应用程序代码。
- en: Define the run parameters. Note that port `8000` is exposed. This will be the
    port we will serve the application on.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义运行参数。请注意，端口`8000`已暴露。这将是我们将在其上提供应用程序的端口。
- en: If running as root, port `80` can be defined. Routing a port in Docker is trivial,
    though, and other than the front-facing load balancer, there's not really any
    reason why you need to use the default HTTP port. Use the same one in all your
    systems, though, which will remove uncertainty.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以root身份运行，可以定义端口`80`。在Docker中路由端口是微不足道的，除了前端负载均衡器之外，没有真正需要使用默认的HTTP端口的理由。不过，可以在所有系统中使用相同的端口，这样可以消除不确定性。
- en: Note that the application code is copied at the end of the file. The application
    code is likely going to be the code that changes most often, so this structure
    takes advantage of the Docker cache and recreates only the very few last layers,
    instead of having to start from the beginning. Take this into account when designing
    your Dockerfiles.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，应用程序代码是在文件末尾复制的。应用程序代码可能是最经常更改的代码，因此这种结构利用了Docker缓存，并且只重新创建了最后的几个层，而不是从头开始。在设计Dockerfile时，请考虑这一点。
- en: Also, keep in mind that there's nothing stopping you from changing the order
    while developing. If you're trying to find a problem with a dependency, and so
    on, you can comment out irrelevant layers or add steps later once the code is
    stable.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请记住，在开发过程中没有什么能阻止您改变顺序。如果您试图找到依赖关系的问题等，您可以注释掉不相关的层，或者在代码稳定后添加后续步骤。
- en: 'Let''s build our container now. See that there are two images created, though
    only one is named. The other is the compile image, which is much bigger as it
    contains the compilers, and so on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建我们的容器。请注意，已创建了两个镜像，尽管只有一个被命名。另一个是编译镜像，它更大，因为它包含了编译器等。
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can run the container. To be able to access the internal port `8000`,
    we need to route it with the `-p` option:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行容器了。为了能够访问内部端口`8000`，我们需要使用`-p`选项进行路由：
- en: '[PRE13]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Accessing our local browser to `127.0.0.1` shows our application. You can see
    the access logs in the standard output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 访问我们的本地浏览器`127.0.0.1`会显示我们的应用程序。您可以在标准输出中看到访问日志：
- en: '![](img/b89b7dd6-5676-4799-8613-bc8cf531e29a.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b89b7dd6-5676-4799-8613-bc8cf531e29a.png)'
- en: 'You can access a running container from a different Terminal with `docker exec`
    and execute a new shell. Remember to add `-it` to keep the Terminal open. Inspect
    the currently running containers with `docker ps` to find the container ID:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`docker exec`从不同的终端访问正在运行的容器，并执行一个新的shell。记得添加`-it`以保持终端开启。使用`docker ps`检查当前正在运行的容器以找到容器ID：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You can stop the container with *Ctrl* + *C*, or, more gracefully, stop it
    from another Terminal:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用*Ctrl* + *C*停止容器，或者更优雅地，从另一个终端停止它：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The logs will show `graceful stop`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 日志将显示`graceful stop`：
- en: '[PRE16]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Capturing `SIGTERM` properly and stopping our services gracefully is important
    for avoiding abrupt terminations of services. We'll see how to configure this
    in uWSGI, as well as the rest of the elements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正确捕获`SIGTERM`并优雅地停止我们的服务对于避免服务突然终止很重要。我们将看到如何在uWSGI中配置这一点，以及其他元素。
- en: Configuring uWSGI
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置uWSGI
- en: 'The `uwsgi.ini` file contains the uWSGI configuration:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`uwsgi.ini`文件包含了uWSGI的配置：'
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Most of it is information that we have from the Dockerfile, though it needs
    to match so that uWSGI knows where to find the application code, the name of the
    WSGI file to start, the user to start it from, and so on.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大部分信息都是我们从Dockerfile中获取的，尽管它需要匹配，以便uWSGI知道在哪里找到应用程序代码、启动WSGI文件的名称、以及从哪个用户开始等。
- en: 'Other parameters are specific to uWSGI behavior:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数是特定于uWSGI行为的：
- en: '`master`: Creates a master process that controls the others. Recommended for
    uWSGI operation as it creates smoother operation.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master`：创建一个控制其他进程的主进程。作为uWSGI操作的推荐选项，因为它创建了更平稳的操作。'
- en: '`http`: Serves in the specified port. The HTTP mode creates a process that
    load balances the HTTP requests toward the workers, and it''s recommended to serve
    HTTP outside of the container.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http`：在指定端口提供服务。HTTP模式创建一个进程，负载均衡HTTP请求到工作进程，并建议在容器外提供HTTP服务。'
- en: '`processes`: The number of application workers. Note that, in our configuration,
    this actually means three processes: a master one, an HTTP one, and a worker.
    More workers can handle more requests but will use more memory. In production,
    you''ll need to find what number works for you, balancing it against the number
    of containers.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`processes`：应用程序工作进程的数量。请注意，在我们的配置中，这实际上意味着三个进程：一个主进程，一个HTTP进程和一个工作进程。更多的工作进程可以处理更多的请求，但会使用更多的内存。在生产中，您需要找到适合您的数量，将其与容器的数量平衡。'
- en: '`max-requests`: After a worker handles this number of requests, recycle the
    worker (stop it and start a new one). This reduces the probability of memory leaks.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max-requests`：在工作进程处理此数量的请求后，回收工作进程（停止并启动新的）。这减少了内存泄漏的可能性。'
- en: '`vacuum`: Clean the environment when exiting.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`vacuum`：在退出时清理环境。'
- en: '`master-fifo`: Create a Unix pipe to send commands to uWSGI. We will use this
    to handle graceful stops.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`master-fifo`：创建一个Unix管道以向uWSGI发送命令。我们将使用这个来处理优雅的停止。'
- en: The uWSGI documentation ([https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/))
    is quite extensive and comprehensive. It contains a lot of valuable information,
    both for operating uWSGI itself and understanding details about how web servers
    operate. I learn something new each time that I read it, but it can be a bit overwhelming
    at first.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: uWSGI文档（[https://uwsgi-docs.readthedocs.io/en/latest/](https://uwsgi-docs.readthedocs.io/en/latest/)）非常全面和详尽。它包含了很多有价值的信息，既可以操作uWSGI本身，也可以理解关于Web服务器操作的细节。我每次阅读它时都会学到一些新东西，但一开始可能会有点压倒性。
- en: It's worth investing a bit of time in running tests to discover what are the
    best parameters for your service in areas such as timeouts, the number of workers,
    and so on. However, remember that some of the options for uWSGI may be better
    served with your container's configuration, which simplifies things.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 值得投入一些时间来运行测试，以发现您的服务在超时、工作进程数量等方面的最佳参数是什么。但是，请记住，uWSGI的一些选项可能更适合您的容器配置，这简化了事情。
- en: 'To allow graceful stops, we wrap the execution of uWSGI in our `start_server.sh` script:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许优雅的停止，我们将uWSGI的执行包装在我们的`start_server.sh`脚本中：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The core of the script is the call to `uwsgi` to start the service. It will
    then wait until it stops.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本的核心是调用`uwsgi`来启动服务。然后它会等待直到服务停止。
- en: The `SIGTERM` signal will be captured and uWSGI will be stopped gracefully by
    sending the `q` command to the `master-fifo` pipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`SIGTERM`信号将被捕获，并通过向`master-fifo`管道发送`q`命令来优雅地停止uWSGI。'
- en: A graceful stop means that a request won't be interrupted when a new container
    version is available. We'll see later how to make rollout deployments, but one
    of the key elements is to interrupt existing servers when they are not serving
    requests, to avoid stopping in the middle of a request and leaving an inconsistent
    state.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 优雅的停止意味着当有新的容器版本可用时，请求不会被中断。我们稍后会看到如何进行滚动部署，但其中一个关键元素是在现有服务器不提供请求时中断它们，以避免在请求中间停止并留下不一致的状态。
- en: Docker uses the `SIGTERM` signal to stop the execution of containers. After
    a timeout, it will kill them with `SIGKILL`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用`SIGTERM`信号来停止容器的执行。超时后，它将使用`SIGKILL`来杀死它们。
- en: Refreshing Docker commands
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新Docker命令
- en: 'We''ve looked at some of the important Docker commands:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了一些重要的Docker命令：
- en: '`docker build`: Builds an image'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker build`：构建镜像'
- en: '`docker run`: Runs an image'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker run`：运行镜像'
- en: '`docker exec`: Executes a command in a running container'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker exec`：在运行的容器中执行命令'
- en: '`docker ps`: Shows the currently running containers'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker ps`：显示当前正在运行的容器'
- en: '`docker images`: Displays the existing images'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker images`：显示现有的镜像'
- en: While these are the basic ones, knowing most of the available Docker commands
    is very useful for debugging problems and to perform operations such as monitoring,
    copying and tagging images, creating networks, and so on. These commands will
    also show you a lot about how Docker works internally.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是基本命令，但了解大多数可用的Docker命令对于调试问题和执行操作（如监视、复制和标记镜像、创建网络等）非常有用。这些命令还会向您展示Docker内部工作的很多内容。
- en: 'An important command: be sure to clean up old containers and images with `docker
    system prune` from time to time. Docker is quite space-intensive after working
    with it for a few weeks.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的命令：一定要定期使用`docker system prune`清理旧的容器和镜像。在使用几周后，Docker占用的空间相当大。
- en: The Docker documentation ([https://docs.docker.com/v17.12/engine/reference/commandline/docker/](https://docs.docker.com/v17.12/engine/reference/commandline/docker/))
    is quite complete. Be sure to know your way around it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Docker文档（[https://docs.docker.com/v17.12/engine/reference/commandline/docker/](https://docs.docker.com/v17.12/engine/reference/commandline/docker/)）非常完整。一定要熟悉它。
- en: Operating with an immutable container
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不可变容器进行操作
- en: Docker commands such as the ones seen earlier in this chapter are the foundation,
    where it all starts. But, when dealing with more than one, it starts getting complicated
    to handle them. You've seen that some commands can get quite long.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 像本章前面看到的Docker命令一样，这些命令是一切的基础。但是，当处理多个命令时，开始变得复杂。您已经看到一些命令可能会变得相当长。
- en: To operate with a container in a clustered operation, we will use `docker-compose`.
    This is Docker's own orchestration tool for defining multi-container operations.
    It gets defined by a YAML file with all the different tasks and services, each
    with enough context to build and run it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要在集群操作中操作容器，我们将使用`docker-compose`。这是Docker自己的编排工具，用于定义多容器操作。它通过一个YAML文件定义所有不同的任务和服务，每个都有足够的上下文来构建和运行它。
- en: It allows you to store the different services and parameters for each of them in
    this configuration file, called `docker-compose.yaml` by default. This allows
    you to coordinate them and generate a replicable cluster of services.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 它允许您在默认情况下的配置文件`docker-compose.yaml`中存储不同服务和每个服务的参数。这允许您协调它们并生成可复制的服务集群。
- en: Testing the container
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试容器
- en: We will start by creating a service to run the unit tests. Keep in mind that
    the tests need to run *inside* the container. This will standardize the execution
    of them and ensure that the dependencies are constant.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个服务来运行单元测试。请记住，测试需要在容器内部运行。这将标准化它们的执行并确保依赖关系是恒定的。
- en: Note that, in the creation of our container, we include all the requirements
    to execute the tests. There's the option to create the running container and inherit
    from it to add the tests and test dependencies.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在创建容器时，我们包括执行测试所需的所有要求。有选项创建运行容器并从中继承以添加测试和测试依赖项。
- en: This certainly creates a smaller running container but creates a situation where
    the testing container is not 100% exactly the same as the one in production. If
    the size is critical and there's a big difference, this may be an option, but
    be aware of the differentiation if there's a subtle bug.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实创建了一个较小的运行容器，但也创建了一个情况，即测试容器与生产中的容器并不完全相同。如果大小很重要并且存在很大差异，这可能是一个选择，但要注意如果存在细微错误。
- en: 'We need to define a service in the `docker-compose.yaml` file, in this way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`docker-compose.yaml`文件中定义一个服务，如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This section defines a service called `test-sqlite`. The build defines the Dockerfile
    to use and the context, in the same way as we'd do with a `docker build` command.
    `docker-compose` automatically sets the name.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分定义了一个名为`test-sqlite`的服务。构建定义了要使用的Dockerfile和上下文，方式与`docker build`命令相同。`docker-compose`会自动设置名称。
- en: 'We can build the container with the following command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令构建容器：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`entrypoint` specifies the command to run, in this case, running the tests
    through the `pytest` command.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`entrypoint`指定要运行的命令，在本例中通过`pytest`命令运行测试。'
- en: There are some differences between the command and the `entrypoint`, which both
    execute a command. The most relevant ones are that `command` is easier to overwrite
    and `entrypoint` appends any extra arguments at the end.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和`entrypoint`之间有一些差异，它们都执行命令。最重要的差异是`command`更容易被覆盖，而`entrypoint`会在最后附加任何额外的参数。
- en: 'To run the container, call the `run` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行容器，请调用`run`命令：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can append `pytest` arguments that will be passed over to the internal
    `entrypoint`. For example, to run tests that match the *validation* string, run
    the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以附加要传递给内部`entrypoint`的`pytest`参数。例如，要运行与*validation*字符串匹配的测试，请运行以下命令：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There are two extra details: the current code is mounted through a volume and
    overwrites the code in the container. See how the current code in `./ThoughtsBackend`
    is mounted in the position of the code in the container, `/opt/code`. This is
    very handy for the development, as it will avoid having to rebuild the container
    each time a change is made.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 还有两个额外的细节：当前代码通过卷挂载，并覆盖容器中的代码。看看如何将`./ThoughtsBackend`中的当前代码挂载到容器中的代码位置`/opt/code`。这对开发非常方便，因为它将避免每次更改时都需要重新构建容器。
- en: This also means that any write in the mounted directory hierarchy will be saved
    in your local filesystem. For example, the `./ThoughtsBackend/db.sqlite3` database
    file allows you to use it for testing. It will also store generated `pyc` files.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着在挂载目录层次结构中的任何写入都将保存在您的本地文件系统中。例如，`./ThoughtsBackend/db.sqlite3`数据库文件允许您用于测试。它还将存储生成的`pyc`文件。
- en: The generation of the `db.sqlite3` file can create permission problems in some
    operating systems. If that's the case, delete it to be regenerated and/or allow
    it to read and write to all users with `chmod 666 ./ThoughtsBackend/db.sqlite3`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`db.sqlite3`文件的生成可能会在某些操作系统中创建权限问题。如果是这种情况，请删除它以重新生成和/或允许所有用户读写`chmod 666 ./ThoughtsBackend/db.sqlite3`。'
- en: That's why we use the `environment` option to pass a `PYTHONDONTWRITEBYTECODE=1`
    environment variable. This stops Python from creating `pyc` files.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们使用`environment`选项传递一个`PYTHONDONTWRITEBYTECODE=1`环境变量。这可以阻止Python创建`pyc`文件。
- en: While SQLite is good for testing, we need to create a better structure reflective
    of the deployment and to configure the access to the database to be able to deploy
    the server.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite适用于测试，但我们需要创建一个更好的反映部署的结构，并配置对数据库的访问以能够部署服务器。
- en: Creating a PostgreSQL database container
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个PostgreSQL数据库容器
- en: We need to test our code against a PostgreSQL database. This is the database
    that we will be deploying the code in production against.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要针对PostgreSQL数据库测试我们的代码。这是我们将在生产中部署代码的数据库。
- en: While the abstraction layer in SQLAlchemy aims to reduce the differences, there
    are some differences in the behavior of the databases.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLAlchemy中的抽象层旨在减少差异，但数据库的行为仍然存在一些差异。
- en: 'For example, in `/thoughts_backend/api_namespace.py`, the following line is
    case-insensitive, which is the behavior that we want:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`/thoughts_backend/api_namespace.py`中，以下行是不区分大小写的，这是我们想要的行为：
- en: '[PRE23]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Translating that to PostgreSQL, it is case-sensitive, which requires you to
    check it. This would be a bug in production if testing with SQLite and running
    in PostgreSQL.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将其翻译成PostgreSQL，它是区分大小写的，这需要你进行检查。如果在SQLite中进行测试并在PostgreSQL中运行，这将是一个生产中的错误。
- en: 'The replaced code, using `ilike` for the expected behavior, is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ilike`替换的代码，以获得预期的行为，如下所示：
- en: '`param = f''%{search_param}%''`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`param = f''%{search_param}%''`'
- en: '`query = (query.filter(ThoughtModel.text.ilike(param)))`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`query = (query.filter(ThoughtModel.text.ilike(param)))`'
- en: We kept the old code in a comment to show this issue.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将旧代码保留在注释中以显示这个问题。
- en: 'To create a database container, we need to define the corresponding Dockerfile.
    We store all the files in the `docker/db/` subdirectory. Let''s take a look at
    Dockerfile and its different parts. The whole file can be found on GitHub ([https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter03/docker/db/Dockerfile](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter03/docker/db/Dockerfile)).
    This Dockerfile can be divided into the following stages:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个数据库容器，我们需要定义相应的Dockerfile。我们将所有文件存储在`docker/db/`子目录中。让我们来看看Dockerfile及其不同的部分。整个文件可以在GitHub上找到（[https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter03/docker/db/Dockerfile](https://github.com/PacktPublishing/Hands-On-Docker-for-Microservices-with-Python/blob/master/Chapter03/docker/db/Dockerfile)）。
- en: Using the `ARG` keyword, define the basic PostgreSQL configuration such as the
    name of the database, user, and password. They get set in environment variables
    so that the PostgreSQL commands can use them.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ARG`关键字，定义基本的PostgreSQL配置，如数据库名称、用户和密码。它们被设置为环境变量，以便PostgreSQL命令可以使用它们。
- en: These commands are for local development only. They'll need to match with the
    environment set up. The `ARG` keyword defines a parameter for Dockerfile at build
    time. We'll see how they are set up as input parameters in the `docker-compose.yaml`
    file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些命令仅用于本地开发。它们需要与环境设置匹配。`ARG`关键字在构建时为Dockerfile定义了一个参数。我们将看到它们如何在`docker-compose.yaml`文件中设置为输入参数。
- en: 'The `ARG` elements are also defined as `ENV` variables, so we keep them defined
    as environment variables:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG`元素也被定义为`ENV`变量，因此我们将它们定义为环境变量：'
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Install the `postgresql` package and all its dependencies, such as Python 3
    and its compilers. We will need them to be able to run the application code:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`postgresql`包及其所有依赖项，如Python 3及其编译器。我们需要它们来运行应用程序代码：
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Install and run the `postgres-setup.sh` script:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装并运行`postgres-setup.sh`脚本：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This initializes the database, setting the correct user, password, and so on.
    Note that this doesn't create the specific tables for our application yet.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这初始化了数据库，设置了正确的用户、密码等。请注意，这并没有为我们的应用程序创建特定的表。
- en: As part of our initialization, we create the data files inside the container.
    This means that the data won't persist after the container stops. This is a good
    thing for testing, but, if you want to access the data for debug purposes, remember
    to keep the container up.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们初始化的一部分，我们在容器内创建数据文件。这意味着数据在容器停止后不会持久保存。这对于测试来说是件好事，但是如果你想要访问数据进行调试，请记住保持容器运行。
- en: 'Install the requirements for our application and specific commands to run in
    the database container:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装我们应用程序的要求和在数据库容器中运行的特定命令：
- en: '[PRE27]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Copy the application code and database commands stored in `docker/db`. Run
    the `prepare_db.sh` script, which creates the application database structure.
    In our case, it sets up the `thoughts` table:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制存储在`docker/db`中的应用程序代码和数据库命令。运行`prepare_db.sh`脚本，该脚本创建应用程序数据库结构。在我们的情况下，它设置了`thoughts`表：
- en: '[PRE28]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This script first starts the PostgreSQL database running in the background,
    then calls `init_db.py`, and then gracefully stops the database.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本首先在后台启动运行PostgreSQL数据库，然后调用`init_db.py`，最后优雅地停止数据库。
- en: Keep in mind that, in each of the steps of Dockerfile, in order to access the
    database, it needs to be running, but it will also be stopped at the end of each
    step. In order to avoid corruption of the data or the abrupt killing of the process,
    be sure to use the `stop_postgres.sh` script until the end. Though PostgreSQL
    will normally recover for an abruptly stopped database, it will slow the startup
    time.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在Dockerfile的每个步骤中，为了访问数据库，它需要在运行，但也会在每个步骤结束时停止。为了避免数据损坏或进程突然终止，确保在最后使用`stop_postgres.sh`脚本。尽管PostgreSQL通常会恢复突然停止的数据库，但这会减慢启动时间。
- en: 'To start the database in operation, the CMD is just the `postgres` command.
    It needs to run with the `postgres` user:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动数据库运行，CMD只是`postgres`命令。它需要以`postgres`用户身份运行：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To run the database service, we need to set it up as part of the `docker-compose`
    file:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 运行数据库服务，我们需要将其设置为`docker-compose`文件的一部分：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that the `args` parameter will set up the `ARG` values during the build.
    We also route the PostgreSQL port to allow access to the database.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`args`参数将在构建期间设置`ARG`值。我们还将路由PostgreSQL端口以允许访问数据库。
- en: 'You can now build and start the server:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以构建和启动服务器：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In a different Terminal, you can use a PostgreSQL client to access the database.
    I recommend the fantastic `pgcli`. You can check out its documentation ([https://www.pgcli.com/](https://www.pgcli.com/)).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，您可以使用PostgreSQL客户端访问数据库。我建议使用fantastic `pgcli`。您可以查看其文档（[https://www.pgcli.com/](https://www.pgcli.com/)）。
- en: You can use also the official `psql` client or any other PostgreSQL client of
    your preference. The documentation for the default client can be found here: [https://www.postgresql.org/docs/current/app-psql.html](https://www.postgresql.org/docs/current/app-psql.html).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用官方的`psql`客户端或您喜欢的任何其他PostgreSQL客户端。默认客户端的文档可以在此处找到：[https://www.postgresql.org/docs/current/app-psql.html](https://www.postgresql.org/docs/current/app-psql.html)。
- en: 'Here, we use the `PGPASSWORD` environment variable to show that the password
    is the previously configured one:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`PGPASSWORD`环境变量来显示密码是先前配置的密码：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Being able to access the database is useful for debugging purposes.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问数据库对于调试目的很有用。
- en: Configuring your service
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置您的服务
- en: We can configure the service to use environment variables to change the behavior.
    For containers, this is a fantastic alternative to using configuration files,
    as it allows immutable containers that get their configuration injected. This
    is in line with the Twelve-Factor App ([https://12factor.net/config](https://12factor.net/config))
    principles and allows for good separation between code and configuration, and
    the setting up of the different deploys that the code might be used for.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置服务使用环境变量来更改行为。对于容器来说，这是使用配置文件的绝佳替代方案，因为它允许不可变的容器注入其配置。这符合十二要素应用程序（[https://12factor.net/config](https://12factor.net/config)）原则，并允许良好地分离代码和配置，并设置代码可能用于的不同部署。
- en: One of the advantages that we'll look at later with the use of Kubernetes is
    creating new environments on-demand, which can be tweaked for testing purposes
    or tailored for development or demo. Being able to quickly change all the configuration
    by injecting the proper environment makes this operation very easy and straightforward.
    It also allows you to enable or disable features, if properly configured, which
    helps the enablement of features on launch day, with no code rollout.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将在使用Kubernetes时看到的一个优势是根据需要创建新环境，这些环境可以根据测试目的进行调整，或者专门用于开发或演示。通过注入适当的环境，能够快速更改所有配置，使此操作非常简单和直接。它还允许您根据需要启用或禁用功能，如果正确配置，这有助于在启动日启用功能，而无需代码发布。
- en: This allows the configuration of the database to connect to, so we can choose
    between the SQLite backend or PostgreSQL.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许配置数据库以连接，因此我们可以在SQLite后端或PostgreSQL之间进行选择。
- en: Configuring the system is not limited to open variables, though. Environment
    variables will be used later in the book for storing secrets. Note that a secret
    needs to be available inside the container.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 系统配置不仅限于开放变量。环境变量将在本书后面用于存储秘密。请注意，秘密需要在容器内可用。
- en: 'We will configure the tests to access our newly created database container.
    To do that, we first need the ability to choose between either SQLite or PostgreSQL
    through configuration. Check out the `./ThoughtsBackend/thoughts_backend/db.py` file:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将配置测试以访问我们新创建的数据库容器。为此，我们首先需要通过配置选择SQLite或PostgreSQL的能力。查看`./ThoughtsBackend/thoughts_backend/db.py`文件：
- en: '[PRE33]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When using the `DATABASE_ENGINE` environment variable set to `POSTGRESQL`, it
    will configure it properly. Other environment variables will need to be correct;
    that is, if the database engine is set to PostgreSQL, the `POSTGRES_HOST` variable
    needs to be set up.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`DATABASE_ENGINE`环境变量设置为`POSTGRESQL`时，它将正确配置。其他环境变量需要正确设置；也就是说，如果数据库引擎设置为PostgreSQL，则需要设置`POSTGRES_HOST`变量。
- en: 'Environment variables can be stored individually in the `docker-compose.yaml`
    file, but it''s more convenient to store multiple ones in a file. Let''s take
    a look at `environment.env`:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量可以单独存储在`docker-compose.yaml`文件中，但更方便的是将多个环境变量存储在一个文件中。让我们看一下`environment.env`：
- en: '[PRE34]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the definition of users, and so on is in line with the arguments to
    create Dockerfile for testing. `POSTGRES_HOST` is defined as `db`, which is the
    name of the service.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，用户的定义等与为测试创建Dockerfile的参数一致。`POSTGRES_HOST`被定义为`db`，这是服务的名称。
- en: Inside the Docker cluster created for `docker-compose`, you can refer to services
    by their names. This will be directed by the internal DNS to the proper container,
    as a shortcut. This allows easy communication between services, as they can configure
    their access very easily by name. Note that this connection is only valid inside
    the cluster, for communication between containers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在为`docker-compose`创建的Docker集群中，您可以通过它们的名称引用服务。这将由内部DNS指向适当的容器，作为快捷方式。这允许服务之间轻松通信，因为它们可以通过名称非常容易地配置其访问。请注意，此连接仅在集群内有效，用于容器之间的通信。
- en: 'Our testing service using the PostgreSQL container then gets defined as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用PostgreSQL容器的测试服务定义如下：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This is very similar to the `test-sqlite` service, but it adds the environment
    configuration in `environment.env` and adds a dependency on `db`. This means that
    `docker-compose` will start the `db` service, if not present.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`test-sqlite`服务非常相似，但它在`environment.env`中添加了环境配置，并添加了对`db`的依赖。这意味着如果不存在`db`服务，`docker-compose`将启动`db`服务。
- en: 'You can now run the tests against the PostgreSQL database:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以针对PostgreSQL数据库运行测试：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This environment file will be useful for any service that needs to connect to
    the database, such as deploying the service locally.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个环境文件对于任何需要连接到数据库的服务都很有用，比如在本地部署服务。
- en: Deploying the Docker service locally
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地部署Docker服务
- en: 'With all these elements, we can create the service to locally deploy the Thoughts
    service:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有了所有这些元素，我们可以创建服务来本地部署Thoughts服务：
- en: '[PRE37]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We need to be sure to add the dependency of the `db` database service. We also
    bound the internal port so that we can access it locally.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保添加`db`数据库服务的依赖关系。我们还绑定了内部端口，以便可以在本地访问它。
- en: We start the service with the `up` command. There are some differences between
    the `up` and the `run` commands, but the main one is that `run` is for single
    commands that start and stop, while `up` is designed for services. For example,
    `run` creates an interactive Terminal, which displays colors, and `up` shows the
    standard output as logs, including the time when they were generated, accepts
    the `-d` flag to run in the background, and so on. Using one instead of the other
    is normally okay, however, `up` exposes ports and allows other containers and
    services to connect, while `run` does not.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`up`命令启动服务。`up`和`run`命令之间有一些区别，但主要区别在于`run`用于启动和停止的单个命令，而`up`设计用于服务。例如，`run`创建一个交互式终端，显示颜色，`up`显示标准输出作为日志，包括生成时间，接受`-d`标志以在后台运行等。通常使用其中一个而不是另一个是可以的，但是`up`会暴露端口并允许其他容器和服务连接，而`run`则不会。
- en: 'We can start the service now with the following commands:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令启动服务：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now access the service in `localhost:8000` in a browser:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在浏览器中访问`localhost:8000`中的服务：
- en: '![](img/741100a2-4db5-4976-9d76-557fb89dcdaf.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/741100a2-4db5-4976-9d76-557fb89dcdaf.png)'
- en: 'You can see the logs in the Terminal. Hitting *Ctrl* + *C* will stop the server.
    The service can also be started using the `-d` flag, to detach the Terminal and
    run in daemon mode:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在终端中查看日志。按下*Ctrl* + *C*将停止服务器。该服务也可以使用`-d`标志启动，以分离终端并以守护程序模式运行：
- en: '[PRE39]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Check the running services, their current state, and open ports with `docker-compose
    ps`:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker-compose ps`检查运行的服务、它们的当前状态和打开的端口：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'As we''ve seen before, we can directly access the database and run raw SQL
    commands in it. This can be useful for debugging problems or conducting experiments:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所见，我们可以直接访问数据库并在其中运行原始的SQL命令。这对于调试问题或进行实验非常有用：
- en: '[PRE41]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now the thought is available through the following API:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Thoughts通过以下API可用：
- en: '[PRE42]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you need to see the logs in detach mode, you can use the `docker-compose
    logs <optional: service>` command:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '如果需要以分离模式查看日志，可以使用`docker-compose logs <optional: service>`命令：'
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'To totally stop the cluster, call `docker-compose down`:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全停止集群，请调用`docker-compose down`：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This stops all the containers.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这将停止所有容器。
- en: Pushing your Docker image to a remote registry
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Docker镜像推送到远程注册表
- en: All the operations that we've seen work with our local Docker repository. Given
    the structure of Docker images and the fact that each layer can be worked on independently,
    they are easy to upload and share. To do so, we need to use a remote repository,
    or registry in Docker terminology, that will accept images pushed to it, and allow
    images to be pulled from it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所见的所有操作都适用于我们的本地Docker存储库。鉴于Docker镜像的结构以及每个层可以独立工作，它们很容易上传和共享。为此，我们需要使用一个远程存储库或Docker术语中的注册表，它将接受推送到它的镜像，并允许从中拉取镜像。
- en: The structure of a Docker image is composed of each of the layers. Each of them
    can be pushed independently, as long as the registry contains the layer it depends
    on. This saves space if the previous layers are already present, as they will
    be stored only once.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像的结构由每个层组成。只要注册表包含它所依赖的层，每个层都可以独立推送。如果先前的层已经存在，这将节省空间，因为它们只会被存储一次。
- en: Obtaining public images from Docker Hub
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从Docker Hub获取公共镜像
- en: 'The default registry is Docker Hub. This is configured by default, and it serves
    as the main source of public images. You can access it freely in [https://hub.docker.com/](https://hub.docker.com/)
    and search for available images to base your images on:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 默认注册表是Docker Hub。这是默认配置的，它作为公共镜像的主要来源。您可以在[https://hub.docker.com/](https://hub.docker.com/)上自由访问它，并搜索可用的镜像来基于您的镜像：
- en: '![](img/11179995-9c90-434a-9807-c307bd277d53.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11179995-9c90-434a-9807-c307bd277d53.png)'
- en: 'Each image has information about the way to use it and the tags that are available.
    You don''t need to download the images independently, just to use the name of
    the image or run a `docker pull` command. Docker will automatically pull from Docker
    Hub if no other registry is specified:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 每个镜像都有关于如何使用它以及可用标签的信息。您不需要单独下载镜像，只需使用镜像的名称或运行`docker pull`命令。如果没有指定其他注册表，Docker将自动从Docker
    Hub拉取：
- en: '![](img/fa6ae25c-9a50-42dc-88be-d66941b5743f.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa6ae25c-9a50-42dc-88be-d66941b5743f.png)'
- en: The name of the image is also the one to use in our `FROM` command in Dockerfiles.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的名称也是我们在Dockerfiles中使用的`FROM`命令。
- en: Docker is a fantastic way of distributing a tool. It's very common right now
    for an open source tool to have an official image in Docker Hub that can be downloaded
    and started in a standalone model, standardizing the access.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一种分发工具的绝佳方式。现在很常见的是，一个开源工具在Docker Hub中有一个官方镜像，可以下载并以独立模式启动，从而标准化访问。
- en: This can be used either for a quick demo, for something such as Ghost—[https://hub.docker.com/_/ghost](https://hub.docker.com/_/ghost) (a
    blogging platform), or a Redis ([https://hub.docker.com/_/redis](https://hub.docker.com/_/redis))
    instance to act as cache with minimal work. Try to run the Ghost example locally.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于快速演示，比如Ghost（https://hub.docker.com/_/ghost）（一个博客平台），或者Redis（https://hub.docker.com/_/redis）实例作为最小工作量的缓存。尝试在本地运行Ghost示例。
- en: Using tags
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签
- en: Tags are descriptors to label different versions of the same image. There's
    an image, `alpine:3.9`, and another, `alpine:3.8`. There are also official images
    of Python for different interpreters (3.6, 3.7, 2.7, and so on), but other than
    versions, the interpreters may refer to ways the image is created.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 标签是用来标记同一镜像的不同版本的描述符。有一个镜像`alpine:3.9`，另一个是`alpine:3.8`。还有Python的官方镜像用于不同的解释器（3.6、3.7、2.7等），但除了版本之外，解释器可能指的是创建镜像的方式。
- en: 'For example, these images have the same effect. The first one is a full image
    containing a Python 3.7 interpreter:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这些镜像具有相同的效果。第一个是包含Python 3.7解释器的完整镜像：
- en: '[PRE45]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The second one also has a Python 3.7 interpreter. Note the `slim` change in
    the name:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个也有一个Python 3.7解释器。请注意名称中的`slim`变化：
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, the sizes of the images are quite different:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，镜像的大小相当不同：
- en: '[PRE47]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Any build uses the `latest` tag automatically if another tag is not specified.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定其他标签，任何构建都会自动使用`latest`标签。
- en: Keep in mind that tags can be overwritten. This may be confusing, given some
    of the similarities between the way Docker and Git work, as the term "tag" in
    Git means something that can't change. A tag in Docker is similar to a branch
    in Git.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，标签可以被覆盖。这可能会让人感到困惑，因为Docker和Git的工作方式之间存在一些相似之处，例如Git中的“标签”意味着不可更改。Docker中的标签类似于Git中的分支。
- en: 'A single image can be tagged multiple times, with different tags. For example,
    the `latest` tag can also be version `v1.5`:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 单个镜像可以多次打标签，使用不同的标签。例如，`latest`标签也可以是版本`v1.5`：
- en: '[PRE48]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Note how `image id` is the same. Using tags allows you to label specific images,
    so we know they are ready to deploy or give them some kind of significance.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`image id`是相同的。使用标签允许您标记特定的镜像，以便我们知道它们已经准备部署或赋予它们某种意义。
- en: Pushing into a registry
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 推送到注册表
- en: Once we have our image tagged, we can push it to a shared registry so that it's
    available for other services to use.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们给我们的镜像打了标签，我们就可以将它推送到共享注册表中，以便其他服务可以使用它。
- en: It is possible to deploy your own Docker registry, but, unless strictly necessary,
    it's better to avoid it. There are cloud providers that allow you to create your
    own registry, either public or private, and even in your own private cloud network.
    If you want to make your image available, the best alternative is Docker Hub,
    as it's the standard and it will be most accessible. In this chapter, we will
    create one here, but we'll explore other options later in the book.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 可以部署自己的Docker注册表，但是，除非绝对必要，最好避免使用它。有一些云服务提供商允许您创建自己的注册表，无论是公共的还是私有的，甚至在您自己的私有云网络中。如果您想使您的镜像可用，最好的选择是Docker
    Hub，因为它是标准的，而且最容易访问。在本章中，我们将在这里创建一个，但是我们将在本书的后面探索其他选项。
- en: 'It''s worth saying it again: maintaining your own Docker registry is much more
    expensive than using a provider one. Commercial prices for registries, unless
    you require a lot of repos will be in the range of tens of dollars per month,
    and there are options from well-known cloud providers such as AWS, Azure, and
    Google Cloud.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次强调的是：维护自己的Docker注册表比使用提供者的注册表要昂贵得多。商业注册表的价格，除非您需要大量的仓库，将在每月几十美元的范围内，而且有来自知名云服务提供商如AWS、Azure和Google
    Cloud的选项。
- en: Unless you really need to, avoid using your own registry.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您确实需要，否则避免使用自己的注册表。
- en: We will create a new repo in the Docker Hub registry. You can create a private
    repo for free, and as many public ones as you want. You need to create a new user,
    which was probably the case when downloading Docker.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在Docker Hub注册表中创建一个新的仓库。您可以免费创建一个私有仓库，以及任意数量的公共仓库。您需要创建一个新用户，这可能是在下载Docker时的情况。
- en: A repo, in Docker terms, is a set of images with different tags; for example,
    all the tags of `thoughts-backend`. This is different from the registry, which
    is a server that contains several repos.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker术语中，仓库是一组具有不同标签的镜像；例如，所有`thoughts-backend`的标签。这与注册表不同，注册表是一个包含多个仓库的服务器。
- en: In more informal terms, it's common to refer to registries as *repos* and to
    repos as *images*, though, speaking purely, an image is unique and may be a tag
    (or not).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 更不正式地说，通常将注册表称为*仓库*，将仓库称为*镜像*，尽管从纯粹的角度来说，镜像是唯一的，可能是一个标签（或者不是）。
- en: 'Then, you can create a new repo as follows:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以按以下方式创建一个新的仓库：
- en: '![](img/d617ceee-0f7b-451a-9bc8-affb75606f9a.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d617ceee-0f7b-451a-9bc8-affb75606f9a.png)'
- en: 'Once the repo is created, we need to tag our image accordingly. This means
    that it should include the username in Docker Hub to identify the repo. An alternative
    is to name the image directly with the username included:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库后，我们需要相应地给我们的镜像打标签。这意味着它应该包括Docker Hub中的用户名以标识仓库。另一种选择是直接使用包含用户名的镜像名称：
- en: '[PRE49]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'To be able to access the repo, we need to log into Docker with our username
    and password in Docker Hub:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问仓库，我们需要使用我们在Docker Hub中的用户名和密码登录Docker：
- en: '[PRE50]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Once logged in, you can push your image:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录，您就可以推送您的镜像：
- en: '[PRE51]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can now share the image and pull it from anywhere, given that the local
    Docker is properly logged. When we deploy a production cluster, we need to be
    sure that the Docker server executing it is capable of accessing the registry
    and that it's properly logged.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以分享镜像并从任何地方拉取它，只要本地的Docker已经正确登录。当我们部署生产集群时，我们需要确保执行它的Docker服务器能够访问注册表并且已经正确登录。
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to use Docker commands to create and operate
    containers. We learned most of the commonly used Docker commands, such as `build`,
    `run`, `exec`, `ps`, `images`, `tag`, and `push`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用Docker命令来创建和操作容器。我们学习了大多数常用的Docker命令，比如`build`，`run`，`exec`，`ps`，`images`，`tag`和`push`。
- en: We saw how to build a web service container, including the preparation of configuration
    files, how to structure a Dockerfile, and how to make our images as small as possible.
    We also covered how to use `docker-compose` to operate locally and, through a
    `docker-compose.yaml` file, connect different containers running in a cluster
    configuration. This included creating a database container that allows testing
    much closer to what the production deployment will be, using the same tools.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何构建一个Web服务容器，包括准备配置文件，如何构建Dockerfile的结构，以及如何尽可能地减小我们的镜像。我们还介绍了如何使用`docker-compose`在本地操作，并通过`docker-compose.yaml`文件连接运行在集群配置中的不同容器。这包括创建一个允许更接近生产部署的数据库容器，使用相同的工具进行测试。
- en: We saw how to use environment variables to configure our service and how to
    inject them through `docker-compose` configuration to allow different modes, such
    as testing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用环境变量来配置我们的服务，并通过`docker-compose`配置来注入它们，以允许不同的模式，比如测试。
- en: Finally, we analyzed how to use a registry to share our images, and how to tag
    them adequately and allow moving them out from local development, ready to be
    used in a deployment.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们分析了如何使用注册表来分享我们的镜像，以及如何充分标记它们并允许将它们从本地开发中移出，准备在部署中使用。
- en: In the next chapter, we will see how to leverage the created containers and
    actions to run tests automatically and make automated tools do the heavy lifting
    for us to be sure our code is always high-quality!
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何利用创建的容器和操作来自动运行测试，并让自动化工具为我们做繁重的工作，以确保我们的代码始终是高质量的！
- en: Questions
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does the `FROM` keyword do in a Dockerfile?
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Dockerfile中，`FROM`关键字是做什么的？
- en: How would you start a container with its predefined command?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何启动一个带有预定义命令的容器？
- en: Why won't creating a step to remove files in a Dockerfile make a smaller image?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么在Dockerfile中创建一个步骤来删除文件不会使镜像变得更小？
- en: Can you describe how a multistage Docker build works?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能描述一下多阶段Docker构建是如何工作的吗？
- en: What is the difference between the `run` and `exec` commands?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`run`和`exec`命令有什么区别？'
- en: When should we use the`-it` flags when using the `run` and `exec` commands?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用`run`和`exec`命令时，什么时候应该使用`-it`标志？
- en: Do you know any alternatives to uWSGI to serve Python web applications?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你知道除了uWSGI之外还有什么替代方案来提供Python Web应用程序吗？
- en: What is `docker-compose` used for?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker-compose`用于什么？'
- en: Can you describe what a Docker tag is?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能描述一下Docker标签是什么吗？
- en: Why is it necessary to push images to a remote registry?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么有必要将镜像推送到远程注册表？
- en: Further reading
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: To further your knowledge of Docker and containers, you can check out the *Mastering
    Docker – Third Edition* book ([https://www.packtpub.com/eu/virtualization-and-cloud/mastering-docker-third-edition](https://www.packtpub.com/eu/virtualization-and-cloud/mastering-docker-third-edition)).
    For tweaking containers and learning how to make your applications more performant,
    see *Docker High Performance - Second Edition* ([https://www.packtpub.com/eu/networking-and-servers/docker-high-performance-second-edition](https://www.packtpub.com/eu/networking-and-servers/docker-high-performance-second-edition)),
    which covers a lot of techniques for analyzing and discovering performance problems.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步了解Docker和容器，你可以查看*Mastering Docker – Third Edition*一书（[https://www.packtpub.com/eu/virtualization-and-cloud/mastering-docker-third-edition](https://www.packtpub.com/eu/virtualization-and-cloud/mastering-docker-third-edition)）。要调整容器并学习如何使你的应用程序更高效，可以查看*
    Docker High Performance - Second Edition*一书（[https://www.packtpub.com/eu/networking-and-servers/docker-high-performance-second-edition](https://www.packtpub.com/eu/networking-and-servers/docker-high-performance-second-edition)），其中涵盖了许多分析和发现性能问题的技术。
