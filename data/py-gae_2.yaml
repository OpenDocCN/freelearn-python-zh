- en: Chapter 2. A More Complex Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章.一个更复杂的应用程序
- en: Web applications commonly provide a set of features such as user authentication
    and data storage. As we know from the previous chapter, App Engine provides the
    services and tools needed to implement such features and the best way to learn
    how to use them is by writing a web application and seeing the platform in action.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 网络应用通常提供一系列功能，如用户身份验证和数据存储。正如我们从上一章所知，App Engine提供了实现这些功能所需的服务和工具，而学习如何使用它们的最佳方式是通过编写一个网络应用并看到平台在实际中的应用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Further details of the webapp2 framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webapp2框架的更多细节
- en: How to authenticate users
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证用户身份
- en: Storing data on Google Cloud Datastore
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Google Cloud Datastore上存储数据
- en: Building HTML pages using templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板构建HTML页面
- en: Serving static files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供静态文件
- en: Experimenting on the Notes application
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在笔记应用上进行实验
- en: To better explore App Engine and Cloud Platform capabilities, we need a real-world
    application to experiment on; something that's not trivial to write, with a reasonable
    list of requirements so that it can fit in this book. A good candidate is a note-taking
    application; we will name it Notes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地探索App Engine和云平台的功能，我们需要一个真实世界的应用来进行实验；一个不是那么容易编写，但有一份合理的需求列表，以便它能够适应这本书的内容。一个好的候选者是笔记应用；我们将称之为Notes。
- en: Notes enable the users to add, remove, and modify a list of notes; a note has
    a title and a body of text. Users can only see their personal notes, so they must
    authenticate before using the application.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Notes允许用户添加、删除和修改笔记列表；一个笔记有一个标题和正文文本。用户只能看到他们个人的笔记，因此在使用应用程序之前必须进行身份验证。
- en: The main page of the application will show the list of notes for logged-in users
    and a form to add new ones.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主页将显示登录用户的笔记列表以及添加新笔记的表单。
- en: The code from the `helloworld` example in the previous chapter is a good starting
    point. We can simply change the name of the root folder and the `application`
    field in the `app.yaml` file to match the new name we chose for the application,
    or we can start a new project from scratch named `notes`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章中`helloworld`示例中的代码是一个好的起点。我们可以简单地更改根文件夹的名称和`app.yaml`文件中的`application`字段，以匹配我们为应用选择的新名称，或者我们可以从头开始一个新的项目，命名为`notes`。
- en: Authenticating users
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证用户身份
- en: 'The first requirement for our Notes application is showing the home page only
    to users who are logged in and redirect others to the login form; the **users**
    service provided by App Engine is exactly what we need and adding it to our `MainHandler`
    class is quite simple:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Notes应用的第一个需求是只向已登录用户显示主页，并将其他人重定向到登录表单；App Engine提供的**用户**服务正是我们所需要的，将其添加到我们的`MainHandler`类中相当简单：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `user` package we import on the second line of the previous code provides
    access to users' service functionalities. Inside the `get()` method of the `MainHandler`
    class, we first check whether the user visiting the page has logged in or not.
    If they have, the `get_current_user()` method returns an instance of the `user`
    class provided by App Engine and representing an authenticated user; otherwise,
    it returns `None` as output. If the user is valid, we provide the response as
    we did before; otherwise, we redirect them to the Google login form. The URL of
    the login form is returned using the `create_login_url()` method, and we call
    it, passing as a parameter the URL we want to redirect users to after a successful
    authentication. In this case, we want to redirect users to the same URL they are
    visiting, provided by webapp2 in the `self.request.uri` property. The webapp2
    framework also provides handlers with a `redirect()` method we can use to conveniently
    set the right status and location properties of the response object so that the
    client browsers will be redirected to the login page.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码的第二行中我们导入的`user`包提供了访问用户服务功能的方法。在`MainHandler`类的`get()`方法内部，我们首先检查访问页面的用户是否已登录。如果他们已登录，`get_current_user()`方法将返回一个由App
    Engine提供的`user`类的实例，代表一个已验证的用户；否则，它返回`None`作为输出。如果用户有效，我们提供与之前相同的响应；否则，我们将他们重定向到Google登录表单。登录表单的URL是通过`create_login_url()`方法返回的，我们调用它，将作为参数传递的URL作为成功身份验证后要重定向用户的URL。在这种情况下，我们希望将用户重定向到他们正在访问的相同URL，由webapp2的`self.request.uri`属性提供。webapp2框架还提供了带有`redirect()`方法的处理器，我们可以使用它方便地设置响应对象的正确状态和位置属性，以便客户端浏览器将被重定向到登录页面。
- en: HTML templates with Jinja2
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jinja2的HTML模板
- en: 'Web applications provide rich and complex HTML user interfaces, and Notes is
    no exception but, so far, response objects in our applications contained just
    small pieces of text. We could include HTML tags as strings in our Python modules
    and write them in the response body but we can imagine how easily it could become
    messy and hard to maintain the code. We need to completely separate the Python
    code from HTML pages and that''s exactly what a template engine does. A template
    is a piece of HTML code living in its own file and possibly containing additional,
    special tags; with the help of a template engine, from the Python script, we can
    load this file, properly parse special tags, if any, and return valid HTML code
    in the response body. App Engine includes in the Python runtime a well-known template
    engine: the Jinja2 library.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Web 应用程序提供了丰富和复杂的 HTML 用户界面，Notes 也不例外，但到目前为止，我们应用程序中的响应对象只包含少量文本。我们可以在 Python
    模块中将 HTML 标签作为字符串包含在内，并在响应体中写入它们，但我们可以想象这会变得多么混乱，难以维护代码。我们需要完全将 Python 代码与 HTML
    页面分开，这正是模板引擎所做的。模板是一段存在于其自身文件中的 HTML 代码，可能包含额外的特殊标签；借助模板引擎，我们可以从 Python 脚本中加载此文件，正确解析特殊标签（如果有的话），并在响应体中返回有效的
    HTML 代码。App Engine 在 Python 运行时包含了一个知名的模板引擎：Jinja2 库。
- en: 'To make the Jinja2 library available to our application, we need to add this
    code to the `app.yaml` file under the `libraries` section:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Jinja2 库对我们的应用程序可用，我们需要在 `app.yaml` 文件中的 `libraries` 部分添加此代码：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can put the HTML code for the main page in a file called `main.html` inside
    the application root. We start with a very simple page:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将主页的 HTML 代码放在名为 `main.html` 的文件中，该文件位于应用程序根目录内。我们从一个非常简单的页面开始：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Most of the content is static, which means that it will be rendered as standard
    HTML as we see it but there is a part that is dynamic and whose content depend
    on which data will be passed at runtime to the rendering process. This data is
    commonly referred to as **template context**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分内容是静态的，这意味着它将以我们看到的标准 HTML 格式渲染，但有一部分是动态的，其内容取决于在运行时传递给渲染过程的哪些数据。这些数据通常被称为**模板上下文**。
- en: What has to be dynamic is the username of the current user and the link used
    to log out from the application. The HTML code contains two special elements written
    in the Jinja2 template syntax, `{{user}}` and `{{logout_url}}`, that will be substituted
    before the final output occurs.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 需要动态的是当前用户的用户名和用于从应用程序注销的链接。HTML 代码包含两个使用 Jinja2 模板语法编写的特殊元素，`{{user}}` 和 `{{logout_url}}`，它们将在最终输出之前被替换。
- en: 'Back to the Python script; we need to add the code to initialize the template
    engine before the `MainHandler` class definition:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 Python 脚本；我们需要在 `MainHandler` 类定义之前添加初始化模板引擎的代码：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The environment instance stores engine configuration and global objects, and
    it's used to load templates instances; in our case, instances are loaded from
    HTML files on the filesystem in the same directory as the Python script.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 环境实例存储引擎配置和全局对象，并用于加载模板实例；在我们的例子中，实例是从与 Python 脚本相同的目录中的 HTML 文件加载的。
- en: 'To load and render our template, we add the following code to the `MainHandler.get()`
    method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载和渲染我们的模板，我们需要将以下代码添加到 `MainHandler.get()` 方法中：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Similar to how we get the login URL, the `create_logout_url()` method provided
    by the user service returns the absolute URI to the logout procedure that we assign
    to the `logout_url` variable.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们获取登录 URL 的方式类似，用户服务提供的 `create_logout_url()` 方法返回指向注销程序的绝对 URI，我们将它分配给 `logout_url`
    变量。
- en: We then create the `template_context` dictionary that contains the context values
    we want to pass to the template engine for the rendering process. We assign the
    nickname of the current user to the `user` key in the dictionary and the logout
    URL string to the `logout_url` key.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建 `template_context` 字典，该字典包含我们想要传递给模板引擎进行渲染过程的环境值。我们将当前用户的昵称分配给字典中的 `user`
    键，并将注销 URL 字符串分配给 `logout_url` 键。
- en: The `get_template()` method from the `jinja_env` instance takes the name of
    the file that contains the HTML code and returns a Jinja2 template object. To
    obtain the final output, we call the `render()` method on the `template` object
    passing in the `template_context` dictionary whose values will be accessed, specifying
    their respective keys in the HTML file with the template syntax elements `{{user}}`
    and `{{logout_url}}`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`jinja_env`实例的`get_template()`方法接受包含HTML代码的文件名，并返回一个Jinja2模板对象。为了获得最终输出，我们在`template`对象上调用`render()`方法，传入包含将被访问的值的`template_context`字典，并在HTML文件中使用模板语法元素`{{user}}`和`{{logout_url}}`指定它们各自的键。'
- en: 'This is the result of the template rendering:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这是模板渲染的结果：
- en: '![HTML templates with Jinja2](img/8194OS_02_01.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![带有Jinja2的HTML模板](img/8194OS_02_01.jpg)'
- en: Handling forms
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理表单
- en: The main page of the application is supposed to list all the notes that belong
    to the current user but there isn't any way to create such notes at the moment.
    We need to display a web form on the main page so that users can submit details
    and create a note.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的主页应该列出属于当前用户的所有笔记，但目前还没有创建此类笔记的方法。我们需要在主页上显示一个网页表单，以便用户可以提交详细信息并创建笔记。
- en: 'To display a form to collect data and create notes, we put the following HTML
    code right below the username and the logout link in the `main.html` template
    file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示一个用于收集数据和创建笔记的表单，我们在`main.html`模板文件中用户名和注销链接下方放置以下HTML代码：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Before showing the form, a message is displayed only when the template context
    contains a variable named `note_title`. To do this, we use an `if` statement,
    executed between the `{% if note_title %}` and `{% endif %}` delimiters; similar
    delimiters are used to perform `for` loops or assign values inside a template.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在显示表单之前，只有当模板上下文中包含名为`note_title`的变量时，才会显示一条消息。为此，我们使用一个`if`语句，在`{% if note_title
    %}`和`{% endif %}`分隔符之间执行；类似的分隔符用于在模板内部执行`for`循环或分配值。
- en: 'The `action` property of the `form` tag is empty; this means that upon form
    submission, the browser will perform a `POST` request to the same URL, which in
    this case is the home page URL. As our WSGI application maps the home page to
    the `MainHandler` class, we need to add a method to this class so that it can
    handle `POST` requests:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`form`标签的`action`属性为空；这意味着在表单提交时，浏览器将向相同的URL执行一个`POST`请求，在这个例子中是主页URL。由于我们的WSGI应用程序将主页映射到`MainHandler`类，我们需要向这个类添加一个方法，以便它可以处理`POST`请求：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When the form is submitted, the handler is invoked and the `post()` method
    is called. We first check whether a valid user is logged in; if not, we raise
    an **HTTP 401: Unauthorized** error without serving any content in the response
    body. Since the HTML template is the same served by the `get()` method, we still
    need to add the logout URL and the user name to the context. In this case, we
    also store the data coming from the HTML form in the context. To access the form
    data, we call the `get()` method on the `self.request` object. The last three
    lines are boilerplate code to load and render the home page template. We can move
    this code in a separate method to avoid duplication:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '当表单提交时，处理程序被调用，并调用`post()`方法。我们首先检查是否有有效的用户登录；如果没有，我们不在响应体中提供任何内容，直接抛出**HTTP
    401: 未授权**错误。由于HTML模板与`get()`方法提供的相同，我们仍然需要将注销URL和用户名添加到上下文中。在这种情况下，我们还将从HTML表单中存储的数据添加到上下文中。要访问表单数据，我们调用`self.request`对象的`get()`方法。最后三行是加载和渲染主页模板的样板代码。我们可以将此代码移动到单独的方法中，以避免重复：'
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the handler class, we will then use something like this to output the template
    rendering result:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理类中，我们将使用类似以下内容来输出模板渲染结果：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We can try to submit the form and check whether the note title and content are
    actually displayed above the form.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试提交表单，并检查笔记标题和内容是否实际上显示在表单上方。
- en: Persisting data in Datastore
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Datastore中持久化数据
- en: Even if users can log in and submit a note, our application isn't very useful
    until notes are stored somewhere. Google Cloud Datastore is the perfect place
    to store our notes. As part of App Engine's infrastructure, it takes care of data
    distribution and replication, so all we have to do is define store and retrieve
    our entities using the Python **NDB** (**Next DB**) **Datastore API**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使用户可以登录并提交笔记，但如果没有将笔记存储在某个地方，我们的应用程序也不会很有用。Google Cloud Datastore是存储我们笔记的完美场所。作为App
    Engine基础设施的一部分，它负责数据分布和复制，所以我们只需要定义存储和检索我们的实体，使用Python **NDB** (**Next DB**) **Datastore
    API**。
- en: Note
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: 'There are currently two APIs available in the Python runtime to interact with
    Datastore: the **DB Datastore API**, also known as `ext.db`, and the NDB Datastore
    API. Even if both the APIs store exactly the same data in Datastore, in this book,
    we will only use NDB; it is more recent, provides more features, and its API is
    slightly more robust.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在 Python 运行时有两个 API 可用于与 Datastore 交互：**DB Datastore API**，也称为 `ext.db`，以及
    NDB Datastore API。即使这两个 API 在 Datastore 中存储的数据完全相同，在这本书中，我们只会使用 NDB；它更新，提供更多功能，并且其
    API 稍微更健壮。
- en: An entity has one or more properties that in turn have a name and a type; each
    entity has a unique key that identifies it, and instead of storing different data
    in different tables as in a relational database, every entity in Datastore is
    categorized by a kind. In the Python world, a kind is determined by its model
    class that we need to define in our application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实体有一个或多个属性，这些属性依次具有名称和类型；每个实体都有一个唯一键来标识它，并且与关系数据库不同，Datastore 中的每个实体都按类型分类。在
    Python 世界中，类型由其模型类确定，我们需要在我们的应用程序中定义它。
- en: Defining the models
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义模型
- en: 'To represent a kind, Datastore models must derive from the `ndb.Model` class
    provided by the NDB API. We define our models in a Python module called `models.py`
    that contains the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要表示一种类型，Datastore 模型必须从 NDB API 提供的 `ndb.Model` 类派生。我们在名为 `models.py` 的 Python
    模块中定义我们的模型，该模块包含以下代码：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Note` class has a property named `title` that contains small text (up
    to 500 characters), another one named `content` that contains text of unlimited
    length, and a property named `date_created` that contains a date and a time. Entities
    of this kind must contain at least a value for the `user` and `content` properties,
    and if not provided, the `date_created` property value will store the date and
    time at the moment the entity was created. We can now add new entities of the
    type `Note` class to the Datastore when users submit the form in the main page
    of the Notes application. In the `main.py` module, we first need to import the
    `Note` class from the `models` module:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`Note` 类有一个名为 `title` 的属性，其中包含少量文本（最多500个字符），另一个名为 `content` 的属性，其中包含无限长度的文本，还有一个名为
    `date_created` 的属性，其中包含日期和时间。此类实体必须至少包含 `user` 和 `content` 属性的值，如果没有提供，则 `date_created`
    属性的值将存储实体创建时的日期和时间。现在，当用户在笔记应用的首页提交表单时，我们可以向 Datastore 添加新的 `Note` 类实体。在 `main.py`
    模块中，我们首先需要从 `models` 模块导入 `Note` 类：'
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, we modify the `post()` method as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们按如下方式修改 `post()` 方法：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: From now on, each time a user submits the form in the main page, an instance
    of the `Note` class is created and an entity is persisted in the Datastore right
    after the `put()` method is called. As we have not modified the `template_context`
    dictionary, the storing process won't do anything apparently. To verify that data
    is actually stored, we can use the local Development Console by opening the browser
    at `http://localhost:8000` and checking out Datastore Viewer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，每次用户在首页提交表单时，都会创建一个 `Note` 类的实例，并在调用 `put()` 方法后立即将实体持久化到 Datastore 中。由于我们没有修改
    `template_context` 字典，存储过程看起来不会做任何事情。为了验证数据实际上已存储，我们可以使用本地开发控制台，通过在浏览器中打开 `http://localhost:8000`
    并检查 Datastore 观察器来验证。
- en: Basic querying
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本查询
- en: An entity can optionally specify another entity as its **parent** and an entity
    without a parent is a **root entity**; entities in Datastore form a hierarchically
    structured space similar to the directory structure in a filesystem. An entity
    together with all its descendants form an **entity group** and the key of the
    common ancestor is defined as the **parent key**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实体可以可选地指定另一个实体作为其 **父实体**，没有父实体的实体是 **根实体**；Datastore 中的实体形成一个类似于文件系统目录结构的分层结构空间。一个实体及其所有后代形成一个
    **实体组**，共同祖先的键被定义为 **父键**。
- en: It's important to understand entities' relationship because of the intrinsic
    distributed nature of the Datastore. Without digging too much into the details,
    what we have to know is that queries across multiple entity groups cannot guarantee
    consistent results and the result of such queries can sometimes fail to reflect
    recent changes to the data.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Datastore 的内在分布式特性，理解实体之间的关系非常重要。不深入细节，我们需要知道的是，跨多个实体组的查询不能保证一致的结果，并且此类查询的结果有时可能无法反映数据最近的变化。
- en: 'We have an alternative though; to get strongly consistent results, we can perform
    a so-called **ancestor query**, which is a query that limits the results to a
    particular entity group. To use ancestor queries in our code, the first thing
    to do is add a parent to our note entities when we create the model instance:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个替代方案；为了获得强一致性结果，我们可以执行所谓的**祖先查询**，这是一种将结果限制在特定实体组的查询。要在我们的代码中使用祖先查询，首先的事情是在创建模型实例时为我们的笔记实体添加一个父实体：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As every note belongs to the user who creates it, we can use the same logic
    to structure our data; we use the currently logged-in user as the parent key for
    an entity group that contains all the notes belonging to that user. This is why
    we specify the `parent` keyword when calling the `Note` constructor in the previous
    code. To obtain the key of the currently logged-in user, we use the `ndb.Key`
    class constructor, passing in the kind and the identifier of the corresponding
    entity.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个笔记都属于创建它的用户，我们可以使用相同的逻辑来结构我们的数据；我们使用当前登录的用户作为包含该用户所有笔记的实体组的父键。这就是为什么我们在上一段代码中调用`Note`构造函数时指定了`parent`关键字。为了获取当前登录用户的键，我们使用`ndb.Key`类构造函数，传入类型和对应实体的标识符。
- en: 'What we need to do now is retrieve our notes from Datastore and show them to
    our users. As we will use ancestor queries, before proceeding, we add a utility
    method to the `Note` model class:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要从Datastore检索我们的笔记并向用户展示它们。由于我们将使用祖先查询，在继续之前，我们在`Note`模型类中添加一个实用方法：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `owner_query()` method returns a query object already filtered and containing
    the group entities for the parent key specified with the `parent_key` function
    parameter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`owner_query()`方法返回一个已经过滤并包含由`parent_key`函数参数指定的父键的组实体的查询对象。'
- en: 'To load all notes belonging to the current user, we then write the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载属于当前用户的全部笔记，我们接下来编写以下代码：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As we want to show the notes in the main page in the case of the `GET` and
    `POST` requests, we can load the entities inside the `_render_template()` method,
    which is called by the handler in both cases:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在`GET`和`POST`请求的情况下在主页上显示笔记，我们可以在`_render_template()`方法中加载实体，该方法在两种情况下都由处理程序调用：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We add the list of the notes as a value for the `notes` key in the `context`
    dictionary so that we can use them in the HTML template by writing the following
    right below the form:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将笔记列表作为`context`字典中`notes`键的值添加，这样我们就可以通过在表单下方编写以下内容在HTML模板中使用它们：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A `div` element will be printed out for each note in the query result and nothing
    will be printed out if the query returned an empty list. Even if the `title` property
    is optional for entities of the kind Note, we can safely access it. If it's not
    present, an empty string will be returned.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 对于查询结果中的每个笔记，将打印出一个`div`元素，如果查询返回了一个空列表，则不会打印任何内容。即使对于笔记类型的实体，`title`属性是可选的，我们也可以安全地访问它。如果它不存在，将返回一个空字符串。
- en: Transactions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务
- en: It's very common for web applications to define and use Datastore models that
    depend on each other so that when we update an entity, we will likely need to
    update dependent entities as well. However, what happens if, during a series of
    Datastore operations, some of them fail? In such cases, we can encapsulate these
    operations in a transaction so that either all of them succeed or all of them
    fail.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Web应用程序来说，定义并使用相互依赖的Datastore模型是很常见的，这样当我们更新一个实体时，我们很可能还需要更新依赖的实体。然而，如果在一系列Datastore操作过程中，其中一些操作失败了怎么办？在这种情况下，我们可以将这些操作封装在一个事务中，这样要么所有操作都成功，要么所有操作都失败。
- en: 'To see a use case for transactions, we add a small feature to our Note model:
    a checklist. A checklist is a list of items that provide a Boolean property that
    determines their checked state. We first need to define a Datastore model for
    a single checklist item:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示事务的使用案例，我们在`Note`模型中添加了一个小功能：清单。清单是一系列项目，它们具有一个布尔属性，用于确定其选中状态。我们首先需要定义一个用于单个清单项目的Datastore模型：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The entity has two properties, the `title` property for the string that will
    be displayed and the `checked` property to store whether the item is checked or
    not.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 实体有两个属性，`title`属性用于显示的字符串，以及`checked`属性用于存储项目是否被选中。
- en: 'We then add a property to the `Node` model class referencing item entities:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们在`Node`模型类中添加一个属性，以引用项目实体：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `checklist_items` property stores key values of the `CheckListItem` kind;
    the `repeated=True` parameter is needed to define that the property can hold more
    than one value.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`checklist_items`属性存储`CheckListItem`类型的键值；需要`repeated=True`参数来定义该属性可以存储多个值。'
- en: 'Users can create checklist items for a note filling the creation form with
    a comma-separated list of values, so we add the following to the HTML template:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过在创建表单中填写逗号分隔的值列表来为笔记创建清单项目，因此我们在HTML模板中添加以下内容：
- en: '[PRE19]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we have to handle the comma-separated list in the `MainHandler` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须处理`MainHandler`类中的逗号分隔列表：
- en: '[PRE20]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We first retrieve the comma-separated values representing checklist items from
    the request. Then, for each of them, we create a `CheckListItem` instance. Until
    a model instance is not persisted, Datastore does not assign any key to it. So,
    we need to first store each item by calling the `put()` method before accessing
    the `key` property and retrieving a `Key` instance for that entity. Once we have
    a valid key, we append it to the list of items of the `Note` instance. We pass
    the key of the note as parent for the items so that all these entities will be
    part of the same entity group. The last step is to call the `put()` method and
    update the Node entity and store the new data for the `checklist_items` property.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从请求中检索表示清单项目的逗号分隔值。然后，对于每一个值，我们创建一个`CheckListItem`实例。直到模型实例被持久化，Datastore不会为其分配任何键。因此，在访问`key`属性和检索该实体的`Key`实例之前，我们需要首先通过调用`put()`方法存储每个项目。一旦我们有一个有效的键，我们就将其追加到`Note`实例的项目列表中。我们将笔记的键作为项目的父级，这样所有这些实体都将成为同一实体组的一部分。最后一步是调用`put()`方法并更新节点实体以及存储`checklist_items`属性的新数据。
- en: 'Now what happens if the `note.put()` method fails? We have a bunch of entities
    of `CheckListItem` type that are not tied to any note, and this is a consistency
    problem. Transactions can help us refactor the creation of a note so that it can
    either succeed or fail, without leaving behind any dangling data. We encapsulate
    the creation of note objects in a separate `_create_node()` method in the handler
    class:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果`note.put()`方法失败会发生什么？我们将有一系列未与任何笔记关联的`CheckListItem`类型的实体，这是一个一致性问题的例子。事务可以帮助我们重构笔记的创建，使其要么成功，要么失败，而不会留下任何悬空数据。我们在处理类中封装了笔记对象的创建，创建了一个单独的`_create_node()`方法：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `@ndb.transactional` decorator is all the Python code we need. Datastore
    will then ensure that any operation in the decorated method happens within a transaction.
    In this way, either we create a note entity along with all the checklist items
    entities or we get an error without touching the underlying data. To complete
    the code, we have to call the `_create_node()` method inside the `post()` method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ndb.transactional`装饰器是我们需要的所有Python代码。然后Datastore将确保装饰的方法中的任何操作都在事务中发生。这样，要么我们创建一个笔记实体以及所有清单项目实体，要么在没有接触底层数据的情况下得到一个错误。为了完成代码，我们必须在`post()`方法中调用`_create_node()`方法：'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To show the list of items in a checklist for our notes, we must add the code
    needed in the HTML template:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 为了显示笔记清单中的项目列表，我们必须在HTML模板中添加所需的代码：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We add an unordered list if the `checklist_items` property is not empty. We
    then iterate the list of items, adding a `class` attribute containing the `checked`
    parameter whenever an item has its `checked` property set to the `true` value:
    later in this chapter, we''ll learn how to add a **CSS (Cascading Style Sheets)**
    rule so that when this class is present, the item is shown with a horizontal line
    through its center.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`checklist_items`属性不为空，我们添加一个无序列表。然后我们遍历项目列表，当项目的`checked`属性设置为`true`值时，添加一个包含`checked`参数的`class`属性：在本章的后面，我们将学习如何添加一个**CSS（层叠样式表）**规则，以便当这个类存在时，项目将以水平线穿过其中心显示。
- en: Using static files
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用静态文件
- en: Usually web applications make use of CSS and JavaScript resources to provide
    a better user experience. For efficiency reasons, such content is not dynamically
    served by the WSGI application and are delivered by App Engine as static files
    instead.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Web应用程序会使用CSS和JavaScript资源来提供更好的用户体验。出于效率的考虑，这种内容不是由WSGI应用程序动态提供，而是由App Engine作为静态文件提供。
- en: 'We know from the previous chapter that App Engine provides two types of handlers,
    script handlers and static file handlers. We add a static file handler to our
    `app.yaml` configuration file like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从前一章我们知道App Engine提供了两种类型的处理程序，脚本处理程序和静态文件处理程序。我们像这样在我们的`app.yaml`配置文件中添加一个静态文件处理程序：
- en: '[PRE24]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The syntax is almost the same as for script handlers. We specify a URL to map
    as a regular expression but instead of providing a Python script to handle requests,
    we specify a filesystem path relative to the application root where the files
    and directories that need to be served as static resources are located.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 语法几乎与脚本处理器相同。我们指定一个作为正则表达式的URL来映射，但不是提供Python脚本来处理请求，而是指定一个相对于应用根目录的文件系统路径，其中包含需要作为静态资源提供的服务文件和目录。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We are now going to provide a minimal style for our HTML pages by manually coding
    some CSS rules. While it is acceptable for the scope of the book to get our hands
    dirty learning how to build a custom design from scratch, in the real world, we
    might prefer to use frontend frameworks such as Bootstrap ([http://getbootstrap.com/](http://getbootstrap.com/))
    or Foundation ([http://foundation.zurb.com/](http://foundation.zurb.com/)) to
    easily provide state-of-the-art aesthetics, cross-browser capabilities, and responsive
    layouts for mobile devices.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将通过手动编写一些CSS规则来为我们的HTML页面提供一个最小样式。虽然对于本书的范围来说，学习如何从头开始构建自定义设计是可接受的，但在现实世界中，我们可能更愿意使用如Bootstrap
    ([http://getbootstrap.com/](http://getbootstrap.com/)) 或Foundation ([http://foundation.zurb.com/](http://foundation.zurb.com/))
    这样的前端框架，以轻松提供最先进的美学、跨浏览器功能和针对移动设备的响应式布局。
- en: 'To provide a CSS for our application, we then create the `static/css` folder
    into our application root:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们应用提供CSS，我们然后在应用根目录中创建 `static/css` 文件夹：
- en: '[PRE25]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This folder should contain a file called `notes.css` that will contain the
    style sheet for our application:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹应包含一个名为 `notes.css` 的文件，该文件将包含我们应用的样式表：
- en: '[PRE26]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first part is for global layout elements; we will put the form and the
    notes one below another in a centered container. We then style the form:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是用于全局布局元素；我们将把表单和笔记放在一个居中的容器中，一个在另一个下方。然后我们样式化表单：
- en: '[PRE27]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The form will be contained in a white box and the legend will look like a note
    title. Form elements will be styled as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 表单将被包含在一个白色框中，图例将看起来像笔记标题。表单元素将被如下样式化：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We then proceed with styling the white boxes that contain the Notes data:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们继续样式化包含笔记数据的白色框：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The last part of the style sheet is dedicated to notes checklists. We provide
    a style for unordered lists contained in `div` elements with a `note` class and
    a style for list items in checked state:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表的最后一部分是专门用于笔记清单的。我们为包含在具有 `note` 类的 `div` 元素中的无序列表提供了一种样式，并为处于选中状态的列表项提供了一种样式：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To use the style sheet, we add this in our HTML template, inside the `<meta>`
    tag:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用样式表，我们在HTML模板中添加以下内容，在 `<meta>` 标签内：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is how the application should appear once the style sheet is applied:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用应用样式表后的外观：
- en: '![Using static files](img/8194OS_02_02.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![使用静态文件](img/8194OS_02_02.jpg)'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Thanks to App Engine, we have already implemented a rich set of features with
    a relatively small effort so far.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了App Engine，我们到目前为止已经以相对较小的努力实现了一套丰富的功能。
- en: In this chapter, we have discovered some more details about the webapp2 framework
    and its capabilities, implementing a nontrivial request handler. We have learned
    how to use the App Engine users service to provide users authentication. We have
    delved into some fundamental details of Datastore and now we know how to structure
    data in grouped entities and how to effectively retrieve data with ancestor queries.
    In addition, we have created an HTML user interface with the help of the Jinja2
    template library, learning how to serve static content such as CSS files.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们发现了关于webapp2框架及其功能的一些更多细节，实现了一个非平凡的请求处理器。我们学习了如何使用App Engine用户服务来提供用户认证。我们深入了解了Datastore的一些基本细节，现在我们知道如何以分组实体结构化数据，以及如何通过祖先查询有效地检索数据。此外，我们还借助Jinja2模板库创建了一个HTML用户界面，学习了如何提供静态内容，如CSS文件。
- en: In the next chapter, we will keep on adding more and more features to the Notes
    application, learning how to store uploaded files on Google Cloud Storage, manipulate
    images, and deal with long operations and scheduled tasks. We will also make the
    application capable of sending and receiving e-mails.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续为笔记应用添加更多功能，学习如何将上传的文件存储在Google Cloud Storage上，处理图像，以及处理长时间操作和计划任务。我们还将使应用能够发送和接收电子邮件。
