- en: Parallel Processing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行处理
- en: In the previous chapter, we created a text mode utility program and you learned
    about several of Python's built-in packages. In this chapter, we're going to see
    how to use both the high-level `concurrent.futures` package and the lower-level
    multiprocessing package to help us write parallel programs. Both are part of the
    Python standard library.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个文本模式实用程序，并学习了 Python 的几个内置包。在这一章中，我们将看到如何使用前面提到的两个包：高级的 `concurrent.futures`
    包和低级的 multiprocessing 包来帮助我们编写并行程序。这两个包都是 Python 标准库的一部分。
- en: 'We will cover the following two topics in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细介绍以下两个主题：
- en: Using the `concurrent.futures` package
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `concurrent.futures` 包
- en: Using multiprocessing packages
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 multiprocessing 包
- en: Using the concurrent.futures package
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 concurrent.futures 包
- en: In this section, we're focusing on `concurrent.futures`, the more abstract and
    easier to use of the two packages mentioned earlier. Our focus will be on the
    four main operations in `concurrent.futures`. We will then move on to the usage
    of future objects and end with the implications of the mechanism of data transfer
    between processes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们专注于 `concurrent.futures`，这是前面提到的两个包中更抽象且更容易使用的包。我们的重点将放在 `concurrent.futures`
    的四个主要操作上。然后我们将继续介绍未来对象的使用，并以进程间数据传输机制的影响结束。
- en: Some programs are what we call CPU-bound, which means that the primary factor
    which determines how long the program takes to complete its tasks is how fast
    the computer can run through its instructions. Interestingly, most programs that
    we use on a daily basis are not CPU-bound. However, for those that are, we can
    often speed them up by breaking them into separate processes.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序是我们所说的 CPU 密集型，这意味着决定程序完成任务所需时间的主要因素是计算机运行其指令的速度有多快。有趣的是，我们日常使用的许多程序都不是
    CPU 密集型。然而，对于那些是 CPU 密集型的，我们通常可以通过将它们分解成单独的进程来加速它们。
- en: 'This difference can be illustrated as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异可以如下说明：
- en: '![](img/c0524bf3-8935-496e-9b07-4930f8c11c05.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0524bf3-8935-496e-9b07-4930f8c11c05.jpg)'
- en: In the preceding figure, on the left-hand side, we have a CPU-bound program.
    It has many things to do, represented by circles and the speed of execution depends
    on how quickly the CPU can process. On the right-hand side, we have a program
    that is not CPU-bound, which means, most of the time, it is waiting for the execution.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，左侧是一个 CPU 密集型程序。它有很多事情要做，用圆圈表示，执行速度取决于 CPU 处理速度的快慢。右侧是一个非 CPU 密集型程序，这意味着，大多数时候，它正在等待执行。
- en: The processes can run simultaneously on different CPU cores or even on completely
    separate CPUs. This has the net effect of increasing the number of program instructors
    executed per second, which means that CPU-bound programs run faster than the programs
    that are not CPU-bound.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 进程可以在不同的 CPU 核心上同时运行，甚至可以在完全独立的 CPU 上运行。这总体上增加了每秒执行的程序指令数，这意味着 CPU 密集型程序比非 CPU
    密集型程序运行得更快。
- en: In some programming languages, we can see the same benefit by running multiple
    threads for a single program. However, as I mentioned earlier, most programs are
    not CPU-bound, so the creators of Python have chosen to optimize Python's threading
    system for the common case, which has the side effect of making Python threads
    not very useful for improving the speed of CPU-bound programs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些编程语言中，我们可以通过为单个程序运行多个线程来获得相同的好处。然而，如我之前提到的，大多数程序都不是 CPU 密集型，因此 Python 的创建者选择了优化
    Python 的线程系统以适应常见情况，这产生了副作用，使得 Python 线程对于提高 CPU 密集型程序的运行速度并不十分有用。
- en: Besides, it's easier for the operating system to optimize the execution of multiple
    processes than multiple threads within a process. So, even if threading were a
    viable option, multiple processes would be a better choice for a CPU-bound program.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，操作系统优化多个进程的执行比优化进程内的多个线程更容易。因此，即使线程是一个可行的选项，对于 CPU 密集型程序来说，多个进程仍然是一个更好的选择。
- en: We already saw one very low-level approach to launching a process and communicating
    with it in our discussion of the `subprocess` module (refer to the *Executing
    other programs with subprocess* section in [Chapter 5](b7c332de-4fe1-4482-886b-b4573aa0d997.xhtml),
    *Making a Command-Line Utility*). However, for cases where the reason we want
    to do that is because our program is broken up into a bunch of cooperative processes
    that work together, Python provides us with a couple of higher-level toolkits
    that make things easier. The more abstract of Python's parallel processing toolkits
    is called `concurrent.futures`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在讨论`subprocess`模块时已经看到了一种非常低级的启动进程和与之通信的方法（请参阅第5章中关于*使用subprocess执行其他程序*的部分，*制作命令行工具*）。然而，对于我们的程序被拆分成一组协同工作的进程的情况，Python为我们提供了一些高级工具包，使事情变得更容易。Python并行处理工具包中更抽象的一个被称为`concurrent.futures`。
- en: The concurrent.futures module
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块'
- en: 'The `concurrent.futures` module is designed for programs that can be structured
    with one controlling process and several worker processes, where the controlling
    process hands out jobs to worker processes and then collects and collates the
    results. The following simple code example of a CPU-bound task uses the `concurrent.futures`
    module:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures`模块是为那些可以由一个控制进程和几个工作进程组成的程序设计的，其中控制进程将任务分配给工作进程，然后收集和整理结果。以下是一个使用`concurrent.futures`模块的简单CPU密集型任务示例：'
- en: '![](img/58dd1edd-1850-42d9-b963-4cc77ef73e1b.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58dd1edd-1850-42d9-b963-4cc77ef73e1b.jpg)'
- en: That's a fairly generic model, especially, for CPU-bound programs. So, `concurrent.futures`
    is as widely applicable as it is simple to use, and the preceding code example
    shows that it is simple.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当通用的模型，尤其是对于CPU密集型程序。因此，`concurrent.futures`模块既易于使用，又非常适用，前面的代码示例也展示了它的简单性。
- en: The basic usage is to just import it, create a `ProcessPoolExecutor` object,
    and then call that object's `map` or `submit` methods to send work to the worker
    processes. When we're completely done with the `ProcessPoolExecutor` and we know
    we'll never need it again, we call its `shutdown` method or allow the `with` statement
    to do it for us. The `ProcessPoolExecutor` object will take care of all the twitchy
    little details of creating and communicating with the worker processes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 基本用法是只需导入它，创建一个`ProcessPoolExecutor`对象，然后调用该对象的`map`或`submit`方法将工作发送到工作进程。当我们完全完成`ProcessPoolExecutor`并且知道我们再也不需要它时，我们可以调用它的`shutdown`方法，或者允许`with`语句为我们完成它。`ProcessPoolExecutor`对象将负责创建和与工作进程通信的所有琐碎细节。
- en: Before going ahead with the `map` and `submit` methods, let's find out more
    about `ProcessPoolExecutor` and what it does.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续使用`map`和`submit`方法之前，让我们更深入地了解`ProcessPoolExecutor`以及它的功能。
- en: Calling ProcessPoolExecutor
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用`ProcessPoolExecutor`
- en: 'When we call the `ProcessPoolExecutor` map or submit methods (which we''ll
    discuss later in this section), we''re asking it to call a function with the given
    parameters. But we want that function call to happen inside a worker process.
    This has some implications that might not be obvious:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`ProcessPoolExecutor`的`map`或`submit`方法（我们将在本节后面讨论），我们是在要求它使用给定的参数调用一个函数。但我们希望这个函数调用发生在工作进程中。这有一些可能不那么明显的含义：
- en: First of all, it means that the function and its parameters need to be **picklable**,
    which is another way of saying that Python needs to know how to turn them into
    a byte string that it could send to the worker process.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，这意味着函数及其参数需要是**可序列化的**，这另一种说法是Python需要知道如何将它们转换成一个字节字符串，它可以发送到工作进程。
- en: For functions, that basically means any function is OK, unless it was defined
    within the body of another function.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于函数，这基本上意味着任何函数都可以，除非它是另一个函数体内的定义。
- en: For the parameters, it means that most objects will work, but generators and
    a few other kinds of special object can't be passed.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参数来说，这意味着大多数对象都可以工作，但生成器和一些其他类型的特殊对象则不能传递。
- en: Being aware that both the function and the parameters passed to it can easily
    bring along information we didn't intend to send when they get pickled for communication
    to the worker processes is important.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到函数及其传递给它的参数在它们被序列化以与工作进程通信时可能会附带我们无意发送的信息是很重要的。
- en: If any of the objects we sent to the `ProcessPoolExecutor` object references
    other objects, those objects get pickled up and sent too. It's entirely possible
    to end up sending most of the state of our program. That's particularly worth
    noting when the function we're asking to run is a method of an object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发送给`ProcessPoolExecutor`对象的对象引用了其他对象，那么这些对象也会被序列化并发送。最终可能会发送我们程序的大部分状态。当请求运行的函数是某个对象的方法时，这一点尤其值得注意。
- en: If the function is a method of an object, the whole object will get pickled
    and sent to the worker process, which means that the function call will be happening
    with a copy of the original object as its self-parameter, not the original object.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是对象的方法，整个对象将被序列化并发送到工作进程，这意味着函数调用将使用原始对象的副本作为其self参数，而不是原始对象。
- en: Second, the return value of the function is pickled and returned to the controlling
    process. All of the warnings about passing parameters to the called function applied
    to the return value too.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二，函数的返回值将被序列化并返回到控制进程。所有关于传递参数给被调用函数的警告也适用于返回值。
- en: So, for example, if the function can't return a generator object and its return
    value contains references to a bunch of objects, copies of them will end up being
    sent to the controlling process.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果函数不能返回生成器对象，并且其返回值包含对多个对象的引用，那么这些对象的副本最终会被发送到控制进程。
- en: Third and finally, the `concurrent.futures` code that's running in the worker
    processes needs to be able to import the modules that our original code was loaded
    from.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三也是最后一点，运行在工作进程中的`concurrent.futures`代码需要能够导入我们的原始代码所加载的模块。
- en: This means that we may need to use the `if __name__ == '__main__'` trick to
    keep the worker processes from getting stuck running complete copies of our program,
    when all they wanted to do was import the module and find the function we were
    asking to have run.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可能需要使用`if __name__ == '__main__'`技巧来防止工作进程陷入运行我们程序完整副本的状态，而他们实际上只想导入模块并找到我们请求运行的函数。
- en: We already saw the `map` method of `ProcessPoolExecutor` in our example, but
    let's look a little closer.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的例子中看到了`ProcessPoolExecutor`的`map`方法，但让我们更仔细地看看。
- en: Using the map method
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`map`方法
- en: 'The `map` method takes a function as its first parameter. We can also pass
    it one or more intervals, which will be used to figure out the parameters for
    each call to the function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法将其第一个参数作为函数。我们还可以传递一个或多个区间，这些区间将被用来确定函数每次调用的参数：'
- en: '![](img/89c49ec5-c2bc-4a44-abc0-940d117acad6.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/89c49ec5-c2bc-4a44-abc0-940d117acad6.jpg)'
- en: Refer to the preceding code example, if we ask `pool` to map the `foo` function
    to the list `[1, 2, 3]` and `[4, 5, 6]`, the result is that the `foo` function
    will be called with `1` and `4` as its parameters, called again with `2` and `5`
    as its parameters, and called a third time with `3` and `6` as its parameters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 参考前面的代码示例，如果我们要求`pool`将`foo`函数映射到列表`[1, 2, 3]`和`[4, 5, 6]`，结果是`foo`函数将用`1`和`4`作为参数被调用，再次用`2`和`5`作为参数被调用，第三次用`3`和`6`作为参数被调用。
- en: There's no guarantee in which order these three calls will happen, though. After
    all, they're likely to each run in different processes and the relationship between
    process scheduling and wall-clock time is partly dependent on unpredictable factors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何保证这三个调用发生的顺序。毕竟，它们可能在每个不同的进程中运行，进程调度与墙钟时间的关系部分取决于不可预测的因素。
- en: The `map` method hides that fact by waiting for all the calls to finish and
    produce the results, then returning an iterator over those results in the proper
    order.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法通过等待所有调用完成并生成结果，然后按正确顺序返回这些结果的迭代器来隐藏这个事实。'
- en: Using the submit method
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`submit`方法
- en: Sometimes, the `map` method is too simple. What if we want to handle the results
    as each worker produces them, instead of waiting for all the workers to get done?
    What if we decide not to run the function after all? What if we want to run different
    functions in worker processes at the same time? For that matter, what if we want
    to pass keyword arguments to the function? We could do all that and more using
    the `submit` method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，`map`方法过于简单。如果我们想在每个工作进程生成结果时处理结果，而不是等待所有工作进程完成，怎么办？如果我们决定最终不运行函数，怎么办？如果我们想在工作进程中同时运行不同的函数，怎么办？至于传递关键字参数给函数，我们可以使用`submit`方法做到所有这些以及更多。
- en: Each call to the `submit` method translates to a single call to the function
    that we pass as the first parameter of the `submit` method. The rest of the parameters
    and keyword arguments we pass to `submit` are passed into the function after being
    sent to the worker process.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`submit`方法都对应于对作为`submit`方法第一个参数传递的函数的单次调用。我们传递给`submit`的其余参数和关键字参数在发送到工作进程后传递给函数。
- en: 'Let''s look at an example of the `submit` method in action:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`submit`方法的一个示例：
- en: '![](img/f9f98218-0a01-4420-a855-8bfc340b363a.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f9f98218-0a01-4420-a855-8bfc340b363a.jpg)'
- en: So, for each time we call `submit`, one worker process calls one function with
    one set of parameters. The `submit` method does not wait for the worker process
    to finish running the function before returning. In fact, it doesn't even wait
    for the worker process to start running the function and so `submit` does not
    return the result of the called function. Instead, it returns a `future` object.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次我们调用`submit`时，一个工作进程都会用一个参数集调用一个函数。`submit`方法在返回之前不会等待工作进程完成函数的运行。实际上，它甚至不会等待工作进程开始运行函数，因此`submit`不会返回被调用函数的结果。相反，它返回一个`future`对象。
- en: A `future` object is in some sense an IOU for the result of the function. If
    we have a `future` object, we can use it to check whether the worker process has
    finished running the function to get the result returned by the function or even
    to set up a callback that will be called when the function finally does finish
    running. We can even use the `future` object to remove the function call from
    the queue of jobs that should be shared out to the worker.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，`future`对象是函数结果的IOU。如果我们有一个`future`对象，我们可以使用它来检查工作进程是否已经运行完函数以获取函数返回的结果，甚至可以设置一个回调，当函数最终完成运行时将被调用。我们甚至可以使用`future`对象从应该分发给工作进程的作业队列中移除函数调用。
- en: The `done` and `result` methods of a `future` object are the ones we'll use
    most often.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最常使用的是`future`对象的`done`和`result`方法。
- en: The done and result methods
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`done`和`result`方法'
- en: 'The `done` method returns `true` if the job is done and `false` if it''s not.
    A job is done if it was cancelled, if it raised an exception, or if the job function
    has returned, as shown in the following code example:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`done`方法在作业完成时返回`true`，如果没有完成则返回`false`。如果作业被取消、引发异常或作业函数已返回，则作业完成，如下面的代码示例所示：'
- en: '![](img/27bcf882-7524-4194-9e91-6314d2d92c6a.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/27bcf882-7524-4194-9e91-6314d2d92c6a.jpg)'
- en: The `result` method returns the return value of the job function if it completed
    successfully. If the job function raised an exception instead of returning a value,
    the worker process will catch the exception and hand it back to the controlling
    process as the result of the job.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作业函数成功完成，`result`方法返回作业函数的返回值。如果作业函数引发异常而不是返回值，工作进程将捕获异常并将其作为作业的结果返回给控制进程。
- en: In the preceding code example, calling the `result` method will re-raise the
    exception, so it can be handled properly.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，调用`result`方法将重新引发异常，因此可以正确处理。
- en: '**The timeout parameter**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**超时参数**'
- en: The timeout parameter is an important parameter in the `result` method. It is
    useful if we want to call the `result` method before the job is done.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 超时参数是`result`方法中的一个重要参数。如果我们想在作业完成之前调用`result`方法，它将非常有用。
- en: If we call the `result` method before the job function is done, then the `result`
    method will wait for the job to complete before it returns. This could be very
    useful, but sometimes we don't want to wait indefinitely. If the job isn't done
    quickly, we want to go on and do something else for a while.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在作业函数完成之前调用`result`方法，那么`result`方法将在返回之前等待作业完成。这可能会非常有用，但有时我们不想无限期地等待。如果作业没有很快完成，我们想要继续做其他事情一段时间。
- en: 'In such a case, we should pass the number of seconds we''re willing to wait
    to the `timeout` parameter of the `result` method, as shown in the following code
    example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们应该将我们愿意等待的秒数传递给`result`方法的`timeout`参数，如下面的代码示例所示：
- en: '![](img/c578c83f-35d8-45f7-964e-d791cab5bcce.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c578c83f-35d8-45f7-964e-d791cab5bcce.jpg)'
- en: Along with the `timeout` parameter, we will add a `TimeoutError` exception.
    If the `timeout` parameter expires without a result being produced, a timeout
    error will be raised.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`timeout`参数外，我们还将添加一个`TimeoutError`异常。如果在没有产生结果的情况下`timeout`参数到期，将引发超时错误。
- en: The wait and as_completed functions
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`wait`和`as_completed`函数'
- en: 'There is a pair of functions in the `concurrent.futures` package that let''s
    wait on several futures at once. They''re called `wait` and `as_completed`. The
    following code example represents the `wait` function:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures` 包中有一对函数允许同时等待多个 `future`。它们被称为 `wait` 和 `as_completed`。以下代码示例表示
    `wait` 函数：'
- en: '![](img/0da427e6-d85c-428c-aa27-d30a7530a0d0.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0da427e6-d85c-428c-aa27-d30a7530a0d0.jpg)'
- en: The `wait` function waits until all the `futures` are ready to deliver the results
    or until a timeout expires. Then, it returns a set of `futures` that are done
    and a set of `futures` that aren't. In contrast, the `as_completed` function returns
    an iterator that produces `futures` one by one as they become ready to produce
    the results.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`wait` 函数等待所有 `futures` 准备好提供结果或直到超时到期。然后，它返回一组已完成和一组未完成的 `futures`。相比之下，`as_completed`
    函数返回一个迭代器，它会逐个产生准备提供结果的 `futures`。'
- en: In rare cases, the `done` and `result` methods of future and the `wait` and
    `as_completed` functions of the `concurrent.futures` package aren't sufficient
    to let a program process futures at the proper times.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，`future` 的 `done` 和 `result` 方法以及 `concurrent.futures` 包的 `wait` 和 `as_completed`
    函数不足以让程序在适当的时间处理 `futures`。
- en: For those occasions, it's possible to have the `future` call a function when
    the result becomes available. We can do that by passing a function into the `add
    done callback` method of `future`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，可以通过将函数传递给 `future` 的 `add done callback` 方法，让 `future` 在结果可用时调用一个函数。
- en: The add done callback function
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加完成回调函数
- en: The `future` object will remember that function and when the `job` function
    is done, the `callback` function will be called with the `future` object as its
    only parameter. The code in the `callback` function can then call the future's
    `result` method to get the return value or exception that the job produced.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`future` 对象会记住该函数，当 `job` 函数完成时，`callback` 函数将使用 `future` 对象作为其唯一参数被调用。然后，`callback`
    函数中的代码可以调用 `future` 的 `result` 方法来获取作业产生的返回值或异常。'
- en: The `callback` function will always be called in the controlling process, but
    it might not be called in the same thread as the main part of the program.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`callback` 函数总是在控制过程中被调用，但它可能不会在程序主要部分的同一线程中被调用。'
- en: When we use `add done callback`, we need to be careful of thread synchronization
    issues, which is a big reason to prefer the `wait` or `as_completed` functions
    when possible. The `future` objects also have a `cancel` method.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 `add done callback` 时，需要小心线程同步问题，这也是尽可能选择 `wait` 或 `as_completed` 函数的一个主要原因。`future`
    对象也有一个 `cancel` 方法。
- en: The cancel method
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消方法
- en: 'The `cancel` method tries to tell the system that we don''t want the call to
    happen after all (refer to the following code example):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`cancel` 方法试图告诉系统我们最终不希望发生调用（参考以下代码示例）：'
- en: '![](img/2d1acd3f-7c47-4b19-8b6e-b1be11141176.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2d1acd3f-7c47-4b19-8b6e-b1be11141176.jpg)'
- en: This code example is not guaranteed to work because if a worker process has
    already begun a job, that job is no longer cancellable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码示例不能保证工作，因为如果工作进程已经开始了一个作业，那么这个作业就不再可取消了。
- en: If the job connected to a `future` object can't be cancelled, the `cancel` method
    returns `false`
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果与 `future` 对象连接的作业无法取消，`cancel` 方法返回 `false`。
- en: If the cancellation succeeded, the `cancel` method returns `true`
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果取消成功，`cancel` 方法返回 `true`。
- en: The `concurrent.futures` module is perfectly suited to farming out computational
    tasks to multiple processes to take advantage of the CPU power of multicore and
    multiprocessor computers. The `map`, `submit`, `wait`, and `as_completed` functions
    are usually all you need for that kind of task.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`concurrent.futures` 模块非常适合将计算任务分配给多个进程，以利用多核和多处理器计算机的 CPU 功率。对于这类任务，通常只需要
    `map`、`submit`、`wait` 和 `as_completed` 函数。'
- en: Using the multiprocessing packages
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多进程包
- en: In the previous section, we saw that the `concurrent.futures` package makes
    it very simple to farm out computational jobs to worker processes. If the program
    we need doesn't fit into the *send out jobs and collect the results* model, we're
    probably better off working at a somewhat lower level of abstraction.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了 `concurrent.futures` 包使得将计算作业分配给工作进程变得非常简单。如果所需的程序不适合 `发送作业并收集结果`
    模型，我们可能更倾向于在较低级别的抽象层面上工作。
- en: So, let's now move on to look at another package that helps us handle multiprocess
    programs that don't fit that model, but the pieces are only partly independent
    of each other. From time to time, they need to pass information between themselves,
    not just back to the controlling process. We can't do that with `concurrent.futures`
    because it just doesn't fit into the model that `concurrent.futures` uses to describe
    parallel processing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们继续看看另一个帮助我们处理不符合该模型的并发程序的包，但这些组件之间只有部分是相互独立的。它们时不时地需要在彼此之间传递信息，而不仅仅是返回到控制进程。我们不能用`concurrent.futures`来做这件事，因为它根本不适合`concurrent.futures`用来描述并行处理的模型。
- en: Alternatively, what if we need to be able to cancel a job after a worker process
    has started running it? Again, that doesn't fit the `concurrent.futures` model.
    The `concurrent.futures` model is powerful, but its power is based in simplicity
    and so it's not too hard to imagine scenarios it can't handle.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们需要在工作进程开始运行作业后能够取消作业，这又不符合`concurrent.futures`模型。`concurrent.futures`模型功能强大，但其强大之处在于其简单性，因此不难想象它无法处理的场景。
- en: When we need to build our own model of how parallel processing should work,
    we can use the `multiprocessing` module as the foundation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要构建自己的并行处理模型时，我们可以将`multiprocessing`模块作为基础。
- en: Process class in the multiprocessing module
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块中的进程类'
- en: The `multiprocessing` module contains a class called `Process` that represents
    the ability to run code in a separate process.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`multiprocessing`模块包含一个名为`Process`的类，它表示在单独的进程中运行代码的能力。'
- en: 'Probably the simplest way to use the `Process` class is to subclass it and
    override the `run` method, which is the entry point for code in the other process,
    as shown in this code example:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Process`类最简单的方法是将其子类化并重写`run`方法，这是其他进程中的代码的入口点，如以下代码示例所示：
- en: '![](img/acfdc246-1a84-427b-88e3-40cf06301d78.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acfdc246-1a84-427b-88e3-40cf06301d78.jpg)'
- en: In the preceding example, we created a specific kind of process that calculates
    some square numbers. Then, we created an instance and started running it. When
    we called `start`, the `multiprocessing` module did the necessary work to make
    sure that the `run` method was executed in a new process.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一种特定类型的进程，用于计算一些平方数。然后，我们创建了一个实例并开始运行它。当我们调用`start`时，`multiprocessing`模块执行了必要的工作，以确保`run`方法在新进程中执行。
- en: By the way, all of the warnings we discussed in the  `concurrent.futures` module
    section (*Using the concurrent.futures package*) about pickling and importing
    modules applies to the `multiprocessing` module as well. When it comes to moving
    data between processes and importing code, they work in the same way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，我们在`concurrent.futures`模块部分（使用`concurrent.futures`包）中讨论的所有关于序列化和导入模块的警告也适用于`multiprocessing`模块。当涉及到在进程之间移动数据和导入代码时，它们以相同的方式工作。
- en: So far, we haven't seen anything that we couldn't do better with `concurrent.futures`,
    but it changes when we start using **queues**, **pipes**, and **managers**. Let's
    have a look at them in detail.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有看到任何我们无法用`concurrent.futures`做得更好的事情，但当我们开始使用**队列**、**管道**和**管理器**时，情况就改变了。让我们详细看看它们。
- en: Queues
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 队列
- en: Queues are communication channels that are appropriate for one to many, many
    to one, and many to many communications between cooperating processes. Depending
    on how they're used, that makes them ideal for posting tasks to a worker process
    when we don't care which worker ends up doing the task and for collecting the
    results of multiple worker processes.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是适用于合作进程之间一对一、多对一和多对多通信的通信通道。根据它们的使用方式，这使得它们非常适合在不需要关心哪个工作进程最终执行任务时向工作进程发布任务，以及收集多个工作进程的结果。
- en: Any process can put a picklable object into a queue and any process can remove
    the next available object from the queue.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 任何进程都可以将可序列化的对象放入队列中，任何进程都可以从队列中移除下一个可用的对象。
- en: 'Queues are **First In First Out** (**FIFO**) data structures, which means that
    objects are removed from the queue in the same order that they''re added. The
    `JoinableQueue` class adds a method, which allows a process to wait until the
    queue has been emptied by other processes. OK, let''s take a closer look at `queue`
    objects:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 队列是**先进先出**（**FIFO**）数据结构，这意味着对象是从队列中以它们被添加的相同顺序被移除的。《JoinableQueue》类添加了一个方法，允许进程等待直到其他进程清空队列。好的，让我们更详细地看看`queue`对象：
- en: '![](img/f9b7dad3-fbba-429b-a5ff-6207cd0563f8.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f9b7dad3-fbba-429b-a5ff-6207cd0563f8.jpg)'
- en: 'Refer to the preceding code example; there are three methods that are primarily
    useful: `put`, `get`, and `get_nowait`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅前面的代码示例；有三个方法主要是有用的：`put`、`get` 和 `get_nowait`。
- en: When we call `put`, an object is placed at the back of the queue.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用 `put` 时，一个对象被放置在队列的后面。
- en: When we call `get`, an object is removed from the queue and returned, unless
    the queue is empty. If the queue is empty, the process that called `get` waits
    until it is able to remove and return an object, which will happen after some
    other process puts an object into the queue.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们调用 `get` 时，一个对象将从队列中移除并返回，除非队列是空的。如果队列是空的，调用 `get` 的进程将等待直到能够移除并返回一个对象，这将在其他进程将对象放入队列之后发生。
- en: When we call `get_nowait` on the other hand, it either removes and returns the
    object at the front of the queue or it raises a `q.empty` exception.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在另一端调用 `get_nowait` 时，它要么移除并返回队列前面的对象，要么引发一个 `q.empty` 异常。
- en: Finally, we could pass a `timeout` parameter to the `get` method, in which case
    it will either remove and return an object within that many seconds or raise `q.empty`.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们可以将 `timeout` 参数传递给 `get` 方法，在这种情况下，它将在那么多的秒内移除并返回一个对象，或者引发 `q.empty`。
- en: We could pass queue objects around between processes by making them part of
    the process's initial data, or by sending them through pre-existing queues or
    pipes, or even by storing them in a manager. Queues are designed to be shared
    between processes. Moving on, let's look at pipes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将队列对象作为进程初始数据的一部分，或者通过通过现有的队列或管道发送它们，甚至通过将它们存储在管理器中，在进程之间传递队列对象。队列被设计成可以在进程之间共享。继续前进，让我们看看管道。
- en: Pipes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道
- en: Pipes are one-to-one communication channels. When we call a pipe, we get back
    a pair of objects that each serve as one end of the communication stream. If we
    give one end each to a pair of processes, they could send messages and data back
    and forth through the pipe.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 管道是一对一的通信通道。当我们调用管道时，我们得到一对对象，每个对象都作为通信流的一端。如果我们将每一端给一对进程，它们可以通过管道来回发送消息和数据。
- en: 'Each end of the pipe has the same methods. The interesting methods are `send`,
    `recv`, and `poll`. Consider the following code example:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 管道的每一端都有相同的方法。有趣的方法是 `send`、`recv` 和 `poll`。考虑以下代码示例：
- en: '![](img/a68fdf21-ed42-4702-bfda-1438352943e0.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a68fdf21-ed42-4702-bfda-1438352943e0.jpg)'
- en: 'In the preceding code example, we see these:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们看到这些：
- en: The `send` method accepts an object as its parameter and sends it to the other
    endpoint.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`send` 方法接受一个对象作为其参数并将其发送到另一个端点。'
- en: The `recv` method waits for something to be sent from the other endpoint, and
    then returns it.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`recv` 方法等待从另一个端点发送来的数据，然后返回它。'
- en: The `poll` method returns `true` if there's an object way to be received and
    `false` if there is not.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`poll` 方法如果可以接收到的对象存在则返回 `true`，如果不存在则返回 `false`。'
- en: The `poll` method can accept a `timeout` parameter. If we give it a number for
    the timeout and there's not currently anything waiting to be received, the `poll`
    function will wait for up to that many seconds for data to arrive and then return
    `true`. If no data arrives before the timeout expires, the `poll` method will
    return `false`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll` 方法可以接受一个 `timeout` 参数。如果我们给它一个超时时间，并且当前没有等待接收的数据，`poll` 函数将等待最多那么多的秒数以等待数据到达，然后返回
    `true`。如果在超时到期之前没有数据到达，`poll` 方法将返回 `false`。'
- en: If we pass `None` as the `poll` method's `timeout` parameter, it will wait until
    data arrives before returning, no matter how long it takes. Like queue objects,
    pipe endpoints can be sent to other processes as they're launched or through other
    queues, pipes, and so on after the process is running.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `None` 作为 `poll` 方法的 `timeout` 参数传递，它将在返回之前等待数据到达，无论需要多长时间。像队列对象一样，管道端点可以在进程启动时或运行后通过其他队列、管道等发送给其他进程。
- en: Using queues and pipes as the only connection between the processes is usually
    considered best because this maximizes the ability of the processes to work in
    parallel.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通常认为使用队列和管道作为进程之间唯一的连接是最好的，因为这最大化了进程并行工作的能力。
- en: If it's possible to organize a parallel program that way, it should be. If we
    find that we need to share some variables between several processes though, we
    can do it using a `Manager` object. Let's look at manager now.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有可能以那种方式组织并行程序，那么应该这样做。如果我们发现需要在几个进程之间共享一些变量，我们可以使用 `Manager` 对象来实现。现在让我们看看管理器。
- en: Manager
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理器
- en: A manager represents a special process with only one job-keeping track of the
    variables that other processes need.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 管理器代表一个具有单一任务的特殊进程——跟踪其他进程需要的变量。
- en: Accessing variables stored in a manager is much slower than accessing a process's
    local variables and it could lead to situations where processes trying to access
    variables at the same time slow each other down. On the other hand, if we actually
    need shared variables, at least the manager handles them correctly and as efficiently
    as possible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 访问存储在管理者中的变量比访问进程的局部变量要慢得多，这可能导致尝试同时访问变量的进程相互减慢。另一方面，如果我们确实需要共享变量，至少管理者能够正确且尽可能高效地处理它们。
- en: Now, managers can handle many types of data, but we're going to focus on their
    ability to store **dictionaries**, **lists**, and **namespaces**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，管理者可以处理许多类型的数据，但我们将关注它们存储 **字典**、**列表** 和 **命名空间** 的能力。
- en: Normally, when we send an object to another process, the other process actually
    gets a copy of that object; this means if the other process changes the object
    it receives, we don't see those changes in the original process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们把一个对象发送到另一个进程时，另一个进程实际上得到该对象的一个副本；这意味着如果另一个进程改变了它接收到的对象，我们不会在原始进程中看到这些变化。
- en: 'A manager lets us create objects that behave more like queues in that, if we
    send the object to another process and that process changes the object, we do
    see the changes in the original process or any other process that has access to
    the object. Consider this code example:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 管理者让我们能够创建更类似队列的对象，如果我们把对象发送到另一个进程，并且该进程改变了对象，我们确实会在原始进程或任何其他可以访问该对象的进程中看到这些变化。考虑以下代码示例：
- en: '![](img/b9f18527-af52-4092-b5e2-e7ed732799f3.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b9f18527-af52-4092-b5e2-e7ed732799f3.jpg)'
- en: The `manager.dict()` and `manager.list()` methods in the preceding code example
    create special dictionaries or lists that could be shared between processes. The
    `Namespace` method, which does indeed start with a capital `N`, creates a more
    generic shared object on which we can set attributes to share them between processes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，`manager.dict()` 和 `manager.list()` 方法创建了一些特殊的字典或列表，这些字典或列表可以在进程之间共享。`Namespace`
    方法确实以大写 `N` 开头，它创建了一个更通用的共享对象，我们可以在其中设置属性以在进程之间共享。
- en: When we have shared data that is being accessed by multiple streams of execution,
    which is exactly what manager provides, we have to be careful to keep the data
    access synchronized. To help with that, managers can also create some standard
    synchronization primitives, such as **locks**, **events**, **conditions**, and
    **semaphores**.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们拥有多个执行流正在访问共享数据时，这正是管理者提供的，我们必须小心保持数据访问的同步。为了帮助做到这一点，管理者还可以创建一些标准的同步原语，例如
    **锁**、**事件**、**条件** 和 **信号量**。
- en: The lock object
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁对象
- en: 'Lock objects are the simplest of the synchronization tools. They have a pair
    of methods called `acquire` and `release`, as shown in the following code example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 锁对象是同步工具中最简单的。它们有一对方法称为 `acquire` 和 `release`，如下面的代码示例所示：
- en: '![](img/2c60f959-8294-44be-92af-dbc13647b3e7.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2c60f959-8294-44be-92af-dbc13647b3e7.jpg)'
- en: After a process calls `acquire`, any other process that calls `acquire` is forced
    to wait until the first process calls `release`. Then, the `acquire` call in one
    of the waiting processes returns, allowing that process to proceed. In other words,
    code between an `acquire` call and `release` call can count on being the only
    code accessing whatever data the `lock` object is protecting.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个进程调用 `acquire` 后，任何其他调用 `acquire` 的进程都必须等待，直到第一个进程调用 `release`。然后，等待进程中的一个
    `acquire` 调用返回，允许该进程继续执行。换句话说，在 `acquire` 调用和 `release` 调用之间的代码可以确信是唯一访问 `lock`
    对象所保护数据的代码。
- en: Notice that the `lock` object doesn't know what data it's protecting. It's up
    to us as programmers to define and respect that association in our own minds.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`lock` 对象并不知道它保护什么数据。这取决于我们作为程序员在自己的脑海中定义并尊重这种关联。
- en: The event object
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件对象
- en: Event objects allow a process to proceed immediately if a flag is `true` or
    wait until the flag becomes `true`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象允许进程在标志为 `true` 时立即继续，或者等待标志变为 `true`。
- en: 'The flag is set to `false` by calling the `event.clear` method or `true` by
    calling its `event.set` method, as shown in this code example:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `event.clear` 方法将标志设置为 `false` 或通过调用其 `event.set` 方法将其设置为 `true`，如下面的代码示例所示：
- en: '![](img/b6ddd297-0f66-4310-92e6-ad047ed3bc20.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b6ddd297-0f66-4310-92e6-ad047ed3bc20.jpg)'
- en: When we call the `event.wait` method, it will return immediately if the flag
    is `true` else it will pause execution until another process calls `set` and then
    return.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `event.wait` 方法时，如果标志为 `true`，它将立即返回；否则，它将暂停执行，直到另一个进程调用 `set` 并然后返回。
- en: Event objects are useful for making a process pause until some specific thing
    happens.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 事件对象对于使进程暂停，直到某个特定事件发生非常有用。
- en: The condition object
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件对象
- en: The condition objects combine some of the features of `lock` and `event` objects.
    Like a `lock`, they have `acquire` and `release` methods that can be used to protect
    data from simultaneous access.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 条件对象结合了`lock`和`event`对象的一些特性。像`lock`一样，它们有`acquire`和`release`方法，可以用来保护数据免受同时访问。
- en: 'However, a `condition` object also has a `wait` method and a `notify` method,
    which can be used to wait until some other process does something and to wake
    up a waiting process as shown in the following code example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`condition`对象还有一个`wait`方法和一个`notify`方法，可以用来等待直到其他进程执行某些操作，并唤醒一个等待的进程，如下面的代码示例所示：
- en: '![](img/da130d6e-6844-4625-acac-7ceb901e14ec.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da130d6e-6844-4625-acac-7ceb901e14ec.jpg)'
- en: Condition objects are useful for creating data structures that synchronize access
    to their contents and wait when they don't have any data to return. The `get`
    and `put` methods of the `queue` class could be implemented using a `condition`
    object.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 条件对象对于创建同步访问其内容的数据结构以及在它们没有数据返回时等待非常有用。`queue`类的`get`和`put`方法可以使用条件对象来实现。
- en: The semaphore object
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`semaphore`对象'
- en: The `semaphore` objects look a lot like `lock` objects. The difference is that,
    where the `lock` objects always ensured that exactly one process has acquired
    the lock at a given time, `semaphore` objects ensure that no more than a fixed
    number of processes can acquire it at the same time.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`semaphore`对象看起来与`lock`对象非常相似。区别在于，`lock`对象总是确保在给定时间只有一个进程获取了锁，而`semaphore`对象确保不会超过固定数量的进程同时获取它。'
- en: 'This can be seen using the following code example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下代码示例来查看：
- en: '![](img/8333a564-780c-4c21-b85f-ca4a10dfe265.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8333a564-780c-4c21-b85f-ca4a10dfe265.jpg)'
- en: This is useful for doing things such as limiting the number of worker processes
    that can access the hard disk at the same time.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于执行诸如限制同时访问硬盘的工作进程数量等操作非常有用。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use `concurrent.futures` to make a particularly
    common multiprocess case extremely simply. We also saw how to use the `multiprocessing`
    package to define what worker processes do and how they interact.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用`concurrent.futures`模块使一个特别常见的多进程案例变得极其简单。我们还看到了如何使用`multiprocessing`包来定义工作进程执行的操作以及它们如何交互。
- en: So, now we know quite a lot about how to help CPU-bound programs take advantage
    of multicore and multiprocessor hardware to run faster. Most programs aren't CPU-bound
    though, they're I/O-bound, which means they spend most of their time waiting for
    input from various sources. Parallel processing doesn't help in that situation,
    but asynchronous I/O does, and that's the topic for our next chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们相当了解如何帮助CPU密集型程序利用多核和多处理器硬件来运行得更快。尽管如此，大多数程序并不是CPU密集型的，它们是I/O密集型的，这意味着它们大部分时间都在等待来自各种来源的输入。在这种情况下，并行处理没有帮助，但异步I/O可以，这是我们下一章的主题。
