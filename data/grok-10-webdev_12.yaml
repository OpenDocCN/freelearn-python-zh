- en: Chapter 11. Key Concepts Behind Grok
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. Grok背后的关键概念
- en: In the first chapter of this book, we discussed the features of Grok, placing
    a strong emphasis on the importance of the **Zope Toolkit** (**ZTK**) and the
    **Zope Component Architecture** (**ZCA**). We also mentioned that Grok offers
    an agile way of using these.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们讨论了Grok的特点，强调了**Zope工具包**（**ZTK**）和**Zope组件架构**（**ZCA**）的重要性。我们还提到Grok提供了一种敏捷的方式来使用这些工具。
- en: Throughout the preceding chapters, we used several ZTK packages and employed
    many ZCA patterns, introducing and explaining them, whenever needed. We also saw
    how agile Grok can be, as we grew our application bit by bit, while having a fully
    functional application from the very beginning.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们使用了几个ZTK包，并采用了许多ZCA模式，在需要时介绍和解释它们。我们还看到了Grok如何敏捷，因为我们逐步增长我们的应用程序，同时从一开始就拥有一个功能齐全的应用程序。
- en: With the material that we have covered so far, it's possible to create fairly
    complex applications, but to really get the most out of Grok, the concepts behind
    the ZCA and the tools that provide Grok's agility have to be explained at a more
    detailed level.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 就目前为止我们所覆盖的材料而言，我们可以创建相当复杂的应用程序，但要真正充分利用Grok，就必须在更详细的层面上解释ZCA背后的概念以及提供Grok灵活性的工具。
- en: Although a full explanation of the ZCA and its patterns is beyond the scope
    of this book, this chapter will at least discuss its more important concepts and
    show their utility through small additions and extensions to our to-do list application.
    The author believes that it's easier to understand these concepts once we have
    seen practical examples of their use at work, which we can refer to when explaining
    them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ZCA及其模式的完整解释超出了本书的范围，但本章至少将讨论其更重要的概念，并通过对我们待办事项应用的小幅增加和扩展来展示它们的实用性。作者认为，一旦我们看到了这些概念在实际应用中的使用实例，我们就可以在解释它们时参考。
- en: 'In this chapter, we will look at these concepts in detail. In particular, we''ll
    discuss:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细探讨这些概念。特别是，我们将讨论：
- en: What the ZCA is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ZCA是什么
- en: Interfaces
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Adapters, utilities, and events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器、实用工具和事件
- en: Application extension through events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过事件扩展应用程序
- en: Application extension through adaptation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过适配器扩展应用程序
- en: The Zope Component Architecture
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zope组件架构
- en: Many agile web application frameworks were designed specifically to allow a
    quick turnaround from idea to working application. This is a good thing, but sometimes
    the emphasis on fast development cycles results in a little less attention being
    paid to things such as extensibility and code reuse. In contrast, Grok is based
    on a set of patterns whose primary concern is the maintainability and extensibility
    of applications. In fact, Grok applications can be extended even from the outside,
    without the need to touch their code. The set of patterns that allows this is
    known as the **Zope Component Architecture**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 许多敏捷的Web应用程序框架被设计成专门允许从想法到工作应用程序的快速转换。这是好事，但有时对快速开发周期的强调会导致对可扩展性和代码重用等事物的关注减少。相比之下，Grok基于一系列模式，其主要关注点是应用程序的可维护性和可扩展性。实际上，Grok应用程序甚至可以从外部扩展，而无需接触它们的代码。允许这种扩展的模式集被称为**Zope组件架构**。
- en: Even though the word "Zope" is in its name, the ZCA is a set of general Python
    packages that can be used to create component-based applications, independent
    of the Zope web application server or the ZTK. In fact, we could use the ZCA to
    create any kind of Python application, and it's especially suited to the development
    of large systems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Zope这个词出现在它的名字中，但ZCA是一组通用的Python包，可以用来创建基于组件的应用程序，独立于Zope网络应用程序服务器或ZTK。实际上，我们可以使用ZCA来创建任何类型的Python应用程序，并且它特别适合于大型系统的开发。
- en: The ZCA works by encapsulating the functionality of a Python object into an
    entity called a **component**, which has a well-defined behavior that can be described
    by using a separate object, known as an **interface**. The interface helps the
    developer to find out how to use a given component, or even replace it wholesale
    by implementing all of the functionality expressed therein.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ZCA通过将Python对象的功能封装到一个称为**组件**的实体中来工作，该组件具有由一个称为**接口**的单独对象定义的良好行为，该接口有助于开发者了解如何使用给定的组件，甚至可以通过实现其中表达的所有功能来完全替换它。
- en: Because the concept of breaking up the functionality of a system into multiple
    components requires the developer to keep track of a potentially large number
    of components, the ZCA offers a registry that can register and retrieve components
    based on their interfaces. This is truly the key part of the Zope Component Architecture,
    as working with it mainly consists of interacting with the registry in various
    ways.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将系统的功能拆分为多个组件的概念需要开发者跟踪大量可能的组件，ZCA 提供了一个注册表，可以根据它们的接口注册和检索组件。这确实是 Zope 组件架构的关键部分，因为与之交互主要涉及以各种方式与注册表交互。
- en: Interfaces
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: We introduced 'interfaces' in Chapter 5, when we used them for automatically
    generating forms. In that chapter, we explained that an interface is used to document
    the external behavior of objects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第 5 章中介绍了“接口”，当时我们使用它们来自动生成表单。在第 5 章中，我们解释了接口用于记录对象的外部行为。
- en: An object that has its functionality defined in an interface is said to *provide*
    this interface. The interface defines what an object can do, but how the object
    internally complies with this contract is entirely decided by the implementor.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在接口中定义其功能的对象被称为 *提供* 该接口。接口定义了一个对象可以做什么，但对象如何内部遵守此协议完全由实现者决定。
- en: Interfaces in the ZCA are used to register and find components in the registry.
    This allows us to find components on the basis of what they do, and easily replace,
    extend, or override a specific functionality in an application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ZCA 中的接口用于在注册表中注册和查找组件。这使得我们能够根据组件的功能来查找它们，并轻松地替换、扩展或覆盖应用程序中的特定功能。
- en: When a class includes the functionality described in an interface, it is said
    to *implement* that interface. The interface is independent of the class, though.
    One specific interface may be implemented by any number of classes. In addition,
    a class can implement any number of interfaces.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类包含接口中描述的功能时，它就被说成是 *实现* 该接口。尽管如此，接口是独立于类的。一个特定的接口可能被任何数量的类实现。此外，一个类可以实现任何数量的接口。
- en: 'Let''s take a look at the interface that we defined in Chapter 6, to make the
    projects, lists, and items searchable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第 6 章中定义的接口，以便使项目、列表和条目可搜索：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: An interface is a class that subclasses the `Interface` class defined in the
    `zope.interface` package. The `ISearchable` interface describes the attributes
    and methods that a searchable object must provide. Similar to our to-do list application,
    we may have several different content types, but as long as all of their class
    definitions promise to implement `ISearchable`, we can use the same search code
    on them without problems.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接口是一个类，它继承自 `zope.interface` 包中定义的 `Interface` 类。`ISearchable` 接口描述了一个可搜索对象必须提供的属性和方法。类似于我们的待办事项列表应用程序，我们可能有几种不同的内容类型，但只要它们的类定义承诺实现
    `ISearchable`，我们就可以在它们上面使用相同的搜索代码而不会出现问题。
- en: Notice how the `searchableText` method definition does not contain the `self`
    parameter that is used in Python classes. That's because although the interface
    documents the methods, it will never be instantiated itself, and so `self` is
    not required here.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到 `searchableText` 方法定义中不包含 Python 类中使用的 `self` 参数。这是因为尽管接口记录了方法，但它永远不会被实例化，因此在这里不需要
    `self`。
- en: 'Once we have defined an interface, we can create the classes that implement
    it. In our application, the `ISearchable` interface is implemented by several
    classes. For example, here''s how the `Project` content type declares its intention
    of abiding by the `ISearchable` contract:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个接口，我们就可以创建实现它的类。在我们的应用程序中，`ISearchable` 接口由几个类实现。例如，以下是 `Project` 内容类型如何声明其遵守
    `ISearchable` 协议的意图：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In Grok, we use the `implements` class annotation to declare that a class implements
    one or more interfaces. We can see that, in addition to `ISearchable`, the `Project`
    class also implements `IProject` and `IMetadata`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Grok 中，我们使用 `implements` 类注解来声明一个类实现了一个或多个接口。我们可以看到，除了 `ISearchable`，`Project`
    类还实现了 `IProject` 和 `IMetadata`。
- en: Once we create an actual `Project` object, it is said to *provide* `ISearchable`,
    which means that classes implement interfaces, and instances of those classes
    provide them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了一个实际的 `Project` 对象，它就被说成是 *提供* `ISearchable`，这意味着类实现接口，而这些类的实例提供了它们。
- en: 'An interface can also be used to define schemata for form generation. We have
    used this a lot throughout our application''s code. Here''s an example:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也可以用来定义表单生成的模式。我们在整个应用程序代码中大量使用了这种方法。以下是一个示例：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We already saw that by using the `grok.AutoFields` directive, we can turn this
    schema definition into HTML controls on a form.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，通过使用 `grok.AutoFields` 指令，我们可以将此模式定义转换为表单上的 HTML 控件。
- en: Because interfaces are used as keys in the component registry, it's possible
    to find all of the objects that implement an interface. This comes in handy for
    finding objects belonging to some type, but can also be used for more interesting
    things, such as creating methods that work only with objects that provide an interface,
    or components that extend the functionality of any class that implements it.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于接口在组件注册表中用作键，因此可以找到实现该接口的所有对象。这对于找到属于某些类型的对象非常有用，但也可以用于更有趣的事情，例如创建仅与提供接口的对象一起工作的方法，或者扩展实现它的任何类的功能。
- en: This is generally useful when no special functionality needs to be defined for
    some interface, so sometimes we can come across empty interface definitions, known
    as **marker interfaces**. They basically mark an object as belonging to a certain
    type, which allows the registry to find them and register other components to
    work with them. We have not needed them so far in our application, but they can
    be a very useful addition to our arsenal.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常在不需要为某些接口定义特殊功能时很有用，因此有时我们可能会遇到空接口定义，称为**标记接口**。它们基本上将对象标记为属于某个类型，这使得注册表可以找到它们并将其他组件注册为与它们一起工作。到目前为止，在我们的应用程序中我们还没有需要它们，但它们可以是我们工具箱中非常有用的补充。
- en: Adapters
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: One of the principles of the ZCA is to use components instead of inheritance
    for extending application behavior, so that we can interconnect different components
    with each other to get the desired result.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ZCA 的一个原则是使用组件而不是继承来扩展应用程序的行为，这样我们就可以将不同的组件相互连接，以获得所需的结果。
- en: 'This approach requires three things:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法需要三件事：
- en: Well-defined components, which is why we use interfaces. They mark a component
    as providing a specific behavior and also offer a sort of blueprint or contract
    for that functionality.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确定义的组件，这就是我们使用接口的原因。它们将组件标记为提供特定的行为，并为该功能提供一种蓝图或合同。
- en: An easy way to keep track of multiple components. We already mentioned that
    the ZCA has a registry, and that interfaces are used as keys to retrieve the components
    according to their defined functionality. This also makes possible the complete
    replacement of a component for an entirely different one as long as it implements
    the same interface.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪多个组件的简单方法。我们已经提到 ZCA 有一个注册表，接口被用作键来根据其定义的功能检索组件。这也使得可以完全替换一个组件为完全不同的一个，只要它实现了相同的接口。
- en: A way to make disparate components work together even if they have completely
    different interfaces. That's where adapters come in.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种使不同接口的组件协同工作的方式，即使它们具有完全不同的接口。这就是适配器发挥作用的地方。
- en: An **adapter** is simply a piece of code that takes an object with a certain
    interface and makes it provide an additional interface. In other words, it adapts
    the component, so that it offers new behavior, without requiring any change in
    its code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器**简单地说是一段代码，它接受具有特定接口的对象，并使其提供额外的接口。换句话说，它适应了组件，使其提供新的行为，而无需对其代码进行任何更改。'
- en: Real-world adapters
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现实世界的适配器
- en: It may be helpful to think of this in terms of real-world objects. Nowadays,
    cellphones are ubiquitous, and many people depend on them for their communication
    needs. However, they have a pretty short battery life and need constant recharging.
    When we buy a new cellphone, we usually get an AC adapter, which allows us to
    plug the phone into any wall outlet and charge it. In some cases, we may not have
    access to a wall outlet, for example, during a long car trip. In such a situation,
    we can of course get a car adapter to charge the phone by using the vehicle's
    power outlet.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 将其视为现实世界中的物体可能会有所帮助。如今，手机无处不在，许多人依赖它们来满足他们的通信需求。然而，它们的电池寿命相当短，需要不断充电。当我们购买一部新手机时，我们通常会得到一个交流适配器，这允许我们将手机插入任何墙壁插座并为其充电。在某些情况下，我们可能无法使用墙壁插座，例如，在长途汽车旅行期间。在这种情况下，我们当然可以使用车载适配器，通过使用车辆的电源插座来为手机充电。
- en: Adapters for the ZCA are very similar to these phone adapters. They adapt a
    power source, be it the car or the wall outlet, and make it present in a different
    interface that can be used by the phone to get charged. Neither the power source
    nor the phone are changed in the least, or even need to know anything about the
    specific adapter used, as long as they conform to the established power and phone
    connection interfaces (now you see where the terminology came from).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ZCA的适配器与这些电话适配器非常相似。它们适配电源，无论是汽车还是插座，并使其以不同的接口呈现，以便手机可以充电。电源和手机都不会有任何改变，甚至不需要了解所使用的特定适配器的任何信息，只要它们符合既定的电源和手机连接接口（现在你明白术语的来源了）。
- en: Defining and using an adapter
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义和使用适配器
- en: 'Up to now, we have not explicitly defined or used an adapter, so let''s take
    a quick look at how we would do this in Grok. Suppose that we want to show the
    number of days elapsed since the last modification to any content in our to-do
    list application. If we add the methods to each content type, we''ll have a lot
    of repeated code, and any change to one method''s logic would require making a
    change to all of the content types. By using an adapter, we get all of the code
    in one place, as shown below:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们尚未明确定义或使用适配器，所以让我们快速看一下在Grok中如何进行此操作。假设我们想要显示待办事项列表应用程序中任何内容上次修改过去的天数。如果我们为每种内容类型添加方法，我们将有很多重复的代码，并且任何对某个方法逻辑的更改都需要对所有内容类型进行更改。通过使用适配器，我们可以在一个地方获得所有代码，如下所示：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: First, we define the interface for our 'day' calculation methods. We'll keep
    it simple, for demonstration purposes. The `grok.Adapter` component is used to
    define an adapter. We create one, and use the `grok.implements` directive to signal
    that it will implement the methods that we just defined in our interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义我们的“天”计算方法的接口。为了演示目的，我们将保持其简单性。`grok.Adapter`组件用于定义适配器。我们创建了一个适配器，并使用`grok.implements`指令来表示它将实现我们在接口中刚刚定义的方法。
- en: All of the content in our application already implements the `ISearchable` interface,
    so to make every to-do application object provide this interface, we use the `grok.adapts`
    directive. Thus, `DaysOld` is an adapter that takes any object that provides `ISearchable`,
    and provides `IDayCalculations` for it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的所有内容已经实现了`ISearchable`接口，因此为了使每个待办事项应用程序对象都提供此接口，我们使用`grok.adapts`指令。因此，`DaysOld`是一个适配器，它接受任何提供`ISearchable`的对象，并为它提供`IDayCalculations`。
- en: The adapter instance will have both the `context` and the `request` attributes.
    This is because an adapter always receives, as parameters, the things that it
    adapts, in order to be able to get at their properties and use them in the implementation.
    In this example, `self.context` refers to the adapted `context` object, which
    can be a `TodoList`, a `Project`, a `TodoListItem`, and so on. As all of these
    objects implement `ISearchable`, we know that `modification_date` and `creation_date`
    will be available for the calculations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器实例将同时具有`context`和`request`属性。这是因为适配器总是接收它所适配的对象作为参数，以便能够访问它们的属性并在实现中使用它们。在这个例子中，`self.context`指的是被适配的`context`对象，它可以是`TodoList`、`Project`、`TodoListItem`等。由于所有这些对象都实现了`ISearchable`接口，我们知道`modification_date`和`creation_date`将可用于计算。
- en: 'We could use this adapter inside any view for one of our content types, in
    the following way:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下方式中使用此适配器在我们的内容类型之一的任何视图中：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, we use the `update` method to insert the `days_modified` and
    `days_old` properties into the view, so that they will be available to the view
    template, when it's rendered. To get the adapter from the registry, we call the
    `IDayCalculations` interface itself, with the `context` object as parameter, which
    in this case is a `Project`. Once we have the adapter, we can simply call its
    methods, and it will behave as if these methods are a part of the `Project` component.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`update`方法将`days_modified`和`days_old`属性插入到视图中，以便在渲染时它们将可用于视图模板。要从注册表中获取适配器，我们调用`IDayCalculations`接口本身，并将`context`对象作为参数，在这种情况下是一个`Project`。一旦我们有了适配器，我们就可以简单地调用它的方法，它将表现得好像这些方法是`Project`组件的一部分。
- en: When first getting to know them, adapters might seem to be sort of a roundabout
    way of getting to the component that we need, but bear in mind that this whole
    system is designed for easy expansion and evolution. By using adapters, we could
    override components from within other packages and still have the system work
    fine without needing to modify the original code in any way.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当刚开始了解它们时，适配器可能看起来是一种绕弯路的方式来获取我们需要的组件，但请记住，整个系统都是为了易于扩展和进化而设计的。通过使用适配器，我们可以在其他包内部覆盖组件，同时系统仍然可以正常工作，无需以任何方式修改原始代码。
- en: Adapters that we have used in our application
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们在应用程序中使用的适配器
- en: For adapters to be used in Grok, they first need to be registered with the ZCA.
    Grok itself performs a number of registrations when the application is started.
    In fact, we have used these already in our code. In Chapter 7, we added authentication
    to our application and we decided to add specific roles to every new user that
    was created, to simplify permission management.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Grok中使用适配器，它们首先需要注册到ZCA中。Grok本身在应用程序启动时会执行一系列注册。实际上，我们已经在代码中使用了这些。在第7章中，我们向我们的应用程序添加了身份验证，并决定为每个新创建的用户添加特定的角色，以简化权限管理。
- en: 'A Grok site knows nothing about role assignment, so to be able to define roles
    for a principal, it uses a role manager. This **role manager** is an adapter that
    enables the site to provide the role manager interface. Take a look at the code
    that we used:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Grok站点对角色分配一无所知，因此为了能够为某个主体定义角色，它使用了一个角色管理器。这个**角色管理器**是一个适配器，它使得站点能够提供角色管理器接口。看看我们使用的代码：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we are adding a new user, and immediately after that, we are assigning
    a role to the user. As we mentioned earlier, the site delegates this responsibility
    to a role manager. The role manager is an adapter that is registered as implementing
    the `IPrincipalRoleManager` interface for Grok sites, so we need to query the
    registry with this information to get the actual manager. The line that does this
    is:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在添加一个新用户，紧接着我们就为该用户分配了一个角色。正如我们之前提到的，站点将这项责任委托给角色管理器。角色管理器是一个适配器，它注册为实现了Grok站点的`IPrincipalRoleManager`接口，因此我们需要使用这些信息查询注册表以获取实际的经理。执行此操作的行是：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The interface itself performs the registry lookup, asking for a component that
    is registered for providing it to objects that implement the Grok site interface.
    Note that the Grok site itself is passed in as a parameter and not its interface,
    but the ZCA is smart enough to find the correct component, if it's registered.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口本身执行注册查找，请求一个已注册的组件，并将其提供给实现Grok站点接口的对象。请注意，Grok站点本身作为参数传递，而不是其接口，但ZCA足够智能，能够找到正确的组件，如果它已注册。
- en: In this case, the query gets us a role manager object that implements the `IPrincipalRoleManager`
    interface, so that we know that the `assignRoleToPrincipal` method will be available
    to assign the correct role to our new user.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，查询为我们提供了一个实现`IPrincipalRoleManager`接口的角色管理器对象，因此我们知道`assignRoleToPrincipal`方法将可用于为我们的新用户分配正确的角色。
- en: 'Adapters can be named, so that we could use its name to get a specific `IPrincipalRoleManager`
    component. Also, it''s possible for an adapter to adapt more than one component
    at the same time, in which case, it''s called a **multiadapter**. For example,
    all of the views in Grok are multiadapters for a request and a context:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器可以被命名，这样我们就可以通过它的名字来获取一个特定的`IPrincipalRoleManager`组件。此外，一个适配器同时适配多个组件也是可能的，在这种情况下，它被称为**多适配器**。例如，Grok中的所有视图都是请求和上下文的多适配器：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The context is specified in the class body by using the `grok.context` directive,
    and the request refers to the current browser request. In the preceding code,
    `TodoListUpdateItems` is a multiadapter for a request and a `TodoList`. It uses
    the name `updateitems`. This multiadapter/view will be called by Grok only when
    the user requests the `updateitems` view while browsing through a `TodoList` object.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文通过`grok.context`指令在类体中指定，请求指的是当前的浏览器请求。在前面的代码中，`TodoListUpdateItems`是一个请求和一个`TodoList`的多适配器。它使用名称`updateitems`。这个多适配器/视图只有在用户在浏览`TodoList`对象时请求`updateitems`视图时，才会被Grok调用。
- en: 'We have also used multiadapters explicitly in our to-do list manager code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在我们的待办事项列表管理器代码中明确使用了多适配器：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In Chapter 8, we showed how to get a form that is rendered inside a viewlet,
    and saw that we needed to get at the specific component that creates that specific
    form. Here, the registry lookup is performed by the `getMultiAdapter` method,
    which is imported from `zope.component`. We specifically want the 'add form' for
    a project, because we want to render the `AddProjectViewlet`. We know that we
    have a request and that the context is a `Todo` application, due to the `grok.context`
    directive above, so if we call `getMultiAdapter` and pass the request and the
    context along with the name of the required form, the ZCA machinery will find
    it for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们展示了如何获取在视图组件中渲染的表单，并看到我们需要获取创建该特定表单的特定组件。在这里，注册表查找是通过从`zope.component`导入的`getMultiAdapter`方法执行的。我们特别想要一个项目的“添加表单”，因为我们想要渲染`AddProjectViewlet`。由于上面的`grok.context`指令，我们知道我们有一个请求，上下文是一个`Todo`应用程序，因此如果我们调用`getMultiAdapter`并传递请求、上下文以及所需表单的名称，ZCA机制将为我们找到它。
- en: Utilities
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实用程序
- en: As we have seen, the component registry mainly consists of adapters that are
    registered to specific interfaces. In some cases, it's also useful to register
    components that do not adapt anything, but provide some sort of service that we
    need to be able to override or replace. A database connection, an authentication
    backend, and a user source are examples of this.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，组件注册表主要是由注册到特定接口的适配器组成。在某些情况下，注册不适应任何东西但提供我们需要能够覆盖或替换的某种服务也是很有用的。数据库连接、身份验证后端和用户源就是这类服务的例子。
- en: The ZCA has the concept of a utility to cover this case. A **utility** is simply
    a component with a declared interface, which may also have a name. Utilities in
    the ZCA can be either local or global.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ZCA有概念来覆盖这种情况。**实用程序**只是一个具有声明接口的组件，它也可能有一个名称。ZCA中的实用程序可以是本地的也可以是全局的。
- en: Global utilities
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局实用程序
- en: A **global utility** is the one that is created and registered when Grok is
    started, but which is not persistent (that is, its state is not saved in the ZODB).
    Examples of global utilities that we have used include database connections and
    session credentials.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局实用程序**是在Grok启动时创建和注册的，但它不是持久的（也就是说，其状态没有保存在ZODB中）。我们使用过的全局实用程序的例子包括数据库连接和会话凭证。'
- en: 'Let''s take a look at the utility that we added in Chapter 7, when we integrated
    authentication services into our application:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看第7章中我们集成到应用程序中的身份验证服务时添加的实用程序：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To define a global utility, we inherit from the `grok.GlobalUtility` component
    and declare the interface provided by the component, by using the `grok.provides`
    directive. Named utilities also need to use the `grok.name` directive to register
    their names.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义全局实用程序，我们继承自`grok.GlobalUtility`组件，并通过使用`grok.provides`指令声明组件提供的接口。命名实用程序也需要使用`grok.name`指令来注册它们的名称。
- en: 'To get a global utility from the registry, we use the `getUtility` function
    defined in `zope.component`. In this case, the `credentials` utility is not called
    directly by our code, but by the authentication mechanism itself. However, if
    we wanted to use this utility, we would get it as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要从注册表中获取全局实用程序，我们使用`zope.component`中定义的`getUtility`函数。在这种情况下，`credentials`实用程序不是直接由我们的代码调用，而是由身份验证机制本身调用。然而，如果我们想使用这个实用程序，我们会像以下这样获取它：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Local utilities
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地实用程序
- en: A **local utility** is very similar to a global utility, but it gets saved in
    the database, so that its state and configuration are persistent. The Zope Toolkit
    catalog and the pluggable authentication mechanism used in our application are
    both examples of local utilities.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地实用程序**与全局实用程序非常相似，但它会被保存在数据库中，因此其状态和配置是持久的。Zope Toolkit目录和我们在应用程序中使用的可插拔身份验证机制都是本地实用程序的例子。'
- en: 'We can take a look at the `UserAuthenticatorPlugin` that we defined in Chapter
    7, to see how to define a local utility:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查看第7章中定义的`UserAuthenticatorPlugin`，以了解如何定义本地实用程序：
- en: '[PRE11]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see that this works exactly the same way as a global utility does, except
    that we inherit from `grok.LocalUtility` instead. However, we can''t actually
    use a local utility until we explicitly add it to a `grok.Container` component.
    Take a look at the main application component for the `Todo` application:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这与全局实用程序的工作方式完全相同，只是我们继承自`grok.LocalUtility`而不是它。然而，我们实际上不能使用本地实用程序，除非我们明确将其添加到`grok.Container`组件中。看看`Todo`应用程序的主应用程序组件：
- en: '[PRE12]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our application contains two local utilities. There is a `UserAuthenticatorPlugin`
    utility, which is named, as we may want to work with several user sources. There
    is also a `PluggableAuthentication` utility, which will handle all of the authentication
    needs for our site, and thus does not need to be differentiated from other similar
    utilities by name.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序包含两个本地实用工具。有一个名为 `UserAuthenticatorPlugin` 的实用工具，因为我们可能需要与多个用户源一起工作。还有一个名为
    `PluggableAuthentication` 的实用工具，它将处理我们网站的认证需求，因此不需要通过名称与其他类似实用工具区分开来。
- en: In fact, our application also contains a third local utility, the "Catalog",
    which is added automatically by Grok upon application creation. The Catalog is
    not a named utility.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们的应用程序还包含第三个本地实用工具，即“目录”，它在应用程序创建时由 Grok 自动添加。目录不是一个命名实用工具。
- en: 'To work with any of these utilities, we use the same `getUtility` function
    that we used for our global utility:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些实用工具之一，我们使用与我们的全局实用工具相同的 `getUtility` 函数：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One very important thing to keep in mind about local utilities is that, because
    they are added at an application's creation time and stored in the database, changing
    the initialization code of one will have no effect once the application is created.
    The easiest way to get a modified local utility to work, in this case, is to delete
    the application instance and create it again.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本地实用工具的一个重要注意事项是，由于它们是在应用程序创建时添加并存储在数据库中的，因此更改一个实用工具的初始化代码在应用程序创建后不会有任何效果。在这种情况下，使修改后的本地实用工具工作最简单的方法是删除应用程序实例并重新创建它。
- en: Events
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: The Zope Toolkit defines a series of life cycle events that are fired whenever
    certain operations are performed on an object, such as creation or modification.
    An **event** can have one or more subscribers, which are called whenever the subscribed
    event takes place. These subscribers are known as **event handlers**, and Grok
    offers an easy way of defining them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Zope 工具包定义了一系列生命周期事件，每当对对象执行某些操作时（如创建或修改）都会触发这些事件。一个**事件**可以有一个或多个订阅者，每当订阅的事件发生时都会调用这些订阅者。这些订阅者被称为**事件处理器**，Grok
    提供了一种简单的方式来定义它们。
- en: 'Here are some of the events that we can subscribe to by using Grok:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们可以通过使用 Grok 订阅的一些事件：
- en: '| Event | Description | Event attributes |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 | 事件属性 |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `IObjectModifiedEvent` | An object has been modified. This is a general event
    that encompasses any change to a persistent object, such as adding, moving, copying,
    or removing objects. | `object``descriptions` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `IObjectModifiedEvent` | 一个对象已被修改。这是一个通用事件，涵盖了持久对象的所有更改，如添加、移动、复制或删除对象。 |
    `object` `descriptions` |'
- en: '| `IContainerModifiedEvent` | The container has been modified. Container modifications
    are specific to addition, removal, or reordering of subobjects. Inherits from
    `grok.IObjectModifiedEvent.` | `object``descriptions` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `IContainerModifiedEvent` | 容器已被修改。容器修改是针对子对象的添加、移除或重新排序的特定操作。继承自 `grok.IObjectModifiedEvent`。
    | `object` `descriptions` |'
- en: '| `IObjectMovedEvent` | An object has been moved. | `object``oldParent``oldName``newParent``newName`
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `IObjectMovedEvent` | 一个对象已被移动。 | `object` `oldParent` `oldName` `newParent`
    `newName` |'
- en: '| Event | Description | Event attributes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 事件 | 描述 | 事件属性 |'
- en: '| `IObjectAddedEvent` | An object has been added to a container. | `object``oldParent``oldName``newParent``newName`
    |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `IObjectAddedEvent` | 一个对象已被添加到一个容器中。 | `object` `oldParent` `oldName` `newParent`
    `newName` |'
- en: '| `IObjectCopiedEvent` | An object has been copied. | `object``original` |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `IObjectCopiedEvent` | 一个对象已被复制。 | `object` `original` |'
- en: '| `IObjectCreatedEvent` | An object has been created. This event is intended
    to happen before an object has been made persistent, that is, its location attributes
    (__name__ and `__parent__)` will usually be `None.` | `object` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `IObjectCreatedEvent` | 一个对象已被创建。此事件旨在在对象被持久化之前发生，即其位置属性（`__name__` 和 `__parent__`）通常为
    `None`。 | `object` |'
- en: '| `IObjectRemovedEvent` | An object has been removed from a container. | `object``oldParent``oldName`
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `IObjectRemovedEvent` | 一个对象已被从一个容器中移除。 | `object` `oldParent` `oldName`
    |'
- en: '| `IBeforeTraverseEvent` | The publisher is about to traverse an object. |
    `object``request` |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `IBeforeTraverseEvent` | 发布者即将遍历一个对象。 | `object` `request` |'
- en: 'We can define an event handler in Grok by using the `grok.subscriber` decorator:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `grok.subscriber` 装饰器在 Grok 中定义事件处理器：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code will be executed every time a new `Project` is added to a container.
    The handler receives two parameters `obj`, which contains the object involved,
    and `event`, which contains the attributes that are listed in the preceding table.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每次向容器添加新的 `Project` 时，都会执行此代码。处理程序接收两个参数 `obj`，它包含涉及的对象，以及 `event`，它包含前面表格中列出的属性。
- en: As the subscription is really a kind of adapter, the first parameter to the
    `grok.subscribe` decorator can be any interface, thus allowing us to make the
    subscription as general or specific as we like. In the earlier example, we passed
    `Project` as a parameter, so the handler will be executed only when a `Project`
    is added, but we could pass `Interface` instead, in order to get all of the occurrences
    of the event, regardless of the object type. There can be additional subscribers
    to the same event, but the order in which they are called cannot be known in advance,
    so never depend on it.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于订阅实际上是一种适配器，`grok.subscribe` 装饰器的第一个参数可以是任何接口，因此我们可以使订阅尽可能通用或具体。在早期示例中，我们传递了
    `Project` 作为参数，因此只有当添加 `Project` 时，处理程序才会执行，但我们可以传递 `Interface`，以便获取所有事件的实例，无论对象类型如何。可以添加额外的订阅者来处理同一事件，但它们被调用的顺序无法预先知道，因此不要依赖它。
- en: Extending a Grok application from the outside
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从外部扩展 Grok 应用程序
- en: Without a doubt, one of the nicest features of the Zope Component Architecture
    is that it makes it very easy to extend or override the functionality of an application
    without having to touch its code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，Zope 组件架构最令人愉悦的特性之一是它使得在不触及代码的情况下扩展或覆盖应用程序的功能变得非常容易。
- en: Many Grok components, such as views and utilities, are ready to be overriden
    without the developer having to do anything special. Other objects, such as viewlets,
    may need small modifications to add new functionality.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Grok 组件，如视图和实用工具，都可以在不进行任何特殊操作的情况下被覆盖。其他对象，如视图小部件，可能需要一些小的修改来添加新功能。
- en: In this section, we are going to show, how easy it is to extend a Grok application
    from the outside, simply by creating an independent package that adds new functionality
    to our to-do application. The knowledge that we just obtained about the ZCA will
    come in handy for this task, so that hopefully we understand it a little better
    when our add-on is ready.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何通过创建一个独立的包来扩展 Grok 应用程序，该包为我们的待办事项应用程序添加新的功能，从而使其变得非常容易。我们刚刚获得的关于
    ZCA 的知识将在这个任务中派上用场，因此希望当我们的附加组件准备好时，我们能对其有更好的理解。
- en: Preparing the original application
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备原始应用程序
- en: This demonstration will, of course, be more convincing if we keep modifications
    to the original application to a minimum. Fortunately, we need to make only one
    small addition to the `app.py` module, and a simple modification to the `navigation.pt`
    template.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们尽量减少对原始应用程序的修改，这个演示将更有说服力。幸运的是，我们只需要对 `app.py` 模块进行一个小小的添加，并对 `navigation.pt`
    模板进行简单的修改。
- en: 'Add the following two lines at the top of `app.py`, just below the `import`
    statements:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app.py` 的顶部添加以下两行，位于 `import` 语句之下：
- en: '[PRE15]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will allow us to use the master page and the form templates in the new
    application, by using a simple `import` statement.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许我们通过使用简单的 `import` 语句来使用新应用程序中的主页面和表单模板。
- en: 'The only other change that we will make is to add an extra viewlet manager
    to the navigation viewlet, so that other applications can easily insert navigation
    options there. To do this, we need to add the viewlet manager definition to `app.py`,
    as shown below:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将做出的唯一其他更改是在导航视图小部件中添加额外的视图管理器，以便其他应用程序可以轻松地在那里插入导航选项。为此，我们需要将视图管理器定义添加到 `app.py`
    中，如下所示：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also need to modify the navigation template to take into account the new
    viewlet manager. Change `app_templates/navigation.pt` to look like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要修改导航模板，以考虑新的视图管理器。将 `app_templates/navigation.pt` 修改如下：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The only thing that we added here is the "provider" line, to insert new viewlets
    after the link, to go back to the main page.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的唯一内容是“提供者”行，用于在链接之后插入新的视图小部件，以便返回主页。
- en: This is all that we need to do in order to leave the to-do application ready
    for extension by third-party packages. Of course, we could have added this code
    there from the beginning, but it's instructive to show how little code you have
    to add, even if you didn't think in terms of extensibility from the start.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使待办事项应用程序准备好由第三方包扩展，我们只需要做这些。当然，我们本可以在一开始就添加这段代码，但展示你需要添加多少代码是有教育意义的，即使你一开始没有考虑可扩展性。
- en: The to-do plus package
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 待办事项+包
- en: Imagine that we just found the to-do application somewhere on the net, and we
    think that it satisfies almost all of our requirements for a list manager, if
    only it had a couple of more features.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们在网上某个地方找到了待办事项应用程序，我们认为它几乎满足了我们对列表管理器的所有要求，只要它有更多一些功能。
- en: The code is available, so we could just extend the application directly. However,
    as we don't control its development, we basically are forking the code, which
    means that any new features added to the application by their original developers
    would need to be merged into our code in order for us to take advantage of them.
    Also, the code style for the original application might be different to the one
    that we are comfortable with, and we don't want to have mixed styles.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是可用的，因此我们可以直接扩展应用程序。然而，由于我们无法控制其开发，我们基本上是在分叉代码，这意味着任何由原始开发者添加到应用程序中的新功能都需要合并到我们的代码中，以便我们能够利用它们。此外，原始应用程序的代码风格可能与我们习惯的不同，我们不希望有混合的风格。
- en: What would be best for us is to create a completely independent package that
    extends the original application, and is under our complete control. If we really
    don't need to modify the original application heavily, this is the way to go.
    Let's create a "to-do plus" package that adds a few features to the existing "to-do"
    package, which we'll declare as a dependency.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对我们来说最好的做法是创建一个完全独立的包，该包扩展原始应用程序，并且完全在我们控制之下。如果我们真的不需要大量修改原始应用程序，这就是我们应该采取的方法。让我们创建一个“待办事项+”包，该包向现有的“待办事项”包添加一些功能，我们将将其声明为依赖项。
- en: Creating the new package
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新包
- en: In real life, the to-do package would be available as an "egg" that we could
    use in a new Grok project, but as we are still in the development stage here,
    we'll just add a new package to our project, instead of creating another one.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，待办事项包将作为一个“egg”提供，我们可以在新的Grok项目中使用它，但由于我们仍然处于开发阶段，我们只需将一个新的包添加到我们的项目中，而不是创建另一个。
- en: 'The `buildout` created by the grokproject script that we used to initialize
    our project has a `src` directory to which we can add our new package. Go into
    that directory, and type the following command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用来初始化项目的grokproject脚本创建的`buildout`有一个`src`目录，我们可以向其中添加我们的新包。进入该目录，并输入以下命令：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This script will ask a few questions, but for now, you can just press the *Enter*
    key after every question, to accept the default values. A new directory, called
    `todo_plus` will be created. This directory will contain our new package.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本将提出一些问题，但到目前为止，你可以在每个问题后只需按下*Enter*键，以接受默认值。将创建一个名为`todo_plus`的新目录。此目录将包含我们的新包。
- en: 'First, we need to make sure that this package gets grokked at startup time,
    so we include `grok`, and grok the current package. As this package depends on
    the existence of the original `todo` application, we have to make sure that its
    dependencies are grokked as well. Create a `configure.zcml` file inside the `todo_plus/todo_plus`
    directory, with the following contents:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保这个包在启动时被解析，因此我们包含`grok`，并解析当前包。由于这个包依赖于原始的`todo`应用程序的存在，我们必须确保其依赖项也被解析。在`todo_plus/todo_plus`目录内创建一个`configure.zcml`文件，内容如下：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that, unlike the `todo` package created for our original project, the
    `todo_plus` package has two subdirectory levels, so be careful to create this
    file inside the second level `todo_plus` directory.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与为我们原始项目创建的`todo`包不同，`todo_plus`包有两个子目录级别，因此请务必在第二级`todo_plus`目录内创建此文件。
- en: 'Next, create the `app_templates` and the `static` directories that are used
    by Grok applications:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建Grok应用程序使用的`app_templates`和`static`目录：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Also, you must add the `todo` package to the `requires` section in the `todo_plus/setup.py`
    file, as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你必须在`todo_plus/setup.py`文件的`requires`部分添加`todo`包，如下所示：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, the `buildout.cfg` file needs to be updated to include the new package.
    This is how the top of the file should look after the `todo_plus` package has
    been added in the required parts (buildout will be discussed in more detail in
    Chapter 14):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要更新`buildout.cfg`文件以包含新包。在将`todo_plus`包添加到所需部分后，文件顶部应如下所示（将在第14章中更详细地讨论buildout）：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the `develop` line, we are telling `buildout` that, in addition to the package
    in the current directory (that is, the `todo` package itself), we'll be adding
    our new `todo_plus` development package. This will create a development "egg"
    for `todo_plus`, which should be added below the eggs line in the `[app]` section,
    right under the original todo package.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在`develop`行中，我们正在告诉`buildout`，除了当前目录中的包（即`todo`包本身）之外，我们还将添加我们的新`todo_plus`开发包。这将创建一个`todo_plus`的开发“egg”，应该添加到`[app]`部分的eggs行下方，紧挨着原始的待办事项包。
- en: 'Now we can rerun the `buildout` and our package will be ready to work:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新运行`buildout`，我们的包将准备好工作：
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Adding a skin chooser form to the application
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将皮肤选择表单添加到应用程序中
- en: In Chapter 8, we added themes to our application, although the only way to look
    at a different theme than the default was to use the ugly `++skin++` traversal
    helper in the URL. As we had mentioned then, we don't want the user to do that,
    so a way to select the desired skin from a form would be neat.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8章中，我们向应用程序添加了主题，尽管查看默认主题之外的主题的唯一方法是在URL中使用丑陋的`++skin++`遍历助手。正如我们当时提到的，我们不希望用户这样做，因此从表单中选择所需皮肤的方法会很方便。
- en: Let's make that the first feature our `todo_plus` package will add to the to-do
    list application. The objective is to have a form where we get a list of available
    screens, pick one, and then save it. After that, Grok should automatically use
    the chosen skin when we navigate through the to-do application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将此作为`todo_plus`包将添加到待办事项列表应用程序中的第一个功能。目标是有一个表单，我们可以从中获取可用屏幕的列表，选择一个，然后保存它。之后，Grok应该在我们导航通过待办事项应用程序时自动使用所选皮肤。
- en: Adding a new skin
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新皮肤
- en: 'First, we''ll have our package include its own skin layer to add to the three
    skins available in the original application. Of course, there are a few things
    we need to import from the to-do application, but it''s all very straightforward.
    Create a file named `app.py` inside the `src/todo_plus/todo_plus` directory, and
    add the following lines of code to it:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的包将包含自己的皮肤层，以添加到原始应用程序中可用的三个皮肤中。当然，我们需要从待办事项应用程序中导入一些东西，但这一切都非常直接。在`src/todo_plus/todo_plus`目录内创建一个名为`app.py`的文件，并向其中添加以下代码行：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because we need to add a viewlet to the `HeadSlot` for this skin layer, we
    have to import it from `todo.app`. Everything else that we need, we already did
    in Chapter 8\. We add a new layer and turn it into a skin by using the `grok.skin`
    directive. After that, we add a viewlet and register it with the name ''head''
    for this layer, overriding the original viewlet from the default skin. Of course,
    we need a template for the new viewlet. Add the following code to `app_templates/head_plus`,
    at the top:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们需要为此皮肤层向`HeadSlot`添加一个视图组件，我们必须从`todo.app`中导入它。我们需要的其他所有东西，我们已经在第8章中完成了。我们添加了一个新层，并使用`grok.skin`指令将其转换为皮肤。之后，我们添加了一个视图组件，并使用名称`head`将其注册到该层，覆盖了默认皮肤中的原始视图组件。当然，我们需要为新视图组件创建一个模板。将以下代码添加到`app_templates/head_plus`的顶部：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we can copy the `styles.css` file from the original app and save it
    as `styles_plus.css`. To keep it simple, as we did in Chapter 8, make some obvious
    modifications, such as changing the header background color, and leave it at that
    for now.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将原始应用程序中的`styles.css`文件复制并保存为`styles_plus.css`。为了保持简单，就像我们在第8章中所做的那样，做一些明显的修改，例如更改页眉背景颜色，然后暂时保持这样。
- en: Restart the to-do application normally, by using paster and then navigate to
    [http://localhost/++skin++plus/todo/index](http://localhost/++skin++plus/todo/index),
    and you'll see the new skin. That's it. Not bad for a simple warm-up. Working
    from a completely separate package, we have added a new skin that transparently
    integrates with the to-do application.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 正常重启待办事项应用程序，使用paster然后导航到[http://localhost/++skin++plus/todo/index](http://localhost/++skin++plus/todo/index)，你将看到新皮肤。就这样。对于一个简单的热身来说，还不错。从一个完全独立的包开始，我们已经添加了一个新皮肤，该皮肤可以透明地与待办事项应用程序集成。
- en: The skin chooser form
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 皮肤选择表单
- en: Now, we are ready to add the form. We need a drop-down list with the names of
    all of the available skins, which currently are Basic (the default), martian,
    forest, and plus. We can use a `schema.Choice` field and pass these values to
    it, but then, if the original application adds a new skin or a third party comes
    up with another add-on package that has new skins, our skin list will be outdated.
    We need a dynamic way to specify the skin name values, so that we don't have to
    keep track of all of the skin names in the code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好添加表单。我们需要一个包含所有可用皮肤名称的下拉列表，目前这些皮肤包括基本（默认）、火星、森林和加号。我们可以使用一个`schema.Choice`字段并将这些值传递给它，但这样，如果原始应用程序添加了新的皮肤或者第三方推出了包含新皮肤的另一个附加包，我们的皮肤列表就会过时。我们需要一种动态指定皮肤名称值的方法，这样我们就不必在代码中跟踪所有皮肤名称。
- en: 'Fortunately, as we will frequently find out when we want to add new functionality
    to a Grok application, the Zope Toolkit already has a package called `zc.sourcefactory`
    that can help us in this situation. We can use this package by adding it to the
    `install_requires` section of the `src/todo_plus/setup.py` file, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正如我们将在想要向Grok应用程序添加新功能时经常发现的那样，Zope Toolkit已经有一个名为`zc.sourcefactory`的包可以帮助我们。我们可以通过将其添加到`src/todo_plus/setup.py`文件的`install_requires`部分来使用此包，如下所示：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Rerun the `buildout` and the package will be downloaded and installed, as usual.
    We can now use it to define a dynamic choice field:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`buildout`，包将像往常一样被下载和安装。现在我们可以用它来定义一个动态选择字段：
- en: '[PRE27]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A **source** is simply a method that returns a list of values to be used inside
    a schema field, instead of static lists. The `BasicSourceFactory` subclass is
    used to define a source.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**源**只是一个返回用于方案字段内部值的方法，而不是静态列表。`BasicSourceFactory`子类用于定义源。'
- en: We have created a form schemata earlier, so the only new thing in the `ISkinChooser`
    schema definition is the `source=SkinNameSource()` parameter in the `Choice` field.
    This tells Grok to use a source factory named `SkinNameSource` to provide the
    skin name values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前已经创建了一个表单方案，所以在`ISkinChooser`方案定义中唯一的新事物是`Choice`字段中的`source=SkinNameSource()`参数。这告诉Grok使用名为`SkinNameSource`的源工厂来提供皮肤名称值。
- en: To create a source, we just subclass from `BasicSourceFactory`, and add a `getValues`
    method that will return a list of the skin names. To get the skin names themselves,
    we have to use the component registry. In Zope, a skin is registered as a named
    utility with the interface `IBrowserSkinType` and the skin name.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '要创建一个源，我们只需从`BasicSourceFactory`派生，并添加一个`getValues`方法，该方法将返回一个皮肤名称列表。要获取皮肤名称本身，我们必须使用组件注册表。在Zope中，皮肤被注册为具有`IBrowserSkinType`接口和皮肤名称的命名实用工具。 '
- en: How do we get all of the utilities registered for this interface? The `zope.component`
    package includes a function called `getAllUtilitiesRegisteredFor` that does this.
    To distinguish them from the Zope skins, Grok adds a tag to its skin components
    that identify them as Grok layers. This tag is the `grokcore.view.directive.skin`
    assigned to `skin_tag` in the preceding code. To get the Grok skin names, we start
    with a list with the value 'Basic' in it, to account for the default skin, which
    is not tagged by Grok. We then go through every registered skin and check if it
    has `skin_tag` on it. If it does, we add it to the list.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何获取注册为此接口的所有实用工具？`zope.component`包包含一个名为`getAllUtilitiesRegisteredFor`的函数，它可以完成这项工作。为了将它们与Zope皮肤区分开来，Grok为其皮肤组件添加了一个标签，以标识它们为Grok层。这个标签是`grokcore.view.directive.skin`，在前面代码中分配给`skin_tag`。要获取Grok皮肤名称，我们从一个包含值'Basic'的列表开始，以考虑到默认皮肤，它没有被Grok标记。然后我们遍历每个注册的皮肤，检查它是否有`skin_tag`。如果有，我们就将它添加到列表中。
- en: In this way, each time a new skin layer is added from a Grok package, it will
    automatically be listed in our 'skin chooser' form. The component registry takes
    care of the available skins for us.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，每次从Grok包添加新的皮肤层时，它将自动列在我们的“皮肤选择器”表单中。组件注册表为我们处理可用的皮肤。
- en: 'Now we need to add the form, and also a `SkinChooser` view and a viewlet that
    includes the form on it. We have done all of this in Chapter 8, so it should seem
    familiar:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要添加表单，以及一个包含表单的`SkinChooser`视图和视图组件。我们在第8章中已经完成了所有这些，所以应该看起来很熟悉：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `SkinChooserForm` inherits from `grok.Form`, because we want a content-independent
    form. Its context is `ITodo` to make it show up only at the root application level.
    We use the fields defined in the `ISkinChooser` interface that we created earlier.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`SkinChooserForm`从`grok.Form`继承，因为我们想要一个与内容无关的表单。其上下文是`ITodo`，使其仅在根应用程序级别显示。我们使用我们在前面创建的`ISkinChooser`接口中定义的字段。'
- en: We need a way to store the skin selection so that it is available when the user
    navigates through the application. For this, we'll use the session mechanism that
    is defined in the `zope.app.session` package (yeah, the Zope Toolkit to the rescue,
    again). The session is an adapter for the request, so we can get it by issuing
    an `ISession(self.request)`. We use the `todo_plus` package name as a session
    key to avoid namespace clashes with other session objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种方法来存储皮肤选择，以便在用户在应用程序中导航时可用。为此，我们将使用在`zope.app.session`包中定义的会话机制（是的，Zope工具包再次救命）。会话是请求的适配器，因此我们可以通过发出`ISession(self.request)`来获取它。我们使用`todo_plus`包名作为会话键，以避免与其他会话对象发生命名空间冲突。
- en: In the `updateWidgets` method of the form, we try to get the value for `skin_name`
    from the session ('Basic' is returned, if `skin_name` has not been initialized).
    With this value, we can show the currently selected skin on the form by calling
    `setRenderedValue` on the choice widget.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单的`updateWidgets`方法中，我们尝试从会话中获取`skin_name`的值（如果`skin_name`尚未初始化，则返回`'Basic'`）。有了这个值，我们可以通过在选项小部件上调用`setRenderedValue`来显示当前所选的皮肤。
- en: Finally, in the form action, we set the `skin_name` key of our session to the
    value returned in the form data submitted by the user, and redirect the user to
    the 'skin chooser' view.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在表单操作中，我们将会话的`skin_name`键设置为用户提交的表单数据返回的值，并将用户重定向到'皮肤选择'视图。
- en: '![The skin chooser form](img/7481_11_01.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![皮肤选择表单](img/7481_11_01.jpg)'
- en: The view and viewlet definitions contain nothing new, but notice how we use
    the components imported from the original to-do application to perform our registrations.
    The view is assigned `ITodo` as its context, and the viewlet is registered with
    the Main viewlet manager from that package.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 视图和视图小部件定义没有新增内容，但请注意我们如何使用从原始待办应用导入的组件来执行注册。视图被分配`ITodo`作为其上下文，视图小部件则注册到该包的Main视图小部件管理器。
- en: Using events to show the selected skin
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用事件来显示所选皮肤
- en: So far, we have a `skin_chooser` form that can save the chosen skin name in
    the current session, but we still need to use that name to set the skin automatically
    on every page view. To do this, we will take advantage of Grok's event functionality,
    which is discussed in *The Zope Component Architecture* section of this chapter.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个可以保存所选皮肤名称到当前会话的`skin_chooser`表单，但我们还需要在每个页面视图中自动使用该名称设置皮肤。为此，我们将利用Grok的事件功能，这在本章的*Zope组件架构*部分有讨论。
- en: 'The ZCA provides an event registered with the interface `IBeforeTraverseEvent`
    that we can use to set the skin on every request. Grok has a very convenient `grok.subscribe`
    decorator that allows us to easily add a handler for this event:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ZCA提供了一个注册了`IBeforeTraverseEvent`接口的事件，我们可以使用它来在每个请求上设置皮肤。Grok有一个非常方便的`grok.subscribe`装饰器，它允许我们轻松添加此事件的处理器：
- en: '[PRE29]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We register the `ITodo` interface with the `IBeforeTraverse` event, which means
    that just before Grok shows a view inside the to-do application instance, our
    `choose_skin` handler will be called.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`ITodo`接口与`IBeforeTraverse`事件注册，这意味着在Grok显示待办应用实例内的视图之前，我们的`choose_skin`处理程序将被调用。
- en: Inside the handler, we get the session object and find the skin name that is
    currently selected for that browser session. We then use the `getUtility` function
    to get the actual skin object by using this name, and then set the skin by using
    the `applySkin` function, which is imported from `zope.publisher.browser`. The
    result is that the chosen skin will be set just in time, before a page is displayed.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理程序内部，我们获取会话对象并找到当前浏览器会话所选的皮肤名称。然后我们使用`getUtility`函数通过此名称获取实际的皮肤对象，并使用从`zope.publisher.browser`导入的`applySkin`函数设置皮肤。结果是所选的皮肤将在页面显示之前及时设置。
- en: Sending e-mail notifications on content creation
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在内容创建时发送电子邮件通知
- en: One feature that is usually requested in multiuser systems, where users can
    act on other users' content, is e-mail notification of changes. Our to-do plus
    package will surely earn its 'plus' moniker if we add such a feature to it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在多用户系统中，通常请求的一个功能是用户可以对其他用户的内容进行操作，即更改的电子邮件通知。如果我们向待办加号包中添加此功能，它肯定会赢得其'plus'名称。
- en: We'll need a form for setting the notification properties, such as the destination
    e-mail and message subject. Of course, to keep the site layout consistent, we
    must also do our usual form-inside-a-viewlet registration dance. These are things
    that we already know how to do. More interesting is how we'll set up our e-mail
    handler by using an event subscription, and how the actual e-mail will be sent.
    Let's get going.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个表单来设置通知属性，例如目标电子邮件和消息主题。当然，为了保持网站布局的一致性，我们还需要进行我们通常的表单在视图组件中的注册舞蹈。这些是我们已经知道如何做到的事情。更有趣的是，我们将如何通过事件订阅来设置我们的电子邮件处理程序，以及实际的电子邮件将如何发送。让我们开始吧。
- en: 'For now, this feature will send notification messages to a specified list of
    e-mails, whenever a project is created. For this, we first need an interface definition
    for the form schema:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，此功能将在创建项目时向指定的电子邮件列表发送通知消息。为此，我们首先需要一个表单模式的接口定义：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `enabled` field will allow the manager to turn notifications on or off.
    If they are turned on, an e-mail with the specified message and `subject` field
    information will be sent to the list of e-mails specified in the `emails` field.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`enabled`字段将允许管理员打开或关闭通知。如果它们被打开，将向`emails`字段中指定的电子邮件列表发送包含指定消息和`subject`字段信息的电子邮件。'
- en: Object annotations
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象注释
- en: Before we proceed with the form definition, we need to decide how to store the
    notification properties. We can't use the session, as we did with the skin chooser,
    because the notification properties will be global for the application. In fact,
    they could be considered as a part of the `Todo` instance itself, so the ideal
    thing would be to store them there. But that would require changing the original
    code to add these properties, right?
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续进行表单定义之前，我们需要决定如何存储通知属性。我们不能使用会话，就像我们在皮肤选择器中做的那样，因为通知属性将是应用程序的全局属性。实际上，它们可以被认为是`Todo`实例本身的一部分，因此理想的做法是将它们存储在那里。但这需要更改原始代码以添加这些属性，对吗？
- en: Well, no. Grok offers a special component called `annotation` that can be used
    to store information inside a specific context object, without needing to alter
    it directly. This is accomplished by using a persistent adapter registered for
    the context object. That is, behind the scenes, there is an `IAnnotation` interface
    that provides this writing service to any objects in the registry that implement
    the `IAnnotatable` interface.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，不是的。Grok提供了一个名为`annotation`的特殊组件，可以用于在特定上下文对象内部存储信息，而无需直接修改它。这是通过为上下文对象注册持久适配器来实现的。也就是说，在幕后，有一个`IAnnotation`接口为任何实现`IAnnotatable`接口的注册表中的对象提供这项写入服务。
- en: 'As usual, Grok simplifies the setup with a convenient component that we can
    subclass, called `grok.Annotation`. As discussed earlier, let''s register our
    `annotation` component to the main application''s `ITodo` interface:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，Grok通过一个方便的组件简化了设置，我们可以通过它进行子类化，称为`grok.Annotation`。如前所述，让我们将我们的`annotation`组件注册到主应用的`ITodo`接口：
- en: '[PRE31]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `grok.context` directive indicates that annotations will be added to a component
    with the `ITodo` interface, which we know is the main application object. The
    `grok.implements` directive tells Grok to register this annotation adapter with
    the `ISetNotifications` interface, which is how we'll find it in the registry.
    Notice that this interface is the same as the one that we'll use in the 'notification
    properties' form. The variables defined after that represent the default values
    for the stored properties.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`grok.context`指令表明，将向具有`ITodo`接口的组件添加注释，我们知道这是主应用对象。`grok.implements`指令告诉Grok将此注释适配器注册到`ISetNotifications`接口，这是我们将在注册表中找到它的方式。注意，此接口与我们将在“通知属性”表单中使用的接口相同。之后定义的变量代表存储属性的默认值。'
- en: Creating the form
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建表单
- en: 'As we now know where the properties will be stored, we can go ahead and create
    the form. The code for the form definition looks like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们现在知道属性将存储在哪里，我们可以继续创建表单。表单定义的代码看起来像这样：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We use the `grok.AutoFields` directive to construct a form automatically, by
    using the fields that we previously defined in the `ISetNotifications` interface.
    As with the `skin_chooser` form, we use the form template imported from the original
    application, in order to keep the look and feel of the site, the same.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`grok.AutoFields`指令通过使用我们在`ISetNotifications`接口中先前定义的字段自动构建表单。与`skin_chooser`表单一样，我们使用从原始应用导入的表单模板，以保持网站的外观和感觉相同。
- en: In the `setUpWidgets` method, we get the `annotation` object with the `ISetNotifications(self.context)`
    call, which searches the registry for an adapter that implements `ISetNotification`
    and that is registered for the current context, which is the `todo` application.
    Once we have that, we use the `setRenderedValue` method of each widget to make
    the form show the currently stored value when the form is displayed. We also alter
    the size of the various text fields (although, at the moment, this is not important).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`setUpWidgets`方法中，我们通过调用`ISetNotifications(self.context)`获取`annotation`对象，该调用在注册表中搜索实现`ISetNotification`并注册到当前上下文（即`todo`应用程序）的适配器。一旦我们有了这个适配器，我们就使用每个小部件的`setRenderedValue`方法来使表单在显示时显示当前存储的值。我们还改变了各种文本字段的大小（尽管，目前这并不重要）。
- en: In the `set_options` form submit handler, we fetch the annotation object again,
    but this time we store the submitted values inside their corresponding properties.
    After that, we just redirect the user to the same form.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`set_options`表单提交处理程序中，我们再次获取注释对象，但这次我们将提交的值存储在其对应的属性中。之后，我们只需将用户重定向到相同的表单。
- en: 'All that''s left is to insert the form into a viewlet, and then add that viewlet
    to the `Main` viewlet manager in a view. The code for that is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的工作是将表单插入到视图中，然后将该视图添加到视图中的`Main`视图管理器。相应的代码如下：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is nothing new here. Just note that the permission to add projects will
    be required to edit the "e-mail notification" properties. The following screenshot
    shows the form in action:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新的内容。只需注意，要编辑“电子邮件通知”属性，需要添加项目的权限。以下截图显示了表单的实际应用：
- en: '![Creating the form](img/7481_11_02.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![创建表单](img/7481_11_02.jpg)'
- en: Sending the e-mail
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 发送电子邮件
- en: 'To send the e-mail, we need an e-mail delivery mechanism. Of course, the Zope
    Toolkit has a package called `zope.sendmail` that does this, so we just need to
    add this to our `setup.py`, file and then rerun the `buildout`, in order to use
    it. Edit the `setup.py` file, and add it to the `install_requires` line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送电子邮件，我们需要一个邮件投递机制。当然，Zope Toolkit有一个名为`zope.sendmail`的包可以完成这个任务，所以我们只需将其添加到我们的`setup.py`文件中，然后重新运行`buildout`，以便使用它。编辑`setup.py`文件，并将其添加到`install_requires`行：
- en: '[PRE34]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Rerun the `buildout`. Now, we have to configure the mail delivery service.
    Unlike the Grok packages that we have used so far, this Zope Toolkit package requires
    configuration by using ZCML the XML-based Zope configuration language. Open the
    `configure.zcml` file in the `todo_plus` package, and modify it to look like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重新运行`buildout`。现在，我们必须配置邮件投递服务。与迄今为止我们使用的Grok包不同，这个Zope Toolkit包需要使用基于XML的Zope配置语言ZCML进行配置。打开`todo_plus`包中的`configure.zcml`文件，并修改它以看起来像这样：
- en: '[PRE35]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the addition of the `mail` namespace at the top of the file. This allows
    us to use the mail directives that appear after the normal Grok configuration.
    The `smtpMailer` directive represents a named SMTP server. Its parameters are
    `host, port, username`, and `password`. If your mail host does not require a password,
    simply omit the `username` and `password` parameters.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意文件顶部添加了`mail`命名空间。这允许我们在正常的Grok配置之后使用邮件指令。`smtpMailer`指令代表一个命名的SMTP服务器。其参数是`host,
    port, username`和`password`。如果你的邮件主机不需要密码，只需省略`username`和`password`参数。
- en: The `queuedDelivery` directive sets up a queue to use to send the mail messages.
    This gets done in an independent thread to allow the application to keep working
    even when numerous e-mails are sent. The `permission` argument refers to the permission
    needed for sending e-mails. Be sure to use the same name for the `mailer` parameter
    that was used in the SMTP mailer definition, above.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`queuedDelivery`指令设置了一个队列，用于发送邮件消息。这在一个独立的线程中完成，以便在发送大量电子邮件时应用程序仍能继续工作。`permission`参数指的是发送电子邮件所需的权限。请确保使用与上面SMTP邮件器定义中使用的`mailer`参数相同的名称。'
- en: Now we are ready to register the event for sending the e-mail. We'll use the
    `grok.subscribe` directive to register our handler with the `IObjectAddedEvent`
    of `Project` objects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备注册发送电子邮件的事件。我们将使用`grok.subscribe`指令将我们的处理程序注册到`Project`对象的`IObjectAddedEvent`。
- en: '[PRE36]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The handler first finds the `annotation` object and checks the value of the
    `enabled` property. If it's `False`, the method just returns without doing anything
    else; if it's `True`, we get the property values and compose the message with
    the help of the Python e-mail module. One simple trick that we use here is to
    allow the message to insert the title, creator, and description of the newly created
    project by using simple string substitutions. Take a look at the screenshot under
    the *Creating a form* section of this chapter, to see how this works.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序首先找到`annotation`对象并检查`enabled`属性的值。如果是`False`，该方法将直接返回而不做其他任何事情；如果是`True`，我们将获取属性值并借助Python电子邮件模块来组合消息。我们在这里使用的一个简单技巧是允许消息通过简单的字符串替换插入新创建项目的标题、创建者和描述。查看本章“创建表单”部分的截图，看看这是如何工作的。
- en: The `zope.sendmail` package registers the mailer utility by using an interface
    named `IMailDelivery`, so we import this and use the `getUtility` function from
    `zope.component` to find it and finally send the e-mail.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`zope.sendmail`包通过名为`IMailDelivery`的接口注册了邮件工具，因此我们导入这个接口并使用`zope.component`中的`getUtility`函数来找到它，最终发送电子邮件。'
- en: Displaying additional navigation links
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示额外的导航链接
- en: So far, the to-do application has 'user management' and 'skin chooser' forms,
    but they don't show up in the site navigation. We have a viewlet manager set up
    for that in our original application, so we just need to register a viewlet with
    that manager and add a template, and we are done. This will demonstrate how easy
    it is to insert arbitrary page fragments in Grok, when the original views plan
    for it carefully.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，待办事项应用程序有“用户管理”和“皮肤选择器”表单，但它们没有显示在网站导航中。我们在原始应用程序中为此设置了一个视图管理器，所以我们只需将视图小部件注册到该管理器并添加一个模板，就完成了。这将演示在Grok中插入任意页面片段是多么容易，前提是原始视图计划了这一点。
- en: 'Let''s add two viewlets one for regular user options, and one for manager-only
    options:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加两个视图小部件，一个用于常规用户选项，另一个用于仅管理员选项：
- en: '[PRE37]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Both of these viewlets are registered with the `ExtraNav` viewlet manager from
    the to-do application, but one requires only the `todo.changeitems` permission,
    while the other needs the `zope.ManageApplication` permission, which is usually
    assigned to the site manager. The page templates just include a couple of links.
    First, inside `manageroptions.pt`, we have:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个视图小部件都注册了来自待办事项应用程序的`ExtraNav`视图小部件管理器，但一个只需要`todo.changeitems`权限，而另一个需要`zope.ManageApplication`权限，这通常分配给网站管理员。页面模板只包含几个链接。首先，在`manageroptions.pt`内部，我们有：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: That's right, just a link to the `userlist` view, which will be inserted in
    the correct place by the viewlet manager.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 确实如此，只需一个指向`userlist`视图的链接，视图管理器会将其插入正确的位置。
- en: 'The other template, `useroptions.pt`, is almost as simple:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个模板`useroptions.pt`几乎同样简单：
- en: '[PRE39]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: That's all that is needed. You can see the result in the navigation section
    of the previous two screenshots of this chapter. The nice thing about this is
    that other third-party packages can add a navigation link as well, and this would
    be transparently integrated with the existing navigation options, without even
    having to know about the existence of these other packages.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所有需要的。你可以在本章前两个截图的导航部分看到结果。这个功能的好处是，其他第三方包也可以添加导航链接，并且它们将与现有的导航选项透明地集成，甚至无需了解这些其他包的存在。
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter discussed the main concepts behind the Zope Component Architecture,
    and showed how to use some of the ZCA's patterns to extend our application. Most
    importantly, we showed how to extend a package without touching its code. In the
    next chapter, we'll see how Grok uses a library called Martian to permit agile
    configuration, and learn how to benefit from it, for our own work.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了Zope组件架构背后的主要概念，并展示了如何使用ZCA的一些模式来扩展我们的应用程序。最重要的是，我们展示了如何在不接触其代码的情况下扩展一个包。在下一章中，我们将看到Grok如何使用一个名为Martian的库来实现敏捷配置，并学习如何从中受益，用于我们的工作。
