- en: Fruity Tunes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水果曲调
- en: In this chapter, you will learn how to create a musical instrument with Circuit
    Playground Express and some bananas. We will connect four bananas to the touchpads
    on the board so that you can play a certain musical sound for each banana you
    touch. We'll add some visual feedback to the project by lighting up a pixel next
    to each touchpad each time you make contact with it. This project will show a
    creative, fun way to bring your capacitive touch projects to life.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将学习如何使用Circuit Playground Express和一些香蕉创建一个乐器。我们将把四根香蕉连接到板上的触摸板，这样您就可以触摸每根香蕉时播放特定的音乐声音。我们将通过点亮每个触摸板旁边的像素来为项目添加一些视觉反馈。这个项目将展示一个创造性、有趣的方式，让您的电容触摸项目生动起来。
- en: By using unexpected objects such as bananas in your projects, you can add a
    unique twist to your mundane MicroPython projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目中使用意想不到的物体，如香蕉，您可以为平凡的MicroPython项目增添独特的风味。
- en: 'In this chapter, we will be covering the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下配方：
- en: Creating a class to react to touch events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个类来响应触摸事件
- en: Creating a function to enable speaker output
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个函数来启用扬声器输出
- en: Creating a function to play audio files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个播放音频文件的函数
- en: Using the NeoPixel object to control pixels
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NeoPixel对象控制像素
- en: Creating a touch handler to play sounds
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个触摸处理程序来播放声音
- en: Creating a touch handler to light up pixels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个触摸处理程序来点亮像素
- en: Creating an event loop to handle all touch events
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个事件循环来处理所有触摸事件
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be found in the `Chapter07` folder in the
    GitHub repository, at [https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub存储库的`Chapter07`文件夹中找到，网址为[https://github.com/PacktPublishing/MicroPython-Cookbook](https://github.com/PacktPublishing/MicroPython-Cookbook)。
- en: Many of the recipes in this chapter require four audio files to be transferred
    to the Circuit Playground Express board. They can all be downloaded from the `Chapter07`
    folder in the GitHub repository. They should be saved in the top-level folder
    with your `main.py` file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多配方需要将四个音频文件传输到Circuit Playground Express板上。它们都可以从GitHub存储库的`Chapter07`文件夹中下载。它们应该保存在与您的`main.py`文件同级的文件夹中。
- en: Circuit Playground Express touchpads
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Circuit Playground Express触摸板
- en: Circuit Playground Express comes with seven capacitive touchpads. Each of them
    can be connected to any object that can conduct electricity, and touching that
    object will, in turn, trigger the sensor. You can use good electrical conductors,
    such as metal, and even weaker ones, such as a banana.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Circuit Playground Express带有七个电容触摸板。它们中的每一个都可以连接到任何可以导电的物体，触摸该物体将触发传感器。您可以使用良好的电导体，如金属，甚至较弱的导体，如香蕉。
- en: 'Water conducts electricity, and the surfaces of many fruits have enough moisture
    for the touchpads to detect a touch event. Many fruits, such as bananas, limes,
    oranges, and apples, will do the job. You can use alligator clips to connect the
    fruit to the touchpads. The following photograph shows a bundle of alligator clips:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 水能导电，许多水果的表面含有足够的水分，可以被触摸板检测到触摸事件。许多水果，如香蕉、酸橙、橙子和苹果，都可以胜任。您可以使用鳄鱼夹将水果连接到触摸板。下一张照片显示了一捆鳄鱼夹：
- en: '![](assets/a34c1b12-42b9-465a-8d1d-00e82740e562.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a34c1b12-42b9-465a-8d1d-00e82740e562.png)'
- en: 'These alligator clips come in a variety of different colors. It''s a good idea
    to use a different color wire for each touchpad. It will make it easier to trace
    which fruit is connected to which touchpad. In this project, we will use green,
    red, yellow, and white wires. We''ll set the color of the pixels next to each
    pad to also be green, red, yellow, and white. The next photograph shows a single
    banana connected to one of the touchpads:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些鳄鱼夹子有各种不同的颜色。最好为每个触摸板使用不同颜色的导线。这样会更容易追踪哪个水果连接到哪个触摸板。在这个项目中，我们将使用绿色、红色、黄色和白色的导线。我们将把每个触摸板旁边的像素颜色也设置为绿色、红色、黄色和白色。下一张照片显示了一个香蕉连接到一个触摸板：
- en: '![](assets/3b3aa8f7-7cf8-4e04-b03e-4fabb1cb7126.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3b3aa8f7-7cf8-4e04-b03e-4fabb1cb7126.png)'
- en: 'The alligator clips work very well, as they don''t require any soldering and
    can easily connect to both the board and a variety of objects. The teeth on the
    alligator clips will also create a good grip, so that a good electrical connection
    can be established between the board and the banana. The following photograph
    gives a closer view of the alligator teeth that are attached to the banana:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 鳄鱼夹非常有效，因为它们不需要任何焊接，可以轻松连接到板和各种物体。鳄鱼夹的牙齿也会产生良好的抓地力，从而可以在板和香蕉之间建立良好的电连接。下一张照片更近距离地展示了连接到香蕉上的鳄鱼夹的牙齿：
- en: '![](assets/155c7ec9-f0c3-49ef-bd49-97fc9e918997.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/155c7ec9-f0c3-49ef-bd49-97fc9e918997.png)'
- en: 'The next photograph shows a closer view of the alligator teeth that are attached
    to the touchpad:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 下一张照片显示了连接到触摸板的鳄鱼夹的更近距离视图：
- en: '![](assets/52b29bc0-114d-40e6-8884-e58bc97b6eef.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/52b29bc0-114d-40e6-8884-e58bc97b6eef.png)'
- en: In previous chapters, we used the Circuit Playground Express library to interact
    with the different components on the board. When you play audio files with this
    library, the library will block your code until the playback of the file is complete.
    In this project, we want the ability to respond to touch events immediately, and
    to play new sounds without waiting for the current audio file to finish playback.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们使用Circuit Playground Express库与板上的不同组件进行交互。当您使用该库播放音频文件时，该库将阻塞您的代码，直到文件播放完成。在这个项目中，我们希望能够立即响应触摸事件，并在当前音频文件播放完成之前播放新的声音。
- en: This level of control can only be achieved if we use the CircuitPython libraries
    that control audio playback and the touchpads directly. For this reason, none
    of the code in this chapter will use the Circuit Playground Express library. By
    taking this approach, we will also get see how to get more fine-tuned control
    of the components on the board.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用直接控制音频播放和触摸板的CircuitPython库才能实现这种程度的控制。因此，本章中的代码将不使用Circuit Playground Express库。通过采用这种方法，我们还将看到如何更精细地控制板上的组件。
- en: Creating a class to react to touch events
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个用于响应触摸事件的类
- en: In this recipe, you will learn how to define a class that can help you use handle
    touch events on a particular touchpad. When you create an instance of this class,
    you specify the pad name and a callback function that will be called each time
    a touch event starts and ends. We can use this class as a building block to have
    a callback called for each of the four touchpads that will be connected to bananas.
    You can use this style of code in your own projects, whenever you want to handle
    a variety of events with a set of callback functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个教程中，您将学习如何定义一个类，以帮助您处理特定触摸板上的触摸事件。当您创建这个类的实例时，您需要指定触摸板的名称和一个回调函数，每次触摸事件开始和结束时都会调用该函数。我们可以将这个类用作构建块，为将连接到香蕉的四个触摸板中的每一个调用一个回调。您可以在自己的项目中使用这种代码风格，每当您想要处理一系列事件时，都可以使用一组回调函数。
- en: Getting ready
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个教程所需的步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: At this stage, we have defined a function that will handle touch events by printing
    the name of the touchpad and whether the pad is being touched.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经定义了一个函数，它将通过打印触摸板的名称以及触摸板是否被触摸来处理触摸事件。
- en: 'Run the next block of code to create a class that will check for touch events.
    After defining the class, it will create one instance and then print out the current
    touch state of the pad:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一块代码以创建一个检查触摸事件的类。在定义类之后，它将创建一个实例，然后打印出触摸板的当前触摸状态：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Hold down your finger on touchpad A1 while running the next block of code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住触摸板A1上的手指，同时运行下一块代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Run the next block of code to create a class with a method to process touch
    events:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一块代码以创建一个具有处理触摸事件的方法的类：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Hold down your finger on touchpad A1 while running the next block of code:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按住触摸板A1上的手指，同时运行下一块代码：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: When executed, this script will repeatedly print a message whenever a touch
    event starts or ends on touchpad A1.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行时，此脚本将在触摸板A1上触摸事件开始或结束时重复打印消息。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `TouchEvent` class is defined to help us keep track of the last known state
    of the touchpad and to respond to a change in its state by making a call to the
    specified callback function. A default touch threshold of `400` is defined so
    that subclasses of this class can override the value. The constructor expects
    the first argument to be the name of the touchpad to monitor and the callback
    function that will be called when a state change is detected.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`TouchEvent`类被定义为帮助我们跟踪触摸板的最后已知状态，并在其状态发生变化时调用指定的回调函数。定义了默认的触摸阈值为`400`，以便该类的子类可以覆盖该值。构造函数期望第一个参数是要监视的触摸板的名称，第二个参数是在检测到状态变化时将被调用的回调函数。'
- en: The name and callback function are saved with attributes on the instance. The
    last known state is initialized to the `False` value. Then, the pin value for
    the named touchpad is retrieved from the `board` Python module. This pin is used
    to create a `TouchIn` instance, which is also saved as an attribute on the object.
    Finally, the threshold is set on this touchpad as part of the initialization process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 名称和回调函数将保存在实例的属性中。最后已知状态初始化为“False”值。然后，从`board` Python模块中检索命名触摸板的引脚值。该引脚用于创建`TouchIn`实例，也保存为对象的属性。最后，在初始化过程中设置了该触摸板的阈值。
- en: The other method that is defined on the class will be called regularly, to check
    for any changes in the touchpad state and to process this state change by calling
    the defined callback function. This is done by getting the current touch state
    and comparing it to the last known value. If they differ, the callback is called
    and the value is saved for future reference.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在类上定义的另一个方法将定期调用，以检查触摸板状态的任何变化，并通过调用定义的回调函数来处理这种状态变化。这是通过获取当前触摸状态并将其与最后已知值进行比较来完成的。如果它们不同，就会调用回调函数并保存该值以供将来参考。
- en: A simple function is defined to handle any touch events by simply printing out
    the name of the touchpad that had a state change and what the current state is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个简单的函数来处理任何触摸事件，只需打印出发生状态变化的触摸板的名称和当前状态。
- en: After these class and function definitions, we create one instance of this class
    that will watch touchpad A1\. We then enter into an infinite loop that repeatedly
    checks for state changes and prints out a message each time one occurs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些类和函数定义之后，我们创建了这个类的一个实例，它将监视触摸板A1。然后我们进入一个无限循环，不断检查状态变化，并在每次发生状态变化时打印出一条消息。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: It's always a good idea to set a touch threshold on your touchpads. If you don't,
    you will get a lot of false positives when interacting with the touchpad. The
    value that has been chosen, `400`, is a value that is suitable to this specific
    setup of connecting bananas with alligator clips. It's best to connect the actual
    objects intended for use with your project, and then fine-tune this value to a
    suitable value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在触摸板上设置触摸阈值总是一个好主意。如果不这样做，当与触摸板交互时会出现很多误报。所选择的值`400`是适合将香蕉与鳄鱼夹连接的特定设置的值。最好连接实际用于项目的对象，然后将该值微调为合适的值。
- en: In this recipe, we have mixed the uses of functions and classes. This approach
    is perfectly fine in Python, and it lets you have the best of both worlds. We
    needed to keep track of the state between each call to the process method, which
    is why we chose a class for that purpose. The callback doesn't need to keep track
    of any states between calls, so a simple function does the job just fine.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们混合了函数和类的用法。这种方法在Python中是完全可以的，它让你同时拥有两种最好的方式。我们需要在每次调用`process`方法之间保持状态，这就是为什么我们选择了一个类来实现这个目的。回调函数不需要在调用之间保持任何状态，所以一个简单的函数就可以胜任。
- en: See also
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation on the `TouchIn` class can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/TouchIn.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/TouchIn.html).
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`TouchIn`类的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/TouchIn.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/touchio/TouchIn.html)找到。
- en: Documentation on the `board` Python module can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html#module-board](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html#module-board).
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`board` Python模块的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html#module-board](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/board/__init__.html#module-board)找到。
- en: Creating a function to enable speaker output
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数来启用扬声器输出
- en: In this recipe, you will learn how to create a function that, when called, will
    enable the speaker. If you don't enable the speaker before audio playback, then
    it will be played through pin A0, which can have a headphone connected to it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何创建一个函数，当调用时，将启用扬声器。如果在音频播放之前不启用扬声器，那么它将通过引脚A0播放，可以连接耳机。
- en: This project will use the speaker on the board instead of headphones, so we
    will need this function to enable the speaker at the start of our script. Beyond
    showing you how to enable the speaker, this recipe will also introduce you to
    ways of digitally controlling input/output pins.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将使用板子上的扬声器而不是耳机，所以我们需要在脚本开始时使用这个函数来启用扬声器。除了向您展示如何启用扬声器之外，这个示例还将向您介绍数字控制输入/输出引脚的方法。
- en: Getting ready
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本示例中提供的代码。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个示例所需的步骤：
- en: 'Execute the next block of code in the REPL:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行下一个代码块：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'At this stage, we have created an object that is connected to the pin, which
    will enable the speaker. Run the next block of code to enable the speaker:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经创建了一个连接到启用扬声器的引脚的对象。运行下一个代码块来启用扬声器：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Reload the board and enter the REPL again. The next block of code will define
    the function to enable the speaker, and will call it:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新加载板子并再次进入REPL。下一个代码块将定义启用扬声器的函数，并调用它：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `enable_speakers` function is defined first. It doesn't receive any arguments,
    as there is only one speaker on the board to enable, and it returns nothing, as
    once the speaker is enabled, its pin doesn't need to be interacted with again.
    The `DigitalInOut` object is used to interact with the pin that will enable the
    speaker. Once this object is created, the `switch_to_output` method is called
    to enable speaker output. After the function is defined, it is called to enable
    the speakers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 首先定义了`enable_speakers`函数。它不接收任何参数，因为板子上只有一个扬声器需要启用，并且不返回任何东西，因为一旦扬声器启用，它的引脚就不需要再进行交互。`DigitalInOut`对象用于与启用扬声器的引脚进行交互。创建了这个对象后，调用`switch_to_output`方法来启用扬声器输出。在定义函数之后，调用它来启用扬声器。
- en: There's more...
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `DigitalInOut` object that is used in this recipe can be used to interact
    with a wide range of pins. On this board, for example, it can be used to connect
    the pins that read input from push button A and push button B. Once you connect
    and configure these push button pins correctly, you can start polling the pin’s
    value to check whether the push button is pressed.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中使用的`DigitalInOut`对象可以用来与各种引脚进行交互。例如，在这块板子上，它可以用来连接读取来自按键A和按键B的输入的引脚。一旦正确连接和配置这些按键引脚，就可以开始轮询引脚的值，以检查按键是否被按下。
- en: See also
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Example usage of the `DigitalInOut` object can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-digital-in-out](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-digital-in-out).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DigitalInOut`对象的示例用法可以在[https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-digital-in-out](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-digital-in-out)找到。'
- en: Documentation on the `DigitalInOut` object can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/digitalio/DigitalInOut.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/digitalio/DigitalInOut.html).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于`DigitalInOut`对象的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/digitalio/DigitalInOut.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/digitalio/DigitalInOut.html)找到。
- en: Creating a function to play audio files
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个函数来播放音频文件
- en: In this recipe, you will learn how to create a function that, when called, will
    play a specific audio file on the built-in speakers. This recipe will illustrate
    how to get access to the audio output device, as well as how to read the contents
    of a `.wav` file, convert it to an audio stream, and feed that audio stream to
    the onboard audio playback device. The techniques shown in this recipe can be
    used in all sorts of projects that need more fine control over the way audio files
    are played back.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，您将学习如何创建一个函数，当调用时，将在内置扬声器上播放特定的音频文件。这个示例将说明如何访问音频输出设备，以及如何读取`.wav`文件的内容，将其转换为音频流，并将该音频流馈送到板载音频播放设备。这个示例中展示的技术可以用于各种需要更精细控制音频文件播放方式的项目中。
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本教程所需的步骤：
- en: 'Use the REPL to run the following lines of code:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'At this stage, we have enabled the speaker and have created an object to feed
    audio data to the speakers. When you run the next block of code, you should hear
    a piano note play on the speakers:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个阶段，我们已经启用了扬声器，并创建了一个对象来向扬声器提供音频数据。当您运行下一块代码时，您应该听到扬声器上播放钢琴音符：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Run the next block of code to hear the same piano note again, but this time,
    played back through a function call:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一块代码以再次听到相同的钢琴音符，但这次是通过函数调用播放：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will play a single piano note each time the board is reloaded:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中，当执行时，它将在重新加载板时播放单个钢琴音符：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: First, the speakers are enabled so that we can hear the audio playback without
    headphones. The `AudioOut` class is then used to access the audio output device.
    The `play_file` function is then called with the speaker audio object and the
    path to the audio file that will be played. This function opens the file in binary
    mode.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启用扬声器，以便我们可以在没有耳机的情况下听到音频播放。然后使用`AudioOut`类来访问音频输出设备。然后调用`play_file`函数，传递扬声器音频对象和将要播放的音频文件的路径。此函数以二进制模式打开文件。
- en: This file object is then used to create a `WaveFile` object, which will return
    us the data as an audio stream. This audio data is then given to the `play` method
    on the `AudioOut` object to start playback. This method immediately returns, and
    doesn't wait for playback to complete. This is why the `sleep` method is called
    afterward, to give the board a chance to play the audio stream before the main
    script ends execution.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用此文件对象创建`WaveFile`对象，该对象将以音频流的形式返回数据。然后将此音频数据提供给`AudioOut`对象上的`play`方法以开始播放。此方法立即返回，并且不等待播放完成。这就是为什么之后调用`sleep`方法，以便在主脚本结束执行之前给板子一个播放音频流的机会。
- en: If you exclude this line of code from the file and reload the code, then the
    script will exit before the board has a chance to play the file, and you won’t
    hear any audio being played back.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您从文件中排除这行代码并重新加载代码，那么脚本将在板子有机会播放文件之前退出，您将听不到任何音频播放。
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using this function, you can play any number of audio files by just passing
    the audio output object and the file path. You can also use this recipe as a starting
    point to experiment further with the audio playback library that comes with this
    board. For example, there's a method to poll and check whether the last provided
    stream is still playing, or if it has finished playback.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此函数，您可以通过仅传递音频输出对象和文件路径来播放任意数量的音频文件。您还可以将此教程用作进一步尝试与此板附带的音频播放库的起点。例如，有一种方法可以轮询和检查最后提供的流是否仍在播放，或者是否已完成播放。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation on the `AudioOut` object can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/AudioOut.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/AudioOut.html).
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`AudioOut`对象的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/AudioOut.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/AudioOut.html)找到。
- en: Documentation on the `WaveFile` object can be found at [https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/WaveFile.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/WaveFile.html).
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关`WaveFile`对象的文档可以在[https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/WaveFile.html](https://circuitpython.readthedocs.io/en/3.x/shared-bindings/audioio/WaveFile.html)找到。
- en: Using the NeoPixel object to control pixels
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用NeoPixel对象控制像素
- en: In this recipe, you will learn how to control the pixels on the board using
    the NeoPixel object. We covered a lot of the methods in this object in previous
    chapters, but this is the first time we will directly create a NeoPixel object.
    It’s useful to have the skills to directly use the NeoPixel object, instead of
    accessing it through another object. You will need these skills if you decide
    to add an additional ring or strip of pixels to your project. In those cases,
    you will need direct access to this object to control the pixels.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，您将学习如何使用NeoPixel对象控制板上的像素。我们在之前的章节中涵盖了这个对象中的许多方法，但这是我们第一次直接创建NeoPixel对象。直接使用NeoPixel对象的技能非常有用，而不是通过另一个对象访问它。如果您决定向项目添加额外的环或像素条，那么您将需要直接访问此对象来控制像素。
- en: Getting ready
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL来运行本教程中提供的代码。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本教程所需的步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After running the previous block of code, the first pixel should become the
    color red. Run the next block of code to make the second pixel green:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在运行上一个代码块之后，第一个像素应该变成红色。运行下一个代码块以使第二个像素变成绿色：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run the next block of code to turn off the first pixel:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一个代码块以关闭第一个像素：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will color the first two pixels red and green:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中，当执行时，它将使前两个像素变成红色和绿色：
- en: '[PRE16]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `NeoPixel` class is used to access the array of pixels on the board. When
    we create this object, we have to specify the pin on the board to connect to and
    the number of pixels connected to that pin.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`NeoPixel`类用于访问板上的像素数组。当我们创建此对象时，我们必须指定要连接到的板上的引脚以及连接到该引脚的像素数。'
- en: In the case of Circuit Playground Express, there are 10 pixels on the board.
    We keep this value in a global constant to improve code readability. We then set
    the brightness of the pixels to 5%.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Circuit Playground Express的情况下，板上有10个像素。我们将此值保存在全局常量中，以提高代码的可读性。然后将像素的亮度设置为5%。
- en: The names and hex codes for the five different colors we need in the project
    are defined in a global dictionary. The colors white, green, red, and yellow,
    each relate to the four colors of the attached wires. The color black is used
    to switch off a pixel. We then set the first and second pixels to the colors red
    and green. Finally, we run an infinite loop, so that we can see these colors and
    stop the script from exiting.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中需要的五种不同颜色的名称和十六进制代码在全局字典中定义。白色、绿色、红色和黄色分别与附加电线的四种颜色相关。黑色用于关闭像素。然后，我们将第一个和第二个像素设置为红色和绿色。最后，我们运行一个无限循环，以便我们可以看到这些颜色并阻止脚本退出。
- en: There's more...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This code has everything required to interact with any of the 10 pixels that
    come with the board. You can take this base code and start experimenting with
    the different methods available on the provided object. Using these different
    methods, you can change the color of all the pixels in one call. You can also
    turn off the default auto-write feature, and then have direct control over when
    the changes you make to colors get applied. This low-level control of the pixels
    is all available through this library.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码具有与板载的任何10个像素进行交互所需的一切。您可以使用此基本代码开始尝试提供对象上可用的不同方法。使用这些不同的方法，您可以一次性更改所有像素的颜色。您还可以关闭默认的自动写入功能，然后直接控制您对颜色所做的更改何时应用。通过此库，可以完全控制像素的低级别控制。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation on ways of testing the pixel features can be found at [https://circuitpython.readthedocs.io/projects/neopixel/en/latest/examples.html](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/examples.html).
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://circuitpython.readthedocs.io/projects/neopixel/en/latest/examples.html](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/examples.html)找到有关测试像素功能的文档。
- en: An overview of the NeoPixel driver can be found at [https://circuitpython.readthedocs.io/projects/neopixel/en/latest/](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/).
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://circuitpython.readthedocs.io/projects/neopixel/en/latest/](https://circuitpython.readthedocs.io/projects/neopixel/en/latest/)找到NeoPixel驱动程序的概述。
- en: Creating a touch handler to play sounds
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建触摸处理程序以播放声音
- en: In this recipe, we will create the first version of our touch handler. This
    first version will play a specific audio file each time a touch event is detected.
    We can then use this handler in later recipes, in order to map each touchpad to
    a specific audio file. We will also expand the functionality of this handler in
    future recipes to add light, as well as sound, to the touch event. Event handlers
    are a common part of many software systems. This recipe will help you see how
    you can use this common approach with your MicroPython projects.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们将创建我们的触摸处理程序的第一个版本。此第一个版本将在检测到触摸事件时播放特定的音频文件。然后，我们可以在以后的教程中使用此处理程序，以将每个触摸板映射到特定的音频文件。我们还将在以后的教程中扩展此处理程序的功能，以在触摸事件中添加光和声音。事件处理程序是许多软件系统的常见部分。本教程将帮助您了解如何在MicroPython项目中使用这种常见方法。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本教程中提供的代码。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看本教程所需的步骤：
- en: 'Execute the next block of code in the REPL:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中执行下一块代码：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At this point, we have enabled the speakers and have set up an object to play
    audio files on the speaker. In the next block of code, we will define a `Handler`
    class and then create an instance of it that will use our `speaker` object:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，我们已经启用了扬声器，并设置了一个对象来在扬声器上播放音频文件。在下一块代码中，我们将定义一个`Handler`类，然后创建一个将使用我们的`speaker`对象的实例：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When you run the next block of code, you should hear a piano sound on the speaker:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行下一块代码时，您应该能听到扬声器上的钢琴声音：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will play a piano sound each time the touchpad A1 is touched:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中，当执行时，每次触摸A1触摸板时都会播放钢琴声音：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `Handler` class that is defined will be used to react to touch events. It
    expects one argument in the constructor, which is the `speaker` object that will
    handle audio playback. This object is saved to an attribute on the object instance.
    This class then defines a method that will be called each time a touch event has
    occurred. The method expects the first argument to be the name of the touchpad,
    and the second argument is a Boolean value that indicates the state of the touchpad.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 所定义的`Handler`类将用于响应触摸事件。它在构造函数中期望一个参数，即将处理音频播放的`speaker`对象。此对象保存到对象实例的属性中。然后，该类定义了一个方法，每次发生触摸事件时都会调用该方法。该方法期望第一个参数是触摸板的名称，第二个参数是指示触摸板状态的布尔值。
- en: When the method is called, it checks whether the pad is being touched; if so,
    it calls the `play_file` function to play the piano sound. The remainder of the
    code in the recipe supports the process of continually checking for new touch
    events and calls the defined handler.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用该方法时，它会检查触摸板是否被触摸；如果是，则调用`play_file`函数播放钢琴声音。本教程中的其余代码支持不断检查新触摸事件并调用已定义的处理程序的过程。
- en: There's more...
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The recipe in this example only plays one sound as a single touchpad is pressed.
    However, it also creates the core structure for us to expand. You can experiment
    with this recipe and try two touchpads, each playing a different sound. You could
    do this by having multiple defined event objects connected to different handlers.
    In later recipes, you will see that a single event class definition and a single
    handler class definition can be used to connect to four different pads and play
    four different sounds.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，配方只会在按下单个触摸板时播放一个声音。但是，它也为我们扩展提供了核心结构。您可以尝试使用这个配方并尝试两个触摸板，每个都播放不同的声音。您可以通过将多个定义的事件对象连接到不同的处理程序来实现这一点。在以后的配方中，您将看到单个事件类定义和单个处理程序类定义可以用于连接到四个不同的触摸板并播放四种不同的声音。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Here are a few references:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: The source code for the `AudioOut` class can be found at [https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/AudioOut.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/AudioOut.c).
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AudioOut`类的源代码可以在[https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/AudioOut.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/AudioOut.c)找到。'
- en: The source code for the `WaveFile` class can be found at [https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/WaveFile.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/WaveFile.c).
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WaveFile`类的源代码可以在[https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/WaveFile.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/audioio/WaveFile.c)找到。'
- en: Creating a touch handler to light up pixels
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个触摸处理程序来点亮像素
- en: In this recipe, we will create a touch handler that will react to touch events
    by playing sounds and lighting up pixels. When the touch sensor gets triggered,
    the handler will play a sound and light up a specific pixel. When the touch sensor
    detects that you have released your finger, the specific pixel that was lit up
    will turn off.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将创建一个触摸处理程序，通过播放声音和点亮像素来对触摸事件做出反应。当触摸传感器被触发时，处理程序将播放声音并点亮特定的像素。当触摸传感器检测到您已经松开手指时，点亮的特定像素将关闭。
- en: In this way, you can hear and see the board react to each of the configured
    touchpads uniquely. This recipe shows a useful way to create different types of
    output, based on different triggered input. Many projects can come to life when
    you add a mix of unique audio and visual output that will react to different types
    of human input.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式，您可以听到并看到板子对每个配置的触摸板的独特反应。这个配方展示了一种有用的方式，可以根据不同的触发输入创建不同类型的输出。当您添加一些独特的音频和视觉输出以对不同类型的人类输入做出反应时，许多项目可以变得生动起来。
- en: Getting ready
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备好
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本配方中提供的代码。
- en: How to do it...
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个配方所需的步骤：
- en: 'Use the REPL to run the following lines of code. This will set up the speakers
    and create an object to interact with the pixels:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用REPL运行以下代码行。这将设置扬声器并创建一个与像素交互的对象：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the next block of code, we will define a `Handler` class and then create
    an instance of it to which we will pass the objects to deal with the speaker and
    pixels:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一块代码中，我们将定义一个`Handler`类，然后创建一个实例，将对象传递给它来处理扬声器和像素：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When you run the next block of code, you should hear a piano sound on the speaker,
    and the first pixel should turn red:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您运行下一块代码时，您应该听到扬声器上的钢琴声音，并且第一个像素应该变成红色：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the next block of code, and you should see the first pixel light switch
    off:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一块代码，您应该看到第一个像素灯关闭：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code should be put into the `main.py` file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When the script is executed, it will play a piano sound and light up a pixel
    each time touchpad A1 is touched.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行脚本时，它将在触摸A1时播放钢琴声音并点亮一个像素。
- en: How it works...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Handler` class that is defined will play sounds and light up pixels each
    time a touch event is detected. The constructor of this class takes the speaker
    and pixel objects and saves them to the instance for later use. Each time the
    `handle` method is called, it checks whether the touchpad is currently pressed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 定义的`Handler`类将在检测到触摸事件时播放声音并点亮像素。这个类的构造函数接受扬声器和像素对象，并将它们保存到实例中以供以后使用。每次调用`handle`方法时，它都会检查触摸板当前是否被按下。
- en: If it is pressed, a pixel is lit up and a sound is played. If the pad is released,
    that same pixel is turned off. The remainder of the script is in charge of initializing
    the speaker and pixels so that they can be used by the handler, and for creating
    an infinite loop that will keep calling the handler each time an event is detected.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按下，一个像素会点亮并播放声音。如果释放垫子，同一个像素将关闭。脚本的其余部分负责初始化扬声器和像素，以便它们可以被处理程序使用，并创建一个无限循环，每次检测到事件时都会调用处理程序。
- en: There's more...
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The script in this recipe lights up a specific pixel each time. You can extend
    it to use a random color each time the touchpad is pressed. There are ways to
    light up more pixels the longer a touchpad is pressed. Another fun experiment
    to try would be to have the board play a random sound each time an event occurred.
    Now that we have added sound and light, there are more options to apply creativity
    to this project and to create a more unique project.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方中的脚本每次都会点亮一个特定的像素。您可以扩展它，每次按下触摸板时使用随机颜色。有多种方法可以在按下触摸板的时间越长时点亮更多的像素。另一个有趣的实验是在每次事件发生时让板子播放随机声音。现在我们已经添加了声音和光，有更多的选择可以将创造力应用到这个项目中，并创建一个更独特的项目。
- en: See also
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另见
- en: 'Here are a few references:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: A project that connects limes to Circuit Playground Express can be found at
    [https://learn.adafruit.com/circuit-playground-express-piano-in-the-key-of-lime/](https://learn.adafruit.com/circuit-playground-express-piano-in-the-key-of-lime/).
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在[https://learn.adafruit.com/circuit-playground-express-piano-in-the-key-of-lime/](https://learn.adafruit.com/circuit-playground-express-piano-in-the-key-of-lime/)找到将酸橙连接到Circuit
    Playground Express的项目。
- en: The source code for the `TouchIn` class can be found at [https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/touchio/TouchIn.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/touchio/TouchIn.c).
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TouchIn`类的源代码可以在[https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/touchio/TouchIn.c](https://github.com/adafruit/circuitpython/blob/3.x/shared-bindings/touchio/TouchIn.c)找到。'
- en: Creating an event loop to handle all touch events
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建事件循环以处理所有触摸事件
- en: This final recipe in this chapter takes all the previous recipes in this chapter
    and combines them to complete the banana power musical machine. Beyond the previous
    recipes, we will need to create an event loop that combines all this logic into
    one structure that can handle all the four touchpads and their related audio files
    and pixels. After going through this recipe, you will be able to create generic
    event loops and handlers that can be extended to meet the varying needs of the
    embedded projects you might create.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一个教程将本章中的所有先前教程结合起来，以完成香蕉音乐机。除了以前的教程之外，我们还需要创建一个事件循环，将所有这些逻辑结合到一个结构中，以处理所有四个触摸板及其相关的音频文件和像素。完成本教程后，您将能够创建通用的事件循环和处理程序，以满足您可能创建的嵌入式项目的不同需求。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need access to the REPL on Circuit Playground Express to run the code
    presented in this recipe.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要访问Circuit Playground Express上的REPL才能运行本教程中提供的代码。
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作步骤...
- en: 'Let''s go over the steps required for this recipe:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看完成本教程所需的步骤：
- en: 'Run the following lines of code in the REPL:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中运行以下代码行：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We have now imported all the libraries we need and have created the main data
    structures that we need in our script. Run the next block of code, and the speakers
    should play a piano sound:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经导入了我们脚本中所需的所有库，并创建了我们脚本中所需的主要数据结构。运行下一个代码块，扬声器应该会播放钢琴声音：
- en: '[PRE27]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Run the next block of code to create an instance of our event handler:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一个代码块以创建我们事件处理程序的实例：
- en: '[PRE28]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run the next block of code to simulate a touch event on pad 2\. You should
    hear a piano sound and see one of the pixels turn red:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行下一个代码块以模拟在2号触摸板上的触摸事件。您应该听到钢琴声音，并看到一个像素变红：
- en: '[PRE29]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code should be put into the `main.py` file and, when executed,
    it will play different sounds and light up different pixels each time one of the
    four configured touchpads is pressed:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码应放入`main.py`文件中，当执行时，每次按下四个配置的触摸板之一时，它将播放不同的声音并点亮不同的像素：
- en: '[PRE30]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `main` function contains our event loop. This function first initializes
    the speakers and pixels. Then, it creates a single handler instance. This single
    handler instance is generic enough that it will be used as the handler for all
    four of the touchpads.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`函数包含我们的事件循环。该函数首先初始化扬声器和像素。然后，它创建一个单个处理程序实例。这个单个处理程序实例足够通用，可以用作所有四个触摸板的处理程序。'
- en: Then, a list of events is created, where each one is connected to one of the
    four pads. An infinite loop is started that loops through each event object and
    calls its `process` method to call the event handler whenever a change in the
    touchpad state is detected.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个事件列表，其中每个事件都连接到四个触摸板中的一个。启动一个无限循环，循环遍历每个事件对象，并调用其`process`方法，以便在检测到触摸板状态变化时调用事件处理程序。
- en: The constants at the top of the script are used to specify the names of the
    touchpads to use, which sound files to play for each pad, and the pixel position
    and color to set when a pad is pressed.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本顶部的常量用于指定要使用的触摸板的名称，每个触摸板要播放的声音文件，以及按下触摸板时要设置的像素位置和颜色。
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This script makes heavy use of a number of data structures, so that values don't
    need to be hardcoded in the function and class definitions. Dictionaries are used
    as a natural structure to map each pad name to the audio filename that should
    be played. A list of data structures is used to define the names of the touchpads
    that will be connected. Finally, a dictionary of tuples is used to map the touchpad
    to its related pixel position and color. Python has a rich set of data structures
    that, when leveraged effectively, can make code much more readable and maintainable.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本大量使用了多种数据结构，以便在函数和类定义中不需要硬编码值。使用字典作为自然结构，将每个触摸板名称映射到应该播放的音频文件名。使用数据结构列表定义将连接的触摸板的名称。最后，使用元组的字典将触摸板映射到其相关的像素位置和颜色。Python具有丰富的数据结构集，有效利用时可以使代码更易读和易维护。
- en: 'This project connects four bananas to the board, with each banana playing a
    different sound when touched. Because the code was constructed to respond to each
    touch immediately, you can even have two people play at the same time. The next
    photograph shows two people, each with a pair of bananas, creating music and controlling
    the pixels on the board:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目将四根香蕉连接到板上，每根香蕉触摸时都会播放不同的声音。由于代码被构造为立即响应每次触摸，所以甚至可以让两个人同时玩。下一张照片显示了两个人，每人手持一对香蕉，创作音乐并控制板上的像素：
- en: '![](assets/1f1a81c1-81e3-46f5-9b39-db853ae75ba1.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1f1a81c1-81e3-46f5-9b39-db853ae75ba1.png)'
- en: See also
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Here are a few references:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些参考资料：
- en: Documentation on providing audio output with CircuitPython can be found at [https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-audio-out](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-audio-out).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关使用CircuitPython提供音频输出的文档可以在[https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-audio-out](https://learn.adafruit.com/adafruit-circuit-playground-express/circuitpython-audio-out)找到。
- en: The source code for the `NeoPixel` class can be found at [https://github.com/adafruit/Adafruit_CircuitPython_NeoPixel](https://github.com/adafruit/Adafruit_CircuitPython_NeoPixel).
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NeoPixel`类的源代码可以在[https://github.com/adafruit/Adafruit_CircuitPython_NeoPixel](https://github.com/adafruit/Adafruit_CircuitPython_NeoPixel)找到。'
