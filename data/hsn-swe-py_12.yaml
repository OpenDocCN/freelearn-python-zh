- en: Persisting Object Data to Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将对象数据持久化到文件
- en: At first glance, the process of reading and writing data to and from a file
    system-resident data store probably looks much simpler than the equivalent processes
    for many database-backed storage mechanisms. Reading and writing files, after
    all, is a very basic process. In reality, it's a slightly more complex process,
    though. There are precautions that need to be taken to deal with things such as
    file system permissions, hard shutdowns of the application using data access,
    and even system crashes, to some degree. While these complicate development somewhat,
    they are perhaps more challenging to identify as possibilities than they are to
    implement safeguards around.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，读取和写入文件系统驻留数据存储的过程可能看起来比许多基于数据库的存储机制的等效过程简单得多。毕竟，读写文件是一个非常基本的过程。但实际上，这是一个稍微复杂的过程。需要采取预防措施来处理诸如文件系统权限、应用程序使用数据访问的硬关闭，甚至系统崩溃等问题。虽然这些使开发变得复杂，但它们可能更具挑战性，因为它们更难以识别为可能性，而不是实施保障措施。
- en: 'This chapter will cover the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: The basic component project setup for `hms_artisan`
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_artisan`的基本组件项目设置'
- en: A further abstraction layer to encapsulate the file system-based data storage
    needs involved
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步的抽象层，以封装基于文件系统的数据存储需求
- en: 'The development of data objects in the `hms_artisan` component project for
    the following:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hms_artisan`组件项目中数据对象的开发包括以下内容：'
- en: Artisans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Artisans
- en: Products
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品
- en: Orders
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单
- en: Setting up the hms_artisan project
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置hms_artisan项目
- en: 'With all of the foundation classes we need (so far) defined in `hms_core`,
    we can start building out the concrete classes that correspond to them in other
    projects. Since the plan is for the **Artisan Application** to have a custom,
    local data storage mechanism, and that''s likely going to be more complicated
    than the equivalents in the Central Office application and the Artisan Gateway
    service, it arguably makes the most sense to start with that project, and by creating
    a project structure to meet the needs of this story:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们需要的所有基础类（到目前为止）在`hms_core`中定义，我们可以开始在其他项目中构建与它们对应的具体类。由于计划是让**Artisan应用程序**具有自定义的本地数据存储机制，这可能会比中央办公室应用程序和Artisan网关服务中的等效机制更复杂，因此从这个项目开始并创建一个项目结构来满足这个故事的需求可能是最合理的：
- en: As a developer, I need a project for the Artisan Application so that I have
    a place to put the relevant code and build the application.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为开发人员，我需要一个项目来为Artisan应用程序提供一个放置相关代码和构建应用程序的地方。
- en: Initially, the code for the `hms_artisan` classes could start in the `hms_artisan/__init__.py` file,
    just as the business object ABCs in `hms_core` started in its root `__init__.py` file, but
    it seems reasonable to assume that some variant of the reason why those were just
    moved to their own `business_objects.py` module would be likely in the Artisan
    Application codebase. With that in mind, we'll create an `artisan_objects.py` module
    to keep them grouped and organized. That will also make it easier to keep any
    data storage classes that we might need that aren't themselves data objects in
    a separate module in the same package. We could just as easily put all of the
    Artisan Application code into a single module (`hms_artisan.py`) instead of having
    a package directory and the attendant files therein. There's no functional reason
    for not doing so, but unless there's some certainty that there would never be
    a need to change from that single module file implementation to a package structure,
    it raises the longer-term risk of having to reorganize the entire namespace file
    structure. The starting project structure looks very much like the default defined
    in [Chapter 7](cabfde73-7c51-4741-8832-ca8427793869.xhtml), *Setting Up Projects
    and Processes:*
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`hms_artisan`类的代码可以从`hms_artisan/__init__.py`文件开始，就像`hms_core`中的业务对象ABC一样从其根`__init__.py`文件开始，但可以合理地假设，这些类似的原因的变体很可能出现在Artisan应用程序代码库中。考虑到这一点，我们将创建一个`artisan_objects.py`模块来对它们进行分组和组织。这也将更容易地将我们可能需要的任何数据存储类（它们本身不是数据对象）放在同一个包中的一个单独模块中。我们可以很容易地将**Artisan应用程序**的所有代码放入一个单独的模块（`hms_artisan.py`）中，而不是在包目录中以及相关文件中。这样做没有功能上的理由，但除非可以确定从单一模块文件实现到包结构不需要更改，否则会增加长期风险，需要重新组织整个命名空间文件结构。起始项目结构看起来非常像[第7章](cabfde73-7c51-4741-8832-ca8427793869.xhtml)中定义的默认结构，*设置项目和流程：*
- en: '![](assets/9949e782-e703-4bd8-9ba5-f4d5636b28a8.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/9949e782-e703-4bd8-9ba5-f4d5636b28a8.png)'
- en: That sort of reorganization is not difficult, but it is time consuming, all
    the more so if unit test modules also have to be reorganized. When such a reorganization
    is under way, it has the potential to limit other work against a codebase by anyone
    who isn't part of the reorganization effort. It also has a lot of potential to
    make source control management very messy until it's complete, which isn't a great
    situation for a member of a dev team with other tasks to execute against that
    codebase to be in.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这种重新组织并不困难，但如果还需要重新组织单元测试模块，那么它就会更加耗时。当这样的重新组织正在进行时，它有可能限制其他人对代码库的工作，这些人不是重新组织的一部分。直到完成之前，它还有可能使源代码控制管理变得非常混乱，这对于开发团队的成员来说并不是一个很好的情况。
- en: The odds are good that we'll want or need a separate module for the actual application
    anyway, though, so it just makes sense to start subdividing code into logical
    groupings at the outset.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能需要一个单独的模块来实际应用程序，但从一开始就将代码细分为逻辑分组是有意义的。
- en: Creating a local file system data store
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建本地文件系统数据存储
- en: 'Artisans'' needs for storing data are captured in two stories:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Artisans对存储数据的需求包括两个故事：
- en: As an Artisan, I need a local data store for all of my system data, so that
    I don't have to be connected to the internet to make changes
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为Artisan，我需要一个本地数据存储来存储所有系统数据，这样我就不必连接到互联网来进行更改
- en: As an Artisan, I need my local data store to be as simple as possible, requiring
    no additional software installations, so that I don't have to worry about installing
    and maintaining a database system as well as the Artisan Application
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个工匠，我需要我的本地数据存储尽可能简单，不需要额外的软件安装，这样我就不必担心安装和维护数据库系统以及工匠应用程序
- en: 'The final relationships between the various Artisan Application data objects
    and `BaseDataObject` could be as simple as having each Artisan-level class derive
    directly from `BaseDataObject`. Indeed, if there were only one such class at the
    Artisan level, and no expectation of that changing in the foreseeable future,
    it would make a lot of sense to take that approach. The code that would handle
    the creation of record files, updating the data therein, reading it, or deleting
    it could live in a lone class. Since there are three object types that we need
    to be concerned with, though, there is at least some potential benefit to collecting
    a common functionality for file-based data stores into another abstract class
    that lives between `BaseDataObject` and the concrete `hms_artisan` classes, such
    as `hms_artisan..Artisan`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 各种工匠应用程序数据对象与`BaseDataObject`之间的最终关系可能只是让每个工匠级别的类直接从`BaseDataObject`派生。实际上，如果在工匠级别只有一个这样的类，并且在可预见的将来没有期望发生变化，采取这种方法是很有意义的。处理记录文件的创建、更新其中的数据、读取或删除的代码可以存在于一个类中。然而，由于我们需要关注的对象类型有三种，因此将基于文件的数据存储的共同功能收集到另一个抽象类中，该抽象类位于`BaseDataObject`和具体`hms_artisan`类之间，例如`hms_artisan..Artisan`，至少有一些潜在的好处：
- en: '![](assets/1069c52d-81b7-4a36-a9be-92c7ce612eb6.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1069c52d-81b7-4a36-a9be-92c7ce612eb6.png)'
- en: That intermediary class, `JSONFileDataObject`, would extend `BaseDataObject`,
    adding functionality and data that is specific to the task of managing object
    state data that lives in a collection of JSON-formatted files. At the same time,
    it would preserve the abstraction requirements from `BaseDataObject`, or provide
    a concrete implementation of them and make them available to classes such as `hms_artisan..Artisan`.
    The net benefit of this inheritance structure is that, ideally, all of the functionality
    necessary to perform CRUD operations against a JSON-backed data store of objects would
    be able to reside in one place. Realistically, some of the specifics may have to
    live in the concrete class implementations – otherwise, they could all be wrapped
    into a single class, after all – but there will almost certainly be substantial
    commonalities that can be implemented in that middle inheritance level.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该中间类`JSONFileDataObject`将扩展`BaseDataObject`，添加特定于管理以JSON格式文件集合中存在的对象状态数据任务的功能和数据。同时，它将保留来自`BaseDataObject`的抽象要求，或者提供它们的具体实现并使它们可用于诸如`hms_artisan..Artisan`之类的类。这种继承结构的净收益是，理想情况下，执行针对对象的JSON后备数据存储的CRUD操作所需的所有功能都能够驻留在一个地方。实际上，一些具体细节可能必须驻留在具体类实现中，否则，它们最终都可以包装到一个类中，但几乎肯定会有相当多的共同点可以在中间继承级别中实现。
- en: 'A more complete collection of goals for any class derived from `JSONFileDataObject` would
    include the following, at a minimum:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从`JSONFileDataObject`派生的任何类的更完整的目标集，至少应包括以下内容：
- en: All of the stored data for any derived class should probably live in one location
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何派生类的所有存储数据可能应该存储在一个位置
- en: Instance data for each object type (class) should probably live in a common
    location within the top-level location
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象类型（类）的实例数据可能应该存储在顶层位置的一个共同位置
- en: Data for any given instance should probably reside in a single, distinct file,
    whose name can be uniquely related to the instance whose data it stores
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何给定实例的数据可能应该存储在一个单独的文件中，其名称可以与存储其数据的实例唯一相关联
- en: 'Additionally, there are some should-have or nice-to-have functionalities that
    are worth considering:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些应该具有或值得考虑的功能：
- en: 'Data reading operations would be faster if the process didn''t involve finding,
    opening, reading, and creating objects for every file every time a data read was
    executed. A trade-off for this is that any time data-altering operations are executed,
    they have to be responsible for making the appropriate alterations to whatever
    data is involved, in all the places it lives. If there is an in-memory collection
    of objects that were read from the persistent files, for example:'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理过程不涉及每次执行数据读取时找到、打开、读取和创建对象，数据读取操作将更快。这样做的一个权衡是，每当执行改变数据的操作时，它们必须负责对所涉及的任何数据进行适当的修改，无论它们存在的所有位置。例如，如果有一个从持久文件中读取的对象的内存集合：
- en: Create operations would have to add new objects to the in-memory store
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建操作必须将新对象添加到内存存储中
- en: Updates would have to write to the data-store file and update the in-memory
    object
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新操作必须写入数据存储文件，并更新内存对象
- en: Deletions would have to remove the relevant file and remove the appropriate
    object from the in-memory store
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除操作必须删除相关文件，并从内存存储中删除适当的对象
- en: None of these are particularly difficult to implement, though.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都不是特别难以实现的。
- en: Implementing JSONFileDataObject
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现JSONFileDataObject
- en: 'Defining the `JSONFileDataObject` abstract class starts with a standard `ABCMeta` metaclass
    specification, and some class-level attributes for various purposes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 定义`JSONFileDataObject`抽象类始于标准的`ABCMeta`元类规范，以及用于各种目的的类级属性：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Where:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '`_file_store_dir` is a default file system directory specification that will
    eventually need to be read from a configuration file in the final installable
    application. For the time being, and for unit testing purposes, it will have a
    hardcoded value set that can be used during development and testing, and we''ll
    look at the configuration setup when we get to the Artisan Application''s implementation.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_file_store_dir`是一个默认的文件系统目录规范，最终需要从配置文件中读取。目前，为了单元测试目的，它将具有一个硬编码的值，可以在开发和测试期间使用，并且当我们到达Artisan应用程序的实现时，我们将查看配置设置。'
- en: '`_file_store_ready` is a flag value that will be used to indicate to the class
    whether it''s loaded all of the available objects from the data files, and thus
    whether it needs to load them before performing any CRUD operations.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_file_store_ready`是一个标志值，用于指示类是否已从数据文件中加载了所有可用对象，因此在执行任何CRUD操作之前是否需要加载它们。'
- en: '`_loaded_objects` is where the collection of objects loaded by the class will
    be stored. The actual object stores will be a `dict` of object instances, but
    until the loading operation has completed, it''s defaulted to `None` in order
    to make the determination between unloaded (`None`) and loaded-with-no-objects
    (an empty `dict`) states later on.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_loaded_objects`是存储类加载的对象集合的位置。实际对象存储将是对象实例的`dict`，但在加载操作完成之前，默认为`None`，以便在以后确定未加载（`None`）和已加载但没有对象（空`dict`）的状态之间进行区分。'
- en: Since it inherits from `BaseDataObject`, the class will start with the abstraction
    requirements defined there, and could not be instantiated without fulfilling those
    requirements. However, since we want `JSONFileDataObject` to also be abstract,
    it also has the standard ABC metaclass specification, and is itself abstract.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它继承自`BaseDataObject`，该类将从那里定义的抽象要求开始，并且如果不满足这些要求就无法实例化。但是，由于我们希望`JSONFileDataObject`也是抽象的，它也具有标准的ABC元类规范，并且本身也是抽象的。
- en: 'The signature of the initialization method of `JSONFileDataObject` is identical
    to that of the `BaseDataObject` it derives from, but it performs a few additional
    tasks during that process:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`JSONFileDataObject`的初始化方法的签名与其派生自的`BaseDataObject`相同，但在该过程中执行了一些额外的任务：'
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first new functionality involved is checking for a non-`None` value for
    the `_file_store_dir` class attribute. Since the whole point of these classes
    is to be able to save object data to JSON files, and that requires a place for
    those files to actually reside, not having one specified is a critical issue that
    would prevent any useful execution of CRUD operations, so an error is raised if
    a problem is detected:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的第一个新功能是检查`_file_store_dir`类属性的非`None`值。由于这些类的整个目的是能够将对象数据保存到JSON文件中，而这需要一个实际存放这些文件的位置，如果没有指定位置，这将是一个关键问题，将阻止任何有用的CRUD操作的执行，因此如果检测到问题，则会引发错误：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similarly, even if the file storage location is specified, that location has
    to exist, and be accessible to the code as it runs under the user''s account with
    the attendant permissions. Each class, then, needs to check for the location''s
    existence (and create it if it doesn''t exist), and make sure that files can be
    written, read, and deleted. This checking process could fire off every time an
    instance of the class is created, but if the process has completed once already,
    it should be satisfactory to skip it from that point on:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，即使指定了文件存储位置，该位置也必须存在，并且代码在用户帐户下以相应权限运行时必须可访问。然后，每个类都需要检查位置是否存在（如果不存在则创建），并确保可以写入、读取和删除文件。这个检查过程可能会在每次创建类的实例时触发，但如果该过程已经完成一次，那么从那时起跳过它应该是可以接受的：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s worth noting that since the `_file_store_ready` value is a class attribute,
    that value will persist for an entire Python run. That is, using the Artisan Application as
    an example, the following will happen:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，由于`_file_store_ready`值是一个类属性，该值将在整个Python运行期间持续存在。也就是说，以Artisan应用程序为例，将会发生以下情况：
- en: The application is started
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已启动
- en: At some point, a data object class instance is initialized (say, a `Product`),
    and the checking process runs, successfully verifying all the data storage needs
    for product objects and setting the `_file_store_ready` to `True` accordingly
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个时候，数据对象类实例被初始化（比如，一个`Product`），并且检查过程成功验证了产品对象的所有数据存储需求，并相应地将`_file_store_ready`设置为`True`
- en: The user does things with the application that don't interact with any product
    objects
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户对应用程序进行操作，不与任何产品对象进行交互
- en: Another product object is initialized, but because the `_file_store_ready` flag
    has been set to `True`, the check process is skipped
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个产品对象被初始化，但由于`_file_store_ready`标志已设置为`True`，因此跳过了检查过程
- en: As soon as the application is shut down, though, that flag value goes away,
    so the next time the application is started up, the check process is repeated
    the first time a product object is initialized.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，一旦应用程序关闭，该标志值就会消失，因此在下次启动应用程序时，初始化产品对象时会重复检查过程。
- en: 'File access permissions are, as noted already, also checked by first writing a
    file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面已经指出的，文件访问权限也通过首先写入文件进行检查：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, by reading the file that was just written:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过读取刚刚写入的文件：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And finally, by deleting that file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过删除该文件：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The balance of `__init__()` follows the same structure established earlier.
    Since the class has a parent class – `BaseDataObject` – it calls that initializer,
    but since there are no local properties to initialize or set values for, there
    aren''t any of those calls. All of the other properties'' initializations are
    handled by the call to `BaseDataObject.__init__`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`的其余部分遵循了先前建立的相同结构。由于该类有一个父类`BaseDataObject`，因此调用该初始化程序，但由于没有要初始化或设置值的本地属性，因此没有这些调用。所有其他属性的初始化都由对`BaseDataObject.__init__`的调用处理：'
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Three of the methods, either required by the abstraction in `BaseDataObject` or
    with concrete implementations, need to be addressed in `JSONFileDataObject`. The `_create` and `_update` methods
    are required by `BaseDataObject`, but don''t make a lot of sense in the context
    of this class because the same basic operation would take place whether the operation
    involved was a creation or update effort. Both of those, while implemented, do
    nothing more than raise an error with some information that would be useful for
    developers who encounter it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 三种方法，要么是由`BaseDataObject`中的抽象所需的，要么是具体实现的，需要在`JSONFileDataObject`中进行处理。`_create`和`_update`方法是`BaseDataObject`所需的，但在这个类的上下文中并没有太多意义，因为无论是创建还是更新操作，都会进行相同的基本操作。尽管这两个方法都已经实现，但它们只是提供一些对开发人员有用的信息，以便开发人员遇到错误时能够引发错误：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Those changes, then, put all the responsibility for writing data to files on
    the `save` method, no matter whether the data being saved represents a new/create
    action or an edit/update one. Although it''s not likely, it''s not impossible
    for the permissions of the directory where data files are stored to change while
    the program is running. They were checked initially, but that only means that
    they were valid at the time they were checked, so the process of writing data
    to files should check them as well, independently:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这些更改将所有写入数据到文件的责任都放在了`save`方法上，无论被保存的数据代表新的/创建操作还是编辑/更新操作。虽然不太可能，但在程序运行时，存储数据文件的目录的权限可能会发生变化。它们最初被检查过，但这只意味着它们在被检查时是有效的，因此写入数据到文件的过程也应该独立地检查它们：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It does need to confirm that objects have been loaded into memory first with `_load_objects`; at
    execution time, this will always be an instance of the class calling a class method that''s inherited, so
    the class has to be explicitly passed as an argument:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实需要首先确认对象已经加载到内存中，使用`_load_objects`；在执行时，这将始终是调用继承的类方法的类的实例，因此必须显式地将类作为参数传递：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then, it saves the data and confirms that the object itself is stored in memory:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它保存数据并确认对象本身存储在内存中：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If the file write fails (the `json.dump` call) with a permissions-related error,
    none of the in-memory updates will be committed, and a more end user-friendly
    error message should be raised, in case it needs to be displayed to that end user:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件写入失败（`json.dump`调用）出现与权限相关的错误，那么所有内存更新都不会被提交，并且应该引发更加用户友好的错误消息，以防需要显示给最终用户：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The same common storage location file system path values that allow the save method
    to be made concrete also allow the `delete` and `get` class methods to be made
    concrete class methods of `JSONFileDataObject`. Because the class properties define
    what''s needed to find the data files relevant to any/all object instances, delete
    code can directly make the needed file-deletion efforts, with the appropriate
    error handling:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的公共存储位置文件系统路径值不仅允许`save`方法变得具体，还允许`delete`和`get`类方法成为`JSONFileDataObject`的具体类方法。因为类属性定义了查找与任何/所有对象实例相关的数据文件所需的内容，`delete`代码可以直接进行所需的文件删除操作，并进行适当的错误处理：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `get` method doesn''t need read access to the files directly – the `_load_objects` class
    method handles that, loading all the data that  `get` relies upon – and once the
    relevant objects exist in memory, finding them, even with criteria or a combination
    of object IDs and criteria, is quite simple and fast:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`方法不需要直接访问文件的读取权限 - `_load_objects`类方法处理了这一点，加载了`get`所依赖的所有数据 - 一旦相关对象存在于内存中，即使有条件或对象ID和`criteria`的组合，找到它们也是非常简单和快速的：'
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If `oids` have been supplied, the process has to account for those, and for `criteria` if it was
    supplied:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`oids`，则该过程必须考虑到这些`oids`，以及如果提供了`criteria`，也要考虑到`criteria`：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If no `oids` were supplied, but `criteria` was, the process is similar:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有提供`oids`，但提供了`criteria`，则该过程类似：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In both branches, any filtering based on `criteria` is handled by the individual
    object's `matches` method, making the process of searching for objects by specific
    property values very easy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个分支中，基于`criteria`的任何过滤都是由各个对象的`matches`方法处理的，这使得通过特定属性值搜索对象的过程非常简单。
- en: 'All of these rely, then, on the `_load_objects` class method to retrieve and
    populate the in-memory copies of all objects whose data has been persisted as
    JSON files, and attaching them to the relevant class, in the `_loaded_objects` dictionary
    that was defined as a common class attribute:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都依赖于`_load_objects`类方法来检索和填充所有对象的内存副本，这些对象的数据已经被持久化为JSON文件，并将它们附加到相关的类中，在`_loaded_objects`字典中定义为一个公共类属性：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the data has not been loaded (indicated by the `_loaded_objects` attribute
    containing a `None` value), or if an explicit reload of data was called for (a `True` value
    received in the `force_load` argument), the method retrieves a list of all files
    in the class data directory, after verifying that the relevant directories exist,
    trying to create them if they don''t, and raising errors if they need to be created
    but cannot be:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据尚未加载（由`_loaded_objects`属性包含`None`值表示），或者如果需要显式重新加载数据（在`force_load`参数中收到`True`值），则该方法检索类数据目录中所有文件的列表，在验证相关目录存在后，尝试创建它们（如果它们不存在），并在需要创建但无法创建时引发错误：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If there are any files found, then an attempt is made to read each one, convert
    it from the JSON-encoded `data_dict` expected into an actual instance of the class,
    and add the instance to the `_loaded_objects` attribute. Since `_loaded_objects` is
    a class attribute, loaded values will persist for as long as that class definition
    is active. Barring an explicit purge or redefinition of the class itself, this
    will persist for the duration of the Python interpreter that''s running the code, allowing
    the data read in by the process to persist for as long as the code that''s using
    it is running:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到任何文件，则尝试读取每个文件，将其从预期的JSON编码的`data_dict`转换为实际的类实例，并将实例添加到`_loaded_objects`属性中。由于`_loaded_objects`是一个类属性，加载的值将持续存在，只要该类定义处于活动状态。除非显式清除或重新定义类本身，否则这将持续到运行代码的Python解释器的持续时间，使得进程中读取的数据可以持续存在：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Since it''s possible, even if it''s unlikely, for the file system permissions
    of the data files themselves or of the parent directories of the file to change
    while the Artisan Application is running, file reads could throw `PermissionError` exceptions,
    so those are caught and tracked until the process is complete:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在Artisan Application运行时，数据文件本身或文件的父目录的文件系统权限可能发生变化，文件读取可能会抛出`PermissionError`异常，因此这些异常被捕获并跟踪直到进程完成：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Similarly, if the content of a data file is invalid, an error is raised, though
    in this case it''s immediate. The rationale for the immediacy is that data has
    been corrupted, and that needs to be resolved before allowing any changes to occur:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果数据文件的内容无效，则会引发错误，尽管在这种情况下是立即的。立即性的理由是数据已经损坏，需要在允许发生任何更改之前解决。
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Any other errors will cascade out to the calling code, to be handled there or
    allowed to abort the application's execution.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 任何其他错误都将级联到调用代码，由那里处理或允许中止应用程序的执行。
- en: 'The original goals, including the should-have or nice-to-have functionalities, have
    all been accounted for at this point, in a complete set of CRUD operation mechanisms:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 原始目标，包括应该具有或者很好具有的功能，在这一点上都已经考虑到了，形成了一套完整的CRUD操作机制：
- en: All of the stored data for any derived class should probably live in one location. This
    is enforced by the `_file_store_dir` class attribute.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何派生类的所有存储数据可能都应该位于一个位置。这是通过`_file_store_dir`类属性来强制执行的。
- en: Instance data for each object type (class) should probably live in a common
    location within the top-level location and data for any given instance should
    probably reside in a single, distinct file, whose name can be uniquely related
    to the instance whose data it stores. These are managed by ensuring that all the
    file paths used contain the class name, so that, for example, all product instance
    data will be stored in `_file_store_dir/Product-data/*.json` files.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象类型（类）的实例数据可能应该存储在顶层位置的一个共同位置，并且任何给定实例的数据可能应该存储在一个单独的文件中，其名称可以与存储其数据的实例唯一相关联。这些是通过确保所有使用的文件路径都包含类名来进行管理，因此，例如，所有产品实例数据将存储在`_file_store_dir/Product-data/*.json`文件中。
- en: Data reading operations would be faster if the process didn't involve finding,
    opening, reading, and creating objects for every file every time that a data read
    was executed. The `_load_objects` class method performs the load, and making sure
    that it gets called before any CRUD operations are executed takes care of making
    them available. The create, update, and delete processes all take into account
    both the persistent data files and the in-memory instances that relate to those
    instances.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果处理不涉及每次执行数据读取时找到、打开、读取和创建对象，数据读取操作将会更快。`_load_objects`类方法执行加载，并确保在执行任何CRUD操作之前调用它，以确保它们可用。创建、更新和删除过程都考虑了持久数据文件和与这些实例相关的内存中实例。
- en: The concrete business objects of hms_artisan
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_artisan的具体业务对象
- en: 'The final definition of the concrete classes in the Artisan Application really
    just boils down to the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在Artisan Application中具体类的最终定义实际上归结为以下内容：
- en: 'Defining each concrete class:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义每个具体类：
- en: Deriving from the corresponding base class in `hms_core`
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`hms_core`中对应的基类派生
- en: Deriving from `JSONFileDataObject` that was just defined
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从刚刚定义的`JSONFileDataObject`中派生
- en: Collecting the arguments for the new class `__init__` method, which needs to
    account for all of the arguments of the parent classes.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集新类`__init__`方法的参数，该方法需要考虑父类的所有参数。
- en: Implementing any of the abstract instance and class methods required by the
    parent classes, many of which have already been set up to allow the derived class
    to call the parent's abstract method.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现父类所需的任何抽象实例和类方法，其中许多已经设置允许派生类调用父类的抽象方法。
- en: Setting up a `_file_store_dir` class attribute value that can be used by instances
    of the classes until the final application configuration is worked out.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个`_file_store_dir`类属性值，可以被类的实例使用，直到最终应用程序配置完成。
- en: 'These relationships may make more sense if they are diagrammed:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将这些关系绘制成图表可能更容易理解：
- en: '![](assets/38603a7f-8659-43ec-b12f-1f879bcb4a48.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/38603a7f-8659-43ec-b12f-1f879bcb4a48.png)'
- en: Dealing with is_dirty and properties
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理is_dirty和属性
- en: '`BaseDataObject` provides `is_dirty`, a property that''s intended to indicate
    when the state data of an object has been changed (for example, it should be set
    to `True` when any of the various `_set_` or `_del_` methods have been called).
    Since the concrete objects'' property setter and deleter methods, as defined in
    their corresponding base classes, aren''t aware of that capability at all, it''s
    up to the concrete objects to implement that functionality.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseDataObject`提供了`is_dirty`属性，用于指示对象的状态数据何时发生了更改（例如，当调用了各种`_set_`或`_del_`方法时，应将其设置为`True`）。由于具体对象的属性设置器和删除器方法，如在其对应的基类中定义的，根本不知道该功能，因此由具体对象来实现该功能。'
- en: 'However, since those setter and deleter methods can be called in the derived
    concrete class definitions, the implementation is very straightforward. Using
    the `address` property of `Artisan` as an example, we essentially define local
    setter and deleter methods that call their counterparts in `BaseArtisan`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这些setter和deleter方法可以在派生的具体类定义中被调用，实现非常简单。以`Artisan`的`address`属性为例，我们基本上定义了本地的setter和deleter方法，调用它们在`BaseArtisan`中的对应方法：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once those are defined, the property itself has to be redefined in order to
    point to the appropriate methods. Without this step, the `Artisan` objects'' properties
    would still point to the `BaseArtisan` setter and deleter methods, so the `is_dirty` flag
    would never get set, and data changes would never be saved:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些被定义，属性本身必须重新定义以指向适当的方法。如果没有这一步，`Artisan`对象的属性仍然会指向`BaseArtisan`的setter和deleter方法，因此`is_dirty`标志永远不会被设置，数据更改永远不会被保存：
- en: '[PRE25]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This same pattern will play out for all of the properties of the `hms_artisan` classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式将适用于`hms_artisan`类的所有属性。
- en: That also means, however, that all of those classes, since they all use their
    various `_del_` methods to initialize instance values during the execution of
    their `__init__` methods, may also need to explicitly reset `is_dirty` to `False` when
    an object is created.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着，所有这些类，因为它们都在执行它们的`__init__`方法期间使用它们各自的`_del_`方法来初始化实例值，当对象被创建时也可能需要显式地将`is_dirty`重置为`False`。
- en: This is a very simplistic approach to handling the dirty state of object instances.
    The fundamental assumption behind this implementation is that any property setting
    or deletion that occurs will make a change to the applicable state value, so the
    instance is dirty as a result. Even if the new value was the same as the old value
    of a property, this would be the case. In systems where there is an actual monetary
    cost for each database transaction (some cloud-based data stores), it might be
    worth the additional effort of checking the property value before executing the
    set code or delete code, and not even making the change, let alone setting the `is_dirty` flag,
    if the incoming new value isn't different from the existing one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常简单的处理对象实例的脏状态的方法。这种实现背后的基本假设是，任何发生的属性设置或删除都会对适用状态值进行更改，因此实例会因此变得脏。即使新值与属性的旧值相同，也是如此。在某些云数据存储中，每个数据库事务都会产生实际的货币成本的系统中，可能值得额外的努力来在执行设置代码或删除代码之前检查属性值，甚至不进行更改，更不用说设置`is_dirty`标志，如果传入的新值与现有值不同。
- en: hms_artisan.Artisan
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_artisan.Artisan
- en: 'Artisans need to be able to manipulate their own data in the Artisan Application:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠需要能够在Artisan应用程序中操纵自己的数据：
- en: As an Artisan, I need to be able to create, manage, and store my own system
    data so that I can keep it up to date
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够创建、管理和存储自己的系统数据，以便我可以保持其最新状态
- en: 'The initial code for the `Artisan` class that provides the data structure and
    persistence that fulfills this story''s needs is very lightweight, since most
    of the functionality is inherited from `hms_core`, `BaseArtisan` (for properties
    and data-structure), and `JSONFileDataObject` (for methods and persistence functionality).
    Not counting comments and documentation, it''s just under 60 lines of real code:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为`Artisan`类提供满足本故事需求的数据结构和持久性的初始代码非常轻量级，因为大部分功能都是从`hms_core`、`BaseArtisan`（用于属性和数据结构）和`JSONFileDataObject`（用于方法和持久性功能）继承的。不计注释和文档，实际代码只有不到60行：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `__init__` method has a long and detailed argument signature, with 12 arguments
    (three of which are required), and the `products` arglist. It may seem daunting,
    but is not expected to be needed for most use cases (more on that shortly). All
    it really needs to do is call the parent initializers to set the applicable property
    values:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__`方法具有一个长而详细的参数签名，有12个参数（其中三个是必需的），以及`products`参数列表。这可能看起来令人生畏，但大多数情况下不需要（稍后会详细说明）。它真正需要做的就是调用父初始化程序来设置适用的属性值：'
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The bulk of the instance methods can call the original abstract methods (with
    their existing implementations) in the classes that they originate from:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分实例方法可以调用它们来自的类中的原始抽象方法（具有它们现有的实现）：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The exception to that is the `to_data_dict` method, which must be customized
    for each concrete class. All that it needs to do, though, is return a `dict` of
    all the properties and values that should be persisted, and that can be used in
    the initialization of an object. The `address` property has an issue with it,
    from the perspective of being able to store it in a JSON file, and that will be
    examined shortly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 例外的是`to_data_dict`方法，这必须针对每个具体的类进行定制。不过，它所需要做的就是返回一个应该被持久化的所有属性和值的`dict`，并且可以在对象初始化时使用。`address`属性存在问题，从能够将其存储在JSON文件的角度来看，这将很快得到检查。
- en: 'The `datetime` and `UUID` properties are converted to string values for the
    outgoing data dictionary, and they are already situated during the initialization
    of an `Artisan` object to be converted back to their native data types:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`datetime`和`UUID`属性被转换为出站数据字典的字符串值，并且它们在`Artisan`对象的初始化期间已经被放置，以便将它们转换回其本机数据类型：'
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The single class method, like the bulk of the preceding instance methods, also
    uses the original abstract class methods that have implementations within them:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 单个类方法，就像前面大部分的实例方法一样，也使用了具有实现的原始抽象类方法：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The long argument signature of `Artisan.__init__` may feel a bit daunting at
    first glance. There are a lot of arguments, after all, and Python's language stipulation
    that requires that arguments have to go before optional ones in method and function
    argument definitions means that three of those arguments have to come first (though
    their sequence with respect to each other is up to the developer).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: “Artisan.__init__”的长参数签名乍看起来可能有点令人生畏。毕竟有很多参数，而且Python的语言规定要求参数必须在方法和函数参数定义中的可选参数之前，这意味着其中三个参数必须首先出现（尽管它们相对于彼此的顺序由开发人员决定）。
- en: 'Most of the time, however, that `__init__` method will probably not be called
    directly. The creation of an instance from data retrieved from the data store
    is expected to be handled with the `from_data_dict` method of the class, probably
    looking something like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大多数情况下，“__init__”方法可能不会直接调用。从数据存储中检索的数据创建实例预计将使用类的“from_data_dict”方法处理，可能看起来像这样：
- en: '[PRE31]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'An `Artisan` instance could also be created directly by passing a dictionary
    of values:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: “Artisan”实例也可以通过传递值字典直接创建：
- en: '[PRE32]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The only considerations for that approach are that the required arguments must
    have valid entries in the `data_dict` being passed, and that `data_dict` cannot
    contain keys that don''t exist as argument names in the `__init__` method – essentially,
    that object creation is equivalent to the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的唯一考虑因素是传递的“data_dict”中必须有有效条目的必需参数，并且“data_dict”不能包含在“__init__”方法中不存在的键名称
    - 本质上，对象创建等同于以下内容：
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'It was noted that there were issues with the `address` property when it came
    to creating JSON output for an `Artisan` instance. The core issue is that the `Address` class
    is not directly serializable into JSON:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建JSON输出时，“地址”属性存在问题，核心问题在于“地址”类无法直接序列化为JSON：
- en: '[PRE34]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If the preceding code is executed, `TypeError: <hms_core.business_objects.Address
    object> is not JSON serializable` is raised.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '如果执行上述代码，“TypeError: <hms_core.business_objects.Address object> is not JSON
    serializable”将被引发。'
- en: 'Although there are several possible solutions for this issue, since we''ve
    already established a pattern of converting objects to and reading/creating them
    from dictionary values, the one that is most like that pattern is to implement
    the `to_dict` and `from_dict` methods on the original `Address` class in `hms_core`,
    and change the `to_data_dict` result to use the `to_dict` of the instance''s `address`.
    The new `Address` methods are simple:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有几种可能的解决方案，但由于我们已经建立了将对象转换为字典值并从中读取/创建对象的模式，最像该模式的解决方案是在“hms_core”中的原始“Address”类上实现“to_dict”和“from_dict”方法，并更改“to_data_dict”结果以使用实例的“address”的“to_dict”。新的“Address”方法很简单：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As is the change to `Artisan.to_data_dict`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与“Artisan.to_data_dict”的更改一样：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'With those changes in place, rerunning the code that raised the `TypeError` before
    now yields usable JSON, meaning that the results of a `to_data_dict` call can
    be used to directly write the JSON files needed to persist `Artisan` data to the
    file system data store:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些更改，重新运行之前引发“TypeError”的代码现在产生可用的JSON，这意味着“to_data_dict”调用的结果可以直接用于编写到文件系统数据存储中持久保存“Artisan”数据所需的JSON文件：
- en: '![](assets/16314853-dd95-4532-a293-d99f6cd53e66.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/16314853-dd95-4532-a293-d99f6cd53e66.png)'
- en: hms_artisan.Product
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_artisan.Product
- en: 'Artisans have a similar data persistence need for `Product` object data:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠对“产品”对象数据有类似的数据持久性需求：
- en: As an Artisan, I need to be able to create, manage, and store `Product` data,
    so that I can keep `product` information current in the central office system
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够创建、管理和存储“产品”数据，以便我可以在中央办公室系统中保持“产品”信息的最新状态
- en: The `hms_artisan..Product` class, like the `Artisan` class of the package, leverages
    its corresponding `hms_core` base class (`BaseProduct`) and the `JSONFileDataObject` ABC
    to minimize the amount of actual code needed in the concrete implementation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: “hms_artisan..Product”类，就像包的“Artisan”类一样，利用其对应的“hms_core”基类（“BaseProduct”）和“JSONFileDataObject”
    ABC，以最小化实际代码在具体实现中所需的数量。
- en: 'In fact, the only real differences are in the `__init__` method (with different
    arguments, and calling a different parent initialization method set):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，唯一的真正区别在于“__init__”方法（具有不同的参数，并调用不同的父初始化方法集）：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `to_data_dict` method (which has to account for the different properties
    of the class):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “to_data_dict”方法（必须考虑类的不同属性）：
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A similar simple creation of a `Product` object, and a dump of its `to_data_dict` results,
    yield viable JSON output:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地简单创建“Product”对象，并转储其“to_data_dict”结果，产生可行的JSON输出：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This yields the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这产生了以下结果：
- en: '![](assets/e7aef5cd-6c79-4a1d-ade0-8db10121250f.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7aef5cd-6c79-4a1d-ade0-8db10121250f.png)'
- en: hms_artisan.Order
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: hms_artisan.Order
- en: 'The ability for Artisans to have locally saved order data is also needed:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠需要能够本地保存订单数据的能力：
- en: As an Artisan, I need to be able to create, manage, and store `Order` data so
    that I can fulfill orders when they are relayed to me, and flag them as fulfilled
    for the Central Office
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够创建、管理和存储“订单”数据，以便在订单传达给我时履行订单，并将其标记为中央办公室已履行
- en: 'Order data, though, is a bit different from the `Artisan` and `Product` data
    that we have explored so far at a structural level:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，订单数据在结构层面上与我们迄今为止所探索的“工匠”和“产品”数据有些不同：
- en: An `Order`, when it comes right down to it, is an association of one customer
    with one-to-many products.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际上，“订单”归根结底是一个客户与一对多产品的关联。
- en: There's no expected need for Artisans to keep track of individual customers,
    except as they relate to orders, so Artisans need `Customer` objects that aren't also
    data objects, in much the same way that `Artisan` objects have an `Address` associated
    with them that aren't themselves data objects.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠不需要跟踪单个客户，除非与订单相关，因此工匠需要不是数据对象的“Customer”对象，就像“工匠”对象有与它们相关联的“Address”一样，它们本身不是数据对象。
- en: The `Customer` object that is part of an `Order` also has an `Address` that
    has to be accounted for.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为“订单”一部分的“客户”对象也有一个必须考虑的“地址”。
- en: The products associated with an order imply at least the possibility of a quantity associated
    with them – a customer may want to order two of one product, five of another,
    and one of a third, for example – and don't really need to have all of the `Product` data
    transmitted, so long as the `oid` for each `Product` in the order is supplied.
    That would be sufficient information for the Artisan Application to look up products
    from its local `Product` data store.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与订单相关的产品至少意味着它们可能有与之关联的数量 - 例如，客户可能想订购一个产品的两个，另一个的五个，第三个的一个 - 并且实际上不需要传输所有的“产品”数据，只要提供订单中每个“产品”的“oid”即可。这将足够Artisan应用程序从其本地“产品”数据存储中查找产品的信息。
- en: 'That last item, in retrospect, calls into question some of the structure of `BaseOrder` in `hms_core`, or
    at least whether it''s relevant in the scope of the Artisan Application. As it''s
    currently defined, it derives from `hms_core` ... `HasProducts`, with the original
    intention that actual `Product` objects would be associated with an `Order`. That might make
    sense in a Central Office or gateway service context, but it''s not going to be
    terribly useful in the context of the Artisan Application. A better order-to-product
    relationship is probably to store the `oids` and quantities of each `Product`  in
    an `Order`, and let the applications and service look them up when necessary:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾最后一项，质疑了“hms_core”中“BaseOrder”的一些结构，或者至少是否在Artisan应用程序的范围内相关。按照当前的定义，它派生自“hms_core”...“HasProducts”，最初的意图是将实际的“产品”对象与“订单”相关联。这在中央办公室或网关服务上可能是有意义的，但在Artisan应用程序的上下文中并不会特别有用。更好的订单到产品关系可能是在“订单”中存储每个“产品”的“oid”和数量，并在必要时让应用程序和服务查找它们：
- en: '![](assets/2ef57d52-c880-4be6-b81e-49f8f9620215.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2ef57d52-c880-4be6-b81e-49f8f9620215.png)'
- en: Taking a step back and looking at what an Artisan Application's `Order` really is,
    it would seem to be an `Address`, with the addition of a `name` property (who
    the order is for), and some `Product` quantity data. The association between `oid` product
    specifications and quantity values is easily managed in a `dict` property, and
    the processes for adding and removing order items can be wrapped in a single method
    that accepts the `oid` and a quantity value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 退一步看看Artisan应用程序的“订单”到底是什么，似乎是一个“地址”，加上一个“名称”属性（订单所属的人），以及一些“产品”数量数据。产品规格的“oid”和数量值之间的关联可以很容易地在“dict”属性中进行管理，并且添加和删除订单项目的过程可以包装在一个接受“oid”和数量值的单个方法中。
- en: 'That feels like a much better solution for Artisans'' order data. They don''t
    really need to know anything more than the data this structure covers:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是Artisans订单数据的一个更好的解决方案。他们实际上不需要知道比这个结构涵盖的数据更多的东西：
- en: Who the order is for (`name`)
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单所属的人（“名称”）
- en: Where it gets sent to (the properties derived from `Address`)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它发送到哪里（从“地址”派生的属性）
- en: What products are part of the order, and in what quantities (`items`)
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单中有哪些产品，以及数量（“项目”）
- en: 'The `Order` class, then, starts by deriving from `Address` and `JSONFileDataObject`,
    with the usual class attributes:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，“订单”类从“地址”和“JSONFileDataObject”派生，并具有通常的类属性：
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The property definitions, getter, setter, and deleter methods, and the property
    declarations follow the pattern we''ve used everywhere else so far, with `_get_items` returning
    a copy of the current property in order to prevent unwanted manipulation of the
    actual data. The setter and deleter methods also have to explicitly call `_set_is_dirty(True)` to
    ensure that the `is_dirty` flag of the instance gets changed appropriately when
    a local property is deleted or set, and the properties themselves, with their setter
    and deleter methods that are inherited from `Address`, have to be overridden. There
    are two local getter methods:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 属性定义、getter、setter和删除方法以及属性声明都遵循我们到目前为止在其他地方使用的模式，“_get_items”返回当前属性的副本，以防止对实际数据的不必要操作。设置器和删除器方法还必须显式调用“_set_is_dirty(True)”以确保在删除或设置本地属性时实例的“is_dirty”标志得到适当的更改，并且属性本身及其从“地址”继承的setter和删除器方法必须被覆盖。有两个本地getter方法：
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Most of the setter methods call their ancestor methods, set `is_dirty`, and
    `exit`, but the two that correspond to the local getters are full implementations:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数setter方法调用其祖先方法，设置“is_dirty”并“退出”，但与本地getter对应的两个方法是完整的实现：
- en: '[PRE42]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The deleter methods follow the same pattern:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 删除方法遵循相同的模式：
- en: '[PRE43]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And the properties follow suit:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 属性也遵循相同的模式：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The initialization process (`__init__`) has a long signature again, since it
    has to accommodate all of the arguments from its parent classes, plus arguments
    for the local properties:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化过程（“__init__”）再次具有很长的签名，因为它必须适应其父类的所有参数，以及本地属性的参数：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `matches` method can still just call the `matches` method of `BaseDataObject`; there''s
    no expectation that any matching will need to happen that would require anything
    more or different:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: “matches”方法仍然可以调用“BaseDataObject”的“matches”方法；没有期望需要进行任何更多或不同的匹配：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The process for setting item quantities in an order has a fair amount of type
    and value checking to do, but those all follow patterns that have been used in
    earlier code, including checking for types, conversion of `oid` string values
    to `UUID` objects, and checking for valid values:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在订单中设置项目数量的过程需要进行相当多的类型和值检查，但所有这些都遵循了在先前代码中使用的模式，包括类型检查、将“oid”字符串值转换为“UUID”对象以及检查有效值：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'If the `quantity` specified for a given item is zero, the item in question
    is removed entirely rather than leaving what is essentially a line item in the
    order for zero items of a given product:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给定项目的“数量”为零，则将删除该问题中的项目，而不是留下本质上是订单中给定产品的零件的情况：
- en: '[PRE49]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The data dictionary generation actively converts the instance''s items into
    a dictionary with string value keys instead of `UUID` objects, but is otherwise
    pretty typical of the implementations written so far:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 数据字典生成主动将实例的项目转换为具有字符串值键的字典，而不是`UUID`对象，但在其他方面基本上与迄今为止编写的实现相当典型。
- en: '[PRE50]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `_load_objects` and `from_data_dict` class methods are identical to those
    put in play in earlier code. The `Address` class `standard_address` method cannot
    be left as it is inherited by `Order`, since any attempt to call it would result
    in an error – it would not have the new, required `name` argument – so it is overridden
    with a new class method with a nearly identical argument set (adding the `name`),
    that can be used to generate a new `Order` instance with no items added, but all
    of the other relevant information:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`_load_objects`和`from_data_dict`类方法与先前代码中使用的方法相同。`Address`类的`standard_address`方法不能保持原样，因为它被`Order`继承，任何调用它的尝试都会导致错误
    - 它不会有新的必需的`name`参数 - 因此它被覆盖为一个新的类方法，几乎具有相同的参数集（添加`name`），可以用来生成一个新的`Order`实例，没有添加任何项目，但所有其他相关信息都有。'
- en: '[PRE51]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The results of these data storage operations can be seen in the file system:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据存储操作的结果可以在文件系统中看到：
- en: '![](assets/3456f833-1030-4ef5-a0f8-6d26ebfe4476.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/3456f833-1030-4ef5-a0f8-6d26ebfe4476.png)'
- en: Barring any corrections or changes prompted by unit testing later in the iteration,
    that accounts for all of the classes in the Artisan Application that have any
    anticipated need to persist data. Basic testing of the data persistence functionality
    by creating a minimal data instance of each shows that they do, indeed, write
    JSON data to the expected location, and that the data written is at least superficially
    correct. Detailed unit testing will still have to be undertaken to ensure that
    the data really is accurately written and retrievable without loss or corruption,
    but the bulk of the main development for these objects is complete.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 除非迭代后期由单元测试引发任何更正或更改，否则这就是Artisan Application中所有具有任何预期需要持久化数据的类。通过创建每个类的最小数据实例对数据持久化功能进行基本测试，显示它们确实将JSON数据写入预期位置，并且写入的数据至少在表面上是正确的。仍然需要进行详细的单元测试，以确保数据确实被准确地写入和检索，而不会丢失或损坏，但这些对象的主要开发工作已经完成。
- en: 'The relationships between these concrete classes and the `hms_core` equivalents
    has changed somewhat, with the creation of `Order` as a class no longer attached
    to `hms_core..BaseOrder`, and the removal of the `Customer` class at the Artisan
    Application level:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这些具体类与`hms_core`等价类之间的关系有所改变，`Order`作为一个类不再附加到`hms_core..BaseOrder`，并且在Artisan
    Application级别删除了`Customer`类：
- en: '![](assets/140d3641-f87d-450f-92ce-7197bd816ba9.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/140d3641-f87d-450f-92ce-7197bd816ba9.png)'
- en: The underlying data storage residing in structured JSON data could also be repurposed
    to providing data access and CRUD operations against a remote API of some sort.
    A RESTful/JSON web service, for example, that returned the same JSON structures
    or accepted them as payloads for creation and update requests, could almost certainly
    use these objects with only a little bit of modification, in most cases. That
    sort of approach might be worth looking at in this system, were it ever to go
    further than it will in this book.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 结构化JSON数据中的基础数据存储也可以被重新用于提供对某种远程API的数据访问和CRUD操作。例如，一个RESTful/JSON web服务，返回相同的JSON结构或接受它们作为创建和更新请求的有效载荷，几乎可以肯定地在大多数情况下使用这些对象，只需要进行一点修改。如果这个系统要比本书中所述的更进一步，这种方法可能值得考虑。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Though it still needs to be thoroughly tested, which will be addressed in [Chapter
    14](4d1c6624-dca4-4f64-beac-4c5132125cec.xhtml), *Testing Data Persistence*, preliminary
    testing of the JSON-based data file persistence feels pretty solid at this point.
    The CRUD operations that are required by `BaseDataObject`, passing through `JSONFileDataObject`
    to all of the concrete data objects, are all present and accounted for, and they
    appear to be fully functional. The change to the structure of the `Order` class
    might be cause for some concern with respect to the original design, but was not
    difficult to deal with. That change should be specifically called out during the
    approval process for the iteration, since it represents a change to the original
    design, but it doesn't feel like it will be a cause for any major concerns at
    this time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管仍需要进行彻底测试，这将在[第14章](4d1c6624-dca4-4f64-beac-4c5132125cec.xhtml)中进行，*测试数据持久性*，但基于基于JSON的数据文件持久性的初步测试目前看来相当可靠。通过`BaseDataObject`需要的CRUD操作，通过`JSONFileDataObject`传递给所有具体数据对象，都已经存在并且运行良好。`Order`类结构的更改可能会引起对原始设计的一些担忧，但处理起来并不困难。这种变化应该在迭代的批准过程中特别指出，因为它代表对原始设计的改变，但目前看来并不会引起任何重大担忧。
- en: With one data persistence mechanism done, and while the concepts are still fresh,
    it's time to look at the equivalent processes, backed by a real database engine,
    for the Central Office applications and service.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个数据持久化机制完成后，当概念仍然新鲜时，是时候看看由真实数据库引擎支持的等效过程，用于中央办公应用程序和服务。
