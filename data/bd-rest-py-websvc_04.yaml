- en: Chapter 4.  Throttling, Filtering, Testing, and Deploying an API with Django
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：使用Django限制、过滤、测试和部署API
- en: 'In this chapter, we will use the additional features included in Django and
    Django REST Framework to improve our RESTful API. We will also write and execute
    unit tests and learn a few things related to deployment. We will cover the following
    topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用Django和Django REST Framework中包含的附加功能来改进我们的RESTful API。我们还将编写和执行单元测试，并学习一些与部署相关的内容。本章将涵盖以下主题：
- en: Understanding throttling classes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解限制类
- en: Configuring throttling policies
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置限制策略
- en: Testing throttle policies
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试限制策略
- en: Understanding filtering, searching and ordering classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解过滤、搜索和排序类
- en: Configuring filtering, searching, and ordering for views
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为视图配置过滤、搜索和排序
- en: Testing filtering, searching and ordering features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试过滤、搜索和排序功能
- en: Filter, search, and order in the browsable API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可浏览的API中进行过滤、搜索和排序
- en: Writing a first round of unit tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: Running unit tests and checking testing coverage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单元测试并检查测试覆盖率
- en: Improving testing coverage
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: Understanding strategies for deployments and scalability
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解部署和可扩展性的策略
- en: Understanding throttling classes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解限制类
- en: So far, we haven't established any limits on the usage of our API, and therefore,
    both authenticated and unauthenticated users can compose and send as many requests
    as they want to. We only took advantage of the pagination features available in
    Django REST Framework to specify how we wanted large results sets to be split
    into individual pages of data. However, any user can compose and send thousands
    of requests to be processed without any kind of limitation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有对我们的API使用设置任何限制，因此，认证用户和非认证用户都可以随意组合并发送尽可能多的请求。我们只是利用了Django REST
    Framework中可用的分页功能来指定我们希望将大量结果集拆分为单独的数据页面的方式。然而，任何用户都可以发送成千上万的请求进行处理，而没有任何限制。
- en: 'We will use throttling to configure the following limitations of the usage
    of our API:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用限制来配置以下API使用的限制：
- en: '**Unauthenticated users**: A maximum of five requests per hour.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非认证用户**：每小时最多5个请求。'
- en: '**Authenticated users**: A maximum of 20 requests per hour.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证用户**：每小时最多20个请求。'
- en: In addition, we want to configure a maximum of 100 requests per hour to the
    game categories related views, no matter whether the user is authenticated or
    not.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们希望配置每小时最多100个请求到游戏类别相关视图，无论用户是否认证。
- en: Django REST Framework provides the following three throttling classes in the
    `rest_framework.throttling` module. All of them are subclasses of the `SimpleRateThrottle`
    class, which is a subclass of the `BaseThrottle` class. The classes allow us to
    set the maximum number of requests per period that are computed based on different
    mechanisms to determine the previous request information used to specify the scope.
    The previous request information for throttling is stored in the cache and the
    classes override the `get_cache_key` method that determines the scope.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Django REST Framework在`rest_framework.throttling`模块中提供了以下三个限制类。它们都是`SimpleRateThrottle`类的子类，而`SimpleRateThrottle`类又是`BaseThrottle`类的子类。这些类允许我们根据不同的机制设置每个周期内最大请求数量，这些机制基于用于指定范围的前一个请求信息。限制的前一个请求信息存储在缓存中，并且这些类覆盖了`get_cache_key`方法，该方法确定范围。
- en: '`AnonRateThrottle`: This class limits the rate of request that an anonymous
    user can make. The IP address of the request is the unique cache key, and therefore,
    all the requests coming from the same IP address will accumulate the total number
    of requests.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnonRateThrottle`：此类限制了匿名用户可以发起的请求数量。请求的IP地址是唯一的缓存键，因此，来自同一IP地址的所有请求将累积总请求数量。'
- en: '`UserRateThrottle`: This class limits the rate at which a specific user can
    make requests. For authenticated users, the authenticated user ID is the unique
    cache key. For anonymous users, the IP address of the request is the unique cache
    key.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRateThrottle`：此类限制了特定用户发起请求的速度。对于认证用户，认证用户ID是唯一的缓存键。对于匿名用户，请求的IP地址是唯一的缓存键。'
- en: '`ScopedRateThrottle`: This class limits the rate of request for specific parts
    of the API identified with the value assigned to the `throttle_scope` property.
    The class is useful when we want to restrict access to specific parts of the API
    with different rates.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScopedRateThrottle`：此类限制了与`throttle_scope`属性分配的值标识的API特定部分的请求速率。当我们需要以不同的速率限制对API特定部分的访问时，此类非常有用。'
- en: Configuring throttling policies
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置速率限制策略
- en: We will use a combination of the three throttling classes, discussed earlier,
    to achieve our previously explained goals. Make sure you quit Django's development
    server. Remember that you just need to press ***Ctrl*** + ***C*** in the Terminal
    or Command Prompt window in which it is running.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用前面讨论的三个速率限制类的组合，以实现我们之前解释的目标。确保您退出Django的开发服务器。请记住，您只需在运行它的终端或命令提示符窗口中按***Ctrl***
    + ***C***即可。
- en: 'Open the `gamesapi/settings.py` file and add the highlighted lines to the dictionary
    named `REST_FRAMEWORK` with two key-value pairs that configure the global default
    throttling classes and their rates. The code file for the sample is included in
    the `restful_python_chapter_04_01` folder:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`gamesapi/settings.py`文件，并将高亮显示的行添加到名为`REST_FRAMEWORK`的字典中，包含两个键值对，用于配置全局默认的速率限制类及其速率。示例代码文件包含在`restful_python_chapter_04_01`文件夹中：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value for the `DEFAULT_THROTTLE_CLASSES` settings key specifies a global
    setting with a tuple of string whose values indicate the default classes that
    we want to use for throttling-`AnonRateThrottle` and `UserRateThrottle`. The `DEFAULT_THROTTLE_RATES`
    settings key specifies a dictionary with default throttle rates. The value specified
    for the `'anon'` key indicates that we want a maximum of five requests per hour
    for anonymous users. The value specified for the `'user'` key indicates that we
    want a maximum of 20 requests per hour for authenticated users. The value specified
    for the `'game-categories'` key indicates that we want a maximum of `30` requests
    per hour for the scope with that name.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`DEFAULT_THROTTLE_CLASSES`设置键的值指定了一个全局设置，是一个字符串值的元组，表示我们想要用于速率限制的默认类-`AnonRateThrottle`和`UserRateThrottle`。`DEFAULT_THROTTLE_RATES`设置键指定了一个包含默认速率限制的字典。对于`''anon''`键指定的值表示我们希望匿名用户每小时最多有五个请求。对于`''user''`键指定的值表示我们希望认证用户每小时最多有20个请求。对于`''game-categories''`键指定的值表示我们希望该名称的作用域每小时最多有30个请求。'
- en: 'The maximum rate is a string that specifies the number of requests per period
    with the following format: `''number_of_requests/period''`, where period can be
    any of the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最大速率是一个字符串，指定了每期的请求数量，格式如下：`'number_of_requests/period'`，其中`period`可以是以下任何一个：
- en: '`s`: second'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`s`: 秒'
- en: '`sec`: second'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sec`: 秒'
- en: '`m`: minute'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`m`: 分钟'
- en: '`min`: minute'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min`: 分钟'
- en: '`h`: hour'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`h`: 小时'
- en: '`hour`: hour'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hour`: 小时'
- en: '`d`: day'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d`: 天'
- en: '`day`: day'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`day`: 天'
- en: 'Now, we will configure throttling policies for the class-based views related
    to game categories. We will override the value for the `throttle_scope` and `throttle_classes`
    class attributes for the `GameCategoryList` and `GameCategoryDetail` classes.
    First, we have to add the following `import` statement after the last import in
    the `views.py` file. The code file for the sample is included in the `restful_python_chapter_04_01`
    folder:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为与游戏类别相关的基于类的视图配置速率限制策略。我们将覆盖`GameCategoryList`和`GameCategoryDetail`类的`throttle_scope`和`throttle_classes`类属性。首先，我们必须在`views.py`文件中的最后一个导入语句之后添加以下`import`语句。示例代码文件包含在`restful_python_chapter_04_01`文件夹中：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following lines show the new code for the `GameCategoryList` class in the
    `views.py` file. The new lines are highlighted. The code file for the sample is
    included in the `restful_python_chapter_04_01` folder:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`views.py`文件中`GameCategoryList`类的新代码。以下代码中的新行被高亮显示。示例代码文件包含在`restful_python_chapter_04_01`文件夹中：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following lines show the new code for the `GameCategoryDetail` class in
    the `views.py` file. The new lines are highlighted in the following code. The
    code file for the sample is included in the `restful_python_chapter_04_01` folder:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了`views.py`文件中`GameCategoryDetail`类的新代码。以下代码中的新行被高亮显示。示例代码文件包含在`restful_python_chapter_04_01`文件夹中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We added the same lines in the two classes. We set `''game-categories''` as
    the value for the `throttle_scope` class attribute and we included `ScopedRateThrottle`
    in the tuple that defines the value for `throttle_classes`. This way, the two
    class-based views will use the settings specified for the `''game-categories''`
    scope and the `ScopeRateThrottle` class for throttling. These views will be able
    to serve 30 requests per hour and won''t take into account the global settings
    that apply to the default classes that we use for throttling: `AnonRateThrottle`
    and `UserRateThrottle`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在两个类中添加了相同的行。我们将`'game-categories'`设置为`throttle_scope`类属性的值，并将`ScopedRateThrottle`包含在定义`throttle_classes`值的元组中。这样，两个基于类的视图将使用为`'game-categories'`作用域指定的设置和`ScopeRateThrottle`类进行节流。这些视图每小时将能够服务30次请求，并且不会考虑适用于我们用于节流的默认类的全局设置：`AnonRateThrottle`和`UserRateThrottle`。
- en: Before Django runs the main body of a view, it performs the checks for each
    throttle class specified in the throttle classes. In the views related to the
    game categories, we wrote code that overrides the default settings. If a single
    throttle check fails, the code will raise a `Throttled` exception and Django won't
    execute the main body of the view. The cache is responsible of storing previous
    requests' information for throttling checking.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Django运行视图的主体之前，它会为在节流类中指定的每个节流类执行检查。在游戏类别相关的视图中，我们编写了覆盖默认设置的代码。如果单个节流检查失败，代码将引发一个`Throttled`异常，Django将不会执行视图的主体。缓存负责存储之前请求的信息以供节流检查。
- en: Testing throttling policies
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试节流策略
- en: Now, we can launch Django's development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django") *,* *Developing RESTful APIs with Django*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Django的开发服务器来组合和发送HTTP请求。根据您的需求，执行以下两个命令之一以访问连接到您的局域网的其他设备或计算机上的API。请记住，我们在[第1章](ch01.html
    "第1章。使用Django开发RESTful API") *《使用Django开发RESTful API》*中分析了它们之间的区别。
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After we run any of the previous commands, the development server will start
    listening at port `8000`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何之前的命令后，开发服务器将开始监听端口`8000`。
- en: 'Now, we will compose and send an HTTP request to retrieve all the player''s
    scores without authentication credentials six times:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将六次发送一个不包含认证凭据的HTTP请求来检索所有玩家的分数：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can also use the features of the shell in macOS or Linux to run the previous
    command six times with just a single line. We can also run the command in a Cygwin
    terminal in Windows. We can execute the next line in a bash shell. However, we
    will see all the results one after the other and you will have to scroll to understand
    what happened with each execution:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用macOS或Linux中shell的功能，通过单行命令运行之前的命令六次。我们也可以在Windows的Cygwin终端中运行该命令。我们可以在bash
    shell中执行下一行。然而，我们将依次看到所有结果，您需要滚动以了解每次执行的情况：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following is the equivalent curl command that we must execute six times:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须执行六次的等效curl命令：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following is the equivalent curl command that is executed six times with
    a single line in a bash shell in macOS or Linux, or a Cygwin terminal in Windows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在macOS或Linux的bash shell中，或Windows的Cygwin终端中，通过单行执行六次的一个等效curl命令：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Django won''t process the sixth request because `AnonRateThrottle` is configured
    as one of the default throttle classes and its throttle settings specify five
    requests per hour. Thus, we will receive a `429 Too many requests` status code
    in the response header and a message indicating that the request was throttled
    and the time in which the server will be able to process an additional request.
    The `Retry-After` key in the response header provides the number of seconds that
    it is necessary to wait until the next request: `3189`. The following lines show
    a sample response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Django不会处理第六个请求，因为`AnonRateThrottle`被配置为默认节流类之一，并且其节流设置指定每小时五次请求。因此，我们将在响应头中收到一个`429
    Too many requests`状态码，以及一个指示请求被节流和服务器将能够处理额外请求的时间的消息。响应头中的`Retry-After`键提供了等待下一次请求所需的秒数：`3189`。以下行显示了一个示例响应：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we will compose and send an HTTP request to retrieve the player's scores
    with authentication credentials, that is, with the `superuser` name and his password.
    We will execute the same request six times. Remember to replace `superuser` with
    the name you used for the `superuser` and `password` with the password you configured
    for this user in [Chapter 3](ch03.html "Chapter 3.  Improving and Adding Authentication
    to an API With Django") *,* *Improving and Adding Authentication to an API with
    Django:*
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将发送一个包含认证凭据的 HTTP 请求来检索玩家的分数，即使用 `superuser` 用户名和他的密码。我们将执行相同的请求六次。请记住将
    `superuser` 替换为你用于 `superuser` 的名称，将 `password` 替换为你为该用户配置的密码，在[第 3 章](ch03.html
    "第 3 章。使用 Django 改进和添加 API 认证") *改进和添加 API 认证：*
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can also run the previous command six times with just a single line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用单行运行之前的命令六次：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the equivalent curl command that we must execute six times:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须执行六次的等效 curl 命令：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is the equivalent `curl` command that is executed six times with
    a single line:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单行执行六次的等效 `curl` 命令：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Django will process the sixth request because we have composed and sent six authenticated
    requests with the same user, `UserRateThrottle` is configured as one of the default
    throttle classes and its throttle settings specify 20 requests per hour.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将处理第六个请求，因为我们已经用同一个用户 `UserRateThrottle` 组成了并发送了六个认证请求，`UserRateThrottle`
    被配置为默认限制类之一，其限制设置指定每小时 20 个请求。
- en: If we run the previous commands 15 times more, we will accumulate 21 requests
    and we will will receive a `429 Too many requests` status code in the response
    header and a message indicating that the request was throttled and the time in
    which the server will be able to process an additional request after the last
    execution.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再运行之前的命令 15 次，我们将累积 21 个请求，并在响应头中收到一个 `429 Too many requests` 状态码，以及一条消息表明请求已被限制，并且在最后一次执行后服务器将能够处理额外请求的时间。
- en: 'Now, we will compose and send an HTTP request to retrieve all the game categories
    thirty times without the authentication credentials:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将三十次发送一个不包含认证凭据的 HTTP 请求来检索所有游戏类别：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can also run the previous command thirty times with just a single line:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以用单行运行之前的命令三十次：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the equivalent `curl` command that we must execute thirty
    times:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们必须执行三十次的等效 `curl` 命令：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the equivalent `curl` command that is executed thirty times
    with a single line:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单行执行三十次的等效 `curl` 命令：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Django will process the thirty requests because we have composed and sent 30
    unauthenticated requests to a URL that is identified with the `'game-categories'`
    throttle scope and uses the `ScopedRateThrottle` class for throttle permission
    control. The throttle settings for the throttle scope identified with `'game-categories'`
    are configured with 30 requests per hour.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Django 将处理三十个请求，因为我们已经向一个被 `'game-categories'` 限制范围识别的 URL 发送了 30 个未认证的请求，该
    URL 使用 `ScopedRateThrottle` 类进行限制权限控制。`'game-categories'` 限制范围的限制设置被配置为每小时 30
    个请求。
- en: If we run the previous command once again, we will accumulate 31 requests and
    we will receive a `429 Too many requests` status code in the response header and
    a message indicating that the request was throttled and the time in which the
    server will be able to process an additional request after the last execution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次运行之前的命令，我们将累积 31 个请求，并在响应头中收到一个 `429 Too many requests` 状态码，以及一条消息表明请求已被限制，并且在最后一次执行后服务器将能够处理额外请求的时间。
- en: Understanding filtering, searching, and ordering classes
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解过滤、搜索和排序类
- en: We took advantage of the pagination features available in Django REST Framework
    to specify how we wanted large results sets to be split into individual pages
    of data. However, we have always been working with the entire queryset as the
    result set. Django REST Framework makes it easy to customize filtering, searching,
    and sorting capabilities to the views we have already coded.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用 Django REST Framework 中可用的分页功能来指定我们希望如何将大型结果集拆分为单个数据页。然而，我们一直都在使用整个查询集作为结果集。Django
    REST Framework 使得我们可以轻松地自定义过滤、搜索和排序功能，以适应我们已编写的视图。
- en: 'First, we will install the `django-filter` package in our virtual environment.
    This way, we will be able to use field filtering features that we can easily customize
    in Django REST Framework. Make sure that you quit the Django''s development server.
    Remember that you just need to press ***Ctrl*** + ***C*** in the terminal or Command
    Prompt window in which it is running. Then, we just need to run the following
    command to install the `django-filter` package:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将在虚拟环境中安装`django-filter`包。这样，我们将能够使用Django REST Framework中易于定制的字段过滤功能。确保您已退出Django的开发服务器。请记住，您只需在运行开发服务器的终端或命令提示符窗口中按***Ctrl***
    + ***C***即可。然后，我们只需运行以下命令来安装`django-filter`包：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last lines for the output will indicate that the `django-filter` package
    has been successfully installed.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`django-filter`包已成功安装。
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In addition, we will install the `django-cripsy-forms` package in our virtual
    environment. This package enhances how the browsable API renders the different
    filters. Run the following command to install the `django-cripsy-forms` package:
    We just need to run the following command to install this package:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将在我们的虚拟环境中安装`django-cripsy-forms`包。这个包增强了可浏览API渲染不同过滤器的方式。运行以下命令来安装`django-cripsy-forms`包：我们只需要运行以下命令来安装此包：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The last lines for the output will indicate that the `django-crispy-forms`
    package has been successfully installed:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行将指示`django-crispy-forms`包已成功安装：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open the `gamesapi/settings.py` file and add the highlighted lines to the `REST_FRAMEWORK`
    dictionary. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`gamesapi/settings.py`文件，并将突出显示的行添加到`REST_FRAMEWORK`字典中。示例代码文件包含在`restful_python_chapter_04_02`文件夹中：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The value for the `''DEFAULT_FILTER_BACKENDS` settings key specifies a global
    setting with a tuple of string whose values indicate the default classes that
    we want to use for filter backends. We will use the following three classes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`''DEFAULT_FILTER_BACKENDS''`设置键的值指定了一个全局设置，其值是一个字符串元组，表示我们想要用于过滤器后端的默认类。我们将使用以下三个类：'
- en: '`rest_framework.filters.DjangoFilterBackend`: This class provides field filtering
    capabilities. It uses the previously installed `django-filter` package. We can
    specify the set of fields we want to be able to filter against or create a `rest_framework.filters.FilterSet`
    class with more customized settings and associate it with the view.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest_framework.filters.DjangoFilterBackend`: 这个类提供字段过滤功能。它使用之前安装的`django-filter`包。我们可以指定我们想要能够过滤的字段集，或者创建一个具有更多自定义设置的`rest_framework.filters.FilterSet`类，并将其与视图关联。'
- en: '`rest_framework.filters.SearchFilter`: This class provides single query parameter-based
    searching capabilities and it is based on Django admin''s search function. We
    can specify the set of fields we want to include for the search and the client
    will be able to filter items by making queries that search these fields with a
    single query. It is useful when we want to make it possible for a request to search
    multiple fields with a single query.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest_framework.filters.SearchFilter`: 这个类提供基于单个查询参数的搜索功能，它基于Django管理员的搜索功能。我们可以指定我们想要包含在搜索中的字段集，客户端将通过对这些字段进行单个查询的查询来过滤项目。当我们想要使请求能够通过单个查询搜索多个字段时，这非常有用。'
- en: '`rest_framework.filters.OrderingFilter`: This class allows the client to control
    how the results are ordered with a single-query parameter. We can also specify
    the fields that can be ordered against.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rest_framework.filters.OrderingFilter`: 这个类允许客户端通过单个查询参数来控制结果的排序。我们还可以指定可以排序的字段。'
- en: Tip
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We can also configure the filter backends by including any of the previously
    enumerated classes in a tuple and assign it to the `filter_backends` class attribute
    for the generic view classes. However, in this case, we will use the default configuration
    for all our class-based views.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在元组中包含之前列出的任何类来配置过滤器后端，并将其分配给通用视图类的`filter_backends`类属性。然而，在这种情况下，我们将使用所有基于类的视图的默认配置。
- en: 'Add `''crispy_forms''` to the installed apps in the `settings.py` file, specifically,
    to the `INSTALLED_APPS` string list. The following code shows the lines we must
    add as the highlighted code. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将`'crispy_forms'`添加到`settings.py`文件中已安装的应用程序列表中，具体来说，添加到`INSTALLED_APPS`字符串列表中。以下代码显示了我们必须添加的突出显示的代码。示例代码文件包含在`restful_python_chapter_04_02`文件夹中：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Tip
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We have to be careful with the fields we configure to be available in the filtering,
    searching, and ordering features. The configuration will have an impact on the
    queries executed on the database, and therefore, we must ensure that we have the
    appropriate database optimizations considering the queries that will be executed.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须小心配置可用于过滤、搜索和排序功能的字段。配置将对数据库执行的查询产生影响，因此我们必须确保我们有适当的数据库优化，考虑到将要执行的查询。
- en: Configuring filtering, searching, and ordering for views
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置视图的过滤、搜索和排序
- en: 'Go to the `gamesapi/games` folder and open the `views.py` file. Add the following
    code after the last line that declares the imports but before the declaration
    of the `UserList` class. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前往 `gamesapi/games` 文件夹并打开 `views.py` 文件。在声明导入的最后一行之后但在 `UserList` 类声明之前添加以下代码。示例代码文件包含在
    `restful_python_chapter_04_02` 文件夹中：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the following highlighted lines to the `GameCategoryList` class declared
    in the `views.py` file. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下加粗的行添加到在 `views.py` 文件中声明的 `GameCategoryList` 类中。示例代码文件包含在 `restful_python_chapter_04_02`
    文件夹中：
- en: '[PRE25]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `filter_fields` attribute specifies a tuple of string whose values indicate
    the field names that we want to be able to filter against. Under the hoods, Django
    REST Framework will automatically create a `rest_framework.filters.FilterSet`
    class and associate it to the `GameCategoryList` view. This way, we will be able
    to filter against the `name` field.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_fields` 属性指定了一个字符串元组，其值表示我们希望能够过滤的字段名称。在底层，Django REST Framework 将自动创建一个
    `rest_framework.filters.FilterSet` 类并将其关联到 `GameCategoryList` 视图。这样，我们就可以对 `name`
    字段进行过滤。'
- en: The `search_fields` attribute specifies a tuple of string whose values indicate
    the text-type field names that we want to include in the search feature. In this
    case, we want to search only against the name field and perform a starts-with
    match. The `'^'` included as a prefix of the field name indicates that we want
    to restrict the search behavior to a starts-with match.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`search_fields` 属性指定了一个字符串元组，其值表示我们希望在搜索功能中包含的文本类型字段名称。在这种情况下，我们只想针对名称字段进行搜索并执行以开头匹配。字段名称前包含的
    `''^''` 前缀表示我们希望将搜索行为限制为以开头匹配。'
- en: The `ordering_fields` attribute specifies a tuple of string whose values indicate
    the field names that the client can specify to sort the results. In case the client
    doesn't specify a field for ordering, the response will use the default ordering
    fields indicated in the model related to the view.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordering_fields` 属性指定了一个字符串元组，其值表示客户端可以指定的字段名称，以对结果进行排序。如果客户端没有指定排序字段，则响应将使用与视图相关的模型中指示的默认排序字段。'
- en: 'Add the following highlighted lines to the `GameList` class declared in the
    `views.py` file. The new lines specify the fields to be used in the filter, search,
    and ordering features. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下加粗的行添加到在 `views.py` 文件中声明的 `GameList` 类中。新行指定了用于过滤、搜索和排序功能的字段。示例代码文件包含在 `restful_python_chapter_04_02`
    文件夹中：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this case, we specified many field names in the `filter_fields` attribute.
    We included `'game_category'` and `'owner'` in the string tuple, and therefore,
    the client will be able to include the id values for any of these two fields in
    the filter. We will take advantage of other options for related models, which
    will later allow us to filter the related models by field. This way, we will understand
    the different customizations available.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们在 `filter_fields` 属性中指定了许多字段名称。我们在字符串元组中包含了 `'game_category'` 和 `'owner'`，因此客户端将能够包含这两个字段中的任何一个的字段值。我们将利用其他相关模型选项，这将在以后允许我们通过字段过滤相关模型。这样，我们将了解可用的不同自定义选项。
- en: The `ordering_fields` attribute specifies two field names for the tuple of string,
    and therefore, the client will be able to order the results by either `name` or
    `release_date`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordering_fields` 属性指定了字符串元组中的两个字段名称，因此客户端将能够通过 `name` 或 `release_date` 对结果进行排序。'
- en: 'Add the following highlighted lines to the `PlayerList` class declared in the
    `views.py` file. The new lines specify the fields to be used in the filter, search,
    and ordering features. The code file for the sample is included in the `restful_python_chapter_04_02`
    folder:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下突出显示的行添加到`views.py`文件中声明的`PlayerList`类。新行指定了用于过滤、搜索和排序功能的字段。示例代码文件包含在`restful_python_chapter_04_02`文件夹中：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following lines to create the new `PlayerScoreFilter` class in the
    `views.py` file but before the declaration of the `PlayerScoreList` class. The
    code file for the sample is included in the `restful_python_chapter_04_02` folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下行添加到`views.py`文件中，在`PlayerScoreList`类声明之前创建新的`PlayerScoreFilter`类。示例代码文件包含在`restful_python_chapter_04_02`文件夹中：
- en: '[PRE28]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `PlayerScoreFilter` is a subclass of the `rest_framework.filters.FilterSet`
    class. We want to customize settings for the fields that we will use for filtering
    in the `PlayerScoreList` class-based view, and therefore, we created the new `PlayerScoreFilter`
    class. The class declares the following six class attributes:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerScoreFilter`是`rest_framework.filters.FilterSet`类的子类。我们希望为在`PlayerScoreList`基于类的视图中用于过滤的字段自定义设置，因此创建了新的`PlayerScoreFilter`类。该类声明了以下六个类属性：'
- en: '`min_score`: It is a `django_filters.NumberFilter` instance that allows the
    client to filter the player scores whose `score` numeric value is greater than
    or equal to the specified number. The value for `name` indicates the field to
    which the numeric filter is applied, `''score''`, and the `lookup_expr` value
    indicates the lookup expression, `''gte''`, which means greater than or equal
    to.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min_score`：它是一个`django_filters.NumberFilter`实例，允许客户端过滤得分数值大于或等于指定数字的玩家得分。`name`的值表示应用于数字过滤器的字段，即`''score''`，而`lookup_expr`的值表示查找表达式，即`''gte''`，表示大于或等于。'
- en: '`max_score`: It is a `django_filters.NumberFilter` instance that allows the
    client to filter the player scores whose `score` numeric value is less than or
    equal to the specified number. The value for `name` indicates the field to which
    the numeric filter is applied, `''score''`, and the `lookup_expr` value indicates
    the lookup expression, `''lte''`, which means less than or equal to.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max_score`：它是一个`django_filters.NumberFilter`实例，允许客户端过滤得分数值小于或等于指定数字的玩家得分。`name`的值表示应用于数字过滤器的字段，即`''score''`，而`lookup_expr`的值表示查找表达式，即`''lte''`，表示小于或等于。'
- en: '`from_score_date`: It is a `django_filters.DateTimeFilter` instance that allows
    the client to filter the player scores whose `score_datedatetime` value is greater
    than or equal to the specified `datetime` value. The value for `name` indicates
    the field to which the datetime filter is applied, `''score_date''`, and the `lookup_expr`
    value indicates the lookup expression, `''gte''`.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`from_score_date`：它是一个`django_filters.DateTimeFilter`实例，允许客户端过滤得分日期时间值大于或等于指定日期时间的玩家得分。`name`的值表示应用于日期时间过滤器的字段，即`''score_date''`，而`lookup_expr`的值表示查找表达式，即`''gte''`。'
- en: '`to_score_date`: It is a `django_filters.DateTimeFilter` instance that allows
    the client to filter the player scores whose `score_datedatetime` value is less
    than or equal to the specified `datetime` value. The value for `name` indicates
    the field to which the `datetime` filter is applied, `''score_date''`,and the
    `lookup_expr` value indicates the lookup expression, `''lte''`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`to_score_date`：它是一个`django_filters.DateTimeFilter`实例，允许客户端过滤得分日期时间值小于或等于指定日期时间的玩家得分。`name`的值表示应用于日期时间过滤器的字段，即`''score_date''`，而`lookup_expr`的值表示查找表达式，即`''lte''`。'
- en: '`player_name`: It is a `django_filters.AllValuesFilte`r: It is an instance
    that allows the client to filter the player scores whose player''s name matches
    the specified string value. The value for `name` indicates the field to which
    the filter is applied, `''player__name''`. Note that the value has a double underscore
    (`__`) and you can read it as the `name` field for the `player` model or simply
    replace the double underscore with a dot and read `player.name`. The name uses
    Django''s double underscore syntax. However, we don''t want the client to use
    `player__name` to specify the filter for the player''s name. Thus, the instance
    is stored in the class attribute named `player_name`, with just a single underscore
    between player and name. The browsable API will display a dropdown with all the
    possible values for the player''s name to use as a filter. The dropdown will only
    include the players'' names that have registered scores because we used the `AllValuesFilter`
    class.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`player_name`：这是一个 `django_filters.AllValuesFilter`：它是一个实例，允许客户端过滤与指定的字符串值匹配的玩家得分。`name`
    的值表示过滤器应用到的字段，`''player__name''`。请注意，该值有一个双下划线（`__`），你可以将其读作 `player` 模型的 `name`
    字段，或者简单地用点替换双下划线并读取 `player.name`。名称使用 Django 的双下划线语法。然而，我们不想让客户端使用 `player__name`
    来指定玩家名称的过滤器。因此，该实例存储在名为 `player_name` 的类属性中，玩家和名称之间只有一个单下划线。可浏览的 API 将显示一个下拉菜单，其中包含所有可能的玩家名称值，用作过滤器。下拉菜单将仅包括已注册得分的玩家名称，因为我们使用了
    `AllValuesFilter` 类。'
- en: '`game_name`: This is a `django_filters.AllValuesFilter` instance that allows
    the client to filter the player scores whose game''s name matches the specified
    string value. The value for `name` indicates the field on which the filter is
    applied, `''game__name''`. The name uses the previously explained Django''s double
    underscore syntax. As happened with `player_name`, we don''t want the client to
    use `game__name` to specify the filter for the game''s name, and therefore, we
    stored the instance in the class attribute named `game_name`, with just a single
    underscore between game and name. The browsable API will display a dropdown with
    all the possible values for the game''s name to use as a filter. The dropdown
    will only include the game''s names that have registered scores because we used
    the `AllValuesFilter` class.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`game_name`：这是一个 `django_filters.AllValuesFilter` 实例，允许客户端过滤与指定的字符串值匹配的游戏名称的玩家得分。`name`
    的值表示过滤器应用到的字段，`''game__name''`。名称使用之前解释过的 Django 的双下划线语法。与 `player_name` 的情况一样，我们不想让客户端使用
    `game__name` 来指定游戏名称的过滤器，因此，我们将该实例存储在名为 `game_name` 的类属性中，游戏和名称之间只有一个单下划线。可浏览的
    API 将显示一个下拉菜单，其中包含所有可能的游戏名称值，用作过滤器。下拉菜单将仅包括已注册得分的游戏名称，因为我们使用了 `AllValuesFilter`
    类。'
- en: 'In addition, the `PlayerScoreFilter` class declares a `Meta` inner class that
    declares two attributes: `model` and `fields`. The `model` attribute specifies
    the model related to the filter set, that is, the `PlayerScore` class. The `fields`
    attribute specifies a tuple of string whose values indicate the field names and
    filter names that we want to include in the filters for the related model. We
    included `''scores''` and the names for all the previously declared filters. The
    string `''scores''` refers to the `score` field name and we want to apply the
    default numeric filter that will be built under the hoods to allow the client
    to filter by an exact match on the `score` field.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`PlayerScoreFilter` 类声明了一个 `Meta` 内部类，该类声明了两个属性：`model` 和 `fields`。`model`
    属性指定与过滤器集相关的模型，即 `PlayerScore` 类。`fields` 属性指定一个字符串元组，其值表示我们想在相关模型的过滤器中包含的字段名称和过滤器名称。我们包含了
    `'scores'` 和之前声明的所有过滤器名称。字符串 `'scores'` 指的是 `score` 字段名称，我们希望应用默认的数值过滤器，该过滤器将在幕后构建，以便客户端可以通过
    `score` 字段上的精确匹配进行过滤。
- en: 'Finally, add the following highlighted lines to the `PlayerScoreList` class
    declared in the `views.py` file. The code file for the sample is included in the
    `restful_python_chapter_04_02` folder:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将以下突出显示的行添加到在 `views.py` 文件中声明的 `PlayerScoreList` 类。示例的代码文件包含在 `restful_python_chapter_04_02`
    文件夹中：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `filter_class` attribute specifies the `FilterSet` subclass that we want
    to use for this class-based view: `PlayerScoreFilter`. In addition, we specified
    the two field names that the client will be able to use for ordering in the `ordering_fields`
    tuple of string.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter_class` 属性指定了我们想用于此类视图的 `FilterSet` 子类：`PlayerScoreFilter`。此外，我们在 `ordering_fields`
    字符串元组中指定了客户端将能够用于排序的两个字段名称。'
- en: Testing filtering, searching, and ordering
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试过滤、搜索和排序
- en: Now, we can launch Django's development server to compose and send HTTP requests.
    Execute any of the following two commands based on your needs to access the API
    in other devices or computers connected to your LAN. Remember that we analyzed
    the difference between them in [Chapter 1](ch01.html "Chapter 1. Developing RESTful
    APIs with Django"), *Developing RESTful APIs with Django*.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动Django的开发服务器来编写和发送HTTP请求。根据您的需求，执行以下两个命令之一以在其他连接到您局域网的设备或计算机上访问API。请记住，我们在[第1章](ch01.html
    "第1章。使用Django开发RESTful API")中分析了它们之间的区别，*使用Django开发RESTful API*。
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After we run any of the previous commands, the development server will start
    listening at port `8000`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们运行任何之前的命令后，开发服务器将监听端口`8000`：
- en: 'Now, we will compose and send an HTTP request to retrieve all the game categories
    whose name matches `3D RPG`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写并发送一个HTTP请求来检索所有名称匹配`3D RPG`的游戏类别：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following lines show a sample response with the single game category whose
    name matches the specified name in the filter. The following lines only show the
    JSON body without the headers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了与过滤器中指定的名称匹配的单个游戏类别的示例响应。以下行仅显示JSON正文，不包含头部信息：
- en: '[PRE33]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will compose and send an HTTP request to retrieve all the games whose related
    category id is equal to `3` and the value for the played field is equal to `True`.
    We want to sort the results by `release_date` in descending order, and therefore,
    we specify `-release_date` in the value for `ordering`. The hyphen (`-`) before
    the field name specifies the ordering feature to use descending order instead
    of the default ascending order. Make sure you replace `3` with the pk value of
    the previously retrieved game category named `3D RPG`. The played field is a `bool`
    field, and therefore, we have to use Python-valid `bool` values (`True` and `False`)
    when specifying the desired values for the `bool` field in the filter:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并发送一个HTTP请求来检索所有相关类别ID等于`3`且玩过的字段值等于`True`的游戏。我们希望按`release_date`降序排序结果，因此，我们在`ordering`的值中指定`-release_date`。字段名前的连字符（`-`）指定了使用降序而不是默认升序的排序功能。确保将`3`替换为之前检索到的名为`3D
    RPG`的游戏类别的pk值。玩过的字段是一个`bool`字段，因此，在指定过滤器中`bool`字段的期望值时，我们必须使用Python有效的`bool`值（`True`和`False`）：
- en: '[PRE34]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The following lines show a sample response with the two games that match the
    specified criteria in the filter. The following lines only show the JSON body
    without the headers:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了与过滤器中指定的标准匹配的两个游戏的示例响应。以下行仅显示JSON正文，不包含头部信息：
- en: '[PRE36]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the `GameList` class, we specified `''game_category''` as one of the strings
    in the `filter_fields` tuple of string. Thus, we had to use the game category
    id in the filter. Now, we will use a filter on the game''s name related to a registered
    score. The `PlayerScoreFilter` class provides us a filter to the name of the related
    game in `game_name`. We will combine the filter with another filter on the player''s
    name related to a registered score. The `PlayerScoreFilter` class provides us
    a filter to the name of the related player in `player_name`. Both conditions specified
    in the criteria must be met, and therefore, the filters are combined with the
    `AND` operator:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GameList`类中，我们将`'game_category'`指定为`filter_fields`元组中的字符串之一。因此，我们必须在过滤器中使用游戏类别ID。现在，我们将使用与已注册分数相关的游戏名称的过滤器。`PlayerScoreFilter`类为我们提供了在`game_name`中相关游戏的过滤器。我们将该过滤器与另一个与已注册分数相关的玩家名称的过滤器结合起来。`PlayerScoreFilter`类为我们提供了在`player_name`中相关玩家的过滤器。必须满足标准中指定的两个条件，因此，过滤器使用`AND`运算符组合：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE38]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following lines show a sample response with the score that matches the
    specified criteria in the filters. The following lines only show the JSON body
    without the headers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了与过滤器中指定的标准匹配的分数的示例响应。以下行仅显示JSON正文，不包含头部信息：
- en: '[PRE39]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We will compose and send an HTTP request to retrieve all the scores that match
    the following criteria. The results will be ordered by `score_date` in descending
    order.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写并发送一个HTTP请求来检索所有符合以下标准的分数。结果将按`score_date`降序排序。
- en: The `score` value is between 30,000 and 150,000
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score`的值在30,000到150,000之间'
- en: The `score_date` is between 2016-06-21 and 2016-06-22
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`score_date`的值在2016-06-21和2016-06-22之间'
- en: '[PRE40]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的`curl`命令：
- en: '[PRE41]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The following lines show a sample response with the three games that match
    the specified criteria in the filters. We overrode the default ordering specified
    in the model with the specified ordering in the request. The following lines only
    show the JSON body without the headers:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了一个示例响应，其中包含符合筛选器中指定标准的三个游戏。我们用请求中指定的排序覆盖了模型中指定的默认排序。以下几行仅显示 JSON 主体，不包含头部信息：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Tip
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the preceding requests, all the responses didn't have more than one page.
    In case the response requires more than one page, the values for the `previous`
    and `next` keys will display the URLs that include the combination of the filters,
    search, ordering and pagination.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的请求中，所有响应的页面不超过一页。如果响应需要超过一页，`previous` 和 `next` 键的值将显示包含筛选、搜索、排序和分页组合的 URL。
- en: 'We will compose and send an HTTP request to retrieve all the games whose `name`
    starts with `''S''`. We will use the search feature that we configured to restrict
    the search behavior to a starts-with match on the `name` field:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将组合并发送一个 HTTP 请求来检索所有以 `'S'` 开头的游戏。我们将使用我们配置的搜索功能，将搜索行为限制在 `name` 字段的以开始匹配上：
- en: '[PRE43]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following is the equivalent `curl` command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应的 `curl` 命令：
- en: '[PRE44]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The following lines show a sample response with the two games that match the
    specified search criteria, that is, those games whose name starts with `''S''`.
    The following lines only show the JSON body without the headers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行显示了一个示例响应，其中包含符合指定搜索标准的两个游戏。以下几行仅显示 JSON 主体，不包含头部信息：
- en: '[PRE45]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'We can change the search and ordering parameter''s default names: `''search''`
    and `''ordering''`. We just need to specify the desired names in the `SEARCH_PARAM`
    and the `ORDERING_PARAM` settings.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更改搜索和排序参数的默认名称：`'search'` 和 `'ordering'`。我们只需在 `SEARCH_PARAM` 和 `ORDERING_PARAM`
    设置中指定所需的名称。
- en: Filtering, searching, and ordering in the Browsable API
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可浏览 API 中的筛选、搜索和排序
- en: We can take advantage of the browsable API to easily test filter, search, and
    order features through a web browser. Open a web browser and enter `http://localhost:8000/player-scores/`.
    In case you use another computer or device to run the browser, replace `localhost` with
    the IP of the computer that is running the Django development server. The browsable
    API will compose and send a `GET` request to `/player-scores/` and will display
    the results of its execution, that is, the headers and the JSON player scores
    list. You will notice that there is a new **Filters** button located on the left-hand
    side of the **OPTIONS** button.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用可浏览的 API，通过网页浏览器轻松测试筛选、搜索和排序功能。打开网页浏览器，输入 `http://localhost:8000/player-scores/`。如果你使用另一台计算机或设备运行浏览器，请将
    `localhost` 替换为运行 Django 开发服务器的计算机的 IP 地址。可浏览的 API 将组合并发送一个 `GET` 请求到 `/player-scores/`，并将显示其执行结果，即头部信息和
    JSON 玩家得分列表。你会注意到在 **OPTIONS** 按钮的左侧有一个新的 **筛选器** 按钮。
- en: 'Click on **Filters** and the browsable API will display the **Filters** dialog
    box with the appropriate controls for each filter that you can apply below **Field
    Filters** and the different ordering options below **Ordering**. The following
    screenshot shows the **Filters** dialog box:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **筛选器**，可浏览的 API 将显示 **筛选器** 对话框，其中包含适用于每个筛选器的适当控件，这些控件位于 **字段筛选器** 下方，以及位于
    **排序** 下的不同排序选项。以下截图显示了 **筛选器** 对话框：
- en: '![Filtering, searching, and ordering in the Browsable API](img/image_04_001.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![可浏览 API 中的筛选、搜索和排序](img/image_04_001.jpg)'
- en: 'Both the **Player name** and **Game name** dropdowns will only include the
    related player''s and game''s names that have registered scores because we used
    the `AllValuesFilter` class for both filters. After we enter all the values for
    the filters, we can select the desired ordering option or click **Submit**. The
    browsable API will compose and send the appropriate HTTP request and will render
    a web page with the results of its execution. The results will include the HTTP
    request that was made to the Django server. The following screenshot shows an
    example of the result of executing the next request, that is, the request we built
    using the browsable API:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**玩家姓名** 和 **游戏名称** 下拉菜单将只包括已注册得分的相关玩家和游戏名称，因为我们为两个筛选器都使用了 `AllValuesFilter`
    类。在输入所有筛选器的值后，我们可以选择所需的排序选项或点击 **提交**。可浏览的 API 将组合并发送适当的 HTTP 请求，并渲染一个显示其执行结果的网页。结果将包括发送到
    Django 服务器的 HTTP 请求。以下截图显示了执行下一个请求的示例结果，即我们使用可浏览的 API 构建的请求：'
- en: '[PRE46]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![Filtering, searching, and ordering in the Browsable API](img/image_04_002.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![在可浏览 API 中进行过滤、搜索和排序](img/image_04_002.jpg)'
- en: Setting up unit tests
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置单元测试
- en: First, we will install the `coverage` and `django-nose` packages in our virtual
    environment. We will make the necessary configurations to use the `django_nose.NoseTestRunner`
    class to run all the tests we code and we will use the necessary configurations
    to improve the accuracy of the test coverage measurements.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将安装 `coverage` 和 `django-nose` 包到我们的虚拟环境中。我们将进行必要的配置以使用 `django_nose.NoseTestRunner`
    类来运行所有编写的测试，并且我们将使用必要的配置来提高测试覆盖率测量的准确性。
- en: 'Make sure that you quit Django''s development server. Remember that you just
    need to press **Ctrl** + **C** in the terminal or the Command Prompt window in
    which it is running. We just need to run the following command to install the
    `coverage` package:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您退出 Django 的开发服务器。请记住，您只需在终端或正在运行的命令提示符窗口中按 **Ctrl** + **C** 即可。我们只需运行以下命令来安装
    `coverage` 包：
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The last few lines of the output indicate that the `django-nose` package has
    been successfully installed:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行表明 `django-nose` 包已成功安装：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We just need to run the following command to install the `django-nose` package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需运行以下命令来安装 `django-nose` 包：
- en: '[PRE49]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The last few lines of the output indicate that the `django-nose` package has
    been successfully installed.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的最后几行表明 `django-nose` 包已成功安装。
- en: '[PRE50]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add `''django_nose''` to the installed apps in the `settings.py` file, specifically,
    to the `INSTALLED_APPS` string list. The following code shows the lines we need
    to add as highlighted code. The code file for the sample is included in the `restful_python_chapter_04_03`
    folder:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `'django_nose'` 添加到 `settings.py` 文件中已安装的应用程序，具体来说，添加到 `INSTALLED_APPS` 字符串列表中。以下代码显示了我们需要添加的突出显示的代码行。示例代码文件包含在
    `restful_python_chapter_04_03` 文件夹中：
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Open the `gamesapi/settings.py` file and add the following lines to configure
    the `django_nose.NoseTestRunner` class as our test runner and specify the default
    command-line options that we will use when we run our tests. The code file for
    the sample is included in the `restful_python_chapter_04_03` folder:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `gamesapi/settings.py` 文件，并添加以下行以配置 `django_nose.NoseTestRunner` 类作为我们的测试运行器，并指定我们在运行测试时将使用的默认命令行选项。示例代码文件包含在
    `restful_python_chapter_04_03` 文件夹中：
- en: '[PRE52]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `NOSE_ARGS` settings specify the following command-line options for the
    nose test suite runner and for coverage:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`NOSE_ARGS` 设置指定了 nose 测试套件运行器和覆盖率所使用的以下命令行选项：'
- en: '`--with-coverage`: This option specifies that we always want to generate a
    test coverage report.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--with-coverage`: 这个选项指定我们始终想要生成测试覆盖率报告。'
- en: '`--cover-erase`: This option makes sure the the test runner deletes the coverage
    test results from the previous run.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cover-erase`: 这个选项确保测试运行器从之前的运行中删除覆盖率测试结果。'
- en: '`--cover-inclusive`: This option includes all the Python files under the working
    directory in the coverage report. This way, we make sure that we discover holes
    in test coverage when we don''t import all the files in our test suite. We will
    create a test suite that won''t import all the files, and therefore, this option
    is very important to have an accurate test coverage report.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cover-inclusive`: 这个选项将工作目录下的所有 Python 文件包含在覆盖率报告中。这样，我们确保在测试套件中没有导入所有文件时，能够发现测试覆盖的漏洞。我们将创建一个不会导入所有文件的测试套件，因此，这个选项对于获得准确的测试覆盖率报告非常重要。'
- en: '`--cover-package=games`: This option indicates the module that we want to cover:
    `games`.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cover-package=games`: 这个选项表示我们想要覆盖的模块：`games`。'
- en: 'Finally, create a new text file named `.coveragerc` within the `gamesapi` root
    folder with the following content:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `gamesapi` 根目录下创建一个名为 `.coveragerc` 的新文本文件，内容如下：
- en: '[PRE53]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This way, the `coverage` utility won't take into account many things related
    to the generated migrations when providing us with the test coverage report. We
    will have a more accurate test coverage report with this settings file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`coverage` 工具在提供测试覆盖率报告时不会考虑与生成的迁移相关的许多事情。我们将使用这个设置文件获得更准确的测试覆盖率报告。
- en: Writing a first round of unit tests
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写第一轮单元测试
- en: 'Now, we will write the first round of unit tests. Specifically, we will write
    unit tests related to the game category class-based views: `GameCategoryList`
    and `GameCategoryDetail`. Open the existing `games/test.py` file and replace the
    existing code with the following lines that declare many `import` statements and
    the `GameCategoryTests` class. The code file for the sample is included in the
    `restful_python_chapter_04_04` folder, as shown:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写第一轮单元测试。具体来说，我们将编写与基于类的游戏类别视图相关的单元测试：`GameCategoryList`和`GameCategoryDetail`。打开现有的`games/test.py`文件，并用以下行替换现有代码，这些行声明了许多`import`语句和`GameCategoryTests`类。示例代码文件包含在`restful_python_chapter_04_04`文件夹中，如下所示：
- en: '[PRE54]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `GameCategoryTests` class is a subclass of `rest_framework.test.APITestCase`.
    The class declares the `create_game_category` method that receives the desired
    `name` for the new game category as an argument. The method builds the URL and
    the data dictionary to compose and send an HTTP `POST` method to the view associated
    with the `gamecategory-list` view name and returns the response generated by this
    request. The code uses `self.client` to access the `APIClient` instance that allows
    us to easily compose and send HTTP requests for testing. In this case, the code
    calls the `post` method with the built `url`, the `data` dictionary, and the desired
    format for the data-`'json'`. Many test methods will call the `create_game_category`
    method to create a game category and then compose and send other HTTP requests
    to the API.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameCategoryTests`类是`rest_framework.test.APITestCase`的子类。该类声明了`create_game_category`方法，该方法将新游戏类别的所需`name`作为参数。该方法构建URL和数据字典，以向与`gamecategory-list`视图名称关联的视图发送HTTP
    `POST`方法，并返回此请求生成的响应。代码使用`self.client`来访问允许我们轻松组合和发送HTTP请求进行测试的`APIClient`实例。在这种情况下，代码使用构建的`url`、`data`字典和所需的数据格式`''json''`调用`post`方法。许多测试方法将调用`create_game_category`方法来创建游戏类别，然后向API发送其他HTTP请求。'
- en: 'The `test_create_and_retrieve_game_category` method tests whether we can create
    a new `GameCategory` and then retrieve it. The method calls the `create_game_category`
    method explained earlier and then uses `assertEqual` to check for the following
    expected results:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_create_and_retrieve_game_category`方法测试我们是否可以创建一个新的`GameCategory`并检索它。该方法调用前面解释的`create_game_category`方法，然后使用`assertEqual`检查以下预期结果：'
- en: The `status_code` for the response is HTTP 201 Created (`status.HTTP_201_CREATED`)
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应的`status_code`是HTTP 201 Created（`status.HTTP_201_CREATED`）
- en: The total number of `GameCategory` objects retrieved from the database is `1`
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从数据库检索到的`GameCategory`对象总数为`1`
- en: 'Add the following methods to the `GameCategoryTests` class we created in the
    `games/test.py` file. The code file for the sample is included in the `restful_python_chapter_04_04`
    folder:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到我们在`games/test.py`文件中创建的`GameCategoryTests`类中。示例代码文件包含在`restful_python_chapter_04_04`文件夹中：
- en: '[PRE55]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We added the following methods that start whose name start with the `test_`
    prefix:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了以下以`test_`前缀开头的方法：
- en: '`test_create_duplicated_game_category`: Tests whether the unique constraints
    don''t make it possible for us to create two game categories with the same name.
    The second time we compose and send an HTTP POST request with a duplicate category
    name, we must receive an `HTTP 400 Bad Request` status code (`status.HTTP_400_BAD_REQUEST`)'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_duplicated_game_category`: 测试唯一约束是否使我们无法创建两个具有相同名称的游戏类别。当我们第二次使用重复的类别名称组合并发送HTTP
    POST请求时，我们必须收到一个`HTTP 400 Bad Request`状态码（`status.HTTP_400_BAD_REQUEST`）'
- en: '`test_retrieve_game_categories_list`: Tests whether we can retrieve a specific
    game category by its primary key or id'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_retrieve_game_categories_list`: 测试我们是否可以通过主键或id检索特定的游戏类别'
- en: '`test_update_game_category`: Tests whether we can update a single field for
    a game category'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_update_game_category`: 测试我们是否可以更新游戏类别的单个字段'
- en: '`test_filter_game_category_by_name`: Tests whether we can filter a game category
    by name'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_filter_game_category_by_name`: 测试我们是否可以通过名称过滤游戏类别'
- en: Tip
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that each test that requires a specific condition in the database must
    execute all the necessary code for the database to be in this specific condition.
    For example, in order to update an existing game category, first we must create
    a new game category and then we can update it. Each test method will be executed
    without data from the previously executed test methods in the database, that is,
    each test will run with a database cleaned of data from previous tests.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个需要在数据库中具有特定条件的测试都必须执行使数据库处于该特定条件的所有必要代码。例如，为了更新现有的游戏类别，我们首先必须创建一个新的游戏类别，然后我们才能更新它。每个测试方法将在数据库中不包含先前执行的测试方法的数据的情况下执行，也就是说，每个测试都将使用从先前测试中清除数据的数据库运行。
- en: 'The last three methods in the preceding list check the data included in the
    response JSON body by inspecting the `data` attribute for the response. For example,
    the first line checks whether the value for `count` is equal to `1` and the next
    lines check whether the `name` key for the first element in the `results` array
    is equal to the value hold in the `new_game_category_name` variable:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上一列表中的最后三种方法通过检查响应 JSON 体的 `data` 属性来验证包含在响应中的数据。例如，第一行检查 `count` 的值是否等于 `1`，接下来的行检查
    `results` 数组中第一个元素的 `name` 键是否等于 `new_game_category_name` 变量中持有的值：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `test_filter_game_category_by_name` method calls the `django.utils.http.urlencode`
    function to generate an encoded URL from the `filter_by_name` dictionary that
    specifies the field name and the value we want to use to filter the retrieved
    data. The following lines show the code that generates the URL and saves it in
    the `url` variable. If `game_cagory_name1` is `'First game category name'`, the
    result of the call to the `urlencode` function will be `'name=First+game+category+name'`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_filter_game_category_by_name` 方法调用 `django.utils.http.urlencode` 函数，从指定字段名称和我们要用于过滤检索数据的值的
    `filter_by_name` 字典生成一个编码的 URL。以下行显示了生成 URL 并将其保存到 `url` 变量的代码。如果 `game_cagory_name1`
    是 `''First game category name''`，则 `urlencode` 函数调用的结果将是 `''name=First+game+category+name''`。'
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Running unit tests and checking testing coverage
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单元测试并检查测试覆盖率
- en: Now, run the following command to create a test database, run all the migrations
    and use the Django nose test running to execute all the tests we created. The
    test runner will execute all the methods for our `GameCategoryTests` class that
    start with the `test_` prefix and will display the results.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以创建测试数据库，运行所有迁移，并使用 Django nose 测试运行器执行我们创建的所有测试。测试运行器将执行以 `test_`
    前缀开始的我们 `GameCategoryTests` 类的所有方法，并将显示结果。
- en: Tip
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The tests won't make changes to the database we have been using when working
    on the API.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理 API 时，测试不会更改我们一直在使用的数据库。
- en: 'Remember that we configured many default command-line options that will be
    used without the need to enter them in our command-line. Run the following command
    within the same virtual environment we have been using. We will use the `-v 2`
    option to use the verbosity level 2 because we want to check all the things that
    the test runner is doing:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们配置了许多默认的命令行选项，它们将在不输入它们的情况下使用。在我们在其中使用的同一虚拟环境中运行以下命令。我们将使用 `-v 2` 选项来使用
    2 级详细程度，因为我们想检查测试运行器正在执行的所有事情：
- en: '[PRE58]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The following lines show the sample output:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例输出：
- en: '[PRE59]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output provides the details indicating that the test runner executed 5
    tests and all of them passed. After the details about the migrations are executed,
    the output displays the comments we included for each method in the `GameCategoryTests`
    class that started with the `test_` prefix and represented a test to be executed.
    The following list shows the description included in the comments and the method
    that they represent:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了详细信息，表明测试运行器执行了 5 个测试，并且所有测试都通过了。在执行迁移的详细信息之后，输出显示了我们在 `GameCategoryTests`
    类中为每个方法包含的注释，这些注释以 `test_` 前缀开头，代表要执行的测试。以下列表显示了注释中包含的描述以及它们所代表的方法：
- en: 'Ensures we can create a new GameCategory and then retrieve it: `test_create_and_retrieve_game_category`.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们可以创建一个新的 GameCategory 并然后检索它：`test_create_and_retrieve_game_category`。
- en: 'Ensures we can create a new GameCategory: `test_create_duplicated_game_category`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们可以创建一个新的 GameCategory：`test_create_duplicated_game_category`。
- en: 'Ensures we can filter a game category by name: `test_retrieve_game_categories_list`.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们可以通过名称过滤游戏类别：`test_retrieve_game_categories_list`。
- en: 'Ensures we can retrieve a game cagory: `test_update_game_category`.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们可以检索一个游戏类别：`test_update_game_category`。
- en: 'Ensures we can update a single field for a game category: `test_filter_game_category_by_name`.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们可以更新游戏类别的单个字段：`test_filter_game_category_by_name`。
- en: 'The test code coverage measurement report provided by the `coverage` package
    uses the code analysis tools and the tracing hooks included in the Python standard
    library to determine which lines of code are executable and which of these lines
    have been executed. The report provides a table with the following columns:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`coverage` 包提供的测试代码覆盖率测量报告使用 Python 标准库中包含的代码分析工具和跟踪钩子来确定哪些代码行是可执行的，以及哪些行已被执行。报告提供了一个包含以下列的表格：'
- en: '`Name`: The Python module name.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`名称`：Python 模块名称。'
- en: '`Stmts`: The count of executable statements for the Python module.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stmts`：Python 模块的语句计数。'
- en: '`Miss`: The number of executable statements missed, that is, the ones that
    weren''t executed.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Miss`：未执行的语句数量，即未执行的语句。'
- en: '`Cover`: The coverage of executable statements, expressed as a percentage.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`覆盖率`：可执行语句的覆盖率，以百分比表示。'
- en: 'We definitely have a very low coverage for `models.py` based on the measurements
    shown in the report. In fact, we just wrote a few tests related to the `GameCategory`
    model, and therefore, it makes sense that the coverage is really low for the models:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 根据报告中显示的测量结果，`models.py` 的覆盖率肯定非常低。实际上，我们只编写了一些与 `GameCategory` 模型相关的测试，因此，覆盖率对于模型来说确实很低：
- en: We can run the `coverage` command with the `-m` command-line option to display
    the line numbers of the missing statements in a new `Missing` column.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用带有 `-m` 命令行选项的 `coverage` 命令来显示缺失语句的行号，并在新的 `Missing` 列中显示。
- en: '[PRE60]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The command will use the information from the last execution and will display
    the missing statements. The next lines show a sample output that correspond to
    the previous execution of the unit tests:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将使用上次执行的信息，并显示缺失的语句。以下几行显示了与之前单元测试执行相对应的示例输出：
- en: '[PRE61]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Now, run the following command to get annotated HTML listings detailing missed
    lines:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行以下命令以获取详细说明缺失行的注释 HTML 列表：
- en: '[PRE62]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Open the `index.html` HTML file generated in the `htmlcov` folder with your
    web browser. The following picture shows an example report that coverage generated
    in HTML format.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的网络浏览器打开在 `htmlcov` 文件夹中生成的 `index.html` HTML 文件。以下图片显示了以 HTML 格式生成的覆盖率报告示例。
- en: '![Running unit tests and checking testing coverage](img/image_04_003.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![运行单元测试和检查测试覆盖率](img/image_04_003.jpg)'
- en: 'Click or tap on `games/models.py` and the web browser will render a web page
    that displays the statements that were run, the missing ones and the excluded,
    with different colors. We can click or tap on the **run**, **missing,** and **excluded**
    buttons to show or hide the background color that represents the status for each
    line of code. By default, the missing lines of code will be displayed with a pink
    background. Thus, we must write unit tests that target these lines of code to
    improve our tests coverage:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 点击或轻触 `games/models.py`，网页浏览器将渲染一个显示已运行、缺失和排除的语句的网页，不同颜色区分。我们可以点击或轻触 **运行**、**缺失**
    和 **排除** 按钮，以显示或隐藏代表每行代码状态的背景色。默认情况下，缺失的代码行将以粉色背景显示。因此，我们必须编写针对这些代码行的单元测试来提高我们的测试覆盖率：
- en: '![Running unit tests and checking testing coverage](img/image_04_004.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![运行单元测试和检查测试覆盖率](img/image_04_004.jpg)'
- en: Improving testing coverage
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高测试覆盖率
- en: 'Now, we will write additional unit tests to improve the testing coverage. Specifically,
    we will write unit tests related to the player class based views: `PlayerList`
    and `PlayerDetail`. Open the existing `games/test.py` file and insert the following
    lines after the last line that declares imports. We need a new `import` statement
    and we will declare the new `PlayerTests` class. The code file for the sample
    is included in the `restful_python_chapter_04_05` folder:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将编写额外的单元测试来提高测试覆盖率。具体来说，我们将编写与玩家类视图相关的单元测试：`PlayerList` 和 `PlayerDetail`。打开现有的
    `games/test.py` 文件，在声明导入的最后一行之后插入以下行。我们需要一个新的 `import` 语句，并将声明新的 `PlayerTests`
    类。示例代码文件包含在 `restful_python_chapter_04_05` 文件夹中：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The `PlayerTests` class is a subclass of `rest_framework.test.APITestCase`.
    The class declares the `create_player` method that receives the desired `name`
    and `gender` for the new player as arguments. The method builds the url and the
    data dictionary to compose and send an HTTP `POST` method to the view associated
    with the `player-list` view name and returns the response generated by this request.
    Many test methods will call the `create_player` method to create a player and
    then compose and send other HTTP requests to the API.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlayerTests`类是`rest_framework.test.APITestCase`的子类。该类声明了`create_player`方法，该方法接收新玩家所需的`name`和`gender`作为参数。该方法构建URL和数据字典，以组成并发送一个HTTP
    `POST`方法到与`player-list`视图名称关联的视图，并返回此请求生成的响应。许多测试方法将调用`create_player`方法来创建玩家，然后组成并发送其他HTTP请求到API。'
- en: 'The class declares the following methods that start whose name start with the
    `test_` prefix:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 该类声明了以下以`test_`前缀开始的方法：
- en: '`test_create_and_retrieve_player`: Tests whether we can create a new `Player`
    and then retrieve it.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_and_retrieve_player`：测试我们是否可以创建一个新的`Player`并检索它。'
- en: '`test_create_duplicated_player`: Tests whether the unique constraints don''t
    make it possible for us to create two players with the same name. The second time
    we compose and send an HTTP POST request with a duplicate player name, we must
    receive an HTTP 400 Bad Request status code (`status.HTTP_400_BAD_REQUEST`).'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_create_duplicated_player`：测试唯一约束是否使我们无法创建具有相同名称的两个玩家。当我们第二次使用重复的玩家名称组成并发送HTTP
    POST请求时，我们必须收到HTTP 400 Bad Request状态码（`status.HTTP_400_BAD_REQUEST`）。'
- en: '`test_retrieve_player_list`: Tests whether we can retrieve a specific game
    category by its primary key or id.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test_retrieve_player_list`：测试我们是否可以通过其主键或id检索特定的游戏类别。'
- en: We just coded a few tests related to players to improve test coverage and notice
    the impact on the test coverage report.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是编写了一些与玩家相关的测试来提高测试覆盖率，并注意到对测试覆盖率报告的影响。
- en: 'Now, run the following command within the same virtual environment we have
    been using. We will use the `-v 2` option to use the verbosity level 2 because
    we want to check all the things that the test runner is doing:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在同一个虚拟环境中运行以下命令。我们将使用`-v 2`选项来使用2级详细程度，因为我们想检查测试运行器所做的一切：
- en: '[PRE64]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following lines show the last lines of the sample output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了样本输出的最后几行：
- en: '[PRE65]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The output provides details that indicate that the test runner executed 8 tests
    and all of them passed. The test code coverage measurement report provided by
    the `coverage` package increased the `Cover` percentage from 3% in the previous
    run to 6%. The additional tests we wrote execute code for the `Player` model,
    and therefore, there is an impact in the coverage report.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 输出提供了细节，表明测试运行器执行了8个测试，并且所有测试都通过了。由`coverage`包提供的测试代码覆盖率测量报告将前一次运行的`Cover`百分比从3%提高到6%。我们编写的附加测试执行了`Player`模型的代码，因此，覆盖率报告中有所影响。
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We just created a few unit tests to understand how we can code them. However,
    of course, it would be necessary to write more tests to provide an appropriate
    coverage of all the featured and execution scenarios included in the API.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是创建了一些单元测试来了解我们如何编写它们。然而，当然，编写更多的测试以提供API中包含的所有功能和执行场景的适当覆盖率是必要的。
- en: Understanding strategies for deployments and scalability
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解部署和可扩展性的策略
- en: One of the biggest drawbacks related to Django and Django REST Framework is
    that each HTTP request is blocking. Thus, whenever the Django server receives
    an HTTP request, it doesn't start working on any other HTTP requests in the incoming
    queue until the server sends the response for the first HTTP request it received.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 与Django和Django REST Framework相关的一个最大的缺点是每个HTTP请求都是阻塞的。因此，每当Django服务器收到一个HTTP请求时，它不会开始处理队列中的任何其他HTTP请求，直到服务器为它收到的第一个HTTP请求发送响应。
- en: However, one of the greatest advantages of RESTful Web Services is that they
    are stateless, that is, they shouldn't keep a client state on any server. Our
    API is a good example of a stateless RESTful Web Service. Thus, we can make the
    API run on as many servers as necessary to achieve our scalability goals. Obviously,
    we must take into account that we can easily transform the database server in
    our scalability bottleneck.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，RESTful Web服务的最大优点之一是它们是无状态的，也就是说，它们不应该在任何服务器上保持客户端状态。我们的API是一个无状态RESTful
    Web服务的良好例子。因此，我们可以让API在尽可能多的服务器上运行，以实现我们的可扩展性目标。显然，我们必须考虑到我们很容易将数据库服务器转化为我们的可扩展性瓶颈。
- en: Tip
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Nowadays, we have a huge number of cloud-based alternatives to deploy a RESTful
    web service that uses Django and Django REST Framework and make it extremely scalable.
    Just to mention a few examples, we have Heroku, PythonAnywhere, Google App Engine,
    OpenShift, AWS Elastic Beanstalk, and Windows Azure.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有大量的基于云的替代方案来部署使用Django和Django REST Framework的RESTful Web服务，使其具有极高的可扩展性。仅举几个例子，我们有Heroku、PythonAnywhere、Google
    App Engine、OpenShift、AWS Elastic Beanstalk和Windows Azure。
- en: Each platform includes detailed instructions to deploy our application. All
    of them will require us to generate the `requirements.txt` file that lists the
    application dependencies together with their versions. This way, the platforms
    will be able to install all the necessary dependencies listed in the file.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每个平台都包含了部署我们应用程序的详细说明。所有这些都需要我们生成`requirements.txt`文件，该文件列出了应用程序及其版本依赖项。这样，平台就能够安装文件中列出的所有必要依赖项。
- en: 'Run the following `pip freeze`, to generate the `requirements.txt` file:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下`pip freeze`命令，以生成`requirements.txt`文件：
- en: '[PRE66]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The following lines show the contents of a sample generated `requirements.txt`
    file. However, bear in mind that many packages increase their version number quickly
    and you might see different versions in your configuration:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行显示了示例生成的`requirements.txt`文件的内容。然而，请注意，许多包的版本号增长很快，你可能会在你的配置中看到不同的版本：
- en: '[PRE67]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We always have to make sure that we profile the API and the database before
    we deploy our first version of the RESTful Web Service. It is very important to
    make sure that the generated queries run properly on the underlying database and
    that the most popular queries do not end up in sequential scans. It is usually
    necessary to add the appropriate indexes to the tables in the database.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署我们的第一个版本的RESTful Web服务之前，我们始终要确保对API和数据库进行性能分析。确保生成的查询在底层数据库上运行正常，以及最常用的查询不会最终变成顺序扫描，这一点非常重要。通常情况下，需要在数据库中的表上添加适当的索引。
- en: 'We have been using basic HTTP authentication. In case we decide to use this
    authentication or other mechanisms, we must make sure that the API runs under
    HTTPS in production environments. In addition, we must make sure that we change
    the following line in the `settings.py` file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用基本的HTTP身份验证。如果我们决定使用这种身份验证或其他机制，我们必须确保API在生产环境中运行在HTTPS下。此外，我们必须确保我们更改`settings.py`文件中的以下行：
- en: '[PRE68]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We must always turn off the debug mode in production, and therefore, we must
    replace the previous line with the following one:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须始终在生产环境中关闭调试模式，因此，我们必须将上一行替换为以下一行：
- en: '[PRE69]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Test your knowledge
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: 'The `ScopedRateThrottle` class:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ScopedRateThrottle`类：'
- en: Limits the rate of requests that a specific user can make.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制特定用户可以发起的请求数量。
- en: Limits the rate of requests for specific parts of the API identified with the
    value assigned to the `throttle_scope` property.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制使用`throttle_scope`属性值标识的API特定部分的请求数量。
- en: Limits the rate of requests that an anonymous user can make.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制匿名用户可以发起的请求数量。
- en: 'The `UserRateThrottle` class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UserRateThrottle`类：'
- en: Limits the rate of requests that a specific user can make.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制特定用户可以发起的请求数量。
- en: Limits the rate of requests for specific parts of the API identified with the
    value assigned to the `throttle_scope` property.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制使用`throttle_scope`属性值标识的API特定部分的请求数量。
- en: Limits the rate of requests that an anonymous user can make.
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制匿名用户可以发起的请求数量。
- en: 'The `DjangoFilterBackend` class:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`DjangoFilterBackend`类：'
- en: Provides single query parameter based searching capabilities and it is based
    on the Django admin's search function.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供基于单个查询参数的搜索功能，并且基于Django管理员的搜索功能。
- en: Allows the client to control how the results are ordered with a single query
    parameter.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许客户端通过单个查询参数控制结果的排序方式。
- en: Provides field filtering capabilities.
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供字段过滤功能。
- en: 'The `SearchFilter` class:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`SearchFilter`类：'
- en: Provides single query parameter based searching capabilities and it is based
    on the Django admin's search function.
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供基于单个查询参数的搜索功能，并且基于Django管理员的搜索功能。
- en: Allows the client to control how the results are ordered with a single query
    parameter.
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许客户端通过单个查询参数控制结果的排序方式。
- en: Provides field filtering capabilities.
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供字段过滤功能。
- en: 'In a subclass of `APITestCase`, `self.client` is:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`APITestCase`的子类中，`self.client`是：
- en: The `APIClient` instance that allows us to easily compose and send HTTP requests
    for testing.
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`APIClient`实例允许我们轻松地组合和发送HTTP请求进行测试。'
- en: The `APITestClient` instance that allows us to easily compose and send HTTP
    requests for testing.
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许我们轻松组合和发送 HTTP 请求进行测试的 `APITestClient` 实例。
- en: The `APITestCase` instance that allows us to easily compose and send HTTP requests
    for testing.
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 允许我们轻松组合和发送 HTTP 请求进行测试的 `APITestCase` 实例。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took advantage of the features included in Django REST Framework
    to define throttling policies. We used filtering, searching, and ordering classes
    to make it easy to configure filters, search queries, and desired order for the
    results in HTTP requests. We used the browsable API feature to test these new
    features included in our API.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们利用 Django REST Framework 包含的功能来定义限流策略。我们使用了过滤、搜索和排序类，使得配置过滤器、搜索查询和结果排序变得容易。我们使用了可浏览的
    API 功能来测试我们 API 中包含的新特性。
- en: We wrote the first round of unit tests, measured test coverage, and then we
    wrote additional unit tests to improve test coverage. Finally, we understood many
    considerations for deployment and scalability.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了第一轮单元测试，测量了测试覆盖率，然后编写了额外的单元测试以提高测试覆盖率。最后，我们了解了关于部署和可扩展性的许多考虑因素。
- en: Now that we built a complex API with Django REST Framework and tested it, we
    will move to another popular Python web framework, Flask, which is what we are
    going to discuss in the next chapter.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经使用 Django REST Framework 构建了一个复杂的 API 并对其进行了测试，接下来我们将转向另一个流行的 Python 网络框架
    Flask，这是我们将在下一章中讨论的内容。
