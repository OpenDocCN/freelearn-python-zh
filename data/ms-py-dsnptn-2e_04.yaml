- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Structural Design Patterns
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构设计模式
- en: In the previous chapter, we covered creational patterns and object-oriented
    programming patterns that help us with object-creation procedures. The next category
    of pattern we want to present is *structural design patterns*. A structural design
    pattern proposes a way of composing objects to provide new functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了创建型模式和面向对象编程模式，这些模式帮助我们处理对象创建过程。接下来，我们想要介绍的模式类别是**结构设计模式**。结构设计模式提出了一种组合对象以提供新功能的方法。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: The adapter pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The decorator pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: The bridge pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 桥接模式
- en: The facade pattern
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 门面模式
- en: The flyweight pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 享元模式
- en: The proxy pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代理模式
- en: At the end of this chapter, you will be equipped with the skills to structure
    your code efficiently and elegantly using structural design patterns.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将掌握使用结构设计模式高效且优雅地构建代码的技能。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: See the requirements presented in [*Chapter 1*](B21896_01.xhtml#_idTextAnchor017).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](B21896_01.xhtml#_idTextAnchor017)中提出的需求。
- en: The adapter pattern
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配器模式
- en: The **adapter** pattern is a structural design pattern that helps us make two
    incompatible interfaces compatible. What does that really mean? If we have an
    old component and we want to use it in a new system, or a new component that we
    want to use in an old system, the two can rarely communicate without requiring
    any code changes. But changing the code is not always possible, either because
    we don’t have access to it, or because it is impractical. In such cases, we can
    write an extra layer that makes all the required modifications for enabling communication
    between the two interfaces. This layer is called an **adapter**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**适配器模式**是一种结构设计模式，它帮助我们使两个不兼容的接口变得兼容。这究竟意味着什么？如果我们有一个旧组件，我们想在新的系统中使用它，或者我们想在旧系统中使用的新组件，这两个组件在没有进行任何代码更改的情况下很少能够相互通信。但是，更改代码并不总是可能的，要么是因为我们没有访问权限，要么是因为这样做不切实际。在这种情况下，我们可以编写一个额外的层，它会对所有必要的修改进行操作，以使两个接口之间能够通信。这个层被称为**适配器**。'
- en: In general, if you want to use an interface that expects `function_a()`, but
    you only have `function_b()`, you can use an adapter to convert (adapt) `function_b()`
    to `function_a()`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你想要使用一个期望`function_a()`的接口，但你只有`function_b()`，你可以使用适配器将（适配）`function_b()`转换为`function_a()`。
- en: Real-world examples
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界案例
- en: 'When you are traveling from most European countries to the UK or the USA, or
    the other way around, you need to use a plug adapter for charging your laptop.
    The same kind of adapter is needed for connecting some devices to your computer:
    the USB adapter.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从大多数欧洲国家前往英国或美国，或者相反，你需要使用一个插头适配器来给你的笔记本电脑充电。连接某些设备到你的电脑也需要同种类型的适配器：USB适配器。
- en: In the software category, the `zope.interface` package ([https://pypi.org/project/zope.interface/](https://pypi.org/project/zope.interface/)),
    part of the **Zope Toolkit** (**ZTK**), provides tools that help define interfaces
    and perform interface adaptation. These tools are used in the core of several
    Python web framework projects (including Pyramid and Plone).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件类别中，`zope.interface`包（[https://pypi.org/project/zope.interface/](https://pypi.org/project/zope.interface/)），是**Zope工具包**（**ZTK**）的一部分，提供了帮助定义接口和执行接口适配的工具。这些工具被用于几个Python网络框架项目的核心（包括Pyramid和Plone）。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`zope.interface` was the solution for working with interfaces in Python, proposed
    by the team ([https://zope.dev/](https://zope.dev/)) behind the Zope application
    server and the ZTK before Python introduced built-in mechanisms, with **abstract
    base classes** (also called **ABCs**) first and protocols later.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`zope.interface`是Python中处理接口的解决方案，由Zope应用程序服务器和ZTK背后的团队提出，在Python引入内置机制之前，首先提出了**抽象基类**（也称为**ABCs**），后来又提出了协议。'
- en: Use cases for the adapter pattern
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式的使用案例
- en: Usually, one of the two incompatible interfaces is either foreign or old/legacy.
    If the interface is foreign, it means that we have no access to the source code.
    If it is old, it is usually impractical to refactor it.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，两个不兼容的接口中有一个是外来的，或者是旧的/遗留的。如果接口是外来的，这意味着我们没有访问源代码。如果是旧的，通常重构它是不切实际的。
- en: Using an adapter to make things work after they have been implemented is a good
    approach because it does not require access to the source code of the foreign
    interface. It is also often a pragmatic solution if we have to reuse some legacy
    code. That being said, be aware that it can introduce side effects that are hard
    to debug. So, use it with caution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现之后使用适配器使事物工作是一种好方法，因为它不需要访问外部接口的源代码。如果我们必须重用一些遗留代码，这通常也是一个实用的解决方案。但要注意，它可能会引入难以调试的副作用。因此，请谨慎使用。
- en: Implementing the adapter pattern – adapt a legacy class
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现适配器模式——适配遗留类
- en: Let’s consider an example where we have a legacy payment system and a new payment
    gateway. The adapter pattern can make them work together without changing the
    existing code, as we are going to see.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中我们有一个遗留的支付系统和一个新的支付网关。适配器模式可以使它们在不更改现有代码的情况下一起工作，正如我们将要看到的。
- en: 'The legacy payment system is implemented using a class, with a `make_payment()`
    method doing the core of the payment job, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留支付系统使用一个类实现，包含一个`make_payment()`方法，用于执行支付的核心工作，如下所示：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The new payment system is implemented using the following class, providing
    an `execute_payment()` method:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 新的支付系统使用以下类实现，提供了一个`execute_payment()`方法：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we are going to add a class that will provide the `make_payment()` method,
    where we call the `execute_payment()` method on the adaptee object to get the
    payment done. The code is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将添加一个类，它将提供`make_payment()`方法，在这个方法中，我们在适配对象上调用`execute_payment()`方法来完成支付。代码如下：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is how the `PaymentAdapter` class adapts the interface of `NewPaymentGateway`
    to match that of `OldPaymentSystem`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`PaymentAdapter`类如何适配`NewPaymentGateway`的接口以匹配`OldPaymentSystem`的接口。
- en: 'Let’s see the result of this adaptation by adding a `main()` function with
    testing code, as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加一个`main()`函数并包含测试代码来查看这种适配的结果，如下所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s recapitulate the complete code (see the `ch04``/adapter/adapt_legacy.py`
    file) of the implementation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现的全代码（见`ch04/adapter/adapt_legacy.py`文件）：
- en: We have some code for the legacy payment system, represented by the `OldPaymentSystem`
    class, providing a `make_payment()` method.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一些遗留支付系统的代码，由`OldPaymentSystem`类表示，它提供了一个`make_payment()`方法，用于执行支付的核心工作，如下所示：
- en: We introduce the new payment system, with the `NewPaymentGateway` class, providing
    an `execute_payment()` method.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们引入了新的支付系统，使用`NewPaymentGateway`类，它提供了一个`execute_payment()`方法。
- en: We add a class for the adapter, `PaymentAdapter`, which has an attribute to
    store the payment system object and a `make_payment()` method; in that method,
    we call the `execute_payment()` method on the payment system object (via `self.system.execute_payment(amount)`).
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个适配器类`PaymentAdapter`，它有一个属性用于存储支付系统对象，以及一个`make_payment()`方法；在该方法中，我们在支付系统对象上调用`execute_payment()`方法（通过`self.system.execute_payment(amount)`）。
- en: We add code for testing our interface adaptation design (and call it within
    the usual `if __name__ == "``__main__"` block).
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了测试我们接口适配设计的代码（并在常规的`if __name__ == "__main__"`块中调用它）。
- en: 'Executing the code, using `python ch04/adapter/adapt_legacy.py`, should give
    the following output:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 执行代码，使用`python ch04/adapter/adapt_legacy.py`，应该得到以下输出：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You now get the idea. This adaptation technique allows us to use the new payment
    gateway with existing code that expects the old interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在明白了。这种适配技术使我们能够使用新的支付网关，同时使用期望旧接口的现有代码。
- en: Implementing the adapter pattern – adapt several classes into a unified interface
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现适配器模式——将几个类适配到统一接口
- en: 'Let’s look at another application to illustrate adaptation: a club’s activities.
    Our club has two main activities:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个应用来展示适配的例子：一个俱乐部的活动。我们俱乐部有两个主要活动：
- en: Hire talented artists to perform in the club
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聘请有才华的艺术家在俱乐部表演
- en: Organize performances and events to entertain its clients
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织表演和活动以娱乐其客户
- en: 'At the core, we have a `Club` class that represents the club where hired artists
    perform some evenings. The `organize_performance()` method is the main action
    that the club can perform. The code is as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在核心，我们有一个`Club`类，它代表俱乐部，聘请的艺术家在某个晚上表演。`organize_performance()`方法是俱乐部可以执行的主要动作。代码如下：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Most of the time, our club hires a DJ to perform, but our application should
    make it possible to organize a diversity of performances: by a musician or music
    band, by a dancer, a one-man or one-woman show, and so on.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们的俱乐部聘请DJ表演，但我们的应用程序应该能够组织多样化的表演：由音乐家或音乐乐队、舞者、单人或双人表演等。
- en: 'Via our research to try and reuse existing code, we find an open source contributed
    library that brings us two interesting classes: `Musician` and `Dancer`. In the
    `Musician` class, the main action is performed by the `play()` method. In the
    `Dancer` class, it is performed by the `dance()` method.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的研究尝试重用现有代码，我们发现了一个开源贡献的库，它为我们带来了两个有趣的类：`Musician`和`Dancer`。在`Musician`类中，主要动作由`play()`方法执行。在`Dancer`类中，由`dance()`方法执行。
- en: 'In our example, to indicate that these two classes are external, we place them
    in a separate module (in the `ch04/adapter/external.py` file). The code includes
    two classes, `Musician` and `Dancer`, as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，为了表明这两个类是外部的，我们将它们放在一个单独的模块中（在`ch04/adapter/external.py`文件中）。代码包括两个类，`Musician`和`Dancer`，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The code we are writing, to use these two classes from the external library,
    only knows how to call the `organize_performance()` method (on the `Club` class);
    it has no idea about the `play()` or `dance()` methods (on the respective classes).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的代码，用于从外部库使用这两个类，只知道如何调用`organize_performance()`方法（在`Club`类上）；它对`play()`或`dance()`方法（在相应类上）一无所知。
- en: How can we make the code work without changing the `Musician` and `Dancer` classes?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在不修改`Musician`和`Dancer`类的情况下让代码工作？
- en: 'Adapters to the rescue! We create a generic `Adapter` class that allows us
    to adapt a number of objects with different interfaces into one unified interface.
    The `obj` argument of the `__init__()` method is the object that we want to adapt,
    and `adapted_methods` is a dictionary containing key/value pairs matching the
    method the client calls and the method that should be called. The code for that
    class is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器来拯救！我们创建了一个通用的`Adapter`类，它允许我们将具有不同接口的多个对象适配到一个统一的接口。`__init__()`方法的`obj`参数是我们想要适配的对象，`adapted_methods`是一个包含键/值对的字典，匹配客户端调用的方法和应该调用的方法。该类的代码如下：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When dealing with the instances of the different classes, we have two cases:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理不同类的实例时，我们有两种情况：
- en: The compatible object that belongs to the `Club` class needs no adaptation.
    We can treat it as is.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属于`Club`类的兼容对象不需要适配。我们可以将其视为原样。
- en: The incompatible objects need to be adapted first, using the `Adapter` class.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不兼容的对象需要首先使用`Adapter`类进行适配。
- en: 'The result is that the client code can continue using the known `organize_performance()`
    method on all objects without the need to be aware of any interface differences.
    Consider the following `main()` function code to prove that the design works as
    expected:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，客户端代码可以在所有对象上继续使用已知的`organize_performance()`方法，而无需意识到任何接口差异。考虑以下`main()`函数代码以证明设计按预期工作：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s recapitulate the complete code of our adapter pattern implementation
    (in the `ch04/adapter/adapt_to_unified_interface.py` file):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们适配器模式实现的完整代码（在`ch04/adapter/adapt_to_unified_interface.py`文件中）：
- en: We import the `Musician` and `Dancer` classes from the `external` module.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从`external`模块中导入`Musician`和`Dancer`类。
- en: We have the `Club` class.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有`Club`类。
- en: We define the `Adapter` class.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`Adapter`类。
- en: We add the `main()` function, which we call within the usual `if __name__ ==
    "``__main__"` block.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了`main()`函数，我们在通常的`if __name__ == "__main__"`块中调用它。
- en: 'Here is the output when executing the `python` `ch04/adapter/adapt_to_unified_interface.py`
    command:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`python ch04/adapter/adapt_to_unified_interface.py`命令时的输出如下：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we managed to make the `Musician` and `Dancer` classes compatible
    with the interface expected by the client code without changing the source code
    of these external classes.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们成功地使`Musician`和`Dancer`类与客户端代码期望的接口兼容，而没有改变这些外部类的源代码。
- en: The decorator pattern
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 装饰器模式
- en: A second interesting structural pattern to learn about is the **decorator**
    pattern, which allows a programmer to add responsibilities to an object dynamically,
    and in a transparent manner (without affecting other objects).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得学习的有趣结构模式是**装饰器**模式，它允许程序员以动态和透明的方式（不影响其他对象）向对象添加职责。
- en: There is another reason why this pattern is interesting to us, as you will see
    in a minute.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式对我们来说还有一个有趣的原因，你将在下一分钟看到。
- en: As Python developers, we can write decorators in a **Pythonic** way (meaning
    using the language’s features), thanks to the built-in decorator feature.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Python开发者，我们可以以**Pythonic**的方式（意味着使用语言的功能）编写装饰器，多亏了内置的装饰器功能。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A Python decorator is a callable (function, method, or class) that gets a `func_in`
    function object as input and returns another function object, `func_out`. It is
    a commonly used technique for extending the behavior of a function, method, or
    class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Python装饰器是一个可调用对象（函数、方法或类），它接收一个`func_in`函数对象作为输入，并返回另一个函数对象`func_out`。这是一种常用的技术，用于扩展函数、方法或类的行为。
- en: 'For more details on Python’s decorator feature, see the official documentation:
    [https://docs.python.org/3/reference/compound_stmts.html#function](https://docs.python.org/3/reference/compound_stmts.html#function)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Python装饰器功能的更多详细信息，请参阅官方文档：[https://docs.python.org/3/reference/compound_stmts.html#function](https://docs.python.org/3/reference/compound_stmts.html#function)
- en: But this feature should not be completely new to you. We have already encountered
    commonly used decorators in previous chapters (`@abstractmethod`, `@property`)
    and there are several other useful built-in decorators in Python. Now, we are
    going to learn how to implement and use our own decorators.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但这个特性不应该对你来说完全陌生。我们在前面的章节中已经遇到了常用的装饰器（`@abstractmethod`，`@property`），Python中还有几个其他有用的内置装饰器。现在，我们将学习如何实现和使用我们自己的装饰器。
- en: Note that there is no one-to-one relationship between the decorator pattern
    and Python’s decorator feature. Python decorators can actually do much more than
    the decorator pattern. One of the things they can be used for is to implement
    the decorator pattern.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，装饰器模式和Python的装饰器功能之间没有一对一的关系。Python装饰器实际上可以做很多装饰器模式做不到的事情。它们可以用作实现装饰器模式的事情之一。
- en: Real-world examples
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现实世界的例子
- en: The decorator pattern is generally used for extending the functionality of an
    object. In everyday life, examples of such extensions are adding a silencer to
    a gun, using different camera lenses, and so on.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式通常用于扩展对象的功能。在日常生活中，此类扩展的例子包括给枪支添加消声器、使用不同的相机镜头等。
- en: 'In web frameworks such as Django, which uses decorators a lot, we have decorators
    that can be used for the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在像Django这样的Web框架中，它大量使用装饰器，我们有以下用途的装饰器：
- en: Restricting access to views (or HTTP-request-handling functions) based on the
    request
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于请求限制对视图（或HTTP请求处理函数）的访问
- en: Controlling the caching behavior on specific views
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定视图中控制缓存行为
- en: Controlling compression on a per-view basis
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于视图的压缩控制
- en: Controlling caching based on specific HTTP request headers
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于特定HTTP请求头控制缓存
- en: Registering a function as an event subscriber
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数注册为事件订阅者
- en: Protecting a function with a specific permission
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用特定权限保护函数
- en: Use cases for the decorator pattern
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式的用例
- en: 'The decorator pattern shines when used for implementing cross-cutting concerns,
    such as the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当用于实现横切关注点时，装饰器模式特别有用，例如以下内容：
- en: Data validation
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据验证
- en: Caching
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存
- en: Logging
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录日志
- en: Monitoring
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控
- en: Debugging
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Business rules
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 业务规则
- en: Encryption
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加密
- en: In general, all parts of an application that are generic and can be applied
    to many other parts of it are considered to be cross-cutting concerns.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个应用程序中所有通用且可以应用于其许多其他部分的组成部分都被认为是横切关注点。
- en: Another popular example of using the decorator pattern is in **graphical user
    interface** (**GUI**) toolkits. In a GUI toolkit, we want to be able to add features
    such as borders, shadows, colors, and scrolling to individual components/widgets.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器模式的一个流行例子是在**图形用户界面**（**GUI**）工具包中。在GUI工具包中，我们希望能够向单个组件/小部件添加诸如边框、阴影、颜色和滚动等功能。
- en: Implementing the decorator pattern
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现装饰器模式
- en: Python decorators are generic and very powerful. In this section, we will see
    how we can implement a `number_sum()` function that returns the sum of the first
    *n* numbers. Note that this function is already available in the `math` module
    as `fsum()`, but let’s pretend it is not.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Python装饰器是通用的且非常强大。在本节中，我们将看到如何实现一个`number_sum()`函数，该函数返回前*n*个数字的总和。请注意，此函数已经在`math`模块中作为`fsum()`提供，但让我们假装它不存在。
- en: 'First, let’s look at the naive implementation (in the `ch04/decorator/number_sum_naive.py`
    file):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个简单的实现（在`ch04/decorator/number_sum_naive.py`文件中）：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'A sample execution of this example shows how slow this implementation is. On
    my computer, it takes more than *7* seconds to calculate the sum of the first
    50 numbers. We get the following output when executing the `python` `ch04/decorator/number_sum_naive.py`
    command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例的执行样本显示了这种实现的缓慢程度。在我的电脑上，计算前50个数字之和需要超过*7*秒。执行`python ch04/decorator/number_sum_naive.py`命令时，我们得到以下输出：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'sum_cache = {0: 0}'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 'sum_cache = {0: 0}'
- en: 'def number_sum(n):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'def number_sum(n):'
- en: 'if n in sum_cache:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n in sum_cache:'
- en: return sum_cache[n]
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: return sum_cache[n]
- en: res = n + number_sum(n - 1)
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: res = n + number_sum(n - 1)
- en: '# Add the value to the cache'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '# Add the value to the cache'
- en: sum_cache[n] = res
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: sum_cache[n] = res
- en: return res
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: return res
- en: 'if __name__ == "__main__":'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 'if __name__ == "__main__":'
- en: from timeit import Timer
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: from timeit import Timer
- en: t = Timer(
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: t = Timer(
- en: '"number_sum(300)",'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '"number_sum(300)",'
- en: '"from __main__ import number_sum",'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '"from __main__ import number_sum",'
- en: )
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'print("Time: ", t.timeit())'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 'print("Time: ", t.timeit())'
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Time:  0.1288748119986849
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Time:  0.1288748119986849
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'fib_cache = {0: 0, 1: 1}'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 'fib_cache = {0: 0, 1: 1}'
- en: 'def fibonacci(n):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fibonacci(n):'
- en: 'if n in fib_cache:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n in fib_cache:'
- en: return fib_cache[n]
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: return fib_cache[n]
- en: res = fibonacci(n - 1) + fibonacci(n - 2)
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: res = fibonacci(n - 1) + fibonacci(n - 2)
- en: fib_cache[n] = res
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: fib_cache[n] = res
- en: return res
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: return res
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: import functools
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: import functools
- en: 'def memoize(func):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'def memoize(func):'
- en: cache = {}
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: cache = {}
- en: '@functools.wraps(func)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '@functools.wraps(func)'
- en: 'def memoizer(*args):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 'def memoizer(*args):'
- en: 'if args not in cache:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 'if args not in cache:'
- en: cache[args] = func(*args)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: cache[args] = func(*args)
- en: return cache[args]
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: return cache[args]
- en: return memoizer
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: return memoizer
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '@memoize'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '@memoize'
- en: 'def number_sum(n):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 'def number_sum(n):'
- en: 'if n == 0:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n == 0:'
- en: return 0
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: return 0
- en: 'else:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return n + number_sum(n - 1)
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: return n + number_sum(n - 1)
- en: '@memoize'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '@memoize'
- en: 'def fibonacci(n):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fibonacci(n):'
- en: 'if n in (0, 1):'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 'if n in (0, 1):'
- en: return n
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: return n
- en: 'else:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 'else:'
- en: return fibonacci(n - 1) + fibonacci(n - 2)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: return fibonacci(n - 1) + fibonacci(n - 2)
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'def main():'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: from timeit import Timer
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: from timeit import Timer
- en: to_execute = [
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: to_execute = [
- en: (
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: number_sum,
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: number_sum,
- en: Timer(
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Timer(
- en: '"number_sum(300)",'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '"number_sum(300)",'
- en: '"from __main__ import number_sum",'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '"from __main__ import number_sum",'
- en: ),
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ),
- en: ),
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ),
- en: (
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: (
- en: fibonacci,
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: fibonacci,
- en: Timer(
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Timer(
- en: '"fibonacci(100)",'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '"fibonacci(100)",'
- en: '"from __main__ import fibonacci",'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '"from __main__ import fibonacci",'
- en: ),
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ),
- en: ),
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ),
- en: ']'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ']'
- en: 'for item in to_execute:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 'for item in to_execute:'
- en: func = item[0]
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: func = item[0]
- en: print(
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: 'f''Function "{func.__name__}": {func.__doc__}'''
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 'f''Function "{func.__name__}": {func.__doc__}'''
- en: )
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: t = item[1]
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: t = item[1]
- en: 'print(f"Time: {t.timeit()}")'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'print(f"Time: {t.timeit()}")'
- en: print()
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: print()
- en: '[PRE17]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Function "number_sum": Returns the sum of the first n numbers'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 'Function "number_sum": Returns the sum of the first n numbers'
- en: 'Time: 0.2148694'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 'Time: 0.2148694'
- en: 'Function "fibonacci": Returns the suite of Fibonacci numbers'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 'Function "fibonacci": Returns the suite of Fibonacci numbers'
- en: 'Time: 0.202763251'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'Time: 0.202763251'
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'class ResourceContentFetcher(Protocol):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 'class ResourceContentFetcher(Protocol):'
- en: 'def fetch(self, path: str) -> str:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fetch(self, path: str) -> str:'
- en: '...'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '...'
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'class ResourceContent:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 'class ResourceContent:'
- en: 'def __init__(self, imp: ResourceContentFetcher):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self, imp: ResourceContentFetcher):'
- en: self._imp = imp
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: self._imp = imp
- en: 'def get_content(self, path):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'def get_content(self, path):'
- en: return self._imp.fetch(path)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: return self._imp.fetch(path)
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'class URLFetcher:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 'class URLFetcher:'
- en: 'def fetch(self, path):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fetch(self, path):'
- en: res = ""
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: res = ""
- en: req = urllib.request.Request(path)
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: req = urllib.request.Request(path)
- en: with urllib.request.urlopen(
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: with urllib.request.urlopen(
- en: req
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: req
- en: ') as response:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ') as response:'
- en: 'if response.code == 200:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'if response.code == 200:'
- en: res = response.read()
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: res = response.read()
- en: return res
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: return res
- en: '[PRE21]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'class LocalFileFetcher:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 'class LocalFileFetcher:'
- en: 'def fetch(self, path):'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'def fetch(self, path):'
- en: 'with open(path) as f:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'with open(path) as f:'
- en: res = f.read()
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: res = f.read()
- en: return res
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: return res
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'def main():'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: url_fetcher = URLFetcher()
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: url_fetcher = URLFetcher()
- en: rc = ResourceContent(url_fetcher)
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: rc = ResourceContent(url_fetcher)
- en: res = rc.get_content("http://python.org")
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: res = rc.get_content("http://python.org")
- en: print(
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: f"Fetched content with {len(res)} characters"
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: f"Fetched content with {len(res)} characters"
- en: )
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: localfs_fetcher = LocalFileFetcher()
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: localfs_fetcher = LocalFileFetcher()
- en: rc = ResourceContent(localfs_fetcher)
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: rc = ResourceContent(localfs_fetcher)
- en: pathname = os.path.abspath(__file__)
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: pathname = os.path.abspath(__file__)
- en: dir_path = os.path.split(pathname)[0]
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: dir_path = os.path.split(pathname)[0]
- en: path = os.path.join(dir_path, "file.txt")
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: path = os.path.join(dir_path, "file.txt")
- en: res = rc.get_content(path)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: res = rc.get_content(path)
- en: print(
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: print(
- en: f"Fetched content with {len(res)} characters"
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: f"Fetched content with {len(res)} characters"
- en: )
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '[PRE23]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Fetched content with 51265 characters
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Fetched content with 51265 characters
- en: Fetched content with 1327 characters
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Fetched content with 1327 characters
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: State = Enum(
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: State = Enum(
- en: '"State",'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '"State",'
- en: '"NEW RUNNING SLEEPING RESTART ZOMBIE",'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '"NEW RUNNING SLEEPING RESTART ZOMBIE",'
- en: )
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '...'
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '...'
- en: 'class Server(ABC):'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Server(ABC):'
- en: '@abstractmethod'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '@abstractmethod'
- en: 'def __init__(self):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: pass
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: 'def __str__(self):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __str__(self):'
- en: return self.name
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: return self.name
- en: '@abstractmethod'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '@abstractmethod'
- en: 'def boot(self):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 'def boot(self):'
- en: pass
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '@abstractmethod'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '@abstractmethod'
- en: 'def kill(self, restart=True):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'def kill(self, restart=True):'
- en: pass
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: pass
- en: '[PRE25]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'class FileServer(Server):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 'class FileServer(Server):'
- en: 'def __init__(self):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.name = "FileServer"
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = "FileServer"
- en: self.state = State.NEW
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = State.NEW
- en: 'def boot(self):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 'def boot(self):'
- en: print(f"booting the {self}")
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"booting the {self}")
- en: self.state = State.RUNNING
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = State.RUNNING
- en: 'def kill(self, restart=True):'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 'def kill(self, restart=True):'
- en: print(f"Killing {self}")
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"Killing {self}")
- en: self.state = (
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = (
- en: State.RESTART if restart else State.ZOMBIE
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: State.RESTART if restart else State.ZOMBIE
- en: )
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'def create_file(self, user, name, perms):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_file(self, user, name, perms):'
- en: msg = (
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: msg = (
- en: f"trying to create file '{name}' "
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: f"尝试创建文件 '{name}' "
- en: f"for user '{user}' "
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: f"for user '{user}' "
- en: f"with permissions {perms}"
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: f"权限为 {perms}"
- en: )
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(msg)
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: print(msg)
- en: '[PRE26]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'class ProcessServer(Server):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 'class ProcessServer(Server):'
- en: 'def __init__(self):'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.name = "ProcessServer"
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: self.name = "ProcessServer"
- en: self.state = State.NEW
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = State.NEW
- en: 'def boot(self):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 'def boot(self):'
- en: print(f"booting the {self}")
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"启动 {self}")
- en: self.state = State.RUNNING
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = State.RUNNING
- en: 'def kill(self, restart=True):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 'def kill(self, restart=True):'
- en: print(f"Killing {self}")
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: print(f"杀死 {self}")
- en: self.state = (
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: self.state = (
- en: State.RESTART if restart else State.ZOMBIE
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: State.RESTART if restart else State.ZOMBIE
- en: )
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'def create_process(self, user, name):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_process(self, user, name):'
- en: msg = (
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: msg = (
- en: f"trying to create process '{name}' "
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: f"尝试创建进程 '{name}' "
- en: f"for user '{user}'"
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: f"for user '{user}'"
- en: )
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: print(msg)
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: print(msg)
- en: '[PRE27]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'class OperatingSystem:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 'class OperatingSystem:'
- en: '"""The Facade"""'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '"""门面模式”'
- en: 'def __init__(self):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: self.fs = FileServer()
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: self.fs = FileServer()
- en: self.ps = ProcessServer()
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: self.ps = ProcessServer()
- en: 'def start(self):'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 'def start(self):'
- en: '[i.boot() for i in (self.fs, self.ps)]'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[i.boot() for i in (self.fs, self.ps)]'
- en: 'def create_file(self, user, name, perms):'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_file(self, user, name, perms):'
- en: return self.fs.create_file(user, name, perms)
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: return self.fs.create_file(user, name, perms)
- en: 'def create_process(self, user, name):'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 'def create_process(self, user, name):'
- en: return self.ps.create_process(user, name)
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: return self.ps.create_process(user, name)
- en: '[PRE28]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'def main():'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 'def main():'
- en: os = OperatingSystem()
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: os = OperatingSystem()
- en: os.start()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: os.start()
- en: os.create_file("foo", "hello.txt", "-rw-r-r")
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: os.create_file("foo", "hello.txt", "-rw-r-r")
- en: os.create_process("bar", "ls /tmp")
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: os.create_process("bar", "ls /tmp")
- en: '[PRE29]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: booting the FileServer
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 启动文件服务器
- en: booting the ProcessServer
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 ProcessServer
- en: trying to create file 'hello.txt' for user 'foo' with permissions -rw-r-r
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试为用户 'foo' 创建文件 'hello.txt'，权限为 -rw-r-r
- en: OperatingSystem class does a good job. The client code can create files and
    processes without needing to know internal details about the operating system,
    such as the existence of multiple servers. To be precise, the client code can
    call the methods for creating files and processes, but they are currently dummy.
    As an interesting exercise, you can implement one of the two methods, or even
    both.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统类做得很好。客户端代码可以创建文件和进程，而无需了解操作系统内部细节，例如多个服务器的存在。更准确地说，客户端代码可以调用创建文件和进程的方法，但它们目前是虚拟的。作为一个有趣的练习，你可以实现这两种方法中的一种，甚至两种都可以。
- en: The flyweight pattern
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轻量级模式
- en: Whenever we create a new object, extra memory needs to be allocated. Although
    virtual memory provides us, theoretically, with unlimited memory, the reality
    is different. If all the physical memory of a system gets exhausted, it will start
    swapping pages with the secondary storage, usually a **hard disk drive** (**HDD**),
    which, in most cases, is unacceptable due to the performance differences between
    the main memory and HDD. **Solid-state drives** (**SSDs**) generally have better
    performance than HDDs, but not everybody is expected to use SSDs. So, SSDs are
    not going to totally replace HDDs anytime soon.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当我们创建一个新的对象时，都需要额外分配内存。虽然虚拟内存从理论上为我们提供了无限的内存，但现实情况并非如此。如果一个系统的所有物理内存都用完了，它将开始与辅助存储（通常是**硬盘驱动器**（**HDD**））交换页面，由于主内存和HDD之间的性能差异，这在大多数情况下是不可接受的。**固态驱动器**（**SSD**）通常比HDD有更好的性能，但并不是每个人都期望使用SSD。因此，SSD不太可能在不久的将来完全取代HDD。
- en: Apart from memory usage, performance is also a consideration. Graphics software,
    including computer games, should be able to render 3-D information (for example,
    a forest with thousands of trees, a village full of soldiers, or an urban area
    with a lot of cars) extremely quickly. If each object in a 3-D terrain is created
    individually and no data sharing is used, the performance will be prohibitive.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了内存使用外，性能也是一个考虑因素。图形软件，包括计算机游戏，应该能够非常快速地渲染3-D信息（例如，有成千上万树木的森林，满是士兵的村庄，或者有很多汽车的城区）。如果3-D地形中的每个对象都是单独创建的，并且没有使用数据共享，性能将会非常低。
- en: As software engineers, we should solve software problems by writing better software,
    instead of forcing the customer to buy extra or better hardware. The **flyweight**
    design pattern is a technique used to minimize memory usage and improve performance
    by introducing data sharing between similar objects. A flyweight is a shared object
    that contains state-independent, immutable (also known as **intrinsic**) data.
    The state-dependent, mutable (also known as **extrinsic**) data should not be
    part of flyweight because this is information that cannot be shared, since it
    differs per object. If flyweight needs extrinsic data, it should be provided explicitly
    by the client code.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为软件工程师，我们应该通过编写更好的软件来解决软件问题，而不是强迫客户购买额外的或更好的硬件。**轻量级**设计模式是一种技术，通过在相似对象之间引入数据共享来最小化内存使用并提高性能。轻量级对象是一个包含状态无关、不可变（也称为**内在**）数据的共享对象。状态相关、可变（也称为**外在**）数据不应成为轻量级对象的一部分，因为这是无法共享的信息，因为它在每个对象中都是不同的。如果轻量级对象需要外在数据，它应该由客户端代码显式提供。
- en: An example might help to clarify how the flyweight pattern can be used practically.
    Let’s assume that we are creating a performance-critical game – for example, a
    **first-person shooter** (**FPS**). In FPS games, the players (soldiers) share
    some states, such as representation and behavior. In *Counter-Strike*, for instance,
    all soldiers on the same team (counter-terrorists versus terrorists) look the
    same (representation). In the same game, all soldiers (on both teams) have some
    common actions, such as jump, duck, and so forth (behavior). This means that we
    can create a flyweight that will contain all of the common data. Of course, the
    soldiers also have a lot of data that is different per soldier and will not be
    a part of the flyweight, such as weapons, health, location, and so on.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是一个例子，可以帮助阐明如何实际使用轻量级模式。假设我们正在创建一个性能关键的游戏——例如，一个**第一人称射击游戏**（**FPS**）。在FPS游戏中，玩家（士兵）共享一些状态，例如表示和行为。例如，在《反恐精英》中，同一队的所有士兵（反恐分子与恐怖分子）看起来都一样（表示）。在同一个游戏中，所有士兵（两队）都有一些共同的动作，如跳跃、蹲下等（行为）。这意味着我们可以创建一个包含所有共同数据的轻量级对象。当然，士兵们也有许多不同的数据，这些数据对于每个士兵来说都是独特的，并且不会成为轻量级对象的一部分，例如武器、健康、位置等。
- en: Real-world examples
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现实世界中的例子
- en: Flyweight is an optimization design pattern; therefore, it is not easy to find
    a good non-computing example of it. We can think of flyweight as caching in real
    life. For example, many bookstores have dedicated shelves with the newest and
    most popular publications. This is a cache. First, you can take a look at the
    dedicated shelves for the book you are looking for, and if you cannot find it,
    you can ask the bookseller to assist you.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轻量级模式是一种优化设计模式；因此，在非计算领域中很难找到一个好的例子。我们可以将轻量级模式视为现实生活中的缓存。例如，许多书店都有专门的书架，用于存放最新和最受欢迎的出版物。这是一个缓存。首先，你可以查看你正在寻找的书的专门书架，如果你找不到，你可以请书店老板帮忙。
- en: The Exaile music player uses flyweight to reuse objects (in this case, music
    tracks) that are identified by the same URL. There’s no point in creating a new
    object if it has the same URL as an existing object, so the same object is reused
    to save resources.
  id: totrans-319
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Exaile音乐播放器使用轻量级模式来重用对象（在这种情况下，是音乐曲目），这些对象通过相同的URL进行标识。如果对象与现有对象具有相同的URL，就没有必要创建新的对象，因此可以重用相同的对象以节省资源。
- en: Use cases for the flyweight pattern
  id: totrans-320
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轻量级模式的使用场景
- en: Flyweight is all about improving performance and memory usage. All embedded
    systems (phones, tablets, games consoles, microcontrollers, and so forth) and
    performance-critical applications (games, 3-D graphics processing, real-time systems,
    and so forth) can benefit from it.
  id: totrans-321
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 轻量级模式（Flyweight）主要关注性能和内存使用的提升。所有嵌入式系统（如手机、平板电脑、游戏机、微控制器等）以及性能关键的应用程序（如游戏、3-D图形处理、实时系统等）都可以从中受益。
- en: 'The *Gang of Four* (*GoF*) book lists the following requirements that need
    to be satisfied to effectively use the flyweight pattern:'
  id: totrans-322
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 《设计模式：可复用面向对象软件的基础》（*Gang of Four*，*GoF*）一书中列出了以下需要满足的要求，才能有效地使用轻量级模式：
- en: The application needs to use a large number of objects.
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序需要使用大量的对象。
- en: There are so many objects that it’s too expensive to store/render them. Once
    the mutable state is removed (because if it is required, it should be passed explicitly
    to flyweight by the client code), many groups of distinct objects can be replaced
    by relatively few shared objects.
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有如此多的对象，存储/渲染它们会非常昂贵。一旦移除了可变状态（因为如果需要，应该由客户端代码显式传递给轻量级对象），许多不同的对象组可以被相对较少的共享对象所替代。
- en: Object identity is not important for the application. We cannot rely on object
    identity because object sharing causes identity comparisons to fail (objects that
    appear different to the client code end up having the same identity).
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象标识对于应用来说并不重要。我们不能依赖于对象标识，因为对象共享会导致标识比较失败（对客户端代码看起来不同的对象最终会有相同的标识）。
- en: Implementing the flyweight pattern
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现享元模式
- en: Let’s see how we can implement an example featuring cars in an area. We will
    create a small car park to illustrate the idea, making sure that the whole output
    is readable in a single terminal page. However, no matter how large you make the
    car park, the memory allocation stays the same.
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现一个包含区域的汽车示例。我们将创建一个小型停车场来展示这个想法，确保整个输出在单个终端页面上可读。然而，无论停车场有多大，内存分配保持不变。
- en: Memoization versus the flyweight pattern
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存与享元模式的比较
- en: Memoization is an optimization technique that uses a cache to avoid recomputing
    results that were already computed in an earlier execution step. Memoization does
    not focus on a specific programming paradigm such as **object-oriented programming**
    (**OOP**). In Python, memoization can be applied to both class methods and simple
    functions.
  id: totrans-329
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缓存是一种优化技术，它使用缓存来避免重新计算在早期执行步骤中已经计算过的结果。缓存并不专注于特定的编程范式，如**面向对象编程**（**OOP**）。在Python中，缓存可以应用于类方法和简单函数。
- en: Flyweight is an OOP-specific optimization design pattern that focuses on sharing
    object data.
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 享元是一种特定于面向对象编程的优化设计模式，它专注于共享对象数据。
- en: Let’s get started with the code for this example.
  id: totrans-331
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们开始编写这个示例的代码。
- en: 'First, we need an `Enum` parameter that describes the three different types
    of car that are in the car park:'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们需要一个`Enum`参数来描述停车场中存在的三种不同类型的汽车：
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we will define the class at the core of our implementation: `Car`. The
    `pool` variable is the object pool (in other words, our cache). Notice that `pool`
    is a class attribute (a variable shared by all instances).'
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们将定义我们实现的核心类：`Car`。`pool`变量是对象池（换句话说，我们的缓存）。请注意，`pool`是一个类属性（一个所有实例共享的变量）。
- en: 'Using the `__new__()` special method, which is called before `__init__()`,
    we are converting the `Car` class to a metaclass that supports self-references.
    This means that `cls` references the `Car` class. When the client code creates
    an instance of `Car`, they pass the type of the car as `car_type`. The type of
    the car is used to check whether a car of the same type has already been created.
    If that’s the case, the previously created object is returned; otherwise, the
    new car type is added to the pool and returned:'
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用在`__init__()`之前被调用的特殊方法`__new__()`，我们将`Car`类转换为一个支持自引用的元类。这意味着`cls`引用了`Car`类。当客户端代码创建`Car`实例时，它们会传递汽车的类型作为`car_type`。汽车的类型用于检查是否已经创建了相同类型的汽车。如果是这样，则返回先前创建的对象；否则，将新的汽车类型添加到池中并返回：
- en: '[PRE31]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `render()` method is what will be used to render a car on the screen. Notice
    how all the mutable information not known by flyweight needs to be explicitly
    passed by the client code. In this case, random `color` and the coordinates of
    a location (of form `x`, `y`) are used for each car.
  id: totrans-337
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`render()`方法将用于在屏幕上渲染汽车。注意，所有未知于享元的信息都需要客户端代码显式传递。在这种情况下，每个汽车使用随机的`color`和位置的坐标（形式为`x`，`y`）。'
- en: Also, note that to make `render()` more useful, it is necessary to ensure that
    no cars are rendered on top of each other. Consider this as an exercise. If you
    want to make rendering more fun, you can use a graphics toolkit such as Tkinter,
    Pygame, or Kivy.
  id: totrans-338
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意，为了使`render()`更有用，必须确保没有汽车渲染在彼此之上。把这当作一个练习。如果你想使渲染更有趣，可以使用图形工具包，如Tkinter、Pygame或Kivy。
- en: 'The `render()` method is defined as follows:'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`render()`方法定义如下：'
- en: '[PRE32]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `main()` function shows how we can use the flyweight pattern. The color
    of a car is a random value from a predefined list of colors. The coordinates use
    random values between 1 and 100\. Although 18 cars are rendered, memory is allocated
    only for 3\. The last line of the output proves that when using flyweight, we
    cannot rely on object identity. The `id()` function returns the memory address
    of an object. This is not the default behavior in Python because, by default,
    `id()` returns a unique ID (actually the memory address of an object as an integer)
    for each object. In our case, even if two objects appear to be different, they
    actually have the same identity if they belong to the same `car_type`). Of course,
    different identity comparisons can still be used for objects of different families,
    but that is possible only if the client knows the implementation details.
  id: totrans-341
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main()`函数展示了如何使用轻量级模式。汽车的颜色是从预定义颜色列表中随机选择的值。坐标使用1到100之间的随机值。尽管渲染了18辆车，但只分配了3个内存。输出中的最后一行证明，在使用轻量级模式时，我们不能依赖于对象身份。`id()`函数返回对象的内存地址。这不是Python的默认行为，因为默认情况下，`id()`为每个对象返回一个唯一的ID（实际上是对象的内存地址的整数）。在我们的情况下，即使两个对象看起来不同，如果它们属于同一个`car_type`，它们实际上具有相同的身份。当然，仍然可以使用不同的身份比较来比较不同家族的对象，但这只有在客户端知道实现细节的情况下才可能。'
- en: 'Our example `main()` function’s code is as follows:'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的示例`main()`函数的代码如下：
- en: '[PRE33]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the recapitulation of the full code listing (the `ch04/flyweight.py`
    file) to show you how the flyweight pattern is implemented and used:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下面是完整代码列表（`ch04/flyweight.py`文件）的回顾，以展示如何实现和使用轻量级模式：
- en: 'We need a couple of imports: `random` and `Enum` (from the `enum` module).'
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入几个模块：`random`和`Enum`（来自`enum`模块）。
- en: We define `Enum` for the types of cars.
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为汽车类型定义了`Enum`。
- en: Then we have the `Car` class, with its `pool` attribute and the `__new__()`
    and `render()` methods.
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们有`Car`类，它具有`pool`属性以及`__new__()`和`render()`方法。
- en: In the first part of the `main` function, we define some variables and render
    a set of subcompact cars.
  id: totrans-348
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`函数的第一部分，我们定义了一些变量并渲染了一组小型车。
- en: The second part of the `main` function.
  id: totrans-349
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`函数的第二部分。'
- en: The third part of the `main` function.
  id: totrans-350
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`main`函数的第三部分。'
- en: Finally, we add the fourth part of the `main` function.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加`main`函数的第四部分。
- en: 'The execution of the `python ch04/flyweight.py` command shows the type, random
    color, and coordinates of the rendered objects, as well as the identity comparison
    results between flyweight objects of the same/different families:'
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 执行`python ch04/flyweight.py`命令的输出显示了渲染对象的类型、随机颜色和坐标，以及相同/不同家族的轻量级对象之间的身份比较结果：
- en: '[PRE34]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Do not expect to see the same output since the colors and coordinates are random,
    and the object identities depend on the memory map.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于颜色和坐标是随机的，并且对象身份取决于内存映射，因此不要期望看到相同的输出。
- en: The proxy pattern
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代理模式
- en: 'The **proxy** design pattern gets its name from the *proxy* (also known as
    **surrogate**) object used to perform an important action before accessing the
    actual object. There are four well-known types of proxy. They are as follows:'
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**代理**设计模式的名称来源于用于在访问实际对象之前执行重要操作的**代理**对象（也称为**代表**）。有四种著名的代理类型。具体如下：'
- en: A **virtual proxy**, which uses **lazy initialization** to defer the creation
    of a computationally expensive object until the moment it is actually needed.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**虚拟代理**，它使用**延迟初始化**来推迟在真正需要时创建计算密集型对象。
- en: A **protection/protective proxy**, which controls access to a sensitive object.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**保护/防护代理**，用于控制对敏感对象的访问。
- en: A **remote proxy**, which acts as the local representation of an object that
    really exists in a different address space (for example, a network server).
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**远程代理**，作为实际存在于不同地址空间中的对象的本地表示（例如，网络服务器）。
- en: A **smart (reference) proxy**, which performs extra actions when an object is
    accessed. Examples of such actions are reference counting and thread-safety checks.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个**智能（引用）代理**，在访问对象时执行额外操作。此类操作的例子包括引用计数和线程安全检查。
- en: Real-world examples
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现实世界例子
- en: '**Chip** cards offer a good example of how a protective proxy is used in real
    life. The debit/credit card contains a chip that first needs to be read by the
    ATM or card reader. After the chip is verified, a password (PIN) is required to
    complete the transaction. This means that you cannot make any transactions without
    physically presenting the card and knowing the PIN.'
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**芯片**卡是保护代理在现实生活中应用的一个好例子。借记/信用卡包含一个芯片，首先需要由ATM或读卡器读取。芯片验证后，需要输入密码（PIN）才能完成交易。这意味着，如果没有物理出示卡片并知道PIN，就无法进行任何交易。'
- en: A bank check that is used instead of cash to make purchases and deals is an
    example of a remote proxy. The check gives access to a bank account.
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用现金购买和交易的银行支票是远程代理的一个例子。支票可以访问银行账户。
- en: In software, the `weakref` module of Python contains a `proxy()` method that
    accepts an input object and returns a smart proxy to it. Weak references are the
    recommended way to add reference-counting support to an object.
  id: totrans-364
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在软件中，Python的`weakref`模块包含一个`proxy()`方法，它接受一个输入对象并返回一个智能代理。弱引用是向对象添加引用计数支持的推荐方式。
- en: Use cases for the proxy pattern
  id: totrans-365
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代理模式的用例
- en: Since there are at least four common proxy types, the proxy design pattern has
    many use cases.
  id: totrans-366
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于至少有四种常见的代理类型，因此代理设计模式有许多用例。
- en: This pattern is used when creating a distributed system using either a private
    network or the cloud. In a distributed system, some objects exist in the local
    memory and some objects exist in the memory of remote computers. If we don’t want
    the client code to be aware of such differences, we can create a remote proxy
    that hides/encapsulates them, making the distributed nature of the application
    transparent.
  id: totrans-367
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当使用私有网络或云来创建分布式系统时，这种模式被使用。在分布式系统中，一些对象存在于本地内存中，而一些对象存在于远程计算机的内存中。如果我们不希望客户端代码意识到这些差异，我们可以创建一个远程代理来隐藏/封装它们，使应用程序的分布式特性变得透明。
- en: The proxy pattern is also handy when our application is suffering from performance
    issues due to the early creation of expensive objects. Introducing lazy initialization
    using a virtual proxy to create the objects only when they are required can give
    us significant performance improvements.
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们的应用程序由于昂贵对象的早期创建而遭受性能问题时，代理模式也很有用。通过使用虚拟代理进行延迟初始化，只在需要时创建对象，可以给我们带来显著的性能提升。
- en: As a third case, this pattern is used to check whether a user has sufficient
    privileges to access a piece of information. If our application handles sensitive
    information (for example, medical data), we want to ensure that the user trying
    to access/modify it can do so. A protection/protective proxy can handle all security-related
    actions.
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为第三个案例，这种模式用于检查用户是否有足够的权限访问某些信息。如果我们的应用程序处理敏感信息（例如，医疗数据），我们希望确保尝试访问/修改它的用户能够这样做。保护/防护代理可以处理所有与安全相关的操作。
- en: This pattern is used when our application (or library, toolkit, framework, and
    so forth) uses multiple threads and we want to move the burden of thread safety
    from the client code to the application. In this case, we can create a smart proxy
    to hide the thread-safety complexities from the client.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种模式适用于我们的应用程序（或库、工具包、框架等）使用多个线程，并且我们希望将线程安全的问题从客户端代码转移到应用程序上。在这种情况下，我们可以创建一个智能代理来隐藏线程安全的复杂性，不让客户端知道。
- en: An **object-relational mapping** (**ORM**) API is also an example of how to
    use a remote proxy. Many popular web frameworks (Django, Flask, FastAPI...) use
    an ORM to provide OOP-like access to a relational database. An ORM acts as a proxy
    to a relational database that can be located anywhere, either at a local or remote
    server.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**对象关系映射**（ORM）API也是如何使用远程代理的一个例子。许多流行的Web框架（Django、Flask、FastAPI...）使用ORM来提供面向对象的数据库访问。ORM充当一个代理，可以位于任何地方，无论是本地服务器还是远程服务器。'
- en: Implementing the proxy pattern – a virtual proxy
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现代理模式——虚拟代理
- en: There are many ways to create a virtual proxy in Python, but I always like focusing
    on the idiomatic/Pythonic implementations. The code shown here is based on the
    great answer by Cyclone, a user of the [stackoverflow.com](http://stackoverflow.com)
    site, to the question about "Python memoising/deferred lookup property decorator."
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Python中创建虚拟代理有许多方法，但我总是喜欢关注惯用/Pythonic的实现。这里展示的代码基于[stackoverflow.com](http://stackoverflow.com)网站的用户Cyclone给出的一个关于“Python
    memoising/deferred lookup property decorator”问题的优秀答案。
- en: Note
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, the terms *property*, *variable*, and *attribute* are used
    interchangeably.
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本节中，术语*属性*、*变量*和*属性*可以互换使用。
- en: 'First, we create a `LazyProperty` class that can be used as a decorator. When
    it decorates a property, `LazyProperty` loads the property lazily (on the first
    use) instead of instantly. The `__init__()` method creates two variables that
    are used as aliases to the method that initializes a property: `method` is an
    alias to the actual method, and `method_name` is an alias to the method’s name.
    To get a better understanding of how the two aliases are used, print their value
    to the output (uncomment the two commented lines in that part of the code):'
  id: totrans-376
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个`LazyProperty`类，它可以作为装饰器使用。当它装饰一个属性时，`LazyProperty`会在第一次使用时延迟加载该属性，而不是立即加载。`__init__()`方法创建了两个变量，用作初始化属性的方法的别名：`method`是实际方法的别名，`method_name`是方法名的别名。为了更好地理解这两个别名是如何使用的，将它们的值打印到输出中（取消注释代码中该部分的两个注释行）：
- en: '[PRE35]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `LazyProperty` class is actually a descriptor. Descriptors are the recommended
    mechanisms to use in Python to override the default behavior of its attribute
    access methods: `__get__()`, `__set__()`, and `__delete__()`. The `LazyProperty`
    class overrides only `__set__()` because that is the only access method it needs
    to override. In other words, we don’t have to override all access methods. The
    `__get__()` method accesses the value of the property the underlying method wants
    to assign, and uses `setattr()` to do the assignment manually. What `__get()__`
    actually does is very neat: it replaces the method with the value! This means
    that not only is the property lazily loaded, but it can also be set only once.
    We will see what this means in a moment.'
  id: totrans-378
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`LazyProperty`类实际上是一个描述符。描述符是在Python中用来覆盖其属性访问方法（`__get__()`、`__set__()`和`__delete__()`）默认行为的推荐机制。`LazyProperty`类仅覆盖`__set__()`，因为这是它需要覆盖的唯一访问方法。换句话说，我们不需要覆盖所有访问方法。`__get__()`方法访问底层方法想要分配的属性值，并使用`setattr()`手动进行分配。`__get()__`实际上执行的操作非常巧妙：它用值替换了方法！这意味着属性不仅被延迟加载，而且只能设置一次。我们稍后会看到这意味着什么。'
- en: '[PRE36]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Again, uncomment the commented line in that part of the code to get some extra
    information.
  id: totrans-380
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，取消注释代码中该部分的注释行以获取一些额外信息。
- en: 'Then, the `Test` class shows how we can use the `LazyProperty` class. There
    are three attributes: `x`, `y`, and `_resource`. We want the `_resource` variable
    to be loaded lazily; thus, we initialize it to `None` as shown in the following
    code:'
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，`Test`类展示了我们如何使用`LazyProperty`类。有三个属性：`x`、`y`和`_resource`。我们希望`_resource`变量能够延迟加载；因此，我们将其初始化为`None`，如下所示：
- en: '[PRE37]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `resource()` method is decorated with the `LazyProperty` class. For demonstration
    purposes, the `LazyProperty` class initializes the `_resource` attribute as a
    tuple, as shown in the following code. Normally, this would be a slow/expensive
    initialization (database, graphics, and so on):'
  id: totrans-383
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`resource()`方法被`LazyProperty`类装饰。为了演示目的，`LazyProperty`类将`_resource`属性初始化为一个元组，如下所示。通常，这会是一个缓慢/昂贵的初始化（数据库、图形等）。'
- en: '[PRE38]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `main()` function, as follows, shows how lazy initialization behaves:'
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如下所示的`main()`函数展示了延迟初始化的行为：
- en: '[PRE39]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Notice how overriding the `__get()__` access method makes it possible to treat
    the `resource()` method as a simple attribute (we can use `t.resource` instead
    of `t.resource()`).
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，覆盖`__get()__`访问方法使得将`resource()`方法视为一个简单属性成为可能（我们可以使用`t.resource`而不是`t.resource()`）。
- en: 'Let’s recapitulate the example code (in `ch04/proxy/proxy_lazy.py`):'
  id: totrans-388
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下示例代码（在`ch04/proxy/proxy_lazy.py`中）：
- en: We define the `LazyProperty` class.
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了`LazyProperty`类。
- en: We define the `Test` class with a `resource()` method that we decorate using
    `LazyProperty`.
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了带有`resource()`方法的`Test`类，并使用`LazyProperty`对其进行装饰。
- en: We add the main function for testing our design example.
  id: totrans-391
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了主函数来测试我们的设计示例。
- en: 'If you can execute the example in its original version (where the added lines
    for better understanding are kept commented), using the `python ch04/proxy/proxy_lazy.py`
    command, you will get the following output:'
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你能够执行示例的原始版本（其中为了更好地理解而添加的行被注释），使用`python ch04/proxy/proxy_lazy.py`命令，你将得到以下输出：
- en: '[PRE40]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Based on this output, we can see the following:'
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据这个输出，我们可以看到以下内容：
- en: The `_resource` variable is indeed initialized not by the time the `t` instance
    is created, but the first time that we use `t.resource`.
  id: totrans-395
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`_resource`变量确实是在我们使用`t.resource`时初始化的，而不是在`t`实例创建时。'
- en: The second time `t.resource` is used, the variable is not initialized again.
    That’s why the initialization string initializing `self._resource` is shown only
    once.
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次使用 `t.resource` 时，变量不再重新初始化。这就是为什么初始化字符串只初始化 `self._resource` 一次的原因。
- en: Additional information
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其他信息
- en: 'There are two basic kinds of lazy initialization in OOP. They are as follows:'
  id: totrans-398
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，存在两种基本的懒加载初始化方式。具体如下：
- en: '- **At the instance level**: This means that an object’s property is initialized
    lazily, but the property has an object scope. Each instance (object) of the same
    class has its own (different) copy of the property.'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **在实例级别**：这意味着对象的属性是懒加载初始化的，但属性具有对象作用域。同一类的每个实例（对象）都有自己的（不同的）属性副本。'
- en: '- **At the class or module level**: In this case, we do not want a different
    copy per instance, but all the instances share the same property, which is lazily
    initialized. This case is not covered in this chapter. If you find it interesting,
    consider it as an exercise.'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- **在类或模块级别**：在这种情况下，我们不希望每个实例有不同的副本，而是所有实例共享相同的属性，该属性是懒加载初始化的。这种情况在本章中没有涉及。如果你对此感兴趣，可以考虑将其作为练习。'
- en: Since there are so many possible cases for using the proxy pattern, let’s see
    another example.
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于使用代理模式的可能性有很多，让我们看看另一个例子。
- en: Implementing the proxy pattern – a protection proxy
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现代理模式 – 保护代理
- en: 'As a second example, let’s implement a simple protection proxy to view and
    add users. The service provides two options:'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为第二个例子，让我们实现一个简单的保护代理来查看和添加用户。服务提供了两种选项：
- en: '**Viewing the list of users**: This operation does not require special privileges'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查看用户列表**：此操作不需要特殊权限'
- en: '**Adding a new user**: This operation requires the client to provide a special
    secret message'
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加新用户**：此操作要求客户端提供特殊秘密消息'
- en: 'The `SensitiveInfo` class contains the information that we want to protect.
    The `users` variable is the list of existing users. The `read()` method prints
    the list of the users. The `add()` method adds a new user to the list. The code
    for that class is as follows:'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SensitiveInfo` 类包含我们想要保护的信息。`users` 变量是现有用户列表。`read()` 方法打印用户列表。`add()` 方法将新用户添加到列表中。该类的代码如下：'
- en: '[PRE41]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `Info` class is a protection proxy of `SensitiveInfo`. The secret variable
    is the message required to be known/provided by the client code to add a new user.
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Info` 类是 `SensitiveInfo` 的保护代理。秘密变量是客户端代码添加新用户所需知道/提供的消息。'
- en: 'Note that this is just an example. In reality, you should never do the following:'
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，这只是一个例子。在现实中，你永远不应该做以下事情：
- en: Store passwords in the source code
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源代码中存储密码
- en: Store passwords in clear-text form
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以明文形式存储密码
- en: Use a weak (for example, MD5) or custom form of encryption
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用弱（例如，MD5）或自定义形式的加密
- en: 'In the `Info` class, as we can see next, the `read()` method is a wrapper to
    `SensitiveInfo.read()` and the `add()` method ensures that a new user can be added
    only if the client code knows the secret message:'
  id: totrans-413
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `Info` 类中，如我们接下来看到的，`read()` 方法是对 `SensitiveInfo.read()` 的包装，而 `add()` 方法确保只有当客户端代码知道秘密消息时，才能添加新用户：
- en: '[PRE42]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `main()` function shows how the proxy pattern can be used by the client
    code. The client code creates an instance of the `Info` class and uses the displayed
    menu to read the list, add a new user, or exit the application. Let’s consider
    the following code:'
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`main()` 函数展示了客户端代码如何使用代理模式。客户端代码创建 `Info` 类的实例，并使用显示的菜单读取列表、添加新用户或退出应用程序。让我们考虑以下代码：'
- en: '[PRE43]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s recapitulate the full code (`ch04/proxy/proxy_protection.py`):'
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下完整的代码（`ch04/proxy/proxy_protection.py`）：
- en: First, we define the `SensitiveInfo` class.
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义 `SensitiveInfo` 类。
- en: Then, we have the code for the `Info` class.
  id: totrans-419
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们有 `Info` 类的代码。
- en: Finally, we add the main function with our testing code.
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加主函数以及我们的测试代码。
- en: 'We can see in the following a sample output of the program when executing the
    `python` `ch04/proxy/proxy_protection.py` command:'
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以在以下示例中看到程序执行 `python ch04/proxy/proxy_protection.py` 命令时的输出样本：
- en: '[PRE44]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Have you already spotted flaws or missing features that can be addressed to
    improve our protection proxy example? Here are a few suggestions:'
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你已经发现了可以解决以改进我们的保护代理示例的缺陷或缺失功能吗？以下是一些建议：
- en: This example has a very big security flaw. Nothing prevents the client code
    from bypassing the security of the application by creating an instance of `SensitiveInfo`
    directly. Improve the example to prevent this situation. One way is to use the
    `abc` module to forbid direct instantiation of `SensitiveInfo`. What other code
    changes are required in this case?
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个示例有一个非常大的安全漏洞。没有任何东西阻止客户端代码通过直接创建`SensitiveInfo`的实例来绕过应用程序的安全。改进这个示例以防止这种情况。一种方法是通过使用`abc`模块禁止直接实例化`SensitiveInfo`。在这种情况下还需要进行哪些代码更改？
- en: A basic security rule is that we should never store clear-text passwords. Storing
    a password safely is not very hard as long as we know which libraries to use.
    If you have an interest in security, try to implement a secure way to store the
    secret message externally (for example, in a file or database).
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个基本的安全规则是，我们永远不应该存储明文密码。只要我们知道使用哪些库，安全地存储密码并不难。如果你对安全感兴趣，尝试实现一种安全的方式来外部存储秘密消息（例如，在文件或数据库中）。
- en: The application only supports adding new users, but what about removing an existing
    user? Add a `remove()` method.
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序仅支持添加新用户，但关于删除现有用户怎么办？添加一个`remove()`方法。
- en: Implementing the proxy pattern – a remote proxy
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现代理模式 – 远程代理
- en: Imagine we are building a file management system where clients can perform operations
    on files stored on a remote server. The operations might include reading a file,
    writing to a file, and deleting a file. The remote proxy hides the complexity
    of network requests from the client.
  id: totrans-428
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想象我们正在构建一个文件管理系统，客户端可以在远程服务器上执行文件操作。这些操作可能包括读取文件、写入文件和删除文件。远程代理隐藏了网络请求的复杂性，对客户端来说。
- en: We start by creating an interface that defines the operations that can be performed
    on the remote server, `RemoteServiceInterface`, and the class that implements
    it to provide the actual service, `RemoteService`.
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先创建一个接口，定义可以在远程服务器上执行的操作，`RemoteServiceInterface`，以及实现该接口的类`RemoteService`以提供实际服务。
- en: 'The interface is defined as follows:'
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口定义如下：
- en: '[PRE45]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The `RemoteService` class is defined as follows (the methods just return a
    string, for the sake of simplicity, but normally, you would have specific code
    for the file handling on the remote service):'
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`RemoteService`类定义如下（为了简单起见，方法仅返回一个字符串，但通常，你会在远程服务上进行特定的文件处理代码）：'
- en: '[PRE46]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we define `ProxyService` for the proxy. It implements the `RemoteServiceInterface`
    interface and acts as a surrogate for `RemoteService`, which handles communication
    with the latter:'
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们为代理定义了`ProxyService`。它实现了`RemoteServiceInterface`接口，并作为`RemoteService`的代理，处理与后者的通信：
- en: '[PRE47]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Clients interact with the `ProxyService` component as if it were the `RemoteService`
    one, unaware of the remote nature of the actual service. The proxy handles the
    communication with the remote service, potentially adding logging, access control,
    or caching. To test things, we can add the following code, based on creating an
    instance of `ProxyService`:'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户端与`ProxyService`组件交互，就像它是`RemoteService`一样，并不知道实际服务的远程性质。代理处理与远程服务的通信，可能包括添加日志、访问控制或缓存。为了测试，我们可以添加以下代码，基于创建`ProxyService`的实例：
- en: '[PRE48]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s recapitulate the implementation (the full code is in `ch04/proxy/proxy_remote.py`):'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现过程（完整代码位于`ch04/proxy/proxy_remote.py`）：
- en: We start by defining the interface, `RemoteServiceInterface`, and a class that
    implements it, `RemoteService`.
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义接口，`RemoteServiceInterface`，以及一个实现该接口的类，`RemoteService`。
- en: Then, we define the `ProxyService` class, which also implements the `RemoteService``Interface`
    interface.
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了`ProxyService`类，它也实现了`RemoteService`接口。
- en: Finally, we add some code for testing the proxy object.
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一些代码来测试代理对象。
- en: 'Let’s see the result of the example by running `python ch04/proxy/proxy_remote.py`:'
  id: totrans-442
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过运行`python ch04/proxy/proxy_remote.py`，让我们看看示例的结果：
- en: '[PRE49]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: It worked. This lightweight example was effective in showing how to implement
    the remote proxy use case.
  id: totrans-444
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这成功了。这个轻量级的示例有效地展示了如何实现远程代理用例。
- en: Implementing the proxy pattern – a smart proxy
  id: totrans-445
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实现代理模式 – 智能代理
- en: Let’s consider a scenario where you have a shared resource in your application,
    such as a database connection. Every time an object accesses this resource, you
    want to keep track of how many references to the resource exist. Once there are
    no more references, the resource can be safely released or closed. A smart proxy
    will help manage the reference counting for this database connection, ensuring
    it’s only closed once all references to it are released.
  id: totrans-446
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，在你的应用程序中有一个共享资源，例如数据库连接。每次对象访问这个资源时，你都想跟踪资源引用的数量。一旦没有更多引用，资源就可以安全地释放或关闭。智能代理将帮助管理这个数据库连接的引用计数，确保它只在所有引用释放后关闭。
- en: As in the previous example, we will need an interface, `DBConnectionInterface`,
    defining operations for accessing the database, and a class that represents the
    actual database connection, `DBConnection`.
  id: totrans-447
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们需要一个定义访问数据库操作的接口，`DBConnectionInterface`，以及一个代表实际数据库连接的类，`DBConnection`。
- en: 'For the interface, let’s use `Protocol` (to change from the `ABC` way):'
  id: totrans-448
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于接口，我们使用`Protocol`（从`ABC`方式更改）：
- en: '[PRE50]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The class for the database connection is as follows:'
  id: totrans-450
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据库连接的类如下：
- en: '[PRE51]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Then, we define the `SmartProxy` class; it also implements the `DBConnectionInterface`
    interface (see the `exec_query()` method). We use this class to manage reference
    counting and access to the `DBConnection` object. It ensures that the `DBConnection`
    object is created on demand when the first query is executed and is only closed
    when there are no more references to it. The code is as follows:'
  id: totrans-452
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们定义了`SmartProxy`类；它也实现了`DBConnectionInterface`接口（请参阅`exec_query()`方法）。我们使用这个类来管理引用计数和`DBConnection`对象的访问。它确保在首次执行查询时按需创建`DBConnection`对象，并且只有当没有更多引用时才关闭。代码如下：
- en: '[PRE52]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, we can add some code to test the implementation:'
  id: totrans-454
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以添加一些代码来测试实现：
- en: '[PRE53]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s recapitulate the implementation (the full code is in `ch04/proxy/proxy_smart.py`):'
  id: totrans-456
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们回顾一下实现（完整代码在`ch04/proxy/proxy_smart.py`中）：
- en: We start by defining the interface, `DBConnectionInterface`, and a class that
    implements it and represents the database connection, `DBConnection`.
  id: totrans-457
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义接口，`DBConnectionInterface`，以及一个实现它的类，代表数据库连接，`DBConnection`。
- en: Then, we define the `SmartProxy` class, which also implements `DBConnectionInterface`.
  id: totrans-458
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了`SmartProxy`类，它也实现了`DBConnectionInterface`。
- en: Finally, we add some code for testing the proxy object.
  id: totrans-459
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们添加一些代码来测试代理对象。
- en: 'Let’s see the result of the example by running `python ch04/proxy/proxy_smart.py`:'
  id: totrans-460
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们通过运行`python ch04/proxy/proxy_smart.py`来查看示例的结果：
- en: '[PRE54]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This was another demonstration of the proxy pattern. Here, it helped us implement
    an improved solution for scenarios where database connections are shared across
    different parts of an application and need to be managed carefully to avoid exhausting
    database resources or leaking connections.
  id: totrans-462
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是对代理模式的一次另类演示。在这里，它帮助我们实现了一种改进的解决方案，适用于数据库连接在不同应用程序部分之间共享且需要谨慎管理以避免耗尽数据库资源或泄露连接的场景。
- en: Summary
  id: totrans-463
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 摘要
- en: Structural patterns are invaluable for creating clean, maintainable, and scalable
    code. They provide solutions for many of the challenges you’ll face in daily coding.
  id: totrans-464
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结构模式对于创建干净、可维护和可扩展的代码至关重要。它们为你在日常编码中遇到的许多挑战提供了解决方案。
- en: First, the adapter pattern serves as a flexible solution for harmonizing mismatched
    interfaces. We can use this pattern to bridge the gap between outdated legacy
    systems and modern interfaces, thus promoting more cohesive and manageable software
    systems.
  id: totrans-465
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 首先，适配器模式作为一种灵活的解决方案，用于协调不匹配的接口。我们可以使用这种模式来弥合过时遗留系统与现代接口之间的差距，从而促进更加紧密和易于管理的软件系统。
- en: Then, we discussed the decorator pattern that we use as a convenient way of
    extending the behavior of an object without using inheritance. Python, with its
    built-in decorator feature, extends the decorator concept even more by allowing
    us to extend the behavior of any callable without using inheritance or composition.
    The decorator pattern is a great solution for implementing cross-cutting concerns
    because they are generic and do not fit well into the OOP paradigm. We mentioned
    several categories of cross-cutting concerns in the *Use cases for the decorator
    pattern* section. We saw how decorators can help us to keep our functions clean
    without sacrificing performance.
  id: totrans-466
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们讨论了装饰器模式，这是一种方便地扩展对象行为而不使用继承的方法。Python通过其内置的装饰器功能，甚至进一步扩展了装饰器概念，允许我们扩展任何可调用的行为而不使用继承或组合。装饰器模式是实现横切关注点的绝佳解决方案，因为它们是通用的，并且不适合OOP范式。我们在“装饰器模式的使用案例”部分提到了几个横切关注点的类别。我们看到了装饰器如何帮助我们保持函数的整洁，同时不牺牲性能。
- en: Sharing similarities with the adapter pattern, the bridge pattern is different
    from it in the sense that it is used up-front to define an abstraction and its
    implementation in a decoupled way so that both can vary independently. The bridge
    pattern is useful when writing software for problem domains such as operation
    systems and device drivers, GUIs, and website builders where we have multiple
    themes and we need to change the theme of a website based on certain properties.
    We discussed an example in the domain of content extraction and management, where
    we defined an interface for the abstraction, an interface for the implementor,
    and two implementations.
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与适配器模式相似，桥接模式在定义抽象及其实现时有所不同，它是在一开始就以一种解耦的方式定义抽象和实现，以便两者可以独立变化。桥接模式在编写操作系统和设备驱动程序、GUI和网站构建器等问题的软件时非常有用，在这些领域中我们有多套主题，并且需要根据某些属性更改网站的主题。我们在内容提取和管理领域讨论了一个例子，其中我们定义了一个抽象的接口、一个实现者的接口和两个实现。
- en: The facade pattern is ideal for providing a simple interface to client code
    that wants to use a complex system but does not need to be aware of the system’s
    complexity. A computer is a facade, since all we need to do to use it is press
    a single button to turn it on. All the rest of the hardware complexity is handled
    transparently by the BIOS, the boot loader, and the other components of the system
    software. There are more real-life examples of facade, such as when we are connected
    to the customer service department of a bank or a company, and the keys that we
    use to turn a vehicle on. We covered an implementation of the interface used by
    a multi-server operating system.
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 外观模式非常适合为希望使用复杂系统但不需要了解系统复杂性的客户端代码提供一个简单的接口。计算机就是一个外观，因为我们只需要按下一个按钮就可以打开它。所有其他硬件复杂性都由BIOS、引导加载程序和系统软件的其他组件透明地处理。还有更多现实生活中的外观例子，比如当我们连接到银行或公司的客户服务部门时，以及我们用来启动车辆的钥匙。我们介绍了一个多服务器操作系统使用的接口实现。
- en: In general, we use the flyweight pattern when an application needs to create
    a large number of computationally expensive objects that share many properties.
    The important point is to separate the immutable (shared) properties from the
    mutable ones. We saw how to implement a car renderer that supports three different
    car families. By providing the mutable color and x, y properties explicitly to
    the `render()` method, we managed to create only 3 different objects instead of
    18\. Although that might not seem like a big win, imagine if the cars were 2,000
    instead of 18.
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常，当应用程序需要创建大量计算成本高昂的对象，而这些对象共享许多属性时，我们会使用享元模式。关键点是区分不可变（共享）属性和可变属性。我们看到了如何实现一个支持三个不同汽车家族的汽车渲染器。通过显式地将可变的颜色和x、y属性提供给`render()`方法，我们只创建了3个不同的对象，而不是18个。虽然这可能看起来不是很大的胜利，但想象一下如果汽车有2,000辆而不是18辆会怎样。
- en: 'We ended with the proxy pattern. We discussed several use cases of the proxy
    pattern, including performance, security, and how to offer simple APIs to users.
    We saw an implementation example for each of the four types of proxy you generally
    need: virtual proxy, protective proxy, proxy to a remote service, and smart proxy.'
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们以代理模式结束。我们讨论了代理模式的几个用例，包括性能、安全性和如何向用户提供简单的API。我们为通常需要的四种代理类型中的每一种都看到了实现示例：虚拟代理、保护代理、远程服务代理和智能代理。
- en: In the next chapter, we will explore behavioral design patterns, patterns that
    deal with object interconnection and algorithms.
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨行为设计模式，这些模式涉及对象交互和算法。
- en: '[PRE55]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
