- en: Chapter 5
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: 'Data Acquisition Features: SQL Database'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取功能：SQL 数据库
- en: In this chapter, you will be guided through two projects that demonstrate how
    to work with SQL databases as a source of data for analysis. This will build on
    the foundational application built in the previous two chapters.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将指导完成两个项目，展示如何将 SQL 数据库作为分析数据源进行操作。这将建立在前面两章中构建的基础应用之上。
- en: This chapter will focus on SQL extracts. Since enterprise SQL databases tend
    to be very private, we’ll guide the reader through creating an SQLite database
    first. This database will be a stand-in for a private enterprise database. Once
    there’s a database available, we will look at extracting data from the database.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍 SQL 提取。由于企业 SQL 数据库通常非常私密，我们将指导读者首先创建一个 SQLite 数据库。这个数据库将作为私有企业数据库的替代品。一旦有了数据库，我们将研究如何从数据库中提取数据。
- en: 'This chapter’s projects cover the following essential skills:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目涵盖了以下基本技能：
- en: Building SQL databases.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 SQL 数据库。
- en: Extracting data from SQL databases.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 SQL 数据库中提取数据。
- en: The first project will build a SQL database for use by the second project.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个项目将为第二个项目构建一个 SQL 数据库。
- en: In an enterprise environment, the source databases will already exist.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业环境中，源数据库已经存在。
- en: On our own personal computers, these databases don’t exist. For this reason,
    we’ll build a database in the first project, and extract from the database in
    the second project.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们自己的个人电脑上，这些数据库并不存在。因此，我们将在第一个项目中构建一个数据库，并在第二个项目中从数据库中提取数据。
- en: We’ll start by looking at getting data into a SQL database. This will be a very
    small and simple database; the project will steer clear of the numerous sophisticated
    design complications for SQL data.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看如何将数据放入 SQL 数据库。这将是一个非常小且简单的数据库；项目将避免 SQL 数据的众多复杂设计问题。
- en: The second project will use SQL queries to extract data from the database. The
    objective is to produce data that is consistent with the projects in the previous
    chapters.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个项目将使用 SQL 查询从数据库中提取数据。目标是生成与上一章项目一致的数据。
- en: '5.1 Project 1.4: A local SQL database'
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 项目 1.4：本地 SQL 数据库
- en: We’ll often need data stored in a database that’s accessed via the SQL query
    language. Use a search string like “SQL is the lingua franca” to find numerous
    articles offering more insight into the ubiquity of SQL. This seems to be one
    of the primary ways to acquire enterprise data for further analysis.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要存储在数据库中的数据，这些数据通过 SQL 查询语言访问。使用搜索字符串“SQL 是通用语言”来找到提供更多关于 SQL 通用性的文章。这似乎是获取企业数据以进行进一步分析的主要方法之一。
- en: 'In the previous chapter, [*Chapter** 4*](ch008.xhtml#x1-780004), [*Data Acquisition
    Features: Web APIs and* *Scraping*](ch008.xhtml#x1-780004), the projects acquired
    data from publicly available APIs and web pages. There aren’t many publicly available
    SQL data sources. In many cases, there are dumps (or exports) of SQLite databases
    that can be used to build a local copy of the database. Direct access to a remote
    SQL database is not widely available. Rather than try to find access to a remote
    SQL database, it’s simpler to create a local SQL database. The SQLite database
    is provided with Python as part of the standard library, making it an easy choice.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章[*第四章*](ch008.xhtml#x1-780004)，[*数据获取功能：Web API 和爬取*](ch008.xhtml#x1-780004)中，项目从公开可用的
    API 和网页中获取数据。公开可用的 SQL 数据源并不多。在许多情况下，可以使用 SQLite 数据库的转储（或导出）来构建数据库的本地副本。直接访问远程
    SQL 数据库并不常见。与其试图找到访问远程 SQL 数据库的方法，不如创建一个本地 SQL 数据库简单。SQLite 数据库作为 Python 标准库的一部分提供，使其成为容易选择。
- en: You may want to examine other databases and compare their features with SQLite.
    While some databases offer numerous capabilities, doing SQL extracts rarely seems
    to rely on anything more sophisticated than a basic `SELECT` statement. Using
    another database may require some changes to reflect that database’s connections
    and SQL statement execution. For the most part, the DB-API interface in Python
    is widely used; there may be unique features for databases other than SQLite.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想检查其他数据库，并将它们的特性与 SQLite 进行比较。虽然一些数据库提供了许多功能，但进行 SQL 提取很少似乎需要比基本的 `SELECT`
    语句更复杂的东西。使用另一个数据库可能需要一些更改，以反映该数据库的连接和 SQL 语句执行。在大多数情况下，Python 中的 DB-API 接口被广泛使用；对于
    SQLite 之外的数据库，可能有一些独特功能。
- en: We’ll start with a project to populate the database. Once a database is available,
    you can then move on to a more interesting project to extract the data using SQL
    statements.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从填充数据库的项目开始。一旦数据库可用，你就可以继续进行更有趣的项目，使用SQL语句提取数据。
- en: 5.1.1 Description
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 描述
- en: The first project for this chapter will prepare a SQL database with data to
    analyze. This is a necessary preparation step for readers working outside an enterprise
    environment with accessible SQL databases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一个项目将为分析准备一个包含数据的SQL数据库。这是读者在具有可访问SQL数据库的企业环境外工作的必要准备步骤。
- en: One of the most fun small data sets to work with is Anscombe’s Quartet.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的小数据集之一就是安斯康姆四重奏。
- en: '[https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet](https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet](https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet)'
- en: The URL given above presents a page with information about the CSV format file.
    Clicking the **Download** button will download the small file of data to your
    local computer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的URL提供了一个包含CSV格式文件信息的页面。点击**下载**按钮将数据小文件下载到您的本地计算机。
- en: The data is available in this book’s GitHub repository’s `data` folder, also.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数据也存放在本书GitHub仓库的`data`文件夹中。
- en: In order to load a database, the first step is designing the database. We’ll
    start with a look at some table definitions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加载数据库，第一步是设计数据库。我们将从查看一些表定义开始。
- en: Database design
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据库设计
- en: A SQL database is organized as tables of data. Each table has a fixed set of
    columns, defined as part of the overall database schema. A table can have an indefinite
    number of rows of data.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SQL数据库以数据表的形式组织。每个表都有一个固定的列集，这些列作为整体数据库模式的一部分进行定义。一个表可以有无限数量的数据行。
- en: For more information on SQL databases, see [https://www.packtpub.com/product/learn-sql-database-programming/9781838984762](https://www.packtpub.com/product/learn-sql-database-programming/9781838984762)
    and [https://courses.packtpub.com/courses/sql](https://courses.packtpub.com/courses/sql).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SQL数据库的更多信息，请参阅[https://www.packtpub.com/product/learn-sql-database-programming/9781838984762](https://www.packtpub.com/product/learn-sql-database-programming/9781838984762)和[https://courses.packtpub.com/courses/sql](https://courses.packtpub.com/courses/sql)。
- en: Anscombe’s Quartet consists of four series of (*x,y*) pairs. In one commonly
    used source file, three of the series share common *x* values, whereas the fourth
    series has distinct *x* values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 安斯康姆四重奏由四组(*x,y*)对组成。在一个常用的源文件中，三个系列共享共同的*x*值，而第四个系列具有不同的*x*值。
- en: 'A relational database often decomposes complicated entities into a collection
    of simpler entities. The objective is to minimize the repetitions of association
    types. The Anscombe’s Quartet information has four distinct series of data values,
    which can be represented as the following two types of entities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库通常将复杂的实体分解为一系列更简单的实体。目标是最大限度地减少关联类型的重复。安斯康姆四重奏信息有四个不同的数据值系列，可以表示为以下两种类型的实体：
- en: The series is composed of a number of individual values. A table named `series_value`
    can store the individual values that are part of a series.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系列由多个单独的值组成。一个名为`series_value`的表可以存储属于系列的单个值。
- en: A separate entity has identifying information for the series as a whole. A table
    named `sources` can store identifying information.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单独的实体为整个系列提供标识信息。一个名为`sources`的表可以存储标识信息。
- en: This design requires the introduction of key values to uniquely identify the
    series, and connect each value of a series with the summary information for the
    series.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计需要引入关键值来唯一标识系列，并将每个系列的值与系列的总结信息连接起来。
- en: For Anscombe’s Quartet data, the summary information for a series is little
    more than a name.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安斯康姆四重奏数据，一个系列的总结信息仅略多于一个名称。
- en: This design pattern of an overall summary and supporting details is so common
    that it is essential for this project to reflect that common pattern.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种整体总结和支持细节的设计模式如此常见，对于本项目来说，反映这种常见模式是至关重要的。
- en: See [*Figure 5.1*](#5.1) for an ERD that shows the two tables that implement
    these entities and their relationships.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 见[*图5.1*](#5.1)以查看显示实现这些实体及其关系的ERD。
- en: '![Figure 5.1: The Database Schema ](img/file24.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：数据库模式](img/file24.jpg)'
- en: 'Figure 5.1: The Database Schema'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：数据库模式
- en: This project will create a small application to build this schema of two tables.
    This application will can then load data into these tables.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目将创建一个小应用程序来构建这两个表的架构。然后，该应用程序可以加载数据到这些表中。
- en: Data loading
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据加载
- en: 'The process of loading data involves three separate operations:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 加载数据的过程涉及三个独立的操作：
- en: Reading the source data from a CSV (or other format) file.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 CSV（或其他格式）文件中读取源数据。
- en: Executing SQL `INSERT` statements to create rows in tables.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 SQL `INSERT` 语句以在表中创建行。
- en: Executing a `COMMIT` to finalize the transaction and write data to the underlying
    database files.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 `COMMIT` 以最终化事务并将数据写入底层数据库文件。
- en: Prior to any of these steps, the schema must be defined using `CREATE`` TABLE`
    statements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤之前，必须使用 `CREATE TABLE` 语句定义模式。
- en: In a practical application, it’s also common to offer a composite operation
    to drop the tables, recreate the schema, and then load the data. The rebuilding
    often happens when exploring or experimenting with database designs. Many times,
    an initial design will prove unsatisfactory, and changes are needed. Additionally,
    the idea of building (and rebuilding) a small database will also be part of the
    acceptance test for any data acquisition application.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，也常见提供组合操作以删除表、重新创建模式，然后加载数据。重建通常发生在探索或实验数据库设计时。很多时候，最初的设计可能无法令人满意，需要做出改变。此外，构建（和重建）小型数据库的想法也将是任何数据采集应用程序验收测试的一部分。
- en: In the next section, we’ll look at how to create a SQL database that can serve
    as a surrogate for a production database in a large enterprise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何创建一个 SQL 数据库，它可以作为大型企业生产数据库的替代品。
- en: 5.1.2 Approach
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 方法
- en: 'There are two general approaches to working with SQL databases for this kind
    of test or demonstration application:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类测试或演示应用程序，处理 SQL 数据库有两种一般方法：
- en: Create a small application to build and populate a database.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个小应用程序来构建和填充数据库。
- en: Create a SQL script via text formatting and run this through the database’s
    CLI application. See [https://sqlite.org/cli.html](https://sqlite.org/cli.html).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过文本格式创建一个 SQL 脚本，并通过数据库的 CLI 应用程序运行它。请参阅 [https://sqlite.org/cli.html](https://sqlite.org/cli.html)。
- en: The small application will make use of the database client connection to execute
    SQL statements. In this case, a single, generic `INSERT` statement template with
    placeholders can be used. The client connection can provide values for the placeholders.
    While the application isn’t complex, it will require unit and acceptance test
    cases.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 该小应用程序将利用数据库客户端连接来执行 SQL 语句。在这种情况下，可以使用一个具有占位符的单个通用 `INSERT` 语句模板。客户端连接可以提供占位符的值。虽然应用程序并不复杂，但它将需要单元和验收测试用例。
- en: 'The SQL script alternative uses a small application to transform data rows
    into valid `INSERT` statements. In many cases, a text editor search-and-replace
    can transform data text into `INSERT` statements. For more complex cases, Python
    f-strings can be used. The f-string might look like the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 脚本替代方案使用一个小应用程序将数据行转换为有效的 `INSERT` 语句。在许多情况下，文本编辑器的搜索和替换功能可以将数据文本转换为 `INSERT`
    语句。对于更复杂的情况，可以使用 Python f-strings。f-string 可能看起来像以下这样：
- en: '[PRE0]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is often successful but suffers from a potentially severe problem: a *SQL*
    *injection exploit*.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常很成功，但存在一个潜在的严重问题：*SQL* 注入攻击。
- en: The SQL injection exploit works by including an end-of-string-literal apostrophe
    `’` in a data value. This can lead to an invalid SQL statement. In extreme cases,
    it can allow injecting additional SQL statements to transform the `INSERT` statement
    into a script. For more information, see [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection).
    Also, see [https://xkcd.com/327/](https://xkcd.com/327/) for another example of
    a SQL injection exploit.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 注入攻击通过在数据值中包含一个字符串字面量结尾的单引号 `’` 来工作。这可能导致无效的 SQL 语句。在极端情况下，它允许注入额外的 SQL
    语句，将 `INSERT` 语句转换为脚本。更多信息，请参阅 [https://owasp.org/www-community/attacks/SQL_Injection](https://owasp.org/www-community/attacks/SQL_Injection)。还可以参阅
    [https://xkcd.com/327/](https://xkcd.com/327/) 以了解 SQL 注入攻击的另一个示例。
- en: While SQL injection can be used maliciously, it can also be a distressingly
    common accident. If a text data value happens to have `’` in it, then this can
    create a statement in the SQL script file that has invalid syntax. SQL cleansing
    only defers the problem to the potentially complicated SQL cleansing function.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQL 注入可能被恶意使用，但它也可能是一个令人沮丧的常见事故。如果文本数据值中恰好有 `’`，那么这可能会在 SQL 脚本文件中创建一个具有无效语法的语句。SQL
    清洗只是将问题推迟到可能复杂的 SQL 清洗函数。
- en: It’s simpler to avoid building SQL text in the first place. A small application
    can be free from the complications of building SQL text.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先避免构建 SQL 文本会更简单。一个小型应用程序可以摆脱构建 SQL 文本的复杂性。
- en: We’ll start by looking at the data definition for this small schema. Then we’ll
    look at the data manipulation statements. This will set the stage for designing
    the small application to build the schema and load the data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看这个小模式的数据定义。然后我们将查看数据操作语句。这将为设计构建模式和加载数据的小型应用程序奠定基础。
- en: SQL Data Definitions
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL 数据定义
- en: 'The essential data definition in SQL is a table with a number of columns (also
    called *attributes*). This is defined by a `CREATE`` TABLE` statement. The list
    of columns is provided in this statement. In addition to the columns, the language
    permits table constraints to further refine how a table may be used. For our purposes,
    the two tables can be defined as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 中的基本数据定义是一个具有多个列（也称为 *属性*）的表。这是通过一个 `CREATE TABLE` 语句定义的。列的列表由该语句提供。除了列之外，该语言还允许表约束进一步细化表的使用方式。就我们的目的而言，两个表可以定义为如下：
- en: '-'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '-'
- en: '[PRE1]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: To remove a schema, the `DROP`` TABLE`` IF`` EXISTS`` series_sample` and `DROP`` TABLE`
    `IF`` EXISTS`` series` statements will do what’s needed. Because of the foreign
    key reference, some databases make it necessary to remove all of the related `series_sample`
    rows before a `series` row can be removed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除模式，使用 `DROP TABLE IF EXISTS series_sample` 和 `DROP TABLE IF EXISTS series`
    语句即可完成所需操作。由于外键引用，某些数据库在删除 `series` 行之前，需要先删除所有相关的 `series_sample` 行。
- en: The `IF`` EXISTS` and `IF`` NOT`` EXISTS` clauses are handy when debugging.
    We may, for example, change the SQL and introduce a syntax error into one of the
    `CREATE`` TABLE` statements. This can leave an incomplete schema. After fixing
    the problem, simply rerunning the entire sequence of `CREATE`` TABLE` statements
    will create only the tables that were missing.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，`IF EXISTS` 和 `IF NOT EXISTS` 子句非常有用。例如，我们可能会更改 SQL 并在某个 `CREATE TABLE`
    语句中引入语法错误。这可能会导致一个不完整的模式。在解决问题后，只需重新运行整个 `CREATE TABLE` 语句序列，就会只创建缺失的表。
- en: An essential feature of this example SQL data model is a simplification of the
    data types involved. Two columns of data in the `series_sample` table are both
    defined as `TEXT`. This is a rarity; most SQL databases will use one of the available
    numeric types.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本例 SQL 数据模型的一个基本特征是简化了涉及的数据类型。`series_sample` 表中的两列数据都被定义为 `TEXT`。这是一个罕见的情况；大多数
    SQL 数据库都会使用可用的某种数值类型。
- en: While SQL data has a variety of useful types, the raw data from other applications,
    however, isn’t numeric. CSV files and HTML pages only provide text. For this reason,
    the results from this application need to be text, also. Once the tables are defined,
    an application can insert rows.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQL 数据有多种有用的类型，但来自其他应用程序的原始数据却不是数值型的。CSV 文件和 HTML 页面只提供文本。因此，这个应用程序的结果也需要是文本的。一旦定义了表，应用程序就可以插入行。
- en: SQL Data Manipulations
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL 数据操作
- en: 'New rows are created with the `INSERT` statement. While SQLite allows some
    details to be omitted, we’ll stick with a slightly wordier but more explicit statement.
    Rows are created in the two tables as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `INSERT` 语句创建新行。虽然 SQLite 允许省略一些细节，但我们将坚持使用稍微冗长但更明确的语句。以下是在两个表中创建行的方式：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The identifiers with a colon prefix, `:x`, `:y`, `:series_id`, etc., are parameters
    that will be replaced when the statement is executed. Since these replacements
    don’t rely on SQL text rules — like the use of apostrophes to end a string — any
    value can be used.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀为冒号的标识符，如 `:x`、`:y`、`:series_id` 等，是将在执行语句时被替换的参数。由于这些替换不依赖于 SQL 文本规则——例如使用引号来结束字符串——可以使用任何值。
- en: It’s rare to need to delete rows from these tables. It’s easier (and sometimes
    faster) to drop and recreate the tables when replacing the data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些表中删除行的情况很少见。在替换数据时，删除并重新创建表通常更简单（有时也更快）。
- en: SQL Execution
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: SQL 执行
- en: Python’s SQLite interface is the `sqlite3` module. This conforms to the PEP-249
    standard ( [https://peps.python.org/pep-0249/](https://peps.python.org/pep-0249/))
    for database access. An application will create a database connection in general.
    It will use the connection to create a *cursor*, which can query or update the
    database.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的 SQLite 接口是 `sqlite3` 模块。这符合数据库访问的 PEP-249 标准（[https://peps.python.org/pep-0249/](https://peps.python.org/pep-0249/））。应用程序通常会在创建数据库连接。它将使用连接来创建一个
    *游标*，可以查询或更新数据库。
- en: The connection is made with a connection string. For many databases, the connection
    string will include the server hosting the database, and the database name; it
    may also include security credentials or other options. For SQLite, the connection
    string can be a complete URI with the form `file:filename.db`. This has a scheme,
    `file:` and a path to the database file.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 连接是通过连接字符串完成的。对于许多数据库，连接字符串将包括托管数据库的服务器以及数据库名称；它还可能包括安全凭证或其他选项。对于 SQLite，连接字符串可以是一个完整的
    URI，形式为 `file:filename.db`。这有一个方案，`file:` 和数据库文件的路径。
- en: It’s not required by this application, but a common practice is to sequester
    the SQL statements into a configuration file. Using a TOML format can be a handy
    way to separate the processing from the SQL statements that implement the processing.
    This separation permits small SQL changes without having to change the source
    files. For compiled languages, this is essential. For Python, it’s a helpful way
    to make SQL easier to find when making database changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这对该应用程序不是必需的，但将 SQL 语句隔离到配置文件中是一种常见的做法。使用 TOML 格式可以是一种方便的方法，将处理与实现处理的 SQL 语句分开。这种分离允许在不更改源文件的情况下进行小的
    SQL 变更。对于编译型语言，这是必需的。对于 Python，这是一种在更改数据库时使 SQL 更容易找到的有帮助的方法。
- en: 'A function to create the schema might look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模式的函数可能看起来像这样：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `CREATE_SCHEMA` is the sequence of statements required to build the schema.
    A similar sequence of statements can be defined to drop the schema. The two sequences
    can be combined to drop and recreate the schema as part of ordinary database design
    and experimentation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE_SCHEMA` 是构建模式所需的语句序列。可以定义类似的语句序列来删除模式。这两个序列可以组合起来，作为普通数据库设计和实验的一部分来删除和重新创建模式。'
- en: 'A main program can create the database with code similar to the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 主程序可以使用类似以下代码创建数据库：
- en: '[PRE4]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This requires a function, `schema_build_load()`, to drop and recreate the schema
    and then load the individual rows of data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这需要一个名为 `schema_build_load()` 的函数，用于删除并重新创建模式，然后加载单个数据行。
- en: We’ll turn to the next step, loading the data. This begins with loading the
    series definitions, then follows this with populating the data values for each
    series.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将转向下一步，即加载数据。这从加载系列定义开始，然后继续填充每个系列的数值。
- en: Loading the SERIES table
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载 SERIES 表
- en: The values in the `SERIES` table are essentially fixed. There are four rows
    to define the four series.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`SERIES` 表中的值基本上是固定的。有四行来定义四个系列。'
- en: 'Executing a SQL data manipulation statement requires two things: the statement
    and a dictionary of values for the placeholders in the statement.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 SQL 数据操作语句需要两个东西：语句和用于语句中占位符的值的字典。
- en: 'In the following code sample, we’ll define the statement, as well as four dictionaries
    with values for placeholders:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将定义语句，以及四个带有占位符值的字典：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `execute()` method of a connection object is given the SQL statement with
    placeholders and a dictionary of values to use for the placeholders. The SQL template
    and the values are provided to the database to insert rows into the table.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 连接对象的 `execute()` 方法被赋予带有占位符的 SQL 语句和一个用于占位符的值的字典。SQL 模板和值被提供给数据库以插入行到表中。
- en: For the individual data values, however, something more is required. In the
    next section, we’ll look at a transformation from source CSV data into a dictionary
    of parameter values for a SQL statement.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于单个数据值，还需要更多。在下一节中，我们将查看从源 CSV 数据到用于 SQL 语句的参数值字典的转换。
- en: Loading the SERIES_VALUE table
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 加载 SERIES_VALUE 表
- en: 'It can help to refer back to the project in [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data* *Acquisition Base Application*](ch007.xhtml#x1-560003). In
    this chapter, we defined a dataclass for the (*x,y*) pairs, and called it `XYPair`.
    We also defined a class hierarchy of `PairBuilder` to create `XYPair` objects
    from the CSV row objects.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 可以参考 [*第3章*](ch007.xhtml#x1-560003) 和 [*项目1.1：数据获取基础应用*](ch007.xhtml#x1-560003)
    中的项目来帮助理解。在这一章中，我们定义了一个 (*x,y*) 对的数据类，并称之为 `XYPair`。我们还定义了一个 `PairBuilder` 类层次结构，用于从
    CSV 行对象创建 `XYPair` 对象。
- en: It can be confusing to load data using application software that is suspiciously
    similar to the software for extracting data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与应用软件提取数据软件可疑相似的应用软件加载数据可能会令人困惑。
- en: This confusion often arises in cases like this where we’re forced to build a
    demonstration database.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种困惑通常出现在我们被迫构建演示数据库的情况下。
- en: It can also arise in cases where a test database is needed for complex analytic
    applications.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可能出现在需要测试数据库以用于复杂分析应用程序的情况下。
- en: In most enterprise environments, the databases already exist and are already
    full of data. Test databases are still needed to confirm that analytic applications
    work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数企业环境中，数据库已经存在并且已经充满了数据。测试数据库仍然需要来确认分析应用程序是否工作。
- en: The `INSERT` statement, shown above in [*SQL Data Manipulations*](#x1-1210002)
    has four placeholders. This means a dictionary with four parameters is required
    by the `execute()` method of a connection.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 `INSERT` 语句（在 [*SQL 数据操作*](#x1-1210002) 中显示）有四个占位符。这意味着连接的 `execute()` 方法需要一个包含四个参数的字典。
- en: The `dataclasses` module includes a function, `asdict()`, to transform the object
    of the `XYPair` into a dictionary. This has two of the parameters required, `:x`
    and `:y`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`dataclasses` 模块包含一个函数 `asdict()`，用于将 `XYPair` 对象转换为字典。这包含了所需的两个参数，`:x` 和 `:y`。'
- en: We can use the `|` operator to merge two dictionaries together. One dictionary
    has the essential attributes of the object, created by `asdict()`. The other dictionary
    is the SQL overheads, including a value for `:series_id`, and a value for `:sequence`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `|` 操作符将两个字典合并在一起。一个字典包含对象的基本属性，由 `asdict()` 创建，另一个字典是 SQL 负载，包括 `:series_id`
    的值和 `:sequence` 的值。
- en: 'Here’s a fragment of code that shows how this might work:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个代码片段，展示了这可能的工作方式：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `reader` object is a `csv.DictReader` for the source CSV data. The `SERIES_BUILDERS`
    object is a sequence of two-tuples with the series number and a function (or callable
    object) to extract the appropriate columns and build an instance of `XYPair`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`reader` 对象是源 CSV 数据的 `csv.DictReader`。`SERIES_BUILDERS` 对象是一个包含系列编号和函数（或可调用对象）的序列，用于提取适当的列并构建
    `XYPair` 实例。'
- en: 'For completeness, here’s the value of the `SERIES_BUILDERS` object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，以下是 `SERIES_BUILDERS` 对象的值：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this case, individual functions have been defined to extract the required
    columns from the CSV source dictionary and build an instance of `XYPair`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，已经定义了单独的函数来从 CSV 源字典中提取所需的列并构建一个 `XYPair` 实例。
- en: The above code snippets need to be built as proper functions and used by an
    overall `main()` function to drop the schema, build the schema, insert the values
    for the `SERIES` table, and then insert the `SERIES_VALUE` rows.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段需要构建为适当的函数，并由整体的 `main()` 函数使用，以删除模式、构建模式、插入 `SERIES` 表的值，然后插入 `SERIES_VALUE`
    行。
- en: 'A helpful final step is a query to confirm the data was loaded. Consider something
    like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有用的最终步骤是查询以确认数据已加载。考虑以下内容：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This should report the names of the four series and the presence of 11 rows
    of data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该报告四个系列的名字和11行数据的存在。
- en: 5.1.3 Deliverables
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 交付成果
- en: 'There are two deliverables for this mini-project:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个迷你项目有两个交付成果：
- en: A database for use in the next project. The primary goal is to create a database
    that is a surrogate for a production database in use by an enterprise.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为下一个项目使用的数据库。主要目标是创建一个数据库，作为企业使用的生产数据库的替代品。
- en: An application that can build (and rebuild) this database. This secondary goal
    is the means to achieve the primary goal.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可以构建（并重建）此数据库的应用程序。这个次要目标是实现主要目标的方法。
- en: 'Additionally, of course, unit tests are strongly encouraged. This works out
    well when the application is designed for testability. This means two features
    are essential:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，单元测试也强烈推荐。当应用程序设计为可测试时，这效果很好。这意味着两个特性是必不可少的：
- en: The database connection object is created in the `main()` function.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接对象是在 `main()` 函数中创建的。
- en: The connection object is passed as an argument value to all the other functions
    that interact with the database.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接对象作为参数值传递给所有与数据库交互的其他函数。
- en: Providing the connection as a parameter value makes it possible to test the
    various functions isolated from the overhead of a database connection. The tests
    for each application function that interacts with the database are given a mock
    connection object. Most mock connection objects have a mock `execute()` method,
    which returns a mock cursor with no rows. For queries, the mock `execute()` method
    can return mocked data rows, often something as simple as a `sentinel` object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将连接作为参数值提供，使得可以独立于数据库连接的开销测试各种函数。对于与数据库交互的每个应用程序函数，都提供了一个模拟连接对象。大多数模拟连接对象都有一个模拟的
    `execute()` 方法，它返回一个没有行的模拟游标。对于查询，模拟的 `execute()` 方法可以返回模拟的数据行，通常是一些简单的`哨兵`对象。
- en: After exercising a function, the mock `execute()` method can then be examined
    to be sure the statement and parameters were provided to the database by the application.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行一个函数之后，可以检查模拟的 `execute()` 方法，以确保应用程序向数据库提供了语句和参数。
- en: A formal acceptance test for this kind of one-use-only application seems excessive.
    It seems easier to run the application and look at the results with a SQL `SELECT`
    query. Since the application drops and recreates the schema, it can be re-run
    until the results are acceptable.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种一次性使用的应用程序，进行正式的验收测试似乎过于繁琐。似乎更容易运行应用程序，并用SQL `SELECT` 查询查看结果。由于应用程序删除并重新创建模式，可以在结果可接受之前重复运行。
- en: '5.2 Project 1.5: Acquire data from a SQL extract'
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 项目1.5：从SQL提取获取数据
- en: At this point, you now have a useful SQL database with schema and data. The
    next step is to write applications to extract data from this database into a useful
    format.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你现在有一个有用的SQL数据库，其中包含模式和数据。下一步是编写应用程序，将数据从该数据库提取到有用的格式中。
- en: 5.2.1 Description
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 描述
- en: It can be difficult to use an operational database for analytic processing.
    During normal operations, locking is used to assure that database changes don’t
    conflict with or overwrite each other. This locking can interfere with gathering
    data from the database for analytic purposes.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用运行中的数据库进行分析处理可能会很困难。在正常操作期间，锁定用于确保数据库更改不会相互冲突或覆盖。这种锁定可能会干扰从数据库中收集数据用于分析。
- en: There are a number of strategies for extracting data from an operational database.
    One technique is to make a backup of the operational database and restore it into
    a temporary clone database for analytic purposes. Another technique is to use
    any replication features and do analytical work in the replicated database.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从运行中的数据库中提取数据有多种策略。一种技术是备份运行中的数据库，并将其恢复到一个临时的克隆数据库中，用于分析目的。另一种技术是使用任何复制功能，并在复制的数据库中进行分析工作。
- en: The strategy we’ll pursue here is the “table-scan” approach. It’s often possible
    to do rapid queries without taking out any database locks. The data may be inconsistent
    because of in-process transactions taking place at the time the query was running.
    In most cases, the number of inconsistent entities is a tiny fraction of the available
    data.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的策略是“表扫描”方法。通常可以在不取出任何数据库锁的情况下进行快速查询。由于查询运行时正在进行的进程事务，数据可能不一致。在大多数情况下，不一致实体数量是可用数据的极小部分。
- en: If it’s necessary to have a *complete and consistent* snapshot at a specific
    point in time, the applications need to have been designed with this idea in mind.
    It can be very difficult to establish the state of a busy database with updates
    being performed by poorly designed applications. In some cases, the definitions
    of *complete* and *consistent* may be difficult to articulate because the domain
    of state changes isn’t known in enough detail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在特定时间点获得一个*完整且一致*的快照，应用程序就需要考虑到这一点进行设计。在由设计不良的应用程序执行更新的情况下，确定繁忙数据库的状态可能非常困难。在某些情况下，*完整*和*一致*的定义可能难以表述，因为状态变化的领域在细节上了解不够充分。
- en: It can be frustrating to work with poorly designed databases.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 与设计不良的数据库一起工作可能会令人沮丧。
- en: It’s often important to educate potential users of analytic software on the
    complexities of acquiring the data. This education needs to translate the database
    complications into the effect on the decisions they’re trying to make and the
    data that supports those decisions.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 教育潜在的分析软件用户了解获取数据的复杂性通常很重要。这种教育需要将数据库复杂性转化为对决策的影响以及支持这些决策的数据。
- en: 'The **User Experience** (**UX**) will be a command-line application. Our expected
    command line should look something like the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户体验**（**UX**）将是一个命令行应用程序。我们期望的命令行可能看起来像以下这样：'
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `-o`` quartet` argument specifies a directory into which four results are
    written. These will have names like `quartet/series_1.json`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` `quartet`参数指定一个目录，四个结果将被写入其中。这些文件名可能像`quartet/series_1.json`。'
- en: The `--schema`` extract.toml` argument is the name of a file with the SQL statements
    that form the basis for the database queries. These are kept separate from the
    application to make it slightly easier to respond to the database structure changes
    without rewriting the application program.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`--schema` `extract.toml`参数是包含构成数据库查询基础的SQL语句的文件名。这些语句与应用程序分开，以便在无需重写应用程序程序的情况下更容易地应对数据库结构的变化。'
- en: The `--db_uri`` file:example.db` argument provides the URI for the database.
    For SQLite, the URIs have a scheme of `file:` and a path to the database file.
    For other database engines, the URI may be more complicated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`--db_uri` `file:example.db`参数提供数据库的URI。对于SQLite，URI方案为`file:`，指向数据库文件的路径。对于其他数据库引擎，URI可能更复杂。'
- en: The `-u` argument provides a username for connecting to the database. The password
    is requested by an interactive prompt. This keeps the password hidden.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`-u`参数提供用于连接数据库的用户名。密码将通过交互式提示请求。这可以隐藏密码。'
- en: The UX shown above includes a username and password.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的UX包括用户名和密码。
- en: While it won’t actually be needed for SQLite, it will be needed for other databases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLite实际上不需要它，但它对于其他数据库将是必需的。
- en: 5.2.2 The Object-Relational Mapping (ORM) problem
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 对象关系映射（ORM）问题
- en: A relational database design decomposes complicated data structures into a number
    of simpler entity types, which are represented as tables. The process of decomposing
    a data structure into entities is called *normalization*. Many database designs
    fit a pattern called *Third Normal Form*; but there are additional normalization
    forms. Additionally, there are compelling reasons to break some of the normalization
    rules to improve performance.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型数据库设计将复杂的数据结构分解为多个简单的实体类型，这些类型以表格的形式表示。将数据结构分解为实体的过程称为*规范化*。许多数据库设计符合称为*第三范式*的模式；但还有其他规范化形式。此外，还有充分的理由打破一些规范化规则以提高性能。
- en: The relational normalization leads to a consistent representation of data via
    simple tables and columns. Each column will have an atomic value that cannot be
    further decomposed. Data of arbitrary complexity can be represented in related
    collections of flat, normalized tables.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 关系规范化通过简单的表格和列来保证数据的一致表示。每一列都将有一个不可再分解的原子值。任意复杂度的数据都可以通过相关集合的平坦、规范化表格来表示。
- en: See [https://www.packtpub.com/product/basic-relational-database-design-video/9781838557201](https://www.packtpub.com/product/basic-relational-database-design-video/9781838557201)
    for some more insights into the database design activity.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有关数据库设计活动的更多信息，请参阅[https://www.packtpub.com/product/basic-relational-database-design-video/9781838557201](https://www.packtpub.com/product/basic-relational-database-design-video/9781838557201)。
- en: The process of retrieving a complex structure is done via a relational *join*
    operation. Rows from different tables and joined into a result set from which
    Plain Old Python Objects can be constructed. This join operation is part of the
    `SELECT` statement. It appears in the `FROM` clause as a rule that states how
    to match rows in one table with rows from another table.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 获取复杂结构的过程是通过关系*连接*操作完成的。来自不同表的行被连接到一个结果集中，从中可以构建原始Python对象。这个连接操作是`SELECT`语句的一部分。它出现在`FROM`子句中，作为一条规则，说明如何将一个表中的行与另一个表中的行匹配。
- en: This distinction between relational design and object-oriented design is sometimes
    called the *Object-Relational Impedance Mismatch*. For more background, see [https://wiki.c2.com/?ObjectRelationalImpedanceMismatch](https://wiki.c2.com/?ObjectRelationalImpedanceMismatch).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关系设计和对象设计之间的区别有时被称为*对象关系阻抗不匹配*。有关更多背景信息，请参阅[https://wiki.c2.com/?ObjectRelationalImpedanceMismatch](https://wiki.c2.com/?ObjectRelationalImpedanceMismatch)。
- en: One general approach to reading complex data from a relational database is to
    create to an ORM layer. This layer uses SQL SELECT statements to extract data
    from multiple tables to build a useful object instance. The ORM layer may use
    a separate package, or it may be part of the application. While an ORM design
    can be designed poorly — i.e. the ORM-related operations may be scattered around
    haphazardly — the layer is always present in any application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从关系型数据库中读取复杂数据的一种通用方法是创建一个ORM层。这个层使用SQL SELECT语句从多个表中提取数据，以构建一个有用的对象实例。ORM层可能使用一个单独的包，或者它可能是应用程序的一部分。虽然ORM设计可能会设计得不好——即ORM相关的操作可能会随意散布——但这个层在任何应用程序中都始终存在。
- en: There are many packages in the **Python Package Index**(**PyPI**) that offer
    elegant, generalized ORM solutions. The **SQLAlchemy** ( [https://www.sqlalchemy.org](https://www.sqlalchemy.org))
    package is very popular. This provides a comprehensive approach to the entire
    suite of **Create, Retrieve, Update, and Delete**(**CRUD**) operations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '**Python包索引**(**PyPI**)中有许多包提供优雅的通用ORM解决方案。**SQLAlchemy** ( [https://www.sqlalchemy.org](https://www.sqlalchemy.org))包非常受欢迎。它提供了一个全面的解决方案，用于整个**创建、检索、更新和删除**(**CRUD**)操作套件。'
- en: 'There are two conditions that suggest creating the ORM layer manually:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种条件表明需要手动创建ORM层：
- en: Read-only access to a database. A full ORM will include features for operations
    that won’t be used.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数据库的只读访问。完整的ORM将包括不会使用的操作功能。
- en: An oddly designed schema. It can sometimes be difficult to work out an ORM definition
    for an existing schema with a design that doesn’t fit the ORM’s built-in assumptions.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个设计奇特的模式。有时很难为设计不符合ORM内置假设的现有模式制定ORM定义。
- en: There’s a fine line between a bad database design and a confusing database design.
    A bad design has quirky features that cannot be successfully described through
    an ORM layer. A confusing design can be described, but it may require using “advanced”
    features of the ORM package. In many cases, building the ORM mapping requires
    learning enough about the ORM’s capabilities to see the difference between bad
    and confusing.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在糟糕的数据库设计和令人困惑的数据库设计之间有一条很细的界限。糟糕的设计具有ORM内置假设无法成功描述的奇特特性。令人困惑的设计可以描述，但它可能需要使用ORM包的“高级”功能。在许多情况下，构建ORM映射需要了解足够的ORM功能，以便区分糟糕的和令人困惑的。
- en: In many cases, a relational schema may involve a vast number of interrelated
    tables, sometimes from a wide variety of subject areas. For example, there may
    be products and a product catalog, sales records for products, and inventory information
    about products. What is the proper boundary for a “product” class? Should it include
    everything in the database related to a product? Or should it be limited by some
    bounded context or problem domain?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，关系模式可能涉及大量相互关联的表，有时来自广泛的学科领域。例如，可能有产品和产品目录、产品的销售记录以及关于产品的库存信息。一个“产品”类的适当边界是什么？它应该包括数据库中与产品相关的所有内容吗？或者它应该由某个有界上下文或问题域限制？
- en: Considerations of existing databases should lead to extensive conversations
    with users on the problem domain and context. It also leads to further conversations
    with the owners of the applications creating the data. All of the conversations
    are aimed at understanding how a user’s concept may overlap with existing data
    sources.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有数据库的考虑应导致与用户就问题域和上下文进行广泛的对话。它还导致与创建数据的应用程序的所有者进行进一步的对话。所有对话的目的是理解用户的观念如何与现有数据源重叠。
- en: Acquiring data from relational databases can be a challenge.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 从关系型数据库中获取数据可能是一个挑战。
- en: The relational normalization will lead to complications. The presence of overlapping
    contexts can lead to further complications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关系型规范化会导致复杂性。重叠上下文的存在可能导致进一步的复杂性。
- en: What seems to be helpful is providing a clear translation from the technical
    world of the database to the kinds of information and decisions users want to
    make.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好像有帮助的是，提供从数据库的技术世界到用户想要做出信息和决策的信息的清晰翻译。
- en: 5.2.3 About the source data
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.3 关于源数据
- en: 'See [*Figure 5.2*](#5.2) for an ERD that shows the two tables that provide
    the desired entities:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 见[*图5.2*](#5.2)以查看提供所需实体的两个表的ERD：
- en: '![Figure 5.2: The Database Schema ](img/file27.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：数据库模式](img/file27.jpg)'
- en: 'Figure 5.2: The Database Schema'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：数据库模式
- en: 'In the design shown above, two tables decompose instances of the `Series` class.
    Here are the Python class definitions:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述设计中，两个表格分解了`Series`类的实例。以下是Python类定义：
- en: '[PRE10]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The idea here is that a collection of `SeriesSample` objects are part of a single
    composite `Series` object. The `SeriesSample` objects, separated from the containing
    `Series`, aren’t useful in isolation. A number of `SeriesSample` instances depend
    on a `Series` object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是一组`SeriesSample`对象是单个复合`Series`对象的一部分。从包含的`Series`中分离出来的`SeriesSample`对象在孤立状态下没有用处。许多`SeriesSample`实例依赖于一个`Series`对象。
- en: 'There are three general approaches to retrieving information from a normalized
    collection of tables:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个规范化的表集合中检索信息有三种一般方法：
- en: A single SQL query. This forces the database server to **join** rows from multiple
    tables, providing a single result set.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个SQL查询。这迫使数据库服务器将多个表中的行**连接**起来，提供一个单一的结果集。
- en: A series of queries to extract data from separate tables and then do lookups
    using Python dictionaries.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一系列查询从单独的表中提取数据，然后使用Python字典进行查找。
- en: Nested SQL queries. These use simpler SQL but can make for a large number of
    database requests.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套SQL查询。这些使用更简单的SQL，但可能导致大量的数据库请求。
- en: Neither alternative is a perfect solution in all cases. Many database designers
    will insist that database join operations are magically the fastest. Some actual
    timing information suggests that Python dictionary lookups can be much faster.
    Numerous factors impact query performance and the prudent design is to implement
    alternatives and compare performance.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有情况下，这两种选择都不是完美的解决方案。许多数据库设计者会坚持认为数据库连接操作是神奇的最快方式。一些实际的计时信息表明，Python字典查找可以更快。许多因素影响查询性能，谨慎的设计是实施替代方案并比较性能。
- en: The number of factors influencing performance is large. No simple “best practice”
    exists. Only actual measurements can help to make a design decision.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 影响性能的因素数量庞大。不存在简单的“最佳实践”。只有实际测量才能帮助做出设计决策。
- en: 'The join query to retrieve the data might look this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检索数据的连接查询可能看起来是这样的：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Each distinct value of `s.name` will lead to the creation of a distinct `Series`
    object. Each row of `sv.x`, and `sv.y` values becomes a `SeriesSample` instance
    within the `Series` object.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`s.name`的每个不同值将导致创建一个不同的`Series`对象。`sv.x`和`sv.y`值的每一行都成为`Series`对象内的`SeriesSample`实例。'
- en: 'Building objects with two separate `SELECT` statements involves two simpler
    queries. Here’s the “outer loop” query to get the individual series:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个单独的`SELECT`语句构建对象涉及两个更简单的查询。以下是获取单个系列的“外循环”查询：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here’s the “inner loop” query to get rows from a specific series:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这是获取特定系列行的“内循环”查询：
- en: '[PRE13]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The second `SELECT` statement has a placeholder that depends on the results
    of the first query. The application must provide this parameter when making a
    nested request for a series-specific subset of rows from the `series_sample` table.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个`SELECT`语句有一个依赖于第一个查询结果的占位符。当应用程序对`series_sample`表中的特定系列子集进行嵌套请求时，必须提供此参数。
- en: It’s also important to note the output is expected to be pure text, which will
    be saved in ND JSON files. This means the sophisticated structure of the SQL database
    will be erased.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，输出预期是纯文本，将保存在ND JSON文件中。这意味着SQL数据库的复杂结构将被删除。
- en: 'This will also make the interim results consistent with CSV files and HTML
    pages, where the data is only text. The output should be similar to the output
    from the CSV extract in [*Chapter** 3*](ch007.xhtml#x1-560003), [*Project 1.1:
    Data Acquisition Base* *Application*](ch007.xhtml#x1-560003): a file of small
    JSON documents that have the keys `"x"` and `"y"`. The goal is to strip away structure
    that may have been imposed by the data persistence mechanism — a SQL database
    for this project. The data is reduced into a common base of text.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将使中间结果与CSV文件和HTML页面保持一致，在这些文件和页面上，数据仅是文本。输出应类似于[第3章](ch007.xhtml#x1-560003)中CSV提取的输出，[项目1.1：数据获取基础应用](ch007.xhtml#x1-560003)：一个小型JSON文档的文件，具有“x”和“y”键。目标是去除可能由数据持久化机制（本项目为SQL数据库）强加的结构。数据被简化为共同的文本基础。
- en: In the next section, we’ll look more closely at the technical approach to acquiring
    data from a SQL database.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将更仔细地研究从SQL数据库获取数据的技术方法。
- en: 5.2.4 Approach
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.4 方法
- en: We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们审视我们的方法时，我们将从C4模型（[https://c4model.com](https://c4model.com)）中获取一些指导。
- en: '**Context**: For this project, a context diagram would show a user extracting
    data from a source. The reader may find it helpful to draw this diagram.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：对于这个项目，上下文图将显示用户从源提取数据。读者可能会发现绘制此图很有帮助。'
- en: '**Containers**: One container is the user’s personal computer. The other container
    is the database server, which is running on the same computer.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：一个容器是用户的个人电脑。另一个容器是运行在同一台电脑上的数据库服务器。'
- en: '**Components**: We’ll address the components below.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：我们将在下面讨论组件。'
- en: '**Code**: We’ll touch on this to provide some suggested directions.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：我们将简要提及以提供一些建议方向。'
- en: This project adds a new `db_client` module to extract the data from a database.
    The overall application in the `acquire` module will change to make use of this
    new module. The other modules — for the most part — will remain unchanged.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目添加了一个新的`db_client`模块来从数据库中提取数据。`acquire`模块中的整体应用将改变以使用此新模块。其他模块——大部分——将保持不变。
- en: The component diagram in [*Figure 5.3*](#5.3) shows an approach to this project.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[*图5.3*](#5.3)中的组件图显示了此项目的处理方法。'
- en: '![Figure 5.3: Component Diagram ](img/file28.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3：组件图](img/file28.jpg)'
- en: 'Figure 5.3: Component Diagram'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：组件图
- en: This diagram shows a revision to the underlying `model`. This diagram extends
    the `model` module to make the distinction between the composite series object
    and the individual samples within the overall series. It also renames the old
    `XYPair` class to a more informative `SeriesSample` class.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了底层`model`的修订。此图扩展了`model`模块，以区分复合系列对象和整体系列中的单个样本。它还将旧的`XYPair`类重命名为更具信息量的`SeriesSample`类。
- en: This distinction between series has been an implicit part of the project in
    the previous chapters. At this point, it seems potentially helpful to distinguish
    a collection of samples from an individual sample.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系列之间的区别是前几章项目中隐含的一部分。在此阶段，区分样本集合和单个样本可能是有帮助的。
- en: Some readers may object to renaming a class partway through a series of closely
    related projects. This kind of change is — in the author’s experience — very common.
    We start with an understanding that evolves and grows the more we work the problem
    domain, the users, and the technology. It’s very difficult to pick a great name
    for a concept. It’s more prudent to fix names as we learn.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一些读者可能反对在一系列紧密相关的项目中中途更改类名。这种改变——根据作者的经验——非常常见。我们开始时有一个理解，随着我们对问题领域、用户和技术的深入了解，这个理解会不断发展和完善。为概念挑选一个很好的名字非常困难。在我们学习的过程中逐步确定名字更为谨慎。
- en: The new module will make use of two SQL queries to perform the extract. We’ll
    look at these nested requests in the next section.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 新模块将使用两个SQL查询来执行提取。我们将在下一节中查看这些嵌套请求。
- en: Extract from a SQL DB
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从SQL数据库中提取
- en: The extraction from the database constructs a series of two parts. The first
    part is to get the attributes of the `Series` class. The second part is to get
    each of the individual `SeriesSample` instances.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库的提取构建了两个部分的系列。第一部分是获取`Series`类的属性。第二部分是获取每个单独的`SeriesSample`实例。
- en: 'Here’s the overview of a potential class design:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是潜在类设计的概述：
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `series_iter()` method iterates over the `Series` instances that can be
    created from the database. The `build_samples()` method creates the individual
    samples that belong to a series.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`series_iter()`方法遍历可以从数据库创建的`Series`实例。`build_samples()`方法创建属于系列的各个样本。'
- en: 'Here’s a first draft of an implementation of the `build_samples()` method:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`build_samples()`方法的初稿实现：
- en: '[PRE15]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method will extract the collection of samples for a series given the name.
    It relies on the SQL query in the `config` object. The list of samples is built
    from the results of the query using a list comprehension.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将根据名称提取系列中的样本集合。它依赖于`config`对象中的SQL查询。使用列表推导从查询结果构建样本列表。
- en: 'This first draft implementation has a dependency on the `SeriesSample` class
    name. This is another SOLID design issue, similar to the one in [*Class design*](ch007.xhtml#x1-620001)
    of [*Chapter** 3*](ch007.xhtml#x1-560003), [*Project 1.1: Data* *Acquisition Base
    Application*](ch007.xhtml#x1-560003).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初稿实现依赖于`SeriesSample`类名。这是另一个SOLID设计问题，类似于第3章[*类设计*](ch007.xhtml#x1-620001)中提到的[*项目1.1：数据采集基础应用*](ch007.xhtml#x1-560003)的问题。
- en: A better implementation would replace this direct dependency with a dependency
    that can be injected at runtime, permitting better isolation for unit testing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的实现将用可以在运行时注入的依赖项替换这个直接依赖项，从而允许更好的单元测试隔离。
- en: 'Here’s an implementation of the `series_iter()` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`series_iter()`方法的实现：
- en: '[PRE16]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This method will extract each of the series from the database. It, too, gets
    the SQL statements from a configuration object, `config`. A configuration object
    is a dictionary of dictionaries. This structure is common for TOML files.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将从数据库中提取每个序列。它同样从配置对象`config`中获取SQL语句。配置对象是一个字典的字典。这种结构在TOML文件中很常见。
- en: 'The idea is to have a configuration file in TOML notation that looks like this:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 想法是有一个TOML符号的配置文件，看起来像这样：
- en: '[PRE17]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This configuration has a `[query]` section, with several individual SQL statements
    used to query the database. Because the SQL statements are often quite large,
    triple quotes are used to delimit them.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置有一个`[query]`部分，包含几个用于查询数据库的单独SQL语句。由于SQL语句通常相当长，因此使用三引号来界定它们。
- en: In cases where the SQL statements are very large, it’s can seem helpful to put
    them in separate files. This leads to a more complicated configuration with a
    number of files, each with a separate SQL statement.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL语句非常长的情况下，将它们放入单独的文件中可能看起来很有帮助。这会导致一个更复杂的配置，包含多个文件，每个文件包含一个单独的SQL语句。
- en: Before we look at the deliverables, we’ll talk a bit about why this data acquisition
    application is different from the previous projects.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看可交付成果之前，我们将简要讨论为什么这个数据采集应用程序与以前的项目不同。
- en: SQL-related processing distinct from CSV processing
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 与CSV处理不同的SQL相关处理
- en: It’s helpful to note some important distinctions between working with CSV data
    and working with SQL data.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 注意一些重要的区别，这些区别在于处理CSV数据和处理SQL数据。
- en: First, CSV data is always text. When working with a SQL database, the underlying
    data often has a data type that maps pleasantly to a native Python type. SQL databases
    often have a few numeric types, including integers and floating-point numbers.
    Some databases will handle decimal values that map to Python’s `decimal.Decimal`
    class; this isn’t a universal capability, and some databases force the application
    to convert between `decimal.Decimal` and text to avoid the truncation problems
    inherent with floating-point values.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，CSV数据始终是文本。当与SQL数据库一起工作时，底层数据通常具有与原生Python类型愉快映射的数据类型。SQL数据库通常有一些数值类型，包括整数和浮点数。一些数据库将处理映射到Python的`decimal.Decimal`类的十进制值；这不是一个通用功能，一些数据库强制应用程序在`decimal.Decimal`和文本之间进行转换，以避免浮点值固有的截断问题。
- en: The second important distinction is the tempo of change. A SQL database schema
    tends to change slowly, and change often involves a review of the impact of the
    change. In some cases, CSV files are built by interactive spreadsheet software,
    and manual operations are used to create and save the data. Unsurprisingly, the
    interactive use of spreadsheets leads to small changes and inconsistencies over
    short periods of time. While some CSV files are produced by highly automated tools,
    there may be less scrutiny applied to the order or names of columns.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的区别是变化的节奏。SQL数据库模式通常变化缓慢，变化通常涉及对变化影响的审查。在某些情况下，CSV文件是由交互式电子表格软件构建的，并且使用手动操作来创建和保存数据。不出所料，电子表格的交互式使用会导致在短时间内出现小的变化和不一致性。虽然一些CSV文件是由高度自动化的工具生成的，但可能对列的顺序或名称的审查较少。
- en: A third important distinction relates to the design of spreadsheets contrasted
    with the design of a database. A relational database is often highly normalized;
    this is an attempt to avoid redundancy. Rather than repeat a group of related
    values, an entity is assigned to a separate table with a primary key. References
    to the group of values via the primary key are used to avoid repetition of the
    values themselves. It’s less common to apply normalization rules to a spreadsheet.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个重要的区别与电子表格的设计与数据库的设计相关。关系数据库通常高度规范化；这是一个避免冗余的尝试。而不是重复一组相关值，实体被分配到一个单独的表中，并具有主键。通过主键引用该值组以避免值的重复。将规范化规则应用于电子表格的情况较少见。
- en: Because spreadsheet data may not be fully normalized, extracting meaningful
    data from a spreadsheet often becomes a rather complicated problem. This can be
    exacerbated when spreadsheets are tweaked manually or the design of the spreadsheet
    changes suddenly. To reflect this, the designs in this book suggest using a hierarchy
    of classes — or collection of related functions — to build a useful Python object
    from a spreadsheet row. It is often necessary to keep a large pool of builders
    available to handle variant spreadsheet data as part of historical analysis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于电子表格数据可能没有完全规范化，从电子表格中提取有意义的数据通常成为一个相当复杂的问题。当电子表格被手动调整或设计突然改变时，这种情况可能会加剧。为了反映这一点，本书中的设计建议使用类层次结构——或相关函数集合——从电子表格行构建一个有用的
    Python 对象。在历史分析中，通常需要保持一个大量的构建者池，以处理变体电子表格数据。
- en: The designs shown earlier had a `PairBuilder` subclass to create individual
    sample objects. These designs used an `Extract` class to manage the overall construction
    of samples from the source file. This provided flexibility to handle spreadsheet
    data.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 之前显示的设计有一个 `PairBuilder` 子类来创建单个样本对象。这些设计使用 `Extract` 类来管理从源文件构建样本的整体构建。这为处理电子表格数据提供了灵活性。
- en: A database extract is somewhat less likely to need a flexible hierarchy of objects
    to create useful Python objects. Instead, the needed flexibility is often implemented
    by changing SQL statements to reflect schema changes or a deeper understanding
    of the available data. For this reason, we encourage the use of a TOML-format
    file to keep the SQL statements, permitting some changes without having to add
    more subclasses to the Python application. The TOML-format configuration files
    can have version numbers in the file name (and in the comments) to make it clear
    which database schema they are designed against.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库提取不太可能需要灵活的对象层次结构来创建有用的 Python 对象。相反，所需的灵活性通常通过更改 SQL 语句以反映模式更改或对可用数据的更深入理解来实现。因此，我们鼓励使用
    TOML 格式文件来保存 SQL 语句，允许在不添加更多子类到 Python 应用程序的情况下进行一些更改。TOML 格式的配置文件可以在文件名（和注释）中包含版本号，以清楚地说明它们是为哪个数据库模式设计的。
- en: Now that we have a design approach, it’s important to make sure we have a list
    of deliverables that serve as a definition of “Done.”
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了设计方法，确保我们有一个可交付成果列表，作为“完成”的定义是很重要的。
- en: 5.2.5 Deliverables
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.5 可交付成果
- en: 'This project has the following deliverables:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目有以下可交付成果：
- en: Documentation in the `docs` folder.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs` 文件夹中的文档。'
- en: Acceptance tests in the `tests/features` and `tests/steps` folders.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests/features` 和 `tests/steps` 文件夹中的验收测试。'
- en: The acceptance tests will involve creating and destroying example databases
    as test fixtures.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验收测试将涉及创建和销毁示例数据库作为测试固定装置。
- en: Unit tests for application modules in the `tests` folder.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests` 文件夹中的应用程序模块的单元测试。'
- en: Mock objects for the database connection will be part of the unit tests.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接的模拟对象将是单元测试的一部分。
- en: Application to acquire data from a SQL database.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序用于从 SQL 数据库获取数据。
- en: We’ll look at a few of these deliverables in a little more detail.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地探讨这些可交付成果中的几个。
- en: Mock database connection and cursor objects for testing
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 测试的模拟数据库连接和游标对象
- en: For the data acquisition application, it’s essential to provide a mock connection
    object to expose the SQL and the parameters that are being provided to the database.
    This mock object can also provide a mock cursor as a query result.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据获取应用程序，提供模拟连接对象以暴露提供给数据库的 SQL 和参数是至关重要的。此模拟对象还可以提供一个模拟游标作为查询结果。
- en: As noted earlier in [*Deliverables*](#x1-1250003), this means the connection
    object should be created only in the `main()` function. It also means the connection
    object should be a parameter to any other functions or methods that perform database
    operations. If the connection object is referenced consistently, it becomes easier
    to test by providing a mock connection object.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在 [*可交付成果*](#x1-1250003) 中，这意味着连接对象只应在 `main()` 函数中创建。这也意味着连接对象应该是任何执行数据库操作的其他函数或方法的参数。如果连接对象被一致引用，通过提供模拟连接对象进行测试就会变得更容易。
- en: 'We’ll look at this in two parts: first, the conceptual Given and When steps;
    after that, we’ll look at the Then steps. This is sometimes called “arrange-act-assert”.
    Here’s the start of the **PyTest** test case:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两部分来探讨这个问题：首先，是概念性的“给定”和“当”步骤；之后，我们将探讨“然后”步骤。这有时被称为“安排-行动-断言”。以下是 **PyTest**
    测试用例的开始部分：
- en: '[PRE18]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The assertions confirm the results come from the mock objects without being
    transformed, dropped, or corrupted by some error in the code under test. The assertions
    look like this example:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 断言确认结果直接来自模拟对象，没有被转换、删除或因测试代码中的某些错误而损坏。断言看起来像这个例子：
- en: '[PRE19]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A mock connection object must provide results with sentinel objects that have
    the proper structure to look like the iterable `Cursor` object that is returned
    by SQLite3 when executing a database query.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟连接对象必须提供具有适当结构的哨兵对象的结果，使其看起来像 SQLite3 执行数据库查询时返回的 `Cursor` 可迭代对象。
- en: 'The mock connection seems rather complicated because it involves two separate
    mock cursors and a mock connection. Here’s some typical code for a mock connection:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟连接似乎相当复杂，因为它涉及两个独立的模拟游标和一个模拟连接。以下是一个模拟连接的典型代码示例：
- en: '[PRE20]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The mocked cursors are provided as simple lists. If the code under test used
    other features of a cursor, a more elaborate `Mock` object would be required.
    The `query_to_cursor` mapping associates a result with a particular query. The
    idea here is the queries will be `sentinel` objects, not long SQL strings.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟游标以简单的列表形式提供。如果测试代码使用了游标的其他功能，则需要一个更复杂的 `Mock` 对象。`query_to_cursor` 映射将结果与特定的查询关联起来。这里的想法是查询将是哨兵对象，而不是长的
    SQL 字符串。
- en: The `connection` object uses the side-effect feature of `Mock` objects. When
    the `execute()` method is evaluated, the call is recorded, and the result comes
    from the side-effect function. In this case, it’s a lambda object that uses the
    `query_to_cursor` mapping to locate an appropriate cursor result.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`connection` 对象使用了 `Mock` 对象的副作用特性。当 `execute()` 方法被评估时，调用会被记录，结果来自副作用函数。在这种情况下，它是一个使用
    `query_to_cursor` 映射来定位适当游标结果的自定义对象。'
- en: This use of the side-effect feature avoids making too many assumptions about
    the internal workings of the unit under test. The SQL will be a `sentinel` object
    and the results will contain `sentinel` objects.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用副作用特性的做法避免了在测试单元的内部工作方式上做出过多的假设。SQL 将是一个哨兵对象，结果将包含哨兵对象。
- en: In this case, we’re insisting the unit under test does no additional processing
    on the values retrieved from the database. In other applications, where additional
    processing is being done, more sophisticated mock objects or test literals may
    be required.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们坚持认为，正在测试的单元不对从数据库检索的值进行任何额外的处理。在其他应用程序中，如果正在进行额外的处理，可能需要更复杂的模拟对象或测试字面量。
- en: It’s not unusual to use something like `(11,`` 13)` instead of `(sentinel.X,`` sentinel.Y)`
    to check that a computation is being performed correctly. However, it’s more desirable
    to isolate the computations performed on SQL results into separate functions.
    This allows testing these functions as separate units. The SQL retrieval processing
    can be tested using mock functions for these additional computations.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类似 `(11,`` 13)` 而不是 `(sentinel.X,`` sentinel.Y)` 来检查计算是否正确执行的情况并不罕见。然而，将 SQL
    结果上的计算隔离到单独的函数中会更好。这允许将这些函数作为独立的单元进行测试。可以使用模拟函数对这些额外的计算进行测试。
- en: Also, note the use of the `cast()` function from the `typing` module to tell
    tools like **mypy** this object can be used like a `Connection` object.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意使用 `typing` 模块中的 `cast()` 函数来告诉像 **mypy** 这样的工具，此对象可以像 `Connection` 对象一样使用。
- en: Unit test for a new acquisition module
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新采集模块的单元测试
- en: Throughout this sequence of chapters, the overall `acquisition` module has grown
    more flexible. The idea is to permit a wide variety of data sources for an analysis
    project.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一系列章节中，整体 `acquisition` 模块变得更加灵活。目的是允许分析项目使用广泛的数据源。
- en: 'Pragmatically, it is more likely to modify an application to work with a number
    of distinct CSV formats, or a number of distinct database schemas. When a RESTful
    API changes, it’s often a good strategy to introduce new classes for the changed
    API as an alternatives to existing classes. Simply modifying or replacing the
    old definition — in a way — erases useful history on why and how an API is expected
    to work. This is the Open/Closed principle from the SOLID design principles: the
    design is open to extension but closed to modification.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，修改应用程序以支持多种不同的 CSV 格式或多种不同的数据库模式更为常见。当 RESTful API 发生变化时，引入新的类作为现有类的替代方案，通常是一个好的策略。简单地修改或替换旧的定义——从某种意义上说——会抹去关于
    API 为什么以及如何工作的有用历史。这是 SOLID 设计原则中的开放/封闭原则：设计对扩展是开放的，但对修改是封闭的。
- en: Acquiring data from a wide variety of data sources — as shown in these projects
    — is less likely than variations in a single source. As an enterprise moves from
    spreadsheets to central databases and APIs, then the analytical tools should follow
    the data sources.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 从各种不同的数据源获取数据——如这些项目所示——比单一数据源的变化可能性要小。随着企业从电子表格迁移到中心数据库和API，分析工具应跟随数据源。
- en: The need for flexible data acquisition drives the need to write unit tests for
    the acquisition module to both cover the expected cases and cover the potential
    domain of errors and mistakes in use.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 对灵活数据获取的需求推动了为获取模块编写单元测试的需要，以覆盖预期的案例，并覆盖使用中可能出现的潜在错误和错误域。
- en: Acceptance tests using a SQLite database
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用SQLite数据库进行验收测试
- en: The acceptance tests need to create (and destroy) a test database. The tests
    often need to create, retrieve, update, and delete data in the test database to
    arrange data for the given step or assert the results in the Then step.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试需要创建（并销毁）一个测试数据库。测试通常需要在测试数据库中创建、检索、更新和删除数据，以安排给定步骤的数据或断言Then步骤的结果。
- en: 'In the context of this book, we started with the [*Project 1.4: A local SQL
    database*](#x1-1150001) project to build a test database. There aren’t many readily
    accessible, public, relational databases with extractable data. In most cases,
    these databases are wrapped with a RESTful API.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的背景下，我们从[*项目1.4：本地SQL数据库*](#x1-1150001)项目开始构建测试数据库。可轻松访问的、公开的关系数据库中可提取的数据不多。在大多数情况下，这些数据库被RESTful
    API所包装。
- en: 'The database built in the previous project has two opposing use cases:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 之前项目中构建的数据库有两个相反的使用案例：
- en: It is for test purposes and can be deleted and rebuilt freely.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是用于测试目的的，可以自由删除和重建。
- en: This database must be treated as if it’s precious enterprise data, and should
    not be deleted or updated.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个数据库必须被视为珍贵的商业数据，不应被删除或更新。
- en: 'When we think of the database created in [*Project 1.4: A local SQL* *database*](#x1-1150001)
    as if it were production data, we need to protect it from unexpected changes.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将[*项目1.4：本地SQL数据库*](#x1-1150001)中创建的数据库视为生产数据时，我们需要保护它免受意外变化的影响。
- en: This means our acceptance tests must build a separate, small, test database,
    separate from the “production” database created by the previous project.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的验收测试必须构建一个独立的、小的测试数据库，与之前项目创建的“生产”数据库分开。
- en: The test database must not collide with precious enterprise data.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 测试数据库不得与珍贵的商业数据冲突。
- en: 'There are two common strategies to avoid collisions between test databases
    and enterprise databases:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 避免测试数据库与企业数据库冲突有两种常见策略：
- en: Use OS-level security in the file system to make it difficult to damage the
    files that comprise a shared database. Also, using strict naming conventions can
    put a test database into a separate namespace that won’t collide with production
    databases.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件系统中使用OS级别的安全性来使损坏构成共享数据库的文件变得困难。此外，使用严格的命名约定可以将测试数据库放入一个不会与生产数据库冲突的单独命名空间中。
- en: Run the tests in a **Docker container** to create a virtual environment in which
    production data cannot be touched.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Docker容器**中运行测试，以创建一个无法接触生产数据的虚拟环境。
- en: 'As we noted above in [*Approach*](#x1-1300004), the idea behind a database
    involves two containers:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*方法*](#x1-1300004)中提到的，数据库背后的想法涉及两个容器：
- en: A container for the application components that extract the data.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为提取数据的应用程序组件创建一个容器。
- en: A container for the database components that provide the data. An acceptance
    test can create an ephemeral database service.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为提供数据的数据库组件创建一个容器。验收测试可以创建一个短暂的数据库服务。
- en: With SQLite, however, there is no distinct database service container. The database
    components become part of the application’s components and run in the application’s
    container. The lack of a separate service container means SQLite breaks the conceptual
    two-container model that applies to large, enterprise databases. We can’t create
    a temporary, mock database **service** for testing purposes.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用SQLite，没有明确的数据库服务容器。数据库组件成为应用程序组件的一部分，并在应用程序的容器中运行。没有单独的服务容器意味着SQLite打破了适用于大型企业数据库的概念性双容器模型。我们无法为测试目的创建一个临时的、模拟的数据库**服务**。
- en: Because the SQLite database is nothing more than a file, we must focus on OS-level
    permissions, file-system paths, and naming conventions to keep our test database
    separate from the production database created in an earlier project. We emphasize
    this because working with a more complicated database engine (like MySQL or PostgreSQL)
    will also involve the same consideration of permissions, file paths, and naming
    conventions. Larger databases will add more considerations, but the foundations
    will be similar.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLite数据库不过是一个文件，我们必须关注操作系统级别的权限、文件系统路径和命名约定，以确保我们的测试数据库与早期项目中创建的生产数据库分开。我们强调这一点，因为与更复杂的数据库引擎（如MySQL或PostgreSQL）一起工作也将涉及相同的权限、文件路径和命名约定考虑。更大的数据库将增加更多的考虑因素，但基础将是相似的。
- en: It’s imperative to avoid disrupting production operations while creating data
    analytic applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建数据分析应用程序时，避免干扰生产操作是至关重要的。
- en: Building and destroying a temporary SQLite database file suggests the use of
    a `@fixture` to create a database and populate the needed schema of tables, views,
    indexes, etc. The Given steps of individual scenarios can provide a summary of
    the data arrangement required by the test.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 构建和销毁临时SQLite数据库文件暗示了使用`@fixture`来创建数据库并填充所需的表、视图、索引等模式。单个场景的给定步骤可以提供测试所需的数据排列的摘要。
- en: We’ll look at how to define this as a feature. Then, we can look at the steps
    required for the implementation of the fixture, and the step definitions.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨如何将其定义为特征。然后，我们可以查看实现配置文件所需的步骤以及步骤定义。
- en: The feature file
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 特征文件
- en: 'Here’s the kind of scenario that seems to capture the essence of a SQL extract
    application:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一种似乎能够捕捉SQL提取应用程序本质的场景：
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `@fixture.` tag follows the common naming convention for associating specific,
    reusable fixtures with scenarios. There are many other purposes for tagging scenarios
    in addition to specifying the fixture to use. In this case, the fixture information
    is used to build an SQLite database with an empty schema.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`@fixture.`标签遵循将特定、可重用配置文件与场景关联的常见命名约定。除了指定要使用的配置文件之外，还有许多其他目的可以用于标记场景。在这种情况下，配置文件信息用于构建一个具有空模式的SQLite数据库。'
- en: The Given steps provide some data to load into the database. For this acceptance
    test, a single series with only a few samples is used.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 给定步骤提供一些数据以加载到数据库中。对于这个验收测试，使用了一个只有几个样本的单个系列。
- en: The tag information can be used by the **behave** tool. We’ll look at how to
    write a `before_tag()` function to create (and destroy) the temporary database
    for any scenario that needs it.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 标签信息可以被**behave**工具使用。我们将探讨如何编写`before_tag()`函数来为任何需要它的场景创建（并销毁）临时数据库。
- en: The sqlite fixture
  id: totrans-273
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: sqlite 配置文件
- en: 'The fixture is generally defined in the `environment.py` module that the **behave**
    tool uses. The `before_tag()` function is used to process the tags for a feature
    or a scenario within a feature. This function lets us then associate a specific
    feature function with the scenario:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件通常定义在**behave**工具使用的`environment.py`模块中。`before_tag()`函数用于处理特征或特征内的场景的标签。这个函数让我们可以将特定的特征函数与场景关联起来：
- en: '[PRE22]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `use_fixture()` function tells the **behave** runner to invoke the given
    function, `sqlite_database()`, with a given argument value – in this case, the
    `context` object. The `sqlite_database()` function should be a generator: it can
    prepare the database, execute a `yield` statement, and then destroy the database.
    The **behave** runner will consume the yielded value as part of setting up the
    test, and the consume one more value when it’s time to tear down the test.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`use_fixture()`函数告诉**behave**运行器使用给定的参数值调用给定的函数`sqlite_database()`，在这种情况下，是`context`对象。`sqlite_database()`函数应该是一个生成器：它可以准备数据库，执行`yield`语句，然后销毁数据库。**behave**运行器将消费生成的值作为设置测试的一部分，并在需要清理测试时再消费一个值。'
- en: 'The function to create (and destroy) the database has the following outline:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 创建（并销毁）数据库的函数具有以下轮廓：
- en: '[PRE23]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We’ve decomposed this function into three parts: the setup, the `yield` to
    allow the test scenario to proceed, and the teardown. We’ll look at the *Set up:
    Build* *the database files* and the *Teardown: Delete the database files* sections
    separately.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将这个函数分解为三个部分：设置、允许测试场景继续的`yield`，以及清理。我们将分别查看`设置：构建数据库文件`和`清理：删除数据库文件`这两个部分。
- en: 'The setup processing of the `sqlite_database()` function is shown in the following
    snippet:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_database()`函数的设置处理过程如下所示：'
- en: '[PRE24]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The configuration file is read from the current working directory. The SQL statements
    to create the database and perform data manipulations are extracted from the schema.
    The database creation SQL will be executed during the tag discovery. The manipulation
    SQL will be put into the context for use by the Given steps executed later.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件是从当前工作目录读取的。创建数据库和执行数据操作的SQL语句是从模式中提取的。数据库创建的SQL将在标签发现期间执行。操作SQL将放入上下文中，供稍后执行的Given步骤使用。
- en: Additionally, the context is loaded up with a working path, which will be used
    for the database file as well as the output files. The context will have a `db_uri`
    string, which can be used by the data extract application to locate the test database.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，上下文还加载了一个工作路径，该路径将用于数据库文件以及输出文件。上下文将有一个`db_uri`字符串，数据提取应用程序可以使用该字符串定位测试数据库。
- en: Once the context has been filled, the individual SQL statements can be executed
    to build the empty database.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上下文已填充，可以执行单个SQL语句来构建空数据库。
- en: 'After the `yield` statement, the teardown processing of the `sqlite_database()`
    function is shown in the following snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在`yield`语句之后，以下片段显示了`sqlite_database()`函数的清理处理：
- en: '[PRE25]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The SQLite3 database must be closed before the files can be removed. The `shutil`
    package includes functions that work at a higher level on files and directories.
    The `rmtree()` function removes the entire directory tree and all of the files
    within the tree.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除文件之前，必须关闭SQLite3数据库。`shutil`包包含在文件和目录上工作的高级函数。`rmtree()`函数会删除整个目录树以及树中的所有文件。
- en: This fixture creates a working database. We can now write step definitions that
    depend on this fixture.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 此固定装置创建了一个工作数据库。我们现在可以编写依赖于此装置的步骤定义。
- en: The step definitions
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 步骤定义
- en: 'We’ll show two-step definitions to insert series and samples into the database.
    The following example shows the implementation of one of the `Given` steps:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示两个步骤定义来将系列和样本插入数据库。以下示例显示了`Given`步骤之一的实现：
- en: '[PRE26]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The step definition shown above uses SQL to create a new row in the `series`
    table. It uses the connection from the context; this was created by the `sqlite_database()`
    function that was made part of the testing sequence by the `before_tag()` function.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的步骤定义使用SQL在`series`表中创建一个新行。它使用上下文中的连接；这是由`sqlite_database()`函数创建的，该函数是通过`before_tag()`函数成为测试序列的一部分。
- en: 'The following example shows the implementation of the other `Given` step:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了另一个`Given`步骤的实现：
- en: '[PRE27]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The step definition shown above uses SQL to create a new row in the `series_sample`
    table. It uses the connection from the context, also.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的步骤定义使用SQL在`series_sample`表中创建一个新行。它还使用来自上下文的关系。
- en: Once the series and samples have been inserted into the database, the `When`
    step can run the data acquisition application using the database URI information
    from the context.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦系列和样本已插入数据库，`When`步骤可以使用上下文中的数据库URI信息运行数据采集应用程序。
- en: The `Then` steps can confirm the results from running the application match
    the database seeded by the fixture and the `Given` steps.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Then`步骤可以确认应用程序运行的结果与由固定装置种子的数据库和`Given`步骤匹配。'
- en: With this testing framework in place, you can run the acceptance test suite.
    It’s common to run the acceptance tests before making any of the programming changes;
    this reveals the `acquire` application doesn’t pass all of the tests.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试框架到位后，您可以运行验收测试套件。在做出任何编程更改之前运行验收测试是常见的；这揭示了`acquire`应用程序未能通过所有测试。
- en: In the next section, we’ll look at the database extract module and rewrite the
    main application.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看数据库提取模块并重写主应用程序。
- en: The Database extract module, and refactoring
  id: totrans-300
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 数据库提取模块和重构
- en: 'This project suggests three kinds of changes to the code written for the previous
    projects:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目建议对先前项目编写的代码进行三种类型的更改：
- en: 'Revise the `model` module to expand on what a “series” is: it’s a parent object
    with a name and a list of subsidiary objects.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`model`模块以扩展“系列”的含义：它是一个具有名称和子对象列表的父对象。
- en: Add the `db_extract` module to grab data from a SQL database.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`db_extract`模块添加到从SQL数据库中抓取数据的任务中。
- en: Update the `acquire` module to gather data from any of the available sources
    and create CSV files.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新`acquire`模块以从任何可用的来源收集数据并创建CSV文件。
- en: Refactoring the `model` module has a ripple effect on other projects, requiring
    changes to those modules to alter the data structure names.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 重构`model`模块会对其他项目产生连锁反应，需要更改这些模块以更改数据结构名称。
- en: As we noted in [*Approach*](#x1-1300004), it’s common to start a project with
    an understanding that evolves and grows. More exposure to the problem domain,
    the users, and the technology shifts our understanding. This project reflects
    a shift in understanding and leads to a need to change the implementation of previously
    completed projects.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*方法*](#x1-1300004)中提到的，通常项目开始时对理解的认识是逐步发展和演变的。对问题领域、用户和技术的更多了解会改变我们的理解。这个项目反映了理解的转变，并导致需要改变之前完成的项目实现。
- en: One consequence of this is exposing the series’ name. In projects from previous
    chapters, the four series had names that were arbitrarily imposed by the application
    program. Perhaps a file name might have been `"series_1.csv"` or something similar.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这其中的一个后果是暴露了系列的名称。在之前章节的项目中，四个系列具有由应用程序程序任意指定的名称。可能文件名会是`"series_1.csv"`或类似的东西。
- en: 'Working with the SQL data exposed a new attribute, the name of a series. This
    leads to two profound choices for dealing with this new attribute:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQL 数据一起工作暴露了一个新的属性，即系列名称。这导致在处理这个新属性时有两个深刻的抉择：
- en: Ignore the new attribute.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 忽略这个新属性。
- en: Alter the previous projects to introduce a series name.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改之前的工程以引入系列名称。
- en: Should the series name be the file name? This seems to be a bad idea because
    the series name may have spaces or other awkward punctuation.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 系列名称应该是文件名吗？这似乎是个糟糕的想法，因为系列名称可能包含空格或其他不规则的标点符号。
- en: It seems as though some additional metadata is required to preserve the series
    name and associate series names with file names. This would be an extra file,
    perhaps in JSON or TOML format, created as part of the extract operation.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 似乎还需要一些额外的元数据来保留系列名称并将系列名称与文件名关联起来。这可能是一个额外的文件，可能是作为提取操作的一部分创建的 JSON 或 TOML
    格式的文件。
- en: 5.3 Summary
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 摘要
- en: 'This chapter’s projects covered two following essential skills:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目涵盖了以下两个基本技能：
- en: Building SQL databases. This includes building a representative of a production
    database, as well as building a test database.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建SQL数据库。这包括构建生产数据库的代表性以及构建测试数据库。
- en: Extracting data from SQL databases.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 SQL 数据库中提取数据。
- en: This requires learning some SQL, of course. SQL is sometimes called the *lingua*
    *franca* of data processing. Many organizations have SQL databases, and the data
    must be extracted for analysis.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然需要学习一些 SQL。SQL 有时被称为数据处理领域的*通用语言*。许多组织都有 SQL 数据库，并且必须提取数据进行分析。
- en: Also important is learning to work in the presence of precious production data.
    It’s important to consider the naming conventions, file system paths, and permissions
    associated with database servers and the files in use. Attempting to extract analytic
    data is not a good reason for colliding with production operations.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的是学会在珍贵生产数据的存在下工作。考虑命名约定、文件系统路径以及与数据库服务器和正在使用的文件相关的权限非常重要。试图提取分析数据并不是与生产操作冲突的好理由。
- en: The effort required to write an acceptance test that uses an ephemeral database
    is an important additional skill. Being able to create databases for test purposes
    permits debugging by identifying problematic data, creating a test case around
    it, and then working in an isolated development environment. Further, having ephemeral
    databases permits examining changes to a production database that might facilitate
    analysis or resolve uncertainty in production data.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 编写使用临时数据库的验收测试所需的工作量是一项重要的额外技能。能够为测试目的创建数据库允许通过识别有问题的数据，围绕它创建测试用例，然后在隔离的开发环境中进行调试。此外，拥有临时数据库允许检查可能有助于分析或解决生产数据不确定性的生产数据库的更改。
- en: In the next chapter, we’ll transition from the bulk acquisition of data to understanding
    the relative completeness and usefulness of the data. We’ll build some tools to
    inspect the raw data that we’ve acquired.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从大量获取数据过渡到理解数据的相对完整性和有用性。我们将构建一些工具来检查我们获取的原始数据。
- en: 5.4 Extras
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 补充内容
- en: Here are some ideas for the reader to add to this project.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法供读者添加到这个项目中。
- en: 5.4.1 Consider using another database
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 考虑使用另一个数据库
- en: For example, MySQL or PostgreSQL are good choices. These can be downloaded and
    installed on a personal computer for non-commercial purposes. The administrative
    overheads are not overly burdensome.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MySQL或PostgreSQL是不错的选择。这些可以在个人计算机上下载并安装，用于非商业目的。管理开销并不算过分。
- en: It is essential to recognize these are rather large, complex tools. For readers
    new to SQL, there is a lot to learn when trying to install, configure, and use
    one of these databases.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到这些工具相当庞大且复杂是至关重要的。对于SQL新手来说，在尝试安装、配置和使用这些数据库时，有很多东西要学习。
- en: See [https://dev.mysql.com/doc/mysql-getting-started/en/](https://dev.mysql.com/doc/mysql-getting-started/en/)
    for some advice on installing and using MySQL.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://dev.mysql.com/doc/mysql-getting-started/en/](https://dev.mysql.com/doc/mysql-getting-started/en/)获取有关安装和使用MySQL的一些建议。
- en: See [https://www.postgresql.org/docs/current/tutorial-start.html](https://www.postgresql.org/docs/current/tutorial-start.html)
    for advice on installing and using PostgreSQL.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://www.postgresql.org/docs/current/tutorial-start.html](https://www.postgresql.org/docs/current/tutorial-start.html)获取有关安装和使用PostgreSQL的建议。
- en: In some cases, it makes sense to explore using a Docker container to run a database
    server on a virtual machine. See [https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058)
    for more about using Docker as a way to run complex services in isolated environments.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，探索在虚拟机上使用Docker容器运行数据库服务器是有意义的。请参阅[https://www.packtpub.com/product/docker-for-developers/9781789536058](https://www.packtpub.com/product/docker-for-developers/9781789536058)了解更多关于使用Docker作为在隔离环境中运行复杂服务的方法。
- en: See [https://dev.mysql.com/doc/refman/8.0/en/docker-mysql-getting-started.html](https://dev.mysql.com/doc/refman/8.0/en/docker-mysql-getting-started.html)
    for ways to use MySQL in a Docker container.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://dev.mysql.com/doc/refman/8.0/en/docker-mysql-getting-started.html](https://dev.mysql.com/doc/refman/8.0/en/docker-mysql-getting-started.html)获取在Docker容器中使用MySQL的方法。
- en: See [https://www.docker.com/blog/how-to-use-the-postgres-docker-official-image/](https://www.docker.com/blog/how-to-use-the-postgres-docker-official-image/)
    for information on running PostgreSQL in a Docker container.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://www.docker.com/blog/how-to-use-the-postgres-docker-official-image/](https://www.docker.com/blog/how-to-use-the-postgres-docker-official-image/)获取有关在Docker容器中运行PostgreSQL的信息。
- en: 5.4.2 Consider using a NoSQL database
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 考虑使用NoSQL数据库
- en: A NoSQL database offers many database features — including reliably persistent
    data and shared access — but avoids (or extends) the relational data model and
    replaces the SQL language.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: NoSQL数据库提供了许多数据库功能——包括可靠持久的数据和共享访问——但避免（或扩展）了关系数据模型，并取代了SQL语言。
- en: This leads to data acquisition applications that are somewhat like the examples
    in this chapter. There’s a connection to a server and requests to extract data
    from the server. The requests aren’t SQL `SELECT` statements. Nor is the result
    necessarily rows of data in a completely normalized structure.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致的数据获取应用程序与本章中的示例有些相似。有一个连接到服务器，并从服务器提取数据的请求。这些请求不是SQL `SELECT`语句。结果也不一定是完全规范化的数据结构中的数据行。
- en: For example, MongoDB. Instead of rows and tables, the data structure is JSON
    documents. See [https://www.packtpub.com/product/mastering-mongodb-4x-second-edition/9781789617870](https://www.packtpub.com/product/mastering-mongodb-4x-second-edition/9781789617870).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，MongoDB。数据结构不是行和表，而是JSON文档。请参阅[https://www.packtpub.com/product/mastering-mongodb-4x-second-edition/9781789617870](https://www.packtpub.com/product/mastering-mongodb-4x-second-edition/9781789617870)了解更多信息。
- en: The use of MongoDB changes data acquisition to a matter of locating the JSON
    documents and then building the desired document from the source data in the database.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 使用MongoDB将数据获取转变为定位JSON文档，然后从数据库中的源数据构建所需的文档。
- en: This would lead to two projects, similar to the two described in this chapter,
    to populate the “production” Mongo database with some data to extract, and then
    writing the acquisition program to extract the data from the database.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致两个项目，类似于本章中描述的两个项目，用于向“生产”Mongo数据库中填充一些要提取的数据，然后编写获取程序从数据库中提取数据。
- en: Another alternative is to use the PostgreSQL database with JSON objects for
    the data column values. This provides a MongoDB-like capability using the PostgreSQL
    engine. See [https://www.postgresql.org/docs/9.3/functions-json.html](https://www.postgresql.org/docs/9.3/functions-json.html)
    for more information on this approach.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是使用带有JSON对象的数据列值的PostgreSQL数据库。这提供了类似于MongoDB的功能，使用PostgreSQL引擎。请参阅[https://www.postgresql.org/docs/9.3/functions-json.html](https://www.postgresql.org/docs/9.3/functions-json.html)获取有关此方法的更多信息。
- en: 'Here are some common categories of NoSQL databases:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见的 NoSQL 数据库类别：
- en: Document databases
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档数据库
- en: Key-value stores
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 键值存储
- en: Column-oriented databases
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列式数据库
- en: Graph databases
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据库
- en: 'The reader is encouraged to search for representative products in these categories
    and consider the two parts of this chapter: loading a database and acquiring data
    from the database.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励读者在这些类别中搜索代表性产品，并考虑本章的两部分内容：加载数据库和从数据库获取数据。
- en: 5.4.3 Consider using SQLAlchemy to define an ORM layer
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 考虑使用 SQLAlchemy 定义一个 ORM 层
- en: In [*The Object-Relational Mapping (ORM) problem*](#x1-1280002) we talked about
    the ORM problem. In that section, we made the case that using a tool to configure
    an ORM package for an existing database can sometimes turn out badly.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*对象关系映射（ORM）问题*](#x1-1280002)中，我们讨论了 ORM 问题。在那个部分，我们提出了使用工具为现有数据库配置 ORM 包有时可能会出现问题的观点。
- en: This database, however, is very small. It’s an ideal candidate for learning
    about simple ORM configuration.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个数据库非常小。它是学习简单 ORM 配置的理想候选者。
- en: We suggest starting with the SQLAlchemy ORM layer. See [https://docs.sqlalchemy.org/en/20/orm/quickstart.html](https://docs.sqlalchemy.org/en/20/orm/quickstart.html)
    for advice on configuring class definitions that can be mapped to tables. This
    will eliminate the need to write SQL when doing extracts from the database.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议从 SQLAlchemy ORM 层开始。请参阅[https://docs.sqlalchemy.org/en/20/orm/quickstart.html](https://docs.sqlalchemy.org/en/20/orm/quickstart.html)以获取有关配置可映射到表的类定义的建议。这将消除从数据库进行提取时编写
    SQL 的需求。
- en: There are other ORM packages available for Python, also. The reader should feel
    free to locate an ORM package and build the extraction project in this chapter
    using the ORM data model.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python，也有其他 ORM 包可用。读者可以自由地定位一个 ORM 包，并使用 ORM 数据模型在本章中构建提取项目。
