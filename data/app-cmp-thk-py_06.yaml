- en: '*Chapter 5*: Exploring Problem Analysis'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第5章*：探索问题分析'
- en: In this chapter, we will explore problem analysis in depth while using some
    of what we have been learning, such as logical reasoning, Boolean logic, and algorithmic
    design. We will work through problem definition, decomposition, and analysis in
    this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将深入探讨问题分析，同时运用我们所学的一些知识，比如逻辑推理、布尔逻辑和算法设计。在这一章中，我们将通过问题定义、分解和分析来解决问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding the problem definitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解问题定义
- en: Learning to decompose problems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习分解问题
- en: Analyzing problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析问题
- en: In order to further understand problems, we'll need to look at a more complex
    problem and define it so we can begin the algorithmic design process. In this
    chapter, you will learn how to define problems and decompose them in order to
    design algorithms. In doing so, you'll also learn about dictionaries in Python.
    After reading this chapter, you'll be able to use the computational thinking process
    in order to design and create an algorithm that addresses complex problems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解问题，我们需要看一个更复杂的问题，并定义它，以便开始算法设计过程。在本章中，您将学习如何定义问题并分解问题，以便设计算法。在这个过程中，您还将学习Python中的字典。阅读完本章后，您将能够使用计算思维过程来设计和创建解决复杂问题的算法。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the latest version of Python to run the codes in this chapter.
    You will find the full source code used in this chapter here: [https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter05](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter05)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要最新版本的Python来运行本章的代码。您可以在此处找到本章使用的完整源代码：[https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter05](https://github.com/PacktPublishing/Applied-Computational-Thinking-with-Python/tree/master/Chapter05)
- en: Understanding the problem definitions
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解问题定义
- en: 'As we discussed in [*Chapter 2*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043),
    *Elements of Computational Thinking*, computational thinking uses four elements
    in order to solve problems:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[*第2章*](B15413_02_Final_SK_ePub.xhtml#_idTextAnchor043)中讨论的，*计算思维的要素*，计算思维使用四个要素来解决问题：
- en: '**Problem decomposition**: This is the process of breaking down data.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题分解**：这是将数据分解的过程。'
- en: '**Pattern recognition**: This is the process of finding similarities or patterns.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式识别**：这是找到相似性或模式的过程。'
- en: '**Abstraction**: This element deals with generalizing the pattern.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抽象**：这个元素处理泛化模式。'
- en: '**Algorithm design**: This is where we define the set of instructions for the
    solution to the problem.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**算法设计**：这是我们为解决问题定义一组指令的地方。'
- en: In this section, in order to learn more about how to analyze problems, we're
    going to analyze a larger problem and work through the steps needed to create
    the algorithm. To be able to create algorithms, it is imperative that we analyze
    the problems and clearly identify what we are trying to solve. That is, *what
    is our algorithm for?* *Why do we need to build it?* Looking at the decomposition
    of problems and then defining what we need will provide us with a better algorithm
    at the end.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，为了更多地了解如何分析问题，我们将分析一个更大的问题，并经过需要创建算法的步骤。为了能够创建算法，我们必须分析问题，并清楚地确定我们要解决什么问题。也就是说，*我们的算法是为了什么？*
    *为什么我们需要构建它？* 查看问题的分解，然后定义我们需要的东西，将在最后为我们提供更好的算法。
- en: We will work through a problem in the next section.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中解决一个问题。
- en: Problem 5A – Building an online store
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题5A – 创建一个在线商店
- en: 'Let''s take a look at the following problem. You are starting an online store.
    It''s in its infancy, but you''ll have three different types of item available.
    They are keychains, water bottles, and t-shirts. For this particular problem,
    we will go through a three-step process:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看以下问题。您正在开设一家在线商店。它还处于起步阶段，但您将有三种不同类型的商品可供选择。它们是钥匙扣、水瓶和T恤。对于这个特定的问题，我们将经历一个三步过程：
- en: '**Making assumptions**'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**做出假设**'
- en: '**Things to consider**'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**需要考虑的事项**'
- en: '**Building a dictionary**'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建字典**'
- en: We will look the preceding steps in the upcoming sections.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的部分中看到前面的步骤。
- en: Making assumptions
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 做出假设
- en: 'Let me state some assumptions about this store that we are going to use:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我陈述一些关于我们将要使用的这家商店的假设：
- en: This is a company that provides items for clients to share with their customers.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一家为客户提供商品的公司，供客户与他们的客户分享。
- en: Each item can have a logo and/or personalized information, such as name, email,
    and phone number.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个项目都可以有标志和/或个性化信息，比如姓名、电子邮件和电话号码。
- en: We will now move on to the next section, which is about things to consider.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将进入下一节，讨论需要考虑的事项。
- en: Things to consider
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 需要考虑的事项
- en: 'Now let''s take a look at some of the things that you''ll need to think about
    before we even start working on an algorithm:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在开始制定算法之前，看看您需要考虑的一些事项：
- en: '*Are the items personalized?*'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*商品是否个性化？*'
- en: '*Will personalization be charged by character, line, or item?*'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*个性化是否按字符、行或项目收费？*'
- en: '*Will the price be fixed or will it change when customers make bulk purchases?*'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*价格是固定的，还是当客户批量购买时会发生变化？*'
- en: '*Will there be discounts if a client orders more than one type of item?*'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*如果客户订购多种类型的商品，是否会有折扣？*'
- en: '*How much is the base price-point for each item?*'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个项目的基准价格是多少？*'
- en: The preceding points are not the only questions that we could go over. But they're
    the questions that we'll start taking a look at when we decompose the problem.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的观点并不是我们可以讨论的唯一问题。但当我们分解问题时，这些是我们将开始研究的问题。
- en: Before we do that, let's talk about how we can include the information in a
    program for each of the items. If you recall from [*Chapter 3*](B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056),
    *Understanding Algorithms and Algorithmic Thinking*, we can use a dictionary in
    **Python** to save our menu of items. In this case, we have keychains, water bottles,
    and t-shirts.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之前，让我们讨论一下如何在程序中为每个项目包含信息。如果你还记得[*第3章*]（B15413_03_Final_SK_ePub.xhtml#_idTextAnchor056），*理解算法和算法思维*，我们可以使用**Python**中的字典来保存我们的商品菜单。在这种情况下，我们有钥匙扣、水瓶和T恤。
- en: Building a dictionary
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 建立一个字典
- en: 'Before we take a look at the complexities presented by this problem and decomposing
    that information, we can build our own dictionary. We can make it so that the
    price for each item in the dictionary is the base price (the price that does not
    contain any customizations or discounts), as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看这个问题所提出的复杂性并分解信息之前，我们可以建立自己的字典。我们可以使字典中每个项目的价格都是基础价格（不包含任何定制或折扣的价格），如下所示：
- en: 'Cost per keychain: $0.75'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个钥匙扣的成本：$0.75
- en: 'Cost per t-shirt: $8.50'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T恤成本：$8.50
- en: 'Cost per water bottle: $10.00'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个水瓶的成本：$10.00
- en: 'Now let''s build the dictionary. Remember that you can do this without the
    dictionary, but creating a dictionary allows you to update the pricing, if necessary,
    at a later date. You can also create functions to solve this problem. We are using
    logic and the dictionary for this problem. The following code shows you how to
    build a dictionary:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们建立字典。记住，你可以在没有字典的情况下做到这一点，但是创建一个字典可以让你在以后有必要时更新定价。你也可以创建函数来解决这个问题。我们正在使用逻辑和字典来解决这个问题。以下代码向你展示了如何建立一个字典：
- en: ch5_storeDictionary.py
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_storeDictionary.py
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the preceding code snippet, keep in mind that the `print()` function is
    not needed here, but I use it often in order to ensure that the code is working
    properly while I continue to build the algorithms. Also notice that the names
    of the variables—`keychain`, `tshirt`, and `bottle`—are simplified.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，请记住这里不需要`print()`函数，但我经常使用它来确保代码在我继续构建算法的同时能正常工作。还要注意变量的名称——`keychain`、`tshirt`和`bottle`——都是简化的。
- en: 'Here''s what that output will look like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是输出的样子：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What the output shows me is that the prices are saved correctly for each of
    the variables. I'm using that `print` function to test my dictionary and ensure
    that it runs correctly before I start working on what I need from that dictionary.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示给我的是每个变量的价格都被正确保存了。我使用`print`函数来测试我的字典，并确保它在我开始从字典中获取所需内容之前能够正确运行。
- en: This helps us when we are writing the code and reuse the variables in multiple
    areas of that code. Having these simple and easy-to-identify variables will allow
    us to change and add to the algorithm without adding errors.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于我们在编写代码时重复使用变量。拥有这些简单易识别的变量将允许我们在不添加错误的情况下更改和添加算法。
- en: In this section, we learned that the problem analysis and definitions help us
    identify how to best design our solution. Remember, when we are looking at problems,
    the definitions we use, both before we write the algorithm and within the algorithm,
    are critical for our design and final product. Let's now look at the decomposition
    of the problem.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解到问题分析和定义帮助我们确定如何最好地设计我们的解决方案。记住，当我们面对问题时，我们在编写算法之前和算法中使用的定义对于我们的设计和最终产品至关重要。现在让我们来看看问题的分解。
- en: Learning to decompose problems
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习分解问题
- en: When we decompose problems, we're identifying what we need the algorithm to
    provide us with. The end user will need to see something seamless. Look at the
    flowchart in *Figure 5.1*; this is a basic decision-making flowchart to help us
    design our algorithm.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分解问题时，我们正在确定算法需要为我们提供什么。最终用户需要看到一些无缝的东西。看看*图5.1*中的流程图；这是一个基本的决策流程图，帮助我们设计我们的算法。
- en: 'Let''s make another assumption first, that is, if the user enters more than
    10, the price will be lower. We''re only going to do less than 10 or more than
    or equal to 10 in this case. However, if you needed to subdivide this further,
    you can add more cases, such as the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先让我们做另一个假设，即，如果用户输入超过10，价格将会更低。在这种情况下，我们只会做少于10或大于或等于10。然而，如果你需要进一步细分，你可以添加更多情况，比如以下情况：
- en: Less than or equal to 10
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 少于或等于10
- en: More than 10 and less than or equal to 50
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超过10但小于或等于50
- en: More than or equal to 50
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 50或更多
- en: You can have as many cases as you need. For the purposes of this algorithm,
    we're going to keep it to two cases, since we also have to include personalization
    costs and we don't want to create an overly complicated algorithm.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以有尽可能多的情况。对于这个算法，我们将保持两种情况，因为我们还必须包括个性化成本，我们不想创建一个过于复杂的算法。
- en: 'The following diagram shows you the flowchart for the algorithm:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下图向你展示了算法的流程图：
- en: '![Figure 5.1 – Initial decision-making flowchart'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 初始决策流程图'
- en: '](image/Figure_5.1_B15413.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.1_B15413.jpg)'
- en: Figure 5.1 – Initial decision-making flowchart
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 初始决策流程图
- en: As you can see in the preceding diagram, this isn't a completed flowchart. After
    we make the decisions about the t-shirts, we need to move on to the bottles. How
    we write the algorithm will depend on what we'd like to output. Right now, we're
    providing the user the information they'd get when they check out of the online
    store that you created.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的图表中所看到的，这不是一个完成的流程图。在我们做出关于T恤的决定之后，我们需要转向瓶子。我们如何编写算法将取决于我们想要输出什么。现在，我们提供给用户的是当他们结账离开你创建的在线商店时会得到的信息。
- en: In the next section, let's use the preceding flowchart to create an algorithm.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们使用前面的流程图来创建一个算法。
- en: Converting the flowchart into an algorithm
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将流程图转换为算法
- en: 'The diagram in *Figure 5.1* allows us to look at the decision-making process
    for the algorithm we''re writing. We''ll want to look at the following key points
    when writing the algorithm:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1*中的图表使我们能够查看我们正在编写的算法的决策过程。在编写算法时，我们将要关注以下关键点：'
- en: '**Dictionary and input**: Input can be within the algorithm or user-entered;
    dictionaries are built within the algorithm. This means, to use a dictionary,
    we have to define it in our algorithm before we are able to use it.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**字典和输入**：输入可以在算法内部或由用户输入；字典是在算法内部构建的。这意味着，要使用字典，我们必须在算法中定义它，然后才能使用它。'
- en: '**Cost**: This is the base cost for each item.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本**：这是每件物品的基本成本。'
- en: '**Personalization costs**: This is added to the base cost.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**个性化成本**：这是添加到基本成本中的成本。'
- en: We'll now look at the preceding points in detail in the upcoming sections.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在接下来的部分详细查看前面的要点。
- en: Building a dictionary and giving inputs
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建字典并提供输入
- en: 'Before we add any of the complications, let''s look at how to grab the price
    of each item and use it at the base price. We''ll need a count for the number
    of each item. The following code shows you this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何复杂性之前，让我们看看如何获取每件物品的价格并将其用作基本价格。我们需要计算每种物品的数量。以下代码向您展示了这一点：
- en: ch5_storeQuantities.py
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_storeQuantities.py
- en: '[PRE2]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: From the preceding code snippet, notice that we added the variables under the
    dictionary. This will be useful later. These variables are named `choicekey`,
    `choicetshirt`, and `choicebottle`. Naming the variables allows us to return to
    them and change code, as needed. In this case, each variable asks for input from
    the person running the program in order to get the number of keychains, t-shirts,
    and bottles they are ordering. Again, there are multiple ways to tackle this problem,
    but we're using what we've learned so far to create an algorithmic solution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中可以看到，我们在字典下添加了变量。这将在以后很有用。这些变量被命名为`choicekey`、`choicetshirt`和`choicebottle`。命名变量使我们能够返回并根据需要更改代码。在这种情况下，每个变量都要求从运行程序的人那里获取输入，以获取他们订购的钥匙扣、T恤和水瓶的数量。再次强调，解决这个问题有多种方法，但我们正在利用到目前为止学到的知识来创建一个算法解决方案。
- en: 'When we run the previous code for `3` keychains, `0` t-shirts, and `10` water
    bottles, this is our output:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们对`3`个钥匙扣、`0`件T恤和`10`个水瓶运行前面的代码时，这是我们的输出：
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, we have a program that takes user input, then confirms to the
    user the choices they have made for each of the items.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，我们有一个接受用户输入的程序，然后向用户确认他们为每件物品所做的选择。
- en: Let's see the next section about cost.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看关于成本的下一节。
- en: Making changes to the cost
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对成本进行更改
- en: 'Now let''s add the changes in cost. Let''s say that if a customer is purchasing
    over 10 items, then the updated costs are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加成本的变化。假设如果顾客购买超过10件物品，那么更新后的成本如下：
- en: 'Keychains: $ 0.65'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 钥匙扣：$0.65
- en: 'T-shirts: $ 8.00'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T恤：$8.00
- en: 'Water bottles: $ 8.75'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水瓶：$8.75
- en: 'To make the preceding changes, we can make the program update the difference
    in cost, which is shown in the following code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行前述更改，我们可以让程序更新成本差异，如下所示：
- en: ch5_storeCost.py
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_storeCost.py
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have updated the code, I''d like to print out my progress to make
    sure that the code is working properly and changes take place. In this case, I
    wanted to make sure that the costs would update if I had totals greater than 10\.
    (That is, when a customer orders more than 10 of an item, it updates the cost
    for each item to the lower cost.) The output of the preceding code is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更新了代码，我想打印出我的进展，以确保代码正常工作并进行更改。在这种情况下，我想确保如果总数大于10，成本会更新。(也就是说，当顾客订购超过10件物品时，它会将每件物品的成本更新为更低的成本。)前面代码的输出如下：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now see from the preceding output that the dictionary has updated the
    values based on the totals the user provided.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以从前面的输出中看到，字典已根据用户提供的总数进行了更新。
- en: 'Now we need to go ahead and provide the cost. We can provide the total item
    cost or the total cost of the full purchase, or both (let''s do both). Take a
    look at the following code snippet:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要继续并提供成本。我们可以提供总物品成本或整个购买的总成本，或两者（让我们两者都做）。看一下以下代码片段：
- en: ch5_storeTotals.py
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_storeTotals.py
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding code snippet is added so that we can have a `print` statement
    to confirm the input from the user. By printing that statement at the end of the
    code, we are checking with the user whether the program can read the numbers correctly,
    and whether the user entered the right numbers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段被添加，以便我们可以有一个`print`语句来确认用户的输入。通过在代码末尾打印该语句，我们正在与用户核对程序是否能正确读取数字，以及用户是否输入了正确的数字。
- en: 'We can continue the code to add the costs per item:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以继续编写代码以添加每件物品的成本：
- en: ch5_storeTotals.py
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_storeTotals.py
- en: '[PRE7]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `print` statements at the end of the preceding code snippet provide the
    breakdown of each item total as well as the full order total. After asking for
    the input for all items, the code then prints the sub-totals for the cost of each
    of the items. The result of the preceding code is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段的末尾的`print`语句提供了每件物品的总成本以及整个订单的总成本的细目。在询问所有物品的输入后，代码然后打印每件物品成本的小计。前面代码的结果如下：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have the totals of the items without personalization, we need to
    be able to take into account the costs of that personalization, if ordered.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了没有个性化的物品总数，我们需要考虑如果订购了个性化，需要考虑个性化的成本。
- en: In the next section, let's take a look at what personalization costs are and
    the decisions we'll need to make before we move on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，让我们看看个性化成本是多少，以及在继续之前我们需要做出的决定。
- en: Adding personalization
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加个性化
- en: 'For now, let''s limit the personalization of keychains, t-shirts, and water
    bottles to binary questions, that is, either the user wants personalization or
    not. We are not looking at tiered costs of personalization, which you may have
    seen. If you wanted to add tiers, you''d need to make more decisions, such as
    cost of choosing fonts, length of the personalization, and so on. We''ll forgo
    those for now, but feel free to add to this code in order to address those kinds
    of customizations. Let''s add another assumption for the personalization:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们将钥匙扣、T恤和水瓶的个性化限制为二进制问题，即用户要么想要个性化，要么不想要。我们不考虑个性化的分层成本，这可能是您见过的。如果您想要添加分层，您需要做出更多决策，比如选择字体的成本，个性化的长度等等。目前我们不考虑这些，但随时可以添加到这段代码中以解决这些类型的自定义。让我们为个性化添加另一个假设：
- en: $1.00 for the keychains
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1美元的钥匙扣
- en: $5.00 for the t-shirts
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T恤5美元
- en: $7.50 for the water bottles
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 水瓶7.50美元
- en: We'll need to create the preceding conditions and then implement them into our
    variables. Let's look at the code in parts. The following file contains each of
    the parts we'll break down.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建前述条件，然后将它们实施到我们的变量中。让我们逐部分查看代码。以下文件包含我们将分解的每个部分。
- en: 'Recall that our algorithm first asked for input for the number of items they
    were purchasing. The following code snippet takes user input in order to take
    personalization into account:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们的算法首先要求输入购买物品的数量。以下代码片段获取用户输入，以便考虑个性化：
- en: ch5_storePersonalize.py
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_storePersonalize.py
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code snippet asks the user the binary questions on personalization.
    After grabbing the input, the code then makes some decisions based on the user
    input and defines the `keychain`, `tshirt`, and `bottle` variables and the totals
    for the choices. The following snippet then uses the totals to print out the information
    for each item purchased as well as the final total:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段询问用户关于个性化的二进制问题。在获取输入后，代码根据用户输入做出一些决策，并定义`keychain`、`tshirt`和`bottle`变量以及选择的总数。接下来的代码片段使用总数打印出每个购买物品的信息以及最终总数：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: From the preceding code, notice that the `keychain`, `tshirt`, and `bottle`
    variables are defined after all our customizations based on total numbers and
    personalization. Remember that in algorithm design, the order matters. If we locate
    those variables earlier in the program, the conditions, such as personalization,
    that follow will not affect those variables.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以注意到，`keychain`、`tshirt`和`bottle`变量是在基于总数和个性化的自定义之后定义的。记住，在算法设计中，顺序很重要。如果我们在程序中较早地定位这些变量，随后的个性化等条件将不会影响这些变量。
- en: So, to be able to get everything we need for our variables, we need to define
    them after defining some of the conditions that affect them, such as customization.
    Take a look at the preceding code to note where the variables are. Feel free to
    play with the code by changing where you define the variables to see whether your
    end results change.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了能够获得我们变量所需的一切，我们需要在定义一些影响它们的条件之后定义它们，比如自定义。看一下前面的代码，注意变量的定义位置。随时可以通过更改变量定义的位置来玩弄代码，看看最终结果是否会改变。
- en: 'Here''s a visual flowchart with the keychain decision-making process:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个具有钥匙扣决策过程的视觉流程图：
- en: '![Figure 5.2 – Keychain decision-making flowchart'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.2 - 钥匙扣决策流程'
- en: '](image/Figure_5.2_B15413.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.2_B15413.jpg)'
- en: Figure 5.2 – Keychain decision-making flowchart
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 - 钥匙扣决策流程
- en: As you can see from the preceding diagram, this is only for **Keychains**. We
    need to repeat the process for the other two variables. In the diagram, you can
    see the decision-making process for the item. First, the user indicates the number
    of items bought, then whether they will personalize them or not.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从前面的图表中所看到的，这仅适用于**钥匙扣**。我们需要为另外两个变量重复这个过程。在图表中，您可以看到物品的决策过程。首先，用户指示购买的物品数量，然后指示他们是否会个性化。
- en: Depending on each answer, the total is calculated by the program. For example,
    if there is no personalization, the total is calculated sooner in the decision-making
    tree. We can rewrite this program using functions (as I mentioned before) to simplify
    some of the processes. For now, we are focusing on learning how to break down
    problems, analyze conditions, and how to design algorithms that take into account
    multiple decisions. Remember to complete the diagram for the other items so that
    the decision-making process is easier to code when designing the algorithm.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 根据每个答案，程序计算总数。例如，如果没有个性化，总数会在决策树中更早地计算出来。我们可以使用函数（如我之前提到的）重写这个程序，以简化一些过程。目前，我们专注于学习如何分解问题，分析条件，以及如何设计算法以考虑多个决策。记得完成其他物品的图表，以便在设计算法时决策过程更容易编码。
- en: In this section, we learned how to use a flowchart to create an algorithm. We
    also learned about building a dictionary for our algorithm.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用流程图创建算法。我们还学习了为我们的算法构建字典。
- en: Before we move on, let's look at the process of analyzing problems. While we
    were creating this algorithm, we did that while we decomposed the problem. However,
    there are some key components of problem analysis that we should consider before
    our next chapter.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们看看分析问题的过程。在创建这个算法时，我们分解了问题。然而，在我们下一章之前，有一些问题分析的关键组成部分值得我们考虑。
- en: Analyzing problems
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析问题
- en: 'When analyzing problems, there are some steps that we can keep in mind to help
    us ensure that we are creating the best possible algorithm:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析问题时，有一些步骤可以帮助我们确保我们正在创建最佳算法：
- en: Clearly read and understand the problem.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清楚地阅读和理解问题。
- en: Identify the main purpose of the solution.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定解决方案的主要目的。
- en: Identify the constraints of the problem.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定问题的约束。
- en: Identify the decision-making flow.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定决策流程。
- en: Establish the possible algorithms that could solve the problem.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立可能解决问题的算法。
- en: Identify the best possible algorithm tools for the problem.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为问题确定最佳的算法工具。
- en: Test the algorithm pieces frequently.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常测试算法片段。
- en: Verify that the algorithm provides the solution for the identified problem.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证算法是否提供了已确定问题的解决方案。
- en: 'If we go back to our problem, we went through this process throughout the chapter:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回到我们的问题，我们在整个章节中都经历了这个过程：
- en: We had an online store with three items.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们有一个有三种商品的在线商店。
- en: Item cost was dependent on quantity purchased.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品成本取决于购买数量。
- en: Item price was also dependent on personalization customizations.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商品价格也取决于个性化定制。
- en: We created flowcharts to help us identify the decision process and how to code
    it.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了流程图来帮助我们确定决策过程以及如何编写代码。
- en: We verified our code through code lines that allowed us to check whether the
    algorithm was producing the correct response multiple times.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过代码行验证了我们的代码，这些代码行允许我们多次检查算法是否产生了正确的响应。
- en: We revisited and reordered pieces of code, as needed.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据需要重新访问和重新排序代码片段。
- en: We verified that the algorithm's output was in line with the problem we had
    identified.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们验证了算法的输出是否符合我们所确定的问题。
- en: The preceding process bears repeating, that is, this is not a linear process.
    Sometimes we'll write an algorithm and then revisit the decision flowchart, make
    adjustments, then tackle the algorithm again.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的过程需要重复，也就是说，这不是一个线性过程。有时我们会编写一个算法，然后重新访问决策流程图，进行调整，然后再次处理算法。
- en: The need for analyzing our problems at multiple *stopping points* becomes even
    clearer when we are looking at larger problems. *Should we write hundreds of lines
    of code before testing?* No! Imagine having 300 lines of code, only to find an
    error on *line 20* that is carried forward throughout the rest of the algorithm.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理更大的问题时，分析我们的问题在多个*停止点*变得更加清晰。*我们应该在测试之前写上几百行代码吗？* 不！想象一下有300行代码，只在*第20行*发现一个错误，这个错误会一直传递到算法的其余部分。
- en: Testing at every possible progress point will allow us to catch the small mistakes
    that can cost us in the long run. Remember, it's almost impossible to write a
    perfect algorithm on the first try. We all make mistakes, small and large, so
    it is important that we continue to test and analyze our progress.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个可能的进度点进行测试将使我们能够发现长期成本的小错误。记住，第一次几乎不可能编写完美的算法。我们都会犯错误，无论大小，所以继续测试和分析我们的进展非常重要。
- en: Let's look at one more problem and go through the process again before leaving
    this chapter.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开本章之前，让我们再看一个问题并再次经历这个过程。
- en: Problem 5B – Analyzing a simple game problem
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题5B - 分析一个简单的游戏问题
- en: You want to design a number guessing game. The user has to guess a random number.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你想设计一个猜数字游戏。用户必须猜一个随机数。
- en: 'Let''s start by defining our problem, which in this case is a game. Let''s
    identify the known information:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从定义我们的问题开始，这种情况下是一个游戏。让我们确定已知信息：
- en: The computer will need to randomly select a number.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机需要随机选择一个数字。
- en: The user will need to input a number.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户需要输入一个数字。
- en: The computer will have to check whether the input from the user matches the
    randomly generated number.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机将不得不检查用户输入是否与随机生成的数字匹配。
- en: '*Now, that''s not enough! If I don''t match on the first try, do I lose? How
    many chances do I get? Is the random number a number between 1 and 10 or between
    1 and 500?* We''re going to have to make some decisions before we start coding
    this. Let''s add some parameters:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在，这还不够！如果我第一次猜不中，我会输吗？我有多少次机会？随机数是1到10之间还是1到500之间？* 在我们开始编码之前，我们需要做一些决定。让我们添加一些参数：'
- en: The number is between 1 and 100.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字在1到100之间。
- en: The user will get 5 chances to guess.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户将有5次猜测的机会。
- en: The computer will tell the user if the answer is too high or too low.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算机会告诉用户答案是太高还是太低。
- en: 'Now that we have those parameters, we can create a decision flowchart:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些参数，我们可以创建一个决策流程图：
- en: '![Figure 5.3 – Decision flowchart for guessing game'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 - 猜数字游戏的决策流程图'
- en: '](image/Figure_5.3_B15413.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '](image/Figure_5.3_B15413.jpg)'
- en: Figure 5.3 – Decision flowchart for guessing game
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 - 猜数字游戏的决策流程图
- en: From the preceding diagram you can see that the chart is not complete. That's
    because we will use some logic to make the process repeat 5 times. We'll get into
    that in a moment. For now, notice the decisions. First, a number is generated
    by the program (but is not revealed). The user then inputs a guess, which is either
    correct or incorrect. If it's correct, then the user wins the game. If it's incorrect,
    then the program lets the user know if the answer was too low or too high and
    asks for a new guess. The process will then repeat itself, as needed. Now, let's
    write the algorithm.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的图表中可以看出，图表并不完整。这是因为我们将使用一些逻辑使过程重复5次。我们稍后会详细介绍。现在，请注意决策。首先，程序生成一个数字（但不会显示）。然后用户输入一个猜测，要么正确，要么错误。如果正确，用户就赢得了游戏。如果不正确，程序会告诉用户答案是太低还是太高，并要求新的猜测。然后过程将根据需要重复。现在，让我们编写算法。
- en: 'First, let''s generate the random number and get the user to guess it. Add
    a `print()` function for both the randomly generated number and the input from
    the user so that you can see that the information is working properly. Remember,
    we''ll take those out later, but it''s important to keep checking and rechecking
    our code as part of our problem analysis process. The following code will do the
    same:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们生成随机数并让用户猜测。为随机生成的数字和用户输入添加`print()`函数，以便您可以看到信息是否正常工作。记住，我们以后会把它们拿掉，但是反复检查我们的代码作为问题分析过程的一部分非常重要。以下代码将执行相同的操作：
- en: ch5_guess1.py
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_guess1.py
- en: '[PRE11]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You'll notice from the preceding code, the imported `random` module. We also
    imported it as `rand`. That's just to save time and space. When you import a module
    in Python, you can rename it. The `random` module gives us a way to generate the
    number in the range that we had selected.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到前面的代码中导入了`random`模块。我们还将其导入为`rand`。这只是为了节省时间和空间。在Python中，当你导入一个模块时，你可以给它重命名。`random`模块给了我们一个在我们选择的范围内生成数字的方法。
- en: The `rand.randint(1, 100)` code line includes `1` and `100`. These are the endpoints,
    or limits for the random number generator. The `rand` function refers to the module,
    as mentioned, while *randint(a, b)* refers to a random integer between *a* and
    *b* (including *a* and *b*).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`rand.randint(1, 100)`代码行包括`1`和`100`。这些是随机数生成器的端点或限制。`rand`函数是指模块，如前所述，而*randint(a,
    b)*指的是*a*和*b*之间的随机整数（包括*a*和*b*）。'
- en: 'Run the code a few times to see how the number generated by the computer changes
    each time. The following points show three test cases:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 多次运行代码，看看计算机生成的数字每次都会发生变化。以下是三个测试案例：
- en: 'The following is test case 1 of the preceding code:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是前面代码的测试案例1：
- en: '[PRE12]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As you can see from the preceding output, `27` is the computer-generated random
    number and `10` is what the user entered.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从前面的输出中看到的，`27`是计算机生成的随机数，而`10`是用户输入的数字。
- en: 'The following is test case 2 results of the previous code:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是前面代码的测试案例2的结果：
- en: '[PRE13]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see from the preceding output of the code, `68` is the value of the
    `compnumber` variable, while the user (me) entered the number `65`. So close,
    yet so far!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如你从前面代码的输出中看到的，`68`是`compnumber`变量的值，而用户（我）输入的数字是`65`。如此接近，但又如此遥远！
- en: 'The following is test case 3 output:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是测试案例3的输出：
- en: '[PRE14]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see from the preceding output, the computer chose the number `50`,
    while the user entered `23`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你从前面的输出中看到的，计算机选择了数字`50`，而用户输入了`23`。
- en: For our final version of this game, we won't print out the computer number.
    That would be cheating! Right now, we're just testing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们游戏的最终版本，我们不会打印出计算机的数字。那是作弊！现在，我们只是在测试。
- en: 'Let''s go ahead and add one condition—whether or not the first guess is correct.
    To do so, we''ll have to verify `compnumber == usernumber`. We''re going to test
    this again before going into the additional repetitions and logic, so we''ll just
    say if it''s true, then you win; if it''s false, then you lose:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再添加一个条件，即第一次猜测是否正确。为此，我们将必须验证`compnumber == usernumber`。在进入额外的重复和逻辑之前，我们将再次测试这一点，所以我们只需说如果是真的，那么你赢了；如果是假的，那么你输了：
- en: ch5_guess2.py
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_guess2.py
- en: '[PRE15]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s just say I lost on the first try when I ran it. I''m not going to run
    this until I do win, however, because that could take, well, 100 tries or more.
    Here''s what that looks like when you run the program:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们说我在第一次尝试时失败了。但是我不会放弃，因为这可能需要100次或更多次。当你运行程序时，它看起来像这样：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now let's talk about repeating a line of code. We're giving the user 5 guesses.
    *How can we do that in Python?*
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈重复一行代码。我们给用户5次猜测。*我们如何在Python中做到这一点？*
- en: 'In Python, we can use `for` loops to iterate through code. We know we get 5
    guesses, so we''ll have to use something like `for number in range(5):` to get
    us started with the logic, which is shown in the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以使用`for`循环来迭代代码。我们知道我们有5次猜测，所以我们将使用类似`for number in range(5):`这样的东西来开始我们的逻辑，如下面的代码所示：
- en: ch5_guess3.py
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_guess3.py
- en: '[PRE17]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From the preceding code, *did you notice that* `i` *variable?* We are using
    that variable so that the user knows how many guesses they have left. So if we
    had 5 guesses, the code will start at `i = 5`; then, if the user is wrong, it
    will use the line `i = i – 1`, which alerts the user they now have 4 guesses left,
    and so on. Take a look at what happens when we run that program:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中，*你注意到*`i`*变量了吗？*我们使用这个变量，这样用户就知道他们还剩下多少次猜测。所以如果我们有5次猜测，代码将从`i = 5`开始；然后，如果用户猜错了，它将使用`i
    = i - 1`这一行，提醒用户他们现在还剩下4次猜测，依此类推。看看我们运行该程序时会发生什么：
- en: '[PRE18]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we''re not really being fair. As mentioned earlier, we want to give the
    user a hint each time they attempt a guess. Now that we have the condition checking
    whether they are equal, we can add an `elif` condition to check whether it''s
    larger or smaller. The following code shows this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们并不是真的很公平。如前所述，我们希望每次用户尝试猜测时都给出一个提示。现在我们有了检查它们是否相等的条件，我们可以添加一个`elif`条件来检查它是大还是小。下面的代码显示了这一点：
- en: ch5_guess4.py
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: ch5_guess4.py
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code now provides some feedback to the user. If the number was
    greater than the computer-generated number, the user receives the feedback `'Your
    number is too large!'`, and if the user number is less than the computer-generated
    number, then they receive the feedback `'Your number is too small!'`. We also
    used an `exit()` code if the user wins. That's because we want the game to stop
    when we win.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码现在为用户提供了一些反馈。如果数字大于计算机生成的数字，用户会收到反馈`'你的数字太大了！'`，如果用户的数字小于计算机生成的数字，那么他们会收到反馈`'你的数字太小了！'`。如果用户赢了，我们还使用了`exit()`代码。这是因为我们希望游戏在我们赢了时停止。
- en: 'This gives us a fighting chance to win this game, take a look at what the output
    looks like now:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这给了我们一个战胜这个游戏的机会，看看现在的输出是什么样子：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now look at what happens when we lose the game:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看当我们输掉游戏时会发生什么：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As you can see, you get a different final message. I confess it took me quite
    a few tries to win a game so I could get the output that follows, but you can
    see the game where the second guess was correct:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，你得到了一个不同的最终消息。我承认我尝试了很多次才赢得了一场比赛，所以我才得到了下面的输出，但你可以看到第二次猜测是正确的游戏：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We are going to stop this game with that last algorithm. We could actually
    make this game better if we wanted to, but it does the job that we needed it to
    do. Some of the changes that you could consider making to your game are as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用最后一个算法来停止这个游戏。如果我们愿意，我们实际上可以让这个游戏变得更好，但它完成了我们需要它完成的工作。你可以考虑对你的游戏进行一些改变，如下所示：
- en: Adding an option that alerts the user of a number already guessed.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个选项，提醒用户已经猜过的数字。
- en: Adding an option that alerts the user that they ignored a previous hint (so
    if the user gave a number that was too small and gave one that was even smaller,
    the computer would alert them).
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加一个选项，提醒用户忽略了先前的提示（所以如果用户给出一个太小的数字，然后给出一个更小的数字，电脑会提醒他们）。
- en: 'I''m sure there are more customizations that you could try. But for now, we
    went through that problem and followed the points that we should consider when
    analyzing problems:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信你可以尝试更多的定制。但现在，我们经历了那个问题，并遵循了我们在分析问题时应该考虑的要点：
- en: We read and understood the problem.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们阅读并理解了问题。
- en: We identified the purpose—creating a computer player versus user player guessing
    game.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确定了目的——创建一个电脑玩家对用户玩家的猜数字游戏。
- en: We identified the constraints of the problem—the range of numbers, the number
    of guesses, and providing hints.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们确定了问题的约束条件——数字范围、猜测次数和提供提示。
- en: We created a decision flowchart.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个决策流程图。
- en: We wrote and established an algorithm for the problem.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们编写并建立了解决问题的算法。
- en: We looked at how to create a simple algorithm that would iterate rather than
    having to write each condition individually.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们看了如何创建一个简单的算法，可以迭代而不必为每个条件单独编写。
- en: We tested the algorithm at multiple points.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在多个点测试了算法。
- en: We verified that the algorithm ran accurately for both wins and losses.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们验证了算法对于胜利和失败的运行是否准确。
- en: What you don't get to see here is the number of errors I went through before
    I got to the algorithms shown. While writing, I had to use the preceding steps
    to help me identify errors, check the best algorithms, and iterate through the
    programs. This is a process that we'll continue to use.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你看不到的是我在展示算法之前经历了多少错误。在写作过程中，我不得不使用前面的步骤来帮助我识别错误，检查最佳算法，并迭代程序。这是一个我们将继续使用的过程。
- en: Summary
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we discussed problem definition, decomposition, and analysis.
    We used problems to help us go through the process of identifying problems, decomposing
    them into the relevant parts and identifying constraints, and analyzing our algorithms.
    We used flowcharts to help us learn about decision-making when designing algorithms
    and how to organize ideas.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了问题定义、分解和分析。我们使用问题来帮助我们经历识别问题、将其分解为相关部分和确定约束条件的过程，并分析我们的算法。我们使用流程图来帮助我们学习在设计算法时的决策过程以及如何组织思路。
- en: We learned to test our algorithms often. This provided us with the skills and
    understanding to identify errors early rather than wait until we had too many
    lines of code, which made it hard to identify those errors. We used an online
    store and a guessing game to help us understand some of the functionalities available
    in Python. Throughout the process, we used Boolean code to verify inputs, we used
    nested `if` statements, and we learned about how to use dictionaries in solving
    the problems presented.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学会了经常测试我们的算法。这为我们提供了识别错误的技能和理解，而不是等到我们有太多行代码时再等待。我们使用了一个在线商店和一个猜数字游戏来帮助我们了解Python中的一些功能。在整个过程中，我们使用布尔代码来验证输入，我们使用嵌套的“if”语句，我们学会了如何在解决所提出的问题时使用字典。
- en: In addition, we got a chance to use a dictionary for an algorithm that used
    user input and variables. Using the algorithm gave us flexibility for defining
    some variables and editing the variables once we run the algorithm or within the
    algorithm.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们有机会使用字典来处理使用用户输入和变量的算法。使用该算法使我们能够灵活定义一些变量，并在运行算法时或在算法内部编辑变量。
- en: In the next chapter, we will go in depth into the solution process and design,
    delving deeper into more complex problems and the Python language.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨解决方案的过程和设计，更深入地研究更复杂的问题和Python语言。
