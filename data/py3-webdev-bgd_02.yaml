- en: Chapter 2. Creating a Simple Spreadsheet
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章：创建简单的电子表格
- en: In this chapter, we will develop a simple spreadsheet application. The spreadsheet
    functionality will be entirely implemented in JavaScript plus jQuery UI, but we
    will configure CherryPy to deliver the page that contains the spreadsheet application
    dynamically.
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发一个简单的电子表格应用程序。电子表格功能将完全使用 JavaScript 和 jQuery UI 实现，但我们将配置 CherryPy
    动态地交付包含电子表格应用程序的页面。
- en: On the presentation side, we will encounter our first jQuery UI widgets (buttons)
    and will see how we can design other elements to adhere to jQuery UI standards
    to fit seamlessly in jQuery UI's theme framework. We will also see how to find
    and use publically available jQuery plugins and integrate the jEditable plugin
    into our application.
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在演示方面，我们将遇到我们的第一个 jQuery UI 小部件（按钮），并了解如何设计其他元素以符合 jQuery UI 标准，使其无缝地融入 jQuery
    UI 的主题框架。我们还将了解如何查找和使用公开可用的 jQuery 插件，并将 jEditable 插件集成到我们的应用程序中。
- en: That is a lot to grasp in one go, but don't worry if every detail is not clear
    the first time. We will encounter many variants of the issues first encountered
    here in the other chapters and will explain all relevant details again in their
    context.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这一次要掌握的内容很多，但如果第一次没有完全清楚，请不要担心。我们将在其他章节中遇到这里首次遇到的问题的许多变体，并将再次在它们的上下文中解释所有相关细节。
- en: 'In this chapter, we will be:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Creating an environment to develop and deliver our applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个用于开发和交付我们应用程序的环境
- en: Designing a simple spreadsheet application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个简单的电子表格应用程序
- en: Learning how to configure CherryPy to deliver this application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何配置 CherryPy 来交付此应用程序
- en: Encountering our first jQuery UI widgets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遇到我们的第一个 jQuery UI 小部件
- en: And designing our own jQuery plugins
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计我们自己的 jQuery 插件
- en: There is a lot of ground to cover so let's go...
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多内容需要覆盖，所以让我们开始吧...
- en: Python 3
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 3
- en: Python 3 is the language we will use to develop the server-side parts of our
    applications. At the time of writing, the current stable version is 3.2\. Installers
    and source archives are available for various platforms (including Windows, Mac
    OS, and Linux distributions) and may be downloaded from [http://www.python.org/download/](http://www.python.org/download/).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 是我们将用来开发应用程序服务器端部分的编程语言。在撰写本文时，当前稳定版本是 3.2。安装程序和源存档适用于各种平台（包括 Windows、Mac
    OS 和 Linux 发行版），可以从 [http://www.python.org/download/](http://www.python.org/download/)
    下载。
- en: Time for action installing Python 3
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Python 3 的时间到了
- en: Downloading and installing Python is not difficult. The installers for many
    platforms can be downloaded from [http://www.python.org/download/](http://www.python.org/download/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下载和安装 Python 并不困难。许多平台的安装程序可以从 [http://www.python.org/download/](http://www.python.org/download/)
    下载。
- en: Download the installer for your platform and follow the installation instructions.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载适用于您平台的安装程序，并按照安装说明进行操作。
- en: 'Verify that you correctly installed Python by typing the following command
    on the command line (for example, inside a Windows command prompt or a Linux xterm):'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在命令行（例如，在 Windows 命令提示符或 Linux xterm 内）输入以下命令来验证你是否正确安装了 Python：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The response will be the version:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应将是版本：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: What just happened?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: On a UNIX-like system (like Ubuntu Linux, or Mac OS), Python might very well
    be already installed, so it might be a good idea to verify that first by trying
    the instructions in step 2\. If the version returned is lower than 3, you should
    update your Python distribution. Note that it is perfectly possible to install
    version 3.x of Python alongside a 2.x version in order to not break applications
    depending on version 2.x (Python 3 is not backward compatible with version 2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在类 UNIX 系统（如 Ubuntu Linux 或 Mac OS）上，Python 可能已经安装好了，所以首先尝试步骤 2 中的说明来验证一下是个好主意。如果返回的版本低于
    3，你应该更新你的 Python 发行版。请注意，在安装 2.x 版本的 Python 旁边安装 3.x 版本是完全可能的，这样就不会破坏依赖于 2.x 版本的程序（Python
    3 与 2 版本不向后兼容）。
- en: CherryPy
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CherryPy
- en: Writing an HTTP server in Python isn't that difficult, but writing and maintaining
    a robust and fully fledged web server that can act as an application server is
    quite something else. As we explained in [Chapter 1](ch01.html "Chapter 1. Choosing
    Your Tools"), *Choosing Your Tools*, we will use CherryPy as our application server.
    At the time of writing, CherryPy's latest stable version for Python 3 is version
    3.2.0 and can be downloaded from [http://download.cherrypy.org/cherrypy/3.2.0/](http://download.cherrypy.org/cherrypy/3.2.0/).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中编写HTTP服务器并不困难，但编写和维护一个健壮且功能齐全的可以作为应用程序服务器的网络服务器则相当不同。正如我们在[第1章](ch01.html
    "第1章。选择你的工具")中解释的，*选择你的工具*，我们将使用CherryPy作为我们的应用程序服务器。在撰写本文时，CherryPy为Python 3的最新稳定版本是3.2.0，可以从[http://download.cherrypy.org/cherrypy/3.2.0/](http://download.cherrypy.org/cherrypy/3.2.0/)下载。
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Windows users should use the zip archive and unpack it before proceeding to
    the instructions in the next section. There is also a `msi` installer available
    at the indicated location, but this installer might not be able to find the correct
    Python installation in the Windows registry and will only work on 32-bit versions
    of Windows. Unpacking the zip archive and following the setup instructions next
    is therefore a safer bet and also identical on both Windows and Unix-like platforms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Windows用户应使用zip存档，并在继续下一节的说明之前将其解压。在指定位置还有一个`msi`安装程序可用，但这个安装程序可能无法在Windows注册表中找到正确的Python安装，并且只能在32位Windows版本上工作。因此，解压zip存档并遵循下一节的设置说明是一个更安全的做法，并且在Windows和类Unix平台上都是相同的。
- en: Time for action installing CherryPy
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装CherryPy的行动时间
- en: 'The one thing to be careful with when you install CherryPy is that you have
    to make sure you install it in the right directory if you have more than one Python
    version on your system. CherryPy uses a setup script to install itself and one
    way to make sure the CherryPy modules end up in the correct place is by invoking
    Python explicitly with a full path, for example:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装CherryPy时需要小心的一点是，如果你系统中有多个Python版本，你必须确保将其安装到正确的目录中。CherryPy使用一个设置脚本来自动安装，确保CherryPy模块最终位于正确位置的一种方法是通过使用完整路径显式调用Python，例如：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What just happened?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'Running CherryPy''s `setup.py` script installs a number of modules in Python''s
    `Lib\site-packages` directory. You may verify this was successful by typing the
    following on the command line:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行CherryPy的`setup.py`脚本会在Python的`Lib\site-packages`目录中安装多个模块。你可以通过在命令行中输入以下内容来验证这是否成功：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This checks whether we can import the `cherrypy` module. If everything is installed
    correctly, there will be no output produced by this command. However, if CherryPy
    isn''t installed, this may be signaled by an error message:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这检查我们是否可以导入`cherrypy`模块。如果一切安装正确，此命令将不会产生任何输出。然而，如果CherryPy没有安装，可能会通过错误信息来表示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you have more than one version of Python installed, be careful to enter
    the complete path of the Python executable to select the correct version, for
    example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装了多个Python版本时，请注意输入Python可执行文件的完整路径以选择正确的版本，例如：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Installing jQuery and jQuery UI
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装jQuery和jQuery UI
- en: The applications we will design and implement in this chapter and the following
    chapters depend heavily on the jQuery and jQuery UI libraries. These libraries
    consist mainly of JavaScript files and some cascading style sheets, and images
    to style the widgets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章和下一章中我们将设计和实现的应用程序高度依赖于jQuery和jQuery UI库。这些库主要由JavaScript文件和一些级联样式表以及用于美化小部件的图像组成。
- en: 'These files are served to the web browser as part of the application, and in
    general, there are two locations where they may be served from:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件作为应用程序的一部分提供给网页浏览器，通常，它们可能从以下两个位置提供：
- en: A (sub)directory on the server that runs CherryPy together with the other files
    that make up our application.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在服务器上运行CherryPy的（子）目录，以及构成我们应用程序的其他文件。
- en: Or from an external web location like Google's or Microsoft's content delivery
    networks.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 或者从外部网络位置，如Google或Microsoft的内容分发网络。
- en: The latter option might be the best choice if your application gets a lot of
    traffic as these publicly available resources are designed for high availability
    and can cope with an enormous number of requests. This might seriously reduce
    the load on your server and thus reduce costs. More information on this can be
    found on jQuery's download section [http://docs.jquery.com/Downloading_jQuery#CDN_Hosted_jQuery](http://docs.jquery.com/Downloading_jQuery#CDN_Hosted_jQuery).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序流量很大，后者可能是一个更好的选择，因为这些公开可用的资源是为高可用性设计的，可以处理大量的请求。这可能会大大减少您服务器的负载，从而降低成本。更多关于此信息可以在jQuery的下载部分找到[http://docs.jquery.com/Downloading_jQuery#CDN_Hosted_jQuery](http://docs.jquery.com/Downloading_jQuery#CDN_Hosted_jQuery)。
- en: For development purposes it is often better to download the necessary files
    and serve them from the web server that serves the rest of the application as
    well. This way we can inspect those files easily when some error occurs or even
    decide to tweak the contents. If we choose to theme our application in a customized
    way (see the info box on jQuery UI's themeroller), the cascading style sheets
    will differ from the standard ones so we will have to serve them from our web
    server anyway.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，通常更好的做法是下载必要的文件，并从提供应用程序其余部分的服务器上提供服务。这样，当出现错误时，我们可以轻松地检查这些文件，甚至决定调整内容。如果我们选择以定制的方式为主题我们的应用程序（参见jQuery
    UI的themroller信息框），则层叠样式表将与标准样式表不同，因此我们无论如何都需要从我们的Web服务器上提供服务。
- en: In the example code provided with this book, we include both the jQuery and
    jQuery UI libraries in the `static` subdirectory of the directory for each chapter.
    There is also a `css` subdirectory that contains a set of customized style sheets
    that are optimized to deliver a visual style that is well readable both in print
    and onscreen. The version of the jQuery library used in this book is downloaded
    from [http://code.jquery.com/jquery-1.4.2.js](http://code.jquery.com/jquery-1.4.2.js).
    Information on downloading a (possible themed) version of jQuery UI can be found
    on [http://jqueryui.com/download](http://jqueryui.com/download).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书提供的示例代码中，我们包括了jQuery和jQuery UI库，它们位于每个章节目录的`static`子目录中。还有一个`css`子目录，其中包含一组优化的自定义样式表，这些样式表旨在在打印和屏幕上提供易于阅读的视觉风格。本书中使用的jQuery库版本是从[http://code.jquery.com/jquery-1.4.2.js](http://code.jquery.com/jquery-1.4.2.js)下载的。有关下载（可能的主题化）版本的jQuery
    UI的信息可以在[http://jqueryui.com/download](http://jqueryui.com/download)找到。
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Using jQuery UI''s themeroller**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用jQuery UI的themroller**'
- en: The theme used throughout this book is called *smoothness* and can be downloaded
    from [http://jqueryui.com/themeroller/](http://jqueryui.com/themeroller/) by choosing
    the **Gallery** tab and clicking the **Download** button below the **Smoothness**
    example. It is even possible to create a completely customized theme based on
    one of the standard themes by selecting one of the themes from the gallery and
    then tweaking it in the **Roll Your Own** tab. Once you're satisfied with the
    look you can download the result. Check the online documentation at [http://jqueryui.com/docs/Getting_Started](http://jqueryui.com/docs/Getting_Started)
    for all details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 本书使用的主题被称为*smoothness*，可以通过选择**Gallery**标签并点击**Smoothness**示例下方的**Download**按钮从[http://jqueryui.com/themeroller/](http://jqueryui.com/themeroller/)下载。甚至可以根据标准主题之一创建一个完全定制的主题，通过在**Roll
    Your Own**标签中选择一个主题并进行调整。一旦你对外观满意，就可以下载结果。有关所有详细信息，请查看在线文档[http://jqueryui.com/docs/Getting_Started](http://jqueryui.com/docs/Getting_Started)。
- en: Serving an application
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务应用程序
- en: The first task we set ourselves is serving content to the end user. In the end
    this should be useful content, of course, but let us first make certain that we
    can write a tiny web application that delivers some content at all.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设定的第一个任务是向最终用户提供内容。最终，这应该是有用的内容，当然，但让我们首先确保我们可以编写一个微型的Web应用程序，至少能够提供一些内容。
- en: Time for action serving a dummy application
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始服务一个虚拟应用程序
- en: 'Now that we have the necessary building blocks in place, we can start developing
    our application. Let''s start with a very simple application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了必要的构建块，我们可以开始开发我们的应用程序。让我们从一个非常简单的应用程序开始：
- en: Go to the directory where you unpacked the example code.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往您解压示例代码的目录。
- en: Go to the directory `Chapter 2`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`第2章`目录。
- en: Double-click the file `nocontent.py`, a text window will open (alternatively
    you can enter the command `python nocontent.py` from the command line):![Time
    for action serving a dummy application](img/3746_2_1.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件`nocontent.py`，将打开一个文本窗口（或者您也可以从命令行输入`python nocontent.py`）：![动态服务一个虚拟应用程序](img/3746_2_1.jpg)
- en: Open your favorite browser and enter `http://localhost:8080` in the address
    bar. You will be presented with a rather dull page:![Time for action serving a
    dummy application](img/3746_2_2.jpg)
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开您喜欢的浏览器，并在地址栏中输入`http://localhost:8080`。您将看到一个相当无聊的页面：![动态服务一个虚拟应用程序](img/3746_2_2.jpg)
- en: Tip
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If your browser is unable to connect to `http://localhost:8080`, this might
    be because your local name server is not configured to resolve the name [localhost](http://localhost).
    If you do not have the means to correct this, it is equally valid, though less
    convenient, to enter `http://127.0.0.1:8080` in the address bar of your browser.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的浏览器无法连接到`http://localhost:8080`，这可能是因为您的本地名称服务器没有配置为解析名称[localhost](http://localhost)。如果您没有纠正这一问题的手段，那么输入`http://127.0.0.1:8080`到浏览器地址栏中也是同样有效，尽管不那么方便。
- en: 'It is also possible that the default port that the application will be listening
    on (8080) is already in use, in which case, Python will raise an exception: **IOError:
    Port 8080 not free on ''127.0.0.1''**. If that is the case, we can configure CherryPy
    to listen on a different port (see the info box in the next section).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '也可能应用程序将要监听的自定义端口（8080）已经被占用，在这种情况下，Python将引发异常：**IOError: ''127.0.0.1''上的端口8080不可用**。如果是这种情况，我们可以配置CherryPy在另一个端口上监听（参见下一节的信息框）。'
- en: What just happened?
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: Double-clicking `nocontent.py` caused the Python interpreter to start and execute
    the script. This opened up a console window where the CherryPy framework logged
    the fact that it started and that it will be listening on port `8080` at `127.0.0.1`
    (the so called loop back IP-address of the local machine, an address present on
    the machine even if it is not connected to the Internet).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 双击`nocontent.py`会导致Python解释器启动并执行脚本。这打开了一个控制窗口，其中CherryPy框架记录了它启动的事实以及它将在`127.0.0.1`（本地机器的所谓回环IP地址，即使没有连接到互联网，该地址也会出现在机器上）的`8080`端口上监听。
- en: This address and port are the ones we point our browser to, after which the
    HTTP server provides us with an HTML file, and a couple of JavaScript files to
    serve the application. Each file that is retrieved by the browser is logged in
    the console window together with a status. This will be convenient for spotting
    the missing files, for example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个地址和端口是我们指向浏览器的，之后HTTP服务器为我们提供HTML文件，以及一些JavaScript文件来提供服务。浏览器检索到的每个文件都会在控制窗口中记录，并附带状态信息。这将会方便我们查找缺失的文件，例如。
- en: Our script can be stopped from serving requests by closing the console window
    or by pressing *Ctrl* + *Break* (on Windows) or *Ctrl* + *C* (on Windows and most
    other platforms).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过关闭控制窗口或按*Ctrl* + *Break*（在Windows上）或*Ctrl* + *C*（在Windows和大多数其他平台上）来停止脚本提供服务。
- en: Time for action serving HTML as dynamic content
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态服务HTML内容的时间
- en: 'We have seen how to run an application and access it with a web browser, now
    let''s have a look at the Python code needed to accomplish this. We will need
    to serve static files but in addition to those static files we want to generate
    the main HTML content dynamically. This isn''t strictly necessary as we could
    have served it as a static file just as easily but it serves as a simple example
    of how to generate dynamic content:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何运行应用程序以及如何使用网络浏览器访问它，现在让我们看看完成这个任务所需的Python代码。我们需要提供静态文件，但除了这些静态文件之外，我们还想动态生成主要HTML内容。这并不是严格必要的，因为我们同样可以很容易地将其作为静态文件提供服务，但它作为一个简单的例子，说明了如何生成动态内容：
- en: '**Chapter2/nocontent.py**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter2/nocontent.py**'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.PacktPub.com](http://www.PacktPub.com). If you
    purchased this book elsewhere, you can visit [http://www.PacktPub.com/support](http://www.PacktPub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从[http://www.PacktPub.com](http://www.PacktPub.com)的账户下载您购买的所有Packt书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问[http://www.PacktPub.com/support](http://www.PacktPub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: '`nocontent.py` starts off with importing the `cherrypy` and `os.path` modules.
    The latter is needed to determine the directory that `nocontent.py` resides in
    (highlighted), so that we may refer to other static files and directories relative
    to `nocontent.py`. This way, we make life a lot easier once we want to move this
    application to its final destination on a production server.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`nocontent.py` 以导入 `cherrypy` 和 `os.path` 模块开始。后者是必要的，以便确定 `nocontent.py` 所在的目录（高亮显示），这样我们就可以相对于
    `nocontent.py` 引用其他静态文件和目录。这样，一旦我们想要将此应用程序移动到生产服务器上的最终目的地，我们就会使生活变得更加容易。'
- en: '**Chapter2/nocontent.py**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter2/nocontent.py**'
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What just happened?
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'The next step is to start the CherryPy server with the `quickstart()` function
    (highlighted). We pass two arguments: the first one is an object instance of a
    class that exposes some methods to CherryPy that may deliver dynamic content.
    We will look at that one in a minute.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用 `quickstart()` 函数启动 CherryPy 服务器（高亮显示）。我们传递两个参数：第一个参数是一个类的对象实例，该类向 CherryPy
    提供了一些可能提供动态内容的方法。我们将在下一分钟查看这一点。
- en: The second (named) argument is a dictionary containing a number of configuration
    items. In this case, we configure just a static directory, but in other situations,
    additional configuration items may appear here. The URL component `/static` is
    made to refer to a location on the file-system relative to `nocontent.py` by concatenating
    to the `current_dir` determined earlier. Again we use a function from Python's
    `os.path` module, `os.path.join()`, to create a file path in a platform-independent
    manner.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个（命名）参数是一个包含多个配置项的字典。在这种情况下，我们只配置了一个静态目录，但在其他情况下，这里可能还会出现其他配置项。URL 组件 `/static`
    是通过连接之前确定的 `current_dir` 来指向文件系统上的位置的。我们再次使用 Python 的 `os.path` 模块中的函数 `os.path.join()`，以平台无关的方式创建文件路径。
- en: The `static` directory contains all jQuery and jQuery UI files we will need
    for this application along with all CSS files and images to style the application.
    In this example, without real content there are no additional files besides the
    ones belonging to the jQuery and jQuery UI libraries, but if we needed them, we
    could have placed them here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 目录包含我们将为这个应用程序需要的所有 jQuery 和 jQuery UI 文件，以及所有 CSS 文件和图像来美化应用程序。在这个例子中，由于没有实际内容，除了属于
    jQuery 和 jQuery UI 库的文件外，没有其他文件，但如果我们需要它们，我们也可以将它们放在这里。'
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If we would like CherryPy to listen on a different port, we should indicate
    this in the global configuration. This can be done by preceding the call to `cherrypy.quickstart()`
    with `cherrypy.config.update({'server.socket_port':8088})`. CherryPy has a rich
    palette of configuration options and can even be instructed to read its configuration
    from files. A good starting point for all the possibilities is [http://www.cherrypy.org/wiki/ConfigAPI](http://www.cherrypy.org/wiki/ConfigAPI).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让 CherryPy 监听不同的端口，我们应在全局配置中指明这一点。这可以通过在调用 `cherrypy.quickstart()` 之前添加
    `cherrypy.config.update({'server.socket_port':8088})` 来实现。CherryPy 提供了丰富的配置选项，甚至可以指示它从文件中读取配置。所有可能性的良好起点是
    [http://www.cherrypy.org/wiki/ConfigAPI](http://www.cherrypy.org/wiki/ConfigAPI)。
- en: 'We still have to implement a `Root` class to provide CherryPy with an object
    instance that may act as the root of the document hierarchy that CherryPy may
    serve. This class should actually be defined before we can create an instance
    to pass to the `quickstart()` method, but I wanted to concentrate on how to start
    the server first before concentrating on producing content:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要实现一个 `Root` 类，为 CherryPy 提供一个可能作为文档层次结构根的对象实例，CherryPy 可能会为其提供服务。实际上，在我们可以创建一个实例并将其传递给
    `quickstart()` 方法之前，我们应该定义这个类，但我想要首先集中精力了解如何启动服务器，然后再集中精力生成内容：
- en: '**Chapter2/nocontent.py**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**Chapter2/nocontent.py**'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `Root` class contains a single class variable `content` that holds the
    HTML code we will serve. We will examine it in detail in the next section. This
    HTML is generated by the `index()` method and passed to the HTTP server that in
    its turn will pass it on to the requesting browser.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Root` 类包含一个单独的类变量 `content`，它保存我们将要服务的 HTML 代码。我们将在下一节中详细检查它。这个 HTML 是由
    `index()` 方法生成的，并传递给 HTTP 服务器，然后服务器将其传递给请求的浏览器。
- en: It is **exposed** to CherryPy by the `@cherrypy.expose` decorator (highlighted).
    Only exposed methods will be called by CherryPy to produce content. In the default
    configuration, CherryPy will map a URL of the form `/name` to a method called
    `name()`. A URL containing just a forward slash */* will map to a method called
    `index()`, just like the one we defined here. This means we have now configured
    CherryPy to deliver dynamic content when the user directs his browser to `http://127.0.0.1:8080/`
    (and he may even omit the final slash as CherryPy effectively ignores a trailing
    slash by default).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过`@cherrypy.expose`装饰器（突出显示）暴露给CherryPy。只有暴露的方法才会被CherryPy调用以生成内容。在默认配置中，CherryPy会将形式为`/name`的URL映射到名为`name()`的方法。仅包含一个正斜杠*/*的URL将映射到名为`index()`的方法，就像我们在这里定义的那样。这意味着我们现在已经配置了CherryPy，当用户将浏览器指向`http://127.0.0.1:8080/`（他甚至可以省略最后的斜杠，因为CherryPy默认会忽略尾随斜杠）时，它会提供动态内容。
- en: Note that we let `index()` return the contents of a single string variable but
    we could have returned just about anything, making this a truly dynamic way of
    producing content.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们让`index()`返回单个字符串变量的内容，但我们本可以返回任何东西，这使得这是一种真正动态的内容生成方式。
- en: 'Who serves what: an overview'
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谁提供什么：概述
- en: Serving an application from a mixture of dynamic and static content may quickly
    become confusing. It might help to form a clear picture early on of the relations
    between components, of data streams, and directory structures used. This builds
    on the general picture sketched in [Chapter 1](ch01.html "Chapter 1. Choosing
    Your Tools") and will get extended in each chapter.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从动态和静态内容的混合中提供服务可能会很快变得令人困惑。在早期形成一个清晰的组件、数据流和目录结构之间的关系图可能有所帮助。这建立在[第1章](ch01.html
    "第1章。选择你的工具")中概述的总体图景之上，并在每一章中进一步扩展。
- en: 'Almost all applications in this book are served from the same directory structure:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的几乎所有应用都是从相同的目录结构中提供的：
- en: '![Who serves what: an overview](img/3746OS_02_08.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![谁提供什么：概述](img/3746OS_02_08.jpg)'
- en: The top-level directory contains one or more Python files that you can execute
    and that will start a CherryPy server. Those Python files implement the server-side
    of an application. They may import additional modules from the same top-level
    directory.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级目录包含一个或多个可以执行并启动CherryPy服务器的Python文件。这些Python文件实现了应用的客户端。它们可以从同一顶级目录导入额外的模块。
- en: The top-level directory also contains a subdirectory called `static`. It holds
    several JavaScript files, including the jQuery and jQuery UI libraries and any
    additional plugins. It also contains a directory called `css` that contains one
    or more subdirectories with additional CSS stylesheets and images for jQuery UI
    themes.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 顶级目录还包含一个名为`static`的子目录。它包含几个JavaScript文件，包括jQuery和jQuery UI库以及任何额外的插件。它还包含一个名为`css`的目录，其中包含一个或多个额外的CSS样式表和jQuery
    UI主题的图像。
- en: Note that although our applications are served by a web server, there are no
    HTML files to be seen because all HTML content is generated dynamically.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们的应用是由Web服务器提供的，但看不到任何HTML文件，因为所有HTML内容都是动态生成的。
- en: 'From an application point of view, the best way to comprehend a web application
    is to see the application as distributed. Some of its code (in our case Python)
    runs on the server, while other code (JavaScript) runs in the browser. Together,
    they make up the complete application as visualized in the following image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从应用的角度来看，理解一个Web应用的最佳方式是将它视为分布式应用。其中一些代码（在我们的例子中是Python）在服务器上运行，而其他代码（JavaScript）在浏览器中运行。它们共同构成了以下图像中可视化的完整应用：
- en: '![Who serves what: an overview](img/3746OS_02_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![谁提供什么：概述](img/3746OS_02_07.jpg)'
- en: Pop quiz serving content with CherryPy
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CherryPy内容服务快速问答
- en: We made the choice to serve our content from the `index()` method so users could
    get the content by referring to the URL ending in just a slash (/). But what if
    we would like our content to be accessed by referring to a URL like [http://127.0.0.1/content?](http://127.0.0.1/content?)
    What would have to change?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择从`index()`方法提供服务，以便用户可以通过仅以斜杠(/)结尾的URL来获取内容。但如果我们希望内容可以通过类似[http://127.0.0.1/content?](http://127.0.0.1/content?)这样的URL访问，我们需要做哪些改变？
- en: 'HTML: separating form and content'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML：分离表单和内容
- en: Almost always, it is a good idea to separate form and content. This enables
    us to concentrate on the logical structure of the information we want to present
    and makes it easier to change the appearance of the data later. This even allows
    for applying themes in a maintainable way.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，将表单和内容分开是一个好主意。这使我们能够专注于我们想要呈现的信息的逻辑结构，并使得以后更改数据的显示方式变得更容易。这甚至允许以可维护的方式应用主题。
- en: The structure of our data is laid down in the HTML we deliver to the browser.
    To be more precise, the structural data can be found within the`<body>` element,
    but the`<head>` element of the HTML contains important information as well. For
    example, references to stylesheets and JavaScript libraries that will be used
    to style the appearance of the data and enhance the user interaction.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们数据的结构是在我们提供给浏览器的HTML中确定的。更准确地说，结构数据可以在`<body>`元素中找到，但HTML的`<head>`元素也包含重要信息。例如，引用将要用于样式化数据和增强用户交互的样式表和JavaScript库。
- en: In the following code, we use a`<link>` element to refer to a CSS stylesheet
    from a theme we downloaded from the jQuery UI website (highlighted). In this example,
    we do not actually use this stylesheet and nor are the jQuery and jQuery UI libraries
    included in the`<script>` elements, but this example shows how to refer to those
    libraries from the HTML we produce, and in the following examples, we will see
    that this is also the spot where we refer to any additional JavaScript libraries
    that we will create ourselves. The actual content is enclosed in the highlighted`<div>`
    element.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们使用一个`<link>`元素来引用从jQuery UI网站下载的主题中的CSS样式表（高亮显示）。在这个例子中，我们实际上并没有使用这个样式表，jQuery和jQuery
    UI库也没有包含在`<script>`元素中，但这个例子展示了如何从我们生成的HTML中引用这些库，在接下来的例子中，我们还将看到这也是我们引用我们将自己创建的任何额外JavaScript库的位置。实际内容包含在突出显示的`<div>`元素中。
- en: '[PRE9]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Time for action a unit convertor
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候进行一个单位转换器操作了
- en: 'Serving just a piece of text isn''t very useful, so our next step is to add
    some HTML content and enhance the display and functionality with JavaScript:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 只提供一段文本并不十分有用，因此我们的下一步是添加一些HTML内容，并通过JavaScript增强显示和功能：
- en: Go to the same directory where `nocontent.py` could be found.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`nocontent.py`可能存在的同一目录。
- en: Double-click the file `unitconvertor.py`, CherryPy console will again open in
    a text window.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件`unitconvertor.py`，CherryPy控制台将再次在文本窗口中打开。
- en: Enter `http://localhost:8080` in the address bar of your browser (or click refresh
    if it is still open on that address). You will now see a small unit convertor:![Time
    for action a unit convertor](img/3746_2_3.jpg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器地址栏中输入`http://localhost:8080`（或者如果它仍然打开在那个地址，点击刷新）。你现在将看到一个小的单位转换器：![是时候进行一个单位转换器操作了](img/3746_2_3.jpg)
- en: You can enter any number (with an optional fraction) in the text input on the
    left and after selecting the units to convert from and to, pressing the **convert**
    button will present you with the converted number on the right.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在左侧的文本输入框中输入任何数字（可选分数），选择要转换的单位和目标单位后，按下**转换**按钮将在右侧显示转换后的数字。
- en: What just happened?
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The basic structure of our web application hasn't changed. The content we deliver
    is different but that hardly changes the Python code we need to deliver it. The
    actual content, that is the HTML we deliver when the `index()` function is invoked,
    does differ as it has to define the`<form>` elements that our unit convertor consists
    of and we want to execute some JavaScript as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Web应用的基本结构并没有改变。我们提供的内容不同，但这几乎不会改变我们需要提供的Python代码。实际内容，即当调用`index()`函数时我们提供HTML，它必须定义我们的单位转换器所包含的`<form>`元素，并且我们还想执行一些JavaScript。
- en: 'HTML: form-based interaction'
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML：基于表单的交互
- en: The`<head>` portion of the HTML doesn't have to be changed as it already refers
    to the stylesheet and JavaScript libraries we want to use. However, we do have
    to change the`<body>` element to contain the structural elements that make up
    our unit convertor.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: HTML的`<head>`部分不需要更改，因为它已经引用了我们想要使用的样式表和JavaScript库。然而，我们必须更改`<body>`元素以包含构成我们的单位转换器的结构元素。
- en: The unit convertor is structured as a`<form>` element (highlighted). It contains
    two drop-down lists to select the units to convert, both implemented with`<select>`
    elements, and a text`<input>` element where the user can enter a number. A second
    text`<input>` element is used to display the result of the conversion. This one
    is set to read only as it is not meant to receive input from the user. The final
    element is a`<button>` that the user may click to initiate the conversion.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 单位转换器以 `<form>` 元素（高亮显示）的形式构建。它包含两个下拉列表，用于选择要转换的单位，这两个列表都使用 `<select>` 元素实现，还有一个文本
    `<input>` 元素，用户可以在其中输入数字。第二个文本 `<input>` 元素用于显示转换结果。这个元素被设置为只读，因为它不打算接收用户的输入。最后一个元素是一个用户可以点击以启动转换的
    `<button>`。
- en: You may have noticed that the`<form>` element lacks an `action` attribute. This
    is intentional as there is no interaction with a server. The conversion that happens
    when the user clicks the button is completely implemented in JavaScript. This
    JavaScript is included (and executed) in the final script element (highlighted).
    We will examine this script in the next section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到 `<form>` 元素缺少 `action` 属性。这是故意的，因为没有与服务器进行交互。当用户点击按钮时发生的转换完全在 JavaScript
    中实现。这段 JavaScript 包含（并执行）在最终的脚本元素（高亮显示）中。我们将在下一节中检查这个脚本。
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'JavaScript: using jQuery UI widgets'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript：使用 jQuery UI 小部件
- en: Screen elements or **widgets** are essential to let the end user interact with
    you application. These widgets might be simple buttons that initiate some action
    when the user clicks them or more complex widgets like drop-down boxes, radio
    buttons, or even little calendars that let you pick a date. The jQuery UI library
    provides a large number of predefined and easy to configure widgets, and so our
    next step is to use jQuery UI to let the button in our conversion application
    react to a click of the mouse and initiate the unit conversion.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕元素或 **小部件** 对于让最终用户与你的应用程序交互至关重要。这些小部件可能是简单的按钮，当用户点击它们时启动某些操作，或者更复杂的小部件，如下拉框、单选按钮，甚至是允许你选择日期的小日历。jQuery
    UI 库提供大量预定义且易于配置的小部件，因此我们的下一步是使用 jQuery UI 让我们的转换应用程序中的按钮对鼠标点击做出反应，并启动单位转换。
- en: Time for action conversion using unitconverter.js
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 unitconverter.js 进行动作转换
- en: '`unitconverter.js` contains the necessary JavaScript code to do the actual
    conversion. It starts with the definition of a conversion map, a dictionary holding
    the conversion factors for any conversion we want to define. We restrict ourselves
    to conversions from inches to centimeters and vice versa, but additional conversion
    factors can easily be added.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`unitconverter.js` 包含执行实际转换所需的 JavaScript 代码。它从定义一个转换映射开始，这是一个包含我们想要定义的任何转换的转换因子的字典。我们限制自己从英寸到厘米以及相反方向的转换，但可以轻松添加额外的转换因子。'
- en: '[PRE11]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The highlighted line in the previous code is our first encounter with the jQuery
    and jQuery UI libraries and deserves some close attention. The `$("button")` part
    selects all`<button>` elements on the page. In this case, it will be just a single
    one. This`<button>` element is converted to a button widget from the jQuery UI
    library with the `button()` method. This is a simple widget that styles an element
    as a recognizable button that will be easy to theme and customize.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一段代码中高亮显示的行是我们第一次接触 jQuery 和 jQuery UI 库，值得密切关注。`$("button")` 这部分选择页面上的所有
    `<button>` 元素。在这种情况下，它将只有一个。这个 `<button>` 元素通过 `button()` 方法从 jQuery UI 库转换为一个按钮小部件。这是一个简单的部件，将元素样式化为一个易于主题化和定制的可识别按钮。
- en: What just happened?
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: What actually happens once the user clicks the button is defined by the anonymous
    function we pass as a **click handler** to the button element with the `click()`
    method. This anonymous function is called each time the user clicks the button.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时实际发生的事情是由我们通过 `click()` 方法传递给按钮元素的匿名函数定义的 **点击处理器**。这个匿名函数在用户每次点击按钮时都会被调用。
- en: The first thing this handler does is retrieve the contents of the text`<input>`
    element with a `name` attribute equal to **from** with `$("input[name='from']").val()`.
    Next, it retrieves the currently selected units from both`<select>` elements.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个处理器首先通过 `$("input[name='from']").val()` 获取具有 `name` 属性等于 **from** 的文本 `<input>`
    元素的 内容。接下来，它从两个 `<select>` 元素中检索当前选定的单位。
- en: If those units are not the same, it fetches the conversion factor from the conversion
    map with the concatenated units as a key. The result of the conversion is calculated
    by multiplying the conversion factor and the contents of the`<input>` element.
    The content we retrieve of any`<input>` element is always returned as a string,
    therefore we have to use the built-in JavaScript function `parseFloat()` to interpret
    it as a floating point number. If both units are equal, the result is simply the
    same as the input value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些单位不相同，它将从转换映射中获取具有连接单位作为键的转换系数。转换结果通过乘以转换系数和`<input>`元素的内容来计算。我们从任何`<input>`元素检索的内容始终以字符串形式返回，因此我们必须使用内置的JavaScript函数`parseFloat()`将其解释为浮点数。如果两个单位相同，结果简单地与输入值相同。
- en: The calculated result is stored in the text`<input>` element with a `name` attribute
    of `to`. Note that even though this element has a read-only attribute to prevent
    the user from entering any text, we can still alter its content within a script.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 计算结果存储在具有`name`属性为`to`的文本`<input>`元素中。请注意，尽管这个元素有一个只读属性来防止用户输入任何文本，我们仍然可以在脚本中更改其内容。
- en: Pop quiz adding an icon to a button
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加图标到按钮的即兴测验
- en: A button with just simple text might be appropriate for many applications but
    it would look much better, if it showed an appropriate icon as well. Knowing that
    the button widget is highly configurable, how would you add an icon to your button?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个只有简单文本的按钮可能适用于许多应用，但如果它还显示了适当的图标，看起来会更好。既然知道按钮小部件高度可配置，你将如何给你的按钮添加一个图标？
- en: Have a go hero adding a dynamic title
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试添加一个动态标题的英雄
- en: The HTML we served in the `nocontent.py` example was simply the contents of
    a class variable, so not really dynamic! What all would we have to do if we wanted
    to serve HTML containing a`<title>` element that shows the current date?
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`nocontent.py`示例中我们提供的HTML只是类变量的内容，所以并不真正是动态的！如果我们想提供包含显示当前日期的`<title>`元素的HTML，我们需要做些什么？
- en: 'Hint: A`<title>` element should be contained inside the`<head>` element. So
    instead of returning all the HTML in one go, you could rewrite the Python code
    to return HTML composed of three parts: The first and last parts are pieces of
    static HTML and the middle part is a dynamically generated string representing
    a`<title>` element containing a date. That date could be obtained from Python''s
    `asctime()` function found in the standard `time` module.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示：`<title>`元素应该包含在`<head>`元素中。因此，而不是一次性返回所有HTML，你可以重写Python代码以返回由三部分组成的HTML：第一部分和最后一部分是静态HTML片段，中间部分是动态生成的字符串，代表一个包含日期的`<title>`元素。这个日期可以通过Python标准`time`模块中的`asctime()`函数获取。
- en: A possible implementation can be found in the file `nocontenttitle.py`.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种可能的实现可以在文件`nocontenttitle.py`中找到。
- en: jQuery selectors
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: jQuery选择器
- en: jQuery selectors pop up in many locations and in a sense they are the focus
    of any JavaScript program that uses the jQuery library. A complete overview is
    out of the scope of this book (for that, refer to the appendix for some books
    on jQuery with extensive examples or check jQuery's documentation section on [http://docs.jquery.com/Main_Page](http://docs.jquery.com/Main_Page),
    especially the part on selectors) but basically jQuery allows us to select any
    element or set of elements in a CSS 3-compliant fashion in a cross browser compatible
    way. In other words, it works even in browsers that do not yet support CSS 3.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery选择器在许多地方出现，从某种意义上说，它们是任何使用jQuery库的JavaScript程序的重点。本书的范围不包括完整的概述（关于这一点，请参阅附录中的一些jQuery书籍，其中包含大量示例，或检查jQuery的[http://docs.jquery.com/Main_Page](http://docs.jquery.com/Main_Page)文档部分，特别是关于选择器的部分），但基本上jQuery允许我们以CSS
    3兼容的方式选择任何元素或元素集。换句话说，即使在尚未支持CSS 3的浏览器中，它也能正常工作。
- en: 'To give some idea of what is possible, some examples are given next, all of
    them assume an HTML document containing the following markup:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让大家有个大致的概念，下面给出了一些示例，所有这些示例都假设有一个包含以下标记的HTML文档：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To select all`<li>` elements: `$("li")`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择所有`<li>`元素：`$("li")`
- en: 'To select just the first`<li>` element: `$("li:first")`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择第一个`<li>`元素：`$("li:first")`
- en: 'To select the`<li>` element with the class `highlight: $(".highlight")`'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择具有`highlight`类的`<li>`元素：`$(".highlight")`
- en: 'To select the`<div>` with an id equal to `footer: $("#footer")`'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择id等于`footer`的`<div>`：`$("#footer")`
- en: The jQuery function (often represented by the alias `$)` returns a jQuery object
    that refers to the collection of matched elements. A jQuery object has many methods
    to manipulate the elements in this collection. For example, `$("li").addClass("red-background")`
    adds the red-background class to all`<li>` elements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery 函数（通常用别名 `$` 表示）返回一个 jQuery 对象，该对象指向匹配的元素集合。jQuery 对象有许多方法可以操作这个集合中的元素。例如，`$("li").addClass("red-background")`
    将红色背景类添加到所有 `<li>` 元素。
- en: The jQuery UI library extends the available methods even further by adding functionality
    to change elements to standardized widgets. That is why in our example `$("button").button()`
    alters the appearance of our button element to the stylized button widget that
    jQuery UI provides.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: jQuery UI 库通过添加将元素转换为标准小部件的功能，进一步扩展了可用方法。这就是为什么在我们的例子中，`$("button").button()`
    会改变按钮元素的样式，使其变为 jQuery UI 提供的样式化按钮小部件。
- en: 'Our example application also shows another important jQuery concept: **chaining**.
    Most jQuery and jQuery UI methods return the selection they operated on. That
    way, it is easy to call multiple methods on the same selection. In our example,
    `$("button").button()` returns the selected button elements after transforming
    them into button widgets, which allows us to chain the click method to define
    mouse-click behavior by writing `$("button").button().click(…)`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例应用程序还展示了另一个重要的 jQuery 概念：**链式操作**。大多数 jQuery 和 jQuery UI 方法返回它们操作的选中项。这样，就很容易在同一个选中项上调用多个方法。在我们的例子中，`$("button").button()`
    在将选中的按钮元素转换为按钮小部件后返回这些按钮元素，这允许我们通过编写 `$("button").button().click(…)` 来链式调用点击方法，以定义鼠标点击行为。
- en: 'CSS: applying a jQuery UI theme to other elements'
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CSS：将 jQuery UI 主题应用到其他元素
- en: The last line in `unitconverter.js` shows how we can style any element in the
    same manner as the standard jQuery UI widgets. This is accomplished, in this case,
    by selecting all elements contained in the`<form>` element with `$("form *")`
    and then adding the `ui-widget` class with the `addClass()` method.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`unitconverter.js` 中的最后一行显示了如何以与标准 jQuery UI 小部件相同的方式设置任何元素的样式。在这种情况下，这是通过使用
    `$("form *")` 选择 `<form>` 元素中包含的所有元素，然后使用 `addClass()` 方法添加 `ui-widget` 类来实现的。'
- en: Any element adorned with the `ui-widget` class will receive the same styling
    as any jQuery UI widget. In our case, this is visible in the font and colors used
    in the `input` and `select` elements. Even if we change the theme this change
    will be uniformly applied. There are more predefined classes available to allow
    for a more fine grained control and we will encounter those when we create our
    own jQuery UI plugin in the next section.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 任何带有 `ui-widget` 类的元素都将获得与任何 jQuery UI 小部件相同的样式。在我们的例子中，这体现在 `input` 和 `select`
    元素使用的字体和颜色上。即使我们更改主题，这种更改也将被统一应用。还有更多预定义的类可供使用，以实现更精细的控制，我们将在下一节创建自己的 jQuery UI
    插件时遇到这些类。
- en: It is important to grasp the effect of one of the predefined jQuery UI classes
    to an element. Classes in themselves don't change the way elements are displayed
    but the jQuery UI framework associates various CSS style elements with the predefined
    classes. When the classes associated with an element change, the browser checks
    again which style elements to apply, effecting an immediate style change.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 理解预定义的 jQuery UI 类对元素的影响是很重要的。类本身并不会改变元素的显示方式，但 jQuery UI 框架将各种 CSS 样式元素与预定义的类关联起来。当与元素关联的类发生变化时，浏览器会再次检查应用哪些样式元素，从而实现即时样式更改。
- en: It is also possible to directly alter CSS styles associated with an element.
    However, defining styles for a certain class and altering the class makes it easier
    to maintain a consistent look without having to resort to individual style components
    for each and every element that you want to change.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以直接更改与元素关联的 CSS 样式。然而，为特定类定义样式并更改类，使得在不需为每个要更改的元素单独使用样式组件的情况下，更容易保持一致的视觉效果。
- en: Have a go hero adding zebra stripes to a table
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试为表格添加斑马条纹的英雄
- en: An often required feature when styling HTML tables is to render the rows of
    tables with an alternating background color.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置 HTML 表格样式时，一个经常需要的功能是使用交替的背景颜色渲染表格的行。
- en: Because jQuery allows us to use CSS 3-compliant selectors and add to an elements
    `class` attribute with the `.addClass()` method, this is now accomplished easily
    even in the browsers that do not support CSS 3.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 jQuery 允许我们使用 CSS 3 兼容的选择器，并通过 `.addClass()` 方法向元素的 `class` 属性添加内容，因此即使在不支持
    CSS 3 的浏览器中，现在也可以轻松完成这项任务。
- en: 'Given the following sample HTML, what JavaScript should be added to the last`<script>`
    element to render the background of all even rows in light gray? (Hints: CSS 3
    has an `:even` selector and when you add a class to an element with jQuery, any
    CSS styles applicable to that class are re-evaluated).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下示例HTML，应向最后一个`<script>`元素添加什么JavaScript代码以将所有偶数行的背景渲染为浅灰色？（提示：CSS 3有一个`:even`选择器，当您使用jQuery向一个元素添加类时，任何适用于该类的CSS样式都将重新评估）。
- en: 'Check `zebra.html` to see a solution (It is included with the sample code for
    [Chapter 2](ch02.html "Chapter 2. Creating a Simple Spreadsheet"). Open the file
    in your browser to see the effect):'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`zebra.html`以查看解决方案（它包含在[第2章](ch02.html "第2章. 创建简单的电子表格")的示例代码中。在您的浏览器中打开该文件以查看效果）：
- en: '[PRE13]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result will look something like this in the browser (note that elements
    are numbered starting at zero, so maybe the result is not what you expected):'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器中的结果将类似于以下内容（请注意，元素从零开始编号，因此结果可能不是您预期的）：
- en: '![Have a go hero adding zebra stripes to a table](img/3746_2_4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![尝试将斑马条纹添加到表格中](img/3746_2_4.jpg)'
- en: Time for action converting a unit convertor into a plugin
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将单位转换器转换为插件的操作时间
- en: 'Re-using one of the many well designed jQuery UI widgets is good as it saves
    us development and maintenance time but the true power of the jQuery UI framework
    is the manner in which it enables us to devise completely new widgets that merge
    seamlessly with the rest of the framework and are indistinguishable in their use
    from the standard widgets. To illustrate what is possible, let''s implement our
    unit converter again, but this time as a jQuery plugin:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用许多精心设计的jQuery UI小部件之一是有益的，因为它可以节省我们的开发和维护时间，但jQuery UI框架的真正力量在于它使我们能够设计出与框架的其他部分无缝融合且在使用上与标准小部件不可区分的新小部件。为了说明可能实现的内容，让我们再次实现我们的单位转换器，但这次作为jQuery插件：
- en: Go to the directory containing the example code for [Chapter 2](ch02.html "Chapter 2. Creating
    a Simple Spreadsheet").
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往包含[第2章](ch02.html "第2章. 创建简单的电子表格")示例代码的目录。
- en: Double-click the file `unitconverter2.py`, the CherryPy console will again open
    in a window.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件`unitconverter2.py`，CherryPy控制台将再次在窗口中打开。
- en: Enter `http://localhost:8080` in the address bar of your browser (or click refresh
    if it is still open on that address). You will now see a slightly restyled unit
    converter:![Time for action converting a unit convertor into a plugin](img/3746_2_5.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器地址栏中输入`http://localhost:8080`（如果该地址仍然打开，请点击刷新）。您现在将看到一个稍微重新设计的单位转换器：![将单位转换器转换为插件的操作时间](img/3746_2_5.jpg)
- en: The interaction with this new unit converter is exactly the same as our previous
    one.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个新的单位转换器的交互与之前的完全相同。
- en: What just happened?
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: 'Instead of structuring a widget with a`<form>` element containing a number
    of additional elements, we now take a simpler approach. We will design a reusable
    unit converter widget that can be inserted into any`<div>` element. Our HTML backbone
    becomes much simpler now, as its body will just contain a single`<div>` element:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在不再使用包含多个额外元素的`<form>`元素来构建小部件，而是采用更简单的方法。我们将设计一个可重用的单位转换器小部件，可以插入到任何`<div>`元素中。现在，我们的HTML骨架变得更加简单，因为其主体将只包含一个`<div>`元素：
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first highlighted line includes the JavaScript file that contains the new
    implementation of the unit converter. We refer to the plugin defined in this file
    in the JavaScript code near the end of the`<body>` element (last highlighted line).
    This script refers to the`<div>` element to which we want to add a unit converter
    by its id (in this case `#example)` and apply the `unitconvertor()` method.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条突出显示的行包含包含新实现单位转换器的JavaScript文件。我们在`<body>`元素末尾附近的JavaScript代码中引用了此文件中定义的插件（最后突出显示的行）。此脚本通过其id（在这种情况下为`#example`）引用我们想要添加单位转换器的`<div>`元素，并应用`unitconvertor()`方法。
- en: As we will see when we look at the JavaScript code that implements our converter
    plugin, `unitconverter()` takes an option object as its single argument. This
    option object may contain any number of keys defining additional conversion factors
    for this instance of the plugin. In this case, we pass additional information
    to allow for conversion from miles to kilometers, and vice versa.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看实现我们的转换插件的JavaScript代码时，`unitconverter()`接受一个选项对象作为其唯一参数。此选项对象可以包含任何数量的键，用于定义此插件实例的附加转换系数。在这种情况下，我们传递附加信息以允许从英里转换为公里，反之亦然。
- en: Pop quiz adding conversions to a unitconverter instance
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单项测验：向unitconverter实例添加转换
- en: What would the JavaScript look like when we want to add a unit converter plugin
    with the possibility of converting from cubic feet to liters?
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要添加一个可以将立方英尺转换为升的单位转换插件时，JavaScript 会是什么样子呢？
- en: 'JavaScript: creating a jQuery UI plugin'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript：创建一个 jQuery UI 插件
- en: All jQuery UI plugins are defined in the same way by adding a new function to
    the `fn` attribute of the `jQuery` object (the object we mostly refer to by its
    alias `$)`. In `unitconverter2.js`, this is exactly what we do, as it is seen
    in the first line of the following code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 jQuery UI 插件都是通过向 `jQuery` 对象的 `fn` 属性（我们通常通过其别名 `$` 来引用的对象）添加一个新函数来定义的。在
    `unitconverter2.js` 中，这正是我们所做的，如下代码的第一行所示。
- en: 'The next thing we do is merge any options passed to the plugin with defaults
    (highlighted). jQuery provides an `extend()` method that merges the attributes
    of any number of objects and returns the first one. As we do not want to overwrite
    the default options that we have defined in `$.fn.unitconverter.conversion_map`,
    we pass it an empty object. This object will receive the default attributes and
    any attributes defined in the `options` object, overwriting the ones with a name
    that is the same. This set of merged attributes is stored in the `cmap` variable:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将传递给插件的任何选项与默认值合并（高亮显示）。jQuery 提供了一个 `extend()` 方法，该方法合并任意数量的对象的属性，并返回第一个对象。由于我们不希望覆盖我们在
    `$.fn.unitconverter.conversion_map` 中定义的默认选项，我们传递一个空对象。该对象将接收默认属性和 `options` 对象中定义的任何属性，覆盖名称相同的属性。这些合并后的属性集存储在
    `cmap` 变量中：
- en: '[PRE15]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The conversion factors are referred to by keys of the form `unit1_unit2`. To
    construct two drop-down selectors from the keys, we iterate over all these keys
    and use JavaScript''s `split()` method to retrieve the individual units (highlighted).
    These are then stored in the `from` and `to` arrays:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 转换系数通过 `unit1_unit2` 形式的键来引用。为了从键构建两个下拉选择器，我们遍历所有这些键，并使用 JavaScript 的 `split()`
    方法检索单个单位（高亮显示）。然后，这些单位被存储在 `from` 和 `to` 数组中：
- en: '[PRE16]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The next step is to construct the HTML needed by the plugin to present to the
    user. The structure is similar to the handcrafted one used in the previous example,
    a`<form>` with`<input>` and`<select>` elements, and a`<button>`. The`<form>` element
    is adorned with a random id attribute. This way we may refer to it later even
    if there is more than one unit converter present on the page.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是构建插件需要向用户展示的 HTML。结构与上一个例子中手工制作的类似，一个包含 `<input>`、`<select>` 元素和 `<button>`
    的 `<form>`。`<form>` 元素被添加了一个随机的 id 属性。这样我们就可以在页面上有多个单位转换器的情况下，稍后引用它。
- en: 'The`<select>` elements contain a number of`<option>` elements that are created
    by retrieving the unit names stored in the `from` and `to` arrays one-by-one with
    the `pop()` method. The first of these options is selected by default (highlighted).
    The HTML code is then passed to the `append()` method of `this. this` is a variable
    that is available to the function implementing the plugin that contains the selected
    elements the plugin is applied to, in our example the`<div>` element with the
    `#example` id:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`<select>` 元素包含多个 `<option>` 元素，这些元素是通过逐个检索存储在 `from` 和 `to` 数组中的单位名称，并使用 `pop()`
    方法创建的。默认情况下，第一个选项被选中（高亮显示）。然后，HTML 代码被传递到 `this.append()` 方法中。`this` 是一个变量，它对实现插件的函数是可用的，它包含应用插件的元素，在我们的例子中是具有
    `#example` id 的 `<div>` 元素：'
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The randomly generated id for the form element now comes in handy to select
    just the`<button>` element within the form we are currently constructing and convert
    it to a button: we construct a suitable selector by concatenating relevant parts
    with `"#"+id+" button`".'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 随机生成的表单元素 id 现在非常有用，可以用来选择我们当前正在构建的表单中的 `<button>` 元素，并将其转换为按钮：我们通过连接相关部分来构建一个合适的选择器，即
    `"#"+id+" button"`。
- en: 'Note that it is perfectly valid to include other plugins or widgets within
    a custom plugin. This time we choose to construct a slightly different looking
    button with just an icon and no text by passing an appropriate options object.
    From the numerous icons shipped with jQuery UI, we choose the one that represents
    the function of the button best: `ui-icon-refresh` (highlighted).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在自定义插件中包含其他插件或小部件是完全有效的。这次我们选择通过传递一个适当的选项对象来构建一个外观略有不同的按钮，该按钮只有一个图标而没有文本。从
    jQuery UI 随带的大量图标中，我们选择最能代表按钮功能的图标：`ui-icon-refresh`（高亮显示）。
- en: 'The conversion that happens when the user clicks the button is implemented
    by a function that we will encounter shortly and that is passed by the button
    object (available to the `click()` method as the `this` variable) and the merged
    map of conversion factors:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时发生的转换是通过一个我们将很快遇到的功能实现的，该功能通过按钮对象（作为`click()`方法中的`this`变量可用）和合并的转换系数映射传递：
- en: '[PRE18]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The finishing touch is to style our widget in a consistent manner. jQuery provides
    us with a `css()` method that allows us to directly manipulate the style attributes
    of any element. We first deal with a layout matter: we apply a `float:left` style
    to the`<form>` element to make sure it doesn''t fill the page completely, but
    shrink/wraps itself around the elements it contains:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是将我们的小部件以一致的方式样式化。jQuery为我们提供了一个`css()`方法，允许我们直接操作任何元素的样式属性。我们首先处理一个布局问题：我们将`float:left`样式应用到`<form>`元素上，以确保它不会完全填满页面，而是收缩/围绕它包含的元素包裹：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then copy a number of background style attributes from the`<button>` element
    to the`<form>` element to give the`<form>` element a look that is consistent with
    the theme applied to the standard button widget. Other style elements from the
    theme like font face and font size are applied to the form element by adding the
    `ui-widget` class (highlighted). We end by returning the `this` variable (which
    in our example contains the`<div>` element we selected, but now with the`<form>`
    element we just added to it). This allows for chaining additional jQuery methods:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将来自`<button>`元素的一些背景样式属性复制到`<form>`元素中，以使`<form>`元素的外观与应用于标准按钮小部件的主题保持一致。主题中的其他样式元素，如字体和字体大小，通过添加`ui-widget`类（突出显示）应用到表单元素上。最后，我们通过返回`this`变量（在我们的例子中包含我们选择的`<div>`元素，但现在添加了刚刚添加到其中的`<form>`元素）来完成。这允许我们链式调用额外的jQuery方法：
- en: '[PRE20]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, we still need to define a function that does the actual conversion
    when the button of the unit converter is clicked. It differs slightly from the
    previous implementation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们仍然需要定义一个函数，当单位转换器的按钮被点击时执行实际的转换。它与之前的实现略有不同。
- en: The `convert()` function is passed both the`<button>` element that is clicked
    and a map with conversion factors. The`<form>` element enclosing the button is
    determined with the `parent()` method and stored in the `form` variable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`convert()`函数接收被点击的`<button>`元素和一个包含转换系数的映射。包含按钮的`<form>`元素通过`parent()`方法确定并存储在`form`变量中。'
- en: The input value we want to convert is retrieved from the`<input>` element with
    a `name` attribute equal to `from`. We can find this specific element by selecting
    all children of the`<form>` element stored in `form` and filtering these children
    by passing a suitable selector to the `.children()` method (highlighted).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要转换的输入值是从具有`name`属性等于`from`的`<input>`元素中检索的。我们可以通过选择存储在`form`中的`<form>`元素的所有子元素并传递一个合适的选择器到`.children()`方法（突出显示）来找到这个特定的元素。
- en: 'In a similar way, we determine which option is selected in the two`<select>`
    elements:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们确定两个`<select>`元素中选择了哪个选项：
- en: '[PRE21]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'What is left is the actual conversion. If the conversion units are not equal,
    we retrieve the conversion factor from the map (highlighted) and then multiply
    it by the contents of the`<input>` element interpreted as a floating point number.
    If the input can''t be interpreted as a floating point number or there wasn''t
    a suitable conversion factor in the map, the result of the multiplication is a
    `NaN` (Not a Number) and we signal that fact by placing an error text in the result.
    However, we convert the result to a number with four decimal digits with JavaScript''s
    `toFixed()` method if everything goes well:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是实际的转换。如果转换单位不相等，我们从映射中检索转换系数（突出显示），然后将其乘以`<input>`元素的内容，该内容被解释为浮点数。如果输入不能被解释为浮点数或映射中没有合适的转换系数，乘法的结果是一个`NaN`（不是一个数字），我们通过在结果中放置错误文本来表示这一点。然而，如果一切顺利，我们使用JavaScript的`toFixed()`方法将结果转换为具有四位小数的数字：
- en: '[PRE22]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`unitconverter2.py` concludes by defining an object with defaults:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`unitconverter2.py`通过定义一个具有默认值的对象来结束。'
- en: '[PRE23]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Pop quiz changing option defaults
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验更改选项默认值
- en: 'If we would:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们：
- en: 'Add a unitconvertor to a <div> element with an ID #first.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将单位转换器添加到具有ID #first的`<div>`元素中。'
- en: Add the possibility of converting from cubic feet to liters to the default conversion
    map.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将从立方英尺到升的转换添加到默认转换映射中。
- en: 'And finally, add a unitconverter to a <div> element with an id #last.'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '最后，将一个单位转换器添加到具有ID #last的`<div>`元素中。'
- en: 'The code would look something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来可能像这样：
- en: '[PRE24]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we would execute the preceding code, which <div> element(s) would get a unitconverter
    with the added conversion possibility?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们执行前面的代码，哪些 `<div>` 元素将获得带有附加转换功能的 unitconverter？ '
- en: 'The div with the #first ID'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '带有 #first ID 的 div'
- en: 'The div with the #last ID'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '带有 #last ID 的 div'
- en: Both
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 两者
- en: Designing a spreadsheet application
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计电子表格应用程序
- en: 'Our goal for this chapter was to be able to present the user with a simple
    spreadsheet application and we are nearly there. We know how to serve HTML and
    we saw how we can implement a custom jQuery UI widget, so let''s apply that knowledge
    to designing a spreadsheet plugin. First let''s see how it will look:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章的目标是能够向用户提供一个简单的电子表格应用程序，我们几乎做到了。我们知道如何提供HTML，我们也看到了如何实现自定义jQuery UI小部件，所以让我们将这些知识应用到设计电子表格插件中。首先，让我们看看它将是什么样子：
- en: Time for action serving a spreadsheet application
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候提供电子表格应用程序了
- en: Go to the directory containing the example code for [Chapter 2:](ch02.html "Chapter 2. Creating
    a Simple Spreadsheet")
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 前往包含示例代码的目录，[第2章](ch02.html "第2章. 创建一个简单的电子表格")
- en: Double-click the file `spreadsheet.py`, the now familiar CherryPy console will
    open in a text window.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击文件 `spreadsheet.py`，现在熟悉的CherryPy控制台将在一个文本窗口中打开。
- en: Enter `http://localhost:8080` in the address bar of your browser (or click refresh
    if it is still open on that address). You will now see a simple spreadsheet application:![Time
    for action serving a spreadsheet application](img/3746_2_6.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器地址栏中输入 `http://localhost:8080`（或者如果该地址仍然打开，请点击刷新）。现在您将看到一个简单的电子表格应用程序：![是时候提供电子表格应用程序](img/3746_2_6.jpg)
- en: 'You can click on any cell to edit its formula. You should not start a formula
    with an equal sign: **42, D2+19** and **"text**" (including the double quote marks)
    are examples of valid formulas. In fact, any JavaScript expression is valid.'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以点击任何单元格来编辑其公式。您不应该以等号开始公式：**42, D2+19** 和 **"text**"（包括双引号）是有效的公式的例子。实际上，任何JavaScript表达式都是有效的。
- en: What just happened?
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么？
- en: The spreadsheet application served to the end user consists of two major parts,
    HTML to structure the spreadsheet and some JavaScript to provide interaction.
    We look at each of these in turn.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给最终用户的电子表格应用程序由两个主要部分组成，HTML用于构建电子表格结构，以及一些JavaScript用于提供交互。我们将依次查看这些部分。
- en: 'HTML: keeping it simple'
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML：保持简单
- en: The HTML we need for our spreadsheet is nearly identical to the one for the
    unit converter. The highlighted lines in the following code show the differences.
    `spreadsheet.js` contains the definition of the plugin and the final`<script>`
    element inserts an 8x10 spreadsheet into the `#example` div. Converting a`<div>`
    element to a fully functional spreadsheet widget is just as simple as converting
    to the standard button widget!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的电子表格HTML几乎与单位转换器的HTML相同。以下代码中高亮显示的行显示了差异。`spreadsheet.js` 包含插件的定义，最后的 `<script>`
    元素将一个8x10的电子表格插入到 `#example` div中。将 `<div>` 元素转换为完全功能的电子表格小部件与转换为标准按钮小部件一样简单！
- en: '[PRE25]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'JavaScript: creating a spreadsheet plugin'
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript：创建电子表格插件
- en: The file `spreadsheet.js` contains all JavaScript code needed to implement a
    reusable spreadsheet widget. The spreadsheet is very similar to our unit converter
    from a jQuery perspective although the actual JavaScript to implement the user
    interaction is somewhat more involved. Again our plugin is a function that is
    associated with jQuery's `fn` attribute as it can be seen in the very first line
    in the following code, where we define our widget with the name `sheet`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 文件 `spreadsheet.js` 包含了实现可重用电子表格小部件所需的全部JavaScript代码。从jQuery的角度来看，这个电子表格与我们之前的单位转换器非常相似，尽管实现用户交互的实际JavaScript代码要复杂一些。同样，我们的插件是一个与jQuery的
    `fn` 属性关联的函数，正如在以下代码的第一行中可以看到的，我们使用名称 `sheet` 定义了我们的小部件。
- en: 'Next we merge the default options for the sheet plugin (defined at the end
    of the file) with the options passed to the function:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将电子表格插件（在文件末尾定义）的默认选项与传递给函数的选项合并：
- en: '[PRE26]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The next step is to create a table that will represent our spreadsheet. We
    create this`<table>` element with a number of associated classes: its very own
    `sheet` class to make it easily recognizable as a sheet plugin once created, a
    `ui-helper-reset` class that will cause suitable CSS to be applied by jQuery to
    reset any unwanted default styling added by the browser and finally a `ui-widget`
    class that will cause the selected theme to be applied. Then we create the table
    contents step-by-step by adding the needed HTML to a variable `t` in incremental
    steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个将代表我们的电子表格的表格。我们通过添加所需的HTML到变量`t`中，逐步创建这个`<table>`元素，并赋予它一系列相关的类：一个独特的`sheet`类，以便一旦创建就可以轻松识别为电子表格插件，一个`ui-helper-reset`类，这将导致jQuery应用适当的CSS以重置浏览器添加的任何不想要的默认样式，最后是一个`ui-widget`类，这将导致应用选定的主题。然后我们逐步创建表格内容，通过逐步添加所需的HTML到变量`t`中：
- en: '[PRE27]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The table contains a`<thead>` element that will be styled as a `ui-widget-header`.
    It contains a single row of`<th>` elements. These`<th>` elements contain the column
    label, a capital letter that we construct from the column index with the `fromCharCode()`
    method (highlighted):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表格包含一个将被设置为`ui-widget-header`样式的`<thead>`元素。它包含一个`<th>`元素的单一行。这些`<th>`元素包含列标签，一个由`fromCharCode()`方法构造的大写字母，该字母来自列索引（突出显示）：
- en: '[PRE28]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The body of the table consists of a`<tbody>` element containing a number of
    rows with`<td>` elements. The first`<td>` element of each row contains the row
    label (a number) and will be styled as a `ui-widget-header` just like the column
    labels. The regular cells, that is the ones that will contain our formulas and
    values, will belong to the class `ui-widget-content` to style them in an appropriate
    manner. These cells will also belong to a class `cell` to make them easy to distinguish
    when we add additional functionality to them (highlighted).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的主体由一个包含多个行和`<td>`元素的`<tbody>`元素组成。每一行的第一个`<td>`元素包含行标签（一个数字）并将被设置为`ui-widget-header`样式，就像列标签一样。常规单元格，即包含我们的公式和值的单元格，将属于`ui-widget-content`类以适当地样式化。这些单元格还将属于一个`cell`类，以便在我们向它们添加附加功能时容易区分（突出显示）。
- en: There is initially no content in such a cell except for a`<span>` element that
    will contain the formula and that will be styled as `ui-helper-hidden`, rendering
    the formula invisible. The value of the evaluated formula will be stored both
    as text content in the`<td>` element (side-by-side with the`<span>` element) and
    as a global variable with a name equal to the name of the cell. A global variable
    in this context is a named attribute of the top-level `window` object defined
    by the browser that may be accessed as `window[name]`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样的单元格中最初没有任何内容，除了一个将包含公式并设置为`ui-helper-hidden`样式的`<span>`元素，这使得公式不可见。评估后的公式的值将同时以文本内容的形式存储在`<td>`元素中（与`<span>`元素并排），以及作为一个与单元格名称相同的全局变量。在这个上下文中，全局变量是浏览器定义的顶层`window`对象的一个命名属性，可以通过`window[name]`访问。
- en: 'Storing the value of a cell in a global variable as well allows us to use any
    JavaScript expression as the formula in a cell because we can now refer to the
    value of any other cell by name. `A1+B3*9`, for example will be a perfectly valid
    expression because `A1` and `B3` will be defined as global variables:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 将单元格的值存储在全局变量中同样允许我们使用任何JavaScript表达式作为单元格中的公式，因为我们现在可以通过名称引用任何其他单元格的值。例如，`A1+B3*9`将是一个完全有效的表达式，因为`A1`和`B3`将被定义为全局变量：
- en: '[PRE29]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The HTML for the table we created in the `t` variable is then inserted into
    the jQuery selection that we applied the `sheet()` method with the `.append()`
    method of the `this` object. The `this` object is available to any function defining
    a plugin and holds the current jQuery selection.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的表格的HTML被插入到我们使用`sheet()`方法并使用`this`对象的`.append()`方法应用的jQuery选择器中。`this`对象对任何定义插件的函数都是可用的，并持有当前的jQuery选择器。
- en: To edit a cell, we will employ the jEditable plugin. This plugin will take care
    of the user interaction when the user clicks a cell to edit its content. To do
    this it needs functions to get and set the contents of a cell.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要编辑一个单元格，我们将使用jEditable插件。这个插件将处理用户点击单元格以编辑其内容时的用户交互。为此，它需要获取和设置单元格内容的功能。
- en: Note
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The jEditable plugin we use here is included in the example code distributed
    with this chapter. The latest version can be obtained from Mika Tuupola''s website:
    [http://www.appelsiini.net/projects/jeditable](http://www.appelsiini.net/projects/jeditable).
    It comes with a pretty comprehensive set of documentation. Turning a`<td>` element
    into something that changes into an editable textbox when the user clicks on it
    with a mouse, is as simple as selecting the element and invoking the `editable()`
    method. For example, `$(".editable").editable("[http://www.example.com/save](http://www.example.com/save)")`
    will render any element with the `editable` class into an editable textbox once
    clicked and will send the edited contents to the URL passed as the first parameter
    to the `editable()` method. The jEditable plugin comes with a host of options
    and we will encounter a few of them when we employ the jEditable plugin to do
    the editing of the spreadsheet cells.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用的 jEditable 插件包含在本章提供的示例代码中。最新版本可以从 Mika Tuupola 的网站获取：[http://www.appelsiini.net/projects/jeditable](http://www.appelsiini.net/projects/jeditable)。它附带了一套相当全面的文档。将
    `<td>` 元素转换为当用户用鼠标点击时变为可编辑文本框的功能，就像选择元素并调用 `editable()` 方法一样简单。例如，`$(".editable").editable("[http://www.example.com/save](http://www.example.com/save)")`
    会在点击后使任何具有 `editable` 类的元素变为可编辑文本框，并将编辑后的内容发送到作为 `editable()` 方法第一个参数传递的 URL。jEditable
    插件附带了许多选项，当我们使用 jEditable 插件编辑电子表格单元格时，我们将遇到其中的一些。
- en: 'We need to define a function that will be invoked by jEditable for extracting
    the content of the element. This function will require two arguments:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要定义一个函数，该函数将由 jEditable 调用以提取元素的内容。此函数将需要两个参数：
- en: The element we are editing (a`<td>` element in our example).
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在编辑的元素（在我们的例子中是一个 `<td>` 元素）。
- en: The original settings passed to the jEditable plugin. Those settings we ignore
    for now.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给 jEditable 插件的原设置。我们现在忽略这些设置。
- en: The`<td>` elements are structured in such a way that the formula itself is stored
    in a (hidden) span element. The `getvalue()` function then must get access to
    this`<span>` element first before it can obtain the formula.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`<td>` 元素的结构是这样的，公式本身存储在一个（隐藏的）`<span>` 元素中。然后 `getvalue()` 函数必须首先获取对这个 `<span>`
    元素的访问权限，然后才能获取公式。'
- en: 'Therefore, we convert the`<td>` element first to a jQuery object (highlighted)
    and then filter the elements it contains to just elements with a class of `formula`.
    This amounts to just the`<span>` element whose text is the formula we are after:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们首先将 `<td>` 元素转换为 jQuery 对象（高亮显示），然后过滤它包含的元素，只保留具有 `formula` 类的元素。这相当于我们想要的文本是公式的
    `<span>` 元素：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The corresponding `setvalue()` function is used by jEditable to store the edited
    formula again in the`<td>` element. When called this function is passed two arguments:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对应的 `setvalue()` 函数被 jEditable 用于将编辑后的公式再次存储在 `<td>` 元素中。当调用此函数时，它传递两个参数：
- en: The edited content of the element.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 元素的编辑内容。
- en: The original settings passed to the jEditable plugin and its code is quite complicated
    because storing the formula is not the only thing it has to do. It must also calculate
    the result of the formula and update any cells that depend on the updated cell.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 传递给 jEditable 插件的原设置及其代码相当复杂，因为存储公式不是它唯一要做的。它还必须计算公式的结果并更新依赖于更新单元格的任何单元格。
- en: The cell we are editing (that is the`<td>` element) is available as the `this`
    variable. We stored the cell index as its `id` attribute so we retrieve that one
    first (highlighted). The `value` argument that was passed to the `setvalue()`
    function is the edited formula.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在编辑的单元格（即 `<td>` 元素）作为 `this` 变量可用。我们将单元格索引存储为其 `id` 属性，所以我们首先检索它（高亮显示）。传递给
    `setvalue()` 函数的 `value` 参数是编辑后的公式。
- en: 'As we use JavaScript syntax for these formulas, we can simply call JavaScript''s
    `eval()` function to calculate the value of the formula. We have to store the
    result in global variables with the name of the cell as well to make it reusable
    by other cells. Note that these global variables are just attributes of the `window`
    object in the context of the browser so assigning a value to such an attribute
    is just what we do inside the `if … else …` clause. If the result of evaluating
    the formula was undefined in some way (for example, because of an error) we set
    the result to the string`''#undef''` to signal that situation to the user:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用JavaScript语法编写这些公式，我们可以简单地调用JavaScript的`eval()`函数来计算公式的值。我们必须将结果存储在具有单元格名称的全局变量中，以便其他单元格可以重复使用。请注意，这些全局变量只是浏览器上下文中`window`对象的属性，因此将值分配给此类属性就是我们在`if
    … else …`子句内部所做的。如果评估公式的结果以某种方式未定义（例如，由于错误），我们将结果设置为字符串`'#undef'`，以向用户指示这种情况：
- en: '[PRE31]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After we have evaluated the formula of the current cell and stored its result
    we must now recalculate all other cells because they may depend on the contents
    of the cell we just changed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们评估了当前单元格的公式并存储了其结果之后，我们现在必须重新计算所有其他单元格，因为它们可能依赖于我们刚刚更改的单元格的内容。
- en: 'We do affect this by selecting all cells in the sheet and applying a function
    to each of them (highlighted). If we are looking at a different cell than the
    one just changed (something we determine by comparing their `id` attributes),
    we recalculate the formula contained in its`<span>` element. If the result is
    different from the previous value stored for a cell we set the change variable
    to true. We repeat the whole procedure until nothing is changed or we repeated
    ourselves more often than there are cells in the sheet, at which point we must
    have a circular reference somewhere, something we indicate to the user by setting
    the value of the cell to a suitable text. This is certainly not the most efficient
    method to recalculate a spreadsheet, nor is it a failsafe method to detect all
    circular references but it works well enough:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过选择工作表中的所有单元格并对每个单元格应用一个函数（突出显示）来影响这一点。如果我们正在查看的不是刚刚更改的单元格（我们通过比较它们的`id`属性来确定这一点），我们将重新计算其`<span>`元素中包含的公式。如果结果与为单元格存储的先前值不同，我们将更改变量设置为true。我们重复整个过程，直到没有变化，或者我们重复的次数比工作表中的单元格多，这时我们必须在某处有一个循环引用，我们通过将单元格的值设置为合适的文本来向用户指示这一点。这当然不是重新计算电子表格的最有效方法，也不是检测所有循环引用的万无一失的方法，但它足够有效：
- en: '[PRE32]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The purpose of defining functions to set and get a value from a`<td>` element
    was to be able to apply the jEditable plugin to every cell. This we do in the
    final lines of our `sheet` plugin. We find all children with a `cell` class (highlighted)
    and invoke an anonymous function on each of them.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 定义函数以从`<td>`元素设置和获取值的目的是能够将jEditable插件应用到每个单元格。我们在`sheet`插件的最后几行这样做。我们找到所有具有`cell`类的子元素（突出显示），并对每个子元素调用一个匿名函数。
- en: This function first applies the jEditable plugin on the element by invoking
    the `editable()` method with a reference to our `setvalue()` function as the first
    argument and an options object as the second argument. The `type` attribute marks
    this editable element as a text element (and not, for example, a multiline text
    area element), whereas setting `onblur` to `cancel` indicates that on clicking
    outside the cell when editing will revert the content to its original. The `data`
    attribute points to our `getvalue()` function to indicate to the plugin how to
    get the value that we want to edit.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数首先通过调用`editable()`方法并使用对`setvalue()`函数的引用作为第一个参数以及一个选项对象作为第二个参数，在元素上应用jEditable插件。`type`属性将此可编辑元素标记为文本元素（而不是，例如，多行文本区域元素），而将`onblur`设置为`cancel`表示在编辑时点击单元格外部将内容恢复到原始状态。`data`属性指向我们的`getvalue()`函数，以指示插件如何获取我们想要编辑的值。
- en: 'The second thing the function does is applies CSS style attributes to each
    cell. In this case a fixed `width` and the `border-collapse` attribute will make
    sure that the border between cells is just as wide as the border on outlying cells:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的第二个作用是应用CSS样式属性到每个单元格。在这种情况下，固定的`width`和`border-collapse`属性将确保单元格之间的边框与外围单元格的边框一样宽：
- en: '[PRE33]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`spreadsheet.js` is completed with the definition of a default options object:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`spreadsheet.js`通过定义一个默认选项对象来完成：'
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Have a go hero adding math functions
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试添加数学函数的英雄
- en: In the spreadsheet we designed, the user may use any JavaScript expression as
    the cell formula. That's fine if we want to use operators like addition (+) or
    multiplication (*), but what if we would like to use, for example, trigonometric
    functions like `sin()` or `cos()?`
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设计的电子表格中，用户可以使用任何JavaScript表达式作为单元格公式。如果我们想使用加法（+）或乘法（*）这样的运算符，那是没有问题的，但如果我们想使用，例如，正弦函数（`sin()`）或余弦函数（`cos()`）这样的三角函数呢？
- en: 'This is possible by referring to the methods of the built-in JavaScript object
    `Math` (an example would be `Math.sin(A1)+Math.cos(B1))` but prefixing every function
    with `Math` is awkward. Devise a way to make these functions available without
    the `Math` prefix. (Hint: we already saw how to create names in the global namespace
    by assigning to `window[<name>])`.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过引用内置JavaScript对象`Math`的方法（例如`Math.sin(A1)+Math.cos(B1)`）来实现，但每个函数前都加上`Math`前缀显得有些笨拙。设计一种方法，使这些函数在没有`Math`前缀的情况下可用。（提示：我们已经在全局命名空间中创建名称的方法中看到了如何进行赋值`window[<name>])`。
- en: A solution can be found in `spreadsheet2.js`. Its effects can be tested by running
    `spreadsheet2.py`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在`spreadsheet2.js`中可以找到解决方案。其效果可以通过运行`spreadsheet2.py`来测试。
- en: The missing parts
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缺失的部分
- en: In designing and building a spreadsheet application we saw that it is relatively
    simple to implement quite sophisticated user interaction by making full use of
    the jQuery and jQuery UI libraries and choosing wisely from the wide array of
    available additional plugins like jEditable.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和构建电子表格应用程序时，我们发现通过充分利用jQuery和jQuery UI库，并明智地选择广泛可用的附加插件（如jEditable），实现相当复杂的用户交互相对简单。
- en: However, although our spreadsheet application was served from the CherryPy server,
    the functionality of the application was limited to client-side activity only.
    For example, there is no possibility to save or load a spreadsheet on the server,
    and neither is there a way to limit the access to our spreadsheet to authorized
    users only. Both requirements depend on ways to store data in a persistent manner
    and dealing with persistence will be the next step on our road to developing web
    applications.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管我们的电子表格应用程序是由CherryPy服务器提供的，但应用程序的功能仅限于客户端活动。例如，服务器上没有保存或加载电子表格的可能性，也没有限制对电子表格访问仅限于授权用户的方法。这两个要求都依赖于以持久方式存储数据的方法，而处理持久性将是我们在开发Web应用程序道路上的下一步。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'We have learned a lot in this chapter. Specifically, we covered:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了很多。具体来说，我们涵盖了：
- en: How to create an environment to develop and deliver our applications. We saw
    how to install Python, CherryPy, and the jQuery and jQuery UI frameworks.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个开发和交付我们应用程序的环境。我们看到了如何安装Python、CherryPy以及jQuery和jQuery UI框架。
- en: The design of a simple spreadsheet application.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单电子表格应用程序的设计。
- en: How to configure CherryPy to deliver static and dynamic content.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何配置CherryPy以提供静态和动态内容。
- en: How to use standard jQuery UI widgets and third party plugins; specifically,
    the button widget and the jEditable plugin.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用标准的jQuery UI小部件和第三方插件；特别是按钮小部件和jEditable插件。
- en: The implementation of our own jQuery plugin.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们自己的jQuery插件的实现。
- en: We also discussed how to reuse jQuery UI's concept of `ui-widget` classes to
    style our own widget components in a way that blends seamlessly with jQuery UI's
    themes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还讨论了如何重用jQuery UI的`ui-widget`类概念来以与jQuery UI主题无缝融合的方式对我们的小部件组件进行样式化。
- en: Now that we've learned about the client-side of web applications, we're ready
    to tackle server-side issues which is the topic of the next chapter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Web应用程序的客户端，我们准备解决服务器端问题，这是下一章的主题。
