- en: Chapter 11. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章 最佳实践
- en: In this chapter, we will explore best practices related to our Python GUI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨与我们的Python图形用户界面相关的最佳实践。
- en: Avoiding spaghetti code
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免意大利面式代码
- en: Using __init__ to connect modules
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `__init__` 连接模块
- en: Mixing fall-down and OOP coding
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合面向对象编程（OOP）和瀑布式开发
- en: Using a code naming convention
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用代码命名约定
- en: When not to use OOP
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时不使用面向对象编程
- en: How to use design patterns successfully
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何成功使用设计模式
- en: Avoiding complexity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: In this chapter, we will explore different best practices that can help us to
    build our GUI in an efficient way and keep it both maintainable and extendible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨不同的最佳实践，这些实践可以帮助我们以高效的方式构建我们的图形用户界面（GUI），并保持其可维护性和可扩展性。
- en: These best practices will also help us to debug our GUI to get it just the way
    we want it to be.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最佳实践也将帮助我们调试我们的GUI，使其达到我们想要的样子。
- en: Avoiding spaghetti code
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免意大利面式代码
- en: In this recipe, we will explore a typical way to create spaghetti code and then
    we will see a much better way of how to avoid such code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨创建 spaghetti 代码的典型方法，然后我们将看到一种避免此类代码的更好方法。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Spaghetti code is code in which a lot of functionality is intertangled.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码是指功能相互交织在一起的代码。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a new, simple GUI written in Python using the tkinter built-in
    Python library.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用内置的 Python 库 tkinter 创建一个新且简单的 GUI。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Having searched online and read the documentation, we might start by writing
    the following code to create our GUI:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上搜索并阅读了文档之后，我们可能首先会编写以下代码来创建我们的图形用户界面：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Running the preceding code results in the following GUI:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码将产生以下图形用户界面：
- en: '![How to do it...](img/B04829_11_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_01.jpg)'
- en: 'This is not quite the GUI we intended. We wanted it to look something more
    like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们想要的图形用户界面。我们希望它看起来更像是这样：
- en: '![How to do it...](img/B04829_11_02.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_02.jpg)'
- en: While the spaghetti code created a GUI, the code is very hard to debug because
    there is so much confusion in the code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段意大利面代码创建了一个图形用户界面，但由于代码中存在很多混乱，这段代码非常难以调试。
- en: 'The following is the code that produces the desired GUI:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为生成所需图形用户界面的代码：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we compared spaghetti code to good code. Good code has many
    advantages over the spaghetti code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们比较了面条代码和良好代码。良好代码相对于面条代码具有许多优势。
- en: It has clearly commented sections.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 它有清晰的注释部分。
- en: 'Spaghetti code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Good code:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It has a natural flow that follows how the widgets get laid out in the GUI main
    form.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它具有一种自然流动，遵循小部件在GUI主表单中的布局方式。
- en: In the spaghetti code, the bottom LabelFrame gets created before the top LabelFrame
    and it is intermixed with an import statement and some widget creation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在面条代码中，底部的LabelFrame在顶部LabelFrame之前被创建，并且它与一个导入语句和一些小部件创建混合在一起。
- en: 'Spaghetti code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Good code:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It does not contain unnecessary variable assignments and neither does it have
    a `print` function that does not do the debugging one might expect it to do when
    reading the code.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它不包含不必要的变量赋值，也没有一个`print`函数，这个函数并不能完成阅读代码时人们期望它所做的调试工作。
- en: 'Spaghetti code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Good code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码：
- en: Has none of the above.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 没有以上任何一种。
- en: The `import` statements only import the required modules. They are not cluttered
    throughout the code. There are no duplicate `import` statements. There is no `import
    *` statement.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`import` 语句仅导入所需的模块。它们不会在代码中造成混乱。没有重复的 `import` 语句。没有 `import *` 语句。'
- en: 'Spaghetti code:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Good code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The chosen variable names are quite meaningful. There are no unnecessary `if`
    statements that use the number `1` instead of `True`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的变量名非常有意义。没有不必要的`if`语句使用数字`1`代替`True`。
- en: 'Spaghetti code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Good code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 好的代码：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We did not lose the intended window title and our check button ended up in the
    correct position. We also made the `LabelFrame` surrounding the check button visible.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有丢失预期的窗口标题，并且我们的复选按钮最终位于正确的位置。我们还使围绕复选按钮的`LabelFrame`可见。
- en: 'Spaghetti code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 意大利面代码：
- en: We lost both the window title and did not display the top `LabelFrame`. The
    check button ended up in the wrong place.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们丢失了窗口标题，并且没有显示顶部的`LabelFrame`。检查按钮最终出现在了错误的位置。
- en: 'Good code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的代码：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Using __init__ to connect modules
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `__init__` 连接模块
- en: When we create a new Python project using the PyDev plugin for the Eclipse IDE,
    it automatically creates a `__init__.py` module. We can also create it ourselves
    manually when not using Eclipse.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用 Eclipse IDE 的 PyDev 插件创建一个新的 Python 项目时，它会自动创建一个 `__init__.py` 模块。如果我们不使用
    Eclipse，我们也可以手动创建它。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The `__init__.py` module is usually empty and then has a size of 0 kilobytes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 模块通常为空，其大小为 0 千字节。'
- en: We can use this usually empty module to connect different Python modules by
    entering code into it. This recipe will show how to do this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个通常为空的模块，通过向其中输入代码来连接不同的Python模块。本食谱将展示如何进行这一操作。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a new GUI similar to the one we created in the previous recipe.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个与之前菜谱中创建的类似的新的图形用户界面。
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: As our project becomes larger and larger, we naturally break it out into several
    Python modules. Using a modern IDE such as Eclipse, it is surprisingly complicated
    to find modules that are located in different subfolders either above or below
    the code that needs to import it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的项目规模越来越大，我们自然会将其拆分成几个Python模块。使用像Eclipse这样的现代IDE，查找位于不同子文件夹中、要么在需要导入它的代码之上要么之下的模块，竟然出奇地复杂。
- en: One practical way to get around this limitation is to use the `__init__.py`
    module.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 克服这一限制的一个实用方法是使用`__init__.py`模块。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In Eclipse, we can set the Eclipse internal project environment to certain folders
    and our Python code will find it. But outside of Eclipse, for example when running
    from a command window, there is sometimes a mismatch in the Python module import
    mechanism and the code will not run.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Eclipse 中，我们可以将 Eclipse 内部项目环境设置为特定的文件夹，我们的 Python 代码将会找到它。但 outside of Eclipse，例如从命令窗口运行时，Python
    模块导入机制有时会出现不匹配，导致代码无法运行。
- en: Here is a screenshot of the empty `__init__.py` module, which appears not with
    the name `__init__` but with the name of the PyDev package it belongs to when
    opened in the Eclipse code editor. The "1" on the left side of the code editor
    is the line number and not any code written in this module. There is absolutely
    no code in this empty `__init__.py` module.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是空的 `__init__.py` 模块的截图，当在 Eclipse 代码编辑器中打开时，它显示的不是 `__init__` 这个名字，而是它所属的
    PyDev 包的名字。"1" 位于代码编辑器的左侧是行号，而不是在这个模块中编写的任何代码。这个空的 `__init__.py` 模块中绝对没有任何代码。
- en: '![How to do it...](img/B04829_11_03.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_03.jpg)'
- en: This file is empty, but it does exist.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件为空，但它确实存在。
- en: '![How to do it...](img/B04829_11_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_04.jpg)'
- en: When we run the following code and click the `clickMe Button`, we get the result
    shown following the code. This is a regular Python module that does not yet use
    the `__init__.py` module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行以下代码并点击`clickMe 按钮`，我们会得到代码下方显示的结果。这是一个尚未使用`__init__.py`模块的常规 Python 模块。
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The __`init__.py` module is not the same as the `__init__(self)` method of a
    Python class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__.py` 模块与 Python 类的 `__init__(self)` 方法并不相同。'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![How to do it...](img/B04829_11_05.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_05.jpg)'
- en: 'In the preceding code, we created the following function, which imports Python''s
    message box and then uses it to display the message box window:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了以下函数，该函数导入Python的消息框，然后使用它来显示消息框窗口：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When we move the `clickMe()` message box code into a nested directory folder
    and try to `import` it into our GUI module, we run into some problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`clickMe()`消息框代码移动到嵌套的目录文件夹中，并尝试将其`导入`到我们的GUI模块时，我们遇到了一些问题。
- en: We have created three sub-folders below where our Python module lives. We then
    placed the `clickMe()` message box code into a new Python module, which we named
    `MessageBox.py`. This module lives in `Folder3`, three levels below where our
    Python module lives.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Python模块所在的下方创建了三个子文件夹。然后我们将`clickMe()`消息框代码放入了一个新的Python模块中，我们将其命名为`MessageBox.py`。这个模块位于`Folder3`中，距离我们的Python模块有三层。
- en: We need to import this `MessageBox.py` module in order to use the `clickMe()`
    function that this module contains.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要导入这个`MessageBox.py`模块，以便使用该模块包含的`clickMe()`函数。
- en: At first, it appears to work because it seems we can import the new nested module
    as we are not getting any errors or warnings from the Eclipse IDE.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，它似乎可以正常工作，因为我们从 Eclipse IDE 没有收到任何错误或警告，看起来我们可以像导入其他模块一样导入这个新的嵌套模块。
- en: 'We are using Python''s relative import syntax:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Python 的相对导入语法：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This can be seen in the following screenshot:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在以下屏幕截图中看到：
- en: '![How to do it...](img/B04829_11_06.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_06.jpg)'
- en: 'We have deleted the local `clickMe()` function and now our callback should
    use the imported `clickMe()` function, but it is not working as expected. Instead
    of the expected popup window, we get an import system error when we run the code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了本地的`clickMe()`函数，现在我们的回调应该使用导入的`clickMe()`函数，但它并没有按预期工作。当我们运行代码时，没有得到预期的弹出窗口，而是出现了一个导入系统错误：
- en: '![How to do it...](img/B04829_11_07.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_07.jpg)'
- en: We can add the subfolder where our new function lives as an external library
    in Eclipse by going to the PyDev Project properties and adding ourselves as an
    external library. This does not seem very intuitive, but it does work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过访问 PyDev 项目的属性，并将我们自己的新函数所在的子文件夹添加为外部库，在 Eclipse 中将其添加为外部库。这看起来可能不太直观，但它确实有效。
- en: '![How to do it...](img/B04829_11_08.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_08.jpg)'
- en: When we now comment out the folder structure and, instead, directly import the
    function from the module which is nested to three levels, the code works as expected.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在注释掉文件夹结构，而是直接从嵌套了三层的模块中导入函数时，代码按预期工作。
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This function displays a different text in a message box:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数在消息框中显示不同的文本：
- en: '![How to do it...](img/B04829_11_09.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_09.jpg)'
- en: A better way to achieve the same result is to use Python's built-in `__init__.py`
    module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相同结果的一个更好的方法是使用 Python 内置的 `__init__.py` 模块。
- en: After deleting the previously Eclipse-specific external library dependency,
    we can now use this module directly.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 删除了之前特定的 Eclipse 外部库依赖后，我们现在可以直接使用此模块。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The code we place into this module runs before all of our other code if we import
    the `__init__.py` module into our program, as of Python 3.4.3.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将代码放入此模块，如果我们在程序中导入`__init__.py`模块，那么在Python 3.4.3版本中，这段代码将先于我们其他所有代码执行。
- en: Ignore the PyDev Unresolved Import (red circle with a cross) error. This `import`
    is necessary; it makes our code run and the entire Python importing mechanism
    work.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略 PyDev 未解析导入（带叉号的红色圆圈）错误。这个 `import` 是必要的；它使我们的代码运行，并使整个 Python 导入机制正常工作。
- en: '![How to do it...](img/B04829_11_10.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_10.jpg)'
- en: After importing the `__init__.py` module into our program, we can use it. The
    first test to check if it works is to code a print statement into this module.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`__init__.py`模块导入到我们的程序之后，我们就可以使用它了。第一个测试它是否工作的是在这个模块中编写一个打印语句。
- en: '![How to do it...](img/B04829_11_11.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_11.jpg)'
- en: 'By adding the following code, we can find out programmatically where we are
    located:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加以下代码，我们可以通过编程方式找出我们的位置：
- en: '![How to do it...](img/B04829_11_12.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_12.jpg)'
- en: 'Now, we can initialize our Python search path from within this `__init__.py`
    module by adding the following code to the same `__init__.py` module:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在本地的`__init__.py`模块中初始化Python搜索路径，只需将以下代码添加到相同的`__init__.py`模块中：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When we now run our GUI code, we get the same expected windows, but we have
    removed our dependency on the Eclipse `PYTHONPATH` variable.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行我们的GUI代码时，我们得到相同的预期窗口，但我们已经移除了对Eclipse `PYTHONPATH`变量的依赖。
- en: Now we can successfully run the same code outside of the Eclipse PyDev plugin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在Eclipse PyDev插件之外成功运行相同的代码。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Our code has become more Pythonic.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码变得更加Pythonic。
- en: How it works...
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we discovered a limitation of using the PyDev plugin, which
    comes free with the wonderful and free Eclipse IDE.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们发现了一个使用免费随Eclipse IDE提供的出色且免费的PyDev插件的局限性。
- en: We first found a workaround in the Eclipse IDE, and next, we became independent
    from this IDE by becoming Pythonic.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 Eclipse IDE 中找到了一种解决方案，然后通过变得 Pythonic，我们摆脱了这一 IDE 的依赖。
- en: Note
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Using pure Python is usually the best way to go.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯Python通常是最佳选择。
- en: Mixing fall-down and OOP coding
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 混合面向对象编程（OOP）和瀑布式开发
- en: Python is an object-oriented programming language yet it does not always make
    sense to use OOP. For simple scripting tasks, the legacy waterfall coding style
    is still appropriate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是一种面向对象的编程语言，但并不总是使用面向对象编程（OOP）有意义。对于简单的脚本任务，传统的瀑布式编码风格仍然适用。
- en: In this recipe, we will create a new GUI that mixes both the fall-down coding
    style with the more modern OOP coding style.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个新的图形用户界面（GUI），它结合了传统的逐行编码风格和更现代的面向对象编程（OOP）风格。
- en: We will create an OOP-style class that will display a tooltip when we hover
    the mouse over a widget in a Python GUI that we will create using a waterfall
    style.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个面向对象的类，当我们将鼠标悬停在用瀑布式创建的Python GUI中的小部件上时，它将显示一个工具提示。
- en: Note
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Fall-down and waterfall coding styles are the same. It means that we have to
    physically place code above code before we can call it from the code below. In
    this paradigm, the code literally falls down from the top of our program to the
    bottom of our program when we execute the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 下降式和瀑布式编码风格是相同的。这意味着我们必须在物理上将代码放置在代码之上，然后才能从下面的代码中调用它。在这个范式下，当我们执行代码时，代码实际上是从程序顶部逐行下降到程序底部的。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will create a GUI using tkinter, which is similar to the
    GUI we created in the first chapter of this book.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用tkinter创建一个GUI，这与本书第一章中创建的GUI类似。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In Python, we can bind functions to classes by turning them into methods using
    the `self` keyword. This is a truly wonderful capability of Python and it allows
    us to create large systems that are understandable and maintainable.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们可以通过使用`self`关键字将函数绑定到类中，将其转换为方法。这是Python真正美妙的功能之一，它使我们能够创建可理解和可维护的大型系统。
- en: Sometimes, when we only write short scripts, OOP does not make sense because
    we find ourselves prepending a lot of variables with the `self` keyword and the
    code gets unnecessarily large when it does not need to be.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当我们只编写简短的脚本时，面向对象编程（OOP）并不适用，因为我们发现自己需要在很多变量前加上`self`关键字，而当代码不需要这样大时，它就会变得不必要地庞大。
- en: Let's first create a Python GUI using tkinter and code it in the waterfall style.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用tkinter创建一个Python GUI，并以瀑布式进行编码。
- en: 'The following code creates the GUI:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码创建GUI：
- en: '[PRE17]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When we run the code, we get the GUI and it looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行代码时，我们会得到图形用户界面，它看起来是这样的：
- en: '![How to do it...](img/B04829_11_13.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_13.jpg)'
- en: We can improve our Python GUI by adding tooltips. The best way to do this is
    to isolate the code that creates the tooltip functionality from our GUI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加工具提示来改进我们的 Python 图形用户界面。实现这一点的最佳方式是将创建工具提示功能的代码从我们的 GUI 中分离出来。
- en: We do this by creating a separate class that has the tooltip functionality,
    and then we create an instance of this class in the same Python module that creates
    our GUI.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个具有提示功能的不同类来实现这一点，然后我们在创建我们GUI的同一Python模块中创建这个类的实例。
- en: Using Python, there is no need to place our `ToolTip` class into a separate
    module. We can place it just above the procedural code and then call it from below
    this code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python，我们无需将我们的`ToolTip`类放入一个单独的模块中。我们只需将它放置在过程代码之上，然后从该代码下方调用它。
- en: 'The code now looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在看起来是这样的：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Running the code creates tooltips for our widgets when we hover the mouse over
    them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会在我们鼠标悬停在组件上时为我们的组件创建工具提示。
- en: '![How to do it...](img/B04829_11_14.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_14.jpg)'
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created a Python GUI in a procedural way, and later, we added
    a class to the top of the module.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们以过程式的方式创建了一个Python GUI，后来，我们在模块顶部添加了一个类。
- en: We can very easily mix and match both procedural and OOP programming in the
    same Python module.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地在同一个Python模块中混合使用过程式和面向对象编程。
- en: Using a code naming convention
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用代码命名约定
- en: The previous recipes in this book have not used a structured code naming convention.
    This recipe will show you the value of adhering to a code naming scheme because
    it helps us to find the code we want to extend, as well as reminds us of the design
    of our program.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本书之前提供的食谱尚未使用结构化的代码命名约定。本食谱将向您展示遵循代码命名方案的价值，因为它有助于我们找到想要扩展的代码，同时也提醒我们关于程序设计的考虑。
- en: Getting ready
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will look at the Python module names from the first chapter
    of this book and compare them to better naming conventions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看本书第一章中的Python模块名称，并将它们与更好的命名约定进行比较。
- en: How to do it...
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In the first chapter of this book, we created our first Python GUI. We improved
    our GUI by incrementing the different code module names via sequential numbers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一章中，我们创建了我们的第一个Python图形用户界面。我们通过递增不同的代码模块名称的序号来改进我们的GUI。
- en: 'It looked like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来是这样的：
- en: '![How to do it...](img/B04829_11_15.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_15.jpg)'
- en: While this is a typical way to code, it does not provide much meaning. When
    we write our Python code during development, it is very easy to increment numbers.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一种典型的编码方式，但它并没有提供太多意义。当我们开发时编写Python代码，很容易增加数字。
- en: Later, coming back to this code, we don't have much of an idea which Python
    module provides which functionality, and sometimes, our last incremented modules
    are not as good as earlier versions.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 后来，当我们回到这段代码时，我们并不清楚哪个Python模块提供了哪些功能，有时，我们最近更新的模块并不如早期版本好。
- en: Note
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A clear naming convention does help.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 明确的命名规范确实有帮助。
- en: We can compare the module names from [Chapter 1](ch01.html "Chapter 1. Creating
    the GUI Form and Adding Widgets"), *Creating the GUI Form and Adding Widgets*,
    to the names from [Chapter 8](ch08.html "Chapter 8. Internationalization and Testing"),
    *Internationalization and Testing*, which are much more meaningful.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将[第1章](ch01.html "第1章。创建GUI表单和添加小部件")中的模块名称*创建GUI表单和添加小部件*与[第8章](ch08.html
    "第8章。国际化与测试")中的名称*国际化与测试*进行比较，后者要更有意义。
- en: '![How to do it...](img/B04829_11_16.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_16.jpg)'
- en: While not perfect, the names chosen for the different Python modules, indicate
    what each module's responsibility is. When we want to add more unit tests, it
    is clear in which module they reside.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并不完美，但为不同的 Python 模块选定的名称表明了每个模块的责任所在。当我们想要添加更多单元测试时，可以清楚地知道它们位于哪个模块中。
- en: 'The following is another example of how to use a code naming convention to
    create a GUI in Python:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用代码命名规范在Python中创建GUI的另一个示例：
- en: '![How to do it...](img/B04829_11_17.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_17.jpg)'
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Replace the word `PRODUCT` with the product you are currently working on.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将单词 `PRODUCT` 替换为你目前正在工作的产品名称。
- en: The entire application is a GUI. All parts are connected. The `DEBUG.py` module
    is only used for debugging our code. The main function to invoke the GUI has its
    name reversed when compared to all of the other modules. It starts with `Gui`
    and ends in a `.pyw` extension.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 整个应用程序是一个图形用户界面。所有部分都是相互连接的。`DEBUG.py`模块仅用于调试我们的代码。与所有其他模块相比，调用GUI的主要函数名称是反向的。它以`Gui`开头，以`.pyw`扩展名结尾。
- en: It is the only Python module that has this extension name.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是唯一具有此扩展名的 Python 模块。
- en: From this naming convention, if you are familiar enough with Python, it will
    be obvious that, in order to run this GUI, you double-click the `Gui_PRODUCT.pyw`
    module.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个命名规范来看，如果你对 Python 足够熟悉，那么很明显，为了运行这个图形用户界面，你需要双击 `Gui_PRODUCT.pyw` 模块。
- en: All other Python modules contain functionality to supply to the GUI as well
    as execute the underlying business logic to fulfil the purpose this GUI addresses.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他Python模块都包含向GUI提供功能以及执行底层业务逻辑以实现GUI所针对目的的功能。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Naming conventions for Python code modules are a great help in keeping us efficient
    and remembering our original design. When we need to debug and fix a defect or
    add new functionality, they are the first resource to look at.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Python代码模块的命名规范对我们保持高效和记住原始设计非常有帮助。当我们需要调试和修复缺陷或添加新功能时，它们是我们首先查阅的资源。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Incrementing module names by numbers is not very meaningful and eventually wastes
    development time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过数字递增模块名称并不十分有意义，最终还会浪费开发时间。
- en: On the other hand, naming Python variables is more of a free form. Python infers
    types, so we do not have to specify that a variable will be of type `<list>` (it
    might not be or actually, later in the code, it might become a different type).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，Python 变量的命名更偏向自由形式。Python 会推断类型，因此我们不必指定一个变量将是 `<list>` 类型（它可能不是，或者实际上，在代码的后续部分，它可能变成另一种类型）。
- en: A good idea for naming variables is to make them descriptive and it is also
    a good idea not to abbreviate too much.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 变量命名的良好建议是使它们具有描述性，同时也不宜过度缩写。
- en: If we wish to point out that a certain variable is designed to be of type `<list>`,
    then it is much more intuitive to use the full word `list` instead of `lst`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要指出某个变量被设计为类型`<list>`，那么使用完整的单词`list`而不是`lst`会更加直观。
- en: It is similar for `number` instead of `num`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`number`和`num`来说，情况类似。
- en: 'While it is a good idea to have very descriptive names for variables, sometimes
    that can get too long. In Apple''s Objective-C language, some variable and function
    names are extreme: `thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然给变量起非常描述性的名字是个好主意，但有时名字可能会变得过长。在苹果的Objective-C语言中，一些变量和函数的名字非常极端：`thisIsAMethodThatDoesThisAndThatAndAlsoThatIfYouPassInNIntegers:1:2:3`
- en: Note
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Use common sense when naming variables, methods, and functions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名变量、方法和函数时，请使用常识。
- en: When not to use OOP
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时不使用面向对象编程（OOP）
- en: Python comes built-in with object-oriented programming capabilities, but at
    the same time, we can write scripts that do not need to use OOP.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: Python自带面向对象编程的能力，但与此同时，我们也可以编写不需要使用OOP的脚本。
- en: For some tasks, OOP does not make sense.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些任务，面向对象编程（OOP）并不适用。
- en: This recipe will show when not to use OOP.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将展示何时不使用面向对象编程（OOP）。
- en: Getting ready
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: In this recipe, we will create a Python GUI similar to previous recipes. We
    will compare the OOP code to the non-OOP alternative way of programming.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个类似于之前菜谱的 Python GUI。我们将比较面向对象（OOP）代码与非面向对象编程的替代方式。
- en: How to do it...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s first create a new GUI using **OOP** methodology. The following code
    will create the GUI displayed below the code:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先使用**面向对象**的方法创建一个新的GUI。下面的代码将创建显示在代码下面的GUI：
- en: '[PRE19]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '![How to do it...](img/B04829_11_18.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_18.jpg)'
- en: We can achieve the same GUI without using an OOP approach by restructuring our
    code slightly. First, we remove the `OOP` class and its `__init__` method.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过稍微重构我们的代码，在不使用面向对象编程（OOP）方法的情况下实现相同的图形用户界面（GUI）。首先，我们移除`OOP`类及其`__init__`方法。
- en: Next, we move all methods to the left and remove the `self` class reference
    which turns them into unbound functions.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将所有方法移动到左侧，并移除`self`类引用，这样它们就变成了未绑定函数。
- en: We also remove any other `self` references our previous code had. Then, we move
    the `createWidgets` function call below the point of the function's declaration.
    We place it just above the `mainloop` call.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还移除了之前代码中所有的`self`引用。然后，我们将`createWidgets`函数调用移至函数声明之下。我们将其放置在`mainloop`调用之上。
- en: In the end, we achieve the same GUI but without using OOP.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们实现了相同的GUI，但没有使用面向对象编程（OOP）。
- en: 'The refactored code is shown as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 重构后的代码如下所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python enables us to use OOP when it makes sense. Other languages such as Java
    and C# force us to always use the OOP approach to coding. In this recipe, we explored
    a situation when it did not make sense to use OOP.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python使我们能够在合理的情况下使用面向对象编程（OOP）。其他语言如Java和C#则强制我们始终使用面向对象编程的编码方法。在本食谱中，我们探讨了一种不适合使用面向对象编程的情况。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The OOP approach will be more extendible if the codebase grows but, if it's
    certain that it is the only code that's needed then there's no need to go through
    OOP.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码库不断增长，面向对象（OOP）方法将更具可扩展性，但如果确定只需要这一种代码，那么就没有必要采用面向对象（OOP）方法。
- en: How to use design patterns successfully
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何成功使用设计模式
- en: In this recipe, we will create widgets for our Python GUI by using the factory
    design pattern.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过使用工厂设计模式来创建我们的Python GUI小部件。
- en: In previous recipes, we created our widgets either manually one at a time or
    dynamically in a loop.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们手动逐个创建小部件，或者通过循环动态创建。
- en: Using the factory design pattern, we will use the factory to create our widgets.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用工厂设计模式，我们将使用工厂来创建我们的小部件。
- en: Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a Python GUI which has three buttons each having different styles.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个具有三个按钮的 Python 图形用户界面，每个按钮都有不同的样式。
- en: How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Towards the top of our Python GUI module, just below the import statements,
    we create several classes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Python GUI 模块顶部，紧接在导入语句下方，我们创建了几个类：
- en: '[PRE21]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We create a base class which our different button style classes inherit from
    and in which each of them overrides the `relief` and `foreground` configuration
    properties. All subclasses inherit the `getButtonConfig` method from this base
    class. This method returns a tuple.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基类，我们的不同按钮样式类都继承自这个基类，并且每个子类都覆盖了`relief`和`foreground`配置属性。所有子类都从该基类继承`getButtonConfig`方法。此方法返回一个元组。
- en: We also create a button factory class and a list that holds the names of our
    button subclasses. We name the list `buttonTypes` as our factory will create different
    types of buttons.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还创建了一个按钮工厂类和一个列表，用于存储我们按钮子类的名称。我们将这个列表命名为`buttonTypes`，因为我们的工厂将创建不同类型的按钮。
- en: Further down in the module we create the button widgets, using the same `buttonTypes`
    list.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的下方，我们使用相同的`buttonTypes`列表创建按钮小部件。
- en: '[PRE22]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we create an instance of the button factory and then we use our factory
    to create our buttons.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个按钮工厂的实例，然后我们使用我们的工厂来创建我们的按钮。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: The items in the `buttonTypes` list are the names of our subclasses.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`buttonTypes` 列表中的项是我们子类的名称。'
- en: We invoke the `createButton` method and then immediately call the `getButtonConfig`
    method of the base class and retrieve the configuration properties using dot notation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`createButton`方法，然后立即调用基类的`getButtonConfig`方法，并使用点符号获取配置属性。
- en: 'When we run the entire code, we get the following Python tkinter GUI:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行整个代码时，我们得到以下Python tkinter图形用户界面：
- en: '![How to do it...](img/B04829_11_19.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_19.jpg)'
- en: We can see that our Python GUI factory did indeed create different buttons,
    each having a different style. They differ in the color of their text and in their
    relief property.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们的 Python GUI 工厂确实创建了不同的按钮，每个按钮都有不同的样式。它们在文字颜色和浮雕属性上有所不同。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we used the factory design pattern to create several widgets
    that have different styles. We can easily use this design pattern to create entire
    GUIs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了工厂设计模式来创建具有不同样式的几个小部件。我们可以轻松地使用这种设计模式来创建整个GUI。
- en: Design patterns are a very exciting tool in our software development toolbox.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是我们软件开发工具箱中一个非常激动人心的工具。
- en: Avoiding complexity
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免复杂性
- en: In this recipe, we will extend our Python GUI and learn ways to handle the ever-increasing
    complexity of our software development efforts.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将扩展我们的Python图形用户界面，并学习处理软件开发工作中不断增长的复杂性的方法。
- en: Our co-workers and clients love the GUIs we create in Python and ask for more
    and more features to add to our GUI.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的合作者和客户都喜欢我们用Python创建的图形用户界面，并不断要求添加更多功能到我们的GUI中。
- en: This increases complexity and can easily ruin our original nice design.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这增加了复杂性，并且很容易毁掉我们原本良好的设计。
- en: Getting ready
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: We will create a new Python GUI similar to those in previous recipes and will
    add many features to it in the form of widgets.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个新的Python GUI，类似于之前食谱中的那些，并且将以小部件的形式添加许多新功能。
- en: How to do it...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will start with a Python GUI that has two tabs and looks like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个具有两个标签页的 Python 图形用户界面开始，其外观如下：
- en: '![How to do it...](img/B04829_11_20.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_20.jpg)'
- en: The first new feature request we receive is to add functionality to **Tab 1**,
    which clears the `scrolledtext` widget.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的第一个新功能请求是向**Tab 1**添加功能，该功能清除`scrolledtext`小部件。
- en: Easy enough. We just add another button to **Tab 1**.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 简单得很。我们只需在**标签1**中添加另一个按钮。
- en: '[PRE23]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We also have to create the callback method to add the desired functionality,
    which we define towards the top of our class and outside the method that creates
    our widgets.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须创建回调方法以添加所需的功能，我们将在类的顶部定义该方法，并在创建我们的小部件的方法之外定义它。
- en: '[PRE24]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now our GUI has a new button and, when we click it, we clear the text of the
    `ScrolledText` widget.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的GUI有一个新的按钮，当我们点击它时，我们将`ScrolledText`小部件的文本清空。
- en: '![How to do it...](img/B04829_11_21.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_21.jpg)'
- en: In order to add this functionality, we had to add code in two places in the
    same Python module.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加这个功能，我们不得不在同一个Python模块的两个地方添加代码。
- en: We inserted the new button in the `createWidgets` method (not shown) and then
    we created a new callback method, which our new button calls when it is clicked.
    We placed this code just below the callback of our first button.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`createWidgets`方法（未显示）中插入了新的按钮，然后创建了一个新的回调方法，当我们的新按钮被点击时，它会调用这个方法。我们将这段代码放置在第一个按钮的回调方法下方。
- en: Our next feature request is to add more functionality. The business logic is
    encapsulated in another Python module. We invoke this new functionality by adding
    three more buttons to **Tab 1**. We use a loop to do this.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们下一个功能请求是添加更多功能。业务逻辑封装在另一个Python模块中。我们通过在**Tab 1**中添加三个更多按钮来调用这个新功能。我们使用循环来完成这个操作。
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our GUI now looks like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的用户界面现在看起来是这样的：
- en: '![How to do it...](img/B04829_11_22.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_22.jpg)'
- en: 'Next, our customers ask for more features and we use the same approach. Our
    GUI now looks as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的客户要求更多功能，我们采用同样的方法。我们的图形用户界面现在看起来如下：
- en: '![How to do it...](img/B04829_11_23.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_23.jpg)'
- en: Note
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This is not too bad. When we get new feature requests for another 50 new features,
    we start to wonder if our approach is still the best approach to use…
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这还不错。当我们收到关于另外50个新功能的新的功能请求时，我们开始怀疑我们的方法是否仍然是最佳使用方法……
- en: One way to handle the ever-increasing complexity our GUI has to handle is by
    adding tabs. By adding more tabs and placing related features into their own tab,
    we get control of the complexity and make our GUI more intuitive.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 处理我们GUI必须处理的日益增加的复杂性的一个方法是通过添加标签页。通过添加更多标签页并将相关功能放入各自的标签页中，我们能够掌控复杂性，并使我们的GUI更加直观。
- en: 'Here is the code that creates our new **Tab 3** and, below it, is our new Python
    GUI:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是创建我们新的**Tab 3**的代码，在其下方是我们的新Python GUI：
- en: '[PRE26]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![How to do it...](img/B04829_11_24.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/B04829_11_24.jpg)'
- en: How it works...
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we added several new widgets to our GUI in order to add more
    functionality to our Python GUI. We saw how more and more new feature requests
    easily got our nice GUI design into a state where it became less clear how to
    use the GUI.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们向我们的GUI添加了几个新的小部件，以便为我们的Python GUI添加更多功能。我们看到了随着越来越多的新功能请求，我们的精美GUI设计很容易陷入一种状态，使得如何使用GUI变得不那么清晰。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: Suddenly, widgets took over the world…
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 突然，小玩意儿们统治了世界…
- en: We saw how to handle complexity by modularizing our GUI by breaking large features
    into smaller pieces and arranging them in functionally-related areas using tabs.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何通过模块化我们的GUI来处理复杂性，即将大型功能拆分成更小的部分，并使用标签将它们安排在功能相关区域。
- en: While complexity has many aspects, modularizing and refactoring code is usually
    a very good approach to handling software code complexity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然复杂性有许多方面，但模块化和重构代码通常是处理软件代码复杂性的一个非常有效的方法。
- en: Note
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: In programming, at certain times, we run into a wall and get stuck. We keep
    banging our head against this wall but nothing happens.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，有时我们会遇到一道墙，陷入困境。我们不断地撞击这堵墙，但没有任何进展。
- en: Sometimes we feel like we want to give up.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们感觉好像想要放弃。
- en: However, miracles do happen…
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，奇迹确实会发生……
- en: If we keep on banging against this wall, at a certain moment in time, the wall
    will collapse and the road will be open.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们持续不断地撞击这堵墙，在某个时刻，墙将会倒塌，道路就会畅通。
- en: At that point in time, we can make a positive dent in the software universe.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个时刻，我们可以在软件宇宙中留下积极的印记。
