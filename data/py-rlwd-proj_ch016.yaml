- en: Chapter 12
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: 'Project 3.8: Integrated Data Acquisition Web Service'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 项目3.8：集成数据获取Web服务
- en: In many enterprise applications, data is provided to several consumers. One
    way to do this is to define an API that provides data (and the metadata) for subsequent
    use. In this chapter, we guide you through the transformation of Project 2.5 schema
    information into a larger OpenAPI specification. We will also build a small Flask
    application that provides the core acquire-cleanse-convert process as a web service.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多企业应用程序中，数据提供给多个消费者。一种方法是为后续使用定义一个API，该API提供数据（以及元数据）。在本章中，我们将指导您将项目2.5的模式信息转换为更大的OpenAPI规范。我们还将构建一个小型的Flask应用程序，将其核心获取-清理-转换过程作为Web服务提供。
- en: 'We’ll cover a number of skills in the chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将介绍多个技能：
- en: Creating an OpenAPI specification for a service to acquire and download data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为获取和下载数据的服务创建OpenAPI规范
- en: Writing a web service application to implement the OpenAPI specification
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个实现OpenAPI规范的Web服务应用程序
- en: Using a processing pool to delegate long-running background tasks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用处理池来委托长时间运行的后台任务
- en: This is a bit of a deviation from a straight path of acquiring and cleaning
    data. In some enterprises, this deviation is needed to publish useful data to
    a wider audience.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这与获取和清理数据的直接路径略有偏差。在某些企业中，这种偏差是必要的，以便将有用的数据发布给更广泛的受众。
- en: We’ll begin with a description of the behavior of this RESTful API server.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从描述这个RESTful API服务器的行为开始。
- en: 12.1 Description
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.1 描述
- en: 'In [*Chapter** 8*](ch012.xhtml#x1-1950008), [*Project 2.5: Schema and Metadata*](ch012.xhtml#x1-1950008),
    we used **Pydantic** to generate a schema for the analysis data model. This schema
    provides a formal, language-independent definition of the available data. This
    can then be shared widely to describe the data and resolve questions or ambiguities
    about the data, the processing provenance, the meaning of coded values, internal
    relationships, and other topics.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](ch012.xhtml#x1-1950008)，[*项目2.5：模式与元数据*](ch012.xhtml#x1-1950008)中，我们使用了**Pydantic**来生成分析数据模型的模式。这个模式提供了一个正式的、与语言无关的数据定义。然后可以广泛共享来描述数据，解决有关数据、处理来源、编码值的含义、内部关系和其他主题的问题或歧义。
- en: This specification for the schema can be extended to create a complete specification
    for a RESTful API that provides the data that meets the schema. The purpose of
    this API is to allow multiple users — via the `requests` module — to query the
    API for the analytical data as well as the results of the analysis. This can help
    users to avoid working with out-of-date data. An organization creates large JupyterLab
    servers to facilitate doing analysis processing on machines far larger than an
    ordinary laptop.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式规范可以扩展为创建一个完整的RESTful API规范，该API提供符合模式的数据。此API的目的是允许多个用户通过`requests`模块查询API以获取分析数据以及分析结果。这可以帮助用户避免处理过时数据。组织创建大型JupyterLab服务器，以便在比普通笔记本电脑大得多的机器上进行分析处理。
- en: Further, an API provides a handy wrapper around the entire acquire-and-clean
    process. When a user requests data for the first time, the processing steps can
    be started and the results cached. Each subsequent request can download available
    data from a filesystem cache, providing rapid access. In the case of a failure,
    the logs can be provided as an alternative to the final data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，API为整个获取和清理过程提供了一个方便的包装器。当用户第一次请求数据时，可以启动处理步骤并将结果缓存。后续的请求可以从文件系统缓存中下载可用数据，提供快速访问。在出现故障的情况下，日志可以作为最终数据的替代提供。
- en: We won’t dive deeply into REST design concepts. For more information on RESTful
    design, see [https://hub.packtpub.com/creating-restful-api/](https://hub.packtpub.com/creating-restful-api/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨REST设计概念。有关RESTful设计的更多信息，请参阅[https://hub.packtpub.com/creating-restful-api/](https://hub.packtpub.com/creating-restful-api/)。
- en: Generally, a RESTful API defines a number of paths to resources. A given path
    can be accessed by a number of methods, some of which will get the resource. Other
    methods may post, patch, put, or delete the resource. The defined HTTP methods
    offer handy mapping to the common **Create-Retrieve-Update-Delete** (**CRUD**)
    conceptual operations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，RESTful API定义了一系列资源路径。给定的路径可以通过多种方法访问，其中一些方法将获取资源。其他方法可能用于发布、修补、更新或删除资源。定义的HTTP方法提供了方便的映射，以对应于常见的**创建-检索-更新-删除**（**CRUD**）概念操作。
- en: 'Here are the common cases:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见的情况：
- en: 'A path without a final identifier, for example, `/series/`. There are two common
    cases here:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有最终标识符的路径，例如，`/series/`。这里有两种常见情况：
- en: The `GET` method will retrieve the list of available resources of the given
    type.
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 方法将检索给定类型的可用资源列表。'
- en: The `POST` method can be used to create a new instance of this type. This is
    the conceptual “Create” operation.
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 方法可以用来创建该类型的新实例。这是概念上的“创建”操作。'
- en: 'A path with an identifier. For example, `/series/Series_4`. This is a specific
    resource. There are several methods that might be implemented:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有标识符的路径。例如，`/series/Series_4`。这是一个特定的资源。可能实现的方法有几种：
- en: The `GET` method will retrieve the resource. This is the “Retrieve” conceptual
    operation.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET` 方法将检索资源。这是“检索”概念操作。'
- en: The `PUT` and `PATCH` methods can be used to replace or update the resource.
    These are two forms of the conceptual “Update” operation.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 和 `PATCH` 方法可以用来替换或更新资源。这是概念上的“更新”操作的两种形式。'
- en: The `DELETE` method can be used to remove the resource. This is the “Delete”
    conceptual operation.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE` 方法可以用来删除资源。这是“删除”概念操作。'
- en: It becomes imperative to consider a RESTful web service as a collection of resources.
    Talking about resources can make it difficult to talk about a RESTful request
    that initiates processing. It raises the question of what resource describes an
    activity such as processing samples. We’ll start by considering the data series
    as the most important resource provided by this service.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将 RESTful 网络服务视为资源集合变得至关重要。谈论资源可能会使谈论启动处理的 RESTful 请求变得困难。它提出了一个问题：哪个资源描述了处理样本等活动。我们将首先考虑数据序列作为此服务提供的重要资源。
- en: 12.1.1 The data series resources
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.1 数据序列资源
- en: The primary resource for this API is the data series. As shown in the previous
    section, [*OpenAPI 3 specification*](#x1-2810001), a path with `/2023.02/series/<id>`
    can be used to extract the data for a named series. The 2023.02 prefix allows
    the API to evolve to a newer version while leaving older paths in place for compatibility
    purposes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此 API 的主要资源是数据序列。如前所述，[**OpenAPI 3 规范**](#x1-2810001)，可以使用 `/2023.02/series/<id>`
    路径来提取命名序列的数据。2023.02 前缀允许 API 向新版本进化，同时为兼容性目的保留旧路径。
- en: The use of **semantic versioning** (**semver**) is common, and many APIs have
    something like “v1” in the path. Yet another alternative is to include the version
    information in the `Accept` header. This means the URIs never change, but the
    schema for the response can change based on the version information provided in
    the header.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**语义版本控制**（**semver**）的使用很常见，许多 API 的路径中都包含类似“v1”的内容。另一种选择是将版本信息包含在 `Accept`
    头部中。这意味着 URI 从不改变，但响应的架构可以根据头部中提供的版本信息进行更改。'
- en: The various “series” routes provide direct access to the data resources. This
    seems appropriate since this is the primary purpose of the service.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 各种“系列”路由提供了直接访问数据资源的方式。这似乎是合适的，因为这是服务的主要目的。
- en: 'There is an additional class of resources that might be of interest: the background
    processing used to create the data. As noted above, projects like [*Chapter** 11*](ch015.xhtml#x1-26400011),
    [*Project 3.7: Interim Data Persistence*](ch015.xhtml#x1-26400011), are the essential
    foundation for processing done by this RESTful API. The acquire and clean applications
    can be run in the background to create data for download.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可能引起兴趣的资源类别：用于创建数据的后台处理。如上所述，[**第 11 章**](ch015.xhtml#x1-26400011)、[**项目
    3.7：临时数据持久化**](ch015.xhtml#x1-26400011) 是此 RESTful API 执行处理的基本基础。获取和清理应用程序可以在后台运行以创建下载数据。
- en: A focus on resources is essential for making useful RESTful APIs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 资源的关注对于创建有用的 RESTful API 至关重要。
- en: Even when describing processing or state changes, the focus must be on the resource
    that undergoes the state change.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在描述处理或状态变化时，焦点也必须放在经历状态变化的那一资源上。
- en: The methods available in HTTP (`GET`, `POST`, `PUT`, `PATCH`, and `DELETE`,
    for example) are effectively the verbs of the API’s language. The resources are
    nouns.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 中可用的方法（例如 `GET`、`POST`、`PUT`、`PATCH` 和 `DELETE`）实际上是 API 语言的动词。资源是名词。
- en: 12.1.2 Creating data for download
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1.2 创建下载数据
- en: The primary purpose of the RESTful API is to store and download clean data for
    analysis work. This can be a relatively straightforward application that offers
    data files from a well-known directory. The work involves matching RESTful requests
    against available files, and returning appropriate status codes when requests
    are made for files that don’t exist.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 的主要目的是存储和下载用于分析工作的干净数据。这可能是一个相对简单的应用程序，提供来自知名目录的数据文件。这项工作包括将 RESTful
    请求与可用文件匹配，并在请求不存在文件时返回适当的状态码。
- en: 'A secondary purpose is to automate the creation of the data for download. The
    RESTful API can be a wrapper around the complete acquire, clean, and persist pipeline.
    To do this, the API will have two distinct kinds of requests:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个目的是自动化数据的创建以供下载。RESTful API 可以是完整获取、清理和持久化管道的包装器。为此，API 将有两种不同的请求类型：
- en: Requests to download existing, cached data. The resource type is clear here.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载现有、缓存数据的请求。这里的资源类型是明确的。
- en: Requests to start the creation of new data; this will lead to cached data available
    for download. The resource type for processing isn’t as clear.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求启动新数据的创建；这将导致可用于下载的缓存数据。处理资源类型并不明确。
- en: 'An operation or action does have some static resources that can be used with
    a RESTful API. Here are two common resource types for activities:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 一个操作或动作确实有一些静态资源，可以使用 RESTful API 来使用。以下是两种常见的活动资源类型：
- en: A ”current status” resource that reflects the work being done right now
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“当前状态”资源，反映正在进行的工作
- en: 'A ”processing history” resource that reflects work completed: this is often
    the log file for the acquisition processing'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个“处理历史”资源，反映已完成的工作：这通常是获取处理的日志文件
- en: 'The control of processing by a RESTful API can work by creating and examining
    processing status or history as a distinct resource type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建和检查作为独立资源类型的处理状态或历史，RESTful API 可以控制处理：
- en: A path with a POST request will start an asynchronous, background process. This
    will also create a new processing history resource. The response body provides
    a transaction identifier referring to this new processing history.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 POST 请求的路径将启动一个异步的后台进程。这也会创建一个新的处理历史资源。响应体提供了一个事务标识符，指向这个新的处理历史。
- en: A path with a transaction identifier and a GET request will return the background
    processing details; this should include the current or final status as well as
    the log.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事务标识符和 GET 请求的路径将返回后台处理详情；这应包括当前或最终状态以及日志。
- en: For sophisticated frontend processing, a web socket can be created to receive
    ongoing status reports from the background process. For a less sophisticated frontend,
    polling every few seconds can be done to see whether the processing has finished
    and the data is available for download.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的客户端处理，可以创建一个 WebSocket 来接收来自后台进程的持续状态报告。对于不太复杂的客户端，可以每几秒钟轮询一次，以查看处理是否完成以及数据是否可供下载。
- en: 'With both processing history resources and data resources, the following two
    sets of paths are necessary:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理历史资源和数据资源的情况下，需要以下两组路径：
- en: '`/series/<id>` paths that refer to specific series, already available in the
    cache. These resources are accessed exclusively with the GET method to download
    data.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/series/<id>` 路径指向特定的系列，这些系列已在缓存中可用。这些资源仅通过 GET 方法访问以下载数据。'
- en: '`/creation/<id>` paths that refer to background processing jobs to create a
    new series of data. These resources will use the POST method to start a background
    job, and the GET method to check the status of a job.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/creation/<id>` 路径指向创建新数据系列的背景处理作业。这些资源将使用 POST 方法启动后台作业，并使用 GET 方法检查作业状态。'
- en: This set of paths (and the associated methods) allows a user to control processing
    and check the results of processing. The user can ask for available datasets and
    download a specific dataset for analysis.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这组路径（和相关方法）允许用户控制处理并检查处理结果。用户可以请求可用的数据集并下载特定数据集进行分析。
- en: 12.2 Overall approach
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.2 总体方法
- en: We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视我们的方法时，我们将借鉴 C4 模型（[https://c4model.com](https://c4model.com)）的一些指导。
- en: '**Context** For this project, the context diagram has several use cases: listing
    available data, downloading available data, starting a process to acquire data,
    and checking the status of a process acquiring data.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文** 对于这个项目，上下文图有几个用例：列出可用数据、下载可用数据、启动获取数据的过程以及检查获取数据的过程的状态。'
- en: '**Containers** Ideally, this runs on a single container that hosts the web
    service as well as the processing. In some cases, multiple containers will be
    required because the processing demands are so huge.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器** 理想情况下，这在一个容器上运行，该容器托管网络服务以及处理。在某些情况下，需要多个容器，因为处理需求如此巨大。'
- en: '**Components** There are two significantly different collections of software
    components: the web service, and the application programs that run in the background
    to acquire and clean the data.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件** 有两组显著不同的软件组件集合：网络服务和在后台运行以获取和清理数据的应用程序程序。'
- en: '**Code** The acquiring and cleaning applications have already been described
    as separate projects. We’ll focus on the web service.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码** 获取和清理应用程序已经被描述为独立的项目。我们将重点关注网络服务。'
- en: We’ll decompose the web service application into several components. The following
    diagram shows the relationship between the RESTful API service and the applications
    that are run to acquire and clean data.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把网络服务应用程序分解成几个组件。以下图显示了RESTful API服务和运行以获取和清理数据的应用程序之间的关系。
- en: The component diagram is shown in [*Figure 12.1*](#12.1).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 组件图显示在[*图12.1*](#12.1)中。
- en: '![Figure 12.1: Application components ](img/file52.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1：应用程序组件](img/file52.jpg)'
- en: 'Figure 12.1: Application components'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：应用程序组件
- en: 'This diagram shows three separate processes:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示了三个独立的过程：
- en: The **RESTful API** process that handles HTTP requests from clients.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自客户端的HTTP请求的**RESTful API**过程。
- en: The **Worker Pool** collection of processes that are managed by the `concurrent.futures`
    module. Each worker will be running a single function, shown as `acquire_series`,
    that’s defined in the same module as the **RESTful API** service.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`concurrent.futures`模块管理的**工作池**集合。每个工作进程将运行一个单独的函数，如`acquire_series`，该函数定义在**RESTful
    API**服务所在的同一模块中。
- en: The **Background** process that is executed by a worker in the worker pool.
    This uses the `subprocess` module to run an existing CLI application.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由工作池中的工作进程执行**后台**过程。这使用`subprocess`模块运行现有的CLI应用程序。
- en: When the API service starts, it uses `concurrent.futures` to create a pool of
    workers. A request to acquire and clean data will use the `submit()` method of
    the pool to create a **future**. This future is a reference to a subprocess that
    will — eventually — return the final status of the acquire and clean job. The
    subprocess that implements the future will evaluate the `acquire_series()` function
    defined in the same module as the RESTful API application to do the work.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当API服务启动时，它使用`concurrent.futures`创建一个工作进程池。一个获取和清理数据的请求将使用池的`submit()`方法创建一个**未来**。这个未来是对一个子进程的引用，该子进程最终将返回获取和清理作业的最终状态。实现未来的子进程将评估与RESTful
    API应用程序位于同一模块中的`acquire_series()`函数来完成工作。
- en: When the `acquire_series()` function finishes the processing, it will have created
    a file that can be downloaded. Via the future object, it will also provide some
    status information to the RESTful API service to indicate the processing is done.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当`acquire_series()`函数完成处理时，它将创建一个可以下载的文件。通过未来对象，它还将提供一些状态信息给RESTful API服务，以指示处理已完成。
- en: One suggested implementation for the `acquire_series()` function is to use `subprocess.run()`
    to execute the acquire and clean applications to gather and cleanse source data.
    There are some other choices available. The most important alternative is to import
    these two other modules, and execute them directly, rather than creating a subprocess.
    This direct execution has the advantage of being slightly faster than spawning
    a subprocess. It has the disadvantage of making it more complicated to create
    a separate log file each time the **acquire** and **clean** application is executed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire_series()`函数的一个建议实现是使用`subprocess.run()`来执行获取和清理应用程序以收集和净化源数据。还有一些其他的选择可用。最重要的替代方案是导入这两个其他模块，并直接执行它们，而不是创建一个子进程。这种直接执行的优势是比创建子进程稍微快一些。它的缺点是每次执行获取和清理应用程序时，创建单独的日志文件会更复杂。'
- en: We’ll take a look at the OpenAPI specification for the RESTful API first. This
    helps to characterize the overall UX.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看RESTful API的OpenAPI规范。这有助于描述整体UX。
- en: 12.2.1 OpenAPI 3 specification
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.1 OpenAPI 3规范
- en: A RESTful API requires a clear description of the requests and responses. The
    OpenAPI specification is a formal definition of RESTful web services. See [https://www.openapis.org](https://www.openapis.org).
    This document has a version identifier and some information about the service
    as a whole. For this project, the most important part is the **paths** section,
    which lists the various resource types and the paths used to locate those resources.
    The **components** section provides the needed schema definitions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API需要明确描述请求和响应。OpenAPI规范是RESTful网络服务的正式定义。请参阅[https://www.openapis.org](https://www.openapis.org)。这份文档有一个版本标识符以及关于整个服务的一些信息。对于这个项目来说，最重要的部分是**paths**部分，它列出了各种资源类型以及定位这些资源的路径。**components**部分提供了所需的模式定义。
- en: 'An OpenAPI document often has an outline like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI文档通常具有如下大纲：
- en: '[PRE0]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The details of the paths and components have been elided from this overview.
    (We’ve used `"..."` in place of the details.) The idea is to show the general
    structure of an OpenAPI specification. While JSON is the underlying format commonly
    used for these specifications, it can be hard to read. For this reason, it’s common
    to use YAML notation for OpenAPI specifications.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 路径和组件的详细信息已从概述中省略。（我们用`"..."`代替了详细信息。）目的是展示OpenAPI规范的一般结构。虽然JSON是这些规范常用的底层格式，但它可能难以阅读。因此，通常使用YAML符号表示OpenAPI规范。
- en: Think of the OpenAPI specification as a binding contract.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将OpenAPI规范视为一个约束性合同。
- en: The acceptance test suite should be Gherkin scenarios with a very direct mapping
    to the OpenAPI specification.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试套件应该是与OpenAPI规范有非常直接映射的Gherkin场景。
- en: For more on the idea of OpenAPI to Gherkin, see [https://medium.com/capital-one-tech/spec-to-gherkin-to-code-902e346bb9aa](https://medium.com/capital-one-tech/spec-to-gherkin-to-code-902e346bb9aa).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于OpenAPI到Gherkin的想法，请参阅[https://medium.com/capital-one-tech/spec-to-gherkin-to-code-902e346bb9aa](https://medium.com/capital-one-tech/spec-to-gherkin-to-code-902e346bb9aa)。
- en: The OpenAPI paths define the resources made available by a RESTful API. In this
    case, the resources are cleaned files, ready for analysis.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI路径定义了RESTful API提供的资源。在这种情况下，资源是经过清理的文件，准备进行分析。
- en: 'We’ll often see entries in the **paths** section that look like the following
    YAML snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常在**paths**部分看到类似以下YAML片段的条目：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This shows a path that starts with an API version number (in this example, calendar
    versioning, “calver”, is used) and a resource-type, `series`. Any given path can
    be accessed by a variety of methods; in this example, only the **get** method
    is defined.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了从API版本号（在这个例子中，使用的是日历版本号，“calver”）和资源类型`series`开始的路径。任何给定的路径都可以通过多种方法访问；在这个例子中，只定义了**get**方法。
- en: One kind of response is defined for requests to this path and method combination.
    The response will have a status code of 200, meaning normal, successful completion.
    The description is there to explain what this resource will be. A response can
    define a variety of content types; in this example, only `application/json` is
    defined. The schema for this is provided elsewhere in the OpenAPI specification,
    in the `components/schemas` section of the document.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个路径和方法的组合请求定义了一种响应类型。响应将具有状态码200，表示正常、成功的完成。描述用于解释这个资源是什么。响应可以定义多种内容类型；在这个例子中，只定义了`application/json`。这个模式在OpenAPI规范的其它地方提供，在文档的`components/schemas`部分。
- en: The use of a `$ref` tag within the specification permits common definitions,
    such as schemas and parameters, to be collected under the `components` section,
    permitting reuse. This follows the **DRY** (**Don’t Repeat Yourself**) principle
    of software design.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在规范中使用`$ref`标签允许将常见的定义，如模式参数，收集在`components`部分下，允许重用。这遵循了软件设计中的**DRY**（**不要重复自己**）原则。
- en: 'It can be difficult to get the syntax correct in an OpenAPI specification.
    It’s helpful to have an editor that validates the specification. For example,
    [https://editor.swagger.io](https://editor.swagger.io) provides an editor that
    helps confirm the specification is internally consistent. For readers using tools
    such as JetBrains’ PyCharm, there’s a plug-in editor: [https://plugins.jetbrains.com/plugin/14837-openapi-swagger-editor](https://plugins.jetbrains.com/plugin/14837-openapi-swagger-editor).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenAPI 规范中正确获取语法可能很困难。拥有一个验证规范的编辑器非常有帮助。例如，[https://editor.swagger.io](https://editor.swagger.io)
    提供了一个编辑器，可以帮助确认规范在内部是一致的。对于使用 JetBrains 的 PyCharm 等工具的读者，有一个插件编辑器：[https://plugins.jetbrains.com/plugin/14837-openapi-swagger-editor](https://plugins.jetbrains.com/plugin/14837-openapi-swagger-editor)。
- en: When a path has an identifier in it, then this is shown with the path name of
    the form `"/2023.02/series/<series_id>"`. The `<series_id>` is defined in the
    `parameters` section of this request. Since parameters are sometimes reused, it’s
    helpful to have a reference to a component with the common definition.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当路径中包含标识符时，则显示为形式为 `"/2023.02/series/<series_id>"` 的路径名称。`<series_id>` 在此请求的
    `parameters` 部分中定义。由于参数有时会被重复使用，因此有一个对具有共同定义的组件的引用是有帮助的。
- en: 'The whole request might start like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 整个请求可能开始如下：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The details of the **responses** section have been omitted from this example.
    The parameter definition — in the `components` section — might look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例中省略了 **响应** 部分的详细信息。参数定义——在 `components` 部分中——可能看起来像这样：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This provides a wealth of details about the `series_id` parameter, including
    the description and a formal schema definition. For simple APIs, the name of the
    parameter and the reference label under `components` are often the same. In more
    complex cases, a parameter name might be reused, but have distinct semantics in
    distinct contexts. A generic word such as `id` might be used in several different
    paths, leading to the reference label being something more descriptive than `id`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了关于 `series_id` 参数的大量细节，包括描述和正式的架构定义。对于简单的 API，参数的名称和 `components` 下的参考标签通常相同。在更复杂的情况下，参数名称可能被重复使用，但在不同的上下文中具有不同的语义。一个通用的词如
    `id` 可能在几个不同的路径中使用，导致参考标签比 `id` 更具有描述性。
- en: 'The content for ND JSON is considered an extension to standard MIME types.
    Therefore the content definition for a response that includes data might look
    like this:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ND JSON 的内容被视为标准 MIME 类型的扩展。因此，包含数据的响应的内容定义可能看起来像这样：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The schema is a challenge because it pushes the boundaries of what JSON Schema
    can describe. It looks as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 架构是一个挑战，因为它推动了 JSON Schema 可以描述的边界。它看起来如下：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The format information describes the physical organization of ND JSON data,
    but doesn’t provide any details on the structure of the schema for each individual
    row. The additional schema details can either be added to the description, or
    a separate label, distinct from other JSON schema labels, can be used, for example,
    ”ndjson-schema:”.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 格式信息描述了 ND JSON 数据的物理组织结构，但并未提供有关每个单独行架构结构的任何细节。额外的架构细节可以添加到描述中，或者使用与其他 JSON
    架构标签不同的单独标签，例如，“ndjson-schema:”。
- en: 12.2.2 RESTful API to be queried from a notebook
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.2 从笔记本查询的 RESTful API
- en: 'The RESTful API service must be a wrapper around application programming that
    can perform the required processing. The idea is to put as little processing as
    possible into the RESTful API. It serves as a very thin — almost transparent —
    interface to the “real work” of the application. For this reason, projects such
    as [*Chapter** 11*](ch015.xhtml#x1-26400011), [*Project 3.7: Interim Data Persistence*](ch015.xhtml#x1-26400011)
    are the essential foundation of this RESTful API.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 服务必须是围绕应用程序编程的包装器，能够执行所需的处理。理念是将尽可能少的处理放入 RESTful API。它作为非常薄——几乎是透明——的应用程序“真实工作”的接口。因此，如[*第
    11 章**](ch015.xhtml#x1-26400011)、[*项目 3.7：临时数据持久性**](ch015.xhtml#x1-26400011)等项目是这个
    RESTful API 的基本基础。
- en: As noted in [*Figure 12.1*](#12.1), the **Background** processing is completely
    outside the RESTful API. This separation of concerns is absolutely essential.
    The general processing of samples can be performed with a CLI or through the RESTful
    API and create identical results.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*图 12.1*](#12.1) 所示，**后台**处理完全在 RESTful API 之外。这种关注点的分离绝对必要。可以使用 CLI 或通过 RESTful
    API 执行样本的一般处理，并创建相同的结果。
- en: If additional processing — for example, additional cleaning — is done by the
    RESTful service, then there are results that can’t be reproduced from the CLI.
    This means the acceptance test suites have distinct results. This will lead to
    problems when a change is made to the underlying **acquire** or **clean** application
    and the “extra” processing that was jammed into the RESTful service now appears
    to be broken.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 RESTful 服务执行了额外的处理——例如，额外的清理——那么就有一些结果无法从 CLI 中重现。这意味着验收测试套件会有不同的结果。当对底层**获取**或**清理**应用程序进行更改，并且之前被强行塞入
    RESTful 服务的“额外”处理现在看起来是损坏的，这将会导致问题。
- en: A common source of problems in enterprise software is the failure to honor the
    **I****nterface** **Segregation** design principle. A complex application may
    be supported by several collaborating organizations. When one organization is
    slow to respond to requests for changes, another organization may step in and
    make a bad design decision, implementing processing in the API interface that
    should have been part of a background module with a proper CLI interface. The
    urge to be responsive to customers can often overshadow the importance of the
    separation of concerns.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 企业软件中常见的问题之一是未能遵守**接口分离**设计原则。一个复杂的应用程序可能由几个协作的组织支持。当一个组织对变更请求响应缓慢时，另一个组织可能会介入并做出错误的设计决策，在
    API 接口中实现本应属于具有适当 CLI 接口的背景模块的处理。对客户响应的迫切需求往往掩盖了关注点分离的重要性。
- en: For this project, the server can be built as a single process, avoiding the
    need for the distributed cache. Further, because the data series and the processing
    logs are all simple files, a database is not required; the local filesystem is
    perfectly suited to this service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，服务器可以构建为一个单一进程，避免需要分布式缓存。此外，由于数据序列和处理日志都是简单的文件，因此不需要数据库；本地文件系统非常适合这个服务。
- en: To create a more scalable solution, a library such as **celery** can be used
    to create a more robust distributed worker pool. This isn’t needed for a small
    server, however.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个更可扩展的解决方案，可以使用如**celery**这样的库来创建一个更健壮的分布式工作池。然而，对于小型服务器来说，这并不是必需的。
- en: In the next section, we’ll review how processing can be started by a RESTful
    API.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将回顾如何通过 RESTful API 启动处理。
- en: 12.2.3 A POST request starts processing
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.3 POST 请求开始处理
- en: The general approach to creating a new resource is to make a `POST` request
    to a path. This will either return a 400 error status or it will issue a redirect
    (301) to a new path to retrieve the status of the background processing. This
    pattern is called the **Post-Redirect-Get** design pattern. It permits a user
    interacting with a browser to use the **back** button to perform the `GET` method
    again; it prevents the **back** button from submitting a duplicate request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新资源的一般方法是向路径发送一个 `POST` 请求。这将返回一个 400 错误状态或发出一个重定向（301）到新的路径以检索后台处理的状态。这种模式称为**后重定向获取**设计模式。它允许用户通过浏览器与交互时使用**后退**按钮再次执行
    `GET` 方法；它防止**后退**按钮提交重复请求。
- en: For a client application making a request via `requests` the redirect is essentially
    invisible. The request history will reveal the redirection. Also, the full URL
    recorded in the response will reflect the redirection.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于通过 `requests` 发起请求的客户端应用程序，重定向基本上是不可见的。请求历史将揭示重定向。此外，响应中记录的完整 URL 将反映重定向。
- en: 'The general processing for this route, then, is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个路由的一般处理过程如下：
- en: Validate all of the parameters to make sure they describe the series and the
    source of the data. If there is anything amiss, a JSON response with the details
    of the problem must be returned, with a status code of 400 to indicate the request
    is invalid and must be changed.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有参数以确保它们描述了数据序列和数据来源。如果有任何问题，必须返回一个包含问题详细信息的 JSON 响应，状态码为 400，以指示请求无效且必须更改。
- en: Use the worker pool `submit()` method to create a `Future` object. This object
    can be saved in a local cache by the RESTful API. This cache of `Future` objects
    can be queried to see the background processing currently being performed. The
    future’s result is usually something indicative of success or failure; for example,
    the return code from the subprocess – usually a zero indicates success.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用工作池的 `submit()` 方法创建一个 `Future` 对象。这个对象可以通过 RESTful API 保存到本地缓存中。这个 `Future`
    对象的缓存可以查询以查看当前正在进行的后台处理。未来的结果通常表明成功或失败；例如，子进程的返回码——通常为零表示成功。
- en: Use the `redirect()` function in the Bottle framework to return the status code
    to direct a client to another URL for the status of the just-created `Future`
    object. Separately, a GET request will prepare a JSON document with the status
    of the job creating the data.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Bottle框架中的`redirect()`函数返回状态码，以将客户端重定向到另一个URL以获取刚刚创建的`Future`对象的状态。单独，GET请求将准备一个包含创建数据作业状态的JSON文档。
- en: When using a framework like Bottle, this function is marked with a `@post("/2023.02/creation")`
    decorator. This names the POST method and the path that will be handled by the
    function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Bottle等框架时，此函数通过`@post("/2023.02/creation")`装饰器进行标记。这命名了POST方法和将由函数处理的路径。
- en: The log files from processing can be the longer-term repository of processing
    history. The GET request for status will return a log and possibly the state of
    an active `Future` object. We’ll look at this request next.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理的日志文件可以是处理历史的长期存储库。状态请求的GET请求将返回日志以及可能的活动`Future`对象的状态。我们将在下一节中查看此请求。
- en: 12.2.4 The GET request for processing status
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.4 对处理状态进行GET请求
- en: The initial POST request to start processing will redirect to a GET request
    that reveals the status of the processing. The initial response may have almost
    no other details beyond the fact that the processing job has started.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的POST请求以开始处理，将重定向到GET请求，以揭示处理状态。初始响应可能除了处理作业已开始之外几乎没有其他细节。
- en: 'This status path should return one of two things:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此状态路径应返回以下两种事物之一：
- en: A 404 status if the process ID is unknown. This would mean no previous request
    had been made with this identifier and no current request has this identifier,
    either.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果进程ID未知，则返回404状态。这意味着没有使用此标识符发出之前的请求，也没有当前请求具有此标识符。
- en: 'A 200 status with JSON content that includes some combination of two things:
    the state of a future object and the log file.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有JSON内容的200状态，包括以下两种事物的组合：未来对象的状态和日志文件。
- en: Most users will only care about the state of the `Future` object. In the case
    of developers, however, who are adding features to data acquire or data cleaning
    applications, then the log might be important support for observability.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户只关心`Future`对象的状态。然而，对于开发人员来说，他们正在向数据获取或数据清理应用程序添加功能，那么日志可能是观察性的重要支持。
- en: When using a framework like Bottle, this function is marked with a `@get("/2023.02/creation/<job_id>")`
    decorator. This provides the method and the path that will be handled by the function.
    The use of `<job_id>` parses this section of the path and provides the value as
    a separate parameter to the function that implements this route.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Bottle等框架时，此函数通过`@get("/2023.02/creation/<job_id>")`装饰器进行标记。这提供了将由函数处理的方法和路径。使用`<job_id>`解析路径的这一部分，并将值作为单独的参数提供给实现此路由的函数。
- en: Once the processing is complete, a subsequent request can provide the data.
    We’ll look at this next.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦处理完成，后续请求可以提供数据。我们将在下一节中查看这一点。
- en: 12.2.5 The GET request for the results
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.5 对结果进行GET请求
- en: 'This path should return one of two things:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径应返回以下两种事物之一：
- en: A 404 status if the series identifier is unknown.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果系列标识符未知，则返回404状态。
- en: A 200 status with the ND JSON content. This has a MIME type of `application/x-ndjson`
    to indicate it’s an extension to the standard collection of MIME types.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有ND JSON内容的200状态。这具有`application/x-ndjson`的MIME类型，以表明它是标准MIME类型集合的扩展。
- en: When using a framework like Bottle, this function is marked with a `@get("/2023.02/series/<series_id>")`
    decorator. The use of `<series_id>` parses this section of the path and provides
    the value as a separate parameter to the function that implements this route.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Bottle等框架时，此函数通过`@get("/2023.02/series/<series_id>")`装饰器进行标记。使用`<series_id>`解析路径的这一部分，并将值作为单独的参数提供给实现此路由的函数。
- en: A more sophisticated implementation can check for an `Accept` header in the
    request. This header will state the preferred MIME type, and might have `text/csv`
    instead of `application/x-ndjson`. The use of this header permits a client to
    make requests for data in a format the application finds most useful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的实现可以检查请求中的`Accept`头。此头将声明首选的MIME类型，可能使用`text/csv`而不是`application/x-ndjson`。使用此头允许客户端以应用程序认为最有用的格式请求数据。
- en: 12.2.6 Security considerations
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2.6 安全性考虑
- en: A RESTful API requires some care to be sure the requests fit with the overall
    enterprise information access policies. In some cases, this might mean individual
    access controls to be sure each person can access permitted data. There are numerous
    **Single Sign-On** (**SSO**) products that can handle the identity of individuals.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个RESTful API需要一些注意，以确保请求与整体企业信息访问策略相匹配。在某些情况下，这可能意味着个人访问控制，以确保每个人都可以访问允许的数据。有许多**单点登录**（**SSO**）产品可以处理个人的身份。
- en: Another common approach is to have an API work with assigned API keys. The team
    supporting the API can provide unique API key values to known users or teams.
    Within most enterprises, there’s little need for automating the assignment of
    API keys for internal-facing APIs. The set of valid API keys may be reduced or
    expanded to reflect organizational merges and splits.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见的方法是让API与分配的API密钥一起工作。支持API的团队可以为已知用户或团队提供唯一的API密钥值。在大多数企业中，对于面向内部API的API密钥的自动化分配几乎没有需求。有效的API密钥集可能需要减少或增加，以反映组织合并和分裂。
- en: API key values are sent from the client to the server to authenticate the user
    making a request. They are never sent from the server to a client. The API keys
    can be kept in a simple text file; the file’s permissions should restrict it to
    read-only access by the account handling the service as a whole. This requires
    administrators to take steps to manage the file of API keys to avoid damaging
    it or revealing it to unauthorized users.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥值是从客户端发送到服务器，以验证发起请求的用户。它们永远不会从服务器发送到客户端。API密钥可以保存在一个简单的文本文件中；文件权限应限制为只读访问，由处理整个服务的账户进行管理。这要求管理员采取措施来管理API密钥文件，以避免损坏它或将其泄露给未经授权的用户。
- en: 'When working with API keys, there are a number of ways the client can provide
    the key with each API request. One of the more popular techniques is to use these
    complementary security features:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当与API密钥一起工作时，客户端有多种方式可以在每次API请求中提供密钥。其中一种更受欢迎的技术是使用这些互补的安全功能：
- en: The HTTPS protocol, where all of the communication between client and server
    application is encrypted.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTPS协议，其中客户端和服务器应用程序之间的所有通信都是加密的。
- en: The HTTP **Authorization** header with **Basic** authorization. This header
    will have a username and the API key as the password.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**基本**授权的HTTP **授权**头。此头将包含用户名和API密钥作为密码。
- en: The use of the **Authorization** header is often very simple for a client tool.
    Many libraries — for example, the **requests** library — offer an object class
    that contains the username and API key. Using the `auth=` parameter on a request
    function will build the appropriate header.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端工具来说，使用**授权**头通常非常简单。许多库——例如，**requests**库——提供了一个包含用户名和API密钥的对象类。在请求函数上使用`auth=`参数将构建适当的头。
- en: The use of HTTPS includes **Transport Layer Security** (**TLS**) to keep the
    content of the **Authorization** header secret. The **requests** package handles
    this politely.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS包括**传输层安全性**（**TLS**）来保护**授权**头的内容。**requests**包会礼貌地处理这一点。
- en: On the server side, each of these must be handled by our RESTful API application.
    Using HTTPS is best done by running the **Bottle** application inside another
    server. We could, for example, create an NGINX and uWSGI configuration that would
    run our RESTful app inside a containing server. Another choice is to use a Python-based
    server such as Paste or GUnicorn to contain the **Bottle** application. It’s essential
    to have a container server to handle the details of HTTPS negotiation.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，这些都需要由我们的RESTful API应用程序来处理。使用HTTPS最好是通过在另一个服务器内运行**Bottle**应用程序来实现。例如，我们可以创建一个NGINX和uWSGI配置，在包含服务器内运行我们的RESTful应用程序。另一个选择是使用基于Python的服务器，如Paste或GUnicorn来包含**Bottle**应用程序。拥有一个容器服务器来处理HTTPS协商的细节是至关重要的。
- en: Processing the **Authorization** header is something best done within the RESTful
    API. Some routes (i.e., the `openapi.yaml`) should not include any security considerations.
    Other routes — specifically those that cause state changes — may be limited to
    a subset of all users.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 处理**授权**头最好在RESTful API中进行。一些路由（例如，`openapi.yaml`）不应包含任何安全考虑。其他路由——特别是那些导致状态变化的路由——可能仅限于所有用户的一个子集。
- en: This suggests the list of users includes some permissions as well as their API
    key. Each route needs to confirm the **Authorization** header has a known user
    and the correct key. The `request.auth` property of the `request` object is a
    two-tuple with the username and API key value. This can be used to decide whether
    the request is generally acceptable, and also to decide whether a state-changing
    **Post** operation is permitted for the given user. This kind of processing is
    often implemented as a decorator.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明用户列表包括一些权限以及它们的API密钥。每个路由都需要确认**授权**头包含一个已知的用户和正确的密钥。`request`对象的`request.auth`属性是一个包含用户名和API密钥值的二元组。这可以用来决定请求是否通常可接受，以及是否允许给定的用户进行状态改变的**POST**操作。这种处理通常实现为一个装饰器。
- en: We won’t dig deeply into the design of this decorator. For this project, with
    so few resources, a repeated `if` statement inside each function is acceptable.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入探讨这个装饰器的设计。对于这个项目，由于资源很少，每个函数内部重复的`if`语句是可以接受的。
- en: 12.3 Deliverables
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.3 可交付成果
- en: 'This project has the following deliverables:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目有以下可交付成果：
- en: Documentation in the `docs` folder
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`文件夹中的文档'
- en: Acceptance tests in the `tests/features` and `tests/steps` folders
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests/features`和`tests/steps`文件夹中的验收测试'
- en: Unit tests for the application modules in the `tests` folder
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`文件夹中应用程序模块的单元测试'
- en: An application for the RESTful API processing
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于RESTful API处理的程序
- en: We’ll start by looking at the acceptance test cases, first. They’ll be rather
    complex because we need to start the RESTful API service before we can access
    it with a client request.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看验收测试用例。由于我们需要在用客户端请求访问之前启动RESTful API服务，所以它们将相当复杂。
- en: 12.3.1 Acceptance test cases
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.1 验收测试用例
- en: 'Back in [*Chapter** 4*](ch008.xhtml#x1-780004), [*Data Acquisition Features:
    Web APIs and Scraping*](ch008.xhtml#x1-780004), specifically [*Acceptance tests
    using a SQLite database*](ch009.xhtml#x1-1360005), we looked at ways to describe
    a scenario that involved a database service.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[*第4章*](ch008.xhtml#x1-780004)，[*数据获取功能：Web API和抓取*](ch008.xhtml#x1-780004)，特别是[*使用SQLite数据库的验收测试*](ch009.xhtml#x1-1360005)，我们探讨了描述涉及数据库服务的场景的方法。
- en: For this project, we’ll need to write scenarios that will lead to step definitions
    that start the RESTful API service.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要编写将导致启动RESTful API服务的步骤定义的场景。
- en: There’s an important question about setting the state of the RESTful API server.
    One approach to setting a state is by making a sequence of requests as part of
    the scenario. This is often appropriate for this application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 关于设置RESTful API服务器状态有一个重要的问题。设置状态的一种方法是在场景中作为一系列请求的一部分。这对于这个应用程序通常是合适的。
- en: If the server’s state is reflected in the file system, then seeding proper files
    can be a way to control the state of the API server. Rather than run an acquire
    and clean process, a test scenario can inject the appropriate status and log files
    into a working directory.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果服务器状态反映在文件系统中，那么通过播种适当的文件可以控制API服务器状态。而不是运行获取和清理过程，测试场景可以将适当的状态和日志文件注入到工作目录中。
- en: Some developers have a feeling that a database (or a distributed cache) is required
    for RESTful APIs. In practice, it’s often the case that a shared file system is
    sufficient.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者有一种感觉，RESTful API需要数据库（或分布式缓存）。在实践中，通常情况下，共享文件系统就足够了。
- en: Using files is not uncommon in practice. A database to share state is not **always**
    required for RESTful APIs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中使用文件并不罕见。对于RESTful API，并不**总是**需要共享状态的数据库。
- en: Using the file system for the state makes acceptance testing work out nicely.
    The proper files can be created to initialize the service in the state described
    by the given steps in the test scenario.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用文件系统进行状态使得验收测试工作得很好。可以创建适当的文件来初始化由测试场景中给定的步骤描述的状态下的服务。
- en: 'A complicated scenario could look like the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的场景可能如下所示：
- en: '[PRE6]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For more background on creating a fixture, see [*Acceptance tests*](ch008.xhtml#x1-910003)
    in [*Chapter** 4*](ch008.xhtml#x1-780004), [*Data Acquisition Features: Web APIs
    and Scraping*](ch008.xhtml#x1-780004). This scenario references a fixture named
    `REST_server`. This means the `environment.py` must define this fixture, and provide
    a `before_tag()` function that will make sure the fixture is used.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 关于创建固定值的更多背景信息，请参阅[*第4章*](ch008.xhtml#x1-780004)，[*数据获取功能：Web API和抓取*](ch008.xhtml#x1-780004)中的[*验收测试*](ch008.xhtml#x1-910003)。此场景引用了一个名为`REST_server`的固定值。这意味着`environment.py`必须定义此固定值，并提供一个`before_tag()`函数，以确保使用该固定值。
- en: The given steps specify an initial query and response. This should set the required
    state in the API server. This request for processing will initiate the acquire
    and clean processing. The `When` step specifies a sequence of actions that include
    polling periodically until the requested processing finishes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给定的步骤指定了一个初始查询和响应。这应该在API服务器中设置所需的状态。此处理请求将启动获取和清理处理。《When》步骤指定了一系列动作，包括定期轮询，直到请求的处理完成。
- en: Note the path provided in the `When` statement. The text `job-id` is in the
    scenario’s path. The step definition function must replace this template string
    with the actual job identifier. This identifier will be in response to the initial
    request in the given step. The `Given` step’s definition function must save the
    value in the context for use in later steps.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`When`语句中提供的路径。文本`job-id`位于场景的路径中。步骤定义函数必须用实际的作业标识符替换此模板字符串。此标识符将在给定步骤的初始请求中给出。《Given》步骤的定义函数必须将值保存在上下文中，以便在后续步骤中使用。
- en: The `Then` step confirms that series data was returned. This example does not
    show a very complete check of the result. You are encouraged to expand on this
    kind of acceptance test scenario to be more complete in checking the actual results
    match the expected results.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`Then`步骤确认系列数据已被返回。此示例并未展示对结果的完整检查。鼓励您扩展此类验收测试场景，以便更完整地检查实际结果是否与预期结果相符。'
- en: For some applications, the retrieval of a tiny test case dataset may be a feature
    that helps test the application. The ordinary datasets the users want may be quite
    large, but a special, exceptionally small dataset may also be made available to
    confirm all the parts are working in concert.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些应用，检索一个微小的测试案例数据集可能是一个有助于测试应用的特性。用户想要的普通数据集可能相当大，但也可以提供一个特别小、异常小的数据集，以确认所有部分都在协同工作。
- en: A self-test resource is often essential for health checks, diagnostics, and
    general site reliability.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 自检资源对于健康检查、诊断和一般站点可靠性通常是必不可少的。
- en: Network load balancers often need to probe a server to be sure it’s capable
    of handling requests. A self-test URI can be helpful for this purpose.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 网络负载均衡器通常需要探测服务器以确保其能够处理请求。一个自检URI可以为此目的提供帮助。
- en: A very subtle issue arises when trying to stop this service. It contains a worker
    pool, and the parent process needs to use the Linux `wait()` to properly terminate
    the children.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试停止此服务时，会出现一个非常微妙的问题。它包含一个工作池，父进程需要使用Linux的`wait()`来正确地终止子进程。
- en: 'One reliable way to do this is to use `server.send_signal(signal.SIGINT)` in
    the function that starts the service to create the fixture for a scenario. This
    means the fixture function will have the following outline:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可靠的方法是在启动服务的函数中使用`server.send_signal(signal.SIGINT)`来创建场景的固定装置。这意味着固定装置函数将有以下轮廓：
- en: '[PRE7]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The various `sleep()` timings are generous over-estimations of the time required
    for the server subprocess to complete the various startup and shut-down tasks.
    In some cases, the OS scheduler will handle this gracefully. In other cases, however,
    disconnected child processes can be left in the list of running processes. These
    “zombie processes” need to be terminated manually, something we’d like to avoid.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 各种`sleep()`时间是对服务器子进程完成各种启动和关闭任务所需时间的宽松估计。在某些情况下，操作系统调度器会优雅地处理这种情况。然而，在其他情况下，断开的子进程可能会留在运行进程的列表中。这些“僵尸进程”需要手动终止，这是我们希望避免的。
- en: On most Linux-derived OSs, the `ps`` -ef` command will show all processes. The
    `ps`` -ef`` |`` grep`` python` pipeline will show all Python processes.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数基于Linux的操作系统上，`ps -ef`命令将显示所有进程。`ps -ef | grep python`管道将显示所有Python进程。
- en: From this list, any zombie worker pool processes should be apparent.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 从此列表中，任何僵尸工作池进程应该都很明显。
- en: '`signal.SIGINT` is the control-C interrupt signal. The Python process makes
    this an exception that will not be handled. When this exception exits from the
    `with` statement that created the process pool, a complete clean-up will be finished
    and no zombie processes will be left running.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`signal.SIGINT`是控制-C中断信号。Python进程将此作为一个不会处理的异常。当此异常从创建进程池的`with`语句退出时，将完成完整的清理，并且不会留下僵尸进程在运行。'
- en: Now that we’ve looked at the acceptance test that defines proper behavior, we
    can look at the RESTful API server application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看定义了适当行为的验收测试，我们可以查看RESTful API服务器应用。
- en: 12.3.2 RESTful API app
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.2 RESTful API应用
- en: 'The RESTful API application can be built with any of the available frameworks.
    Since a previous chapter ([*Chapter** 4*](ch008.xhtml#x1-780004), [*Data Acquisition
    Features: Web APIs and* *Scraping*](ch008.xhtml#x1-780004)) used the Bottle framework,
    you can continue with this small framework. Because Bottle is very much like Flask,
    when additional features are needed, the upgrade to Flask isn’t horribly complicated.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 应用程序可以使用任何可用的框架来构建。由于前一章 ([*第 4 章*](ch008.xhtml#x1-780004)，[*数据获取功能：Web
    API 和* *抓取*](ch008.xhtml#x1-780004))) 使用了 Bottle 框架，你可以继续使用这个小型框架。因为 Bottle 和
    Flask 非常相似，当需要额外功能时，升级到 Flask 并不复杂。
- en: One of the advantages of using Flask for this application is an integrated client
    for writing unit test cases. The Bottle project can do everything that’s required,
    but it lacks a test client. When looking at unit testing, we’ll also look at unit
    test tools for the Bottle framework.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Flask 为此应用程序的一个优点是集成了用于编写单元测试用例的客户端。Bottle 项目可以完成所需的一切，但它缺少测试客户端。在查看单元测试时，我们还将查看
    Bottle 框架的单元测试工具。
- en: 'In [*OpenAPI 3 specification*](#x1-2810001) we looked at the OpenAPI specification
    for a specific path. Here’s how that specification can be implemented:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*OpenAPI 3 规范*](#x1-2810001) 中，我们查看了一个特定路径的 OpenAPI 规范。以下是该规范可以如何实现：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This function builds a sequence of metadata dictionaries. Each item has a series
    name, which is used in a separate request to get the data. The size is computed
    by a small function to read the series and find the number of samples.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数构建了一系列元数据字典。每个项目都有一个系列名称，该名称用于单独的请求来获取数据。大小是通过一个小函数计算得出的，该函数读取系列并找到样本数量。
- en: The `response` object is not always manipulated as shown in this example. This
    is an extreme case, where the value to be returned is not a Python dictionary.
    If the return value is a dictionary, the Bottle framework will convert it to JSON,
    and the content type will be set to `application/json` automatically. In this
    case, the result is a list of dictionaries; the Bottle framework will not automatically
    serialize the object in JSON notation.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`response` 对象并不总是像这个示例中那样被操作。这是一个极端案例，其中要返回的值不是一个 Python 字典。如果返回值是字典，Bottle
    框架会自动将其转换为 JSON，并将内容类型设置为 `application/json`。在这种情况下，结果是字典列表；Bottle 框架不会自动将对象序列化为
    JSON 表示法。'
- en: An important part of the design is a cache to retain `Future` objects until
    the processing completes, and the data is available. One way to handle this is
    with a dataclass that keeps the parameters of the request, the `Future` object
    that will produce the results, and the assigned job identifier.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 设计的一个重要部分是缓存，以保留 `Future` 对象直到处理完成，数据可用。处理这种需求的一种方法是用数据类来保存请求的参数、将产生结果的 `Future`
    对象以及分配的工作标识符。
- en: 'This structure for each `Future` object might look like the following example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `Future` 对象的结构可能看起来像以下示例：
- en: '[PRE9]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This keeps the parameters for the request as well as the processing details.
    The values for `series`, `source_path`, and `output_path` are built from the parameters
    provided when making an initial request. The paths are built from supplied names
    and include the base path for the working directory the server is using. In this
    example, the user’s input is limited to the series name and the data source. These
    come from a small domain of valid values, making it relatively easy to validate
    these values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这保留了请求的参数以及处理细节。`series`、`source_path` 和 `output_path` 的值是从初始请求时提供的参数构建的。路径是从提供的名称构建的，并包括服务器正在使用的作业目录的基本路径。在这个示例中，用户的输入仅限于系列名称和数据源。这些值来自一个有效的值域，这使得验证这些值相对容易。
- en: The RESTful API can then create the output path within the appropriate directory
    of cleaned data.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，RESTful API 可以在适当的数据清理目录中创建输出路径。
- en: The value for the `job_id` attribute is computed automatically when an instance
    of the `AcquireJob` class is created.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `AcquireJob` 类的实例时，自动计算 `job_id` 属性的值。
- en: The value for the `future` attribute is set when the `submit()` method is used
    to submit a processing request to process a pool of waiting workers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `submit()` 方法提交处理请求到等待的工作池时，设置 `future` 属性的值。
- en: 'The worker pool needs to be created before any work can be done by the RESTful
    API. The startup can look like the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RESTful API 执行任何工作之前，需要创建工作池。启动可能看起来像以下示例：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each route is handled by a separate function. Because of this, the Bottle (as
    well as the Flask) framework expects the worker pool to be a global object shared
    by all of the route-handling functions. In the event of a multi-threaded server,
    a lock must be used before a write access to the `WORKERS` global.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由都由一个单独的函数处理。因此，Bottle（以及Flask）框架期望工作池是一个由所有路由处理函数共享的全局对象。在多线程服务器的情况下，在写入`WORKERS`全局之前必须使用锁。
- en: Similarly, the cache of `AcquireJob` instances is also expected to be a global
    object. This is updated only by the route-handling function to handle initiating
    a processing request. This cache will be queried by a route that shows the status
    of a processing request. In the event of a multi-threaded server, a lock must
    be used before adding a new item to the global cache of working jobs.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`AcquireJob`实例的缓存也预期是一个全局对象。这个缓存只由处理路由的函数更新，以处理初始化处理请求。这个缓存将由显示处理请求状态的路由查询。在多线程服务器的情况下，在向全局工作作业缓存添加新项之前必须使用锁。
- en: In some cases, where the load is particularly heavy, thread-local storage may
    be needed for any processing done by the various functions in the RESTful API
    implementation. The `request` and `response` objects, in particular, are already
    in thread-local storage. Ideally, there is very little processing done by these
    functions, minimizing the number of objects that need to be created and kept in
    an instance of `threading.local`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当负载特别重时，可能需要为RESTful API实现中各种函数执行的处理使用线程局部存储。特别是`request`和`response`对象已经在线程局部存储中。理想情况下，这些函数执行的处理非常少，最小化需要创建并保留在`threading.local`实例中的对象数量。
- en: There are a few special considerations for the unit tests for this project.
    We’ll look at those in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目的单元测试有一些特殊考虑。我们将在下一节中探讨这些内容。
- en: 12.3.3 Unit test cases
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3.3 单元测试用例
- en: Some frameworks — like **Flask** — offer a test client that can be used to exercise
    an application without the overheads of starting a server and a worker pool.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架——如**Flask**——提供了一个测试客户端，可以用来在没有启动服务器和工作池开销的情况下测试应用程序。
- en: The **Bottle** framework doesn’t offer a test client. An associated project,
    **boddle**, offers a way to build a mock `request` object to support unit testing.
    See [https://github.com/keredson/boddle](https://github.com/keredson/boddle).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bottle**框架不提供测试客户端。一个相关项目，**boddle**，提供了一种构建模拟`request`对象以支持单元测试的方法。请参阅[https://github.com/keredson/boddle](https://github.com/keredson/boddle)。'
- en: The **WebTest** project is an alternative for writing unit tests. A **WebTest**
    fixture contains the Bottle application and provides requests and responses through
    the internal WSGI interface. This avoids the need to start a complete server.
    It also permits some monkey-patching of the Bottle application to mock components.
    See [https://docs.pylonsproject.org/projects/webtest/en/latest/](https://docs.pylonsproject.org/projects/webtest/en/latest/).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebTest**项目是编写单元测试的替代方案。一个**WebTest**固定配置包含Bottle应用程序，并通过内部WSGI接口提供请求和响应。这避免了启动完整服务器的需要。它还允许对Bottle应用程序进行一些猴子补丁以模拟组件。请参阅[https://docs.pylonsproject.org/projects/webtest/en/latest/](https://docs.pylonsproject.org/projects/webtest/en/latest/)。'
- en: It seems best to use the very sophisticated `WebTest` client that’s part of
    the **Pylons** framework. This client can execute the unit tests.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Pylons**框架中包含的非常复杂的`WebTest`客户端似乎是最好的选择。这个客户端可以执行单元测试。
- en: It’s sometimes helpful to note that functions with decorators are composite
    objects. This means the “unit” test isn’t testing the decoration and the function
    in isolation from each other. This lack of separate testing can sometimes lead
    to difficulty in debugging the root cause of a test case failure. A problem may
    be in the function, it may be the `@route` decorator, or it may be any authorization
    decorator that’s also part of the composite function being tested.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有时注意到带有装饰器的函数是复合对象是有帮助的。这意味着“单元”测试并不是在彼此独立的情况下测试装饰和函数。这种缺乏单独测试的情况有时会导致调试测试用例失败的根本原因变得困难。问题可能出在函数上，也可能是`@route`装饰器，或者可能是测试中作为复合函数一部分的任何授权装饰器。
- en: It seems easier to test the composite route functions, using appropriate log
    messages for debugging. While this doesn’t follow the strict idea of testing each
    component in isolation, it does work well for testing each route with appropriate
    mocks. For example, we can mock the worker pool, avoiding the overhead of starting
    a subprocess when testing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的日志消息进行调试似乎更容易测试组合路由函数。虽然这并不严格遵循单独测试每个组件的想法，但它对于使用适当的模拟测试每个路由来说效果很好。例如，我们可以模拟工作池，避免在测试时启动子进程的开销。
- en: 'Here’s an example of a test function using **WebTest** to exercise a **Bottle**
    route:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个使用 **WebTest** 来测试 **Bottle** 路由的测试函数示例：
- en: '[PRE11]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`service.app` is the global `app` object in the RESTful API application. This
    is an instance of the `Bottle` class. `service.ACCESS` is the global list of usernames
    and their expected API keys. This is monkey-patched by the test to force in a
    specific test username and test API Key. This initial setup is something that
    might be used by a number of tests and should be defined as a reusable fixture.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`service.app` 是 RESTful API 应用程序中的全局 `app` 对象。这是一个 `Bottle` 类的实例。`service.ACCESS`
    是全局的用户名及其预期 API 密钥的列表。测试通过 monkey-patch 强制输入特定的测试用户名和测试 API 密钥。这种初始设置可能是许多测试会用到的，应该定义为一个可重用的固定装置。'
- en: When the `app.get()` request is made, the test harness will execute the `route`
    function and collect the response for examination by the `test` method. This makes
    a direct function call, avoiding the overhead of a network request.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出 `app.get()` 请求时，测试工具将执行 `route` 函数并收集响应，以便由 `test` 方法进行检查。这直接调用函数，避免了网络请求的开销。
- en: One of the reasons for choosing to use **Flask** instead of **Bottle** is the
    availability of a test client that can simplify some of this test setup.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用 **Flask** 而不是 **Bottle** 的原因之一是可用的测试客户端可以简化一些测试设置。
- en: 12.4 Summary
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.4 概述
- en: 'This chapter integrated a number of application programs under the cover of
    a single RESTful API. To build a proper API, there were several important groups
    of skills:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章在单个 RESTful API 的覆盖下集成了多个应用程序。为了构建合适的 API，需要几个重要的技能组：
- en: Creating an OpenAPI specification.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 OpenAPI 规范。
- en: Writing a web service application to implement the OpenAPI specification.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写实现 OpenAPI 规范的 Web 服务应用程序。
- en: Using a processing pool to delegate long-running background tasks. In this example,
    we used `concurrent.futures` to create a future promise of results, and then compute
    those results.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用处理池来委托长时间运行的后台任务。在这个例子中，我们使用了 `concurrent.futures` 来创建结果的未来承诺，然后计算这些结果。
- en: The number of processes involved can be quite daunting. In addition to the web
    service, there is a processing pool, with a number of sub-processes to do the
    work of acquiring and cleaning data.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 涉及的进程数量可能相当令人畏惧。除了 Web 服务之外，还有一个处理池，有多个子进程来执行获取和清理数据的工作。
- en: In many cases, additional tools are built to monitor the API to be sure it’s
    running properly. Further, it’s also common to allocate dedicated servers to this
    work, and configure `supervisord` to start the overall service and ensure the
    service continues to run properly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，会构建额外的工具来监控 API，以确保其正常运行。此外，通常还会分配专用服务器来完成这项工作，并配置 `supervisord` 来启动整体服务并确保服务继续正常运行。
- en: 12.5 Extras
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 12.5 额外内容
- en: Here are some ideas for you to add to these projects.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法，您可以将其添加到这些项目中。
- en: 12.5.1 Add filtering criteria to the POST request
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.1 向 POST 请求添加过滤条件
- en: The **POST** request that initiates acquire processing is quite complicated.
    See [*A* *POST request starts processing*](#x1-2830003) to see the processing
    it does.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化获取处理的 **POST** 请求相当复杂。参见 [*A* *POST 请求开始处理*](#x1-2830003) 了解它执行的处理。
- en: We might name the function for this route `creation_job_post()` to make it clear
    that this creates jobs to acquire data in response to an HTTP POST request.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能将此路由的函数命名为 `creation_job_post()`，以使其明确表示该函数创建工作以响应 HTTP POST 请求来获取数据。
- en: 'The list of tasks in this function includes the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数中的任务列表包括以下内容：
- en: Check the user’s permissions.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查用户的权限。
- en: Validate the parameters.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证参数。
- en: Build an `AcquireJob` instance with the parameters.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用参数构建一个 `AcquireJob` 实例。
- en: Update the `AcquireJob` instance with the `Future` object. The future will evaluate
    the `acquire_series()` function that does the work of acquiring and cleaning the
    data.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Future` 对象更新 `AcquireJob` 实例。该未来将评估 `acquire_series()` 函数，该函数执行获取和清理数据的工作。
- en: Return a JSON object with details of the submitted job, as well as headers and
    a status code to redirect to a request to get the job’s status.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回一个包含提交作业详细信息的 JSON 对象，以及用于重定向到获取作业状态的请求的头部和状态码。
- en: Some RESTful APIs will have even more complicated parameters. For example, users
    may want to filter the data to create a subset before downloading. This improves
    the UX by providing only the required data. It also allows analysts to share subsets
    of data without having to share the filtering code within the analyst community.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 RESTful API 可能会有更复杂的参数。例如，用户可能希望在下载之前过滤数据以创建一个子集。这通过只提供所需数据来提高用户体验。它还允许分析师在不需要在分析师社区中共享过滤代码的情况下共享数据子集。
- en: It can also improve the UX by performing filtering on larger, powerful servers.
    It can prevent having to download and filter data on a local laptop.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以通过在更大的、更强大的服务器上执行过滤来提高用户体验。它可以防止需要在本地笔记本电脑上下载和过滤数据。
- en: This is emphatically **not** a feature of the RESTful API. This must **first**
    be built as a feature of an application that reads and filters the clean data.
    This new application will create a new dataset, ready for download. The data set
    name might be a UUID, and an associated metadata file would contain the filter
    parameters.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对**不是**RESTful API 的特性。这必须**首先**作为一个读取和过滤干净数据的应用程序的特性来构建。这个新应用程序将创建一个新的数据集，准备下载。数据集名称可能是一个
    UUID，相关的元数据文件将包含过滤参数。
- en: The implementation requires the `creation_job_post()` function to now also validate
    the filter criteria. It must include the filter criteria in the `AcquireJob` instance
    that is built, and provide the filter criteria to the underlying `acquire_series()`
    function.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 实现需要 `creation_job_post()` 函数现在也要验证过滤标准。它必须在构建的 `AcquireJob` 实例中包含过滤标准，并将过滤标准提供给底层的
    `acquire_series()` 函数。
- en: The `acquire_series()` function will have the most dramatic changes. It will
    run the acquire, clean, and filter applications as subprocesses. You may want
    to consider an integrated application that runs the other applications, simplifying
    the RESTful API.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`acquire_series()` 函数将会有最显著的变化。它将以子进程的形式运行获取、清理和过滤应用程序。你可能需要考虑一个集成的应用程序，该应用程序运行其他应用程序，简化
    RESTful API。'
- en: This will, of course, lead to considerably more complicated acceptance test
    cases to be sure the data acquisition works with — and without — these additional
    filter criteria.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然会导致接受测试用例的复杂性大大增加，以确保数据获取与这些额外的过滤标准一起以及不一起工作。
- en: 12.5.2 Split the OpenAPI specification into two parts to use $REF for the output
    schema
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.2 将 OpenAPI 规范分成两部分以使用 $REF 来引用输出模式
- en: The OpenAPI specification includes a number of schema. In [*OpenAPI 3* *specification*](#x1-2810001),
    we showed a few key features of this specification.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 规范包括多个模式。在 [*OpenAPI 3 规范*](#x1-2810001) 中，我们展示了该规范的一些关键特性。
- en: It’s not too difficult for an analyst to download the entire specification,
    and then locate the `components.schemas.seriesList` schema. This navigation through
    a JSON document doesn’t involve too many challenges.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分析师来说，下载整个规范并定位到 `components.schemas.seriesList` 模式并不太难。这种通过 JSON 文档的导航不涉及太多挑战。
- en: While this is not burdensome, some users might object. An analyst focused on
    a business problem should not be asked to also sort out the structure of the OpenAPI
    specification. An alternative is to decompose the specification into pieces and
    serve the pieces separately.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不繁重，但一些用户可能会反对。专注于商业问题的分析师不应该被要求也整理 OpenAPI 规范的结构。一个替代方案是将规范分解成几个部分，并分别提供这些部分。
- en: Specifically, the places where `"$ref"` references appear generally use a path
    of the form `#/components/schemas/...`. The path is a local URL, omitting the
    hostname information. This can be replaced with a full URL that refers to schema
    details on the RESTful API server.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，`"$ref"` 引用出现的地方通常使用形式为 `#/components/schemas/...` 的路径。该路径是一个本地 URL，省略了主机名信息。这可以被替换为一个指向
    RESTful API 服务器上模式详细信息的完整 URL。
- en: We might use `http://localhost:8080/api/schemas/...` to refer to the various
    schema files stored as separate JSON documents. Each individual schema definition
    would have a distinct URI, permitting ready access to only the relevant schema,
    and ignoring other aspects of the OpenAPI specification.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能使用 `http://localhost:8080/api/schemas/...` 来引用存储为单独 JSON 文档的各个模式文件。每个单独的模式定义将有一个独特的
    URI，允许仅访问相关的模式，并忽略 OpenAPI 规范的其他方面。
- en: This decomposes the OpenAPI specification into the overall specification for
    the service and separate specifications for a schema that describes downloadable
    datasets. It also requires adding a path to the RESTful API service to properly
    download the schema in addition to downloading the overall OpenAPI specification.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这将 OpenAPI 规范分解为服务的整体规范以及描述可下载数据集的单独规范。它还要求添加一个路径到 RESTful API 服务，以便正确下载整体 OpenAPI
    规范。
- en: This leads to a few extra acceptance test cases to extract the schema as well
    as the overall OpenAPI specification.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致需要一些额外的接受测试用例来提取模式以及整体 OpenAPI 规范。
- en: 12.5.3 Use Celery instead of concurrent.futures
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.3 使用 Celery 而不是 concurrent.futures
- en: The suggestion in [*Overall approach*](#x1-2800002) is to use the `concurrent.futures`
    module to handle the long-running data acquisition and cleaning processes. The
    API requests that initiate processing create a `Future` object that reflects the
    state of a separate subprocess doing the actual work. The RESTful API is free
    to respond to additional requests while the work is being completed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*整体方法*](#x1-2800002) 中的建议是使用 `concurrent.futures` 模块来处理长时间运行的数据获取和清理过程。启动处理过程的
    API 请求创建一个反映实际工作子进程状态的 `Future` 对象。在任务完成期间，RESTful API 可以自由响应额外的请求。
- en: Another popular package for implementing this kind of background processing
    is `celery`. See [https://docs.celeryq.dev/en/stable/getting-started/introduction.html](https://docs.celeryq.dev/en/stable/getting-started/introduction.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个用于实现此类后台处理的流行包是 `celery`。请参阅 [https://docs.celeryq.dev/en/stable/getting-started/introduction.html](https://docs.celeryq.dev/en/stable/getting-started/introduction.html)。
- en: This is a bit more complicated than using the `concurrent.futures` module. It
    also scales elegantly to allow a large number of separate computers to comprise
    the pool of available workers. This can permit very large processing loads to
    be controlled by a relatively small RESTful API application.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这比使用 `concurrent.futures` 模块要复杂一些。它还优雅地扩展，允许大量独立的计算机组成可用工作池。这可以允许由相对较小的 RESTful
    API 应用程序控制非常大的处理负载。
- en: 'Using Celery requires creating tasks, using the `@task` decorator. It also
    requires starting the worker pool separately. This means the overall RESTful API
    now has two steps to get started:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Celery 需要创建任务，使用 `@task` 装饰器。它还需要单独启动工作池。这意味着整个 RESTful API 现在有两个步骤才能开始：
- en: The celery worker pool must be running.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 芹菜工作池必须正在运行。
- en: The RESTful API can then start. Once it’s running, it can delegate work to workers
    in the pool.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后 RESTful API 可以启动。一旦运行，它可以委托工作给池中的工作进程。
- en: For very large workloads, where the worker pool is spread across multiple computers,
    use of Celery’s sophisticated management tools are required to be sure the pools
    are starting and stopping appropriately.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常大的工作负载，当工作池分布在多台计算机上时，需要使用 Celery 的复杂管理工具来确保池能够适当地启动和停止。
- en: The core work of submitting work to the worker pool changes from `pool.submit()`
    to `celery_app.delay()`. This is a small programming change that permits using
    a more sophisticated and scalable worker pool.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作提交给工作池的核心工作从 `pool.submit()` 更改为 `celery_app.delay()`。这是一个小的编程更改，允许使用更复杂和可扩展的工作池。
- en: There aren’t any acceptance test changes for this. The features are identical.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此版本没有接受测试的更改。功能是相同的。
- en: 'The fixture definition required to start the RESTful API will be more complicated:
    it will have to start the **Celery** pool of workers before starting the RESTful
    API. It will also need to shut down both services.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 RESTful API 所需的固定定义将更加复杂：它必须在启动 RESTful API 之前启动 **Celery** 工作池。它还需要关闭这两个服务。
- en: 12.5.4 Call external processing directly instead of running a subprocess
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5.4 直接调用外部处理而不是运行子进程
- en: In [*Overall approach*](#x1-2800002), we suggested the work should be done by
    an `acquire_series()` function. This function would be evaluated by the `POOL.submit()`
    function. This would delegate the work to a worker, and return a `Future` object
    to track the state of completion.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*整体方法*](#x1-2800002) 中，我们建议工作应由 `acquire_series()` 函数完成。此函数将由 `POOL.submit()`
    函数评估。这将委托工作给工作进程，并返回一个 `Future` 对象以跟踪完成状态。
- en: In that section, we suggested the `acquire_series()` function could use `subprocess.run()`
    to execute the various components of the processing pipeline. It could run the
    `src/acquire.py` application, and then run the `src/clean.py` application, using
    the `subprocess` module.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个部分，我们建议 `acquire_series()` 函数可以使用 `subprocess.run()` 来执行处理管道的各个组件。它可以运行 `src/acquire.py`
    应用程序，然后运行 `src/clean.py` 应用程序，使用 `subprocess` 模块。
- en: This isn’t the only way it could work. The alternative is to import these application
    modules, and evaluate their `main()` functions directly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是唯一可行的方法。另一种方法是导入这些应用程序模块，并直接评估它们的 `main()` 函数。
- en: This means replacing the `subprocess.run()` function with the `acquire.main()`
    and `clean.main()` functions. This avoids a tiny overhead in Linux. It can be
    a conceptual simplification to see how the `acquire_series()` function creates
    the data using other Python modules.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着用 `acquire.main()` 和 `clean.main()` 函数替换 `subprocess.run()` 函数。这可以避免在 Linux
    上的微小开销。从概念上简化来看，我们可以看到 `acquire_series()` 函数是如何使用其他 Python 模块来创建数据的。
- en: This involves no changes to the acceptance test cases. It does involve some
    changes to the unit test cases. When using `subprocess.run()`, the unit test must
    monkey-patch the `subprocess` module with a mock that captures the argument values
    and returns a useful result. When replacing this processing with the `acquire.main()`
    and `clean.main()` functions, these two modules must be monkey patched with mocks
    that capture the argument values and return useful results.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不涉及对验收测试用例的任何更改。但它确实涉及到单元测试用例的一些更改。当使用 `subprocess.run()` 时，单元测试必须使用一个捕获参数值并返回有用结果的模拟来
    monkey-patch `subprocess` 模块。当用 `acquire.main()` 和 `clean.main()` 函数替换此处理过程时，这两个模块必须使用捕获参数值并返回有用结果的模拟来
    monkey-patch。
