- en: Function and Scope of Variable
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数和变量的作用域
- en: In the previous chapter, we learned about control statements and loops. We learned
    about various types of control statements such as `if` statement, `if...else`
    statement, and `if...elif...else` statement. Next, we saw two main categories
    of loops, that is, definite and infinite loops. Under definite loops, we saw the
    working of for loop and we learned about two utility functions that are provided
    by Python, which can generate a list on-the-fly. They are `range()` and `xrange()`.
    Next, we learned about infinite loops, where we saw the working principle of the
    while loop. Then, we learned about nested loops along with break and continue
    statements. In this chapter, we will be covering functions, functions with arguments,
    functions with arguments and return value, functions with default arguments, functions
    with variable length arguments, key-value pairs as variable length arguments to
    the function, and finally we will be discussing on the scope of the variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了控制语句和循环。我们学习了各种类型的控制语句，例如`if`语句、`if...else`语句和`if...elif...else`语句。接下来，我们看到了两种主要的循环类别，即确定性和无限循环。在确定性循环下，我们看到了for循环的工作原理，并学习了Python提供的两个实用函数，它们可以即时生成列表。它们是`range()`和`xrange()`。接下来，我们学习了无限循环，其中我们看到了while循环的工作原理。然后，我们学习了嵌套循环以及break和continue语句。在本章中，我们将介绍函数、带参数的函数、带参数和返回值的函数、带默认参数的函数、带可变长度参数的函数、将键值对作为函数的可变长度参数，最后我们将讨论变量的作用域。
- en: Functions
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: The big question arising in the minds of the beginner would be, "What are functions?"
    and "Why are they necessary in any programming language?"
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者心中浮现的大问题可能是，“什么是函数？”以及“为什么它们在任何编程语言中都是必要的？”
- en: 'Functions are nothing but a small programming unit inside a big programming
    construct that generates a designated output. Let''s try to understand with real-world
    scenario. It''s difficult to think of a scenario where someone may not have access
    to television. What do you observe inside a normal television? On broader classification,
    considering a normal viewer, it has three functions:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 函数不过是一个大编程结构内部的小编程单元，它产生一个指定的输出。让我们通过现实世界的场景来尝试理解。很难想象一个没有电视的场景。你在普通电视里观察到什么？从更广泛的分类来看，考虑到普通观众，它有三个功能：
- en: It has a display unit
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个显示单元
- en: It has a volume control unit
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有一个音量控制单元
- en: It has a channel tuning setup embedded inside the electronic circuitry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在电子电路中嵌入了一个频道调谐设置
- en: Although modern smart televisions have more complex functions, we will restrict
    our example to three main functions explained.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然现代智能电视有更复杂的功能，但我们将我们的例子限制在三个主要功能的解释上。
- en: The display unit works differently from the other two functional units and its
    sole purpose is to put up a display to the user. Similarly, the volume control
    unit has its sole purpose to fine-tune the volume of the television, and, finally,
    channel tuning has the main function to have different channels loaded in the
    memory. Functions in programming language also work in a similar fashion, each
    has its own purpose defined. Some examples can be `calculateMonthSalary()`, `calculateTotalBill()`,
    and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 显示单元与其他两个功能单元的工作方式不同，它的唯一目的是向用户显示。同样，音量控制单元的唯一目的是精细调整电视的音量，最后，频道调谐的主要功能是在内存中加载不同的频道。编程语言中的函数也以类似的方式工作，每个都有自己的定义目的。一些例子可以是`calculateMonthSalary()`、`calculateTotalBill()`等等。
- en: A method is an identical function in terms of name except that it is called
    on object and passed on the data, whereas a function is called directly by name
    and passed on the data to operate. A method is something that belongs to an object
    or in object-oriented programming class which contains the method. In this chapter,
    we will study more about functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 方法在名称上与函数相同，但它是通过对象调用的，并传递数据，而函数则是直接通过名称调用并传递数据以操作。方法是属于对象或面向对象编程类中包含方法的某个东西。在本章中，我们将更深入地研究函数。
- en: Categories of functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数的分类
- en: 'Functions in any programming language can fall into two broad categories:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的函数可以分为两大类：
- en: Built-in functions
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置功能
- en: User-defined functions
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户定义的函数
- en: Built-in functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置函数
- en: They are predefined by programming languages and each serves a specific purpose.
    While some built-in functions cannot be customized, some can be customized as
    per the programming guidelines laid down by a specific programming languages.
    The Python language also comes with a set of built-in functions such as `len()` and `cmp()`.
    You can get details about built-in functions from the Python documentation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是由编程语言预定义的，每个都有特定的用途。虽然一些内置函数不能自定义，但一些可以根据特定编程语言制定的编程指南进行自定义。Python语言也附带了一套内置函数，如`len()`和`cmp()`。您可以从Python文档中获取有关内置函数的详细信息。
- en: The Python documentation can be found at [https://docs.python.org](https://docs.python.org).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python文档可以在[https://docs.python.org](https://docs.python.org)找到。
- en: User-defined functions
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户定义的函数
- en: They are defined by users as per their programming requirement. Functions can
    be created or can exist in various forms in any programming language. In this
    section, we will learn in depth about various ways in which we can create a function.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是根据用户的编程需求定义的。函数可以在任何编程语言中以各种形式创建或存在。在本节中，我们将深入了解我们可以创建函数的各种方法。
- en: Function definition
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数定义
- en: 'There are some simple rules to define a function in Python. They are as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中定义一个函数有一些简单的规则。它们如下：
- en: Use the `def` keyword followed by function name with parentheses `()`
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`def`关键字后跟带有括号`()`的函数名
- en: Any argument to the function must be placed within these parentheses `()`
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的任何参数都必须放置在这些括号`()`内
- en: The code block must start with a colon `:`
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码块必须以冒号`:`开头
- en: The code within the function must be indented
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数内的代码必须缩进
- en: 'The syntax for this is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个语法的语法如下：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is the syntax of any function definition in Python. If there are any arguments,
    they are written inside the parentheses and if the function has any return value
    that would be the last statement in any function code block or function body.
    The function code block or function body starts immediately after colon (`:`)
    and ends with return value if there is any return value. In Python, the body of
    any code block which starts after a colon (`:`) must be indented using spaces
    (preferably) or else with a tab. This eliminates indentation errors, which the
    interpreter might throw while running the program.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Python中任何函数定义的语法。如果有任何参数，它们将被写入括号内，如果函数有任何返回值，那么它将是任何函数代码块或函数体中的最后一个语句。函数代码块或函数体在冒号（`:`）之后立即开始，如果有返回值，则结束于返回值。在Python中，冒号（`:`）之后开始的任何代码块的主体必须使用空格（最好是）或制表符缩进。这消除了缩进错误，解释器在运行程序时可能会抛出这些错误。
- en: 'More on indentation is available at:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于缩进的信息可以在以下位置找到：
- en: '[https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces)。'
- en: Next, we will see how to call a function in a program.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在程序中调用一个函数。
- en: Calling a function
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用函数
- en: You might be wondering what is *calling a function*. Now, let's suppose you
    wrote some business logic about washing instructions to be embedded inside an
    automatic washing machine. Let's say you want to time sequence for rinsing of
    clothes immediately after wash. In programming language, you don't want to get
    lost writing a big chunk of program, so, in order to make things easy, you write
    your business logic inside a function. This function has to be called when you
    want that particular sequence to be timed right after the washing sequence finishes.
    There you pass the execution of instruction to the function written for timing
    of sequence. This is achieved by calling the function at an appropriate time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道什么是**调用函数**。现在，假设你编写了一些关于洗涤说明的业务逻辑，要嵌入到自动洗衣机中。假设你想要在洗涤后立即进行漂洗的时间序列。在编程语言中，你不想在编写一大块程序时迷失方向，所以，为了使事情变得简单，你将你的业务逻辑写入一个函数中。这个函数必须在你想在洗涤序列完成后立即计时那个特定序列时被调用。在那里，你将执行指令传递给用于计时序列的函数。这是通过在适当的时间调用函数来实现的。
- en: 'Syntax block of code is:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的语法块如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'A function can be called within a programming construct similar to the built-in
    function. Use the name of the function followed by a set of parentheses. A function
    can be called any number of times within the same programming file, or another,
    or can be called within another function. Yes you got it right: a function can
    call another function. Let''s learn from an example:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以在类似于内置函数的编程结构中调用。使用函数名后跟一组括号。一个函数可以在同一编程文件、另一个文件或另一个函数中多次调用。是的，你猜对了：一个函数可以调用另一个函数。让我们通过一个例子来学习：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, we define the `helloWorld()` function and we give a body, which has a
    comment and a print statement. Finally, we simply call the function by merely
    typing the name of the function followed by parentheses. When the program is run,
    we get the output as shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了 `helloWorld()` 函数，并给出了一个包含注释和打印语句的主体。最后，我们只需通过键入函数名后跟括号来调用该函数。当程序运行时，我们将得到如下所示的输出：
- en: '![](img/image1-2.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图片1-2](img/image1-2.jpg)'
- en: There are various ways in which a function can be written or exists in any programming
    language. We will discuss various ways in which a function can be formed in Python.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何编程语言中，函数可以通过多种方式被编写或存在。我们将讨论在Python中构建函数的各种方法。
- en: Function with arguments
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有参数的函数
- en: 'So far we saw a function which had no arguments, now we will learn about functions
    with arguments. A function can contain any number of arguments depending on the
    business requirement. Let''s try to understand with an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了一个没有参数的函数，现在我们将学习有关带有参数的函数。一个函数可以包含任何数量的参数，这取决于业务需求。让我们通过一个例子来尝试理解：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, the `func` function accepts one argument which has
    a data type string. We create a variable `str` with a certain string statement
    assigned and then we call the `func` function and thereby pass the value of `str`.
    Finally, the output will look something like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`func` 函数接受一个具有字符串数据类型的参数。我们创建一个变量 `str` 并将其分配给一个特定的字符串语句，然后调用 `func`
    函数并传递 `str` 的值。最终，输出将类似于以下内容：
- en: '![](img/image2-4.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图片2-4](img/image2-4.jpg)'
- en: In the preceding example, what will happen if we do not pass any argument to
    the function?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们不向函数传递任何参数会发生什么？
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It will simply throw a `TypeError` as shown in the following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它将简单地抛出一个 `TypeError`，如下面的截图所示：
- en: '![](img/image3-4.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片3-4](img/image3-4.jpg)'
- en: Hence, it becomes mandatory to pass an argument to the function during function
    calling after the function has been defined to accept arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在定义了接受参数的函数之后，在函数调用时传递参数变得强制性的。
- en: Function with an argument and return type
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有参数和返回类型的函数
- en: 'Sometimes, it may be necessary to return any specific datatype or value from
    a function which takes any arbitrary number of arguments. Let''s evaluate this
    scenario with an example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，可能需要从接受任意数量参数的函数中返回任何特定的数据类型或值。让我们通过一个示例来评估这个场景：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here, we define the function, which accepts two arguments and the body evaluates
    their sum with return type as value of the sum, which is denoted by the `return
    c` statement. We then call the function in the print statement and pass the value
    of variable `x` and variable `y`. This will give us the output as shown next:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个函数，它接受两个参数，其主体计算它们的和，返回类型为和的值，这由 `return c` 语句表示。然后我们在打印语句中调用该函数，并传递变量
    `x` 和变量 `y` 的值。这将给出下一个显示的输出：
- en: '![](img/image4-3.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片4-3](img/image4-3.jpg)'
- en: Function with default argument
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有默认参数的函数
- en: 'Sometimes you will be presented with a condition where there has to be some
    value assigned to the argument, which will be called as the default argument.
    Let''s try to understand with real-life scenario. Most of us fill in certain forms
    for job application online. Now, in the form, there is a section for gender selection.
    In this case, programmers have inserted a default value as female. By default
    your sex will be set to female if you do not specifically change this value. Same
    is the case with the function with default arguments. Let''s try to understand
    this with a small code example:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能会遇到一个条件，其中必须为参数分配某个值，这个值被称为默认参数。让我们通过一个现实生活中的场景来尝试理解。我们中的大多数人都会在线填写某些表格以申请工作。现在，在表格中有一个性别选择的选项。在这种情况下，程序员插入了一个默认值“女性”。默认情况下，如果你的性别没有特别更改此值，则你的性别将被设置为女性。具有默认参数的函数也是同样的情况。让我们通过一个小代码示例来理解这一点：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, the `info` function takes two arguments `name` and `age`. The `age` is
    the argument with the default value `50`. In this case, during the calling of
    the `info` function, if `age` is not provided, then the function will set the
    value of `age` as `50`. We have called the `info` function twice. In the first
    call, we pass the value of `"John"` and `age` as `28`, while in the second call,
    we just pass the value of `name` as `"James"`. We will get output as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`info` 函数接受两个参数 `name` 和 `age`。`age` 是具有默认值 `50` 的参数。在这种情况下，在调用 `info` 函数时，如果未提供
    `age`，则函数将 `age` 的值设置为 `50`。我们两次调用了 `info` 函数。在第一次调用中，我们传递了 `"John"` 和 `age` 的值为
    `28`，而在第二次调用中，我们只传递了 `name` 的值 `"James"`。我们将得到如下所示的输出：
- en: '![](img/image5-4.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image5-4.jpg)'
- en: Function with variable length argument
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可变长度参数的函数
- en: 'There might be a scenario where you need to pass more arguments than specified
    during the function definition. In this case, variable length arguments can be
    passed:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在一种情况，你需要传递比函数定义中指定的更多参数。在这种情况下，可以传递可变长度参数：
- en: '**Syntax**'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**'
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, `arg` means normal argument which is passed to the function. The `*var`
    refers to the variable length argument. This is will be more clear through the
    example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`arg` 表示传递给函数的正常参数。`*var` 指的是可变长度参数。这将通过以下示例变得更加清晰：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case, we define a function which takes two arguments, where the second
    argument is the variable length argument. When we call the function for the first
    time, we pass only `60` as the value to the argument and the function takes it
    as the first argument. During our second call to the function, we pass five numbers,
    so the function takes them as variable length argument. Depending on the nature
    of arguments passed, the function either considers the first argument or the variable
    length argument. Finally, we could see a different output based on our passing
    of different values as shown here:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个函数，它接受两个参数，其中第二个参数是可变长度参数。当我们第一次调用该函数时，我们只传递 `60` 作为参数的值，函数将其作为第一个参数。在我们第二次调用该函数时，我们传递了五个数字，所以函数将它们作为可变长度参数。根据传递的参数的性质，函数要么考虑第一个参数，要么考虑可变长度参数。最终，我们可以看到基于我们传递的不同值的不同输出，如下所示：
- en: '![](img/image6-3.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image6-3.jpg)'
- en: Key-value pair as variable length argument
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键值对作为可变长度参数
- en: 'Under certain circumstances, there might be a situation, where the key-value
    pair needs to be passed as the variable length argument to the function. Let''s
    take one example here. In the given example, the key-value pairs are passed as
    variable length arguments:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要将键值对作为可变长度参数传递给函数。以下是一个例子。在给定的例子中，键值对作为可变长度参数传递：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Using a for loop we print out each key-value pair that is passed to the function.
    On the first call, we pass only few key-value pairs, while in the second call
    to the function, we pass a bit more key-value pairs and we get the output as shown
    here:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 for 循环，我们打印出传递给函数的每个键值对。在第一次调用时，我们只传递少量键值对，而在第二次调用函数时，我们传递更多的键值对，输出结果如下所示：
- en: '![](img/image7-3.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image7-3.jpg)'
- en: Pass by reference versus pass by value
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按引用传递与按值传递
- en: '**Pass by reference** is the term used in some programming languages, where
    values to the argument of the function are passed by reference, that is, the address
    of the variable is passed and then the operation is done on the value stored at
    these addresses.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**按引用传递**是在某些编程语言中使用的术语，其中函数参数的值是通过引用传递的，即传递变量的地址，然后在这些地址存储的值上进行操作。'
- en: '**Pass by value** means that the value is directly passed as the value to the
    argument of the function. In this case, the operation is done on the value and
    then the value is stored at the address.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**按值传递**意味着值直接作为函数参数的值传递。在这种情况下，操作是在值上进行的，然后该值存储在地址中。'
- en: 'In Python arguments, the values are passed by reference. During the function
    call, the called function uses the value stored at the address passed to it and
    any changes to it also affect the source variable:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 参数中，值是通过引用传递的。在函数调用期间，被调用的函数使用传递给它的地址存储的值，并且对它的任何更改也会影响源变量：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, in the function definition, we pass the list to the `pass_ref` function
    and then we extend the list to add two more numbers to the list and then print
    its value. The list extends inside the function, but the change is also reflected
    back in the calling function. We finally get the output by printing out different
    representations of the list:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，我们将列表传递给 `pass_ref` 函数，然后我们扩展列表以添加两个更多数字到列表中，然后打印其值。列表在函数内部扩展，但更改也会反映在调用函数中。我们最终通过打印列表的不同表示来获取输出：
- en: '![](img/image8-2.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image8-2.jpg)'
- en: 'Let''s look at another scenario:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个场景：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding example might make you think it is called by value, as the change
    happening inside the Python function does not get reflected back in the calling
    function. It is still a pass by reference, as, in this situation inside the function,
    we made new assignment, that is, `a= a+4`. Although you might think that `a =
    a + 4` is changing the number stored in `a`, but it is actually reassigning a
    to point to a new value:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子可能会让你认为它是按值传递的，因为 Python 函数内部发生的更改不会反映在调用函数中。但实际上，它仍然是通过引用传递的，因为在函数内部这种情况中，我们进行了新的赋值，即
    `a = a + 4`。尽管你可能认为 `a = a + 4` 正在改变存储在 `a` 中的数字，但实际上它是在重新分配 a 指向一个新的值：
- en: '![](img/image9-3.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image9-3.jpg)'
- en: Scope of variables
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量的作用域
- en: 'This could be an intriguing topic for you to understand for the first time.
    But it is actually a very simple topic. Let''s try to understand this with a real-life
    situation. You might be aware of two types of airlines: domestic and international
    carriers. The scope of domestic carriers will be restricted to a particular country''s
    operation only, while an international carrier has the scope to operate on an
    international border. Same is the case with variables. The scope on the broader
    aspect defines the access level for specific variable. There are two basic scopes
    of variables in Python:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个对你来说第一次理解的有趣话题。但实际上，这是一个非常简单的话题。让我们尝试通过一个现实生活中的情况来理解这一点。你可能知道两种类型的航空公司：国内和国际运营商。国内运营商的范围将仅限于特定国家的运营，而国际运营商则有权在国际边界上运营。变量的范围也是如此。从更广泛的角度来看，变量的范围定义了特定变量的访问级别。Python
    中变量的基本作用域有两种：
- en: Local variables
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 局部变量
- en: Global variables
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局变量
- en: 'A local variable is defined inside the Python function. Local variables are
    only accessible within their local scope. A global variable is defined outside
    the Python function. Global variables are only accessible throughout the program:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 函数内部定义的局部变量。局部变量仅在它们的局部作用域内可访问。全局变量是在 Python 函数外部定义的。全局变量在整个程序中都可访问：
- en: '![](img/image11-4.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image11-4.jpg)'
- en: Here, the variable `k` with value `4` is an example of a global variable, while
    the `list1` variable is an example of a local variable. The area marked in green
    inside the `main()` function shows the scope of the `list1` variable, while the
    area marked in yellow shows the scope within the `add()` function, and this scope
    is valid until the end of the `add()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，值为 `4` 的变量 `k` 是一个全局变量的例子，而 `list1` 变量是一个局部变量的例子。在 `main()` 函数内部标记为绿色的区域显示了
    `list1` 变量的作用域，而标记为黄色的区域显示了在 `add()` 函数内的作用域，这个作用域一直有效到 `add()` 函数的末尾。
- en: 'The succeeding example will explain both these types of variables:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的例子将解释这两种类型的变量：
- en: '[PRE12]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Variable a is a global variable; its value remains the same outside the function
    compared to the value inside the function, where it is acting as a local variable:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 a 是一个全局变量；与作为局部变量在函数内部的作用相比，其值在函数外部保持不变：
- en: '![](img/image10-3.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image10-3.jpg)'
- en: 'Let''s analyze another situation:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析另一种情况：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here we have declared variable a whose scope is local to the `func()` function.
    As we try to access the local variable, the interpreter does not support us on
    this and will tell you something as shown next:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明了变量 a，其作用域仅限于 `func()` 函数。当我们尝试访问局部变量时，解释器不会支持我们，并会告诉你如下所示：
- en: '![](img/image11-3.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image11-3.jpg)'
- en: 'But this situation can be overcome using the `global` keyword, as we will use
    in our next example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种情况可以通过使用 `global` 关键字来克服，正如我们将在下一个例子中所做的那样：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this case, we declare the `k` variable as global using the `global` keyword
    inside the function. We can now access it from anywhere. The `global` keyword
    tells the interpreter that the variable is global and it should stop searching
    across all the functions or local scopes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用函数内部的`global`关键字将`k`变量声明为全局变量。现在我们可以从任何地方访问它。`global`关键字告诉解释器该变量是全局的，它应该停止在所有函数或局部作用域中搜索。
- en: '![](img/image12-2.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图12-2](img/image12-2.jpg)'
- en: Memory management
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存管理
- en: 'This is quite a fascinating topic and is also a big pain for any programmer
    who has to deal with memory-related issues such as memory leakage issues. However,
    since it is a big topic which needs to be covered at the intermediate stage, we
    will try to explain the very basics of the topic. In the earlier days, memory
    management used to be handled manually by all the programmers. Who could better
    understand manual memory management than C/C++ language programmers. New and modern
    programming languages such as Java and others are coming loaded with more advanced
    memory management mechanism, so programmers have to worry less in this area as
    every issue is taken care by the language garbage collection facility. We have
    already covered what is local scope and what is global scope are. Local scope
    of the function, contains parameters and variables. The complete local scope must
    be stored somewhere in the RAM of the computer. Language divides the RAM into
    two parts called run-time stack and the heap. Memory is divided into two parts
    in any programming language:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常迷人的主题，也是任何必须处理与内存相关问题的程序员的一大痛点，例如内存泄漏问题。然而，由于这是一个需要在中级阶段涵盖的大主题，我们将尝试解释这个主题的非常基础的部分。在早期，内存管理通常由所有程序员手动处理。谁比C/C++语言程序员更了解手动内存管理呢？新的和现代的编程语言，如Java和其他语言，都配备了更先进的内存管理机制，因此程序员在这个领域不必担心太多，因为每个问题都由语言的垃圾回收功能处理。我们已经涵盖了什么是局部作用域和什么是全局作用域。函数的局部作用域包含参数和变量。完整的局部作用域必须存储在计算机的RAM中。语言将RAM分为两部分，称为运行时栈和堆。在任何编程语言中，内存都分为两部分：
- en: Stack or run-time stack
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈或运行时栈
- en: Heap
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 堆
- en: 'The heap is a specific area of RAM where all values (objects) are stored. The
    run-time stack never contains the object. The run-time stack store only references
    pointing toward the values stored in the heap. Let''s try to understand with an
    example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 堆是RAM中存储所有值（对象）的特定区域。运行时栈永远不会包含对象。运行时栈只存储指向存储在堆中值的引用。让我们通过一个例子来尝试理解：
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: During execution of lines 5, 6, and 7 of the code, the run-time stack looks
    as shown in the next figure. There are three activation records present on run-time
    stack. The interpreter first puts the **module Activation Record**. While executing
    the module, the interpreter goes from top to bottom and places the variable definition
    of the module scope into the activation record of the module. The activation record
    of the module consists of the reference **k** to the value **4**.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行代码的第5、6和7行期间，运行时栈看起来如图所示。运行时栈上有三个活动记录。解释器首先放置**模块活动记录**。在执行模块时，解释器从上到下移动，并将模块作用域的变量定义放入模块的活动记录中。模块的活动记录由指向值**4**的引用**k**组成。
- en: '![](img/Stackheap.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![堆栈和堆](img/Stackheap.jpg)'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we learned about functions and how to define a function. Then
    we discussed various types of functions such as built-in and user-defined functions.
    We saw various examples of user-defined functions, where we explained functions
    with no arguments and no return type, functions with arguments, functions with
    arguments and return type, functions with default arguments, and functions with
    variable length arguments. We also learned about key-value pairs being passed
    as a variable length argument to the function. We came across the scope of the
    variable and, finally, we examined the basic concepts of memory management where
    we learned about two types of memory, namely, stack and heap.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了函数以及如何定义一个函数。然后我们讨论了各种类型的函数，例如内置函数和用户定义函数。我们看到了用户定义函数的各种示例，其中我们解释了无参数和无返回类型的函数、有参数的函数、有参数和返回类型的函数、有默认参数的函数以及有可变长度参数的函数。我们还学习了将键值对作为可变长度参数传递给函数。我们遇到了变量的作用域，最后，我们考察了内存管理的基本概念，我们学习了两种类型的内存，即栈和堆。
- en: 'In the next chapter we will learn about quite an interesting topic: collections.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习一个非常有趣的主题：集合。
