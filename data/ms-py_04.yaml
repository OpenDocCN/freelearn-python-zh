- en: Chapter 4. Functional Programming – Readability Versus Brevity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。函数式编程-可读性与简洁性
- en: Python is one of the few (or at least the earliest) nonfunctional languages
    to incorporate functional features. While Guido van Rossum has tried to remove
    some of them a few times, they have become ingrained in the Python community,
    and list comprehensions (`dict` and `set` comprehensions soon to follow) are widely
    used in all sorts of code. The most important thing about code shouldn't be how
    cool your `reduce` statement is or how you can fit the entire function in a single
    line with an incomprehensible list comprehension. Readability counts (once again,
    `PEP20`)!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python是少数（或至少是最早的）不是函数式语言的语言之一，它包含了函数式特性。虽然Guido van Rossum曾试图多次删除其中一些特性，但它们已经深入到Python社区中，`list`推导（`dict`和`set`推导很快也会跟进）在各种代码中被广泛使用。代码最重要的事情不应该是您的`reduce`语句有多酷，或者您如何能够用一个难以理解的列表推导将整个函数放入一行。可读性很重要（再次，`PEP20`）！
- en: This chapter will show you some of the cool tricks that functional programming
    in Python gives you, and it will explain some of the limitations of Python's implementation.
    While we will try to steer clear of lambda calculus (λ-calculus) as much as possible,
    the **Y combinator** will be discussed briefly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您展示Python函数式编程提供的一些很酷的技巧，并解释Python实现的一些限制。虽然我们会尽量避免使用λ演算（λ-演算），但会简要讨论**Y组合子**。
- en: The last few paragraphs will list (and explain) the usage of the `functools`
    and `itertools` libraries. If you are familiar with these libraries, feel free
    to skip them, but note that some of these will be used heavily in the later chapters
    about decorators ([Chapter 5](ch05.html "Chapter 5. Decorators – Enabling Code
    Reuse by Decorating"), *Decorators – Enabling Code Reuse by Decorating*), generators
    ([Chapter 6](ch06.html "Chapter 6. Generators and Coroutines – Infinity, One Step
    at a Time"), *Generators and Coroutines – Infinity, One Step at a Time*), and
    performance ([Chapter 12](ch12.html "Chapter 12. Performance – Tracking and Reducing
    Your Memory and CPU Usage"), *Performance – Tracking and Reducing Your Memory
    and CPU Usage*).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后几段将列出（并解释）`functools`和`itertools`库的用法。如果您熟悉这些库，请随意跳过它们，但请注意，这些库中的一些将在后面关于装饰器（[第5章](ch05.html
    "第5章。装饰器-通过装饰实现代码重用")，*装饰器-通过装饰实现代码重用*）、生成器（[第6章](ch06.html "第6章。生成器和协程-无限，一步一步")，*生成器和协程-无限，一步一步*）和性能（[第12章](ch12.html
    "第12章。性能-跟踪和减少内存和CPU使用")，*性能-跟踪和减少内存和CPU使用*）的章节中大量使用。
- en: 'These are the topics covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: The theory behind functional programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程的理论
- en: '`list` comprehensions'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list`推导'
- en: '`dict` comprehensions'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dict`推导'
- en: '`set` comprehensions'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set`推导'
- en: '`lambda` functions'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lambda`函数'
- en: '`functools` (`partial`, and `reduce`)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`functools`（`partial`和`reduce`）'
- en: '`itertools` (`accumulate`, `chain`, `dropwhile`, `starmap`, and so on)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`itertools`（`accumulate`、`chain`、`dropwhile`、`starmap`等）'
- en: Functional programming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: Functional programming is a paradigm that originates from the lambda calculus.
    Without diving too much into the lambda calculus (λ-calculus), this roughly means
    that computation is performed through the use of mathematical functions, which
    avoids mutable data and changing state of surroundings. The idea of a strictly
    functional language is that all function outputs are dependent only on the input
    and not on any external state. Since Python is not strictly a programming language,
    this doesn't necessarily hold true, but it is a good idea to adhere to this paradigm
    as mixing these can cause unforeseen bugs as discussed in [Chapter 2](ch02.html
    "Chapter 2. Pythonic Syntax, Common Pitfalls, and Style Guide"), *Pythonic Syntax,
    Common Pitfalls, and Style Guide*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程是源自λ演算的一种范式。不深入λ演算（λ-演算），这大致意味着计算是通过使用数学函数来执行的，这避免了可变数据和改变周围状态的情况。严格功能语言的想法是所有函数输出仅依赖于输入，而不依赖于任何外部状态。由于Python并不严格是一种函数式编程语言，这并不一定成立，但遵循这种范式是一个好主意，因为混合这些可能会导致意想不到的错误，正如[第2章](ch02.html
    "第2章。Pythonic Syntax, Common Pitfalls, and Style Guide")中讨论的那样，*Pythonic Syntax,
    Common Pitfalls, and Style Guide*。
- en: Even outside of functional programming, this is a good idea. Keeping functions
    purely functional (relying only on the given input) makes code clearer, easier
    to understand, and better to test as there are less dependencies. Well-known examples
    can be found within the `math` module. These functions (`sin`, `cos`, `pow`, `sqrt`,
    and so on) have an input and an output that is strictly dependent on the input.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在函数式编程之外，这也是一个好主意。保持函数纯粹功能（仅依赖于给定输入）使代码更清晰，更易理解，并且更易于测试，因为依赖性更少。`math`模块中可以找到一些著名的例子。这些函数（`sin`、`cos`、`pow`、`sqrt`等）具有严格依赖于输入的输入和输出。
- en: list comprehensions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列表推导
- en: The Python `list` comprehensions are a very easy way to apply a function or
    filter to a list of items. List comprehensions can be very useful if used correctly
    but very unreadable if you're not careful.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`list`推导是将函数或过滤器应用于一系列项目的非常简单的方法。如果使用正确，`list`推导可以非常有用，但如果不小心使用，可能会非常难以阅读。
- en: 'Let''s dive right into a few examples. The basic premise of a `list` comprehension
    looks like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们立即看几个例子。`list`推导的基本前提看起来是这样的：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can easily expand this with a filter:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地扩展这个过滤器：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The syntax is pretty close to regular Python for loops, but the `if` statement
    and automatic storing of results makes it quite useful for some cases. The regular
    Python equivalent is not much longer, however:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 语法与常规Python for循环非常接近，但`if`语句和自动存储结果使其在某些情况下非常有用。常规的Python等价物并不长，但是：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Care must be taken though; because of the special list comprehension structure,
    some types of operations are not as obvious as you might expect. This time, we
    are looking for random numbers greater than `0.5`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 但必须小心，由于特殊的列表推导结构，某些类型的操作并不像你期望的那样明显。这一次，我们正在寻找大于`0.5`的随机数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See that last number? It's actually less than `0.5`. This happens because the
    first and the last random calls are actually separate calls and return different
    results.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 看到最后一个数字了吗？它实际上小于`0.5`。这是因为第一个和最后一个随机调用实际上是分开的调用，并返回不同的结果。
- en: 'One way to counter this is by creating the list separate from the filter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对抗这种情况的一种方法是通过从过滤器中创建单独的列表：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That obviously works, but it's not all that pretty. So what other options are
    there? Well, there are a few but the readability is a bit questionable, so these
    are not the solutions that I would recommend. It's good to see them at least once,
    however.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显然这样可以工作，但并不是很美观。那么还有什么其他选择呢？嗯，还有一些，但可读性有点值得商榷，所以这些不是我推荐的解决方案。至少看到它们一次也是好的。
- en: 'Here is a `list` comprehension in a list comprehension:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个列表推导中的列表推导：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And here''s one that quickly becomes an incomprehensible `list` comprehension:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个很快变成难以理解的列表推导：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Caution is needed with these options as the double list comprehension actually
    works like a nested `for` loop would, so it quickly generates a lot of results.
    To elaborate on this regard:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意这些选项，因为双重列表推导实际上像嵌套的`for`循环一样工作，因此会快速生成大量结果。在这方面进行详细说明：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This effectively does the following:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上做了以下事情：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'These can be useful for some cases, but I would recommend that you limit their
    usage, as they have a tendency to quickly become unreadable. I would strongly
    advise against using `list` comprehensions within `list` comprehensions for the
    sake of readability. It''s still important to understand what is happening, so
    let''s look at one more example. The following `list` comprehension swaps the
    column and row counts, so a 3 x 4 matrix becomes 4 x 3:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些在某些情况下可能很有用，但我建议限制它们的使用，因为它们很快就会变得难以阅读。我强烈建议不要在列表推导中使用列表推导来提高可读性。重要的是要理解发生了什么，所以让我们看一个更多的例子。以下列表推导交换了列数和行数，因此3
    x 4矩阵变成了4 x 3：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Even with the extra indentation, the `list` comprehension just isn't all that
    readable. With four nested loops, that is expectedly so, of course. There are
    rare cases where nested list comprehensions might be justified, but generally
    I won't recommend their usage.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有额外的缩进，列表推导也并不那么易读。当然，有四个嵌套循环，这是可以预料的。有些情况下，嵌套列表推导可能是合理的，但通常我不建议使用它们。
- en: dict comprehensions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: dict推导
- en: '`dict` comprehensions are very similar to list comprehensions, but the result
    is a `dict` instead. Other than this, the only real difference is that you need
    to return both a key and a value, whereas a `list` comprehension accepts any type
    of value. The following is a basic example:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`推导与列表推导非常相似，但结果是一个`dict`。除此之外，唯一的真正区别是你需要返回一个键和一个值，而列表推导接受任何类型的值。以下是一个基本示例：'
- en: '[PRE10]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the output is a dictionary, the key needs to be hashable for the `dict`
    comprehension to work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出是一个字典，键需要是可散列的才能使`dict`推导工作。
- en: 'The funny thing is that you can mix these two, of course, for even more unreadable
    magic:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是你可以混合这两个，当然，这样会更加难以阅读：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, you need to be careful with these. They can be very useful if used
    correctly, but the output quickly becomes unreadable, even with proper whitespace.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你需要小心处理这些。如果使用正确，它们可能非常有用，但即使有适当的空格，输出也很快变得难以阅读。
- en: set comprehensions
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集合推导
- en: 'Just as you can create a `set` using curly brackets (`{}`), you can also create
    a set using `set` comprehensions. These work in a way similar to `list` comprehensions,
    but the values are unique (and without sort order):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以使用花括号(`{}`)创建一个`set`一样，你也可以使用`set`推导来创建一个集合。它们的工作方式类似于列表推导，但值是唯一的（并且没有排序顺序）：
- en: '[PRE12]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As is the case with the regular set, `set` comprehensions support only hashable
    types.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规集合一样，`set`推导只支持可散列类型。
- en: lambda functions
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lambda函数
- en: 'The `lambda` statement in Python is simply an anonymous function. Due to the
    syntax, it is slightly more limited than regular functions, but a lot can be done
    through it. As always though, readability counts, so generally it is a good idea
    to keep it as simple as possible. One of the more common use cases is the `sort`
    key for the `sorted` function:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的`lambda`语句只是一个匿名函数。由于语法的限制，它比常规函数稍微有限，但可以通过它完成很多事情。但是，可读性很重要，所以通常最好尽可能简单。其中一个更常见的用例是`sorted`函数的`sort`关键字：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While the function could have been written separately or the `__cmp__` method
    of `Spam` could have been overwritten in this case, in many cases, this is an
    easy way to get a quick sort function as you would want it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这种情况下函数可以单独编写，或者`Spam`的`__cmp__`方法可以被重写，但在许多情况下，这是一个快速获得排序函数的简单方法。
- en: 'It''s not that the regular function would be verbose, but by using an anonymous
    function, you have a small advantage; you are not contaminating your local scope
    with an extra function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是说常规函数会很啰嗦，但是通过使用匿名函数，你有一个小优势；你不会用额外的函数污染你的本地范围：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As for style, do note that `PEP8` dictates that assigning a lambda to a variable
    is a bad idea. And logically, it is. The idea of an anonymous function is that
    it is just that—anonymous. If you are giving it an identity, you should define
    it as a normal function. It really isn''t much longer if you want to keep it short.
    Note that both of the following statements are considered bad style and are for
    example purposes only:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 至于风格，请注意`PEP8`规定将lambda分配给变量是一个坏主意。逻辑上也是如此。匿名函数的概念就是这样——匿名的。如果你给它一个身份，你应该将它定义为一个普通函数。如果你想保持它简短，实际上并不会长太多。请注意，以下两个语句都被认为是不好的风格，仅用于示例目的：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In my opinion, the only valid use case for `lambda` functions is as anonymous
    functions used as function parameters, and preferably only if they are short enough
    to fit on a single line.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，`lambda`函数的唯一有效用例是作为函数参数使用的匿名函数，最好只有在它们足够短以适合单行时。
- en: The Y combinator
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Y组合子
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that this paragraph can easily be skipped. It is mostly an example of the
    mathematical value of the lambda statement.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此段落可以轻松跳过。这主要是lambda语句的数学价值的一个例子。
- en: 'The Y combinator is probably the most famous example of the λ-calculus:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Y组合子可能是λ-演算中最著名的例子：
- en: '![The Y combinator](images/4711_04_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![The Y combinator](images/4711_04_01.jpg)'
- en: 'All this looks very complicated, but that''s also because it has used the lambda
    calculus notation. You should read this syntax, ![The Y combinator](images/4711_04_02.jpg),
    as an anonymous (lambda) function that takes `x` as an input and returns ![The
    Y combinator](images/4711_04_03.jpg). In Python, this would be expressed almost
    exactly as it is in the original lambda calculus, except for replacing ![The Y
    combinator](images/4711_04_04.jpg) with lambda and `.` with `:`, so it results
    in lambda `x: x^2`.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '所有这些看起来非常复杂，但这也是因为它使用了lambda演算符号。您应该将此语法读作，![The Y combinator](images/4711_04_02.jpg)，作为一个接受`x`作为输入并返回![The
    Y combinator](images/4711_04_03.jpg)的匿名（lambda）函数。在Python中，这几乎可以与原始lambda演算符号完全相同地表达，只是用lambda替换![The
    Y combinator](images/4711_04_04.jpg)，用`:`替换`.`，因此结果是lambda `x: x^2`。'
- en: 'With some algebra, this can be reduced to ![The Y combinator](images/4711_04_05.jpg),
    or a function that takes the `f` function and applies it to itself. The λ-calculus
    notation of this function is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一些代数运算，这可以简化为![The Y combinator](images/4711_04_05.jpg)，或者一个接受`f`函数并将其应用于自身的函数。该函数的λ-演算表示如下：
- en: '![The Y combinator](images/4711_04_06.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![The Y combinator](images/4711_04_06.jpg)'
- en: 'Here is the Python notation:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Python表示法：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following is the longer version:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是较长版本：
- en: '[PRE17]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This might still be a bit unclear to you, so let''s look at an example that
    actually uses it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对您来说仍然有点不清楚，所以让我们看一个实际使用它的例子：
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the short version, where the power of the Y combinator actually
    appears, with a recursive but still anonymous function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是短版本，其中Y组合子的力量实际上出现了，具有递归但仍然匿名的函数：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that the `n` and `n * c(n – 1)` or `1` part is short for the `if` statement
    used in the longer version of the function. Alternatively, this can be written
    using the Python ternary operator:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`n`和`n * c(n – 1)`或`1`部分是长版本函数中使用的`if`语句的简写。或者，这可以使用Python三元运算符来编写：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You might be wondering about the point of this entire exercise. Can't you write
    a factorial shorter/easier? Yes, you can. The importance of the Y combinator is
    that it can be applied to any function and is very close to the mathematical definition.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道整个练习的重点是什么。难道你不能更短/更容易地写一个阶乘吗？是的，你可以。Y组合子的重要性在于它可以应用于任何函数，并且非常接近数学定义。
- en: 'One final example of the Y combinator will be given by the definition of `quicksort`
    in a few lines:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个Y组合子的例子将通过在几行中定义`quicksort`来给出：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: While the Y combinator most likely doesn't have much practical use in Python,
    it does show the power of the `lambda` statement and how close Python is to the
    mathematical definition. Essentially, the difference is only in the notation and
    not in the functionality.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Y组合子在Python中可能没有太多实际用途，但它确实展示了`lambda`语句的强大之处，以及Python与数学定义的接近程度。基本上，区别只在于表示法，而不在功能上。
- en: functools
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: functools
- en: In addition to the `list/dict/set` comprehensions, Python also has a few (more
    advanced) functions that can be really convenient when coding functionally. The
    `functools` library is a collection of functions that return callable objects.
    Some of these functions are used as decorators (we'll cover more about that in
    [Chapter 5](ch05.html "Chapter 5. Decorators – Enabling Code Reuse by Decorating"),
    *Decorators – Enabling Code Reuse by Decorating*), but the ones that we are going
    to talk about are used as straight-up functions to make your life easier.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`list/dict/set`推导，Python还有一些（更高级）函数，在函数编程时可能非常方便。`functools`库是一组返回可调用对象的函数。其中一些函数用作装饰器（我们将在[第5章](ch05.html
    "第5章。装饰器-通过装饰实现代码重用")中详细介绍），但我们要讨论的函数是直接用作函数，以使您的生活更轻松。
- en: partial – no need to repeat all arguments every time
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: partial-无需每次重复所有参数
- en: 'The `partial` function is really convenient for adding some default arguments
    to a function that you use often but can''t (or don''t want to) redefine. With
    object-oriented code, you can usually work around cases similar to these, but
    with procedural code, you will often have to repeat your arguments. Let''s take
    the `heapq` functions from [Chapter 3](ch03.html "Chapter 3. Containers and Collections
    – Storing Data the Right Way"), *Containers and Collections – Storing Data the
    Right Way*, as an example:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`函数非常方便，可以为经常使用但无法（或不想）重新定义的函数添加一些默认参数。在面向对象的代码中，通常可以解决类似这样的情况，但在过程式代码中，您经常需要重复参数。让我们以[第3章](ch03.html
    "第3章。容器和集合-正确存储数据的方式")中的`heapq`函数为例：'
- en: '[PRE22]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Almost all the `heapq` functions require a `heap` argument, so why not make
    a shortcut for it? This is where `functools.partial` comes in:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有的`heapq`函数都需要一个`heap`参数，那么为什么不为它创建一个快捷方式呢？这就是`functools.partial`的用武之地：
- en: '[PRE23]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Seems a bit cleaner, right? In this case, both versions are fairly short and
    readable, but it's a convenient function to have.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来更清晰了，对吧？在这种情况下，两个版本都相当简短和可读，但这是一个方便的函数。
- en: Why should we use `partial` instead of writing a `lambda` argument? Well, it's
    mostly about convenience, but it also helps solve the late binding problem discussed
    in [Chapter 2](ch02.html "Chapter 2. Pythonic Syntax, Common Pitfalls, and Style
    Guide"), *Pythonic Syntax, Common Pitfalls, and Style Guide*. Additionally, partial
    functions can be pickled whereas `lambda` statements cannot.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们应该使用`partial`而不是编写一个`lambda`参数？嗯，这主要是为了方便，但它还有助于解决[第2章](ch02.html "第2章。Pythonic
    Syntax, Common Pitfalls, and Style Guide")中讨论的延迟绑定问题。此外，partial函数可以被pickled，而`lambda`语句不行。
- en: reduce – combining pairs into a single result
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: reduce-将一对组合成单个结果
- en: The `reduce` function implements a mathematical technique called `fold`. It
    basically applies a function to the first and second elements, uses that result
    to apply together with the third element, and continues until the list is exhausted.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数实现了一种称为`fold`的数学技术。它基本上将一个函数应用于第一个和第二个元素，使用该结果将第三个元素一起应用，并继续直到列表耗尽。'
- en: The `reduce` function is supported by many languages but in most cases using
    different names such as `curry`, `fold`, `accumulate`, or `aggregate`. Python
    has actually supported `reduce` for a very long time, but since Python 3, it has
    been moved from the global scope to the `functools` library. Some code can be
    simplified beautifully using the `reduce` statement; whether it's readable or
    not is debatable, however.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数受许多语言支持，但在大多数情况下使用不同的名称，如`curry`，`fold`，`accumulate`或`aggregate`。Python实际上很长时间以来一直支持`reduce`，但自Python
    3以来，它已经从全局范围移动到`functools`库。一些代码可以使用`reduce`语句进行简化；它是否可读是值得商榷的。'
- en: Implementing a factorial function
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现阶乘函数
- en: 'One of the most used examples of `reduce` is for calculating factorials, which
    is indeed quite simple:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`最常用的例子之一是计算阶乘，这确实非常简单：'
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The preceding code uses `operator.mul` instead of `lambda a, b: a * b`. While
    they produce the same results, the former can be quite faster.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '上述代码使用`operator.mul`而不是`lambda a, b: a * b`。虽然它们产生相同的结果，但前者可能更快。'
- en: 'Internally, the `reduce` function will do the following:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，`reduce`函数将执行以下操作：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To clarify this further, let''s look at it like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步澄清这一点，让我们这样看：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Or with a simple `while` loop using the `deque` collection:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用`deque`集合的简单`while`循环：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Processing trees
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理树
- en: 'Trees are a case where the `reduce` function really shines. Remember the one-line
    tree definition using a `defaultdict` from [Chapter 3](ch03.html "Chapter 3. Containers
    and Collections – Storing Data the Right Way"), *Containers and Collections –
    Storing Data the Right Way*? What would be a good way to access the keys inside
    of that object? Given a path of a tree item, we can use `reduce` to easily access
    the items inside:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 树是`reduce`函数真正发挥作用的一个案例。还记得在[第3章](ch03.html "第3章。容器和集合-正确存储数据")中使用`defaultdict`定义树的一行代码吗？有什么好的方法可以访问该对象内部的键？给定树项目的路径，我们可以使用`reduce`轻松访问内部项目：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And lastly, some people might be wondering why Python only has `fold_left` and
    no `fold_right`. In my opinion, you don't really need both of them as you can
    easily reverse the operation.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有些人可能会想知道为什么Python只有`fold_left`而没有`fold_right`。在我看来，你实际上不需要这两者，因为你可以很容易地反转操作。
- en: 'The regular `reduce`—the `fold left` operation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 常规`reduce`-`fold left`操作：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The reverse—the `fold right` operation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 反向-`fold right`操作：
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: While this one is definitely very useful in purely functional languages—where
    these operations are used quite often—initially there were plans to remove the
    `reduce` function from Python with the introduction of Python 3\. Luckily, that
    plan was modified, and instead of being removed, it has been moved from `reduce`
    to `functools.reduce`. There may not be many useful cases for `reduce`, but there
    are some cool use cases. Especially traversing recursive data structures is far
    more easily done using `reduce`, since it would otherwise involve more complicated
    loops or recursive functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这在纯函数式语言中绝对非常有用-这些操作经常被使用-最初计划在引入Python 3时从Python中删除`reduce`函数。幸运的是，这个计划被修改了，而不是被删除，它已经从`reduce`移动到`functools.reduce`。也许`reduce`没有太多有用的用例，但确实有一些很酷的用例。特别是使用`reduce`更容易地遍历递归数据结构，因为否则将涉及更复杂的循环或递归函数。
- en: itertools
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: itertools
- en: The `itertools` library contains iterable functions inspired by those available
    in functional languages. All of these are iterable and have been constructed in
    such a way that only a minimal amount of memory is required to process even the
    largest of datasets. While you can easily write most of these functions yourself
    using a simple function, I would still recommend using the ones available in the
    `itertools` library. These are all fast, memory efficient, and—perhaps more importantly—tested.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools`库包含受函数式语言启发的可迭代函数。所有这些都是可迭代的，并且已经以这样一种方式构建，即使是处理最大的数据集也只需要最少量的内存。虽然你可以使用一个简单的函数轻松地编写这些函数中的大多数，但我仍然建议使用`itertools`库中提供的函数。这些都很快，内存效率高，而且更重要的是经过测试。'
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though the titles of the paragraphs are capitalized, the functions themselves
    are not. Be careful not to accidently type `Accumulate` instead of `accumulate`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管段落的标题是大写的，但函数本身不是。小心不要意外输入`Accumulate`而不是`accumulate`。
- en: accumulate – reduce with intermediate results
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: accumulate-带有中间结果的reduce
- en: The `accumulate` function is very similar to the `reduce` function, which is
    why some languages actually have `accumulate` instead of `reduce` as the folding
    operator.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`accumulate`函数与`reduce`函数非常相似，这就是为什么一些语言实际上有`accumulate`而不是`reduce`作为折叠运算符。'
- en: 'The major difference between the two is that the `accumulate` function returns
    the immediate results. This can be useful when summing the results of a company''s
    sales, for example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的主要区别在于`accumulate`函数返回即时结果。例如，在对公司销售额进行求和时，这可能很有用：
- en: '[PRE31]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It should be noted that the `operator.add` function is actually optional in
    this case as the default behavior of accumulate is to sum the results. In some
    other languages and libraries, this function is called `cumsum` (cumulative sum).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出，`operator.add`函数在这种情况下实际上是可选的，因为`accumulate`的默认行为是对结果求和。在其他一些语言和库中，这个函数被称为`cumsum`（累积和）。
- en: chain – combining multiple results
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: chain-组合多个结果
- en: 'The `chain` function is a simple but useful function that combines the results
    of multiple iterators. Very simple but also very useful if you have multiple lists,
    iterators, and so on—just combine them with a simple chain:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`chain`函数是一个简单但有用的函数，它可以组合多个迭代器的结果。如果你有多个列表、迭代器等，只需用一个简单的链条组合它们：'
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It should be noted that there is a small variant of `chain` that accepts an
    iterable containing iterables, namely `chain.from_iterable`. They work nearly
    identically, except for the fact that you need to pass along an iterable item
    instead of passing a list of arguments. Your initial response might be that this
    can be achieved simply by unpacking the (`*args`) tuple, as we will see in [Chapter
    6](ch06.html "Chapter 6. Generators and Coroutines – Infinity, One Step at a Time"),
    *Generators and Coroutines – Infinity, One Step at a Time*. However, this is not
    always the case. For now, just remember that if you have a iterable containing
    iterables, the easiest method is to use `itertools.chain.from_iterable`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意，`chain`有一个小变体，它接受一个包含可迭代对象的可迭代对象，即`chain.from_iterable`。它们的工作方式几乎相同，唯一的区别是您需要传递一个可迭代的项目，而不是传递一个参数列表。您最初的反应可能是，这可以通过简单地展开(`*args`)元组来实现，正如我们将在[第6章](ch06.html
    "第6章. 生成器和协程 – 无限，一步一步")中看到的那样，*生成器和协程 – 无限，一步一步*。然而，并非总是如此。现在，只需记住，如果您有一个包含可迭代对象的可迭代对象，最简单的方法是使用`itertools.chain.from_iterable`。
- en: combinations – combinatorics in Python
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合 – Python中的组合数学
- en: 'The `combinations` iterator produces results exactly as you would expect from
    the mathematical definition. All combinations with a specific length from a given
    list of items:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`combinations`迭代器产生的结果与您从数学定义中所期望的完全相同。从给定的项目列表中选择特定长度的所有组合：'
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `combinations` function gives all possible combinations of the given items
    of a given length. The number of possible combinations is given by the binomial
    coefficient, the `nCr` button on many calculators. It is commonly denoted as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`combinations`函数给出了给定长度的给定项目的所有可能组合。可能组合的数量由二项式系数给出，许多计算器上的`nCr`按钮。通常表示如下：'
- en: '![combinations – combinatorics in Python](images/4711_04_07.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![组合 – Python中的组合数学](images/4711_04_07.jpg)'
- en: We have `n=2` and `k=4` in this case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有`n=2`和`k=4`。
- en: 'Here is the variant with repetition of elements:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这是元素重复的变体：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `combinations_with_repetitions` function is very similar to the regular
    `combinations` function, except that the items can be combined with themselves
    as well. To calculate the number of results, the binomial coefficient described
    earlier can be used with the parameters as `n=n+k-1` and `k=k`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`combinations_with_repetitions`函数与常规的`combinations`函数非常相似，只是项目也可以与自身组合。要计算结果的数量，可以使用前面描述的二项式系数，参数为`n=n+k-1`和`k=k`。'
- en: 'Let''s look at a little combination of combinations and chain for generating
    a `powerset`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个使用组合和链的小组合，生成一个`powerset`：
- en: '[PRE35]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The `powerset` is essentially the combined result of all combinations from
    `0` to `n`, meaning that it also includes elements with zero items (the empty
    set, or `()`), elements with `1` item, and all the way up to `n`. The number of
    items in the `powerset` is easily calculated using the power operator: `2**n`.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`powerset`本质上是从`0`到`n`的所有组合的组合结果，这意味着它还包括具有零个项目（空集，或`()`）的元素，具有`1`个项目的元素，一直到`n`。`powerset`中的项目数量可以使用幂运算符轻松计算：`2**n`。'
- en: permutations – combinations where the order matters
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: permutations – 顺序很重要的组合
- en: 'The `permutations` function is quite similar to the `combinations` function.
    The only real difference is that `(a, b)` is considered distinct from `(b, a)`.
    In other words, the order matters:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`permutations`函数与`combinations`函数非常相似。唯一的真正区别是`(a, b)`被认为与`(b, a)`不同。换句话说，顺序很重要：'
- en: '[PRE36]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: compress – selecting items using a list of Booleans
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: compress – 使用布尔列表选择项目
- en: 'The `compress` function is one of those that you won''t need too often, but
    it can be very useful when you do need it. It applies a Boolean filter to your
    iterable, making it return only the ones you actually need. The most important
    thing to note here is that it''s all executed lazily and that `compress` will
    stop if either the data or the selectors collection is exhausted. So, even with
    infinite ranges, it works without a hitch:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`compress`函数是那种您不经常需要的函数之一，但在您需要时它可能非常有用。它对您的可迭代对象应用布尔过滤器，使其仅返回您实际需要的项目。这里最重要的一点是，它都是懒执行的，如果数据或选择器集合耗尽，`compress`将停止。因此，即使有无限范围，它也可以正常工作：'
- en: '[PRE37]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: dropwhile/takewhile – selecting items using a function
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: dropwhile/takewhile – 使用函数选择项目
- en: 'The `dropwhile` function will drop all results until a given predicate evaluates
    to true. This can be useful if you are waiting for a device to finally return
    an expected result. That''s a bit difficult to demonstrate here, so I''ll just
    show an example with the basic usage—waiting for a number greater than `3`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`dropwhile`函数将删除所有结果，直到给定的谓词求值为true。如果您正在等待设备最终返回预期结果，这可能很有用。这在这里有点难以证明，所以我只会展示一个基本用法的例子——等待大于`3`的数字：'
- en: '[PRE38]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As you might expect, the `takewhile` function is the reverse of this. It will
    simply return all rows until the predicate turns false:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能期望的，`takewhile`函数是其相反。它将简单地返回所有行，直到谓词变为false：
- en: '[PRE39]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Simply adding the two will give you the original result again.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 简单地将两者相加将再次给出原始结果。
- en: count – infinite range with decimal steps
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: count – 无限范围，带有小数步长
- en: The `count` function is quite similar to the `range` function, but there are
    two significant differences.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`函数与`range`函数非常相似，但有两个重大区别。'
- en: The first is that this range is infinite, so don't even try to do `list(itertools.count())`.
    You'll definitely run out of memory immediately and it might even freeze your
    system.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别是这个范围是无限的，所以甚至不要尝试`list(itertools.count())`。您肯定会立即耗尽内存，甚至可能会冻结系统。
- en: The second difference is that unlike the `range` function, you can actually
    use floating-point numbers here, so there is no need of whole/integer numbers.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，与`range`函数不同，您实际上可以在这里使用浮点数，因此不需要整数/整数。
- en: 'Since listing the entire range will kill our Python interpreter, we''ll simply
    use `zip` both to limit the results and to compare the results of the regular
    `range` function. In a later paragraph, we will see a more convenient option using
    `itertools.islice`. The `count` function takes two optional parameters: a `start`
    parameter, which defaults to `0`, and a `step` parameter, which defaults to `1`:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于列出整个范围将使我们的Python解释器崩溃，我们将简单地使用`zip`来限制结果并比较常规`range`函数的结果。在后面的段落中，我们将看到使用`itertools.islice`的更方便的选项。`count`函数有两个可选参数：`start`参数，默认为`0`，`step`参数，默认为`1`：
- en: '[PRE40]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `itertools.islice` function is also very useful in conjunction with `itertools.count`,
    as we'll see in a later paragraph.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`itertools.islice`函数在与`itertools.count`结合使用时也非常有用，我们将在后面的段落中看到。'
- en: groupby – grouping your sorted iterable
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: groupby - 对排序后的可迭代对象进行分组
- en: 'The `groupby` function is a really convenient function for grouping results.
    The usage and use cases are probably clear, but there are some important things
    to keep in mind when using this function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupby`函数是一个非常方便的用于分组结果的函数。使用方法和用例可能很清楚，但在使用此函数时有一些重要的事项需要牢记：'
- en: The input needs to be sorted by the `group` parameter. Otherwise, it will be
    added as a separate group.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入需要按`group`参数进行排序。否则，它将被添加为一个单独的组。
- en: The results are available for use only once. So, after processing a group, it
    will not be available anymore.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果只能使用一次。因此，在处理完一个组之后，它将不再可用。
- en: 'Here is an example of the proper use of `groupby`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`groupby`的正确用法示例：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'And then there are cases where you might get unexpected results:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后还有一些情况可能会产生意外的结果：
- en: '[PRE42]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now we see two groups containing `a`. So, make sure you sort by the grouping
    parameter before trying to group. Additionally, walking through the same group
    a second time offers no results. This can be fixed easily using `groups[group]
    = list(items)` instead, but it can give quite a few unexpected bugs if you are
    not aware of this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们看到两个包含`a`的组。所以，在尝试分组之前，请确保按分组参数进行排序。另外，第二次遍历相同的组不会产生结果。这可以很容易地通过使用`groups[group]
    = list(items)`来修复，但如果你不知道这一点，它可能会导致一些意外的错误。
- en: islice – slicing any iterable
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: islice - 对任何可迭代对象进行切片
- en: When working with the `itertools` functions, you might notice that you cannot
    slice these objects. That is because they are generators, a topic that we will
    discuss in [Chapter 6](ch06.html "Chapter 6. Generators and Coroutines – Infinity,
    One Step at a Time"), *Generators and Coroutines – Infinity, One Step at a Time*.
    Luckily, the `itertools` library has a function for slicing these objects as well—`islice`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`itertools`函数时，您可能会注意到无法对这些对象进行切片。这是因为它们是生成器，这是我们将在[第6章](ch06.html "第6章.
    生成器和协程-无限，一步一次")中讨论的一个主题，*生成器和协程-无限，一步一次*。幸运的是，`itertools`库也有一个用于对这些对象进行切片的函数——`islice`。
- en: 'Let''s take `itertools.counter` from before as an example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以之前的`itertools.counter`为例：
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'So, instead of the regular `slice`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要使用常规的`slice`：
- en: '[PRE44]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We enter the `slice` parameters to the function:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`slice`参数输入到函数中：
- en: '[PRE45]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: What you should note from this is actually more than the inability to slice
    the objects. It is not just that slicing doesn't work, but it is not possible
    to get the length either—at least not without counting all items separately—and
    with infinite iterators, even that is not possible. The only understanding you
    actually get from a generator is that you can fetch items one at a time. You won't
    even know in advance whether you're at the end of the generator or not.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该注意的不仅仅是无法对对象进行切片。不仅切片不起作用，而且也无法获取长度—至少不是不逐个计算所有项目的情况下—并且对于无限迭代器，甚至这也是不可能的。您从生成器中实际上只能获得一次理解，即您可以一次获取一个项目。您甚至事先不知道自己是否已经到达生成器的末尾。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: For some reason, functional programming is a paradigm that scares many people,
    but really it shouldn't. The most important difference between functional and
    procedural programming (within Python) is the mindset. Everything is executed
    using simple (and often translations of the mathematical equivalent) functions
    without any storage of variables. Simply put, a functional program consists of
    many functions having a simple input and output, without using (or even having)
    any outside scope or context to access. Python is not a purely functional language,
    so it is easy to cheat and work outside of the local scope, but that is not recommended.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于某种原因，函数式编程是一种让许多人感到恐惧的范式，但实际上不应该。在Python中，函数式编程和过程式编程的最重要区别是思维方式。一切都是使用简单的（通常是数学等价物的转换）函数执行，没有任何变量的存储。简单来说，函数式程序由许多具有简单输入和输出的函数组成，而不使用（甚至没有）任何外部范围或上下文来访问。Python不是纯粹的函数式语言，因此很容易作弊并在局部范围之外工作，但这是不推荐的。
- en: This chapter covered the basics of functional programming within Python and
    some of the mathematics behind it. In addition to this, some of the many useful
    libraries that can be used in a very convenient way by using functional programming
    were covered.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了Python中函数式编程的基础知识以及其中的一些数学知识。除此之外，还介绍了一些可以通过使用函数式编程非常方便地使用的许多有用的库。
- en: 'The most important outtakes should be the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的要点应该是以下内容：
- en: Lambda statements are not inherently bad but it would be best to make them use
    variables from the local scope only, and they should not be longer than a single
    line.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda语句本质上并不是坏的，但最好让它们只使用局部范围的变量，并且不应超过一行。
- en: Functional programming can be very powerful, but it has a tendency to quickly
    become unreadable. Care must be taken.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程可能非常强大，但很容易变得难以阅读。必须小心。
- en: '`list/dict/set` comprehensions are very useful, but they should generally not
    be nested, and for the purpose of readability, they should be kept short as well.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`list/dict/set`推导式非常有用，但通常不应嵌套，并且为了可读性，它们也应该保持简短。'
- en: Ultimately, it is a matter of preference. For the sake of readability, I recommend
    limiting the usage of the functional paradigm when there is no obvious benefit.
    Having said that, when executed correctly, it can be a thing of beauty.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，这是一个偏好的问题。为了可读性，我建议在没有明显好处时限制使用功能范式。话虽如此，当正确执行时，它可以成为一种美丽的事物。
- en: Next up are decorators—methods to wrap your functions and classes in other functions
    and/or classes to modify their behavior and extend their functionality.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是装饰器——用来包装您的函数和类的方法，以修改它们的行为并扩展它们的功能。
