- en: '*Chapter 9*: Understanding Code through Abstract Syntax Tree'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 9 章*：通过抽象语法树理解代码'
- en: In this chapter, we will look at what abstract syntax trees are and how to understand
    the syntax tree of each unit of the Python code we write.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨抽象语法树是什么，以及如何理解我们编写的 Python 代码中每个单元的语法树。
- en: Any programming language is designed with its own syntax, which is used by developers
    while coding in the language following specific syntax. The interpreter or compiler
    of a programming language interprets the syntax of the language and compiles or
    interprets the code and executes it to achieve the desired result.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言都是设计有其自己的语法，开发者在使用该语言编码时遵循特定的语法。编程语言的解释器或编译器解释语言的语法，编译或解释代码并执行它以实现预期的结果。
- en: In Python, an `ast` that can be used to understand the abstract syntax of the
    code that we develop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`ast` 可以用来理解我们开发的代码的抽象语法。
- en: Throughout this chapter, we will look at understanding the syntax tree of some
    of the important code snippets that we developed in previous chapters, and we
    will also look at modifying or adding more information to the code through a few
    examples. We will be making use of abstract syntax trees throughout this chapter
    to perform an analysis of the code.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨理解我们在前几章中开发的一些重要代码片段的语法树，同时我们还将通过几个示例来查看修改或添加更多信息的代码。我们将在本章中使用抽象语法树来对代码进行分析。
- en: 'In this chapter, we will be taking a look at the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主要主题：
- en: Exploring the `ast` library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `ast` 库
- en: Inspecting Python code with abstract syntax trees
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象语法树检查 Python 代码
- en: Understanding abstract syntax trees with applications
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用理解抽象语法树
- en: By the end of this chapter, you should be able to understand the abstract syntax
    tree of Python code. You should also be able to inspect, parse, and modify the
    abstract syntax tree of source code through metaprogramming.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解 Python 代码的抽象语法树。你还应该能够通过元编程检查、解析和修改源代码的抽象语法树。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code examples shared in this chapter are available on GitHub under the
    code for this chapter here: [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中分享的代码示例可在 GitHub 上找到，地址为：[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter9)。
- en: Exploring the ast library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 `ast` 库
- en: In this section, we will explore the `ast` Python library, which can be imported
    from Python 3 to analyze the Python code written by developers. We can also use
    it to modify the code through its abstract syntax tree at a metaprogramming level
    rather than modifying the syntax of the code itself. This helps in understanding
    how the code is syntactically represented and how the syntax tree of the code
    can be used to modify its behavior without modifying the original source code.
    We will look at some of the important functions of the `ast` library, as those
    functions will be used throughout this chapter to understand the code from our
    core example.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探索 `ast` Python 库，该库可以从 Python 3 中导入以分析开发者编写的 Python 代码。我们还可以通过其抽象语法树在元编程级别上修改代码，而不是修改代码本身的语法。这有助于理解代码是如何在语法上表示的，以及代码的语法树如何被用来修改其行为而不修改原始源代码。我们将查看
    `ast` 库的一些重要功能，因为这些功能将在本章中用于理解我们的核心示例。
- en: 'Let’s start by importing the `ast` library:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从导入 `ast` 库开始：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once we import the library, we can look at analyzing a piece of code using
    this library. We will now create a variable named `assignment` and assign a string
    format of the code to it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们导入库，我们就可以使用这个库来分析一段代码。现在我们将创建一个名为 `assignment` 的变量，并将代码的字符串格式赋值给它：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output of the `assignment` variable appears as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`assignment` 变量的输出如下所示：'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code can be parsed into its corresponding nodes using the `parse`
    method of the `ast` library. We will now create a variable named `assign_tree`
    and store the parsed node of the lines of code stored under `assignment`:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码可以使用 `ast` 库的 `parse` 方法解析为其对应的节点。现在我们将创建一个名为 `assign_tree` 的变量，并将存储在 `assignment`
    下的代码行的解析节点存储到它中：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output of the parsed node looks as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 解析节点的输出如下所示：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can make use of another method called `dump` to print the tree structure
    of the node with each of its values and fields. This helps in debugging the code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用另一个名为`dump`的方法来打印节点的树结构，包括其每个值和字段。这有助于调试代码：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The output of the code is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下：
- en: '![Figure 9.1 – Example of an abstract syntax tree ](img/Figure_9.1_B13426.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 抽象语法树示例](img/Figure_9.1_B13426.jpg)'
- en: Figure 9.1 – Example of an abstract syntax tree
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 抽象语法树示例
- en: The `"product_name = 'Iphone X'"` code is broken down into multiple parts. The
    syntax of any code in Python is grammatically embedded into `Module` followed
    by `body`. We have assigned the `Iphone X` value to the `product_name` variable
    and so the code that performs a value assignment is identified by the `Assign`
    branch, which has attributes mapped with the corresponding ID, context, and value.
    This is an example of what a simple representation of a node would look like.
    For multiple lines of code with various other operations, the node will have multiple
    other branches in the tree.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`"product_name = ''Iphone X''"`代码被分解成多个部分。任何Python代码的语法都是语法嵌入到`Module`后面跟着`body`。我们将`Iphone
    X`的值赋给`product_name`变量，因此执行值赋值的代码被识别为`Assign`分支，该分支具有与相应ID、上下文和值映射的属性。这是一个简单节点表示的例子。对于多行代码和多种其他操作，节点将在树中有多个其他分支。'
- en: Let’s start inspecting the Python code for a few examples of using abstract
    syntax trees in the following section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下部分开始检查使用抽象语法树的Python代码的几个示例。
- en: Inspecting Python code with abstract syntax trees
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象语法树检查Python代码
- en: In this section, we will review and understand the code for a simple arithmetic
    addition example, and we will also further look into parsing the code and modifying
    it using abstract syntax trees.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾和理解简单算术加法示例的代码，并且将进一步探讨使用抽象语法树解析和修改代码。
- en: Reviewing simple code using ast
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ast回顾简单代码
- en: 'In this section, let’s review simple code that adds two numbers, and let’s
    look at all the elements of the node, and also how the elements are organized
    in the tree. Let’s begin by writing code to assign two variables, `a` and `b`,
    with numerical values, and `c` as the sum of `a` and `b`. Finally, let’s print
    the `c` value. This is shown in the following code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们回顾一下简单的加法代码，并查看节点中的所有元素，以及这些元素在树中的组织方式。让我们先编写代码来赋值两个变量`a`和`b`的数值，以及`c`作为`a`和`b`的和。最后，让我们打印`c`的值。这在上面的代码中显示如下：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will now parse the preceding `addfunc` and store the node in another variable
    called `add_tree`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将解析前面的`addfunc`并将节点存储在另一个名为`add_tree`的变量中：
- en: '[PRE13]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output of the parsed node is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 解析后的节点输出如下：
- en: '[PRE15]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The base element of the node is `Module`, and all the other lines of code are
    split into semantics that are stored within the module of the node.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的基元素是`Module`，所有其他代码行都被分割成存储在节点模块中的语义。
- en: 'Let’s look at the detailed tree representation in the following code by calling
    the `dump` method on the tree:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在树上调用`dump`方法来查看以下代码中的详细树表示：
- en: '[PRE16]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The tree begins with `Module` as its base element, or the trunk followed by
    multiple branches. `Module` is followed by `body` as a list item that lists down
    all other elements of the code.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 树以`Module`作为其基本元素，或者说是树干，随后是多个分支。`Module`后面跟着一个`body`作为列表项，列出了代码的所有其他元素。
- en: 'Within `body`, there will be four list items that describe the operations of
    `addfunc`. The first one, which is also the first line of `addfunc`, is to assign
    the `Constant` value `1098` to a variable with a name whose id is `a` and the
    context of the value is `Store` since we are storing the value in the variable.
    Here is how it appears:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在`body`中，将有四个列表项描述`addfunc`的操作。第一个，也是`addfunc`的第一行，是将`Constant`值`1098`赋给一个名为id的变量，其值为`a`，上下文为`Store`，因为我们正在将值存储在变量中。它看起来是这样的：
- en: '![Figure 9.2 – Code snippet output ](img/Figure_9.2_B13426.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 代码片段输出](img/Figure_9.2_B13426.jpg)'
- en: Figure 9.2 – Code snippet output
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 代码片段输出
- en: 'Similarly, the second line of `addfunc` is to store the `2032` value in the
    `b` variable, which is represented grammatically in the following list item:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`addfunc`的第二行是将`2032`值存储在`b`变量中，这在以下列表项中以语法形式表示：
- en: '![Figure 9.3 – Code snippet output ](img/Figure_9.3_B13426.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 代码片段输出](img/Figure_9.3_B13426.jpg)'
- en: Figure 9.3 – Code snippet output
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 代码片段输出
- en: 'The third line of code in `addfunc` has the arithmetic operation of adding
    the two values stored in `a` and `b`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`addfunc`中的第三行代码执行了将存储在`a`和`b`中的两个值相加的算术操作：'
- en: '![Figure 9.4 – Code snippet output ](img/Figure_9.4_B13426.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 代码片段输出](img/Figure_9.4_B13426.jpg)'
- en: Figure 9.4 – Code snippet output
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 代码片段输出
- en: The preceding code has an additional element, `BinOp`, followed by `left`, `op`,
    and `right` variables to indicate the left numerical value, addition operation,
    and right numerical value, respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有一个额外的元素`BinOp`，后面跟着`left`、`op`和`right`变量，分别表示左数值、加法操作和右数值。
- en: 'The last line of the code in `addfunc` is the `Expr` expression element, which
    represents the printing of the `c` variable with a context value of `Load`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`addfunc`中的最后一行代码是`Expr`表达式元素，它表示以`Load`上下文值打印`c`变量：'
- en: '![Figure 9.5 – Code snippet output ](img/Figure_9.5_B13426.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 代码片段输出](img/Figure_9.5_B13426.jpg)'
- en: Figure 9.5 – Code snippet output
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 代码片段输出
- en: 'To execute `addfunc`, we need to first compile the parsed tree as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行`addfunc`，我们需要首先按照以下方式编译解析树：
- en: '[PRE17]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Post-compilation, we should be able to execute the compiled tree, which results
    in the addition of `a` and `b`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编译后，我们应该能够执行编译后的树，这将导致`a`和`b`的相加：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following is the output of the code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为代码的输出：
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this section, we reviewed the abstract syntax tree of the simple arithmetic
    `add` function. In the following section, let’s look at modifying the code of
    the `add` function using metaprogramming.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了简单算术`add`函数的抽象语法树。在下一节中，让我们看看如何使用元编程修改`add`函数的代码。
- en: Modifying simple code using ast
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ast 修改简单代码
- en: In this section, let’s consider the example of `addfunc` from the preceding
    section and look at how to modify the code in the example through metaprogramming,
    without modifying the actual code. The operation performed by the code in `addfunc`
    is arithmetic addition. What if we want to perform arithmetic multiplication instead
    of addition and we don’t want the actual code to be modified? What if there are
    multiple locations where we want arithmetic addition to be replaced by arithmetic
    multiplication, and browsing through thousands of lines of code and modifying
    them is not a feasible option as it might impact or break something else in the
    code? In such scenarios, we can modify the node of the code using its syntax tree
    instead of modifying the actual code itself. To achieve this, let’s make use of
    the abstract syntax tree of the code.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们考虑上一节中的`addfunc`示例，并看看如何通过元编程修改示例中的代码，而不修改实际代码。`addfunc`中代码执行的操作是算术加法。如果我们想执行算术乘法而不是加法，并且不想修改实际代码，会怎样？如果我们想在多个位置将算术加法替换为算术乘法，而浏览数千行代码并修改它们不是一个可行的选项，因为它可能会影响或破坏代码中的其他部分，会怎样？在这种情况下，我们可以通过修改代码的节点而不是修改实际代码本身来修改代码的节点。为了实现这一点，让我们利用代码的抽象语法树。
- en: 'Let’s reuse the `add_tree` parsed tree variable from the code in the preceding
    section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重用前面代码中的`add_tree`解析树变量：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To understand which fields to modify, let’s look at the following representation
    of the node and look at each section of the node marked by an identifier. The
    elements of interest for this example are represented inside a box in the following
    figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解哪些字段需要修改，让我们看看以下节点的表示，并查看节点中由标识符标记的每个部分。本例中感兴趣的元素在以下图中用方框表示：
- en: '![Figure 9.6 – Parsed node of addfunc ](img/Figure_9.6_B13426.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.6 – `addfunc`的解析节点](img/Figure_9.6_B13426.jpg)'
- en: Figure 9.6 – Parsed node of addfunc
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.6 – `addfunc`的解析节点
- en: 'To modify the add operation into a multiplication operation, the tree for this
    node traverses through `body` followed by its list item `2`, followed by the `value`
    field of the item, followed by the `op` field. The `Add()` operation of the `op`
    field will have to be modified into a multiplication operation to achieve our
    goal for this section. Here’s how:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要将加法操作修改为乘法操作，此节点的树遍历`body`，然后是其列表项`2`，然后是项的`value`字段，然后是`op`字段。`op`字段的`Add()`操作必须修改为乘法操作，以实现本节的目标。以下是方法：
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Executing the preceding code results in a change of the tree:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码会导致树的变化：
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The figure of the updated tree structure is represented as follows, with the
    `Add()` operation replaced by the `Mult()` operation:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 更新后的树结构图如下所示，其中`Add()`操作被`Mult()`操作所替代：
- en: '![Figure 9.7 – Tree modified to perform multiplication ](img/Figure_9.7_B13426.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.7 – 修改后的树以执行乘法](img/Figure_9.7_B13426.jpg)'
- en: Figure 9.7 – Tree modified to perform multiplication
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.7 – 修改后的树以执行乘法
- en: 'To verify whether the preceding modification on the tree node works, let’s
    compile the tree and execute it to check the results:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证前面在树节点上的修改是否有效，让我们编译树并执行它以检查结果：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Executing the preceding code should have ideally provided an output of `3130`,
    which is the addition of two numbers, `1098` and `2032`. But we have modified
    `ast` to perform multiplication instead and so it would result in the value, which
    is a product of the two numbers:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面的代码理想情况下应该提供输出 `3130`，这是两个数字 `1098` 和 `2032` 的和。但我们已经修改了 `ast` 以执行乘法，因此它将得到的结果是两个数字的乘积：
- en: '[PRE26]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Thus the tree is now modified and can be compiled to achieve the desired result
    without modifying the actual code.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，树现在已经被修改，可以编译以实现所需的结果，而无需修改实际代码。
- en: With this understanding, let’s proceed further to look at how to parse and understand
    the classes in Python.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，让我们进一步探讨如何解析和理解 Python 中的类。
- en: Understanding abstract syntax trees with applications
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解抽象语法树及其应用
- en: In this section, we will look into applying the concept of abstract syntax trees
    to our core example of *ABC Megamart* and explore how `ast` is defined in the
    classes, such as the `Branch` class and the `VegCounter` class of *ABC Megamart*.
    We will also look at modifying the behavior of these classes using `ast` at a
    metaprogramming level instead of modifying the actual source code of the class.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨将抽象语法树的概念应用于我们的核心示例 *ABC Megamart*，并探索 `ast` 在类中的定义，例如 *ABC Megamart*
    的 `Branch` 类和 `VegCounter` 类。我们还将探讨如何使用 `ast` 在元编程级别上修改这些类的行为，而不是修改类的实际源代码。
- en: Understanding the ast of a class
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解类的 ast
- en: 'In this section, we will look at understanding the abstract syntax tree of
    a class, which will help us in exploring how to modify the elements of a class
    through metaprogramming. We can try it as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨理解类的抽象语法树，这将帮助我们探索如何通过元编程修改类的元素。我们可以尝试如下：
- en: 'Let’s begin by creating a class with empty definitions and look at its abstract
    syntax tree:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个具有空定义的类开始，并查看其抽象语法树：
- en: '[PRE27]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, let’s parse the code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们解析代码：
- en: '[PRE28]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let’s further look at the elements of the node and understand how the class
    is grammatically defined:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们进一步查看节点元素，并了解类是如何在语法上定义的：
- en: '[PRE29]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The structure of the node is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的结构如下：
- en: '![Figure 9.8 – Code snippet output  ](img/Figure_9.8_B13426.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.8 – 代码片段输出](img/Figure_9.8_B13426.jpg)'
- en: Figure 9.8 – Code snippet output
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.8 – 代码片段输出
- en: In the preceding output, we have `Module` followed by `body`, with `ClassDef`
    within the `body` element. This `ClassDef` has a `name` element followed by two
    expressions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，我们有 `Module` 后跟 `body`，在 `body` 元素内部有 `ClassDef`。这个 `ClassDef` 有一个 `name`
    元素，后面跟着两个表达式。
- en: 'Let’s redefine this empty class definition with an attribute and a method along
    with a decorator and recheck the structure of the node:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新定义这个空类定义，并添加一个属性和一个方法，以及一个装饰器，然后重新检查节点的结构：
- en: '[PRE30]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will now parse `branch_code` in the following step:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在以下步骤中解析 `branch_code`：
- en: '[PRE31]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The structure of the `Branch` class in the form of an abstract syntax tree is
    as follows. We can see that the node starts with the `Module` element followed
    by `body`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Branch` 类的抽象语法树结构如下。我们可以看到节点从 `Module` 元素开始，后面跟着 `body`。'
- en: 'Within `body`, we have a `ClassDef` element that contains the class name followed
    by its attributes, which include `branch_id` stored as a constant value followed
    by the `get_product` method with its arguments. Refer to the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `body` 中，我们有一个包含类名及其属性的 `ClassDef` 元素，这些属性包括存储为常量的 `branch_id`，后面跟着带有其参数的
    `get_product` 方法。请参阅以下输出：
- en: '![Figure 9.9 – Code snippet output](img/Figure_9.9_B13426.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.9 – 代码片段输出](img/Figure_9.9_B13426.jpg)'
- en: Figure 9.9 – Code snippet output
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.9 – 代码片段输出
- en: 'We also have a `decorator` method loaded under `decorator_list` as follows:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还在 `decorator_list` 下加载了一个 `decorator` 方法，如下所示：
- en: '![Figure 9.10 – Code snippet output ](img/Figure_9.10_B13426.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.10 – 代码片段输出](img/Figure_9.10_B13426.jpg)'
- en: Figure 9.10 – Code snippet output
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.10 – 代码片段输出
- en: 'If we create an object for the class, the code for the object can also be parsed
    similarly to the preceding class example:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们为该类创建一个对象，该对象的代码也可以像前面的类示例一样进行解析：
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The node of the object will have the following structure:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对象的节点将具有以下结构：
- en: '![Figure 9.11 Code snippet output ](img/Figure_9.11_B13426.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.11 代码片段输出](img/Figure_9.11_B13426.jpg)'
- en: Figure 9.11 Code snippet output
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.11 代码片段输出
- en: In this section, we reviewed the abstract syntax tree of a class to understand
    the various elements of its syntax. With this understanding, let’s look further
    into modifying the abstract syntax tree of a class from our core example, *ABC
    Megamart*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了类的抽象语法树，以了解其语法的各种元素。有了这种理解，让我们进一步探讨从我们的核心示例 *ABC Megamart* 中修改类的抽象语法树。
- en: Modifying the ast of a code block by parsing
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过解析修改代码块的 ast
- en: In this section, let’s look at how to modify the attributes in the code of a
    class by using its abstract syntax tree instead of modifying the actual class
    itself.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让我们看看如何通过使用类的抽象语法树来修改代码中的属性，而不是直接修改类本身。
- en: Let’s consider having developed a robust library with multiple classes and methods.
    A robust library definition may be too big to be disturbed or modified. Instead
    of modifying the source code, we can make changes to some specific attributes
    in the library without impacting the actual code, through metaprogramming. In
    such a scenario, modifying `ast` of the library would be a better way of making
    changes rather than impacting the source code of the library.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑已经开发了一个具有多个类和方法的健壮库。健壮的库定义可能太大，无法被打扰或修改。而不是修改源代码，我们可以通过元编程在库中的一些特定属性上进行更改，而不影响实际的代码。在这种情况下，修改库的
    `ast` 将是比影响库的源代码更好的更改方式。
- en: 'In this example, we will be following these steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将遵循以下步骤：
- en: 'We will be creating a `vegCounter` class and adding a `return_cart` method
    to return the items within the cart. We will also be creating an object for the
    class and calling the `return_cart` method on the object. Refer to the following
    code:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个 `vegCounter` 类，并添加一个 `return_cart` 方法来返回购物车中的项目。我们还将创建类的对象，并在对象上调用 `return_cart`
    方法。请参考以下代码：
- en: '[PRE33]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, let’s parse the code for `vegCounter` and look at the structure of the
    node:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们解析 `vegCounter` 的代码，并查看节点的结构：
- en: '[PRE34]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output of the node is as follows. There is a class definition followed
    by a function definition in `ast`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的输出如下。在 `ast` 中，有一个类定义后跟一个函数定义：
- en: '![Figure 9.12 – Code snippet output](img/Figure_9.12_B13426.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12 – 代码片段输出](img/Figure_9.12_B13426.jpg)'
- en: Figure 9.12 – Code snippet output
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.12 – 代码片段输出
- en: 'The following output has the elements for the list item and the logic that
    reads items to the list:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出具有列表项和读取项目到列表的逻辑元素：
- en: '![Figure 9.13 – Code snippet output ](img/Figure_9.13_B13426.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.13 – 代码片段输出](img/Figure_9.13_B13426.jpg)'
- en: Figure 9.13 – Code snippet output
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – 代码片段输出
- en: 'The following output has the syntax for creating the object for the `VegCounter`
    class:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出显示了创建 `VegCounter` 类对象的语法：
- en: '![Figure 9.14 – Code snippet output ](img/Figure_9.14_B13426.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.14 – 代码片段输出](img/Figure_9.14_B13426.jpg)'
- en: Figure 9.14 – Code snippet output
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 代码片段输出
- en: 'The following output displays the elements that print the cart items by calling
    the `return_cart` method on a list of cart items:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下输出显示了通过在购物项列表上调用 `return_cart` 方法来打印购物项的元素：
- en: '![Figure 9.15 – Code snippet output ](img/Figure_9.15_B13426.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.15 – 代码片段输出](img/Figure_9.15_B13426.jpg)'
- en: Figure 9.15 – Code snippet output
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.15 – 代码片段输出
- en: 'Let’s now compile the abstract syntax tree and execute it to display the list
    of items added to the cart:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们编译抽象语法树并执行它以显示添加到购物车中的项目列表：
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, let’s navigate through the values in the cart items and look at the path
    of the second value in the `return_cart` method output:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在购物项的值中导航，并查看 `return_cart` 方法输出中第二个值的路径：
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let’s now change the second value of the cart item from `tomatoes` to `potatoes`
    by parsing through the node elements hierarchically:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们通过逐级解析节点元素，将购物项的第二个值从 `tomatoes` 更改为 `potatoes`：
- en: '[PRE37]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the following output, let’s look at the updated value for the second item
    in the cart, which is modified without changing the source code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在以下输出中，让我们看看购物车中第二个项目的更新值，该值在未更改源代码的情况下进行了修改：
- en: '![Figure 9.16 – Modifying value within ast ](img/Figure_9.16_B13426.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.16 – 在 ast 中修改值](img/Figure_9.16_B13426.jpg)'
- en: Figure 9.16 – Modifying value within ast
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.16 – 在 ast 中修改值
- en: 'We can now unparse the node using the `unparse` method in the `ast` library
    as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用 `ast` 库中的 `unparse` 方法来解析节点，如下所示：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The modified source code now looks as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改后的源代码现在看起来如下所示：
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is one approach to modifying the Python source code using an abstract syntax
    tree.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种使用抽象语法树修改 Python 源代码的方法。
- en: With this understanding, let’s proceed with the next approach, where we will
    be transforming the nodes of the abstract syntax tree.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这种理解，让我们继续探讨下一个方法，即我们将转换抽象语法树的节点。
- en: Modifying the ast of a code block by transforming nodes
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过转换节点修改代码块的 ast
- en: 'In this section, we will look at another approach to modifying the source code
    of a class by modifying the abstract syntax tree instead of changing the actual
    code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨另一种通过修改抽象语法树而不是实际代码来修改类源代码的方法：
- en: 'Let’s now create the `VegCounter` class as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在创建一个名为 `VegCounter` 的类，如下所示：
- en: '[PRE40]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, let’s create a variable named `cart` and add the function call on the
    object as a string:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `cart` 的变量，并将对象上的函数调用作为一个字符串添加：
- en: '[PRE41]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Parsing the preceding code provides the following output:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解析前面的代码提供了以下输出：
- en: '![Figure 9.17 – AST of the object variable ](img/Figure_9.17_B13426.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.17 – 对象变量的 AST](img/Figure_9.17_B13426.jpg)'
- en: Figure 9.17 – AST of the object variable
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.17 – 对象变量的 AST
- en: 'In this section, instead of traversing through the structure of the node, we
    will be using `NodeTransformer` from the `ast` library to perform code transformation:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不会遍历节点的结构，而是将使用 `ast` 库的 `NodeTransformer` 来执行代码转换：
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The attributes of `NodeTransformer` are as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`NodeTransformer` 的属性如下：'
- en: '![Figure 9.18 – Attributes of NodeTransformer ](img/Figure_9.18_B13426.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.18 – NodeTransformer 的属性](img/Figure_9.18_B13426.jpg)'
- en: Figure 9.18 – Attributes of NodeTransformer
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.18 – NodeTransformer 的属性
- en: 'Next, let’s create a class named `ModifyVegCounter` inherited from the `NodeTransfomer`
    class. We will be redefining the `visit_Constant` method to modify the constant
    values of the cart items by adding a string prefix whenever the constant value
    occurs in the code:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个名为 `ModifyVegCounter` 的类，它继承自 `NodeTransfomer` 类。我们将重新定义 `visit_Constant`
    方法，以便在代码中常数值出现时添加一个字符串前缀来修改购物项的常数值：
- en: '[PRE43]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can make use of the `visit` method to visit the node and use the `dump`
    method to print the tree:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以利用 `visit` 方法来访问节点，并使用 `dump` 方法来打印树：
- en: '[PRE44]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The transformed node looks as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 转换后的节点如下所示：
- en: '![Figure 9.19 – Source code transformed with NodeTransformer ](img/Figure_9.19_B13426.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.19 – 使用 NodeTransformer 转换的源代码](img/Figure_9.19_B13426.jpg)'
- en: Figure 9.19 – Source code transformed with NodeTransformer
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.19 – 使用 NodeTransformer 转换的源代码
- en: 'We can further unparse the code using the `ast` library’s `unparse` method:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `ast` 库的 `unparse` 方法进一步将代码反解析：
- en: '[PRE45]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The output of the code is represented as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的输出如下所示：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This is another example of how an abstract syntax tree can be used in metaprogramming.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是抽象语法树在元编程中应用的另一个例子。
- en: In this section, we covered the approach of transforming the nodes of an abstract
    syntax tree using the `NodeTransformer` method of the `ast` library.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们介绍了使用 `ast` 库的 `NodeTransformer` 方法来转换抽象语法树节点的技术。
- en: Summary
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned about the concept of the abstract syntax tree
    by exploring the `ast` library in Python 3\. We also inspected Python code using
    abstract syntax trees. We understood the applications of abstract syntax trees
    by modifying the code at the node level using source code from our core example.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过探索 Python 3 中的 `ast` 库来了解抽象语法树的概念。我们还使用抽象语法树检查了 Python 代码。通过使用我们的核心示例中的源代码在节点级别修改代码，我们理解了抽象语法树的应用。
- en: Similar to other chapters in this book, this chapter covered the concept of
    abstract syntax trees in metaprogramming. This also helps in understanding how
    to modify the behavior of Python objects externally without modifying the source
    code. Modifying the abstract syntax tree instead of the actual methods and attributes
    in the code helps migrate source code from different versions of Python or the
    application development platform conveniently without impacting the actual logic
    of the code.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他章节类似，本章介绍了元编程中的抽象语法树的概念。这也有助于理解如何在不修改源代码的情况下，从外部修改 Python 对象的行为。通过修改代码中的实际方法和属性，而不是抽象语法树，可以方便地将源代码从不同的
    Python 版本或应用程序开发平台迁移，而不会影响代码的实际逻辑。
- en: In the next chapter, we will be looking at the concept of **method resolution
    order** with some other interesting examples.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨**方法解析顺序**的概念，并伴随一些有趣的示例。
