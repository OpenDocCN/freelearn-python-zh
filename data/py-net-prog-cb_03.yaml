- en: Chapter 3. IPv6, Unix Domain Sockets, and Network Interfaces
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：IPv6、Unix域套接字和网络接口
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Forwarding a local port to a remote host
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将本地端口转发到远程主机
- en: Pinging hosts on the network with ICMP
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ICMP ping网络上的主机
- en: Waiting for a remote network service
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待远程网络服务
- en: Enumerating interfaces on your machine
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出您的机器上的接口
- en: Finding the IP address for a specific interface on your machine
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找您的机器上特定接口的IP地址
- en: Finding whether an interface is up on your machine
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查您的机器上的接口是否已启动
- en: Detecting inactive machines on your network
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测您的网络上的不活跃机器
- en: Performing a basic IPC using connected sockets (socketpair)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连接套接字（socketpair）执行基本IPC
- en: Performing IPC using Unix domain sockets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unix域套接字执行IPC
- en: Finding out if your Python supports IPv6 sockets
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看您的Python是否支持IPv6套接字
- en: Extracting an IPv6 prefix from an IPv6 address
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从IPv6地址中提取IPv6前缀
- en: Writing an IPv6 echo client/server
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写IPv6 echo客户端/服务器
- en: Introduction
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter extends the use of Python's socket library with a few third-party
    libraries. It also discusses some advanced techniques, for example, the asynchronous
    `ayncore` module from the Python standard library. This chapter also touches upon
    various protocols, ranging from an ICMP ping to an IPv6 client/server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章扩展了Python的socket库的使用，结合了一些第三方库。它还讨论了一些高级技术，例如Python标准库中的异步 `ayncore` 模块。本章还涉及了各种协议，从ICMP
    ping到IPv6客户端/服务器。
- en: In this chapter, a few useful Python third-party modules have been introduced
    by some example recipes. For example, the network packet capture library, **Scapy**,
    is well known among Python network programmers.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，通过一些示例配方介绍了一些有用的Python第三方模块。例如，网络数据包捕获库 **Scapy** 在Python网络程序员中广为人知。
- en: A few recipes have been dedicated to explore the IPv6 utilities in Python including
    an IPv6 client/server. Some other recipes cover Unix domain sockets.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些配方致力于探索Python中的IPv6实用工具，包括IPv6客户端/服务器。其他一些配方涵盖了Unix域套接字。
- en: Forwarding a local port to a remote host
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将本地端口转发到远程主机
- en: Sometimes, you may need to create a local port forwarder that will redirect
    all traffic from a local port to a particular remote host. This might be useful
    to enable proxy users to browse a certain site while preventing them from browsing
    some others.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要创建一个本地端口转发器，将所有从本地端口到特定远程主机的流量重定向。这可能有助于允许代理用户浏览某些网站，同时防止他们浏览其他网站。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let us create a local port forwarding script that will redirect all traffic
    received at port 8800 to the Google home page ([http://www.google.com](http://www.google.com)).
    We can pass the local and remote host as well as port number to this script. For
    the sake of simplicity, let's only specify the local port number as we are aware
    that the web server runs on port 80.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个本地端口转发脚本，该脚本将所有接收到的端口8800上的流量重定向到谷歌首页 ([http://www.google.com](http://www.google.com))。我们可以将本地和远程主机以及端口号传递给此脚本。为了简化，让我们只指定本地端口号，因为我们知道Web服务器运行在端口80上。
- en: 'Listing 3.1 shows a port forwarding example, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1显示了端口转发示例，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'First, we define the `PortForwarder` class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义 `端口转发器` 类：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we need to specify the `Receiver` and `Sender` classes, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要指定 `接收器` 和 `发送器` 类，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run this script, it will show the following output:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行此脚本，它将显示以下输出：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, open your browser and visit `http://localhost:8800`. This will take you
    to the Google home page and the script will print something similar to the following
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打开您的浏览器并访问 `http://localhost:8800`。这将带您进入谷歌首页，脚本将打印类似以下命令的内容：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following screenshot shows the forwarding a local port to a remote host:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了将本地端口转发到远程主机：
- en: '![How to do it...](img/3463OS_03_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/3463OS_03_01.jpg)'
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We created a port forwarding class, `PortForwarder subclassed`, from `asyncore.dispatcher`,
    which wraps around the socket object. It provides a few additional helpful functions
    when certain events occur, for example, when the connection is successful or a
    client is connected to a server socket. You have the choice of overriding the
    set of methods defined in this class. In our case, we only override the `handle_accept()`
    method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个从 `asyncore.dispatcher` 继承的端口转发类 `PortForwarder subclassed`，它围绕套接字对象进行包装。当某些事件发生时，它提供了一些额外的有用功能，例如，当连接成功或客户端连接到服务器套接字时。您可以选择覆盖此类中定义的方法集。在我们的例子中，我们只覆盖了
    `handle_accept()` 方法。
- en: Two other classes have been derived from `asyncore.dispatcher`. The `Receiver`
    class handles the incoming client requests and the `Sender` class takes this `Receiver`
    instance and processes the sent data to the clients. As you can see, these two
    classes override the `handle_read()`, `handle_write()`, and `writeable()` methods
    to facilitate the bi-directional communication between the remote host and local
    client.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 已从 `asyncore.dispatcher` 派生出两个其他类。`Receiver` 类处理传入的客户端请求，而 `Sender` 类接收此 `Receiver`
    实例并处理发送到客户端的数据。如您所见，这两个类覆盖了 `handle_read()`、`handle_write()` 和 `writeable()` 方法，以促进远程主机和本地客户端之间的双向通信。
- en: In summary, the `PortForwarder` class takes the incoming client request in a
    local socket and passes this to the `Sender` class instance, which in turn uses
    the `Receiver` class instance to initiate a bi-directional communication with
    a remote server in the specified port.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，`PortForwarder` 类在本地套接字中接收传入的客户端请求，并将其传递给 `Sender` 类实例，该实例随后使用 `Receiver`
    类实例在指定的端口上与远程服务器建立双向通信。
- en: Pinging hosts on the network with ICMP
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ICMP 对网络上的主机进行ping操作
- en: An ICMP ping is the most common type of network scanning you have ever encountered.
    It is very easy to open a command-line prompt or terminal and type `ping www.google.com`.
    How difficult is that from inside a Python program? This recipe shows you an example
    of a Python ping.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ICMP ping 是您曾经遇到的最常见的网络扫描类型。在命令行提示符或终端中打开并输入 `ping www.google.com` 非常容易。在Python程序内部这样做有多难？这个配方为您展示了Python
    ping的示例。
- en: Getting ready
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need the superuser or administrator privilege to run this recipe on your
    machine.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上具有超级用户或管理员权限才能运行此配方。
- en: How to do it...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You can lazily write a Python script that calls the system ping command-line
    tool, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以懒洋洋地编写一个Python脚本，该脚本调用系统ping命令行工具，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, in many circumstances, the system's ping executable may not be available
    or may be inaccessible. In this case, we need a pure Python script to do that
    ping. Note that this script needs to be run as a superuser or administrator.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在许多情况下，系统的ping可执行文件可能不可用或不可访问。在这种情况下，我们需要一个纯Python脚本来执行ping操作。请注意，此脚本需要以超级用户或管理员身份运行。
- en: 'Listing 3.2 shows the ICMP ping, as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.2显示了如下ICMP ping：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need a `send_ping()` method that will send the data of a ping request to
    the target host. Also, this will call the `do_checksum()` method for checking
    the integrity of the ping data, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个 `send_ping()` 方法，它将ping请求的数据发送到目标主机。此外，这将调用 `do_checksum()` 方法来检查ping数据的完整性，如下所示：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Let us define another method called `ping_once()` that makes a single ping
    call to the target host. It creates a raw ICMP socket by passing the ICMP protocol
    to `socket()`. The exception handling code takes care if the script is not run
    by a superuser or if any other socket error occurs. Let''s take a look at the
    following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义另一个名为 `ping_once()` 的方法，它对目标主机进行单次ping调用。它通过将ICMP协议传递给 `socket()` 创建一个原始的ICMP套接字。异常处理代码负责处理脚本不是以超级用户身份运行或发生任何其他套接字错误的情况。让我们看一下以下代码：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The main executive method of this class is `ping()`. It runs a `for` loop inside
    which the `ping_once()` method is called count times and receives a delay in the
    ping response in seconds. If no delay is returned, that means the ping has failed.
    Let''s take a look at the following code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此类的主体执行方法是 `ping()`。它在一个 `for` 循环内部调用 `ping_once()` 方法 count 次，并接收ping响应的延迟（以秒为单位）。如果没有返回延迟，则表示ping失败。让我们看一下以下代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This script shows the following output. This has been run with the superuser
    privilege:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本显示了以下输出。此脚本以超级用户权限运行：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A `Pinger` class has been constructed to define a few useful methods. The class
    initializes with a few user-defined or default inputs, which are as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 已经构建了一个名为 `Pinger` 的类来定义一些有用的方法。该类使用一些用户定义的或默认的输入进行初始化，如下所示：
- en: '`target_host`: This is the target host to ping'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`target_host`：这是要 ping 的目标主机'
- en: '`count`: This is how many times to do the ping'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`：这是进行 ping 的次数'
- en: '`timeout`: This is the value that determines when to end an unfinished ping
    operation'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timeout`：这是确定何时结束未完成的 ping 操作的值'
- en: The `send_ping()` method gets the DNS hostname of the target host and creates
    an `ICMP_ECHO_REQUEST` packet using the `struct` module. It's necessary to check
    the data integrity of the method using the `do_checksum()` method. It takes the
    source string and manipulates it to produce a proper checksum. On the receiving
    end, the `receive_pong()` method waits for a response until the timeout occurs
    or receives the response. It captures the ICMP response header and then compares
    the packet ID and calculates the delay in the request and response cycle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`send_ping()` 方法获取目标主机的 DNS 主机名并使用 `struct` 模块创建一个 `ICMP_ECHO_REQUEST` 数据包。使用
    `do_checksum()` 方法检查方法的数据完整性是必要的。它接受源字符串并对其进行操作以产生正确的校验和。在接收端，`receive_pong()`
    方法等待响应，直到超时或接收到响应。它捕获 ICMP 响应头，然后比较数据包 ID 并计算请求和响应周期中的延迟。'
- en: Waiting for a remote network service
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待远程网络服务
- en: Sometimes, during the recovery of a network service, it might be useful to run
    a script to check when the server is online again.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络服务恢复期间，有时运行一个脚本来检查服务器何时再次上线可能很有用。
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: We can write a client that will wait for a particular network service forever
    or for a timeout. In this example, by default, we would like to check when a web
    server is up in localhost. If you specified some other remote host or port, that
    information will be used instead.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个客户端，使其永久等待或超时等待特定的网络服务。在这个例子中，默认情况下，我们希望检查本地主机上的 Web 服务器是否启动。如果您指定了其他远程主机或端口，则将使用该信息。
- en: 'Listing 3.3 shows waiting for a remote network service, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 显示了等待远程网络服务，如下所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If a web server, such as Apache, is running on your machine, this script will
    show the following output:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的机器上运行着像 Apache 这样的 Web 服务器，此脚本将显示以下输出：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, stop the Apache process, run this script, and restart Apache again. The
    output pattern will be different. On my machine, the following output pattern
    was found:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，停止 Apache 进程，运行此脚本，然后再次启动 Apache。输出模式将不同。在我的机器上，发现了以下输出模式：
- en: '[PRE13]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following screenshot shows the waiting for an active Apache web server
    process:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了等待一个活动的 Apache Web 服务器进程：
- en: '![How to do it...](img/3463OS_03_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/3463OS_03_02.jpg)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding script uses the `argparse` module to take the user input and process
    the hostname, port, and timeout, that is how long our script will wait for the
    desired network service. It launches an instance of the `NetServiceChecker` class
    and calls the `check()` method. This method calculates the final end time of waiting
    and uses the socket's `settimeout()` method to control each round's end time,
    that is `next_timeout`. It then uses the socket's `connect()` method to test if
    the desired network service is available until the socket timeout occurs. This
    method also catches the socket timeout error and checks the socket timeout against
    the timeout values given by the user.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本使用 `argparse` 模块来获取用户输入并处理主机名、端口和超时，即我们的脚本将等待所需网络服务的时间。它启动 `NetServiceChecker`
    类的一个实例并调用 `check()` 方法。此方法计算等待的最终结束时间，并使用套接字的 `settimeout()` 方法来控制每一轮的结束时间，即 `next_timeout`。然后它使用套接字的
    `connect()` 方法来测试所需的网络服务是否可用，直到套接字超时。此方法还会捕获套接字超时错误，并将套接字超时与用户给出的超时值进行比较。
- en: Enumerating interfaces on your machine
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列举您的机器上的接口
- en: If you need to list the network interfaces present on your machine, it is not
    very complicated in Python. There are a couple of third-party libraries out there
    that can do this job in a few lines. However, let's see how this is done using
    a pure socket call.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要列出机器上存在的网络接口，在 Python 中这并不复杂。有几个第三方库可以在几行内完成这项工作。然而，让我们看看如何使用纯套接字调用完成这项工作。
- en: Getting ready
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'You need to run this recipe on a Linux box. To get the list of available interfaces,
    you can execute the following command:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在 Linux 服务器上运行此脚本。要获取可用接口的列表，您可以执行以下命令：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How to do it...
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Listing 3.4 shows how to list the networking interfaces, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.4展示了如何列出网络接口，如下所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding script will list the network interfaces, as shown in the following
    output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的脚本将列出网络接口，如下所示输出：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe code uses a low-level socket feature to find out the interfaces
    present on the system. The single `list_interfaces()`method creates a socket object
    and finds the network interface information from manipulating this object. It
    does so by making a call to the `fnctl` module's `ioctl()` method. The `fnctl`
    module interfaces with some Unix routines, for example, `fnctl()`. This interface
    performs an I/O control operation on the underlying file descriptor socket, which
    is obtained by calling the `fileno()` method of the socket object.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱代码使用低级套接字功能来找出系统上存在的接口。单个`list_interfaces()`方法创建一个套接字对象，并通过操作此对象来查找网络接口信息。它是通过调用`fnctl`模块的`ioctl()`方法来做到这一点的。`fnctl`模块与一些Unix例程接口，例如`fnctl()`。此接口在底层文件描述符套接字上执行I/O控制操作，该套接字是通过调用套接字对象的`fileno()`方法获得的。
- en: The additional parameter of the `ioctl()` method includes the `SIOCGIFADDR`
    constant defined in the C socket library and a data structure produced by the
    `struct` module's `pack()` function. The memory address specified by a data structure
    is modified as a result of the `ioctl()` call. In this case, the `interface_names`
    variable holds this information. After unpacking the `sock_info` return value
    of the `ioctl()` call, the number of network interfaces is increased twice if
    the size of the data suggests it. This is done in a `while` loop to discover all
    interfaces if our initial interface count assumption is not correct.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ioctl()`方法的附加参数包括在C套接字库中定义的`SIOCGIFADDR`常量和由`struct`模块的`pack()`函数产生的数据结构。数据结构指定的内存地址在`ioctl()`调用后会修改。在这种情况下，`interface_names`变量包含这些信息。在解包`ioctl()`调用的`sock_info`返回值后，如果数据的大小表明需要，网络接口的数量会增加两次。这是通过`while`循环完成的，以发现所有接口，如果我们的初始接口计数假设不正确的话。'
- en: The names of interfaces are extracted from the string format of the `interface_names`
    variable. It reads specific fields of that variable and appends the values in
    the interfaces' list. At the end of the `list_interfaces()` function, this is
    returned.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接口名称是从`interface_names`变量的字符串格式中提取出来的。它读取该变量的特定字段，并将接口列表中的值附加到这些字段上。在`list_interfaces()`函数的末尾，这些信息被返回。
- en: Finding the IP address for a specific interface on your machine
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在您的机器上查找特定接口的IP地址
- en: Finding the IP address of a particular network interface may be needed from
    your Python network application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的Python网络应用程序中，可能需要查找特定网络接口的IP地址。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is prepared exclusively for a Linux box. There are some Python modules
    specially designed to bring similar functionalities on Windows and Mac platforms.
    For example, see [http://sourceforge.net/projects/pywin32/](http://sourceforge.net/projects/pywin32/)
    for Windows-specific implementation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱专门为Linux服务器准备。有一些Python模块专门设计用于在Windows和Mac平台上实现类似的功能。例如，请参阅[http://sourceforge.net/projects/pywin32/](http://sourceforge.net/projects/pywin32/)以获取Windows特定的实现。
- en: How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: You can use the `fnctl` module to query the IP address on your machine.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`fnctl`模块查询您机器上的IP地址。
- en: 'Listing 3.5 shows us how to find the IP address for a specific interface on
    your machine, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.5展示了如何在您的机器上查找特定接口的IP地址，如下所示：
- en: '[PRE17]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output of this script is shown in one line, as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出显示在一行中，如下所示：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'This recipe is similar to the previous one. The preceding script takes a command-line
    argument: the name of the network interface whose IP address is to be known. The
    `get_ip_address()` function creates a socket object and calls the `fnctl.ioctl()`
    function to query on that object about IP information. Note that the `socket.inet_ntoa()`
    function converts the binary data to a human-readable string in a dotted format
    as we are familiar with it.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱与上一个类似。前面的脚本接受一个命令行参数：要查找IP地址的网络接口的名称。`get_ip_address()`函数创建一个套接字对象，并调用`fnctl.ioctl()`函数来查询该对象的IP信息。请注意，`socket.inet_ntoa()`函数将二进制数据转换为人类可读的以点分隔的字符串，正如我们所熟悉的那样。
- en: Finding whether an interface is up on your machine
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找您的机器上某个接口是否已启动
- en: If you have multiple network interfaces on your machine, before doing any work
    on a particular interface, you would like to know the status of that network interface,
    for example, if the interface is actually up. This makes sure that you route your
    command to active interfaces.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你机器上有多个网络接口，在开始对特定接口进行任何操作之前，你可能会想知道该网络接口的状态，例如，接口是否实际上处于开启状态。这确保了你的命令被路由到活动接口。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe is written for a Linux machine. So, this script will not run on
    a Windows or Mac host. In this recipe, we use `nmap`, a famous network scanning
    tool. You can find more about `nmap` from its website [http://nmap.org/](http://nmap.org/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱是为Linux机器编写的。因此，此脚本不会在Windows或Mac主机上运行。在此食谱中，我们使用`nmap`，一个著名的网络扫描工具。你可以从其网站[http://nmap.org/](http://nmap.org/)了解更多关于`nmap`的信息。
- en: 'You also need the `python-nmap` module to run this recipe. This can be installed
    by `pip`, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要`python-nmap`模块来运行此食谱。这可以通过以下方式使用`pip`安装：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can create a socket object and get the IP address of that interface. Then,
    we can use any of the scanning techniques to probe the interface status.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个套接字对象并获取该接口的IP地址。然后，我们可以使用任何扫描技术来探测接口状态。
- en: 'Listing 3.6 shows the detect network interface status, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.6展示了检测网络接口状态，如下所示：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you run this script to inquire the status of the `eth0` status, it will
    show something similar to the following output:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此脚本来查询`eth0`的状态，它将显示类似于以下输出：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The recipe takes the interface's name from the command line and passes it to
    the `get_interface_status()` function. This function finds the IP address of that
    interface by manipulating a UDP socket object.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 该食谱从命令行获取接口名称，并将其传递给`get_interface_status()`函数。此函数通过操作UDP套接字对象来找到该接口的IP地址。
- en: This recipe needs the `nmap` third-party module. We can install that PyPI using
    the `pip` install command. The `nmap` scanning instance, `nm`, has been created
    by calling `PortScanner()`. An initial scan to a local IP address gives us the
    status of the associated network interface.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要`nmap`第三方模块。我们可以使用`pip install`命令安装它。`nmap`扫描实例`nm`是通过调用`PortScanner()`创建的。对本地IP地址的初始扫描为我们提供了相关网络接口的状态。
- en: Detecting inactive machines on your network
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检测网络上的不活跃机器
- en: If you have been given a list of IP addresses of a few machines on your network
    and you are asked to write a script to find out which hosts are inactive periodically,
    you would want to create a network scanner type program without installing anything
    on the target host computers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你被赋予了网络上几台机器的IP地址列表，并且要求你编写一个脚本来找出哪些主机定期不活跃，你将希望创建一个网络扫描程序，而不需要在目标主机计算机上安装任何东西。
- en: Getting ready
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe requires installing the Scapy library (> 2.2), which can be obtained
    at [http://www.secdev.org/projects/scapy/files/scapy-latest.zip](http://www.secdev.org/projects/scapy/files/scapy-latest.zip).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱需要安装Scapy库（> 2.2），可以从[http://www.secdev.org/projects/scapy/files/scapy-latest.zip](http://www.secdev.org/projects/scapy/files/scapy-latest.zip)获取。
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We can use Scapy, a mature network-analyzing, third-party library, to launch
    an ICMP scan. Since we would like to do it periodically, we need Python's `sched`
    module to schedule the scanning tasks.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Scapy，一个成熟的第三方网络分析库，来启动ICMP扫描。由于我们希望定期进行，我们需要Python的`sched`模块来安排扫描任务。
- en: 'Listing 3.7 shows us how to detect inactive machines, as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.7展示了如何检测不活跃机器，如下所示：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output of this script will be something like the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出将类似于以下命令：
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How it works...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding script first takes a list of network hosts, `scan_hosts`, from
    the command line. It then creates a schedule to launch the `detect_inactive_hosts()`
    function after a one-second delay. The target function takes the `scan_hosts`
    argument and calls Scapy's `sr()` function.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本首先从命令行获取网络主机列表`scan_hosts`。然后，它创建一个计划，在延迟一秒后启动`detect_inactive_hosts()`函数。目标函数接受`scan_hosts`参数并调用Scapy的`sr()`函数。
- en: This function schedules itself to rerun after every 10 seconds by calling the
    `schedule.enter()` function once again. This way, we run this scanning task periodically.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数通过再次调用`schedule.enter()`函数来安排自己在每10秒后重新运行。这样，我们就定期运行这个扫描任务。
- en: Scapy's `sr()` scanning function takes an IP, protocol and some scan-control
    information. In this case, the `IP()` method passes `scan_hosts` as the destination
    hosts to scan, and the protocol is specified as ICMP. This can also be TCP or
    UDP. We do not specify a retry and one-second timeout to run this script faster.
    However, you can experiment with the options that suit you.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: Scapy 的 `sr()` 扫描函数接受一个 IP、协议和一些扫描控制信息。在这种情况下，`IP()` 方法将 `scan_hosts` 作为要扫描的目标主机传递，协议指定为
    ICMP。这也可以是 TCP 或 UDP。我们没有指定重试和一秒超时以加快脚本运行速度。然而，你可以尝试适合你的选项。
- en: The scanning `sr()`function returns the hosts that answer and those that don't
    as a tuple. We check the hosts that don't answer, build a list, and print that
    information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描 `sr()` 函数返回响应和未响应的主机作为元组。我们检查未响应的主机，构建一个列表，并打印该信息。
- en: Performing a basic IPC using connected sockets (socketpair)
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用连接套接字（socketpair）执行基本 IPC
- en: Sometimes, two scripts need to communicate some information between themselves
    via two processes. In Unix/Linux, there's a concept of connected socket, of `socketpair`.
    We can experiment with this here.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，两个脚本需要通过两个进程相互之间传递一些信息。在 Unix/Linux 中，有一个连接套接字的概念，即 `socketpair`。我们在这里可以实验一下。
- en: Getting ready
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: This recipe is designed for a Unix/Linux host. Windows/Mac is not suitable for
    running this one.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是为 Unix/Linux 主机设计的。Windows/Mac 不适合运行此配方。
- en: How to do it...
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We use a `test_socketpair()` function to wrap a few lines that test the socket's
    `socketpair()` function.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个 `test_socketpair()` 函数来包装一些测试套接字 `socketpair()` 函数的几行代码。
- en: 'List 3.8 shows an example of `socketpair`, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 展示了 `socketpair` 的一个示例，如下所示：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output from the preceding script is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段脚本的输出如下：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `socket.socketpair()` function simply returns two connected socket objects.
    In our case, we can say that one is a parent and another is a child. We fork another
    process via a `os.fork()` call. This returns the process ID of the parent. In
    each process, the other process' socket is closed first and then a message is
    exchanged via a `sendall()` method call on the process's socket. The try-except
    block prints any error in case of any kind of exception.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`socket.socketpair()` 函数简单地返回两个连接的套接字对象。在我们的例子中，我们可以称其中一个为父进程，另一个为子进程。我们通过
    `os.fork()` 调用创建另一个进程。这会返回父进程的进程 ID。在每个进程中，首先关闭另一个进程的套接字，然后通过进程套接字上的 `sendall()`
    方法调用交换消息。try-except 块在发生任何类型的异常时打印错误。'
- en: Performing IPC using Unix domain sockets
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unix 域套接字执行 IPC
- en: '**Unix domain sockets** (**UDS**) are sometimes used as a convenient way to
    communicate between two processes. As in Unix, everything is conceptually a file.
    If you need an example of such an IPC action, this can be useful.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unix 域套接字**（**UDS**）有时被用作在两个进程之间通信的便捷方式。在 Unix 中，一切概念上都是文件。如果你需要一个此类 IPC
    行动的例子，这可能很有用。'
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We launch a UDS server that binds to a filesystem path, and a UDS client uses
    the same path to communicate with the server.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动一个 UDS 服务器，将其绑定到文件系统路径，UDS 客户端使用相同的路径与服务器通信。
- en: 'Listing 3.9a shows a Unix domain socket server, as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9a 展示了一个 Unix 域套接字服务器，如下所示：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Listing 3.9b shows a UDS client, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9b 展示了一个 UDS 客户端，如下所示：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The server output is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器输出如下：
- en: '[PRE28]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The client output is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端输出如下：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: How it works...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A common path is defined for a UDS client/server to interact. Both the client
    and server use the same path to connect and listen to.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为 UDS 客户端/服务器定义了一个常见的交互路径。客户端和服务器使用相同的路径进行连接和监听。
- en: In a server code, we remove the path if it exists from the previous run of this
    script. It then creates a Unix datagram socket and binds it to the specified path.
    It then listens for incoming connections. In the data processing loop, it uses
    the `recv()` method to get data from the client and prints that information on
    screen.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器代码中，我们删除了之前运行此脚本时存在的路径。然后创建一个 Unix 数据报套接字并将其绑定到指定的路径。然后监听传入的连接。在数据处理循环中，它使用
    `recv()` 方法从客户端获取数据，并在屏幕上打印该信息。
- en: The client-side code simply opens a Unix datagram socket and connects to the
    shared server address. It sends a message to the server using `sendall()`. It
    then waits for the message to be echoed back to itself and prints that message.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端代码简单地打开一个 Unix 数据报套接字，并连接到共享的服务器地址。它使用 `sendall()` 向服务器发送消息。然后它等待消息被回显给自己，并打印那条消息。
- en: Finding out if your Python supports IPv6 sockets
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找你的 Python 是否支持 IPv6 套接字
- en: 'IP version 6 or IPv6 is increasingly adopted by the industry to build newer
    applications. In case you would like to write an IPv6 application, the first thing
    you''d like to know is if your machine supports IPv6\. This can be done from the
    Linux/Unix command line, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: IP版本6或IPv6正越来越被行业采用以构建新的应用程序。如果您想编写IPv6应用程序，您首先想知道的是您的机器是否支持IPv6。这可以通过以下Linux/Unix命令行完成：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From your Python script, you can also check if the IPv6 support is present on
    your machine, and Python is installed with that support.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的Python脚本中，您还可以检查您的机器上是否存在IPv6支持，以及Python是否安装了该支持。
- en: Getting ready
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this recipe, use `pip` to install a Python third-party library, `netifaces`,
    as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此配方，使用`pip`安装Python第三方库`netifaces`，如下所示：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: We can use a third-party library, `netifaces`, to find out if there is IPv6
    support on your machine. We can call the `interfaces()` function from this library
    to list all interfaces present in the system.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用第三方库`netifaces`来检查您的机器上是否有IPv6支持。我们可以从这个库中调用`interfaces()`函数来列出系统中存在的所有接口。
- en: 'Listing 3.10 shows the Python IPv6 support checker, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.10显示了Python IPv6支持检查器，如下所示：
- en: '[PRE32]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output from this script will be as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出将如下所示：
- en: '[PRE33]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following screenshot shows the interaction between the IPv6 client and
    server:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了IPv6客户端和服务器之间的交互：
- en: '![How to do it...](img/3463OS_03_03.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3463OS_03_03.jpg)'
- en: How it works...
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The IPv6 support checker function, `inspect_ipv6_support()`, first checks if
    Python is built with IPv6 using `socket.has_ipv6`. Next, we call the `interfaces()`
    function from the `netifaces` module. This gives us the list of all interfaces.
    If we call the `ifaddresses()` method by passing a network interface to it, we
    can get all the IP addresses of this interface. We then extract various IP-related
    information, such as protocol family, address, netmask, and broadcast address.
    Then, the address of a network interface has been added to the `IPv6_address`
    dictionary if its protocol family matches `AF_INET6`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6支持检查器函数`inspect_ipv6_support()`首先检查Python是否使用`socket.has_ipv6`构建了IPv6。接下来，我们调用`netifaces`模块中的`interfaces()`函数。这为我们提供了所有接口的列表。如果我们通过传递一个网络接口给`ifaddresses()`方法，我们可以获取该接口的所有IP地址。然后，我们提取各种IP相关信息，如协议族、地址、子网掩码和广播地址。然后，如果协议族匹配`AF_INET6`，则将网络接口的地址添加到`IPv6_address`字典中。
- en: Extracting an IPv6 prefix from an IPv6 address
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从IPv6地址中提取IPv6前缀
- en: In your IPv6 application, you need to dig out the IPv6 address for getting the
    prefix information. Note that the upper 64-bits of an IPv6 address are represented
    from a global routing prefix plus a subnet ID, as defined in RFC 3513\. A general
    prefix (for example, /48) holds a short prefix based on which a number of longer,
    more specific prefixes (for example, /64) can be defined. A Python script can
    be very helpful in generating the prefix information.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的IPv6应用程序中，您需要挖掘出IPv6地址以获取前缀信息。请注意，IPv6地址的高64位由全局路由前缀加上子网ID表示，如RFC 3513中定义。一个通用前缀（例如，/48）包含一个基于短前缀的较长、更具体的前缀（例如，/64）。Python脚本在生成前缀信息方面非常有帮助。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We can use the `netifaces` and `netaddr` third-party libraries to find out
    the IPv6 prefix information for a given IPv6 address, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`netifaces`和`netaddr`第三方库来查找给定IPv6地址的IPv6前缀信息，如下所示：
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The output from this script is as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 此脚本的输出如下所示：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Python's `netifaces` module gives us the network interface IPv6 address. It
    uses the `interfaces()` and `ifaddresses()` functions for doing this. The `netaddr`
    module is particularly helpful to manipulate a network address. It has a `IPNetwork()`
    class that provides us with an address, IPv4 or IPv6, and computes the prefix,
    network, and broadcast addresses. Here, we find this information class instance's
    version, prefixlen, and network and broadcast attributes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`netifaces`模块为我们提供了网络接口的IPv6地址。它使用`interfaces()`和`ifaddresses()`函数来完成此操作。`netaddr`模块特别有助于操作网络地址。它有一个`IPNetwork()`类，为我们提供了一个地址，IPv4或IPv6，并计算前缀、网络和广播地址。在这里，我们找到这个信息类实例的版本、前缀长度和网络和广播属性。
- en: Writing an IPv6 echo client/server
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写IPv6 echo客户端/服务器
- en: You need to write an IPv6 compliant server or client and wonder what could be
    the differences between an IPv6 compliant server or client and its IPv4 counterpart.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要编写一个IPv6兼容的服务器或客户端，并想知道IPv6兼容服务器或客户端与其IPv4对应版本之间可能存在的差异。
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: We use the same approach as writing an echo client/server using IPv6\. The only
    major difference is how the socket is created using IPv6 information.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用与使用IPv6编写回显客户端/服务器相同的方法。唯一的重大区别是使用IPv6信息创建套接字的方式。
- en: 'Listing 12a shows an IPv6 echo server, as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12a显示了IPv6回显服务器，如下所示：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Listing 12b shows an IPv6 echo client, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表12b显示了IPv6回显客户端，如下所示：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The server output is as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器输出如下：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The client output is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端输出如下：
- en: '[PRE39]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The IPv6 echo server first determines its IPv6 information by calling `socket.getaddrinfo()`.
    Notice that we passed the `AF_UNSPEC` protocol for creating a TCP socket. The
    resulting information is a tuple of five values. We use three of them, address
    family, socket type, and protocol, to create a server socket. Then, this socket
    is bound with the socket address from the previous tuple. It then listens to the
    incoming connections and accepts them. After a connection is made, it receives
    data from the client and echoes it back.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: IPv6回显服务器首先通过调用`socket.getaddrinfo()`确定其IPv6信息。请注意，我们传递了`AF_UNSPEC`协议来创建TCP套接字。结果信息是一个包含五个值的元组。我们使用其中的三个值，地址族、套接字类型和协议，来创建服务器套接字。然后，这个套接字与之前元组中的套接字地址绑定。接下来，它监听传入的连接并接受它们。一旦建立连接，它从客户端接收数据并将其回显。
- en: On the client-side code, we create an IPv6-compliant client socket instance
    and send the data using the `send()` method of that instance. When the data is
    echoed back, the `recv()` method is used to get it back.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端代码中，我们创建一个符合IPv6规范的客户端套接字实例，并使用该实例的`send()`方法发送数据。当数据被回显回来时，使用`recv()`方法来获取它。
