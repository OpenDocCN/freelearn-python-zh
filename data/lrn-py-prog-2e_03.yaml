- en: Iterating and Making Decisions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代和做决定
- en: '"Insanity: doing the same thing over and over again and expecting different
    results."– Albert Einstein'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: “疯狂：一遍又一遍地做同样的事情，却期待不同的结果。”- 阿尔伯特·爱因斯坦
- en: In the previous chapter, we looked at Python's built-in data types. Now that
    you're familiar with data in its many forms and shapes, it's time to start looking
    at how a program can use it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们看了Python的内置数据类型。现在你已经熟悉了数据的各种形式和形状，是时候开始看看程序如何使用它了。
- en: 'According to Wikipedia:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: In computer science, control flow (or alternatively, flow of control) refers
    to the specification of the order in which the individual statements, instructions
    or function calls of an imperative program are executed or evaluated.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机科学中，控制流（或者叫控制流程）是指规定命令式程序的各个语句、指令或函数调用的执行或评估顺序。
- en: 'In order to control the flow of a program, we have two main weapons: **conditional
    programming** (also known as **branching**) and **looping**. We can use them in
    many different combinations and variations, but in this chapter, instead of going
    through all the possible forms of those two constructs in a *documentation* fashion,
    I''d rather give you the basics and then I''ll write a couple of small scripts
    with you. In the first one, we''ll see how to create a rudimentary prime-number
    generator, while in the second one, we''ll see how to apply discounts to customers
    based on coupons. This way, you should get a better feeling for how conditional
    programming and looping can be used.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了控制程序的流程，我们有两个主要的工具：**条件编程**（也称为**分支**）和**循环**。我们可以以许多不同的组合和变体使用它们，但在本章中，我不打算以*文档*的方式介绍这两个结构的所有可能形式，而是给你一些基础知识，然后和你一起编写一些小脚本。在第一个脚本中，我们将看到如何创建一个简单的素数生成器，而在第二个脚本中，我们将看到如何根据优惠券给顾客打折。这样，你应该更好地了解条件编程和循环如何使用。
- en: 'In this chapter, we are going to cover the following:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Conditional programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件编程
- en: Looping in Python
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的循环
- en: A quick peek at the itertools module
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速浏览`itertools`模块
- en: Conditional programming
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件编程
- en: 'Conditional programming, or branching, is something you do every day, every
    moment. It''s about evaluating conditions: *if the light is green, then I can
    cross;* *if it''s raining, then I''m taking the umbrella;* and *if I''m late for
    work, then I''ll call my manager*.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 条件编程，或者分支，是你每天、每时每刻都在做的事情。它涉及评估条件：*如果交通灯是绿色的，那么我可以过去；* *如果下雨，那么我会带伞；* *如果我上班迟到了，那么我会打电话给我的经理*。
- en: 'The main tool is the `if` statement, which comes in different forms and colors,
    but basically it evaluates an expression and, based on the result, chooses which
    part of the code to execute. As usual, let''s look at an example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主要工具是`if`语句，它有不同的形式和颜色，但基本上它评估一个表达式，并根据结果选择要执行的代码部分。像往常一样，让我们看一个例子：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is possibly the simplest example: when fed to the `if` statement, `late`
    acts as a conditional expression, which is evaluated in a Boolean context (exactly
    like if we were calling `bool(late)`). If the result of the evaluation is `True`,
    then we enter the body of the code immediately after the `if` statement. Notice
    that the `print` instruction is indented: this means it belongs to a scope defined
    by the `if` clause. Execution of this code yields:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是最简单的例子：当传递给`if`语句时，`late`充当条件表达式，在布尔上下文中进行评估（就像我们调用`bool(late)`一样）。如果评估的结果是`True`，那么我们就进入`if`语句后面的代码体。请注意，`print`指令是缩进的：这意味着它属于由`if`子句定义的作用域。执行这段代码会产生：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since `late` is `True`, the `print` statement was executed. Let''s expand on
    this example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`late`是`True`，`print`语句被执行了。让我们扩展一下这个例子：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This time I set `late = False`, so when I execute the code, the result is different:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我设置了`late = False`，所以当我执行代码时，结果是不同的：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Depending on the result of evaluating the `late` expression, we can either enter
    block `#1` or block `#2`, *but not both*. Block `#1` is executed when `late` evaluates
    to `True`, while block `#2` is executed when `late` evaluates to `False`. Try
    assigning `False`/`True` values to the `late` name, and see how the output for
    this code changes accordingly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 根据评估`late`表达式的结果，我们可以进入块`#1`或块`#2`，*但不能同时进入*。当`late`评估为`True`时，执行块`#1`，而当`late`评估为`False`时，执行块`#2`。尝试给`late`名称分配`False`/`True`值，并看看这段代码的输出如何相应地改变。
- en: The preceding example also introduces the `else` clause, which becomes very
    handy when we want to provide an alternative set of instructions to be executed
    when an expression evaluates to `False` within an `if` clause. The else clause
    is optional, as is evident by comparing the preceding two examples.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子还介绍了`else`子句，当我们想要在`if`子句中的表达式评估为`False`时提供一组备用指令时，它非常方便。`else`子句是可选的，通过比较前面的两个例子可以明显看出。
- en: A specialized else – elif
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个专门的else - elif
- en: 'Sometimes all you need is to do something if a condition is met (a simple `if`
    clause). At other times, you need to provide an alternative, in case the condition
    is `False` (`if`/`else` clause), but there are situations where you may have more
    than two paths to choose from, so, since calling the manager (or not calling them)
    is kind of a binary type of example (either you call or you don''t), let''s change
    the type of example and keep expanding. This time, we decide on tax percentages.
    If my income is less than $10,000, I won''t pay any taxes. If it is between $10,000
    and $30,000, I''ll pay 20% in taxes. If it is between $30,000 and $100,000, I''ll
    pay 35% in taxes, and if it''s over $100,000, I''ll (gladly) pay 45% in taxes.
    Let''s put this all down into beautiful Python code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您只需要在满足条件时执行某些操作（简单的`if`子句）。在其他时候，您需要提供一个替代方案，以防条件为`False`（`if`/`else`子句），但有时您可能有更多的选择路径，因此，由于调用经理（或不调用他们）是一种二进制类型的示例（要么您打电话，要么您不打电话），让我们改变示例的类型并继续扩展。这次，我们决定税收百分比。如果我的收入低于$10,000，我将不支付任何税。如果在$10,000和$30,000之间，我将支付20%的税。如果在$30,000和$100,000之间，我将支付35%的税，如果超过$100,000，我将（很高兴）支付45%的税。让我们把这一切都写成漂亮的Python代码：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Executing the preceding code yields:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码产生的结果：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s go through the example line by line: we start by setting up the income
    value. In the example, my income is $15,000\. We enter the `if` clause. Notice
    that this time we also introduced the `elif` clause, which is a contraction of `else-if`,
    and it''s different from a bare `else` clause in that it also has its own condition.
    So, the `if` expression of `income < 10000` evaluates to `False`, therefore block
    `#1` is not executed.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行通过这个例子：我们首先设置收入值。在这个例子中，我的收入是$15,000。我们进入`if`子句。请注意，这一次我们还引入了`elif`子句，它是`else-if`的缩写，与裸的`else`子句不同，它也有自己的条件。因此，`income
    < 10000`的`if`表达式评估为“False”，因此块`#1`不被执行。
- en: 'The control passes to the next condition evaluator: `elif income < 30000`.
    This one evaluates to `True`, therefore block `#2` is executed, and because of
    this, Python then resumes execution after the whole `if`/`elif`/`elif`/`else`
    clause (which we can just call the `if` clause from now on). There is only one
    instruction after the `if` clause, the `print` call, which tells us I will pay
    `3000.0` in taxes this year (*15,000 * 20%*). Notice that the order is mandatory:
    `if` comes first, then (optionally) as many `elif` clauses as you need, and then
    (optionally) an `else` clause.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 控制传递给下一个条件评估器：`elif income < 30000`。这个评估为“True”，因此块`#2`被执行，因此，Python在整个`if`/`elif`/`elif`/`else`子句之后恢复执行（我们现在可以称之为`if`子句）。在`if`子句之后只有一条指令，即`print`调用，它告诉我们今年我将支付`3000.0`的税（*15,000
    * 20%*）。请注意，顺序是强制的：`if`首先出现，然后（可选）是尽可能多的`elif`子句，然后（可选）是一个`else`子句。
- en: Interesting, right? No matter how many lines of code you may have within each
    block, when one of the conditions evaluates to `True`, the associated block is
    executed and then execution resumes after the whole clause. If none of the conditions
    evaluates to `True` (for example, `income = 200000`), then the body of the `else`
    clause would be executed (block `#4`). This example expands our understanding
    of the behavior of the `else` clause. Its block of code is executed when none
    of the preceding `if`/`elif`/.../`elif` expressions has evaluated to `True`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，对吧？无论每个块内有多少行代码，当其中一个条件评估为“True”时，相关的块将被执行，然后在整个子句之后恢复执行。如果没有一个条件评估为“True”（例如，`income
    = 200000`），那么`else`子句的主体将被执行（块`#4`）。这个例子扩展了我们对`else`子句行为的理解。当之前的`if`/`elif`/.../`elif`表达式没有评估为“True”时，它的代码块被执行。
- en: Try to modify the value of `income` until you can comfortably execute all blocks
    at will (one per execution, of course). And then try the **boundaries**. This
    is crucial, whenever you have conditions expressed as **equalities** or **inequalities**
    (`==`, `!=`, `<`, `>`, `<=`, `>=`), those numbers represent boundaries. It is
    essential to test boundaries thoroughly. Should I allow you to drive at 18 or
    17? Am I checking your age with `age < 18`, or `age <= 18`? You can't imagine
    how many times I've had to fix subtle bugs that stemmed from using the wrong operator,
    so go ahead and experiment with the preceding code. Change some `<` to `<=` and
    set income to be one of the boundary values (10,000, 30,000, 100,000) as well
    as any value in between. See how the result changes, and get a good understanding
    of it before proceeding.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改`income`的值，直到您可以随意执行所有块（每次执行一个）。然后尝试**边界**。这是至关重要的，每当您将条件表达为**相等**或**不等**（`==`，`!=`，`<`，`>`，`<=`，`>=`）时，这些数字代表边界。彻底测试边界是至关重要的。我是否允许您在18岁或17岁时开车？我是用`age
    < 18`还是`age <= 18`来检查您的年龄？您无法想象有多少次我不得不修复由于使用错误的运算符而产生的微妙错误，因此继续并尝试修改上述代码。将一些`<`更改为`<=`，并将收入设置为边界值之一（10,000，30,000，100,000）以及之间的任何值。看看结果如何变化，并在继续之前对其有一个很好的理解。
- en: 'Let''s now see another example that shows us how to nest `if` clauses. Say
    your program encounters an error. If the alert system is the console, we print
    the error. If the alert system is an email, we send it according to the severity
    of the error. If the alert system is anything other than console or email, we
    don''t know what to do, therefore we do nothing. Let''s put this into code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看另一个示例，向我们展示如何嵌套`if`子句。假设您的程序遇到错误。如果警报系统是控制台，我们打印错误。如果警报系统是电子邮件，我们根据错误的严重程度发送它。如果警报系统不是控制台或电子邮件之外的任何其他东西，我们不知道该怎么办，因此我们什么也不做。让我们把这写成代码：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding example is quite interesting, because of its silliness. It shows
    us two nested `if` clauses (**outer** and **inner**). It also shows us that the
    outer `if` clause doesn't have any `else`, while the inner one does. Notice how
    indentation is what allows us to nest one clause within another one.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子非常有趣，因为它很愚蠢。它向我们展示了两个嵌套的`if`子句（**外部**和**内部**）。它还向我们展示了外部`if`子句没有任何`else`，而内部`if`子句有。请注意，缩进是允许我们将一个子句嵌套在另一个子句中的原因。
- en: If `alert_system == 'console'`, body `#1` is executed, and nothing else happens.
    On the other hand, if `alert_system == 'email'`, then we enter into another `if`
    clause, which we called inner. In the inner `if` clause, according to `error_severity`,
    we send an email to either an admin, first-level support, or second-level support
    (blocks `#2`, `#3`, and `#4`). The `send_email` function is not defined in this
    example, therefore trying to run it would give you an error. In the source code
    of the book, which you can download from the website, I included a trick to redirect
    that call to a regular `print` function, just so you can experiment on the console
    without actually sending an email. Try changing the values and see how it all
    works.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`alert_system == 'console'`，则执行`#1`部分，其他情况则不执行。另一方面，如果`alert_system == 'email'`，那么我们进入另一个`if`子句，我们称之为内部。在内部`if`子句中，根据`error_severity`，我们向管理员、一级支持或二级支持发送电子邮件（块`#2`，`#3`和`#4`）。在此示例中未定义`send_email`函数，因此尝试运行它会导致错误。在本书的源代码中，您可以从网站下载，我包含了一个技巧，将该调用重定向到常规的`print`函数，这样您就可以在控制台上进行实验，而不必实际发送电子邮件。尝试更改值，看看它是如何工作的。
- en: The ternary operator
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'One last thing I would like to show you, before moving on to the next subject,
    is the **ternary operator** or, in layman''s terms, the short version of an `if`/`else`
    clause. When the value of a name is to be assigned according to some condition,
    sometimes it''s easier and more readable to use the ternary operator instead of
    a proper `if` clause. In the following example, the two code blocks do exactly
    the same thing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在转移到下一个主题之前，我想向您展示的最后一件事是**三元运算符**，或者通俗地说，是`if`/`else`子句的简短版本。当根据某个条件来分配名称的值时，有时使用三元运算符而不是适当的`if`子句更容易阅读。在下面的示例中，两个代码块完全做同样的事情：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For simple cases like this, I find it very nice to be able to express that logic
    in one line instead of four. Remember, as a coder, you spend much more time reading
    code than writing it, so Python's conciseness is invaluable.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样简单的情况，我发现能够用一行代码来表达这种逻辑非常好，而不是用四行。记住，作为编码人员，您花在阅读代码上的时间远远多于编写代码的时间，因此Python的简洁性是无价的。
- en: Are you clear on how the ternary operator works? Basically, `name = something
    if condition else something-else`. So `name` is assigned `something` if `condition`
    evaluates to `True`, and `something-else` if `condition` evaluates to `False`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您清楚三元运算符是如何工作的吗？基本上，`name = something if condition else something-else`。因此，如果`condition`评估为`True`，则`name`被分配为`something`，如果`condition`评估为`False`，则为`something-else`。
- en: 'Now that you know everything about controlling the path of the code, let''s
    move on to the next subject: *looping*.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了如何控制代码的路径，让我们继续下一个主题：*循环*。
- en: Looping
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 循环
- en: If you have any experience with looping in other programming languages, you
    will find Python's way of looping a bit different. First of all, what is looping?
    **Looping** means being able to repeat the execution of a code block more than
    once, according to the loop parameters we're given. There are different looping
    constructs, which serve different purposes, and Python has distilled all of them
    down to just two, which you can use to achieve everything you need. These are
    the `for` and `while` statements.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在其他编程语言中有循环的经验，您会发现Python的循环方式有些不同。首先，什么是循环？**循环**意味着能够根据给定的循环参数多次重复执行代码块。有不同的循环结构，它们有不同的目的，Python已将它们全部简化为只有两种，您可以使用它们来实现您需要的一切。这些是`for`和`while`语句。
- en: While it's definitely possible to do everything you need using either of them,
    they serve different purposes and therefore they're usually used in different
    contexts. We'll explore this difference thoroughly in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用它们中的任何一个都可以做你需要做的一切，但它们有不同的目的，因此它们通常在不同的上下文中使用。我们将在本章中深入探讨这种差异。
- en: The for loop
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`for`循环'
- en: 'The `for` loop is used when looping over a sequence, such as a list, tuple,
    or a collection of objects. Let''s start with a simple example and expand on the
    concept to see what the Python syntax allows us to do:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当循环遍历序列时，例如列表、元组或对象集合时，使用`for`循环。让我们从一个简单的示例开始，扩展概念，看看Python语法允许我们做什么：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This simple snippet of code, when executed, prints all numbers from `0` to `4`.
    The `for` loop is fed the list `[0, 1, 2, 3, 4]` and at each iteration, `number`
    is given a value from the sequence (which is iterated sequentially, in order),
    then the body of the loop is executed (the print line). The `number` value changes
    at every iteration, according to which value is coming next from the sequence.
    When the sequence is exhausted, the `for` loop terminates, and the execution of
    the code resumes normally with the code after the loop.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这段简单的代码片段在执行时打印从`0`到`4`的所有数字。`for`循环接收到列表`[0, 1, 2, 3, 4]`，在每次迭代时，`number`从序列中获得一个值（按顺序迭代），然后执行循环体（打印行）。`number`的值在每次迭代时都会更改，根据序列中接下来的值。当序列耗尽时，`for`循环终止，代码的执行在循环后恢复正常。
- en: Iterating over a range
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历范围
- en: 'Sometimes we need to iterate over a range of numbers, and it would be quite
    unpleasant to have to do so by hardcoding the list somewhere. In such cases, the
    `range` function comes to the rescue. Let''s see the equivalent of the previous
    snippet of code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们需要遍历一系列数字，将其硬编码到某个地方将会很不方便。在这种情况下，`range`函数就派上用场了。让我们看看前面代码片段的等价物：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `range` function is used extensively in Python programs when it comes to
    creating sequences: you can call it by passing one value, which acts as `stop`
    (counting from `0`), or you can pass two values (`start` and `stop`), or even
    three (`start`, `stop`, and `step`). Check out the following example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python程序中，`range`函数在创建序列时被广泛使用：您可以通过传递一个值来调用它，该值充当`stop`（从`0`开始计数），或者您可以传递两个值（`start`和`stop`），甚至三个值（`start`，`stop`和`step`）。查看以下示例：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the moment, ignore that we need to wrap `range(...)` within a `list`. The
    `range` object is a little bit special, but in this case, we''re just interested
    in understanding what values it will return to us. You can see that the deal is
    the same with slicing: `start` is included, `stop` excluded, and optionally you
    can add a `step` parameter, which by default is `1`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时忽略我们需要在`range(...)`内部包装一个`list`。`range`对象有点特殊，但在这种情况下，我们只对了解它将向我们返回什么值感兴趣。您可以看到，切片的处理方式与之相同：`start`包括在内，`stop`排除在外，还可以添加一个`step`参数，其默认值为`1`。
- en: Try modifying the parameters of the `range()` call in our `simple.for.py` code
    and see what it prints. Get comfortable with it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试修改我们的`simple.for.py`代码中`range()`调用的参数，并查看它打印出什么。熟悉它。
- en: Iterating over a sequence
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在序列上进行迭代
- en: 'Now we have all the tools to iterate over a sequence, so let''s build on that
    example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了迭代序列的所有工具，所以让我们在此基础上构建示例：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code adds a little bit of complexity to the game. Execution will
    show this result:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码给游戏增加了一点复杂性。执行将显示此结果：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s use the **inside-out** technique to break it down, OK? We start from
    the innermost part of what we''re trying to understand, and we expand outward.
    So, `len(surnames)` is the length of the `surnames` list: `3`. Therefore, `range(len(surnames))`
    is actually transformed into `range(3)`. This gives us the range [0, 3), which
    is basically a sequence (`0`, `1`, `2`). This means that the `for` loop will run
    three iterations. In the first one, `position` will take value `0`, while in the
    second one, it will take value `1`, and finally value `2` in the third and last
    iteration. What is (`0`, `1`, `2`), if not the possible indexing positions for
    the `surnames` list? At position `0`, we find `''Rivest''`, at position `1`, `''Shamir''`,
    and at position `2`, `''Adleman''`. If you are curious about what these three
    men created together, change `print(position, surnames[position])` to `print(surnames[position][0],
    end='''')`, add a final `print()` outside of the loop, and run the code again.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用**从内到外**的技术来分解它，好吗？我们从我们试图理解的最内部部分开始，然后向外扩展。因此，`len(surnames)`是`surnames`列表的长度：`3`。因此，`range(len(surnames))`实际上被转换为`range(3)`。这给我们提供了范围[0,
    3)，基本上是一个序列（`0`，`1`，`2`）。这意味着`for`循环将运行三次迭代。在第一次迭代中，`position`将取值`0`，而在第二次迭代中，它将取值`1`，最后在第三次和最后一次迭代中取值`2`。如果不是`surnames`列表的可能索引位置（`0`，`1`，`2`），那是什么？在位置`0`，我们找到`'Rivest'`，在位置`1`，`'Shamir'`，在位置`2`，`'Adleman'`。如果您对这三个人一起创造了什么感到好奇，请将`print(position,
    surnames[position])`更改为`print(surnames[position][0], end='')`，在循环之外添加最后一个`print()`，然后再次运行代码。
- en: 'Now, this style of looping is actually much closer to languages such as Java
    or C++. In Python, it''s quite rare to see code like this. You can just iterate
    over any sequence or collection, so there is no need to get the list of positions
    and retrieve elements out of a sequence at each iteration. It''s expensive, needlessly
    expensive. Let''s change the example into a more Pythonic form:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这种循环的风格实际上更接近于Java或C++等语言。在Python中，很少见到这样的代码。您可以只是迭代任何序列或集合，因此没有必要在每次迭代时获取位置列表并从序列中检索元素。这是昂贵的，没有必要的昂贵。让我们将示例改为更符合Python风格的形式：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now that's something! It's practically English. The `for` loop can iterate over
    the `surnames` list, and it gives back each element in order at each interaction.
    Running this code will print the three surnames, one at a time. It's much easier
    to read, right?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这就是了！它几乎是英语。`for`循环可以在`surnames`列表上进行迭代，并且在每次交互中按顺序返回每个元素。运行此代码将逐个打印出三个姓氏。阅读起来更容易，对吧？
- en: 'What if you wanted to print the position as well though? Or what if you actually
    needed it? Should you go back to the `range(len(...))` form? No. You can use the
    `enumerate` built-in function, like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您想要打印位置呢？或者如果您实际上需要它呢？您应该回到`range(len(...))`形式吗？不。您可以使用`enumerate`内置函数，就像这样：
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code is very interesting as well. Notice that enumerate gives back a two-tuple
    `(position, surname)` at each iteration, but still, it's much more readable (and
    more efficient) than the `range(len(...))` example. You can call `enumerate` with
    a `start` parameter, such as `enumerate(iterable, start)`, and it will start from
    `start`, rather than `0`. Just another little thing that shows you how much thought
    has been given in designing Python so that it makes your life easier.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也非常有趣。请注意，`enumerate`在每次迭代时都会返回一个两元组（`position，surname`），但仍然比`range(len(...))`示例更可读（更有效）。您可以使用`start`参数调用`enumerate`，例如`enumerate(iterable,
    start)`，它将从`start`开始，而不是`0`。这只是另一件小事，向您展示了Python在设计时考虑了多少，以便使您的生活更轻松。
- en: You can use a `for` loop to iterate over lists, tuples, and in general anything
    that Python calls iterable. This is a very important concept, so let's talk about
    it a bit more.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`for`循环来迭代列表、元组和一般Python称为可迭代的任何东西。这是一个非常重要的概念，所以让我们再谈一谈。
- en: Iterators and iterables
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代器和可迭代对象
- en: 'According to the Python documentation ([https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)),
    an iterable is:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python文档（[https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)）的说法，可迭代对象是：
- en: An object capable of returning its members one at a time. Examples of iterables
    include all sequence types (such as list, str, and tuple) and some non-sequence
    types like dict, file objects, and objects of any classes you define with an __iter__()
    or __getitem__() method. Iterables can be used in a for loop and in many other
    places where a sequence is needed (zip(), map(), ...). When an iterable object
    is passed as an argument to the built-in function iter(), it returns an iterator
    for the object. This iterator is good for one pass over the set of values. When
    using iterables, it is usually not necessary to call iter() or deal with iterator
    objects yourself. The for statement does that automatically for you, creating
    a temporary unnamed variable to hold the iterator for the duration of the loop.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 能够逐个返回其成员的对象。可迭代对象的示例包括所有序列类型（如列表、str和元组）和一些非序列类型，如字典、文件对象和您使用__iter__()或__getitem__()方法定义的任何类的对象。可迭代对象可以在for循环和许多其他需要序列的地方使用（zip()、map()等）。当将可迭代对象作为参数传递给内置函数iter()时，它会返回该对象的迭代器。该迭代器对值集合进行一次遍历。在使用可迭代对象时，通常不需要调用iter()或自己处理迭代器对象。for语句会自动为您执行这些操作，为循环的持续时间创建一个临时的无名变量来保存迭代器。
- en: 'Simply put, what happens when you write `for k in sequence: ... body ...`,
    is that the `for` loop asks `sequence` for the next element, it gets something
    back, it calls that something `k`, and then executes its body. Then, once again,
    the `for` loop asks `sequence` for the next element, it calls it `k` again, and
    executes the body again, and so on and so forth, until the sequence is exhausted.
    Empty sequences will result in zero executions of the body.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '简而言之，当你写`for k in sequence: ... body ...`时，`for`循环会向`sequence`请求下一个元素，它会得到一些返回值，将返回值称为`k`，然后执行其主体。然后，再次，`for`循环会向`sequence`请求下一个元素，再次将其称为`k`，并再次执行主体，依此类推，直到序列耗尽。空序列将导致主体执行零次。'
- en: Some data structures, when iterated over, produce their elements in order, such
    as lists, tuples, and strings, while some others don't, such as sets and dictionaries
    (prior to Python 3.6). Python gives us the ability to iterate over iterables,
    using a type of object called an **iterator**.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据结构在进行迭代时按顺序产生它们的元素，例如列表、元组和字符串，而另一些则不会，例如集合和字典（Python 3.6之前）。Python让我们能够迭代可迭代对象，使用一种称为**迭代器**的对象类型。
- en: 'According to the official documentation ([https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)),
    an iterator is:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方文档（[https://docs.python.org/3/glossary.html](https://docs.python.org/3/glossary.html)）的说法，迭代器是：
- en: An object representing a stream of data. Repeated calls to the iterator's __next__()
    method (or passing it to the built-in function next()) return successive items
    in the stream. When no more data are available a StopIteration exception is raised
    instead. At this point, the iterator object is exhausted and any further calls
    to its __next__() method just raise StopIteration again. Iterators are required
    to have an __iter__() method that returns the iterator object itself so every
    iterator is also iterable and may be used in most places where other iterables
    are accepted. One notable exception is code which attempts multiple iteration
    passes. A container object (such as a list) produces a fresh new iterator each
    time you pass it to the iter() function or use it in a for loop. Attempting this
    with an iterator will just return the same exhausted iterator object used in the
    previous iteration pass, making it appear like an empty container.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代表数据流的对象。对迭代器的__next__()方法进行重复调用（或将其传递给内置函数next()）会返回数据流中的连续项目。当没有更多数据可用时，会引发StopIteration异常。此时，迭代器对象已耗尽，对其__next__()方法的任何进一步调用都会再次引发StopIteration。迭代器需要具有一个返回迭代器对象本身的__iter__()方法，因此每个迭代器也是可迭代的，并且可以在大多数其他可接受可迭代对象的地方使用。一个值得注意的例外是尝试多次迭代传递的代码。容器对象（如列表）每次将其传递给iter()函数或在for循环中使用时都会产生一个全新的迭代器。尝试对迭代器执行此操作将只返回上一次迭代传递中使用的相同耗尽的迭代器对象，使其看起来像一个空容器。
- en: Don't worry if you don't fully understand all the preceding legalese, you will
    in due time. I put it here as a handy reference for the future.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不完全理解前面的法律术语，不要担心，你以后会理解的。我把它放在这里作为将来的方便参考。
- en: In practice, the whole iterable/iterator mechanism is somewhat hidden behind
    the code. Unless you need to code your own iterable or iterator for some reason,
    you won't have to worry about this too much. But it's very important to understand
    how Python handles this key aspect of control flow because it will shape the way
    you will write your code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，整个可迭代/迭代器机制在代码后面有些隐藏。除非出于某种原因需要编写自己的可迭代或迭代器，否则你不必过多担心这个问题。但是理解Python如何处理这一关键的控制流方面非常重要，因为它将塑造你编写代码的方式。
- en: Iterating over multiple sequences
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遍历多个序列
- en: 'Let''s see another example of how to iterate over two sequences of the same
    length, in order to work on their respective elements in pairs. Say we have a
    list of people and a list of numbers representing the age of the people in the
    first list. We want to print a pair person/age on one line for all of them. Let''s
    start with an example and let''s refine it gradually:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个例子，如何迭代两个相同长度的序列，以便处理它们各自的元素对。假设我们有一个人员列表和一个代表第一个列表中人员年龄的数字列表。我们想要打印所有人员的姓名/年龄对。让我们从一个例子开始，然后逐渐完善它：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'By now, this code should be pretty straightforward for you to understand. We
    need to iterate over the list of positions (`0`, `1`, `2`, `3`) because we want
    to retrieve elements from two different lists. Executing it we get the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这段代码对你来说应该很容易理解。我们需要遍历位置列表（`0`，`1`，`2`，`3`），因为我们想要从两个不同的列表中检索元素。执行后，我们得到以下结果：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code is both inefficient and not Pythonic. It''s inefficient because retrieving
    an element given the position can be an expensive operation, and we''re doing
    it from scratch at each iteration. The postal worker doesn''t go back to the beginning
    of the road each time they deliver a letter, right? They move from house to house.
    From one to the next one. Let''s try to make it better using `enumerate`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码既低效又不符合Python风格。它是低效的，因为根据位置检索元素可能是一个昂贵的操作，并且我们在每次迭代时都是从头开始做的。邮递员在递送信件时不会每次都回到路的起点，对吧？他们从一户到另一户。让我们尝试使用`enumerate`使其更好：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'That''s better, but still not perfect. And it''s still a bit ugly. We''re iterating
    properly on `people`, but we''re still fetching `age` using positional indexing,
    which we want to lose as well. Well, no worries, Python gives you the `zip` function,
    remember? Let''s use it:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做更好，但还不完美。而且还有点丑陋。我们在`people`上进行了适当的迭代，但仍然使用位置索引获取`age`，我们也想要摆脱。别担心，Python给了你`zip`函数，记得吗？让我们使用它：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ah! So much better! Once again, compare the preceding code with the first example
    and admire Python''s elegance. The reason I wanted to show this example is twofold.
    On the one hand, I wanted to give you an idea of how shorter code in Python can
    be compared to other languages where the syntax doesn''t allow you to iterate
    over sequences or collections as easily. And on the other hand, and much more
    importantly, notice that when the `for` loop asks `zip(sequenceA, sequenceB)`
    for the next element, it gets back a tuple, not just a single object. It gets
    back a tuple with as many elements as the number of sequences we feed to the `zip`
    function. Let''s expand a little on the previous example in two ways, using explicit
    and implicit assignment:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 啊！好多了！再次将前面的代码与第一个示例进行比较，并欣赏Python的优雅之处。我想展示这个例子的原因有两个。一方面，我想让您了解Python中较短的代码与其他语言相比有多么简洁，其他语言的语法不允许您像这样轻松地迭代序列或集合。另一方面，更重要的是，请注意，当`for`循环请求`zip(sequenceA,
    sequenceB)`的下一个元素时，它会得到一个元组，而不仅仅是一个单一对象。它会得到一个元组，其中包含与我们提供给`zip`函数的序列数量一样多的元素。让我们通过两种方式扩展前面的示例，使用显式和隐式赋值：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the preceding code, we added the nationalities list. Now that we feed three
    sequences to the `zip` function, the for loop gets back a *three-tuple* at each
    iteration. Notice that the position of the elements in the tuple respects the
    position of the sequences in the `zip` call. Executing the code will yield the
    following result:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们添加了国籍列表。现在我们向`zip`函数提供了三个序列，for循环在每次迭代时都会返回一个*三元组*。请注意，元组中元素的位置与`zip`调用中序列的位置相对应。执行代码将产生以下结果：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Sometimes, for reasons that may not be clear in a simple example such as the
    preceding one, you may want to explode the tuple within the body of the `for`
    loop. If that is your desire, it''s perfectly possible to do so:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，由于在前面的简单示例中可能不太清楚的原因，您可能希望在`for`循环的主体中分解元组。如果这是您的愿望，完全可以做到：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'It''s basically doing what the `for` loop does automatically for you, but in
    some cases you may want to do it yourself. Here, the three-tuple `data` that comes
    from `zip(...)` is exploded within the body of the `for` loop into three variables:
    `person`, `age`, and `nationality`.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上是在某些情况下自动为您执行`for`循环的操作，但是在某些情况下，您可能希望自己执行。在这里，来自`zip(...)`的三元组`data`在`for`循环的主体中被分解为三个变量：`person`、`age`和`nationality`。
- en: The while loop
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: while循环
- en: In the preceding pages, we saw the `for` loop in action. It's incredibly useful
    when you need to loop over a sequence or a collection. The key point to keep in
    mind, when you need to be able to discriminate which looping construct to use,
    is that the `for` loop rocks when you have to iterate over a finite amount of
    elements. It can be a huge amount, but still, something that ends at some point.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的页面中，我们看到了`for`循环的运行情况。当您需要循环遍历一个序列或集合时，它非常有用。需要记住的关键点是，当您需要能够区分使用哪种循环结构时，`for`循环在必须迭代有限数量的元素时非常有效。它可以是一个巨大的数量，但是仍然是在某个点结束的东西。
- en: There are other cases though, when you just need to loop until some condition
    is satisfied, or even loop indefinitely until the application is stopped, such
    as cases where we don't really have something to iterate on, and therefore the
    `for` loop would be a poor choice. But fear not, for these cases, Python provides
    us with the `while` loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有其他情况，当您只需要循环直到满足某个条件，甚至无限循环直到应用程序停止时，例如我们实际上没有东西可以迭代，因此`for`循环将是一个不好的选择。但是不用担心，对于这些情况，Python为我们提供了`while`循环。
- en: The `while` loop is similar to the `for` loop, in that they both loop, and at
    each iteration they execute a body of instructions. What is different between
    them is that the `while` loop doesn't loop over a sequence (it can, but you have
    to write the logic manually and it wouldn't make any sense, you would just want
    to use a `for` loop), rather, it loops as long as a certain condition is satisfied.
    When the condition is no longer satisfied, the loop ends.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环类似于`for`循环，因为它们都循环，并且在每次迭代时执行一组指令。它们之间的不同之处在于`while`循环不会循环遍历一个序列（它可以，但您必须手动编写逻辑，而且这没有任何意义，您只想使用`for`循环），而是只要满足某个条件就会循环。当条件不再满足时，循环结束。'
- en: 'As usual, let''s see an example that will clarify everything for us. We want
    to print the binary representation of a positive number. In order to do so, we
    can use a simple algorithm that collects the remainders of division by `2` (in
    reverse order), and that turns out to be the binary representation of the number
    itself:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，让我们看一个示例，以便更好地理解。我们想要打印一个正数的二进制表示。为了做到这一点，我们可以使用一个简单的算法，它收集除以`2`的余数（以相反的顺序），结果就是数字本身的二进制表示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s write some code to calculate the binary representation for the number
    39: 100111[2]:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来计算数字39的二进制表示：100111[2]：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the preceding code, I highlighted `n > 0`, which is the condition to keep
    looping. We can make the code a little shorter (and more Pythonic), by using the
    `divmod` function, which is called with a number and a divisor, and returns a
    tuple with the result of the integer division and its remainder. For example,
    `divmod(13, 5)` would return `(2, 3)`, and indeed *5 * 2 + 3 = 13*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我突出显示了`n > 0`，这是保持循环的条件。我们可以通过使用`divmod`函数使代码变得更短（更符合Python风格），该函数使用一个数字和一个除数调用，并返回一个包含整数除法结果及其余数的元组。例如，`divmod(13,
    5)`将返回`(2, 3)`，确实*5 * 2 + 3 = 13*：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding code, we have reassigned `n` to the result of the division
    by `2`, and the remainder, in one single line.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们已经将`n`重新分配为除以`2`的结果，并在一行中得到了余数。
- en: Notice that the condition in a `while` loop is a condition to continue looping.
    If it evaluates to `True`, then the body is executed and then another evaluation
    follows, and so on, until the condition evaluates to `False`. When that happens,
    the loop is exited immediately without executing its body.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在`while`循环中的条件是继续循环的条件。如果评估为`True`，则执行主体，然后进行另一个评估，依此类推，直到条件评估为`False`。当发生这种情况时，循环立即退出，而不执行其主体。
- en: 'If the condition never evaluates to `False`, the loop becomes a so-called **infinite
    loop**. Infinite loops are used, for example, when polling from network devices:
    you ask the socket whether there is any data, you do something with it if there
    is any, then you sleep for a small amount of time, and then you ask the socket
    again, over and over again, without ever stopping.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果条件永远不会评估为`False`，则循环变成所谓的**无限循环**。无限循环用于例如从网络设备轮询：您询问套接字是否有任何数据，如果有任何数据，则对其进行某些操作，然后您休眠一小段时间，然后再次询问套接字，一遍又一遍，永远不停止。
- en: Having the ability to loop over a condition, or to loop indefinitely, is the
    reason why the `for` loop alone is not enough, and therefore Python provides the
    `while` loop.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有循环条件或无限循环的能力，这就是为什么仅使用`for`循环是不够的原因，因此Python提供了`while`循环。
- en: By the way, if you need the binary representation of a number, check out the
    `bin` function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，如果您需要数字的二进制表示，请查看`bin`函数。
- en: 'Just for fun, let''s adapt one of the examples (`multiple.sequences.py`) using
    the while logic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 只是为了好玩，让我们使用`while`逻辑来调整一个例子（`multiple.sequences.py`）：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, I have highlighted the *initialization*, *condition*,
    and *update* of the `position` variable, which makes it possible to simulate the
    equivalent `for` loop code by handling the iteration variable manually. Everything
    that can be done with a `for` loop can also be done with a `while` loop, even
    though you can see there's a bit of boilerplate you have to go through in order
    to achieve the same result. The opposite is also true, but unless you have a reason
    to do so, you ought to use the right tool for the job, and 99.9% of the time you'll
    be fine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我突出显示了`position`变量的*初始化*、*条件*和*更新*，这使得可以通过手动处理迭代变量来模拟等效的`for`循环代码。所有可以使用`for`循环完成的工作也可以使用`while`循环完成，尽管您可以看到为了实现相同的结果，您需要经历一些样板文件。反之亦然，但除非您有理由这样做，否则您应该使用正确的工具来完成工作，99.9%的时间您都会没问题。
- en: So, to recap, use a `for` loop when you need to iterate over an iterable, and
    a `while` loop when you need to loop according to a condition being satisfied
    or not. If you keep in mind the difference between the two purposes, you will
    never choose the wrong looping construct.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总结一下，当您需要遍历可迭代对象时，请使用`for`循环，当您需要根据满足或不满足的条件循环时，请使用`while`循环。如果您记住了两种目的之间的区别，您将永远不会选择错误的循环结构。
- en: Let's now see how to alter the normal flow of a loop.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何改变循环的正常流程。
- en: The break and continue statements
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中断和继续语句
- en: According to the task at hand, sometimes you will need to alter the regular
    flow of a loop. You can either skip a single iteration (as many times as you want),
    or you can break out of the loop entirely. A common use case for skipping iterations
    is, for example, when you're iterating over a list of items and you need to work
    on each of them only if some condition is verified. On the other hand, if you're
    iterating over a collection of items, and you have found one of them that satisfies
    some need you have, you may decide not to continue the loop entirely and therefore
    break out of it. There are countless possible scenarios, so it's better to see
    a couple of examples.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 根据手头的任务，有时您需要改变循环的常规流程。您可以跳过单个迭代（任意次数），或者完全退出循环。跳过迭代的常见用例是，例如，当您遍历项目列表并且只有在验证了某些条件时才需要处理每个项目时。另一方面，如果您正在遍历项目集，并且找到了满足您某些需求的项目，您可能决定不继续整个循环，因此退出循环。有无数种可能的情况，因此最好看一些例子。
- en: 'Let''s say you want to apply a 20% discount to all products in a basket list
    for those that have an expiration date of today. The way you achieve this is to
    use the `continue` statement, which tells the looping construct (`for` or `while`)
    to stop execution of the body immediately and go to the next iteration, if any.
    This example will take us a little deeper down the rabbit hole, so be ready to
    jump:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您想对购物篮列表中所有今天到期的产品应用20%的折扣。您实现这一点的方式是使用`continue`语句，它告诉循环结构（`for`或`while`）立即停止执行主体并继续下一个迭代（如果有的话）。这个例子将带我们深入了解，所以准备好跳下去：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We start by importing the `date` and `timedelta` objects, then we set up our
    products. Those with `sku` as `1` and `3` have an expiration date of `today`,
    which means we want to apply a 20% discount on them. We loop over each `product`
    and we inspect the expiration date. If it is not (inequality operator, `!=`) `today`,
    we don't want to execute the rest of the body suite, so we `continue`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入`date`和`timedelta`对象，然后设置我们的产品。`sku`为`1`和`3`的产品具有“今天”的到期日期，这意味着我们希望对它们应用20%的折扣。我们遍历每个产品并检查到期日期。如果它不是（不等运算符，`!=`）“今天”，我们不希望执行其余的主体套件，因此我们`continue`。
- en: 'Notice that it is not important where in the body suite you place the `continue`
    statement (you can even use it more than once). When you reach it, execution stops
    and goes back to the next iteration. If we run the `discount.py` module, this
    is the output:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在代码块中放置`continue`语句的位置并不重要（甚至可以使用多次）。当到达它时，执行停止并返回到下一次迭代。如果我们运行`discount.py`模块，这是输出：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows you that the last two lines of the body haven't been executed for
    `sku` number `2`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这向你展示了循环体的最后两行没有被执行，对于`sku`编号`2`。
- en: 'Let''s now see an example of breaking out of a loop. Say we want to tell whether
    at least one of the elements in a list evaluates to `True` when fed to the `bool`
    function. Given that we need to know whether there is at least one, when we find
    it, we don''t need to keep scanning the list any further. In Python code, this
    translates to using the `break` statement. Let''s write this down into code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看一个中断循环的例子。假设我们想要判断列表中的至少一个元素在传递给`bool`函数时是否评估为`True`。鉴于我们需要知道是否至少有一个，当我们找到它时，就不需要继续扫描列表。在Python代码中，这意味着使用`break`语句。让我们把这写成代码：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The preceding code is such a common pattern in programming, you will see it
    a lot. When you inspect items this way, basically what you do is to set up a `flag`
    variable, then start the inspection. If you find one element that matches your
    criteria (in this example, that evaluates to `True`), then you update the flag
    and stop iterating. After iteration, you inspect the flag and take action accordingly.
    Execution yields:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在编程中是一个常见的模式，你会经常看到它。当你以这种方式检查项目时，基本上你是设置一个`flag`变量，然后开始检查。如果你找到一个符合你标准的元素（在这个例子中，评估为`True`），然后你更新标志并停止迭代。迭代后，你检查标志并相应地采取行动。执行结果是：
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See how execution stopped after `True` was found? The `break` statement acts
    exactly like the `continue` one, in that it stops executing the body of the loop
    immediately, but also, prevents any other iteration from running, effectively
    breaking out of the loop. The `continue` and `break` statements can be used together
    with no limitation in their numbers, both in the `for` and `while` looping constructs.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 看到了吗？在找到`True`后执行停止了吗？`break`语句的作用与`continue`相同，即立即停止循环体的执行，但也阻止其他迭代运行，有效地跳出循环。`continue`和`break`语句可以在`for`和`while`循环结构中一起使用，数量上没有限制。
- en: By the way, there is no need to write code to detect whether there is at least
    one element in a sequence that evaluates to `True`. Just check out the built-in `any` function.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，没有必要编写代码来检测序列中是否至少有一个元素评估为`True`。只需查看内置的`any`函数。
- en: A special else clause
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特殊的else子句
- en: One of the features I've seen only in the Python language is the ability to
    have `else` clauses after `while` and `for` loops. It's very rarely used, but
    it's definitely nice to have. In short, you can have an `else` suite after a `for`
    or `while` loop. If the loop ends normally, because of exhaustion of the iterator
    (`for` loop) or because the condition is finally not met (`while` loop), then
    the `else` suite (if present) is executed. In case execution is interrupted by
    a `break` statement, the `else` clause is not executed. Let's take an example
    of a `for` loop that iterates over a group of items, looking for one that would
    match some condition. In case we don't find at least one that satisfies the condition,
    we want to raise an **exception**. This means we want to arrest the regular execution
    of the program and signal that there was an error, or exception, that we cannot
    deal with. Exceptions will be the subject of [Chapter 8](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe),
    *Testing, Profiling, and Dealing with Exceptions*, so don't worry if you don't
    fully understand them now. Just bear in mind that they will alter the regular
    flow of the code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我在Python语言中看到的一个特性是在`while`和`for`循环后面有`else`子句的能力。它很少被使用，但绝对是一个不错的功能。简而言之，你可以在`for`或`while`循环后面有一个`else`代码块。如果循环正常结束，因为迭代器耗尽（`for`循环）或者因为条件最终不满足（`while`循环），那么`else`代码块（如果存在）会被执行。如果执行被`break`语句中断，`else`子句就不会被执行。让我们来看一个`for`循环的例子，它遍历一组项目，寻找一个满足某些条件的项目。如果我们找不到至少一个满足条件的项目，我们想要引发一个**异常**。这意味着我们想要中止程序的正常执行，并且表示出现了一个错误或异常，我们无法处理。异常将在[第8章](part0211.html#6976M0-2ddb708647cc4530a187c2c6c0e9acfe)中讨论，*测试、分析和处理异常*，所以如果你现在不完全理解它们，不用担心。只要记住它们会改变代码的正常流程。
- en: 'Let me now show you two examples that do exactly the same thing, but one of
    them is using the special `for...else` syntax. Say that we want to find, among
    a collection of people, one that could drive a car:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我向你展示两个做同样事情的例子，但其中一个使用了特殊的`for...else`语法。假设我们想在一群人中找到一个能开车的人：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice the `flag` pattern again. We set the driver to be `None`, then if we
    find one, we update the `driver` flag, and then, at the end of the loop, we inspect
    it to see whether one was found. I kind of have the feeling that those kids would
    drive a very *metallic* car, but anyway, notice that if a driver is not found, `DriverException`
    is raised, signaling to the program that execution cannot continue (we're lacking
    the driver).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意`flag`模式。我们将驾驶员设置为`None`，然后如果我们找到一个，我们会更新`driver`标志，然后在循环结束时检查它是否找到了。我有一种感觉，那些孩子可能会开一辆非常*金属感*的车，但无论如何，请注意，如果找不到驾驶员，将会引发`DriverException`，向程序表示执行无法继续（我们缺少驾驶员）。
- en: 'The same functionality can be rewritten a bit more elegantly using the following
    code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的功能可以使用以下代码更加优雅地重写：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we aren't forced to use the `flag` pattern any more. The exception
    is raised as part of the `for` loop logic, which makes good sense because the
    `for` loop is checking on some condition. All we need is to set up a `driver`
    object in case we find one, because the rest of the code is going to use that
    information somewhere. Notice the code is shorter and more elegant, because the
    logic is now correctly grouped together where it belongs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不再被迫使用`flag`模式。异常是作为`for`循环逻辑的一部分引发的，这是合理的，因为`for`循环正在检查某些条件。我们只需要在找到一个时设置一个`driver`对象，因为代码的其余部分将在某个地方使用该信息。请注意，代码更短、更优雅，因为逻辑现在正确地组合在一起。
- en: 'In the *Transforming Code into Beautiful, Idiomatic Python* video, Raymond
    Hettinger suggests a much better name for the `else` statement associated with
    a for loop: `nobreak`. If you struggle remembering how the `else` works for a
    `for` loop, simply remembering this fact should help you.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在*将代码转换为优美、成语化的Python*视频中，Raymond Hettinger建议为与for循环关联的`else`语句取一个更好的名字：`nobreak`。如果你在记住`else`在`for`循环中的工作原理方面有困难，只需记住这个事实就应该能帮助你。
- en: Putting all this together
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 把所有这些放在一起
- en: Now that you have seen all there is to see about conditionals and loops, it's
    time to spice things up a little, and look at those two examples I anticipated
    at the beginning of this chapter. We'll mix and match here, so you can see how
    you can use all these concepts together. Let's start by writing some code to generate
    a list of prime numbers up to some limit. Please bear in mind that I'm going to
    write a very inefficient and rudimentary algorithm to detect primes. The important
    thing for you is to concentrate on those bits in the code that belong to this
    chapter's subject.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了关于条件和循环的所有内容，是时候稍微调剂一下，看看我在本章开头预期的那两个例子。我们将在这里混合搭配，这样你就可以看到如何将所有这些概念结合起来使用。让我们先写一些代码来生成一个质数列表，直到某个限制为止。请记住，我将写一个非常低效和基本的算法来检测质数。对你来说重要的是集中精力关注代码中属于本章主题的部分。
- en: A prime generator
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 质数生成器
- en: 'According to Wikipedia:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科：
- en: A prime number (or a prime) is a natural number greater than 1 that has no positive
    divisors other than 1 and itself. A natural number greater than 1 that is not
    a prime number is called a composite number.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 质数（或质数）是大于1的自然数，除了1和它本身之外没有其他正因子。大于1的自然数如果不是质数，则称为合数。
- en: 'Based on this definition, if we consider the first 10 natural numbers, we can
    see that 2, 3, 5, and 7 are primes, while 1, 4, 6, 8, 9, and 10 are not. In order
    to have a computer tell you whether a number, *N*, is prime, you can divide that
    number by all natural numbers in the range [2, *N*). If any of those divisions
    yields zero as a remainder, then the number is not a prime. Enough chatter, let''s
    get down to business. I''ll write two versions of this, the second of which will
    exploit the `for...else` syntax:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，如果我们考虑前10个自然数，我们可以看到2、3、5和7是质数，而1、4、6、8、9和10不是。为了让计算机告诉你一个数*N*是否是质数，你可以将该数除以范围[2，*N*)内的所有自然数。如果其中任何一个除法的余数为零，那么这个数就不是质数。废话够多了，让我们开始吧。我将写两个版本，第二个版本将利用`for...else`语法：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There are a lot of things to notice in the preceding code. First of all, we
    set up an empty `primes` list, which will contain the primes at the end. The limit
    is `100`, and you can see it's inclusive in the way we call `range()` in the outer
    loop. If we wrote `range(2, upto)` that would be *[2, upto)*, right? Therefore
    `range(2, upto + 1)` gives us *[2, upto + 1) == [2, upto]*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中有很多需要注意的事情。首先，我们设置了一个空的`primes`列表，它将在最后包含质数。限制是`100`，你可以看到我们在外部循环中调用`range()`的方式是包容的。如果我们写`range(2,
    upto)`，那么是*[2, upto)*，对吧？因此`range(2, upto + 1)`给我们*[2, upto + 1) == [2, upto]*。
- en: So, there are two `for` loops. In the outer one, we loop over the candidate
    primes, that is, all natural numbers from `2` to `upto`. Inside each iteration
    of this outer loop, we set up a flag (which is set to `True` at each iteration),
    and then start dividing the current `n` by all numbers from `2` to `n - 1`. If
    we find a proper divisor for `n`, it means `n` is composite, and therefore we
    set the flag to `False` and break the loop. Notice that when we break the inner
    one, the outer one keeps on going normally. The reason why we break after having
    found a proper divisor for `n` is that we don't need any further information to
    be able to tell that `n` is not a prime.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有两个`for`循环。在外部循环中，我们循环遍历候选质数，即从`2`到`upto`的所有自然数。在外部循环的每次迭代中，我们设置一个标志（在每次迭代时设置为`True`），然后开始将当前的`n`除以从`2`到`n-1`的所有数字。如果我们找到`n`的一个适当的除数，那么意味着`n`是合数，因此我们将标志设置为`False`并中断循环。请注意，当我们中断内部循环时，外部循环会继续正常进行。我们之所以在找到`n`的适当除数后中断，是因为我们不需要任何进一步的信息就能判断`n`不是质数。
- en: When we check on the `is_prime` flag, if it is still `True`, it means we couldn't
    find any number in [2, *n*) that is a proper divisor for `n`, therefore `n` is
    a prime. We append `n` to the `primes` list, and hop! Another iteration proceeds,
    until `n` equals `100`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查`is_prime`标志时，如果它仍然是`True`，这意味着我们在[2，*n*)中找不到任何是`n`的适当除数的数字，因此`n`是质数。我们将`n`添加到`primes`列表中，然后继续下一个迭代，直到`n`等于`100`。
- en: 'Running this code yields:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这段代码会产生：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Before we proceed, one question: of all the iterations of the outer loop, one
    of them is different from all the others. Could you tell which one, and why? Think
    about it for a second, go back to the code, try to figure it out for yourself,
    and then keep reading on.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，有一个问题：在外部循环的所有迭代中，其中一个与其他所有迭代不同。你能告诉哪一个，以及为什么吗？想一想，回到代码，试着自己找出答案，然后继续阅读。
- en: 'Did you figure it out? If not, don''t feel bad, it''s perfectly normal. I asked
    you to do it as a small exercise because it''s what coders do all the time. The
    skill to understand what the code does by simply looking at it is something you
    build over time. It''s very important, so try to exercise it whenever you can.
    I''ll tell you the answer now: the iteration that behaves differently from all
    others is the first one. The reason is because in the first iteration, `n` is
    `2`. Therefore the innermost `for` loop won''t even run, because it''s a `for`
    loop that iterates over `range(2, 2)`, and what is that if not [2, 2)? Try it
    out for yourself, write a simple `for` loop with that iterable, put a `print`
    in the body suite, and see whether anything happens (it won''t...).'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你弄清楚了吗？如果没有，不要感到难过，这是完全正常的。我让你做这个小练习，因为这是程序员一直在做的事情。通过简单地查看代码来理解代码的功能是您随着时间建立的技能。这非常重要，所以尽量在您能做到的时候进行练习。我现在告诉你答案：与所有其他迭代不同的是第一个迭代。原因是因为在第一次迭代中，`n`是`2`。因此，最内层的`for`循环甚至不会运行，因为它是一个迭代`range(2,
    2)`的`for`循环，那不就是[2, 2)吗？自己试一下，用这个可迭代对象编写一个简单的`for`循环，将`print`放在主体套件中，看看是否会发生任何事情（不会...）。
- en: 'Now, from an algorithmic point of view, this code is inefficient, so let''s
    at least make it more beautiful:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从算法的角度来看，这段代码是低效的，所以让我们至少让它更美观一些：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Much nicer, right? The `is_prime` flag is gone, and we append `n` to the `primes`
    list when we know the inner `for` loop hasn't encountered any `break` statements.
    See how the code looks cleaner and reads better?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 漂亮多了，对吧？`is_prime`标志消失了，当我们知道内部`for`循环没有遇到任何`break`语句时，我们将`n`附加到`primes`列表中。看看代码看起来更清晰，阅读起来更好了吗？
- en: Applying discounts
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用折扣
- en: 'In this example, I want to show you a technique I like a lot. In many programming
    languages, other than the `if`/`elif`/`else` constructs, in whatever form or syntax
    they may come, you can find another statement, usually called `switch`/`case`,
    that in Python is missing. It is the equivalent of a cascade of `if`/`elif`/.../`elif`/`else`
    clauses, with a syntax similar to this (warning! JavaScript code!):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我想向你展示一种我非常喜欢的技术。在许多编程语言中，除了`if`/`elif`/`else`结构之外，无论以什么形式或语法，你都可以找到另一个语句，通常称为`switch`/`case`，在Python中缺少。它相当于一系列`if`/`elif`/.../`elif`/`else`子句，其语法类似于这样（警告！JavaScript代码！）：
- en: '[PRE36]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the preceding code, we `switch` on a variable called `day_number`. This
    means we get its value and then we decide what case it fits in (if any). From
    `1` to `5` there is a cascade, which means no matter the number, [`1`, `5`] all
    go down to the bit of logic that sets `day` as `"Weekday"`. Then we have single
    cases for `0` and `6`, and a `default` case to prevent errors, which alerts the
    system that `day_number` is not a valid day number, that is, not in [`0`, `6`].
    Python is perfectly capable of realizing such logic using `if`/`elif`/`else` statements:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们根据名为`day_number`的变量进行`switch`。这意味着我们获取它的值，然后决定它适用于哪种情况（如果有的话）。从`1`到`5`有一个级联，这意味着无论数字如何，[`1`，`5`]都会进入将`day`设置为“工作日”的逻辑部分。然后我们有`0`和`6`的单个情况，以及一个`default`情况来防止错误，它会提醒系统`day_number`不是有效的日期数字，即不在[`0`，`6`]中。Python完全能够使用`if`/`elif`/`else`语句实现这样的逻辑：
- en: '[PRE38]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the preceding code, we reproduce the same logic of the JavaScript snippet
    in Python, using `if`/`elif`/`else` statements. I raised the `ValueError` exception
    just as an example at the end, if `day_number` is not in [`0`, `6`]. This is one
    possible way of translating the `switch`/`case` logic, but there is also another
    one, sometimes called dispatching, which I will show you in the last version of
    the next example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用`if`/`elif`/`else`语句在Python中复制了JavaScript片段的相同逻辑。我最后提出了`ValueError`异常，如果`day_number`不在[`0`，`6`]中，这只是一个例子。这是将`switch`/`case`逻辑转换的一种可能方式，但还有另一种方式，有时称为分派，我将在下一个示例的最后版本中向您展示。
- en: By the way, did you notice the first line of the previous snippet? Have you
    noticed that Python can make double (actually, even multiple) comparisons? It's
    just wonderful!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你有没有注意到前面片段的第一行？你有没有注意到Python可以进行双重（实际上甚至多重）比较？这太棒了！
- en: 'Let''s start the new example by simply writing some code that assigns a discount
    to customers based on their coupon value. I''ll keep the logic down to a minimum
    here, remember that all we really care about is understanding conditionals and
    loops:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过简单地编写一些代码来开始新的示例，根据客户的优惠券价值为他们分配折扣。我会尽量保持逻辑的最低限度，记住我们真正关心的是理解条件和循环：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We start by setting up some customers. They have an order total, a coupon code,
    and an ID. I made up four different types of coupons, two are fixed and two are
    percentage-based. You can see that in the `if`/`elif`/`else` cascade I apply the
    discount accordingly, and I set it as a `'discount'` key in the `customer` dictionary.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先设置一些客户。他们有订单总额、优惠券代码和ID。我编造了四种不同类型的优惠券，两种是固定的，两种是基于百分比的。你可以看到，在`if`/`elif`/`else`级联中，我相应地应用折扣，并将其设置为`customer`字典中的`'discount'`键。
- en: 'At the end, I just print out part of the data to see whether my code is working
    properly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我只打印出部分数据，看看我的代码是否正常工作：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code is simple to understand, but all those clauses are kind of cluttering
    the logic. It''s not easy to see what''s going on at a first glance, and I don''t
    like it. In cases like this, you can exploit a dictionary to your advantage, like
    this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很容易理解，但所有这些子句有点混乱。一眼看上去很难看出发生了什么，我不喜欢。在这种情况下，你可以利用字典来发挥你的优势，就像这样：
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Running the preceding code yields exactly the same result we had from the snippet
    before it. We spared two lines, but more importantly, we gained a lot in readability,
    as the body of the `for` loop now is just three lines long, and very easy to understand.
    The concept here is to use a dictionary as a **dispatcher**. In other words, we
    try to fetch something from the dictionary based on a code (our `coupon_code`),
    and by using `dict.get(key, default)`, we make sure we also cater for when the
    `code` is not in the dictionary and we need a default value.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码产生了与之前片段相同的结果。我们节省了两行，但更重要的是，我们在可读性上获得了很多好处，因为`for`循环的主体现在只有三行，而且非常容易理解。这里的概念是将字典用作**分发器**。换句话说，我们尝试从字典中根据代码（我们的`coupon_code`）获取一些东西，并通过`dict.get(key,
    default)`，我们确保当`code`不在字典中时，我们也需要一个默认值。
- en: Notice that I had to apply some very simple linear algebra in order to calculate
    the discount properly. Each discount has a percentage and fixed part in the dictionary,
    represented by a two-tuple. By applying `percent * total + fixed`, we get the
    correct discount. When `percent` is `0`, the formula just gives the fixed amount,
    and it gives `percent * total` when fixed is `0`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我必须应用一些非常简单的线性代数来正确计算折扣。字典中的每个折扣都有一个百分比和固定部分，由一个二元组表示。通过应用`percent * total
    + fixed`，我们得到正确的折扣。当`percent`为`0`时，该公式只给出固定金额，当固定为`0`时，它给出`percent * total`。
- en: This technique is important because it is also used in other contexts, with
    functions, where it actually becomes much more powerful than what we've seen in
    the preceding snippet. Another advantage of using it is that you can code it in
    such a way that the keys and values of the `discounts` dictionary are fetched
    dynamically (for example, from a database). This will allow the code to adapt
    to whatever discounts and conditions you have, without having to modify anything.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术很重要，因为它也用在其他情境中，比如函数，它实际上比我们在前面片段中看到的要强大得多。使用它的另一个优势是，你可以以这样的方式编码，使得`discounts`字典的键和值可以动态获取（例如，从数据库中获取）。这将使代码能够适应你所拥有的任何折扣和条件，而无需修改任何内容。
- en: If it's not completely clear to you how it works, I suggest you take your time
    and experiment with it. Change values and add print statements to see what's going
    on while the program is running.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不完全明白它是如何工作的，我建议你花点时间来试验一下。更改值并添加打印语句，看看程序运行时发生了什么。
- en: A quick peek at the itertools module
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速浏览itertools模块
- en: A chapter about iterables, iterators, conditional logic, and looping wouldn't
    be complete without a few words about the `itertools` module. If you are into
    iterating, this is a kind of heaven.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 关于可迭代对象、迭代器、条件逻辑和循环的章节，如果没有提到`itertools`模块，就不完整了。如果你喜欢迭代，这是一种天堂。
- en: 'According to the Python official documentation ([https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)),
    the `itertools` module is:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Python官方文档（[https://docs.python.org/2/library/itertools.html](https://docs.python.org/2/library/itertools.html)），`itertools`模块是：
- en: This module which implements a number of iterator building blocks inspired by
    constructs from APL, Haskell, and SML. Each has been recast in a form suitable
    for Python. The module standardizes a core set of fast, memory efficient tools
    that are useful by themselves or in combination. Together, they form an “iterator
    algebra” making it possible to construct specialized tools succinctly and efficiently
    in pure Python.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块实现了一些受APL、Haskell和SML构造启发的迭代器构建块。每个都已经被重塑成适合Python的形式。该模块标准化了一组核心的快速、内存高效的工具，这些工具本身或组合在一起都很有用。它们一起形成了一个“迭代器代数”，使得可以在纯Python中简洁高效地构建专门的工具。
- en: By no means do I have the room here to show you all the goodies you can find
    in this module, so I encourage you to go check it out for yourself, I promise
    you'll enjoy it. In a nutshell, it provides you with three broad categories of
    iterators. I will give you a very small example of one iterator taken from each
    one of them, just to make your mouth water a little.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我无法向你展示这个模块中所有的好东西，所以我鼓励你自己去查看，我保证你会喜欢的。简而言之，它为您提供了三种广泛的迭代器类别。我将给你一个非常小的例子，来自每一个迭代器，只是为了让你稍微流口水。
- en: Infinite iterators
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无限迭代器
- en: 'Infinite iterators allow you to work with a `for` loop in a different fashion,
    such as if it were a `while` loop:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 无限迭代器允许您以不同的方式使用`for`循环，就像它是一个`while`循环一样：
- en: '[PRE42]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Running the code gives this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会得到这个结果：
- en: '[PRE43]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `count` factory class makes an iterator that just goes on and on counting.
    It starts from `5` and keeps adding `3` to it. We need to break it manually if
    we don't want to get stuck in an infinite loop.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`工厂类创建一个迭代器，它只是不断地计数。它从`5`开始，然后不断加`3`。如果我们不想陷入无限循环，我们需要手动中断它。'
- en: Iterators terminating on the shortest input sequence
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在最短输入序列上终止的迭代器
- en: 'This category is very interesting. It allows you to create an iterator based
    on multiple iterators, combining their values according to some logic. The key
    point here is that among those iterators, in case any of them are shorter than
    the rest, the resulting iterator won''t break, it will simply stop as soon as
    the shortest iterator is exhausted. This is very theoretical, I know, so let me
    give you an example using `compress`. This iterator gives you back the data according
    to a corresponding item in a selector being `True` or `False`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别非常有趣。它允许您基于多个迭代器创建一个迭代器，根据某种逻辑组合它们的值。关键点在于，在这些迭代器中，如果有任何一个比其余的短，那么生成的迭代器不会中断，它将在最短的迭代器耗尽时停止。这非常理论化，我知道，所以让我用`compress`给你举个例子。这个迭代器根据选择器中的相应项目是`True`还是`False`，给你返回数据：
- en: '`compress(''ABC'', (1, 0, 1))` would give back `''A''` and `''C''`, because
    they correspond to `1`. Let''s see a simple example:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`compress(''ABC'', (1, 0, 1))`会返回`''A''`和`''C''`，因为它们对应于`1`。让我们看一个简单的例子：'
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Notice that `odd_selector` and `even_selector` are 20 elements long, while
    `data` is just 10 elements long. `compress` will stop as soon as `data` has yielded
    its last element. Running this code produces the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`odd_selector`和`even_selector`的长度为20个元素，而`data`只有10个元素。`compress`将在`data`产生最后一个元素时停止。运行此代码会产生以下结果：
- en: '[PRE45]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It's a very fast and nice way of selecting elements out of an iterable. The
    code is very simple, just notice that instead of using a `for` loop to iterate
    over each value that is given back by the compress calls, we used `list()`, which
    does the same, but instead of executing a body of instructions, puts all the values
    into a list and returns it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常快速和方便的从可迭代对象中选择元素的方法。代码非常简单，只需注意，我们使用`list()`而不是使用`for`循环来迭代压缩调用返回的每个值，`list()`做的事情是一样的，但是它不执行一系列指令，而是将所有的值放入一个列表并返回它。
- en: Combinatoric generators
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合生成器
- en: Last but not least, combinatoric generators. These are really fun, if you are
    into this kind of thing. Let's just see a simple example on permutations.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但并非最不重要的，组合生成器。如果你对这种事情感兴趣，这些真的很有趣。让我们看一个关于排列的简单例子。
- en: 'According to Wolfram Mathworld:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Wolfram Mathworld：
- en: A permutation, also called an "arrangement number" or "order", is a rearrangement
    of the elements of an ordered list S into a one-to-one correspondence with S itself.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 排列，也称为“排列数”或“顺序”，是有序列表S的元素重新排列成与S本身一一对应的过程。
- en: 'For example, there are six permutations of ABC: ABC, ACB, BAC, BCA, CAB, and
    CBA.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，ABC有六种排列：ABC，ACB，BAC，BCA，CAB和CBA。
- en: 'If a set has *N* elements, then the number of permutations of them is *N!*
    (*N* factorial). For the ABC string, the permutations are *3! = 3 * 2 * 1 = 6*.
    Let''s do it in Python:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个集合有*N*个元素，那么它们的排列数就是*N!*（*N*的阶乘）。对于ABC字符串，排列数为*3! = 3 * 2 * 1 = 6*。让我们用Python来做一下：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This very short snippet of code produces the following result:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这段非常简短的代码产生了以下结果：
- en: '[PRE47]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Be very careful when you play with permutations. Their number grows at a rate
    that is proportional to the factorial of the number of the elements you're permuting,
    and that number can get really big, really fast.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你玩排列时要非常小心。它们的数量增长速度与你进行排列的元素的阶乘成正比，而这个数字可能会变得非常大，非常快。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we've taken another step toward expanding our coding vocabulary.
    We've seen how to drive the execution of the code by evaluating conditions, and
    we've seen how to loop and iterate over sequences and collections of objects.
    This gives us the power to control what happens when our code is run, which means
    we are getting an idea of how to shape it so that it does what we want and it
    reacts to data that changes dynamically.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们又迈出了一步，扩展了我们的编码词汇。我们已经看到如何通过评估条件来驱动代码的执行，以及如何循环和迭代序列和对象集合。这赋予了我们控制代码运行时发生的事情的能力，这意味着我们正在了解如何塑造代码，使其按照我们的意愿进行操作，并对动态变化的数据做出反应。
- en: We've also seen how to combine everything together in a couple of simple examples,
    and in the end, we took a brief look at the `itertools` module, which is full
    of interesting iterators that can enrich our abilities with Python even more.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还看到了如何在几个简单的例子中将所有东西结合在一起，最后，我们简要地看了一下`itertools`模块，这个模块充满了有趣的迭代器，可以进一步丰富我们使用Python的能力。
- en: Now it's time to switch gears, take another step forward, and talk about functions.
    The next chapter is all about them because they are extremely important. Make
    sure you're comfortable with what has been covered up to now. I want to provide
    you with interesting examples, so I'll have to go a little faster. Ready? Turn
    the page.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候换个方式，向前迈进一步，谈谈函数。下一章将全面讨论它们，因为它们非常重要。确保你对到目前为止所涵盖的内容感到舒适。我想为你提供有趣的例子，所以我将不得不加快速度。准备好了吗？翻页吧。
