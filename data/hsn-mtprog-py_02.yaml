- en: '*Chapter 1*: The Need for and Applications of Metaprogramming'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：元编程的需求与应用'
- en: '*Metaprogramming with Python* is a practical guide to learning metaprogramming
    in Python.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用Python进行元编程*是学习Python元编程的实用指南。'
- en: In today’s programming world, Python is considered one of the easiest languages
    to learn and use to develop useful applications. Understanding the programming
    concepts and applying them is easier in Python compared to any other programming
    language. A Python program can be written simply by adding existing libraries
    and making use of their inbuilt methods. At the same time, the language also has
    many powerful features that can help in developing robust libraries and applications.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的编程世界中，Python被认为是学习和使用最简单、开发有用应用程序最方便的语言之一。在Python中理解编程概念并将其应用比其他任何编程语言都更容易。一个Python程序可以通过添加现有库并利用其内置方法来简单地编写。同时，该语言还具有许多强大的功能，可以帮助开发健壮的库和应用。
- en: This book covers the need for one of the most advanced features in Python, called
    metaprogramming, along with insights into its practical applications. Understanding
    the concepts of metaprogramming helps in tapping into the advanced features of
    Python 3 and knowing where to apply them to make Python code more reusable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了Python中最先进的功能之一——元编程的需求，以及对其实际应用的见解。理解元编程的概念有助于挖掘Python 3的高级功能，并了解在哪里应用它们以使Python代码更具可重用性。
- en: Unlike the regular Python-based application development that follows object-oriented
    programming, metaprogramming covers certain advanced concepts of Python that deal
    with manipulating the programmable objects of Python, such as its classes, methods,
    functions, and variables. Throughout this book, we will look at applications and
    examples that help in understanding these concepts in a user-friendly manner.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与遵循面向对象编程的常规Python应用程序开发不同，元编程涵盖了Python的一些高级概念，这些概念涉及操作Python的可编程对象，例如其类、方法、函数和变量。在本书中，我们将探讨一些应用和示例，以帮助用户以用户友好的方式理解这些概念。
- en: 'In this chapter, we will provide an introduction to metaprogramming and the
    need to perform metaprogramming using Python 3\. We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍元编程以及使用Python 3进行元编程的需求。我们将涵盖以下主题：
- en: An overview of metaprogramming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元编程概述
- en: Understanding why we need metaprogramming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么我们需要元编程
- en: Exploring the applications of metaprogramming
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索元编程的应用
- en: By the end of this chapter, you will have a high-level understanding of metaprogramming
    in Python 3, the need for using it, and know of a few practical examples where
    it can be applied.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将对Python 3中的元编程有一个高级理解，了解使用它的需求，并知道一些实际的应用示例。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code examples in this chapter are available on GitHub repository for this
    chapter at [https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例可在GitHub仓库中找到，该仓库地址为[https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01](https://github.com/PacktPublishing/Metaprogramming-with-Python/tree/main/Chapter01)。
- en: An overview of metaprogramming
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程概述
- en: '**Metaprogramming** is a concept widely heard of in other programming languages
    such as C++, Java, .NET, and Ruby but not so widely heard of in Python. Python
    is a programming language that is easy to learn for beginners to programming and
    efficient to implement for advanced programmers. Therefore, it has an additional
    advantage in improving efficiency and optimization while developing high-performance
    applications when techniques such as metaprogramming are blended with the process
    of application development.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**元编程**是一个在C++、Java、.NET和Ruby等其他编程语言中广泛听说，但在Python中并不那么广泛听说的概念。Python是一种易于编程初学者学习且对高级程序员高效实现的编程语言。因此，它在将元编程等技术与开发过程相结合时，具有提高效率和优化的额外优势。'
- en: In this book, we will deep dive into the concepts of metaprogramming using Python
    3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将深入探讨使用Python 3的元编程概念。
- en: The term **meta**, as the name suggests, is a process that references itself
    or its the high-level information. In the context of programming, metaprogramming
    also describes the similar concept of a program referencing itself or a program
    object referencing itself. A program referencing itself or its entity gives data
    on the program or the programming entity that can be used at various levels to
    perform activities, such as transformations or manipulations, in a programming
    language.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**元**，正如其名，是一个引用自身或其高级信息的进程。在编程的上下文中，元编程也描述了程序引用自身或程序对象引用自身的类似概念。程序引用自身或其实体提供了有关程序或编程实体的数据，这些数据可以在各种级别上用于执行活动，如转换或操作。
- en: 'To understand the term **meta**, let’s consider the term *metadata*. As an
    example, let’s look at a Python DataFrame. For those who are not familiar with
    the term DataFrame, we can use the term *table*. The one shown in the following
    screenshot is called *Employee Data*:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解术语**元**，让我们考虑术语*元数据*。例如，让我们看看一个Python DataFrame。对于那些不熟悉术语DataFrame的人来说，我们可以使用术语*表*。以下截图显示的是称为*Employee
    Data*的表：
- en: '![Figure 1.1 – Employee Data table ](img/B13426_01_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – 员工数据表](img/B13426_01_01.jpg)'
- en: Figure 1.1 – Employee Data table
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 员工数据表
- en: This Employee Data table consists of employee information such as the name of
    the employee, employee ID, qualification, experience, salary, and so on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此员工数据表包含员工信息，如员工姓名、员工ID、资格、经验、薪资等。
- en: All of this information are attributes of single or multiple employees, and
    it is the data of employees in an organization. So, what will the metadata be?
    The **m****etadata** is the data of how employee data is stored in the Employee
    Data table.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都是单个或多个员工的属性，它是组织中员工的资料。那么，元数据是什么呢？**元元数据**是员工数据在员工数据表中存储的数据。
- en: 'The metadata for the Employee Data table defines how each column and its values
    are stored in the table. For example, in the following screenshot, we can see
    metadata where **Name** is stored as a string with a length of 64 characters,
    while **Salary** is stored as a **Float** with a length of 12 digits:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 员工数据表的元数据定义了每个列及其值在表中是如何存储的。例如，在以下截图中，我们可以看到**Name**作为长度为64个字符的字符串存储，而**Salary**作为长度为12位的**Float**存储：
- en: '![Figure 1.2 – Metadata representation for the Employee Data table ](img/B13426_01_02.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 员工数据表的元数据表示](img/B13426_01_02.jpg)'
- en: Figure 1.2 – Metadata representation for the Employee Data table
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 员工数据表的元数据表示
- en: Accessing, modifying, transforming, and updating the Employee Data table using
    information such as the name or ID of an employee is data manipulation, while
    accessing, modifying, transforming, and updating the data type or size of the
    column name or employee ID or salary, is metadata manipulation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 使用员工姓名或ID等信息访问、修改、转换和更新员工数据表是数据操作，而访问、修改、转换和更新列名或员工ID或薪资的数据类型或大小是元数据操作。
- en: With this understanding, let’s look at an example of metaprogramming.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种理解，让我们看看元编程的一个例子。
- en: Metaprogramming – a practical introduction
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元编程 – 实用介绍
- en: Any programming language that can be used to write code to perform actions consists
    of a basic unit or piece of code that can be written to perform an action. This
    is known as a function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 任何可以用来编写执行动作的代码的编程语言都包含一个基本单元或代码片段，可以编写以执行动作。这被称为函数。
- en: 'If we have two numbers stored in two variables, `a` and `b`, to perform an
    `add` action, you can simply add those two numbers by writing a function, as shown
    in the following code block:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在两个变量`a`和`b`中存储两个数字，要执行`add`动作，你可以简单地通过编写一个函数来添加这两个数字，如下面的代码块所示：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, if we execute this code, it can go through different scenarios, depending
    on the input data provided to the `add` function. Let’s take a close look at each
    of them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们执行此代码，它可以通过`add`函数提供的输入数据执行不同的场景。让我们逐一仔细看看它们。
- en: '**Scenario 1**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景 1**'
- en: 'Running the `add` function with two integers would result in two numbers being
    added together, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个整数运行`add`函数会导致两个数字相加，如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Scenario 2**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景 2**'
- en: 'Running the `add` function with two strings would result in the concatenation
    of two words, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个字符串运行`add`函数会导致两个单词的连接，如下所示：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Scenario 3**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景 3**'
- en: 'Let’s take a look at running the `add` function with one string and one integer:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看运行`add`函数时一个字符串和一个整数的情况：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding code would result in the following error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将导致以下错误：
- en: '![Figure 1.3 – TypeError ](img/B13426_01_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图1.3 – TypeError](img/B13426_01_03.jpg)'
- en: Figure 1.3 – TypeError
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – TypeError
- en: Let’s examine this error in detail.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细检查这个错误。
- en: The error in the preceding code snippet denotes a `TypeError`, which was caused
    by an attempt to add a `meta` string with an integer of `1`. The question that
    may occur to you is, *can we resolve this error using metaprogramming*?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段中的错误表示一个`TypeError`，这是由于尝试将一个`meta`字符串与一个整数值`1`相加而引起的。你可能想知道，*我们能否使用元编程来解决这个问题*？
- en: 'The `add` function in this example denotes a piece of code or program, similar
    to how the Employee Data table in *Figure 1.1* denotes data. In the same line,
    can we identify the metadata of the `add` function and use it to resolve the `TypeError`
    object returned by the following code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的`add`函数表示一段代码或程序，类似于*图1.1*中的员工数据表表示数据。在同一行中，我们可以识别`add`函数的元数据，并使用它来解决以下代码返回的`TypeError`对象：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we will look at a practical example of metaprogramming. We will be making
    use of the metadata of the `add` function to understand this concept.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看元编程的实际示例。我们将利用`add`函数的元数据来理解这个概念。
- en: Metadata of the add function
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: add函数的元数据
- en: 'A function in any programming language is written to perform a set of operations
    on the input variables; it will return the results as a consequence of the operations
    performed on them. In this section, we will look at a simple example of a function
    that adds two variables. This will help us understand that metaprogramming can
    be applied to functions and manipulate the behavior of the function without modifying
    the algorithm of the function. We will be adding these two variables by writing
    an `add` function. To change the results of the `add` function, we will be manipulating
    the metadata of its two input variables, thus getting different results each time
    a different type of input variable is provided to execute the function. Just like
    we can manipulate what a function should do by writing lines of code to perform
    various operations, we can also manipulate the function itself by programming
    its metadata and setting restrictions on what it should and shouldn’t do. Just
    like a dataset, DataFrame, or table has data and metadata, a program or a function
    in Python 3 also has data and metadata. In this example, we will be manipulating
    the actions that are performed by the `add` function by restricting its behavior
    – not based on the input data provided to the function but on the *type* of input
    data provided to the `add` function instead. Take a look at the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 任何编程语言中的函数都是编写来对输入变量执行一系列操作的；它将根据对这些变量执行的操作返回结果。在本节中，我们将查看一个简单的函数示例，该函数用于添加两个变量。这将帮助我们理解元编程可以应用于函数，并可以操纵函数的行为而不修改函数的算法。我们将通过编写一个`add`函数来添加这两个变量。为了改变`add`函数的结果，我们将操作其两个输入变量的元数据，从而在每次提供不同类型的输入变量来执行函数时得到不同的结果。就像我们可以通过编写执行各种操作的代码行来操纵函数应该做什么一样，我们也可以通过编程其元数据和设置限制来操纵函数本身，以确定它应该做什么以及不应该做什么。就像数据集、DataFrame或表格有数据和元数据一样，Python
    3中的程序或函数也有数据和元数据。在本例中，我们将通过限制其行为来操纵`add`函数执行的操作，而不是基于提供给函数的输入数据，而是基于提供给`add`函数的输入数据的*类型*。请看以下截图：
- en: '![Figure 1.4 – Examining the data and metadata of the add function ](img/B13426_01_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4 – 检查add函数的数据和元数据](img/B13426_01_04.jpg)'
- en: Figure 1.4 – Examining the data and metadata of the add function
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 – 检查add函数的数据和元数据
- en: 'The following code helps us identify the metadata for each data item in the
    `add` function:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码帮助我们识别`add`函数中每个数据项的元数据：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A function call to the preceding function will now return the metadata of the
    `add` function instead of its result. Now, let’s call the `add` method with an
    integer as input:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对前面函数的函数调用现在将返回`add`函数的元数据而不是其结果。现在，让我们用整数作为输入调用`add`方法：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We’ll get the following output:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Similarly, we can also check the addition of strings, as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们也可以检查字符串的相加，如下所示：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’ll get the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Python 3 allows us to use the metadata of the code to manipulate it so that
    it deviates from its actual behavior. This will also provide customized solutions
    for the problems we are trying to solve.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python 3 允许我们使用代码的元数据来操作它，使其偏离其实际行为。这还将为我们试图解决的问题提供定制化的解决方案。
- en: In the preceding example, we used the `type` function, a method in Python that
    returns the class or data type that any object or variable belongs to.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`type`函数，这是Python中的一个方法，它返回任何对象或变量所属的类或数据类型。
- en: From the preceding output, it is evident that the `a` and `b` variables we passed
    to the `add` function belong to the integer data type, and its result, `c`, is
    an integer too. The `add` function itself is of the `function` class/type.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中可以看出，我们传递给`add`函数的`a`和`b`变量属于整数数据类型，其结果`c`也是一个整数。`add`函数本身是`function`类/类型。
- en: Resolving type errors using metaprogramming
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用元编程解决类型错误
- en: There are many variations on how we can resolve the type error from the `add`
    function we saw in the previous section using metaprogramming. We will look at
    this in this section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用元编程从上一节中看到的`add`函数解决类型错误的变体有很多。我们将在本节中探讨这一点。
- en: '**Scenario 1**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景1**'
- en: 'The following meta-program handles the error and allows the `add` function
    to add two strings or two integers. It also suggests that the user enters the
    input data with the right data types:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下元程序处理错误，并允许`add`函数添加两个字符串或两个整数。它还建议用户以正确的数据类型输入数据：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the function definition of `add`, we have added two conditions – one to check
    if the type of `a` is a string and the type of `b` is an int, or if the type of
    `a` is an int and the type of `b` is a string. We are checking the combination
    of these input variables to handle the type mismatch error and directing the users
    to provide the right data type for input variables.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在`add`函数的定义中，我们添加了两个条件——一个用于检查`a`的类型是否为字符串且`b`的类型为int，或者`a`的类型是否为int且`b`的类型为字符串。我们正在检查这些输入变量的组合以处理类型不匹配错误，并指导用户为输入变量提供正确的数据类型。
- en: 'The following table shows the various combinations of input variable data types
    and their corresponding output or results based on the conditions set on the metadata
    of the `add` function, based on **Scenario 1**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了输入变量数据类型的各种组合以及根据`add`函数的元数据上设置的条件得出的输出或结果，基于**场景1**：
- en: '![Figure 1.5 – Scenario 1 metadata combinations ](img/B13426_01_05.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图1.5 – 场景1元数据组合](img/B13426_01_05.jpg)'
- en: Figure 1.5 – Scenario 1 metadata combinations
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 – 场景1元数据组合
- en: 'The following code executes the `add` function to reinforce the input-output
    combinations explained in *Figure 1.5*:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码执行`add`函数以强化在*图1.5*中解释的输入-输出组合：
- en: '[PRE33]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**Scenario 2**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景2**'
- en: 'The following meta-program resolves the type mismatch error by converting the
    mismatching data types into string variables and performing a string concatenation.
    It is only logical to concatenate a string and an integer using a `+` operator
    as we cannot perform arithmetic addition on these two different data types. Take
    a look at the following program:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下元程序通过将不匹配的数据类型转换为字符串变量并执行字符串连接来解决类型不匹配错误。使用`+`运算符连接字符串和整数是合乎逻辑的，因为我们不能对这两种不同的数据类型执行算术加法。看看以下程序：
- en: '[PRE41]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Here, no matter what input we provide for the `a` and `b` variables, they both
    get converted into string variables and are then concatenated using `+`, whereas
    if both the input variables are integers, they get added using arithmetic addition.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，无论我们为`a`和`b`变量提供什么输入，它们都会被转换为字符串变量，然后使用`+`进行连接，而如果这两个输入变量都是整数，它们将使用算术加法相加。
- en: 'The following table shows the various combinations of input variable data types
    and their corresponding output or results based on the conditions set on the metadata
    of the `add` function based on **Scenario 2**:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了输入变量数据类型的各种组合以及根据`add`函数的元数据上设置的条件得出的输出或结果，基于**场景2**：
- en: '![Figure 1.6 – Scenario 2 metadata combinations ](img/B13426_01_06.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图1.6 – 场景2元数据组合](img/B13426_01_06.jpg)'
- en: Figure 1.6 – Scenario 2 metadata combinations
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 场景2元数据组合
- en: 'Executing the following code provides the combinations of output values we
    saw in the preceding table:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码将提供我们在前表中看到的输出值组合：
- en: '[PRE52]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '**Scenario 3**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**场景3**'
- en: Now, let’s go a step further and restrict the nature of the `add` function itself
    to ensure it only performs arithmetic addition and doesn’t accept any other data
    types or combinations of data types.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更进一步，限制`add`函数本身的性质，确保它只执行算术加法，不接受任何其他数据类型或数据类型的组合。
- en: In the following code block, we have added another condition to perform a data
    type check on floating-point values, along with data type checks for the string
    and integer input values.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们添加了另一个条件来对浮点数值进行数据类型检查，同时还有对字符串和整型输入值的数据类型检查。
- en: 'This function only accepts numeric values as input and will return a message
    directing users to input numbers so that only arithmetic addition is performed.
    Let’s look at the code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数仅接受数值作为输入，并将返回一条消息，指导用户输入数字，以便仅执行算术加法。让我们看看代码：
- en: '[PRE62]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The following table shows the various combinations of input variable data types
    and their corresponding output or results based on the conditions set on the metadata
    of the `add` function based on **Scenario 3**:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了输入变量数据类型的不同组合以及根据在`add`函数的元数据上设置的**场景 3**条件所对应的输出或结果：
- en: '![Figure 1.7 – Scenario 3 metadata combinations ](img/B13426_01_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 场景3元数据组合](img/B13426_01_07.jpg)'
- en: Figure 1.7 – Scenario 3 metadata combinations
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 场景3元数据组合
- en: 'Executing the following code provides the combination of output values shown
    in *Figure 1.7*, including the addition of floating-point values:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码将提供*图1.7*中显示的输出值组合，包括浮点数的加法：
- en: '[PRE71]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: These are some of the approaches that can be applied to perform simple metaprogramming
    on a function. However, these are not the only solutions that solve type errors
    or manipulate a function. There is more than one way or approach to implementing
    solutions using metaprogramming.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些可以应用于在函数上执行简单元编程的方法。然而，这些并不是解决类型错误或操作函数的唯一解决方案。使用元编程实现解决方案的方法或途径不止一种。
- en: Understanding why we need metaprogramming
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解为什么我们需要元编程
- en: 'Considering what we’ve learned about metaprogramming, we may be wondering the
    following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到我们已经学到的关于元编程的知识，我们可能会思考以下问题：
- en: “*Is it always mandatory to apply metaprogramming techniques or to manipulate
    the metadata of the code while developing applications using Python 3 or above?*”
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: “*在使用Python 3或更高版本开发应用程序时，是否总是必须应用元编程技术或操作代码的元数据？*”
- en: This is a common question that can be asked not only while developing applications
    using Python 3 or above, but also when using any programming language that supports
    the techniques of metaprogramming and gives developers the option to apply them
    in the application development process.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个常见问题，不仅在开发使用Python 3或更高版本的应用程序时会被问到，而且在使用任何支持元编程技术并允许开发者在应用程序开发过程中应用它们的编程语言时也会被问到。
- en: To answer this question, it is important to understand the flexibility of metaprogramming
    and the techniques that are supported by Python to handle code manipulation, which
    will be covered throughout this book.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 要回答这个问题，了解元编程的灵活性和Python支持处理代码操作的技术是非常重要的，这些内容将在本书的后续章节中介绍。
- en: One of the reasons to apply metaprogramming is to avoid repetition in various
    aspects of the Python-based application development process. We will look at an
    example of this in the *Don’t Repeat Yourself* section.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 应用元编程的一个原因是为了避免在基于Python的应用程序开发过程中的各个方面重复。我们将在*不要重复自己*部分中查看一个例子。
- en: In other words, introducing concepts such as code generators at the meta level
    can save development and execution time in functional- or domain-level programming.
    Domain-level programming corresponds to writing code for a particular domain,
    such as finance, networking, social media, and so on.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，在元级别引入诸如代码生成器等概念可以节省函数级或领域级编程的开发和执行时间。领域级编程对应于为特定领域编写代码，例如金融、网络、社交媒体等。
- en: The other need is to increase the abstraction of your code at the program metadata
    level rather than at the functional level. **Abstraction** is the concept of information
    hiding in the literal sense or in terms of object-oriented programming. Implementing
    abstraction at the meta-program level would help us decide what information to
    provide to the next level of coding and what not to provide.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需求是在程序元数据级别而不是在功能级别提高代码的抽象程度。**抽象**在字面上或面向对象编程的术语中是指信息隐藏的概念。在元程序级别实现抽象将帮助我们决定向下一级编码提供哪些信息，以及不提供哪些信息。
- en: For example, developing a function template at the meta-program level would
    hide the function definition at the domain or functional level, as well as limit
    the amount of information that goes to the functional-level code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在元编程级别开发一个函数模板将隐藏在域或功能级别的函数定义，以及限制传递给功能级别代码的信息量。
- en: Metaprogramming allows us to manipulate programs using metadata at the meta
    level, which helps define how the grammar and semantics of your program should
    be. For example, in the *Resolving type erors using metaprogramming* section,
    we looked at controlling the outcome of the data types of a function by manipulating
    the function’s variables.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程允许我们使用元数据在元级别上操作程序，这有助于定义你的程序语法和语义应该如何。例如，在*使用元编程解决类型错误*这一节中，我们探讨了通过操作函数的变量来控制函数的数据类型结果。
- en: Don’t Repeat Yourself
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要重复自己
- en: In any application development process, thousands of lines of code are written.
    Don’t Repeat Yourself is a principle defined by *Andy Hunt and Dave Thomas* in
    their book *The Pragmatic Programmer*. The principle states that “*Every piece
    of knowledge must have a single, unambiguous, authoritative representation within
    a system.*”
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何应用程序开发过程中，都会编写数千行代码。不要重复自己（Don’t Repeat Yourself）是安迪·亨特（Andy Hunt）和大卫·托马斯（Dave
    Thomas）在他们所著的《程序员修炼之道》（The Pragmatic Programmer）一书中提出的原则。该原则指出：“*系统中的每一项知识都必须有一个单一、明确、权威的表示。*”
- en: While writing code, there are very high chances of writing multiple functions
    or methods that perform similar kinds of repetitive tasks, and the functions or
    methods, in turn, might be repetitive. This leads to redundancy in application
    development. The greatest disadvantage of redundancy is that when you make any
    modifications at one location, the implementation, modification, or code fixing
    needs to be repeated at multiple locations.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时，有很大可能性会编写多个执行类似重复任务的函数或方法，而这些函数或方法本身也可能是重复的。这导致应用程序开发中的冗余。冗余的最大缺点是，当你对某个位置进行任何修改时，实现、修改或代码修复需要在多个位置重复进行。
- en: Libraries are developed with classes and methods, including object-oriented
    programming techniques such as abstraction, inheritance, encapsulation, and so
    on, to avoid redundancy and maintain coding standards as much as possible. Even
    then, there are chances of repetitive methods being within a class that can still
    be simplified.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 库是通过类和方法开发的，包括面向对象编程技术，如抽象、继承、封装等，以尽可能避免冗余并维护编码标准。即便如此，类中仍有可能存在可以简化的重复方法。
- en: Metaprogramming can help in handling such instances by implementing approaches
    such as dynamic code generation, dynamic function creation, and more. Throughout
    this book, we will be looking at various approaches that help you not to repeat
    yourself while developing applications.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程可以通过实现动态代码生成、动态函数创建等方法来帮助处理此类情况。在这本书的整个过程中，我们将探讨各种方法，帮助你在开发应用程序时避免重复。
- en: To get a taste of how we can dynamically generate code and avoid repetitions,
    let’s look at a simple example where arithmetic operations are implemented as
    repetitive functions.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解我们如何动态生成代码并避免重复，让我们看看一个简单的例子，其中算术运算被实现为重复函数。
- en: 'The following code consists of four basic arithmetic operations that can be
    performed on two numeric variables. We will be declaring and defining four functions
    that add, subtract, multiply, and divide two variables, `a` and `b`, store the
    result in a variable, `c`, and return it while the function is executed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码由四个基本算术运算组成，这些运算可以在两个数值变量上执行。我们将声明并定义四个函数，这些函数将执行两个变量`a`和`b`的加、减、乘、除运算，将结果存储在变量`c`中，并在函数执行时返回它：
- en: '[PRE85]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Each of the preceding functions needs to be called separately and variables
    need to be provided as input to execute them individually, as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的每个函数都需要单独调用，并且需要提供变量作为输入以单独执行，如下所示：
- en: '[PRE97]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: In this example, there is only one difference – the arithmetic operator that’s
    used in the function definition. This code can be simplified without implementing
    metaprogramming, just by declaring a new function that takes in an additional
    input variable operator.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，只有一个区别——函数定义中使用的算术运算符。这个代码可以通过不实现元编程，仅通过声明一个接受额外输入变量运算符的新函数来简化。
- en: 'Let’s learn how to avoid this repetitive function definition and simplify the
    logic. The following code block defines one common function that can be reused
    to perform all four arithmetic operations. Let’s start by importing Python’s inbuilt
    `module` operator, which contains methods that support multiple arithmetic operations:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何避免这种重复的函数定义并简化逻辑。以下代码块定义了一个通用函数，可以重复使用以执行所有四个算术运算。让我们首先导入Python的内置`module`运算符，它包含支持多个算术运算的方法：
- en: '[PRE105]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'In this code snippet, we have declared three variables, including the operation
    in the function arithmetic. Let’s see this in action:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码片段中，我们声明了三个变量，包括函数算术中的操作。让我们看看它是如何工作的：
- en: '[PRE109]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Executing this function using input variables would return a concatenated string,
    `25`, that will serve the purpose of creating the common `arithmetic` function
    to perform multiple operations. We can look at providing various operations as
    input to see how this one common function serves multiple purposes.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 使用输入变量执行此函数将返回一个连接的字符串，`25`，这将用于创建通用的`arithmetic`函数以执行多个操作。我们可以查看提供各种操作作为输入，看看这个通用函数如何服务于多个目的。
- en: 'Calling this function with different arithmetic operators would resolve the
    need for repetitive function definitions:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不同的算术运算符调用此函数可以解决重复函数定义的需求：
- en: '[PRE110]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This is one approach to resolving code redundancy and avoiding multiple function
    definitions. But what if we do not want to define the function itself until and
    unless it is required?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这是解决代码冗余和避免多次函数定义的一种方法。但如果我们不想在需要之前定义函数本身怎么办？
- en: To answer this question, we can implement dynamic function creation using metaprogramming.
    Dynamic functions are created during the code’s runtime as and when they are required.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这个问题，我们可以通过元编程实现动态函数的创建。动态函数在代码运行时根据需要创建。
- en: Although we are still in the introductory chapter, we will discuss an example
    of dynamic function creation next to get a view of what kind of programming will
    be covered throughout this book.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们还在介绍章节中，但我们将讨论动态函数创建的示例，以了解本书将涵盖哪种类型的编程。
- en: Creating dynamic functions
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建动态函数
- en: In this section, we’ll look at an example of how dynamic functions can be created
    for the same set of arithmetic operations we discussed earlier in this section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看一个示例，说明如何为之前在本节中讨论的相同算术运算集创建动态函数。
- en: 'To create an arithmetic function dynamically, we need to import the library
    types and the `FunctionType` type. `FunctionType` is the type of all user-defined
    functions created by users during the Python-based application development process:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动态创建算术函数，我们需要导入库`types`和`FunctionType`类型。`FunctionType`是用户在基于Python的应用程序开发过程中创建的所有用户定义函数的类型：
- en: '[PRE118]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'To begin this process, we will create a string variable that is a function
    definition of the arithmetic function:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始这个过程，我们将创建一个字符串变量，它是算术函数的函数定义：
- en: '[PRE119]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'We’ll get the following output:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将得到以下输出：
- en: '[PRE126]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Now, we will create another variable, `functiontemplate`, and compile `''functionstring''`
    into a code object. We will also set the code object to be executed using `''exec''`.
    The `compile` method is used to convert the string in Python into a code object
    that can be further executed using the `exec` method:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建另一个变量，`functiontemplate`，并将`'functionstring'`编译成一个代码对象。我们还将设置代码对象使用`'exec'`来执行。`compile`方法用于将Python中的字符串转换为代码对象，该对象可以进一步使用`exec`方法执行：
- en: '[PRE130]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The code object of the function definition arithmetic will be stored in a tuple
    in `functiontemplate` and can be accessed as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 函数定义算术的代码对象将被存储在`functiontemplate`中的元组中，可以按以下方式访问：
- en: '[PRE133]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The next step involves creating a function object using the `functiontemplate`
    code object. This can be done using the `FunctionType` method, which accepts the
    code object and global variables as input parameters:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步涉及使用`functiontemplate`代码对象创建一个函数对象。这可以通过使用`FunctionType`方法完成，该方法接受代码对象和全局变量作为输入参数：
- en: '[PRE135]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Upon executing, `dynamicfunction`, it will behave the same way as the `add`
    operation works in the operator module’s `add` method in the arithmetic function:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 执行`dynamicfunction`后，它将表现得与算术函数中操作模块的`add`方法中的`add`操作相同：
- en: '[PRE138]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Now that we know how to create a function dynamically, we can look at extending
    it further to create multiple functions, each with a different operation and a
    different name, dynamically.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何动态创建函数，我们可以进一步扩展它以创建多个函数，每个函数具有不同的操作和不同的名称，动态地。
- en: 'To do this, we must create a list of operators and a list of function names:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须创建一个操作符列表和一个函数名列表：
- en: '[PRE140]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Our earlier list of four functions only contained the add, sub, multiply, and
    divide operations.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前列出的四个函数只包含加、减、乘和除操作。
- en: The earlier `functionname` list contained eight functions. This is the flexibility
    we get while creating dynamic functions.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 之前`functionname`列表包含八个函数。这是我们在创建动态函数时获得的灵活性。
- en: 'For ease of use, let’s also create two input variables, `a` and `b`, to be
    used while executing the function:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于使用，我们还创建了两个输入变量`a`和`b`，用于执行函数时使用：
- en: '[PRE143]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: In the following code, we will be creating a function called `functiongenerator()`
    that implements metaprogramming to dynamically generate as many arithmetic functions
    as we want. This function will take four input parameters – that is, the list’s
    `functionname`, `operator`, `a`, and `b`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们将创建一个名为`functiongenerator()`的函数，该函数实现元编程以动态生成我们想要的任意数量的算术函数。此函数将接受四个输入参数——即列表的`functionname`、`operator`、`a`和`b`。
- en: 'Here is the code:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码：
- en: '[PRE145]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Within `functiongenerator()`, the following occurs:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在`functiongenerator()`内部，发生以下情况：
- en: A new `functionstring` list is created with a function definition for each arithmetic
    operator provided in the operator list.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用操作符列表中提供的每个算术运算符定义，创建一个新的`functionstring`列表。
- en: A new `functiontemplate` list is created with a code object for each function
    definition.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个函数定义创建一个新的`functiontemplate`列表，包含代码对象。
- en: A new `dynamicfunction` list is created with a function object for each code
    object.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个代码对象创建一个新的`dynamicfunction`列表，包含一个函数对象。
- en: A new `functiondict` dictionary is created with a key-value pair of function
    name-function objects.
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`functiondict`字典，包含函数名-函数对象的键值对。
- en: '`Functiongenerator` returns the generated functions as a dictionary.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Functiongenerator`返回生成的函数作为字典。'
- en: Additionally, `functiongenerator` executes the dynamic functions and prints
    the results.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，`functiongenerator`执行动态函数并打印结果。
- en: 'Executing this function results in the following output:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此函数将产生以下输出：
- en: '[PRE168]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Any specific function from the preceding generated functions can be called
    individually and used further, as follows:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 可以单独调用前面生成的任何特定函数，并进一步使用，如下所示：
- en: '[PRE186]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The following diagram shows the complete process of metaprogramming to develop
    these dynamic functions:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了开发这些动态函数的元编程的完整过程：
- en: '![Figure 1.8 – Dynamic function generator ](img/B13426_01_08.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8 – 动态函数生成器](img/B13426_01_08.jpg)'
- en: Figure 1.8 – Dynamic function generator
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 动态函数生成器
- en: Now that we know about dynamic function generators, let’s look at other applications
    of metaprogramming.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了动态函数生成器，让我们看看元编程的其他应用。
- en: Exploring the applications of metaprogramming
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索元编程的应用
- en: Metaprogramming can be applied to various Python-based application development
    solutions, such as automated code generators, component-based or flow-based application
    development, domain-specific language development, and many more.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程可以应用于各种基于Python的应用程序开发解决方案，例如自动化代码生成器、基于组件或基于流程的应用程序开发、特定领域语言开发等等。
- en: Any code you develop, be it for a class or a method, internally applies metaprogramming,
    and its use is inevitable in the Python application development process. However,
    applying metaprogramming concepts explicitly is a conscious decision-making process
    and it purely depends on the expected outcome of your application.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 您开发的任何代码，无论是类还是方法，都内部应用了元编程，并且在Python应用程序开发过程中其使用是不可避免的。然而，明确应用元编程概念是一个有意识的决策过程，并且它完全取决于您应用程序的预期结果。
- en: In our example of dynamic function creation, we implemented metaprogramming
    to avoid repetitions and also to ensure the abstraction of the code at the meta-level.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的动态函数创建示例中，我们实现了元编程来避免重复，并确保代码在元级别的抽象。
- en: 'Let’s consider a scenario where we want to develop a functional flow-based
    application for non-programmers to use. For instance, the application can be a
    domain-specific data transformation tool that works with high levels of abstraction
    and does not provide too much design or development-based information to the end
    users. However, it also helps the end users dynamically create modules that can
    help in their domain-specific problem solving, without the need to write any programs.
    In such cases, metaprogramming comes in handy for the application development
    process:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个场景，其中我们想要开发一个基于功能流程的应用程序，供非程序员使用。例如，该应用程序可以是一个特定领域的数据库转换工具，它以高层次的抽象工作，并且不向最终用户提供太多设计或开发信息。然而，它也帮助最终用户动态创建模块，这些模块可以帮助他们在特定领域的问题解决中，而无需编写任何程序。在这种情况下，元编程在应用程序开发过程中非常有用：
- en: '![Figure 1.9 – Levels of programming ](img/B13426_01_9.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9 – 编程层次](img/B13426_01_9.jpg)'
- en: Figure 1.9 – Levels of programming
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.9 – 编程层次
- en: We will look at the case studies and applications of metaprogramming in more
    detail throughout this book.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将更详细地探讨元编程的案例研究和应用。
- en: Summary
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we provide a quick overview of the programming paradigm of
    metaprogramming and looked at an example of solving a type error using metaprogramming
    in Python 3.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了一个关于元编程编程范式的快速概述，并查看了一个使用Python 3进行元编程解决类型错误的示例。
- en: We learned why there is a need to apply metaprogramming techniques in the Python
    application development process. We also learned about the Don’t Repeat Yourself
    concept by looking at a practical approach that explains an example implementation
    of dynamic function creation using metaprogramming, emphasizing the concepts of
    avoiding repetition and implementing abstraction at the meta level in the code.
    Finally, we provided a high-level overview of the applications of metaprogramming
    that we will look at throughout this book. These skills will help us understand
    how and why to apply metaprogramming in various applications.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了为什么在Python应用程序开发过程中需要应用元编程技术。我们还通过查看一个解释动态函数创建的示例实现，了解了“不要重复自己”的概念，该示例强调了避免重复和在代码的元级别实现抽象的概念。最后，我们提供了对本书中将探讨的元编程应用的高级概述。这些技能将帮助我们理解如何在各种应用中应用元编程。
- en: In the next chapter, we will review the object-oriented programming concepts
    of Python. The next chapter is more of a refresher on object-oriented programming
    concepts and is optional if you are already familiar with those concepts.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾Python的对象导向编程概念。下一章更多地是对对象导向编程概念的复习，如果你已经熟悉这些概念，则是可选的。
