- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Clean Architecture
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构
- en: In this final chapter, we focus on how everything fits together in the design
    of a whole system. This is more of a theoretical chapter. Given the nature of
    the topic, it would be too complex to delve down into the more low-level details.
    Besides, the point is precisely to escape from those details, assume that all
    the principles explored in previous chapters are assimilated, and focus on the
    design of a system at scale.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们关注的是整个系统设计中的所有部分是如何相互配合的。这更偏向于理论性的章节。鉴于主题的性质，深入探讨更底层的细节会过于复杂。此外，目的正是要避开这些细节，假设在前几章中探索的所有原则都已吸收，并专注于大规模系统的设计。
- en: 'The main goals of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要目标如下：
- en: Designing software systems that can be maintained in the long run
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计长期可维护的软件系统
- en: Working effectively on a software project by maintaining quality attributes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过维护质量属性有效地进行软件项目工作
- en: Studying how all concepts applied to code relate to systems in general
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究所有应用于代码的概念如何与系统总体相关联
- en: This chapter explores how clean code evolves into a clean architecture, and
    conversely how clean code is also the cornerstone of good architecture. A software
    solution is effective if it has quality. The architecture needs to enable this
    by achieving quality attributes (performance, testability, maintainability, and
    so on). But then the code needs to also enable this on every component.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了清洁代码如何演变成清洁架构，反之亦然，清洁代码也是良好架构的基石。一个软件解决方案如果具有质量，则是有效的。架构需要通过实现质量属性（性能、可测试性、可维护性等）来实现这一点。但代码也需要在每个组件上实现这一点。
- en: The first section starts by exploring the relationship between the code and
    the architecture.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分首先探讨代码与架构之间的关系。
- en: From clean code to clean architecture
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从清洁代码到清洁架构
- en: This section is a discussion of how concepts that were emphasized in previous
    chapters reappear in a slightly different shape when we consider aspects of large
    systems. There is an interesting resemblance to how concepts that apply to more
    detailed design, as well as code, also apply to large systems and architectures.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了在前几章中强调的概念，当我们考虑大型系统的方面时，它们以略微不同的形式再次出现。这与适用于更详细设计以及代码的概念也适用于大型系统和架构有有趣的相似之处。
- en: 'The concepts explored in previous chapters were related to single applications,
    generally, a project, which might be a single repository (or a few), of a source
    control version system (Git). This is not to say that those design ideas are only
    applicable to code, or that they are of no use when thinking of an architecture,
    for two reasons: the code is the foundation of the architecture, and, if it''s
    not written carefully, the system will fail regardless of how well thought-out
    the architecture is.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中探讨的概念与单一应用程序相关，通常是一个项目，可能是一个源代码版本控制系统（Git）的单个存储库（或几个）。这并不是说那些设计理念只适用于代码，或者它们在考虑架构时没有用处，原因有两个：代码是架构的基础，而且如果代码编写不仔细，无论架构考虑得多周全，系统都会失败。
- en: Second, some principles that were covered in previous chapters do not apply
    only to code but are design ideas instead. The clearest example comes from design
    patterns. They are high-level abstractions. With them, we can get a quick picture
    of how a component in our architecture might appear, without going into the details
    of the code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一些在前几章中提到的原则不仅适用于代码，而是设计理念。最明显的例子来自设计模式。它们是高级抽象。有了它们，我们可以快速了解我们的架构中某个组件可能的样子，而不必深入了解代码的细节。
- en: But large enterprise systems typically consist of many of these applications,
    and now it's time to start thinking in terms of a larger design, in the form of
    a distributed system.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但大型企业系统通常由许多这样的应用程序组成，现在是时候开始从更大设计的角度思考，即分布式系统。
- en: In the following sections, we discuss the main topics that have been discussed
    throughout the book, but now from the perspective of a whole system.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论本书中已经讨论过的主要主题，但现在是从整个系统的角度来考虑。
- en: Software architecture is good if it's effective. The most common aspects to
    look at in a good architecture are the so-called quality attributes (traits like
    scalability, security, performance, and endurance are the most common ones). This
    makes sense; after all, you want your system to handle an increase of load without
    collapsing, and to be able to work continuously for indefinite periods of time
    without requiring maintenance, and also to be extensible to support new requirements.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果软件架构有效，那么它就是好的。在好的架构中，最常见的方面是所谓的质量属性（如可扩展性、安全性、性能和耐用性是最常见的）。这很有道理；毕竟，你希望你的系统能够处理负载的增加而不会崩溃，并且能够在不需要维护的情况下连续工作不定期的时间，同时也能够扩展以支持新的需求。
- en: But the operational aspects of an architecture also make it clean. Traits like
    operability, continuous integration, and how easy it is to release changes also
    influence the overall quality of the system.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 但架构的操作方面也使其变得清晰。如可操作性、持续集成以及发布变更的难易程度等因素也会影响系统的整体质量。
- en: Separation of concerns
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关注点分离
- en: Inside an application, there are multiple components. Their code is divided
    into other subcomponents, such as modules or packages, and the modules into classes
    or functions, and the classes into methods. Throughout the book, the emphasis
    has been on keeping these components as small as possible, particularly in the
    case of functions—functions should do one thing and be small.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个应用程序内部，存在多个组件。它们的代码被划分为其他子组件，如模块或包，模块被划分为类或函数，类被划分为方法。在整个书中，我们一直强调将这些组件保持尽可能小，尤其是在函数的情况下——函数应该只做一件事，并且要小。
- en: Several reasons were presented to justify this rationale. Small functions are
    easier to understand, follow, and debug. They are also easier to test. The smaller
    the pieces in our code, the easier it will be to write unit tests for it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 提出了几个理由来证明这一论点。小的函数更容易理解、跟踪和调试。它们也更容易测试。我们代码中的块越小，编写单元测试就越容易。
- en: For the components of each application, we wanted different traits, mainly high
    cohesion and low coupling. By dividing components into smaller units, each one
    with a single and well-defined responsibility, we achieve a better structure where
    changes are easier to manage. In the face of new requirements, there will be a
    single correct place to make the changes, and the rest of the code should probably
    be unaffected.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个应用程序的组件，我们希望有不同的特性，主要是高内聚和低耦合。通过将组件划分为更小的单元，每个单元都拥有单一且定义明确的职责，我们实现了更好的结构，使得变更更容易管理。面对新的需求时，将只有一个正确的地方进行变更，其余的代码可能不会受到影响。
- en: When we talk about code, we say *component* to refer to one of these cohesive
    units (it might be a class, for example). When speaking in terms of architecture,
    a component means anything in the system that can be treated as a working unit.
    The term component itself is quite vague, so there is no universally accepted
    definition in software architecture of what this means more concretely. The concept
    of a working unit is something that can vary from project to project. A component
    should be able to be released or deployed with its own cycles, independently from
    the rest of the system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论代码时，我们用“组件”来指代这些内聚单元之一（例如，它可能是一个类）。在谈论架构时，组件意味着系统中任何可以被视为工作单元的东西。组件这个术语本身相当模糊，因此在软件架构中并没有一个普遍接受的定义来更具体地说明这意味着什么。工作单元的概念可能因项目而异。组件应该能够独立于系统其余部分进行发布或部署。
- en: For Python projects, a component could be a package, but a service can also
    be a component. Notice how two different concepts, with different levels of granularity,
    can be considered under the same category. To give an example, the event systems
    we used in previous chapters could be considered a component. They are a working
    unit with a clearly defined purpose (to enrich events identified from logs). They
    can be deployed independently from the rest (whether as a Python package, or,
    if we expose their functionality, as a service; more on that later), and they're
    a part of the entire system, but not the whole application itself.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Python项目来说，一个组件可能是一个包，但一个服务也可以是一个组件。注意，两种不同概念，不同粒度级别，可以被视为同一类别。以一个例子来说明，我们在前几章中使用的事件系统可以被视为一个组件。它们是一个具有明确目的的工作单元（用于丰富从日志中识别的事件）。它们可以独立于其他部分部署（无论是作为Python包，还是如果我们公开其功能，作为服务；关于这一点稍后还会详细介绍），并且它们是整个系统的一部分，但不是整个应用程序本身。
- en: In the examples in previous chapters, we saw idiomatic code, and we also highlighted
    the importance of good design for our code, with objects that have single, well-defined
    responsibilities being isolated, orthogonal, and easier to maintain. This very
    same criteria, which applies to a detailed design (functions, classes, methods),
    also applies to the components of software architecture.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章的示例中，我们看到了惯用的代码，我们也强调了良好设计对我们代码的重要性，具有单一、明确职责的对象被隔离、正交，并且更容易维护。这个适用于详细设计（函数、类、方法）的标准，同样适用于软件架构的组件。
- en: Keep in mind good design principles when looking at the big picture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑大局时，请记住良好的设计原则。
- en: It's probably undesirable for a large system to be just one component. A monolithic
    application will act as the single source of truth, responsible for everything
    in the system, and that will carry a lot of undesired consequences (harder to
    isolate and identify changes, to test effectively, and so on).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个大型系统来说，仅仅是一个组件可能是不理想的。单体应用程序将作为系统的单一真相来源，负责系统中的所有内容，这将带来许多不希望看到的结果（更难隔离和识别变更，难以有效测试，等等）。
- en: In the same way, our code will be harder to maintain if we are not careful and
    place everything in one place, the application will suffer from similar problems
    if its components aren't treated with the same level of attention.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果我们不小心将所有内容都放在一个地方，我们的代码将更难维护，如果应用程序的组件没有得到同样的关注，它将面临类似的问题。
- en: The idea of creating cohesive components in a system can have more than one
    implementation, depending on the level of abstraction we require.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中创建内聚组件的想法可以有不止一种实现方式，这取决于我们所需的抽象级别。
- en: One option would be to identify common logic that is likely to be reused multiple
    times and place it in a Python package (we will discuss the details later in the
    chapter).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是将可能被多次重用的通用逻辑识别出来，并将其放置在一个Python包中（我们将在本章后面讨论细节）。
- en: Another alternative would be to break the application down into multiple smaller
    services, in a microservice architecture. The idea is to have components with
    a single and well-defined responsibility and achieve the same functionality as
    a monolithic application by making those services cooperate and exchange information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是将应用程序分解成多个更小的服务，采用微服务架构。其理念是拥有单一且定义明确的职责的组件，并通过这些服务之间的合作和信息交换来实现与单体应用程序相同的功能。
- en: Monolithic applications and microservices
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体应用程序和微服务
- en: 'The most important idea from the previous section is the concept of separating
    concerns: different responsibilities should be distributed across diverse components.
    Just as in our code (a more detailed level of design) it wouldn''t be good to
    have a giant object that knows everything, in our architecture, there shouldn''t
    be a single component owning everything.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节最重要的观点是关注点的分离概念：不同的职责应该分布在不同的组件中。正如在我们的代码（更详细的设计级别）中，不应该有一个知道所有东西的巨大对象一样，在我们的架构中，不应该有一个拥有所有东西的单个组件。
- en: There is, however, an important distinction. Different components don't necessarily
    mean different services. It's possible to divide the application into smaller
    Python packages (we'll look at packaging later in the chapter) and create a single
    service composed of many dependencies.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一个重要的区别。不同的组件不一定意味着不同的服务。可以将应用程序划分为更小的Python包（我们将在本章后面讨论打包），并创建一个由许多依赖项组成的单一服务。
- en: Separating responsibilities into different services is a good idea that has
    some benefits, but it also comes at a cost.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 将职责分离到不同的服务中是一个好主意，它带来了一些好处，但也伴随着成本。
- en: In the case that there's code that needs to be reused across several other services,
    a typical response is to encapsulate that into a microservice to be called by
    many other services in the company. This isn't the only way to reuse code. Consider
    the possibility of packaging that logic as a library to be imported by other components.
    Of course, this is only viable as long as all other components are written in
    the same language; otherwise, yes, the microservices pattern is the only option
    left.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有代码需要在多个其他服务中重用，一个典型的做法是将这部分代码封装成一个微服务，以便公司内的其他许多服务调用。但这并不是重用代码的唯一方法。考虑将这种逻辑打包成库，以便其他组件导入。当然，这只有在所有其他组件都使用相同语言的情况下才可行；否则，是的，微服务模式是唯一的选择。
- en: 'Microservices architecture has the advantage of total decoupling: different
    services can be written in different languages or frameworks, and even be deployed
    independently. They can also be tested in isolation. This comes at a cost. They
    also need a strong contract for clients to know how to interact with this service,
    and they''re also subject to **service-level agreements** (**SLAs**) and **service-level
    objectives** (**SLOs**), respectively.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构具有完全解耦的优势：不同的服务可以用不同的语言或框架编写，甚至可以独立部署。它们也可以单独进行测试。这也有代价。它们还需要强大的客户端合同来了解如何与该服务交互，并且它们也分别受到**服务级别协议**（**SLAs**）和**服务级别目标**（**SLOs**）的约束。
- en: 'They also incur increased latency: having to call external services to get
    data (whether via HTTP or gRPC) takes a toll on the overall performance.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也会产生更高的延迟：需要调用外部服务来获取数据（无论是通过HTTP还是gRPC）都会对整体性能产生影响。
- en: An application composed of fewer services is more rigid and can't be deployed
    independently. It could even be more fragile as it might become a single point
    of failure. On the other hand, it could be more efficient (since we're avoiding
    expensive I/O calls), and we could still achieve a good separation of components
    by using Python packages.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 由较少服务组成的程序更加僵化，无法独立部署。它甚至可能更加脆弱，因为它可能成为单一故障点。另一方面，它可能更有效率（因为我们避免了昂贵的I/O调用），并且我们可以通过使用Python包来实现良好的组件分离。
- en: The food for thought of this section is to ponder the right architectural style
    between creating a new service or using Python packages.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的思考点是考虑在创建新服务或使用Python包之间选择合适的架构风格。
- en: Abstractions
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: This is where encapsulation appears again. When it comes to our systems (as
    we do in relation to code), we want to speak in terms of the domain problem and
    leave the implementation details as hidden as possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是封装再次出现的地方。当我们谈到我们的系统（就像我们对代码所做的那样）时，我们希望用领域问题的术语来谈论，并尽可能隐藏实现细节。
- en: In the same way that code has to be expressive (almost to the point of being
    self-documenting) and have the right abstractions that reveal the solution to
    the essential problem (minimizing accidental complexity), the architecture should
    tell us what the system is about. Details such as the solution used to persist
    data on disk, the web framework of choice, the libraries used to connect to external
    agents, and interaction between systems are not relevant. What is relevant is
    what the system does. A concept such as a screaming architecture (SCREAM) reflects
    this idea.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就像代码必须具有表现力（几乎达到自文档化的程度）并具有正确的抽象来揭示基本问题的解决方案（最小化意外复杂性）一样，架构应该告诉我们系统是关于什么的。诸如用于在磁盘上持久化数据的解决方案、选择的Web框架、用于连接外部代理的库以及系统之间的交互等细节并不相关。相关的是系统做什么。一个如尖叫架构（SCREAM）这样的概念反映了这一想法。
- en: The **Dependency Inversion Principle** (**DIP**), explained in *Chapter 4*,
    *The SOLID Principles*, is of great help in this regard; we don't want to depend
    upon concrete implementations but rather abstractions. In the code, we place abstractions
    (or interfaces) on the boundaries, the dependencies, those parts of the application
    that we don't control and might change in the future. We do this because we want
    to invert the dependencies and let them have to adapt to our code (by having to
    comply with an interface), not the other way round.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖倒置原则**（**DIP**），在第4章“SOLID原则”中解释，在这方面非常有帮助；我们不想依赖于具体的实现，而是抽象。在代码中，我们在边界处放置抽象（或接口），即依赖项，那些我们无法控制且可能在未来发生变化的程序部分。我们这样做是因为我们想要反转依赖关系，并让它们适应我们的代码（通过必须遵守接口），而不是反过来。'
- en: Creating abstractions and inverting dependencies are good practices, but they're
    not enough. We want our entire application to be independent and isolated from
    things that are out of our control. And this goes even further than just abstracting
    with objects—we need layers of abstraction.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 创建抽象和反转依赖是良好的实践，但它们还不够。我们希望我们的整个应用程序独立且与不受我们控制的事物隔离。而且这甚至比仅仅用对象进行抽象还要更进一步——我们需要抽象层。
- en: This is a subtle yet important difference with respect to the detailed design.
    In the DIP, it is recommended to create an interface that could be implemented
    with the `abc` module from the standard library, for instance. Because Python
    works with duck typing, while using an abstract class might be helpful, it's not
    mandatory, as we can easily achieve the same effect with regular objects as long
    as they comply with the required interface.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这与详细设计相比是一个微妙但重要的区别。在依赖倒置原则（DIP）中，建议创建一个接口，该接口可以用标准库中的`abc`模块实现，例如。因为Python使用鸭子类型，虽然使用抽象类可能会有所帮助，但它不是强制性的，只要它们符合所需接口，我们就可以轻松地用常规对象实现相同的效果。
- en: The dynamic typing nature of Python allows us to have these alternatives. When
    thinking in terms of architecture, there is no such thing. As it will become clearer
    with the following example, we need to abstract dependencies entirely, and there
    is no feature of Python that can do that for us.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Python的动态类型特性允许我们有这些替代方案。从架构的角度思考，没有这样的东西。随着以下示例的进一步说明，我们需要完全抽象依赖项，Python没有为我们做到这一点的特性。
- en: 'Some might argue: "Well, the **Object-Relational Mapper** (**ORM**) is a good
    abstraction for a database, isn''t it?" No. The ORM itself is a dependency and,
    as such, is out of our control. It would be even better to create an intermediate
    layer, an adapter, between the API of the ORM and our application.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人可能会争辩：“嗯，对象关系映射器（ORM）是数据库的一个很好的抽象，不是吗？”不。ORM本身是一个依赖项，因此它不受我们控制。创建一个介于ORM
    API和我们的应用程序之间的中间层，一个适配器，会更好。
- en: This means that we don't abstract the database just with an ORM; we use the
    abstraction layer we create on top of it to define objects of our own that belong
    to our domain. If that abstraction just happens to use an ORM underneath, that's
    a coincidence; the domain layer (where our business logic lies) shouldn't be concerned
    with it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们不仅仅用对象关系映射器（ORM）来抽象数据库；我们使用我们在其之上创建的抽象层来定义属于我们领域自己的对象。如果这个抽象恰好使用ORM作为底层，那只是一个巧合；领域层（我们的业务逻辑所在）不应该关心它。
- en: Having abstractions of our own gives us more flexibility and control over the
    application. We might even later decide that we don't want an ORM at all (let's
    say because we want more control over the database engine we're using), and if
    we coupled our application with a specific ORM (or any library in general), it'll
    be harder to change that in the future. The idea is to insulate the core of our
    application from external dependencies we don't have control over.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己的抽象给了我们更多的灵活性和对应用程序的控制。我们甚至可能后来决定我们根本不需要ORM（比如说，因为我们想更多地控制我们使用的数据库引擎），如果我们把应用程序与特定的ORM（或任何库）耦合起来，将来改变这一点会更难。想法是隔离我们应用程序的核心，使其不受我们无法控制的依赖项的影响。
- en: The application then imports this component, and uses the entities provided
    by this layer, but not the other way round. The abstraction layer should not know
    about the logic of our application; it's even truer that the database should know
    nothing about the application itself. If that were the case, the database would
    be coupled to our application. The goal is to invert the dependency—this layer
    provides an API, and every storage component that wants to connect has to conform
    to this API. This is the concept of a *hexagonal architecture* (HEX).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序随后导入这个组件，并使用这一层提供的实体，但反之则不然。抽象层不应该了解我们应用程序的逻辑；甚至更确切地说，数据库不应该了解应用程序本身。如果是那样的话，数据库就会与我们的应用程序耦合。目标是反转依赖关系——这一层提供了一个API，任何想要连接的存储组件都必须符合这个API。这是*六边形架构*（HEX）的概念。
- en: In the next section, we analyze concrete tools that will help us create components
    to use in our architecture.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将分析具体工具，这些工具将帮助我们创建用于我们架构的组件。
- en: Software components
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件组件
- en: We have a large system now, and we need to scale it. It also has to be maintainable.
    At this point, the concerns aren't only technical but also organizational. This
    means it's not just about managing software repositories; each repository will
    most likely belong to an application, and it will be maintained by a team who
    owns that part of the system.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个庞大的系统，我们需要对其进行扩展。它还必须易于维护。在这个阶段，问题不仅仅是技术性的，还包括组织性的。这意味着这不仅仅是管理软件仓库；每个仓库很可能会属于一个应用程序，并且将由拥有该系统部分的所有团队进行维护。
- en: This demands that we keep in mind how a large system is divided into different
    components. This can have many phases, from a very simple approach about, say,
    creating Python packages, to more complex scenarios in a microservice architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们牢记如何将大型系统划分为不同的组件。这可以有许多阶段，从创建Python包的非常简单的方法，到微服务架构中的更复杂场景。
- en: The situation could be even more complex when different languages are involved,
    but in this chapter, we will assume they are all Python projects.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及不同的语言时，情况可能会更加复杂，但在这个章节中，我们将假设它们都是Python项目。
- en: These components need to interact, as do the teams. The only way this can work
    at scale is if all the parts agree on an interface, a contract.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件需要相互交互，就像团队一样。要在规模上有效工作，唯一的方法是所有部分都同意一个接口，一个合同。
- en: Packages
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: A Python package is a convenient way to distribute software and reuse code in
    a more general way. Packages that have been built can be published to an artifact
    repository (such as an internal PyPi server for the company), from where they
    will be downloaded by the rest of the applications that require them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Python包是分发软件和以更通用方式重用代码的便捷方式。构建好的包可以发布到工件仓库（如公司内部的PyPi服务器），然后其他需要这些包的应用程序将从中下载。
- en: The motivation behind this approach has many elements to it—it's about reusing
    code at large, and also achieving conceptual integrity.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的动机有很多方面——它关乎代码的重用，也关乎概念完整性。
- en: Here, we discuss the basics of packaging a Python project that can be published
    in a repository. The default repository might be PyPi (the *Python Package Index*,
    at [https://pypi.org/](https://pypi.org/)), but also could be internal; or custom
    setups will work with the same basics.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们讨论将Python项目打包成可以在仓库中发布的基本知识。默认仓库可能是PyPi（Python包索引，[https://pypi.org/](https://pypi.org/)），但也可能是内部的；或者自定义设置也可以使用相同的原理。
- en: We are going to simulate that we have created a small library, and we will use
    that as an example to review the main points to take into consideration.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将模拟我们已经创建了一个小型库，并将使用它作为例子来回顾需要考虑的主要点。
- en: Aside from all the open-source libraries available, sometimes we might need
    some extra functionality—perhaps our application uses a particular idiom repeatedly
    or relies on a function or mechanism quite heavily and the team has devised a
    better function for these particular needs. In order to work more effectively,
    we can place this abstraction into a library, and encourage all team members to
    use the idioms as provided by it, because doing so will help avoid mistakes and
    reduce bugs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了所有可用的开源库之外，有时我们可能需要一些额外的功能——也许我们的应用程序反复使用特定的习语，或者非常依赖某个函数或机制，并且团队已经为这些特定需求设计了一个更好的函数。为了更有效地工作，我们可以将这个抽象放入库中，并鼓励所有团队成员使用它提供的习语，因为这样做将有助于避免错误并减少bug。
- en: That's typically the case when you own a service and a client library for that
    service. You don't want clients calling your API directly, so instead, you provide
    them with a client library. The code for this library will be wrapped into a Python
    package and distributed through the internal package management systems.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是你拥有某个服务及其客户端库时的情况。你不想让客户端直接调用你的API，所以相反，你为他们提供一个客户端库。这个库的代码将被封装成Python包并通过内部包管理系统进行分发。
- en: Potentially, there are infinite examples that could suit this scenario. Maybe
    the application needs to extract a lot of `.tar.gz` files (in a particular format)
    and has faced security problems in the past with malicious files that ended up
    with path traversal attacks.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在无限多的例子可以适应这种情况。也许应用程序需要提取大量的`.tar.gz`文件（以特定格式），并且过去在恶意文件中遇到了路径遍历攻击的安全问题。
- en: As a mitigation measure, the functionality for abstracting custom file formats
    securely was put in a library that wraps the default one and adds some extra checks.
    This sounds like a good idea.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种缓解措施，抽象自定义文件格式安全性的功能被放入了一个库中，该库包装了默认的库并添加了一些额外的检查。这听起来是个好主意。
- en: Or maybe there is a configuration file that has to be written, or parsed in
    a particular format, and this requires many steps to be followed in order; again,
    creating a helper function to wrap this, and using it in all the projects that
    need it, constitutes a good investment, not only because it saves a lot of code
    repetition, but also because it makes it harder to make mistakes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可能需要编写或解析特定格式的配置文件，这需要遵循许多步骤；再次，创建一个辅助函数来封装这个操作，并在所有需要它的项目中使用它，这是一种很好的投资，不仅因为它节省了大量代码重复，而且还因为它使得出错的可能性更小。
- en: The gain is not only complying with the DRY principle (avoiding code duplication,
    encouraging reuse) but also that the abstracted functionality represents a single
    point of reference of how things should be done, hence contributing to the attainment
    of conceptual integrity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 获得的收益不仅符合 DRY 原则（避免代码重复，鼓励重用），而且抽象的功能代表了一个单一的参考点，说明了事情应该如何完成，从而有助于实现概念完整性。
- en: 'In general, the minimum layout for a library would look like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，库的最小布局看起来像这样：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The important part is the `setup.py` file, which contains the definition for
    the package. In this file, all the important definitions of the project (its requirements,
    dependencies, name, description, and so on) are specified.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是 `setup.py` 文件，它包含包的定义。在这个文件中，指定了项目的重要定义（其需求、依赖项、名称、描述等）。
- en: The `apptool` directory under `src` is the name of the library we're working
    on. This is a typical Python project, so we place here all the files we need.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`src` 下的 `apptool` 目录是我们正在工作的库的名称。这是一个典型的 Python 项目，因此我们将所有需要的文件都放在这里。'
- en: 'An example of the `setup.py` file could be:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py` 文件的示例可能如下：'
- en: '[PRE1]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This minimal example contains the key elements of the project. The `name` argument
    in the `setup` function is used to give the name that the package will have in
    the repository (under this name, we run the command to install it; in this case,
    it's `pip install apptool`). It's not strictly required that it matches the name
    of the project directory (`src/apptool`), but it's highly recommended, so it's
    easier for users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个最小示例包含了项目的关键元素。`setup` 函数中的 `name` 参数用于指定包在仓库中的名称（使用此名称运行安装命令；在这种情况下，它是 `pip
    install apptool`）。它并不严格要求它与项目目录的名称（`src/apptool`）匹配，但强烈推荐这样做，这样用户使用起来更方便。
- en: In this case, since both names match, it's easier to see the relationship between
    `pip install apptool` and then, in our code, `from apptool import myutil`. But
    the latter corresponds to the name under the `src/` directory and the former to
    the one specified in the `setup.py` file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于两个名称匹配，因此更容易看到 `pip install apptool` 和我们代码中的 `from apptool import myutil`
    之间的关系。但后者对应于 `src/` 目录下的名称，而前者对应于在 `setup.py` 文件中指定的名称。
- en: The version is important to keep different releases going on, and then the packages
    are specified. By using the `find_packages()` function, we automatically discover
    everything that's a package, in this case under the `src/` directory. Searching
    under this directory helps to avoid mixing up files beyond the scope of the project
    and, for instance, accidentally releasing tests or a broken structure of the project.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 版本很重要，可以保持不同版本的发布，并指定包。通过使用 `find_packages()` 函数，我们可以自动发现所有是包的内容，在这种情况下是在 `src/`
    目录下。在目录下搜索有助于避免将超出项目范围之外的文件混合在一起，例如，意外发布测试或项目结构的损坏。
- en: 'A package is built by running the following commands, assuming its run inside
    a virtual environment with the dependencies installed:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行以下命令构建包，假设它在已安装依赖项的虚拟环境中运行：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will place the artifacts in the `dist/` directory, from where they can
    later be published either to PyPi or to the internal package repository of the
    company.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将工件放置在 `dist/` 目录中，从这里可以稍后将其发布到 PyPi 或公司的内部包仓库。
- en: 'The key points in packaging a Python project are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打包 Python 项目的关键点包括：
- en: Test and verify that the installation is platform-independent and that it doesn't
    rely on any local setup (this can be achieved by placing the source files under
    an `src/` directory). This means that the package that is constructed should not
    depend upon files that are on your local machine and won't be available when shipped
    (nor in a custom directory structure).
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和验证安装是否与平台无关，并且不依赖于任何本地设置（这可以通过将源文件放在 `src/` 目录下实现）。这意味着构建的包不应依赖于您本地机器上的文件，并且在分发时（或在自定义目录结构中）将不可用。
- en: Make sure that unit tests aren't shipped as part of the package being built.
    This is meant for production. In the Docker image that will run in production,
    you don't need extra files (for example, the fixtures) that aren't strictly needed.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保单元测试不是作为正在构建的包的一部分进行分发。这是针对生产的。在生产环境中运行的Docker镜像不需要非严格必需的额外文件（例如，固定装置）。
- en: Separate dependencies—what the project strictly needs to run is not the same
    as what developers require.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离依赖项——项目严格需要的运行内容与开发者需要的并不相同。
- en: It's a good idea to create entry points for the commands that are going to be
    required the most.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建最常需要的命令的入口点是个好主意。
- en: The `setup.py` file supports multiple other parameters and configurations and
    can be affected in a much more complicated manner. If our package requires several
    operating system libraries to be installed, it's a good idea to write some logic
    in the `setup.py` file to compile and build the extensions that are required.
    This way, if something is amiss, it will fail early on in the installation process,
    and if the package provides a helpful error message, the user will be able to
    fix the dependencies more quickly and continue.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py`文件支持多种其他参数和配置，并且可以以更复杂的方式受到影响。如果我们的包需要安装几个操作系统库，那么在`setup.py`文件中编写一些逻辑来编译和构建所需的扩展是个好主意。这样，如果出现问题，它将在安装过程的早期失败，如果包提供了一个有用的错误消息，用户将能够更快地修复依赖项并继续。'
- en: Installing such dependencies represents another difficult step in making the
    application ubiquitous and easy to run by any developer regardless of their platform
    of choice. The best way to surmount this obstacle is to abstract the platform
    by creating a Docker image, as we will discuss in the next section.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 安装这样的依赖项是使应用程序无处不在且任何开发者都能轻松运行（无论他们选择什么平台）的另一个困难步骤。克服这个障碍的最佳方法是通过创建Docker镜像来抽象平台，正如我们将在下一节中讨论的那样。
- en: Managing dependencies
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理依赖项
- en: 'Before describing how we''ll leverage Docker containers to deliver our application,
    it''s important to take a look at a **Software Configuration Management** (**SCM**)
    issue, namely: how do we list the dependencies for our applications, so that they''re
    repeatable?'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述我们将如何利用Docker容器交付我们的应用程序之前，重要的是要审视一个**软件配置管理**（**SCM**）问题，即：我们如何列出应用程序的依赖项，以便它们是可重复的？
- en: Keep in mind that issues in software might not only come from our code. External
    dependencies also impact the final delivery. At all times, you'd want to know
    the full list of packages and their versions that were delivered. This is called
    a baseline.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，软件问题可能不仅来自我们的代码。外部依赖项也会影响最终交付。在任何时候，你都想了解所交付的完整包列表及其版本。这被称为基线。
- en: 'The idea is that if at any time a dependency introduced an issue with our software,
    you''d want to be able to pinpoint it quickly. More importantly, you''d also want
    your builds to be repeatable: given everything else is unchanged, a new build
    should produce the exact same artifacts as the last one.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，如果在任何时候引入的依赖项给我们的软件带来了问题，你希望能够快速定位它。更重要的是，你还希望你的构建是可重复的：在所有其他内容不变的情况下，新的构建应该产生与上一个构建完全相同的工件。
- en: The software is delivered to production by following a development pipeline.
    This starts in a first environment, then the tests run on it (integration, acceptance,
    and so on), and then through continuous integration and continuous deployment,
    it moves through the different stages of the pipeline (for example, if you have
    a beta-testing environment, or pre-production before it ultimately reaches production).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 软件通过遵循开发管道被交付到生产环境中。这个过程从第一个环境开始，然后在该环境中运行测试（集成、验收等），接着通过持续集成和持续部署，它将穿过管道的不同阶段（例如，如果你有一个beta测试环境，或者在生产之前有一个预生产环境）。
- en: Docker is great at ensuring the exact same image is moved along the pipeline,
    but there's no guarantee that if you run the same version of the code (the same
    `git commit`, let's say) again through the pipeline, you'll get the same results.
    That work is on us, and it's what we're exploring in this section.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Docker擅长确保沿管道移动的图像完全相同，但无法保证如果你再次通过管道运行相同的代码版本（例如，相同的`git commit`），你会得到相同的结果。这项工作是我们自己的，也是我们在本节中要探讨的。
- en: 'Let''s say the `setup.py` file of our web package looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的网络包的`setup.py`文件如下所示：
- en: '[PRE3]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In this case, there''s only one dependency (declared in the `install_requires`
    parameter), and it''s controlling a version interval. This is usually a good practice:
    we want to at least work with a specific version of a package, but we are also
    interested in not going beyond the next major version (as major versions can carry
    backward-incompatible changes).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，只有一个依赖项（在 `install_requires` 参数中声明），它控制着一个版本区间。这通常是一个好的实践：我们希望至少使用特定版本的包，但我们也对不超过下一个主要版本感兴趣（因为主要版本可能包含向后不兼容的更改）。
- en: We set the versions like this because we're interested in getting updates for
    our dependencies (there are tools like `Dependabot`—[https://dependabot.com/](https://dependabot.com/)—that
    automatically detect when there are new releases for our dependencies and can
    open a new `pull` request), but we still want to know the exact version that was
    installed at any given time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样设置版本是因为我们对我们依赖项的更新感兴趣（有像 `Dependabot` ([https://dependabot.com/](https://dependabot.com/))
    这样的工具，它可以自动检测依赖项的新版本发布，并可以打开一个新的 `pull` 请求），但我们仍然想了解任何给定时间安装的确切版本。
- en: Not only that, but we also want to track the full tree of dependencies, meaning
    transitive dependencies should also be listed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想跟踪完整的依赖项树，这意味着应该列出传递依赖项。
- en: One way of doing that is by using pip-tools ([https://github.com/jazzband/pip-tools](https://github.com/jazzband/pip-tools))
    and compiling the `requirements.txt` file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的其中一种方法是通过使用 pip-tools ([https://github.com/jazzband/pip-tools](https://github.com/jazzband/pip-tools))
    并编译 `requirements.txt` 文件。
- en: 'The idea is to use this tool to generate the requirements file from the `setup.py`
    file, like so:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是使用此工具从 `setup.py` 文件生成需求文件，如下所示：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will generate a `requirements.txt` file that we are going to use in our
    `Dockerfile` to install the dependencies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个 `requirements.txt` 文件，我们将使用它来在 `Dockerfile` 中安装依赖项。
- en: Always install the dependencies in your `Dockerfile` from the `requirements.txt`
    file, in order to have builds that are deterministic from the point of view of
    version control.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保从版本控制的角度来看构建的可确定性，始终应从 `requirements.txt` 文件安装 `Dockerfile` 中的依赖项。
- en: The file that lists the requirements should be placed under version control,
    and whenever we want to upgrade a dependency, we run the command again with the
    `–U` flag and track the new version of the requirements file.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列出需求项的文件应置于版本控制之下，每次我们想要升级依赖项时，我们再次使用带有 `–U` 标志的命令，并跟踪需求文件的新版本。
- en: Having all dependencies listed is not only good for repeatability, but it also
    adds clarity. If you are using many dependencies, it can happen that there are
    some conflicts with versions, and this will be easier to spot if we know which
    package imports which library (and on what version). But once again, this is only
    part of the problem. There are more considerations we need to take into account
    when dealing with dependencies.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列出所有依赖项不仅有利于可重复性，还能增加清晰度。如果你使用了许多依赖项，可能会出现版本冲突的情况，如果我们知道哪个包导入了哪个库（以及其版本），这将更容易被发现。但再次强调，这仅仅是问题的一部分。在处理依赖项时，我们还需要考虑更多因素。
- en: Other considerations when managing dependencies
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理依赖项时的其他考虑因素
- en: By default, when installing dependencies, `pip` will use the public repository
    from the internet ([https://pypi.org/](https://pypi.org/)). It's also possible
    to install from other indexes, or even version control systems.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在安装依赖项时，`pip` 将使用互联网上的公共仓库（[https://pypi.org/](https://pypi.org/)）。也可以从其他索引或版本控制系统安装。
- en: This has some problems and limitations. For starters, you will depend on the
    availability of those services. There's also the caveat that you won't be able
    to publish your internal packages (which contain your company's intellectual property)
    on a public repository. And finally, there's the problem that we don't really
    know for sure how reliable or trustworthy some of the authors are in terms of
    keeping the versions of the artifacts accurate and secure (for example, some authors
    might want to republish a different version of the code with the same version
    number, something that's obviously wrong and not allowed, but all systems have
    flaws). I don't recall a particular issue like this in Python, but I do remember
    a few years ago this happened in the JavaScript community when someone deleted
    a package from the NPM registry (REGISTER01), and by unpublishing this library,
    lots of other builds broke. Even if PyPi doesn't allow this, we don't want to
    be at the mercy of someone else's good (or bad) faith.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一些问题和局限性。首先，您将依赖于这些服务的可用性。还有这样的限制，您无法在公共仓库上发布包含您公司知识产权的内部软件包。最后，还有一个问题，我们并不真正确信一些作者在保持工件版本准确和安全方面的可靠性和可信度（例如，一些作者可能想要以相同的版本号重新发布不同版本的代码，这显然是错误的，也是不允许的，但所有系统都有缺陷）。我不记得在Python中遇到过这样的特定问题，但几年前我确实记得在JavaScript社区中发生过这样的事情，有人从NPM注册表中删除了一个软件包（REGISTER01），通过取消发布这个库，许多其他构建都失败了。即使PyPi不允许这样做，我们也不想受制于他人的善意（或恶意）。
- en: 'The solution is simple: your company must have an internal server for dependencies,
    and all builds must target this internal repository. Regardless of how this is
    implemented (on-premises, on the cloud, by using an open-source tool, or by outsourcing
    to a provider) the idea is that new, needed dependencies have to be added to this
    repository, and this is also where the internal packages are published as well.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案很简单：您的公司必须有一个用于依赖项的内部服务器，并且所有构建都必须针对这个内部仓库。无论这是如何实现的（本地、云上、使用开源工具或外包给提供商），想法是必须将新的、所需的依赖项添加到这个仓库中，内部软件包也在这里发布。
- en: Make sure this internal repository gets updated and configure all repositories
    to receive upgrades when new versions of your dependencies are made available.
    Keep in mind that this is also another form of technical debt. There are several
    reasons for this. As we've discussed in previous chapters, technical debt is not
    just about poorly written code. When new technology is made available, you're
    missing out on those features, which means you could probably be making better
    use of the technology available. More importantly, packages might have security
    vulnerabilities that are discovered over time, so you'd want to upgrade to make
    sure your software is patched.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确保这个内部仓库得到更新，并配置所有仓库在您的依赖项有新版本可用时接收升级。请记住，这也是技术债务的另一种形式。这里有几个原因。正如我们在前面的章节中讨论的那样，技术债务不仅仅是关于代码编写得不好。当新技术可用时，您会错过那些特性，这意味着您可能能够更好地利用可用的技术。更重要的是，软件包可能存在随着时间的推移而被发现的漏洞，因此您希望升级以确保您的软件得到修补。
- en: Having outdated versions of dependencies is another form of technical debt.
    Make the habit of using the latest versions available of your dependencies.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用过时的依赖项版本是另一种形式的技术债务。养成使用您依赖项最新版本的习惯。
- en: 'Don''t let too much time pass before upgrading dependencies because the more
    you wait, the harder it will be to catch up. After all, that''s the whole point
    of continuous integration: you''d want to integrate changes (including new dependencies)
    continuously, in an incremental way, provided you have automated tests that run
    as part of the build and act as a safety net for regressions.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在升级依赖项之前不要让太多时间过去，因为您等待的时间越长，追赶上就越困难。毕竟，这就是持续集成的全部意义：您希望以增量方式持续集成更改（包括新的依赖项），前提是您有作为构建一部分运行的自动化测试，并作为回归的安全网。
- en: Configure a tool that automatically sends pull requests for new versions of
    your dependencies, and also configure automatic security checks on them.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 配置一个工具，它会自动为新版本的依赖项发送拉取请求，并配置对它们的自动安全检查。
- en: This workflow should require minimal work. The idea is that you configure the
    `setup.py` file of your project with a range of versions and have the requirements
    file. When there are new versions available, the tool you've configured for your
    repository will rebuild the requirements file, which will list all packages and
    their new versions (which will show up in the difference of the `pull` request
    the tool opens). If the build is green, and there's nothing suspicious in the
    difference the `pull` request shows, you can go ahead and `merge`, trusting the
    continuous integration would have caught the issues. If, on the other hand, the
    build fails, that will require your intervention to adjust.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程应该需要最少的工作。想法是，你配置你的项目的 `setup.py` 文件以一系列版本，并拥有需求文件。当有新版本可用时，你为你的仓库配置的工具将重建需求文件，该文件将列出所有包及其新版本（这些新版本将显示在工具打开的
    `pull` 请求的差异中）。如果构建是绿色的，且 `pull` 请求显示的差异中没有可疑之处，你可以继续进行 `merge`，相信持续集成已经捕获了问题。另一方面，如果构建失败，这将需要你介入调整。
- en: Artifact versions
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工件版本
- en: There's a trade-off between stability and cutting-edge software. Having the
    latest versions is usually positive, because it means we get the latest features
    and bug fixes just by upgrading. That's when the new version doesn't bring incompatible
    changes (the downside). For that reason, software is managed in versions with
    a clear meaning.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在稳定性和前沿软件之间有一个权衡。拥有最新版本通常是积极的，因为这意味着我们只需升级就能获得最新的特性和错误修复。这就是新版本不会带来不兼容的更改（缺点）。因此，软件以具有明确意义的版本进行管理。
- en: When we establish a range of desired versions, we want to get upgrades, but
    at the same time not be too aggressive and break the application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们确定所需版本的范围时，我们希望获得升级，但同时又不要太激进，以免破坏应用程序。
- en: If we only upgrade the dependencies and write the new version of the requirements
    file, we should be publishing a new version of our artifact (after all, we're
    delivering something new, hence different). This can be a minor or micro version,
    but the important part is that we have to abide by the same rules we expect from
    third-party libraries when we're publishing our own custom artifacts.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只升级依赖项并编写新的需求文件版本，我们应该发布我们工件的新版本（毕竟，我们在交付新的东西，因此是不同的）。这可以是一个小版本或微版本，但重要的是我们必须遵守与第三方库发布我们自己的定制工件时相同的规则。
- en: A good reference for this in Python is PEP-440 ([https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)),
    which describes how to set the version numbers in the `setup.py` file for our
    libraries.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，PEP-440 ([https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/))
    是一个很好的参考，它描述了如何在 `setup.py` 文件中设置我们库的版本号。
- en: In the next section, we take a look at a different technology that will also
    help us create components to deliver our code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种不同的技术，它也将帮助我们创建组件以交付我们的代码。
- en: Docker containers
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker 容器
- en: This chapter is dedicated to architecture, so the term container refers to something
    completely different from a Python container (an object with a `__contains__`
    method), explored in *Chapter 2*, *Pythonic Code*. A container is a process that
    runs in the operating system under a group with certain restrictions and isolation
    considerations. Concretely, we refer to `Docker` containers, which allow managing
    applications (services or processes) as independent components.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门讨论架构，因此“容器”一词指的是与第 2 章“Pythonic 代码”中探讨的 Python 容器（具有 `__contains__` 方法的对象）完全不同的东西。容器是在操作系统下以具有某些限制和隔离考虑的组运行的过程。具体来说，我们指的是
    `Docker` 容器，它允许将应用程序（服务或进程）作为独立组件进行管理。
- en: Containers represent another way of delivering software. Creating Python packages
    that take into account the considerations in the previous section is more suitable
    for libraries, or frameworks, where the goal is to reuse code and take advantage
    of using a single place where specific logic is gathered.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 容器代表了另一种软件交付的方式。创建考虑了上一节内容的 Python 包更适合用于库或框架，在这些场景中，目标是重用代码并利用将特定逻辑集中在一个地方的优势。
- en: In the case of containers, the objective will not be creating libraries but
    applications (most of the time). However, an application or platform does not
    necessarily mean an entire service. The idea of building containers is to create
    small components that represent a service with a small and clear purpose.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器的情况下，目标不是创建库而是应用程序（大多数时候）。然而，一个应用程序或平台并不一定意味着一个完整的服务。构建容器的想法是创建代表具有小而明确目的的服务的小型组件。
- en: In this section, we will mention Docker when we talk about containers, and we
    will explore the basics of how to create Docker images and containers for Python
    projects. Keep in mind that this is not the only technology for launching applications
    into containers, and also that it's completely independent of Python.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，当我们讨论容器时，我们会提到Docker，并探讨如何为Python项目创建Docker镜像和容器的基础知识。请记住，这并不是将应用程序部署到容器中的唯一技术，而且它与Python完全独立。
- en: A Docker container needs an image to run on, and this image is created from
    other base images. But the images we create can themselves serve as base images
    for other containers. We will want to do that in cases where there is a common
    base in our application that can be shared across many containers. A potential
    use would be creating a base image that installs a package (or many) in the way
    we described in the previous section, and also all of its dependencies, including
    those at the operating system level. As discussed in *Chapter 9*, *Common Design
    Patterns*, a package we create can depend not only on other Python libraries,
    but also on a particular platform (a specific operating system), and particular
    libraries preinstalled in that operating system, without which the package will
    simply not install and will fail.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器需要有一个镜像来运行，而这个镜像是由其他基础镜像创建的。但我们创建的镜像本身也可以作为其他容器的基镜像。我们希望在应用程序中存在一个共同的基，可以在许多容器之间共享的情况下这样做。一个潜在的使用案例是创建一个基镜像，按照我们在上一节中描述的方式安装一个包（或多个），以及所有依赖项，包括操作系统级别的依赖项。正如在第9章“通用设计模式”中讨论的那样，我们创建的包不仅可能依赖于其他Python库，也可能依赖于特定的平台（特定的操作系统），以及在该操作系统中预先安装的特定库，没有这些库，包将无法安装并会失败。
- en: Containers are a great portability tool for this. They can help us ensure that
    our application will have a canonical way of running, and they will also ease
    the development process a lot (reproducing scenarios across environments, replicating
    tests, on-boarding new team members, and so on).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是这一点的绝佳便携工具。它们可以帮助我们确保我们的应用程序将以标准化的方式运行，并且它们也将极大地简化开发过程（在各个环境中重现场景、复制测试、接纳新团队成员等）。
- en: Docker helps avoid platform-dependent issues. The idea is that we package our
    Python application as a Docker container image, and this will be useful for developing
    and testing locally, as well as for launching our software in production.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Docker帮助避免平台依赖问题。其理念是将我们的Python应用程序打包成一个Docker容器镜像，这对于本地开发和测试以及在生产环境中部署我们的软件都非常有用。
- en: 'Typically, in the past, Python was hard to deploy because of its nature. Since
    it''s an interpreted language, the code you write will be run by the Python virtual
    machine on the host on production. So, you need to make sure the target platform
    will have the version of the interpreter you''re expecting it to have. Moreover,
    the packaging of the dependencies was also hard: this was done by packaging everything
    into a virtual environment and running it. Things got harder if you had platform-dependent
    specifics, and some of your dependencies used C extensions. And here I''m not
    even talking about Windows or Linux; sometimes, even different versions of Linux
    (Debian-based versus Red Hat-based) had different versions of the C libraries
    needed for the code to run, so the only true way to test your application and
    make sure it''d run properly was to use a virtual machine, and compile everything
    against the right architecture. In modern applications, most of those pains should
    go away. Now you''ll have a `Dockerfile` in your root directory, with the instructions
    to build that application. And your application is delivered in production also
    by running it in Docker.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在过去，Python的部署很困难，因为它的本质。由于它是一种解释型语言，你编写的代码将在生产主机上的Python虚拟机上运行。因此，你需要确保目标平台将具有你期望的解析器版本。此外，依赖项的打包也很困难：这是通过将所有内容打包到虚拟环境中并运行来完成的。如果你有平台相关的特定需求，并且一些依赖项使用了C扩展，事情会变得更复杂。而且我甚至还没有提到Windows或Linux；有时，即使是不同的Linux版本（基于Debian与基于Red
    Hat）也需要不同的C库版本，以便代码能够运行，所以唯一真正测试你的应用程序并确保它能够正确运行的方法是使用虚拟机，并针对正确的架构编译一切。在现代应用程序中，这些痛苦中的大多数都应该消失。现在你将在根目录中有一个`Dockerfile`，其中包含构建该应用程序的指令。并且你的应用程序在生产中也是通过在Docker中运行来交付的。
- en: Just as packages are the way we reuse code and unify criteria, containers represent
    the way we create the different services of the application. They meet the criteria
    behind the principle of **Separation of Concerns** (**SoC**) of the architecture.
    Each service is another kind of component that will encapsulate a set of functionalities
    independently of the rest of the application. These containers ought to be designed
    in such a way that they favor maintainability—if the responsibilities are clearly
    divided, a change in a service should not impact any other part of the application
    whatsoever.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 正如包是我们在代码中重用和统一标准的方式一样，容器代表了创建应用程序不同服务的方式。它们符合架构中**关注点分离**（**SoC**）原则背后的标准。每个服务都是另一种类型的组件，它将独立于应用程序的其他部分封装一组功能。这些容器应该设计得有利于可维护性——如果责任划分清晰，服务中的任何更改都不应影响应用程序的任何其他部分。
- en: We cover the basics of how to create a Docker container from a Python project
    in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍如何从Python项目创建Docker容器的基础知识。
- en: Use case
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: As an example of how we might organize the components of our application, and
    how the previous concepts might work in practice, we present the following simple
    example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们可能如何组织应用程序组件的例子，以及先前概念如何在实践中工作的例子，我们提供了一个以下简单的示例。
- en: The use case is that there is an application for delivering food, and this application
    has a specific service for tracking the status of each delivery at its different
    stages. We are going to focus only on this particular service, regardless of how
    the rest of the application might appear. The service has to be really simple—a
    REST API that, when asked about the status of a particular order, will return
    a JSON response with a descriptive message.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用例是这样的：有一个用于送餐的应用程序，并且这个应用程序有一个特定服务，用于跟踪每个配送在不同阶段的状况。我们将只关注这个特定的服务，而不管应用程序的其他部分可能看起来如何。这个服务必须非常简单——一个REST
    API，当询问特定订单的状态时，将返回一个包含描述性信息的JSON响应。
- en: We are going to assume that the information about each particular order is stored
    in a database, but this detail should not matter at all.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设每个特定订单的信息存储在数据库中，但这个细节根本不重要。
- en: 'Our service has two main concerns for now: getting the information about a
    particular order (from wherever this might be stored), and presenting this information
    in a useful way to the clients (in this case, delivering the results in JSON format,
    exposed as a web service).'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务目前有两个主要关注点：获取有关特定订单的信息（无论这些信息可能存储在哪里），以及以有用的方式向客户端展示这些信息（在这种情况下，以JSON格式交付结果，作为Web服务公开）。
- en: 'As the application has to be maintainable and extensible, we want to keep these
    two concerns as hidden as possible and focus on the main logic. Therefore, these
    two details are abstracted and encapsulated into Python packages that the main
    application with the core logic will use, as shown in *Figure 10.1*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于应用程序必须可维护和可扩展，我们希望尽可能隐藏这两个关注点，并专注于主要逻辑。因此，这两个细节被抽象化和封装到主应用程序将使用的Python包中，如图*10.1*所示：
- en: '![](img/16567_10_01.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/16567_10_01.png)'
- en: 'Figure 10.1: A service application (named "Web service") that makes use of
    two Python packages, one of which connects to a database.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1：一个服务应用程序（命名为“Web服务”），它使用了两个Python包，其中一个连接到数据库。
- en: In the following sections, we briefly demonstrate how the code might appear,
    in terms of the packages mainly, and how to create services from these, in order
    to finally see what conclusions we can infer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将简要展示代码可能的样子，主要是关于包的，以及如何从这些包中创建服务，以便最终看到我们可以得出什么结论。
- en: The code
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码
- en: The idea of creating Python packages in this example is to illustrate how abstracted
    and isolated components can be made, in order to work effectively. In reality,
    there is no actual need for these to be Python packages; we could just create
    the right abstractions as part of the "delivery service" project, and, while the
    correct isolation is preserved, it will work without any issues.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中创建Python包的想法是为了说明如何创建抽象化和隔离的组件，以便有效地工作。实际上，并没有真正需要它们成为Python包；我们可以在“交付服务”项目中创建正确的抽象，同时保持正确的隔离，这样它将没有任何问题。
- en: Creating packages makes more sense when there is logic that is going to be repeated
    and is expected to be used across many other applications (that will import from
    those packages) because we want to favor code reuse. In this particular case,
    there are no such requirements, so it might be beyond the scope of the design,
    but such distinction still makes clearer the idea of a "pluggable architecture"
    or component, something that is really a wrapper abstracting technical details
    we don't really want to deal with, much less depend upon.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在将要重复的逻辑并且预期将在许多其他应用程序（将从中导入这些包）中使用时，创建包更有意义，因为我们希望优先考虑代码重用。在这个特定的情况下，没有这样的要求，所以它可能超出了设计的范围，但这种区分仍然使“可插拔架构”或组件的概念更加清晰，这实际上是一个封装技术细节的包装器，我们根本不想处理，更不用说依赖了。
- en: The `storage` package is in charge of retrieving the data that is required and
    presenting this to the next layer (the delivery service) in a convenient format,
    something that is suitable for the business rules. The main application should
    now know where this data came from, what its format is, and so on. This is the
    entire reason why we have such an abstraction in between, so the application doesn't
    use a row or an ORM entity directly, but rather something workable.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`包负责检索所需的数据并以方便的格式将其呈现给下一层（交付服务），这对于业务规则来说是合适的。主应用程序现在应该知道这些数据来自哪里，其格式是什么，等等。这就是我们为什么在中间有一个这样的抽象的原因，这样应用程序就不直接使用行或ORM实体，而是使用可操作的东西。'
- en: Domain models
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 领域模型
- en: The following definitions apply to classes for business rules. Notice that they
    are meant to be pure business objects, not bound to anything in particular. They
    aren't models of an ORM, or objects of an external framework, and so on. The application
    should work with these objects (or objects with the same criteria).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定义适用于业务规则的类。请注意，它们旨在成为纯业务对象，不与特定事物绑定。它们不是ORM的模型，也不是外部框架的对象，等等。应用程序应与这些对象（或具有相同标准的对象）一起工作。
- en: 'In each case, the docstring documents the purpose of each class, according
    to the business rule:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，文档字符串根据业务规则记录了每个类的目的：
- en: '[PRE5]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: From this code, we can already get an idea of what the application will look
    like—we want to have a `DeliveryOrder` object, which will have its own status
    (as an internal collaborator), and once we have that, we will call its `message()`
    method to return this information to the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码中，我们已能对应用程序的外观有一个大致的了解——我们希望有一个`DeliveryOrder`对象，它将有自己的状态（作为一个内部合作者），一旦我们有了这个，我们就会调用它的`message()`方法将此信息返回给用户。
- en: Calling from the application
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从应用程序调用
- en: 'This is how these objects are going to be used in the application. Notice how
    this depends on the previous packages (`web` and `storage`), but not the other
    way round:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象将在应用程序中使用。请注意，这取决于之前的包（`web`和`storage`），而不是反过来：
- en: '[PRE6]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the previous section, the `domain` objects were shown and here the code for
    the application is displayed. Aren't we missing something? Sure, but is it something
    we really need to know now? Not necessarily.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中展示了`domain`对象，而在这里展示了应用程序的代码。我们是不是遗漏了什么？当然，但我们现在真的需要知道这些吗？不一定。
- en: The code inside the `storage` and `web` packages was deliberately left out (although
    the reader is more than encouraged to look at it—the repository for the book contains
    the full example). Also, and this was done on purpose, the names of such packages
    were chosen so as not to reveal any technical details—`storage` and `web`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`storage`和`web`包内的代码被故意省略了（尽管读者被鼓励查看它——本书的仓库包含了完整的示例）。此外，这也是故意为之的，这些包的名称被选择得不会泄露任何技术细节——`storage`和`web`。'
- en: Look again at the code in the previous listing. Can you tell which frameworks
    are being used? Does it say whether the data comes from a text file, a database
    (if so, of what type? SQL? NoSQL?), or another service (the web, for instance)?
    Assume that it comes from a relational database. Is there any clue as to how this
    information is retrieved (manual SQL queries? Through an ORM?)?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次查看前一部分中的代码。你能说出使用了哪些框架吗？它是否说明了数据来自文本文件、数据库（如果是的话，是什么类型的？SQL？不是SQL？）或另一个服务（例如，网络）？假设它来自关系数据库。是否有任何线索表明如何检索这些信息（手动SQL查询？通过ORM？）？
- en: What about the web? Can we guess what frameworks are used?
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那网络呢？我们能猜出使用了哪些框架吗？
- en: The fact that we cannot answer any of these questions is probably a good sign.
    Those are details, and details ought to be encapsulated. We can't answer these
    questions unless we take a look at what's inside those packages.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法回答这些问题的事实可能是一个好兆头。这些都是细节，而细节应该被封装起来。除非我们查看那些包内部的内容，否则我们无法回答这些问题。
- en: 'There is another way of answering the previous questions, and it comes in the
    form of a question itself: why do we need to know that? Looking at the code, we
    can see that there is a `DeliveryOrder`, created with an identifier of a delivery,
    and that it has a `get()` method, which returns an object representing the status
    of the delivery. If all of this information is correct, that''s all we should
    care about. What difference does it make how it is done?'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种回答上述问题的方法是以一个问题本身的形式出现：我们为什么需要知道这个？查看代码，我们可以看到有一个`DeliveryOrder`，它使用一个交付的标识符创建，并且它有一个`get()`方法，该方法返回表示交付状态的对象。如果所有这些信息都是正确的，那么这就是我们应该关心的全部。它如何完成有什么区别呢？
- en: The abstractions we created make our code declarative. In declarative programming,
    we declare the problem we want to solve, not how we want to solve it. It's the
    opposite of imperative, in which we have to make all the steps required explicit
    in order to get something (for instance, connect to the database, run this query,
    parse the result, load it into this object, and so on). In this case, we are declaring
    that we just want to know the status of the delivery given by some identifier.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的抽象使我们的代码具有声明性。在声明式编程中，我们声明我们想要解决的问题，而不是我们想要如何解决它。这与命令式相反，在命令式中，我们必须明确所有必要的步骤才能得到某些结果（例如，连接到数据库，运行此查询，解析结果，将其加载到该对象中，等等）。在这种情况下，我们声明我们只想知道由某个标识符给出的交付状态。
- en: These packages are in charge of dealing with the details and presenting what
    the application needs in a convenient format, namely objects of the kind presented
    in the previous section. We just have to know that the `storage` package contains
    an object that, given an ID for a delivery and a storage client (this dependency
    is being injected into this example for simplicity, but other alternatives are
    also possible), it will retrieve `DeliveryOrder`, which we can then ask to compose
    the message.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些包负责处理细节并以方便的格式呈现应用程序所需的内容，即前一部分中展示的那种类型的对象。我们只需要知道`storage`包包含一个对象，给定一个交付的ID和一个存储客户端（为了简单起见，这个依赖项被注入到这个例子中，但其他替代方案也是可能的），它将检索`DeliveryOrder`，然后我们可以要求它组合消息。
- en: This architecture provides convenience and makes it easier to adapt to changes,
    as it protects the kernel of the business logic from the external factors that
    can change.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构提供了便利，并使它更容易适应变化，因为它保护了业务逻辑的核心免受可能改变的外部因素的影响。
- en: 'Imagine we want to change how the information is retrieved. How hard would
    that be? The application relies on an API, like the following one:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们想要改变信息检索的方式，那会难到什么程度？应用程序依赖于一个API，如下所示：
- en: '[PRE7]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: So, it would just be about changing how the `get()` method works, adapting it
    to the new implementation detail. All we need is for this new object to return
    `DeliveryOrder` on its `get()` method and that would be all. We can change the
    query, the ORM, the database, and so on, and, in all cases, the code in the application
    does not need to change!
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这仅仅涉及到改变 `get()` 方法的工作方式，将其适配到新的实现细节。我们需要的只是这个新对象在其 `get()` 方法上返回 `DeliveryOrder`，这就足够了。我们可以更改查询、ORM、数据库等，在所有情况下，应用程序中的代码都不需要更改！
- en: Adapters
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 适配器
- en: Still, without looking at the code in the packages, we can conclude that they
    work as interfaces for the technical details of the application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然，即使不查看包中的代码，我们也可以得出结论，它们作为应用程序技术细节的接口工作。
- en: In fact, since we are seeing the application from a high-level perspective,
    without needing to look at the code, we can imagine that inside those packages
    there must be an implementation of the adapter design pattern (introduced in *Chapter
    9*, *Common Design Patterns*). One or more of these objects is adapting an external
    implementation to the API defined by the application. This way, dependencies that
    want to work with the application must conform to the API, and an adapter will
    have to be made.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，由于我们从高层次的角度看待应用程序，而不需要查看代码，我们可以想象在这些包内部必须有适配器设计模式的实现（在第 9 章 *常见设计模式* 中介绍）。一个或多个这些对象正在将外部实现适配到应用程序定义的
    API。这样，想要与应用程序一起工作的依赖项必须遵守 API，并且必须创建一个适配器。
- en: There is one clue pertaining to this adapter in the code for the application
    though. Notice how the view is constructed. It inherits from a class named `View`
    that comes from our `web` package. We can deduce that this `View` is, in turn,
    a class derived from one of the web frameworks that might be being used, creating
    an adapter by inheritance. The important thing to note is that once this is done,
    the only object that matters is our `View` class, because, in a way, we are creating
    our own framework, which is based on adapting an existing one (but again, changing
    the framework will mean just changing the adapters, not the entire application).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，在应用程序的代码中有一个关于这个适配器的线索。注意视图是如何构建的。它继承自来自我们的 `web` 包的 `View` 类。我们可以推断出这个
    `View` 是一个从可能正在使用的某个 Web 框架中派生出来的类，通过继承创建了一个适配器。需要注意的是，一旦完成这个操作，唯一重要的对象就是我们的 `View`
    类，因为从某种意义上说，我们正在创建自己的框架，这个框架基于对现有框架的适配（但再次强调，改变框架只会改变适配器，而不是整个应用程序）。
- en: Starting from the next section, we'll take a look at what the services look
    like internally.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 从下一节开始，我们将查看服务内部的结构。
- en: The services
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务
- en: To create the service, we are going to launch the Python application inside
    a Docker container. Starting from a base image, the container will have to install
    the dependencies for the application to run, which also has dependencies at the
    operating system level.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建服务，我们将在 Docker 容器中启动 Python 应用程序。从基础镜像开始，容器必须安装应用程序运行所需的依赖项，这些依赖项也具有操作系统级别的依赖项。
- en: This is actually a choice because it depends on how the dependencies are used.
    If a package we use requires other libraries on the operating system to compile
    at installation time, we can avoid this simply by building a wheel for our platform
    of the library and installing this directly. If the libraries are needed at runtime,
    then there is no choice but to make them part of the image of the container.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个选择，因为它取决于依赖项的使用方式。如果我们使用的包在安装时需要操作系统上的其他库来编译，我们可以通过为我们的平台构建库的 wheel 并直接安装来避免这种情况。如果库在运行时需要，那么别无选择，只能将它们作为容器镜像的一部分。
- en: 'Now, we will discuss one of the many ways of preparing a Python application
    to be run inside a Docker container. This is one of the numerous alternatives
    for packaging a Python project into a container. First, we take a look at what
    the structure of the directories looks like:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将讨论准备 Python 应用程序在 Docker 容器中运行的各种方法之一。这是将 Python 项目打包到容器中的众多替代方案之一。首先，我们来看看目录结构是什么样的：
- en: '[PRE8]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `libs` directory can be ignored since it's just the place where the dependencies
    are placed (it's displayed here to keep them in mind when they are referenced
    in the `setup.py` file, but they could be placed in a different repository and
    installed remotely via `pip`).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`libs` 目录可以被忽略，因为它只是放置依赖项的地方（在这里显示是为了在 `setup.py` 文件中引用它们时记住它们，但它们可以放在不同的仓库中，并通过
    `pip` 远程安装）。'
- en: We have `Makefile` with some helper commands, then the `setup.py` file, and
    the application itself inside the `statusweb` directory. A common difference between
    packaging applications and libraries is that while the latter specify their dependencies
    in the `setup.py` file, the former have a `requirements.txt` file from where dependencies
    are installed via `pip install -r requirements.txt`. Normally, we would do this
    in the `Dockerfile`, but in order to keep things simpler, in this particular example,
    we will assume that taking the dependencies from the `setup.py` file is enough.
    This is because besides this consideration, there are a lot more considerations
    to be taken into account when dealing with dependencies, such as freezing the
    version of the packages, tracking indirect dependencies, using extra tools such
    as `pipenv`, and more topics that are beyond the scope of the chapter. In addition,
    it is also customary to make the `setup.py` file read from `requirements.txt`
    for consistency.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个包含一些辅助命令的`Makefile`，然后是`setup.py`文件，以及位于`statusweb`目录中的应用程序本身。在打包应用程序和库之间的一个常见区别是，后者在`setup.py`文件中指定它们的依赖项，而前者有一个`requirements.txt`文件，依赖项通过`pip
    install -r requirements.txt`安装。通常，我们会在`Dockerfile`中做这件事，但为了使事情更简单，在这个特定的例子中，我们将假设从`setup.py`文件中获取依赖项就足够了。这是因为除了这个考虑之外，还有许多其他考虑因素需要考虑，例如冻结包的版本、跟踪间接依赖项、使用额外的工具如`pipenv`，以及更多超出本章范围的话题。此外，为了保持一致性，通常也会使`setup.py`文件从`requirements.txt`读取。
- en: 'Now we have the content of the `setup.py` file, which states some details of
    the application:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`setup.py`文件的内容，它声明了应用程序的一些详细信息：
- en: '[PRE9]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first thing we notice is that the application declares its dependencies,
    which are the packages we created and placed under `libs/`, namely `web` and `storage`,
    abstracting and adapting to some external components. These packages, in turn,
    will have dependencies, so we will have to make sure the container installs all
    the required libraries when the image is being created so that they can install
    successfully, and then this package afterward.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先注意到的是，应用程序声明了它的依赖项，即我们创建并放置在`libs/`下的包，即`web`和`storage`，它们抽象和适应了一些外部组件。这些包反过来也会有依赖项，因此我们必须确保在创建镜像时容器安装所有必需的库，以便它们可以成功安装，然后安装这个包。
- en: 'The second thing we notice is the definition of the `entry_points` keyword
    argument passed to the `setup` function. This is not strictly mandatory, but it''s
    a good idea to create an entry point. When the package is installed in a virtual
    environment, it shares this directory along with all its dependencies. A virtual
    environment is a structure of directories with the dependencies of a given project.
    It has many subdirectories, but the most important ones are:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到的第二件事是传递给`setup`函数的`entry_points`关键字参数的定义。这并不是强制性的，但创建一个入口点是个好主意。当包在一个虚拟环境中安装时，它共享这个目录以及所有其依赖项。虚拟环境是一个包含给定项目依赖项的目录结构。它有许多子目录，但最重要的几个是：
- en: '`<virtual-env-root>/lib/<python-version>/site-packages`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<virtual-env-root>/lib/<python-version>/site-packages`'
- en: '`<virtual-env-root>/bin`'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<virtual-env-root>/bin`'
- en: The first one contains all the libraries installed in that virtual environment.
    If we were to create a virtual environment with this project, that directory would
    contain the `web` and `storage` packages, along with all its dependencies, plus
    some extra basic ones and the current project itself.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个包含在该虚拟环境中安装的所有库。如果我们用这个项目创建一个虚拟环境，那么这个目录将包含`web`和`storage`包，以及所有其依赖项，还有一些额外的基本包，以及当前项目本身。
- en: The second, `/bin/`, contains the binary files and commands available when that
    virtual environment is active. By default, it would just be the version of Python,
    `pip`, and some other basic commands. When we create a console entry point, a
    binary with that declared name is placed there, and, as a result, we have that
    command available to run when the environment is active. When this command is
    called, it will run the function that is specified with all the context of the
    virtual environment. That means it is a binary we can call directly without having
    to worry about whether the virtual environment is active, or whether the dependencies
    are installed in the path that is currently running.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个是`/bin/`，它包含在虚拟环境激活时可用二进制文件和命令。默认情况下，它将只是Python版本、`pip`和一些其他基本命令。当我们创建控制台入口点时，将放置一个声明了该名称的二进制文件，因此，当环境激活时，我们就有可运行的该命令。当调用此命令时，它将运行指定了所有虚拟环境上下文的函数。这意味着这是一个我们可以直接调用的二进制文件，无需担心虚拟环境是否激活，或者依赖项是否安装在了当前运行的路径中。
- en: 'The definition is the following one:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 定义如下：
- en: '[PRE10]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The left-hand side of the equals sign declares the name of the entry point.
    In this case, we will have a command named `status-service` available. The right-hand
    side declares how that command should be run. It requires the package where the
    function is defined, followed by the function name after :`.` In this case, it
    will run the `main` function declared in `statusweb/service.py`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 等号左边的部分声明了入口点的名称。在这种情况下，我们将有一个名为`status-service`的命令可用。等号右边的部分声明了该命令应该如何运行。它需要定义函数的包，然后是冒号`.`之后的函数名称。在这种情况下，它将运行在`statusweb/service.py`中声明的`main`函数。
- en: 'This is followed by a definition of the `Dockerfile`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是对`Dockerfile`的定义：
- en: '[PRE11]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The image is built based on a lightweight Linux image with Python installed,
    and then the operating system dependencies are installed so that our libraries
    can be deployed. Following the previous consideration, this `Dockerfile` simply
    copies the libraries, but this might as well be installed from a `requirements.txt`
    file accordingly. After all the `pip install` commands are ready, it copies the
    application in the working directory, and the entry point from Docker (the `CMD`
    command, not to be confused with the Python one) calls the entry point of the
    package where we placed the function that launches the process. For local development,
    we'd still use the `Dockerfile`, in conjunction with a `docker-compose.yml` file
    with the definitions of all the services (including dependencies such as databases),
    base images, and how they are linked and interconnected.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像是基于安装了Python的轻量级Linux镜像构建的，然后安装了操作系统依赖项，以便我们可以部署我们的库。根据之前的考虑，这个`Dockerfile`只是简单地复制了库，但也可以相应地从`requirements.txt`文件中安装。在所有`pip
    install`命令准备就绪后，它将复制工作目录中的应用程序，并且Docker的入口点（`CMD`命令，不要与Python的混淆）调用我们放置函数启动进程的包的入口点。对于本地开发，我们仍然会使用`Dockerfile`，并结合一个包含所有服务定义（包括数据库等依赖项）、基础镜像以及它们如何链接和相互关联的`docker-compose.yml`文件。
- en: 'Now that we have the container running, we can launch it and run a small test
    on it to get an idea of how it works:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经启动了容器，我们可以启动它并在其上运行一个小测试，以了解其工作原理：
- en: '[PRE12]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let's analyze the architectural traits for the code we've seen so far, starting
    in the next section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析到目前为止看到的代码的架构特性，从下一节开始。
- en: Analysis
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析
- en: There are many conclusions to be drawn from the previous implementation. While
    it might seem like a good approach, there are cons that come with the benefits;
    after all, no architecture or implementation is perfect. This means that a solution
    such as this one cannot be good for all cases, so it will pretty much depend on
    the circumstances of the project, the team, the organization, and more.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 从之前的实现中可以得出许多结论。虽然这可能看起来是一个好的方法，但随之而来的缺点与好处一样明显；毕竟，没有架构或实现是完美的。这意味着这种解决方案并不适用于所有情况，所以它将很大程度上取决于项目的环境、团队、组织等等。
- en: While it's true that the main idea of the solution is to abstract details as
    much as possible, as we shall see, some parts cannot be fully abstracted away,
    and also the contracts between the layers imply an abstraction leak.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然解决方案的主要思想是尽可能抽象细节，正如我们将看到的，有些部分不能完全抽象掉，而且各层之间的合同意味着抽象泄露。
- en: After all, technology always creeps in. For example, if we were to change our
    implementation from a REST service to serve our data through GraphQL, we would
    have to adapt how the application server is configured and built, but still, we
    should be able to have a structure very similar to the preceding one. Even if
    we want to make a more radical change so as to transform our service into a gRPC
    server, we would of course be forced to adapt some glue code, but we should still
    be able to use our packages as much as possible. The changes needed should be
    kept to a minimum.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，技术总是悄悄地渗透进来。例如，如果我们要把我们的实现从REST服务更改为通过GraphQL提供数据，我们就必须调整应用程序服务器的配置和构建方式，但即便如此，我们仍然应该能够拥有一个非常类似的前一个结构。即使我们想要进行更激进的改变，将我们的服务转变为gRPC服务器，我们当然被迫要调整一些粘合代码，但我们仍然应该尽可能多地使用我们的包。所需的变化应保持在最小。
- en: The dependency flow
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 依赖关系流
- en: Notice that dependencies flow in only one direction, as they move closer to
    the kernel, where the business rules lie. This can be traced by looking at the
    `import` statements. The application imports everything it needs from storage,
    for example, and in no part is this inverted.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，随着它们接近位于业务规则所在的核心，依赖关系只流向一个方向。这可以通过查看`import`语句来追踪。应用程序从存储中导入它所需的一切，例如，在没有任何部分是这种反转的。
- en: Breaking this rule would create coupling. The way the code is arranged now means
    that there is a weak dependency between the application and storage. The API is
    such that we need an object with a `get()` method, and any storage that wants
    to connect to the application needs to implement this object according to this
    specification. The dependencies are therefore inverted—it's up to every storage
    to implement this interface, in order to create an object according to what the
    application is expecting.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 违反这条规则会创建耦合。现在代码的排列方式意味着应用程序和存储之间存在弱依赖。API是这样的，我们需要一个具有`get()`方法的对象，任何想要连接到应用程序的存储都需要根据这个规范实现这个对象。因此，依赖关系被反转——每个存储都必须实现这个接口，以便创建一个符合应用程序期望的对象。
- en: Limitations
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局限性
- en: Not everything can be abstracted away. In some cases, it's simply not possible,
    and in others, it might not be convenient. Let's start with the convenience aspect.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有东西都可以抽象化。在某些情况下，这是不可能的，在其他情况下，可能不方便。让我们从方便性方面开始。
- en: In this example, there is an adapter of the web framework of choice to a clean
    API to be presented to the application. In a more complex scenario, such a change
    might not be possible. Even with this abstraction, parts of the library are still
    visible to the application. It's not entirely a problem to be completely isolated
    from the web framework because, sooner or later, we will need some of its features
    or technical details.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个将所选网络框架适配到干净API的适配器，以便向应用程序展示。在更复杂的场景中，这样的改变可能不可行。即使有了这种抽象，库的一部分仍然对应用程序可见。完全与网络框架隔离并不是一个完全的问题，因为迟早我们需要它的某些功能或技术细节。
- en: The important takeaway here is not the adapter, but the idea of hiding technical
    details as much as possible. That means that the best thing that is displayed
    on the listing for the code of the application is not the fact that there is an
    adapter between our version of the web framework and the actual one, but instead,
    the fact that the latter is not mentioned by name in any part of the visible code.
    The service has made clear that `web` is just a dependency (a detail being imported)
    and revealed the intention behind what it was supposed to do. The goal is to reveal
    the intention (as in the code) and to defer details as much as possible.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的收获不是适配器，而是尽可能隐藏技术细节的想法。这意味着在应用程序代码列表上显示的最好的事情不是我们的网络框架版本和实际版本之间存在适配器的事实，而是后者在可见代码的任何部分都没有被提及。服务已经明确指出`web`只是一个依赖（一个被导入的细节）并揭示了其背后的意图。目标是揭示意图（如在代码中），尽可能推迟细节。
- en: As to what things cannot be isolated, those are the elements that are closest
    to the code. In this case, the web application is using the objects operating
    within them in an asynchronous fashion. That is a hard constraint we cannot circumvent.
    It's true that whatever is inside the `storage` package can be changed, refactored,
    and modified, but whatever these modifications might be, it still needs to preserve
    the interface, and that includes the asynchronous interface.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 关于那些无法隔离的事物，它们是最接近代码的元素。在这种情况下，网络应用程序正在以异步方式使用它们内部的这些对象。这是一个我们无法规避的硬性约束。确实，`storage`
    包内的任何内容都可以被更改、重构和修改，但无论这些修改可能是什么，它仍然需要保留接口，这包括异步接口。
- en: Testability
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试性
- en: Again, much like with the code, the architecture can benefit from separating
    pieces into smaller components. The fact that dependencies are now isolated and
    controlled by separate components leaves us with a cleaner design for the main
    application, and now it's easier to ignore the boundaries to focus on testing
    the core of the application.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，就像代码一样，架构可以从将部分分离成更小的组件中受益。依赖关系现在被隔离并由单独的组件控制，这使得主应用程序的设计更加清晰，现在更容易忽略边界，专注于测试应用程序的核心。
- en: We could create a patch for the dependencies and write unit tests that are simpler
    (they won't need a database), or launch an entire web service, for instance. Working
    with pure `domain` objects means it will be easier to understand the code and
    the unit tests. Even the adapters will not need that much testing because their
    logic should be very simple.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为依赖关系创建补丁，编写更简单的单元测试（它们不需要数据库），或者启动整个网络服务，例如。与纯`domain`对象一起工作意味着将更容易理解代码和单元测试。甚至适配器也不需要太多测试，因为它们的逻辑应该非常简单。
- en: 'Keep in mind the software testing pyramid mentioned in *Chapter 8*, *Unit Testing
    and Refactoring*. We want to have a large number of unit tests, followed by fewer
    component tests, and finally even fewer integration tests. Separating our architecture
    into different components goes a long way for component testing: we can mock up
    our dependencies and test some components in isolation.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住第8章中提到的软件测试金字塔，即*单元测试和重构*。我们希望拥有大量的单元测试，然后是较少的组件测试，最后甚至更少的集成测试。将我们的架构分为不同的组件对于组件测试大有裨益：我们可以模拟我们的依赖关系，并单独测试一些组件。
- en: This is both cheaper and faster, but it doesn't mean that we shouldn't have
    integration tests at all. To make sure our final application works as expected,
    we need integration tests that will exercise all components of our architecture
    (be that microservices or packages), working together.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这既便宜又快，但这并不意味着我们不应该进行任何集成测试。为了确保我们的最终应用程序按预期工作，我们需要进行集成测试，这将测试我们架构的所有组件（无论是微服务还是包），协同工作。
- en: Intention revealing
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 意图揭示
- en: Intention revealing is a critical concept for our code—every name has to be
    wisely chosen, clearly communicating what it's supposed to do. Every function
    should tell a story. We should keep functions short, concerns separated, and dependencies
    isolated and assign the right meaning to abstractions in every part of the code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 意图揭示是我们代码中的一个关键概念——每个名称都必须明智选择，清楚地传达它应该做什么。每个函数都应该讲述一个故事。我们应该保持函数简短，关注点分离，依赖关系隔离，并在代码的每个部分赋予抽象正确的含义。
- en: Good architecture should reveal the intent of the system it entails. It should
    not mention the tools it's built with; those are details, and as we discussed
    at length, details should be hidden and encapsulated.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的架构应该揭示它所包含系统的意图。它不应提及它所使用的工具；这些都是细节，正如我们详细讨论的那样，细节应该被隐藏和封装。
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The principles of good software design apply to all levels. In the same way
    that we want to write readable code, and for that we need to keep in mind the
    intention-revealing aspects of the code, the architecture also has to express
    the intent of the problem it is trying to solve.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 良好软件设计的原则适用于所有层次。正如我们希望编写可读的代码，并为此需要记住代码的意图揭示方面一样，架构也必须表达它试图解决的问题的意图。
- en: All these ideas are interconnected. The same intention revealing that ensures
    our architecture is defined in terms of the domain problem also leads us to abstract
    details as much as possible, create layers of abstraction, invert dependencies,
    and separate concerns.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些想法都是相互关联的。确保我们的架构以领域问题定义的意图揭示同样也引导我们尽可能抽象细节，创建抽象层，反转依赖关系，并分离关注点。
- en: When it comes to reusing code, Python packages are a great and flexible option.
    Criteria such as cohesion and the single responsibility principle are the most
    important considerations when deciding to create a package. In line with having
    components with cohesion and few responsibilities, the concept of microservices
    comes into play, and for that, we have seen how a service can be deployed in a Docker
    container starting from a packaged Python application.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到代码重用时，Python包是一个优秀且灵活的选择。在决定创建包时，最重要的考虑因素是内聚性和单一职责原则。与具有内聚性和较少职责的组件相一致，微服务概念应运而生，为此，我们已经看到如何从打包的Python应用程序开始，在Docker容器中部署一个服务。
- en: As with everything in software engineering, there are limitations and there
    are exceptions. It will not always be possible to abstract things as much as we
    would like to or to completely isolate dependencies. Sometimes, it will just not
    be possible (or practical) to comply with the principles explained here in the
    book. But that is probably the best piece of advice the reader should take from
    the book—they are just principles, not laws. If it's not possible, or practical,
    to abstract from a framework, it should not be a problem. Remember what has been
    quoted from the *Zen of Python* itself throughout the book—*practicality beats
    purity*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件工程中的所有事情一样，都有局限性和例外。我们不可能像我们希望的那样抽象出所有事物，或者完全隔离依赖。有时，可能根本不可能（或不切实际）遵守书中解释的原则。但读者可能应该从书中吸取的最佳建议是——它们只是原则，而不是法律。如果无法或实际上无法从框架中抽象出来，这不应该成为问题。记住，书中引用了*Python之禅*本身——*实用性胜于纯洁性*。
- en: References
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: 'Here is a list of information you can refer to:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些您可以参考的信息列表：
- en: '*SCREAM*: *Screaming Architecture* ([https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html))'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*SCREAM*: *Screaming Architecture* ([https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html))'
- en: '*CLEAN-01*: *The Clean Architecture* ([https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html))'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CLEAN-01*: *Clean Architecture* ([https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html))'
- en: '*HEX*: *Hexagonal Architecture* ([https://staging.cockburn.us/hexagonal-architecture/](https://staging.cockburn.us/hexagonal-architecture/))'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*HEX*: *Hexagonal Architecture* ([https://staging.cockburn.us/hexagonal-architecture/](https://staging.cockburn.us/hexagonal-architecture/))'
- en: '*PEP-508*: Dependency specification for Python software packages ([https://www.python.org/dev/peps/pep-0508/](https://www.python.org/dev/peps/pep-0508/))'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-508*: Python软件包的依赖规范 ([https://www.python.org/dev/peps/pep-0508/](https://www.python.org/dev/peps/pep-0508/))'
- en: 'Packaging and distributing projects in Python: [https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#distributing-packages](https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#di)'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Python中打包和分发项目：[https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#distributing-packages](https://python-packaging-user-guide.readthedocs.io/guides/distributing-packages-using-setuptools/#di)
- en: '*PEP-440*: [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-440*: [https://www.python.org/dev/peps/pep-0440/](https://www.python.org/dev/peps/pep-0440/)'
- en: '*REGISTER01*: [https://www.theregister.com/2016/03/23/npm_left_pad_chaos/](https://www.theregister.com/2016/03/23/npm_left_pad_chaos/)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*REGISTER01*: [https://www.theregister.com/2016/03/23/npm_left_pad_chaos/](https://www.theregister.com/2016/03/23/npm_left_pad_chaos/)'
- en: 'Python packaging user guide: [https://packaging.python.org/](https://packaging.python.org/)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python打包用户指南：[https://packaging.python.org/](https://packaging.python.org/)
- en: 'AWS builder''s library: *Going faster with continuous delivery* ([https://aws.amazon.com/builders-library/going-faster-with-continuous-delivery/](https://aws.amazon.com/builders-library/going-faster-with-continuous-delivery/))'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS构建者库：*通过持续交付加速* ([https://aws.amazon.com/builders-library/going-faster-with-continuous-delivery/](https://aws.amazon.com/builders-library/going-faster-with-continuous-delivery/))
- en: Summing it all up
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The content of this book is a reference, a possible way of implementing a software
    solution by following the mentioned criteria. These criteria are explained through
    examples, and the rationale for every decision is presented. The reader might
    very well disagree with the approaches taken in the examples.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的内容是一个参考，是一个通过遵循提到的标准来实现软件解决方案的可能方式。这些标准通过示例进行解释，并展示了每个决策的合理性。读者可能会非常不同意示例中采取的方法。
- en: 'In fact, I encourage you to disagree: the more viewpoints there are, the richer
    the debate. But regardless of opinions, it''s important to make clear that what
    is presented here is by no means a strong directive, something that must be followed
    imperatively. Quite the opposite; it''s a way of presenting a solution and a set
    of ideas that you might find helpful.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我鼓励你提出不同的意见：观点越多，辩论就越丰富。但无论意见如何，重要的是要明确，这里所呈现的内容绝对不是一项强制的指令，不是必须严格遵循的东西。恰恰相反；这是一种展示解决方案和一系列可能对你有帮助的想法的方式。
- en: As introduced at the beginning, the goal of this book was not to give you recipes
    or formulas that you can apply directly, but rather to develop your critical thinking.
    Idioms and syntax features come and go; they change over time. But ideas and core
    software concepts remain. With these tools and the examples provided, you should
    have a better understanding of what clean code means.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如开头所述，这本书的目标不是给你提供可以直接应用的食谱或公式，而是培养你的批判性思维。习语和语法特性会来来去去；它们会随时间而变化。但思想和核心软件概念是永恒的。有了这些工具和提供的例子，你应该对什么是干净的代码有更好的理解。
- en: I sincerely hope this book has helped you become a better developer than you
    were before you started it, and I wish you much success in your projects.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我真诚地希望这本书能帮助你成为比开始阅读时更好的开发者，并祝愿你在项目中取得巨大成功。
- en: '**Share your experience**'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**分享你的经验**'
- en: 'Thank you for taking the time to read this book. If you enjoyed this book,
    help others to find it. Leave a review at: [https://www.amazon.com/dp/1800560214](https://www.amazon.com/dp/1800560214)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢您抽出时间阅读这本书。如果您喜欢这本书，请帮助他人找到它。在以下链接留下评论：[https://www.amazon.com/dp/1800560214](https://www.amazon.com/dp/1800560214)
