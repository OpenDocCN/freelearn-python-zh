- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: From Finite State Machines to Computers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从有限状态机到计算机
- en: In this chapter, you will discover the fundamental nature of computers. Our
    goal is to explain what makes a computer a computer. These concepts are important
    because you can’t understand how a computer works until you appreciate the implications
    of its sequential nature.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将发现计算机的基本本质。我们的目标是解释是什么让计算机成为计算机。这些概念很重要，因为在你理解计算机的工作原理之前，你必须欣赏其顺序性的影响。
- en: Once we’ve introduced the concept of digital systems, the next chapter will
    demonstrate how a computer operates by fetching instructions from memory and executing
    them. After that, we will introduce Python and demonstrate how you can write a
    program to simulate a computer and observe its operations. This book is all about
    learning by doing; by building a computer with software, you will learn how it
    operates and how to extend and modify it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们介绍了数字系统的概念，下一章将演示计算机如何通过从内存中获取指令并执行它们来运行。之后，我们将介绍Python，并展示如何编写程序来模拟计算机并观察其操作。这本书完全是关于通过实践学习的；通过用软件构建计算机，你将学习它是如何运行的以及如何扩展和修改它。
- en: The remainder of this book will look at a real computer, a Raspberry Pi, and
    show you how to write programs for it and observe their execution. In doing so,
    we will move on from simulating a hypothetical computer to learning about a real
    computer.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余部分将探讨一台真实的计算机，树莓派（Raspberry Pi），并展示如何为其编写程序并观察它们的执行。在这个过程中，我们将从模拟假设的计算机转向学习真实的计算机。
- en: A computer is a *deterministic symbol processing* machine. But what does that
    mean? *Deterministic* tells us that a computer always behaves in the same way
    when operating under the same conditions (that is, programs and inputs). If you
    use a computer to evaluate √2, you will always get the same result, no matter
    how many times you perform the operation. Not all systems are deterministic –
    if you toss a coin, the sequence of heads and tails is not predictable.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机是一个**确定性符号处理**机器。但这究竟意味着什么？**确定性**告诉我们，当计算机在相同条件下操作时（即，程序和输入），它总是以相同的方式行为。如果你用计算机来评估√2，无论你执行操作多少次，你都会得到相同的结果。并非所有系统都是确定性的——如果你抛硬币，正面和反面的序列是不可预测的。
- en: 'When we say that a computer is a *symbol processing machine*, we mean that
    it takes in symbols and operates on them to provide new symbols as an output.
    These symbols are anything that can be represented in digital form: letters, words,
    numbers, images, sound, and video. Consider a computer that’s playing chess. The
    input symbols that are received by the program correspond to the moves made by
    a player. The program operates on the input symbols according to a set of rules
    and produces an output symbol – the computer’s move.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说计算机是一个**符号处理机器**时，我们的意思是它接受符号并对它们进行操作，以提供新的符号作为输出。这些符号可以是任何可以用数字形式表示的东西：字母、单词、数字、图像、声音和视频。考虑一台正在下棋的计算机。程序接收到的输入符号对应于玩家的移动。程序根据一组规则对输入符号进行操作，并产生一个输出符号——计算机的移动。
- en: Although we’ve just provided a theoretical definition of a computer, it is important
    to appreciate that programming involves translating information in the real world
    into symbols that can be manipulated by a computer – writing a set of rules (that
    is, a program) that tells the computer how to manipulate the symbols, and then
    converting the output symbols into a form that is meaningful to a human. The symbols
    that are processed by a computer have no intrinsic meaning to the computer – a
    certain pattern of bits (that is, the symbol) might represent a number, a name,
    a move in a game, and so on. The computer processes these bits to produce a new
    pattern of bits (that is, an output symbol) that has a meaning only to the programmer
    or user.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚提供了一个计算机的理论定义，但重要的是要认识到编程涉及将现实世界中的信息转换为计算机可以操作的符号——编写一组规则（即，程序），告诉计算机如何操作这些符号，然后将输出符号转换为对人类有意义的格式。计算机处理的符号对计算机本身没有固有的意义——一定的比特模式（即，符号）可能代表一个数字、一个名字、游戏中的移动等等。计算机处理这些比特以产生一个新的比特模式（即，输出符号），这种模式只对程序员或用户有意义。
- en: We are going to pose a simple problem and then solve it. Our solution will lead
    us to the concepts of algorithms and computers, and also introduce key concepts
    such as discrete digital operations, memory and storage, variables, and conditional
    operations. By doing this, we can determine the types of operations a computer
    needs to perform to solve a problem. After this, we can ask, “How can we automate
    this? That is, how can we build a computer?”
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提出一个简单的问题，并解决它。我们的解决方案将引导我们了解算法和计算机的概念，并介绍诸如离散数字操作、内存和存储、变量以及条件操作等关键概念。通过这样做，我们可以确定计算机需要执行哪些操作来解决一个问题。在此之后，我们可以问，“我们如何自动化这个过程？也就是说，我们如何构建一台计算机？”
- en: 'It’s a trite statement, but once you understand a problem, you’re well on the
    way to finding a solution. When you first encounter a problem that requires an
    algorithmic solution, you have to think about what you want to do, rather than
    how you are going to do it. The worst approach to problem solving is to start
    writing an algorithm (or even actual computer code) before you have fully explored
    the problem. Suppose you were asked to design a cruise control system for an automobile.
    In principle, this is a very simple problem with an equally simple solution:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一句陈词滥调，但一旦你理解了一个问题，你就已经找到了解决问题的方法。当你第一次遇到需要算法解决的问题时，你必须考虑你想要做什么，而不是你打算如何去做。解决问题的最糟糕的方法是在完全探索问题之前就开始编写算法（甚至实际的计算机代码）。假设有人要求你为汽车设计一个巡航控制系统。从原则上讲，这是一个非常简单的问题，解决方案同样简单：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Couldn’t be simpler, could it? Well, what happens if you’ve selected cruise
    control and someone pulls out in front of you? You could brake, but this algorithm
    would attempt to keep the speed constant while you are braking by applying full
    throttle at the same time. Alternatively, you might suggest that the act of braking
    should disengage the cruise control mechanism. But is the cruise control to be
    disengaged permanently, or should the automobile accelerate to its previous speed
    once the braking action has ceased? You have to think about all the aspects of
    the problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这难道不是再简单不过了吗？好吧，如果你已经选择了巡航控制，而有人在你面前突然驶出，会发生什么？你可以刹车，但这个算法会试图在刹车的同时通过全油门来保持速度不变。或者，你可能会建议，刹车应该解除巡航控制机制。但是，巡航控制应该永久解除，还是汽车在刹车动作停止后应该加速到之前的速度？你必须考虑问题的所有方面。
- en: Even if you design a correct algorithm, you have to consider the effect erroneous
    or spurious data will have on your system. One of the most popular criticisms
    of computers is that they produce meaningless results if you feed them with incorrect
    data. This idea is summed up by the expression **garbage in, garbage out** (**GIGO**).
    A well-constructed algorithm should detect and filter out any garbage in the input
    data stream.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你设计了一个正确的算法，你也必须考虑错误或虚假数据对你的系统产生的影响。对计算机最普遍的批评之一是，如果你向它们提供错误的数据，它们会产生无意义的结果。这个观点可以用“垃圾输入，垃圾输出”（**GIGO**）这个表达来概括。一个构造良好的算法应该能够检测并过滤掉输入数据流中的任何垃圾。
- en: 'In this chapter, we will introduce the following topics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主题：
- en: The finite state machine
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限状态机
- en: Solving a problem algorithmically
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法解决问题
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the programs used in this chapter on GitHub at [https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter01](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter01).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章使用的程序，链接为[https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter01](https://github.com/PacktPublishing/Practical-Computer-Architecture-with-Python-and-ARM/tree/main/Chapter01)。
- en: The finite state machine
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限状态机
- en: There are remarkably few fundamental concepts that you need to know about to
    understand what a digital computer does and how it operates. One of the most important
    concepts is discrete, which lies at the heart of both computer operation and computer
    programs.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解的基本概念寥寥无几，才能理解数字计算机的功能及其工作原理。其中最重要的概念之一是离散，它既是计算机操作的核心，也是计算机程序的核心。
- en: Computers operate on discrete data elements – that is, elements whose values
    are chosen from a fixed and finite range of values. We use discrete values in
    everyday life – for example, the letters of the Roman alphabet that belong to
    the set {A...Z}. A letter is never between two possible values. It’s the same
    with the days of the week; you can have one of seven days, but you can’t have
    a day that is slightly Monday or just a little bit bigger than Wednesday. In the
    case of computers, the fundamental data element is the bit, which can only have
    values of 0 or 1, and all its data structures are represented by strings of 1s
    and 0s.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机操作的是离散数据元素——也就是说，其值是从一个固定且有限的值范围内选择的元素。我们在日常生活中使用离散值——例如，属于集合{A...Z}的罗马字母表中的字母。一个字母永远不会位于两个可能值之间。星期几也是如此；你可以有七天中的一天，但你不能有一个稍微是星期一或者稍微比星期三大一点的日子。在计算机的情况下，基本数据元素是比特，它只能有0或1的值，并且所有数据结构都是由1和0的字符串表示的。
- en: As well as discrete data values, we can have discrete points in time. Imagine
    that time moves in one direction, from one discrete point to another discrete
    point. Nothing exists between two discrete points in time. It’s a bit like a digital
    clock that goes from 12:15:59 to 12:16:00\. There’s nothing in between.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 除了离散的数据值，我们还可以有时间上的离散点。想象一下时间沿着一个方向移动，从一个离散点移动到另一个离散点。时间上的两个离散点之间不存在任何东西。这有点像从12:15:59到12:16:00跳转的数字时钟。中间没有任何东西。
- en: 'Now, imagine state space, which is a grandiose term for all the states a system
    can be in (for example, a plane can be in the climbing, descending, or level flight
    state). States are a bit like time, except that you can go forward or backward
    between discrete points in state space. If there are a limited number of possible
    states, a device that models the transitions between states is called a **finite
    state machine** (**FSM**). An elevator is a finite state machine: it has states
    (position at the floors, doors open or closed, and so on) and inputs (the elevator
    call buttons, floor selection buttons, and door open and close buttons).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下状态空间，这是一个宏伟的术语，用于描述系统可能处于的所有状态（例如，飞机可能处于爬升、下降或水平飞行状态）。状态有点像时间，不同之处在于你可以在状态空间中的离散点之间向前或向后移动。如果可能的状态数量有限，那么一个模拟状态之间转换的设备被称为**有限状态机**（**FSM**）。电梯就是一个有限状态机：它有状态（楼层位置、门开或关等）和输入（电梯呼叫按钮、楼层选择按钮以及开门和关门按钮）。
- en: 'Before we take a serious look at FSMs, let’s begin with a simple example of
    how to use FSMs to describe a real system. Consider the TV of yesterday, which
    is a device with two states: on and off. It is always in one of these two states,
    and it can move between these states. It is never in a state that is neither on
    nor off. Modern TVs often have three states – on, *standby*, and off– where the
    standby state provides a fast-on mechanism (that is, part of the electronics is
    in an active on state, but the display and sound system are powered down). The
    standby state is often called the sleep state or idle state. We can model discrete
    states using a diagram. Each state is represented by a labeled circle, as demonstrated
    in *Figure 1**.1*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们认真研究有限状态机之前，让我们从一个简单的例子开始，看看如何使用有限状态机来描述一个真实系统。考虑昨天的电视，这是一个有两个状态的设备：开启和关闭。它总是处于这两种状态之一，并且可以在这些状态之间移动。它永远不会处于既不是开启也不是关闭的状态。现代电视通常有三个状态——开启、*待机*和关闭——其中待机状态提供了一个快速开启机制（也就是说，电子设备的一部分处于活跃的开启状态，但显示和声音系统是关闭的）。待机状态通常被称为睡眠状态或空闲状态。我们可以使用图表来模拟离散状态。每个状态都由一个标记的圆圈表示，如*图1*.*1*所示：
- en: '![Figure 1.1 – Representing the three states of a television](img/B19624_01_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1 – 表示电视的三个状态](img/B19624_01_01.jpg)'
- en: Figure 1.1 – Representing the three states of a television
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 表示电视的三个状态
- en: '*Figure 1**.1* shows the three states, but it doesn’t tell us the most important
    information we need to know: how we move between states. We can do this by drawing
    lines between states and labeling them with the event that triggers a change of
    state. *Figure 1**.2* does this. Please note that we are going to construct an
    incorrect system first to illustrate some of the concepts concerning FSMs:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*图1*.*1*显示了三个状态，但它没有告诉我们我们需要知道的最重要信息：我们如何在不同状态之间移动。我们可以通过在状态之间画线并标注触发状态变化的触发事件来实现这一点。*图1*.*2*就是这样做的。请注意，我们将首先构建一个不正确的系统来展示一些关于有限状态机的概念：'
- en: '![Figure 1.2 – Representing the states of a television with transitions](img/B19624_01_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2 – 表示电视状态及其转换](img/B19624_01_02.jpg)'
- en: Figure 1.2 – Representing the states of a television with transitions
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 用转换表示电视的状态
- en: In *Figure 1**.2*, we labeled each transition by the event that triggers it;
    in each case, it’s pressing a button on the remote controller. To go from off
    to on, you have to first press the standby button and then the on button. To go
    between on and standby, you must press the on button or the standby button.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 1*.*2* 中，我们通过触发事件的名称来标记每个转换；在每种情况下，都是按下遥控器上的按钮。要从关闭状态切换到开启状态，您必须首先按下待机按钮，然后按下开启按钮。要在开启和待机状态之间切换，您必须按下开启按钮或待机按钮。
- en: We’ve forgotten something – what if you are already in a state and you press
    the same button? For example, let’s say the TV is on, and you press the on button.
    Also, what’s the initial state? *Figure 1**.3* rectifies these omissions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们忘记了一些事情——如果您已经处于某个状态并按下相同的按钮怎么办？例如，假设电视处于开启状态，您按下开启按钮。此外，初始状态是什么？*图 1*.*3*
    纠正了这些遗漏。
- en: '*Figure 1**.3* has two innovations. There is an arrow to the off state marked
    *Power on*. This line indicates the state the system enters when you first plug
    it into the electricity supply. The second innovation in *Figure 1**.3* is that
    each state has a loop back to itself; for example, if you are in the on state
    and you press the on button, you remain in that state:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1*.*3* 有两个创新。有一个指向关闭状态的箭头标记为 *开启电源*。这条线表示您第一次将系统接入电源时系统进入的状态。*图 1*.*3* 的第二个创新是每个状态都有一个回到自身的循环；例如，如果您处于开启状态并按下开启按钮，您将保持在那个状态：'
- en: '![Figure 1.3 – The TV control with initialization](img/B19624_01_03.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 – 初始化后的电视控制](img/B19624_01_03.jpg)'
- en: Figure 1.3 – The TV control with initialization
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 初始化后的电视控制
- en: 'The state diagram shown in *Figure 1**.3* has both a logical error and an ergonomic
    error. What happens if you are in the off state and press the on button? If you
    are in the off state, pressing the on button (in this system) is incorrect because
    you have to go to standby first. *Figure 1**.4* corrects this error by dealing
    with incorrect inputs:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1*.*3* 中所示的状态图既有逻辑错误也有人体工程学错误。如果您处于关闭状态并按下开启按钮会发生什么？如果您处于关闭状态，在这个系统中按下开启按钮是不正确的，因为您必须先进入待机状态。*图
    1*.*4* 通过处理错误输入来纠正这个错误：'
- en: '![Figure 1.4 – The TV control with wrong button correction](img/B19624_01_04.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – 具有错误按钮纠正的电视控制](img/B19624_01_04.jpg)'
- en: Figure 1.4 – The TV control with wrong button correction
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 具有错误按钮纠正的电视控制
- en: '*Figure 1**.4* now provides correct operations from any state and includes
    the effect of pressing buttons that cause no change of state. But we still have
    the ergonomic error – that is, it’s a correct design that behaves in a way that
    many would consider poor. The standby state is a convenience that speeds up operations.
    However, the user does not need to know about this state – it should be invisible
    to the user.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1*.*4* 现在提供了从任何状态的正确操作，并包括按下不会改变状态按钮的效果。但是，我们仍然存在人体工程学错误——也就是说，这是一个正确的设计，但它的行为方式许多人会认为不好。待机状态是一种方便，可以加快操作速度。然而，用户不需要了解这种状态——它应该对用户不可见。'
- en: '*Figure 1**.5* demonstrates the final version of the controller. We’ve eliminated
    a standby button, but not the standby state. When the user presses the on button,
    the system goes directly to the on state. However, when the user presses off when
    in the on state, the system goes to the standby state. From the standby state,
    pressing the on button results in the power on state, while pressing off results
    in the power off state. Note that the same action (pressing off) can have different
    effects, depending on the current state:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1*.*5* 展示了控制器的最终版本。我们消除了待机按钮，但没有消除待机状态。当用户按下开启按钮时，系统直接进入开启状态。然而，当用户在开启状态下按下关闭按钮时，系统进入待机状态。从待机状态，按下开启按钮会导致开机状态，而按下关闭按钮会导致关机状态。请注意，同一动作（按下关闭按钮）可能根据当前状态产生不同的效果：'
- en: '![Figure 1.5 – The TV control with a hidden standby state](img/B19624_01_05.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5 – 具有隐藏待机状态的电视控制](img/B19624_01_05.jpg)'
- en: Figure 1.5 – The TV control with a hidden standby state
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 具有隐藏待机状态的电视控制
- en: We’ve labored with this example because the notion of FSMs is at the heart of
    all digital systems. All digital systems, apart from the most trivial, move from
    state to state, depending on the current input and past states. In a digital computer,
    the change-of-state trigger is the system clock. A modern computer operating at
    a clock speed of 4 GHz changes state every 0.25 x 10-9 s or every 0.25 ns. Light
    traveling at 300,000 km/s (186,000 mph) moves about 7.5 cm or 3 inches during
    a clock cycle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以详细讨论这个例子，是因为FSM的概念是所有数字系统的核心。所有数字系统，除了最简单的，都会根据当前输入和过去状态从一种状态转移到另一种状态。在数字计算机中，状态变化的触发器是系统时钟。现代计算机以4
    GHz的时钟速度运行，每0.25 x 10^-9秒或每0.25纳秒改变一次状态。以300,000 km/s（186,000 mph）的速度传播的光在时钟周期内大约移动7.5厘米或3英寸。
- en: Traffic lights example
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交通信号灯示例
- en: 'Let’s look at a second example of an FSM. A classic example of an FSM is traffic
    lights at a crossroads. Consider an intersection with traffic moving north-south
    or east-west. The traffic may move in only one direction at a time. Assume that
    this is a system with a clock and a change of state is permitted every minute:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个FSM的第二个例子。FSM的一个经典例子是交叉路口的交通信号灯。考虑一个南北或东西方向交通流动的交叉口。交通可能一次只能在一个方向上流动。假设这是一个带有时钟的系统，并且每分钟允许状态变化：
- en: '| **Current State of** **the Lights** | **Traffic in the** **North-South Direction**
    | **Traffic in the** **East-West Direction** | **Action to Be Taken On the** **Next
    Clock** | **Next State of** **the Lights** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **当前灯光状态** | **南北方向交通** | **东西方向交通** | **下一个时钟周期要采取的行动** | **灯光的下一个状态** |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '| North-south | None | None | No traffic, no change | North-south |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 南北方向 | 无 | 无 | 无交通，无变化 | 南北方向 |'
- en: '| North-south | None | One or more | East-west, forces change | East-west |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 南北方向 | 无 | 一个或多个 | 东西方向，强制变化 | 东西方向 |'
- en: '| North-south | One or more | None | North-south, no change | North-south |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 南北方向 | 一个或多个 | 无 | 南北方向，无变化 | 南北方向 |'
- en: '| North-south | One or more | One or more | East-west, forces change | East-west
    |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 南北方向 | 一个或多个 | 一个或多个 | 东西方向，强制变化 | 东西方向 |'
- en: '| East-west | None | None | No traffic, no change | East-west |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 东西方向 | 无 | 无 | 无交通，无变化 | 东西方向 |'
- en: '| East-west | None | One or more | East-west, no change | East-west |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 东西方向 | 无 | 一个或多个 | 东西方向，无变化 | 东西方向 |'
- en: '| East-west | One or more | None | North-south, forces change | North-south
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 东西方向 | 一个或多个 | 无 | 南北方向，强制变化 | 南北方向 |'
- en: '| East-west | One or more | One or more | North-south, forces change | North-south
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 东西方向 | 一个或多个 | 一个或多个 | 南北方向，强制变化 | 南北方向 |'
- en: Table 1.1 – Traffic lights sequence table
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – 交通信号灯序列表
- en: Suppose the traffic is currently flowing north-south. At the next clock, it
    may either remain flowing north-south or the lights may change to allow east-west
    traffic. Similarly, if traffic is flowing east-west, at the next clock, it may
    either remain flowing east-west or the lights may change to permit north-south
    traffic.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设交通目前是南北方向流动。在下一个时钟周期，它可能继续保持南北方向流动，或者信号灯可能改变以允许东西方向交通。同样，如果交通是东西方向流动，在下一个时钟周期，它可能继续保持东西方向流动，或者信号灯可能改变以允许南北方向交通。
- en: 'We can use *Table 1.1* to describe this system. We have provided the current
    state of the lights (direction of traffic flow), indicated whether any traffic
    had been detected in either the north-south or east-west direction, the action
    to be taken at the next clock, and the next state. The traffic rule is simple:
    the lights remain in their current state unless there is pending traffic in the
    other direction.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用*表 1.1*来描述这个系统。我们提供了灯光的当前状态（交通流动方向），指示是否在南北或东西方向检测到任何交通，下一个时钟周期要采取的行动，以及下一个状态。交通规则很简单：除非有其他方向的待处理交通，否则信号灯保持当前状态。
- en: 'We can now convert this table into the FSM diagram shown in *Figure 1**.6*.
    Note that we have made the east-west state the power on state; this is an arbitrary
    choice:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个表格转换为*图 1.6*中所示的FSM图。请注意，我们将东西方向状态设置为开机状态；这是一个任意的选择：
- en: '![Figure 1.6 – A finite state machine for Table 1.1](img/B19624_01_06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6 – 表 1.1 的有限状态机](img/B19624_01_06.jpg)'
- en: Figure 1.6 – A finite state machine for Table 1.1
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – 表 1.1 的有限状态机
- en: 'What have we learned? The most important point is that a system is, at any
    instant, in a particular state and that a transition to another state (or a transition
    back to the current state) is made according to a defined set of conditions. The
    FSM has several advantages, both as a teaching tool and a design tool:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了什么？最重要的观点是，在任何时刻，系统都处于特定的状态，并且根据定义的一组条件进行状态转换（或转换回当前状态）。有限状态机作为教学工具和设计工具都有几个优点：
- en: It uses a simple intuitive diagram to describe a system with discrete states
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使用一个简单直观的图来描述具有离散状态的系统
- en: The state transition diagram (if correct) provides a complete and unambiguous
    way of describing a system
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态转换图（如果正确）提供了一种完整且无歧义的方式来描述一个系统
- en: The FSM is also an abstract machine in the sense that it models a real system,
    but we don’t have to worry about how the FSM is implemented in real hardware or
    software
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限状态机也是一个抽象机，因为它模拟了一个真实系统，但我们不必担心有限状态机在真实硬件或软件中的实现
- en: Any FSM can be implemented either in hardware or software; that is, if you can
    define a state diagram on paper, you can build the circuit in dedicated hardware
    or write the program to run on a general-purpose computer
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何有限状态机都可以在硬件或软件中实现；也就是说，如果你能在纸上定义一个状态图，你就可以在专用硬件中构建电路，或者编写在通用计算机上运行的程序
- en: I have included a brief introduction to FSMs because they can be considered
    a precursor to the digital computer. An FSM is designed to carry out a specific
    task; this is built into its hardware. A computer has some of the characteristics
    of an FSM but you can program the transitions between states.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我包括了对有限状态机的简要介绍，因为它们可以被认为是数字计算机的先驱。有限状态机被设计用来执行特定任务；这是内置到其硬件中的。计算机具有有限状态机的某些特征，但你可以在状态之间编程转换。
- en: Solving a simple problem algorithmically
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以算法方式解决简单问题
- en: Now that we’ve introduced FSMs, we will describe a problem, solve it, and then
    construct our computer. A bag contains a mixture of red and white tokens. Suppose
    that we take a token at a time out of the bag and continue until we have removed
    three consecutive red tokens. We want to construct an algorithm that tells us
    to stop removing tokens from the bag when three reds in a row have been detected.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了有限状态机（FSM），我们将描述一个问题，解决问题，然后构建我们的计算机。一个袋子包含红色和白色标记的混合物。假设我们一次从袋子中取出一个标记，直到我们取出三个连续的红色标记。我们想要构建一个算法，告诉我们何时停止从袋子中取出标记，当检测到三个连续的红色标记时。
- en: 'Before creating an algorithm, we’ll provide an FSM for this problem:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建算法之前，我们将为此问题提供一个有限状态机：
- en: '![Figure 1.7 – FSM for a three-token detector](img/B19624_01_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图1.7 – 三标记检测器的有限状态机](img/B19624_01_07.jpg)'
- en: Figure 1.7 – FSM for a three-token detector
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 三标记检测器的有限状态机
- en: As you can see, there are four states. We begin in state S0\. Each time a token
    is received, we move to the next state if it’s red, and back to the initial state
    if it’s white. Once we’ve reached state S3, the process ends. Now, we’ll perform
    the same operation algorithmically.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里有四种状态。我们从状态S0开始。每次接收到一个标记时，如果它是红色的，我们就移动到下一个状态，如果是白色的，就回到初始状态。一旦我们达到状态S3，过程就结束了。现在，我们将以算法的方式执行相同的操作。
- en: 'If a white token is represented by the symbol W, and a red token by R, a possible
    sequence of tokens might be RRWRWWWWRWWRRR (the sequence is terminated by the
    three Rs). An algorithm that tells us when to stop removing tokens can be written
    in the following form:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果白色标记用符号W表示，红色标记用R表示，一个可能的标记序列可能是RRWRWWWWRWWRRR（序列由三个R终止）。一个告诉我们何时停止取出标记的算法可以写成以下形式：
- en: 'Line 1: Get a token from the bag'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第1行：从袋子中获取一个标记
- en: 'Line 2: If the token is white, then go back to line 1'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第2行：如果标记是白色的，则回到第1行
- en: 'Line 3: Get a token from the bag'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第3行：从袋子中获取一个标记
- en: 'Line 4: If the token is white, then go back to Line 1'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第4行：如果标记是白色的，则回到第1行
- en: 'Line 5: Get a token from the bag'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第5行：从袋子中获取一个标记
- en: 'Line 6: If the token is white, then go back to Line 1'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6行：如果标记是白色的，则回到第1行
- en: 'Line 7: Success – three consecutive red tokens have been taken out of the bag'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第7行：成功 – 已从袋子中取出三个连续的红色标记
- en: As you can see, the algorithm is expressed in plain English. It is read from
    top to bottom, line by line, and the action specified by each line is carried
    out before the next line is processed. In this algorithm, each line has a unique
    name (that is, Line 1, Line 2, and so on). Labeling a line enables us to refer
    to it; for example, when the algorithm states that we must go back to Line 1,
    this means that the next step to be carried out is specified by Line 1, and we
    continue carrying out actions from Line 1 onward. This algorithm is not entirely
    satisfactory – we haven’t checked that the bag contains only red and white tokens,
    and we haven’t dealt with the situation in which we run out of tokens before we
    locate the sequence we’re looking for. At the moment, we are not concerned with
    these details.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该算法用普通英语表达。它是从上到下，逐行阅读的，并且每行指定的操作在处理下一行之前执行。在这个算法中，每一行都有一个独特的名称（即行 1、行
    2 等）。给行标记使我们能够引用它；例如，当算法声明我们必须返回行 1 时，这意味着下一步要执行的操作由行 1 指定，并且我们从行 1 开始继续执行操作。这个算法并不完全令人满意
    – 我们还没有检查袋子中是否只包含红色和白色标记，并且我们还没有处理在找到我们正在寻找的序列之前用完标记的情况。目前，我们并不关心这些细节。
- en: 'There’s no single solution to this problem – more often than not, lots of algorithms
    can be constructed to solve a given problem. Let’s derive another algorithm to
    detect a sequence of three consecutive red tokens:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题没有唯一的解决方案 – 更多的时候，可以构建许多算法来解决给定的问题。让我们推导出另一个算法来检测三个连续红色标记的序列：
- en: 'Line 1: Set the total number of consecutive red tokens found so far to 0'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 行 1：将迄今为止找到的连续红色标记的总数设置为 0
- en: 'Line 2: Get a token from the bag'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 行 2：从袋子中取一个标记
- en: 'Line 3: If the token is white, then go back to Line 1'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 行 3：如果标记是白色的，则返回行 1
- en: 'Line 4: Add 1 to the number of consecutive red tokens found so far'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 行 4：将迄今为止找到的连续红色标记的数量加 1
- en: 'Line 5: If the number of consecutive red tokens is less than 3, then go back
    to Line 2'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 行 5：如果连续红色标记的数量少于 3，则返回行 2
- en: 'Line 6: Success – 3 consecutive red tokens have been taken out of the bag'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 行 6：成功 – 已从袋子中取出 3 个连续的红色标记
- en: This algorithm is more versatile because it can easily be modified to detect
    any number of consecutive red tokens simply by changing the value of 3 in Line
    5 of the algorithm.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这个算法更灵活，因为它可以很容易地通过更改算法中行 5 的 3 的值来检测任意数量的连续红色标记。
- en: '*Figure 1**.8* presents this algorithm diagrammatically in the form of a flowchart
    that shows the sequence of operations that take place when executing an algorithm.
    Lines with arrowheads indicate the sequence in which operations are carried out.
    Boxes indicate the actions themselves, and diamonds represent conditional actions.
    The expression in the diamond is evaluated to yield either “yes” or “no,” and
    control flows in one direction or another. In general, flowcharts are well suited
    to depicting simple algorithms, but they are regarded as very unsuitable for complex
    algorithms. A flowchart for a complex algorithm looks like a bowl of spaghetti
    – but without the spaghetti’s inherent clarity and organization.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.8* 以流程图的形式直观地表示了这个算法，展示了执行算法时发生的操作序列。带箭头的线条表示操作的执行顺序。方框表示操作本身，菱形代表条件操作。菱形中的表达式评估为“是”或“否”，并且控制流向一个方向或另一个方向。一般来说，流程图非常适合表示简单的算法，但它们被认为不适合复杂的算法。复杂算法的流程图看起来像一碗意大利面
    – 但没有意大利面固有的清晰性和组织性。'
- en: '![Figure 1.8 – An algorithm represented by a flowchart](img/B19624_01_08.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.8 – 用流程图表示的算法](img/B19624_01_08.jpg)'
- en: Figure 1.8 – An algorithm represented by a flowchart
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 用流程图表示的算法
- en: Constructing an algorithm
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建算法
- en: 'The next step is to provide an *algorithm* that tells us how to solve this
    problem clearly and unambiguously. As we step through the sequence of digits,
    we will need to keep track of what’s happening, as *Table* *1.2* demonstrates:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是提供一个 *算法*，它清楚地告诉我们如何明确无歧义地解决这个问题。当我们遍历数字序列时，我们需要跟踪正在发生的事情，正如 *表 1.2* 所展示的：
- en: '| **Position** **in sequence** | **0** | **1** | **2** | **3** | **4** | **5**
    | **6** | **7** | **8** | **9** | **10** | **11** | **12** | **13** |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| **序列中的位置** | **0** | **1** | **2** | **3** | **4** | **5** | **6** | **7**
    | **8** | **9** | **10** | **11** | **12** | **13** |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- |'
- en: '| New token | R | R | W | R | W | W | W | W | R | W | W | R | R | R |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 新标记 | R | R | W | R | W | W | W | W | R | W | W | R | R | R |'
- en: '| Is it red? | Y | Y | N | Y | N | N | N | N | Y | N | N | Y | Y | Y |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 是红色吗？ | Y | Y | N | Y | N | N | N | N | Y | N | N | Y | Y | Y |'
- en: '| Number of reds | 1 | 2 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 2 | 3 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 红色数量 | 1 | 2 | 0 | 1 | 0 | 0 | 0 | 0 | 1 | 0 | 0 | 1 | 2 | 3 |'
- en: Table 1.2 – A sequence of tokens selected at random
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.2 – 随机选择的标记序列
- en: '`REPEAT...UNTIL` are in bold. We will look at these operations in detail when
    we introduce Python:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`REPEAT...UNTIL` 是粗体的。当我们介绍 Python 时，我们将详细研究这些操作：'
- en: '[PRE1]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This pseudocode employs two constructs found in many high-level computer languages:
    the `REPEAT...UNTIL` construct in lines 3 to 8, and the `IF...THEN...ELSE` construct
    on lines 5 to 7\. `REPEAT...UNTIL` lets you carry out an action one or more times,
    while `IF...THEN...ELSE` lets you choose between one of two possible courses of
    action.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段伪代码采用了许多高级计算机语言中常见的两种结构：第 3 到 8 行的 `REPEAT...UNTIL` 结构，以及第 5 到 7 行的 `IF...THEN...ELSE`
    结构。`REPEAT...UNTIL` 允许你执行一次或多次动作，而 `IF...THEN...ELSE` 允许你在两种可能的行动之间进行选择。
- en: The `IF...THEN...ELSE` construct is central to the operation of digital computers
    and you will encounter it many times in this book.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`IF...THEN...ELSE` 结构是数字计算机操作的核心，你将在本书中多次遇到它。'
- en: 'The next step is to introduce Python so that we can write a program to implement
    this algorithm. Then, we can start to look at the computer. The following code
    shows a Python program and its output when executed. We haven’t introduced Python
    yet. The purpose of this program is to demonstrate how close it is to the preceding
    algorithm and the simplicity of Python:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是介绍 Python，这样我们就可以编写一个程序来实现这个算法。然后，我们可以开始研究计算机。以下代码显示了一个 Python 程序及其执行时的输出。我们还没有介绍
    Python。这个程序的目的在于展示它与前面的算法多么接近，以及 Python 的简单性：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `while numRed != maxRed:` line means *carry out the block of indented operations,
    so long as (*`while`*) the value of* `numRed` *is not equal to* `maxRed`. The
    `!=` Python operator means *not equal*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`while numRed != maxRed:` 这一行表示 *只要 (*`while`*) `numRed` 的值不等于 `maxRed`，就执行缩进的代码块。Python
    的 `!=` 操作符表示 *不等于*。'
- en: 'This is the output when the program is executed. It correctly identifies three
    consecutive reds and indicates the location of the first run in the run of three:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序执行时的输出。它正确地识别了三个连续的红色，并指出了三个红色序列中第一个红色出现的位置：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this first chapter, we introduced the concept of a computer via an FSM. A
    state machine is an abstraction of any system that can exist in one of several
    states at any instant. State machines are defined in terms of the states and the
    transitions between states. We introduced state machines as a precursor to digital
    systems. State machines introduce the notion of discrete states and discrete times.
    A state machine moves from one state to another at discrete instants in time.
    This mirrors the action of a program where actions (change of state) take place
    only when an instruction is executed.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过有限状态机（FSM）的概念介绍了计算机。状态机是任何可以在任何时刻存在于几种状态之一的系统的抽象。状态机是在状态及其状态之间转换的术语中定义的。我们引入状态机作为数字系统的一个先导。状态机引入了离散状态和离散时间的概念。状态机在离散的时间点从一个状态移动到另一个状态。这反映了程序的行为，其中动作（状态改变）仅在执行指令时发生。
- en: State machines can model systems as simple as traffic lights to a game of chess
    or a computer program. We also introduced the idea of algorithms – that is, a
    set of rules used to solve a problem. Later in this book, we’ll explain how computers
    can implement algorithms.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机可以模拟从交通灯到棋类游戏或计算机程序这样简单的系统。我们还介绍了算法的概念——即，用于解决问题的规则集。在本书的后面部分，我们将解释计算机如何实现算法。
- en: In [*Chapter 2*](B19624_02.xhtml#_idTextAnchor023), we’ll provide a brief overview
    of n. We’ve chosen this language because it has a remarkably shallow learning
    curve, is very powerful (it does a lot with a few lines of code), is taught in
    many universities, and is freely available to run on PCs, Macs, and Raspberry
    Pi systems.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B19624_02.xhtml#_idTextAnchor023) 中，我们将简要概述 n。我们选择这种语言是因为它有一个非常平缓的学习曲线，功能非常强大（用几行代码就能做很多事情），在许多大学中都有教授，并且可以在
    PC、Mac 和 Raspberry Pi 系统上免费运行。
