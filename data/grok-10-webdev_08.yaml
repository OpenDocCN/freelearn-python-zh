- en: Chapter 7. Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章 安全
- en: As it stands, our to-do list manager application can be accessed by anyone.
    Whoever can get to the 8080 port on the Grok server will be able to create, update,
    and delete projects and tasks.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的待办事项管理应用程序可以被任何人访问。任何能够访问Grok服务器上的8080端口的用户都将能够创建、更新和删除项目和任务。
- en: If we think about what we want the application to do, it would be nice if only
    authenticated users are able to access it in the first place. For example, it
    should be possible to install the application inside a company and have only a
    single department there as the application's users. Users with the correct permissions
    could create projects and assign tasks to team members.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑应用程序想要执行的操作，那么最初只允许经过身份验证的用户访问它将会很理想。例如，应该可以在公司内部安装应用程序，并且只有单个部门作为应用程序的用户。拥有正确权限的用户可以创建项目和将任务分配给团队成员。
- en: 'Grok includes the necessary tools to accomplish this, as we will see in this
    chapter. Here are the key concepts that we will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Grok包括完成此任务所需的工具，正如我们将在本章中看到的那样。以下是我们将学习的核心概念：
- en: Authentication and authorization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: Principals, permissions, and roles
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实体、权限和角色
- en: What the default security policy is and how it is defined in the `site.zcml`
    configuration file
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认安全策略是什么以及如何在`site.zcml`配置文件中定义它
- en: Setting up authentication using `site.zcml` declarations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`site.zcml`声明设置身份验证
- en: Setting up a custom security policy
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置自定义安全策略
- en: Adding and managing users
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和管理用户
- en: Authentication and authorization
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证和授权
- en: 'When speaking about web application security, there are two important concepts
    to get right before beginning: **authentication** and **authorization**.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论Web应用程序安全时，在开始之前有两个重要概念需要正确理解：**身份验证**和**授权**。
- en: In a given application, we might have a number of users who are allowed to log
    in. To do so, they usually would provide a username and a password. If the username
    and the password match, the user has been authenticated, so the system assumes
    he is who he says he is. In this chapter, we will learn how to perform authentication
    in Grok by using plugins.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个特定的应用程序中，我们可能会有许多被允许登录的用户。为了这样做，他们通常会提供一个用户名和一个密码。如果用户名和密码匹配，则用户已经通过身份验证，因此系统假设他就是他所说的那个人。在本章中，我们将学习如何通过使用插件在Grok中执行身份验证。
- en: Once a user is logged in, he may want to perform a number of actions, from just
    viewing the application to managing it. The user is authorized to perform some
    or all of the available actions by giving him specific permissions to carry them
    out.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户登录，他可能想要执行多项操作，从仅查看应用程序到管理它。通过给予他执行特定操作的特定权限，用户被授权执行一些或所有可用的操作。
- en: Principals, permissions, and roles
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体、权限和角色
- en: In Grok, users are known by the term 'principals'. A **principal** represents
    any entity that interacts with the application, be it a user or any kind of agent,
    such as a remote client program. A **group** is a special kind of principal that
    can contain other principals. In the rest of the chapter, we will mostly use the
    more familiar term 'user' when talking about principals.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在Grok中，用户被称为“实体”。一个**实体**代表与应用程序交互的任何实体，无论是用户还是任何类型的代理，例如远程客户端程序。一个**组**是一种特殊的实体，可以包含其他实体。在本章的其余部分，当我们谈论实体时，我们将主要使用更熟悉的术语“用户”。
- en: Views in Grok can be protected by permissions, so that only users with the correct
    permission can access each view. By default, however, Grok allows everybody including
    authenticated users, to have unrestricted access to all of the views.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Grok中的视图可以通过权限进行保护，这样只有拥有正确权限的用户才能访问每个视图。然而，默认情况下，Grok允许包括经过身份验证的用户在内的每个人都无限制地访问所有视图。
- en: Instead of assigning and keeping track of permissions to individual users, it's
    more efficient to group related permissions together and assign this group to
    a user. That's what roles do in Grok. For example, the admin user that we have
    been using for accessing the Grok administration UI has the role `zope.Manager`
    that grants all existing permissions to this user.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 与为单个用户分配和跟踪权限相比，将相关权限分组并将此组分配给用户更有效率。这就是Grok中角色的作用。例如，我们一直在使用的用于访问Grok管理UI的admin用户具有`zope.Manager`角色，该角色授予此用户所有现有权限。
- en: We'll learn about permissions and roles after we introduce security policies
    in the *Setting up a custom security policy* section of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍本章的“*设置自定义安全策略*”部分中的安全策略之后，我们将了解权限和角色。
- en: Security policies
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全策略
- en: A Grok application will thus have a number of principals, permissions, and roles.
    The collection of these is called a **security policy** and represents the global
    security decisions for a specific application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Grok应用程序将具有许多主体、权限和角色。这些集合被称为**安全策略**，代表特定应用程序的全局安全决策。
- en: As we mentioned before, Grok applications have a default security policy that
    gives view permission to everybody. It also defines authenticated and unauthenticated
    user groups.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Grok应用程序有一个默认的安全策略，它给予所有人查看权限。它还定义了认证和未认证的用户组。
- en: Default Grok security policy definition
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认的Grok安全策略定义
- en: The security policy that Grok uses by default is defined in the `site.zcml`
    file, which is inside the `etc` directory. There are several declarations in this
    file which we will discuss individually.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Grok默认使用的安全策略定义在`site.zcml`文件中，该文件位于`etc`目录内。此文件中有几个声明，我们将逐一讨论。
- en: 'The following statement is the user representation for unauthenticated users
    in the system:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明是系统中未认证用户的用户表示：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All of the users who visit the application without authenticating will share
    this same ID.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有未认证访问应用程序的用户将共享相同的ID。
- en: 'The unauthenticated group is assigned to unauthenticated principals:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 未认证组被分配给未认证主体：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is useful to have this defined for group operations.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分组操作来说，定义这一点是有用的。
- en: 'Next, we have a dynamic group that includes all of the authenticated users,
    irrespective of their permissions or roles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们有一个包含所有已认证用户的动态组，无论他们的权限或角色如何：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Finally, there is a group that includes all users, authenticated or not:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一个包括所有用户（认证或不认证）的组：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We now come to the part where users are defined. In this case, there is only
    one user, the "site manager", with the login "admin":'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来到了定义用户的部分。在这种情况下，只有一个用户，即“站点管理员”，登录名为“admin”：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As you can see, the password is assigned to this manager using plain text. You
    may recall that the title defined here is what we show in the creator column when
    listing the projects in the dashboard.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，密码以纯文本形式分配给此管理员。您可能还记得这里定义的标题是我们列出仪表板中的项目时在创建者列中显示的内容。
- en: The next two declarations grant the permissions for viewing to the `zope`. Anybody
    user that represents the unauthenticated principal defined earlier.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个声明将查看权限授予`zope`。任何代表之前定义的未认证主体的`Anybody`用户。
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that in this case there is no separate definition for permission, because
    a permission is just a name. These declarations allow all unauthenticated users
    to view, so by default, an application is wide open for viewing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，没有单独的权限定义，因为权限只是一个名称。这些声明允许所有未认证用户查看，因此默认情况下，应用程序对查看是开放的。
- en: 'Next comes the role definitions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是角色定义：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: A "site manager" role is defined for managing the site. Then, a "site member"
    role is defined for regular site users, although this role is unused in the default
    configuration.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个“站点管理员”角色用于管理站点。然后，定义了一个“站点成员”角色用于常规站点用户，尽管在默认配置中此角色未使用。
- en: Finally, all of the permissions are granted to the `zope.Manager` role by using
    `grantAll`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过使用`grantAll`将所有权限授予`zope.Manager`角色。
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This means that users with the manager role will get all defined permissions.
    The role is then assigned to the user we defined earlier in the *Principals, permissions,
    and roles* section.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着具有管理角色的用户将获得所有定义的权限。然后，该角色被分配到我们在*主体、权限和角色*部分中定义的用户。
- en: 'To recap, a security policy consists of:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，安全策略由以下内容组成：
- en: A number of users who can log into the application.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一群可以登录应用程序的用户。
- en: Groups of users, which can contain any number of users. A user can also belong
    to several groups.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户组，可以包含任意数量的用户。一个用户也可以属于多个组。
- en: Specific permissions for allowing these users to work with parts of the application.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许这些用户与应用程序的部分进行工作的特定权限。
- en: Roles that can be assigned multiple permissions, so that a user or group can
    be assigned a role that includes all related permissions for a task. This greatly
    simplifies permission administration.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以分配多个权限的角色，这样用户或组可以分配一个包含所有相关权限的任务角色。这大大简化了权限管理。
- en: Modifying the security policy
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改安全策略
- en: So far, we have been accessing the application by using the "manager" user that
    is defined in the *Default Grok security policy definition* section. Now, close
    all of the browser windows, reopen the browser, and go to the `todo` application
    URL directly, without logging in. You are unauthenticated, yet no login window
    will be shown. Add a project or make some other change and see how the application
    does it obediently.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是通过使用在*默认Grok安全策略定义*部分中定义的“manager”用户来访问应用程序的。现在，关闭所有浏览器窗口，重新打开浏览器，直接访问`todo`应用程序的URL，无需登录。你未经过身份验证，但不会显示登录窗口。添加一个项目或进行其他更改，看看应用程序是如何顺从地执行的。
- en: '![Modifying the security policy](img/7481_07_01.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![修改安全策略](img/7481_07_01.jpg)'
- en: Wait a minute, didn't we say that only the view permission was assigned to the
    unauthenticated user? Why did Grok allow us to make changes to the projects then?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下，我们不是说只将查看权限分配给了未经身份验证的用户吗？那么Grok为什么允许我们更改项目呢？
- en: Well, the thing is, views need to be specifically protected with permissions,
    if we want to protect them. Until we do so it doesn't matter whether the user
    is authenticated or not, much less, if he holds the required permissions. Again,
    all of this is intended by the very open default security policy for Grok applications.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，问题是，如果我们想保护它们，视图需要通过权限进行特别保护。在我们这样做之前，用户是否经过身份验证并不重要，更不用说如果他拥有所需的权限。再次强调，所有这些都是Grok应用程序非常开放默认安全策略的意图。
- en: Modifying the default view permissions
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改默认视图权限
- en: 'Let''s change the default security policy a bit to see how it works. In the
    specific case of the to-do list manager, we would like to keep unauthenticated
    users away, so let''s begin by changing the `grant permission` declarations to
    look like the following code:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微修改一下默认安全策略，看看它是如何工作的。在待办事项列表管理员的特定情况下，我们希望阻止未经身份验证的用户，因此让我们首先将`grant permission`声明更改为以下代码：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Instead of granting view permissions to everybody, we grant them to the `zope.Authenticated`
    group that we defined earlier, so that only authenticated users are allowed to
    access the application.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是将查看权限授予每个人，而是授予我们之前定义的`zope.Authenticated`组，这样只有经过身份验证的用户才能访问应用程序。
- en: Adding a new user
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加新用户
- en: 'To test these declarations, we need to add another user to the site, because
    the "manager" user will get the view permission anyway. Add the following lines
    to `site.zcml`, after the manager definition:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试这些声明，我们需要向网站添加另一个用户，因为“manager”用户无论如何都会获得查看权限。在`site.zcml`中添加以下行，在manager定义之后：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We now have a `todo.user` with "user" as the username and password. Save the
    file and restart Grok. It is necessary to delete and create the application again,
    as security policies are applied at the moment of application creation.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个`todo.user`，用户名为“user”，密码为“password”。保存文件并重新启动Grok。由于安全策略是在创建应用程序时应用的，因此有必要删除并重新创建应用程序。
- en: 'Now it should be possible to log in as `todo.user`. Try it: Go to the root
    of the site to get the login window, and then enter the new user''s login and
    password. You will see an error message because the new user does not have permission
    to manage Grok applications. Ignore the error and go to the application URL. The
    project dashboard will appear in the browser.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该可以以`todo.user`的身份登录。试试看：前往网站的根目录以获取登录窗口，然后输入新用户的登录名和密码。你会看到一个错误消息，因为新用户没有权限管理Grok应用程序。忽略错误并转到应用程序URL。项目仪表板将在浏览器中显示。
- en: Of course, our new user can create and delete projects and tasks, as the views
    are not protected. Not only that, but unauthenticated users can still view and
    edit everything.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们的新用户可以创建和删除项目以及任务，因为视图没有受到保护。不仅如此，未经身份验证的用户仍然可以查看和编辑一切。
- en: Protecting a view
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保护视图
- en: 'It''s time to protect a view and keep unauthenticated users away from it, as
    intended. Just change the dashboard view to the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候保护一个视图并阻止未经身份验证的用户访问它了，正如预期的那样。只需将仪表板视图更改为以下内容：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To protect a view with a permission, we use the `grok.require` class annotation.
    Notice how we passed the permission name to it as defined in the `site.zcml` configuration
    file. Restart the application (no need to re-create it this time), and then close
    and open the browser to lose the current authentication information. Try to access
    the application URL without logging in and you should get the login window. Unauthenticated
    users can't view the dashboard anymore. Enter the `todo.user` credentials, and
    the dashboard will appear again.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用权限保护一个视图，我们使用`grok.require`类注解。注意我们是如何将权限名称传递给它，正如在`site.zcml`配置文件中定义的那样。重新启动应用程序（这次不需要重新创建它），然后关闭并重新打开浏览器以丢失当前的认证信息。尝试在不登录的情况下访问应用程序URL，你应该会看到登录窗口。未经认证的用户不能再查看仪表板了。输入`todo.user`凭证，仪表板将再次出现。
- en: Setting up a custom security policy
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置自定义安全策略
- en: Now that we have seen how the security machinery works, we are ready to add
    our own security policy to the application. Let's begin by creating some permissions,
    and attaching them to our views.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了安全机制的工作原理，我们准备将我们自己的安全策略添加到应用程序中。让我们从创建一些权限并将它们附加到我们的视图中开始。
- en: Creating permissions
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建权限
- en: Grok offers a very easy mechanism for defining permissions and restricting access.
    A permission can be defined simply by subclassing from the `grok.Permission` class
    and adding a name.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Grok提供了一个非常简单的机制来定义权限和限制访问。可以通过从`grok.Permission`类派生并添加一个名称来简单地定义一个权限。
- en: 'To keep things simple, let''s define only four permissions for our application
    a general permission to view, and specific permissions for adding projects and
    lists or modifying list items:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持简单，让我们只为我们的应用程序定义四个权限：一个通用的查看权限，以及添加项目和列表或修改列表项的特定权限：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Permissions are applied to views by using the `grok.require` directive, so
    to protect each of our views we need to go through our application code and add
    an appropriate `grok.require` statement to each view. For example:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`grok.require`指令将权限应用于视图，因此为了保护我们的每个视图，我们需要遍历我们的应用程序代码，并为每个视图添加适当的`grok.require`语句。例如：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We protect the dashboard with our view permission, which means no anonymous
    users will be able to access it. The `TodoAddList` view will require `addlists`
    permission, and to delete a project, the `addprojects` permission is necessary.
    In this way, we can protect all of our views with the permissions that we want.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用视图权限保护仪表板，这意味着匿名用户将无法访问它。`TodoAddList`视图将需要`addlists`权限，而要删除项目，则需要`addprojects`权限。这样，我们可以使用我们想要的权限来保护所有视图。
- en: Roles
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: The views are protected with permissions, but assigning the permissions to actual
    users is best done by using roles. Let's define three simple roles for the application.
    *Project members* will be able to view and change list items only. *Project managers*
    can do all that and also create lists. *Application managers* are the only ones
    who can create projects.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 视图通过权限进行保护，但将权限分配给实际用户最好是通过使用角色。让我们为应用程序定义三个简单的角色。*项目成员*将只能查看和更改列表项。*项目经理*可以执行所有这些操作，还可以创建列表。*应用程序管理员*是唯一可以创建项目的人。
- en: 'The `grok.Role` class is useful for defining these roles, as shown by the following
    code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`grok.Role`类对于定义这些角色很有用，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we have created four separate roles for different user levels in our application.
    Each role is assigned a name and one or more permissions by using the `grok.name`
    and `grok.permissions` declarations respectively.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经为我们的应用程序中不同用户级别创建了四个不同的角色。每个角色分别通过使用`grok.name`和`grok.permissions`声明分配了一个名称和一个或多个权限。
- en: As you can see, a **role** is simply a collection of permissions with a name.
    The benefit of using such a collection instead of assigning each permission individually
    is that once a role is assigned to a user, it's possible to add or remove permissions
    from the role without having to grant or remove them from each user individually.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，**角色**只是一个具有名称的权限集合。使用此类集合而不是单独分配每个权限的好处是，一旦将角色分配给用户，就可以在不为每个用户单独授予或撤销权限的情况下，向角色添加或删除权限。
- en: Adding authentication
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加认证
- en: We now have all of our views protected, but so far there are no users, so nobody
    can be assigned the roles that we created. We need to add a mechanism for creating
    and managing users, as well as a way to authenticate them and assign roles to
    them, so that they can use the different views.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经保护了所有的视图，但到目前为止还没有用户，所以没有人可以被分配我们创建的角色。我们需要添加一个创建和管理用户以及验证他们并分配角色的机制，这样他们就可以使用不同的视图。
- en: The Pluggable Authentication Utility
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可插拔认证工具
- en: The **Pluggable Authentication Utility** (**PAU**) is a framework for authenticating
    users. It is a part of the Zope Toolkit and currently Grok offers no built-in
    mechanisms to work with it, but we'll see that it is not too complex.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**可插拔认证工具**（**PAU**）是一个用于用户认证的框架。它是Zope工具包的一部分，目前Grok没有提供内置机制来与之工作，但我们将看到它并不复杂。'
- en: PAU uses plugins to do its work, so that it's possible to have plugins for different
    authentication sources, and easily substitute one for another, or even have them
    work together.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: PAU使用插件来完成其工作，因此可以有不同的认证源插件，并且可以轻松地替换它们，甚至让它们协同工作。
- en: 'There are two types of plugins for PAU: "credentials" plugins extract credentials
    from a request (user and password, for example) and "authenticator" plugins check
    that these credentials are valid and generate a user for the application to work
    with, if they are.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: PAU有两种类型的插件：“凭证”插件从请求中提取凭证（例如用户名和密码），“认证”插件检查这些凭证是否有效，并在凭证有效的情况下为应用程序生成一个用户。
- en: Registering PAU with our application
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的应用程序中注册PAU
- en: To be able to use PAU in our application, we first need to register it as a
    local utility. A **utility** is simply a service that an application can provide.
    Being local means that it can store information and configuration specific to
    each instance of the application.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要能够在我们的应用程序中使用PAU，我们首先需要将其注册为一个本地实用程序。**实用程序**是一个应用程序可以提供的服务。本地意味着它可以存储特定于应用程序每个实例的信息和配置。
- en: Here's how we can register PAU in our main `todo` application definition. First,
    we import `PluggableAuthentication`, which is a factory that will create the actual
    PAU object. We also import `IAuthentication`, which is the interface that our
    PAU utility must provide in order to integrate with the authentication machinery.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何在我们的主`todo`应用程序定义中注册PAU的方法。首先，我们导入`PluggableAuthentication`，这是一个工厂，将创建实际的PAU对象。我们还导入了`IAuthentication`，这是我们的PAU实用程序必须提供的接口，以便与认证机制集成。
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we register a PAU utility, we need to configure it to use the appropriate
    plugins, which is the purpose of the `setup_authentication import` statement in
    the preceding code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们注册一个PAU实用程序时，我们需要配置它使用适当的插件，这就是前面代码中`setup_authentication import`语句的目的。
- en: 'Now we register the utility by using the `grok.local_utility` directive and
    passing to the directive the `PluggableAuthentication` factory, the interface
    that it''s going to provide, and the `setup` function. Keep in mind that this
    directive is in no way exclusive to PAU­ any kind of service can be registered
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过使用`grok.local_utility`指令并传递给该指令`PluggableAuthentication`工厂、它将要提供的接口以及`setup`函数来注册这个实用程序。请注意，这个指令并不局限于PAU，任何类型的服务都可以这样注册：
- en: '[PRE15]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'That''s all we need to do for now in the main `app.py` file. Let''s add the
    `setup_authentication` method, and all of the other security classes and views,
    in another module. Create the `auth.py` file and add the following lines to it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在主`app.py`文件中我们只需要做这么多。让我们添加`setup_authentication`方法，以及其他所有安全类和视图，到另一个模块中。创建`auth.py`文件，并添加以下行到其中：
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a very simple method that just assigns a plugin named `credentials`
    to the `credentialsPlugins` of our PAU, and assigns another plugin named `users`
    to the `authenticatorPlugins`. The first will take care of extracting the user's
    credentials from the browser request and making them available to the application.
    The `users` plugin will be used for authentication. Of course, these plugins do
    not exist yet; we need to create them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的方法，它只是将一个名为`credentials`的插件分配给PAU的`credentialsPlugins`，并将另一个名为`users`的插件分配给`authenticatorPlugins`。第一个将负责从浏览器请求中提取用户的凭证并将其提供给应用程序。`users`插件将用于认证。当然，这些插件目前还不存在；我们需要创建它们。
- en: Adding a credentials plugin
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加凭证插件
- en: For the credential extraction service, we are going to use a plugin called `SessionCredentialsPlugin`,
    which comes with the Zope Toolkit. As its name implies, this plugin stores the
    credentials extracted by requesting the session, so that the application can easily
    use this information. As we don't need to store any application-specific information
    inside the plugin, let's use a global utility this time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于凭据提取服务，我们将使用一个名为 `SessionCredentialsPlugin` 的插件，该插件包含在 Zope 工具包中。正如其名称所暗示的，此插件通过请求会话存储提取的凭据，以便应用程序可以轻松使用这些信息。由于我们不需要在插件中存储任何特定于应用程序的信息，这次让我们使用一个全局实用工具。
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A **global utility** is simply a service that is not stored in the application
    data, but resides in a registry that's available to all application instances
    in Grok. We will explain utilities in more detail in Chapter 11.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**全局实用工具** 简单来说是一个不存储在应用程序数据中，但位于可供 Grok 中所有应用程序实例访问的注册表中的服务。我们将在第 11 章中更详细地解释实用工具。'
- en: Notice how we inherit from both `grok.GlobalUtility` and the `SessionCredentialsPlugin`
    that we mentioned earlier. The `grok.name` directive is very important here because
    it assigns a name to the plugin that we configured earlier in the `setup_authentication`
    method for our PAU.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何从 `grok.GlobalUtility` 和我们之前提到的 `SessionCredentialsPlugin` 继承。这里的 `grok.name`
    指令非常重要，因为它为我们之前在 `setup_authentication` 方法中为我们的 PAU 配置的插件分配了一个名称。
- en: After that comes a few class variables that are used to configure how the plugin
    works. `loginpagename` is the name of the view that will be shown whenever a user
    attempts to access a protected page. Typically, this points to a login form. `loginfield`
    and `passwordfield` are the names of the fields within this form that will contain
    the credentials of the user. They will be used by the authenticator plugin to
    authenticate the user with the application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之后是一些用于配置插件工作方式的类变量。`loginpagename` 是当用户尝试访问受保护页面时将显示的视图的名称。通常，这指向一个登录表单。`loginfield`
    和 `passwordfield` 是表单中包含用户凭据的字段名称。它们将由认证插件用于使用应用程序对用户进行认证。
- en: The login form
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 登录表单
- en: Now that we have configured the credentials plugin, to look for the login form
    when a user wants to access a protected view, we might as well create the form
    immediately.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了凭据插件，当用户想要访问受保护视图时查找登录表单，我们不妨立即创建该表单。
- en: First, we define a form schema by using an interface. The `login` and `password`
    fields should have the exact same names that we configured in the credentials
    plugin. We added a `camefrom` parameter that will be used to redirect the user
    to the page he wanted to view before he logged in.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过使用接口定义一个表单模式。`login` 和 `password` 字段应该与我们配置在凭据插件中的名称完全相同。我们添加了一个 `camefrom`
    参数，该参数将用于在用户登录之前将其重定向到他想要查看的页面。
- en: '[PRE18]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `SessionCredentialsPlugin` automatically adds this variable to the request
    when it redirects the user to the login form, so the name has to be the same.
    That's why we assign an empty string to the form field `prefix` in the following
    code to keep the name intact.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionCredentialsPlugin` 在将用户重定向到登录表单时自动将此变量添加到请求中，因此名称必须相同。这就是为什么我们在以下代码中将表单字段的
    `prefix` 赋值为空字符串，以保持名称不变。'
- en: Notice that we use the `grok.require` declaration to assign the permission `zope.Public`
    to the view. This permission is defined in the Zope Toolkit that powers Grok and
    is assigned to the views that everyone can see. We use this permission to make
    it explicit that every visitor to our application can get to the login form.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用 `grok.require` 声明将权限 `zope.Public` 分配给视图。此权限在驱动 Grok 的 Zope 工具包中定义，并分配给所有人都可以看到的视图。我们使用此权限来明确表示，每位访问我们应用程序的访客都可以访问登录表单。
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need a `setUpWidgets` method inside this class, so that we can make sure
    that the `camefrom` field is not displayed on the form, which uses the custom
    template we created back in Chapter 5\. This is done so that it looks integrated
    with the design that we are using.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在这个类中实现一个 `setUpWidgets` 方法，以确保 `camefrom` 字段不会在表单上显示，该表单使用我们在第 5 章中创建的自定义模板。这样做是为了使其看起来与我们所使用的布局融为一体。
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, the `handle_login` action redirects the user to the `camefrom` URL,
    or to the site root if `camefrom` is not available. If the user enters invalid
    credentials, the login form will be displayed again.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`handle_login` 动作将用户重定向到 `camefrom` URL，或者如果 `camefrom` 不可用，则重定向到网站根目录。如果用户输入无效凭据，登录表单将再次显示。
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That''s it. Look at the form in action, in the next screenshot:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。看看下一个截图中的表单在实际操作中的样子：
- en: '![The login form](img/7481_07_02.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![登录表单](img/7481_07_02.jpg)'
- en: The logout view
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注销视图
- en: 'We have a login mechanism, so we need a way to finish a session and maybe log
    in as a different user. We will add a logout view to take care of this requirement:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个登录机制，所以我们需要一种方法来结束会话，也许登录为不同的用户。我们将添加一个注销视图来处理这个需求：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we need to determine if the current user is logged in, which we do by
    getting this information from the request by using `self.request.principal` and
    checking to see if it provides the `IUnauthenticatedPrincipal` interface. If it
    does, then we'll know that this user is not authenticated. If it turns out that
    he is authenticated, we look for our PAU by using `component.getUtility` and calling
    the `logout` method.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确定当前用户是否已登录，我们通过使用 `self.request.principal` 从请求中获取此信息，并检查它是否提供了 `IUnauthenticatedPrincipal`
    接口。如果是，那么我们就知道这个用户未认证。如果结果显示他已经认证，我们将使用 `component.getUtility` 来查找我们的 PAU 并调用
    `logout` 方法。
- en: This view needs a template, which we will keep pretty simple for now. Take a
    look at the next screenshot to see this view in action.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图需要一个模板，我们现在将保持它相当简单。请看下一张截图以查看此视图的实际操作。
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![The logout view](img/7481_07_03.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![注销视图](img/7481_07_03.jpg)'
- en: The UserAuthenticator plugin
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UserAuthenticator 插件
- en: For the authentication part, we are going to need another local utility because
    we need to store user information in there. We register the utility in a similar
    way to the PAU utility, by using the `grok.local_utility` directive. In fact,
    this code goes just below the PAU declaration in our main application file, `app.py:`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于认证部分，我们需要另一个本地实用工具，因为我们需要在那里存储用户信息。我们以类似 PAU 实用工具的方式注册该实用工具，使用 `grok.local_utility`
    指令。实际上，这段代码位于我们的主应用程序文件 `app.py` 中的 PAU 声明下方：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The only difference here is that we pass a `name` parameter that has to correspond
    to the name that we used for the plugin in the `setup_authentication` method.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是我们传递了一个 `name` 参数，它必须与我们在 `setup_authentication` 方法中用于插件的名称相匹配。
- en: We are going to create a Grok container in order to store the user accounts
    there, so our plugin will know how to create a new user, and to decide if a login
    attempt has valid credentials for an existing one. Let's look at the authenticator
    plugin code step-by-step.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 Grok 容器来存储用户账户，因此我们的插件将知道如何创建新用户，并决定登录尝试是否为现有用户提供了有效的凭证。让我们一步一步地查看认证插件代码。
- en: 'First, we need to make some imports, and then comes the plugin definition:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要做一些导入，然后是插件定义：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Notice how we inherit from `grok.LocalUtility` and implement the `IAuthenticatorPlugin`
    interface. When the utility is initialized (the `__init__` method), we create
    a user folder and store it there. The user folder is a simple Grok container:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何从 `grok.LocalUtility` 继承并实现 `IAuthenticatorPlugin` 接口。当实用工具初始化（`__init__`
    方法）时，我们创建一个用户文件夹并将其存储在那里。用户文件夹是一个简单的 Grok 容器：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now we come to the methods of the plugin itself. The `authenticateCredentials`
    method is called whenever a login attempt is made. It receives the credentials
    that the credentials plugin extracted from the request, and then uses the `getAccount`
    method to try to get a valid account. Next, it calls the account's `checkPassword`
    method to verify the password against the one from the user's credentials.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看插件本身的方法。`authenticateCredentials` 方法在每次登录尝试时被调用。它接收凭证插件从请求中提取的凭证，然后使用
    `getAccount` 方法尝试获取一个有效账户。接下来，它调用账户的 `checkPassword` 方法来验证密码与用户凭证中的密码是否一致。
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Notice that the `authenticateCredentials` method returns a `PrincipalInfo` object
    that contains the account name, the title or display name, and the description
    for the user. This object implements the `IPrincipalInfo` interface that was imported
    at the top of the code, which means that you can expect to find similar behavior
    in other authenticator plugins.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`authenticateCredentials` 方法返回一个包含账户名称、标题或显示名称和用户描述的 `PrincipalInfo` 对象。此对象实现了在代码顶部导入的
    `IPrincipalInfo` 接口，这意味着你可以在其他认证插件中期待找到类似的行为。
- en: Here's the `PrincipalInfo` class code that is used in this plugin. In addition
    to the principal information, it holds the credentials and authenticator plugins
    used to authorize the user.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这是此插件中使用的 `PrincipalInfo` 类代码。除了主体信息外，它还持有用于授权用户的凭证和认证插件。
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `IAuthenticatorPlugin` interface that we are implementing in this plugin
    needs to have a `principalInfo` method, which should return the `PrincipalInfo`
    object that we just defined:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个插件中实现的 `IAuthenticatorPlugin` 接口需要有一个 `principalInfo` 方法，该方法应返回我们刚刚定义的
    `PrincipalInfo` 对象：
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The plugin's most important method is `getAccount`, which tries to find a given
    user account inside the `user_folder`, and returns that, or `None`, if the user
    is not found. Right now we are using the Grok ZODB to store the users, but we
    could easily access a relational database, or an external authentication system
    instead, by modifying this method.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 插件最重要的方法是 `getAccount`，它试图在 `user_folder` 中找到指定的用户账户，并返回该账户，如果用户未找到，则返回 `None`。目前我们使用
    Grok ZODB 存储用户，但我们可以通过修改此方法轻松访问关系数据库或外部认证系统。
- en: The implementation is fairly straightforward. We use a Boolean expression to
    check if the login that was passed into the method is in our `user` folder and
    if so, return the user object that's inside. Otherwise, we return `None:`
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 实现相当直接。我们使用布尔表达式检查传递给方法的方法登录是否在我们的 `user` 文件夹中，如果是，则返回文件夹内的用户对象。否则，我们返回 `None`：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Adding users
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加用户
- en: The other important method of our authenticator plugin is `addUser`. This creates
    an account object with a given username, and then uses this name to assign a role
    to the user.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认证插件中的另一个重要方法是 `addUser`。它创建一个具有给定用户名的账户对象，然后使用此名称为用户分配一个角色。
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: After creating a user account inside our `user` folder, the most important bit
    in this method is the part where we take the role that is passed from the `addUser`
    form and assign the appropriate role to the new user accordingly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `user` 文件夹内创建用户账户后，这个方法中最重要的部分是我们根据 `addUser` 表单传递的角色分配适当的角色给新用户的部分。
- en: 'Observe how we first get the `RoleManager` for the site, as follows:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 观察我们首先如何获取站点的 `RoleManager`，如下所示：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, when we know what role to apply, we use its `assignRoleToPrincipal` method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们知道要应用什么角色时，我们使用其 `assignRoleToPrincipal` 方法：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the account class that we use:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们使用的账户类：
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Account objects need to include the `checkPassword` and `setPassword` methods,
    which are used together with a password manager utility. The utility does all
    of the heavy work, as the `checkPassword` method simply gets the account password
    and passes it, together with the password that the user entered, to the `checkPassword`
    method of the `passwordManager`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 账户对象需要包含 `checkPassword` 和 `setPassword` 方法，这些方法与密码管理实用程序一起使用。实用程序执行所有繁重的工作，因为
    `checkPassword` 方法只是获取账户密码并将其与用户输入的密码一起传递给 `passwordManager` 的 `checkPassword`
    方法。
- en: The `setPassword` method uses the `encodePassword` method of the `passwordManager`
    utility to set the password. You may recall that we saw a 'plain-text' password
    manager when we worked with the `site.zcml` declarations at the beginning of this
    chapter. In this case, we use a `SHAI` password manager, to be able to store encrypted
    passwords.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`setPassword` 方法使用 `passwordManager` 实用程序的 `encodePassword` 方法来设置密码。你可能还记得，当我们在本章开头处理
    `site.zcml` 声明时，我们看到了一个 ''plain-text'' 密码管理器。在这种情况下，我们使用 `SHAI` 密码管理器，以便能够存储加密密码。'
- en: Basic user management
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基本用户管理
- en: 'Of course, we need a way to add users to our application. The `addUser` method
    of the `UserAuthenticator` is exclusively called by a form that we define using
    the interface and schema mechanism for automatic form presentation that were discussed
    in Chapter 5\. First, we define an interface for the form fields:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要一种方法将用户添加到我们的应用程序中。`UserAuthenticator` 的 `addUser` 方法仅由我们使用第 5 章中讨论的接口和模式机制定义的表单自动呈现机制调用。首先，我们为表单字段定义一个接口：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then we define the actual `AddUser` form, which uses the fields from the previously
    defined interface to construct the form. The `handle_add` method uses the Grok
    `action` decorator to add a button to the form that will call the `addUser` method
    from the authenticator plugin:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义实际的 `AddUser` 表单，该表单使用先前定义的接口中的字段来构建表单。`handle_add` 方法使用 Grok 的 `action`
    装饰器向表单添加一个按钮，该按钮将调用认证插件中的 `addUser` 方法：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice how we add a role field that allows the manager to assign one of our
    defined roles to each user. It''s very important to note that this user management
    view is protected with the `zope.ManageApplication` permission, which is assigned
    to Zope managers only. If we used one of our own permissions, we would never be
    able to create a user in the first place. The finished form can be seen in the
    following screenshot:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何添加一个角色字段，允许管理员将我们定义的其中一个角色分配给每个用户。值得注意的是，这个用户管理视图受到`zope.ManageApplication`权限的保护，这个权限仅分配给Zope管理员。如果我们使用我们自己的权限，我们根本无法首先创建用户。完成后的表单可以在以下截图查看：
- en: '![Basic user management](img/7481_07_04.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![基本用户管理](img/7481_07_04.jpg)'
- en: 'A simple user list view completes the user interface for our user management
    application:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的用户列表视图完成了我们用户管理应用程序的用户界面：
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Nothing new here. We just get the list of users from the `UserAuthenticator`
    plugin and pass it on to the view template, which simply lists the users in a
    table. You should now be familiar with some of this code. First, we insert our
    stylesheet definition using the static view, to correctly show the URL in the
    template:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有新内容。我们只是从`UserAuthenticator`插件获取用户列表，并将其传递给视图模板，模板简单地以表格形式列出用户。你现在应该熟悉一些这段代码。首先，我们使用静态视图插入我们的样式表定义，以正确显示模板中的URL：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In the main body of the template, we have the site search form that is a part
    of the header, and contains the application's title. Then we have a link to add
    a new user, which points to the form that we just defined.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在模板的主体中，我们有一个作为页眉一部分的站点搜索表单，其中包含应用程序的标题。然后有一个链接用于添加新用户，它指向我们刚刚定义的表单。
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The user listing is shown only if there are any users, and consists of a table
    that iterates through the user listing defined in the `UserList` view (view/users).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当存在用户时，用户列表才会显示，它由一个表格组成，该表格遍历在`UserList`视图中定义的用户列表（视图/users）。
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: That's it. We can now have multiple users with different profiles in our application,
    as shown in the next screenshot. Create some users and test the permissions and
    roles to see how it works together.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在我们可以在应用程序中拥有多个具有不同配置文件的用户，如下一张截图所示。创建一些用户并测试权限和角色，以了解它们是如何协同工作的。
- en: '![Basic user management](img/7481_07_05.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![基本用户管理](img/7481_07_05.jpg)'
- en: Summary
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about Grok's security features, and added authentication
    and authorization to our application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了Grok的安全功能，并将身份验证和授权添加到我们的应用程序中。
