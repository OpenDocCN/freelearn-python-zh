- en: '8'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '8'
- en: More Advanced Class Design
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级的类设计
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), we looked at some recipes
    that covered the basics of class design. In this chapter, we’ll dive more deeply
    into Python classes and class design.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [7](ch011_split_000.xhtml#x1-3760007) 章中，我们探讨了涵盖类设计基础的一些菜谱。在这一章中，我们将更深入地探讨
    Python 类和类设计。
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    and [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipes in Chapter [7](ch011_split_000.xhtml#x1-3760007), we identified a design
    choice that’s central to object-oriented programming, the ”wrap versus extend”
    decision. One way to add features is to create a new subclass via an extension.
    The other technique for adding features is to wrap an existing class, making it
    part of a new class.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [7](ch011_split_000.xhtml#x1-3760007) 章的 [设计大量处理的类](ch011_split_000.xhtml#x1-3890003)
    和 [使用属性实现懒属性](ch011_split_001.xhtml#x1-43100010) 菜谱中，我们确定了一个面向对象编程的核心设计选择，“封装与扩展”决策。添加功能的一种方式是通过扩展创建一个新的子类。添加功能的另一种技术是封装一个现有的类，使其成为新类的一部分。
- en: In addition to direct inheritance, there are some other class extension techniques
    available in Python. A Python class can inherit features from more than one superclass.
    We call this design pattern a mixin.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接继承之外，Python 中还有一些其他类扩展技术可用。一个 Python 类可以从多个超类继承功能。我们称这种设计模式为混入（mixin）。
- en: In Chapter [4](ch008_split_000.xhtml#x1-2240004) and Chapter [5](ch009.xhtml#x1-2890005),
    we looked at the core built-in data structures. We can combine and extend these
    collection definition features to create more complex data structures or data
    structures with additional features.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [4](ch008_split_000.xhtml#x1-2240004) 章和第 [5](ch009.xhtml#x1-2890005) 章中，我们探讨了核心内置数据结构。我们可以结合和扩展这些集合定义功能，以创建更复杂的数据结构或具有附加功能的数据结构。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将探讨以下菜谱：
- en: '[Choosing between inheritance and composition – the ”is-a” question](ch012.xhtml#x1-4530001)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在继承和组合之间选择 – “是”问题](ch012.xhtml#x1-4530001)'
- en: '[Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[通过多重继承分离关注点](ch012.xhtml#x1-4610002)'
- en: '[Leveraging Python’s duck typing](ch012.xhtml#x1-4670003)'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[利用 Python 的鸭子类型](ch012.xhtml#x1-4670003)'
- en: '[Managing global and singleton objects](ch012.xhtml#x1-4730004)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[管理全局和单例对象](ch012.xhtml#x1-4730004)'
- en: '[Using more complex structures – maps of lists](ch012.xhtml#x1-4810005)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用更复杂的结构 – 列表映射](ch012.xhtml#x1-4810005)'
- en: '[Creating a class that has orderable objects](ch012.xhtml#x1-4870006)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[创建具有可排序对象的类](ch012.xhtml#x1-4870006)'
- en: '[Deleting from a list of complicated objects](ch012.xhtml#x1-4930007)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[从复杂对象的列表中删除](ch012.xhtml#x1-4930007)'
- en: 'There are a great many techniques of object-oriented class design available
    in Python. We’ll start with a foundational design concept: making the design choice
    between using inheritance from a base class and wrapping a class to extend it.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python 中有大量的面向对象类设计技术。我们将从一个基础设计概念开始：在从基类继承和使用封装来扩展之间做出设计选择。
- en: 8.1 Choosing between inheritance and composition – the ”is-a” question
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.1 在继承和组合之间选择 – “是”问题
- en: In the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006)
    recipe in Chapter [6](ch010.xhtml#x1-3300006), and the [Extending a built-in collection
    – a list that does statistics](ch011_split_001.xhtml#x1-4250009) recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007),
    we looked at extending a class. In both cases, the class implemented in the recipe
    was a subclass of one of Python’s built-in classes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [6](ch010.xhtml#x1-3300006) 章的 [使用 cmd 创建命令行应用程序](ch010.xhtml#x1-3610006)
    菜谱和第 [7](ch011_split_000.xhtml#x1-3760007) 章的 [扩展内置集合 – 执行统计的列表](ch011_split_001.xhtml#x1-4250009)
    菜谱中，我们探讨了类的扩展。在这两种情况下，菜谱中实现的类都是 Python 内置类的一个子类。
- en: 'The idea of extension via inheritance is sometimes called the generalization-specialization
    relationship. It can also be called an is-a relationship. There’s an important
    semantic issue:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承进行扩展的想法有时被称为泛化-特殊化关系。它也可以称为“是”关系。有一个重要的语义问题：
- en: Do we mean that instances of the subclass are also instances of the superclass?
    This is an is-a relationship, an example of inheritance, where we extend a class,
    changing the implementation details of features.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的意思是子类的实例也是超类的实例吗？这是一个“是”关系，是继承的一个例子，其中我们扩展了一个类，改变了功能的实现细节。
- en: Or do we mean something else? Perhaps there’s a composition or association,
    sometimes called a has-a relationship. In this case, we may wrap another class,
    adding or removing features.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者我们的意思是不是别的？可能是指组合或关联，有时称为“有”关系。在这种情况下，我们可能包装另一个类，添加或删除功能。
- en: One of the SOLID design principles, the Liskov Substitution Principle, requires
    any subclass to be a proper replacement for the superclass. We’ll look at both
    the inheritance and composition techniques for creating new features for existing
    classes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID设计原则之一，Liskov替换原则要求任何子类都应该是超类的一个适当替代。我们将探讨创建现有类新功能的继承和组合技术。
- en: 8.1.1 Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.1 准备工作
- en: For this recipe, we’ll use models for a deck of playing cards as concrete examples.
    We’ll look at several ways to design a collection.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用扑克牌的模型作为具体的例子。我们将探讨几种设计集合的方法。
- en: 'The core ingredient for both implementations is the underlying Card object.
    We can define this using NamedTuple:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现的核心成分是底层的Card对象。我们可以使用NamedTuple来定义它：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’ll use this Card class in the rest of this recipe. What’s important is the
    various kinds of collection representing a deck or hand; all have considerable
    overlaps in the kinds of features they support.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱的其余部分，我们将使用这个Card类。重要的是表示一副牌或牌手的各种集合类型；它们在支持的功能类型上都有相当大的重叠。
- en: 'We have several common pattern for collections:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几个常见的集合模式：
- en: 'Aggregation: Some objects are bound into collections, but the objects have
    a properly independent existence. While Card objects can be aggregated into a
    Hand collection, when the Hand object is deleted, the Card objects continue to
    exist.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 聚合：某些对象被绑定到集合中，但对象有适当的独立存在。虽然牌对象可以被聚合到牌手集合中，但当牌手对象被删除时，牌对象仍然存在。
- en: 'Composition: Some objects in collections do not have an independent existence.
    A Hand of cards cannot exist without a Player. When a Player instance leaves a
    game, the Hand object must also be removed.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合：集合中的某些对象没有独立的存在。一副牌手不能没有玩家而存在。当一个玩家实例离开游戏时，牌手对象也必须被移除。
- en: 'Inheritance (also called an is-a relationship): This is the idea that a Deck
    is a Hand with some extra features. We can extend a built-in class like list to
    implement this.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承（也称为“是一个”关系）：这是指一副牌是一个具有一些额外功能的牌手。我们可以扩展内置的类如列表来实现这一点。
- en: The distinction between aggregation and composition is very important when designing
    a database, where persistence of objects is the focus. In Python, the distinction
    is a minor nuance. The ordinary Python memory management will preserve the objects
    still referenced by collections or variables. We’ll consider both to be examples
    of composition.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计数据库时，区分聚合和组合非常重要，因为此时关注的是对象的持久性。在Python中，这种区分是一个小的细微差别。普通的Python内存管理会保留由集合或变量仍然引用的对象。我们将两者都视为组合的例子。
- en: 'Once the relationships are understood, there are two distinct paths: [Composition
    or aggregation](ch012.xhtml#x1-4560002) or [Inheritance and extension](ch012.xhtml#x1-4570002).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了关系，就有两条不同的路径：[组合或聚合](ch012.xhtml#x1-4560002)或[继承和扩展](ch012.xhtml#x1-4570002)。
- en: 8.1.2 How to do it...
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.2 如何实现...
- en: 'This recipe has two separate mini-recipes: aggregation and inheritance.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱有两个独立的迷你食谱：聚合和继承。
- en: Composition or aggregation
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组合或聚合
- en: 'Wrapping a collection object inside another class’s instance variables has
    two common variants, sometimes called composition and aggregation. The nuanced
    difference doesn’t matter in Python. Here’s how we design a collection using composition:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个类的实例变量中包装集合对象有两种常见的变体，有时称为组合和聚合。在Python中，这种细微的差别并不重要。以下是使用组合设计集合的方法：
- en: Define the collection class.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义集合类。
- en: To distinguish similar examples in this book, the name has a _W suffix to show
    it is a wrapper. This is not a generally recommended practice; it’s only used
    here to emphasize the distinctions between class definitions in this recipe.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了区分本书中的类似例子，名称带有“_W”后缀以表明它是一个包装器。这不是一个普遍推荐的做法；它只在这里用来强调本食谱中类定义之间的区别。
- en: 'Here’s the definition of the class:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是类的定义：
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Use the __init__() method of this class as one way to provide the underlying
    collection object. This will also initialize any stateful variables. We might
    create an iterator for dealing:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个类的`__init__()`方法作为提供底层集合对象的一种方式。这也会初始化任何有状态的变量。我们可能创建一个用于发牌的迭代器：
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This uses a type hint, list[Card], to show the source collection that will be
    wrapped.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这使用类型提示list[Card]来显示将要包装的源集合。
- en: 'Provide the methods appropriate to the aggregate object. The shuffle() method
    randomizes the internal list object. It also creates an iterator used to step
    through the list by the deal() method. We’ve provided a type hint on deal() to
    clarify that it returns Card instances:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为聚合对象提供适当的方法。shuffle()方法随机化内部列表对象。它还创建了一个迭代器，由deal()方法用来遍历列表。我们在deal()上提供了类型提示，以明确它返回Card实例：
- en: '[PRE3]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here’s how we can use the Deck_W class. We’ll be working with a list of Card
    objects. In this case, the domain variable was created from a list comprehension
    that generated all 52 combinations of 13 ranks and four suits:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用Deck_W类的方法。我们将使用Card对象列表。在这种情况下，domain变量是由生成所有52种13个花色和四种花色的组合的列表推导式创建的：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can use the items in this collection, domain, to create a second aggregate
    object that shares the same underlying Card objects. We’ll build the Deck_W object
    from a list of Card objects:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个集合中的项目，domain，来创建一个共享相同底层Card对象的第二个聚合对象。我们将从Card对象列表构建Deck_W对象：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Inheritance and extension
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承和扩展
- en: 'Here’s an approach to defining a class that extends one of the built-in collections
    of objects:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是定义扩展内置对象集合的类的做法：
- en: 'Start by defining the extension class as a subclass of a built-in collection.
    To distinguish similar examples in this book, the name has an _X suffix. The subclass
    relationship is a formal statement—a Deck_X instance is also a kind of list. Here’s
    the class definition:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先定义扩展类为内置集合的子类。为了区分本书中的类似示例，名称有一个_X后缀。子类关系是一个正式声明——Deck_X实例也是一种列表。以下是类定义：
- en: '[PRE6]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: No additional code is needed to initialize the instance, as we’ll use the __init__()
    method inherited from the list class.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化实例不需要额外的代码，因为我们将从列表类继承__init__()方法。
- en: No additional code is needed to update the deck, as we’ll use other methods
    of the list class for adding, changing, or removing items from the Deck_X instance.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新牌组不需要额外的代码，因为我们将在Deck_X实例中添加、更改或删除项目时使用列表类的其他方法。
- en: 'Provide the appropriate new features to the extended object. The shuffle()
    method randomizes the object as a whole. The collection here is self, because
    this method is an extension of the list class. The deal() object relies on an
    iterator created by the shuffle() method to step through the list, returning Card
    instances:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向扩展对象提供适当的新功能。shuffle()方法随机化整个对象。这里的集合是self，因为此方法是列表类的一个扩展。deal()对象依赖于shuffle()方法创建的迭代器来遍历列表，返回Card实例：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here’s how we can use the Deck_X class. First, we’ll build a deck of cards:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何使用Deck_X类的方法。首先，我们将构建一副牌：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using only the deck-specific features for the Deck_X implementation looks exactly
    like the other implementation, Deck_W:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Deck_X实现中仅使用特定的牌组功能看起来与Deck_W实现完全相同：
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we’ll see below in There’s more..., because Deck_X is a list, it has all
    of the methods of a list object. When designing a framework for others to use,
    this may be a bad idea. When designing an application, it’s easy to avoid using
    the extra features.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在下面的There’s more...中将要看到的，因为Deck_X是列表，它具有列表对象的所有方法。当为他人设计框架时，这可能是一个坏主意。当设计应用程序时，很容易避免使用额外的功能。
- en: 8.1.3 How it works...
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.3 它是如何工作的...
- en: 'Python implements the idea of inheritance via a clever search algorithm for
    finding methods (and attributes) of an object’s class. The search works like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过一个聪明的搜索算法实现继承的概念，用于查找对象类的（方法）和属性。搜索过程如下：
- en: Examine the object’s class for the method or attribute name.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查对象的类以获取方法或属性名称。
- en: If the name is not defined in the immediate class, then search in all of the
    parent classes for the method or attribute. The Method Resolution Order (MRO)
    defines the order in which these classes are searched.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在直接类中未定义名称，则将在所有父类中搜索该方法或属性。方法解析顺序（MRO）定义了搜索这些类的顺序。
- en: 'Searching through the parent classes ensures two things:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过遍历父类确保两件事：
- en: All methods defined in any superclass are available to subclasses.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何超类中定义的所有方法都对子类可用。
- en: Any subclass can override a method to replace the superclass method. The super()
    function searches parent classes for the definition being overridden.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何子类都可以覆盖方法以替换超类方法。super()函数搜索父类以查找被覆盖的定义。
- en: Because of this, a subclass of the list class inherits all the features of the
    parent class. It is a specialized extension of the built-in list class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，列表类的子类继承了父类的所有特性。它是内置列表类的一个特殊扩展。
- en: This also means that all methods have the potential to be overridden by a subclass.
    Some languages have ways to lock a method against extension. Because Python doesn’t
    have this, a subclass can override any method.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着所有方法都有可能被子类覆盖。一些语言有锁定方法以防止扩展的方法。由于 Python 没有这个限制，子类可以覆盖任何方法。
- en: 'The super() function allows a subclass to add features by wrapping the superclass
    version of a method. One way to use it is like this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: super() 函数允许子类通过包装超类方法版本来添加功能。使用它的一个方法如下：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, the some_method() method of a class will do something extra and
    then use the superclass version of the method. This allows us a handy way to extend
    selected methods of a class. We can preserve the superclass features while adding
    features unique to the subclass.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类的 some_method() 方法将执行一些额外操作，然后使用该方法超类版本。这为我们提供了一种方便的方式来扩展类的选定方法。我们可以在添加子类特有的功能的同时保留超类的特性。
- en: 8.1.4 There’s more...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.4 更多内容...
- en: 'There are some huge differences between the two definitions, Deck_W and Deck_X.
    When wrapping, we get precisely the methods we defined and no others. When using
    inheritance, we receive a wealth of method definitions from the superclass. This
    leads to some additional behaviors in the Deck_X class that may not be desirable:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Deck_W 和 Deck_X 这两个定义之间有一些巨大的差异。在包装时，我们得到我们定义的确切方法而没有其他方法。在使用继承时，我们从超类接收大量方法定义。这导致
    Deck_X 类中一些可能不受欢迎的额外行为：
- en: We can use a variety of collections as a source to create Deck_X instances.
    This works because the list class has a number of features for converting Python
    collections to lists. The Deck_W class will only work for sequences offering the
    methods implicitly required by the shuffle() method. Further, the type hint of
    list[Card] will cause programs like mypy to raise errors for the use of other
    source collections.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用各种集合作为创建 Deck_X 实例的来源。这是因为列表类具有将 Python 集合转换为列表的许多特性。Deck_W 类仅适用于提供 shuffle()
    方法隐式所需方法的序列。此外，list[Card] 的类型提示将导致像 mypy 这样的程序在使用其他来源集合时引发错误。
- en: A Deck_X instance can be sliced and indexed outside the core sequential iteration
    supported by the deal() method.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Deck_X 实例可以在 deal() 方法支持的核心理解迭代之外进行切片和索引。
- en: Because the Deck_X class is a list, it also works directly with the iter() function;
    it can be used as an iterable source of Card objects without the deal() method.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 Deck_X 类是列表，它也可以直接与 iter() 函数一起使用；它可以在不使用 deal() 方法的情况下作为 Card 对象的可迭代来源。
- en: These differences are also important parts of deciding which technique to use.
    If the additional features are desirable, that suggests inheritance. If the additional
    features create problems, then composition might be a better choice.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些差异也是决定使用哪种技术的重要部分。如果额外的功能是可取的，那么这表明继承是合适的。如果额外的功能造成问题，那么组合可能是一个更好的选择。
- en: 8.1.5 See also
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1.5 参见
- en: We’ve looked at built-in collections in Chapter [4](ch008_split_000.xhtml#x1-2240004).
    Also, in Chapter [7](ch011_split_000.xhtml#x1-3760007), we looked at how to define
    simple collections.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经在第 [4](ch008_split_000.xhtml#x1-2240004) 章中探讨了内置集合。在第 [7](ch011_split_000.xhtml#x1-3760007)
    章中，我们也探讨了如何定义简单的集合。
- en: In the [Designing classes with lots of processing](ch011_split_000.xhtml#x1-3890003)
    recipe, we looked at wrapping a class with a separate class that handles the processing
    details. We can contrast this with the [Using properties for lazy attributes](ch011_split_001.xhtml#x1-43100010)
    recipe of Chapter [7](ch011_split_000.xhtml#x1-3760007), where we put the complicated
    computations into the class as properties; this design relies on extension.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [设计具有大量处理的类](ch011_split_000.xhtml#x1-3890003) 的配方中，我们探讨了使用一个处理处理细节的单独类来包装一个类。我们可以将其与第
    [7](ch011_split_000.xhtml#x1-3760007) 章的 [使用属性进行懒加载属性](ch011_split_001.xhtml#x1-43100010)
    配方进行对比，在那里我们将复杂的计算作为属性放入类中；这种设计依赖于扩展。
- en: 8.2 Separating concerns via multiple inheritance
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.2 通过多重继承分离关注点
- en: 'In the [Choosing between inheritance and composition – the ”is-a” question](ch012.xhtml#x1-4530001)
    recipe earlier in the chapter, we looked at the idea of defining a Deck class
    that was a composition of playing card objects. For the purposes of that example,
    we treated each Card object as simply having rank and suit attributes. This created
    two small problems:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的 [在继承和组合之间选择 – “是”问题](ch012.xhtml#x1-4530001) 配方中，我们探讨了定义一个 Deck 类的想法，该类是玩牌对象的组合。为了这个示例的目的，我们将每个
    Card 对象视为仅具有等级和花色属性。这造成了两个小问题：
- en: The display for the card always showed a numeric rank. We didn’t see J, Q, or
    K. Instead we saw 11, 12, and 13\. Similarly, an ace was shown as 1 instead of
    A.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卡片的显示总是显示数字等级。我们没有看到 J、Q 或 K。相反，我们看到 11、12 和 13。同样，A 牌显示为 1 而不是 A。
- en: Many games like Cribbage assign a point value to each rank. Generally, the face
    cards have 10 points. The remaining cards have points that match their rank.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多游戏，如克里比奇，为每个等级分配点值。通常，面牌有 10 点。剩余的牌的点数与它们的等级相匹配。
- en: Python’s multiple inheritance lets us handle variations in card game rules while
    keeping a single, essential Card class. Using multiple inheritance lets us separate
    rules for specific games from generic properties of playing cards. We can combine
    a base class definition with a mixin class that provides needed features.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的多重继承让我们在保持单个基本 Card 类的同时处理卡牌游戏规则的变化。使用多重继承让我们将特定游戏的规则与通用牌的特性分开。我们可以将基类定义与提供所需功能的混合类组合起来。
- en: Python multiple inheritance relies on a clever algorithm called C3 to resolve
    various parent classes into a single list, in a useful order. When we combine
    multiple classes, they will have common parent classes, which now have multiple
    references. The C3 algorithm creates a linear list that respects all of the parent-child
    relationships.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的多重继承依赖于一个称为 C3 的巧妙算法，用于将各种父类解析为单个列表，以有用的顺序。当我们组合多个类时，它们将具有共同的父类，现在有多个引用。C3
    算法创建了一个尊重所有父子关系的线性列表。
- en: 8.2.1 Getting ready
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.1 准备工作
- en: 'A practical extension to the Card class needs to be a mixture of two feature
    sets. Python lets us define a class that includes features from multiple parents.
    The are two parts to this pattern:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Card 类的实际扩展需要是两个特性集的混合。Python 允许我们定义一个包含多个父类特性的类。这个模式有两个部分：
- en: 'Essential features: This are the rank and suit. This also includes a method
    to show the Card object’s value nicely as a string using “J”, “Q”, and “K” for
    court cards, and “A” for aces.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心特性：这是等级和花色。这还包括一个方法，以字符串形式优雅地显示 Card 对象的值，使用“J”、“Q”和“K”表示宫廷牌，以及“A”表示 A 牌。
- en: 'Mixin features: These are all of the less essential, game-specific features,
    such as the number of points allotted to each particular card.'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 混合特性：这些都是不那么重要的、特定于游戏的特性，例如分配给每张特定牌的点数。
- en: The working application relies on a combination of features built from the essentials
    and the mixins.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 工作应用程序依赖于从基本特性和混合特性构建的特性组合。
- en: 8.2.2 How to do it...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.2 如何操作...
- en: 'This recipe will create two hierarchies of classes, one for the essential Card
    and one for game-specific features including Cribbage point values:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将创建两个类层次结构，一个用于基本的 Card 类，另一个用于特定游戏的特性，包括克里比奇点值：
- en: 'Define the essential class. This is a generic Card class, suitable for ranks
    2 to 10:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义基本类。这是一个通用的 Card 类，适用于 2 到 10 的等级：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Define the subclasses to implement specializations. We need two subclasses
    of the Card class—the AceCard class and the FaceCard class, as defined in the
    following code:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义子类以实现特殊化。我们需要 Card 类的两个子类——AceCard 类和 FaceCard 类，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of this overrides the built-in __str__() method to provide distinct behaviors.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个类都覆盖了内置的 `__str__()` 方法以提供不同的行为。
- en: 'Define the core features required by the mixin classes. Use the typing.Protocol
    superclass to be sure the various implementations all provide the required features.
    The rank attribute is required by the protocol, and will be defined in the essential
    class. A points() method will be defined in the mixin classes. Here’s how it looks:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义混合类所需的核心特性。使用 `typing.Protocol` 超类以确保各种实现都提供了所需的功能。协议需要 `rank` 属性，它将在基本类中定义。混合类中将定义一个
    `points()` 方法。以下是它的样子：
- en: '[PRE13]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When writing type hint classes, the body can be ... because this will be ignored
    by tools like mypy.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当编写类型提示类时，主体可以是 ... 因为这将由像 mypy 这样的工具忽略。
- en: 'Define a mixin subclasses for additional features that will be added. For the
    game of Cribbage, the points for some cards are equal to the rank of the card,
    and face cards are 10 points:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义混合子类以添加额外的功能。对于 Cribbage 游戏，某些牌的点数等于牌的等级，面牌是 10 点：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create the final concrete class definitions to combine an essential base class
    and all of the required mixin classes:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建最终的实体类定义以组合基本类和所有所需的混合类：
- en: '[PRE16]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the CribbagePoints mixin is used for both Card and AceCard classes,
    allowing us to reuse code.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，CribbagePoints 混合类被用于 Card 和 AceCard 类，这使得我们可以重用代码。
- en: 'Define a function (or class) to create the appropriate objects based on the
    input parameters. This is often called a factory function or factory class. The
    objects being created will all be considered as subclasses of the Card class because
    it’s first in the list of base classes:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数（或类）根据输入参数创建适当的对象。这通常被称为工厂函数或工厂类。被创建的对象都将被视为 Card 类的子类，因为它是基类列表中的第一个：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can use the make_cribbage_card() function to create a shuffled deck of cards,
    as shown in this example interactive session:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 make_cribbage_card() 函数创建一副洗好的牌，如下面的示例交互会话所示：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can evaluate the points() method of each Card object:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以评估每个 Card 对象的 points() 方法：
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The hand has two face cards, plus 3, 6, and ace, so the total points are 30\.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 手中有两张面牌，加上 3、6 和 A，所以总分数是 30。
- en: 8.2.3 How it works...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.3 它是如何工作的...
- en: 'Python’s mechanism for finding a method (or attribute) of an object works like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Python 查找对象方法（或属性）的机制如下：
- en: Search the instance for the attribute.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实例中搜索该属性。
- en: Search in the class for the method or attribute.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中搜索该方法或属性。
- en: If the name is not defined in the immediate class, then search all of the parent
    classes for the method or attribute. The parent classes are searched in a sequence
    called, appropriately, the Method Resolution Order (MRO).
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在直接类中未定义名称，则会在所有父类中搜索该方法或属性。父类是按照称为方法解析顺序（Method Resolution Order，MRO）的顺序搜索的。
- en: 'We can display the MRO using the mro() method of a class. Here’s an example:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类的 mro() 方法显示 MRO。以下是一个示例：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The mro() method of the CribbageCard class shows us the order that’s used to
    resolve names. Because the class object uses an internal dict to store method
    definitions, the search is an extremely fast hash-based lookup of the attribute
    name.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: CribbageCard 类的 mro() 方法显示了用于解析名称的顺序。因为类对象使用内部字典来存储方法定义，所以搜索是极快的基于哈希的属性名称查找。
- en: 8.2.4 There’s more...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.4 更多...
- en: 'There are several kinds of design concerns we can separate in the form of mixins:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将几种设计关注点以混合类的形式分离出来：
- en: 'Persistence and representation of state: A mixin class could add methods to
    manage conversion to a consistent external representation like CSV or JSON notation.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久性和状态表示：一个混合类可以添加方法来管理转换为一致的 CSV 或 JSON 表示法等外部表示。
- en: 'Security: A mixin class could add methods performs a consistent authorization
    check that applies to a number of base classes.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性：一个混合类可以添加执行一致授权检查的方法，这些检查适用于多个基类。
- en: 'Logging: A mixin class could introduce a logger with a definition consistent
    across a variety of classes.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志记录：一个混合类可以引入一个具有跨各种类定义一致的 logger。
- en: 'Event signaling and change notification: A mixin might report object state
    changes so one or more GUI widgets can refresh the display.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件信号和变更通知：一个混合类可能会报告对象状态的变化，以便一个或多个 GUI 小部件可以刷新显示。
- en: As an example, we’ll create a mixin to introduce logging to cards. We’ll define
    this class in a way that must be provided first in the list of superclasses. Since
    it’s early in the MRO list, it uses the super() function to use methods defined
    by subsequent classes in the MRO list.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将创建一个混合类来向牌引入日志记录。我们将以必须首先在超类列表中提供的方式定义此类。由于它在 MRO 列表中较早，因此它使用 super()
    函数来使用 MRO 列表中后续类定义的方法。
- en: 'This class will add the logger attribute to each object that has the PointedCard
    protocol defined:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将为具有 PointedCard 协议定义的每个对象添加 logger 属性：
- en: '[PRE21]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that we’ve used super().__init__() to perform the __init__() method of
    any other classes defined. The order for these initializations comes from the
    class MRO. The simplest approach to have one class that defines the essential
    features of an object, and all other mixins add features in the form of additional
    methods to the essential object.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了super().__init__()来执行任何其他类定义的__init__()方法。这些初始化的顺序来自类MRO。最简单的方法是有一个定义对象基本特征的类，而所有其他混入则通过向基本对象添加额外方法的形式添加功能。
- en: We’ve provided an overriding definition for points(). This will search other
    classes in the MRO list for an implementation of the points() method. Then it
    will log the results computed by the method from another mixin class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为points()提供了覆盖定义。这将搜索MRO列表中的其他类以查找points()方法的实现。然后它将记录由另一个混入类中的方法计算的结果。
- en: 'The # type: ignore [safe-super] comment is a note to tools like mypy that do
    strict type-checking. When we look at the definitions of the PointedCard protocol,
    there’s no definition for this method. From the tool’s examination of the class
    hierarchy, it’s possible that calling super().points() is unsafe. We’re sure this
    won’t happen in practice, because a mixin will always be present to define the
    points() method. We’ve flagged the unsafe use of super() as an error to be ignored.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '# type: ignore [safe-super]注释是给像mypy这样的严格类型检查工具的提示。当我们查看PointedCard协议的定义时，没有为这个方法提供定义。从工具对类层次结构的检查来看，调用super().points()可能是不安全的。我们确信在实际情况中不会发生这种情况，因为混入将始终存在以定义points()方法。我们将super()的不安全使用标记为要忽略的错误。'
- en: 'Here are some classes that include the Logged mixin features:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些包含Logged混入功能的类：
- en: '[PRE22]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Each of these classes are built from three separate class definitions. Since
    the Logged class is provided first, we’re assured that all classes have consistent
    logging. We’re also assured that any method in Logged can use super() to locate
    an implementation in the class list that follows it in the sequence of classes
    in the definition.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类都是基于三个独立的类定义构建的。由于Logged类首先提供，我们确保所有类都有一致的日志记录。我们还确保Logged中的任何方法都可以使用super()来定位在类定义中跟随其后的类列表中的实现。
- en: To make use of these classes, we’d need to define a make_logged_card() function
    to use these new classes.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些类，我们需要定义一个make_logged_card()函数来使用这些新类。
- en: 8.2.5 See also
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2.5 参见
- en: The method resolution order is computed when the class is created. The algorithm
    used is called C3\. The process was originally developed for the Dylan language
    and is now also used by Python. The C3 algorithm ensures that each parent class
    is searched exactly once. It also ensures the relative ordering of superclasses
    is preserved; subclasses will be searched before any of their parent classes are
    examined. More information is available at [https://dl.acm.org/doi/10.1145/236337.236343](https://dl.acm.org/doi/10.1145/236337.236343).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当类创建时计算方法解析顺序。使用的算法称为C3。这个过程最初是为Dylan语言开发的，现在也被Python使用。C3算法确保每个父类只被搜索一次。它还确保了超类之间的相对顺序被保留；子类将在检查任何父类之前被搜索。更多信息请参阅[https://dl.acm.org/doi/10.1145/236337.236343](https://dl.acm.org/doi/10.1145/236337.236343)。
- en: When considering multiple inheritance, it’s always essential to also consider
    whether or not a wrapper is a better design than a subclass. See the [Choosing
    between inheritance and composition – the ”is-a” question](ch012.xhtml#x1-4530001)
    recipe.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在考虑多重继承时，始终需要考虑是否将包装器作为比子类更好的设计。参见[在继承和组合之间选择 – “是”问题](ch012.xhtml#x1-4530001)配方。
- en: 8.3 Leveraging Python’s duck typing
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.3 利用Python的鸭子类型
- en: When a design involves inheritance, there is often a clear relationship from
    a superclass to one or more subclasses. In the [Choosing between inheritance and
    composition – the ”is-a” question](ch012.xhtml#x1-4530001) recipe of this chapter,
    as well as the [Extending a built-in collection – a list that does statistics](ch011_split_001.xhtml#x1-4250009)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007), we’ve looked at extensions
    that involve a proper subclass-superclass relationship.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计涉及继承时，通常从超类到一个或多个子类之间存在明确的关系。在本章的[在继承和组合之间选择 – “是”问题](ch012.xhtml#x1-4530001)配方以及第[7](ch011_split_000.xhtml#x1-3760007)章中的[扩展内置集合
    – 做统计的列表](ch011_split_001.xhtml#x1-4250009)配方中，我们查看涉及适当的子类-超类关系的扩展。
- en: In order to have classes that can be used in place of one another (”polymorphic”
    classes), some languages require a common superclass. In many cases, the common
    class doesn’t have concrete implementations for all of the methods; it’s called
    an abstract superclass.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有可以相互替换使用的类（“多态类”），某些语言要求有一个共同的超类。在许多情况下，共同类并没有对所有方法进行具体实现；它被称为抽象超类。
- en: Python doesn’t require common superclasses. The standard library offers the
    abc module to support creating abstract classes in cases where it can help to
    clarify the relationships among classes.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Python不需要共同的超类。标准库提供了abc模块，以支持在有助于阐明类之间关系的情况下创建抽象类。
- en: 'Instead of defining polymorphic classes with common superclasses, Python relies
    on duck typing to establish equivalence. This name comes from the quote:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用具有共同超类的多态类相比，Python依赖于鸭子类型来建立等价性。这个名字来源于以下引言：
- en: When I see a bird that walks like a duck and swims like a duck and quacks like
    a duck, I call that bird a duck.
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我看到一只既像鸭子走路又像鸭子游泳还像鸭子嘎嘎叫的鸟时，我就称那只鸟为鸭子。
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (James Whitcomb Riley)
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （詹姆斯·惠特科姆·赖利）
- en: In the case of Python class relationships, if two objects have the same methods
    and the same attributes, these similarities have the same effect as having a common
    superclass. No formal definition of a common class is required.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python类关系的情况下，如果两个对象具有相同的方法和属性，这些相似之处与具有共同超类具有相同的效果。不需要对共同类进行正式的定义。
- en: This recipe will show how to exploit the concept of duck typing to create polymorphic
    classes. Instances of these classes can be used in place of each other, giving
    us more flexible designs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何利用鸭子类型的概念来创建多态类。这些类的实例可以相互替换，使我们能够拥有更灵活的设计。
- en: 8.3.1 Getting ready
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.1 准备工作
- en: 'In some cases, it can be awkward to define a superclass for a number of loosely
    related implementation choices. For example, if an application is spread across
    several modules, it might be challenging to factor out a common superclass and
    put this by itself in a separate module where it can be imported into other modules.
    Instead of factoring out a common abstraction, it’s sometimes easier to create
    classes that will pass the ”duck test”: the various classes have the same methods
    and attributes; therefore, they are effectively interchangeable, polymorphic classes.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，为多个松散相关的实现选择定义一个超类可能会有些尴尬。例如，如果一个应用程序分布在几个模块中，可能很难提取一个共同的超类并将其单独放在一个模块中，以便在其他模块中导入。与其提取一个共同的抽象，有时创建将通过“鸭子测试”的类更容易：各种类具有相同的方法和属性；因此，它们实际上是可互换的，是多态类。
- en: 8.3.2 How to do it...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.2 如何实现...
- en: 'We’ll define a pair of classes to show how this works. These classes will both
    simulate rolling a pair of dice. We’ll create two distinct implementations that
    have enough common features that they are interchangeable:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一对类来展示这是如何工作的。这两个类都将模拟掷两个骰子的过程。我们将创建两个具有足够共同特征的独立实现，这样它们就可以互换使用：
- en: 'Start with a class, Dice1, with the required methods and attributes. In this
    example, we’ll have one attribute, dice, that retains the result of the last roll,
    and one method, roll(), that changes the state of the dice:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从一个具有所需方法和属性的类开始，Dice1。在这个例子中，我们将有一个属性，dice，它保留上一次掷骰子的结果，以及一个方法，roll()，它改变骰子的状态：
- en: '[PRE23]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Define another class, Dice2, with the same methods and attributes. Here’s a
    somewhat more complex definition that creates a class that has the same signature
    as the Dice1 class:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义另一个类，Dice2，具有相同的方法和属性。这里是一个稍微复杂一些的定义，它创建了一个与Dice1类具有相同签名的类：
- en: '[PRE24]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At this point, the two classes, Dice1 and Dice2, can be interchanged freely.
    Here’s a function that accepts either class as an argument, creates an instance,
    and yields several rolls of the dice:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，两个类，Dice1和Dice2，可以自由互换。这里是一个接受任一类作为参数的函数，创建一个实例，并产生几个掷骰子的结果：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can use this function providing either the Dice1 class or Dice2 class for
    the dice argument value. The type[Dice1 | Dice2] type hint specifies a union of
    multiple equivalent classes. This function creates an instance of the given class
    in the dice parameter, and can even provide the seed value. Using a known seed
    creates reproducible results, often required for unit testing, and also used for
    reproducing statistical studies that involve randomized selection.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Dice1类或Dice2类作为dice参数值的函数。type[Dice1 | Dice2]类型提示指定了多个等效类的联合。此函数在dice参数中创建给定类的实例，甚至可以提供种子值。使用已知的种子可以创建可重复的结果，这对于单元测试通常是必需的，也用于重现涉及随机选择的统计研究。
- en: 'The following interactive session shows the roller() function being applied
    to both classes:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下交互会话显示了roller()函数被应用于两个类：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The objects built from Dice1 and Dice2 have enough similarities that they’re
    indistinguishable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由Dice1和Dice2构建的对象有足够的相似性，以至于它们无法区分。
- en: 8.3.3 How it works...
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.3 它是如何工作的...
- en: We’ve created two classes with identical collections of attributes and methods.
    This is the essence of duck typing. Because of the way Python searches through
    a sequence of dictionaries for matching names, classes do not need to have a common
    superclass to be interchangeable.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个具有相同属性和方法集合的类。这是鸭子类型的核心。由于Python通过遍历字典序列来搜索匹配的名称，因此类不需要有共同的超类就可以互换。
- en: It can be helpful to define a union of related classes. An alternative is to
    define a common Protocol that the classes adhere to. It’s not necessary for each
    class to explicitly inherit from the Protocol definition, but it can make it more
    clear to your readers to do this. Tools like mypy can discern whether or not a
    class fits a Protocol, which is how duck typing works.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 定义相关类的联合可能会有所帮助。另一个选择是定义一个类都遵守的通用协议。对于每个类来说，虽然不是必须显式地从协议定义中继承，但这样做可以使读者更清晰地理解。像mypy这样的工具可以判断一个类是否符合协议，这正是鸭子类型的工作方式。
- en: 8.3.4 There’s more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.4 更多内容...
- en: 'In the definition of the roller() function, we used the following type hint:
    dice: type[Dice1 | Dice2].'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '在roller()函数的定义中，我们使用了以下类型提示：dice: type[Dice1 | Dice2]。'
- en: 'It’s often helpful to make this explicit with code like this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如下代码可以使这种做法更明确：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This can be easily extended as new alternative definitions are added. Client
    classes can then use type[Dice] to refer to the union of alternatives.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以很容易地扩展，因为当添加新的替代定义时。客户端类可以使用type[Dice]来引用替代方案的联合。
- en: 'An alternative is to define a protocol. A protocol defines a generic type with
    only the common features the various implementations will share:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是定义一个协议。协议定义了一个具有仅共享各种实现共同特征的通用类型：
- en: '[PRE28]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: It helps to create type hints later in the development process. After creating
    alternative implementations, it’s easy to define a type that’s a union of the
    various choices. If more implementations arise, they can be added to the union.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于在开发过程的后期创建类型提示。在创建替代实现之后，很容易定义一个联合各种选择的类型。如果出现更多实现，它们可以被添加到联合中。
- en: A protocol permits easier expansion of the alternatives. The protocol defines
    only the relevant features of the implementations. This is often done by refactoring
    the signatures of client methods and attributes to refer to the protocol class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 协议允许更容易地扩展替代方案。协议仅定义了实现的有关特征。这通常是通过重构客户端方法签名的属性来完成的，使其引用协议类。
- en: 8.3.5 See also
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3.5 参见
- en: The duck type question is implicit in the [Choosing between inheritance and
    composition – the ”is-a” question](ch012.xhtml#x1-4530001) recipe; if we leverage
    duck typing, we’re also making a claim that two classes are not the same thing.
    When we bypass inheritance, we are implicitly claiming that the is-a relationship
    doesn’t hold.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鸭子类型问题在[在继承和组合之间选择 – “是”问题](ch012.xhtml#x1-4530001)配方中是隐含的；如果我们利用鸭子类型，我们也在声称两个类不是同一件事。当我们绕过继承时，我们隐含地声称is-a关系不成立。
- en: When looking at the [Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)
    recipe, we’re also able to leverage duck typing to create composite classes that
    may not have a simple inheritance hierarchy.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当查看[通过多重继承分离关注点](ch012.xhtml#x1-4610002)配方时，我们也能够利用鸭子类型来创建可能没有简单继承层次结构的复合类。
- en: 8.4 Managing global and singleton objects
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.4 管理全局和单例对象
- en: The Python environment contains a number of implicit global objects. These objects
    provide a convenient way to work with a collection of other objects. Because the
    collection is implicit, we’re saved from the annoyance of explicit initialization
    code.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Python 环境包含许多隐式全局对象。这些对象提供了一种方便的方式来处理其他对象的集合。因为集合是隐式的，所以我们避免了显式初始化代码的烦恼。
- en: One example of this is an implicit random number generating object in the random
    module. When we evaluate random.random(), we’re actually making use of an instance
    of the random.Random class.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这的一个例子是 random 模块中的隐式随机数生成对象。当我们评估 random.random() 时，我们实际上是在使用 random.Random
    类的一个实例。
- en: Because a module is only imported once, a module implements the Singleton design
    pattern. We can rely on this technique to implement these global singletons.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因为一个模块只导入一次，所以模块实现了 Singleton 设计模式。我们可以依赖这项技术来实现这些全局单例。
- en: 'Other examples of this include the following:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 其他例子包括以下内容：
- en: The collection of data encoders and decoders (codecs) available. The codecs
    module has a registry for encoders and decoders. We can add encodings and decodings
    to this registry.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用的数据编码器和解码器（编解码器）集合。编解码器模块有一个编码器和解码器的注册表。我们可以向这个注册表中添加编码和解码。
- en: The webbrowser module has a registry of known browsers.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webbrowser 模块有一个已知浏览器的注册表。
- en: The numbers module has a registry of numeric data types. This allows a module
    to define a new implementation of a numeric type and add it to the mix of known
    types.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: numbers 模块有一个数字数据类型的注册表。这允许模块定义一个新的数字类型实现并将其添加到已知类型的混合中。
- en: The logging module maintains a collection of named loggers. The getLogger()
    function tries to find an existing logger; it creates a new logger if needed.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: logging 模块维护一个命名记录器的集合。getLogger() 函数试图找到一个现有的记录器；如果需要，它会创建一个新的记录器。
- en: The re module has a cache of compiled regular expressions. This saves the time
    to recompile a regular expression that’s defined inside a method or function.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: re 模块有一个编译正则表达式的缓存。这节省了重新编译在方法或函数内部定义的正则表达式的时间。
- en: This recipe will show how to work with an implicit global object like the registries
    used for codecs, browsers, and number classes.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将展示如何处理像用于编解码器、浏览器和数字类的注册表这样的隐式全局对象。
- en: 8.4.1 Getting ready
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.1 准备工作
- en: A collection of functions can all work with an implicit global object, created
    by a module. The benefit is to allow other modules to share a common object without
    having to write any code that explicitly coordinates sharing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一组函数都可以与由模块创建的隐式全局对象一起工作。好处是允许其他模块共享一个公共对象，而无需编写任何显式协调共享的代码。
- en: This is potentially confusing to people reading your code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让阅读你代码的人感到困惑。
- en: The idea of shared global state can become a design nightmare. The further step
    of making a shared object implicit may compound the problem.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 共享全局状态的想法可能会变成一个设计噩梦。进一步使共享对象变得隐式可能会使问题更加复杂。
- en: Looking at the examples from the Python standard library, there are two important
    patterns. First, there’s a narrow focus. Second, the updates to the registry are
    limited to adding new instances.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 观察 Python 标准库中的示例，有两个重要的模式。首先，有一个狭窄的焦点。其次，注册表的更新仅限于添加新实例。
- en: As an example, we’ll define a module with a global singleton object. We’ll look
    more at modules in Chapter [13](ch017.xhtml#x1-71500013).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们将定义一个包含全局单例对象的模块。我们将在第 13 章中更详细地讨论模块。
- en: Our global object will be a counter that we can use to accumulate centralized
    data from several independent modules or objects. We’ll use this global to count
    events in the application. The counts provide a summary of the work completed,
    and a check to confirm that all the work was completed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的全球对象将是一个计数器，我们可以用它来累积来自几个独立模块或对象的集中化数据。我们将使用这个全局对象来计数应用程序中的事件。计数提供了已完成工作的摘要，并检查以确认所有工作都已完成。
- en: 'The goal is to be able to write something like this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够编写如下内容：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The some_processing() function might use something like count(’reject’) to count
    rejected input rows. This function may call other functions that also use the
    count() function to record evidence of the processing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: some_processing() 函数可能会使用类似 count('reject') 来计算被拒绝的输入行数。这个函数可能会调用其他也使用 count()
    函数来记录处理证据的函数。
- en: 'These two independent functions both refer to a shared global counter:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个独立函数都引用了一个共享的全局计数器：
- en: count(key) increments a global Counter and returns the current value for the
    given key.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: count(key) 增加一个全局 Counter，并返回给定键的当前值。
- en: counts() provides all of the Counter values.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counts()` 提供所有的计数器值。'
- en: 8.4.2 How to do it...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.2 如何实现...
- en: 'There are two common ways to handle global state information:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 处理全局状态信息有两种常见的方式：
- en: Use a module global variable because modules are singleton objects.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块全局变量，因为模块是单例对象。
- en: Use a class-level variable (called static in some programming languages). In
    Python, a class definition is also a singleton object that can be shared.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类级别的变量（在某些编程语言中称为静态）。在 Python 中，类定义也是一个可以共享的单例对象。
- en: We’ll cover these as separate mini-recipes, starting with module globals.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将单独介绍这些小技巧，从模块全局变量开始。
- en: Module global variables
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模块全局变量
- en: 'We can do the following to create a variable that is global to a module:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做来创建一个对模块全局的变量：
- en: Create a module file. This will be a .py file with the definitions in it. We’ll
    call it counter.py.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模块文件。这将是一个包含定义的 .py 文件。我们将它命名为 counter.py。
- en: 'If necessary, define a class for the global singleton. In our case, we can
    use this definition to create a collections.Counter object:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，定义一个全局单例类的类。在我们的例子中，我们可以使用这个定义来创建一个 `collections.Counter` 对象：
- en: '[PRE30]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the one and only instance of the global singleton object. We’ve used
    a leading _ in the name to make it slightly less visible. It’s not — technically
    — private. It is, however, gracefully ignored by many Python tools and utilities:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义全局单例对象的唯一实例。我们在名称前使用了前导下划线使其稍微不那么显眼。它——技术上——不是私有的。然而，它被许多 Python 工具和实用程序优雅地忽略：
- en: '[PRE31]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A common idiom for marking global variables is to use an ALL_CAPS name. This
    seems more important for global variables that are to be considered as constants.
    In this case, this variable will be updated, and an ALL_CAPS name seems misleading.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标记全局变量的常见习惯是使用全大写的名称。这似乎对被视为常量的全局变量更重要。在这种情况下，这个变量将被更新，使用全大写名称似乎有些误导。
- en: 'Define the two functions to use the global object, _global_counter. These functions
    encapsulate the detail of how the counter is implemented:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义两个函数以使用全局对象 `_global_counter`。这些函数封装了计数器实现的细节：
- en: '[PRE32]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now we can write applications that use the count() function in a variety of
    places. The counted events, however, are fully centralized in a single object,
    defined as part of the module.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写在多个地方使用 `count()` 函数的应用程序。然而，计数的事件完全集中在一个对象中，该对象作为模块的一部分定义。
- en: 'We might have code that looks like this:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有这样的代码：
- en: '[PRE33]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We’ve imported the count() and counts() functions from the counter module. We’ve
    also imported the Dice1 class as a handy object that creates a sequence of events.
    When we create an instance of Dice1, we provide an initialization to force a particular
    random seed. This gives repeatable results.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从 `counter` 模块中导入了 `count()` 和 `counts()` 函数。我们还导入了 `Dice1` 类作为一个方便的对象，用于创建事件序列。当我们创建
    `Dice1` 的实例时，我们提供一个初始化来强制特定的随机种子。这给出了可重复的结果。
- en: The benefit of this technique is that several modules can all share the global
    object within the counter module. All that’s required is an import statement.
    No further coordination or overheads are necessary.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的优点是，多个模块都可以在 `counter` 模块中共享全局对象。所需的一切只是一个导入语句。不需要进一步的协调或开销。
- en: Class-level ”static” variables
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类级别的“静态”变量
- en: 'We can do the following to create a variable that is global to all instances
    of a class definition:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样做来创建一个对类定义的所有实例全局的变量：
- en: 'Define a class with a variable outside the __init__() method. This variable
    is part of the class, not part of an instance. To make it clear that the attribute
    is shared by all instances of the class, the ClassVar type hint is helpful. In
    this example, we’ve decided to use a leading _ so the class-level variable is
    not seen as part of the public interface:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `__init__()` 方法之外定义一个类的变量。这个变量是类的一部分，而不是实例的一部分。为了清楚地表明这个属性是由类的所有实例共享的，`ClassVar`
    类型提示很有帮助。在这个例子中，我们决定使用前导下划线，这样类级别的变量就不会被视为公共接口的一部分：
- en: '[PRE34]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add methods to update and extract data from the class-level _class_counter
    attribute. These will use the @classmethod decorators to show they are used directly
    by the class, not by an instance. The self variable is not used; instead, a cls
    variable is used as a reminder that the method applies to the class:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加更新和从类级别的 `_class_counter` 属性中提取数据的方法。这些方法将使用 `@classmethod` 装饰器来表明它们是直接由类使用的，而不是由实例使用的。不使用
    `self` 变量；相反，使用 `cls` 变量作为方法适用于类的提醒：
- en: '[PRE35]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s very important to note that the _class_counter attribute is part of the
    class, and is referred to as cls._class_counter. We don’t use a self instance
    variable because we aren’t referring to an instance of the class; we’re referring
    to a variable that’s part of the overall class definition, provided as the first
    parameter to a method decorated with @classmethod.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要注意，_class_counter 属性是类的一部分，被称为 cls._class_counter。我们不使用 self 实例变量，因为我们不是指代类的实例；我们是指代类定义中的一部分变量，作为装饰有
    @classmethod 的方法的第一个参数提供。
- en: Here’s how we can use this class.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们可以使用这个类的方法。
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Since all these operations update the EventCounter class, each increments the
    shared variable.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有这些操作都更新 EventCounter 类，每个都会增加共享变量。
- en: Shared global state must be used carefully.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的全局状态必须谨慎使用。
- en: They may be tangential to the real work of the class. The focus must be narrow
    and limited to very state changes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可能与类的实际工作无关。焦点必须狭窄且限于非常有限的状态变化。
- en: When in doubt, explicitly shared objects will be a better design strategy, but
    will involve a bit more code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当有疑问时，显式共享对象将是一个更好的设计策略，但将涉及更多的代码。
- en: 8.4.3 How it works...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.3 它是如何工作的...
- en: 'The Python import mechanism uses sys.modules to track which modules are loaded.
    Once a module is in this mapping, it is not loaded again. This means that any
    variable defined within a module will be a singleton: there will only be one instance.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Python 导入机制使用 sys.modules 来跟踪哪些模块被加载。一旦模块在这个映射中，它就不会再次被加载。这意味着模块内定义的任何变量都将是一个单例：只有一个实例。
- en: Within a module, a class definition can only be created once. This means the
    internal state changes of a class also follow the Singleton design pattern.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个模块中，只能创建一次类定义。这意味着类的内部状态变化也遵循单例设计模式。
- en: How can we choose between these two mechanisms? The choice is based on the degree
    of confusion created by having multiple classes sharing a global state. As shown
    in the previous example in [Class-level ”static” variables](ch012.xhtml#x1-4770002),
    we could have multiple variables sharing a common Counter object. If the presence
    of an implicitly shared global state seems confusing, then a module-level global
    is a better choice. In the cases where a module-level global is confusing, share
    state explicitly with ordinary visible variables.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何在这两种机制之间进行选择？选择基于由多个类共享全局状态所造成的混淆程度。正如在[类级别的“静态”变量](ch012.xhtml#x1-4770002)中的前一个示例所示，我们可以有多个变量共享一个共同的
    Counter 对象。如果隐式共享的全局状态看起来很令人困惑，那么模块级全局变量是一个更好的选择。在模块级全局变量令人困惑的情况下，应通过普通可见变量显式共享状态。
- en: 8.4.4 There’s more...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.4 更多内容...
- en: A shared global state can be called the opposite of object-oriented programming.
    One ideal of object-oriented programming is to encapsulate state changes in individual
    objects. Used too broadly, global variables break the idea of encapsulation of
    state within a single object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 共享的全局状态可以被称为面向对象编程的反面。面向对象编程的一个理想是封装单个对象中的状态变化。如果过于广泛地使用，全局变量会破坏封装单个对象状态的想法。
- en: In a sense, a module is a kind of class-like structure. A module is a namespace
    with module-level variables to define state and module functions that are like
    methods.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，一个模块是一种类似于类的结构。模块是一个命名空间，具有模块级变量来定义状态和类似于方法的模块函数。
- en: One example of a need for a common global state often arises when trying to
    define configuration parameters for an application. It can help to have a single,
    uniform configuration that’s shared widely throughout multiple modules. When these
    objects are used for pervasive features such as configuration, audits, logging,
    and security, globals can be helpful for segregating a single, focused cross-cutting
    concern into a generic class separate from application-specific classes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 需要公共全局状态的一个例子通常出现在尝试为应用程序定义配置参数时。拥有一个单一、统一的配置，并在多个模块中广泛共享，可能会有所帮助。当这些对象用于普遍的功能，如配置、审计、日志记录和安全时，全局变量可以帮助将单个、专注的横切关注点隔离到一个通用的类中，该类与应用程序特定的类分开。
- en: An alternative is to create a configuration object explicitly. This configuration
    object can then be provided as a parameter to other objects throughout an application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选择是显式创建一个配置对象。然后，可以将此配置对象作为参数提供给应用程序中的其他对象。
- en: 8.4.5 See also
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4.5 参见
- en: Chapter [14](ch018.xhtml#x1-75800014) covers additional topics in module and
    application design.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第 [14](ch018.xhtml#x1-75800014) 章介绍了模块和应用设计中的其他主题。
- en: 8.5 Using more complex structures – maps of lists
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.5 使用更复杂的结构 – 列表映射
- en: In Chapter [4](ch008_split_000.xhtml#x1-2240004), we looked at the basic data
    structures available in Python. Those recipes generally looked at the various
    structures in isolation.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [4](ch008_split_000.xhtml#x1-2240004) 章中，我们探讨了 Python 中可用的基本数据结构。那些菜谱通常单独查看各种结构。
- en: We’ll look at a common combination structure—the mapping from a single key to
    a list of related values. This can be used to accumulate detailed information
    about database or log records identified by a given key. This recipe will partition
    a flat list of details into lists organized by shared key values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨一种常见的组合结构——从单个键到相关值列表的映射。这可以用来累积有关数据库或日志记录的详细信息，这些记录由给定的键标识。这个菜谱将把平铺的细节列表分割成按共享键值组织的列表。
- en: This blurs into class design because we can often leverage Python’s built-in
    classes for this kind of work. This can reduces the volume of unique, new code
    we have to write.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这与类设计相融合，因为我们经常可以利用 Python 的内置类来完成这类工作。这可以减少我们必须编写的独特新代码的量。
- en: 8.5.1 Getting ready
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5.1 准备工作
- en: We’ll look at a mapping from a string to a list of instances of a class we’ll
    design. We’re going to start with some raw log entries from an application, decompose
    each line into individual fields, and then create individual Event objects from
    the fields of data. Once we have these objects, we can then reorganize and regroup
    them into lists associated with common attribute values like module name, or message
    severity.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨从一个字符串到我们设计的类的实例列表的映射。我们将从一个应用程序的原始日志条目开始，将每一行分解成单个字段，然后从数据字段创建单个事件对象。一旦我们有了这些对象，我们就可以将它们重新组织和分组到与常见属性值（如模块名称或消息严重性）关联的列表中。
- en: In Chapter [5](ch009.xhtml#x1-2890005), we looked at log data in the [Creating
    dictionaries – inserting and updating](ch009.xhtml#x1-2900001) recipe.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 [5](ch009.xhtml#x1-2890005) 章中，我们探讨了 [创建字典 – 插入和更新](ch009.xhtml#x1-2900001)
    菜谱中的日志数据。
- en: The first step will be to transform the log lines into a more useful comma-separated
    value (CSV) format. A regular expression can pick out the various syntactic groups.
    See the [String parsing with regular expressions](ch005_split_000.xhtml#x1-350003)
    recipe in Chapter [1](ch005_split_000.xhtml#x1-170001) for information on how
    the parsing works.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步将是将日志行转换成更有用的逗号分隔值（CSV）格式。正则表达式可以提取各种语法组。有关解析工作如何进行的更多信息，请参阅第 [1](ch005_split_000.xhtml#x1-170001)
    章的 [使用正则表达式进行字符串解析](ch005_split_000.xhtml#x1-350003) 菜谱。
- en: 'The raw data looks like the following:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 原始数据看起来如下：
- en: '[PRE37]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each row can be parsed into the component fields with a regular expression.
    We’ll define a NamedTuple subclass that has a static method, from_line(), to create
    instances of the class using these four fields. Making sure the attribute names
    match the regular expression group names, we can build instances of the class
    using the following definition:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都可以用正则表达式解析成组件字段。我们将定义一个名为 NamedTuple 的子类，它有一个静态方法 from_line()，用于使用这四个字段创建类的实例。确保属性名称与正则表达式分组名称匹配，我们可以使用以下定义来构建类的实例：
- en: '[PRE38]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our objective is to group the log messages by the module name attribute. We
    want to see something like this:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是按模块名称属性对日志消息进行分组。我们希望看到如下内容：
- en: '[PRE39]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 8.5.2 How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5.2 如何实现...
- en: 'We can write a summarize() function to restructure the log data as follows:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个 summarize() 函数，将日志数据重新结构化为以下形式：
- en: 'Import the required modules and some type hints for various kinds of collections:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入所需的模块和一些用于各种集合的类型提示：
- en: '[PRE40]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The defaultdict type is a concrete class that extends the MutableMapping abstract
    base class. This is in a separate module from the Iterable type hint, which is
    an abstract base class definition.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: defaultdict 类型是一个扩展了 MutableMapping 抽象基类的具体类。这与 Iterable 类型提示所在的模块分开，后者是一个抽象基类定义。
- en: The source data type, the Event class, was shown in the Getting ready section.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源数据类型，事件类，在准备就绪部分已经展示。
- en: 'Define an overall type hint for the summary dictionary we’ll be working with:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义我们将要工作的摘要字典的整体类型提示：
- en: '[PRE41]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Start the definition of a function to summarize an iterable source of the Event
    instances, and produce a Summary object:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始定义一个函数，用于总结可迭代的事件实例源，并生成一个 Summary 对象：
- en: '[PRE42]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Use the list function as the default value for defaultdict. It’s also helpful
    to create a type hint for this collection:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表函数用作 defaultdict 的默认值。为这个集合创建一个类型提示也很有用：
- en: '[PRE43]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The list function is provided as a name only. A common mistake using list()
    will evaluate the function and create a list object that is not a function. An
    error message like TypeError: first argument must be callable or None is a reminder
    that the argument must be the name of a function only.
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '列表函数仅提供名称。使用 `list()` 的常见错误是评估函数并创建一个列表对象，该对象不是函数。错误消息如 `TypeError: first argument
    must be callable or None` 提醒我们，参数必须是函数名称。'
- en: 'Iterate through the data, appending to the list associated with each key. The
    defaultdict object will use the supplied list() function to build an empty list
    as the value corresponding to each new key the first time each key is encountered:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历数据，将列表添加到每个键关联的列表中。`defaultdict` 对象将使用提供的 `list()` 函数来构建一个空列表，作为首次遇到每个新键时的值：
- en: '[PRE44]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The result of the summarize() function is a dictionary that maps from a module
    name string to a list of all log rows for that module name. The data will look
    like the following:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`summarize()` 函数的结果是一个字典，它将模块名称字符串映射到该模块名称的所有日志行列表。数据看起来如下：'
- en: '[PRE45]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The key for this mapping is the module name and the value in the mapping is
    the list of rows for that module name. We can now focus the analysis on a specific
    module. This seems to be a close match with the initial expectations for the summarized
    results.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 此映射的键是模块名称，映射中的值是该模块名称的行列表。我们现在可以专注于特定模块的分析。这似乎与总结结果的初始预期非常接近。
- en: 8.5.3 How it works...
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5.3 它是如何工作的...
- en: 'There are two choices for how a mapping behaves when a key is not found:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当找不到键时，映射的行为有两种选择：
- en: The built-in dict class raises an exception when a key is missing. This makes
    it difficult to accumulate values associated with keys that aren’t known in advance.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内置的 `dict` 类在键缺失时抛出异常。这使得累积与预先不知道的键关联的值变得困难。
- en: The defaultdict class evaluates a function that creates a default value when
    a key is missing. In many cases, the function is int or float to create a default
    numeric value of 0 or 0.0\. In this case, the function is list to create an empty
    list.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict` 类在键缺失时评估一个创建默认值的函数。在许多情况下，该函数是 `int` 或 `float`，以创建默认的数值 0 或 0.0。在这种情况下，该函数是
    `list`，以创建一个空列表。'
- en: We can imagine using the set function instead of list to create an empty set
    object for a missing key. This would be suitable for a mapping from a key to a
    set of immutable objects that share that key.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象使用 `set` 函数而不是 `list` 来为缺失的键创建一个空的集合对象。这对于从键到共享该键的不可变对象集合的映射是合适的。
- en: 8.5.4 There’s more...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5.4 更多...
- en: 'We can also build a version of this as an extension to the built-in dict class:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将其作为一个扩展构建为内置的 `dict` 类：
- en: '[PRE46]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We’ve provided an implementation for the special __missing__() method. The default
    behavior is to raise a KeyError exception. This will create a new empty list in
    the mapping.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个特殊 `__missing__()` 方法的实现。默认行为是抛出一个 `KeyError` 异常。这将在映射中创建一个新的空列表。
- en: 'This allows us to use code such as the following:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们使用如下代码：
- en: '[PRE47]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The use case is identical to the defaultdict, but the definition of the collection
    class is slightly more complicated. This permits further extension to add features
    to the ModuleEvents class.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 用例与 `defaultdict` 相同，但集合类的定义稍微复杂一些。这允许进一步扩展以向 `ModuleEvents` 类添加功能。
- en: 8.5.5 See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5.5 相关阅读
- en: In the [Creating dictionaries – inserting and updating](ch009.xhtml#x1-2900001)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), we looked at the basics
    of using a mapping.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [4](ch008_split_000.xhtml#x1-2240004) 章的 [创建字典 – 插入和更新](ch009.xhtml#x1-2900001)
    菜谱中，我们探讨了使用映射的基础。
- en: In the [Avoiding mutable default values for function parameters](ch009.xhtml#x1-3210006)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), we looked at other places
    where default values are used.
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [4](ch008_split_000.xhtml#x1-2240004) 章的 [避免为函数参数使用可变默认值](ch009.xhtml#x1-3210006)
    菜谱中，我们探讨了其他使用默认值的地方。
- en: In the [Using more sophisticated collections](ch011_split_001.xhtml#x1-4190008)
    recipe in Chapter [7](ch011_split_000.xhtml#x1-3760007), we looked at other examples
    of using the defaultdict class.
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第 [7](ch011_split_000.xhtml#x1-3760007) 章的 [使用更复杂的集合](ch011_split_001.xhtml#x1-4190008)
    菜谱中，我们探讨了使用 `defaultdict` 类的其他示例。
- en: 8.6 Creating a class that has orderable objects
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.6 创建具有可排序对象的类
- en: We often need objects that can be sorted into order. Log records, to give one
    example, are often ordered by date and time. Most of our class definitions have
    not included the features necessary for sorting objects into order. Many of the
    recipes have kept objects in mappings or sets based on the internal hash value
    computed by the __hash__() method, and an equality test defined by the __eq__()
    method.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要能够按顺序排列的对象。以日志记录为例，它们通常按日期和时间排序。我们大多数类定义都没有包括将对象按顺序排序所需的特性。许多配方都保持对象基于由
    `__hash__()` 方法计算的内联哈希值和由 `__eq__()` 方法定义的相等性测试的映射或集合。
- en: In order to keep items in a sorted collection, we’ll need the comparison methods
    that implement <, >, <=, and >=. These comparisons are all based on the attribute
    values of each object.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持项目在排序集合中，我们需要实现 `<`、`>`、`<=` 和 `>=` 的比较方法。这些比较都是基于每个对象的属性值。
- en: When we extend the NamedTuple class, the comparison methods that apply to the
    tuple class are available. If we defined class using the @dataclass decorator,
    the comparison methods are not provided by default. We can use @dataclass(order=True)
    to have the ordering methods included. For this recipe, we’ll look at a class
    that is not based on either of these helpers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展 `NamedTuple` 类时，适用于元组类的比较方法都是可用的。如果我们使用 `@dataclass` 装饰器定义类，默认情况下不会提供比较方法。我们可以使用
    `@dataclass(order=True)` 来包含排序方法。对于这个配方，我们将查看一个不基于这些辅助工具的类。
- en: 8.6.1 Getting ready
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6.1 准备工作
- en: In the [Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)
    recipe, we defined playing cards using two class definitions. The Card class hierarchy
    defined essential features of each card. A second set of mixin classes provided
    game-specific features for each card.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [通过多重继承分离关注点](ch012.xhtml#x1-4610002) 的配方中，我们使用两个类定义来定义扑克牌。`Card` 类层次定义了每张牌的基本特性。第二组混合类为每张牌提供了特定于游戏的特性。
- en: The core definition, Card, was a frozen dataclass. It did not have the order=True
    parameter, and does not properly put cards into order. We’ll need to add features
    to this Card definition to create objects that can be ordered properly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 核心定义，`Card`，是一个冻结的数据类。它没有 `order=True` 参数，并且没有正确地将牌按顺序排列。我们需要向这个 `Card` 定义添加功能，以创建可以正确排序的对象。
- en: We’ll assume one more class definition, PinochlePoints to follow the rules for
    assigning points to cards for the game of Pinochle. The details don’t matter;
    all that matters is that the class implements the points() method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设另一个类定义，`PinochlePoints`，以遵循为 Pinochle 游戏分配牌点的规则。细节不重要；重要的是这个类实现了 `points()`
    方法。
- en: In order to create a sortable collection of cards, we need to add yet another
    feature to the family of Card class definitions. We’ll need to define four special
    methods used for the comparison operators.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个可排序的牌集合，我们需要向 `Card` 类定义系列添加另一个特性。我们需要定义用于比较运算符的四个特殊方法。
- en: 8.6.2 How to do it...
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6.2 如何做...
- en: 'To create an orderable class definition, we’ll create a comparison protocol,
    and then define a class that implements the protocol, as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可排序的类定义，我们将创建一个比较协议，然后定义一个实现该协议的类，如下所示：
- en: 'We’re defining a new protocol that tools like mypy can use when comparing objects.
    This will describe what kinds of objects the mixin will apply to. We’ve called
    it CardLike because it applies to any class with at least the two attributes of
    rank and suit:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在定义一个新的协议，像 mypy 这样的工具可以在比较对象时使用。这将描述混合类将应用于哪些类型的对象。我们称之为 `CardLike`，因为它适用于具有至少排名和花色这两个属性的任何类：
- en: '[PRE48]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This use of something-Like as a protocol name is part of the overall Pythonic
    approach of duck typing. Rather than insist on a type hierarchy, we define the
    fewest features required as a new Protocol.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将类似-Something 作为协议名称的使用是 Pythonic 整体方法的一部分，即鸭子类型。而不是坚持类型层次结构，我们定义了作为新协议所需的最少特性。
- en: 'Extending the protocol, we can create the SortableCard subclass for the comparison
    features. This subclass can be mixed into any class that fits the protocol definition:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展协议，我们可以创建具有比较特性的 `SortableCard` 子类。这个子类可以混合到任何符合协议定义的类中：
- en: '[PRE49]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Add the four order comparison methods to the SortableCard subclass. In this
    case, we’re using the relevant attributes of any class that fits the CardLike
    protocol into a tuple, then using Python’s built-in tuple comparison to handle
    the details of comparing the items in the tuple. Here are the methods:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将四个排序比较方法添加到 SortableCard 子类中。在这种情况下，我们使用符合 CardLike 协议的任何类的相关属性到一个元组中，然后使用
    Python 的内置元组比较来处理元组中项的比较细节。以下是这些方法：
- en: '[PRE50]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Write the composite class definitions, built from an essential Card class and
    two mixin classes to provide the Pinochle and comparison features:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写由基本 Card 类和两个混合类构建的复合类定义，以提供 Pinochle 和比较功能：
- en: '[PRE51]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'There’s no simple superclass for this collection of classes. We’ll add a type
    hint to create a common definition:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这组类没有简单的超类。我们将添加一个类型提示来创建一个公共定义：
- en: '[PRE52]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now we can create a function that will create individual PinochleCard objects
    from the classes defined previously:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以创建一个函数，从之前定义的类中创建单个 PinochleCard 对象：
- en: '[PRE53]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The dauntingly complex point rules for Pinochle are encapsulated in the PinochlePoints
    class. We’ve omitted them because the points don’t parallel the six card ranks
    at all. Building composite classes as a base subclass of Card plus PinochlePoints
    leads to an accurate model of the cards without too much overt complexity.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Pinochle 的复杂点规则被封装在 PinochlePoints 类中。我们省略了它们，因为点数根本不与六种牌等级平行。将复合类作为 Card 和
    PinochlePoints 的基子类构建，可以准确地对牌进行建模，而不会过于复杂。
- en: 'We can now make cards that respond to comparison operators, using the following
    sequence of interactive commands:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用以下交互命令序列来创建对比较运算符做出响应的牌：
- en: '[PRE54]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The equality comparisons to implement == and != are defined in the base class,
    Card. This is a frozen data class. By default, data classes contain equality test
    methods.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实现等于（==）和不等于（!=）的相等比较是在基类 Card 中定义的。这是一个冻结的数据类。默认情况下，数据类包含相等测试方法。
- en: 'Here’s a function that builds the special 48-card deck. It creates two copies
    of each of the 24 different rank and suit combinations:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个构建特殊 48 张牌组的函数。它创建了 24 种不同等级和花色组合的每张牌的两个副本：
- en: '[PRE55]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The value of the SUITS variable is the four Unicode characters for the suits.
    The generator expression inside the make_deck() function builds two copies of
    each card using the 6 ranks that are part of the Pinochle game.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: SUITS 变量的值是四种 Unicode 字符，代表花色。make_deck() 函数内部的生成表达式使用 Pinochle 游戏中的 6 个等级构建每张牌的两个副本。
- en: 8.6.3 How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6.3 它是如何工作的...
- en: Python uses special methods for a vast number of things. Almost every operator
    in the language is implemented by a special method. (The few exceptions are the
    is operator and and, or, and not.) In this recipe, we’ve leveraged the four ordering
    operators.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Python 为许多事物使用特殊方法。语言中几乎每个运算符都是由特殊方法实现的。（少数例外是 is 运算符和 and、or、not。）在这个配方中，我们利用了四个排序运算符。
- en: The expression c1 <= c2 is evaluated as if we’d written c1.__le__(c2). This
    kind of transformation happens for almost all Python operators.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式 c1 <= c2 被评估为如果我们写了 c1.__le__(c2)。这种转换几乎适用于 Python 的所有运算符。
- en: The Python Language Reference organizes the special methods into several distinct
    groups. In this recipe, we’ve looked at methods used for basic customization of
    a class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: Python 语言参考将特殊方法组织成几个不同的组。在这个配方中，我们查看用于基本定制类的那些方法。
- en: 'Here’s how it looks when we work with instances of this class hierarchy. The
    first example will create a 48-card Pinochle deck:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们处理这个类层次结构的实例时，看起来是这样的。第一个例子将创建一个 48 张牌的 Pinochle 牌组：
- en: '[PRE56]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The important part of the above example is the use of the sorted() function.
    Because we’ve defined proper comparison operators, we can sort the PinochleCard
    instances, and they are presented in the expected order from low rank to high
    rank.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子中重要的部分是 sorted() 函数的使用。因为我们已经定义了适当的比较运算符，我们可以对 PinochleCard 实例进行排序，并且它们按照从低等级到高等级的预期顺序呈现。
- en: 8.6.4 There’s more...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6.4 更多...
- en: 'A little formal logic suggests that we really only need to implement two of
    the comparisons in detail. From an equality method and one ordering method, all
    the remaining methods can be built. For example, if we build the operations for
    less than (__lt__()) and equal to (__eq__()), we could compute the other three
    comparisons following these equivalence rules:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一点形式逻辑表明，我们实际上只需要详细实现两种比较。从一个相等方法和一个排序方法，所有其他方法都可以构建。例如，如果我们为小于（__lt__()）和等于（__eq__()）构建操作，我们可以根据以下等价规则计算其他三个比较：
- en: '![a ≤ b ≡ a < b∨ a = b ](img/file55.png)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![a ≤ b ≡ a < b∨ a = b ](img/file55.png)'
- en: '![a ≥ b ≡ b < a∨ a = b ](img/file56.png)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![a ≥ b ≡ b < a∨ a = b ](img/file56.png)'
- en: '![a ⁄= b ≡ ¬(a = b) ](img/file57.png)'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_IMG
  zh: '![a ⁄= b ≡ ¬(a = b) ](img/file57.png)'
- en: Python emphatically does not do any of this kind of advanced algebra for us.
    We need to do the algebra carefully and implement the necessary comparison methods.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Python 明确不会为我们做这类高级代数运算。我们需要仔细进行代数运算并实现必要的比较方法。
- en: The functools library includes a decorator, @total_ordering, that can generate
    these missing comparison methods.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: functools 库包括一个装饰器，@total_ordering，它可以生成这些缺失的比较方法。
- en: 8.6.5 See also
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6.5 参见
- en: See the [Separating concerns via multiple inheritance](ch012.xhtml#x1-4610002)
    recipe for the essential definitions of cards and card game rules.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见[通过多重继承分离关注点](ch012.xhtml#x1-4610002)配方，了解卡片和卡牌游戏规则的必要定义。
- en: See Chapter [7](ch011_split_000.xhtml#x1-3760007) for more information on dataclasses
    and named tuple classes.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参见第 7 章（ch011_split_000.xhtml#x1-3760007）了解更多关于数据类和命名元组类的信息。
- en: 8.7 Deleting from a list of complicated objects
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8.7 从复杂对象列表中删除
- en: 'Removing items from a list has an interesting consequence. Specifically, when
    an item is removed, all the subsequent items move forward. The rule is this:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 从列表中删除项目有一个有趣的结果。具体来说，当一个项目被删除时，所有后续的项目都会向前移动。规则是这样的：
- en: On deleting item y, items list[y+1:] take the place of items list[y:].
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在删除项目 y 时，items list[y+1:] 取代了 items list[y:]。
- en: This is a side-effect that happens in addition to removing the selected item.
    Because things can move around in a list, it makes deleting more than one item
    at a time potentially challenging.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在删除选定的项目之外发生的副作用。由于列表中的项目可能会移动，这使得一次删除多个项目具有潜在的挑战性。
- en: When the list contains items that have a definition for the __eq__() special
    method, then the list remove() method can remove each item. When the list items
    don’t have a simple __eq__() test, then the remove() method doesn’t work, making
    it more challenging to remove multiple items from the list.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表包含具有 __eq__() 特殊方法定义的项目时，列表的 remove() 方法可以删除每个项目。当列表项目没有简单的 __eq__() 测试时，remove()
    方法不起作用，这使得从列表中删除多个项目更具挑战性。
- en: 8.7.1 Getting ready
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.1 准备工作
- en: For this example, we’ll work with a list of dictionaries, where a naïve approach
    to removing items doesn’t work out. It’s helpful to see what can go wrong with
    trying repeatedly to search a list for an item to delete.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用字典列表，其中删除项目的天真方法不起作用。看到尝试重复搜索列表以删除项目可能会出错是有帮助的。
- en: 'In this case, we’ve got some data that includes a song name, the writers, and
    a duration. The dictionary objects are rather long. The data looks like this:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一些包含歌曲名称、作家和持续时间的资料。字典对象相当长。数据看起来像这样：
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The type hint for each row of this complex structure can be defined with as
    follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用以下方式定义这个复杂结构的每一行的类型提示：
- en: '[PRE59]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: A better design would use a datetime.timedelta for the song’s time. We’ve omitted
    this complication from the recipe.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的设计会使用 datetime.timedelta 来表示歌曲的时间。我们在配方中省略了这个复杂性。
- en: The list of songs as a whole can be described as list[SongType].
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 整个歌曲列表可以描述为 list[SongType]。
- en: 'Here’s a naïve approach that emphatically does not work:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个天真且明显无效的方法：
- en: '[PRE60]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Because items are moved, the computed index values will skip over the item
    just after one that is deleted. Further, because the list gets shorter, the range
    is wrong after a deletion. This fails with an index error, as shown in the following
    output:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于项目被移动，计算出的索引值会跳过刚被删除的项目之后的那个项目。此外，由于列表变短，删除后的范围是错误的。这会导致索引错误，如下面的输出所示：
- en: '[PRE61]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Another failing approach looks like this:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种失败的方法看起来是这样的：
- en: '[PRE62]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This suffers from the problem that each remove() operation must search the list
    from the beginning. This approach will be slow for a very large list.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个问题，即每个 remove() 操作都必须从列表的开始搜索。对于非常大的列表，这种方法会很慢。
- en: We need to combine search and remove operations in a way that avoids multiple
    passes through the list.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要以避免多次遍历列表的方式组合搜索和删除操作。
- en: 8.7.2 How to do it...
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.2 如何做...
- en: 'To efficiently delete multiple items from a list, we’ll need to implement our
    own list index processing function as follows:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了有效地从列表中删除多个项目，我们需要实现自己的列表索引处理函数，如下所示：
- en: 'Define a function to update a list object by removing selected items:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，通过删除选定的项目来更新列表对象：
- en: '[PRE63]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Initialize an index value, i, to zero to begin with the first item in the list:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个索引值 i，从列表的第一个项目开始为零：
- en: '[PRE64]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'While the value for the i variable is not equal to the length of the list,
    we want to make a state change to either increment the i value or shrink the list:'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 i 变量的值不等于列表的长度时，我们希望对状态进行更改，要么增加 i 值，要么缩小列表：
- en: '[PRE65]'
  id: totrans-376
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the data[i] value is the searched-for target, we can remove it, shrinking
    the list.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 data[i] 的值是搜索的目标，我们可以删除它，缩小列表。
- en: 'Otherwise, increment the index value, i, one step closer to the length of the
    list:'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 否则，增加索引值 i，使其更接近列表的长度：
- en: '[PRE66]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This leads to the expected behavior of removing the items from the list without
    suffering from index errors, making multiple passes through the list items, or
    failing to delete matching items.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致从列表中删除项目时不会出现索引错误，也不会多次遍历列表项，或者无法删除匹配的项目。
- en: 8.7.3 How it works...
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.3 它是如何工作的...
- en: 'The goal is to examine each item exactly once and either remove it or step
    over it, leaving it in place. The while statement design stems from looking at
    statements that advance toward the goal: increment the index, and delete an item.
    Each of these works in a limited set of conditions:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是检查每个项目恰好一次，要么删除它，要么跳过它，将其留在原位。while 语句的设计源于观察那些朝着目标前进的语句：增加索引，删除一个项目。这些操作在有限的一组条件下有效：
- en: Incrementing the index only works if the item should not be removed.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当项目不应该被删除时，增加索引才有效。
- en: Deleting an item only works if the item is a match.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅当项目是匹配项时，删除项目才有效。
- en: What’s important is that the conditions are exclusive. When we use a for statement,
    the increment processing always happens, an undesirable feature. The while statement
    permits us to increment only when the item should be left in place.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是条件是互斥的。当我们使用 for 语句时，增量处理总是发生，这是一个不希望的特性。while 语句允许我们仅在项目应该留在原位时才进行增量。
- en: 8.7.4 There’s more...
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.4 更多内容...
- en: An alternative to the overhead of removal is to create a new list with some
    items rejected. Making a shallow copy of items is much faster than removing items
    from a list, but uses more storage. This is a common example of the time versus
    memory trade-off.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 相对于删除的开销，另一种方法是创建一个新列表，其中一些项目被拒绝。制作项目浅拷贝比从列表中删除项目快得多，但需要更多的存储空间。这是一个常见的关于时间和内存权衡的例子。
- en: 'We can use a list comprehension like the following one to create a new list
    of only the desired items:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用如下列表推导来创建一个只包含所需项目的新的列表：
- en: '[PRE67]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This will create a shallow copy of selected items from the list. The items we
    don’t want to keep will be ignored. For more information on the idea of a shallow
    copy, see the Making shallow and deep copies of objects recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建列表中选定项目的浅拷贝。我们不希望保留的项目将被忽略。有关浅拷贝的概念的更多信息，请参阅第 [4](ch008_split_000.xhtml#x1-2240004)
    章中的“制作浅拷贝和深拷贝对象”配方。
- en: 'We can also use a higher-order function, filter(), as part of the copy operation.
    Consider this example:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在复制操作中使用一个高阶函数，filter()。考虑以下示例：
- en: '[PRE68]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The filter() function has two arguments: a lambda object and the original set
    of data. In this case, the lambda expression is used to decide which items to
    pass. Items for which the lambda returns False are rejected.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: filter() 函数有两个参数：一个 lambda 对象和原始数据集。在这种情况下，lambda 表达式用于决定哪些项目要传递。lambda 返回 False
    的项目将被拒绝。
- en: The filter() function is a generator. This means that we need to collect all
    of the items to create a final list object. The list() function is one way to
    consume all items from a generator, stashing them in the collection object they
    create and return.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: filter() 函数是一个生成器。这意味着我们需要收集所有项目以创建一个最终的列表对象。list() 函数是消耗生成器中所有项目的一种方式，将它们存储在它们创建并返回的集合对象中。
- en: 8.7.5 See also
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.7.5 参考内容
- en: 'We’ve leveraged two other recipes: [Making shallow and deep copies of objects](ch009.xhtml#x1-3160005)
    and [Slicing and dicing a list](ch008_split_000.xhtml#x1-2400003) in Chapter [4](ch008_split_000.xhtml#x1-2240004).'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经利用了两个其他配方：[制作浅拷贝和深拷贝对象](ch009.xhtml#x1-3160005) 和 [切片和切块列表](ch008_split_000.xhtml#x1-2400003)，它们在第
    [4](ch008_split_000.xhtml#x1-2240004) 章中。
- en: We’ll look closely at filters and generator expressions in Chapter [9](ch013_split_000.xhtml#x1-5020009).
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在第 [9](ch013_split_000.xhtml#x1-5020009) 章节中仔细研究过滤器和生成器表达式。
- en: Join our community Discord space
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区 Discord 空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Python Discord 工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/file1.png)'
