- en: Part 1. Pythonic Classes via Special Methods
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部分1. 通过特殊方法创建Pythonic类
- en: '*[The _init_() Method](ch01.html "Chapter 1. The __init__() Method")*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: __init__()方法
- en: '*[Integrating Seamlessly with Python – Basic Special Methods](ch02.html "Chapter 2. Integrating
    Seamlessly with Python Basic Special Methods")*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python无缝集成 - 基本特殊方法
- en: '*[Attribute Access, Properties, and Descriptors](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors")*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 属性访问、属性和描述符
- en: '*[The ABCs of Consistent Design](ch04.html "Chapter 4. The ABCs of Consistent
    Design")*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一致设计的ABCs
- en: '*[Using Callables and Contexts](ch05.html "Chapter 5. Using Callables and Contexts")*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可调用对象和上下文
- en: '*[Creating Containers and Collections](ch06.html "Chapter 6. Creating Containers
    and Collections")*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 创建容器和集合
- en: '*[Creating Numbers](ch07.html "Chapter 7. Creating Numbers")*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数字
- en: '*[Decorators and Mixins – Cross-cutting Aspects](ch08.html "Chapter 8. Decorators
    and Mixins – Cross-cutting Aspects")*'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器和混合 - 横切方面
- en: Pythonic Classes via Special Methods
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过特殊方法创建Pythonic类
- en: Python exposes a great deal of its internal mechanisms through its special method
    names. The idea is pervasive throughout Python. A function such as `len()` will
    exploit the `__len__()` special method of a class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Python通过其特殊方法名称暴露了大量的内部机制。这个想法在整个Python中都是普遍的。例如，`len()`这样的函数将利用类的`__len__()`特殊方法。
- en: What this means is that we have a tidy, universal public interface (`len(x)`)
    that works on any kind of class. Python's polymorphism is based in part on the
    way any class can implement a `__len__()` method; objects of any such class will
    respond to the `len()` function.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们有一个整洁的、通用的公共接口（`len(x)`），可以在任何类型的类上使用。Python的多态性部分基于任何类都可以实现`__len__()`方法；任何这样的类的对象都将响应`len()`函数。
- en: When we define a class, we can (and should) include these special methods to
    improve the integration between our class and the rest of Python. [Part 1](pt01.html
    "Part 1. Pythonic Classes via Special Methods"), *Pythonic Classes via Special
    Methods*, will extend basic object-oriented programming techniques to create classes
    that are more *Pythonic*. Any class should be able to integrate seamlessly with
    other parts of Python. A close fit with other parts of Python will allow us to
    use many language and standard library features, and the clients of our packages
    and modules will be more confident about using them and more successful in maintaining
    and extending them.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个类时，我们可以（也应该）包括这些特殊方法，以改进我们的类与Python其他部分之间的集成。[部分1](pt01.html "部分1. 通过特殊方法创建Pythonic类")，*通过特殊方法创建Pythonic类*，将扩展基本的面向对象编程技术，以创建更*Pythonic*的类。任何类都应该能够与Python的其他部分无缝集成。与Python的其他部分紧密结合将使我们能够使用许多语言和标准库功能，我们包和模块的客户端将更有信心地使用它们，并更成功地维护和扩展它们。
- en: In a way, our classes can appear as extensions of Python. We want our classes
    to be so much like native Python classes that distinctions between language, standard
    library, and our application are minimized.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种程度上，我们的类可以看作是Python的扩展。我们希望我们的类非常像本机Python类，以至于语言、标准库和我们的应用之间的区别被最小化。
- en: 'The Python language uses a large number of special method names. They fall
    into the following few discrete categories:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Python语言使用了大量的特殊方法名称。它们可以分为以下几个离散的类别：
- en: '**Attribute Access**: These special methods implement what we see as `object.attribute`
    in an expression, `object.attribute` on the left-hand side of an assignment, and
    `object.attribute` in a `del` statement.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性访问：这些特殊方法实现了我们在表达式中看到的`object.attribute`，在赋值的左侧看到的`object.attribute`，以及在`del`语句中看到的`object.attribute`。
- en: '**Callables**: This special method implements what we see as a function that
    is applied to arguments, much like the built-in `len()` function.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可调用对象：这个特殊方法实现了我们所看到的作用于参数的函数，就像内置的`len()`函数一样。
- en: '**Collections**: These special methods implement the numerous features of collections.
    This involves methods such as `sequence[index]`, `mapping[key]`, and `some_set|another_set`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合：这些特殊方法实现了集合的许多特性。这涉及到诸如`sequence[index]`、`mapping[key]`和`some_set|another_set`等方法。
- en: '**Numbers**: These special methods provide arithmetic operators and comparison
    operators. We can use these methods to expand the domain of numbers that Python
    works with.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数字：这些特殊方法提供了算术运算符和比较运算符。我们可以使用这些方法来扩展Python处理的数字的领域。
- en: '**Contexts**: There are two special methods we''ll use to implement a context
    manager that works with the `with` statement.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文：有两个特殊方法，我们将使用它们来实现一个与`with`语句一起工作的上下文管理器。
- en: '**Iterators**: There are special methods that define an iterator. This isn''t
    essential since generator functions handle this feature so elegantly. However,
    we''ll take a look at how we can design our own iterators.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器：有一些特殊方法定义了迭代器。这并不是必需的，因为生成器函数如此优雅地处理了这个特性。然而，我们将看看如何设计我们自己的迭代器。
- en: A few of these special method names have been introduced in *Python 3 Object
    Oriented Programming*. We'll review these topics and introduce some additional
    special method names that fit into a kind of *basic* category.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一些这些特殊方法名称已经在《Python 3面向对象编程》中介绍过。我们将回顾这些主题，并介绍一些适合于一种*基本*类别的额外特殊方法名称。
- en: Even within this basic category, we've got deeper topics to discover. We'll
    start with the truly basic special methods. There are some rather advanced special
    methods that are thrown into the basic category because they don't seem to belong
    anywhere else.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在这个基本类别中，我们还有更深入的主题要探讨。我们将从真正基本的特殊方法开始。有一些相当高级的特殊方法被归类为基本类别，因为它们似乎不属于其他任何地方。
- en: The `__init__()` method permits a great deal of latitude in providing the initial
    values for an object. In the case of an immutable object, this is the essential
    definition of the instance, and clarity becomes very important. In the first chapter,
    we'll review the numerous design alternatives for this method.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法允许在提供对象的初始值时具有很大的灵活性。对于不可变对象，这是实例的基本定义，清晰度变得非常重要。在第一章中，我们将回顾该方法的众多设计替代方案。'
- en: Chapter 1. The __init__() Method
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章。`__init__()`方法
- en: The `__init__()` method is profound for two reasons. Initialization is the first
    big step in an object's life; every object must be initialized properly to work
    properly. The second reason is that the argument values for `__init__()` can take
    on many forms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法有两个重要原因。初始化是对象生命周期中的第一步；每个对象必须得到适当的初始化才能正常工作。第二个原因是`__init__()`的参数值可以采用许多形式。'
- en: Because there are so many ways to provide argument values to `__init__()`, there
    is a vast array of use cases for object creation. We take a look at several of
    them. We want to maximize clarity, so we need to define an initialization that
    properly characterizes the problem domain.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因为有很多种方法可以向`__init__()`提供参数值，所以有很多对象创建的用例。我们将看几种。我们希望最大限度地提高清晰度，因此需要定义一个正确描述问题域的初始化。
- en: Before we can get to the `__init__()` method, however, we need to take a look
    at the implicit class hierarchy in Python, glancing, briefly, at the class named
    `object`. This will set the stage for comparing default behavior with the different
    kinds of behavior we want from our own classes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们可以进入`__init__()`方法之前，我们需要看一下Python中的隐式类层次结构，简要地看一下名为`object`的类。这将为比较默认行为与我们自己类的不同行为奠定基础。
- en: In this chapter, we take a look at different forms of initialization for simple
    objects (for example, playing cards). After this, we can take a look at more complex
    objects, such as hands that involve collections and players that involve strategies
    and states.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究简单对象（例如扑克牌）的不同初始化形式。之后，我们可以研究更复杂的对象，例如涉及集合的手和涉及策略和状态的玩家。
- en: The implicit superclass – object
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐式超类 - object
- en: 'Each Python class definition has an implicit superclass: `object`. It''s a
    very simple class definition that does almost nothing. We can create instances
    of `object`, but we can''t do much with them because many of the special methods
    simply raise exceptions.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Python类定义都有一个隐式的超类：`object`。这是一个非常简单的类定义，几乎什么都不做。我们可以创建`object`的实例，但我们不能对它们做太多事情，因为许多特殊方法只是简单地引发异常。
- en: 'When we define our own class, `object` is the superclass. The following is
    an example class definition that simply extends `object` with a new name:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义自己的类时，`object`是超类。以下是一个简单扩展`object`的新名称的示例类定义：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are some interactions with our class:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与我们的类的一些交互：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can see that a class is an object of the class named `type` and that the
    base class for our new class is the class named `object`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个类是名为`type`的类的对象，我们新类的基类是名为`object`的类。
- en: As we look at each method, we also take a look at the default behavior inherited
    from `object`. In some cases, the superclass special method behavior will be exactly
    what we want. In other cases, we'll need to override the special method.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看每种方法时，我们还会看一下从`object`继承的默认行为。在某些情况下，超类特殊方法的行为恰好是我们想要的。在其他情况下，我们需要覆盖特殊方法。
- en: The base class object __init__() method
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类对象`__init__()`方法
- en: Fundamental to the life cycle of an object are its creation, initialization,
    and destruction. We'll defer creation and destruction to a later chapter on more
    advanced special methods and only focus on initialization for now.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的生命周期的创建、初始化和销毁是基本的。我们将把创建和销毁推迟到更高级特殊方法的后一章，现在只关注初始化。
- en: The superclass of all classes, `object`, has a default implementation of `__init__()`
    that amounts to `pass`. We aren't required to implement `__init__()`. If we don't
    implement it, then no instance variables will be created when the object is created.
    In some cases, this default behavior is acceptable.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 所有类的超类`object`具有`__init__()`的默认实现，相当于`pass`。我们不需要实现`__init__()`。如果我们不实现它，那么在创建对象时不会创建任何实例变量。在某些情况下，这种默认行为是可以接受的。
- en: 'We can always add attributes to an object that''s a subclass of the foundational
    base class, `object`. Consider the following class that requires two instance
    variables but doesn''t initialize them:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以始终向`object`的子类添加属性。考虑以下类，它需要两个实例变量，但没有初始化它们：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Rectangle` class has a method that uses two attributes to return a value.
    The attributes have not been initialized anywhere. This is legal Python. It's
    a little strange to avoid specifically setting attributes, but it's valid.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Rectangle`类有一个使用两个属性返回值的方法。这些属性在任何地方都没有被初始化。这是合法的Python。避免明确设置属性有点奇怪，但是是有效的。'
- en: 'The following is an interaction with the `Rectangle` class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与`Rectangle`类的交互：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: While this is legal, it's a potential source of deep confusion, which is a good
    reason to avoid it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是合法的，但这可能是深度混淆的潜在来源，这是避免的一个很好的理由。
- en: However, this kind of design grants flexibility, so there could be times when
    we needn't set all of the attributes in the `__init__()` method. We walk a fine
    line here. An optional attribute is a kind of subclass that's not formally declared
    as a proper subclass. We're creating polymorphism in a way that could lead to
    confusing and inappropriate use of convoluted `if` statements. While uninitialized
    attributes may be useful, they could be the symptom of a bad design.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种设计方式提供了灵活性，因此可能有时我们不需要在`__init__()`方法中设置所有属性。我们在这里走了一条细线。可选属性是一种未正式声明为正确子类的子类。我们正在以一种可能导致混乱和不恰当使用复杂的`if`语句的方式创建多态性。虽然未初始化的属性可能有用，但它们可能是糟糕设计的症状。
- en: 'The *Zen of Python* poem (`import this`) offers the following advice:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python之禅*诗（`import this`）提供以下建议：'
- en: '"Explicit is better than implicit."'
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “明确胜于含蓄。”
- en: An `__init__()` method should make the instance variables explicit.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法应该使实例变量明确。'
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Pretty Poor Polymorphism**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**相当差的多态性**'
- en: There's a fine line between flexibility and foolishness.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在灵活性和愚蠢之间有一条细微的界限。
- en: 'We may have stepped over the edge off *flexible* into *foolish* as soon as
    we feel the need to write:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们感到有必要编写：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Or:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It's time to reconsider the API and add a common method or attribute. Refactoring
    is better than adding `if` statements.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候重新考虑API并添加一个公共方法或属性了。重构比添加`if`语句更好。
- en: Implementing __init__() in a superclass
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在超类中实现__init__()
- en: We initialize an object by implementing the `__init__()` method. When an object
    is created, Python first creates an empty object and then calls the `__init__()`
    method for that new object. This method function generally creates the object's
    instance variables and performs any other one-time processing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过实现`__init__()`方法来初始化对象。当对象被创建时，Python首先创建一个空对象，然后调用该新对象的`__init__()`方法。这个方法通常创建对象的实例变量并执行任何其他一次性处理。
- en: 'The following are some example definitions of a `Card` class hierarchy. We''ll
    define a `Card` superclass and three subclasses that are variations of the basic
    theme of `Card`. We have two instance variables that have been set directly from
    argument values and two variables that have been calculated by an initialization
    method:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Card`类层次结构的一些示例定义。我们将定义一个`Card`超类和三个子类，这些子类是`Card`基本主题的变体。我们有两个实例变量，它们直接从参数值设置，还有两个变量，它们是通过初始化方法计算得出的：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this example, we factored the `__init__()` method into the superclass so
    that a common initialization in the superclass, `Card`, applies to all the three
    subclasses `NumberCard`, `AceCard`, and `FaceCard`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`__init__()`方法分解到超类中，以便超类`Card`中的通用初始化适用于所有三个子类`NumberCard`、`AceCard`和`FaceCard`。
- en: 'This shows a common polymorphic design. Each subclass provides a unique implementation
    of the `_points()` method. All the subclasses have identical signatures: they
    have the same methods and attributes. Objects of these three subclasses can be
    used interchangeably in an application.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个常见的多态设计。每个子类提供了`_points()`方法的独特实现。所有子类具有相同的签名：它们具有相同的方法和属性。这三个子类的对象可以在应用程序中互换使用。
- en: 'If we simply use characters for suits, we will be able to create `Card` instances
    as shown in the following code snippet:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们简单地使用字符表示花色，我们就可以创建`Card`实例，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We enumerated the class, rank, and suit for several cards in a list. In the
    long run, we need a much smarter factory function to build `Card` instances; enumerating
    all 52 cards this way is tedious and error prone. Before we get to the factory
    functions, we take a look at a number of other issues.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在列表中为几张卡片枚举了类、等级和花色。从长远来看，我们需要一个更聪明的工厂函数来构建`Card`实例；以这种方式枚举所有52张卡片是乏味且容易出错的。在我们开始工厂函数之前，我们先看一下其他一些问题。
- en: Using __init__() to create manifest constants
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用__init__()创建显式常量
- en: We can define a class for the suits of our cards. In blackjack, the suits don't
    matter, and a simple character string could work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为我们的卡片花色定义一个类。在21点游戏中，花色并不重要，一个简单的字符字符串就可以工作。
- en: We use suit construction as an example of creating constant objects. In many
    cases, our application will have a small domain of objects that can be defined
    by a collection of constants. A small domain of static objects may be part of
    implementing a **Strategy** or **State** design pattern.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以创建常量对象的方式作为示例来使用花色构造。在许多情况下，我们的应用程序将具有可以由一组常量定义的对象的小领域。静态对象的小领域可能是实现**策略**或**状态**设计模式的一部分。
- en: In some cases, we may have a pool of constant objects created in an initialization
    or configuration file, or we might create constant objects based on command-line
    parameters. We'll return to the details of initialization design and startup design
    in [Chapter 16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping
    with the Command Line*.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能会有一个在初始化或配置文件中创建的常量对象池，或者我们可能会根据命令行参数创建常量对象。我们将在[第16章](ch16.html
    "第16章。处理命令行")中详细讨论初始化设计和启动设计的细节，*处理命令行*。
- en: Python has no simple formal mechanism for defining an object as immutable. We'll
    look at techniques to assure immutability in [Chapter 3](ch03.html "Chapter 3. Attribute
    Access, Properties, and Descriptors"), *Attribute Access, Properties, and Descriptors*.
    In this example, it might make sense for the attributes of a suit to be immutable.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Python没有一个简单的正式机制来定义对象为不可变的。我们将在[第3章](ch03.html "第3章。属性访问、属性和描述符")中查看确保不可变性的技术，*属性访问、属性和描述符*。在这个例子中，使花色的属性不可变可能是有意义的。
- en: 'The following is a class that we''ll use to build four manifest constants:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将用来构建四个显式常量的类：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following is the domain of "constants" built around this class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是围绕这个类构建的“常量”领域：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can now create `cards` as shown in the following code snippet:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建`cards`，如下面的代码片段所示：
- en: '[PRE10]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For an example this small, this method isn't a huge improvement over single
    character suit codes. In more complex cases, there may be a short list of Strategy
    or State objects that can be created like this. This can make the Strategy or
    State design patterns work efficiently by reusing objects from a small, static
    pool of constants.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这么小的一个例子，这种方法并没有比单个字符的花色代码有多大的改进。在更复杂的情况下，可能会有一系列短的策略或状态对象可以像这样创建。这可以通过重用来自一个小的静态常量池的对象，使策略或状态设计模式能够高效地工作。
- en: We do have to acknowledge that in Python these objects aren't technically constant;
    they are mutable. There may be some benefit in doing the extra coding to make
    these objects truly immutable.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须承认，在Python中，这些对象在技术上并不是常量；它们是可变的。做额外的编码使这些对象真正不可变可能会有一些好处。
- en: Tip
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**The irrelevance of immutability**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**不可变性的无关性**'
- en: Immutability can become an attractive nuisance. It's sometimes justified by
    the mythical "malicious programmer" who modifies the constant value in their application.
    As a design consideration, this is silly. This mythical, malicious programmer
    can't be stopped this way. There's no easy way to "idiot-proof" code in Python.
    The malicious programmer has access to the source and can tweak it just as easily
    as they can write code to modify a constant.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性可能成为一个有吸引力的麻烦。有时，这是由神秘的“恶意程序员”来证明的，他们修改了他们的应用程序中的常量值。作为设计考虑，这是愚蠢的。这个神秘的、恶意的程序员不能通过这种方式停止。在Python中，没有简单的方法来“防傻”代码。恶意的程序员可以访问源代码，并且可以像编写代码来修改常量一样轻松地调整它。
- en: It's better not to struggle too long to define the classes of immutable objects.
    In [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*, we'll show ways to implement
    immutability that provides suitable diagnostic information for a buggy program.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要花太多时间来定义不可变对象的类。在[第3章](ch03.html "第3章。属性访问、属性和描述符") *属性访问、属性和描述符*中，我们将展示实现不可变性的方法，为有错误的程序提供适当的诊断信息。
- en: Leveraging __init__() via a factory function
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过工厂函数利用__init__()
- en: 'We can build a complete deck of cards via a factory function. This beats enumerating
    all 52 cards. In Python, we have two common approaches to factories as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一个工厂函数构建一副完整的扑克牌。这比枚举所有52张牌要好。在Python中，我们有两种常见的工厂方法，如下所示：
- en: We define a function that creates objects of the required classes.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义一个创建所需类的对象的函数。
- en: We define a class that has methods for creating objects. This is the full factory
    design pattern, as described in books on design patterns. In languages such as
    Java, a factory class hierarchy is required because the language doesn't support
    standalone functions.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义一个具有创建对象方法的类。这是完整的工厂设计模式，如设计模式书籍中所述。在诸如Java之类的语言中，需要工厂类层次结构，因为该语言不支持独立函数。
- en: In Python, a class isn't *required*. It's merely a good idea when there are
    related factories that are complex. One of the strengths of Python is that we're
    not forced to use a class hierarchy when a simple function might do just as well.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，一个类并不是*必需的*。当相关的工厂很复杂时，使用类层次结构只是一个好主意。Python的一个优点是，当一个简单的函数可能同样有效时，我们并不被迫使用类层次结构。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: While this is a book about object-oriented programming, a function really is
    fine. It's common, idiomatic Python.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一本关于面向对象编程的书，但函数确实很好。这是常见的，符合惯例的Python。
- en: We can always rewrite a function to be a proper callable object if the need
    arises. From a callable object, we can refactor it into a class hierarchy for
    our factories. We'll look at callable objects in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，我们总是可以重写一个函数成为一个适当的可调用对象。从可调用对象，我们可以将其重构为我们的工厂类层次结构。我们将在[第5章](ch05.html
    "第5章。使用可调用对象和上下文") *使用可调用对象和上下文*中讨论可调用对象。
- en: The advantage of class definitions in general is to achieve code reuse via inheritance.
    The function of a factory class is to wrap some target class hierarchy and the
    complexities of object construction. If we have a factory class, we can add subclasses
    to the factory class when extending the target class hierarchy. This gives us
    polymorphic factory classes; the different factory class definitions have the
    same method signatures and can be used interchangeably.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，类定义的优势是通过继承实现代码重用。工厂类的作用是包装一些目标类层次结构和对象构造的复杂性。如果有一个工厂类，我们可以在扩展目标类层次结构时将子类添加到工厂类中。这给我们多态工厂类；不同的工厂类定义具有相同的方法签名，并且可以互换使用。
- en: This class-level polymorphism can be very helpful with statically compiled languages
    such as Java or C++. The compiler can resolve the details of the class and methods
    when generating code.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类级别的多态性对于静态编译语言（如Java或C++）非常有帮助。编译器在生成代码时可以解析类和方法的细节。
- en: If the alternative factory definitions don't actually reuse any code, then a
    class hierarchy won't be helpful in Python. We can simply use functions that have
    the same signatures.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果替代工厂定义实际上没有重用任何代码，那么在Python中类层次结构将不会有帮助。我们可以简单地使用具有相同签名的函数。
- en: 'The following is a factory function for our various `Card` subclasses:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们各种`Card`子类的工厂函数：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This function builds a `Card` class from a numeric `rank` number and a `suit`
    object. We can now build cards more simply. We've encapsulated the construction
    issues into a single factory function, allowing an application to be built without
    knowing precisely how the class hierarchy and polymorphic design works.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数从一个数字`rank`和一个`suit`对象构建一个`Card`类。现在我们可以更简单地构建卡片。我们将构造问题封装到一个单一的工厂函数中，允许应用程序构建而不需要精确知道类层次结构和多态设计的工作原理。
- en: 'The following is an example of how we can build a deck with this factory function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个使用这个工厂函数构建一副牌的示例：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This enumerates all the ranks and suits to create a complete deck of 52 cards.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这枚举了所有的等级和花色，以创建一副完整的52张牌。
- en: Faulty factory design and the vague else clause
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误的工厂设计和模糊的else子句
- en: Note the structure of the `if` statement in the `card()` function. We did not
    use a catch-all `else` clause to do any processing; we merely raised an exception.
    The use of a catch-all `else` clause is subject to a tiny scrap of debate.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`card()`函数中`if`语句的结构。我们没有使用一个通用的`else`子句来进行任何处理；我们只是引发了一个异常。使用通用的`else`子句是一个小小的争论点。
- en: On the one hand, it can be argued that the condition that belongs on an `else`
    clause should never be left unstated because it may hide subtle design errors.
    On the other hand, some `else` clause conditions are truly obvious.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一方面，可以说属于`else`子句的条件不应该被省略，因为它可能隐藏了微妙的设计错误。另一方面，一些`else`子句条件确实是显而易见的。
- en: It's important to avoid the vague `else` clause.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 避免模糊的`else`子句是很重要的。
- en: 'Consider the following variant on this factory function definition:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下对这个工厂函数定义的以下变体：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following is what will happen when we try to build a deck:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是当我们尝试构建一副牌时会发生的情况：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Does it work? What if the `if` conditions were more complex?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 它有效吗？如果`if`条件更复杂会怎么样？
- en: Some programmers can understand this `if` statement at a glance. Others will
    struggle to determine if all of the cases are properly exclusive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员可以一眼看出这个`if`语句。其他人将努力确定所有情况是否都是正确排他的。
- en: For advanced Python programming, we should not leave it to the reader to deduce
    the conditions that apply to an `else` clause. Either the condition should be
    obvious to the newest of n00bz, or it should be explicit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高级Python编程，我们不应该让读者推断适用于`else`子句的条件。条件要么对最新的n00bz是显而易见的，要么应该是明确的。
- en: Tip
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**When to use catch-all else**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用catch-all else**'
- en: Rarely. Use it only when the condition is obvious. When in doubt, be explicit
    and use `else` to raise an exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 很少。只有在条件明显时才使用。如果有疑问，要明确使用`else`来引发异常。
- en: Avoid the vague `else` clause.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 避免模糊的`else`子句。
- en: Simplicity and consistency using elif sequences
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`elif`序列的简单和一致性
- en: 'Our factory function, `card()`, is a mixture of two very common factory design
    patterns:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂函数`card()`是两种非常常见的工厂设计模式的混合：
- en: An `if-elif` sequence
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`if-elif`序列
- en: A mapping
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个映射
- en: For the sake of simplicity, it's better to focus on just one of these techniques
    rather than on both.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，最好专注于这些技术中的一个，而不是两者都关注。
- en: We can always replace a mapping with `elif` conditions. (Yes, always. The reverse
    is not true though; transforming `elif` conditions to a mapping can be challenging.)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们总是可以用`elif`条件替换映射。（是的，总是。反之则不然；将`elif`条件转换为映射可能具有挑战性。）
- en: 'The following is a `Card` factory without the mapping:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个没有映射的`Card`工厂：
- en: '[PRE15]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We rewrote the `card()` factory function. The mapping was transformed into additional
    `elif` clauses. This function has the advantage that it is more consistent than
    the previous version.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重写了`card()`工厂函数。映射被转换为额外的`elif`子句。这个函数的优点是它比以前的版本更一致。
- en: Simplicity using mapping and class objects
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用映射和类对象的简单性
- en: In some cases, we can use a mapping instead of a chain of `elif` conditions.
    It's possible to find conditions that are so complex that a chain of `elif` conditions
    is the only sensible way to express them. For simple cases, however, a mapping
    often works better and can be easy to read.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用映射来代替一系列`elif`条件。可能会发现条件非常复杂，以至于一系列`elif`条件是表达它们的唯一明智的方式。然而，对于简单的情况，映射通常效果更好，而且易于阅读。
- en: Since `class` is a first-class object, we can easily map from the `rank` parameter
    to the class that must be constructed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`class`是一个一流对象，我们可以很容易地从`rank`参数映射到必须构造的类。
- en: 'The following is a `Card` factory that uses only a mapping:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个只使用映射的`Card`工厂：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We've mapped the `rank` object to a class. Then, we applied the class to the
    `rank` and `suit` values to build the final `Card` instance.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`rank`对象映射到一个类。然后，我们将该类应用于`rank`和`suit`值，以构建最终的`Card`实例。
- en: 'We can use a `defaultdict` class as well. However, it''s no simpler for a trivial
    static mapping. It looks like the following code snippet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用`defaultdict`类。但是，对于一个微不足道的静态映射来说，它并不更简单。代码如下所示：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that the *default* of a `defaultdict` class must be a function of zero
    arguments. We've used a `lambda` construct to create the necessary function wrapper
    around a constant. This function, however, has a serious deficiency. It lacks
    the translation from `1` to `A` and `13` to `K` that we had in previous versions.
    When we try to add that feature, we run into a problem.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`defaultdict`类的*default*必须是零参数的函数。我们使用了`lambda`构造来创建必要的函数包装器，围绕一个常量。然而，这个函数有一个严重的缺陷。它缺少从`1`到`A`和`13`到`K`的转换，这是我们在以前版本中有的。当我们尝试添加该功能时，我们遇到了问题。
- en: 'We need to change the mapping to provide both a `Card` subclass as well as
    the string version of the `rank` object. What can we do for this two-part mapping?
    There are four common solutions:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要改变映射，以提供`Card`子类以及`rank`对象的字符串版本。对于这种两部分映射，我们可以做什么？有四种常见的解决方案：
- en: We can do two parallel mappings. We don't suggest this, but we'll show it to
    emphasize what's undesirable about it.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做两个并行映射。我们不建议这样做，但我们将展示它以强调它的不可取之处。
- en: We can map to a two-tuple. This also has some disadvantages.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以映射到一个二元组。这也有一些缺点。
- en: We can map to a `partial()` function. The `partial()` function is a feature
    of the `functools` module.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以映射到`partial()`函数。`partial()`函数是`functools`模块的一个特性。
- en: We can also consider modifying our class definition to fit more readily with
    this kind of mapping. We'll look at this alternative in the next section on pushing
    `__init__()` into the subclass definitions.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以考虑修改我们的类定义，以更容易地适应这种映射。我们将在下一节关于将`__init__()`推入子类定义中看看这种替代方案。
- en: We'll look at each of these with a concrete example.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用一个具体的例子来看看每一个。
- en: Two parallel mappings
  id: totrans-140
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两个并行映射
- en: 'The following is the essence of the two parallel mappings solution:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个并行映射解决方案的本质：
- en: '[PRE18]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is not desirable. It involves a repetition of the sequence of the mapping
    keys `1`, `11`, `12`, and `13`. Repetition is bad because parallel structures
    never seem to stay that way after the software has been updated.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可取的。它涉及到映射键`1`、`11`、`12`和`13`序列的重复。重复是不好的，因为并行结构在软件更新后似乎永远不会保持不变。
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t use parallel structures**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要使用并行结构**'
- en: Two parallel structures should be replaced with tuples or some kind of proper
    collection.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 两个并行结构应该被替换为元组或某种适当的集合。
- en: Mapping to a tuple of values
  id: totrans-147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射到一个值的元组
- en: 'The following is the essence of how mapping is done to a two-tuple:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是映射到二元组的本质：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This is reasonably pleasant. It's not much code to sort out the special cases
    of playing cards. We will see how it could be modified or expanded if we need
    to alter the `Card` class hierarchy to add additional subclasses of `Card`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是相当愉快的。要解决纸牌的特殊情况并不需要太多的代码。我们将看到如果需要修改或扩展`Card`类层次结构以添加`Card`的其他子类，它可能会如何被修改或扩展。
- en: It does feel odd to map a `rank` value to a `class` object and just one of the
    two arguments to that class initializer. It seems more sensible to map the rank
    to a simple class or function object without the clutter of providing some (but
    not all) of the arguments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将`rank`值映射到`class`对象，并将其中一个参数映射到该类初始化程序似乎有些奇怪。将rank映射到一个简单的类或函数对象，而不提供一些（但不是全部）参数，似乎更合理。
- en: The partial function solution
  id: totrans-152
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部分函数解决方案
- en: Rather than map to a two-tuple of function and one of the arguments, we can
    create a `partial()` function. This is a function that already has some (but not
    all) of its arguments provided. We'll use the `partial()` function from the `functools`
    library to create a partial of a class with the `rank` argument.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`partial()`函数，而不是映射到函数和一个参数的二元组。这是一个已经提供了一些（但不是全部）参数的函数。我们将使用`functools`库中的`partial()`函数来创建一个带有`rank`参数的部分。
- en: 'The following is a mapping from `rank` to a `partial()` function that can be
    used for object construction:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从`rank`到可以用于对象构造的`partial()`函数的映射：
- en: '[PRE20]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The mapping associates a `rank` object with a `partial()` function that is assigned
    to `part_class`. This `partial()` function can then be applied to the `suit` object
    to create the final object. The use of `partial()` functions is a common technique
    for functional programming. It works in this specific situation where we have
    a function instead of an object method.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该映射将`rank`对象与分配给`part_class`的`partial()`函数相关联。然后可以将此`partial()`函数应用于`suit`对象以创建最终对象。使用`partial()`函数是函数式编程的一种常见技术。它在这种特定情况下起作用，其中我们有一个函数而不是对象方法。
- en: In general, however, `partial()` functions aren't helpful for most object-oriented
    programming. Rather than create `partial()` functions, we can simply update the
    methods of a class to accept the arguments in different combinations. A `partial()`
    function is similar to creating a fluent interface for object construction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，`partial()`函数对大多数面向对象编程并不是很有帮助。与其创建`partial()`函数，我们可以简单地更新类的方法，以接受不同组合的参数。`partial()`函数类似于为对象构造创建流畅的接口。
- en: Fluent APIs for factories
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 工厂的流畅API
- en: In some cases, we design a class where there's a defined order for method usage.
    Evaluating methods sequentially is very much like creating a `partial()` function.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们设计一个类，其中方法的使用顺序是有定义的。顺序评估方法非常类似于创建`partial()`函数。
- en: We might have `x.a().b()` in an object notation. We can think of it as ![Fluent
    APIs for factories](graphics/0971OS_01_01.jpg). The `x.a()` function is a kind
    of `partial()` function that's waiting for `b()`. We can think of this as if it
    were ![Fluent APIs for factories](graphics/0971OS_01_02.jpg).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象表示法中，我们可能会有`x.a().b()`。我们可以将其视为![工厂的流畅API](graphics/0971OS_01_01.jpg)。`x.a()`函数是一种等待`b()`的`partial()`函数。我们可以将其视为![工厂的流畅API](graphics/0971OS_01_02.jpg)。
- en: The idea here is that Python offers us two alternatives for managing a state.
    We can either update an object or create a `partial()` function that is (in a
    way) stateful. Because of this equivalence, we can rewrite a `partial()` function
    into a fluent factory object. We make the setting of the `rank` object a fluent
    method that returns `self`. Setting the `suit` object will actually create the
    `Card` instance.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是，Python为我们提供了两种管理状态的替代方案。我们可以更新对象，也可以创建一个（在某种程度上）有状态的`partial()`函数。由于这种等价性，我们可以将`partial()`函数重写为流畅的工厂对象。我们使`rank`对象的设置成为返回`self`的流畅方法。设置`suit`对象实际上将创建`Card`实例。
- en: 'The following is a fluent `Card` factory class with two method functions that
    must be used in a specific order:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个流畅的`Card`工厂类，其中有两个必须按特定顺序使用的方法函数：
- en: '[PRE21]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `rank()` method updates the state of the constructor, and the `suit()` method
    actually creates the final `Card` object.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`rank()`方法更新构造函数的状态，而`suit()`方法实际上创建最终的`Card`对象。'
- en: 'This factory class can be used as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工厂类可以如下使用：
- en: '[PRE22]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we create a factory instance, then we use that instance to create `Card`
    instances. This doesn't materially change how `__init__()` itself works in the
    `Card` class hierarchy. It does, however, change the way that our client application
    creates objects.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个工厂实例，然后使用该实例创建`Card`实例。这并不会实质性地改变`Card`类层次结构中`__init__()`本身的工作方式。但是，它改变了我们的客户端应用程序创建对象的方式。
- en: Implementing __init__() in each subclass
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在每个子类中实现`__init__()`
- en: As we look at the factory functions for creating `Card` objects, we see some
    alternative designs for the `Card` class. We might want to refactor the conversion
    of the rank number so that it is the responsibility of the `Card` class itself.
    This pushes the initialization down into each subclass.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看用于创建`Card`对象的工厂函数时，我们看到了`Card`类的一些替代设计。我们可能希望重构排名数字的转换，使其成为`Card`类本身的责任。这将初始化推入到每个子类中。
- en: This often requires some common initialization of a superclass as well as subclass-specific
    initialization. We need to follow the **Don't Repeat Yourself** (**DRY**) principle
    to keep the code from getting cloned into each of the subclasses.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常需要对超类进行一些常见的初始化，以及子类特定的初始化。我们需要遵循**不要重复自己**（**DRY**）原则，以防止代码被克隆到每个子类中。
- en: 'The following is an example where the initialization is the responsibility
    of each subclass:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中初始化是每个子类的责任：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is still clearly polymorphic. The lack of a truly common initialization,
    however, leads to some unpleasant redundancy. What's unpleasant here is the repeated
    initialization of `suit`. This must be *pulled up* into the superclass. We can
    have each `__init__()` subclass make an explicit reference to the superclass.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然显然是多态的。然而，缺乏一个真正共同的初始化导致了一些令人不快的冗余。这里令人不快的是`suit`的重复初始化。这必须被*提升*到超类中。我们可以让每个`__init__()`子类对超类进行显式引用。
- en: 'This version of the `Card` class has an initializer at the superclass level
    that is used by each subclass, as shown in the following code snippet:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Card`类的版本在超类级别有一个初始化器，每个子类都使用它，如下面的代码片段所示：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ve provided `__init__()` at both the subclass and superclass level. This
    has the small advantage that it simplifies our factory function, as shown in the
    following code snippet:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在子类和超类级别都提供了`__init__()`。这有一个小优点，就是它简化了我们的工厂函数，如下面的代码片段所示：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Simplifying a factory function should not be our focus. We can see from this
    variation that we've created rather complex `__init__()` methods for a relatively
    minor improvement in a factory function. This is a common trade-off.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 简化工厂函数不应该是我们的重点。从这个变化中我们可以看到，我们为了在工厂函数中稍微改进而创建了相当复杂的`__init__()`方法。这是一个常见的权衡。
- en: Tip
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Factory functions encapsulate complexity**'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂函数封装复杂性**'
- en: There's a trade-off that occurs between sophisticated `__init__()` methods and
    factory functions. It's often better to stick with more direct but less programmer-friendly
    `__init__()` methods and push the complexity into factory functions. A factory
    function works well if you wish to wrap and encapsulate the construction complexities.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的`__init__()`方法和工厂函数之间存在一个权衡。通常更好的做法是坚持使用更直接但不太友好的`__init__()`方法，并将复杂性推入工厂函数。如果你希望包装和封装构造复杂性，工厂函数会起作用。
- en: Simple composite objects
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单的复合对象
- en: 'A composite object can also be called a **container**. We''ll look at a simple
    composite object: a deck of individual cards. This is a basic collection. Indeed,
    it''s so basic that we can, without too much struggle, use a simple `list` as
    a deck.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复合对象也可以被称为**容器**。我们将看一个简单的复合对象：一叠单独的卡片。这是一个基本的集合。事实上，它是如此基本，以至于我们可以不费吹灰之力地使用一个简单的`list`作为一叠卡片。
- en: 'Before designing a new class, we need to ask this question: is using a simple
    `list` appropriate?'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计一个新的类之前，我们需要问这个问题：使用一个简单的`list`是否合适？
- en: We can use `random.shuffle()` to shuffle the deck and `deck.pop()` to deal cards
    into a player's `Hand`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`random.shuffle()`来洗牌，使用`deck.pop()`来发牌到玩家的`Hand`中。
- en: 'Some programmers rush to define new classes as if using a built-in class violates
    some object-oriented design principle. Avoiding a new class leaves us with something
    as shown in the following code snippet:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员急于定义新的类，好像使用内置类违反了某些面向对象设计原则。避免新类会使我们得到以下代码片段中所示的东西：
- en: '[PRE26]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If it's that simple, why write a new class?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这么简单，为什么要写一个新的类呢？
- en: The answer isn't perfectly clear. One advantage is that a class offer a simplified,
    implementation-free interface to the object. As we noted previously, when discussing
    factories, a class isn't a requirement in Python.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 答案并不完全清晰。一个优点是，一个类提供了一个简化的、无实现的接口给对象。正如我们之前提到的，在讨论工厂时，一个类在Python中并不是必需的。
- en: In the preceding code, the deck only has two simple use cases and a class definition
    doesn't seem to simplify things very much. It does have the advantage of concealing
    the implementation's details. But the details are so trivial that exposing them
    seems to have little cost. We're focused primarily on the `__init__()` method
    in this chapter, so we'll look at some designs to create and initialize a collection.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，这个牌组只有两个简单的用例，而且一个类定义似乎并没有简化事情太多。它的优点在于隐藏了实现的细节。但是这些细节如此微不足道，以至于暴露它们似乎没有太大的成本。在本章中，我们主要关注`__init__()`方法，所以我们将看一些设计来创建和初始化一个集合。
- en: 'To design a collection of objects, we have the following three general design
    strategies:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计一个对象的集合，我们有以下三种一般的设计策略：
- en: '**Wrap**: This design pattern is an existing collection definition. This might
    be an example of the **Facade** design pattern.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装**：这个设计模式是一个现有的集合定义。这可能是**外观**设计模式的一个例子。'
- en: '**Extend**: This design pattern is an existing collection class. This is ordinary
    subclass definition.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：这个设计模式是一个现有的集合类。这是普通的子类定义。'
- en: '**Invent**: This is designed from scratch. We''ll look at this in [Chapter
    6](ch06.html "Chapter 6. Creating Containers and Collections"), *Creating Containers
    and Collections*.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发明**：这是从头开始设计的。我们将在[第6章](ch06.html "第6章。创建容器和集合")中看到这个，*创建容器和集合*。'
- en: These three concepts are central to object-oriented design. We must always make
    this choice when designing a class.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个概念是面向对象设计的核心。在设计一个类时，我们必须始终做出这个选择。
- en: Wrapping a collection class
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装一个集合类
- en: 'The following is a wrapper design that contains an internal collection:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含内部集合的包装设计：
- en: '[PRE27]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've defined `Deck` so that the internal collection is a `list` object. The
    `pop()` method of `Deck` simply delegates to the wrapped `list` object.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`Deck`，使得内部集合是一个`list`对象。`Deck`的`pop()`方法只是委托给了包装的`list`对象。
- en: 'We can then create a `Hand` instance with the following kind of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以用以下代码创建一个`Hand`实例：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Generally, a Facade design pattern or wrapper class contains methods that are
    simply delegated to the underlying implementation class. This delegation can become
    wordy. For a sophisticated collection, we may wind up delegating a large number
    of methods to the wrapped object.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，外观设计模式或包装类包含了简单地委托给底层实现类的方法。这种委托可能会变得啰嗦。对于一个复杂的集合，我们可能最终会委托大量的方法给包装对象。
- en: Extending a collection class
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展一个集合类
- en: An alternative to wrapping is to extend a built-in class. By doing this, we
    have the advantage of not having to reimplement the `pop()` method; we can simply
    inherit it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 包装的另一种选择是扩展内置类。通过这样做，我们不必重新实现`pop()`方法，我们可以直接继承它。
- en: The `pop()` method has the advantage that it creates a class without writing
    too much code. In this example, extending the `list` class has the disadvantage
    that this provides many more functions than we truly need.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`pop()`方法的优点在于它可以创建一个类，而不需要编写太多的代码。在这个例子中，扩展`list`类的缺点在于它提供了比我们实际需要的更多的函数。'
- en: 'The following is a definition of `Deck` that extends the built-in `list`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是扩展内置`list`的`Deck`定义：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In some cases, our methods will have to explicitly use the superclass methods
    in order to have proper class behavior. We'll see other examples of this in the
    following sections.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们的方法将不得不明确地使用超类方法，以便具有适当的类行为。我们将在接下来的章节中看到其他例子。
- en: We leverage the superclass's `__init__()` method to populate our `list` object
    with an initial single deck of cards. Then we shuffle the cards. The `pop()` method
    is simply inherited from `list` and works perfectly. Other methods inherited from
    the `list` also work.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用超类的`__init__()`方法来用一副初始的牌组填充我们的`list`对象。然后我们洗牌。`pop()`方法只是从`list`继承而来，完美地工作。其他从`list`继承的方法也可以工作。
- en: More requirements and another design
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多要求和另一个设计
- en: In a casino, the cards are often dealt from a shoe that has half a dozen decks
    of cards all mingled together. This consideration makes it necessary for us to
    build our own version of `Deck` and not simply use an unadorned `list` object.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在赌场里，牌通常是从一个混合了半打牌组的鞋子中发出的。这个考虑使我们必须建立我们自己的`Deck`版本，而不仅仅使用一个朴素的`list`对象。
- en: Additionally, a casino shoe is not dealt fully. Instead, a marker card is inserted.
    Because of the marker, some cards are effectively set aside and not used for play.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，赌场鞋子并不是完全发牌。相反，会插入一个标记牌。由于标记牌，一些牌实际上被搁置不用于游戏。
- en: 'The following is `Deck` definition that contains multiple sets of 52-card decks:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是包含多副52张牌组的`Deck`定义：
- en: '[PRE30]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we used the `__init__()` superclass to build an empty collection. Then,
    we used `self.extend()` to append multiple 52-card decks to the shoe. We could
    also use `super().extend()` since we did not provide an overriding implementation
    in this class.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`__init__()`超类来构建一个空集合。然后，我们使用`self.extend()`来将多副52张牌的牌组附加到鞋子上。我们也可以使用`super().extend()`，因为在这个类中我们没有提供覆盖的实现。
- en: 'We could also carry out the entire task via `super().__init__()` using a more
    deeply nested generator expression, as shown in the following code snippet:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过`super().__init__()`使用更深层嵌套的生成器表达式来完成整个任务，如下面的代码片段所示：
- en: '[PRE31]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This class provides us with a collection of `Card` instances that we can use
    to emulate casino blackjack as dealt from a shoe.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类为我们提供了一系列`Card`实例，我们可以用它来模拟从鞋子中发牌的赌场21点。
- en: There's a peculiar ritual in a casino where they reveal the burned card. If
    we're going to design a card-counting player strategy, we might want to emulate
    this nuance too.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在赌场里有一个奇怪的仪式，他们会揭示被烧毁的牌。如果我们要设计一个计牌玩家策略，我们可能也想模拟这种细微差别。
- en: Complex composite objects
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂的复合对象
- en: 'The following is an example of a blackjack `Hand` description that might be
    suitable for emulating play strategies:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个适合模拟玩法策略的21点`Hand`描述的例子：
- en: '[PRE32]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this example, we have an instance variable `self.dealer_card` based on a
    parameter of the `__init__()` method. The `self.cards` instance variable, however,
    is not based on any parameter. This kind of initialization creates an empty collection.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个基于`__init__()`方法的参数的实例变量`self.dealer_card`。然而，`self.cards`实例变量并不基于任何参数。这种初始化方式创建了一个空集合。
- en: 'To create an instance of `Hand`, we can use the following code:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建`Hand`的一个实例，我们可以使用以下代码：
- en: '[PRE33]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This has the disadvantage that a long-winded sequence of statements is used
    to build an instance of a `Hand` object. It can become difficult to serialize
    the `Hand` object and rebuild it with an initialization such as this one. Even
    if we were to create an explicit `append()` method in this class, it would still
    take multiple steps to initialize the collection.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种初始化方式的缺点是使用了一长串陈述来构建`Hand`对象的实例。使用这种初始化方式，将`Hand`对象序列化并重新构建会变得困难。即使我们在这个类中创建了一个显式的`append()`方法，初始化集合仍然需要多个步骤。
- en: We could try to create a fluent interface, but that doesn't really simplify
    things; it's merely a change in the syntax of the way that a `Hand` object is
    built. A fluent interface still leads to multiple method evaluations. When we
    take a look at the serialization of objects in [Part 2](pt02.html "Part 2. Persistence
    and Serialization"), *Persistence and Serialization* we'd like an interface that's
    a single class-level function, ideally the class constructor. We'll look at this
    in depth in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML,
    Pickle, CSV, and XML"), *Serializing and Saving - JSON, YAML, Pickle, CSV, and
    XML*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试创建一个流畅的接口，但这并不能真正简化事情；它只是改变了构建`Hand`对象的语法方式。流畅的接口仍然会导致多个方法的评估。当我们在[第2部分](pt02.html
    "第2部分。持久性和序列化")中查看对象的序列化时，*持久性和序列化*我们希望一个单一的类级函数接口，理想情况下是类构造函数。我们将在[第9章](ch09.html
    "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中深入研究，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*。
- en: Note also that the hard total and soft total method functions shown here don't
    fully follow the rules of blackjack. We return to this issue in [Chapter 2](ch02.html
    "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"), *Integrating
    Seamlessly with Python – Basic Special Methods*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，这里显示的硬总和和软总和方法函数并不完全遵循21点的规则。我们将在[第2章](ch02.html "第2章。与Python基本特殊方法无缝集成")中回到这个问题，*与Python无缝集成
    - 基本特殊方法*。
- en: Complete composite object initialization
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完整的复合对象初始化
- en: Ideally, the `__init__()` initializer method will create a complete instance
    of an object. This is a bit more complex when creating a complete instance of
    a container that contains an internal collection of other objects. It'll be helpful
    if we can build this composite in a single step.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，`__init__()`初始化方法将创建一个完整的对象实例。当创建一个包含内部其他对象集合的容器的完整实例时，这会更加复杂。如果我们可以一次性构建这个复合体将会很有帮助。
- en: It's common to have both a method to incrementally accrete items as well as
    the initializer special method that can load all of the items in one step.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有一个逐步累积项目的方法，以及一个可以一次性加载所有项目的初始化特殊方法。
- en: 'For example, we might have a class such as the following code snippet:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能有一个类，如下面的代码片段：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This initialization sets all of the instance variables in a single step. The
    other methods are simply copies of the previous class definition. We can build
    a `Hand2` object in two ways. This first example loads one card at a time into
    a `Hand2` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种初始化可以一次性设置所有实例变量。其他方法只是前一个类定义的副本。我们可以以两种方式构建`Hand2`对象。第一个例子是一次将一张牌加载到`Hand2`对象中：
- en: '[PRE35]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This second example uses the `*cards` parameter to load a sequence of `Cards`
    class in a single step:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第二个例子使用`*cards`参数一次性加载一个`Cards`类的序列：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For unit testing, it's often helpful to build a composite object in a single
    statement in this way. More importantly, some of the serialization techniques
    from the next part will benefit from a way of building a composite object in a
    single, simple evaluation.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，以这种方式一次性构建一个复合对象通常是有帮助的。更重要的是，下一部分的一些序列化技术将受益于一种在单个简单评估中构建复合对象的方法。
- en: Stateless objects without __init__()
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 没有`__init__()`的无状态对象
- en: 'The following is an example of a degenerate class that doesn''t need an `__init__()`
    method. It''s a common design pattern for **Strategy** objects. A Strategy object
    is plugged into a Master object to implement an algorithm or decision. It may
    rely on data in the master object; the Strategy object may not have any data of
    its own. We often design strategy classes to follow the **Flyweight** design pattern:
    we avoid internal storage in the `Strategy` object. All values are provided to
    `Strategy` as method argument values. The `Strategy` object itself can be stateless.
    It''s more a collection of method functions than anything else.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个不需要`__init__()`方法的退化类的示例。这是**策略**对象的常见设计模式。策略对象被插入到主对象中以实现算法或决策。它可能依赖于主对象中的数据；策略对象本身可能没有任何数据。我们经常设计策略类遵循**享元**设计模式：我们避免在`Strategy`对象中存储内部数据。所有值都作为方法参数值提供给`Strategy`。`Strategy`对象本身可以是无状态的。它更像是一组方法函数而不是其他任何东西。
- en: 'In this case, we''re providing the game play decisions for a `Player` instance.
    The following is an example of a (dumb) strategy to pick cards and decline the
    other bets:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们为`Player`实例提供游戏玩法决策。以下是一个（愚蠢的）选择牌和拒绝其他赌注的策略示例：
- en: '[PRE37]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Each method requires the current `Hand` as an argument value. The decisions
    are based on the available information; that is, on the dealer's cards and the
    player's cards.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每种方法都需要当前的“手牌”作为参数值。决策是基于可用信息的；也就是说，基于庄家的牌和玩家的牌。
- en: 'We can build a single instance of this strategy for use by various `Player`
    instances as shown in the following code snippet:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建这种策略的单个实例，供各种`Player`实例使用，如下面的代码片段所示：
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We can imagine creating a family of related strategy classes, each one using
    different rules for the various decisions a player is offered in blackjack.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象创建一系列相关的策略类，每个类使用不同的规则来决定玩家在二十一点中所面临的各种决策。
- en: Some additional class definitions
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些额外的类定义
- en: 'As noted previously, a player has two strategies: one for betting and one for
    playing their hand. Each `Player` instance has a sequence of interactions with
    a larger simulation engine. We''ll call the larger engine the `Table` class.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，玩家有两种策略：一种是下注策略，一种是打牌策略。每个`Player`实例都与一个更大的模拟引擎有一系列的交互。我们将更大的引擎称为`Table`类。
- en: 'The `Table` class requires the following sequence of events by the `Player`
    instances:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`类需要`Player`实例按以下顺序进行一系列事件：'
- en: The player must place an initial bet based on the betting strategy.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家必须根据下注策略下注初始赌注。
- en: The player will then receive a hand.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后玩家将收到一手牌。
- en: If the hand is splittable, the player must decide to split or not based on the
    play strategy. This can create additional `Hand` instances. In some casinos, the
    additional hands are also splittable.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果手牌可以分牌，玩家必须根据玩法策略决定是否要分牌。这可能会创建额外的`Hand`实例。在一些赌场，额外的手牌也可以分牌。
- en: For each `Hand` instance, the player must decide to hit, double, or stand based
    on the play strategy.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个`Hand`实例，玩家必须根据玩法策略决定是否要叫牌、加倍或站立。
- en: The player will then receive payouts, and they must update their betting strategy
    based on their wins and losses.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后玩家将收到赔付，他们必须根据胜负更新他们的投注策略。
- en: From this, we can see that the `Table` class has a number of API methods to
    receive a bet, create a `Hand` object, offer a split, resolve each hand, and pay
    off the bets. This is a large object that tracks the state of play with a collection
    of `Players`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到`Table`类有许多API方法来接收赌注，创建一个`Hand`对象，提供分牌，解决每一手牌，并支付赌注。这是一个大对象，用一组`Players`跟踪游戏状态。
- en: 'The following is the beginning of a `Table` class that handles the bets and
    cards:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是处理赌注和牌的`Table`类的开始部分：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `Table` class is used by the `Player` class to accept a bet, create a `Hand`
    object, and determine if theinsurance bet is in play for this hand. Additional
    methods can be used by the `Player` class to get cards and determine the payout.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`Table`类被`Player`类用于接受赌注，创建`Hand`对象，并确定这手牌是否有保险赌注。`Player`类可以使用其他方法来获取牌并确定赔付。'
- en: The exception handling shown in `get_hand()` is not a precise model of casino
    play. This may lead to minor statistical inaccuracies. A more accurate simulation
    requires developing a deck that reshuffles itself when empty instead of raising
    an exception.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_hand()`中显示的异常处理并不是赌场游戏的精确模型。这可能导致轻微的统计不准确。更准确的模拟需要开发一个在空时重新洗牌而不是引发异常的牌组。'
- en: In order to interact properly and simulate realistic play, the `Player` class
    needs a betting strategy. The betting strategy is a stateful object that determines
    the level of the initial bet. The various betting strategies generally change
    the bet based on whether the game was a win or a loss.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确交互并模拟真实的游戏，`Player`类需要一个下注策略。下注策略是一个有状态的对象，确定初始下注的水平。各种下注策略通常根据游戏是赢还是输来改变下注。
- en: Ideally, we'd like to have a family of betting strategy objects. Python has
    a module with decorators that allows us to create an abstract superclass. An informal
    approach to creating Strategy objects is to raise an exception for methods that
    *must* be implemented by a subclass.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望有一系列的下注策略对象。Python有一个带有装饰器的模块，允许我们创建一个抽象超类。创建策略对象的非正式方法是为必须由子类实现的方法引发异常。
- en: 'We''ve defined an abstract superclass as well as a specific subclass as follows
    to define a flat betting strategy:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个抽象超类以及一个特定的子类，如下所示，以定义一个平级下注策略：
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The superclass defines the methods with handy default values. The basic `bet()`
    method in the abstract superclass raises an exception. The subclass must override
    the `bet()` method. The other methods can be left to provide the default values.
    Given the game strategy in the previous section plus the betting strategy here,
    we can look at more complex `__init__()` techniques surrounding the `Player` class.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 超类定义了具有方便的默认值的方法。抽象超类中的基本`bet()`方法引发异常。子类必须覆盖`bet()`方法。其他方法可以保留以提供默认值。鉴于前一节中的游戏策略以及这里的下注策略，我们可以看看围绕`Player`类的更复杂的`__init__()`技术。
- en: 'We can make use of the `abc` module to formalize an abstract superclass definition.
    It would look like the following code snippet:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`abc`模块来规范化一个抽象超类定义。它看起来像以下代码片段：
- en: '[PRE41]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This has the advantage that it makes the creation of an instance of `BettingStrategy2,`
    or any subclass that failed to implement `bet(),` impossible. If we try to create
    an instance of this class with an unimplemented abstract method, it will raise
    an exception instead of creating an object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是，它使得创建`BettingStrategy2`的实例，或者任何未能实现`bet()`的子类的实例都是不可能的。如果我们尝试使用未实现的抽象方法创建此类的实例，它将引发异常而不是创建对象。
- en: And yes, the abstract method has an implementation. It can be accessed via `super().bet()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，抽象方法有一个实现。可以通过`super().bet()`访问它。
- en: Multi-strategy __init__()
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多策略__init__()
- en: We may have objects that are created from a variety of sources. For example,
    we might need to clone an object as part of creating a memento, or freeze an object
    so that it can be used as the key of a dictionary or placed into a set; this is
    the idea behind the `set` and `frozenset` built-in classes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有从各种来源创建的对象。例如，我们可能需要克隆一个对象作为创建备忘录的一部分，或者冻结一个对象，以便将其用作字典的键或放入集合中；这就是`set`和`frozenset`内置类背后的思想。
- en: There are several overall design patterns that have multiple ways to build an
    object. One design pattern is complex `__init__()` that is called multi-strategy
    initialization. Also, there are multiple class-level (static) constructor methods.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种整体设计模式可以构建对象的多种方式。一个设计模式是复杂的`__init__()`，称为多策略初始化。还有多个类级（静态）构造方法。
- en: These are incompatible approaches. They have radically different interfaces.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是不兼容的。它们具有根本不同的接口。
- en: Tip
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Avoid clone methods**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 避免克隆方法
- en: A clone method that unnecessarily duplicates an object is rarely needed in Python.
    Using cloning may be an indication of failure to understand the object-oriented
    design principles available in Python.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中很少需要不必要地复制对象的克隆方法。使用克隆可能表明未能理解Python中可用的面向对象设计原则。
- en: A clone method encapsulates the knowledge of object creation in the wrong place.
    The source object that's being cloned cannot know about the structure of the target
    object that was built from the clone. However, the reverse (targets having knowledge
    about a source) is acceptable if the source provides a reasonably well-encapsulated
    interface.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 克隆方法将对象创建的知识封装在错误的位置。被克隆的源对象不能了解从克隆创建的目标对象的结构。然而，反过来（目标了解源）是可以接受的，如果源提供了一个相当封装良好的接口。
- en: The examples we have shown here are effectively cloning because they're so simple.
    We'll expand on them in the next chapter. However, to show ways in which these
    fundamental techniques are used to do more than trivial cloning, we'll look at
    turning a mutable `Hand` object into a frozen, immutable `Hand` object.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示的示例实际上是克隆，因为它们非常简单。我们将在下一章中扩展它们。然而，为了展示这些基本技术被用于不仅仅是微不足道的克隆的方式，我们将看看如何将可变的`Hand`对象转换为冻结的不可变的`Hand`对象。
- en: 'The following is an example of a `Hand` object that can be built in either
    of the two ways:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用两种方式构建的`Hand`对象的示例：
- en: '[PRE42]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the first case, a `Hand3` instance has been built from an existing `Hand3`
    object. In the second case, a `Hand3` object has been built from individual `Card`
    instances.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，从现有的`Hand3`对象构建了一个`Hand3`实例。在第二种情况下，从单独的`Card`实例构建了一个`Hand3`对象。
- en: 'This parallels the way a `frozenset` object can be built from individual items
    or an existing `set` object. We look more at creating immutable objects in the
    next chapter. Creating a new `Hand` from an existing `Hand` allows us to create
    a memento of a `Hand` object using a construct like the following code snippet:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这与从单个项目或现有`set`对象构建`frozenset`对象的方式相似。我们将在下一章中更多地了解创建不可变对象。从现有的`Hand`创建一个新的`Hand`使我们能够使用以下代码片段创建`Hand`对象的备忘录：
- en: '[PRE43]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We saved the `Hand` object in the `memento` variable. This can be used to compare
    the final with the original hand that was dealt, or we can *freeze* it for use
    in a set or mapping too.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`Hand`对象保存在`memento`变量中。这可以用来比较最终手牌和原始发牌的手牌，或者我们可以将其*冻结*以供在集合或映射中使用。
- en: More complex initialization alternatives
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更复杂的初始化替代方案
- en: In order to write a multi-strategy initialization, we're often forced to give
    up on specific named parameters. This design has the advantage that it is flexible,
    but the disadvantage that it has opaque, meaningless parameter names. It requires
    a great deal of documentation explaining the variant use cases.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了编写多策略初始化，我们经常不得不放弃特定的命名参数。这种设计的优点是灵活，但缺点是参数名是不透明的，没有意义的。它需要大量的文档来解释各种用例。
- en: 'We can expand our initialization to also split a `Hand` object. The result
    of splitting a `Hand` object is simply another constructor. The following code
    snippet shows how the splitting of a `Hand` object might look:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的初始化来拆分`Hand`对象。拆分`Hand`对象的结果只是另一个构造函数。以下代码片段显示了拆分`Hand`对象可能是什么样子：
- en: '[PRE44]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This design involves getting extra cards to build proper, split hands. When
    we create one `Hand4` object from another `Hand4` object, we provide a split keyword
    argument that uses the index of the `Card` class from the original `Hand4` object.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设计涉及获取额外的牌来构建适当的拆分手牌。当我们从另一个`Hand4`对象创建一个`Hand4`对象时，我们提供一个拆分关键字参数，该参数使用原始`Hand4`对象的`Card`类的索引。
- en: 'The following code snippet shows how we''d use this to split a hand:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了我们如何使用这个方法来拆分一手牌：
- en: '[PRE45]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We created an initial `h` instance of `Hand4` and split it into two other `Hand4`
    instances, `s1` and `s2`, and dealt an additional `Card` class into each. The
    rules of blackjack only allow this when the initial hand has two cards of equal
    rank.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Hand4`的初始实例`h`，并将其拆分成另外两个`Hand4`实例`s1`和`s2`，并为每个实例发了一张额外的`Card`类。二十一点的规则只允许在初始手牌有两张相同等级的牌时才能这样做。
- en: While this `__init__()` method is rather complex, it has the advantage that
    it can parallel the way in which `fronzenset` is created from an existing set.
    The disadvantage is that it needs a large docstring to explain all these variations.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个`__init__()`方法相当复杂，但它的优点是可以并行地创建`fronzenset`对象。缺点是需要一个大的文档字符串来解释所有这些变化。
- en: Initializing static methods
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化静态方法
- en: When we have multiple ways to create an object, it's sometimes more clear to
    use static methods to create and return instances rather than complex `__init__()`
    methods.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多种创建对象的方式时，有时使用静态方法来创建和返回实例比复杂的`__init__()`方法更清晰。
- en: It's also possible to use class methods as alternate initializers, but there's
    little tangible advantage to receiving the class as an argument to the method.
    In the case of freezing or splitting a `Hand` object, we might want to create
    two new static methods to freeze or split a `Hand` object. Using static methods
    as surrogate constructors is a tiny syntax change in construction, but it has
    huge advantages when organizing the code.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用类方法作为替代初始化程序，但是将类作为方法的参数并没有太大的优势。在冻结或拆分`Hand`对象的情况下，我们可能希望创建两个新的静态方法来冻结或拆分`Hand`对象。在构造中使用静态方法作为替代构造函数是一个微小的语法变化，但在组织代码时有巨大的优势。
- en: 'The following is a version of `Hand` with static methods that can be used to
    build new instances of `Hand` from an existing `Hand` instance:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个带有静态方法的`Hand`版本，可以用来从现有的`Hand`实例构建新的`Hand`实例：
- en: '[PRE46]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: One method freezes or creates a memento version. The other method splits a `Hand5`
    instance to create two new child instances of `Hand5`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是冻结或创建一个备忘录版本。另一种方法是拆分一个`Hand5`实例，创建两个新的`Hand5`子实例。
- en: This is considerably more readable and preserves the use of the parameter names
    to explain the interface.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做会更加可读，并保留参数名来解释接口。
- en: 'The following code snippet shows how we can split a `Hand5` instance with this
    version of the class:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用这个类的版本拆分`Hand5`实例：
- en: '[PRE47]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We created an initial `h` instance of `Hand5`, split it into two other hands,
    `s1` and `s2`, and dealt an additional `Card` class into each. The `split()` static
    method is much simpler than the equivalent functionality implemented via `__init__()`.
    However, it doesn't follow the pattern of creating a `fronzenset` object from
    an existing `set` object.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个`Hand5`的初始实例`h`，将其拆分成另外两个手牌`s1`和`s2`，并为每个实例发了一张额外的`Card`类。`split()`静态方法比通过`__init__()`实现的等效功能要简单得多。然而，它不遵循从现有`set`对象创建`fronzenset`对象的模式。
- en: Yet more __init__() techniques
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多的__init__()技术
- en: We'll take a look at a few other, more advanced `__init__()` techniques. These
    aren't quite so universally useful as the techniques in the previous sections.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些其他更高级的`__init__()`技术。这些技术并不像前面的技术那样普遍有用。
- en: 'The following is a definition for the `Player` class that uses two strategy
    objects and a `table` object. This shows an unpleasant-looking `__init__()` method:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用两个策略对象和一个`table`对象的`Player`类的定义。这显示了一个看起来不太好的`__init__()`方法：
- en: '[PRE48]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `__init__()` method for `Player` seems to do little more than bookkeeping.
    We're simply transferring named parameters to same-named instance variables. If
    we have numerous parameters, simply transferring the parameters into the internal
    variables will amount to a lot of redundant-looking code.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Player`的`__init__()`方法似乎只是做一些簿记工作。我们只是将命名参数传递给同名的实例变量。如果有很多参数，简单地将参数传递到内部变量中将会产生大量看起来多余的代码。'
- en: 'We can use this `Player` class (and related objects) as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用这个`Player`类（和相关对象）：
- en: '[PRE49]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: We can provide a very short and very flexible initialization by simply transferring
    keyword argument values directly into the internal instance variables.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将关键字参数值直接传递到内部实例变量中，我们可以提供一个非常简短和非常灵活的初始化。
- en: 'The following is a way to build a `Player` class using keyword argument values:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用关键字参数值构建`Player`类的方法：
- en: '[PRE50]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This sacrifices a great deal of readability for succinctness. It crosses over
    into a realm of potential obscurity.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这牺牲了很多可读性以换取简洁性。它跨越了潜在的晦涩领域。
- en: 'Since the `__init__()` method is reduced to one line, it removes a certain
    level of "wordiness" from the method. This wordiness, however, is transferred
    to each individual object constructor expression. We have to add the keywords
    to the object initialization expression since we''re no longer using positional
    parameters, as shown in the following code snippet:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`__init__()`方法被简化为一行，它从方法中删除了一定程度的“啰嗦”。然而，这种啰嗦转移到了每个单独的对象构造表达式。由于我们不再使用位置参数，我们必须向对象初始化表达式添加关键字，如下面的代码片段所示：
- en: '[PRE51]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Why do this?
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这样做？
- en: It does have a *potential* advantage. A class defined like this is quite open
    to extension. We can, with only a few specific worries, supply additional keyword
    parameters to a constructor.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实有一个*潜在*的优势。像这样定义的类非常容易扩展。我们只需担心一些特定的问题，就可以向构造函数提供额外的关键字参数。
- en: 'The following is the expected use case:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是预期的用例：
- en: '[PRE52]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The following is a bonus use case:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个额外的用例：
- en: '[PRE53]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We've added a `log_name` attribute without touching the class definition. This
    can be used, perhaps, as part of a larger statistical analysis. The `Player2.log_name`
    attribute can be used to annotate logs or other collected data.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`log_name`属性，而没有触及类定义。这可以用作更大的统计分析的一部分。`Player2.log_name`属性可用于注释日志或其他收集的数据。
- en: We are limited in what we can add; we can only add parameters that fail to conflict
    with the names already in use within the class. Some knowledge of the class implementation
    is required to create a subclass that doesn't abuse the set of keywords already
    in use. Since the `**kw` parameter provides little information, we need to read
    carefully. In most cases, we'd rather trust the class to work than review the
    implementation details.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在添加内容方面受到限制；我们只能添加与类内已使用的名称冲突的参数。需要一些了解类实现的知识才能创建一个不滥用已使用的关键字集的子类。由于`**kw`参数提供的信息很少，我们需要仔细阅读。在大多数情况下，我们宁愿相信类能够正常工作，而不是审查实现细节。
- en: This kind of keyword-based initialization can be done in a superclass definition
    to make it slightly simpler for the superclass to implement subclasses. We can
    avoiding writing an additional `__init__()` method in each subclass when the unique
    feature of the subclass involves simple new instance variables.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于关键字的初始化可以在超类定义中完成，以使超类更容易实现子类。当子类的独特特性涉及简单的新实例变量时，我们可以避免在每个子类中编写额外的`__init__()`方法。
- en: The disadvantage of this is that we have obscure instance variables that aren't
    formally documented via a subclass definition. If it's only one small variable,
    an entire subclass might be too much programming overhead to add a single variable
    to a class. However, one small variable often leads to a second and a third. Before
    long, we'll realize that a subclass would have been smarter than an extremely
    flexible superclass.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，我们有一些不是通过子类定义正式记录的晦涩实例变量。如果只有一个小变量，那么为了向类添加一个变量，整个子类可能是太多的编程开销。然而，一个小变量往往会导致第二个和第三个。不久之后，我们会意识到，与极其灵活的超类相比，一个子类会更明智。
- en: 'We can (and should) hybridize this with a mixed positional and keyword implementation
    as shown in the following code snippet:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以（也应该）将其与混合位置和关键字实现相结合，如下面的代码片段所示：
- en: '[PRE54]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This is more sensible than a completely open definition. We've made the required
    parameters positional parameters. We've left any nonrequired parameters as keywords.
    This clarifies the use of any extra keyword arguments given to the `__init__()`
    method.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这比完全开放的定义更明智。我们已经将必需的参数作为位置参数。我们将任何非必需的参数留作关键字。这澄清了传递给`__init__()`方法的任何额外关键字参数的用法。
- en: This kind of flexible, keyword-based initialization depends on whether we have
    relatively transparent class definitions. This openness to change requires some
    care to avoid debugging name clashes because the keyword parameter names are open-ended.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活的、基于关键字的初始化取决于我们是否有相对透明的类定义。这种开放性需要一些小心，以避免由于关键字参数名称是开放式的而导致调试名称冲突。
- en: Initialization with type validation
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 带有类型验证的初始化
- en: Type validation is rarely a sensible requirement. In a way, this might be a
    failure to fully understand Python. The notional objective is to validate that
    all of the arguments are of a *proper* type. The issue with trying to do this
    is that the definition of *proper* is often far too narrow to be truly useful.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 类型验证很少是一个明智的要求。在某种程度上，这可能是对Python的不完全理解。概念上的目标是验证所有参数都是*适当*类型的。尝试这样做的问题在于，*适当*的定义通常太狭窄，以至于真正有用。
- en: This is different from validating that objects meet other criteria. Numeric
    range checking, for example, may be essential to prevent infinite loops.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这与验证对象是否符合其他标准是不同的。例如，数字范围检查可能是必要的，以防止无限循环。
- en: 'What can create problems is trying to do something like the following in an
    `__init__()` method:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出问题的是尝试在`__init__()`方法中做以下操作：
- en: '[PRE55]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `isinstance()` method checks circumvent Python's normal **duck typing**.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`isinstance()`方法检查规避了Python正常的**鸭子类型**。'
- en: We write a casino game simulation in order to experiment with endless variations
    on `GameStrategy`. These are so simple (merely four methods) that there's little
    real benefit from inheritance from the superclass. We could define the classes
    independently, lacking an overall superclass.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写一个赌场游戏模拟，以便尝试对`GameStrategy`进行无尽的变化。这些变化如此简单（仅仅四种方法），以至于从超类继承几乎没有真正的好处。我们可以独立定义这些类，没有整体的超类。
- en: The initialization error-checking shown in this example would force us to create
    subclasses merely to pass the error check. No usable code is inherited from the
    abstract superclass.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中所示的初始化错误检查将迫使我们创建子类，仅仅是为了通过错误检查。没有从抽象超类继承可用的代码。
- en: 'One of the biggest duck typing issues surrounds numeric types. Different numeric
    types will work in different contexts. Attempts to validate the types of arguments
    may prevent a perfectly sensible numeric type from working properly. When attempting
    validation, we have the following two choices in Python:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的鸭子类型问题之一涉及数字类型。不同的数字类型将在不同的上下文中起作用。尝试验证参数的类型可能会阻止一个完全合理的数字类型正常工作。在尝试验证时，我们在Python中有以下两种选择：
- en: We write validation so that a relatively narrow collection of types is permitted,
    and someday the code will break because a new type that would have worked sensibly
    is prohibited
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们进行验证，以便允许相对狭窄的类型集合，并且有一天，代码会因为禁止了本来可以合理工作的新类型而出错
- en: We eschew validation so that a broad collection of types is permitted, and someday
    the code will break because a type that would not work sensibly was used
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们避免验证，以便允许广泛的类型集合，并且有一天，代码会因为使用了不合理的类型而出错
- en: Note that both are essentially the same. The code could perhaps break someday.
    It either breaks because a type was prevented from being used even though it's
    sensible or a type that's not really sensible was used.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，两者本质上是一样的。代码可能会在某一天出现问题。它可能会因为某种类型被阻止使用而导致问题，即使它是合理的，或者使用了一种不太合理的类型。
- en: Tip
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Just allow it**'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '**只是允许它**'
- en: Generally, it's considered better Python style to simply permit any type of
    data to be used.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，被认为更好的Python风格是允许任何类型的数据被使用。
- en: We'll return to this in [Chapter 4](ch04.html "Chapter 4. The ABCs of Consistent
    Design"), *The ABCs of Consistent Design*.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第4章](ch04.html "第4章。一致设计的ABC")*一致设计的ABC*中回到这一点。
- en: 'The question is this: why restrict potential future use cases?'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是：为什么要限制潜在的未来用例？
- en: And the usual answer is that there's no good reason to restrict potential future
    use cases.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的答案是没有好的理由限制潜在的未来用例。
- en: Rather than prevent a sensible, but possibly unforeseen, use case, we can provide
    documentation, testing, and debug logging to help other programmers understand
    any restrictions on the types that can be processed. We have to provide the documentation,
    logging, and test cases anyway, so there's minimal additional work involved.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 与其阻止一个合理的，但可能是意想不到的用例，我们可以提供文档、测试和调试日志，以帮助其他程序员理解可以处理的类型的任何限制。我们必须提供文档、日志和测试用例，所以涉及的额外工作很少。
- en: 'The following is an example docstring that provides the expectations of the
    class:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个提供类期望的示例文档字符串：
- en: '[PRE56]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The programmer using this class has been warned about what the type restrictions
    are. The use of other types is permitted. If the type isn't compatible with the
    expected type, then things will break. Ideally, we'll use too like `unittest`
    or `doctest` to uncover the breakage.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个类的程序员已经被警告了类型限制是什么。允许使用其他类型。如果类型与预期类型不兼容，那么事情将会出错。理想情况下，我们将使用像`unittest`或`doctest`这样的工具来发现错误。
- en: Initialization, encapsulation, and privacy
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化、封装和隐私
- en: 'The general Python policy regarding privacy can be summed up as follows: *we''re
    all adults here*.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 关于隐私的一般Python政策可以总结如下：*我们都是成年人*。
- en: Object-oriented design makes an explicit distinction between interface and implementation.
    This is a consequence of the idea of encapsulation. A class encapsulates a data
    structure, an algorithm, an external interface, or something meaningful. The idea
    is to have the capsule separate the class-based interface from the implementation
    details.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象设计明确区分了接口和实现。这是封装思想的一个结果。一个类封装了一个数据结构、一个算法、一个外部接口或者其他有意义的东西。这个想法是让胶囊将基于类的接口与实现细节分开。
- en: However, no programming language reflects every design nuance. Python, typically,
    doesn't implement all design considerations as explicit code.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有一种编程语言能反映出每一个设计细微之处。通常情况下，Python不会将所有设计考虑作为显式代码实现。
- en: One aspect of a class design that is not fully carried into code is the distinction
    between the *private* (implementation) and *public* (interface) methods or attributes
    of an object. The notion of privacy in languages that support it (C++ or Java
    are two examples) is already quite complex. These languages include settings such
    as private, protected, and public as well as "not specified", which is a kind
    of semiprivate. The private keyword is often used incorrectly, making subclass
    definition needlessly difficult.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有完全体现在代码中的类设计方面是对象的*私有*（实现）和*公共*（接口）方法或属性之间的区别。在支持它的语言中（C++或Java是两个例子），隐私的概念已经相当复杂。这些语言包括私有、受保护和公共等设置，以及“未指定”，这是一种半私有。私有关键字经常被错误地使用，使得子类定义变得不必要地困难。
- en: 'Python''s notion of privacy is simple, as follows:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: Python对隐私的概念很简单，如下所示：
- en: It's all *essentially* public. The source code is available. We're all adults.
    Nothing can be truly hidden.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都是*基本上*公开的。源代码是可用的。我们都是成年人。没有什么是真正隐藏的。
- en: Conventionally, we'll treat some names in a way that's less public. They're
    generally implementation details that are subject to change without notice, but
    there's no formal notion of private.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，我们会以不太公开的方式对待一些名称。它们通常是可能会在没有通知的情况下发生变化的实现细节，但没有正式的私有概念。
- en: Names that begin with `_` are honored as less public by some parts of Python.
    The `help()` function generally ignores these methods. Tools such as Sphinx can
    conceal these names from documentation.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 以`_`开头的名称在Python的某些部分被认为是不太公开的。`help()`函数通常会忽略这些方法。像Sphinx这样的工具可以将这些名称从文档中隐藏起来。
- en: Python's internal names begin (and end) with `__`. This is how Python internals
    are kept from colliding with application features above the internals. The collection
    of these internal names is fully defined by the language reference. Further, there's
    no benefit to trying to use `__` to attempt to create a "super private" attribute
    or method in our code. All that happens is that we create a potential future problem
    if a release of Python ever starts using a name we chose for internal purposes.
    Also, we're likely to run afoul of the internal name mangling that is applied
    to these names.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内部名称以`__`开头（和结尾）。这是Python内部与上面的应用程序功能不发生冲突的方式。这些内部名称的集合完全由语言参考定义。此外，尝试使用`__`在我们的代码中创建“超级私有”属性或方法没有任何好处。所有会发生的是，如果Python的一个版本开始使用我们为内部目的选择的名称，我们就会创建潜在的未来问题。此外，我们很可能会违反对这些名称应用的内部名称混淆。
- en: 'The rules for the visibility of Python names are as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: Python名称的可见性规则如下：
- en: Most names are public.
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数名称都是公开的。
- en: Names that start with `_` are somewhat less public. Use them for implementation
    details that are truly subject to change.
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`_`开头的名称稍微不太公开。将它们用于真正可能会发生变化的实现细节。
- en: Names that begin and end with `__` are internal to Python. We never make these
    up; we use the names defined by the language reference.
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以`__`开头和结尾的名称是Python内部的。我们从不自己创造这些名字；我们使用语言参考中定义的名字。
- en: Generally, the Python approach is to register the intent of a method (or attribute)
    using documentation and a well-chosen name. Often, the interface methods will
    have elaborate documentation, possibly including `doctest` examples, while the
    implementation methods will have more abbreviated documentation and may not have
    `doctest` examples.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，Python的方法是使用文档和精心选择的名称来注册方法（或属性）的意图。通常，接口方法将有详细的文档，可能包括`doctest`示例，而实现方法将有更简略的文档，可能没有`doctest`示例。
- en: For programmers new to Python, it's sometimes surprising that privacy is not
    more widely used. For programmers experienced in Python, it's surprising how many
    brain calories get burned sorting out private and public declarations that aren't
    really very helpful because the intent is obvious from the method names and the
    documentation.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 对于刚接触Python的程序员来说，隐私并没有被广泛使用有时会令人惊讶。对于有经验的Python程序员来说，令人惊讶的是有多少大脑能量被用来解决并不真正有帮助的私有和公共声明，因为方法名称和文档的意图是显而易见的。
- en: Summary
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have reviewed the various design alternatives of the `__init__()`
    method. In the next chapter, we will take a look at the special methods, along
    with a few advanced ones as well.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经回顾了`__init__()`方法的各种设计替代方案。在下一章中，我们将研究特殊方法，以及一些高级方法。
- en: Chapter 2. Integrating Seamlessly with Python Basic Special Methods
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。与Python基本特殊方法无缝集成
- en: There are a number of special methods that permit close integration between
    our classes and Python. *Standard Library Reference* calls them **basic**. A better
    term might be *foundational* or *essential*. These special methods form a foundation
    for building classes that seamlessly integrate with other Python features.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多特殊方法允许我们的类与Python之间进行紧密集成。*标准库参考*将它们称为**基本**。更好的术语可能是*基础*或*必要*。这些特殊方法为构建与其他Python功能无缝集成的类奠定了基础。
- en: For example, we need string representations of a given object's value. The base
    class, `object`, has a default implementation of `__repr__()` and `__str__()`
    that provides string representations of an object. Sadly, these default representations
    are remarkably uninformative. We'll almost always want to override one or both
    of these default definitions. We'll also look at `__format__()`, which is a bit
    more sophisticated but serves the same purpose.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们需要给定对象值的字符串表示。基类`object`有一个`__repr__()`和`__str__()`的默认实现，提供对象的字符串表示。遗憾的是，这些默认表示非常不具信息性。我们几乎总是希望覆盖其中一个或两个默认定义。我们还将研究`__format__()`，它更复杂一些，但具有相同的目的。
- en: 'We''ll also look at other conversions, specifically `__hash__()`, `__bool__()`,
    and `__bytes__()`. These methods will convert an object into a number, a true/false
    value, or a string of bytes. When we implement `__bool__()`, for example, we can
    use our object in an `if` statement as follows: `if someobject:`.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究其他转换，特别是`__hash__()`，`__bool__()`和`__bytes__()`。这些方法将对象转换为数字、真/假值或字节字符串。例如，当我们实现`__bool__()`时，我们可以在`if`语句中使用我们的对象：`if
    someobject:`。
- en: Then, we can look at the special methods that implement the comparison operators
    `__lt__()`, `__le__()`, `__eq__()`, `__ne__()`, `__gt__()`, and `__ge__()`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以查看实现比较运算符`__lt__()`、`__le__()`、`__eq__()`、`__ne__()`、`__gt__()`和`__ge__()`的特殊方法。
- en: These basic special methods are almost always needed in class definitions.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本特殊方法几乎总是需要在类定义中。
- en: We'll look at `__new__()` and `__del__()` last because the use cases for these
    methods are rather complex. We don't need these as often as we need the other
    basic special methods.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将最后查看`__new__()`和`__del__()`，因为这些方法的用例相当复杂。我们不需要这些方法的频率与我们需要其他基本特殊方法的频率一样高。
- en: We'll look in detail at how we can expand a simple class definition to add these
    special methods. We'll need to look at both the default behaviors inherited from
    object so that we can understand what overrides are needed and when they're actually
    needed.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细研究如何扩展简单的类定义以添加这些特殊方法。我们需要查看从对象继承的默认行为，以便了解需要覆盖哪些以及何时实际需要覆盖。
- en: The __repr__() and __str__() methods
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__repr__()`和`__str__()`方法'
- en: Python has two string representations of an object. These are closely aligned
    with the built-in functions `repr()`, `str()`, `print()`, and the `string.format()`
    method.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Python有两种对象的字符串表示。这些与内置函数`repr()`、`str()`、`print()`和`string.format()`方法密切相关。
- en: Generally, the `str()` method representation of an object is commonly expected
    to be more friendly to humans. This is built by an object's `__str__()` method.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般来说，对象的`str()`方法表示通常被期望对人更友好。这是通过对象的`__str__()`方法构建的。
- en: 'The `repr()` method representation is often going to be more technical, perhaps
    even a complete Python expression to rebuild the object. The documentation says:'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr()`方法的表示通常会更加技术性，甚至可能是一个完整的Python表达式来重建对象。文档中说：'
- en: For many types, this function makes an attempt to return a string that would
    yield an object with the same value when passed to `eval()`.
  id: totrans-382
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于许多类型，此函数尝试返回一个字符串，当传递给`eval()`时将产生相同值的对象。
- en: This is built by an object's `__repr__()` method.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过对象的`__repr__()`方法构建的。
- en: The `print()` function will use `str()` to prepare an object for printing.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print()`函数将使用`str()`来准备对象进行打印。'
- en: The `format()` method of a string can also access these methods. When we use
    `{!r}` or `{!s}` formatting, we're requesting `__repr__()` or `__str__()`, respectively.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串的`format()`方法也可以访问这些方法。当我们使用`{!r}`或`{!s}`格式化时，我们分别请求`__repr__()`或`__str__()`。
- en: Let's look at the default implementations first.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看默认实现。
- en: 'The following is a simple class hierarchy:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的类层次结构：
- en: '[PRE57]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We've defined two simple classes with four attributes in each class.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了两个简单的类，每个类中有四个属性。
- en: 'The following is an interaction with an object of one of these classes:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与这些类中的一个对象的交互：
- en: '[PRE58]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We can see from this output that the default implementations of `__str__()`
    and `__repr__()` are not very informative.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从这个输出中看到，`__str__()`和`__repr__()`的默认实现并不是非常有信息性的。
- en: 'There are two broad design cases that we consider when overriding `__str__()`
    and `__repr__()`:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重写`__str__()`和`__repr__()`时，有两种广泛的设计情况：
- en: '**Non-collection objects**: A "simple" object doesn''t contain a collection
    of other objects and generally doesn''t involve very complex formatting of that
    collection'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非集合对象**：一个“简单”的对象不包含其他对象的集合，通常也不涉及对该集合的非常复杂的格式化'
- en: '**Collection objects**: An object that contains a collection involves somewhat
    more complex formatting'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合对象**：包含集合的对象涉及到更复杂的格式化'
- en: Non collection __str__() and __repr__()
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非集合__str__()和__repr__()
- en: 'As we saw previously, the output from `__str__()` and `__repr__()` are not
    very informative. We''ll almost always need to override them. The following is
    an approach to override `__str__()` and `__repr__()` when there''s no collection
    involved. These methods belong to the `Card` class, defined previously:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，`__str__()`和`__repr__()`的输出并不是非常有信息性的。我们几乎总是需要重写它们。以下是在没有涉及集合时重写`__str__()`和`__repr__()`的方法。这些方法属于之前定义的`Card`类：
- en: '[PRE59]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: These two methods rely on passing the object's internal instance variable dictionary,
    `__dict__`, to the `format()` function. This isn't appropriate for objects that
    use `__slots__`; often, these are immutable objects. The use of names in the format
    specifications makes the formatting more explicit. It also makes the format template
    longer. In the case of `__repr__()`, we passed in the internal `__dict__` plus
    the object's `__class__` as keyword argument values to the `format()` function.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法依赖于将对象的内部实例变量字典`__dict__`传递给`format()`函数。这对于使用`__slots__`的对象不合适；通常，这些是不可变对象。在格式规范中使用名称使得格式更加明确。它还使格式模板变得更长。在`__repr__()`的情况下，我们传递了内部的`__dict__`加上对象的`__class__`作为关键字参数值传递给`format()`函数。
- en: 'The template string uses two kinds of format specifications:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 模板字符串使用了两种格式规范：
- en: The `{__class__.__name__}` template that could also be written as `{__class__.__name__!s}`
    to be more explicit about providing a simple string version of the class name
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{__class__.__name__}`模板也可以写为`{__class__.__name__!s}`，以更明确地提供类名的简单字符串版本'
- en: The `{suit!r}` and `{rank!r}` template both use the `!r` format specification
    to produce the `repr()` method of the attribute values
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`{suit!r}`和`{rank!r}`模板都使用`!r`格式规范来生成属性值的`repr()`方法'
- en: In the case of `__str__()`, we've only passed the object's internal `__dict__`.
    The formatting uses implicit `{!s}` format specifications to produce the `str()`
    method of the attribute values.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__str__()`的情况下，我们只传递了对象的内部`__dict__`。格式化使用了隐式的`{!s}`格式规范来生成属性值的`str()`方法。
- en: Collection __str__() and __repr__()
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合__str__()和__repr__()
- en: 'When there''s a collection involved, we need to format each individual item
    in the collection as well as the overall container for those items. The following
    is a simple collection with both `__str__()` and `__repr__()` methods:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到集合时，我们需要格式化集合中的每个单独项目以及这些项目的整体容器。以下是一个具有`__str__()`和`__repr__()`方法的简单集合：
- en: '[PRE60]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The `__str__()` method is a simple recipe, as follows:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`__str__()`方法是一个简单的配方，如下所示：'
- en: Map `str()` to each item in the collection. This will create an iterator over
    the resulting string values.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`str()`映射到集合中的每个项目。这将创建一个迭代器，遍历生成的字符串值。
- en: Use `", ".join()` to merge all the item strings into a single, long string.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`, `.join()`将所有项目字符串合并成一个单一的长字符串。
- en: 'The `__repr__()` method is a multiple-part recipe, as follows:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__()`方法是一个多部分的配方，如下所示：'
- en: Map `repr()` to each item in the collection. This will create an iterator over
    the resulting string values.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`repr()`映射到集合中的每个项目。这将创建一个迭代器，遍历生成的字符串值。
- en: Use `", ".join()` to merge all the item strings.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`, `.join()`将所有项目字符串合并在一起。
- en: Create a set of keywords with `__class__`, the collection string, and the various
    attributes from `__dict__`. We've named the collection string `_cards_str` so
    that it doesn't conflict with an existing attribute.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`__class__`、集合字符串和`__dict__`中的各种属性创建一组关键字。我们将集合字符串命名为`_cards_str`，以避免与现有属性冲突。
- en: Use `"{__class__.__name__}({dealer_card!r}, {_cards_str})".format()` to combine
    the class name and the long string of item values. We use the `!r` formatting
    to ensure that the attribute uses the `repr()` conversion too.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`"{__class__.__name__}({dealer_card!r}, {_cards_str})".format()`来组合类名和项目值的长字符串。我们使用`!r`格式化来确保属性也使用`repr()`转换。
- en: In some cases, this can be optimized and made somewhat simpler. Use of positional
    arguments for the formatting can somewhat shorten the template string.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，这可以被优化并变得更简单。使用位置参数进行格式化可以在一定程度上缩短模板字符串。
- en: The __format__() method
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __format__()方法
- en: The `__format__()` method is used by `string.format()` as well as the `format()`
    built-in function. Both of these interfaces are used to get presentable string
    versions of a given object.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`__format__()`方法被`string.format()`和`format()`内置函数使用。这两个接口都用于获取给定对象的可呈现字符串版本。'
- en: 'The following are the two ways in which arguments will be presented to `__format__()`:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是参数将被呈现给`__format__()`的两种方式：
- en: '`someobject.__format__("")`: This happens when the application does `format(someobject)`
    or something equivalent to `"{0}".format(someobject)`. In these cases, a zero-length
    string specification was provided. This should produce a default format.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someobject.__format__("")`：当应用程序执行`format(someobject)`或类似于`"{0}".format(someobject)`时会发生这种情况。在这些情况下，提供了一个零长度的字符串规范。这应该产生一个默认格式。'
- en: '`someobject.__format__(specification)`: This happens when the application does
    `format(someobject, specification)` or something equivalent to `"{0:specification}".format(someobject)`.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`someobject.__format__(specification)`：当应用程序执行`format(someobject, specification)`或类似于`"{0:specification}".format(someobject)`时会发生这种情况。'
- en: Note that something equivalent to `"{0!r}".format()` or `"{0!s}".format()` doesn't
    use the `__format__()` method. These use `__repr__()` or `__str__()` directly.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，类似于`"{0!r}".format()`或`"{0!s}".format()`并不使用`__format__()`方法。这些直接使用`__repr__()`或`__str__()`。
- en: With a specification of `""`, a sensible response is `return str(self)`. This
    provides an obvious consistency between the various string representations of
    an object.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`""`作为规范，一个明智的响应是`return str(self)`。这提供了一个明显的一致性，使对象的各种字符串表示之间保持一致。
- en: The format specification will be all the text after the `":"` in a format string.
    When we write `"{0:06.4f}"`, the `06.4f` is the format specification that applies
    to item `0` of the argument list to be formatted.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 格式规范将是格式字符串中`":"`后面的所有文本。当我们写`"{0:06.4f}"`时，`06.4f`是应用于要格式化的参数列表中的项目`0`的格式规范。
- en: 'Section 6.1.3.1 of the *Python Standard Library* documentation defines a sophisticated
    numeric specification as a nine-part string. This is the format specification
    mini-language. It has the following syntax:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python标准库*文档的6.1.3.1节定义了一个复杂的数值规范，它是一个九部分的字符串。这是格式规范迷你语言。它具有以下语法：'
- en: '[PRE61]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can parse these standard specifications with a **regular expression** (**RE**)
    as shown in the following code snippet:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用**正则表达式**（**RE**）来解析这些标准规范，如下面的代码片段所示：
- en: '[PRE62]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This RE will break the specification into eight groups. The first group will
    have both the `fill` and `alignment` fields from the original specification. We
    can use these groups to work out the formatting for the numeric data of the classes
    that we've defined.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这个RE将规范分成八组。第一组将包括原始规范中的`fill`和`alignment`字段。我们可以使用这些组来解决我们定义的类的数字数据的格式化问题。
- en: However, Python's format specification mini-language might not apply very well
    to the classes that we've defined. Therefore, we might need to define our own
    specification mini-language and process it in our class `__format__()` method.
    If we're defining numeric types, we should stick to the predefined mini-language.
    For other types, however, there's no reason to stick to the predefined language.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Python的格式规范迷你语言可能不太适用于我们定义的类。因此，我们可能需要定义自己的规范迷你语言，并在我们的类`__format__()`方法中处理它。如果我们正在定义数值类型，我们应该坚持预定义的迷你语言。然而，对于其他类型，没有理由坚持预定义的语言。
- en: As an example, here's a trivial language that uses the character `%r` to show
    us the rank and the character `%s` to show us the suit. The `%%` character becomes
    `%` in the resulting string. All other characters are repeated literally.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这是一个使用字符`%r`来显示等级和字符`%s`来显示花色的微不足道的语言。结果字符串中的`%%`字符变成`%`。所有其他字符都被字面重复。
- en: 'We could extend our `Card` class with formatting as shown in the following
    code snippet:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展我们的`Card`类，如下面的代码片段所示：
- en: '[PRE63]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This definition checks for a format specification. If there's no specification,
    then the `str()` function is used. If a specification was provided, a series of
    replacements is done to fold rank, suit, and any `%` characters into the format
    specification, turning it into the output string.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义检查格式规范。如果没有规范，则使用`str()`函数。如果提供了规范，则进行一系列替换，将等级、花色和任何`%`字符折叠到格式规范中，将其变成输出字符串。
- en: 'This allows us to format cards as follows:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够按照以下方式格式化卡片：
- en: '[PRE64]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The format specification (`"%r of %s"`) is passed to our `__format__()` method
    as the `format` parameter. Using this, we're able to provide a consistent interface
    for the presentation of the objects of the classes that we've defined.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 格式规范(`"%r of %s"`)作为`format`参数传递给我们的`__format__()`方法。使用这个，我们能够为我们定义的类的对象的呈现提供一个一致的接口。
- en: 'Alternatively, we can define things as follows:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以定义如下：
- en: '[PRE65]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This has the advantage of putting all string presentations into the `__format__()`
    method instead of spreading it between `__format__()` and `__str__()`. This has
    a disadvantage because we don't always need to implement `__format__()`, but we
    almost always need to implement `__str__()`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是将所有字符串表示都放入`__format__()`方法中，而不是在`__format__()`和`__str__()`之间分散。这有一个缺点，因为我们并不总是需要实现`__format__()`，但我们几乎总是需要实现`__str__()`。
- en: Nested formatting specifications
  id: totrans-440
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 嵌套格式规范
- en: The `string.format()` method can handle nested instances of `{}` to perform
    simple keyword substitution into the format specification. This replacement is
    done to create the final format string that's passed to our class `__format__()`
    method. This kind of nested substitution simplifies some kinds of relatively complex
    numeric formatting by parameterizing an otherwise generic specification.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`string.format()`方法可以处理`{}`的嵌套实例，以执行简单的关键字替换到格式规范中。这种替换是为了创建最终的格式字符串，该字符串传递给我们的类`__format__()`方法。这种嵌套替换简化了一些相对复杂的数值格式化，通过对本来是通用规范的参数化。'
- en: 'The following is an example where we''ve made `width` easy to change in the
    `format` parameter:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，我们已经在`format`参数中使`width`易于更改：
- en: '[PRE66]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We've defined a generic format, `"{hand:%r%s} {count:{width}d}"`, which requires
    a `width` parameter to make it into a proper format specification.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个通用格式，`"{hand:%r%s} {count:{width}d}"`，它需要一个`width`参数来将其转换为一个适当的格式规范。
- en: The value provided with the `width=` parameter to the `format()` method is used
    to replace the `{width}` nested specification. Once this is replaced, the final
    format as a whole is provided to the `__format__()` method.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 提供给`format()`方法的`width=`参数的值用于替换`{width}`嵌套规范。一旦替换了这个值，整个最终格式将提供给`__format__()`方法。
- en: Collections and delegating format specifications
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集合和委托格式规范
- en: 'When formatting a complex object that includes a collection, we have two formatting
    issues: how to format the overall object and how to format the items in the collection.
    When we look at `Hand`, for example, we see that we have a collection of individual
    `Cards` class. We''d like to have `Hand` delegate some formatting details to the
    individual `Card` instances in the `Hand` collection.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在格式化包含集合的复杂对象时，我们有两个格式化问题：如何格式化整个对象以及如何格式化集合中的项目。例如，当我们看`Hand`时，我们看到我们有一个由单个`Cards`类组成的集合。我们希望`Hand`将一些格式化细节委托给`Hand`集合中的单个`Card`实例。
- en: 'The following is a `__format__()` method that applies to `Hand`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是适用于`Hand`的`__format__()`方法：
- en: '[PRE67]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The `format_specification` parameter will be used for each individual `Card`
    instance within the `Hand` collection. The format specification of `"{0:{fs}}"`
    uses the nested format specification technique to push the `format_specification`
    string to create a format that applies to each `Card` instance. Given this method,
    we can format a `Hand` object, `player_hand`, as follows:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '`format_specification`参数将用于`Hand`集合中的每个`Card`实例。`"{0:{fs}}"`的格式规范使用了嵌套格式规范技术，将`format_specification`字符串推送到创建适用于每个`Card`实例的格式中。有了这种方法，我们可以格式化一个`Hand`对象`player_hand`如下：'
- en: '[PRE68]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will apply the `%r%s` format specification to each `Card` instance of the
    `Hand` object.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对`Hand`对象的每个`Card`实例应用`%r%s`格式规范。
- en: The __hash__() method
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__hash__()`方法'
- en: The built-in `hash()` function invokes the `__hash__()` method of a given object.
    This hash is a calculation which reduces a (potentially complex) value to a small
    integer value. Ideally, a hash reflects all the bits of the source value. Other
    hash calculations—often used for cryptographic purposes—can produce very large
    values.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`hash()`函数调用给定对象的`__hash__()`方法。这个哈希是一个计算，它将一个（可能复杂的）值减少到一个小的整数值。理想情况下，哈希反映了源值的所有位。其他哈希计算——通常用于加密目的——可以产生非常大的值。
- en: 'Python includes two hash libraries. The cryptographic-quality hash functions
    are in `hashlib`. The `zlib` module has two high-speed hash functions: `adler32()`
    and `crc32()`. For relatively simple values, we don''t use either of these. For
    large, complex values, these algorithms can be of help.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: Python包括两个哈希库。加密质量的哈希函数在`hashlib`中。`zlib`模块有两个高速哈希函数：`adler32()`和`crc32()`。对于相对简单的值，我们不使用这两者。对于大型、复杂的值，这些算法可以提供帮助。
- en: The `hash()` function (and the associated `__hash__()` method) is used to create
    a small integer key that is used to work with collections such as `set`, `frozenset`,
    and `dict`. These collections use the hash value of an **immutable** object to
    rapidly locate the object in the collection.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`hash()`函数（以及相关的`__hash__()`方法）用于创建一个小整数键，用于处理诸如`set`、`frozenset`和`dict`之类的集合。这些集合使用**不可变**对象的哈希值来快速定位集合中的对象。'
- en: Immutability is important here; we'll mention it many times. Immutable objects
    don't change their state. The number `3`, for example, doesn't change state. It's
    always `3`. More complex objects, similarly, can have an immutable state. Python
    strings are immutable so that they can be used as keys to mappings and sets.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不可变性很重要；我们会多次提到它。不可变对象不会改变它们的状态。例如，数字`3`不会改变状态。它始终是`3`。同样，更复杂的对象也可以具有不可变的状态。Python字符串是不可变的，因此它们可以用作映射和集合的键。
- en: 'The default `__hash__()` implementation inherited from an object returns a
    value based on the object''s internal ID value. This value can be seen with the
    `id()` function as follows:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 从对象继承的默认`__hash__()`实现返回基于对象内部ID值的值。可以使用`id()`函数来查看这个值，如下所示：
- en: '[PRE69]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: From this, we can see that on the author's particular system, the hash value
    is the object's `id//16`. This detail might vary from platform to platform. CPython,
    for example, uses portable `C` libraries where Jython relies on the Java JVM.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中，我们可以看到在作者特定的系统上，哈希值是对象的`id//16`。这个细节可能因平台而异。例如，CPython使用可移植的`C`库，而Jython依赖于Java
    JVM。
- en: What's essential is that there is a strong correlation between the internal
    ID and the default `__hash__()` method. This means that the default behavior is
    for each object to be hashable as well as utterly distinct, even if it appears
    to have the same value.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是内部ID和默认的`__hash__()`方法之间有很强的相关性。这意味着默认行为是每个对象都是可哈希的，而且即使它们看起来具有相同的值，它们也是完全不同的。
- en: We'll need to modify this if we want to coalesce different objects with the
    same value into a single hashable object. We'll look at an example in the next
    section, where we would like two instances of a single `Card` instance to be treated
    as if they were the same object.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将具有相同值的不同对象合并为单个可散列对象，我们需要修改这个。我们将在下一节中看一个例子，我们希望单个`Card`实例的两个实例被视为同一个对象。
- en: Deciding what to hash
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决定要哈希什么
- en: Not every object should provide a hash value. Specifically, if we're creating
    a class of stateful, mutable objects, the class should *never* return a hash value.
    The definition of `__hash__` should be `None`.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个对象都应该提供哈希值。特别是，如果我们正在创建一个有状态、可变对象的类，该类应该*永远*不返回哈希值。`__hash__`的定义应该是`None`。
- en: Immutable objects, on the other hand, might sensibly return a hash value so
    that the object can be used as the key in a dictionary or a member of a set. In
    this case, the hash value needs to parallel the way the test for equality works.
    It's bad to have objects that claim to be equal and have different hash values.
    The reverse—objects with the same hash that are actually not equal—is acceptable.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，不可变对象可能合理地返回一个哈希值，以便该对象可以用作字典的键或集合的成员。在这种情况下，哈希值需要与相等测试的方式相对应。拥有声称相等但具有不同哈希值的对象是不好的。相反，具有相同哈希值但实际上不相等的对象是可以接受的。
- en: The `__eq__()` method, which we'll also look at in the section on comparison
    operators, is intimately tied up with hashing.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '`__eq__()`方法，我们也将在比较运算符部分进行讨论，与哈希密切相关。'
- en: 'There are three tiers of equality comparison:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 有三个层次的相等比较：
- en: '**Same Hash Value**: This means that two objects could be equal. The hash value
    provides us with a quick check for likely equality. If the hash value is different,
    the two objects cannot possibly be equal, nor can they be the same object.'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相同的哈希值**：这意味着两个对象可能是相等的。哈希值为我们提供了一个快速检查可能相等的方法。如果哈希值不同，这两个对象不可能相等，也不可能是同一个对象。'
- en: '**Compare As Equal**: This means that the hash values must also have been equal.
    This is the definition of the `==` operator. The objects may be the same object.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较为相等**：这意味着哈希值也必须相等。这是`==`运算符的定义。对象可能是同一个对象。'
- en: '**Same IDD**: This means that they are the same object. They also compare as
    equal and will have the same hash value. This is the definition of the `is` operator.'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相同的IDD**：这意味着它们是同一个对象。它们也比较为相等，并且将具有相同的哈希值。这是`is`运算符的定义。'
- en: 'The **Fundamental Law of Hash** (**FLH**) is this: objects that compare as
    equal have the same hash value.'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希基本定律**（**FLH**）是这样的：比较为相等的对象具有相同的哈希值。'
- en: We can think of a hash comparison as being the first step in an equality test.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将哈希比较视为相等测试的第一步。
- en: The inverse, however, is not true. Objects can have the same hash value but
    compare as not equal. This is valid and leads to some expected processing overhead
    when creating sets or dictionaries. We can't reliably create distinct 64 bit hash
    values from much larger data structures. There will be unequal objects that are
    reduced to coincidentally equal hash values.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，反之不成立。对象可以具有相同的哈希值，但比较为不相等。这是有效的，并且在创建集合或字典时会导致一些预期的处理开销。我们无法可靠地从更大的数据结构中创建不同的64位哈希值。将会有不相等的对象被减少为巧合相等的哈希值。
- en: Coincidentally, equal hash values are an expected overhead when working with
    `sets` and `dicts`. These collections have internal algorithms to use alternate
    locations in the event of hash collisions.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 巧合的是，当使用`sets`和`dicts`时，相等的哈希值是预期的开销。这些集合具有内部算法，以在哈希冲突发生时使用备用位置。
- en: 'There are three use cases for defining equality tests and hash values via the
    `__eq__()` and `__hash__()` method functions:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`__eq__()`和`__hash__()`方法函数定义相等测试和哈希值有三种用例：
- en: '**Immutable objects**: These are stateless objects of types such as tuples,
    namedtuples, and frozensets that cannot be updated. We have two choices:'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可变对象**：这些是无状态对象，如元组、命名元组和不可变集合的类型，不能被更新。我们有两种选择：'
- en: Define neither `__hash__()` nor `__eq__()`. This means doing nothing and using
    the inherited definitions. In this case, `__hash__()` returns a trivial function
    of the ID value for the object, and `__eq__()` compares the ID values. The default
    equality test may sometimes be counterintuitive. Our application might require
    two instances of `Card( 1, Clubs )` to test as equal and compute the same hash;
    this won't happen by default.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 既不定义`__hash__()`也不定义`__eq__()`。这意味着什么都不做，使用继承的定义。在这种情况下，`__hash__()`返回对象的ID值的一个微不足道的函数，`__eq__()`比较ID值。默认的相等测试有时可能令人费解。我们的应用程序可能需要两个`Card(1,Clubs)`实例测试为相等并计算相同的哈希；这不会默认发生。
- en: Define both `__hash__()` and `__eq__()`. Note that we're expected to define
    both for an immutable object.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时定义`__hash__()`和`__eq__()`。请注意，对于不可变对象，我们期望同时定义两者。
- en: '**Mutable objects**: These are stateful objects that can be modified internally.
    We have one design choice:'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可变对象**：这些是可以在内部修改的有状态对象。我们有一个设计选择：'
- en: Define `__eq__()` but set `__hash__` to `None`. These cannot be used as `dict`
    keys or items in `sets`.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义`__eq__()`但将`__hash__`设置为`None`。这些不能用作`dict`键或`sets`中的项目。
- en: 'Note that there''s an additional possible combination: defining `__hash__()`
    but using a default definition for `__eq__()`. This is simply a waste of code,
    as the default `__eq__()` method is the same as the `is` operator. The default
    `__hash__()` method would have involved writing less code for the same behavior.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，还有一个额外的可能组合：定义`__hash__()`但使用默认的`__eq__()`定义。这只是浪费代码，因为默认的`__eq__()`方法与`is`运算符相同。默认的`__hash__()`方法将涉及编写更少的代码以实现相同的行为。
- en: We'll look at each of the three situations in detail.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细讨论这三种情况。
- en: Inheriting definitions for immutable objects
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承不可变对象的定义
- en: 'Let''s see how the default definitions operate. The following is a simple class
    hierarchy that uses the default definitions of `__hash__()` and `__eq__()`:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看默认定义是如何运作的。以下是一个使用`__hash__()`和`__eq__()`的默认定义的简单类层次结构：
- en: '[PRE70]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This is a class hierarchy for *philosophically* immutable objects. We haven't
    taken care to implement the special methods that prevent the attributes from getting
    updated. We'll look at attribute access in the next chapter.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个*哲学上*不可变对象的类层次结构。我们没有注意实现特殊方法来防止属性被更新。我们将在下一章中讨论属性访问。
- en: 'Let''s see what happens when we use this class hierarchy:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们使用这个类层次结构时会发生什么：
- en: '[PRE71]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We defined two instances of what appear to be the same `Card` instance. We
    can check the `id()` values as shown in the following code snippet:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个看起来是相同的`Card`实例。我们可以检查`id()`值，如下面的代码片段所示：
- en: '[PRE72]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: They have different `id()` numbers; they're distinct objects. This meets our
    expectations.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有不同的`id()`编号；它们是不同的对象。这符合我们的期望。
- en: 'We can check to see if they''re the same using the `is` operator as shown in
    the following code snippet:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`is`运算符来检查它们是否相同，如下面的代码片段所示：
- en: '[PRE73]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The "is test" is based on the `id()` numbers; it shows us that they are indeed
    separate objects.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: “is测试”是基于`id()`编号的；它显示它们确实是不同的对象。
- en: 'We can see that their hash values are different from each other:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它们的哈希值彼此不同：
- en: '[PRE74]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'These hash values come directly from the `id()` values. This is our expectation
    for the inherited methods. In this implementation, we can compute the hash from
    the `id()` function as shown in the following code snippet:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 这些哈希值直接来自`id()`值。这是我们对继承方法的期望。在这个实现中，我们可以从`id()`函数中计算哈希，如下面的代码片段所示：
- en: '[PRE75]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As the hash values are different, they must not compare as equal. This fits
    the definitions of hash and equality. However, this violates our expectations
    for this class. The following is an equality check:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希值不同，它们不应该相等。这符合哈希和相等的定义。然而，这违反了我们对这个类的期望。以下是一个相等性检查：
- en: '[PRE76]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: We created them with the same arguments. They didn't compare as equal. In some
    applications, this might not be good. For example, when accumulating statistical
    counts around dealer cards, we don't want to have six counts for one card because
    the simulation used a 6-deck shoe.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相同的参数创建了它们。它们并不相等。在某些应用中，这可能不太好。例如，在累积有关庄家牌的统计计数时，我们不希望因为模拟使用了6副牌而为一张牌有六个计数。
- en: 'We can see that they''re proper immutable objects as we can put them into a
    set:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到它们是适当的不可变对象，因为我们可以将它们放入一个集合中：
- en: '[PRE77]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: This is the documented behavior from the *Standard Library Reference* documentation.
    By default, we'll get a `__hash__()` method based on the ID of the object so that
    each instance appears unique. However, this isn't always what we want.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自*标准库参考*文档的记录行为。默认情况下，我们将得到一个基于对象ID的`__hash__()`方法，以便每个实例看起来都是唯一的。然而，这并不总是我们想要的。
- en: Overriding definitions for immutable objects
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖不可变对象的定义
- en: 'The following is a simple class hierarchy that provides us with definitions
    of `__hash__()` and `__eq__()`:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的类层次结构，为我们提供了`__hash__()`和`__eq__()`的定义：
- en: '[PRE78]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: This object is immutable in principle. There's no formal mechanism to make it
    immutable. We'll look at how to prevent the attribute value changes in [Chapter
    3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"), *Attribute
    Access, Properties, and Descriptors*.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象原则上是不可变的。没有正式的机制使其不可变。我们将在[第3章](ch03.html "第3章。属性访问、属性和描述符")中看到如何防止属性值的更改，*属性访问、属性和描述符*。
- en: Also, note that the preceding code omits two of the subclasses that didn't change
    significantly from the previous example.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，注意到前面的代码省略了两个子类，它们与前一个示例没有显著变化。
- en: 'The `__eq__()` method function compares these two essential values: `suit`
    and `rank`. It doesn''t compare the hard and soft values; they''re derived from
    `rank`.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '`__eq__()`方法函数比较了这两个基本值：`suit`和`rank`。它不比较硬值和软值；它们是从`rank`派生出来的。'
- en: The rules for Blackjack make this definition a bit suspicious. Suit doesn't
    actually matter in Blackjack. Should we merely compare rank? Should we define
    an additional method that compares rank only? Or, should we rely on the application
    to compare ranks properly? There's no best answer to these questions; these are
    just trade-offs.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 二十一点的规则使得这个定义有些可疑。在二十一点中，花色实际上并不重要。我们应该只比较等级吗？我们应该定义一个额外的方法只比较等级吗？或者，应该依赖应用程序正确比较等级？这些问题没有最佳答案；这些只是权衡。
- en: The `__hash__()` method function computes a bit pattern from the two essential
    values using an exclusive OR of the bits that comprise each value. Using the ^
    operator is a quick-and-dirty hash method that often works pretty well. For larger
    and more complex objects, a more sophisticated hash might be appropriate. Start
    with `ziplib` before inventing something that has bugs.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`__hash__()`方法函数使用异或运算符从这两个基本值中计算出一个位模式。使用^运算符是一种快速而简单的哈希方法，通常效果很好。对于更大更复杂的对象，可能需要更复杂的哈希方法。在发明可能存在错误的东西之前，先从`ziplib`开始。'
- en: 'Let''s see how objects of these classes behave. We expect them to compare as
    equal and behave properly with sets and dictionaries. Here are two objects:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些类的对象的行为。我们期望它们比较相等，并且在集合和字典中表现正常。这里有两个对象：
- en: '[PRE79]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We defined two instances of what appear to be the same card. We can check the
    ID values to be sure that they''re distinct objects:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了两个看起来是相同的卡片实例。我们可以检查ID值以确保它们是不同的对象：
- en: '[PRE80]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: These have different `id()` numbers. When we test with the `is` operator, we
    see that they're distinct.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 它们有不同的`id()`编号。当我们使用`is`运算符进行测试时，我们发现它们是不同的。
- en: 'Let''s compare the hash values:'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较一下哈希值：
- en: '[PRE81]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The hash values are identical. This means that they could be equal.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希值是相同的。这意味着它们可能是相等的。
- en: 'The equality operator shows us that they properly compare as equal:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 相等运算符显示它们确实比较相等：
- en: '[PRE82]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'As they''re immutable, we can put them into a set as follows:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是不可变的，我们可以将它们放入一个集合中，如下所示：
- en: '[PRE83]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: This meets our expectations for complex immutable objects. We had to override
    both special methods to get consistent, meaningful results.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合我们对复杂不可变对象的期望。我们必须重写两个特殊方法才能获得一致且有意义的结果。
- en: Overriding definitions for mutable objects
  id: totrans-526
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖可变对象的定义
- en: This example will continue using the `Cards` class. The idea of mutable cards
    is strange, perhaps even wrong. However, we'd like to apply just one small tweak
    to the previous examples.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子将继续使用“Cards”类。可变卡片的概念是奇怪的，甚至可能是错误的。然而，我们希望对先前的示例进行一点小调整。
- en: 'The following is a class hierarchy that provides us with the definitions of
    `__hash__()` and `__eq__()`, appropriate for mutable objects:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个类层次结构，为可变对象提供了`__hash__()`和`__eq__()`的定义：
- en: '[PRE84]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Let''s see how objects of these classes behave. We expect them to compare as
    equal but not work at all with sets or dictionaries. We''ll create two objects
    as follows:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些类的对象如何行为。我们期望它们相等，但不能与集合或字典一起使用。我们将创建两个对象如下：
- en: '[PRE85]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We've defined two instances of what appear to be the same card.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了两个看起来相同的卡片实例。
- en: 'We''ll look at their ID values to ensure they really are distinct:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看它们的ID值，以确保它们确实是不同的。
- en: '[PRE86]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'No surprise here. We''ll see if we can get hash values:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么意外。我们将看看是否可以获得哈希值：
- en: '[PRE87]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: As `__hash__` is set to `None`, these `Card3` objects can't be hashed and can't
    provide a value for the `hash()` function. This is the expected behavior.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`__hash__`设置为`None`，这些`Card3`对象无法被哈希，也无法为`hash()`函数提供值。这是预期的行为。
- en: 'We can perform equality comparisons, though, as shown in the following code
    snippet:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行相等性比较，如下面的代码片段所示：
- en: '[PRE88]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The equality test works properly, allowing us to compare cards. They just can't
    be inserted into sets or used as a key to a dictionary.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 相等性测试正常工作，允许我们比较卡片。它们只是不能插入到集合中或用作字典的键。
- en: 'The following is what happens when we try:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试时会发生以下情况：
- en: '[PRE89]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: We get a proper exception when trying to put these into a set.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试将它们放入集合时，我们会得到一个适当的异常。
- en: Clearly, this is not a proper definition for something that—in real life—is
    immutable like a card. This style of definition is more appropriate for stateful
    objects such as `Hand`, where the content of the hand is always changing. We'll
    provide you with a second example of stateful objects in the following section.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是对像卡片这样在现实生活中是不可变的东西的正确定义。这种定义方式更适合于状态对象，比如“Hand”，其中手牌的内容总是在变化。我们将在下一节为您提供另一个状态对象的示例。
- en: Making a frozen hand from a mutable hand
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从可变手牌制作冻结手牌
- en: 'If we want to perform statistical analysis of specific `Hand` instances, we
    might want to create a dictionary that maps a `Hand` instance to a count. We can''t
    use a mutable `Hand` class as the key in a mapping. We can, however, parallel
    the design of `set` and `frozenset` and create two classes: `Hand` and `FrozenHand`.
    This allows us to "freeze" a `Hand` class via `FrozenHand`; the frozen version
    is immutable and can be used as a key in a dictionary.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想对特定的“Hand”实例执行统计分析，我们可能希望创建一个将“Hand”实例映射到计数的字典。我们不能使用可变的“Hand”类作为映射中的键。但是，我们可以并行设计“set”和“frozenset”，并创建两个类：“Hand”和“FrozenHand”。这允许我们通过“FrozenHand”“冻结”“Hand”类；冻结版本是不可变的，可以用作字典中的键。
- en: 'The following is a simple `Hand` definition:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的“Hand”定义：
- en: '[PRE90]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This is a mutable object (`__hash__` is `None`) that has a proper equality test
    that compares two hands.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可变对象（`__hash__`是`None`），它具有适当的相等性测试，可以比较两手牌。
- en: 'The following is a frozen version of `Hand`:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是“Hand”的冻结版本：
- en: '[PRE91]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The frozen version has a constructor that will build one `Hand` class from another
    `Hand` class. It defines a `__hash__()` method that sums the card's hash value
    that is limited to the `sys.hash_info.modulus` value. For the most part, this
    kind of modulus-based calculation works out reasonably well for computing hashes
    of composite objects.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结版本有一个构造函数，可以从另一个“Hand”类构建一个“Hand”类。它定义了一个`__hash__()`方法，该方法对限制为`sys.hash_info.modulus`值的卡片哈希值求和。在大多数情况下，这种基于模的计算方法对于计算复合对象的哈希值是合理的。
- en: 'We can now use these classes for operations such as the following code snippet:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这些类进行以下操作：
- en: '[PRE92]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We've initialized a statistics dictionary, `stats`, as a `defaultdict` dictionary
    that can collect integer counts. We could also use a `collections.Counter` object
    for this.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化了一个统计字典“stats”，作为一个可以收集整数计数的“defaultdict”字典。我们也可以使用“collections.Counter”对象来实现这一点。
- en: By freezing a `Hand` class, we can use it as a key in a dictionary, collecting
    counts of each hand that actually gets dealt.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 通过冻结“Hand”类，我们可以将其用作字典中的键，收集实际发放的每个手牌的计数。
- en: The __bool__() method
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __bool__()方法
- en: Python has a pleasant definition of falsity. The reference manual lists a large
    number of values that will test as equivalent to `False`. This includes things
    such as `False`, `0`, `''`, `()`, `[]`, and `{}`. Most other objects will test
    as equivalent to `True`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Python对虚假的定义很愉快。参考手册列出了许多值，这些值将测试为等同于“False”。这包括诸如`False`、`0`、`''`、`()`、`[]`和`{}`等内容。大多数其他对象将测试为等同于“True”。
- en: 'Often, we''ll want to check for an object being "not empty" with a simple statement
    as follows:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们希望通过以下简单语句检查对象是否“非空”：
- en: '[PRE93]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Under the hood, this is the job of the `bool()` built-in function. This function
    depends on the `__bool__()` method of a given object.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，这是“bool()”内置函数的工作。这个函数依赖于给定对象的`__bool__()`方法。
- en: 'The default `__bool__()` method returns `True`. We can see this with the following
    code:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的`__bool__()`方法返回`True`。我们可以通过以下代码看到这一点：
- en: '[PRE94]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: For most classes, this is perfectly valid. Most objects are not expected to
    be `False`. For collections, however, this is not appropriate. An empty collection
    should be equivalent to `False`. A nonempty collection can return `True`. We might
    want to add a method like this to our `Deck` objects.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数类来说，这是完全有效的。大多数对象不应该是“False”。然而，对于集合来说，这是不合适的。空集合应该等同于“False”。非空集合可以返回“True”。我们可能希望为我们的“Deck”对象添加一个类似的方法。
- en: 'If we''re wrapping a list, we might have something as shown in the following
    code snippet:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包装一个列表，我们可能会有以下代码片段中显示的内容：
- en: '[PRE95]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This delegates the Boolean function to the internal `_cards` collection.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 这将布尔函数委托给内部的“_cards”集合。
- en: 'If we''re extending a list, we might have something as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展一个列表，可能会有以下内容：
- en: '[PRE96]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This delegates to the superclass definition of the `__bool__()` function.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 这将委托给超类定义的`__bool__()`函数。
- en: In both cases, we're specifically delegating the Boolean test. In the wrap case,
    we're delegating to the collection. In the extend case, we're delegating to the
    superclass. Either way, wrap or extend, an empty collection will be `False`. This
    will give us a way to see whether the `Deck` object has been entirely dealt and
    is empty.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都在专门委托布尔测试。在wrap情况下，我们委托给集合。在extend情况下，我们委托给超类。无论哪种方式，wrap或extend，空集合都将是`False`。这将让我们有办法看到`Deck`对象是否已经完全发放并且为空。
- en: 'We can do things as shown in the following code snippet:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下代码片段所示的方式进行操作：
- en: '[PRE97]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: This loop will deal all the cards without getting an `IndexError` exception
    when the deck has been exhausted.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将处理所有的卡片，而不会在牌堆用尽时出现“IndexError”异常。
- en: The __bytes__() method
  id: totrans-575
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__bytes__()`方法'
- en: There are relatively few occasions to transform an object into bytes. We'll
    look at this in detail in [Part 2](pt02.html "Part 2. Persistence and Serialization"),
    *Persistence and Serialization*.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有机会将对象转换为字节。我们将在[第2部分](pt02.html "第2部分。持久性和序列化")中详细讨论*持久性和序列化*。
- en: In the most common situation, an application can create a string representation,
    and the built-in encoding capabilities of the Python IO classes will be used to
    transform the string into bytes. This works perfectly for almost all situations.
    The main exception would be when we're defining a new kind of string. In that
    case, we'd need to define the encoding of that string.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在最常见的情况下，应用程序可以创建一个字符串表示，Python IO类的内置编码功能将用于将字符串转换为字节。这对几乎所有情况都有效。主要的例外情况是当我们定义一种新类型的字符串时。在这种情况下，我们需要定义该字符串的编码。
- en: 'The `bytes()` function does a variety of things, depending on the arguments:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`bytes()`函数根据参数执行各种操作：'
- en: '`bytes(integer)`: This returns an immutable bytes object with the given number
    of `0x00` values.'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes(integer)`: 返回一个具有给定数量的`0x00`值的不可变字节对象。'
- en: '`bytes(string)`: This will encode the given string into bytes. Additional parameters
    for encoding and error handling will define the details of the encoding process.'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes(string)`: 这将把给定的字符串编码为字节。编码和错误处理的额外参数将定义编码过程的细节。'
- en: '`bytes(something)`: This will invoke `something.__bytes__()` to create a bytes
    object. The encoding or error arguments will not be used here.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bytes(something)`: 这将调用`something.__bytes__()`来创建一个字节对象。这里不会使用编码或错误参数。'
- en: The base `object` class does not define `__bytes__()`. This means our classes
    don't provide a `__bytes__()` method by default.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的`object`类没有定义`__bytes__()`。这意味着我们的类默认情况下不提供`__bytes__()`方法。
- en: There are some exceptional cases where we might have an object that will need
    to be encoded directly into bytes before being written to a file. It's often simpler
    to work with strings and allow the `str` type to produce bytes for us. When working
    with bytes, it's important to note that there's no *trivial* way to decode bytes
    from a file or interface. The built-in `bytes` class will only decode strings,
    not our unique, new objects. We might need to parse the strings that are decoded
    from the bytes. Or, we might need to explicitly parse the bytes using the `struct`
    module and create our unique objects from the parsed values.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊情况，我们可能有一个需要直接编码成字节的对象，然后再写入文件。使用字符串并允许`str`类型为我们生成字节通常更简单。在处理字节时，重要的是要注意，没有*简单*的方法从文件或接口解码字节。内置的`bytes`类只会解码字符串，而不是我们独特的新对象。我们可能需要解析从字节解码的字符串。或者，我们可能需要显式地使用`struct`模块解析字节，并从解析的值创建我们独特的对象。
- en: 'We''ll look at encoding and decoding `Card` to bytes. As there are only 52
    card values, each card could be packed into a single byte. However, we''ve elected
    to use a character to represent `suit` and a character to represent `rank`. Further,
    we''ll need to properly reconstruct the subclass of `Card`, so we have to encode
    several things:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究将`Card`编码和解码为字节。由于只有52张卡片，每张卡片可以打包成一个字节。然而，我们选择使用一个字符来表示`suit`和一个字符来表示`rank`。此外，我们需要正确重建`Card`的子类，因此我们需要编码几件事情：
- en: The subclass of `Card` (`AceCard`, `NumberCard`, `FaceCard`)
  id: totrans-585
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Card`的子类（`AceCard`，`NumberCard`，`FaceCard`）'
- en: The parameters to the subclass-defined `__init__()`
  id: totrans-586
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类定义的`__init__()`的参数
- en: Note that some of our alternative `__init__()` methods will transform a numeric
    rank into a string, losing the original numeric value. For the purposes of a reversible
    byte encoding, we need to reconstruct this original numeric rank value.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的一些替代`__init__()`方法会将数字等级转换为字符串，从而丢失原始的数值。为了可逆的字节编码，我们需要重建这个原始的数字等级值。
- en: 'The following is an implementation of `__bytes__()`, which returns a **UTF-8**
    encoding of the `Cards` class, `rank`, and `suit`:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`__bytes__()`的实现，它返回`Cards`类，`rank`和`suit`的**UTF-8**编码：
- en: '[PRE98]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This works by creating a string representation of the `Card` object and then
    encoding the string into bytes. This is often the simplest and most flexible approach.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过创建`Card`对象的字符串表示，然后将字符串编码为字节来实现。这通常是最简单和最灵活的方法。
- en: 'When we are given a pile of bytes, we can decode the string and then parse
    the string into a new `Card` object. The following is a method that can be used
    to create a `Card` object from bytes:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们得到一堆字节时，我们可以解码字符串，然后将字符串解析成一个新的`Card`对象。以下是一个可以用来从字节创建`Card`对象的方法：
- en: '[PRE99]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: In the preceding code, we've decoded the bytes into a string. Then we've parsed
    the string into individual values. From those values, we can locate the class
    and build the original `Card` object.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们已经将字节解码为字符串。然后我们解析了字符串成单独的值。从这些值中，我们可以找到类并构建原始的`Card`对象。
- en: 'We can build a bytes representation of a `Card` object as follows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式构建`Card`对象的字节表示：
- en: '[PRE100]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'We can reconstruct the `Card` object from the bytes as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以按照以下方式从字节重建`Card`对象：
- en: '[PRE101]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: It's important to note that the external bytes representation is often challenging
    to design. We're creating a representation of the state of an object. Python already
    has a number of representations that work well for our class definitions.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，外部字节表示通常很难设计。我们正在创建对象状态的表示。Python 已经有了许多适合我们类定义的表示。
- en: It's often better to use the `pickle` or `json` modules than to invent a low-level
    bytes representation of an object. This is the subject of [Chapter 9](ch09.html
    "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and XML"), *Serializing
    and Saving – JSON, YAML, Pickle, CSV, and XML*.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好使用 `pickle` 或 `json` 模块，而不是发明一个对象的低级字节表示。这是[第9章](ch09.html "第9章 序列化和保存 –
    JSON、YAML、Pickle、CSV 和 XML") *序列化和保存 – JSON、YAML、Pickle、CSV 和 XML* 的主题。
- en: The comparison operator methods
  id: totrans-600
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较操作符方法
- en: 'Python has six comparison operators. These operators have special method implementations.
    According to the documentation, the mapping works as follows:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有六个比较操作符。这些操作符有特殊的方法实现。根据文档，映射如下：
- en: '`x<y` calls `x.__lt__(y)`'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x<y` 调用 `x.__lt__(y)`'
- en: '`x<=y` calls `x.__le__(y)`'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x<=y` 调用 `x.__le__(y)`'
- en: '`x==y` calls `x.__eq__(y)`'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x==y` 调用 `x.__eq__(y)`'
- en: '`x!=y` calls `x.__ne__(y)`'
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x!=y` 调用 `x.__ne__(y)`'
- en: '`x>y` calls `x.__gt__(y)`'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x>y` 调用 `x.__gt__(y)`'
- en: '`x>=y` calls `x.__ge__(y)`'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x>=y` 调用 `x.__ge__(y)`'
- en: We'll return to comparison operators again when looking at numbers in [Chapter
    7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第7章](ch07.html "第7章 创建数字") *创建数字* 中再次讨论比较操作符。
- en: There's an additional rule regarding what operators are actually implemented
    that's relevant here. These rules are based on the idea that the object's class
    on the left defines the required special method. If it doesn't, Python can try
    an alternative operation by changing the order.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个关于实际实现了哪些操作符的额外规则。这些规则基于这样一个想法，即左边的对象类定义了所需的特殊方法。如果没有定义，Python 可以尝试通过改变顺序来尝试替代操作。
- en: Tip
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Here are the two basic rules**'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '**以下是两个基本规则**'
- en: 'First, the operand on the left is checked for an operator implementation: `A<B`
    means `A.__lt__(B)`.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查左边的操作数是否有操作符实现：`A<B` 意味着 `A.__lt__(B)`。
- en: 'Second, the operand on the right is checked for a reversed operator implementation:
    `A<B` means `B.__gt__(A)`.'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，检查右边的操作数是否有反向操作符实现：`A<B` 意味着 `B.__gt__(A)`。
- en: The rare exception to this occurs when the right operand is a subclass of the
    left operand; then, the right operand is checked first to allow a subclass to
    override a superclass.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况的罕见例外是右操作数是左操作数的子类；然后，首先检查右操作数以允许子类覆盖超类。
- en: We can see how this works by defining a class with only one of the operators
    defined and then using it for other operations.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过定义一个只有一个操作符定义的类，然后用它进行其他操作来看看它是如何工作的。
- en: 'The following is a partial class that we can use:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个我们可以使用的部分类：
- en: '[PRE102]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This follows the Blackjack comparison rules where suits don't matter. We've
    omitted comparison methods to see how Python will fallback when an operator is
    missing. This class will allow us to perform the `<` comparisons. Interestingly,
    Python can also use this to perform the `>` comparisons by switching the argument
    order. In other words, *x<y≡y>x*. This is the mirror reflection rule; we'll see
    it again in [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 这遵循了二十一点比较规则，其中花色无关紧要。我们省略了比较方法，以查看 Python 在操作符缺失时会如何回退。这个类将允许我们执行 `<` 比较。有趣的是，Python
    也可以使用这个类来执行 `>` 比较，方法是交换参数顺序。换句话说，*x<y≡y>x*。这是镜像反射规则；我们将在[第7章](ch07.html "第7章
    创建数字") *创建数字* 中再次看到它。
- en: 'We see this when we try to evaluate different comparison operations. We''ll
    create two `Cards` classes and compare them in various ways as shown in the following
    code snippet:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试评估不同的比较操作时，我们会看到这一点。我们将创建两个 `Cards` 类并以各种方式进行比较，如下面的代码片段所示：
- en: '[PRE103]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: From this, we can see where `two < three` maps to `two.__lt__(three)`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 从中我们可以看到 `two < three` 映射到 `two.__lt__(three)`。
- en: However, for `two > three`, there's no `__gt__()` method defined; Python uses
    `three.__lt__(two)` as a fallback plan.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `two > three`，没有定义 `__gt__()` 方法；Python 使用 `three.__lt__(two)` 作为备用计划。
- en: 'By default, the `__eq__()` method is inherited from `object`; it compares the
    object IDs; the objects participate in `==` and `!=` tests as follows:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`__eq__()` 方法是从 `object` 继承的；它比较对象的 ID；对象参与 `==` 和 `!=` 测试如下：
- en: '[PRE104]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We can see that the results aren't quite what we expect. We'll often need to
    override the default implementation of `__eq__()`.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到结果并不完全符合我们的预期。我们经常需要覆盖 `__eq__()` 的默认实现。
- en: 'Also, there''s no logical connection among the operators. Mathematically, we
    can derive all the necessary comparisons from just two. Python doesn''t do this
    automatically. Instead, Python handles the following four simple reflection pairs
    by default:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这些操作符之间没有逻辑连接。从数学上讲，我们可以从其中两个推导出所有必要的比较。Python 不会自动执行这一点。相反，Python 默认处理以下四个简单的反射对：
- en: '![The comparison operator methods](graphics/0971OS_02_01.jpg)![The comparison
    operator methods](graphics/0971OS_02_02.jpg)![The comparison operator methods](graphics/0971OS_02_03.jpg)![The
    comparison operator methods](graphics/0971OS_02_04.jpg)'
  id: totrans-627
  prefs: []
  type: TYPE_IMG
  zh: '![比较操作符方法](graphics/0971OS_02_01.jpg)![比较操作符方法](graphics/0971OS_02_02.jpg)![比较操作符方法](graphics/0971OS_02_03.jpg)![比较操作符方法](graphics/0971OS_02_04.jpg)'
- en: This means that we must, at the minimum, provide one from each of the four pairs.
    For example, we could provide `__eq__()`, `__ne__()`, `__lt__()`, and `__le__()`.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须至少提供四对中的一个。例如，我们可以提供 `__eq__()`、`__ne__()`、`__lt__()` 和 `__le__()`。
- en: 'The `@functools.total_ordering` decorator overcomes the default limitation
    and deduces the rest of the comparisons from just `__eq__()` and one of these:
    `__lt__()`, `__le__()`, `__gt__()`, or `__ge__()`. We''ll revisit this in [Chapter
    7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '`@functools.total_ordering` 装饰器克服了默认限制，并从 `__eq__()` 和其中一个 `__lt__()`、`__le__()`、`__gt__()`
    或 `__ge__()` 推断出其余的比较。我们将在[第7章](ch07.html "第7章 创建数字") *创建数字* 中重新讨论这个问题。'
- en: Designing comparisons
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计比较
- en: 'There are two considerations when defining the comparison operators:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义比较运算符时有两个考虑因素：
- en: The obvious question of how to compare two objects of the same class
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何比较同一类的两个对象的明显问题
- en: The less obvious question of how to compare objects of different classes
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何比较不同类的对象的不太明显的问题
- en: For a class with multiple attributes, we often have a profound ambiguity when
    looking at the comparison operators. It might not be perfectly clear what we're
    going to compare.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个具有多个属性的类，当查看比较运算符时，我们经常会有一个深刻的模糊。我们可能不清楚我们要比较什么。
- en: Consider the humble playing card (again!). An expression such as `card1 == card2`
    is clearly intended to compare `rank` and `suit`. Right? Or is that always true?
    After all, `suit` doesn't matter in Blackjack.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑谦卑的纸牌（再次！）。诸如`card1 == card2`的表达显然是用来比较`rank`和`suit`的。对吗？或者这总是正确的吗？毕竟，在二十一点中`suit`并不重要。
- en: 'If we want to decide whether a `Hand` object can be split, we have to see which
    of the two code snippets is better. The following is the first code snippet:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要决定一个“Hand”对象是否可以分割，我们必须看看哪个代码片段更好。以下是第一个代码片段：
- en: '[PRE105]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The following is the second code snippet:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是第二个代码片段：
- en: '[PRE106]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: While one is shorter, brevity is not always best. If we define equality to only
    consider `rank`, we will have trouble defining unit tests because a simple `TestCase.assertEqual()`
    method will tolerate a wide variety of cards when a unit test should be focused
    on exactly correct cards.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一个更短，简洁并不总是最好的。如果我们定义相等只考虑`rank`，我们将很难定义单元测试，因为一个简单的`TestCase.assertEqual()`方法将容忍各种各样的卡片，而单元测试应该专注于完全正确的卡片。
- en: An expression such as `card1 <= 7` is clearly intended to compare `rank`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如`card1 <= 7`的表达显然是用来比较`rank`的。
- en: Do we want some comparisons to compare all attributes of a card and other comparisons
    to compare just `rank`? What do we do to order cards by `suit`? Furthermore, equality
    comparison must parallel the hash calculation. If we've included multiple attributes
    in the hash, we need to include them in the equality comparison. In this case,
    it appears that equality (and inequality) between cards must be full `Card` comparisons
    because we're hashing the `Card` values to include `rank` and `suit`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否希望一些比较比较卡片的所有属性，而其他比较只比较`rank`？我们如何按`suit`对卡片进行排序？此外，相等比较必须与哈希计算相对应。如果我们在哈希中包含了多个属性，我们需要在相等比较中包含它们。在这种情况下，似乎卡片之间的相等（和不等）必须是完全的`Card`比较，因为我们正在对`Card`值进行哈希以包括`rank`和`suit`。
- en: The ordering comparisons between `Card`, however, should be `rank` only. Comparisons
    against integers, similarly, should be `rank` only. For the special case of detecting
    a split, `hand.cards[0].rank == hand.cards[1].rank` will do nicely because it's
    explicit on the rule for a split.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Card`之间的排序比较应该只是`rank`。同样，对整数的比较也应该只是`rank`。对于检测分割的特殊情况，`hand.cards[0].rank
    == hand.cards[1].rank`将很好，因为它明确了分割的规则。
- en: Implementation of comparison for objects of the same class
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现相同类的对象的比较
- en: 'We''ll look at a simple same-class comparison by looking at a more complete
    `BlackJackCard` class:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过查看一个更完整的`BlackJackCard`类来看一个简单的同类比较：
- en: '[PRE107]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: We've now defined all six comparison operators.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经定义了所有六个比较运算符。
- en: 'We''ve shown you two kinds of type checking: **explicit** and **implicit**.
    The explicit type checking uses `isinstance()`. The implicit type checking uses
    a `try:` block. There''s a tiny conceptual advantage to using the `try:` block:
    it avoids repeating the name of a class. It''s entirely possible that someone
    might want to invent a variation on a card that''s compatible with this definition
    of `BlackJackCard` but not defined as a proper subclass. Using `isinstance()`
    might prevent an otherwise valid class from working correctly.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向您展示了两种类型检查：**显式**和**隐式**。显式类型检查使用`isinstance()`。隐式类型检查使用`try:`块。使用`try:`块有一个微小的概念优势：它避免了重复类的名称。完全有可能有人想要发明一个与`BlackJackCard`的定义兼容但未定义为正确子类的卡的变体。使用`isinstance()`可能会阻止一个否则有效的类正常工作。
- en: The `try:` block might allow a class that coincidentally happens to have a `rank`
    attribute to work. The risk of this turning into a difficult-to-solve problem
    is nil, as the class would likely fail everywhere else it was used in this application.
    Also, who compares an instance of `Card` with a class from a financial modeling
    application that happens to have a rank-ordering attribute?
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '`try:`块可能允许一个偶然具有`rank`属性的类工作。这变成一个难以解决的问题的风险为零，因为该类在此应用中的其他任何地方都可能失败。此外，谁会将`Card`的实例与一个具有等级排序属性的金融建模应用程序的类进行比较？'
- en: In future examples, we'll focus on the `try:` block. The `isinstance()` method
    check is idiomatic Python and is widely used. We explicitly return `NotImplemented`
    to inform Python that this operator isn't implemented for this type of data. Python
    can try reversing the argument order to see if the other operand provides an implementation.
    If no valid operator can be found, then a `TypeError` exception will be raised.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后的示例中，我们将专注于`try:`块。`isinstance()`方法检查是Python的成语，并且被广泛使用。我们明确返回`NotImplemented`以通知Python这个运算符对于这种类型的数据没有实现。Python可以尝试颠倒参数顺序，看看另一个操作数是否提供了实现。如果找不到有效的运算符，那么将引发`TypeError`异常。
- en: We omitted the three subclass definitions and the factory function, `card21()`.
    They're left as an exercise.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了三个子类定义和工厂函数`card21()`。它们留作练习。
- en: 'We also omitted intraclass comparisons; we''ll save that for the next section.
    With this class, we can compare cards successfully. The following is an example
    where we create and compare three cards:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还省略了类内比较；我们将在下一节中保存。有了这个类，我们可以成功地比较卡片。以下是一个我们创建和比较三张卡片的示例：
- en: '[PRE108]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Given those `Cards` classes, we can perform a number of comparisons as shown
    in the following code snippet:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这些`Cards`类，我们可以执行许多比较，如下面的代码片段所示：
- en: '[PRE109]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The definitions seem to work as expected.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 定义似乎按预期工作。
- en: Implementation of comparison for objects of mixed classes
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合类对象的比较实现
- en: We'll use the `BlackJackCard` class as an example to see what happens when we
    attempt comparisons where the two operands are from different classes.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`BlackJackCard`类作为一个例子，看看当我们尝试比较两个不同类的操作数时会发生什么。
- en: 'The following is a `Card` instance that we can compare against the `int` values:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们可以与`int`值进行比较的`Card`实例：
- en: '[PRE110]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This is what we expected: the subclass of `BlackJackCard`, `Number21Card` doesn''t
    provide the required special methods, so there''s a `TypeError` exception.'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们预期的：`BlackJackCard`的子类`Number21Card`没有提供所需的特殊方法，因此会有一个`TypeError`异常。
- en: 'However, consider the following two examples:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，考虑以下两个例子：
- en: '[PRE111]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Why do these provide responses? When confronted with a `NotImplemented` value,
    Python will reverse the operands. In this case, the integer values define an `int.__eq__()`
    method that tolerates objects of an unexpected class.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这些提供了响应？当遇到`NotImplemented`值时，Python会颠倒操作数。在这种情况下，整数值定义了一个`int.__eq__()`方法，容忍意外类的对象。
- en: Hard totals, soft totals, and polymorphism
  id: totrans-665
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 硬总数、软总数和多态性
- en: Let's define `Hand` so that it will perform a meaningful mixed-class comparison.
    As with other comparisons, we have to determine precisely what we're going to
    compare.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义`Hand`，以便它执行有意义的混合类比较。与其他比较一样，我们必须确定我们要比较的内容。
- en: For equality comparisons between `Hands`, we should compare all cards.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Hands`之间的相等比较，我们应该比较所有的卡。
- en: For ordering comparisons between `Hands`, we need to compare an attribute of
    each `Hand` object. For comparisons against an `int` literal, we should compare
    the `Hand` object's total against the literal. In order to have a total, we have
    to sort out the subtlety of hard totals and soft totals in the game of Blackjack.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Hands`之间的排序比较，我们需要比较每个`Hand`对象的属性。对于与`int`字面值的比较，我们应该将`Hand`对象的总数与字面值进行比较。为了得到一个总数，我们必须解决Blackjack游戏中硬总数和软总数的微妙之处。
- en: 'When there''s an ace in a hand, then the following are two candidate totals:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 当手中有一张ace时，接下来有两个候选总数：
- en: The **soft total** treats an ace as 11\. If the soft total is over 21, then
    this version of the ace has to be ignored.
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**软总数**将ace视为11。如果软总数超过21，那么这个ace的版本必须被忽略。'
- en: The **hard total** treats an ace as 1.
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**硬总数**将ace视为1。'
- en: This means that the hand's total isn't a simple sum of the cards.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着手的总数不是卡的简单总和。
- en: We have to determine if there's an ace in the hand first. Given that information,
    we can determine if there's a valid (less than or equal to 21) soft total. Otherwise,
    we'll fall back on the hard total.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先必须确定手中是否有ace。有了这个信息，我们可以确定是否有一个有效的（小于或等于21）软总数。否则，我们将退回到硬总数。
- en: One symptom of **Pretty Poor Polymorphism** is relying on `isinstance()` to
    determine the subclass membership. Generally, this is a violation of the basic
    encapsulation. A good set of polymorphic subclass definitions should be completely
    equivalent with the same method signatures. Ideally, the class definitions are
    opaque; we don't need to look inside the class definition. A poor set of polymorphic
    classes uses extensive `isinstance()` testing. In some cases, `isinstance()` is
    necessary. This can arise when using a built-in class. We can't retroactively
    add method functions to built-in classes, and it might not be worth the effort
    of subclassing them to add a polymorphism helper method.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '**相当差的多态性**的一个症状是依赖`isinstance()`来确定子类成员资格。一般来说，这是对基本封装的违反。一个良好的多态子类定义应该完全等同于相同的方法签名。理想情况下，类定义是不透明的；我们不需要查看类定义。一个糟糕的多态类集使用了大量的`isinstance()`测试。在某些情况下，`isinstance()`是必要的。这可能是因为使用了内置类。我们不能事后向内置类添加方法函数，而且可能不值得为了添加一个多态辅助方法而对其进行子类化。'
- en: In some of the special methods, it's necessary to see `isinstance()` used to
    implement operations that work across multiple classes of objects where there's
    no simple inheritance hierarchy. We'll show you an idiomatic use of `isinstance()`
    for unrelated classes in the next section.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特殊方法中，有必要使用`isinstance()`来实现跨多个对象类的操作，其中没有简单的继承层次结构。我们将在下一节中展示`isinstance()`在不相关类中的惯用用法。
- en: For our cards class hierarchy, we want a method (or an attribute) that identifies
    an ace without having to use `isinstance()`. This is a polymorphism helper method.
    It ensures we can tell otherwise equivalent classes apart.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的卡类层次结构，我们希望有一个方法（或属性）来识别一个ace，而不必使用`isinstance()`。这是一个多态辅助方法。它确保我们可以区分否则相等的类。
- en: 'We have two choices:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个选择：
- en: Add a class-level attribute
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个类级别的属性
- en: Add a method
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个方法
- en: Because of the way the insurance bet works, we have two reasons to check for
    aces. If the dealer's card is an ace, it triggers an insurance bet. If the dealer's
    hand (or the player's hand) has an ace, there will be a soft total versus hard
    total calculation.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 由于保险赌注的工作方式，我们有两个原因要检查ace。如果庄家的卡是ace，它会触发一个保险赌注。如果庄家的手（或玩家的手）有一个ace，就会有一个软总数与硬总数的计算。
- en: The hard total and soft total always differ by the `card.soft–card.hard` value
    for the card that's an ace. We can look inside the definition of `AceCard` to
    see that this value is 10\. However, looking at the implementation breaks encapsulation
    by looking deeply at a class implementation.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 硬总数和软总数总是由ace的`card.soft-card.hard`值不同。我们可以查看`AceCard`的定义，看到这个值是10。然而，查看实现会通过深入查看类的实现来破坏封装。
- en: We can treat `BlackjackCard` as opaque and check to see whether `card.soft-card.hard!=0`
    is true. If this is true, it is sufficient information to work out the hard total
    versus soft total of the hand.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`BlackjackCard`视为不透明，并检查`card.soft-card.hard!=0`是否为真。如果是真的，这就足够了解手的硬总数与软总数。
- en: 'The following is a version of the `total` method that makes use of the soft
    versus hard delta value:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用软与硬差值的`total`方法的版本：
- en: '[PRE112]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: We'll compute the largest difference between the hard and soft total as `delta_soft`.
    For most cards, the difference is zero. For an ace, the difference will be nonzero.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将计算硬总数和软总数之间的最大差值作为`delta_soft`。对于大多数卡片，差值为零。对于一张A牌，差值将不为零。
- en: Given the hard total and `delta_soft`, we can determine which total to return.
    If `hard+delta_soft` is less than or equal to 21, the value is the soft total.
    If the soft total is greater than 21, then revert to a hard total.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 给定硬总和`delta_soft`，我们可以确定要返回的总数。如果`hard+delta_soft`小于或等于21，则值为软总数。如果软总数大于21，则恢复到硬总数。
- en: We can consider making the value 21 a manifest constant in the class. A meaningful
    name is sometimes more helpful than a literal. Because of the rules of Blackjack,
    it's unlikely that 21 would ever change to a different value. It's difficult to
    find a more meaningful name than the literal 21.
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑在类中将值21作为一个显式常量。有时，有意义的名称比字面量更有帮助。由于21点的规则，21点不太可能会改变为其他值。很难找到比字面量21更有意义的名称。
- en: A mixed class comparison example
  id: totrans-688
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合类比较示例
- en: Given a definition of a total for a `Hand` object, we can meaningfully define
    comparisons between the `Hand` instances and comparisons between `Hand` and `int`.
    In order to determine which kind of comparison we're doing, we're forced to use
    `isinstance()`.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`Hand`对象的总数定义，我们可以有意义地定义`Hand`实例之间的比较以及`Hand`和`int`之间的比较。为了确定我们正在进行哪种比较，我们被迫使用`isinstance()`。
- en: 'The following is a partial definition of `Hand` with comparisons:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对`Hand`进行比较的部分定义：
- en: '[PRE113]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: We've defined three of the comparisons, not all six.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三种比较，而不是全部六种。
- en: 'In order to interact with `Hands`, we''ll need a few `Card` objects:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与`Hands`交互，我们需要一些`Card`对象：
- en: '[PRE114]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: We'll use this sequence of cards to see two different `hand` instances.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这组卡片来查看两个不同的`hand`实例。
- en: 'This first `Hands` object has an irrelevant dealer''s `Card` object and the
    set of four `Cards` created previously. One of the `Card` objects is an ace:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个`Hands`对象有一个无关紧要的庄家`Card`对象和之前创建的四张`Card`的集合。其中一张`Card`是一张A牌。
- en: '[PRE115]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The soft total is 18 and the hard total is 8.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 软总数是18，硬总数是8。
- en: 'The following is a second `Hand` object that has an additional `Card` object:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具有额外`Card`对象的第二个`Hand`对象：
- en: '[PRE116]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The hard total is 13\. There's no soft total because it would be over 21.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 硬总数是13。没有软总数，因为它会超过21。
- en: 'The comparisons among `Hands` work very nicely, as shown in the following code
    snippet:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hands`之间的比较非常好，如下面的代码片段所示：'
- en: '[PRE117]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: We can rank `Hands` based on the comparison operators.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据比较运算符对`Hands`进行排名。
- en: 'We can also compare `Hands` with integers, as follows:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`Hands`与整数进行比较，如下所示：
- en: '[PRE118]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The comparisons with integers work as long as Python isn't forced to try a fallback.
    The previous example shows us what happens when there's no `__gt__()` method.
    Python checks the reflected operands, and the integer 17 doesn't have a proper
    `__lt__()` method for `Hand` either.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 与整数的比较只要Python不被迫尝试回退就可以工作。前面的例子向我们展示了当没有`__gt__()`方法时会发生什么。Python检查了反射操作数，整数17对于`Hand`也没有适当的`__lt__()`方法。
- en: We can add the necessary `__gt__()` and `__ge__()` functions to make `Hand`
    work properly with integers.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加必要的`__gt__()`和`__ge__()`函数，使`Hand`与整数正常工作。
- en: The __del__() method
  id: totrans-709
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__del__()`方法'
- en: The `__del__()` method has a rather obscure use case.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '`__del__()`方法有一个相当模糊的用例。'
- en: The intent is to give an object a chance to do any cleanup or finalization just
    before the object is removed from memory. This use case is handled much more cleanly
    by context manager objects and the `with` statement. This is the subject of [Chapter
    5](ch05.html "Chapter 5. Using Callables and Contexts"), *Using Callables and
    Contexts*. Creating a context is much more predictable than dealing with `__del__()`
    and the Python garbage collection algorithm.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是在对象从内存中删除之前给对象一个机会做任何清理或最终处理。上下文管理器对象和`with`语句可以更清晰地处理这种用例。这是[第5章](ch05.html
    "第5章。使用可调用和上下文")的主题，*使用可调用和上下文*。创建上下文比处理`__del__()`和Python垃圾收集算法更可预测。
- en: In the case where a Python object has a related OS resource, the `__del__()`
    method is a last chance to cleanly disentangle the resource from the Python application.
    As examples, a Python object that conceals an open file, a mounted device, or
    perhaps a child subprocess might all benefit from having the resource released
    as part of `__del__()` processing.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python对象具有相关OS资源的情况下，`__del__()`方法是从Python应用程序中干净地释放资源的最后机会。例如，隐藏打开文件、挂载设备或者子进程的Python对象都可能受益于在`__del__()`处理中释放资源。
- en: 'The `__del__()` method is not invoked at any easy-to-predict time. It''s not
    always invoked when the object is deleted by a `del` statement, nor is it always
    invoked when an object is deleted because a namespace is being removed. The documentation
    on the `__del__()` method describes the circumstances as *precarious* and provides
    this additional note on exception processing: exceptions that occur during their
    execution are ignored, and a warning is printed to `sys.stderr` instead.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '`__del__()`方法不会在任何易于预测的时间被调用。当对象被`del`语句删除时，并不总是调用它，当命名空间被删除时，也不总是调用它。`__del__()`方法的文档描述了*不稳定*的情况，并在异常处理上提供了额外的注意事项：执行期间发生的异常将被忽略，并在`sys.stderr`上打印警告。'
- en: For these reasons, a context manager is often preferable to implementing `__del__()`.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 出于这些原因，上下文管理器通常比实现`__del__()`更可取。
- en: The reference count and destruction
  id: totrans-715
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引用计数和销毁
- en: For the CPython implementation, objects have a reference count. The count is
    incremented when the object is assigned to a variable and decremented when the
    variable is removed. When the reference count is zero, the object is no longer
    needed and can be destroyed. For simple objects, `__del__()` will be invoked and
    the object will be removed.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 对于CPython实现，对象有一个引用计数。当对象被分配给一个变量时，引用计数会增加，当变量被移除时，引用计数会减少。当引用计数为零时，对象不再需要，可以被销毁。对于简单对象，`__del__()`将被调用并且对象将被移除。
- en: For complex objects that have circular references among objects, the reference
    count might never go to zero and `__del__()` can't be invoked easily.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有对象之间循环引用的复杂对象，引用计数可能永远不会降为零，并且`__del__()`不能轻易被调用。
- en: 'The following is a class that we can use to see what happens:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个我们可以用来查看发生了什么的类：
- en: '[PRE119]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can create (and see the removal of) these objects as follows:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建（并查看移除）这些对象，如下所示：
- en: '[PRE120]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We created and removed a `Noisy` object, and almost immediately we saw the message
    from the `__del__()` method. This indicates that the reference count properly
    went to zero when the `x` variable was deleted. Once the variable is gone, there's
    no longer a reference to the instance of `Noisy` and it, too, can be cleaned up.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建并移除了一个`Noisy`对象，几乎立即就看到了`__del__()`方法的消息。这表明当删除`x`变量时，引用计数正确地降为零。一旦变量消失，对`Noisy`实例的引用也就不存在了，它也可以被清理了。
- en: 'The following is a common situation that involves the shallow copies that are
    often created:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个经常出现的涉及经常创建的浅拷贝的情况：
- en: '[PRE121]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'There''s no response to this `del` statement. The `Noisy` objects have not
    had their reference counts go to zero yet; they''re still being referenced somewhere,
    as shown in the following code snippet:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个`del`语句没有响应。`Noisy`对象的引用计数还没有降为零；它们仍然在某个地方被引用，如下面的代码片段所示：
- en: '[PRE122]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The `ln2` variable was a shallow copy of the `ln` list. The `Noisy` objects
    were referenced in two lists. They could not be destroyed until both lists were
    removed, reducing the reference counts to zero.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: '`ln2`变量是`ln`列表的浅拷贝。`Noisy`对象被两个列表引用。只有当这两个列表都被移除，将引用计数降为零后，它们才能被销毁。'
- en: 'There are numerous other ways to create shallow copies. The following are a
    few ways to create shallow copies of objects:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他创建浅拷贝的方法。以下是一些创建对象浅拷贝的方法：
- en: '[PRE123]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: The point here is that we can often be confused by the number of references
    to an object that can exist because shallow copies are prevalent in Python.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 关键在于我们经常会被对象的引用数量所困扰，因为浅拷贝在Python中很常见。
- en: Circular references and garbage collection
  id: totrans-731
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环引用和垃圾回收
- en: Here's a common situation that involves circularity. One class, `Parent`, contains
    a collection of children. Each `Child` instance contains a reference to the `Parent`
    class.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个涉及循环引用的常见情况。一个类`Parent`包含一个子类的集合。每个`Child`实例都包含对`Parent`类的引用。
- en: 'We''ll use these two classes to examine circular references:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这两个类来检查循环引用：
- en: '[PRE124]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: A `Parent` instance has a collection of children as a simple `list`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent`实例有一个简单的`list`作为子类的集合。'
- en: Each `Child` instance has a reference to the `Parent` class that contains it.
    The reference is created during initialization when the children are inserted
    into the parent's internal collection.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Child`实例都引用包含它的`Parent`类。这个引用是在初始化时创建的，当子类被插入到父类的内部集合中。
- en: 'We''ve made both classes rather noisy so we can see when the objects are removed.
    The following is what happens:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使这两个类都很吵闹，这样我们就可以看到对象何时被移除。以下是发生的情况：
- en: '[PRE125]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The `Parent` and two initial `Child` instances cannot be removed. They both
    contain references to each other.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parent`和两个初始的`Child`实例都无法被移除。它们彼此之间都包含引用。'
- en: 'We can create a childless `Parent` instance, as shown in the following code
    snippet:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个没有子类的`Parent`实例，如下面的代码片段所示：
- en: '[PRE126]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: This is deleted, as expected.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 这被删除了，如预期的那样。
- en: Because of the mutual or circular references, a `Parent` instance and its list
    of `Child` instances cannot be removed from the memory. If we import the garbage
    collector interface, `gc`, we can collect and display these nonremovable objects.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 由于相互引用或循环引用，`Parent`实例及其`Child`实例的列表无法从内存中移除。如果我们导入垃圾收集器接口`gc`，我们可以收集并显示这些不可移除的对象。
- en: 'We''ll use the `gc.collect()` method to collect all the nonremovable objects
    that have a `__del__()` method, as shown in the following code snippet:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`gc.collect()`方法来收集所有具有`__del__()`方法的不可移除对象，如下面的代码片段所示：
- en: '[PRE127]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: We can see that our `Parent` objects (for example, ID of `4313921808 = 0x101213910`)
    are prominent on the list of nonremovable garbage. To reduce the reference counts
    to zero, we would need to either update each `Parent` instance on the garbage
    list to remove the children, or update each `Child` instance on the list to remove
    the reference to the `Parent` instance.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们的`Parent`对象（例如，ID为`4313921808 = 0x101213910`）在不可移除的垃圾列表中很显眼。为了将引用计数降为零，我们需要更新垃圾列表中的每个`Parent`实例以移除子类，或者更新列表中的每个`Child`实例以移除对`Parent`实例的引用。
- en: Note that we can't break the circularity by putting code in the `__del__()`
    method. The `__del__()` method is called *after* the circularity has been broken
    and the reference counts are already zero. When we have circular references, we
    can no longer rely on simple Python reference counting to clear out the memory
    of unused objects. We must either explicitly break the circularity or use a `weakref`
    reference, which permits garbage collection.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能通过在`__del__()`方法中放置代码来打破循环引用。`__del__()`方法在循环引用被打破并且引用计数已经为零之后才会被调用。当存在循环引用时，我们不能再依赖简单的Python引用计数来清除未使用对象的内存。我们必须显式地打破循环引用，或者使用`weakref`引用来进行垃圾回收。
- en: Circular references and the weakref module
  id: totrans-748
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环引用和weakref模块
- en: 'In the cases where we need circular references but also want `__del__()` to
    work nicely, we can use **weak references**. One common use case for circular
    references are mutual references: a parent with a collection of children; each
    child has a reference back to the parent. If a `Player` class has multiple hands,
    it might be helpful for a `Hand` object to contain a reference to the owning `Player`
    class.'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要循环引用但又希望`__del__()`正常工作的情况下，我们可以使用**弱引用**。循环引用的一个常见用例是相互引用：一个父对象有一组子对象；每个子对象都有一个指向父对象的引用。如果`Player`类有多个手，那么`Hand`对象包含对拥有`Player`类的引用可能会有所帮助。
- en: The default object references could be called **strong references**; however,
    direct references is a better term. They're used by the reference-counting mechanism
    in Python and can be discovered by the garbage collector if reference counting
    can't remove the objects. They cannot be ignored.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的对象引用可以称为**强引用**；然而，直接引用是一个更好的术语。它们被Python中的引用计数机制使用，并且如果引用计数无法移除对象，它们可以被垃圾回收器发现。它们不能被忽视。
- en: 'A strong reference to an object is followed directly. Consider the following
    statement:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 对对象的强引用直接跟随。考虑以下语句：
- en: 'When we say:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说：
- en: '[PRE128]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The `a` variable has a direct reference to the object of the `B` class that
    was created. The reference count to the instance of `B` is at least 1 because
    the `a` variable has a reference.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '`a`变量直接引用了创建的`B`类的对象。`B`的实例的引用计数至少为1，因为`a`变量有一个引用。'
- en: A weak reference involves a two-step process to find the associated object.
    A weak reference will use `x.parent()`, invoking the weak reference as a callable
    object to track down the actual parent object. This two-step process allows the
    reference counting or garbage collection to remove the referenced object, leaving
    the weak reference dangling.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 弱引用涉及两步过程来找到关联的对象。弱引用将使用`x.parent()`，调用弱引用作为可调用对象来跟踪实际的父对象。这两步过程允许引用计数或垃圾回收器移除引用的对象，使弱引用悬空。
- en: The `weakref` module defines a number of collections that use weak references
    instead of strong references. This allows us to create dictionaries that, for
    example, permit the garbage collection of otherwise unused objects.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: '`weakref`模块定义了许多使用弱引用而不是强引用的集合。这使我们能够创建字典，例如，允许对否则未使用的对象进行垃圾回收。'
- en: We can modify our `Parent` and `Child` classes to use weak references from `Child`
    to `Parent`, permitting a simpler destruction of unused objects.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以修改我们的`Parent`和`Child`类，使用从`Child`到`Parent`的弱引用，允许更简单地销毁未使用的对象。
- en: 'The following is a modified class that uses weak references from `Child` to
    `Parent`:'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个修改过的类，它使用从`Child`到`Parent`的弱引用：
- en: '[PRE129]'
  id: totrans-759
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We've changed the child to parent reference to be a `weakref` object reference.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将子到父的引用更改为`weakref`对象引用。
- en: 'From within a `Child` class, we must locate the `parent` object via a two-step
    operation:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Child`类内部，我们必须通过两步操作来定位`parent`对象：
- en: '[PRE130]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: We can explicitly check to be sure the referenced object was found. There's
    a possibility that the reference was left dangling.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以明确检查确保找到了引用的对象。有可能引用被悬空。
- en: 'When we use this new `Parent2` class, we see that reference counting goes to
    zero and the object is removed:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用这个新的`Parent2`类时，我们看到引用计数变为零，对象被移除：
- en: '[PRE131]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'When a `weakref` reference is dead (because the referent was destroyed), we
    have three potential responses:'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 当`weakref`引用失效（因为引用对象被销毁）时，我们有三种潜在的响应：
- en: Recreate the referent. Reload it from a database, perhaps.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新创建引用。可能从数据库重新加载。
- en: Use the `warnings` module to write the debugging information on low-memory situations
    where the garbage collector removed objects unexpectedly.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`warnings`模块在低内存情况下写入调试信息，其中垃圾回收器意外地移除了对象。
- en: Ignore the problem.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 忽略这个问题。
- en: 'Generally, the `weakref` references are dead because objects have been removed:
    variables have gone out of scope, a namespace is no longer in use, the application
    is shutting down. For this reason, the third response is quite common. The object
    trying to create the reference is probably about to be removed as well.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`weakref`引用已经失效，因为对象已被移除：变量已经超出作用域，命名空间不再使用，应用程序正在关闭。因此，第三种响应是非常常见的。试图创建引用的对象可能也即将被移除。
- en: The __del__() and close() methods
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`__del__()`和`close()`方法'
- en: The most common use for `__del__()` is to ensure files are closed.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '`__del__()`最常见的用途是确保文件被关闭。'
- en: 'Generally, class definitions that open files will have something like what''s
    shown in the following code:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，打开文件的类定义将具有类似以下代码的内容：
- en: '[PRE132]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: This will ensure the `__del__()` method is also the `close()` method.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保`__del__()`方法也是`close()`方法。
- en: Anything more complex than this is better done with a context manager. See [Chapter
    5](ch05.html "Chapter 5. Using Callables and Contexts"), *Using Callables and
    Contexts*, for more information on context managers.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 比这更复杂的任何事情最好使用上下文管理器来完成。有关上下文管理器的更多信息，请参见[第5章](ch05.html "第5章。使用可调用对象和上下文")，*使用可调用对象和上下文*。
- en: The __new__() method and immutable objects
  id: totrans-777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__new__()`方法和不可变对象'
- en: One use case for the `__new__()` method is to initialize objects that are otherwise
    immutable. The `__new__()` method is where our code can build an uninitialized
    object. This allows processing before the `__init__()` method is called to set
    the attribute values of the object.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法的一个用例是初始化否则不可变的对象。`__new__()`方法是我们的代码可以构建未初始化对象的地方。这允许在调用`__init__()`方法设置对象的属性值之前进行处理。'
- en: The `__new__()` method is used to extend the immutable classes where the `__init__()`
    method can't easily be overridden.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法用于扩展不可变类，其中`__init__()`方法不能轻松地被覆盖。'
- en: 'The following is a class that does not work. We''ll define a version of `float`
    that carries around information on units:'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个不起作用的类。我们将定义一个携带有关单位信息的`float`的版本：
- en: '[PRE133]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We're trying (improperly) to initialize an immutable object.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在（不当地）初始化一个不可变对象。
- en: 'The following is what happens when we try to use this class definition:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试使用这个类定义时会发生什么，以下是发生的情况：
- en: '[PRE134]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: From this, we see that we can't easily override the `__init__()` method for
    the built-in immutable `float` class. We'd have similar problems with all other
    immutable classes. We can't set the attribute values on the immutable object,
    `self`, because that's the definition of immutability. We can only set attribute
    values during the object construction. Enter the `__new__()` method after this.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，我们无法轻松地覆盖内置的不可变`float`类的`__init__()`方法。我们在所有其他不可变类中也会遇到类似的问题。我们无法设置不可变对象`self`的属性值，因为这就是不可变性的定义。我们只能在对象构造期间设置属性值。在此之后进入`__new__()`方法。
- en: The `__new__()` method is auto-magically a static method. This is true without
    using the `@staticmethod` decorator. It doesn't use a `self` variable, as its
    job is to create the object that will eventually be assigned to the `self` variable.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法自动成为一个静态方法。这是真的，即使没有使用`@staticmethod`装饰器。它不使用`self`变量，因为它的工作是创建最终将分配给`self`变量的对象。'
- en: For this use case, the method signature is `__new__( cls, *args, **kw )`. The
    `cls` parameter is the class for which an instance must be created. For the metaclass
    use case in the next section, the `args` sequence of values are more complex than
    shown here.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种用例，方法签名是`__new__(cls, *args, **kw)`。`cls`参数是必须创建实例的类。对于下一节中的元类用例，`args`值序列比这里显示的更复杂。
- en: 'The default implementation of `__new__()` simply does this: `return super().__new__(
    cls )`. It delegates the operation to the superclass. The work winds up getting
    delegated to `object.__new__()`, which builds a simple, empty object of the required
    class. The arguments and keywords to `__new__()`, with the exception of the `cls`
    argument, will be passed to `__init__()` as part of the standard Python behavior.'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`的默认实现只是这样做：`return super().__new__(cls)`。它将操作委托给超类。最终工作被委托给`object.__new__()`，它构建了一个简单的、空的所需类的对象。`__new__()`的参数和关键字，除了`cls`参数，将作为标准Python行为的一部分传递给`__init__()`。'
- en: 'With two notable exceptions, this is exactly what we want. The following are
    the exceptions:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 除了两个显著的例外，这正是我们想要的。以下是例外情况：
- en: When we want to subclass an immutable class definition. We'll dig into that
    later.
  id: totrans-790
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们想要对一个不可变的类定义进行子类化时。我们稍后会深入讨论这一点。
- en: When we need to create a metaclass. That's the subject of the next section,
    as it's fundamentally different from creating immutable objects.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们需要创建一个元类时。这是下一节的主题，因为它与创建不可变对象的方法有根本的不同。
- en: 'Instead of overriding `__init__()` when creating a subclass of a built-in immutable
    type, we have to tweak the object at the time of the creation by overriding `__new__()`.
    The following is an example class definition that shows us the proper way to extend
    `float`:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建内置不可变类型的子类时，我们必须在创建时通过覆盖`__new__()`来调整对象，而不是覆盖`__init__()`。以下是一个示例类定义，向我们展示了扩展`float`的正确方法：
- en: '[PRE135]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: In the preceding code, we set the value of an attribute during the creation
    of an object.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们在创建对象时设置了一个属性的值。
- en: 'The following code snippet gives us a floating-point value with attached units
    information:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段为我们提供了一个带有附加单位信息的浮点值：
- en: '[PRE136]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that an expression such as `speed * 10` does not create a `Float_Units`
    object. This class definition inherits all the operator special methods from `float`;
    the `float` arithmetic special methods all create `float` objects. Creating `Float_Units`
    objects is the subject of [Chapter 7](ch07.html "Chapter 7. Creating Numbers"),
    *Creating Numbers*.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，诸如`speed * 10`这样的表达式不会创建一个`Float_Units`对象。这个类定义继承了`float`的所有操作符特殊方法；`float`算术特殊方法都会创建`float`对象。创建`Float_Units`对象是[第7章](ch07.html
    "第7章。创建数字")*创建数字*的主题。
- en: The __new__() method and metaclasses
  id: totrans-798
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`__new__()`方法和元类'
- en: The other use case for the `__new__()` method as a part of a metaclass is to
    control how a class definition is built. This is distinct from how `__new__()`
    controls building an immutable object, shown previously.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`方法作为元类的一部分的另一个用例是控制类定义的构建方式。这与`__new__()`控制构建不可变对象的方式不同，前面已经展示过。'
- en: A metaclass builds a class. Once a class object has been built, the class object
    is used to build instances. The metaclass of all class definitions is `type`.
    The `type()` function is used to create class objects.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 元类构建一个类。一旦类对象被构建，类对象就被用来构建实例。所有类定义的元类都是`type`。`type()`函数用于创建类对象。
- en: Additionally, the `type()` function can be used as a function to reveal the
    class of an object.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`type()`函数可以作为一个函数来显示对象的类。
- en: 'The following is a silly example of building a new, nearly useless class directly
    with `type()` as a constructor:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个用`type()`直接构建一个新的、几乎无用的类的愚蠢示例：
- en: '[PRE137]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Once we've created this class, we can create objects of this `Useless` class.
    However, they won't do much because they have no methods or attributes.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了这个类，我们就可以创建这个`Useless`类的对象。但是，它们不会做太多事情，因为它们没有方法或属性。
- en: 'We can use this newly-minted `Useless` class to create objects, for what little
    it''s worth. The following is an example:'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个新创建的`Useless`类来创建对象，尽管价值不大。以下是一个例子：
- en: '[PRE138]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: We can add attributes to the objects of this class. It does work, minimally,
    as an object.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向这个类的对象添加属性。它确实可以作为一个对象工作。
- en: 'This is almost equivalent to using `types.SimpleNamespace` or defining a class
    as follows:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎等同于使用`types.SimpleNamespace`或者以下方式定义一个类：
- en: '[PRE139]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'This brings up the important question: why would we mess with the way classes
    are defined in the first place?'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个重要的问题：为什么我们要首先搞乱类的定义方式呢？
- en: 'The answer is that some of the default features of a class aren''t *perfectly*
    applicable to some edge cases. We''ll talk about four situations where we might
    want to introduce a metaclass:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，一些类的默认特性并不完全适用于一些边缘情况。我们将讨论四种情况，我们可能想要引入一个元类：
- en: We can use a metaclass to preserve some information about the source text for
    a class. A class built by the built-in `type` uses `dict` to store the various
    methods and class-level attributes. As `dict` is inherently unordered, the attributes
    and methods appear in no particular order. It's extremely unlikely that they would
    appear in the order originally presented in the source. We'll show this in our
    first example.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用元类来保留关于类的源文本的一些信息。由内置的`type`构建的类使用`dict`来存储各种方法和类级属性。由于`dict`是无序的，属性和方法没有特定的顺序。它们极不可能按照源代码中最初的顺序出现。我们将在第一个示例中展示这一点。
- en: Metaclasses are used to create **Abstract Base Classes** (**ABC**) that we'll
    look at from Chapters 4 through 7\. An ABC relies on a metaclass `__new__()` method
    to confirm that the concrete subclass is complete. We'll introduce this in [Chapter
    4](ch04.html "Chapter 4. The ABCs of Consistent Design"), *The ABCs of Consistent
    Design*.
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类用于创建**抽象基类**（**ABC**），我们将在第4章到第7章中介绍。ABC依赖于元类`__new__()`方法来确认具体子类是否完整。我们将在[第4章](ch04.html
    "第4章。一致设计的ABC")中介绍这一点，*一致设计的ABC*。
- en: Metaclasses can be used to simplify some aspects of object serialization. We'll
    look at this in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON,
    YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV,
    and XML*.
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类可以用来简化对象序列化的一些方面。我们将在[第9章](ch09.html "第9章。序列化和保存-JSON、YAML、Pickle、CSV和XML")中介绍这一点，*序列化和保存-JSON、YAML、Pickle、CSV和XML*。
- en: As a final and rather easy example, we'll look at a self-reference within a
    class. We'll design classes that reference a *master* class. This isn't a superclass-subclass
    relationship. It's a bunch of subclasses that are peer subclasses but have an
    association with one of its peer group as being the master. To be consistent with
    its peers, the master needs a reference to itself, something that's impossible
    without a metaclass. This will be our second example.
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为最后一个相当简单的例子，我们将看一个类内的自引用。我们将设计引用*master*类的类。这不是一个超类-子类关系。这是一组同级子类，但与同级群体中的一个类有关联，作为主类。为了与同级保持一致，主类需要引用自身，这是不可能的，没有元类。这将是我们的第二个例子。
- en: Metaclass example 1 – ordered attributes
  id: totrans-816
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元类示例1-有序属性
- en: This is the canonical example in section 3.3.3, *Customizing Class Creation*,
    of *Python Language Reference*. This metaclass will record the order in which
    the attributes and method functions are defined.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 这是《Python语言参考》第3.3.3节“自定义类创建”的典型示例。这个元类将记录属性和方法函数定义的顺序。
- en: 'The recipe has the following three parts:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方有以下三个部分：
- en: Create a metaclass. The `__prepare__()` and `__new__()` functions of that metaclass
    will change the way a target class is built, replacing a plain-old `dict` class
    with the `OrderedDict` class.
  id: totrans-819
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个元类。该元类的`__prepare__()`和`__new__()`函数将改变目标类的构建方式，用`OrderedDict`类替换了普通的`dict`类。
- en: Create an abstract superclass that is based on the metaclass. This abstract
    class simplifies the inheritance for other classes.
  id: totrans-820
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基于元类的抽象超类。这个抽象类简化了其他类的继承。
- en: Create subclasses of the abstract superclass that benefit from the metaclass.
  id: totrans-821
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建从抽象超类派生的子类，这些子类受益于元类。
- en: 'The following is the example metaclass that will retain the order of the creation
    of the attribute:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是将保留属性创建顺序的示例元类：
- en: '[PRE140]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This class extends the built-in default metaclass, `type`, with a new version
    of `__prepare__()` and `__new__()`.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了内置的默认元类`type`，使用了`__prepare__()`和`__new__()`的新版本。
- en: The `__prepare__()` method is executed prior to the creation of the class; its
    job is to create the initial namespace object into which the definitions will
    be added. This method could work on any other preparation prior to the execution
    of the class body that is being processed.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '`__prepare__()`方法在创建类之前执行；它的工作是创建初始的命名空间对象，其中将添加定义。这个方法可以在处理类体之前的任何其他准备工作上工作。'
- en: 'The `__new__()` static method is executed after the class body elements have
    been added to the namespace. It is given the class object, the class name, the
    superclass tuple, and the fully built namespace mapping object. This example is
    typical: it delegates the real work of `__new__()` to the superclass; the superclass
    of a metaclass is the built-in `type`; we use `type.__new__()` to create the default
    class object that can be tweaked.'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: '`__new__()`静态方法在类体元素被添加到命名空间后执行。它接收类对象、类名、超类元组和完全构建的命名空间映射对象。这个例子很典型：它将`__new__()`的真正工作委托给了超类；元类的超类是内置的`type`；我们使用`type.__new__()`来创建可以调整的默认类对象。'
- en: The `__new__()` method in this example adds an attribute, `_order`, into the
    class definition that shows us the original order of the attributes.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`__new__()`方法向类定义中添加了一个名为`_order`的属性，显示了属性的原始顺序。
- en: 'We can use this metaclass instead of `type` when defining a new abstract superclass,
    as follows:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在定义新的抽象超类时使用这个元类，而不是`type`。
- en: '[PRE141]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'We can then use this new abstract class as the superclass for any new classes
    that we define, as follows:'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以将这个新的抽象类作为我们定义的任何新类的超类，如下所示：
- en: '[PRE142]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'When we look at the `Something` class, we see the following code snippet:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`Something`类时，我们会看到以下代码片段：
- en: '[PRE143]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: We can consider exploiting this information to properly serialize the object
    or provide debugging information that is tied to the original source definitions.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以考虑利用这些信息来正确序列化对象或提供与原始源定义相关的调试信息。
- en: Metaclass example 2 – self-reference
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元类示例2-自引用
- en: We'll look at an example that involves unit conversion. For example, units of
    length include meters, centimeters, inches, feet, and numerous other units. Managing
    unit conversions can be challenging. Superficially, we need a matrix of all possible
    conversion factors among all the various units. Feet to meters, feet to inches,
    feet to yards, meters to inches, meters to yards, and so on—every combination.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个涉及单位转换的例子。例如，长度单位包括米、厘米、英寸、英尺和许多其他单位。管理单位转换可能是具有挑战性的。表面上，我们需要一个包含所有各种单位之间所有可能转换因子的矩阵。英尺到米，英尺到英寸，英尺到码，米到英寸，米到码，等等-每一种组合。
- en: 'Practically, however, we can do better than this if we define a standard unit
    for length. We can convert any unit to the standard and the standard to any other
    unit. By doing this, we can easily perform any possible conversion as a two-step
    operation, eliminating the complex matrix of all possible conversions: feet to
    standard, inches to standard, yards to standard, meters to standard.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果我们定义一个长度的标准单位，我们可以做得更好。我们可以将任何单位转换为标准单位，将标准单位转换为任何其他单位。通过这样做，我们可以轻松地执行任何可能的转换作为一个两步操作，消除了所有可能转换的复杂矩阵：英尺到标准单位，英寸到标准单位，码到标准单位，米到标准单位。
- en: In the following example, we're not going to subclass `float` or `numbers.Number`
    in any way. Rather than binding the unit to the value, we'll allow each value
    to remain a simple number. This is an example of a **Flyweight** design pattern.
    The class doesn't define objects that contain the relevant value. The objects
    only contain the conversion factors.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们不会以任何方式对`float`或`numbers.Number`进行子类化。我们不会将单位绑定到值，而是允许每个值保持一个简单的数字。这是**享元**设计模式的一个例子。这个类不定义包含相关值的对象。对象只包含转换因子。
- en: The alternative (binding units to values) leads to rather complex dimensional
    analysis. While interesting, it's rather complex.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法（将单位绑定到值）会导致相当复杂的维度分析。虽然有趣，但相当复杂。
- en: 'We''ll define two classes: `Unit` and `Standard_Unit`. We can easily be sure
    that each `Unit` class has a reference to its appropriate `Standard_Unit`. How
    can we ensure that each `Standard_Unit` class has a reference to itself? Self-referencing
    within a class definition is impossible because the class hasn''t been defined
    yet.'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义两个类：`Unit`和`Standard_Unit`。我们可以很容易确保每个`Unit`类都有一个指向其适当`Standard_Unit`的引用。我们如何确保每个`Standard_Unit`类都有一个指向自身的引用？在类定义内部进行自引用是不可能的，因为类还没有被定义。
- en: 'The following is our `Unit` class definition:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`Unit`类定义：
- en: '[PRE144]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The intent is that `Unit.value()` will convert a value in the given unit to
    the standard unit. The `Unit.convert()` method will convert a standard value to
    the given unit.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的意图是`Unit.value()`将把给定单位的值转换为标准单位。`Unit.convert()`方法将把标准值转换为给定单位。
- en: 'This allows us to work with units, as shown in the following code snippet:'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用单位，如下面的代码片段所示：
- en: '[PRE145]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: The values created are built-in `float` values. For temperatures, the `value()`
    and `convert()` methods need to be overridden, as a simple multiplication doesn't
    work.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的值是内置的`float`值。对于温度，需要重写`value()`和`convert()`方法，因为简单的乘法不起作用。
- en: 'For `Standard_Unit`, we''d like to do something as follows:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`Standard_Unit`，我们想做如下的事情：
- en: '[PRE146]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: However, that won't work. `INCH` hasn't been defined within the body of `INCH`.
    The class doesn't exist until after the definition.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这样做是行不通的。`INCH`在`INCH`的主体内部还没有被定义。在定义之后类才存在。
- en: 'We could, as a fallback, do this:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 作为备选方案，我们可以这样做：
- en: '[PRE147]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: However, that's rather ugly.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这相当丑陋。
- en: 'We could define a decorator as follows:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个装饰器如下：
- en: '[PRE148]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: This decorator function could tweak the class definition to add an attribute.
    We'll return to this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器函数可以调整类定义以添加一个属性。我们将在[第8章](ch08.html "第8章。装饰器和混入-横切面")*装饰器和混入-横切面*中回到这个问题。
- en: 'Instead, we''ll define a metaclass that can insert a circular reference into
    the class definition, as follows:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将定义一个元类，可以将循环引用插入类定义，如下所示：
- en: '[PRE149]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This forces the class variable standard into the class definition.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这迫使类变量标准进入类定义。
- en: For most units, `SomeUnit.standard` references `TheStandardUnit` class. In parallel
    with that we'll also have `TheStandardUnit.standard` referencing `TheStandardUnit`
    class, also. This consistent structure among the `Unit` and `Standard_Unit` subclasses
    can help with writing the documentation and automating the unit conversions.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数单位，`SomeUnit.standard`引用`TheStandardUnit`类。与此同时，我们还将有`TheStandardUnit.standard`引用`TheStandardUnit`类。`Unit`和`Standard_Unit`子类之间的这种一致结构可以帮助编写文档并自动化单位转换。
- en: 'The following is the `Standard_Unit` class:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Standard_Unit`类：
- en: '[PRE150]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: The unit conversion factor inherited from `Unit` is 1.0, so this class does
    nothing to the supplied values. It includes the special metaclass definition so
    that it will have a self-reference that clarifies that this class is the standard
    for this particular dimension of measurement.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Unit`继承的单位转换因子是1.0，因此这个类对提供的值没有任何作用。它包括特殊的元类定义，以便它将有一个自引用，澄清这个类是这个特定测量维度的标准。
- en: As an optimization, we could override the `value()` and `convert()` methods
    to avoid the multiplication and division.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种优化，我们可以重写`value()`和`convert()`方法以避免乘法和除法。
- en: 'The following are some sample class definitions for units:'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些单位的样本类定义：
- en: '[PRE151]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: We defined `INCH` as the standard unit. The other units' definitions will convert
    to and from inches.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`INCH`定义为标准单位。其他单位的定义将转换为英寸和从英寸转换。
- en: 'We''ve provided some documentation for each unit: the full name in the docstring
    and a short name in the `name` attribute. The conversion factor is automatically
    applied by the `convert()` and `value()` functions inherited from `Unit`.'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个单位提供了一些文档：在文档字符串中是全名，在`name`属性中是简称。转换因子是通过从`Unit`继承的`convert()`和`value()`函数自动应用的。
- en: 'These definitions allow the following kind of programming in our applications:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义允许我们的应用程序进行以下类型的编程：
- en: '[PRE152]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: We can set a particular measurement from a given value in inches and report
    that value in any other compatible unit.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从给定的英寸值中设置特定的测量，并以任何其他兼容的单位报告该值。
- en: 'What the metaclass does is allow us to make queries like this from the unit-definition
    classes:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 元类的作用是允许我们从单位定义类中进行这样的查询：
- en: '[PRE153]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: These kinds of references can allow us to track all the various units of a given
    dimension.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 这些引用可以让我们跟踪给定维度的所有各种单位。
- en: Summary
  id: totrans-874
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've looked at a number of *basic* special methods, which are essential features
    of any class that we design. These methods are already part of every class, but
    the defaults we inherit from the object may not match our processing requirements.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过一些*基本*特殊方法，这些是我们设计的任何类的基本特性。这些方法已经是每个类的一部分，但我们从对象继承的默认值可能不符合我们的处理要求。
- en: We'll almost always have a need to override `__repr__()`, `__str__()`, and `__format__()`.
    The default implementations of these methods aren't very helpful at all.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎总是需要覆盖`__repr__()`、`__str__()`和`__format__()`。这些方法的默认实现并不是很有帮助。
- en: We rarely need to override `__bool__()` unless we're writing our own collection.
    That's the subject of [Chapter 6](ch06.html "Chapter 6. Creating Containers and
    Collections"), *Creating Containers and Collections*.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少需要覆盖`__bool__()`，除非我们正在编写自己的集合。这是[第6章](ch06.html "第6章。创建容器和集合")的主题，*创建容器和集合*。
- en: We often need to override the comparison and `__hash__()` methods. The definitions
    are suitable for simple immutable objects but not at all appropriate for mutable
    objects. We may not need to write all the comparison operators; we'll look at
    the `@functools.total_ordering` decorator in [Chapter 8](ch08.html "Chapter 8. Decorators
    and Mixins – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常需要覆盖比较和`__hash__()`方法。这些定义适用于简单的不可变对象，但对于可变对象则完全不合适。我们可能不需要编写所有的比较运算符；我们将在[第8章](ch08.html
    "第8章。装饰器和混合 - 横切方面")中看到`@functools.total_ordering`装饰器，*装饰器和混合 - 横切方面*。
- en: The other two *basic* special method names, `__new__()` and `__del__()`, are
    for more specialized purposes. Using `__new__()` to extend an immutable class
    is the most common use case for this method function.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 另外两个*基本*特殊方法名称`__new__()`和`__del__()`是用于更专门的目的。使用`__new__()`来扩展不可变类是这种方法函数的最常见用例。
- en: 'These basic special methods, along with `__init__()`, will appear in almost
    every class definition we write. The rest of the special methods are for more
    specialized purposes; they fall into six discrete categories:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 这些基本特殊方法，以及`__init__()`，几乎会出现在我们编写的每个类定义中。其余的特殊方法是为更专门的目的而设计的；它们分为六个离散的类别：
- en: '**Attribute Access**: These special methods implement what we see as `object.attribute`
    in an expression, `object.attribute` on the left-hand side of assignment, and
    `object.attribute` in a `del` statement.'
  id: totrans-881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**属性访问**：这些特殊方法实现了我们在表达式中看到的`object.attribute`，在赋值的左侧看到的`object.attribute`，以及在`del`语句中看到的`object.attribute`。'
- en: '**Callables**: A special method implements what we see as a function applied
    to arguments, much like the built-in `len()` function.'
  id: totrans-882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可调用**：一个特殊方法实现了我们所看到的作为应用于参数的函数，就像内置的`len()`函数一样。'
- en: '**Collections**: These special methods implement the numerous features of collections.
    This involves things such as `sequence[index]`, `mapping[key]`, and `set | set`.'
  id: totrans-883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集合**：这些特殊方法实现了集合的许多特性。这涉及诸如`sequence[index]`、`mapping[key]`和`set | set`等内容。'
- en: '**Numbers**: These special methods provide the arithmetic operators and the
    comparison operators. We can use these methods to expand the domain of numbers
    that Python works with.'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数字**：这些特殊方法提供了算术运算符和比较运算符。我们可以使用这些方法来扩展Python处理的数字域。'
- en: '**Contexts**: There are two special methods we''ll use to implement a context
    manager that works with the `with` statement.'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：有两个特殊方法，我们将使用它们来实现一个与`with`语句一起工作的上下文管理器。'
- en: '**Iterators**: There are special methods that define an iterator. This isn''t
    essential, as generator functions handle this feature so elegantly. However, we''ll
    look at how we can design our own iterators.'
  id: totrans-886
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代器：有一些特殊的方法来定义迭代器。这并非必要，因为生成器函数如此优雅地处理了这个特性。然而，我们将看看如何设计我们自己的迭代器。
- en: In the next chapter, we will address attributes, properties, and descriptors.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论属性、属性和描述符。
- en: Chapter 3. Attribute Access, Properties, and Descriptors
  id: totrans-888
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。属性访问、属性和描述符
- en: An object is a collection of features, including methods and attributes. The
    default behavior of the `object` class involves setting, getting, and deleting
    named attributes. We often need to modify this behavior to change the attributes
    available in an object.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是一组特性，包括方法和属性。`object`类的默认行为涉及设置、获取和删除命名属性。我们经常需要修改这种行为，以改变对象中可用的属性。
- en: 'This chapter will focus on the following five tiers of attribute access:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍属性访问的以下五个层次：
- en: We'll look at built-in attribute processing, which is the simplest, but least
    sophisticated option.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将研究内置属性处理，这是最简单但最不复杂的选项。
- en: We'll review the `@property` decorator. A property extends the concept of an
    attribute to include the processing defined in method functions.
  id: totrans-892
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将回顾`@property`装饰器。属性扩展了属性的概念，包括在方法函数中定义的处理。
- en: 'We''ll look at how to make use of the lower-level special methods that control
    attribute access: `__getattr__()`, `__setattr__()`, and `__delattr__()`. These
    special methods allow us to build more sophisticated attribute processing.'
  id: totrans-893
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将研究如何利用控制属性访问的低级特殊方法：`__getattr__()`、`__setattr__()`和`__delattr__()`。这些特殊方法允许我们构建更复杂的属性处理。
- en: We'll also take a look at the `__getattribute__()` method, which provides more
    granular control over attributes. This can allow us to write very unusual attribute
    handling.
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还将看一下`__getattribute__()`方法，它可以更精细地控制属性。这可以让我们编写非常不寻常的属性处理。
- en: Finally, we'll take a look at descriptors. These are used to access an attribute,
    but they involve somewhat more complex design decisions. Descriptors are used
    heavily by Python under the hood to implement properties, static methods, and
    class methods.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将看一下描述符。这些用于访问属性，但它们涉及更复杂的设计决策。描述符在Python底层被大量使用，用于实现属性、静态方法和类方法。
- en: In this chapter, we'll see how the default processing works in detail. We need
    to decide where and when to override the default behavior. In some cases, we want
    our attributes to do more than simply be instance variables. In other cases, we
    might want to prevent adding attributes. We may have attributes that have even
    more complex behaviors.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细了解默认处理的工作原理。我们需要决定何时以及在何处覆盖默认行为。在某些情况下，我们希望我们的属性不仅仅是实例变量。在其他情况下，我们可能希望阻止添加属性。我们可能有更复杂的行为属性。
- en: Also, as we explore descriptors, we'll come to a much deeper understanding of
    how Python's internals work. We don't often need to use descriptors explicitly.
    We often use them implicitly, however, because they're the mechanism that implements
    a number of Python features.
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当我们探索描述符时，我们将更深入地了解Python内部的工作原理。我们通常不需要显式使用描述符。但我们经常隐式使用它们，因为它们是实现许多Python特性的机制。
- en: Basic attribute processing
  id: totrans-898
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本属性处理
- en: 'By default, any class we create will permit the following four behaviors with
    respect to attributes:'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们创建的任何类都将允许以下四种属性行为：
- en: To create a new attribute by setting its value
  id: totrans-900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设置其值来创建一个新属性
- en: To set the value of an existing attribute
  id: totrans-901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置现有属性的值
- en: To get the value of an attribute
  id: totrans-902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取属性的值
- en: To delete an attribute
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除属性
- en: 'We can experiment with this using something as simple as the following code.
    We can create a simple, generic class and an object of that class:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下简单的代码进行实验。我们可以创建一个简单的通用类和该类的一个对象：
- en: '[PRE154]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The preceding code permits us to create, get, set, and delete attributes. We
    can easily create and get an attribute. The following are some examples:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许我们创建、获取、设置和删除属性。我们可以轻松地创建和获取属性。以下是一些示例：
- en: '[PRE155]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We can add, change, and remove attributes. We will get exceptions if we try
    to get an otherwise unset attribute or delete an attribute that doesn't exist
    yet.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加、更改和删除属性。如果尝试获取未设置的属性或删除尚不存在的属性，将会引发异常。
- en: 'A slightly better way to do this is using an instance of the class `types.SimpleNamespace`
    class. The feature set is the same, but we don''t need to create an extra class
    definition. We create an object of the `SimpleNamespace` class instead, as follows:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的一个稍微更好的方法是使用`types.SimpleNamespace`类的一个实例。功能集是相同的，但我们不需要创建额外的类定义。我们可以创建`SimpleNamespace`类的对象，如下所示：
- en: '[PRE156]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'In the following code, we can see that the same use cases work for a `SimpleNamespace`
    class:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们可以看到相同的用例适用于`SimpleNamespace`类：
- en: '[PRE157]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: We can create attributes for this object. Any attempt to use an undefined attribute
    raises an exception. A `SimpleNamespace` class has different behavior from what
    we saw when we created an instance of the object class.. A simple instance of
    the object class doesn't permit the creation of new attributes; it lacks the internal
    `__dict__` structure that Python stores attributes and values in.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为此对象创建属性。任何尝试使用未定义的属性都会引发异常。`SimpleNamespace`类的行为与我们创建对象类的实例时所看到的不同。对象类的简单实例不允许创建新属性；它缺少Python存储属性和值的内部`__dict__`结构。
- en: Attributes and the __init__() method
  id: totrans-914
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性和`__init__()`方法
- en: Most of the time, we create an initial suite of attributes using the `__init__()`
    method of a class. Ideally, we provide default values for all the attributes in
    `__init__()`.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们使用类的`__init__()`方法创建一组初始属性。理想情况下，我们在`__init__()`中为所有属性提供默认值。
- en: It's *not* required to provide all attributes in the `__init__()` method. Because
    of this, the presence or absence of an attribute can be used as part of an object's
    state.
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: 在`__init__()`方法中*不*需要提供所有属性。因此，属性的存在或不存在可以作为对象状态的一部分。
- en: An optional attribute pushes the edge of the envelope for class definition.
    It makes considerable sense for a class to have a well-defined set of attributes.
    Attributes can often be added (or removed) more clearly by creating a subclass
    or superclass.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性推动了类定义的边界。一个类拥有一组明确定义的属性是非常合理的。通过创建子类或超类，可以更清晰地添加（或删除）属性。
- en: Consequently, optional attributes imply a kind of informal subclass relationship.
    Therefore, we bump up against Pretty Poor Polymorphism when we use optional attributes.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可选属性意味着一种非正式的子类关系。因此，当我们使用可选属性时，我们会遇到相当差的多态性。
- en: 'Consider a Blackjack game in which only a single split is permitted. If a hand
    is split, it cannot be resplit. There are several ways that we can model this:'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个只允许单次分牌的二十一点游戏。如果一手被分牌，就不能再次分牌。我们可以用几种方式来建模：
- en: We can create a subclass for `SplitHand` from the `Hand.split()` method. We
    won't show this in detail.
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以从`Hand.split()`方法创建一个`SplitHand`的子类。我们不会详细展示这一点。
- en: We can create a status attribute on an object named `Hand`, which can be created
    from the `Hand.split()` method. Ideally, this is a Boolean value, but we can implement
    it as an optional attribute as well.
  id: totrans-921
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在名为`Hand`的对象上创建一个状态属性，该对象可以从`Hand.split()`方法创建。理想情况下，这是一个布尔值，但我们也可以将其实现为可选属性。
- en: 'The following is a version of `Hand.split()` that can detect splittable versus
    unsplittable hands via an optional attribute:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Hand.split()`的一个版本，它可以通过可选属性检测可分割与不可分割的手：
- en: '[PRE158]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: In effect, the `split()` method tests to see if there's a `split_count` attribute.
    If this attribute exists, then this is a split hand and the method raises an exception.
    If the `split_count` attribute does not exist, this is an initial deal, and splitting
    is allowed.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`split()`方法测试是否存在`split_count`属性。如果存在这个属性，则这是一个分牌手，该方法会引发异常。如果`split_count`属性不存在，则这是一个初始发牌，允许分牌。
- en: An optional attribute has the advantage of leaving the `__init__()` method relatively
    uncluttered with status flags. It has the disadvantage of obscuring some aspects
    of object state. This use of a `try:` block to determine object state can be very
    confusing and should be avoided.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 可选属性的优势在于使`__init__()`方法相对不那么混乱，没有状态标志。它的缺点是模糊了对象状态的某些方面。使用`try:`块来确定对象状态可能会非常令人困惑，应该避免。
- en: Creating properties
  id: totrans-926
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建属性
- en: A property is a method function that appears (syntactically) to be a simple
    attribute. We can get, set, and delete property values similarly to how we can
    get, set, and delete attribute values. There's an important distinction here.
    A property is actually a method function and can process, rather than simply preserve,
    a reference to another object.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是一个方法函数，从语法上看，它是一个简单的属性。我们可以像获取、设置和删除属性值一样获取、设置和删除属性值。这里有一个重要的区别。属性实际上是一个方法函数，可以处理引用另一个对象，而不仅仅是保留引用。
- en: Besides the level of sophistication, one other difference between properties
    and attributes is that we can't attach new properties to an existing object easily;
    however, we can add attributes to an object easily, by default. A property is
    not identical to simple attributes in this one respect.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 除了复杂程度之外，属性和属性之间的另一个区别是，我们不能轻松地将新属性附加到现有对象；但是，我们可以轻松地向对象添加属性，默认情况下。在这一点上，属性与简单属性并不相同。
- en: There are two ways to create properties. We can use the `@property` decorator
    or we can use the `property()` function. The differences are purely syntactic.
    We'll focus on the decorator.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 创建属性有两种方法。我们可以使用`@property`装饰器，也可以使用`property()`函数。区别纯粹是语法上的。我们将专注于装饰器。
- en: 'We''ll take a look at two basic design patterns for properties:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看两种属性的基本设计模式：
- en: '**Eager calculation**: In this design pattern, when we set a value via a property,
    other attributes are also computed'
  id: totrans-931
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**急切计算**：在这种设计模式中，当我们通过属性设置值时，其他属性也会被计算'
- en: '**Lazy calculation**: In this design pattern, calculations are deferred until
    requested via a property'
  id: totrans-932
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**懒惰计算**：在这种设计模式中，计算被推迟到通过属性请求时'
- en: 'In order to compare the preceding two approaches to properties, we''ll split
    some common features of the `Hand` object into an abstract superclass, as follows:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较前面两种属性的方法，我们将`Hand`对象的一些常见特性拆分为一个抽象的超类，如下所示：
- en: '[PRE159]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: In the preceding code, we defined just some string representation methods and
    nothing else.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只定义了一些字符串表示方法，没有别的。
- en: 'The following is a subclass of `Hand`, where `total` is a lazy property that
    is computed only when needed:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Hand`的一个子类，其中`total`是一个懒惰计算的属性，只有在需要时才计算：
- en: '[PRE160]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The `Hand_Lazy` class initializes a `Hand` object with a list of the `Cards`
    object. The `total` property is a method that computes the total only when requested.
    Additionally, we defined some other properties to update the collection of cards
    in the hand. The `card` property can get, set, or delete cards in the hand. We'll
    take a look at these properties in setter and deleter properties section.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hand_Lazy`类使用`Cards`对象的列表初始化一个`Hand`对象。`total`属性是一个方法，只有在请求时才计算总数。此外，我们定义了一些其他属性来更新手中的卡片集合。`card`属性可以获取、设置或删除手中的卡片。我们将在设置器和删除器属性部分查看这些属性。'
- en: 'We can create a `Hand` object, `total` appears to be a simple attribute:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个`Hand`对象，`total`看起来就像一个简单的属性：
- en: '[PRE161]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The total is computed lazily by rescanning the cards in the hand each time the
    total is requested. This can be an expensive overhead.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 总数是通过每次请求总数时重新扫描手中的卡片来进行懒惰计算的。这可能是一个昂贵的开销。
- en: Eagerly computed properties
  id: totrans-942
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 急切计算的属性
- en: 'The following is a subclass of `Hand`, where `total` is a simple attribute
    that''s computed eagerly as each card is added:'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`Hand`的一个子类，其中`total`是一个简单属性，每添加一张卡片都会急切计算：
- en: '[PRE162]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: In this case, each time a card is added, the `total` attribute is updated.
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，每次添加一张卡片时，`total`属性都会更新。
- en: The other `card` property—the deleter—eagerly updates the `total` attribute
    whenever a card is removed. We'll take a look at the deleter in detail in the
    next section.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`card`属性——删除器——在删除卡片时急切地更新`total`属性。我们将在下一节详细介绍删除器。
- en: 'A client sees the same syntax between these two subclasses (`Hand_Lazy()` and
    `Hand_Eager()`) of `Hand`:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在这两个子类（`Hand_Lazy()`和`Hand_Eager()`）中看到相同的语法：
- en: '[PRE163]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: In both cases, the client software simply uses the `total` attribute.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，客户端软件只是使用`total`属性。
- en: 'The advantage of using properties is that the syntax doesn''t have to change
    when the implementation changes. We can make a similar claim for getter/setter
    method functions. However, getter/setter method functions involve extra syntax
    that isn''t very helpful nor informative. The following are two examples, one
    of which is using a setter method and the other that is using the assignment operator:'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: 使用属性的优势在于，当实现更改时，语法不必更改。我们也可以对getter/setter方法函数提出类似的要求。但是，getter/setter方法函数涉及的额外语法并不是很有帮助，也不具有信息性。以下是两个示例，一个使用了setter方法，另一个使用了赋值运算符：
- en: '[PRE164]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: The presence of the assignment operator (`=`) makes the intent very plain. Many
    programmers find it clearer to look for assignment statements than to look for
    setter method functions.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符（`=`）的存在使意图非常明显。许多程序员发现查找赋值语句比查找setter方法函数更清晰。
- en: Setter and deleter properties
  id: totrans-953
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置器和删除器属性
- en: In the previous examples, we defined the `card` property to deal additional
    cards into an object of the `Hand` class.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了`card`属性，将额外的卡片分发到`Hand`类的对象中。
- en: 'Since setter (and deleter) properties are created from the getter property,
    we must always define a getter property first using the following code:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 由于setter（和deleter）属性是从getter属性创建的，我们必须始终首先使用以下代码定义getter属性：
- en: '[PRE165]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'This allows us to add a card to the hand with a simple statement like the following:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够通过以下简单的语句将一张卡添加到手中：
- en: '[PRE166]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: The preceding assignment statement has a disadvantage because it looks like
    it replaces all the cards with a single card. On the other hand, it also has an
    advantage because it uses simple assignment to update the state of a mutable object.
    We can use the `__iadd__()` special method to do this a little more cleanly. But,
    we'll wait until [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating
    Numbers*, to introduce the other special methods.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的赋值语句有一个缺点，因为它看起来像是用一张卡替换了所有的卡。另一方面，它也有一个优点，因为它使用简单的赋值来更新可变对象的状态。我们可以使用`__iadd__()`特殊方法来更清晰地做到这一点。但是，我们将等到[第7章](ch07.html
    "第7章。创建数字")*创建数字*，来介绍其他特殊方法。
- en: For our current examples, there's no compelling reason to use a deleter property.
    Even without a compelling reason, there's still some use for a deleter. We could,
    however, make use of it to remove the last dealt card. This can be used as part
    of the process for splitting a hand.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们目前的示例，没有强制使用deleter属性的理由。即使没有强制使用的理由，deleter仍然有一些用途。然而，我们可以利用它来移除最后一张发出的卡片。这可以作为分割手牌过程的一部分使用。
- en: 'We will consider a version of `split()` that works like the following code:'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑一个类似以下代码的`split()`版本：
- en: '[PRE167]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The preceding method updates the given hand and returns a new hand. The following
    is an example of a hand being split:'
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法更新了给定的手牌并返回一个新的手牌。以下是手牌分割的一个示例：
- en: '[PRE168]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Once we have two cards, we can use `split()` to produce the second hand. A card
    was removed from the initial hand.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了两张卡，我们就可以使用`split()`来产生第二手牌。一张卡从初始手牌中被移除。
- en: This version of `split()` is certainly workable. However, it seems somewhat
    better to have the `split()` method return two fresh new `Hand` objects. That
    way, the old, presplit `Hand` instance can be used as a memento to gather statistics.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`split()`版本肯定可行。然而，似乎更好的是让`split()`方法返回两个全新的`Hand`对象。这样，旧的、预分割的`Hand`实例可以用作收集统计信息的备忘录。
- en: Using special methods for attribute access
  id: totrans-967
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用特殊方法进行属性访问
- en: 'We''ll look at the three canonical special methods for attribute access: `__getattr__()`,
    `__setattr__()`, and `__delattr__()`. Additionally, we''ll acknowledge the `__dir__()`
    method to reveal attribute names. We''ll defer `__getattribute__()` to the next
    section.'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究三种用于属性访问的经典特殊方法：`__getattr__()`、`__setattr__()`和`__delattr__()`。此外，我们将使用`__dir__()`方法来显示属性名称。我们将在下一节中讨论`__getattribute__()`。
- en: 'The default behavior shown in the first section is as follows:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 第一节中显示的默认行为如下：
- en: The `__setattr__()` method will create and set attributes.
  id: totrans-970
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__setattr__()`方法将创建并设置属性。'
- en: The `__getattr__()` method will do two things. Firstly, if an attribute already
    has a value, `__getattr__()` is not used; the attribute value is simply returned.
    Secondly, if the attribute does not have a value, then `__getattr__()` is given
    a chance to return a meaningful value. If there is no attribute, it must raise
    an `AttributeError` exception.
  id: totrans-971
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__getattr__()`方法将执行两件事。首先，如果属性已经有一个值，`__getattr__()`就不会被使用；属性值会直接返回。其次，如果属性没有值，那么`__getattr__()`就有机会返回一个有意义的值。如果没有属性，它必须引发`AttributeError`异常。'
- en: The `__delattr__()` method deletes an attribute.
  id: totrans-972
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delattr__()`方法删除一个属性。'
- en: The `__dir__()` method returns a list of attribute names.
  id: totrans-973
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__dir__()`方法返回属性名称的列表。'
- en: The `__getattr__()` method function is only one step in a larger process; it
    is only used if the attribute is otherwise unknown. If the attribute is a known
    attribute, this method is not used. The `__setattr__()` and `__delattr__()` methods
    do not have built-in processing. These methods don't interact with additional
    processing.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattr__()`方法函数只是更大过程中的一步；只有在属性否则未知时才会使用它。如果属性是已知属性，则不会使用此方法。`__setattr__()`和`__delattr__()`方法没有内置处理。这些方法不与其他处理交互。'
- en: 'We have a number of design choices for controlling attribute access. These
    follow our three essential design choices to extend, wrap, or invent. The design
    choices are as follows:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有许多设计选择来控制属性访问。这些选择遵循我们的三个基本设计选择：扩展、包装或发明。设计选择如下：
- en: We can extend a class, making it almost immutable by overriding `__setattr__()`
    and `__delattr__()`. We can also replace the internal `__dict__` with `__slots__`.
  id: totrans-976
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过覆盖`__setattr__()`和`__delattr__()`来扩展一个类，使其几乎不可变。我们还可以用`__slots__`替换内部的`__dict__`。
- en: We can wrap a class and delegate attribute access to the object (or composite
    of objects) being wrapped. This may involve overriding all three of these methods.
  id: totrans-977
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以包装一个类，并将属性访问委托给被包装的对象（或对象的组合）。这可能涉及覆盖这三种方法。
- en: We can implement property-like behaviors in a class. Using these methods, we
    can assure that all property processing is centralized.
  id: totrans-978
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在类中实现类似属性的行为。使用这些方法，我们可以确保所有属性处理都是集中的。
- en: We can create lazy attributes where the values aren't (or can't be) computed
    until they're needed. We may have an attribute that doesn't have a value until
    it's read from a file, database, or network. This is common use for `__getattr__()`.
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以创建延迟属性，直到需要它们时才计算值。我们可能有一个属性，直到从文件、数据库或网络中读取时才有值。这是`__getattr__()`的常见用法。
- en: We can have eager attributes, where setting an attribute creates values in other
    attributes automagically. This is done via overrides to `__setattr__()`.
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以有急切属性，其中设置一个属性会自动创建其他属性的值。这是通过对`__setattr__()`进行覆盖来实现的。
- en: 'We won''t look at all of these alternatives. Instead, we''ll focus on the two
    most commonly used techniques: extending and wrapping. We''ll create immutable
    objects and look at other ways to eagerly compute attribute values.'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会考虑所有这些替代方案。相反，我们将专注于两种最常用的技术：扩展和包装。我们将创建不可变对象，并研究急切计算属性值的其他方法。
- en: Creating immutable objects with __slots__
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用__slots__创建不可变对象
- en: 'If we are not able to set an attribute or create a new one, then the object
    is immutable. The following is what we''d like to see in interactive Python:'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们无法设置属性或创建新属性，那么对象就是不可变的。以下是我们希望在交互式Python中看到的：
- en: '[PRE169]'
  id: totrans-984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The preceding code shows that we are not allowed to change an attribute or add
    one to this object.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码表明，我们不允许更改此对象的属性或添加属性。
- en: 'We need to make two changes to a class definition for this to work. We''ll
    omit much of the class and focus on just the three features that make an object
    immutable, as follows:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要对类定义进行两处更改才能实现这一点。我们将省略大部分类，只关注使对象不可变的三个特性，如下所示：
- en: '[PRE170]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'We made three significant changes:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了三个重大改变：
- en: We set `__slots__` to the names of only the allowed attributes. This turns off
    the internal `__dict__` feature of the object and limits us to just the attributes
    and no more.
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`__slots__`设置为只允许属性的名称。这将关闭对象的内部`__dict__`功能，并限制我们只能使用属性，没有更多。
- en: We defined `__setattr__()` to raise an exception rather than do anything useful.
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了`__setattr__()`来引发异常，而不是做任何有用的事情。
- en: We defined `__init__()` to use the superclass version of `__setattr__()` so
    that values can be properly set in spite of the absence of a working `__setattr__()`
    method in this class.
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了`__init__()`来使用超类版本的`__setattr__()`，以便在这个类中没有有效的`__setattr__()`方法的情况下正确设置值。
- en: With some care, we can bypass the immutability feature if we work at it.
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些小心翼翼的处理，我们可以绕过不可变特性。
- en: '[PRE171]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: That brings us to a question. "How can we prevent an "evil" programmer from
    bypassing the immutability feature?" The question is silly. We can't stop the
    evil programmer. Another equally silly question is, "Why would some evil programmer
    write all that code to circumvent immutability?". We can't stop the evil programmer
    from doing evil things.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带来了一个问题。“我们如何防止一个‘邪恶’的程序员绕过不可变特性？”这个问题很愚蠢。我们无法阻止邪恶的程序员。另一个同样愚蠢的问题是，“为什么一些邪恶的程序员要写那么多代码来规避不可变性？”我们无法阻止邪恶的程序员做坏事。
- en: If this imaginary programmer doesn't like immutability in a class, they can
    modify the definition of the class to remove the redefinition of `__setattr__()`.
    The point of an immutable object like this is to guarantee `__hash__()` returning
    a consistent value and not to prevent people from writing rotten code.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个虚构的程序员不喜欢类中的不可变性，他们可以修改类的定义，以删除对`__setattr__()`的重新定义。这样一个不可变对象的目的是保证`__hash__()`返回一个一致的值，而不是阻止人们编写糟糕的代码。
- en: Tip
  id: totrans-996
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Don''t abuse __slots__**'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要滥用__slots__**'
- en: The `__slots__` feature is intended primarily to save memory by limiting the
    number of attributes.
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '`__slots__`特性主要是为了通过限制属性的数量来节省内存。'
- en: Creating immutable objects as a tuple subclass
  id: totrans-999
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将不可变对象创建为tuple子类
- en: We can also create an immutable object by making our `Card` property a subclass
    of `tuple` and an override to `__getattr__()`. In this case, we'll translate `__getattr__(name)`
    requests to `self[index]` requests. As we'll see in [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*, `self[index]`
    is implemented by `__getitem__(index)`.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过将我们的`Card`属性设置为`tuple`的子类，并覆盖`__getattr__()`来创建一个不可变对象。在这种情况下，我们将`__getattr__(name)`请求转换为`self[index]`请求。正如我们将在[第6章](ch06.html
    "第6章。创建容器和集合")中看到的那样，*创建容器和集合*，`self[index]`是由`__getitem__(index)`实现的。
- en: 'The following is a small extension to the built-in `tuple` class:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对内置的`tuple`类的一个小扩展：
- en: '[PRE172]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: In this example, we simply raised a simple `AttributeError` exception rather
    than providing detailed error messages.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是引发了一个简单的`AttributeError`异常，而没有提供详细的错误消息。
- en: 'When we use the preceding code, we see the following kinds of interaction:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用上面的代码时，我们会看到以下类型的交互：
- en: '[PRE173]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: We can't change the value of a card easily. However, we can still tweak `d.__dict__`
    to introduce *additional* attributes.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法轻易更改卡的值。但是，我们仍然可以调整`d.__dict__`来引入*额外*的属性。
- en: Note
  id: totrans-1007
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Is this really necessary?**'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: '**这真的有必要吗？**'
- en: This is, perhaps, too much work to simply assure that an object isn't accidentally
    misused. Practically, we're more interested in the diagnostic information available
    from an exception and traceback than we are in a super-secure immutable class.
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，这样做太麻烦了，只是为了确保对象不会被意外滥用。实际上，我们更感兴趣的是异常和回溯提供的诊断信息，而不是一个超级安全的不可变类。
- en: Eagerly computed attributes
  id: totrans-1010
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 急切计算的属性
- en: We can define an object where attributes are computed eagerly as soon as possible
    after a value is set. This object optimizes access by doing a computation once
    and leaving the result to be used multiple times.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一个对象，在设置值后尽快计算属性。这个对象通过一次计算来优化访问，并将结果留下来供多次使用。
- en: We're able to define a number of property setters to do this. However, a lot
    of property setters, each of which compute a number of attributes, can get wordy
    for a complex calculation.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义一些属性设置器来实现这一点。然而，对于复杂的计算，每个属性设置器都会计算多个属性，这可能会变得很啰嗦。
- en: We can centralize the attribute processing. In the following example, we'll
    use a few tweaks to extend Python's internal `dict` type. The advantage of extending
    `dict` is that it works well with the `format()` method of a string. Also, we
    don't have to worry much about setting extra attribute values that are otherwise
    ignored.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以集中处理属性。在下面的例子中，我们将使用一些调整来扩展Python内部的`dict`类型。扩展`dict`的优势在于它与字符串的`format()`方法很好地配合。此外，我们不必担心设置额外的属性值，否则这些值会被忽略。
- en: 'We''d like something that looks like the following code:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望看到类似下面的代码：
- en: '[PRE174]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'We can set the values in this `RateTimeDistance` object. Additional attributes
    are computed as soon as sufficient data is present. We can do this either all
    at once, as shown earlier, or in stages, as shown in the following code:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设置这个`RateTimeDistance`对象中的值。只要有足够的数据，就会计算额外的属性。我们可以像之前展示的那样一次性完成，也可以像下面的代码一样分阶段完成：
- en: '[PRE175]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The following is the extension to the built-in `dict` . We''ve extended the
    essential mapping that `dict` implements to compute a missing attribute:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是内置 `dict` 的扩展。我们扩展了 `dict` 实现的基本映射，以计算缺少的属性：
- en: '[PRE176]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: The `dict` type uses `__init__()` to populate the internal dictionary, then
    tries to solve if enough data is present. It uses `__setattr__()` to add new items
    to the dictionary. It also attempts to solve the equation each time a value is
    set.
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict` 类型使用 `__init__()` 来填充内部字典，然后尝试解决是否有足够的数据。它使用 `__setattr__()` 来向字典添加新项目。每次设置一个值时，它也会尝试解决方程。'
- en: In `__getattr__()`, we use `None` to indicate a missing value from the equation.
    This allows us to set an attribute to `None` to indicate that it is a missing
    value, and this will force the solution to look for this value. For example, we
    might do this based on user inputs or a network request where all parameters were
    given a value but one variable was set to `None`.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__getattr__()` 中，我们使用 `None` 来表示方程中的缺失值。这允许我们将属性设置为 `None` 来表示它是一个缺失值，并且这将迫使解决方案寻找这个值。例如，我们可能基于用户输入或网络请求进行这样的操作，其中所有参数都被赋予一个值，但一个变量被设置为
    `None`。
- en: 'We can use it as follows:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像下面这样使用它：
- en: '[PRE177]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Note
  id: totrans-1024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we can't set attribute values inside this class definition easily.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们不能轻松地在这个类定义内设置属性值。
- en: 'Let''s consider the following line of code:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下代码行：
- en: '[PRE178]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: If we were to write the preceding code snippet, we'd have infinite recursions
    between `__setattr__()` and `_solve()`. When we used `self['distance']` in the
    example, we avoided the recursive call of `__setattr__()`.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们编写上述代码片段，`__setattr__()` 和 `_solve()` 之间将会产生无限递归。在示例中，当我们使用 `self['distance']`
    时，我们避免了对 `__setattr__()` 的递归调用。
- en: It's also important to note that once all three values are set, this object
    can't be changed to provide new solutions easily.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意的是，一旦所有三个值都被设置，这个对象就不能轻松地提供新的解决方案了。
- en: 'We can''t simply set a new value for `rate` and compute a new value for `time`
    while leaving `distance` unchanged. To tweak this model, we need to both clear
    one variable and set a new value for another variable:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地设置 `rate` 的新值并计算 `time` 的新值，同时保持 `distance` 不变。为了调整这个模型，我们需要清除一个变量并为另一个变量设置一个新值：
- en: '[PRE179]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Here, we cleared `time` and changed `rate` to get a new solution for `time`
    using the established value for `distance`.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们清除了 `time` 并改变了 `rate` 以使用已建立的 `distance` 值来获得 `time` 的新解决方案。
- en: We could design a model that tracked the order that the variables were set in;
    this model could save us from having to clear one variable before setting another
    to recompute a related result.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一个跟踪变量设置顺序的模型；这个模型可以避免我们在重新计算相关结果之前清除一个变量然后设置另一个变量。
- en: The __getattribute__() method
  id: totrans-1034
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: __getattribute__() 方法
- en: An even lower level attribute processing is the `__getattribute__()` method.
    The default implementation attempts to locate the value as an existing attribute
    in the internal `__dict__` (or `__slots__`). If the attribute is not found, it
    calls `__getattr__()` as a fallback. If the value located is a descriptor (see
    in the following *Creating descriptors* section), then it processes the descriptor.
    Otherwise, the value is simply returned.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 更低级的属性处理是 `__getattribute__()` 方法。默认实现尝试在内部 `__dict__`（或 `__slots__`）中查找值作为现有属性。如果找不到属性，则调用
    `__getattr__()` 作为后备。如果找到的值是一个描述符（见下面的 *创建描述符* 部分），那么它会处理描述符。否则，值将被简单地返回。
- en: 'By overriding this method, we can perform any of the following kinds of tasks:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 通过覆盖这个方法，我们可以执行以下任何一种任务：
- en: We can effectively prevent access to attributes. This method, by raising an
    exception instead of returning a value, can make an attribute more secret than
    if we were to merely use the leading underscore (`_`) to mark a name as private
    to the implementation.
  id: totrans-1037
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以有效地阻止对属性的访问。通过引发异常而不是返回一个值，这种方法可以使属性比仅仅使用前导下划线 (`_`) 标记一个名称作为实现私有更加保密。
- en: We can invent new attributes similarly to how `__getattr__()` can invent new
    attributes. In this case, however, we can bypass the default lookup done by the
    default version of `__getattribute__()`.
  id: totrans-1038
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以像 `__getattr__()` 一样发明新的属性。然而，在这种情况下，我们可以绕过默认查找由默认版本的 `__getattribute__()`
    完成的查找。
- en: We can make attributes perform unique and different tasks. This might make the
    program very difficult to understand or maintain. This could be a terrible idea,
    also.
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使属性执行独特和不同的任务。这可能会使程序非常难以理解或维护。这也可能是一个可怕的主意。
- en: We can change the way descriptors behave. While technically possible, changing
    a descriptor's behavior sounds like a terrible idea.
  id: totrans-1040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以改变描述符的行为方式。虽然在技术上是可能的，但改变描述符的行为听起来像是一个可怕的主意。
- en: When we implement the `__getattribute__()` method, it's important to note that
    there cannot be any internal attribute access in the method's body. If we attempt
    to get the value for `self.name`, it will lead to infinite recursions.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现 `__getattribute__()` 方法时，重要的是要注意方法体中不能有任何内部属性访问。如果我们尝试获取 `self.name` 的值，将导致无限递归。
- en: Note
  id: totrans-1042
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `__getattribute__()` method cannot give any simple `self.name` attribute
    access; it will lead to infinite recursions.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: '`__getattribute__()` 方法不能简单地给出任何 `self.name` 属性访问；这将导致无限递归。'
- en: 'In order to get attribute values within the `__getattribute__()` method, we
    must explicitly refer to the base method defined in `object`, as shown in the
    following declaration:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `__getattribute__()` 方法内获取属性值，我们必须明确地引用在 `object` 中定义的基本方法，如下所示：
- en: '[PRE180]'
  id: totrans-1045
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'We could, for example, revise our immutable class to use `__getattribute__()`
    and prevent access to the internal `__dict__` attribute. The following is a class
    that conceals all the names beginning with the underscore character (`_`):'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以修改我们的不可变类，使用 `__getattribute__()` 并阻止对内部 `__dict__` 属性的访问。以下是一个隐藏所有以下划线字符
    (`_`) 开头的名称的类：
- en: '[PRE181]'
  id: totrans-1047
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'We''ve overridden `__getattribute__()` to raise an attribute error on private
    names as well as Python''s internal names. This has a microscopic advantage over
    the previous example: we are not allowed to tweak the object at all. We''ll see
    an example of an interaction with an instance of this class.'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重写了`__getattribute__()`，以便在私有名称和Python的内部名称上引发属性错误。这比之前的例子有微小的优势：我们根本不允许对对象进行调整。我们将看到与这个类的实例交互的一个例子。
- en: 'The following is an example of an object of this class being mutated:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个类的对象被改变的一个例子：
- en: '[PRE182]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: As general advice, it's rarely a good idea to mess with `__getattribute__()`.
    The default method is quite sophisticated, and almost everything we need is available
    as a property or as a change to `__getattr__()`.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般建议，擅自修改`__getattribute__()`通常不是一个好主意。默认方法非常复杂，几乎我们需要的一切都可以作为属性或者作为对`__getattr__()`的更改而获得。
- en: Creating descriptors
  id: totrans-1052
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建描述符
- en: A descriptor is a class that mediates attribute access. The descriptor class
    can be used to get, set, or delete attribute values. Descriptor objects are built
    inside a class at class definition time.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是一个调解属性访问的类。描述符类可以用来获取、设置或删除属性值。描述符对象是在类定义时内部构建的。
- en: 'The descriptor design pattern has two parts: an **owner class** and the **attribute
    descriptor** itself. The owner class uses one or more descriptors for its attributes.
    A descriptor class defines some combination of get, set, and delete methods. An
    instance of the descriptor class will be an attribute of the owner class.'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符设计模式有两个部分：一个**所有者类**和**属性描述符**本身。所有者类使用一个或多个描述符来定义其属性。描述符类定义了一些组合的获取、设置和删除方法。描述符类的实例将成为所有者类的属性。
- en: Properties are based on the method functions of the owner class. A descriptor,
    unlike a property, is an instance of a class different from the owning class.
    Therefore, descriptors are often reusable, generic kinds of attributes. The owning
    class can have multiple instances of each descriptor class to manage attributes
    with similar behaviors.
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是基于所有者类的方法函数。与属性不同，描述符是一个与拥有类不同的类的实例。因此，描述符通常是可重用的、通用的属性。拥有类可以有每个描述符类的多个实例，以管理具有类似行为的属性。
- en: Unlike other attributes, descriptors are created at the class level. They're
    not created within the `__init__()` initialization. While descriptor values can
    be set during initialization, descriptors are generally built as part of the class,
    outside any method functions.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他属性不同，描述符是在类级别创建的。它们不是在`__init__()`初始化中创建的。虽然可以在初始化期间设置描述符的值，但通常描述符是作为类的一部分在任何方法函数之外构建的。
- en: Each descriptor object will be an instance of a descriptor class bound to a
    distinct class-level attribute name when the owner class is defined.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 每个描述符对象在定义所有者类时将成为绑定到不同类级属性名称的描述符类的实例。
- en: To be recognized as a descriptor, a class must implement any combination of
    the following three methods.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 要被识别为描述符，一个类必须实现以下三种方法的任意组合。
- en: '`Descriptor.__get__( self, instance, owner ) → object`: In this method, the
    `instance` parameter is the `self` variable of the object being accessed. The
    `owner` parameter is the owning class object. If this descriptor is invoked in
    a class context, the `instance` parameter will get a `None` value. This must return
    the value of the descriptor.'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Descriptor.__get__( self, instance, owner ) → object`：在这个方法中，`instance`参数是被访问的对象的`self`变量。`owner`参数是拥有类的对象。如果在类上下文中调用这个描述符，`instance`参数将得到一个`None`值。这必须返回描述符的值。'
- en: '`Descriptor.__set__( self, instance, value )`: In this method, the `instance`
    parameter is the `self` variable of the object being accessed. The `value` parameter
    is the new value that the descriptor needs to be set to.'
  id: totrans-1060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Descriptor.__set__( self, instance, value )`：在这个方法中，`instance`参数是被访问的对象的`self`变量。`value`参数是描述符需要设置的新值。'
- en: '`Descriptor.__delete__( self, instance )`: In this method, the `instance` parameter
    is the `self` variable of the object being accessed. This method of the descriptor
    must delete this attribute''s value.'
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Descriptor.__delete__( self, instance )`：在这个方法中，`instance`参数是被访问的对象的`self`变量。这个描述符的方法必须删除这个属性的值。'
- en: Sometimes, a descriptor class will also need an `__init__()` method function
    to initialize the descriptor's internal state.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，描述符类还需要一个`__init__()`方法函数来初始化描述符的内部状态。
- en: 'There are two species of descriptors based on the methods defined, as follows:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定义的方法，描述符有两种类型：
- en: '**A nondata descriptor**: This kind of descriptor defines `__set__()` or `__delete__()`
    or both. It cannot define `__get__()`. The nondata descriptor object will often
    be used as part of some larger expression. It might be a callable object, or it
    might have attributes or methods of its own. An immutable nondata descriptor must
    implement `__set__()` but may simply raise `AttributeError`. These descriptors
    are slightly simpler to design because the interface is more flexible.'
  id: totrans-1064
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非数据描述符**：这种描述符定义了`__set__()`或者`__delete__()`或者两者。它不能定义`__get__()`。非数据描述符对象通常作为更大表达式的一部分使用。它可能是一个可调用对象，或者它可能有自己的属性或方法。不可变的非数据描述符必须实现`__set__()`但可以简单地引发`AttributeError`。这些描述符设计起来稍微简单一些，因为接口更加灵活。'
- en: '**A data descriptor**: This descriptor defines `__get__()` at a minimum. Usually,
    it defines both `__get__()` and `__set__()` to create a mutable object. The descriptor
    can''t define any further attributes or methods of this object since the descriptor
    will largely be invisible. A reference to an attribute that has a value of a data
    descriptor is delegated to the `__get__()`, `__set__()`, or `__delete__()` methods
    of the descriptor. These can be tricky to design, so we''ll look at them second.'
  id: totrans-1065
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据描述符**：这种描述符至少定义了`__get__()`。通常，它同时定义了`__get__()`和`__set__()`来创建一个可变对象。描述符不能定义这个对象的任何其他属性或方法，因为描述符基本上是不可见的。对于值为数据描述符的属性的引用将被委托给描述符的`__get__()`、`__set__()`或`__delete__()`方法。这些可能很难设计，所以我们将在第二个例子中看一下它们。'
- en: 'There are a wide variety of use cases for descriptors. Internally, Python uses
    descriptors for several reasons:'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符有各种用途。在内部，Python使用描述符有几个原因：
- en: Under the hood, the methods of a class are implemented as descriptors. These
    are nondata descriptors that apply the method function to the object and the various
    parameter values.
  id: totrans-1067
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底层，类的方法被实现为描述符。这些是应用方法函数到对象和各种参数值的非数据描述符。
- en: The `property()` function is implemented by creating a data descriptor for the
    named attribute.
  id: totrans-1068
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建命名属性的数据描述符来实现`property()`函数。
- en: A class method or static method is implemented as a descriptor; this applies
    to the class instead of an instance of the class.
  id: totrans-1069
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类方法或静态方法被实现为描述符；这适用于类而不是类的实例。
- en: When we look at object-relational mapping in [Chapter 11](ch11.html "Chapter 11. Storing
    and Retrieving Objects via SQLite"), *Storing and Retrieving Objects via SQLite*,
    we'll see that many of the ORM class definitions make heavy use of descriptors
    to map Python class definitions to SQL tables and columns.
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第11章](ch11.html "第11章。通过SQLite存储和检索对象")中查看对象关系映射时，*通过SQLite存储和检索对象*，我们会看到许多ORM类定义大量使用描述符将Python类定义映射到SQL表和列。
- en: 'As we think about the purposes of a descriptor, we must also examine the three
    common use cases for the data that a descriptor works with as follows:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑描述符的目的时，我们还必须检查描述符处理的数据的三种常见用例：
- en: The **descriptor object** has, or acquires, the data. In this case, the descriptor
    object's `self` variable is relevant and the descriptor is stateful. With a data
    descriptor, the `__get__()` method returns this internal data. With a nondata
    descriptor, the descriptor has other methods or attributes to access this data.
  id: totrans-1072
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述符对象**具有或获取数据。在这种情况下，描述符对象的`self`变量是相关的，描述符是有状态的。对于数据描述符，`__get__()`方法返回这个内部数据。对于非数据描述符，描述符有其他方法或属性来访问这些数据。'
- en: The **owner instance** contains the data. In this case, the descriptor object
    must use the `instance` parameter to reference a value in the owning object. With
    a data descriptor, the `__get__()` method fetches the data from the instance.
    With a nondata descriptor, the descriptor's other methods access the instance
    data.
  id: totrans-1073
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有者实例**包含数据。在这种情况下，描述符对象必须使用`instance`参数来引用拥有对象中的值。对于数据描述符，`__get__()`方法从实例中获取数据。对于非数据描述符，描述符的其他方法访问实例数据。'
- en: The **owner class** contains the relevant data. In this case, the descriptor
    object must use the `owner` parameter. This is commonly used when the descriptor
    implements a static method or class method that applies to the class as a whole.
  id: totrans-1074
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拥有者类**包含相关数据。在这种情况下，描述符对象必须使用`owner`参数。当描述符实现适用于整个类的静态方法或类方法时，通常会使用这种方法。'
- en: We'll take a look at the first case in detail. We'll look at creating a data
    descriptor with `__get__()` and `__set__()` methods. We'll also look at creating
    a nondata descriptor without a `__get__()` method.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将详细查看第一种情况。我们将查看如何使用`__get__()`和`__set__()`方法创建数据描述符。我们还将查看如何创建一个没有`__get__()`方法的非数据描述符。
- en: The second case (the data in the owning instance) shows what the `@property`
    decorator does. The possible advantage that a descriptor has over a conventional
    property is that it moves the calculations into the descriptor class from the
    owner class. This tends to fragment class design and is probably not the best
    approach. If the calculations are truly of epic complexity, then a strategy pattern
    might be better.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种情况（拥有实例中的数据）展示了`@property`装饰器的作用。描述符相对于常规属性可能具有的优势是，它将计算移到描述符类中，而不是拥有者类。这往往会导致类设计的碎片化，可能不是最佳的方法。如果计算确实非常复杂，那么策略模式可能更好。
- en: The third case shows how the `@staticmethod` and `@classmethod` decorators are
    implemented. We don't need to reinvent those wheels.
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况展示了`@staticmethod`和`@classmethod`装饰器的实现。我们不需要重新发明这些轮子。
- en: Using a nondata descriptor
  id: totrans-1078
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用非数据描述符
- en: We often have small objects with a few tightly bound attribute values. For this
    example, we'll take a look at numeric values that are bound up with units of measure.
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常有一些与少量紧密绑定的属性值的小对象。例如，我们将查看与度量单位绑定的数值。
- en: 'The following is a simple nondata descriptor class that lacks a `__get__()`
    method:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简单的没有`__get__()`方法的非数据描述符类：
- en: '[PRE183]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: This class defines a simple pair of values, one that is mutable (the value)
    and another that is effectively immutable (the unit).
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义了一对简单的值，一个是可变的（值），另一个是有效不可变的（单位）。
- en: When this descriptor is accessed, the descriptor object itself is made available,
    and other methods or attributes of the descriptor can then be used. We can use
    this descriptor to create classes that manage measurements and other numbers associated
    with physical units.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问此描述符时，描述符对象本身可用，并且可以使用描述符的其他方法或属性。我们可以使用此描述符创建管理与物理单位相关的测量和其他数字的类。
- en: 'The following is a class that does rate-time-distance calculations eagerly:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个急切地进行速率-时间-距离计算的类：
- en: '[PRE184]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: As soon as the object is created and the attributes loaded, the missing value
    is computed. Once computed, the descriptor can be examined to get the value or
    the unit's name. Additionally, the descriptor has a handy response to `str()`
    and formatting requests.
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象被创建并且属性被加载，缺失的值就会被计算。一旦计算完成，就可以检查描述符以获取值或单位的名称。此外，描述符对`str()`和格式化请求有一个方便的响应。
- en: 'The following is an interaction between a descriptor and the `RTD_1` class:'
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述符和`RTD_1`类之间的交互：
- en: '[PRE185]'
  id: totrans-1088
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: We created an instance of `RTD_1` with `rate` and `distance` arguments. These
    were used to evaluate the `__set__()` methods of the `rate` and `distance` descriptors.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`rate`和`distance`参数创建了`RTD_1`的一个实例。这些参数用于评估`rate`和`distance`描述符的`__set__()`方法。
- en: When we asked for `str(m1)`, this evaluated the overall `__str__()` method of
    `RTD_1` that, in turn, used the `__format__()` method of the rate, time, and distance
    descriptors. This provided us with numbers with units attached to them.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要求`str(m1)`时，这将评估`RTD_1`的整体`__str__()`方法，而`RTD_1`又使用了速率、时间和距离描述符的`__format__()`方法。这为我们提供了附加单位的数字。
- en: We can also access the individual elements of a descriptor since nondata descriptors
    don't have `__get__()` and don't return their internal values.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以访问描述符的各个元素，因为非数据描述符没有`__get__()`，也不返回它们的内部值。
- en: Using a data descriptor
  id: totrans-1092
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数据描述符
- en: 'A data descriptor is somewhat trickier to design because it has such a limited
    interface. It must have a `__get__()` method and it can only have `__set__()`
    or `__delete__()`. This is the entire interface: from one to three of these methods
    and no other methods. Introducing an additional method means that Python will
    not recognize the class as being a proper data descriptor.'
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 数据描述符的设计有些棘手，因为它的接口非常有限。它必须有一个`__get__()`方法，而且只能有`__set__()`或`__delete__()`。这就是整个接口：从一个到三个这些方法，没有其他方法。引入额外的方法意味着Python将不会将该类识别为适当的数据描述符。
- en: We'll design an overly simplistic unit conversion schema using descriptors that
    can do appropriate conversions in their `__get__()` and `__set__()` methods.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设计一个过于简化的单位转换模式，使用描述符可以在它们的`__get__()`和`__set__()`方法中执行适当的转换。
- en: 'The following is a superclass of a descriptor of units that will do conversions
    to and from a standard unit:'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个单位描述符的超类，将执行到标准单位的转换：
- en: '[PRE186]'
  id: totrans-1096
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This class does simple multiplications and divisions to convert standard units
    to other non-standard units and vice versa.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类执行简单的乘法和除法，将标准单位转换为其他非标准单位，反之亦然。
- en: With this superclass, we can define some conversions from a standard unit. In
    the previous case, the standard unit is KPH (kilometers per hour).
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个超类，我们可以定义一些从标准单位的转换。在前面的情况下，标准单位是KPH（每小时公里）。
- en: 'The following are the two conversion descriptors:'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个转换描述符：
- en: '[PRE187]'
  id: totrans-1100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-1101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The inherited methods are perfectly useful. The only thing that changes is
    the conversion factor. These classes can be used to work with values that involve
    unit conversion. We can work with MPH''s or knots interchangeably. The following
    is a unit descriptor for a standard unit, kilometers per hour:'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的方法非常有用。唯一改变的是转换因子。这些类可以用于处理涉及单位转换的值。我们可以互换地使用MPH或节。以下是一个标准单位，每小时公里的单位描述符：
- en: '[PRE189]'
  id: totrans-1103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: This class represents a standard, so it doesn't do any conversion. It uses a
    private variable in the instance to save the standard value for speed in KPH.
    Avoiding any arithmetic conversion is simply a technique of optimization. Avoiding
    any reference to one of the public attributes is essential to avoiding infinite
    recursions.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类代表一个标准，所以它不做任何转换。它在实例中使用一个私有变量来保存以KPH为单位的速度的标准值。避免任何算术转换只是一种优化技术。避免引用公共属性之一是避免无限递归的关键。
- en: 'The following is a class that provides a number of conversions for a given
    measurement:'
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个为给定测量提供多种转换的类：
- en: '[PRE190]'
  id: totrans-1106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Each of the class-level attributes is a descriptor for a different unit. The
    get and set methods of the various descriptors will do appropriate conversions.
    We can use this class to convert speeds among a variety of units.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类级属性都是不同单位的描述符。各种描述符的获取和设置方法将执行适当的转换。我们可以使用这个类来在各种单位之间转换速度。
- en: 'The following is an example of an interaction with the `Measurement` class:'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是与`Measurement`类交互的一个示例：
- en: '[PRE191]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: We created an object of the `Measurement` class by setting various descriptors.
    In the first case, we set the knots descriptor.
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过设置各种描述符创建了一个`Measurement`类的对象。在第一种情况下，我们设置了knots描述符。
- en: When we displayed the value as a large string, each of the descriptor's `__get__()`
    methods was used. These methods fetched the internal `kph` attribute value from
    the owning object, applied a conversion factor, and returned the resulting value.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将值显示为一个大字符串时，每个描述符的`__get__()`方法都被使用了。这些方法从拥有对象中获取内部的`kph`属性值，应用转换因子，然后返回结果值。
- en: The `kph` attribute also uses a descriptor. This descriptor does not do any
    conversion; however, it simply returns a private value cached in the owning object.
    The `KPH` and `Knots` descriptors require that the owning class implement a `kph`
    attribute.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: '`kph`属性也使用了一个描述符。这个描述符不执行任何转换；然而，它只是返回拥有对象中缓存的私有值。`KPH`和`Knots`描述符要求拥有类实现一个`kph`属性。'
- en: Summary, design considerations, and trade-offs
  id: totrans-1113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要、设计考虑和权衡
- en: In this chapter, we looked at several ways to work with an object's attributes.
    We can use the built-in features of the `object` class and get and set attribute
    values. We can define properties to modify how attributes behave.
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了几种处理对象属性的方法。我们可以使用`object`类的内置功能来获取和设置属性值。我们可以定义属性来修改属性的行为。
- en: If we want more sophistication, we can tweak the underlying special method implementations
    for `__getattr__()`, `__setattr__()`, `__delattr__()`, or `__getattribute__()`.
    These allow us very fine-grained control over attribute behaviors. We walk a fine
    line when we touch these methods because we can make fundamental (and confusing)
    changes to Python's behavior.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要更复杂的功能，我们可以调整`__getattr__()`、`__setattr__()`、`__delattr__()`或`__getattribute__()`的基础特殊方法实现。这允许我们对属性行为进行非常精细的控制。当我们触及这些方法时，我们要小心，因为我们可能会对Python的行为进行根本性（和令人困惑的）更改。
- en: Internally, Python uses descriptors to implement features such as method functions,
    static method functions, and properties. Many of the cool use cases for descriptors
    are already first-class features of the language.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Python使用描述符来实现方法函数、静态方法函数和属性等功能。描述符的许多酷用例已经是语言的一流特性。
- en: Programmers coming from other languages (particularly Java and C++) usually
    have the urge to try to make all attributes private and write extensive getter
    and setter functions. This kind of coding is necessary for languages where type
    definitions are statically compiled in.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 来自其他语言（特别是Java和C++）的程序员通常有冲动尝试将所有属性设为私有，并编写大量的getter和setter函数。这种编码在静态编译类型定义的语言中是必要的。
- en: 'In Python, it''s considerably simpler to treat all attributes as public. This
    means the following:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，将所有属性视为公共属性要简单得多。这意味着以下内容：
- en: They should be well documented.
  id: totrans-1119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该有很好的文档。
- en: They should properly reflect the state of the object; they shouldn't be temporary
    or transient values.
  id: totrans-1120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应该正确地反映对象的状态；它们不应该是临时或瞬时值。
- en: In the rare case of an attribute that has a potentially confusing (or brittle)
    value, a single leading underscore character (`_`) marks the name as "not part
    of the defined interface." It's not really private.
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在属性具有潜在混乱（或脆弱）值的罕见情况下，单个下划线字符（`_`）标记名称为“不是定义接口的一部分”。它实际上并不是私有的。
- en: It's important to think of private attributes as a nuisance. Encapsulation isn't
    broken by the lack of complex privacy mechanisms in the language; it is broken
    by bad design.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 将私有属性视为一种麻烦是很重要的。封装并没有因为语言中缺乏复杂的隐私机制而被破坏；它是因为糟糕的设计而被破坏。
- en: Properties versus attributes
  id: totrans-1123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 属性与属性之间的区别
- en: In most cases, attributes can be set outside a class with no adverse consequences.
    Our example of the `Hand` class shows this. For many versions of the class, we
    can simply append to `hand.cards`, and the lazy computation of `total` via a property
    will work perfectly.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，可以在类外部设置属性而不会产生不良后果。我们的“Hand”类的示例就表明了这一点。对于类的许多版本，我们可以简单地追加到“hand.cards”，属性的延迟计算将完美地工作。
- en: 'In cases where the changing of an attribute should lead to consequential changes
    in other attributes, some more sophisticated class design is required:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性的更改应导致其他属性的相关更改的情况下，需要更复杂的类设计：
- en: A method function may clarify the state change. This will be necessary when
    multiple parameter values are required.
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法函数可能会澄清状态变化。当需要多个参数值时，这将是必要的。
- en: A property setter may be clearer than a method function. This will be a sensible
    option when a single value is required.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性设置器可能比方法函数更清晰。当需要单个值时，这将是一个明智的选择。
- en: We can also use in-place operators. We'll defer this until [Chapter 7](ch07.html
    "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们也可以使用就地操作符。我们将把这个推迟到[第7章](ch07.html "第7章 创建数字")，“创建数字”。
- en: There's no strict rule. In this case, where we need to set a single parameter
    value, the distinction between a method function and a property is entirely one
    of API syntax and how well that communicates the intent.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 没有严格的规定。在这种情况下，当我们需要设置单个参数值时，方法函数和属性之间的区别完全是API语法以及它如何传达意图的问题。
- en: For computed values, a property allows lazy computation, while an attribute
    requires eager computation. This devolves to a performance question. The benefits
    of lazy versus eager computation are based on the expected use cases.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于计算值，属性允许延迟计算，而属性需要急切计算。这归结为一个性能问题。延迟计算与急切计算的好处基于预期的用例。
- en: Designing with descriptors
  id: totrans-1131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用描述符进行设计
- en: Many examples of descriptors are already part of Python. We don't need to reinvent
    properties, class methods, or static methods.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 许多描述符的示例已经是Python的一部分。我们不需要重新发明属性、类方法或静态方法。
- en: The most compelling cases for creating new descriptors relate to mapping between
    Python and something non-Python. Object-relational database mapping, for example,
    requires a great deal of care to ensure that a Python class has the right attributes
    in the right order to match a SQL table and columns. Also, when mapping to something
    outside Python, a descriptor class can handle encoding and decoding data or fetching
    the data from external sources.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新描述符的最具说服力的案例与Python和非Python之间的映射有关。例如，对象关系数据库映射需要非常小心，以确保Python类具有正确的属性顺序，以匹配SQL表和列。此外，当映射到Python之外的内容时，描述符类可以处理数据的编码和解码，或者从外部来源获取数据。
- en: When building a web service client, we might consider using descriptors to make
    web service requests. The `__get__()` method, for example, might turn into an
    HTTP GET request, and the `__set__()` method might turn into an HTTP PUT request.
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web服务客户端时，我们可能会考虑使用描述符来发出Web服务请求。“__get__()”方法，例如，可能会变成HTTP GET请求，“__set__()”方法可能会变成HTTP
    PUT请求。
- en: In some cases, a single request may populate the data of several descriptors.
    In this case, the `__get__()` method would check the instance cache and return
    that value before making an HTTP request.
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，单个请求可能会填充多个描述符的数据。在这种情况下，“__get__()”方法会在发出HTTP请求之前检查实例缓存并返回该值。
- en: 'Many data descriptor operations are more simply handled by properties. This
    provides us with a place to start: to write properties first. If the property
    processing becomes too expansive or complex, then we can switch to descriptors
    to refactor the class.'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 许多数据描述符操作可以通过属性更简单地处理。这为我们提供了一个起点：首先编写属性。如果属性处理变得过于繁琐或复杂，那么我们可以切换到描述符来重构类。
- en: Looking forward
  id: totrans-1137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next chapter, we'll look closely at the **ABC**s (**Abstract Base Classes**)
    that we'll exploit in Chapters 5, 6, and 7\. These ABCs will help us define classes
    that integrate nicely with existing Python features. They will also allow us to
    create class hierarchies that enforce consistent design and extension.
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将仔细研究我们将在第5、6和7章中利用的**ABC**（抽象基类）。这些ABC将帮助我们定义与现有Python功能良好集成的类。它们还将允许我们创建强制一致设计和扩展的类层次结构。
- en: Chapter 4. The ABCs of Consistent Design
  id: totrans-1139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章 一致设计的ABC
- en: The Python Standard Library provides abstract base classes for a number of features
    of containers. It provides a consistent framework for the built-in container classes,
    such as `list`, `map`, and `set`.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: Python标准库为多个容器特性提供了抽象基类。它为内置的容器类（如`list`、`map`和`set`）提供了一致的框架。
- en: Additionally, the library provides abstract base classes for numbers. We can
    use these classes to extend the suite of numeric classes available in Python.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该库还为数字提供了抽象基类。我们可以使用这些类来扩展Python中可用的数字类套件。
- en: We'll look in general at the abstract base classes in the `collections.abc`
    module. From there, we can focus on a few use cases that will be the subject of
    detailed examination in future chapters.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将总体上看一下`collections.abc`模块中的抽象基类。从那里，我们可以专注于一些用例，这些用例将成为未来章节中详细检查的主题。
- en: 'We have three design strategies: Wrap, Extend, and Invent. We''ll look at the
    general concepts behind the various containers and collections that we might want
    to wrap or extend. Similarly, we''ll look at the concepts behind the numbers that
    we might want to implement.'
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种设计策略：包装、扩展和发明。我们将总体上看一下我们可能想要包装或扩展的各种容器和集合背后的概念。同样，我们将研究我们可能想要实现的数字背后的概念。
- en: Our goal is to assure that our application classes integrate seamlessly with
    existing Python features. If we create a collection, for example, it's appropriate
    to have that collection also create an iterator by implementing `__iter__()`.
    A collection that implements `__iter__()` will work seamlessly with a `for` statement.
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是确保我们的应用程序类与现有的Python特性无缝集成。例如，如果我们创建一个集合，那么通过实现`__iter__()`来创建一个迭代器是合适的。实现`__iter__()`的集合将与`for`语句无缝协作。
- en: Abstract base classes
  id: totrans-1145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象基类
- en: The core of the **Abstract Base Class** (**ABC**) definition is defined in a
    module named `abc`. This contains the required decorators and metaclasses to create
    abstractions. Other classes rely on these definitions.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象基类**（**ABC**）的核心定义在一个名为`abc`的模块中。这包含了创建抽象的所需装饰器和元类。其他类依赖于这些定义。'
- en: In Python 3.2, the abstract base classes for collections were buried in `collections`.
    In Python 3.3, however, the abstract base classes have been split into a separate
    submodule named `collections.abc`.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.2中，集合的抽象基类被隐藏在`collections`中。然而，在Python 3.3中，抽象基类已经被拆分成一个名为`collections.abc`的单独子模块。
- en: We'll also look at the `numbers` module, because it contains ABCs for numeric
    types. There are abstract base classes for I/O in the `io` module too.
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将研究`numbers`模块，因为它包含了数字类型的ABC。`io`模块中也有用于I/O的抽象基类。
- en: We'll focus on Python Version 3.3\. The definitions will work very similarly
    for Python 3.2, but the `import` statement will change slightly to reflect the
    flatter library structure.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将专注于Python 3.3版本。这些定义在Python 3.2中也会非常类似，但`import`语句会略有变化以反映更扁平的库结构。
- en: 'An abstract base class has a number of features, as follows:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类具有以下特点：
- en: Abstract means that these classes don't contain all of the method definitions
    required to work completely. For it to be a useful subclass, we will need to provide
    some method definitions.
  id: totrans-1151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象意味着这些类并不包含完全工作所需的所有方法定义。为了使其成为一个有用的子类，我们需要提供一些方法定义。
- en: Base means that other classes will use it as a superclass.
  id: totrans-1152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类意味着其他类将使用它作为超类。
- en: An abstract class provides some definitions for method functions. Most importantly,
    the abstract base classes provide the signatures for the missing method functions.
    A subclass must provide the right methods to create a concrete class that fits
    the interface defined by the abstract class.
  id: totrans-1153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类为方法函数提供了一些定义。最重要的是，抽象基类为缺失的方法函数提供了签名。子类必须提供正确的方法来创建一个符合抽象类定义的接口的具体类。
- en: 'The features of the abstract base classes include the following ideas:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象基类的特点包括以下几点：
- en: We can use them to define a consistent set of base classes for Python's internal
    classes and our customized application classes.
  id: totrans-1155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用它们来为Python内部类和我们定制的应用程序类定义一致的基类集。
- en: We can use them to create some common, reusable abstractions that we can use
    in our applications.
  id: totrans-1156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用它们来创建一些常见的可重用的抽象，可以在我们的应用程序中使用。
- en: We can use them to support the proper inspection of a class to determine what
    it does. This allows better collaboration among library classes and new classes
    in our applications. In order to do an inspection properly, it helps to have the
    formal definition of concepts such as "container" and "number".
  id: totrans-1157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用它们来支持对类的适当检查，以确定它的功能。这允许库类和我们应用程序中的新类更好地协作。为了进行适当的检查，有必要有诸如“容器”和“数字”之类的概念的正式定义。
- en: Without abstract base classes (that is, in the "bad old days") a container may,
    or may not, have provided all the features of a `Sequence` class consistently.
    This often leads to a class being almost a sequence or sequence-like. This, in
    turn, leads to odd inconsistencies and kludgy workarounds for a class that didn't
    quite provide all the features of a sequence.
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 没有抽象基类（也就是在“旧的不好的日子里”），一个容器可能会或可能不会一致地提供`Sequence`类的所有特性。这经常导致一个类几乎成为一个序列或类似序列。这反过来导致了奇怪的不一致和笨拙的解决方法，因为一个类并没有完全提供序列的所有特性。
- en: With an abstract base class, you can assure that an application's given class
    will have the advertised features. If it lacks a feature, the presence of an undefined
    abstract method will make the class unusable for building object instances.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 有了抽象基类，你可以确保应用程序给定的类将具有宣传的特性。如果缺少某个特性，未定义的抽象方法的存在将使该类无法用于构建对象实例。
- en: 'We''ll use ABCs in several situations, as follows:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在几种情况下使用ABC，如下：
- en: We'll use ABC's as superclasses when defining our own classes
  id: totrans-1161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在定义自己的类时使用ABC作为超类
- en: We'll use ABC's within a method to confirm that an operation is possible
  id: totrans-1162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在方法中使用ABC来确认一个操作是否可能
- en: We'll use ABC's within a diagnostic message or exception to indicate why an
    operation can't work
  id: totrans-1163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在诊断消息或异常中使用ABC来指示为什么操作无法工作
- en: 'For the first use case, we may write modules with code that looks like the
    following:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个用例，我们可以编写以下代码样式的模块：
- en: '[PRE192]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: Our `SomeApplicationClass` is defined to be a `Callable` class. It must then
    implement the specific methods required by `Callable`, or we will not be able
    to create an instance.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`SomeApplicationClass`被定义为一个`Callable`类。然后，它必须实现`Callable`所需的特定方法，否则我们将无法创建实例。
- en: A function is a concrete example of a `Callable` class. The abstraction is a
    class that defines the `__call__()` method. We'll look at `Callables` classes
    in the following section and in [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), Using *Callables and Contexts*.
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是`Callable`类的一个具体示例。抽象是定义`__call__()`方法的类。我们将在下一节和[第5章](ch05.html "第5章。使用可调用和上下文")中查看`Callables`类，使用*可调用和上下文*。
- en: 'For the second use case, we may write methods with code that looks like the
    following:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个用例，我们可以编写以下代码样式的方法：
- en: '[PRE193]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Our `some_method()` requires for the `other` argument to be a subclass of `Iterator`.
    If the `other` argument can't pass this test, we get an exception. A common alternative
    to `assert` is an `if` statement that raises `TypeError`, which may be more meaningful.
    We'll see this in the following section.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`some_method()`要求`other`参数是`Iterator`的子类。如果`other`参数无法通过此测试，我们会得到一个异常。`assert`的一个常见替代方案是引发`TypeError`的`if`语句，这可能更有意义。我们将在下一节中看到这一点。
- en: 'For the third use case, we might have something like the following:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个用例，我们可能会有以下内容：
- en: '[PRE194]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: In this case, we wrote a diagnostic warning that shows the base classes for
    a given object. This may help debug the problem with the application design.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们编写了一个诊断警告，显示给定对象的基类。这可能有助于调试应用程序设计中的问题。
- en: Base classes and polymorphism
  id: totrans-1174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基类和多态性
- en: In this section, we'll flirt with the idea of **Pretty Poor Polymorphism**.
    Inspection of argument values is a Python programming practice that should be
    isolated to a few special cases.
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨**相当差的多态性**的概念。检查参数值是一种应该只用于少数特殊情况的Python编程实践。
- en: Well-done polymorphism follows what is sometimes called the **Liskov Substitution
    Principle**. Polymorphic classes can be used interchangeably. Each polymorphic
    class has the same suite of properties. For more information, visit [http://en.wikipedia.org/wiki/Liskov_substitution_principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle).
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的多态性遵循有时被称为**里氏替换原则**的原则。多态类可以互换使用。每个多态类具有相同的属性套件。有关更多信息，请访问[http://en.wikipedia.org/wiki/Liskov_substitution_principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle)。
- en: Overusing `isinstance()` to distinguish between the types of arguments can lead
    to a needlessly complex (and slow) program. Instance comparisons are made all
    the time, but errors are generally only introduced through software maintenance.
    Unit testing is a far better way to find programming errors than verbose type-checking
    in the code.
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 过度使用`isinstance()`来区分参数类型可能会导致程序变得不必要复杂（和缓慢）。实例比较一直在进行，但错误通常只是通过软件维护引入的。单元测试是发现编程错误的更好方法，而不是在代码中进行冗长的类型检查。
- en: Method functions with lots of `isinstance()` methods can be a symptom of a poor
    (or incomplete) design of polymorphic classes. Rather than having type-specific
    processing outside of a class definition, it's often better to extend or wrap
    classes to make them more properly polymorphic and encapsulate the type-specific
    processing within the class definition.
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: 具有大量`isinstance()`方法的方法函数可能是多态类设计不良（或不完整）的症状。与在类定义之外具有特定于类型的处理相比，通常最好扩展或包装类，使它们更适当地多态化，并在类定义内封装特定于类型的处理。
- en: 'One good use of the `isinstance()` method is to create diagnostic messages.
    A simple approach is to use the `assert` statement:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '`isinstance()`方法的一个很好的用途是创建诊断消息。一个简单的方法是使用`assert`语句：'
- en: '[PRE195]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'This will raise an `AssertionError` exception to indicate that there''s a problem.
    This has the advantage that it is short and to the point. However, it has two
    disadvantages: assertions can be silenced, and it would probably be better to
    raise a `TypeError` for this. The following example might be better:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 这将引发`AssertionError`异常以指示存在问题。这有一个优点，即它简短而直接。但是，它有两个缺点：断言可能会被消除，并且最好引发`TypeError`。以下示例可能更好：
- en: '[PRE196]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: The preceding code has the advantage that it raises the correct error. However,
    it has the disadvantage that it is long winded.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码有一个优点，即它引发了正确的错误。但是，它的缺点是冗长。
- en: 'The more Pythonic approach is summarized as follows:'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 更Pythonic的方法总结如下：
- en: '"It''s better to ask for forgiveness than to ask for permission."'
  id: totrans-1185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “宁愿请求宽恕，也不要请求许可。”
- en: This is generally taken to mean that we should minimize the upfront testing
    of arguments (asking permission) to see if they're the correct type. Argument-type
    inspections are rarely of any tangible benefit. Instead, we should handle the
    exceptions appropriately (asking forgiveness).
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常被理解为我们应该尽量减少对参数的前期测试（请求许可），以查看它们是否是正确的类型。参数类型检查很少有任何实际好处。相反，我们应该适当地处理异常（请求宽恕）。
- en: What's best is to combine diagnostic information with the exception in the unlikely
    event that an inappropriate type is used and somehow passed through unit testing
    into operation.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是在不太可能发生不适当类型的情况下，将诊断信息与异常结合在一起，并通过单元测试进入操作。
- en: 'The following is often what''s done:'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下会做以下操作：
- en: '[PRE197]'
  id: totrans-1189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The `isinstance()` method assumes that `some_argument` is a proper instance
    of a `collections.abc.Container` class and will respond to the `in` operator.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '`isinstance()`方法假定`some_argument`是`collections.abc.Container`类的一个适当实例，并且将响应`in`运算符。'
- en: In the unlikely event that someone changes the application and `some_argument`
    is now of the wrong class, the application will write a diagnostic message and
    crash with a `TypeError` exception.
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少数情况下，如果有人更改了应用程序，并且`some_argument`现在是错误的类，应用程序将写入诊断消息，并因`TypeError`异常而崩溃。
- en: Callables
  id: totrans-1192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可调用对象
- en: Python's definition of **callable object** includes the obvious function definitions
    created with the `def` statement.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: Python对**可调用对象**的定义包括使用`def`语句创建的明显函数定义。
- en: It also includes, informally, any class with a `__call__()` method. We can see
    several examples of this in *Python 3 Object Oriented Programming*, *Dusty Phillips*,
    *Packt Publishing*. For it to be more formal, we should make every callable class
    definition a proper subclass of `collections.abc.Callable`.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 它还包括，非正式地，任何具有`__call__()`方法的类。我们可以在*Python 3面向对象编程*，*Dusty Phillips*，*Packt
    Publishing*中看到几个例子。为了更正式，我们应该使每个可调用类定义成为`collections.abc.Callable`的适当子类。
- en: 'When we look at any Python function, we see the following behavior:'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看任何Python函数时，我们会看到以下行为：
- en: '[PRE198]'
  id: totrans-1196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'The built-in `abs()` function is a proper instance of `collections.abc.Callable`.
    This is also true for the functions we define. The following is an example:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的`abs()`函数是`collections.abc.Callable`的一个正确实例。我们定义的函数也是如此。以下是一个例子：
- en: '[PRE199]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: Every function reports itself as `Callable`. This simplifies the inspection
    of an argument value and helps write meaningful debugging messages.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数都报告自己是`Callable`。这简化了对参数值的检查，并有助于编写有意义的调试消息。
- en: We'll take a look at callables in detail in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](ch05.html "第5章。使用可调用对象和上下文")*使用可调用对象和上下文*中详细讨论可调用对象。
- en: Containers and collections
  id: totrans-1201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和集合
- en: The `collections` module defines a number of collections above and beyond the
    built-in container classes. The container classes include `namedtuple()`, `deque`,
    `ChainMap`, `Counter`, `OrderedDict`, and `defaultdict`. All of these are examples
    of classes based on ABC definitions.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections`模块定义了许多超出内置容器类的集合。容器类包括`namedtuple()`、`deque`、`ChainMap`、`Counter`、`OrderedDict`和`defaultdict`。所有这些都是基于ABC定义的类的示例。'
- en: 'The following is a quick interaction to show how we can inspect collections
    to see the methods they will support:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个快速交互，展示了我们如何检查集合以查看它们将支持的方法：
- en: '[PRE200]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: We can inspect the simple `dict` class to see that it follows the basic mapping
    protocol and will support the required methods.
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查简单的`dict`类，看它是否遵循基本的映射协议并支持所需的方法。
- en: We can inspect a `defaultdict` collection to confirm that it is also a mapping.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查`defaultdict`集合以确认它也是一个映射。
- en: When creating a new kind of container, we can do it informally. We can create
    a class that has all of the right special methods. However, we aren't *required*
    to make a formal declaration that it's a certain kind of container.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新类型的容器时，我们可以不正式地进行。我们可以创建一个具有所有正确特殊方法的类。但是，我们并不*需要*正式声明它是某种类型的容器。
- en: 'It''s more clear (and more reliable) to use a proper ABC as the base class
    for one of our application classes. The additional formality has the following
    two advantages:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适当的ABC作为应用程序类的基类更清晰（也更可靠）。额外的形式性具有以下两个优点：
- en: It advertises what our intention was to people reading (and possibly using or
    maintaining) our code. When we make a subclass of `collections.abc.Mapping`, we're
    making a very strong claim about how that class will be used.
  id: totrans-1209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它向阅读（可能使用或维护）我们的代码的人宣传了我们的意图。当我们创建`collections.abc.Mapping`的子类时，我们对该类将如何使用做出了非常强烈的声明。
- en: It creates some diagnostic support. If we somehow fail to implement all of the
    required methods properly, we can't create instances of the abstract base class.
    If we can't run the unit tests because we can't create instances of an object,
    then this indicates a serious problem that needs to be fixed.
  id: totrans-1210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它创建了一些诊断支持。如果我们以某种方式未能正确实现所有所需的方法，我们就无法创建抽象基类的实例。如果我们无法运行单元测试，因为无法创建对象的实例，那么这表明存在需要修复的严重问题。
- en: The entire family tree of built-in containers is reflected in the abstract base
    classes. Lower-level features include `Container`, `Iterable`, and `Sized`. These
    are a part of higher-level constructs; they require a few specific methods, particularly
    `__contains__()`, `__iter__()`, and `__len__()`, respectively.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 内置容器的整个家族树反映在抽象基类中。较低级别的特性包括`Container`、`Iterable`和`Sized`。这些是更高级别的构造的一部分；它们需要一些特定的方法，特别是`__contains__()`、`__iter__()`和`__len__()`。
- en: 'Higher-level features include the following characteristics:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 更高级别的特性包括以下特征：
- en: '`Sequence` and `MutableSequence`: These are the abstractions of the concrete
    classes `list` and `tuple`. Concrete sequence implementations also include `bytes`
    and `str`.'
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sequence`和`MutableSequence`：这些是具体类`list`和`tuple`的抽象。具体的序列实现还包括`bytes`和`str`。'
- en: '`MutableMapping`: This is the abstraction of `dict`. It extends `Mapping`,
    but there''s no built-in concrete implementation of this.'
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MutableMapping`：这是`dict`的抽象。它扩展了`Mapping`，但没有内置的具体实现。'
- en: '`Set` and `MutableSet`: These are the abstractions of the concrete classes,
    `frozenset` and `set`.'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`和`MutableSet`：这些是具体类`frozenset`和`set`的抽象。'
- en: This allows us to build new classes or extend existing classes and maintain
    a clear and formal integration with the rest of Python's built-in features.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够构建新类或扩展现有类，并与Python的其他内置特性保持清晰和正式的集成。
- en: We'll look at containers and collections in detail in [Chapter 6](ch06.html
    "Chapter 6. Creating Containers and Collections"), *Creating Containers and Collections*.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第6章](ch06.html "第6章。创建容器和集合")*创建容器和集合*中详细讨论容器和集合。
- en: Numbers
  id: totrans-1218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: When creating new numbers (or extending existing numbers), we'll turn to the
    `numbers` module. This module contains the abstract definitions of Python's built-in
    numeric types. These types form a tall, narrow hierarchy, from the simplest to
    the most elaborate. In this case, simplicity (and elaboration) refers to the collection
    of methods available.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的数字（或扩展现有数字）时，我们会转向`numbers`模块。这个模块包含了Python内置数值类型的抽象定义。这些类型形成了一个高高瘦瘦的层次结构，从最简单到最复杂。在这种情况下，简单（和复杂）指的是可用的方法集合。
- en: 'There''s an abstract base class named `numbers.Number` that defines all of
    the numeric and number-like classes. We can see that this is true with interactions
    like the following one:'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`numbers.Number`的抽象基类，它定义了所有的数字和类似数字的类。我们可以通过以下交互来看到这一点：
- en: '[PRE201]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Clearly, integer and float values are subclasses of the abstract `numbers.Number`
    class.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，整数和浮点数值是抽象`numbers.Number`类的子类。
- en: The subclasses include `numbers.Complex`, `numbers.Real`, `numbers.Rational`,
    and `numbers.Integral`. These definitions are roughly parallel mathematical thoughts
    on the various classes of numbers.
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 子类包括`numbers.Complex`、`numbers.Real`、`numbers.Rational`和`numbers.Integral`。这些定义大致上是对各种数字类的数学思考。
- en: 'The `decimal.Decimal` class, however, doesn''t fit this hierarchy extremely
    well. We can check the relationships using the `issubclass()` method as follows:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`decimal.Decimal`类并不非常适合这个层次结构。我们可以使用`issubclass()`方法来检查关系，如下所示：
- en: '[PRE202]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: It shouldn't be too surprising that `Decimal` doesn't fit the established number
    types well. For a concrete implementation of `numbers.Rational`, look at the `fractions`
    module. We'll look at the various kinds of numbers in detail in [Chapter 7](ch07.html
    "Chapter 7. Creating Numbers"), *Creating Numbers*.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: '`Decimal`不太适合已建立的数字类型并不太令人惊讶。对于`numbers.Rational`的具体实现，请查看`fractions`模块。我们将在[第7章](ch07.html
    "第7章。创建数字")中详细讨论各种数字，*创建数字*。'
- en: Some additional abstractions
  id: totrans-1227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一些额外的抽象
- en: We'll look at some other interesting ABC classes that are less widely extended.
    It's not that these abstractions are less widely used. It's more that the concrete
    implementations rarely need extensions or revisions.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些其他有趣的ABC类，这些类的扩展范围较小。并不是这些抽象较少被使用。更多的是具体实现很少需要扩展或修订。
- en: We'll look at the iterator, which is defined by `collections.abc.Iterator`.
    We'll also look at the unrelated idea of a context manager. This isn't defined
    with the same formality as other ABC classes. We'll look at this in detail in
    [Chapter 5,](ch05.html "Chapter 5. Using Callables and Contexts") *Using Callables
    and Contexts*.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下由`collections.abc.Iterator`定义的迭代器。我们还将看一下与上下文管理器无关的概念。这并没有像其他ABC类那样正式定义。我们将在[第5章](ch05.html
    "第5章。使用可调用和上下文")中详细讨论这一点，*使用可调用和上下文*。
- en: The iterator abstraction
  id: totrans-1230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代器抽象
- en: Iterators are created implicitly when we use an iterable container with a `for`
    statement. We rarely care about the iterator itself. And the few times we do care
    about the iterator, we rarely want to extend or revise the class definition.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`for`语句与可迭代容器一起使用时，迭代器会隐式创建。我们很少关心迭代器本身。而我们确实关心迭代器的几次，我们很少想要扩展或修订类定义。
- en: 'We can expose the implicit iterators that Python uses via the `iter()` function.
    We can interact with an iterator in the following way:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`iter()`函数暴露Python使用的隐式迭代器。我们可以以以下方式与迭代器交互：
- en: '[PRE203]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: We created an iterator over a list object and then stepped through the values
    in that iterator using the `next()` function.
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个列表对象上的迭代器，然后使用`next()`函数逐步遍历该迭代器中的值。
- en: The final `isinstance()` expression confirmed that this iterator object is an
    instance of `collections.abc.Iterator`.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`isinstance()`表达式确认了这个迭代器对象是`collections.abc.Iterator`的一个实例。
- en: Most of the time, we'll work with iterators that have been created by the collection
    classes themselves. However, when we branch out and build our own collection classes
    or extend a collection class, we may also need to build a unique iterator. We'll
    look at iterators in [Chapter 6](ch06.html "Chapter 6. Creating Containers and
    Collections"), *Creating Containers and Collections*.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，我们将使用由集合类自己创建的迭代器。然而，当我们扩展集合类或构建自己的集合类时，我们可能也需要构建一个独特的迭代器。我们将在[第6章](ch06.html
    "第6章。创建容器和集合")中详细讨论迭代器，*创建容器和集合*。
- en: Contexts and context managers
  id: totrans-1237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文和上下文管理器
- en: 'A context manager is used with the `with` statement. We''re working with a
    context manager when we write something like the following:'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器与`with`语句一起使用。当我们写类似以下内容时，我们正在使用上下文管理器：
- en: '[PRE204]'
  id: totrans-1239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: In the preceding case, `function(arg)` creates the context manager.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的情况下，`function(arg)`创建了上下文管理器。
- en: 'One very commonly used context manager is a file. When we open a file, we should
    define a context that will also automatically close the file. Consequently, we
    should almost always use a file in the following way:'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常常用的上下文管理器是文件。当我们打开一个文件时，我们应该定义一个上下文，这样也会自动关闭文件。因此，我们几乎总是以以下方式使用文件：
- en: '[PRE205]'
  id: totrans-1242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: At the end of the `with` statement, we're assured that the file will be closed
    properly. The `contextlib` module provides several tools for building proper context
    managers. Rather than providing an abstract base class, this library offers decorators,
    which will transform simple functions into context managers, as well as a `contextlib.ContextDecorator`
    base class, which can be used extended to build a class that is a context manager.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`语句的末尾，我们可以确保文件会被正确关闭。`contextlib`模块提供了几种构建正确上下文管理器的工具。这个库并没有提供抽象基类，而是提供了装饰器，可以将简单函数转换为上下文管理器，以及一个`contextlib.ContextDecorator`基类，可以用来扩展构建一个上下文管理器的类。
- en: We'll look at context managers in [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), *Using Callables and Contexts*.
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第5章](ch05.html "第5章。使用可调用和上下文")中详细讨论上下文管理器，*使用可调用和上下文*。
- en: The abc module
  id: totrans-1245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: abc模块
- en: The core method of creating ABCs is defined in the `abc` module. This module
    includes the `ABCMeta` class that provides several features.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 创建ABC的核心方法在`abc`模块中定义。这个模块包括提供几个特性的`ABCMeta`类。
- en: First, the `ABCMeta` class assures that abstract classes can't be instantiated.
    A subclass that provides all of the required definitions, however, can be instantiated.
    The metaclass will invoke the abstract class's special method, `__subclasshook__()`,
    as a part of processing `__new__()`. If that method returns `NotImplemented`,
    then an exception will be raised to show that the class didn't define all the
    required methods.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`ABCMeta`类确保抽象类不能被实例化。然而，提供了所有必需定义的子类可以被实例化。元类将调用抽象类的特殊方法`__subclasshook__()`，作为处理`__new__()`的一部分。如果该方法返回`NotImplemented`，那么将引发异常，以显示该类没有定义所有必需的方法。
- en: Second, it provides definitions for `__instancecheck__()` and `__subclasscheck__()`.
    These special methods implement the `isinstance()` and `issubclass()` built-in
    functions. They provide the checks to confirm that an object (or a class) belongs
    to the proper ABC. This includes a cache of subclasses to speed up the testing.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它为`__instancecheck__()`和`__subclasscheck__()`提供了定义。这些特殊方法实现了`isinstance()`和`issubclass()`内置函数。它们提供了确认对象（或类）属于适当ABC的检查。这包括一个子类的缓存，以加快测试速度。
- en: The `abc` module also includes a number of decorators for creating abstract
    method functions that must be provided by a concrete implementation of the abstract
    base class. The most important of these is the `@abstractmethod` decorator.
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '`abc`模块还包括许多装饰器，用于创建必须由抽象基类的具体实现提供的抽象方法函数。其中最重要的是`@abstractmethod`装饰器。'
- en: 'If we wanted to create a new abstract base class, we would use something like
    the following:'
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想创建一个新的抽象基类，我们会使用类似以下的东西：
- en: '[PRE206]'
  id: totrans-1251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: This class includes `ABCMeta` as its metaclass; it also uses the `__subclasshook__()`
    method, which checks for completeness. These provide the core features of an abstract
    class.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类包括`ABCMeta`作为它的元类；它还使用`__subclasshook__()`方法，检查完整性。这些提供了抽象类的核心特性。
- en: This abstraction uses the `abstractmethod` decorator to define three abstract
    methods. Any concrete subclass must define these in order to be a complete implementation
    of the abstract base class.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个抽象使用`abstractmethod`装饰器来定义三个抽象方法。任何具体的子类必须定义这些方法，以便成为抽象基类的完整实现。
- en: The `__subclasshook__` method requires that all of the three abstract methods
    be provided by a subclass. This is, perhaps, heavy-handed, since a super-simple
    betting strategy shouldn't have to provide methods for counting wins and losses.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: '`__subclasshook__`方法要求子类提供所有三个抽象方法。这可能有些过分，因为一个超级简单的投注策略不应该必须提供计算赢和输的方法。'
- en: 'The subclass hook relies on two internal features of a Python class definition:
    the `__dict__` attribute and the `__mro__` attribute. The `__dict__` attribute
    is where the method names and attribute names are recorded for a class definition.
    This is essentially the body of the class. The `__mro__` attribute is the method
    resolution order. This is the sequence of the superclasses of this class. Since
    Python uses multiple inheritance, there can be many superclasses, and the order
    of these superclasses determines the precedence for resolving names.'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 子类挂钩依赖于Python类定义的两个内部特性：`__dict__`属性和`__mro__`属性。`__dict__`属性是记录类定义的方法名和属性名的地方。这基本上是类的主体。`__mro__`属性是方法解析顺序。这是这个类的超类的顺序。由于Python使用多重继承，可以有许多超类，这些超类的顺序决定了解析名称的优先顺序。
- en: 'The following is an example of a concrete class:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个具体类的例子：
- en: '[PRE207]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: The preceding code can't be built because it doesn't provide necessary implementations
    for all three methods.
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码无法构建，因为它没有为所有三种方法提供必要的实现。
- en: 'The following is what happens when we try to build it:'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试构建它时会发生以下情况：
- en: '[PRE208]'
  id: totrans-1260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'The error message indicates that the concrete class is incomplete. The following
    is a better concrete class that passes the completeness test:'
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息表明具体类是不完整的。以下是一个更好的具体类，通过了完整性测试：
- en: '[PRE209]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: We can build an instance of this class and use it as part of our simulation.
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建这个类的一个实例，并将其用作我们模拟的一部分。
- en: As we noted earlier, the `bet()` method should probably be the only *required*
    method. The other two methods should be allowed to default to the single statement
    `pass`.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前指出的，`bet()`方法可能应该是唯一*必需*的方法。其他两个方法应该允许默认为单个语句`pass`。
- en: Summary, design considerations, and trade-offs
  id: totrans-1265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结、设计考虑和权衡
- en: In this chapter, we looked at the essential ingredients of abstract base classes.
    We saw a few features of each kind of abstraction.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看了抽象基类的基本要素。我们看到了每种抽象的一些特性。
- en: We also learned that one rule for good class design is to inherit as much as
    possible. We saw two broad patterns here. We also saw common exceptions to this
    rule.
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学到了一个好的类设计规则是尽可能继承。我们在这里看到了两种广泛的模式。我们还看到了这个规则的常见例外。
- en: Some application classes don't have behaviors that overlap with internal features
    of Python. From our Blackjack examples, a `Card` isn't much like a number, a container,
    an iterator, or a context. It's just a playing card. In this case, we can generally
    invent a new class because there isn't any built-in features to inherit fro.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用类的行为与Python的内部特性没有重叠。从我们的二十一点示例中，`Card`与数字、容器、迭代器或上下文并不相似。它只是一张扑克牌。在这种情况下，我们通常可以发明一个新的类，因为没有任何内置特性可以继承。
- en: 'When we look at `Hand`, however, we see that a hand is clearly a container.
    As we noted when looking at hand classes in [Chapters 1](ch01.html "Chapter 1. The
    __init__() Method"), *The __init__() Method*, and [Chapter 2](ch02.html "Chapter 2. Integrating
    Seamlessly with Python Basic Special Methods"), *Integrating Seamlessly with Python
    – Basic Special Methods*, the following are three fundamental design strategies:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们看`Hand`时，我们会发现手显然是一个容器。正如我们在[第1章](ch01.html "第1章。__init__()方法")和[第2章](ch02.html
    "第2章。与Python基本特殊方法无缝集成")中注意到的，以下是三种基本的设计策略：
- en: Wrapping an existing container
  id: totrans-1270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装现有的容器
- en: Extending an existing container
  id: totrans-1271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展现有的容器
- en: Inventing a wholly new kind of container
  id: totrans-1272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发明一种全新的容器类型
- en: Most of the time, we'll be wrapping or extending an existing container. This
    fits with our rule of inheriting as much as possible.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们将包装或扩展现有的容器。这符合我们尽可能继承的规则。
- en: When we extend an existing class, our application class will fit into the class
    hierarchy neatly. An extension to the built-in `list` is already an instance of
    `collections.abc.MutableSequence`.
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们扩展一个现有的类时，我们的应用类将很好地适应类层次结构。对内置的`list`的扩展已经是`collections.abc.MutableSequence`的一个实例。
- en: When we wrap an existing class, however, we have to consider carefully what
    parts of the original interface we want to support and what parts we don't want
    to support. In our examples in the previous chapters, we only wanted to expose
    the `pop()` method from the list object we were wrapping.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们包装一个现有的类时，我们必须仔细考虑我们想要支持原始接口的哪些部分，以及我们不想支持哪些部分。在前几章的例子中，我们只想暴露我们包装的列表对象的`pop()`方法。
- en: Because a wrapper class is not a complete mutable sequence implementation, there
    are many things it can't do. On the other hand, an extension class participates
    in a number of use cases that just might turn out to be useful. For example, a
    hand that extends `list` will turn out to be iterable.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 因为包装类不是一个完整的可变序列实现，它有很多事情做不了。另一方面，扩展类参与了一些可能会变得有用的用例。例如，扩展`list`的手将变得可迭代。
- en: If we find that extending a class doesn't meet our requirements, we can resort
    to building an entirely new collection. The ABC definitions provide a great deal
    of guidance on what methods are required in order to create a collection that
    can integrate seamlessly with the rest of the Python universe. We'll look at a
    detailed example of inventing a collection in [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*.
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现扩展一个类不能满足我们的要求，我们可以建立一个全新的集合。ABC定义提供了大量关于需要哪些方法才能与Python宇宙的其余部分无缝集成的指导。我们将在[第6章](ch06.html
    "第6章。创建容器和集合")中详细介绍如何发明一个集合的例子。
- en: Looking forward
  id: totrans-1278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the coming chapters, we'll make extensive use of these abstract base classes
    discussed in this chapter. In [Chapter 5](ch05.html "Chapter 5. Using Callables
    and Contexts"), *Using Callables and Contexts*, we'll look at the relatively simple
    features of callables and containers. In [Chapter 6](ch06.html "Chapter 6. Creating
    Containers and Collections"), *Creating Containers and Collections*, we'll look
    at the available containers and collections. We'll also look at building a unique,
    new kind of container in this chapter. Lastly, in [Chapter 7](ch07.html "Chapter 7. Creating
    Numbers"), *Creating Numbers*, we'll look at various numeric types and how we
    can create our own kind of number.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将广泛使用本章讨论的这些抽象基类。在[第5章](ch05.html "第5章。使用可调用和上下文")中，我们将研究可调用和容器的相对简单的特性。在[第6章](ch06.html
    "第6章。创建容器和集合")中，我们将研究可用的容器和集合。我们还将在本章中构建一种独特的新型容器。最后，在[第7章](ch07.html "第7章。创建数字")中，我们将研究各种数字类型以及如何创建我们自己的数字类型。
- en: Chapter 5. Using Callables and Contexts
  id: totrans-1280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。使用可调用和上下文
- en: We can exploit the `collections.abc.Callable` ABC and employ a technique called
    **memoization** to create objects that behave like functions but perform very
    quickly because they are able to cache previous results. In some cases, memoization
    is essential for creating an algorithm that finishes within a reasonable amount
    of time.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用`collections.abc.Callable` ABC并采用一种称为**记忆化**的技术来创建行为类似函数但执行非常快的对象，因为它们能够缓存先前的结果。在某些情况下，记忆化对于创建在合理时间内完成的算法是必不可少的。
- en: The **context** concept allows us to create elegant, reliable resource management.
    The `with` statement defines a context and creates a context manager to control
    the resources used in that context. Python files are generally context managers;
    when used in a `with` statement, they are properly closed.
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '**上下文**概念允许我们创建优雅、可靠的资源管理。`with`语句定义了一个上下文，并创建了一个上下文管理器来控制在该上下文中使用的资源。Python文件通常是上下文管理器；当在`with`语句中使用时，它们会被正确关闭。'
- en: We'll look at several ways to create context managers using the tools in the
    `contextlib` module.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`contextlib`模块中的工具来创建几种上下文管理器的方法。
- en: In Python 3.2, the abstract base classes were in the `collections` module.
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.2中，抽象基类位于`collections`模块中。
- en: In Python 3.3, the abstract base classes are in a separate submodule called
    `collections.abc`. In this chapter, we'll focus on Python Version 3.3\. The basic
    definitions will also be true for Python 3.2, but the `import` statement will
    change.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.3中，抽象基类位于一个名为`collections.abc`的单独子模块中。在本章中，我们将专注于Python版本3.3。基本定义对于Python
    3.2也是正确的，但`import`语句会改变。
- en: We'll show a number of variant designs for callable objects. This will show
    us why a stateful callable object is sometimes more useful than a simple function.
    We'll also look at how to use some of the existing Python context managers before
    we dive in and write our own context manager.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将展示一些可调用对象的变体设计。这将向我们展示为什么有状态的可调用对象有时比简单的函数更有用。我们还将看看如何在深入编写自己的上下文管理器之前使用一些现有的Python上下文管理器。
- en: Designing with ABC callables
  id: totrans-1287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ABC可调用对象进行设计
- en: 'There are two easy ways to create callable objects in Python, as follows:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法可以在Python中创建可调用对象，如下所示：
- en: Using the `def` statement to create a function
  id: totrans-1289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`def`语句创建一个函数
- en: By creating an instance of a class that uses `collections.abc.Callable` as its
    base class
  id: totrans-1290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过创建一个使用`collections.abc.Callable`作为基类的类的实例
- en: 'We can also assign a **lambda** form to a variable. A lambda is a small, anonymous
    function that consists of exactly one expression. We''d rather not emphasize saving
    lambdas in a variable as it leads to the confusing situation where we have a function-like
    callable that''s not defined with a `def` statement. The following is a simple
    callable object that has been created from a class:'
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将**lambda**形式分配给一个变量。lambda是一个由一个表达式组成的小型匿名函数。我们不太愿意强调将lambda保存在变量中，因为这会导致混乱的情况，即我们有一个类似函数的可调用对象，但没有使用`def`语句定义。以下是从类创建的一个简单的可调用对象：
- en: '[PRE210]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'There are three parts to the preceding callable object, as follows:'
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的可调用对象有三个部分，如下所示：
- en: We defined the class as a subclass of `abc.Callable`
  id: totrans-1294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将类定义为`abc.Callable`的子类
- en: We defined the `__call__()` method
  id: totrans-1295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了`__call__()`方法
- en: We created an instance of the class, `pow1()`
  id: totrans-1296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个类的实例，`pow1()`
- en: Yes, the algorithm seems inefficient. We'll address that.
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个算法看起来效率低下。我们将解决这个问题。
- en: Clearly, this is so simple that a full class definition isn't really necessary.
    In order to show the various optimizations, it's slightly simpler to start with
    a callable object rather than mutate a function into a callable object.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是如此简单，以至于真的不需要一个完整的类定义。为了展示各种优化，从可调用对象开始要比将函数变异为可调用对象稍微简单一些。
- en: 'We can now use the `pow1()` function just as we''d use any other function.
    Here''s how to use the `pow1()` function in a Python command line:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以像使用其他函数一样使用`pow1()`函数。以下是如何在Python命令行中使用`pow1()`函数：
- en: '[PRE211]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: We've evaluated the callable object with various kinds of argument values. It's
    not *required* to make a callable object a subclass of `abc.Callable`. However,
    it does help with debugging.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用各种参数值评估了可调用对象。将可调用对象作为`abc.Callable`的子类并不是*必需*的。但是，它有助于调试。
- en: 'Consider this flawed definition:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个有缺陷的定义：
- en: '[PRE212]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: The preceding class definition has an error and doesn't meet the definition
    of the callable abstraction.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类定义有一个错误，并且不符合可调用对象的定义。
- en: Found the error yet? If not, it's at the end of the chapter.
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 找到错误了吗？如果没有，那么错误就在章节的末尾。
- en: 'The following is what happens when we try to create an instance of this class:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试创建这个类的实例时，会发生以下情况：
- en: '[PRE213]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: It may not be obvious exactly what went wrong, but we have a fighting chance
    to debug this. If we hadn't subclassed `collections.abc.Callable`, we'd have a
    somewhat more mysterious problem to debug.
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 可能并不明显出了什么问题，但我们有一个很大的机会来调试这个问题。如果我们没有将`collections.abc.Callable`作为子类，我们将有一个更加神秘的问题需要调试。
- en: Here's what the more mysterious problem would look like. We'll skip the actual
    code for `Power3`. It's the same as `Power2`, except it doesn't subclass `collections.abc.Callable`.
    It starts `class Power3`; otherwise, it's identical.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是更神秘的问题会是什么样子。我们将跳过`Power3`的实际代码。它与`Power2`相同，只是没有将`collections.abc.Callable`作为子类。它以`class
    Power3`开始；其他方面都是相同的。
- en: 'The following is what happens when we try to use `Power3` as a class that doesn''t
    meet the expectations of callables and isn''t a subclass of the `abc.Callable`
    either:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试将`Power3`用作不符合可调用对象期望并且也不是`abc.Callable`的子类的类时，会发生以下情况：
- en: '[PRE214]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: This error provides less guidance as to why the `Power3` class definition is
    flawed. The `Power2` error is much more explicit about the nature of the problem.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误提供的指导不够明确，无法解释`Power3`类定义有什么问题。`Power2`错误对问题的性质更加明确。
- en: Improving performance
  id: totrans-1313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高性能
- en: We'll look at two performance tweaks for the `Power3` class.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看`Power3`类的两种性能调整。
- en: First, a better algorithm. Then, a better algorithm combined with memoization,
    which involves a cache; therefore, the function becomes stateful. This is where
    callable objects shine.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是更好的算法。然后是与记忆化相结合的更好的算法，其中涉及缓存；因此，函数变得有状态。这就是可调用对象的优势所在。
- en: The first modification is to use a **Divide and Conquer** design strategy. The
    previous version chopped ![Improving performance](graphics/0971OS_05_01.jpg) into
    *n* steps; the loop carried out *n* individual multiplication operations. If we
    can find a way to split the problem into two equal portions, the problem decomposes
    into ![Improving performance](graphics/0971OS_05_02.jpg) steps. Given `pow1(2,1024)`,
    the `Power1` callable performs the calculation 1024 multiplications by 2\. We
    can optimize this down to 10 multiplications, a significant speedup.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个修改是使用**分而治之**的设计策略。之前的版本将![提高性能](graphics/0971OS_05_01.jpg)分成*n*步；循环执行*n*个单独的乘法操作。如果我们能找到一种方法将问题分成两个相等的部分，问题就会分解成![提高性能](graphics/0971OS_05_02.jpg)步。给定`pow1(2,1024)`，`Power1`可调用对象执行了1024次乘以2的计算。我们可以将这个优化到10次乘法，显著提高速度。
- en: 'Rather than simply multiplying by a fixed value, we''ll use the "fast exponentiation"
    algorithm. It uses three essential rules for computing ![Improving performance](graphics/0971OS_05_01.jpg),
    as follows:'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是简单地乘以一个固定值，我们将使用“快速指数”算法。它使用三个计算![提高性能](graphics/0971OS_05_01.jpg)的基本规则，如下所示：
- en: If ![Improving performance](graphics/0971OS_05_03.jpg):![Improving performance](graphics/0971OS_05_04.jpg),
    the result is simply 1.
  id: totrans-1318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果![提高性能](graphics/0971OS_05_03.jpg)：![提高性能](graphics/0971OS_05_04.jpg)，结果就是1。
- en: If *n* is odd and ![Improving performance](graphics/0971OS_05_05.jpg), the result
    is ![Improving performance](graphics/0971OS_05_06.jpg). This involves a recursive
    computation of ![Improving performance](graphics/0971OS_05_07.jpg). This still
    does a multiplication but not a real optimization.
  id: totrans-1319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*为奇数且![提高性能](graphics/0971OS_05_05.jpg)，结果是![提高性能](graphics/0971OS_05_06.jpg)。这涉及到![提高性能](graphics/0971OS_05_07.jpg)的递归计算。这仍然进行了乘法，但并非真正的优化。
- en: If *n* is even and ![Improving performance](graphics/0971OS_05_08.jpg), the
    result is ![Improving performance](graphics/0971OS_05_09.jpg). This involves a
    recursive computation of ![Improving performance](graphics/0971OS_05_10.jpg).
    This chops the number of multiplications in half.
  id: totrans-1320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*n*是偶数且![提高性能](graphics/0971OS_05_08.jpg)，结果是![提高性能](graphics/0971OS_05_09.jpg)。这涉及到![提高性能](graphics/0971OS_05_10.jpg)的递归计算。这将乘法次数减半。
- en: 'The following is the recursive callable object:'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是递归可调用对象：
- en: '[PRE215]'
  id: totrans-1322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: We applied the three rules to the input value. If *n* is zero, we'll return
    1\. If *n* is odd, we'll make a recursive call and return ![Improving performance](graphics/0971OS_05_06.jpg).
    If *n* is even, we'll make a recursive call and return ![Improving performance](graphics/0971OS_05_09.jpg).
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对输入值应用了三条规则。如果*n*为零，我们将返回1。如果*n*为奇数，我们将进行递归调用并返回![提高性能](graphics/0971OS_05_06.jpg)。如果*n*为偶数，我们将进行递归调用并返回![提高性能](graphics/0971OS_05_09.jpg)。
- en: The execution time is dramatically faster. We can use the `timeit` module to
    see the difference in performance. See *Some Preliminaries*, for information on
    using `timeit`. When we compare running `pow1(2,1024)` and `pow4(2,1024)` 10,000
    times, we'll see something like 183 seconds for the previous version versus 8
    seconds for this version. We can do better, however, with memoization.
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间大大加快。我们可以使用`timeit`模块来查看性能上的差异。有关使用`timeit`的信息，请参阅*一些准备工作*。当我们比较运行`pow1(2,1024)`和`pow4(2,1024)`
    10000次时，我们会看到先前版本大约需要183秒，而这个版本只需要8秒。然而，我们可以通过备忘录做得更好。
- en: 'The following is how we can gather performance data using `timeit`:'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用`timeit`收集性能数据：
- en: '[PRE216]'
  id: totrans-1326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: We imported the `timeit` module. The `timeit.timeit()` function will evaluate
    a given statement in the defined context. In this case, our expression is the
    simple `pow1(2,1024)` expression. The context for this statement is the definition
    of the `pow1()` function; it includes the import, class definition, and creation
    of the instance.
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们导入了`timeit`模块。`timeit.timeit()`函数将在定义的上下文中评估给定的语句。在这种情况下，我们的表达式是简单的`pow1(2,1024)`表达式。这个语句的上下文是`pow1()`函数的定义；它包括导入、类定义和实例的创建。
- en: Note that we provided `number=100000` to speed things up. If we had used the
    default value for the number of iterations, it could have taken almost 2 minutes.
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们提供了`number=100000`来加快速度。如果我们使用了默认值进行迭代，可能需要将近2分钟。
- en: Using memoization or caching
  id: totrans-1329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用备忘录或缓存
- en: The idea behind memoization is to cache previous results to avoid recomputing
    them. We'll use considerably more memory, but we can also dramatically speed up
    performance by avoiding computation.
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录的理念是缓存先前的结果，以避免重新计算它们。我们将使用更多的内存，但也可以通过避免计算来大大提高性能。
- en: An ordinary function doesn't have a place to cache previous results. A function
    is not expected to be stateful. A callable object, however, can be stateful. It
    can include a cache of previous results.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: 普通函数没有地方来缓存先前的结果。不希望函数有状态。然而，可调用对象可以有状态。它可以包括一个缓存的先前结果。
- en: 'The following is a memoized version of our `Power` callable object:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们的`Power`可调用对象的备忘录版本：
- en: '[PRE217]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: We revised our algorithm to work with the `self.memo` cache.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们修改了我们的算法以适应`self.memo`缓存。
- en: If the value of![Using memoization or caching](graphics/0971OS_05_01.jpg)has
    been requested previously, that result is returned and no computation is performed.
    This is the big speedup that we spoke of earlier.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果之前已经请求过![使用备忘录或缓存](graphics/0971OS_05_01.jpg)的值，那么将返回该结果，不进行计算。这就是我们之前所说的巨大加速。
- en: Otherwise, the value of ![Using memoization or caching](graphics/0971OS_05_01.jpg)
    must be computed and saved in the memoization cache. The three rules to compute
    the fast exponent are used to get and put values in the cache. This assures us
    that future calculations will be able to exploit the cached values.
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，必须计算并保存![使用备忘录或缓存](graphics/0971OS_05_01.jpg)的值在备忘录缓存中。使用三条规则来计算快速指数，以获取和放置缓存中的值。这确保了未来的计算将能够利用缓存的值。
- en: The importance of memoization can't be stressed enough. The reduction in computation
    can be dramatic. It is commonly done by replacing a slow, expensive function with
    a callable object.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 备忘录的重要性不言而喻。计算的减少可能是巨大的。通常是通过用可调用对象替换一个慢、昂贵的函数来完成的。
- en: Using functools for memoization
  id: totrans-1338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用functools进行备忘录
- en: The Python library includes a memoization decorator in the `functools` module.
    We can use this module instead of creating our own callable object.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: Python库中包括了`functools`模块中的备忘录装饰器。我们可以使用这个模块而不是创建我们自己的可调用对象。
- en: 'We can use it as follows:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用：
- en: '[PRE218]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: This defined a function, `pow6()`, which is decorated with a **Least Recently
    Used** (**LRU**) cache. Previous requests are stored in a memoization cache. The
    requests are tracked in the cache, and the size is limited. The idea behind an
    LRU cache is that the most recently made requests are kept and the least recently
    made requests are quietly purged.
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个函数`pow6()`，它被装饰为**最近最少使用**（**LRU**）缓存。先前的请求被存储在备忘录缓存中。请求在缓存中被跟踪，并且大小是有限的。LRU缓存的理念是最近做出的请求被保留，而最不常做出的请求则被悄悄清除。
- en: Using `timeit`, we can see that 10,000 iterations of `pow5()` run in about 1
    second, while the iterations for `pow6()` run in about 8 seconds.
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`timeit`，我们可以看到`pow5()`的10000次迭代大约需要1秒，而`pow6()`的迭代大约需要8秒。
- en: What this also shows is that a trivial use of `timeit` can misstate the performance
    of the memoization algorithms. The requests of the `timeit` module should be made
    more sophisticated to reflect more realistic use cases, to properly mix cache
    hits and cache misses. Simple random numbers aren't always appropriate for all
    problem domains.
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: 这也表明，`timeit`的一个微不足道的用法可能会误导记忆算法的性能。`timeit`模块的请求应该更加复杂，以反映更现实的用例，以正确地混合缓存命中和缓存未命中。简单的随机数并不总是适用于所有问题领域。
- en: Aiming for simplicity using the callable API
  id: totrans-1345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用可调用的API来追求简单
- en: The idea behind a callable object is that we have an API that's focused on a
    single method.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象的背后思想是，我们有一个专注于单个方法的API。
- en: Some objects have multiple relevant methods. A Blackjack `Hand`, for example,
    has to add cards and produce a total. A blackjack `Player` has to place bets,
    accept hands, and make play decisions (for example, hit, stand, split, insure,
    double down, and so on). These are more complex interfaces that are not suitable
    to be callables.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 一些对象有多个相关方法。例如，一个二十一点`Hand`必须添加卡片并产生总数。一个二十一点`Player`必须下注，接受手牌，并做出打牌决定（例如，要牌、停牌、分牌、投保、加倍下注等）。这些是更复杂的接口，不适合作为可调用对象。
- en: The betting strategy, however, is a candidate for being a callable.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，赌注策略是一个可调用的候选对象。
- en: The betting strategy can either be implemented as several methods (some setters
    and a getter method) or it can be a callable interface with a few public attributes.
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: 赌注策略可以实现为几种方法（一些设置器和一个获取器方法），或者它可以是一个可调用接口，具有一些公共属性。
- en: 'The following is the straight betting strategy. It is always the same:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是直接的赌注策略。它总是相同的：
- en: '[PRE219]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The idea of this API is that a `Player` object will inform the betting strategy
    of win amounts and loss amounts. The `Player` object might have methods such as
    the following to inform the betting strategy about the outcome:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: 这个API的想法是，`Player`对象将通知赌注策略的赢得金额和损失金额。`Player`对象可能有以下方法来通知赌注策略有关结果的情况：
- en: '[PRE220]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'These methods inform a betting strategy object (the `self.bet` object) whether
    the hand was a win or a loss. When it''s time to place a bet, the `Player` will
    perform something like the following operation to get the current betting level:'
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法通知一个赌注策略对象（`self.bet`对象）手牌是赢还是输。当是下注的时候，`Player`将执行类似以下操作来获取当前的下注水平：
- en: '[PRE221]'
  id: totrans-1355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: This is a pleasantly short API. After all, the betting strategy doesn't do much
    other than encapsulate a few, relatively simple rules.
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简短的API。毕竟，赌注策略除了封装一些相对简单的规则之外，并没有做太多事情。
- en: The shortness of this interface is one of the elegant features of a callable
    object. We don't have many method names, and we don't have a complex set of syntaxes
    for a simple thing.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口的简短性是可调用对象的一个优雅特性。我们没有太多的方法名，也没有复杂的语法用于一个简单的事情。
- en: Complexities and the callable API
  id: totrans-1358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂性和可调用API
- en: 'Let''s see how well this API holds up as our processing becomes more complex.
    The following is the double-up on each loss strategy (also known as the **Martingale**
    betting system):'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们的处理变得更加复杂时，这个API能否经得起考验。以下是每次损失都加倍的策略（也称为**马丁尼**赌注系统）：
- en: '[PRE222]'
  id: totrans-1360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Each loss doubles the betting by multiplying the stage by two. This goes on
    until we win and recoup our losses, reach the table limit, or go broke and can
    no longer place any bets. Casinos prevent this by imposing table limits.
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: 每次损失都会将赌注加倍，将阶段乘以二。这将持续下去，直到我们赢得并收回我们的损失，达到桌子限制，或者破产并不能再下注。赌场通过施加桌子限制来防止这种情况。
- en: Whenever we win, the betting is reset to the base bet. The stage is reset to
    have a value of one.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们赢得时，赌注就会重置为基本赌注。阶段被重置为一个值为一的值。
- en: In order to keep the attribute interface—code such as `bet.win += 1`—we need
    to create properties to make the state changes correctly based on the wins and
    losses. We only really care about the setter properties, but we must define getter
    properties in order to clearly create setter properties.
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持属性接口——例如`bet.win += 1`这样的代码，我们需要创建属性，以便根据赢和输正确地进行状态更改。我们只关心设置器属性，但我们必须定义获取器属性，以便清楚地创建设置器属性。
- en: 'We can see this class in action as follows:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到这个类的实际操作如下：
- en: '[PRE223]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The API is still quite simple. We can either count the wins and reset the bet
    to the base, or we can count the losses, and the bets will double.
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: API仍然非常简单。我们可以计算赢得次数并将赌注重置为基本赌注，或者我们可以计算损失次数，赌注将加倍。
- en: 'The use of properties made the class definition long and hideous. We''re really
    only interested in the setters and not the getters, so we can use `__setattr__()`
    to streamline the class definition somewhat, as shown in the following code:'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的使用使得类定义变得冗长且丑陋。我们真正感兴趣的只是设置器而不是获取器，因此我们可以使用`__setattr__()`来简化类定义，如下面的代码所示：
- en: '[PRE224]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: We used `__setattr__()` to monitor the updates to `win` and `loss`. In addition
    to setting the instance variables using `super().__setattr__()`, we also updated
    the internal state for the betting amount.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`__setattr__()`来监视对`win`和`loss`的更新。除了使用`super().__setattr__()`设置实例变量之外，我们还更新了赌注金额的内部状态。
- en: This is a nicer looking class definition, and it retains the simple API as a
    callable object with two attributes.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好看的类定义，并且保留了一个具有两个属性的简单API作为可调用对象。
- en: Managing contexts and the with statement
  id: totrans-1371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理上下文和`with`语句
- en: Contexts and context managers are used in several places in Python. We'll look
    at a few examples to establish the basic terminology.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文和上下文管理器在Python中的几个地方使用。我们将看一些例子来建立基本术语。
- en: A context is defined by the `with` statement. The following program is a small
    example that parses a logfile to create a useful CSV summary of that log. Since
    there are two open files, we expect to see nested `with` contexts. The example
    uses a complex regular expression, `format_1_pat`. We'll define this shortly.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文由`with`语句定义。以下程序是一个小例子，它解析日志文件，创建一个有用的日志CSV摘要。由于有两个打开的文件，我们期望看到嵌套的`with`上下文。示例使用了一个复杂的正则表达式`format_1_pat`。我们很快就会定义这个。
- en: 'We might see something like the following in an application program:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会在应用程序中看到以下内容：
- en: '[PRE225]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Two contexts with two context managers were emphasized in this example.
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中强调了两个上下文和两个上下文管理器。
- en: The outermost context starts with `with open("subset.csv", "w") as target`.
    The built-in `open()` function opens a file that is also a context manager and
    assigns it to the `target` variable for further use.
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: 最外层的上下文从`with open("subset.csv", "w") as target`开始。内置的`open()`函数打开一个文件，同时也是一个上下文管理器，并将其分配给`target`变量以供进一步使用。
- en: The inner context starts with `with gzip.open(path, "r") as source`. This `gzip.open()`
    function behaves much like the `open()` function in that it opens a file that
    is also a context manager.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 内部上下文从`with gzip.open(path, "r") as source`开始。这个`gzip.open()`函数的行为与`open()`函数类似，它打开一个文件，同时也是一个上下文管理器。
- en: When the `with` statements end, the contexts exit and the files are properly
    closed. Even if there's an exception in the body of the `with` context, the context
    manager's exit will be processed correctly and the file will be closed.
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 当`with`语句结束时，上下文退出，文件被正确关闭。即使在`with`上下文的主体中出现异常，上下文管理器的退出也将被正确处理，文件将被关闭。
- en: Tip
  id: totrans-1380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Always use a with around a file()**'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: '**始终在文件周围使用with**'
- en: Since files involve OS resources, it's important to be sure that the entanglements
    between our applications and the OS are released as soon as they're no longer
    needed. The `with` statement ensures that resources are used properly.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件涉及操作系统资源，确保应用程序和操作系统之间的纠缠在不再需要时被释放是很重要的。`with`语句确保资源被正确使用。
- en: 'Just to complete the example, the following is the regular expression used
    to parse Apache HTTP server logfiles in **Common Log Format**:'
  id: totrans-1383
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成示例，以下是用于解析Apache HTTP服务器日志文件的**通用日志格式**的正则表达式：
- en: '[PRE226]'
  id: totrans-1384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The preceding expression located the various log format fields used in the previous
    example.
  id: totrans-1385
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中找到了用于前面示例中使用的各种日志格式字段。
- en: Using the decimal context
  id: totrans-1386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用十进制上下文
- en: Another context that is used frequently is the decimal context. This context
    defines a number of properties of `decimal.Decimal` calculation, including the
    quantization rules used to round or truncate values.
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 经常使用的另一个上下文是十进制上下文。这个上下文定义了`decimal.Decimal`计算的许多属性，包括用于舍入或截断值的量化规则。
- en: 'We might see application programming that looks like the following:'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会看到以下样式的应用程序编程：
- en: '[PRE227]'
  id: totrans-1389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: The preceding example shows the default context as well as a local context.
    The default context has the default rounding rule. The localized context, however,
    shows how we can assure consistent operations by setting the decimal rounding
    for a particular calculation.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例显示了默认上下文以及局部上下文。默认上下文具有默认的舍入规则。然而，局部上下文显示了如何通过为特定计算设置十进制舍入来确保一致的操作。
- en: The `with` statement is used to assure that the original context is restored
    after the localized change. Outside this context, the default rounding applies.
    Inside this context, a specific rounding applies.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: '`with`语句用于确保在局部更改后恢复原始上下文。在此上下文之外，将应用默认舍入。在此上下文中，将应用特定的舍入。'
- en: Other contexts
  id: totrans-1392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他上下文
- en: There are a few other common contexts. Almost all of them are associated with
    basic input/output operations. Most modules that open a file create a context
    along with the file-like object.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些其他常见的上下文。几乎所有与基本输入/输出操作相关的模块都会创建一个上下文以及类似文件的对象。
- en: Contexts are also associated with locking and database transactions. We may
    acquire and release an external lock, like a semaphore, or we may want a database
    transaction to properly commit when it's successful or roll back when it fails.
    These are all the things that have defined contexts in Python.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文还与锁定和数据库事务相关联。我们可能会获取和释放外部锁，比如信号量，或者我们可能希望数据库事务在成功提交时正确提交，或者在失败时回滚。这些都是Python中定义上下文的事情。
- en: The PEP 343 document provides a number of other examples of how the `with` statement
    and context managers might be used. There are other places where we might like
    to use a context manager.
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: PEP 343文档提供了`with`语句和上下文管理器可能被使用的其他一些示例。还有其他地方我们可能想要使用上下文管理器。
- en: We may need to create classes that are simply context managers, or we may need
    to create classes that can have multiple purposes, one of which is to be a context
    manager. The `file()` object is similar. We'll look at a number of design strategies
    for contexts.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能需要创建仅仅是上下文管理器的类，或者我们可能需要创建可以具有多种用途的类之一是作为上下文管理器。`file()`对象类似。我们将研究一些上下文的设计策略。
- en: We'll return to this again in [Chapter 8](ch08.html "Chapter 8. Decorators and
    Mixins – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*,
    where we can cover a few more ways to create classes that have context manager
    features.
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第8章](ch08.html "第8章。装饰器和混入-横切面")中再次讨论这个问题，*装饰器和混入-横切面*，在那里我们可以涵盖创建具有上下文管理器功能的类的更多方法。
- en: Defining the __enter__() and __exit__() methods
  id: totrans-1398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义`__enter__()`和`__exit__()`方法
- en: 'The defining feature of a context manager is that it has two special methods:
    `__enter__()` and `__exit__()`. These are used by the `with` statement to enter
    and exit the context. We''ll use a simple context so that we can see how they
    work.'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器的定义特征是它具有两个特殊方法：`__enter__()`和`__exit__()`。这些方法由`with`语句用于进入和退出上下文。我们将使用一个简单的上下文，以便看到它们是如何工作的。
- en: We'll often use context managers to make transient global changes. This might
    be a change to the database transaction status or a change to the locking status,
    something that we want to do and then undo when the transaction is complete.
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常使用上下文管理器进行瞬时全局更改。这可能是对数据库事务状态或锁定状态的更改，我们希望在事务完成时撤消。
- en: For this example, we'll make a global change to the random number generator.
    We'll create a context in which the random number generator uses a fixed and known
    seed, providing a fixed sequence of values.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将全局更改随机数生成器。我们将创建一个上下文，在这个上下文中，随机数生成器使用一个固定和已知的种子，提供一个固定的值序列。
- en: 'The following is the context manager class definition:'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是上下文管理器类的定义：
- en: '[PRE228]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: We defined the required `__enter__()` and _`_exit__()` methods. The `__enter__()`
    method will save the previous state of the random module and then reset the seed
    to a given value. The `__exit__()` method will restore the original state of the
    random number generator.
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了所需的`__enter__()`和`__exit__()`方法。`__enter__()`方法将保存随机模块的先前状态，然后将种子重置为给定值。`__exit__()`方法将恢复随机数生成器的原始状态。
- en: Note that `__enter__()` returns `self`. This is common for **mixin** context
    managers that have been added into other class definitions. We'll look at the
    concept of a mixin in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators And Mixins – Cross-cutting Aspects*.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`__enter__()` 返回 `self`。这对于已添加到其他类定义中的**mixin**上下文管理器是常见的。我们将在[第8章](ch08.html
    "第8章。装饰器和Mixin-横切方面")中讨论mixin的概念，*装饰器和Mixin-横切方面*。
- en: The `__exit__()` method's parameters will have the value of `None` under normal
    circumstances. Unless we have specific exception-handling needs, we generally
    ignore the argument values. We'll look at exception-handling in the following
    code.
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__()`方法的参数在正常情况下将具有`None`的值。除非我们有特定的异常处理需求，通常会忽略参数值。我们将在下面的代码中讨论异常处理。'
- en: 'Here''s an example of using the context:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用上下文的示例：
- en: '[PRE229]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Each time we create an instance of `KnownSequence`, we're modifying the way
    the `random` module works. During the context of the `with` statement, we'll get
    a fixed sequence of values. Outside the context, the random seed is restored,
    and we get random values.
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们创建`KnownSequence`的实例时，我们都会修改`random`模块的工作方式。在`with`语句的上下文中，我们将获得一系列固定的值。在上下文之外，随机种子将被恢复，我们将获得随机值。
- en: 'The output will look like the following (in most cases):'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
  zh: 输出通常如下所示：
- en: '[PRE230]'
  id: totrans-1411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: Some of this output is machine-dependent. While the exact values may vary, the
    second and fourth lines will match because the seed was fixed by the context.
    The other lines will not necessarily match because they rely on the `random` module's
    own randomization features.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 部分输出取决于机器。虽然确切的值可能有所不同，但第二行和第四行将匹配，因为种子由上下文固定。其他行不一定匹配，因为它们依赖于`random`模块自己的随机化特性。
- en: Handling exceptions
  id: totrans-1413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理异常
- en: Exceptions that arise in a block will be passed to the `__exit__()` method of
    the context manager. The standard bits of an exception—the class, arguments, and
    the traceback stack—will all be provided as argument values.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个块中出现的异常将传递给上下文管理器的`__exit__()`方法。异常的标准部分-类、参数和回溯堆栈-都将作为参数值提供。
- en: 'The `__exit__()` method can do one of the following two things with the exception
    information:'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__()`方法可以对异常信息执行以下两种操作之一：'
- en: Silence the exception by returning some `True` value.
  id: totrans-1416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过返回一些`True`值来消除异常。
- en: Allow the exception to rise normally by returning any other `False` value. Returning
    nothing is the same as returning `None`, which is a `False` value; this allows
    the exception to propagate.
  id: totrans-1417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过返回任何其他`False`值来允许异常正常上升。返回什么也不同于返回`None`，这是一个`False`值；这允许异常传播。
- en: An exception might also be used to alter what the context manager does on exit.
    We might, for example, have to do special processing for certain types of OS errors
    that might arise.
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 异常也可以用于更改上下文管理器在退出时的操作。例如，我们可能必须对可能出现的某些类型的OS错误进行特殊处理。
- en: Context manager as a factory
  id: totrans-1419
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 上下文管理器作为工厂
- en: We can create a context manager class, which is a factory for an application
    object. This gives us a pleasant separation of design considerations without cluttering
    up an application class with context management features.
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个上下文管理器类，它是应用程序对象的工厂。这使我们在不使应用程序类混杂上下文管理特性的情况下，愉快地分离设计考虑。
- en: Let's say we want a deterministic `Deck` for dealing in blackjack. This isn't
    as useful as it might sound. For unit testing, we'll need a completely mock deck
    with specific sequences of cards. This has the advantage that the context manager
    works with the classes we already saw.
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要一个确定性的用于21点的`Deck`。这并不像听起来那么有用。对于单元测试，我们将需要一个完全模拟的具有特定卡片序列的牌组。这样做的好处是上下文管理器可以与我们已经看到的类一起使用。
- en: We'll extend the simple context manager shown earlier to create a `Deck` that
    can be used within the `with` statement context.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将扩展之前显示的简单上下文管理器，以创建一个可以在`with`语句上下文中使用的`Deck`。
- en: 'The following is a class that is a factory for `Deck` and also tweaks the `random`
    module:'
  id: totrans-1423
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个工厂`Deck`并调整`random`模块的类：
- en: '[PRE231]'
  id: totrans-1424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: The preceding context manager class preserves the argument values so that it
    can create a `Deck` with the given arguments.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的上下文管理器类保留参数值，以便它可以使用给定的参数创建一个`Deck`。
- en: The `__enter__()` method preserves the old random number state and then sets
    the `random` module in a mode that provides a fixed sequence of values. This is
    used to build and shuffle the deck.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '`__enter__()`方法保留了旧的随机数状态，然后设置了`random`模块的模式，以提供一系列固定的值。这用于构建和洗牌牌组。'
- en: Note that the `__enter__()` method returns a newly minted `Deck` object to be
    used in the `with` statement context. This is assigned via the `as` clause in
    the `with` statement.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`__enter__()`方法返回一个新创建的`Deck`对象，以便在`with`语句上下文中使用。这是通过`with`语句中的`as`子句分配的。
- en: We could have provided similar functionality in another way. We could create
    an instance of `random.Random(x=seed)` within the `Deck` class. While that also
    works well, it tends to clutter the `Deck` class with code that's only used for
    demonstrations.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以以另一种方式提供类似的功能。我们可以在`Deck`类中创建`random.Random(x=seed)`的实例。虽然这也很有效，但它倾向于使`Deck`类混杂了仅用于演示的代码。
- en: 'The following is a way to use this factory context manager:'
  id: totrans-1429
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用此工厂上下文管理器的方法：
- en: '[PRE232]'
  id: totrans-1430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: The preceding example of code guarantees a specific sequence of cards that we
    can use for demonstration purposes.
  id: totrans-1431
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码示例保证了我们可以用于演示目的的特定顺序的卡片。
- en: Cleaning up in a context manager
  id: totrans-1432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在上下文管理器中清理
- en: In this section, we'll discuss a more complex context manager that attempts
    some cleanup when there are problems.
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论一个更复杂的上下文管理器，在出现问题时尝试进行一些清理。
- en: 'This addresses the common issue where we want to save a backup copy of a file
    that our application is rewriting. We want to be able to do something like the
    following:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 这解决了我们想要保存正在重写的文件的备份副本的常见问题。我们希望能够做类似以下的事情：
- en: '[PRE233]'
  id: totrans-1435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: The intent is to have the original file renamed to `some_file copy`. If the
    context works normally—no exceptions—then the backup copy can be deleted or renamed
    to `some_file old`.
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 意图是将原始文件重命名为`some_file copy`。如果上下文正常工作——没有异常——那么备份副本可以被删除或重命名为`some_file old`。
- en: If the context doesn't work normally—there's an exception—we want to rename
    the new file to `some_file error` and rename the old file to `some_file`, putting
    the original file back the way it was before the exception.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上下文不能正常工作——有一个异常——我们希望将新文件重命名为`some_file error`，并将旧文件重命名为`some_file`，将原始文件放回异常发生之前的状态。
- en: 'We will need a context manager like the following:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一个如下的上下文管理器：
- en: '[PRE234]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: This context manager's `__enter__()` method will attempt to preserve a previous
    copy of the named file if it already exists. If it didn't exist, there's nothing
    to preserve.
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个上下文管理器的`__enter__()`方法将尝试保留已命名文件的先前副本。如果它不存在，就没有什么可以保留的了。
- en: The `__exit__()` method be given information about any exception that occurred
    in the context. If there is no exception, it will simply return any previous file
    that exists was preserved the file created within the context will also exist.
    If there is an exception, then the `__exit__()` method will try to preserve the
    output (with a suffix of "error") for debugging purposes it will also put any
    previous version of file back in place.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__()`方法将提供有关上下文中发生的任何异常的信息。如果没有异常，它将简单地返回任何先前存在的文件，保留了在上下文中创建的文件也将存在。如果有异常，那么`__exit__()`方法将尝试保留输出（带有后缀"error"）以进行调试，它还将把文件的任何先前版本放回原位。'
- en: This is functionally equivalent to a `try-except-finally` block. However, it
    has the advantage that it separates the relevant application processing from the
    context management. The application processing is written in the `with` statement.
    The context issues are set aside into a separate class.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上等同于`try-except-finally`块。但它的优势在于它将相关的应用处理与上下文管理分开。应用处理写在`with`语句中。上下文问题被放到一个单独的类中。
- en: Summary
  id: totrans-1443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We looked at three of the special methods for class definition. The `__call__()`
    method is used when creating a callable. The callable is used to create functions
    that are stateful. Our primary example is a function that memoizes previous results.
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看了类定义的三个特殊方法。`__call__()`方法用于创建可调用对象。可调用对象用于创建有状态的函数。我们的主要示例是一个记忆化先前结果的函数。
- en: The `__enter__()` and `__exit__()` methods are used to create a context manager.
    The context is used to handle processing that is localized to the body of a with
    statement. Most of our examples include input-output processing. However, Python
    presents a number of other situations where a localized context can come handy.
    will focus on creating containers and collections.
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: '`__enter__()`和`__exit__()`方法用于创建上下文管理器。上下文用于处理局部化到with语句体中的处理。我们的大多数示例包括输入输出处理。然而，Python提供了许多其他情况，其中局部上下文可能会派上用场。将重点放在创建容器和集合上。'
- en: Callable design considerations and trade-offs
  id: totrans-1446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可调用设计考虑和权衡
- en: 'When designing a callable object, we need to consider the following:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计可调用对象时，我们需要考虑以下事项：
- en: The first is the API of the object. If there's a reason for the object to have
    a function-like interface, then a callable object is a sensible design approach.
    Using `collections.abc.Callable` assures that the callable API is built correctly,
    and it informs anyone reading the code what the intent of the class is.
  id: totrans-1448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是对象的API。如果对象需要具有类似函数的接口，那么可调用对象是一个明智的设计方法。使用`collections.abc.Callable`确保可调用API被正确构建，并且它告诉任何阅读代码的人类的意图是什么。
- en: The second is the statefulness of the function. Ordinary functions in Python
    have no hysteresis—there's no saved state. A callable object, however, can easily
    save a state. The memoization design pattern makes good use of stateful callable
    objects.
  id: totrans-1449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个是函数的状态性。Python中的普通函数没有滞后性——没有保存的状态。然而，可调用对象可以轻松保存状态。记忆化设计模式很好地利用了有状态的可调用对象。
- en: The only disadvantage of a callable object is the amount of syntax that is required.
    An ordinary function definition is shorter and therefore less error prone and
    easier to read.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 可调用对象的唯一缺点是所需的语法量。普通函数定义更短，因此更不容易出错，更容易阅读。
- en: 'It''s easy to migrate a defined function to a callable object, as follows:'
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 将已定义的函数迁移到可调用对象很容易，如下所示：
- en: '[PRE235]'
  id: totrans-1452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The preceding function can be converted into the following callable object:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的函数可以转换为以下可调用对象：
- en: '[PRE236]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: This is the minimal set of changes required to get the function to pass unit
    tests in the new form. The existing body will work in the new context unmodified.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在新形式中使函数通过单元测试所需的最小更改集。现有的主体将在新上下文中不经修改地工作。
- en: Once the change has been made, features can be added to the callable object's
    version of the function.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦更改完成，就可以向可调用对象的函数版本添加功能。
- en: Context manager design considerations and trade-offs
  id: totrans-1457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上下文管理器设计考虑和权衡
- en: A context is generally used to acquire/release, open/close, and lock/unlock
    types of operation pairs. Most of the examples are file I/O related, and most
    of the file-like objects in Python are already proper context managers.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文通常用于获取/释放、打开/关闭和锁定/解锁类型的操作对。大多数示例与文件I/O相关，Python中的大多数类似文件的对象已经是适当的上下文管理器。
- en: A context manager is almost always required for anything that has steps which
    bracket the essential processing. In particular, anything that requires a final
    `close()` method should be wrapped by a context manager.
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是需要上下文管理器来处理任何具有包围基本处理步骤的东西。特别是，任何需要最终`close()`方法的东西都应该被上下文管理器包装。
- en: Some Python libraries have open/close operations, but the objects aren't proper
    contexts. The `shelve` module, for example, doesn't create a proper context.
  id: totrans-1460
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Python库具有打开/关闭操作，但对象不是适当的上下文。例如，`shelve`模块并不创建适当的上下文。
- en: We can (and should) use the `contextllib.closing()` context on a `shelve` file.
    We'll show this in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving –
    JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*.
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以（也应该）在`shelve`文件上使用`contextllib.closing()`上下文。我们将在[第9章](ch09.html "第9章。序列化和保存
    - JSON，YAML，Pickle，CSV和XML")中展示这一点，*序列化和保存 - JSON，YAML，Pickle，CSV和XML*。
- en: For our own classes that require a `close()`method, we can use the `closing()`
    function. When confronted with a class that has any kind of acquire/release life
    cycle, we want to acquire resources in `__init__()` or a class-level `open()`method
    and release them in `close()`. That way, our class can integrate well with this
    `closing()` function.
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们自己的需要`close()`方法的类，我们可以使用`closing()`函数。当面对具有任何类型获取/释放生命周期的类时，我们希望在`__init__()`或类级`open()`方法中获取资源，并在`close()`中释放资源。这样，我们的类就可以很好地与这个`closing()`函数集成。
- en: 'The following is an example of some class being wrapped that requires a `close()`
    function:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个需要`close()`函数的类的示例：
- en: '[PRE237]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: The `contextllib.closing()` function will invoke the `close()` method of the
    object that is given as an argument. We can guarantee that `my_object` will have
    its `close()` method evaluated.
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '`contextllib.closing()`函数将调用作为参数给定的对象的`close()`方法。我们可以保证`my_object`将评估其`close()`方法。'
- en: Looking forward
  id: totrans-1466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next two chapters, we'll look at the special methods used to create containers
    and numbers. In [Chapter 6](ch06.html "Chapter 6. Creating Containers and Collections"),
    *Creating Containers and Collections*, we'll look at the containers and collections
    in the standard library. We'll also look at building a unique, new kind of container.
    In [Chapter 7](ch07.html "Chapter 7. Creating Numbers"), *Creating Numbers*, we'll
    look at the various numeric types and how we can create our own kind of number.
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我们将研究用于创建容器和数字的特殊方法。在[第6章](ch06.html "第6章。创建容器和集合")中，*创建容器和集合*，我们将研究标准库中的容器和集合。我们还将研究构建一种独特的新类型的容器。在[第7章](ch07.html
    "第7章。创建数字")中，*创建数字*，我们将研究各种数字类型以及如何创建我们自己的数字类型。
- en: Chapter 6. Creating Containers and Collections
  id: totrans-1468
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。创建容器和集合
- en: We can extend a number of ABCs to create new kinds of collections. The ABCs
    provide us with design guidelines to extend the built-in containers. These allow
    us to fine-tune the features or radically define new data structures that fit
    our problem domain more precisely.
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展多个ABC来创建新类型的集合。ABC为我们提供了扩展内置容器的设计指南。这些允许我们微调特性或根本定义更精确地适应我们问题域的新数据结构。
- en: We'll look at the basics of ABC for container classes. There are a fairly large
    number of abstractions that are used to assemble the Python built-in types, such
    as `list`, `tuple`, `dict`, `set`, and `frozenset`.
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究容器类的ABC基础知识。有相当多的抽象用于组装Python内置类型，如`list`，`tuple`，`dict`，`set`和`frozenset`。
- en: We'll review the variety of special methods that are involved in being a container
    and offering the various features of containers. We'll split these into the core
    container methods, separate from more specialized sequence, map, and set methods.
  id: totrans-1471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾涉及成为容器并提供各种容器特性的各种特殊方法。我们将这些分为核心容器方法，与更专门的序列，映射和集合方法分开。
- en: We'll address extending built-in containers to add features. We'll also look
    at wrapping built-in containers and delegating methods through the wrapper to
    the underlying container.
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论扩展内置容器以添加特性。我们还将研究包装内置容器并通过包装器委托方法到底层容器。
- en: Finally, we'll look at building entirely new containers. This is a challenging
    territory, because there's a huge variety of interesting and useful collection
    algorithms already present in the Python Standard Library. In order to avoid deep
    computer science research, we'll build a pretty lame collection. Before starting
    on a real application, a careful study of *Introduction to Algorithms* by Cormen,
    Leiserson, Rivest, and Stein is essential.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将研究构建全新的容器。这是一个具有挑战性的领域，因为Python标准库中已经存在着大量有趣和有用的集合算法。为了避免深入的计算机科学研究，我们将构建一个相当无聊的集合。在开始真正的应用程序之前，有必要仔细研究Cormen，Leiserson，Rivest和Stein的《算法导论》。
- en: We'll finish by summarizing some of the design considerations that go into extending
    or creating new collections.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将总结一些设计考虑因素，这些因素涉及扩展或创建新集合。
- en: ABCs of collections
  id: totrans-1475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集合的ABC
- en: The `collections.abc` module provides a wealth of abstract base classes that
    decompose collections into a number of discrete feature sets.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: '`collections.abc`模块提供了丰富的抽象基类，将集合分解为多个离散的特性集。'
- en: We can successfully use the `list` class without thinking too deeply about the
    various features and how they relate to the `set` class or the `dict` class. Once
    we start looking at the ABCs, however, we can see that there's a bit of subtlety
    to these classes. By decomposing the aspects of each collection, we can see areas
    of overlapping that manifest themselves as an elegant polymorphism even among
    different data structures.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以成功地使用`list`类，而不需要深入思考各种特性以及它们与`set`类或`dict`类的关系。然而，一旦我们开始研究ABC，我们就可以看到这些类有一些微妙之处。通过分解每个集合的方面，我们可以看到重叠的领域，这些领域表现为即使在不同的数据结构之间也有一种优雅的多态性。
- en: 'At the bottom of the base classes are some "one-trick pony" definitions. These
    are the base classes that require a single special method:'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: 在基类的底部有一些“一招鲜”的定义。这些是需要一个特殊方法的基类：
- en: The `Container` base class requires the concrete class to implement the `__contains__()`
    method. This special method implements the `in` operator.
  id: totrans-1479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Container`基类要求具体类实现`__contains__()`方法。这个特殊方法实现了`in`运算符。'
- en: The `Iterable` base class requires `__iter__()`. This special method is used
    by the `for` statement and the generator expressions as well as the `iter()` function.
  id: totrans-1480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Iterable`基类需要`__iter__()`。这个特殊方法被`for`语句和生成器表达式以及`iter()`函数使用。'
- en: The `Sized` base class requires `__len__()`. This method is used by the `len()`
    function. It's also prudent to implement `__bool__()`, but it's not required by
    this abstract base class.
  id: totrans-1481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sized`基类需要`__len__()`。这个方法被`len()`函数使用。实现`__bool__()`也是明智的，但这不是这个抽象基类所要求的。'
- en: The `Hashable` base class requires `__hash__()`. This is used by the `hash()`
    function. If this is implemented, it means that the object is immutable.
  id: totrans-1482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Hashable`基类需要`__hash__()`。这是`hash()`函数使用的。如果实现了这个方法，这意味着对象是不可变的。'
- en: 'Each of these abstract classes is used to build the higher-level, composite
    definitions of structures we can use in our applications. These composite constructs
    include the lower-level base classes of `Sized`, `Iterable`, and `Container`.
    Here are some composite base classes that we might use in an application:'
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象类都用于构建我们应用程序中可以使用的更高级别的、复合的结构的定义。这些复合结构包括`Sized`、`Iterable`和`Container`的较低级别基类。以下是我们可能在应用程序中使用的一些复合基类：
- en: The `Sequence` and `MutableSequence` classes build on the basics and fold in
    methods such as `index()`, `count()`, `reverse()`, `extend()`, and `remove()`.
  id: totrans-1484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sequence`和`MutableSequence`类基于基础并折叠方法，如`index()`、`count()`、`reverse()`、`extend()`和`remove()`。'
- en: The `Mapping` and `MutableMapping` classes fold in methods such as `keys()`,
    `items()`, `values()`, and `get()`, among others.
  id: totrans-1485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mapping`和`MutableMapping`类折叠方法，如`keys()`、`items()`、`values()`和`get()`，等等。'
- en: The `Set` and `MutableSet` classes fold in comparison and arithmetic operators
    to perform set operations.
  id: totrans-1486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`和`MutableSet`类比较和算术运算符来执行集合操作。'
- en: If we look more deeply into the built-in collections, we can see how the ABC
    class definitions serve to organize the special methods that we need to write
    or modify.
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更深入地研究内置集合，我们可以看到ABC类定义如何组织我们需要编写或修改的特殊方法。
- en: Examples of special methods
  id: totrans-1488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊方法的例子
- en: 'When looking at a blackjack `Hand` object, we have an interesting special case
    for containment. We often want to know if there''s an ace in the hand. If we define
    `Hand` as an extension to `list`, then we can''t ask for a generic ace. We can
    only ask for specific cards. We hate to write something like this:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 当查看一个黑杰克`Hand`对象时，我们对包含有一个有趣的特殊情况。我们经常想知道手中是否有一张王牌。如果我们将`Hand`定义为`list`的扩展，那么我们不能要求一个通用的王牌。我们只能要求特定的卡片。我们不想写这样的东西：
- en: '[PRE238]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: That seems a long-winded way to look for an ace in a hand.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一个冗长的寻找一手牌中的王牌的方式。
- en: 'Here''s a better example, but it still is less-than-ideal, perhaps:'
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更好的例子，但可能仍然不太理想：
- en: '[PRE239]'
  id: totrans-1493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'So, we''d like something like this:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们想要这样的东西：
- en: '[PRE240]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'This means that we''re modifying the meaning of "contains" for a `Hand` object
    that extends `list`. We''re not looking for a `Card` instance, we''re merely looking
    for the rank property of a `Card` object. We can override the `__contains__()`
    method to do this:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们正在修改`Hand`对象对`list`的“包含”含义。我们不是在寻找一个`Card`实例，我们只是在寻找`Card`对象的等级属性。我们可以重写`__contains__()`方法来实现这一点：
- en: '[PRE241]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: This allows us to use a simpler `in` test for a given rank in a hand.
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们可以在手中对给定等级进行更简单的`in`测试。
- en: Similar design considerations can be applied to `__iter__()` and `__len__()`
    special methods. Be cautious, however. Changing the semantics of `len()` or how
    a collection interacts with the `for` statement might be disastrous.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的设计考虑可以应用于`__iter__()`和`__len__()`特殊方法。但是要小心。改变`len()`的语义或集合与`for`语句的交互方式可能是灾难性的。
- en: Using the standard library extensions
  id: totrans-1500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准库扩展
- en: We'll look at some extensions to built-in classes that are already part of the
    standard library. These are the collections that extend or modify the built-in
    collections. Most of these are covered in one form or another in books such as
    *Python 3 Object Oriented Programming*.
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一些已经是标准库一部分的内置类的扩展。这些是扩展或修改内置集合的集合。这些大多数在《Python 3面向对象编程》等书籍中以一种形式或另一种形式进行了讨论。
- en: 'We''ll look at the following six library collections:'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下以下六个库集合：
- en: The `namedtuple()` function creates subclasses of tuple subclasses with named
    attributes. We can use this instead of defining a complete class, which merely
    assigns names to the attribute values.
  id: totrans-1503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`namedtuple()`函数创建具有命名属性的元组子类。我们可以使用这个来代替定义一个完整的类，仅仅为属性值分配名称。'
- en: '`deque` (note the atypical spelling) is a double-ended queue, a list-like collection
    that can perform fast appends and pops on either end. A subset of the features
    of this class will create single-ended stacks or queues.'
  id: totrans-1504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`（注意不寻常的拼写）是一个双端队列，一个类似列表的集合，可以在任一端执行快速的附加和弹出操作。这个类的一部分特性将创建单端堆栈或队列。'
- en: In some cases, we can use `ChainMap` instead of merging mappings together. This
    is a view of multiple mappings.
  id: totrans-1505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可以使用`ChainMap`来代替合并映射。这是多个映射的视图。
- en: An `OrderedDict` collection is a mapping in which the original key entry order
    is maintained.
  id: totrans-1506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`集合是一个维护原始键入顺序的映射。'
- en: '`defaultdict` (note the atypical spelling) is a `dict` subclass that uses a
    factory function to provide values for missing keys.'
  id: totrans-1507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`（注意不寻常的拼写）是一个`dict`子类，它使用一个工厂函数来为缺失的键提供值。'
- en: The `Counter` is a `dict` subclass that can be used for counting objects to
    create frequency tables. However, it's actually a more sophisticated data structure
    called a **multiset** or **bag**.
  id: totrans-1508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`是一个`dict`子类，可用于计算对象以创建频率表。但实际上，它是一种称为**multiset**或**bag**的更复杂的数据结构。'
- en: 'We''ll see examples of each one of the preceding collections. There are two
    important lessons to be learned from studying the library collections:'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到前述每个集合的示例。从研究库集合中可以学到两个重要的教训：
- en: What's already present and doesn't need to be reinvented
  id: totrans-1510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经存在且不需要重新发明的东西
- en: How to extend the ABCs to add interesting and useful structures to the language
  id: totrans-1511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何扩展ABCs以向语言添加有趣和有用的结构
- en: 'Also, it''s important to read the source for the libraries. The source will
    show us numerous Python object-oriented programming techniques. Beyond these basics
    are even more modules. They are as follows:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，阅读库的源代码很重要。源代码将展示给我们许多Python面向对象编程技术。除了这些基础知识外，还有更多的模块。它们如下：
- en: The `heapq` module is a set of functions that impose a heap queue structure
    on an existing `list` object. The heap queue invariant is the set of those items
    in the heap that are maintained in order to allow rapid retrieval in an ascending
    order. If we use the `heapq` methods on a `list` structure, we will never have
    to explicitly sort the list. This can have significant performance improvements.
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`heapq`模块是一组函数，它在现有的`list`对象上施加了一个堆队列结构。堆队列不变式是在堆中维护的那些项目的集合，以便允许按升序快速检索。如果我们在`list`结构上使用`heapq`方法，我们将永远不必显式对列表进行排序。这可能会带来显著的性能改进。'
- en: The `array` module is a kind of sequence that optimizes storage for certain
    kinds of values. This provides list-like features over potentially large collections
    of simple values.
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array`模块是一种为某些类型的值优化存储的序列。这为潜在的大量简单值提供了类似列表的功能。'
- en: In addition, of course, there's the deeper computer science that supports these
    various data structure definitions.
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当然还有支持这些各种数据结构定义的更深层次的计算机科学。
- en: The namedtuple() function
  id: totrans-1516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: namedtuple()函数
- en: The `namedtuple()` function creates a new class definition from the supplied
    arguments. This will have a class name, field names, and a pair of optional keywords
    that define the behavior of the created class.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: '`namedtuple()`函数从提供的参数创建一个新的类定义。这将有一个类名、字段名和一对可选关键字，用于定义所创建类的行为。'
- en: Using `namedtuple()` will condense a class definition into a very short definition
    of a simple immutable object. It saves us from having to write longer and more
    complex class definitions for the common case where we want to name a fixed set
    of attributes.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`namedtuple()`将类定义压缩成一个非常简短的简单不可变对象的定义。它使我们不必为了常见情况下想要命名一组固定属性而编写更长更复杂的类定义。
- en: 'For something like a playing card, we might want to insert the following code
    in a class definition:'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像扑克牌这样的东西，我们可能希望在类定义中插入以下代码：
- en: '[PRE242]'
  id: totrans-1520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'We defined a new class and provided precisely four named attributes: `rank`,
    `suit`, `hard`, and `soft`. Since each of these objects is immutable, we don''t
    need to worry about a badly behaved application attempting to change the rank
    of a `BlackjackCard` instance.'
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个新类，并提供了四个命名属性：`rank`、`suit`、`hard`和`soft`。由于这些对象都是不可变的，我们不必担心一个行为不端的应用程序试图更改`BlackjackCard`实例的等级。
- en: 'We can use a factory function to create instances of this class, as shown in
    the following code:'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用工厂函数来创建这个类的实例，如下面的代码所示：
- en: '[PRE243]'
  id: totrans-1523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'This will build an instance of `BlackjackCard` with the hard and soft totals
    set properly for various card ranks. A new class called `namedtuple` is created
    by filling in a template for a subclass of `tuple` with the various parameters.
    Essentially, the template starts out with this kind of code:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用正确设置硬和软总数的各种卡等级构建一个`BlackjackCard`实例。通过填写一个`tuple`子类的模板来创建一个名为`namedtuple`的新类，基本上，模板从这种代码开始：
- en: '[PRE244]'
  id: totrans-1525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: The template code extends the built-in `tuple` class. Nothing surprising there.
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 模板代码扩展了内置的`tuple`类。没有什么令人惊讶的。
- en: 'It sets `__slots__` to an empty tuple. There are two ways to manage instance
    variables: `__slots__` and `__dict__`. By setting `__slots__`, the `__dict__`
    alternative is disabled, removing the ability to add new instance variables to
    an object of this class. Also, the resulting object is kept to the absolute minimum
    size.'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: 它将`__slots__`设置为空元组。管理实例变量有两种方法：`__slots__`和`__dict__`。通过设置`__slots__`，禁用了`__dict__`的替代方案，从而无法向该类的对象添加新的实例变量。此外，生成的对象保持在绝对最小的大小。
- en: The template creates a class-level variable named `_fields`, which names the
    fields. The `{field_names!r}` construct is where the template text is filled with
    the list of field names.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 模板创建了一个名为`_fields`的类级变量，用于命名字段。`{field_names!r}`构造是模板文本填充了字段名列表的地方。
- en: The template defines a `__new__()` method that is used to initialize the immutable
    object. The `{arg_list}` construct is where the template is filled with the list
    of arguments used to build each instance.
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 模板定义了一个`__new__()`方法，用于初始化不可变对象。`{arg_list}`构造是模板填充了用于构建每个实例的参数列表的地方。
- en: There are several other method functions, but this provides some hints as to
    how the `namedtuple` function works under the hood.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他几个方法函数，但这提供了一些关于`namedtuple`函数在幕后工作的提示。
- en: We can, of course, subclass a `namedtuple` class to add features. We have to
    be cautious about trying to add attributes to a `namedtuple` class, though. The
    list of attributes is encoded in `_fields`, as well as the arguments to `__new__()`.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以对`namedtuple`类进行子类化以添加功能。但是，我们必须谨慎尝试向`namedtuple`类添加属性。属性列表被编码在`_fields`中，以及`__new__()`的参数。
- en: 'Here''s an example of subclassing a `namedtuple` class:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个对`namedtuple`类进行子类化的示例：
- en: '[PRE245]'
  id: totrans-1533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: We used `__slots__` to ensure that the subclass has no `__dict__`; we can't
    add any new attributes. We've overridden `__new__()` so that we can construct
    instances with only two values (`rank` and `suit`), yet populate all four values.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`__slots__`来确保子类没有`__dict__`；我们不能添加任何新属性。我们重写了`__new__()`，这样我们就可以用只有两个值（`rank`和`suit`）构建实例，但是填充所有四个值。
- en: The deque class
  id: totrans-1535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: deque类
- en: A `list` object is designed to provide uniform performance for any element within
    the container. Some operations have performance penalties. Most notably, any operation
    at the front of the list (`list.insert(0, item)` or `list.pop(0)`) will incur
    some overheads because the list size is changed and the position of each element
    has changed.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: '`list`对象旨在为容器中的任何元素提供统一的性能。某些操作会有性能惩罚。特别是，列表前端的任何操作（`list.insert(0, item)`或`list.pop(0)`）会产生一些开销，因为列表大小发生了变化，每个元素的位置也发生了变化。'
- en: A `deque`—a double-ended queue—is designed to provide uniform performance for
    the first and last elements of a list. The idea is that appending and popping
    will be faster than the built-in `list` object.
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: '`deque`——双端队列——旨在为列表的第一个和最后一个元素提供统一的性能。其设计思想是，追加和弹出的速度将比内置的`list`对象更快。'
- en: Tip
  id: totrans-1538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Spelling irregularity**'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: '**拼写不规范**'
- en: Class names are usually in title case. However, the `deque` class isn't.
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: 类名通常采用标题大小写。然而，`deque`类不是。
- en: Our design for a deck of cards avoids the potential performance pitfall of a
    `list` object by always popping from the end, never from the beginning.
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为一副牌的设计避免了`list`对象的潜在性能陷阱，始终从末尾弹出，而不是从开头弹出。
- en: However, as we're using so few features of a `list` object, perhaps a structure
    like that of a deque is a better fit for our problem. We're only storing cards
    so that they can be shuffled and popped from the collection. Other than shuffling,
    our applications never reference elements within the list by their indexed positions.
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于我们几乎没有使用`list`对象的特性，也许像deque这样的结构更适合我们的问题。我们只存储卡片，以便可以对其进行洗牌和弹出。除了洗牌之外，我们的应用程序从不通过它们的索引位置引用列表中的元素。
- en: While the `deque.pop()` method might be very fast, shuffling may suffer. A shuffle
    will make random access to the container, something for which a deque is not designed.
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`deque.pop()`方法可能非常快，但洗牌可能会受到影响。洗牌将对容器进行随机访问，这是deque不设计的功能。
- en: 'In order to confirm the potential costs, we can use `timeit` to compare `list`
    and `deque` shuffling performance as follows:'
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认潜在的成本，我们可以使用`timeit`来比较`list`和`deque`的洗牌性能，如下所示：
- en: '[PRE246]'
  id: totrans-1545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: We invoked `timeit` using `random.shuffle()`. One works on a `list` object,
    the other works on a deque.
  id: totrans-1546
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`random.shuffle()`调用了`timeit`。一个在`list`对象上工作，另一个在deque上工作。
- en: These results indicate that shuffling a deque is only a trifle slower than shuffling
    a `list` object—about 2 percent slower. This distinction is a hair not worth splitting.
    We can confidently try a `deque` object in place of `list`.
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: 这些结果表明，洗牌deque只比洗牌`list`对象慢一点点——大约慢2%。这种区别微乎其微。我们可以有信心地尝试用`deque`对象替换`list`。
- en: 'The change amounts to this:'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的意义在于：
- en: '[PRE247]'
  id: totrans-1549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: We replaced `list` with `deque` in the definition of `Deck`. Otherwise, the
    class is identical.
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Deck`的定义中用`deque`替换了`list`。否则，该类是相同的。
- en: 'What is the actual performance difference? Let''s create decks of 100,000 cards
    and deal them:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的性能差异是什么？让我们创建10万张卡片的牌组并发牌：
- en: '[PRE248]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: We invoked `timeit` using `x.pop()`. One works on a `list`, the other works
    on a deque.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`x.pop()`调用了`timeit`。一个在`list`上工作，另一个在deque上工作。
- en: The dealing time is cut almost by half (42 percent, actually). We had big savings
    from a tiny change in the data structure.
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 发牌时间几乎减少了一半（实际上是42%）。我们从数据结构的微小变化中获得了巨大的节省。
- en: In general, it's important to pick the optimal data structure for the application.
    Trying several variations can show us what's more efficient.
  id: totrans-1555
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，选择最佳的数据结构对应用程序很重要。尝试几种变体可以向我们展示什么更有效。
- en: The ChainMap use case
  id: totrans-1556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ChainMap的用例
- en: The use case for chaining maps together fits nicely with Python's concept of
    local versus global definitions. When we use a variable in Python, first the local
    namespaces, and then the global namespaces are searched, in that order. In addition
    to searching both namespaces for a variable, setting a variable works in the local
    namespace without disturbing the global namespace. This default behavior (without
    the `global` or `nonlocal` statements) is also how a `ChainMap` works.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: 将地图链接在一起的用例与Python的本地与全局定义概念很好地契合。当我们在Python中使用一个变量时，首先搜索本地命名空间，然后搜索全局命名空间，按照这个顺序。除了在两个命名空间中搜索变量之外，设置变量在本地命名空间中进行，而不会影响全局命名空间。这种默认行为（没有`global`或`nonlocal`语句）也是`ChainMap`的工作原理。
- en: When our applications start running, we often have properties that come from
    command-line parameters, configuration files, OS environment variables, and possibly,
    installation-wide settings. We'd like to merge this into a single dictionary-like
    structure so that we can easily locate a setting.
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的应用程序开始运行时，我们经常有来自命令行参数、配置文件、操作系统环境变量以及可能的全局设置的属性。我们希望将这些合并成一个类似字典的结构，以便我们可以轻松地找到一个设置。
- en: 'We might have an application startup that combines several sources of configuration
    options like this:'
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能有一个应用程序启动，将几个配置选项的来源组合在一起，例如：
- en: '[PRE249]'
  id: totrans-1560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'The preceding code shows us the configuration from several sources, such as
    the following:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码向我们展示了来自多个来源的配置，例如以下内容：
- en: The command-line arguments. We saw one token argument called `playerclass`,
    but there are often many, many others.
  id: totrans-1562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数。我们看到一个名为`playerclass`的令牌参数，但通常还有许多其他参数。
- en: One of the arguments, `configuration`, is the name of a configuration file with
    additional parameters. This is expected to be in the JSON format, and the file's
    contents are read.
  id: totrans-1563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一个参数`configuration`是配置文件的名称，其中包含额外的参数。预计这是以JSON格式，读取文件内容。
- en: Additionally, there's a `defaults.json` file with yet another place to look
    for the configuration values.
  id: totrans-1564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另外，还有一个`defaults.json`文件，可以查找配置值的另一个地方。
- en: From the preceding sources, we can build a single `ChainMap` object use case
    that allows looking for a parameter in each of the listed locations. The `ChainMap`
    instance use case will search through each mapping, in an order, looking for the
    given value. This gives us a tidy, easy-to-use source for runtime options and
    parameters.
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的来源中，我们可以构建一个单一的`ChainMap`对象用例，允许在列出的每个位置中查找参数。`ChainMap`实例用例将按顺序搜索每个映射，寻找给定值。这为我们提供了一个整洁、易于使用的运行时选项和参数来源。
- en: We'll look at this again in [Chapter 13](ch13.html "Chapter 13. Configuration
    Files and Persistence"), *Configuration Files and Persistence*, as well as [Chapter
    16](ch16.html "Chapter 16. Coping With the Command Line"), *Coping with the Command
    Line*.
  id: totrans-1566
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第13章](ch13.html "第13章。配置文件和持久性") *配置文件和持久性* 中再次讨论这个问题，以及[第16章](ch16.html
    "第16章。应对命令行") *应对命令行*。
- en: The OrderedDict collection
  id: totrans-1567
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有序字典集合
- en: The `OrderedDict` collection class makes clever use of two storage structures.
    There's an underlying `dict` object type that maps keys to values. Plus, there's
    an additional doubly-linked list of keys that maintains the insertion order.
  id: totrans-1568
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`集合类巧妙地利用了两种存储结构。有一个底层的`dict`对象类型，将键映射到值。此外，还有一个维护插入顺序的键的双向链表。'
- en: One common use for `OrderedDict` is when processing HTML or XML files, where
    the order of objects must be retained, but objects might have cross-references
    via ID and IDREF attributes. We can optimize the connections among objects by
    using the ID as a dictionary key. We can retain the source document's ordering
    with the `OrderedDict` structure.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: '`OrderedDict`的一个常见用途是处理HTML或XML文件，其中对象的顺序必须保留，但对象可能通过ID和IDREF属性具有交叉引用。我们可以通过使用ID作为字典键来优化对象之间的连接。我们可以使用`OrderedDict`结构保留源文档的顺序。'
- en: We don't want to digress too far into the XML parsing here. That's a subject
    for [Chapter 9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在这里过多地深入XML解析。这是[第9章](ch09.html "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")的主题，*序列化和保存
    - JSON、YAML、Pickle、CSV和XML*。
- en: Consider this short example of an XML document that has a rather complex network
    of references between several indexes. We'll imagine a simple microblog document
    with ordered entries that have IDs and indices that have IDREFs to the original
    entries.
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个XML文档的简短示例，其中有几个索引之间的引用网络相当复杂。我们将想象一个简单的微博文档，其中有按顺序排列的条目，这些条目具有ID，索引具有对原始条目的IDREFs。
- en: 'We''ll break the XML into two parts:'
  id: totrans-1572
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将XML分成两部分：
- en: '[PRE250]'
  id: totrans-1573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'There will be a section on topics and another section on indices. Here''s the
    topics'' portion of the blog:'
  id: totrans-1574
  prefs: []
  type: TYPE_NORMAL
  zh: 将有一个关于主题的部分，另一个关于索引的部分。这是博客的主题部分：
- en: '[PRE251]'
  id: totrans-1575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: Each topic has a sequence of entries. Each entry has a unique ID. We're hinting
    that they might belong to **Universally Unique ID** (**UUID**), but we didn't
    produce actual examples.
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 每个主题都有一系列条目。每个条目都有一个唯一的ID。我们暗示它们可能属于**通用唯一标识符**（**UUID**），但我们没有提供实际的例子。
- en: 'Here''s one of the indices for the blog:'
  id: totrans-1577
  prefs: []
  type: TYPE_NORMAL
  zh: 这是博客的一个索引：
- en: '[PRE252]'
  id: totrans-1578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: One index presents the blog entries by the tag. We can see that each tag has
    a list of entries. Each entry has a reference to the original microblog entry.
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 一个索引按标签呈现博客条目。我们可以看到每个标签都有一个条目列表。每个条目都有对原始微博条目的引用。
- en: When we parse this XML document, we need to keep the topics in the original
    order. But, we also have to track the IDs as keys for each entry.
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们解析这个XML文档时，我们需要保持主题的原始顺序。但是，我们还必须跟踪每个条目的ID作为键。
- en: 'Here''s a technical spike that will parse the document and build an `OrderedDict`
    collection:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个技术性的尖峰，将解析文档并构建一个`OrderedDict`集合：
- en: '[PRE253]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: The first part, `# Parse`, will parse the XML source document, creating an `ElementTree`
    object.
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分`# Parse`将解析XML源文档，创建一个`ElementTree`对象。
- en: The second part, `# Gather`, will traverse the entries in the topics section
    of the XML document. Each topic is loaded into a topic's `OrderedDict` collection
    by ID. The original order is retained so that the material can be rendered in
    the correct order.
  id: totrans-1584
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分`# Gather`将遍历XML文档中主题部分的条目。每个主题都按ID加载到一个主题的`OrderedDict`集合中。原始顺序保留，以便可以按正确的顺序呈现材料。
- en: The final part, `# Display`, shows us the entries in their original order and
    their ID.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分`# Display`向我们展示了条目的原始顺序和它们的ID。
- en: The defaultdict subclass
  id: totrans-1586
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`defaultdict`子类'
- en: An ordinary `dict` type throws an exception when a key is not found. A `defaultdict`
    collection class evaluates a given function and inserts the value of that function
    into the dictionary.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 普通的`dict`类型在找不到键时会抛出异常。`defaultdict`集合类会评估给定的函数，并将该函数的值插入字典中。
- en: Tip
  id: totrans-1588
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Note the spelling irregularity**'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: '**请注意拼写不规则**'
- en: Class names are usually in TitleCase. However, the `defaultdict` class isn't.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 类名通常是TitleCase。但是，`defaultdict`类不是。
- en: A common use case for a `defaultdict` class is to create indices for objects.
    When several objects have a common key, we can create a list of objects that share
    this key.
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`类的一个常见用例是为对象创建索引。当几个对象具有共同的键时，我们可以创建共享此键的对象列表。'
- en: 'Here''s a part of a technical spike that shows us how we might accumulate a
    list of outcomes indexed by the dealer''s upcard:'
  id: totrans-1592
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个技术性尖峰的一部分，向我们展示了如何累积由庄家明牌索引的结果列表：
- en: '[PRE254]'
  id: totrans-1593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Each value of `outcomes[rank]` will be a list of simulated payouts. We can average
    or total these to summarize the payouts. We can count wins versus losses or perform
    other quantitative analysis to determine a strategy for play that minimizes losses
    and maximizes wins.
  id: totrans-1594
  prefs: []
  type: TYPE_NORMAL
  zh: '`outcomes[rank]`的每个值将是模拟支付的列表。我们可以对这些进行平均或总结，以总结支付。我们可以计算赢得与损失的次数，或执行其他定量分析，以确定最小化损失和最大化赢利的游戏策略。'
- en: In some cases, we might want to use a `defaultdict` collection class to provide
    a constant value. Instead of writing `container.get(key,"N/A")`, we'd like to
    write `container[key]` and have the string constant provided the value `"N/A"`
    if the key was not found. The difficulty with doing this is that a `defaultdict`
    class is created with a zero-argument function to create the default values. We
    can't use a constant trivially.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望使用`defaultdict`集合类来提供一个常量值。我们希望写`container[key]`而不是写`container.get(key,"N/A")`，如果找不到键，则提供字符串常量值`"N/A"`。这样做的困难在于，`defaultdict`类是使用零参数函数创建默认值的。我们不能轻易使用一个常量。
- en: 'We can create a zero-argument `lambda` object. This works very nicely. Here''s
    an example:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个零参数的`lambda`对象。这非常好用。下面是一个例子：
- en: '[PRE255]'
  id: totrans-1597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'The default value is returned, and the key (in this example, `''other''`) is
    added to the dictionary. We can determine how many new values were entered by
    looking for all the keys that have a value of `"N/A"`:'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值被返回，并且键（在这个例子中是`'other'`）被添加到字典中。我们可以通过查找所有值为`"N/A"`的键来确定输入了多少个新值：
- en: '[PRE256]'
  id: totrans-1599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: As you see in the preceding output, we found the key that was assigned the default
    value of `"N/A"`. This is often a helpful summary of the data that is being accumulated.
    It shows us all of the keys associated with the default value.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前面的输出中看到的，我们找到了被分配默认值`"N/A"`的键。这通常是正在累积的数据的一个有用的摘要。它向我们展示了所有与默认值相关联的键。
- en: The counter collection
  id: totrans-1601
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计数集合
- en: 'One of the most common use cases for a `defaultdict` class is when accumulating
    counts of events. We might write code that looks like this:'
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: '`defaultdict`类最常见的用例之一是在累积事件计数时。我们可能会编写类似这样的代码：'
- en: '[PRE257]'
  id: totrans-1603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: We're counting the number of times each key value, `k`, appears in the sequence
    of values from `some_iterator()`.
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在计算每个键值`k`在`some_iterator()`值序列中出现的次数。
- en: This use case is so common that there's a variation on the `defaultdict` theme
    that performs the same operation shown in the preceding code—it's called `Counter`.
    A `Counter` collection, however, is considerably more sophisticated than a simple
    `defaultdict` class. Consider the additional use case of determining the most
    common value, known to statisticians as the **mode**.
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用例是如此常见，以至于`defaultdict`主题有一个变体执行与前面代码中显示的相同操作的`Counter`。然而，`Counter`集合比简单的`defaultdict`类要复杂得多。考虑确定最常见值的附加用例，统计学家称之为**模式**。
- en: 'We need to restructure the values in the `defaultdict` object to find the mode.
    It''s not difficult, but it can be irksome because it''s a boilerplate code. It
    looks like this:'
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重新构造`defaultdict`对象中的值以找到模式。这并不困难，但可能会让人恼火，因为这是一个样板代码。它看起来像这样：
- en: '[PRE258]'
  id: totrans-1607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: We created a second dictionary. The keys for this new `by_value` dictionary
    are the frequency values. Each key is associated with all of the original `some_iterator()`
    values that occurred with this frequency.
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了第二个字典。这个新的`by_value`字典的键是频率值。每个键与出现此频率的所有原始`some_iterator()`值相关联。
- en: 'We can then use the following processing to locate and display the most common
    values in the order of frequency of the occurrence:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用以下处理来定位并按出现频率的顺序显示最常见的值：
- en: '[PRE259]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: This will create a kind of frequency histogram that shows us the list of key
    values with a given frequency and the frequency count shared by all those key
    values.
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一种频率直方图，显示具有给定频率的键值列表和所有这些键值共享的频率计数。
- en: 'All of these features are already a part of the `Counter` collection. Here''s
    an example to create a frequency histogram from some source of data:'
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些特性已经是`Counter`集合的一部分。下面是一个例子，从某些数据源创建一个频率直方图：
- en: '[PRE260]'
  id: totrans-1613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: This example shows us how we can easily gather statistical data by providing
    any iterable item to `Counter`. It will gather frequency data on the values in
    that iterable item. In this case, we provided an iterable function named `some_iterator()`.
    We might have provided a sequence or some other collection.
  id: totrans-1614
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了如何通过向`Counter`提供任何可迭代的项目来轻松收集统计数据。它将收集该可迭代项目中值的频率数据。在这种情况下，我们提供了一个名为`some_iterator()`的可迭代函数。我们可能提供了一个序列或其他集合。
- en: We can then display the results in the descending order of popularity. But wait!
    That's *not* all.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以按照受欢迎程度的降序显示结果。但等等！这还不是全部。
- en: The `Counter` collection is not merely a simplistic variation of the `defaultdict`
    collection. The name is misleading. A `Counter` object is actually a "multiset",
    sometimes called a "bag".
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: '`Counter`集合不仅仅是`defaultdict`集合的简单变体。这个名字是误导的。`Counter`对象实际上是一个"多重集"，有时被称为"袋子"。'
- en: It's a collection that is set-like, but allows for repeats of values in the
    bag. It is not a sequence with items identified by an index or position; order
    doesn't matter. It is not a mapping with keys and values. It is like a set in
    which items stand for themselves and order doesn't matter. But it is unlike a
    set because, in this case, elements can repeat.
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个类似集合的集合，但允许袋子中的值重复。它不是一个由索引或位置标识的序列；顺序并不重要。它不是一个具有键和值的映射。它就像一个集合，其中的项代表它们自己，顺序并不重要。但它不像一个集合，因为在这种情况下，元素可以重复。
- en: As elements can repeat, the `Counter` object represents multiple occurrences
    with an integer count. Hence, it's used as a frequency table. However, it does
    more than this. As a bag is like a set, we can compare the elements of two bags
    to create a union or an intersection.
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 由于元素可以重复，`Counter`对象用整数计数表示多次出现。因此，它被用作频率表。但它不仅仅是这样。由于一个袋子就像一个集合，我们可以比较两个袋子的元素来创建一个并集或交集。
- en: 'Let''s create two bags:'
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建两个袋子：
- en: '[PRE261]'
  id: totrans-1620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: We built each bag by examining a sequence of letters. For characters that occur
    more than once, there's a count that is more than one.
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查一系列字母来构建每个袋子。对于出现多次的字符，有一个大于一的计数。
- en: 'We can easily compute the union of the two bags:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地计算两个袋子的并集：
- en: '[PRE262]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: This shows us the entire suite of letters between the two strings. There were
    three instances of `o`. Not surprisingly, other letters were less popular.
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 这向我们展示了两个字符串之间的整套字母。`o`有三个实例。毫不奇怪，其他字母不那么受欢迎。
- en: 'We can just as easily compute the difference between the bags:'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以轻松地计算两个袋子之间的差异：
- en: '[PRE263]'
  id: totrans-1626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: The first expression shows us characters in `bag1` that were not in `bag2`.
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表达式向我们展示了`bag1`中不在`bag2`中的字符。
- en: The second expression shows us characters in `bag2` that were not in `bag1`.
    Note that the letter `o` occurred twice in `bag2` and once in `bag1`. The difference
    only removed one of the `o` characters from `bag1`.
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个表达式向我们展示了`bag2`中不在`bag1`中的字符。请注意，字母`o`在`bag2`中出现了两次，在`bag1`中出现了一次。差异只移除了`bag1`中的一个`o`字符。
- en: Creating new kinds of collections
  id: totrans-1629
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新类型的集合
- en: We'll look at some extensions we might make to Python's built-in container classes.
    Although, we won't show an example of extending each container. If we did, the
    book would become out of control in size.
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一下我们可能对Python内置容器类进行的一些扩展。尽管我们不会展示扩展每个容器的例子。如果这样做，这本书的大小将变得不可控。
- en: 'We''ll pick an example of extending a specific container and see how the process
    works:'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择一个扩展特定容器的例子，并看看这个过程是如何工作的：
- en: 'Define the requirements. This may include research on Wikipedia, generally
    starting here: [http://en.wikipedia.org/wiki/Data_structure](http://en.wikipedia.org/wiki/Data_structure).
    Designs of data structures can be complex because there are often complex edge
    cases.'
  id: totrans-1632
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义需求。这可能包括在维基百科上进行研究，通常从这里开始：[http://en.wikipedia.org/wiki/Data_structure](http://en.wikipedia.org/wiki/Data_structure)。数据结构的设计可能会很复杂，因为通常存在复杂的边缘情况。
- en: If necessary, look at the `collections.abc` module to see what methods must
    be implemented to create the new functionality.
  id: totrans-1633
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果必要，查看`collections.abc`模块，看看必须实现哪些方法来创建新的功能。
- en: Create some test cases. This also requires careful study of the algorithms to
    ensure that the edge cases are properly covered.
  id: totrans-1634
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一些测试案例。这也需要仔细研究算法，以确保边缘情况得到适当的覆盖。
- en: Code.
  id: totrans-1635
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码。
- en: We need to emphasize the importance of researching the fundamentals before trying
    to invent a new kind of data structure. In addition to searching the Web for overviews
    and summaries, details will be necessary. See *Introduction to Algorithms* by
    Cormen, Leiserson, Rivest, and Stein or *Data Structures and Algorithms* by Aho,
    Ullman, and Hopcroft, or *The Algorithm Design Manual* by Steven Skiena.
  id: totrans-1636
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要强调在尝试发明新类型的数据结构之前，研究基础知识的重要性。除了搜索网络上的概述和摘要外，还需要详细信息。参见Cormen、Leiserson、Rivest和Stein的《算法导论》，或Aho、Ullman和Hopcroft的《数据结构与算法》，或Steven
    Skiena的《算法设计手册》。
- en: 'As we saw earlier, the ABCs define three broad kinds of collections: sequences,
    mappings, and sets. We have three design strategies that we can use to create
    new kinds of collections of our own:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，ABCs定义了三种广义的集合：序列、映射和集合。我们有三种设计策略可以用来创建我们自己的新类型的集合：
- en: '**Extend**: This is an existing sequence.'
  id: totrans-1638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展**：这是一个现有的序列。'
- en: '**Wrap**: This is an existing sequence.'
  id: totrans-1639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包装**：这是一个现有的序列。'
- en: '**Invent**: This is a new sequence from scratch.'
  id: totrans-1640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发明**：这是一个全新的序列。'
- en: In principle, we could give as many as nine examples—each basic flavor of collection
    with each basic design strategy. We won't beat this subject to death like that.
    We'll dig deep to create new kinds of sequences, learning how to extend and wrap
    existing sequences.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们可以给出多达九个例子——每种基本类型的集合与每种基本设计策略。我们不会像那样过分强调这个主题。我们将深入研究如何创建新类型的序列，学习如何扩展和包装现有序列。
- en: As there are so many extended mappings (such as `ChainMap`, `OrderedDict`, `defaultdict`,
    and `Counter`), we'll only touch lightly on creating new kinds of mappings. We'll
    also dig deep to create a new kind of ordered multiset or bag.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有许多扩展映射（如`ChainMap`、`OrderedDict`、`defaultdict`和`Counter`），我们只会轻轻地涉及创建新类型的映射。我们还将深入研究创建一种新类型的有序多重集或袋子。
- en: Defining a new kind of sequence
  id: totrans-1643
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一种新类型的序列
- en: A common requirement that we have when performing statistical analysis is to
    compute basic means, modes, and standard deviations on a collection of data. Our
    blackjack simulation will produce outcomes that must be analyzed statistically
    to see if we have actually invented a better strategy.
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: 进行统计分析时的一个常见要求是对一组数据进行基本均值、众数和标准偏差的计算。我们的二十一点模拟将产生必须进行统计分析的结果，以查看我们是否真的发明了更好的策略。
- en: When we simulate a playing strategy, we should wind up with some outcome data
    that will be a sequence of numbers that show us the final result of playing a
    sequence of hands with a given strategy. The rate of play varies from about 50
    hands per hour at a crowded table to 200 hands per hour if one is alone with the
    dealer. We'll assume 200 hands as two hours of blackjack before having to take
    a biology break.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们模拟一种玩牌策略时，我们应该得到一些结果数据，这些数据将是一系列数字，显示了使用给定策略玩一系列手牌的最终结果。游戏速度从拥挤的桌子上每小时50手到独自与庄家时每小时200手不等。我们将假设200手相当于二小时的二十一点，然后需要休息一下。
- en: 'We could accumulate the outcomes into a built-in `list` class. We can compute
    the mean via ![Defining a new kind of sequence](graphics/0971OS_06_01.jpg), where
    N is the number of elements in *x*:'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将结果累积到内置的`list`类中。我们可以通过![定义一种新类型的序列](graphics/0971OS_06_01.jpg)来计算均值，其中N是*x*中的元素数：
- en: '[PRE264]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'Standard deviation can be computed via ![Defining a new kind of sequence](graphics/0971OS_06_02.jpg):'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 标准偏差可以通过![定义一种新类型的序列](graphics/0971OS_06_02.jpg)来计算：
- en: '[PRE265]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Both of these are relatively simple calculation functions that are easy to use.
    As things get more complex, however, loose functions like these become less helpful.
    One of the benefits of object-oriented programming is to bind the functionality
    with the data.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个都是相对简单的计算函数，易于使用。然而，随着事情变得更加复杂，这些松散的函数变得不那么有用。面向对象编程的好处之一是将功能与数据绑定在一起。
- en: Our first example will not involve rewriting any of the special methods of `list`.
    We'll simply subclass `list` to add methods that will compute the statistics.
    This is a very common kind of extension.
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个示例不涉及重写`list`的任何特殊方法。我们只需对`list`进行子类化，以添加将计算统计信息的方法。这是一种非常常见的扩展。
- en: We'll revisit this in the second example so that we can revise and extend the
    special methods. This will require some study of the ABC special methods to see
    what we need to add or modify so that our new list subclass properly inherits
    all the features of the built-in `list` class.
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第二个示例中重新审视这一点，以便我们可以修改和扩展特殊方法。这将需要对ABC特殊方法进行一些研究，以查看我们需要添加或修改什么，以便我们的新列表子类正确继承内置的`list`类的所有特性。
- en: Because we're looking at sequences, we also have to wrestle with the Python
    `slice` notation. We'll look at what a slice is and how it works internally in
    the Working with `__getitem__`, `__setitem__`, `__delitem__`, and slices section.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们正在研究序列，所以我们还必须处理Python的`slice`表示法。我们将在*使用`__getitem__`、`__setitem__`、`__delitem__`和切片*部分中查看切片是什么以及它是如何在内部工作的。
- en: The second important design strategy is wrapping. We'll create a wrapper around
    a list and see how we might delegate methods to the wrapped list. Wrapping has
    some advantages when it comes to object persistence, which is the subject of [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*.
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要的设计策略是包装。我们将在列表周围创建一个包装器，并看看如何将方法委托给包装的列表。在对象持久性方面，包装具有一些优势，这是[第9章](ch09.html
    "第9章。序列化和保存–JSON、YAML、Pickle、CSV和XML")的主题，*序列化和保存–JSON、YAML、Pickle、CSV和XML*。
- en: We can also look at the kind of things that need to be done to invent a new
    kind of sequence from scratch.
  id: totrans-1655
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看看需要从头开始发明新类型序列的事情。
- en: A statistical list
  id: totrans-1656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 统计列表
- en: 'It makes good sense to incorporate mean and standard deviation features directly
    into a subclass of `list`. We can extend `list` like this:'
  id: totrans-1657
  prefs: []
  type: TYPE_NORMAL
  zh: 将均值和标准偏差特性直接合并到`list`的子类中是很有意义的。我们可以这样扩展`list`：
- en: '[PRE266]'
  id: totrans-1658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: With this simple extension to the built-in `list` class, we can accumulate data
    and report statistics with relative ease.
  id: totrans-1659
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对内置的`list`类进行这种简单扩展，我们可以相对轻松地累积数据并报告统计信息。
- en: We can imagine an overall simulation script that looks like this.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个整体的模拟脚本，看起来像这样。
- en: '[PRE267]'
  id: totrans-1661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Choosing eager versus lazy calculation
  id: totrans-1662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择急切计算与懒惰计算
- en: Note that our calculations are lazy; they are only done when requested. This
    also means that they're performed each and every time they're requested. This
    can be a considerable overhead, depending on the context in which objects of these
    classes are used.
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的计算是懒惰的；它们只在被请求时才执行。这也意味着每次请求时都会执行它们。这可能是一个相当大的开销，取决于这些类的对象在哪种上下文中使用。
- en: It's actually sensible to transform these statistical summaries into eager calculations,
    as we know when elements are added and removed from a list. Although there's a
    hair more programming to create eager versions of these functions, it has a net
    impact of improving performance when there's a lot of data being accumulated.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些统计摘要转换为急切计算实际上是明智的，因为我们知道何时从列表中添加和删除元素。尽管需要更多的编程来创建这些函数的急切版本，但在累积大量数据时，它会提高性能。
- en: The point of eager statistical calculations is to avoid the loops that compute
    sums. If we compute the sums eagerly, as the list is being created, we avoid extra
    looping through the data.
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 急切统计计算的重点是避免计算总和的循环。如果我们急切地计算总和，那么在创建列表时，我们就避免了对数据的额外循环。
- en: When we look at the special methods for a `Sequence` class, we can see all of
    the places where data is added to, removed from, and modified in the sequence.
    We can use this information to recompute the two sums that are involved. We start
    with the `collections.abc` section of the *Python Standard Library* documentation,
    section 8.4.1 at [http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes](http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes).
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看`Sequence`类的特殊方法时，我们可以看到数据被添加到、从序列中移除和修改的所有地方。我们可以使用这些信息来重新计算所涉及的两个总和。我们从*Python标准库*文档的`collections.abc`部分开始，8.4.1节在[http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes](http://docs.python.org/3.4/library/collections.abc.html#collections-abstract-base-classes)。
- en: 'Here are the required methods for a `MutableSequence` class: `__getitem__`,
    `__setitem__`, `__delitem__`, `__len__`, `insert`, `append`, `reverse`, `extend`,
    `pop`, `remove`, and `__iadd__`. The documentation also mentions the **Inherited
    Sequence methods**. However, as those are for immutable sequences, we can certainly
    ignore them.'
  id: totrans-1667
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是`MutableSequence`类所需的方法：`__getitem__`、`__setitem__`、`__delitem__`、`__len__`、`insert`、`append`、`reverse`、`extend`、`pop`、`remove`和`__iadd__`。文档还提到了**继承的序列方法**。但是，由于这些方法适用于不可变序列，我们当然可以忽略它们。
- en: 'Here are the details of what must be done for each method:'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每种方法必须完成的详细信息：
- en: '`__getitem__`: Nothing, as there''s no change in the state.'
  id: totrans-1669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__getitem__`：没有任何变化，因为状态没有改变。'
- en: '`__setitem__`: This changes an item. We need to take the old item out of each
    sum and fold the new item into each sum.'
  id: totrans-1670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__setitem__`：这会改变一个项目。我们需要从每个总和中取出旧项目，并将新项目折叠到每个总和中。'
- en: '`__delitem__`: This removes an item. We need to take the old item out of each
    sum.'
  id: totrans-1671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delitem__`：这会移除一个项目。我们需要从每个总和中取出旧项目。'
- en: '`__len__`: Nothing here either, as there''s no change in the state.'
  id: totrans-1672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__len__`：这里也没有任何变化，因为状态没有改变。'
- en: '`insert`: As this adds a new item, we need to fold it into each sum.'
  id: totrans-1673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`insert`：由于这会添加一个新项目，我们需要将其折叠到每个总和中。'
- en: '`append`: As this also adds a new item, we need to fold it into each sum.'
  id: totrans-1674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`append`：由于这也添加了一个新项目，我们需要将其折叠到每个总和中。'
- en: '`reverse`: Nothing here either, as there''s no change in the state of the mean
    or standard deviation.'
  id: totrans-1675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reverse`：这里也没有任何变化，因为均值或标准偏差的状态没有改变。'
- en: '`extend`: This adds many new items such as `__init__`, for which we''ll need
    to process each item before extending the list.'
  id: totrans-1676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extend`：这会添加许多新项目，例如`__init__`，因此我们需要在扩展列表之前处理每个项目。'
- en: '`pop`: This removes an item. We need to take the old item out of each sum.'
  id: totrans-1677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pop`：这将移除一个项目。我们需要从每个总和中取出旧项目。'
- en: '`remove`: This also removes an item. We need to take the old item out of each
    sum.'
  id: totrans-1678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove`：这也移除一个项目。我们需要从每个总和中取出旧项目。'
- en: '`__iadd__`: This is the `+=` augmented assignment statement, the in-place addition.
    It''s effectively the same as the `extend` keyword.'
  id: totrans-1679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__iadd__`：这是`+=`增强赋值语句，就地加法。它实际上与`extend`关键字相同。'
- en: 'We won''t look at each method in detail, because there are really only two
    use cases:'
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细查看每个方法，因为实际上只有两种用例：
- en: Fold in one new value
  id: totrans-1681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 折叠一个新值
- en: Remove one old value
  id: totrans-1682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移除一个旧值
- en: The replacement case is a combination of the remove and fold in operations.
  id: totrans-1683
  prefs: []
  type: TYPE_NORMAL
  zh: 替换情况是移除和折叠操作的组合。
- en: 'Here are the elements of an eager `StatsList` class. We''re going to see just
    `insert` and `pop`:'
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个急切`StatsList`类的元素。我们将只看到`insert`和`pop`：
- en: '[PRE268]'
  id: totrans-1685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: We provided three internal variables with quick comments to show the invariants
    that this class will maintain them. We'll call these the "sum invariants" because
    each of them contains a particular kind of sum that is maintained as invariant
    (always true) after each kind of state change. The essence of this eager calculation
    are the `_rmv()` and `_new()` methods, which update our three internal sums based
    on changes to the list, so that the relationships really remain invariant.
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了三个内部变量，并附上快速注释，以显示这个类将维护它们的不变性。我们将这些称为“总和不变性”，因为它们每个都包含一种特定类型的总和，在每种状态变化后都保持不变（始终为真）。这种急切计算的本质是`_rmv()`和`_new()`方法，它们根据列表的变化更新我们的三个内部总和，以确保关系真正保持不变。
- en: When we remove an item, that is, after a successful `pop()` operation, we have
    to adjust our sums. When we add an item (either initially, or via the `insert()`
    method), we also have to adjust our sums. The other methods we need to implement
    will make use of these two methods to ensure that the three sum invariants hold.
    We assure that L.sum0 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_03.jpg),
    sum1 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_04.jpg),
    and sum2 is always ![Choosing eager versus lazy calculation](graphics/0971OS_06_05.jpg).
  id: totrans-1687
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移除一个项目，也就是在成功的`pop()`操作之后，我们必须调整我们的总和。当我们添加一个项目（初始时或通过`insert()`方法），我们也必须调整我们的总和。我们需要实现的其他方法将利用这两种方法来确保这三个总和不变。我们保证L.sum0总是![选择急切与懒惰的计算](graphics/0971OS_06_03.jpg)，sum1总是![选择急切与懒惰的计算](graphics/0971OS_06_04.jpg)，sum2总是![选择急切与懒惰的计算](graphics/0971OS_06_05.jpg)。
- en: Other methods such as `append()`, `extend()`, and `remove()`, are similar in
    many ways to these methods. We didn't show them because they're similar.
  id: totrans-1688
  prefs: []
  type: TYPE_NORMAL
  zh: 其他方法，如`append()`，`extend()`和`remove()`，在许多方面与这些方法类似。我们没有展示它们，因为它们很相似。
- en: 'There''s an important bit missing: individual item replacement via `list[index]=
    value`. We''ll delve into it in the following paragraph.'
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个重要的部分缺失：通过`list[index]= value`进行单个项目替换。我们将在下一段深入讨论。
- en: 'We can see how this list works by playing with some data:'
  id: totrans-1690
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过处理一些数据来看看这个列表是如何工作的：
- en: '[PRE269]'
  id: totrans-1691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: We can create a list and the sums are computed initially. Each subsequent change
    eagerly updates the various sums. We can change, remove, insert, and pop an item;
    each change results in a new set of sums.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个列表，并且初始计算出总和。每个后续的变化都会急切地更新各种总和。我们可以更改、移除、插入和弹出一个项目；每个变化都会产生一组新的总和。
- en: 'All that''s left is to add our mean and standard deviation calculations, which
    we can do as follows:'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是添加我们的均值和标准差计算，我们可以这样做：
- en: '[PRE270]'
  id: totrans-1694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: These make use of the sums already computed. There's no additional looping over
    the data to compute these two statistics.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 这些利用了已经计算的总和。没有额外的循环来计算这两个统计数据。
- en: Working with __getitem__(), __setitem__(), __delitem__(), and slices
  id: totrans-1696
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用__getitem__()，__setitem__()，__delitem__()和切片
- en: The `StatsList2` example didn't show us the implementation of `__setitem__()`
    or `__delitem__()` because they involve slices. We'll need to look at the implementation
    of a slice before we can implement these methods properly.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatsList2`示例没有显示`__setitem__()`或`__delitem__()`的实现，因为它们涉及切片。在实现这些方法之前，我们需要查看切片的实现。'
- en: 'Sequences have two different kinds of indexes:'
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 序列有两种不同的索引：
- en: '`a[i]`: This is a simple Integer index.'
  id: totrans-1699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a[i]`：这是一个简单的整数索引。'
- en: '`a[i:j]` or `a[i:j:k]`: These are `slice` expressions with `start:stop:step`
    values. Slice expressions can be quite complex with seven different variations
    for different kinds of defaults.'
  id: totrans-1700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`a[i:j]`或`a[i:j:k]`：这些是带有`start:stop:step`值的`slice`表达式。切片表达式可以非常复杂，有七种不同的变体，适用于不同种类的默认值。'
- en: 'This basic syntax works in three contexts:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基本的语法在三个上下文中都适用：
- en: In an expression, relying on `__getitem__()` to get a value
  id: totrans-1702
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个表达式中，依赖于`__getitem__()`来获取一个值
- en: On the left-hand side of assignment, relying on `__setitem__()` to set a value
  id: totrans-1703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赋值的左侧，依赖于`__setitem__()`来设置一个值
- en: On a `del` statement, relying on `__delitem__()` to delete a value
  id: totrans-1704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`del`语句上，依赖于`__delitem__()`来删除一个值
- en: When we do something like `seq[:-1]`, we write a `slice` expression. The underlying
    `__getitem__()` method will be given a `slice` object instead of a simple integer.
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们做类似`seq[:-1]`的操作时，我们写了一个`slice`表达式。底层的`__getitem__()`方法将得到一个`slice`对象，而不是一个简单的整数。
- en: 'The reference manual tells us a few things about slices. A `slice` object will
    have three attributes: `start`, `stop`, and `step`. It will also have a method
    function called `indices()`, which will properly compute any omitted attribute
    values for a slice.'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: 参考手册告诉我们一些关于切片的事情。一个`slice`对象将有三个属性：`start`，`stop`和`step`。它还将有一个名为`indices()`的方法函数，它将正确计算切片的任何省略的属性值。
- en: 'We can explore the `slice` objects with a trivial class that extends `list`:'
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个扩展`list`的微不足道的类来探索`slice`对象：
- en: '[PRE271]'
  id: totrans-1708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: This class will dump the `slice` object and the value of the `indices()` function
    result. Then, use the superclass implementation so that the list behaves normally
    otherwise.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将输出`slice`对象和`indices()`函数结果的值。然后，使用超类实现，以便列表在其他方面表现正常。
- en: 'Given this class, we can try different `slice` expressions to see what we get:'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个类，我们可以尝试不同的`slice`表达式，看看我们得到了什么：
- en: '[PRE272]'
  id: totrans-1711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: In the preceding `slice` expressions, we can see that a `slice` object has three
    attributes, and the values for those attributes come directly from the Python
    syntax. When we provide the proper length to the `indices()` function, it returns
    a three-tuple value with start, stop, and step values.
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述的`slice`表达式中，我们可以看到`slice`对象有三个属性，这些属性的值直接来自Python语法。当我们向`indices()`函数提供适当的长度时，它会返回一个包含开始、停止和步长值的三元组值。
- en: Implementing __getitem__(), __setitem__(), and __delitem__()
  id: totrans-1713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现__getitem__()，__setitem__()和__delitem__()
- en: 'When we implement the methods `__getitem__()`, `__setitem__()` and `__delitem__()`,
    we must work with two kinds of argument values: `int` and `slice`.'
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现`__getitem__()`、`__setitem__()`和`__delitem__()`方法时，我们必须处理两种类型的参数值：`int`和`slice`。
- en: When we overload the various sequence methods, we must handle the slice situation
    appropriately.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们重载各种序列方法时，必须适当处理切片情况。
- en: 'Here is a `__setitem__()` method that works with slices:'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个与切片一起使用的`__setitem__()`方法：
- en: '[PRE273]'
  id: totrans-1717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'The preceding method has two processing paths:'
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法有两种处理路径：
- en: If the index is a `slice` object, we'll compute the `start`, `stop`, and `step`
    values. Then, locate all the old values that will be removed. We can then invoke
    the superclass operation and fold in the new values that replaced the old values.
  id: totrans-1719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引是一个`slice`对象，我们将计算`start`、`stop`和`step`值。然后，找到将被移除的所有旧值。然后，我们可以调用超类操作，并合并替换旧值的新值。
- en: If the index is a simple `int` object, the old value is a single item, and the
    new value is a single item, similarly.
  id: totrans-1720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果索引是一个简单的`int`对象，旧值是一个单个项目，新值也是一个单个项目。
- en: 'Here''s the `__delitem__()` method that works with slices:'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与切片一起使用的`__delitem__()`方法：
- en: '[PRE274]'
  id: totrans-1722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: The preceding code, too, expands the slice to determine what values could be
    removed. If the index is a simple integer, then just one value is removed.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码也扩展了切片，以确定可以删除哪些值。如果索引是一个简单的整数，那么就只删除一个值。
- en: When we introduce proper slice processing to our `StatsList2` class, we can
    create lists that do everything the base `list` class does and also (rapidly)
    returns mean and standard deviation for the values that are currently in the list.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向我们的`StatsList2`类引入适当的切片处理时，我们可以创建列表，它可以做到基本的`list`类所做的一切，还可以（快速）返回当前列表中的平均值和标准差。
- en: Note
  id: totrans-1725
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that these method functions will each create a temporary list object, `olds`;
    this involves some overhead that can be removed. As an exercise for the reader,
    it's helpful to move the `_rmv()` functions forward in these methods to eliminate
    the use of the `olds` variable.
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些方法函数将分别创建一个临时列表对象`olds`；这涉及一些开销，可以消除。作为读者的练习，将`_rmv()`函数前移这些方法，以消除对`olds`变量的使用，这是有帮助的。
- en: Wrapping a list and delegating
  id: totrans-1727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包装列表和委托
- en: We'll look at how we might wrap one of Python's built-in container classes.
    Wrapping an existing class means that some methods will have to be delegated to
    the underlying container.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何包装Python的内置容器类之一。包装现有类意味着一些方法必须委托给底层容器。
- en: As there are a large number of methods in any of the built-in collections, wrapping
    a collection may require a fair amount of code. When it comes to creating persistent
    classes, wrapping has advantages over extending. That's the subject of [Chapter
    9](ch09.html "Chapter 9. Serializing and Saving – JSON, YAML, Pickle, CSV, and
    XML"), *Serializing and Saving – JSON, YAML, Pickle, CSV, and XML*. In some cases,
    we'll want to expose the internal collection to save writing a large number of
    sequence methods that delegate to an internal list.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任何内置集合中都有大量方法，包装集合可能需要相当多的代码。在创建持久类时，包装比扩展具有优势。这是[第9章](ch09.html "第9章。序列化和保存
    - JSON、YAML、Pickle、CSV和XML")的主题，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*。在某些情况下，我们希望公开内部集合，以避免编写大量委托给内部列表的序列方法。
- en: A common restriction that applies to statistics data classes is that they need
    to be "insert only." We'll be disabling a number of method functions. This is
    the kind of dramatic change that requires a wrapper.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: 统计数据类的一个常见限制是它们需要是“仅插入”的。我们将禁用一些方法函数。这是一种需要包装的重大变化。
- en: 'We can design a class that supports only `append` and `__getitem__`, for example.
    It would wrap a `list` class. The following code can be used to accumulate data
    from simulations:'
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以设计一个仅支持`append`和`__getitem__`的类，例如。它将包装一个`list`类。以下代码可用于从模拟中累积数据：
- en: '[PRE275]'
  id: totrans-1732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: This class has an internal `_list` object that is the underlying list. The list
    is always initially empty. As we've only defined `append()` as a way to update
    the list, we can maintain the various sums easily. We need to be careful to delegate
    the work to the superclass to be sure that the list is actually updated before
    our subclass processes the argument value.
  id: totrans-1733
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有一个内部的`_list`对象，是底层列表。列表始终最初为空。由于我们只定义了`append()`作为更新列表的方法，我们可以轻松地维护各种和。我们需要小心地将工作委托给超类，以确保列表在我们的子类处理参数值之前实际更新。
- en: We can directly delegate `__getitem__()` to the internal list object without
    examining the arguments or the results.
  id: totrans-1734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接将`__getitem__()`委托给内部列表对象，而不检查参数或结果。
- en: 'We can use this class as follows:'
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样使用这个类：
- en: '[PRE276]'
  id: totrans-1736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: We created an empty list and appended items to the list. As we maintain the
    sums as items are appended, we can compute the mean and standard deviation extremely
    quickly.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个空列表，并向列表中添加了项目。由于我们在添加项目时保持和，我们可以非常快速地计算平均值和标准差。
- en: We didn't intentionally make our class iterable. We didn't define `__iter__()`.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并没有有意使我们的类可迭代。我们没有定义`__iter__()`。
- en: Because we've defined `__getitem__()`, several things now work. Not only can
    we get items, but it also turns out that there will be a default implementation
    that allows us to iterate through the sequence of values.
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们定义了`__getitem__()`，现在有几件事可以做。我们不仅可以获取项目，而且还会有一个默认实现，允许我们遍历值序列。
- en: 'Here''s an example:'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE277]'
  id: totrans-1741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: The preceding output shows us that a minimal wrapper around a collection is
    often enough to satisfy many use cases.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出告诉我们，一个围绕集合的最小包装通常足以满足许多用例。
- en: 'Note that we didn''t, for example, make the list sizeable. If we attempt to
    get the size, it will raise an exception, as shown in the following:'
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们没有使列表可伸缩。如果我们尝试获取大小，它将引发异常，如下所示：
- en: '[PRE278]'
  id: totrans-1744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: We might want to add a `__len__()` method that delegates the real work to the
    internal `_list` object. We might also want to set `__hash__` to `None`, which
    would be prudent as this is a mutable object.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要添加一个`__len__()`方法，将真正的工作委托给内部的`_list`对象。我们可能还想将`__hash__`设置为`None`，因为这是一个可变对象，这是明智的。
- en: We might want to define `__contains__()` and delegate this feature to the internal
    `_list` too. This will create a minimalist container that offers the low-level
    feature set of a container.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要定义`__contains__()`并将此功能委托给内部的`_list`。这将创建一个提供容器的低级特性集的极简主义容器。
- en: Creating iterators with __iter__()
  id: totrans-1747
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`__iter__()`创建迭代器
- en: When our design involves wrapping an existing class, we'll need to be sure our
    class is iterable. When we look at the documentation for `collections.abc.Iterable`,
    we see that we only need to define `__iter__()` to make an object iterable. The
    `__iter__()` method can either return a proper `Iterator` object, or it can be
    a generator function.
  id: totrans-1748
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的设计涉及包装现有类时，我们需要确保我们的类是可迭代的。当我们查看`collections.abc.Iterable`的文档时，我们看到我们只需要定义`__iter__()`来使对象可迭代。`__iter__()`方法可以返回一个适当的`Iterator`对象，也可以是一个生成器函数。
- en: Creating an `Iterator` object, while not terribly complex, is rarely necessary.
    It's so much simpler to create generator functions. For a wrapped collection,
    we should always simply delegate the `__iter__()` method to the underlying collection.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个`Iterator`对象，虽然并不是非常复杂，但很少是必要的。创建生成器函数要简单得多。对于包装的集合，我们应该总是简单地将`__iter__()`方法委托给底层集合。
- en: 'For our `StatsList3` class, it would look like this:'
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`StatsList3`类，它看起来像这样：
- en: '[PRE279]'
  id: totrans-1751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: This method function would delegate the iteration to the underlying list's `Iterator`.
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法函数将迭代委托给底层列表的`Iterator`。
- en: Creating a new kind of mapping
  id: totrans-1753
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一种新的映射
- en: Python has a built-in mapping called `dict`, and numerous library mappings.
    In addition to the `collections` module extensions to `dict` (`defaultdict`, `Counter`,
    `OrderedDict`, and `ChainMap`), there are several other library modules that contain
    mapping-like structures.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一个名为`dict`的内置映射，以及许多库映射。除了`collections`模块对`dict`的扩展（`defaultdict`、`Counter`、`OrderedDict`和`ChainMap`）之外，还有几个其他库模块包含类似映射的结构。
- en: The `shelve` module is an important example of another mapping. We'll look at
    this in [Chapter 10](ch10.html "Chapter 10. Storing and Retrieving Objects via
    Shelve"), *Storing and Retrieving Objects via Shelve*. The `dbm` module is similar
    to `shelve`, in that it also maps a key to a value.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: '`shelve`模块是另一个映射的重要示例。我们将在[第10章](ch10.html "第10章。通过Shelve存储和检索对象")中查看这一点，*通过Shelve存储和检索对象*。`dbm`模块类似于`shelve`，它也将键映射到值。'
- en: The `mailbox` module and `email.message` modules both have classes that provide
    an interface that is similar to `dict` for the mailbox structure used to manage
    local e-mails.
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '`mailbox`模块和`email.message`模块都有提供类似于`dict`的接口的类，用于管理本地电子邮件的邮箱结构。'
- en: As far as design strategies go, we can extend or wrap one of the existing mappings
    to add even more features.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 就设计策略而言，我们可以扩展或包装现有的映射，以添加更多功能。
- en: We could upgrade `Counter` to add mean and standard deviation to data stored
    as a frequency distribution. Indeed, we can also calculate median and mode very
    easily from this class.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以升级`Counter`，将存储为频率分布的数据添加均值和标准差。事实上，我们还可以很容易地从这个类中计算中位数和众数。
- en: 'Here''s a `StatsCounter` extension to `Counter` that adds some statistical
    functions:'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`StatsCounter`对`Counter`的扩展，添加了一些统计函数：
- en: '[PRE280]'
  id: totrans-1760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: We extended the `Counter` class with two new methods to compute the mean and
    standard deviation from the frequency distributions. The formulae are similar
    to the examples shown earlier for the eager calculations on a `list` object, even
    though they're lazy calculations on a `Counter` object.
  id: totrans-1761
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了`Counter`类，增加了两个新方法，用于计算频率分布的均值和标准差。这些公式与之前在`list`对象上进行的急切计算的示例类似，尽管它们是在`Counter`对象上进行的懒惰计算。
- en: We used `sum0= sum( v for k,v in self.items() )` to compute a sum of the values,
    `v`, ignoring the `k` keys. We could use an underscore (`_`) instead of `k` to
    emphasize that we're ignoring the keys. We could also use `sum( v for v in self.values()
    )` to emphasize that we're not using the keys. We prefer obvious parallel structures
    for `sum0` and `sum1`.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`sum0= sum( v for k,v in self.items() )`来计算值`v`的总和，忽略`k`键。我们可以使用下划线（`_`）代替`k`，以强调我们正在忽略键。我们也可以使用`sum(
    v for v in self.values() )`来强调我们没有使用键。我们更喜欢`sum0`和`sum1`的明显并行结构。
- en: We can use this class to efficiently gather statistics and to perform quantitative
    analysis on the raw data. We might run a number of simulations, using a `Counter`
    object to gather the results.
  id: totrans-1763
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个类来高效地收集统计数据，并对原始数据进行定量分析。我们可以运行多个模拟，使用`Counter`对象来收集结果。
- en: 'Here''s an interaction with a list of sample data that stands in for real results:'
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个与样本数据列表的交互，代表真实结果：
- en: '[PRE281]'
  id: totrans-1765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: The results of `most_common()` are reported as a sequence of two-tuples with
    the mode value (4) and the number of times the value occurred (3). We might want
    to get the top three values to bracket the mode with the next two less-popular
    items. We get several popular values with an evaluation such as `sc.most_common(3)`.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: '`most_common()`的结果报告为两个元组的序列，包括模式值（4）和值出现的次数（3）。我们可能想要获取前三个值，以将模式与下两个不太流行的项进行比较。我们可以通过`sc.most_common(3)`这样的评估来获取几个流行的值。'
- en: The `elements()` method reconstructs a `list` that's like the original data
    with the items repeated properly.
  id: totrans-1767
  prefs: []
  type: TYPE_NORMAL
  zh: '`elements()`方法重建一个像原始数据一样的`list`，其中的项被适当地重复。'
- en: 'From the sorted elements, we can extract the median, the middle-most item:'
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 从排序的元素中，我们可以提取中位数，即中间的项：
- en: '[PRE282]'
  id: totrans-1769
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: This method is not only lazy, it's rather extravagant with memory; it creates
    an entire sequence of the available values merely to find the middle-most item.
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法不仅是懒惰的，而且在内存上非常奢侈；它仅仅为了找到最中间的项就创建了整个可用值的序列。
- en: While it is simple, this is often an expensive way to use Python.
  id: totrans-1771
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单，但这通常是使用Python的一种昂贵的方式。
- en: A smarter approach would be to compute the effective length and mid-point via
    `sum(self.values())//2`. Once this is known, the keys can be visited in that order,
    using the counts to compute the range of positions for a given key. Eventually,
    a key will be found with a range that includes the midpoint.
  id: totrans-1772
  prefs: []
  type: TYPE_NORMAL
  zh: 更聪明的方法是通过`sum(self.values())//2`来计算有效长度和中点。一旦知道了这一点，就可以按照这个顺序访问键，使用计数来计算给定键的位置范围。最终，将找到一个包含中点的范围的键。
- en: 'The code would look something like the following:'
  id: totrans-1773
  prefs: []
  type: TYPE_NORMAL
  zh: 代码看起来像下面这样：
- en: '[PRE283]'
  id: totrans-1774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: We stepped through the keys and the number of times they occur to locate the
    key that is midmost. Note that this uses the internal `sorted()` function, which
    is not without its own cost.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐步遍历键和它们出现的次数，以找到最中间的键。请注意，这使用了内部的`sorted()`函数，这并不是没有成本的。
- en: Via `timeit`, we can learn that the extravagant version takes 9.5 seconds; the
    smarter version takes 5.2 seconds.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`timeit`，我们可以得知奢侈版需要9.5秒；而更聪明的版本只需要5.2秒。
- en: Creating a new kind of set
  id: totrans-1777
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一种新的集合类型
- en: Creating a whole new collection requires some preliminary work. We need to have
    new algorithms or new internal data structures that offer significant improvements
    over the built-in collections. It's important to do thorough "Big-O" complexity
    calculations before designing a new collection. It's also important to use `timeit`
    after an implementation to be sure that the new collection really is an improvement
    on the built-in class.
  id: totrans-1778
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个全新的集合需要一些初步工作。我们需要有新的算法或新的内部数据结构，可以显著改进内置集合。在设计新的集合之前，进行彻底的“大O”复杂度计算非常重要。在实施后使用`timeit`来确保新的集合确实是内置类的改进也很重要。
- en: 'We might, for example, want to create a binary search tree structure that will
    keep the elements in a proper order. As we want this to be a mutable structure,
    we''ll have to perform the following kinds of design activities:'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可能想要创建一个二叉搜索树结构，以保持元素的正确顺序。由于我们希望这是一个可变的结构，我们将不得不执行以下类型的设计活动：
- en: Design the essential binary tree structure
  id: totrans-1780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计基本的二叉树结构
- en: 'Decide which structure is the basis: `MutableSequence`, `MutableMapping`, or
    `MutableSet`'
  id: totrans-1781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 决定基础结构是`MutableSequence`、`MutableMapping`还是`MutableSet`
- en: Look at the special methods for the collection in the `collections.abc` section
    of the *Python Standard Library* documentation, section 8.4.1.
  id: totrans-1782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看`Python标准库`文档的`collections.abc`部分中集合的特殊方法，第8.4.1节。
- en: 'A binary search tree has nodes with two branches: a "less than" branch for
    all keys less than this node, and a "greater than or equal to" branch for keys
    greater than or equal to this node.'
  id: totrans-1783
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉搜索树有两个分支的节点：一个是“小于”这个节点的所有键的分支，另一个是“大于或等于”这个节点的键的分支。
- en: 'We need to examine the fit between our collection and the Python ABCs:'
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查我们的集合与Python ABCs之间的匹配：
- en: It's not a great sequence because we don't usually use an index with a binary
    tree. We most often refer to elements in a search tree by their key. However,
    we can force an Integer index without too much difficulty.
  id: totrans-1785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这不是一个很好的序列，因为我们通常不会在二叉树中使用索引。我们在搜索树中通常通过它们的键来引用元素。但是，我们可以不太困难地强制使用整数索引。
- en: It could be used for the keys of a mapping; this would keep the keys in a sorted
    order. That's a common use for a binary search tree.
  id: totrans-1786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以用于映射的键；这将保持键的排序顺序。这是二叉搜索树的常见用法。
- en: It is a good alternative to a `set` or a `Counter` class because it trivially
    tolerates multiple items, making it easily bag-like.
  id: totrans-1787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是一个很好的选择，可以替代`set`或`Counter`类，因为它可以容易地容纳多个项，使其类似于袋子。
- en: We'll look at creating a sorted multiset or a bag. This can contain multiple
    copies of an object. It will rely on relatively simple comparison tests among
    objects.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将研究创建一个排序的多重集或者一个袋子。这可以包含对象的多个副本。它将依赖于对象之间相对简单的比较测试。
- en: This is a rather complex design. There are a great many details. To create a
    background, it's important to read articles such as [http://en.wikipedia.org/wiki/Binary_search_tree](http://en.wikipedia.org/wiki/Binary_search_tree).
    At the end of the previous Wikipedia page are a number of external links that
    will provide further information. It's essential to study the essential algorithms
    in books such as *Introduction to Algorithms* by Cormen, Leiserson, Rivest, and
    Stein or *Data Structures and Algorithms* by Aho, Ullman, and Hopcroft, or *The
    Algorithm Design Manual* by Steven Skiena.
  id: totrans-1789
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当复杂的设计。有很多细节。要创建一个背景，重要的是阅读诸如[http://en.wikipedia.org/wiki/Binary_search_tree](http://en.wikipedia.org/wiki/Binary_search_tree)这样的文章。在前面的维基百科页面的末尾有许多外部链接，可以提供更多信息。在书籍中学习基本算法也是非常重要的，比如Cormen、Leiserson、Rivest和Stein的*算法导论*，Aho、Ullman和Hopcroft的*数据结构与算法*，或者Steven
    Skiena的*算法设计手册*。
- en: Some design rationale
  id: totrans-1790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些设计原理
- en: 'We''re going to split the collection into two classes: `TreeNode` and `Tree`.'
  id: totrans-1791
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把集合分成两个类：`TreeNode`和`Tree`。
- en: The `TreeNode` class will contains the item as well as the `more`, `less`, and
    `parent` references. We'll also delegate some functionality to this class.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: '`TreeNode`类将包含项目以及`more`、`less`和`parent`引用。我们还将把一些功能委托给这个类。'
- en: For example, searching for a particular item in order to use `__contains__()`
    or `discard()` will be delegated to the node itself using a simple recursion.
    The algorithm's outline looks like this.
  id: totrans-1793
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，搜索特定项目以使用`__contains__()`或`discard()`将被委托给节点本身，使用简单的递归。算法的概要如下。
- en: If the target item is equal to the self item, then return `self`
  id: totrans-1794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标项目等于自身项目，则返回`self`
- en: If the target item is less than `self.item`, then recursively use `less.find(target
    item)`
  id: totrans-1795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标项目小于`self.item`，则递归使用`less.find(target item)`
- en: If the target item is greater than `self.item`, then recursively use `more.find(target.item)`
  id: totrans-1796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果目标项目大于`self.item`，则递归使用`more.find(target.item)`
- en: We'll use similar delegation to the TreeNode class for more of the real work
    of maintaining the tree structure.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用类似的委托给TreeNode类来完成更多维护树结构的真正工作。
- en: The second class will be a **Facade**, which defines the `Tree` itself. A Facade
    design can also be called a **Wrapper**; the idea is to add features required
    for a particular interface. We'll provide the external interface required by a
    `MutableSet` abstract base class.
  id: totrans-1798
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个类将是一个**Facade**，它定义了`Tree`本身。Facade设计也可以称为**Wrapper**；其思想是为特定接口添加所需的功能。我们将提供`MutableSet`抽象基类所需的外部接口。
- en: The algorithms can be somewhat simpler if there's a root node that's empty and
    always compares as less than all other key values. This can be challenging in
    Python because we don't know—in advance—what types of data the nodes might have;
    we can't easily define a bottom value for the root node. Instead, we'll use a
    special case value of `None`, and endure the overheads of `if` statements checking
    for the root node.
  id: totrans-1799
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根节点为空并且始终比所有其他键值小，则算法可能会更简单。这在Python中可能会有挑战，因为我们事先不知道节点可能具有的数据类型；我们无法轻松地为根节点定义底部值。相反，我们将使用`None`的特殊情况值，并忍受检查根节点的`if`语句的开销。
- en: Defining the Tree class
  id: totrans-1800
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义树类
- en: 'Here''s the core of an extension to `MutableSet` class that provides the minimal
    method functions:'
  id: totrans-1801
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对`MutableSet`类的扩展核心，提供了最小的方法函数：
- en: '[PRE284]'
  id: totrans-1802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: The initialization is similar to that of a `Counter` object; this class will
    accept an iterable and load the elements into the structure.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化类似于`Counter`对象；这个类将接受一个可迭代对象，并将元素加载到结构中。
- en: The `add()` and `discard()` methods keep track of the overall size. That saves
    counting nodes via a recursive traversal of the tree. These methods also delegate
    their work to the `TreeNode` object at the root of the tree.
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: '`add()`和`discard()`方法会跟踪整体大小。这样可以通过对树进行递归遍历来节省计算节点的数量。这些方法还将它们的工作委托给树根处的`TreeNode`对象。'
- en: The `__contains__()` special method performs a recursive find. It transforms
    a `KeyError` exception into a `False` return value.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: '`__contains__()`特殊方法执行递归查找。它将`KeyError`异常转换为`False`返回值。'
- en: The `__iter__()` special method is a generator function. It also delegates the
    real work to recursive iterators within the `TreeNode` class.
  id: totrans-1806
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__()`特殊方法是一个生成器函数。它还将真正的工作委托给`TreeNode`类内的递归迭代器。'
- en: We defined `discard()`; mutable sets require this to be silent when attempting
    to discard the missing keys. The abstract superclass provides a default implementation
    of `remove()`, which raises an exception if a key is not found. Both method functions
    must be present; we defined `discard()` based on `remove()` by silencing the exception.
    In some cases, it might be easier to define `remove()` based on `discard()` by
    raising an exception if a problem is found.
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了`discard()`；可变集合要求在尝试丢弃缺失的键时保持沉默。抽象超类提供了`remove()`的默认实现，如果找不到键，则会引发异常。两种方法函数都必须存在；我们基于`remove()`定义了`discard()`，通过消除异常来保持沉默。在某些情况下，基于`discard()`定义`remove()`可能更容易，如果发现问题则引发异常。
- en: Defining the TreeNode class
  id: totrans-1808
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义TreeNode类
- en: The overall `Tree` class relies on the `TreeNode` class to handle the detailed
    work of adding, removing, and iterating through the various items in the bag.
    This class is rather large, so we'll present it in three sections.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 整个`Tree`类依赖于`TreeNode`类来处理添加、删除和遍历包中各种项目的详细工作。这个类相当大，所以我们将它分成三个部分呈现。
- en: 'Here''s the first part that includes finding and iterating through the nodes:'
  id: totrans-1810
  prefs: []
  type: TYPE_NORMAL
  zh: 这是包括查找和遍历节点的第一部分：
- en: '[PRE285]'
  id: totrans-1811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: We defined the essential initialization for a node with two variants. We can
    provide as little as just the item; we can provide as much as the item, the two
    subtrees, and the parent link.
  id: totrans-1812
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了节点的基本初始化，有两种变体。我们可以提供尽可能少的项目；我们也可以提供项目、两个子树和父链接。
- en: The properties are used to ensure that the parent attribute is actually a `weakref`
    attribute that appears like a strong reference. For more information on weak references,
    see [Chapter 2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic
    Special Methods"), *Integrating Seamlessly with Python – Basic Special Methods*.
    We have mutual references between a `TreeNode` parent object and its children
    objects; this circularity could make it difficult to remove `TreeNode` objects.
    Using a `weakref` breaks the circularity.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 属性用于确保父属性实际上是一个类似强引用的`weakref`属性。有关弱引用的更多信息，请参见[第2章](ch02.html "第2章。与Python基本特殊方法无缝集成")，“与Python无缝集成-基本特殊方法”。我们在`TreeNode`父对象和其子对象之间有相互引用；这种循环可能使得难以删除`TreeNode`对象。使用`weakref`打破了这种循环。
- en: We saw the `find()` method, which performs a recursive search from a tree through
    the appropriate subtree looking for the target item.
  id: totrans-1814
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了`find()`方法，它从树中执行递归搜索，通过适当的子树寻找目标项目。
- en: The `__iter__()` method does what's called an inorder traversal of this node
    and its subtrees. As is typical, this is a generator function that yields the
    values from iterators over each collection of subtrees. Although we could create
    a separate iterator class that's tied to our `Tree` class, there's little benefit
    when a generator function does everything we need.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: '`__iter__()`方法执行所谓的中序遍历，遍历这个节点及其子树。通常情况下，这是一个生成器函数，它从每个子树的迭代器中产生值。虽然我们可以创建一个与我们的`Tree`类相关联的单独的迭代器类，但当生成器函数可以满足我们的所有需求时，几乎没有什么好处。'
- en: 'Here''s the next part of this class to add a new node to a tree:'
  id: totrans-1816
  prefs: []
  type: TYPE_NORMAL
  zh: 这是这个类的下一部分，用于向树中添加一个新节点：
- en: '[PRE286]'
  id: totrans-1817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: This is the recursive search for the proper place to add a new node. The structure
    parallels the `find()` method.
  id: totrans-1818
  prefs: []
  type: TYPE_NORMAL
  zh: 这是递归搜索适当位置以添加新节点。这个结构与`find()`方法相似。
- en: 'Finally, we have the (more complex) processing to remove a node from the tree.
    This requires some care to relink the tree around the missing node:'
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有（更复杂的）处理从树中删除节点。这需要一些小心，以重新链接围绕缺失节点的树：
- en: '[PRE287]'
  id: totrans-1820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: The `remove()` method has two sections. The first part is the recursive search
    for the target node.
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()`方法有两部分。第一部分是递归搜索目标节点。'
- en: 'Once the node is found, there are three cases to consider:'
  id: totrans-1822
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到节点，有三种情况需要考虑：
- en: When we delete a node with no children, we simply delete it and update the parent
    to replace the link with `None`.
  id: totrans-1823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们删除一个没有子节点的节点时，我们只需删除它，并更新父节点以用`None`替换链接。
- en: When we delete a node with one child, we can push the single child up to replace
    this node under the parent.
  id: totrans-1824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们删除一个只有一个子节点的节点时，我们可以将单个子节点上移，以替换父节点下的这个节点。
- en: When there are two children, we need to restructure the tree. We locate the
    successor node (the least item in the `more` subtree). We can replace the to-be-removed
    node with the content of this successor. Then, we can remove the duplicative former
    successor node.
  id: totrans-1825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当有两个子节点时，我们需要重构树。我们找到后继节点（`more`子树中的最小项）。我们可以用这个后继节点的内容替换要删除的节点。然后，我们可以删除重复的前任后继节点。
- en: We rely on two private methods. The `_least()` method performs a recursive search
    for the least-valued node in a given tree. The `_replace()` method examines a
    parent to see whether it should touch the `less` or `more` attribute.
  id: totrans-1826
  prefs: []
  type: TYPE_NORMAL
  zh: 我们依赖于两个私有方法。`_least()`方法对给定树进行递归搜索，找到最小值节点。`_replace()`方法检查父节点，看它是否应该触及`less`或`more`属性。
- en: Demonstrating the binary tree set
  id: totrans-1827
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 演示二叉树集合
- en: We built a complete new collection. The ABC definitions included a number of
    methods automatically. These inherited methods might not be particularly efficient,
    but they're defined, they work, and we didn't write the code for them.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个完整的新集合。ABC定义自动包括了许多方法。这些继承方法可能并不特别高效，但它们被定义了，它们起作用，而且我们没有为它们编写代码。
- en: '[PRE288]'
  id: totrans-1829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: This example shows us that the set `union` operator for set objects works properly,
    even though we didn't provide code for it specifically. As this is a bag, items
    are duplicated properly, too.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了集合对象的`union`运算符是如何正常工作的，即使我们没有为它专门提供代码。因为这是一个包，项目也被正确地复制了。
- en: Summary
  id: totrans-1831
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we looked at a number of built-in class definitions. The built-in
    collections are the starting place for most design work. We'll often start with
    `tuple`, `list`, `dict`, or `set`. We can leverage the extension to `tuple`, created
    by `namedtuple()`, for an application's immutable objects.
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们看了一些内置类的定义。内置集合是大多数设计工作的起点。我们经常会从`tuple`、`list`、`dict`或`set`开始。我们可以利用`namedtuple()`创建的对`tuple`的扩展来创建应用程序的不可变对象。
- en: 'Beyond these classes, we have other standard library classes in the `collections`
    mode that we can use:'
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些类，我们还有其他标准库类在`collections`模式中可以使用：
- en: '`deque`'
  id: totrans-1834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deque`'
- en: '`ChainMap`'
  id: totrans-1835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ChainMap`'
- en: '`OrderedDict`'
  id: totrans-1836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OrderedDict`'
- en: '`defaultdict`'
  id: totrans-1837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`defaultdict`'
- en: '`Counter`'
  id: totrans-1838
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`'
- en: We have three standard design strategies, too. We can wrap any of these existing
    classes, or we can extend a class.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也有三种标准的设计策略。我们可以包装任何这些现有类，或者我们可以扩展一个类。
- en: Finally, we can also invent an entirely new kind of collection. This requires
    defining a number of method names and special methods.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还可以发明一种全新的集合类型。这需要定义一些方法名和特殊方法。
- en: Design considerations and Trade-offs
  id: totrans-1841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: 'When working with containers and collections, we have a multistep design strategy:'
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理容器和集合时，我们有一个多步设计策略：
- en: Consider the built-in versions of sequence, mapping, and set.
  id: totrans-1843
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑序列、映射和集合的内置版本。
- en: Consider the library extensions in the collection module as well as extras such
    as `heapq`, `bisect`, and `array`.
  id: totrans-1844
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑集合模块中的库扩展，以及`heapq`、`bisect`和`array`等额外内容。
- en: Consider a composition of existing class definitions. In many cases, a list
    of `tuple` objects or a `dict` of lists provides the needed features.
  id: totrans-1845
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑现有类定义的组合。在许多情况下，`tuple`对象的列表或`dict`的列表提供了所需的功能。
- en: Consider extending one of the earlier mentioned classes to provide additional
    methods or attributes.
  id: totrans-1846
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑扩展前面提到的类之一，以提供额外的方法或属性。
- en: Consider wrapping an existing structure as another way to provide additional
    methods or attributes.
  id: totrans-1847
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑将现有结构包装为提供额外方法或属性的另一种方式。
- en: 'Finally, consider a novel data structure. Generally, there is a lot of careful
    analysis available. Start with Wikipedia articles like this:'
  id: totrans-1848
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，考虑一个新颖的数据结构。通常情况下，有很多仔细的分析可用。从维基百科这样的文章开始：
- en: '[http://en.wikipedia.org/wiki/List_of_data_structures](http://en.wikipedia.org/wiki/List_of_data_structures)'
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://en.wikipedia.org/wiki/List_of_data_structures](http://en.wikipedia.org/wiki/List_of_data_structures)'
- en: 'Once the design alternatives have been identified, there are two parts of the
    evaluation left:'
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设计替代方案被确定，剩下的评估部分有两个：
- en: How well the interface fits with the problem domain. This is a relatively subjective
    determination.
  id: totrans-1851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口与问题域的契合程度如何。这是一个相对主观的判断。
- en: How well the data structure performs as measured with `timeit`. This is an entirely
    objective result.
  id: totrans-1852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据结构的性能如何，可以通过`timeit`来衡量。这是一个完全客观的结果。
- en: It's important to avoid the paralysis of analysis. We need to *effectively*
    find the proper collection.
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: 避免分析瘫痪是很重要的。我们需要*有效地*找到合适的集合。
- en: In most cases, it is best to profile a working application to see which data
    structure is the performance bottleneck. In some cases, consideration of the complexity
    factors for a data structure will reveal its suitability for a particular kind
    of problem before starting the implementation.
  id: totrans-1854
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好对工作应用程序进行性能分析，以查看哪种数据结构是性能瓶颈。在某些情况下，考虑数据结构的复杂性因素将在开始实施之前揭示其适用于特定问题类型的适用性。
- en: 'Perhaps the most important consideration is this: "For highest performance,
    avoid search".'
  id: totrans-1855
  prefs: []
  type: TYPE_NORMAL
  zh: 也许最重要的考虑是：“为了获得最佳性能，避免搜索”。
- en: This is the reason sets and mappings require hashable objects. A hashable object
    can be located in a set or mapping with almost no processing. Locating an item
    by value (not by index) in a list can take a great deal of time.
  id: totrans-1856
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么集合和映射需要可散列对象的原因。可散列对象几乎不需要处理就可以在集合或映射中找到。在列表中通过值（而不是索引）定位一个项目可能需要很长时间。
- en: 'Here''s a comparison of a bad set-like use of a list and proper use of a set:'
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用列表的不良类似集合的比较和使用集合的正确使用的比较：
- en: '[PRE289]'
  id: totrans-1858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: We removed and added an item from a list as well as a set.
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从列表和集合中删除并添加了一个项目。
- en: Clearly, abusing a list to get it to perform set-like operations makes the collection
    run 2.7 times as long.
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，滥用列表以执行类似集合的操作会使集合运行时间延长2.7倍。
- en: As a second example, we'll abuse a list to make it mapping-like. This is based
    on a real-world example where the original code had two parallel lists to mimic
    the keys and values of a mapping.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二个例子，我们将滥用列表使其类似映射。这是基于一个真实世界的例子，原始代码中有两个并行列表来模拟映射的键和值。
- en: 'We''ll compare a proper mapping with two parallel lists, as follows:'
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将比较一个适当的映射和两个并行列表，如下所示：
- en: '[PRE290]'
  id: totrans-1863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: We used one list to look up a value and then set the value in a second, parallel
    list. In the other case, we simply updated a mapping.
  id: totrans-1864
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用一个列表来查找一个值，然后在第二个并行列表中设置该值。在另一种情况下，我们只是更新了一个映射。
- en: Clearly, performing an index and update on two parallel lists is a horrifying
    mistake. It takes 8.6 times as long to locate something via `list.index()` as
    it does to locate it via a mapping and the hash value.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在两个并行列表上执行索引和更新是一个可怕的错误。通过`list.index()`定位某物所需的时间是定位映射和哈希值的8.6倍。
- en: Looking forward
  id: totrans-1866
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: In the next chapter, we'll closely look at the built-in numbers and how to create
    new kinds of numbers. As with containers, Python offers a rich variety of built-in
    numbers. When creating a new kind of number, we'll have to define numerous special
    methods.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将仔细研究内置数字以及如何创建新类型的数字。与容器一样，Python提供了丰富多样的内置数字。创建新类型的数字时，我们将不得不定义许多特殊方法。
- en: After looking at numbers, we can look at some more sophisticated design techniques.
    We'll look at how we can create our own decorators and use those to simplify the
    class definition. We'll also look at using mixin class definitions, which are
    similar to the ABC definitions.
  id: totrans-1868
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看数字之后，我们可以看一些更复杂的设计技术。我们将看看如何创建自己的装饰器，并使用它们来简化类定义。我们还将研究使用混合类定义，这类似于ABC定义。
- en: Chapter 7. Creating Numbers
  id: totrans-1869
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 创建数字
- en: We can extend the ABC abstractions in the `numbers` module to create new kinds
    of numbers. We might need to do this to create numeric types that fit our problem
    domain more precisely than the built-in numeric types.
  id: totrans-1870
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展`numbers`模块中的ABC抽象，以创建新类型的数字。我们可能需要这样做来创建比内置数字类型更精确地适应我们问题域的数字类型。
- en: The abstractions in the `numbers` module need to be looked at first, since they
    define the existing built-in classes. Before working with new kinds of numbers,
    it's essential to see how the existing numbers work.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要查看`numbers`模块中的抽象，因为它们定义了现有的内置类。在使用新类型的数字之前，了解现有数字是至关重要的。
- en: We'll digress to look at Python's operator-to-method mapping algorithm. The
    idea is that a binary operator has two operands; either operand can define the
    class that implements the operator. Python's rules for locating the relevant class
    are essential to decide what special methods to implement.
  id: totrans-1872
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将离题一下，看看Python的运算符到方法映射算法。这个想法是，二元运算符有两个操作数；任何一个操作数都可以定义实现该运算符的类。Python定位相关类的规则对于决定要实现哪些特殊方法至关重要。
- en: The essential arithmetic operators such as `+`, `-`, `*`, `/`, `//`, `%`, and
    `**` form the backbone of numeric operations. There are additional operators that
    include `^`, `|`, and `&`. These are used for the bit-wise processing of integers.
    They're also used as operators among sets. There are some more operators in this
    class, including `<<`, `>>`. The comparison operators were covered in [Chapter
    2](ch02.html "Chapter 2. Integrating Seamlessly with Python Basic Special Methods"),
    *Integrating Seamlessly with Python - Basic Special Methods*. These include `<`,
    `>`, `<=`, `>=`, `==`, and `!=`. We'll review and extend our study of the comparison
    operators in this chapter.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的算术运算符，如`+`，`-`，`*`，`/`，`//`，`%`和`**`构成了数字操作的基础。还有其他运算符，包括`^`，`|`和`&`。这些用于整数的位运算处理。它们也用作集合之间的运算符。在这个类别中还有一些运算符，包括`<<`，`>>`。比较运算符在[第2章](ch02.html
    "第2章. 与Python基本特殊方法无缝集成")中已经介绍过，*与Python基本特殊方法无缝集成*。这些包括`<`，`>`，`<=`，`>=`，`==`和`!=`。我们将在本章中复习并扩展对比较运算符的研究。
- en: There are a number of additional special methods for numbers. These include
    the various conversions to other built-in types. Python also defines "in-place"
    combinations of an assignment with an operator. These include `+=`, `-=`, `*=`,
    `/=`, `//=`, `%=`, `**=`, `&=`, `|=`, `^=`, `>>=`, and `<<=`. These are more appropriate
    for mutable objects than numbers. We'll finish by summarizing some of the design
    considerations that go into extending or creating new numbers.
  id: totrans-1874
  prefs: []
  type: TYPE_NORMAL
  zh: 数字还有许多其他特殊方法。这些包括各种转换为其他内置类型。Python还定义了"就地"赋值与运算符的组合。这些包括`+=`、`-=`、`*=`、`/=`、`//=`、`%=`、`**=`、`&=`、`|=`、`^=`、`>>=`和`<<=`。这些更适用于可变对象而不是数字。最后，我们将总结一些扩展或创建新数字时涉及的设计考虑。
- en: ABCs of numbers
  id: totrans-1875
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字的ABC
- en: 'The `numbers` package provides a tower of numeric types that are all implementations
    of `numbers.Number`. Additionally, the `fractions` and `decimal` modules provide
    extension numeric types: `fractions.Fraction` and `decimal.Decimal`.'
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers`包提供了一系列数字类型，它们都是`numbers.Number`的实现。此外，`fractions`和`decimal`模块提供了扩展的数字类型：`fractions.Fraction`和`decimal.Decimal`。'
- en: These definitions roughly parallel the mathematical thought on the various classes
    of numbers. An article available at [http://en.wikipedia.org/wiki/Number_theory](http://en.wikipedia.org/wiki/Number_theory)
    covers the basics of different kinds of numbers.
  id: totrans-1877
  prefs: []
  type: TYPE_NORMAL
  zh: 这些定义大致与数学上对各类数字的思考相一致。一篇文章在[http://en.wikipedia.org/wiki/Number_theory](http://en.wikipedia.org/wiki/Number_theory)上介绍了不同类型数字的基础知识。
- en: What's important is the question of how well computers implement mathematical
    abstractions. To be more specific, we want to be sure that anything that is computable
    in the abstract world of mathematics can be computed using a concrete computer.
    This is why the question of computability is so important. The idea behind a "Turing
    Complete" programming language is that it can compute anything that's computable
    by an abstract Turing Machine. A helpful article can be found at [http://en.wikipedia.org/wiki/Computability_theory](http://en.wikipedia.org/wiki/Computability_theory).
  id: totrans-1878
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是计算机如何实现数学抽象。更具体地说，我们希望确保在数学的抽象世界中可以计算的任何东西都可以使用具体的计算机进行计算。这就是可计算性问题如此重要的原因。"图灵完备"编程语言的理念是它可以计算图灵机可以计算的任何东西。可以在[http://en.wikipedia.org/wiki/Computability_theory](http://en.wikipedia.org/wiki/Computability_theory)找到一篇有用的文章。
- en: Python defines the following abstractions and their associated implementation
    classes. Further, these classes form an inheritance hierarchy where each abstract
    class inherits from the class above it. As we move down the list, the classes
    have more features. Since there are very few classes, it forms a *tower* rather
    than a tree.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: Python定义了以下抽象及其相关的实现类。此外，这些类形成了一个继承层次结构，其中每个抽象类都继承自上面的类。随着我们向下移动列表，类具有更多的特性。由于类很少，它形成了一个*塔*而不是一棵树。
- en: '`numbers.Complex` implemented by `complex`'
  id: totrans-1880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers.Complex`由`complex`实现'
- en: '`numbers.Real` implemented by `float`'
  id: totrans-1881
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers.Real`由`float`实现'
- en: '`numbers.Rational` implemented by `fractions.Fraction`'
  id: totrans-1882
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers.Rational`由`fractions.Fraction`实现'
- en: '`numbers.Integral` implemented by `int`'
  id: totrans-1883
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numbers.Integral`由`int`实现'
- en: Additionally, we have `decimal.Decimal`, which is a bit like a float; it isn't
    a proper subclass of `numbers.Real`, but is somewhat like it.
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还有`decimal.Decimal`，它有点像`float`；它不是`numbers.Real`的适当子类，但有些类似。
- en: Tip
  id: totrans-1885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: While it may be obvious, it's still essential to repeat that the `float` value
    is merely an approximation. It's not exact.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能是显而易见的，但重复一遍`float`值仅仅是一个近似值。它不是精确的。
- en: 'Don''t be surprised by this sort of thing. The following is an example of using
    the ![ABCs of numbers](graphics/0971OS_07_01.jpg) approximations:'
  id: totrans-1887
  prefs: []
  type: TYPE_NORMAL
  zh: 不要对这种事情感到惊讶。以下是使用![数字的ABC](graphics/0971OS_07_01.jpg)近似的一个例子：
- en: '`>>> (3*5*7*11)/(11*13*17*23*29)`'
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> (3*5*7*11)/(11*13*17*23*29)`'
- en: '`0.0007123135264946712`'
  id: totrans-1889
  prefs: []
  type: TYPE_NORMAL
  zh: '`0.0007123135264946712`'
- en: '`>>> _*13*17*23*29`'
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: '`>>> _*13*17*23*29`'
- en: '`105.00000000000001`'
  id: totrans-1891
  prefs: []
  type: TYPE_NORMAL
  zh: '`105.00000000000001`'
- en: In principle, the further down the number tower we go, the smaller the order
    of infinity. This can be a confusing subject. While the various abstract definitions
    of numbers are each infinite, it's possible to prove that there are different
    orders of infinity. This leads to the idea that floats represent more numbers
    than integers in principle. Pragmatically, a 64-bit float and 64-bit integer have
    the same number of distinct values.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，我们沿着数字塔向下走，无穷的次序会变得更小。这可能是一个令人困惑的主题。虽然各种抽象定义的数字都是无穷的，但可以证明存在不同的无穷次序。这导致了一个观点，即在原则上，浮点数表示的数字比整数多。从实际上来看，64位浮点数和64位整数具有相同数量的不同值。
- en: 'In addition to the numeric class definitions, there are also a number of conversions
    among the various classes. It''s not possible to convert from every type to every
    other type, so we must work out a matrix that shows the conversions that work
    and conversions that can''t work. The following is a summary:'
  id: totrans-1893
  prefs: []
  type: TYPE_NORMAL
  zh: 除了数字类的定义之外，还有许多在各种类之间的转换。不可能从每种类型转换到其他每种类型，因此我们必须制定一个矩阵，显示可以进行的转换和不能进行的转换。以下是一个总结：
- en: '`complex`: This can''t be converted to any other type. A `complex` value can
    be decomposed into the `real` and `imag` portions, both of which are `float`.'
  id: totrans-1894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`complex`：这不能转换为任何其他类型。`complex`值可以分解为`real`和`imag`部分，两者都是`float`。'
- en: '`float`: This can be converted explicitly to any type including `decimal.Decimal`.
    Arithmetic operators won''t implicitly coerce a `float` value to `Decimal`.'
  id: totrans-1895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`：这可以显式转换为任何类型，包括`decimal.Decimal`。算术运算符不会将`float`值隐式转换为`Decimal`。'
- en: '`Fractions.Fraction`: This can be converted to any of the other types, except
    `decimal.Decimal`. To get to `decimal` requires a two-part operation: (1) to `float`
    (2) to `decimal.Decimal`. This leads to an approximation.'
  id: totrans-1896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fractions.Fraction`：这可以转换为任何其他类型，除了`decimal.Decimal`。要转换为`decimal`需要一个两部分的操作：(1)转换为`float`
    (2)转换为`decimal.Decimal`。这会导致近似值。'
- en: '`int`: This can be converted to any of the other types.'
  id: totrans-1897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`：这可以转换为任何其他类型。'
- en: '`Decimal`: This can be converted to any other type. It is not implicitly coerced
    to other types via arithmetic operations.'
  id: totrans-1898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Decimal`：这可以转换为任何其他类型。它不会通过算术运算隐式地强制转换为其他类型。'
- en: The up and down conversions come from the tower of numeric abstractions shown
    previously.
  id: totrans-1899
  prefs: []
  type: TYPE_NORMAL
  zh: 上下转换来自先前显示的数值抽象的塔。
- en: Deciding which types to use
  id: totrans-1900
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 决定使用哪些类型
- en: 'Because of the conversions, we see the following four general domains of numerical
    processing:'
  id: totrans-1901
  prefs: []
  type: TYPE_NORMAL
  zh: 由于转换，我们看到了以下四个数值处理的一般领域：
- en: '**Complex**: Once we get involved in complex math, we''ll be using `complex`,
    `float`, plus the `cmath` module. We probably aren''t going to use `Fraction`
    or `Decimal` at all. However, there''s no reason to impose restrictions on the
    numeric types; most numbers will be converted to complex.'
  id: totrans-1902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**复数**：一旦我们涉及复杂的数学，我们将使用`complex`、`float`以及`cmath`模块。我们可能根本不会使用`Fraction`或`Decimal`。然而，没有理由对数值类型施加限制；大多数数字将被转换为复数。'
- en: '**Currency**: For currency-related operations, we absolutely must use `Decimal`.
    Generally, when doing currency calculations, there''s no good reason to mix the
    decimal values with non-decimal values. Sometimes, we''ll use the `int` values,
    but there''s no good reason to work with `float` or `complex` along with `Decimal`.
    Remember, floats are approximations, and that''s unacceptable when working with
    currency.'
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**货币**：对于与货币相关的操作，我们绝对必须使用`Decimal`。通常，在进行货币计算时，没有理由将小数值与非小数值混合在一起。有时，我们会使用`int`值，但没有理由使用`float`或`complex`与`Decimal`一起工作。记住，浮点数是近似值，在处理货币时是不可接受的。'
- en: '**Bit kicking**: For operations that involve bit and byte processing, we''ll
    generally use `int`, only `int`, and nothing but `int`.'
  id: totrans-1904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位操作**：对于涉及位和字节处理的操作，我们通常只会使用`int`，只有`int`，仅仅是`int`。'
- en: '**Conventional**: The broad, vague "everything else" category. For most conventional
    mathematical operations `int`, `float`, and `Fraction` are all interchangeable.
    Indeed, a well-written function can often be properly polymorphic; it will work
    perfectly well with any numeric type. Python types, particularly `float` and `int`,
    will participate in a variety of implicit conversions. This makes the selection
    of a specific numeric type for these kinds of problems somewhat moot.'
  id: totrans-1905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统：广泛而模糊的“其他一切”类别。对于大多数传统数学运算，`int`、`float`和`Fraction`是可以互换的。事实上，一个写得很好的函数通常可以是适当的多态的；它可以很好地与任何数值类型一起使用。Python类型，特别是`float`和`int`，将参与各种隐式转换。这使得为这些问题选择特定的数值类型有些无关紧要。
- en: These are generally obvious aspects of a problem domain. It's usually easy to
    distinguish applications that might involve science or engineering and complex
    numbers from applications that involve financial calculations, currency, and decimal
    numbers. It's important to be as permissive as possible in the numeric types that
    are used in an application. Needlessly narrowing the domain of types via the `isinstance()`
    test is often a waste of time and code.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 这些通常是问题领域的明显方面。通常很容易区分可能涉及科学或工程和复数的应用程序，以及涉及财务计算、货币和小数的应用程序。在应用程序中尽可能宽容地使用数值类型是很重要的。通过`isinstance()`测试不必要地缩小类型的领域通常是浪费时间和代码。
- en: The method resolution and the reflected operator concept
  id: totrans-1907
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法解析和反射运算符概念
- en: The arithmetic operators (`+`, `-`, `*`, `/`, `//`, `%`, `**`, and so on) all
    map to special method names. When we provide an expression such as `355+113`,
    the generic `+` operator will be mapped to a concrete `__add__()` method of a
    specific numeric class. This example will turn out to be evaluated as though we
    had written `355.__add__(113)`. The simplest rule is that the left-most operand
    determines the class of the operator being used.
  id: totrans-1908
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符（`+`、`-`、`*`、`/`、`//`、`%`、`**`等）都映射到特殊的方法名。当我们提供一个表达式，比如`355+113`，通用的`+`运算符将被映射到特定数值类的具体`__add__()`方法。这个例子将被计算，就好像我们写了`355.__add__(113)`一样。最简单的规则是，最左边的操作数决定了所使用的运算符的类。
- en: But wait, there's more! When we have an expression with mixed types, Python
    may end up with two implementations of the special methods, one in each class.
    Consider `7-0.14` as an expression. Using the left-side `int` class, this expression
    will be attempted as `7.__sub__(0.14)`. This involves an unpleasant complexity,
    since the argument to an `int` operator is a `float` value `0.14` and converting
    `float` to `int` could potentially lose precision. Converting up the tower of
    types (from `int` toward `complex`) won't lose precision. Converting down the
    tower of types implies a potential loss of precision.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等，还有更多！当我们有一个混合类型的表达式时，Python可能会得到两个特殊方法的实现，每个类一个。考虑`7-0.14`作为一个表达式。使用左侧的`int`类，这个表达式将被尝试为`7.__sub__(0.14)`。这涉及到一个不愉快的复杂性，因为`int`运算符的参数是一个`float`值`0.14`，将`float`转换为`int`可能会丢失精度。从`int`向上转换到`complex`的类型塔不会丢失精度。向下转换类型塔意味着可能会丢失精度。
- en: 'Using the right-side `float` version, however, this expression will be attempted
    as: `0.14.__rsub__(7)`. In this case, the argument to a `float` operator is an
    `int` value `7`; converting `int` up the tower to `float` doesn''t (generally)
    lose precision. (A truly giant `int` value can lose precision; however, that''s
    a technical quibble, not a general principle.)'
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用右侧的`float`版本，这个表达式将被尝试为：`0.14.__rsub__(7)`。在这种情况下，`float`运算符的参数是一个`int`值`7`；将`int`转换为`float`不会（通常）丢失精度。（一个真正巨大的`int`值可能会丢失精度；然而，这是一个技术上的争论，而不是一个一般原则。）
- en: 'The `__rsub__()` operation is "reflected subtraction". The `X.__sub__(Y)` operation
    is the expected ![The method resolution and the reflected operator concept](graphics/0971OS_07_02.jpg).
    The `A.__rsub__(B)` operation is the reflection ![The method resolution and the
    reflected operator concept](graphics/0971OS_07_03.jpg); the implementation method
    comes from the right-hand side operand''s class. We''ve seen the following two
    rules:'
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: '`__rsub__()`操作是“反射减法”。`X.__sub__(Y)`操作是预期的![方法解析和反射运算符概念](graphics/0971OS_07_02.jpg)。`A.__rsub__(B)`操作是反射![方法解析和反射运算符概念](graphics/0971OS_07_03.jpg)；实现方法来自右操作数的类。我们已经看到了以下两条规则：'
- en: Try the left-hand side operand's class first. If that works, good. If the operand
    returns `NotImplemented` as a value, then use rule 2.
  id: totrans-1912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先尝试左操作数的类。如果可以，很好。如果操作数返回`NotImplemented`作为值，那么使用规则2。
- en: Try the right-hand side operand with the reflected operator. If that works,
    good. If it returns `NotImplemented`, then it really is not implemented, so an
    exception must be raised.
  id: totrans-1913
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试反射运算符的右操作数。如果可以，很好。如果返回`NotImplemented`，那么它确实没有实现，因此必须引发异常。
- en: 'The notable exception is when the two operands happen to have a subclass relationship.
    This additional rule applies before the first pair rules as a special case:'
  id: totrans-1914
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的例外情况是当两个操作数恰好具有子类关系时。这个额外的规则适用于第一对规则之前作为特殊情况：
- en: If the right operand is a subclass of the left and the subclass defines the
    reflected special method name for the operator, then the subclass reflected operator
    will be tried. This allows a subclass override to be used, even if the subclass
    operand is on the right-hand side of the operator.
  id: totrans-1915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果右操作数是左操作数的子类，并且子类为运算符定义了反射特殊方法名称，则将尝试子类的反射运算符。这允许使用子类覆盖，即使子类操作数位于运算符的右侧。
- en: Otherwise, use rule 1 and try the left side.
  id: totrans-1916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，使用规则1并尝试左侧。
- en: Imagine we wrote a subclass of float, `MyFloat`. In an expression like `2.0-MyFloat(1)`,
    the right operand is of a subclass of the left operand's class. Because of this
    subclass relationship, `MyFloat(1).__rsub__(2.0)` will be tried first. The point
    of this rule is to give precedence to the subclass.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们写了一个float的子类`MyFloat`。在`2.0-MyFloat(1)`这样的表达式中，右操作数是左操作数类的子类。由于这种子类关系，将首先尝试`MyFloat(1).__rsub__(2.0)`。这条规则的目的是给子类优先权。
- en: This means that a class that will do implicit coercion from other types must
    implement the forward, as well as the reflected operators. When we implement or
    extend a numeric type, we must work out the conversions that our type is able
    to do.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着一个类必须从其他类型进行隐式转换，必须实现前向和反射运算符。当我们实现或扩展一个数值类型时，我们必须确定我们的类型能够进行的转换。
- en: The arithmetic operator's special methods
  id: totrans-1919
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符的特殊方法
- en: 'There are a total of 13 binary operators and their associated special methods.
    We''ll focus on the obvious arithmetic operators first. The special method names
    match the operators (and functions), as shown in the following table:'
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有13个二元运算符及其相关的特殊方法。我们将首先关注明显的算术运算符。特殊方法名称与运算符（和函数）匹配，如下表所示：
- en: '| Method | Operator |'
  id: totrans-1921
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-1922
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__add__(self, other)` | `+` |'
  id: totrans-1923
  prefs: []
  type: TYPE_TB
  zh: '| `object.__add__(self, other)` | `+` |'
- en: '| `object.__sub__(self, other)` | `-` |'
  id: totrans-1924
  prefs: []
  type: TYPE_TB
  zh: '| `object.__sub__(self, other)` | `-` |'
- en: '| `object.__mul__(self, other)` | `*` |'
  id: totrans-1925
  prefs: []
  type: TYPE_TB
  zh: '| `object.__mul__(self, other)` | `*` |'
- en: '| `object.__truediv__(self, other)` | `/` |'
  id: totrans-1926
  prefs: []
  type: TYPE_TB
  zh: '| `object.__truediv__(self, other)` | `/` |'
- en: '| `object.__floordiv__(self, other)` | `//` |'
  id: totrans-1927
  prefs: []
  type: TYPE_TB
  zh: '| `object.__floordiv__(self, other)` | `//` |'
- en: '| `object.__mod__(self, other)` | `%` |'
  id: totrans-1928
  prefs: []
  type: TYPE_TB
  zh: '| `object.__mod__(self, other)` | `%` |'
- en: '| `object.__divmod__(self, other)` | `divmod()` |'
  id: totrans-1929
  prefs: []
  type: TYPE_TB
  zh: '| `object.__divmod__(self, other)` | `divmod()` |'
- en: '| `object.__pow__(self, other[, modulo])` | `pow()` as well as `**` |'
  id: totrans-1930
  prefs: []
  type: TYPE_TB
  zh: '| `object.__pow__(self, other[, modulo])` | `pow()` 以及 `**` |'
- en: 'And yes, interestingly, two functions are included with the various symbolic
    operators. There are a number of unary operators and functions which have special
    method names, shown in the following table:'
  id: totrans-1931
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，有趣的是，各种符号运算符都包括了两个函数。有许多一元运算符和函数，它们具有特殊的方法名称，如下表所示：
- en: '| Method | Operator |'
  id: totrans-1932
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-1933
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__neg__(self)` | `-` |'
  id: totrans-1934
  prefs: []
  type: TYPE_TB
  zh: '| `object.__neg__(self)` | `-` |'
- en: '| `object.__pos__(self)` | `+` |'
  id: totrans-1935
  prefs: []
  type: TYPE_TB
  zh: '| `object.__pos__(self)` | `+` |'
- en: '| `object.__abs__(self)` | `abs()` |'
  id: totrans-1936
  prefs: []
  type: TYPE_TB
  zh: '| `object.__abs__(self)` | `abs()` |'
- en: '| `object.__complex__(self)` | `complex()` |'
  id: totrans-1937
  prefs: []
  type: TYPE_TB
  zh: '| `object.__complex__(self)` | `complex()` |'
- en: '| `object.__int__(self)` | `int()` |'
  id: totrans-1938
  prefs: []
  type: TYPE_TB
  zh: '| `object.__int__(self)` | `int()` |'
- en: '| `object.__float__(self)` | `float()` |'
  id: totrans-1939
  prefs: []
  type: TYPE_TB
  zh: '| `object.__float__(self)` | `float()` |'
- en: '| `object.__round__(self[, n])` | `round()` |'
  id: totrans-1940
  prefs: []
  type: TYPE_TB
  zh: '| `object.__round__(self[, n])` | `round()` |'
- en: '| `object.__trunc__(self[, n])` | `math.trunc()` |'
  id: totrans-1941
  prefs: []
  type: TYPE_TB
  zh: '| `object.__trunc__(self[, n])` | `math.trunc()` |'
- en: '| `object.__ceil__(self[, n])` | `math.ceil()` |'
  id: totrans-1942
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ceil__(self[, n])` | `math.ceil()` |'
- en: '| `object.__floor__(self[, n])` | `math.floor()` |'
  id: totrans-1943
  prefs: []
  type: TYPE_TB
  zh: '| `object.__floor__(self[, n])` | `math.floor()` |'
- en: 'And yes, there are a lot of functions in this list too. We can tinker with
    Python''s internal trace to see what''s going on under the hood. We''ll define
    a simplistic trace function that will provide us with a little bit of visibility
    into what''s going on:'
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这个列表中也有很多函数。我们可以调整Python的内部跟踪，看看底层发生了什么。我们将定义一个简单的跟踪函数，它将为我们提供一点点关于发生了什么的可见性：
- en: '[PRE291]'
  id: totrans-1945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'This function will dump special method names when the code associated with
    the traced frame has a name that starts with `"__"`. We can install this trace
    function into Python using the following code:'
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 当与跟踪帧相关联的代码的名称以`"__"`开头时，此函数将转储特殊方法名称。我们可以使用以下代码将此跟踪函数安装到Python中：
- en: '[PRE292]'
  id: totrans-1947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'Once installed, everything passes through our `trace()` function. We''re filtering
    the trace events for special method names. We''ll define a subclass of a built-in
    class so that we can explore the method resolution rules:'
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装，一切都通过我们的`trace()`函数。我们正在过滤特殊方法名称的跟踪事件。我们将定义一个内置类的子类，以便我们可以探索方法解析规则：
- en: '[PRE293]'
  id: totrans-1949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'This class overrides just two of the operator''s special method names. When
    we add `noisyfloat` values, we''ll see a printed summary of the operation. Plus,
    the trace will tell us what''s going on. The following is the interaction that
    shows Python''s choice of class to implement a given operation:'
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只重写了两个操作符的特殊方法名称。当我们添加`noisyfloat`值时，我们将看到操作的打印摘要。此外，跟踪将告诉我们发生了什么。以下是显示Python选择实现给定操作的类的交互：
- en: '[PRE294]'
  id: totrans-1951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: From `x+3`, we see how `noisyfloat+int` provided the `int` object, `3`, to the
    `__add__()` method. This value was passed to the superclass, `float`, which handled
    the coercion of 3 to a `float` and did the addition, too. `2+x` shows how the
    right side `noisyfloat` version of the operation was used. Again, `int` was passed
    to the superclass that handled the coercion to `float`. From `x+2.3`, we come
    to know that `noisyfloat+float` used the subclass that was on the left-hand side.
    On the other hand, `2.3+x` shows how `float+noisyfloat` used the subclass on the
    right-hand side and the reflected `__radd__()` operator.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: 从`x+3`，我们看到`noisyfloat+int`提供了`int`对象`3`给`__add__()`方法。这个值被传递给了超类`float`，它处理了3到`float`的强制转换，并且也进行了加法。`2+x`展示了右侧`noisyfloat`版本的操作是如何被使用的。同样，`int`被传递给了处理`float`的超类。从`x+2.3`，我们知道`noisyfloat+float`使用了左侧的子类。另一方面，`2.3+x`展示了`float+noisyfloat`是如何使用右侧的子类和反射的`__radd__()`操作符。
- en: Creating a numeric class
  id: totrans-1953
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个数值类
- en: We'll try to design a new kind of number. This is no easy task when Python already
    offers integers of indefinite precision, rational fractions, standard floats,
    and decimal numbers for currency calculations. We'll define a class of "scaled"
    numbers. These are numbers that include an integer value coupled with a scaling
    factor. We can use these for currency calculations. For many currencies of the
    world, we can use a scale of 100 and do all our calculations to the nearest cent.
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将尝试设计一种新的数字类型。当Python已经提供了无限精度的整数、有理分数、标准浮点数和货币计算的十进制数时，这并不是一件容易的任务。我们将定义一类“缩放”数字。这些数字包括一个整数值和一个缩放因子。我们可以用这些来进行货币计算。对于世界上许多货币，我们可以使用100的比例，并进行最接近的分的所有计算。
- en: The advantage of scaled arithmetic is that it can be done very simply by using
    low-level hardware instructions. We could rewrite this module to be a C-language
    module and exploit hardware speed operations. The disadvantage of inventing new
    scaled arithmetic is that the `decimal` package already does a very neat job of
    exact decimal arithmetic.
  id: totrans-1955
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放算术的优势在于可以通过使用低级硬件指令来非常简单地完成。我们可以将这个模块重写为一个C语言模块，并利用硬件速度操作。发明新的缩放算术的缺点在于，`decimal`包已经非常好地执行了精确的十进制算术。
- en: We'll call this `FixedPoint` class because it will implement a kind of fixed
    decimal point number. The scale factor will be a simple integer, usually a power
    of 10\. In principle, a scaling factor that's a power of 2 could be considerably
    faster, but wouldn't be ideally suited for currency.
  id: totrans-1956
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将称这个类为`FixedPoint`类，因为它将实现一种固定的小数点数。比例因子将是一个简单的整数，通常是10的幂。原则上，一个2的幂作为缩放因子可能会更快，但不太适合货币。
- en: The reason a scaling factor that's a power of 2 can be faster is that we can
    replace `value*(2**scale)` with `value << scale` and replace `value/(2**scale)`
    with `value >> scale`. The left and right shift operations are often hardware
    instructions that are much faster than multiplication or division.
  id: totrans-1957
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放因子是2的幂可以更快的原因是，我们可以用`value << scale`替换`value*(2**scale)`，用`value >> scale`替换`value/(2**scale)`。左移和右移操作通常是比乘法或除法快得多的硬件指令。
- en: Ideally, the scaling factor is a power of 10, but we don't explicitly enforce
    this. It's a relatively simple extension to track both a scaling power and the
    scale factor that goes with the power. We might store 2 as the power and ![Creating
    a numeric class](graphics/0971OS_07_04.jpg) as the factor. We've simplified this
    class definition to just track the factor.
  id: totrans-1958
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，缩放因子是10的幂，但我们并没有明确强制执行这一点。跟踪缩放幂和与幂相关的比例因子是一个相对简单的扩展。我们可以将2存储为幂，并将![Creating
    a numeric class](graphics/0971OS_07_04.jpg)存储为因子。我们已经简化了这个类的定义，只需跟踪因子。
- en: Defining FixedPoint initialization
  id: totrans-1959
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义FixedPoint初始化
- en: 'We''ll start with initialization, which includes conversions of various types
    to the `FixedPoint` values as follows:'
  id: totrans-1960
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从初始化开始，包括将各种类型转换为`FixedPoint`值，如下所示：
- en: '[PRE295]'
  id: totrans-1961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'Our `FixedPoint` class is defined as a `numbers.Rational` subclass. We''re
    going to wrap two integer values, `scale` and `value`, and follow the general
    definitions for fractions. This requires a large number of special method definitions.
    The initialization is for an immutable object, so it overrides `__new__()` instead
    of `__init__()`. It defines a limited number of slots to prevent the adding of
    any additional attributes. The initialization includes several kinds of conversions
    as follows:'
  id: totrans-1962
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`FixedPoint`类被定义为`numbers.Rational`的子类。我们将包装两个整数值，`scale`和`value`，并遵循分数的一般定义。这需要大量的特殊方法定义。初始化是为了一个不可变的对象，所以它重写了`__new__()`而不是`__init__()`。它定义了有限数量的插槽，以防止添加任何额外的属性。初始化包括以下几种转换：
- en: If we're given another `FixedPoint` object, we'll copy the internal attributes
    to create a new `FixedPoint` object that's a kind of clone of the original. It
    will have a unique ID, but we can be sure it has the same hash value and compares
    as equal, making the clone largely indistinguishable.
  id: totrans-1963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们得到另一个`FixedPoint`对象，我们将复制内部属性以创建一个新的`FixedPoint`对象，它是原始对象的克隆。它将有一个唯一的ID，但我们可以确信它具有相同的哈希值并且比较相等，使得克隆在很大程度上是不可区分的。
- en: When given integral or rational values (concrete classes of `int` or `float`),
    these are used to set the `value` and `scale` attributes.
  id: totrans-1964
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当给定整数或有理数值（`int`或`float`的具体类），这些值被用来设置`value`和`scale`属性。
- en: We can add cases to handle `decimal.Decimal` and `fractions.Fraction`, as well
    as parsing input string values.
  id: totrans-1965
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加处理`decimal.Decimal`和`fractions.Fraction`的情况，以及解析输入字符串值。
- en: 'We''ve defined three special methods to produce string results: `__str__()`,
    `__repr__()`, and `__format__()`. For the format operation, we''ve decided to
    leverage the existing floating-point features of the format specification language.
    Because this is a rational number, we need to provide numerator and denominator
    methods.'
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个特殊方法来生成字符串结果：`__str__()`、`__repr__()`和`__format__()`。对于格式操作，我们决定利用格式规范语言的现有浮点特性。因为这是一个有理数，我们需要提供分子和分母方法。
- en: Note that we could have also started with wrapping the existing `fractions.Fraction`
    class. Also, note that we're playing fast and loose with the rounding rules. This
    should also be defined with reasonable care before applying this class to a specific
    problem domain.
  id: totrans-1967
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们也可以从现有的`fractions.Fraction`类开始。还要注意，我们在舍入规则上玩得很快。在将此类应用于特定问题域之前，这也应该以合理的方式定义。
- en: Defining FixedPoint binary arithmetic operators
  id: totrans-1968
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义FixedPoint二进制算术运算符
- en: 'The whole reason for defining a new class of numbers is to overload the arithmetic
    operators. Each `FixedPoint` object has two parts: `value` and `scale`. We can
    say this: ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_05.jpg).'
  id: totrans-1969
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新类别数字的整个原因是为了重载算术运算符。每个`FixedPoint`对象有两部分：`value`和`scale`。我们可以这样说：![定义FixedPoint二进制算术运算符](graphics/0971OS_07_05.jpg)。
- en: Note that we've worked out the algebra in the example below using correct but
    inefficient floating point expressions. We'll discuss the slightly more efficient,
    pure integer operations.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经使用正确但低效的浮点表达式在下面的示例中解出了代数。我们将讨论稍微更有效的纯整数操作。
- en: 'The general form for addition (and subtraction) is this: ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_06.jpg). But it creates a result
    with a lot of useless precision.'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 加法（和减法）的一般形式是这样的：![定义FixedPoint二进制算术运算符](graphics/0971OS_07_06.jpg)。但它创建了一个有很多无用精度的结果。
- en: Imagine adding 9.95 and 12.95\. We'd have (in principle) 229000/10000\. This
    can be properly reduced to 2290/100\. The problem is that it also reduces to 229/10,
    which is no longer in cents. We'd like to avoid reducing fractions in a general
    way and instead stick with cents or mils to the extent possible.
  id: totrans-1972
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下添加9.95和12.95。我们将（原则上）有229000/10000。这可以正确地减少为2290/100。问题是它也减少为229/10，这不再是分。我们希望避免以一般方式减少分数，而尽可能坚持分或毫。
- en: 'We can identify two cases for ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_07.jpg):'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以确定![定义FixedPoint二进制算术运算符](graphics/0971OS_07_07.jpg)有两种情况：
- en: '**The scale factors match**: In this case, the sum is ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_08.jpg). When adding `FixedPoint`
    and the plain old integer, this will also work, since we can force the plain old
    integer to have the required scale factor.'
  id: totrans-1974
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比例因子匹配**：在这种情况下，总和是![定义FixedPoint二进制算术运算符](graphics/0971OS_07_08.jpg)。当添加`FixedPoint`和普通整数时，这也可以工作，因为我们可以强制普通整数具有所需的比例因子。'
- en: '**The scale factors don''t match**: The right thing to do is to produce a result
    that has the maximum scale factor of the two input values, ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_09.jpg). From this, we can compute
    two scale factors, ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_10.jpg)
    and ![Defining FixedPoint binary arithmetic operators](graphics/0971OS_07_11.jpg).
    One of those scale factors will be 1, the other will be less than 1\. We can now
    add with a common value in the denominator. Algebraically, it''s ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_12.jpg). This can be further optimized
    into two cases, since one of the factors is 1 and the other is a power of 10.'
  id: totrans-1975
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比例因子不匹配**：正确的做法是产生一个具有两个输入值的最大比例因子的结果，![定义FixedPoint二进制算术运算符](graphics/0971OS_07_09.jpg)。从这里，我们可以计算两个比例因子，![定义FixedPoint二进制算术运算符](graphics/0971OS_07_10.jpg)和![定义FixedPoint二进制算术运算符](graphics/0971OS_07_11.jpg)。其中一个比例因子将是1，另一个将小于1。我们现在可以用一个公共值在分母上相加。代数上，它是![定义FixedPoint二进制算术运算符](graphics/0971OS_07_12.jpg)。这可以进一步优化为两种情况，因为一个因子是1，另一个是10的幂。'
- en: We can't really optimize multiplication. It's essentially ![Defining FixedPoint
    binary arithmetic operators](graphics/0971OS_07_13.jpg). The precision really
    does increase when we multiply the `FixedPoint` values.
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上不能优化乘法。它本质上是![定义FixedPoint二进制算术运算符](graphics/0971OS_07_13.jpg)。当我们相乘`FixedPoint`值时，精度确实会增加。
- en: 'Division is multiplication by an inverse, ![Defining FixedPoint binary arithmetic
    operators](graphics/0971OS_07_14.jpg). If A and B have the same scale, these values
    will cancel so that we do have a handy optimization available. However, this changes
    the scale from cents to wholes, which might not be appropriate. The following
    is what the forward operators, built around a similar boilerplate, look like:'
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: 除法是乘以倒数，![定义FixedPoint二进制算术运算符](graphics/0971OS_07_14.jpg)。如果A和B具有相同的比例，这些值将取消，以便我们确实有一个方便的优化可用。然而，这将把比例从分变为整，这可能不合适。前向运算符，围绕类似的样板构建，看起来像这样：
- en: '[PRE296]'
  id: totrans-1978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: For the simple addition, subtraction, and multiplication cases, we've provided
    versions that can be optimized to eliminate some of the relatively slow floating
    point intermediate results.
  id: totrans-1979
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的加法、减法和乘法情况，我们提供了可以优化以消除一些相对较慢的浮点中间结果的版本。
- en: For the two divisions, the `__mod__()` and `__pow__()` methods, we haven't done
    any optimization to try and eliminate noise being introduced via floating-point
    division. Instead, we've provided a working Python implementation that can be
    used with a suite of unit tests as a basis for optimization and refactoring.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: 对于两个除法，`__mod__()`和`__pow__()`方法，我们没有进行任何优化来尝试消除通过浮点除法引入的噪音。相反，我们提供了一个可用于一套单元测试的工作Python实现，作为优化和重构的基础。
- en: It's important to note that the division operations can properly reduce the
    scale factors. However, that may be undesirable. When doing currency work, we
    might divide the currency rate (dollars) by a non-currency value (hours) to get
    the dollars-per-hour result. The proper answer might have zero relevant decimal
    places, this would be a scale of 1, but we might want to force the value to have
    a cents-oriented scale of 100\. This implementation assures that the left-hand
    side operand dictates the desired number of decimal places.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，除法操作可以正确地减少比例因子。但这可能是不希望的。在进行货币工作时，我们可能会将货币汇率（美元）除以非货币值（小时）以获得每小时美元的结果。正确的答案可能没有相关的小数位，这将是1的比例，但我们可能希望强制该值具有以分为单位的比例为100。该实现确保左操作数决定所需的小数位数。
- en: Defining FixedPoint unary arithmetic operators
  id: totrans-1982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义FixedPoint一元算术运算符
- en: 'The following are the unary operators method functions:'
  id: totrans-1983
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一元运算符方法函数：
- en: '[PRE297]'
  id: totrans-1984
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: For the `__round__()`, `__trunc__()`, `__ceil__()`, and `__floor__()` operators,
    we've delegated the work to a Python library function. There are some potential
    optimizations, but we've taken the lazy route of creating a float approximation
    and using that to create the desired result. This suite of methods assures that
    our `FixedPoint` objects will work with a number of arithmetic functions. Yes,
    there are a lot of operators in Python. This isn't the entire suite. We haven't
    covered comparison or bit-kicking operators.
  id: totrans-1985
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`__round__()`、`__trunc__()`、`__ceil__()`和`__floor__()`运算符，我们已将工作委托给Python库函数。有一些潜在的优化，但我们采取了创建浮点近似值并使用它来创建所需结果的懒惰方式。这一系列方法确保我们的`FixedPoint`对象将与许多算术函数一起使用。是的，Python中有很多运算符。这并不是整套。我们还没有涵盖比较或位操作符。
- en: Implementing FixedPoint reflected operators
  id: totrans-1986
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现FixedPoint反射运算符
- en: 'The reflected operators are used in the following two cases:'
  id: totrans-1987
  prefs: []
  type: TYPE_NORMAL
  zh: 反射运算符在以下两种情况下使用：
- en: The right-hand operand is a subclass of the left-hand operand. In this case,
    the reflected operator is tried first to assure that the subclass overrides the
    parent class.
  id: totrans-1988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右操作数是左操作数的子类。在这种情况下，首先尝试反射运算符，以确保子类覆盖父类。
- en: The left-hand operand's class doesn't implement the needed special method. In
    this case, the right-hand operand's reflected special method is used.
  id: totrans-1989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左操作数的类没有实现所需的特殊方法。在这种情况下，将使用右操作数的反射特殊方法。
- en: The following table shows the mapping between reflected special methods and
    operators.
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了反射特殊方法和运算符之间的映射关系。
- en: '| Method | Operator |'
  id: totrans-1991
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-1992
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__radd__(self, other)` | `+` |'
  id: totrans-1993
  prefs: []
  type: TYPE_TB
  zh: '| `object.__radd__(self, other)` | `+` |'
- en: '| `object.__rsub__(self, other)` | `-` |'
  id: totrans-1994
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rsub__(self, other)` | `-` |'
- en: '| `object.__rmul__(self, other)` | `*` |'
  id: totrans-1995
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rmul__(self, other)` | `*` |'
- en: '| `object.__rtruediv__(self, other)` | `/` |'
  id: totrans-1996
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rtruediv__(self, other)` | `/` |'
- en: '| `object.__rfloordiv__(self, other)` | `//` |'
  id: totrans-1997
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rfloordiv__(self, other)` | `//` |'
- en: '| `object.__rmod__(self, other)` | `%` |'
  id: totrans-1998
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rmod__(self, other)` | `%` |'
- en: '| `object.__rdivmod__(self, other)` | `divmod()` |'
  id: totrans-1999
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rdivmod__(self, other)` | `divmod()` |'
- en: '| `object.__rpow__(self, other[, modulo])` | `pow()` as well as `**` |'
  id: totrans-2000
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rpow__(self, other[, modulo])` | `pow()` 以及 `**` |'
- en: 'These reflected operation special methods are also built around a common boilerplate.
    Since these are reflected, the order of the operands in subtraction, division,
    modulus, and power is important. For commutative operations such as addition and
    multiplication, the order doesn''t matter. The following are the reflected operators:'
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 这些反射操作特殊方法也围绕一个常见的样板构建。由于这些是反射的，减法、除法、模数和幂运算中的操作数顺序很重要。对于加法和乘法等可交换操作，顺序并不重要。以下是反射运算符：
- en: '[PRE298]'
  id: totrans-2002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: We've tried to use math that is identical to the forward operators. The idea
    is to switch the operands in a simple way. This is the most common situation.
    Having the text of the forward and reverse methods match each other simplifies
    code inspections.
  id: totrans-2003
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尝试使用与正向运算符相同的数学。这样做的想法是以简单的方式交换操作数。这是最常见的情况。使正向和反向方法的文本相匹配可以简化代码检查。
- en: As with the forward operators, we've kept the division, modulus, and power operators
    simple to avoid optimizations. The versions shown here can introduce noise from
    the conversion to a floating-point approximation and back to a `FixedPoint` value.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: '与正向运算符一样，我们保持除法、模数和幂运算符的简单，以避免优化。这里显示的版本可以通过将其转换为浮点近似值然后转回`FixedPoint`值来引入噪音。 '
- en: Implementing FixedPoint comparison operators
  id: totrans-2005
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现FixedPoint比较运算符
- en: 'The following are the six comparison operators and the special methods which
    implement them:'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是六个比较运算符和实现它们的特殊方法：
- en: '| Method | Operator |'
  id: totrans-2007
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-2008
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__lt__(self, other)` | `<` |'
  id: totrans-2009
  prefs: []
  type: TYPE_TB
  zh: '| `object.__lt__(self, other)` | `<` |'
- en: '| `object.__le__(self, other)` | `<=` |'
  id: totrans-2010
  prefs: []
  type: TYPE_TB
  zh: '| `object.__le__(self, other)` | `<=` |'
- en: '| `object.__eq__(self, other)` | `==` |'
  id: totrans-2011
  prefs: []
  type: TYPE_TB
  zh: '| `object.__eq__(self, other)` | `==` |'
- en: '| `object.__ne__(self, other)` | `!=` |'
  id: totrans-2012
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ne__(self, other)` | `!=` |'
- en: '| `object.__gt__(self, other)` | `>` |'
  id: totrans-2013
  prefs: []
  type: TYPE_TB
  zh: '| `object.__gt__(self, other)` | `>` |'
- en: '| `object.__ge__(self, other)` | `>=` |'
  id: totrans-2014
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ge__(self, other)` | `>=` |'
- en: The `is` operator compares object IDs. We can't meaningfully override this,
    since it's independent of any specific class. The `in` comparison operator is
    implemented by `object.__contains__( self, value )`. This isn't meaningful for
    numeric values.
  id: totrans-2015
  prefs: []
  type: TYPE_NORMAL
  zh: '`is`运算符比较对象ID。我们无法有意义地覆盖它，因为它独立于任何特定的类。`in`比较运算符由`object.__contains__( self,
    value )`实现。这对于数值没有意义。'
- en: Note that equality testing is a subtle business. Since floats are approximations,
    we have to be very careful to avoid direct equality testing with float values.
    We really need to compare to see if the values are within a small range, that
    is, epsilon. It should never be written as `a == b`. The general approach to compare
    floating-point approximations should be `abs(a-b) <= eps`. Or, more correctly,
    `abs(a-b)/a <= eps`.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，相等性测试是一个微妙的问题。由于浮点数是近似值，我们必须非常小心，避免直接使用浮点值进行相等性测试。我们真的需要比较值是否在一个小范围内，即 epsilon。它永远不应该被写成
    `a == b`。比较浮点近似值的一般方法应该是 `abs(a-b) <= eps`。或者更正确地说，`abs(a-b)/a <= eps`。
- en: In our `FixedPoint` class, the scale indicates how close two values need to
    be for a `float` value to be considered equal. For a scale of 100, the epsilon
    could be 0.01\. We'll actually be more conservative than that and use 0.005 as
    the basis for comparison when the scale is 100.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `FixedPoint` 类中，比例表示两个值需要多接近，以便将一个 `float` 值视为相等。对于比例为100，epsilon 可以是0.01。我们实际上会更保守一些，当比例为100时，使用0.005作为比较的基础。
- en: Additionally, we have to decide whether `FixedPoint(123, 100)` should be equal
    to `FixedPoint(1230, 1000)` or not. While they're mathematically equal, one value
    is in cents and one is in mils. This can be taken as a claim about the different
    accuracies of the two numbers; the presence of an additional significant digit
    may indicate that they're not supposed to simply appear equal. If we follow this
    approach, then we need to be sure the hash values are different too.
  id: totrans-2018
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们必须决定 `FixedPoint(123, 100)` 是否应该等于 `FixedPoint(1230, 1000)`。虽然它们在数学上是相等的，但一个值是以分为单位，另一个值是以毫为单位。这可以被视为关于两个数字不同精度的声明；额外的有效数字的存在可能表明它们不应该简单地看起来相等。如果我们遵循这种方法，那么我们需要确保哈希值也是不同的。
- en: 'We think the distinguishing scale is not appropriate for our application. We
    want `FixedPoint(123, 100)` to be equal to `FixedPoint(1230, 1000)`. This is the
    assumption behind the recommended `__hash__()` implementation too. The following
    are the implementations for our `FixedPoint` class comparisons:'
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 我们认为区分比例对于我们的应用程序不合适。我们希望 `FixedPoint(123, 100)` 等于 `FixedPoint(1230, 1000)`。这也是推荐的
    `__hash__()` 实现的假设。以下是我们的 `FixedPoint` 类比较的实现：
- en: '[PRE299]'
  id: totrans-2020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Each of the comparison functions tolerates a value that is not a `FixedPoint`
    value. The only requirement is that the other value must have a floating-point
    representation. We've defined a `__float__()` method for the `FixedPoint` objects,
    so the comparison operations will work perfectly well when comparing the two `FixedPoint`
    values.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 每个比较函数都容忍一个不是 `FixedPoint` 值的值。唯一的要求是另一个值必须有一个浮点表示。我们已经为 `FixedPoint` 对象定义了一个
    `__float__()` 方法，所以当比较两个 `FixedPoint` 值时，比较操作将完全正常工作。
- en: We don't need to write all six comparisons. The `@functools.total_ordering`
    decorator can generate the missing methods from just two `FixedPoint` values.
    We'll look at this in [Chapter 8](ch08.html "Chapter 8. Decorators and Mixins
    – Cross-cutting Aspects"), *Decorators and Mixins – Cross-cutting Aspects*.
  id: totrans-2022
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要写所有六个比较。`@functools.total_ordering` 装饰器可以从只有两个 `FixedPoint` 值生成缺失的方法。我们将在[第8章](ch08.html
    "第8章。装饰器和混入 - 横切面方面")中看到这一点，*装饰器和混入 - 横切面方面*。
- en: Computing a numeric hash
  id: totrans-2023
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算数值哈希
- en: 'We do need to define the `__hash__()` method properly. See section 4.4.4 of
    the *Python Standard Library* for information on computing hash values for numeric
    types. That section defines a `hash_fraction()` function, which is the recommended
    solution for what we''re doing here. Our method looks like the following:'
  id: totrans-2024
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实需要正确定义 `__hash__()` 方法。有关计算数值类型的哈希值的信息，请参阅 *Python标准库* 第4.4.4节。该部分定义了一个
    `hash_fraction()` 函数，这是我们正在做的事情的推荐解决方案。我们的方法如下：
- en: '[PRE300]'
  id: totrans-2025
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: This reduces a two-part rational fraction value to a single, standardized hash.
    This code is copied with a few modifications from the reference manual. The core
    of the calculation, which is highlighted, multiplies the numerator by the inverse
    of the denominator. In effect, it carries out the division of the numerator by
    the denominator, `mod P`. We can optimize this to make it more specific to our
    problem domain.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 这将一个两部分的有理分数值减少到一个单一的标准化哈希。这段代码是从参考手册复制过来的，稍作修改。计算的核心部分，即高亮部分，将分子乘以分母的倒数。实际上，它执行了分子除以分母的
    `mod P`。我们可以优化这个，使它更具体化到我们的问题域。
- en: First, we can (and should) modify our `__new__()` method to assure that the
    scale is nonzero, eliminating any need for `sys.hash_info.inf`. Second, we should
    explicitly limit the range of the scale factor to be less than `sys.hash_info.modulus`
    (generally ![Computing a numeric hash](graphics/0971OS_07_15.jpg) for 64-bit computers).
    We can eliminate the need to remove common factors of `P`. That would boil the
    hash down to `hash_ = (abs(m) % P) * pow(n, P - 2, P) % P`, the sign handling
    and the special case that -1 is mapped to -2.
  id: totrans-2027
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以（也应该）修改我们的 `__new__()` 方法，以确保比例不为零，消除了对 `sys.hash_info.inf` 的任何需求。其次，我们应该明确限制比例因子的范围小于
    `sys.hash_info.modulus`（通常为64位计算机）。我们可以消除去除 `P` 的常见因素的需要。这将使哈希简化为 `hash_ = (abs(m)
    % P) * pow(n, P - 2, P) % P`，符号处理和特殊情况 -1 映射到 -2。
- en: Finally, we might want to memorize the result of any hash calculation. This
    requires an additional slot that's only populated once the first time a hash is
    requested. The `pow(n, P - 2, P)` expression is relatively expensive to evaluate
    and we don't want to compute it more often than necessary.
  id: totrans-2028
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可能希望记住任何哈希计算的结果。这需要一个额外的插槽，只有在第一次请求哈希时才填充。`pow(n, P - 2, P)` 表达式相对昂贵，我们不希望计算它的频率超过必要的次数。
- en: Designing more useful rounding
  id: totrans-2029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计更有用的四舍五入
- en: We truncated the presentation on rounding. We defined the required functions
    for `round()` and `trunc()` without further explanation. These definitions are
    the minimum requirements of the abstract superclass. However, these definitions
    are not quite enough for our purposes.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在四舍五入的演示中进行了截断。我们定义了`round()`和`trunc()`的必需函数，没有进一步的解释。这些定义是抽象超类的最低要求。然而，这些定义对我们的目的来说还不够。
- en: 'To process currency, we''ll often have code that looks like the following:'
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理货币，我们经常会有类似以下的代码：
- en: '[PRE301]'
  id: totrans-2032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Then, we need to round this value off to a scale of `100` to get a value of
    `942`. We need methods that will round (as well as truncate) a number to a new
    scale factor. The following is a method to round to a specific scale:'
  id: totrans-2033
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将这个值四舍五入到`100`的比例，得到一个值为`942`。我们需要一些方法，将一个数字四舍五入（以及截断）到一个新的比例因子。以下是一个四舍五入到特定比例的方法：
- en: '[PRE302]'
  id: totrans-2034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'The following code allows us to properly rescale the value:'
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码允许我们正确地重新调整值：
- en: '[PRE303]'
  id: totrans-2036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: This shows that we have a minimal set of functions to calculate currency.
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们有一组最小的函数来计算货币。
- en: Implementing other special methods
  id: totrans-2038
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现其他特殊方法
- en: 'In addition to the core arithmetic and comparison operators, we have a group
    of additional operators that (generally) we only define for the `numbers.Integral`
    values. Since we''re not defining integral values, we can avoid these special
    methods:'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: 除了核心算术和比较运算符，我们还有一组额外的运算符（通常）仅为`numbers.Integral`值定义。由于我们不定义整数值，我们可以避免这些特殊方法：
- en: '| Method | Operator |'
  id: totrans-2040
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-2041
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__lshift__(self, other)` | `<<` |'
  id: totrans-2042
  prefs: []
  type: TYPE_TB
  zh: '| `object.__lshift__(self, other)` | `<<` |'
- en: '| `object.__rshift__(self, other)` | `>>` |'
  id: totrans-2043
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rshift__(self, other)` | `>>` |'
- en: '| `object.__and__(self, other)` | `&` |'
  id: totrans-2044
  prefs: []
  type: TYPE_TB
  zh: '| `object.__and__(self, other)` | `&` |'
- en: '| `object.__xor__(self, other)` | `^` |'
  id: totrans-2045
  prefs: []
  type: TYPE_TB
  zh: '| `object.__xor__(self, other)` | `^` |'
- en: '| `object.__or__(self, other)` | `&#124;` |'
  id: totrans-2046
  prefs: []
  type: TYPE_TB
  zh: '| `object.__or__(self, other)` | `|` |'
- en: 'Also, there are reflected versions of these operators:'
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有这些运算符的反射版本：
- en: '| Method | Operator |'
  id: totrans-2048
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-2049
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__rlshift__(self, other)` | `<<` |'
  id: totrans-2050
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rlshift__(self, other)` | `<<` |'
- en: '| `object.__rrshift__(self, other)` | `>>` |'
  id: totrans-2051
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rrshift__(self, other)` | `>>` |'
- en: '| `object.__rand__(self, other)` | `&` |'
  id: totrans-2052
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rand__(self, other)` | `&` |'
- en: '| `object.__rxor__(self, other)` | `^` |'
  id: totrans-2053
  prefs: []
  type: TYPE_TB
  zh: '| `object.__rxor__(self, other)` | `^` |'
- en: '| `object.__ror__(self, other)` | `&#124;` |'
  id: totrans-2054
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ror__(self, other)` | `|` |'
- en: 'Additionally, there''s a unary operator for a bit-wise inverse of the value:'
  id: totrans-2055
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个用于值的按位取反的一元运算符：
- en: '| Method | Operator |'
  id: totrans-2056
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-2057
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__invert__(self)` | `~` |'
  id: totrans-2058
  prefs: []
  type: TYPE_TB
  zh: '| `object.__invert__(self)` | `~` |'
- en: Interestingly, some of these operators are defined for the set collection, as
    well as integral numbers. They don't apply to our rational value. The principles
    to define these operators are the same as the other arithmetic operators.
  id: totrans-2059
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，其中一些运算符也适用于集合，以及整数。它们不适用于我们的有理数值。定义这些运算符的原则与其他算术运算符相同。
- en: Optimization with the in-place operators
  id: totrans-2060
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用就地运算符进行优化
- en: Generally, numbers are immutable. However, the numeric operators are also used
    for mutable objects. Lists and sets, for example, respond to a few of the defined
    augmented assignment operators. As an optimization, a class can include an in-place
    version of a selected operator. These methods implement the augmented assignment
    statements for mutable objects. Note that these methods are expected to end with
    `return self` to be compatible with ordinary assignment.
  id: totrans-2061
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数字是不可变的。然而，数字运算符也用于可变对象。例如，列表和集合对一些定义的增强赋值运算符做出响应。作为一种优化，一个类可以包括所选运算符的就地版本。这些方法实现了可变对象的增强赋值语句。请注意，这些方法预期以`return
    self`结尾，以便与普通赋值兼容。
- en: '| Method | Operator |'
  id: totrans-2062
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 运算符 |'
- en: '| --- | --- |'
  id: totrans-2063
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `object.__iadd__(self, other)` | `+=` |'
  id: totrans-2064
  prefs: []
  type: TYPE_TB
  zh: '| `object.__iadd__(self, other)` | `+=` |'
- en: '| `object.__isub__(self, other)` | `-=` |'
  id: totrans-2065
  prefs: []
  type: TYPE_TB
  zh: '| `object.__isub__(self, other)` | `-=` |'
- en: '| `object.__imul__(self, other)` | `*=` |'
  id: totrans-2066
  prefs: []
  type: TYPE_TB
  zh: '| `object.__imul__(self, other)` | `*=` |'
- en: '| `object.__itruediv__(self, other)` | `/=` |'
  id: totrans-2067
  prefs: []
  type: TYPE_TB
  zh: '| `object.__itruediv__(self, other)` | `/=` |'
- en: '| `object.__ifloordiv__(self, other)` | `//=` |'
  id: totrans-2068
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ifloordiv__(self, other)` | `//=` |'
- en: '| `object.__imod__(self, other)` | `%=` |'
  id: totrans-2069
  prefs: []
  type: TYPE_TB
  zh: '| `object.__imod__(self, other)` | `%=` |'
- en: '| `object.__ipow__(self, other[, modulo])` | `**=` |'
  id: totrans-2070
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ipow__(self, other[, modulo])` | `**=` |'
- en: '| `object.__ilshift__(self, other)` | `<<=` |'
  id: totrans-2071
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ilshift__(self, other)` | `<<=` |'
- en: '| `object.__irshift__(self, other)` | `>>=` |'
  id: totrans-2072
  prefs: []
  type: TYPE_TB
  zh: '| `object.__irshift__(self, other)` | `>>=` |'
- en: '| `object.__iand__(self, other)` | `&=` |'
  id: totrans-2073
  prefs: []
  type: TYPE_TB
  zh: '| `object.__iand__(self, other)` | `&=` |'
- en: '| `object.__ixor__(self, other)` | `^=` |'
  id: totrans-2074
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ixor__(self, other)` | `^=` |'
- en: '| `object.__ior__(self, other)` | `&#124;=` |'
  id: totrans-2075
  prefs: []
  type: TYPE_TB
  zh: '| `object.__ior__(self, other)` | `|=` |'
- en: 'Since our `FixedPoint` objects are immutable, we should not define any of these.
    Stepping outside this example, for a moment, we can see a more typical use for
    in-place operators. We could easily define some in-place operators for our Blackjack
    `Hand` objects. We might want to add this definition to `Hand` as follows:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`FixedPoint`对象是不可变的，我们不应该定义这些方法。暂时离开这个例子，我们可以看到就地运算符的更典型的用法。我们可以很容易地为我们的Blackjack
    `Hand`对象定义一些就地运算符。我们可能希望将此定义添加到`Hand`中，如下所示：
- en: '[PRE304]'
  id: totrans-2077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'This allows us to deal into `hand` with the following code:'
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: 这使我们能够使用以下代码处理`hand`：
- en: '[PRE305]'
  id: totrans-2079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: This seems to be an elegant way to indicate that `hand` is updated with another
    card.
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 这似乎是一种优雅的方式来表明`hand`已经更新为另一张牌。
- en: Summary
  id: totrans-2081
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've looked at the built-in numeric types. We've also looked at the vast number
    of special methods required to invent a new numeric type. Specialized numeric
    types that integrate seamlessly with the rest of Python is one of the core strengths
    of the language. That doesn't make the job easy. It merely makes it elegant and
    useful when done properly.
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过内置的数字类型。我们还看过了发明新的数字类型所需的大量特殊方法。与Python的其余部分无缝集成的专门的数字类型是该语言的核心优势之一。这并不意味着工作容易。只是在正确完成时使其优雅和有用。
- en: Design considerations and trade-offs
  id: totrans-2083
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: 'When working with numbers, we have a multistep design strategy:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理数字时，我们有一个多步设计策略：
- en: Consider the built-in versions of `complex`, `float`, and `int`.
  id: totrans-2085
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑`complex`，`float`和`int`的内置版本。
- en: Consider the library extensions such as `decimal` and `fractions`. For financial
    calculations, `decimal` must be used; there is no alternative.
  id: totrans-2086
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑库扩展，如`decimal`和`fractions`。对于财务计算，必须使用`decimal`；没有其他选择。
- en: Consider extending one of the above classes with additional methods or attributes.
  id: totrans-2087
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑使用以上类之一扩展额外的方法或属性。
- en: Finally, consider a novel number. This is particularly challenging, since Python's
    variety of available numbers is very rich.
  id: totrans-2088
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，考虑一个新颖的数字。这是特别具有挑战性的，因为Python提供的可用数字种类非常丰富。
- en: 'Defining new numbers involves several considerations:'
  id: totrans-2089
  prefs: []
  type: TYPE_NORMAL
  zh: 定义新数字涉及几个考虑：
- en: '**Completeness and consistency**: The new number must perform a complete set
    of operations and behave consistently in all kinds of expressions. This is really
    a question of properly implementing the formal mathematical definitions of this
    new kind of computable number.'
  id: totrans-2090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**完整性和一致性**：新数字必须执行完整的操作集，并且在所有类型的表达式中表现一致。这实际上是一个问题，即正确实现这种新类型的可计算数字的形式数学定义。'
- en: '**Fit with the problem domain**: Is this number truly suitable? Does it help
    clarify the solution?'
  id: totrans-2091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与问题域的契合**：这个数字真的适合吗？它是否有助于澄清解决方案？'
- en: '**Performance**: As with other design questions, we must be sure that our implementation
    is efficient enough to warrant writing all that code. Our example in this chapter,
    for example, uses some inefficient floating-point operations that could be optimized
    by doing a little more math and a little less coding.'
  id: totrans-2092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：与其他设计问题一样，我们必须确保我们的实现足够高效，以至于值得编写所有这些代码。例如，本章中的示例使用了一些效率低下的浮点运算，可以通过进行更多的数学运算而不是编码来进行优化。'
- en: Looking forward
  id: totrans-2093
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: The next chapter is about using decorators and mixins to simplify and normalize
    class design. We can use decorators to define features that should be present
    in a number of classes, which are not in a simple inheritance hierarchy. Similarly,
    we can use mixin class definitions to create a complete application class from
    component class definitions. One of the decorators that is helpful to define comparison
    operators is the `@functools.total_ordering` decorator.
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于使用装饰器和混入来简化和规范类设计。我们可以使用装饰器来定义应该存在于多个类中的特性，这些特性不在简单的继承层次结构中。同样，我们可以使用混入类定义来从组件类定义中创建完整的应用程序类。有一个有助于定义比较运算符的装饰器是`@functools.total_ordering`装饰器。
- en: Chapter 8. Decorators and Mixins – Cross-cutting Aspects
  id: totrans-2095
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。装饰器和混入-横切面
- en: A software design often has aspects that apply across several classes, functions,
    or methods. We might have a technical aspect, examples include logging, auditing,
    or security, that must be implemented consistently. The general method for reuse
    of functionality in object-oriented programming is inheritance through a class
    hierarchy. However, inheritance doesn't always work out well. Some aspects of
    a software design are orthogonal to the class hierarchy. These are sometimes called
    "cross-cutting concerns". They cut across the classes, making design more complex.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 软件设计通常具有适用于多个类、函数或方法的方面。我们可能有一个技术方面，例如日志记录、审计或安全，必须一致地实现。在面向对象编程中，重用功能的一般方法是通过类层次结构进行继承。然而，继承并不总是奏效。软件设计的一些方面与类层次结构正交。这些有时被称为“横切关注点”。它们横跨类，使设计变得更加复杂。
- en: A decorator provides a way to define functionality that's not bound to the inheritance
    hierarchy. We can use decorators to design an aspect of our application and then
    apply the decorators across classes, methods, or functions.
  id: totrans-2097
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器提供了一种定义功能的方式，该功能不受继承层次结构的约束。我们可以使用装饰器来设计应用程序的一个方面，然后将装饰器应用于类、方法或函数。
- en: Additionally, we can use multiple inheritance in a disciplined way to create
    cross-cutting aspects. We'll consider a base class plus mixin class definitions
    to introduce features. Often, we'll use the mixin classes to build cross-cutting
    aspects.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以有纪律性地使用多重继承来创建横切面。我们将考虑基类加上混入类定义来引入特性。通常，我们将使用混入类来构建横切面。
- en: It's important to note that cross-cutting concerns are rarely specific to the
    application at hand. They're often generic considerations. The common examples
    of logging, auditing, and security could be considered as infrastructure separate
    from the application's details.
  id: totrans-2099
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，横切面很少与手头的应用程序有关。它们通常是通用的考虑因素。日志记录、审计和安全的常见示例可以被视为与应用程序细节分开的基础设施。
- en: Python comes with many decorators, and we can expand this standard set of decorators.
    There are several different use cases. We'll look at simple function decorators,
    function decorators with arguments, class decorators, and method decorators.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: Python带有许多装饰器，我们可以扩展这个标准的装饰器集。有几种不同的用例。我们将研究简单的函数装饰器、带参数的函数装饰器、类装饰器和方法装饰器。
- en: Class and meaning
  id: totrans-2101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类和含义
- en: One essential feature of objects is that they can be classified. Each object
    belongs to a class. This is a straightforward relationship between an object and
    class with a simple, single-inheritance design.
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的一个基本特征是它们可以被分类。每个对象都属于一个类。这是对象与类之间的简单直接关系，具有简单的单继承设计。
- en: With multiple inheritance, the classification problem can become complex. When
    we look at real-world objects, such as coffee cups, we can classify them as containers
    without too much difficulty. That is, after all, their primary use case. The problem
    they solve is that of holding coffee. However, in another context, we may be interested
    in other use cases. In a decorative collection of ceramic mugs, we might be more
    interested in size, shape, and glaze than we are in the coffee-carrying aspect
    of a cup.
  id: totrans-2103
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多重继承，分类问题可能变得复杂。当我们看真实世界的对象，比如咖啡杯，我们可以将它们分类为容器而不会遇到太多困难。毕竟，这是它们的主要用例。它们解决的问题是容纳咖啡。然而，在另一个情境中，我们可能对其他用例感兴趣。在装饰性的陶瓷马克杯收藏中，我们可能更感兴趣的是尺寸、形状和釉面，而不是杯子的容纳咖啡的方面。
- en: Most objects have a straightforward *is-a* relationship with a class. In our
    coffee-holding problem domain, the mug sitting on the desk is a coffee cup as
    well as a container. Objects may also have several *acts-as* relationships with
    other classes. A mug acts as a piece of ceramic art with size, shape, and glaze
    properties. A mug acts as a paper weight with mass and friction properties. Generally,
    these other features can be seen as mixin classes, and they define the additional
    interfaces or behaviors for an object.
  id: totrans-2104
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数对象与一个类有一个直接的*is-a*关系。在我们的咖啡杯问题领域中，桌子上的杯子既是咖啡杯，也是一个容器。对象还可以与其他类有几个*acts-as*关系。杯子作为一个陶瓷艺术品，具有尺寸、形状和釉面属性。杯子作为一个纸张重量，具有质量和摩擦属性。通常，这些其他特性可以被视为混入类，并为对象定义了额外的接口或行为。
- en: When doing object-oriented design, it's common to identify the *is-a* class
    and the essential aspects defined by that class. Other classes can mix in interfaces
    or behaviors that an object will also have. We'll take a look at how classes are
    constructed and decorated. We'll start with function definition and decoration
    since it's somewhat simpler than class construction.
  id: totrans-2105
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行面向对象设计时，通常会确定*is-a*类和该类定义的基本方面。其他类可以混入对象也将具有的接口或行为。我们将看看类是如何构建和装饰的。我们将从函数定义和装饰开始，因为这比类构建要简单一些。
- en: Constructing the functions
  id: totrans-2106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建函数
- en: We construct functions in two stages. The first stage is the `def` statement
    with an original definition.
  id: totrans-2107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分两个阶段构建函数。第一阶段是使用原始定义的`def`语句。
- en: Tip
  id: totrans-2108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: It's technically possible to build a function using a lambda and assignment;
    we'll avoid that.
  id: totrans-2109
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，可以使用lambda和赋值来构建函数；我们将避免这样做。
- en: A `def` statement provides a name, parameters, defaults, a `docstring`, a code
    object, and a number of other details. A function is a collection of 11 attributes,
    defined in section 3.2 of the *Python Language Reference* which is the standard
    type hierarchy. See [http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy](http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy).
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: '`def`语句提供了名称、参数、默认值、`docstring`、代码对象和其他一些细节。函数是由11个属性组成的集合，在*Python语言参考*的第3.2节中定义了标准类型层次结构。参见[http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy](http://docs.python.org/3.3/reference/datamodel.html#the-standard-type-hierarchy)。'
- en: 'The second stage is applying a decorator to the original definition. When we
    apply a decorator (`@d`) to a function (`F`), the effect is as if we have created
    a new function, ![Constructing the functions](graphics/0971OS_08_01.jpg). The
    name is the same, but the functionality can be different depending on the kind
    of features that have been added, removed, or modified. Then, we will write the
    following code:'
  id: totrans-2111
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段是将装饰器应用于原始定义。当我们将装饰器(`@d`)应用于函数(`F`)时，效果就好像我们创建了一个新函数，![构建函数](graphics/0971OS_08_01.jpg)。名称是相同的，但功能可能会有所不同，具体取决于已添加、删除或修改的功能类型。然后，我们将编写以下代码：
- en: '[PRE306]'
  id: totrans-2112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'The decorator is written immediately in front of the function definition. What
    happens is this:'
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器紧跟在函数定义的前面。发生的情况是：
- en: '[PRE307]'
  id: totrans-2114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'The decorator modifies the function definition to create a new function. Here
    is the list of attributes of a function:'
  id: totrans-2115
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器修改函数定义以创建一个新函数。以下是函数的属性列表：
- en: '| Attribute | Contents |'
  id: totrans-2116
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 内容 |'
- en: '| --- | --- |'
  id: totrans-2117
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__doc__` | The docstring, or `None`. |'
  id: totrans-2118
  prefs: []
  type: TYPE_TB
  zh: '| `__doc__` | 文档字符串，或`None`。 |'
- en: '| `__name__` | The original name of the function. |'
  id: totrans-2119
  prefs: []
  type: TYPE_TB
  zh: '| `__name__` | 函数的原始名称。 |'
- en: '| `__module__` | The name of the module the function was defined in, or `None`.
    |'
  id: totrans-2120
  prefs: []
  type: TYPE_TB
  zh: '| `__module__` | 函数定义所在的模块的名称，或`None`。 |'
- en: '| `__qualname__` | The function''s fully qualified name, `__module__.__name__`.
    |'
  id: totrans-2121
  prefs: []
  type: TYPE_TB
  zh: '| `__qualname__` | 函数的完全限定名称，`__module__.__name__`。 |'
- en: '| `__defaults__` | The default argument values, or none if there are no defaults.
    |'
  id: totrans-2122
  prefs: []
  type: TYPE_TB
  zh: '| `__defaults__` | 默认参数值，如果没有默认值则为none。 |'
- en: '| `__kwdefaults__` | The default values for keyword-only parameters. |'
  id: totrans-2123
  prefs: []
  type: TYPE_TB
  zh: '| `__kwdefaults__` | 关键字参数的默认值。 |'
- en: '| `__code__` | The code object representing the compiled function body. |'
  id: totrans-2124
  prefs: []
  type: TYPE_TB
  zh: '| `__code__` | 代表编译函数体的代码对象。 |'
- en: '| `__dict__` | A namespace for the function''s attributes. |'
  id: totrans-2125
  prefs: []
  type: TYPE_TB
  zh: '| `__dict__` | 函数属性的命名空间。 |'
- en: '| `__annotations__` | The annotations of parameters, including `''return''`
    for the return annotation. |'
  id: totrans-2126
  prefs: []
  type: TYPE_TB
  zh: '| `__annotations__` | 参数的注释，包括返回注释`''return''`。 |'
- en: '| `__globals__` | The global namespace of the module that the function was
    defined in; this is used to resolve global variables and is read only. |'
  id: totrans-2127
  prefs: []
  type: TYPE_TB
  zh: '| `__globals__` | 函数定义所在模块的全局命名空间；这用于解析全局变量，是只读的。 |'
- en: '| `__closure__` | Bindings for the function''s free variables or none. It is
    read-only. |'
  id: totrans-2128
  prefs: []
  type: TYPE_TB
  zh: '| `__closure__` | 函数的自由变量的绑定，或者没有。它是只读的。 |'
- en: Except for `__globals__` and `__closure__`, a decorator can change any of these
    attributes. However, we'll see later that it's impractical to tinker with these
    too deeply.
  id: totrans-2129
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`__globals__`和`__closure__`之外，装饰器可以改变这些属性中的任何一个。然而，我们将在后面看到，深度修改这些属性是不切实际的。
- en: Pragmatically, decoration usually involves defining a new function that *wraps*
    the existing function. A few of the previous attributes may need to be copied
    or updated. This defines a practical limit to what decorators can and should do.
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，装饰通常涉及定义一个*包装*现有函数的新函数。可能需要复制或更新一些先前的属性。这为装饰器可以做什么以及应该做什么定义了一个实际的限制。
- en: Constructing the class
  id: totrans-2131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建类
- en: Class construction is a nested set of two-stage processes. Making class construction
    more complex is the way references are made to class methods that involve a multistep
    lookup. An object's class will define a **Method Resolution Order** (**MRO**).
    This defines how base classes are searched to locate an attribute or method name.
    The MRO works its way up the inheritance hierarchy; this means that subclass names
    override superclass names. This implementation method search meets our expectation
    for what inheritance means.
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造是一组嵌套的两阶段过程。使类构造更复杂的是类方法的引用方式，涉及到多步查找。对象的类将定义一个**方法解析顺序**（**MRO**）。这定义了如何搜索基类以定位属性或方法名称。MRO沿着继承层次结构向上工作；这意味着子类名称会覆盖超类名称。这种实现方法搜索符合我们对继承含义的期望。
- en: The first stage in class construction is the `class` statement with the original
    definition. This stage involves the evaluation of the metaclass followed by the
    execution of the sequence of assignment and `def` statements within a `class`.
    Each `def` statement within the class expands to a nested two-stage function construction,
    as described previously. Decorators can be applied to each method function as
    part of the process of building the class.
  id: totrans-2133
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造的第一阶段是原始定义的“class”语句。这个阶段涉及到元类的评估，然后在“class”内部执行一系列赋值和“def”语句。类内的每个“def”语句都会扩展为一个嵌套的两阶段函数构造，如前面所述。装饰器可以应用到每个方法函数上，作为构建类的过程的一部分。
- en: The second stage in class construction is to apply an overall class decorator
    to a class definition. Generally, a `decorator` function can add features. It's
    somewhat more common to add attributes rather than adding methods. However, we
    will see decorators that can also add method functions.
  id: totrans-2134
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造的第二阶段是将整体类装饰器应用于类定义。通常，`decorator`函数可以添加特性。通常更常见的是添加属性而不是添加方法。然而，我们会看到一些装饰器也可以添加方法函数。
- en: 'The features inherited from superclasses clearly cannot be modified through
    decorators since they are resolved lazily by method resolution lookup. This leads
    to some important design considerations. We generally introduce methodsthrough
    classes and mixin classes. We''re limited to introducing attributes either via
    decorators or mixin class definitions. Here''s a list of some of the attributes
    that are built for a class. A number of additional attributes are part of the
    metaclass; they are described in the following table:'
  id: totrans-2135
  prefs: []
  type: TYPE_NORMAL
  zh: 从超类继承的特性显然不能通过装饰器进行修改，因为它们是通过方法解析查找惰性解析的。这导致了一些重要的设计考虑。我们通常通过类和混合类来引入方法。我们只能通过装饰器或混合类定义来引入属性。以下是一些为类构建的属性列表。一些额外的属性是元类的一部分；它们在下表中描述：
- en: '| Attribute | Contents |'
  id: totrans-2136
  prefs: []
  type: TYPE_TB
  zh: '| 属性 | 内容 |'
- en: '| --- | --- |'
  id: totrans-2137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `__doc__` | The class''s documentation string, or `None` if undefined |'
  id: totrans-2138
  prefs: []
  type: TYPE_TB
  zh: '| `__doc__` | 类的文档字符串，如果未定义则为`None` |'
- en: '| `__name__` | The class name |'
  id: totrans-2139
  prefs: []
  type: TYPE_TB
  zh: '| `__name__` | 类名 |'
- en: '| `__module__` | The module name that the class was defined in |'
  id: totrans-2140
  prefs: []
  type: TYPE_TB
  zh: '| `__module__` | 定义类的模块名称 |'
- en: '| `__dict__` | The dictionary containing the class''s namespace |'
  id: totrans-2141
  prefs: []
  type: TYPE_TB
  zh: '| `__dict__` | 包含类命名空间的字典 |'
- en: '| `__bases__` | A tuple (possibly empty or a singleton) containing the base
    classes, in the order of their occurrence in the base class list; it is used to
    work out method resolution order |'
  id: totrans-2142
  prefs: []
  type: TYPE_TB
  zh: '| `__bases__` | 一个元组（可能为空或单个元素），包含基类，按照它们在基类列表中的出现顺序；它用于计算方法解析顺序 |'
- en: '| `__class__` | The superclass of this class, often the `type` class |'
  id: totrans-2143
  prefs: []
  type: TYPE_TB
  zh: '| `__class__` | 这个类的超类，通常是`type`类 |'
- en: Some additional method functions that are part of a class include `__subclasshook__`,
    `__reduce__`, and `__reduce_ex__`, which are part of the interface for `pickle`.
  id: totrans-2144
  prefs: []
  type: TYPE_NORMAL
  zh: 一些作为类的一部分的额外方法函数包括`__subclasshook__`，`__reduce__`和`__reduce_ex__`，它们是`pickle`接口的一部分。
- en: Some class design principles
  id: totrans-2145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些类设计原则
- en: 'When defining a class, we have the following three sources of attributes and
    methods:'
  id: totrans-2146
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义一个类时，我们有以下三个属性和方法的来源：
- en: The class statement
  id: totrans-2147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类语句
- en: The decorators applied to the class definition
  id: totrans-2148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用于类定义的装饰器
- en: The mixin classes with the base class that is given last
  id: totrans-2149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后给出的基类与混合类
- en: We need to be cognizant of the level of visibility for each of these. The `class`
    statement is the most obvious source for attributes and methods. The mixins and
    the base class are somewhat less obvious than the class body. It's helpful to
    make sure that the base class name clarifies its role as essential. We've tried
    to name our base classes after real-world objects.
  id: totrans-2150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要意识到每个属性的可见级别。`class`语句是最明显的属性和方法来源。混合类和基类比类体稍微不那么明显。确保基类名称澄清其作为基本的角色是有帮助的。我们试图将基类命名为现实世界的对象。
- en: The mixin classes will generally define additional interfaces or behaviors of
    a class. It's important to be clear how the mixin classes are used to build the
    final class definitions. While a `docstring` class is an important part of this,
    the overall module `docstring` is also important to show how a proper class can
    be assembled from the various parts.
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 混合类通常会定义类的额外接口或行为。清楚地了解混合类如何用于构建最终的类定义是很重要的。虽然“docstring”类是其中的重要部分，但整个模块“docstring”也很重要，可以展示如何从各个部分组装一个合适的类。
- en: When writing the `class` statement, the essential superclass is listed last
    and the mixins are listed before that. This is not merely convention. The last
    listed class is the essential *is-a* class. The application of the decorator to
    the class will lead to somewhat more obscure features. Typically, a decorator
    will do relatively little. A strong focus on one or a few features helps to clarify
    what the decorator does.
  id: totrans-2152
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写`class`语句时，基本的超类最后列出，混合类在其之前列出。这不仅仅是约定。最后列出的类是基本的*is-a*类。将装饰器应用于类会导致一些更加晦涩的特性。通常，装饰器的作用相对较小。对一个或几个特性的强调有助于澄清装饰器的作用。
- en: Aspect-oriented programming
  id: totrans-2153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面向方面的编程
- en: 'Parts of **aspect-oriented programming** (**AOP**) are relevant to decorators.
    Our purpose here is to leverage a few aspect-oriented concepts to help show the
    purpose of decorators and mixins in Python. The idea of a **cross-cutting concern**
    is central to AOP. Here''s some additional background: [http://en.wikipedia.org/wiki/Cross-cutting_concern](http://en.wikipedia.org/wiki/Cross-cutting_concern).
    There are several common examples of cross-cutting concerns, as follows:'
  id: totrans-2154
  prefs: []
  type: TYPE_NORMAL
  zh: '**面向方面的编程**（AOP）的部分内容与装饰器相关。我们在这里的目的是利用一些面向方面的概念来帮助展示Python中装饰器和混合类的目的。横切关注的概念对AOP至关重要。以下是一些额外的背景信息：[http://en.wikipedia.org/wiki/Cross-cutting_concern](http://en.wikipedia.org/wiki/Cross-cutting_concern)。以下是一些常见的横切关注的例子：'
- en: '**Logging**: We often need to have logging features implemented consistently
    in many classes. We want to be sure the loggers are named consistently and logging
    events follow the class structure in a consistent manner.'
  id: totrans-2155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志记录**：我们经常需要在许多类中一致地实现日志记录功能。我们希望确保记录器的命名一致，并且日志事件以一致的方式遵循类结构。'
- en: '**Auditability**: A variation of the logging theme is to provide an audit trail
    that shows each transformation of a mutable object. In many commerce-oriented
    applications, the transactions are business records that represent bills or payments.
    Each step in the processing of a business record needs to be auditable to show
    that no errors have been introduced by the processing.'
  id: totrans-2156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可审计性**：日志主题的一个变种是提供一个审计跟踪，显示可变对象的每个转换。在许多面向商业的应用程序中，交易是代表账单或付款的业务记录。业务记录处理过程中的每个步骤都需要进行审计，以显示处理过程中没有引入错误。'
- en: '**Security**: Our applications will often have security aspects that pervade
    each HTTP request and each piece of content downloaded by the website. The idea
    is to confirm that each request involves an authenticated user who is authorized
    to make the request. Cookies, secure sockets, and other cryptographic techniques
    must be used consistently to assure that an entire web application is secured.'
  id: totrans-2157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：我们的应用程序经常会有安全方面的需求，涵盖每个HTTP请求和网站下载的每个内容。其目的是确认每个请求都涉及经过身份验证的用户，该用户被授权进行请求。必须一致使用Cookie、安全套接字和其他加密技术，以确保整个Web应用程序的安全。'
- en: 'Some languages and tools have deep, formal support for AOP. Python borrows
    a few of the concepts. The Pythonic approach to AOP involves the following language
    features:'
  id: totrans-2158
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言和工具对AOP有深入的正式支持。Python借鉴了一些概念。Python对AOP的方法涉及以下语言特性：
- en: '**Decorators**: With a decorator, we can establish a consistent aspect implementation
    at one of two simple join points in a function. We can perform the aspect''s processing
    before or after the existing function. We can''t easily locate join points inside
    the code of a function. It''s easiest for decorators to transform a function or
    method by wrapping it with additional functionality.'
  id: totrans-2159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**装饰器**：使用装饰器，我们可以在函数的两个简单连接点之一建立一致的方面实现。我们可以在现有函数之前或之后执行方面的处理。我们不能轻易地在函数的代码内部找到连接点。对于装饰器来说，最容易的方法是通过包装函数或方法来转换它并添加额外的功能。'
- en: '**Mixins**: With a mixin, we can define a class that exists outside a single
    class hierarchy. The mixin class can be used with other classes to provide a consistent
    implementation of a cross-cutting aspect. For this to work, the mixin API must
    be used by the classes that it is mixed into. Generally, mixin classes are considered
    abstract since they can''t be meaningfully instantiated.'
  id: totrans-2160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**混合类**：使用混合类，我们可以定义一个存在于单个类层次结构之外的类。混合类可以与其他类一起使用，以提供横切面方面的一致实现。为了使其工作，混合API必须被混合到的类使用。通常，混合类被认为是抽象的，因为它们不能有实际意义地实例化。'
- en: Using built-in decorators
  id: totrans-2161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用内置装饰器
- en: Python has several built-in decorators that are part of the language. The `@property`,
    `@classmethod`, and `@staticmethod` decorators are used to annotate methods of
    a class. The `@property` decorator transforms a method function into a descriptor.
    We use this to give a method function the syntax of a simple attribute. The property
    decorator, when applied to a method, also creates an additional pair of properties
    that can be used to create a `setter` and `deleter` property. We looked at this
    in [Chapter 3](ch03.html "Chapter 3. Attribute Access, Properties, and Descriptors"),
    *Attribute Access, Properties, and Descriptors*.
  id: totrans-2162
  prefs: []
  type: TYPE_NORMAL
  zh: Python有几个内置装饰器，它们是语言的一部分。`@property`、`@classmethod`和`@staticmethod`装饰器用于注释类的方法。`@property`装饰器将一个方法函数转换为一个描述符。我们使用这个来给一个方法函数提供一个简单属性的语法。应用到方法的属性装饰器还创建了一个额外的属性对，可以用来创建`setter`和`deleter`属性。我们在[第3章](ch03.html
    "第3章。属性访问、属性和描述符")中看到了这一点，*属性访问、属性和描述符*。
- en: 'The `@classmethod` and `@staticmethod` decorators transform a method function
    into a class-level function. The decorated method can now be called from a class,
    not an object. In the case of a static method, there''s no explicit reference
    to the class. With a class method, on the other hand, the class is the first argument
    of the method function. The following is an example of a class that includes `@staticmethod`
    and some `@property` definitions:'
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: '`@classmethod`和`@staticmethod`装饰器将一个方法函数转换为一个类级函数。装饰后的方法现在可以从一个类中调用，而不是一个对象。在静态方法的情况下，没有对类的明确引用。另一方面，对于类方法，类是方法函数的第一个参数。以下是一个包括`@staticmethod`和一些`@property`定义的类的示例：'
- en: '[PRE308]'
  id: totrans-2164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: This class defines an `Angle` that can be represented in degrees or radians.
    The constructor expects degrees. However, we've also defined a `from_radians()`
    method function that emits an instance of the class. This function does not work
    with an instance variable; it works with the class itself and returns an instance
    of the class. The `__new__()` method is implicitly a class method. A decorator
    is not used.
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类定义了一个可以用度或弧度表示的“角度”。构造函数期望度数。然而，我们还定义了一个`from_radians()`方法函数，它发出类的一个实例。这个函数不适用于实例变量；它适用于类本身，并返回类的一个实例。`__new__()`方法隐式地是一个类方法。没有使用装饰器。
- en: 'Additionally, we provide the `degrees()` and `radians()` method functions that
    have been decorated so that they are properties. Under the hood, these decorators
    create a descriptor so that accessing the attribute name `degrees` or `radians`
    will invoke the named method function. We can use the `static` method to create
    an instance and then use a `property` method to access a method function:'
  id: totrans-2166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们提供了`degrees()`和`radians()`方法函数，它们已经被装饰为属性。在底层，这些装饰器创建了一个描述符，以便访问属性名`degrees`或`radians`将调用命名的方法函数。我们可以使用`static`方法创建一个实例，然后使用`property`方法访问一个方法函数：
- en: '[PRE309]'
  id: totrans-2167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: The static method is effectively a function because it's not tied to the `self`
    instance variable. It has the advantage that it is syntactically bound to the
    class; using `Angle.from_radians` can be microscopically more helpful than using
    a function named `angle_from_radians`. The use of these decorators assures that
    the implementation is done correctly and consistently.
  id: totrans-2168
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法实际上是一个函数，因为它不与`self`实例变量绑定。它的优势在于它在语法上绑定到类；使用`Angle.from_radians`可能比使用名为`angle_from_radians`的函数微小地更有帮助。使用这些装饰器可以确保实现正确和一致。
- en: Using standard library decorators
  id: totrans-2169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用标准库装饰器
- en: 'The standard library has a number of decorators. Modules such as `contextlib`,
    `functools`, `unittest`, `atexit`, `importlib`, and `reprlib` contain decorators
    that are excellent examples of cross-cutting aspects of a software design. For
    example, the `functools` library offers the `total_ordering` decorator that defines
    comparison operators. It leverages `__eq__()` and either `__lt__()`, `__le__()`,
    `__gt__()`, or `__ge__()` to create a complete suite of comparisons. The following
    is a variation on the `Card` class that defines just two comparisons:'
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库有许多装饰器。像`contextlib`、`functools`、`unittest`、`atexit`、`importlib`和`reprlib`这样的模块包含了优秀的跨切面软件设计的装饰器示例。例如，`functools`库提供了`total_ordering`装饰器来定义比较运算符。它利用`__eq__()`和`__lt__()`、`__le__()`、`__gt__()`或`__ge__()`来创建一个完整的比较套件。以下是定义了两个比较的`Card`类的变化：
- en: '[PRE310]'
  id: totrans-2171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'Our class is wrapped by a class-level decorator, `@functools.total_ordering`.
    This decorator creates the missing method functions. We can use this class to
    create objects that can be compared using all of the comparison operators, even
    though only two were defined. Here''s an example of comparisons we''ve defined
    as well as comparisons we have not defined:'
  id: totrans-2172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的类被一个类级装饰器`@functools.total_ordering`包装。这个装饰器创建了缺失的方法函数。我们可以使用这个类来创建可以使用所有比较运算符进行比较的对象，即使只定义了两个。以下是我们定义的比较的示例，以及我们没有定义的比较：
- en: '[PRE311]'
  id: totrans-2173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: This interaction shows that we are able to make comparisons that are not defined
    in the original class. The decorator added method functions to the original class
    definition.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个交互显示了我们能够进行未在原始类中定义的比较。装饰器为原始类定义添加了方法函数。
- en: Using standard library mixin classes
  id: totrans-2175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用标准库混合类
- en: The standard library makes use of mixin class definitions. There are several
    modules that contain examples, including `io`, `socketserver`, `urllib.request`,
    `contextlib`, and `collections.abc`.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库使用了混合类定义。有几个模块包含了示例，包括`io`、`socketserver`、`urllib.request`、`contextlib`和`collections.abc`。
- en: When we define our own collection based on the `collections.abc` abstract base
    classes, we're making use of mixins to assure that cross-cutting aspects of the
    containers are defined consistently. The top-level collections (`Set`, `Sequence`,
    and `Mapping`) are all built from multiple mixins. It's very important to look
    at section 8.4 of the *Python Standard Library* to see how the mixins contribute
    features, as the overall structure is built up from pieces.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们基于`collections.abc`抽象基类定义自己的集合时，我们利用混合来确保容器的交叉切面方面得到一致的定义。顶层集合（`Set`、`Sequence`和`Mapping`）都是由多个混合构建的。非常重要的是要查看*Python标准库*的第8.4节，看看混合如何贡献特性，因为整体结构是由各个部分构建起来的。
- en: Looking at just one line, the summary of `Sequence`, we see that it inherits
    from `Sized`, `Iterable`, and `Container`. These mixin classes lead to methods
    of `__contains__()`, `__iter__()`, `__reversed__()`, `index()`, and `count()`.
  id: totrans-2178
  prefs: []
  type: TYPE_NORMAL
  zh: 仅看一行，`Sequence`的摘要，我们看到它继承自`Sized`、`Iterable`和`Container`。这些混合类导致了`__contains__()`、`__iter__()`、`__reversed__()`、`index()`和`count()`方法。
- en: Using the context manager mixin class
  id: totrans-2179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用上下文管理器混合类
- en: When we looked at context managers in [Chapter 5](ch05.html "Chapter 5. Using
    Callables and Contexts"), *Using Callables and Contexts*, we ignored the `ContextDecorator`
    mixin and focused on the special methods themselves. Using the mixin can make
    the definition clearer.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第5章](ch05.html "第5章。使用可调用和上下文")中看上下文管理器时，*使用可调用和上下文*，我们忽略了`ContextDecorator`混合，而是专注于特殊方法本身。使用混合可以使定义更清晰。
- en: Tip
  id: totrans-2181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In the previous version of the example, we created a context manager that altered
    a global state; it reset the random number seed. We'll rework that design to make
    a deck that can be its own context manager. When used as a context manager, it
    can generate a fixed sequence of cards. This isn't really the best way to unit
    test a deck of cards. However, it's a simple use of a context manager.
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例版本中，我们创建了一个改变全局状态的上下文管理器；它重置了随机数种子。我们将重新设计该设计，使得一副牌可以成为自己的上下文管理器。当作为上下文管理器使用时，它可以生成一系列固定的牌。这并不是测试一副牌的最佳方式。然而，这是上下文管理器的一个简单用法。
- en: 'Defining context management as a mixin of an application class requires some
    care. We may have to redesign the initialization method to remove some assumptions.
    Our application classes may be used in the following two distinct ways:'
  id: totrans-2183
  prefs: []
  type: TYPE_NORMAL
  zh: 将上下文管理定义为应用类的混合需要一些小心。我们可能需要重新设计初始化方法以去除一些假设。我们的应用类可以以以下两种不同的方式使用：
- en: When used outside a `with` statement, the `__enter__()` and `__exit__()` methods
    will not be evaluated
  id: totrans-2184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在`with`语句之外使用时，`__enter__()`和`__exit__()`方法将不会被评估
- en: When used inside a `with` statement, the `__enter__()` and `__exit__()` methods
    will be evaluated
  id: totrans-2185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在`with`语句中使用时，`__enter__()`和`__exit__()`方法将被评估
- en: 'In our case, we can''t assume that it''s valid to evaluate the `shuffle()`
    method during `__init__()` processing because we don''t know whether or not the
    context manager methods will be used. We can''t defer shuffling to `__enter__()`
    because it may not be used. This complexity may indicate that we''re offering
    too much flexibility. Either we have to shuffle lazily, just before the first
    `pop()`, or we have to provide a method function that can be turned off by a subclass.
    The following is a simple `Deck` definition that extends `list`:'
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们不能假设在`__init__()`处理期间评估`shuffle()`方法是有效的，因为我们不知道上下文管理器方法是否会被使用。我们不能将洗牌推迟到`__enter__()`，因为它可能不会被使用。这种复杂性可能表明我们提供了太多的灵活性。要么我们必须懒洋洋地洗牌，就在第一次`pop()`之前，要么我们必须提供一个可以被子类关闭的方法函数。以下是一个扩展`list`的简单`Deck`定义：
- en: '[PRE312]'
  id: totrans-2187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'We''ve defined this deck to have a removable `_init_shuffle()` method. A subclass
    can override this method to change when the shuffling is complete. A subclass
    of `Deck` can seed the random number generator before shuffling. This version
    of the class can avoid shuffling during creation. The following is a subclass
    of `Deck` that includes the `contextlib.ContextDecorator` mixin:'
  id: totrans-2188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了这个牌组有一个可移除的`_init_shuffle()`方法。子类可以重写这个方法来改变何时洗牌完成。`Deck`的子类可以在洗牌之前设置随机数生成器的种子。这个版本的类可以避免在创建时洗牌。以下是包含`contextlib.ContextDecorator`混入的`Deck`的子类：
- en: '[PRE313]'
  id: totrans-2189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: This subclass prevents shuffling during initialization by overriding the `_init_shuffle()`
    method. Because this mixes in `ContextDecorator`, it must also define `__enter__()`
    and `__exit__()`. This subclass of `Deck` can work in a `with` context. When used
    in a `with` statement, the random number seed is set, and the shuffling will use
    a known sequence. If it's used outside a `with` statement, then the shuffling
    will use the current random number settings and there will be no `__enter__()`
    evaluation.
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子类通过重写`_init_shuffle()`方法来防止初始化期间的洗牌。因为它混入了`ContextDecorator`，所以它还必须定义`__enter__()`和`__exit__()`。`Deck`的这个子类可以在`with`上下文中工作。在`with`语句中使用时，随机数种子被设置，洗牌将使用已知的序列。如果在`with`语句之外使用，那么洗牌将使用当前的随机数设置，并且不会进行`__enter__()`评估。
- en: 'The purpose of this style of programming is to separate the truly essential
    features of a class from other aspects of the `Deck` implementation. We have separated
    some of the random seed processing from other aspects of `Deck`. Clearly, we can
    simplify things a great deal if we simply insist that a context manager is required.
    This is not typical of the way the `open()` function works. However, it can be
    helpful simplification. We can use examples like the following to see the differences
    in behavior:'
  id: totrans-2191
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程风格的目的是将类的真正基本特征与`Deck`实现的其他方面分开。我们已经将一些随机种子处理与`Deck`的其他方面分开。显然，如果我们坚持要求使用上下文管理器，我们可以大大简化事情。这并不是`open()`函数的典型工作方式。然而，这可能是一个有用的简化。我们可以使用以下示例来查看行为上的差异：
- en: '[PRE314]'
  id: totrans-2192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'This example shows how `Deck` can be used by itself to generate randomized
    shuffles. This is the simple use of having `Deck` produce shuffled cards. The
    next example shows `TestDeck` with a given seed:'
  id: totrans-2193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了`Deck`如何单独使用来生成随机洗牌。这是使用`Deck`生成洗牌卡片的简单用法。下一个例子展示了带有给定种子的`TestDeck`：
- en: '[PRE315]'
  id: totrans-2194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: This shows `TestDeck`, the subclass of `Deck`, which is used as a context manager
    to produce a known sequence of cards. Each time we invoke it, we get the same
    sequence of cards.
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 这展示了`TestDeck`，`Deck`的子类，它被用作上下文管理器来生成一系列已知的卡片。每次调用它，我们都会得到相同的卡片序列。
- en: Turning off a class feature
  id: totrans-2196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭类功能
- en: 'We''ve turned off the shuffle-during-initialization feature by redefining a
    method function to have a body of `pass`. This process may seem a bit long winded
    to remove a feature from a subclass. There''s an alternative to remove functionality
    in a subclass: to set the method name to be `None`. We can do this inside `TestDeck`
    to remove the initial shuffle:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过重新定义一个方法函数的主体为`pass`来关闭初始化期间的洗牌功能。这个过程可能看起来有点冗长，以便从子类中删除一个功能。在子类中删除功能的另一种方法是将方法名称设置为`None`。我们可以在`TestDeck`中这样做来移除初始洗牌：
- en: '[PRE316]'
  id: totrans-2198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'The preceding code requires a little more programming in the superclass to
    tolerate the missing method, which is shown in the following snippet:'
  id: totrans-2199
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码需要在超类中进行一些额外的编程来容忍缺失的方法，这在以下片段中显示：
- en: '[PRE317]'
  id: totrans-2200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: This can be a somewhat more explicit way to remove a feature in a subclass definition.
    This shows that the method could be missing or has intentionally been set to `None`.
    Yet another alternative design is to move the call to `_init_shuffle()` from `__init__()`
    to the `__enter__()` method. This will require the use of a context manager that
    will make the object behave properly. That's not too odious a burden if it's documented
    clearly.
  id: totrans-2201
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是在子类定义中删除一个功能的一种更加明确的方式。这表明该方法可能丢失，或者已经被故意设置为`None`。另一种替代设计是将对`_init_shuffle()`的调用从`__init__()`移动到`__enter__()`方法。这将需要使用上下文管理器来使对象正常工作。如果清楚地记录下来，这并不是太繁琐的负担。
- en: Writing a simple function decorator
  id: totrans-2202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个简单的函数装饰器
- en: 'A `decorator` function is a function (or a callable object) that returns a
    new function. The simplest case involves a single argument: the function that
    is to be decorated. The result of a decorator is a function that has been wrapped.
    Essentially, the additional features are put either before or after the original
    functionality. These are the two readily available join points in a function.'
  id: totrans-2203
  prefs: []
  type: TYPE_NORMAL
  zh: '`decorator`函数是一个返回新函数的函数（或可调用对象）。最简单的情况涉及一个参数：要装饰的函数。装饰器的结果是一个已经包装过的函数。基本上，额外的功能要么放在原始功能之前，要么放在原始功能之后。这是函数中两个可用的连接点。'
- en: When we define a decorator, we want to be sure that the decorated function has
    the original function's name and `docstring`. These attributes should be set by
    a decorator, which we will use to write the decorated functions. Using `functools.wraps`
    to write new decorators simplifies the work we need to do because this bit of
    bookkeeping is handled for us.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个装饰器时，我们希望确保装饰的函数具有原始函数的名称和`docstring`。这些属性应该由装饰器设置，我们将使用它们来编写装饰的函数。使用`functools.wraps`编写新装饰器可以简化我们需要做的工作，因为这部分繁琐的工作已经为我们处理了。
- en: 'To illustrate the two places where functionality can be inserted, we can create
    a debug trace decorator that will log parameters and return values from a function.
    This puts functionality both before and after the called function. The following
    is some defined function, `some_function`, that we want to wrap:'
  id: totrans-2205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明功能可以插入的两个位置，我们可以创建一个调试跟踪装饰器，它将记录函数的参数和返回值。这将在调用函数之前和之后放置功能。以下是我们想要包装的一些定义的函数，`some_function`：
- en: '[PRE318]'
  id: totrans-2206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: This snippet shows how we'll have new processing to wrap the original function.
  id: totrans-2207
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码显示了我们将有新的处理来包装原始函数。
- en: 'It''s difficult to insert processing into a defined function by poking at the
    underlying `__code__` object. In the rare case where it seems necessary to inject
    an aspect in the middle of a function, it''s much easier to rewrite the function
    as a callable object, by breaking the functionality down into multiple method
    functions. Then, we can use mixin and subclass definitions rather than complex
    code rewriting. The following is a debug decorator that inserts logging before
    and after function evaluation:'
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 通过戳击底层的`__code__`对象很难在定义的函数中插入处理。在极少数情况下，似乎有必要在函数中间注入一个方面时，将函数重写为可调用对象要容易得多，通过将功能分解为多个方法函数。然后，我们可以使用混合和子类定义，而不是复杂的代码重写。以下是一个调试装饰器，在函数评估之前和之后插入日志记录：
- en: '[PRE319]'
  id: totrans-2209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'We''ve used the `functools.wraps` decorator to assure that the original function
    name and `docstring` are preserved in the result function. Now, we can use our
    decorator to produce noisy, detailed debugging. For example, we can do this to
    apply the decorator to some function, `ackermann()`, as follows:'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用`functools.wraps`装饰器来确保原始函数的名称和`docstring`在结果函数中得到保留。现在，我们可以使用我们的装饰器来产生嘈杂、详细的调试。例如，我们可以这样做，将装饰器应用于某个函数`ackermann()`：
- en: '[PRE320]'
  id: totrans-2211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'This definition wraps the `ackermann()` function with debugging information
    written via the logging module to the `root` logger. We configure the logger to
    produce the following debugging output:'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 此定义使用日志模块将调试信息写入`root`记录器，以调试`ackermann()`函数。我们配置记录器以生成以下调试输出：
- en: '[PRE321]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'We''ll revisit logging in detail in [Chapter 14](ch14.html "Chapter 14. The
    Logging and Warning Modules"), *The Logging and Warning Modules*. We''ll see this
    kind of result when we evaluate `ackermann(2,4)`:'
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[第14章](ch14.html "第14章。日志和警告模块")中详细讨论日志记录，*日志和警告模块*。当我们评估`ackermann(2,4)`时，我们将看到这种结果：
- en: '[PRE322]'
  id: totrans-2215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Creating separate loggers
  id: totrans-2216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建单独的记录器
- en: 'As a logging optimization, we might want to use a specific logger for each
    wrapped function and not overuse the root logger for this kind of debugging output.
    We''ll return to the logger in [Chapter 14](ch14.html "Chapter 14. The Logging
    and Warning Modules"), *The Logging and Warning Modules*. The following is a version
    of our decorator that creates a separate logger for each individual function:'
  id: totrans-2217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为日志优化，我们可能希望为每个包装的函数使用特定的记录器，而不是过度使用根记录器进行此类调试输出。我们将在[第14章](ch14.html "第14章。日志和警告模块")中返回记录器，*日志和警告模块*。以下是我们的装饰器的一个版本，它为每个单独的函数创建一个单独的记录器：
- en: '[PRE323]'
  id: totrans-2218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: 'This version modifies the output to look like the following:'
  id: totrans-2219
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本修改了输出，看起来像这样：
- en: '[PRE324]'
  id: totrans-2220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: The function name is now the logger name. This can be used to fine-tune the
    debugging output. We can now enable logging for individual functions. We can't
    trivially change the decorator and expect the decorated function to also change.
  id: totrans-2221
  prefs: []
  type: TYPE_NORMAL
  zh: 函数名现在是记录器名称。这可以用于微调调试输出。我们现在可以为单个函数启用日志记录。我们不能轻易更改装饰器并期望装饰的函数也会改变。
- en: We need to apply the revised decorator to the function. This means that debugging
    and experimenting with decorators can't be done *trivially* from the `>>>` interactive
    prompt. We have to reload the function definitions after we tweak the decorator
    definition. This can involve a bunch of copy and paste, or it can involve rerunning
    a script that defines the decorator, the functions, and then runs tests or a demonstration
    script to show that everything works as expected.
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将修改后的装饰器应用于函数。这意味着无法从`>>>`交互提示符轻松地进行调试和实验。我们必须在调整装饰器定义后重新加载函数定义。这可能涉及大量的复制和粘贴，或者可能涉及重新运行定义装饰器、函数，然后运行测试或演示脚本以展示一切都按预期工作。
- en: Parameterizing a decorator
  id: totrans-2223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 给装饰器加参数
- en: Sometimes we want to provide more elaborate parameters to a decorator. The idea
    is that we are going to customize the wrapping function. When we do this, decoration
    becomes a two-step process.
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们想要为装饰器提供更复杂的参数。想法是我们将要定制包装函数。当我们这样做时，装饰变成了一个两步过程。
- en: 'When we write the following code, we provide a parameterized decorator to a
    function definition:'
  id: totrans-2225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写以下代码时，我们为函数定义提供了一个带参数的装饰器：
- en: '[PRE325]'
  id: totrans-2226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'The use of the decorator is a shorthand for the following code:'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的使用是以下代码的简写：
- en: '[PRE326]'
  id: totrans-2228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Both examples do the following three things:'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个示例都做了以下三件事：
- en: Defined a function, `func`
  id: totrans-2230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义了一个函数，`func`
- en: Applied the abstract decorator to its arguments to create a concrete decorator,
    `decorator(arg)`
  id: totrans-2231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将抽象装饰器应用于其参数，以创建具体装饰器，`decorator(arg)`
- en: Applied the concrete decorator to the defined function to create the decorated
    version of the function, `decorator(arg)(func)`
  id: totrans-2232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将定义的函数应用具体装饰器，以创建函数的装饰版本，`decorator(arg)(func)`
- en: 'This means that a decorator with arguments will require indirect construction
    of the final function. Let''s tweak our debugging decorator yet again. We''d like
    to do the following:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着带有参数的装饰器将需要间接构造最终函数。让我们再次微调我们的调试装饰器。我们想要做以下事情：
- en: '[PRE327]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'This kind of code allows us to specifically name the log that the debugging
    output will go to. We don''t use the root logger nor default to a distinct logger
    for each function. The outline of a parameterized decorator is something like
    the following:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码允许我们明确命名调试输出将要进入的日志。我们不使用根记录器，也不默认为每个函数使用不同的记录器。参数化装饰器的概要如下所示：
- en: '[PRE328]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'Let''s peel back the layers of this onion before looking at the example. The
    decorator definition (`def decorator(config)`) shows the parameters we will provide
    to the decorator when we use it. The body of this is the concrete decorator, which
    is returned. The concrete decorator (`def concrete_decorator(function)`) is the
    decorator that will be applied to the target function. This, then, is just like
    the simple function decorator shown in the previous section. It builds the wrapped
    function (`def wrapped(*args, **kw)`), which it returns. The following is our
    named logger version of debug:'
  id: totrans-2237
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看示例之前，让我们先剥开这个装饰器的层层皮。装饰器定义（`def decorator(config)`）显示了我们在使用装饰器时将提供的参数。其中的具体装饰器是返回的具体装饰器。具体装饰器（`def
    concrete_decorator(function)`）是将应用于目标函数的装饰器。这与前一节中显示的简单函数装饰器一样。它构建了包装函数（`def wrapped(*args,
    **kw)`），然后返回它。以下是我们命名的调试版本：
- en: '[PRE329]'
  id: totrans-2238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'This `decorator` function accepts an argument that is the name of the log to
    use. It creates and returns a concrete decorator function. When this is applied
    to a function, the concrete decorator returns the wrapped version of the given
    function. When the function is used in the following manner, the decorator adds
    noisy debug lines. They direct the output to a log named `recursion` as follows:'
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`decorator`函数接受一个参数，即要使用的日志的名称。它创建并返回一个具体装饰器函数。当这个函数应用于一个函数时，具体装饰器返回给定函数的包装版本。当函数以以下方式使用时，装饰器会添加嘈杂的调试行。它们将输出到名为`recursion`的日志中，如下所示：
- en: '[PRE330]'
  id: totrans-2240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: Creating a method function decorator
  id: totrans-2241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建方法函数装饰器
- en: A decorator for a method function of a class definition is identical to a decorator
    for a standalone function. It's simply used in a different context. One small
    consequence of this different context is that we often must explicitly name the
    `self` variable.
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义的方法函数的装饰器与独立函数的装饰器是相同的。它只是在不同的上下文中使用。这种不同上下文的一个小后果是，我们经常必须明确命名`self`变量。
- en: One application for method function decoration is to produce an audit trail
    for object state change. Business applications often create stateful records;
    commonly, these are represented as rows in a relational database. We'll look at
    object representation in [Chapter 9](ch09.html "Chapter 9. Serializing and Saving
    – JSON, YAML, Pickle, CSV, and XML"), *Serializing and Saving – JSON, YAML, Pickle,
    CSV, and XML*, [Chapter10](ch10.html "Chapter 10. Storing and Retrieving Objects
    via Shelve"), *Storing and Retrieving Objects via Shelve*, and [Chapter 11](ch11.html
    "Chapter 11. Storing and Retrieving Objects via SQLite"), *Storing and Retrieving
    Objects via SQLite*.
  id: totrans-2243
  prefs: []
  type: TYPE_NORMAL
  zh: 方法函数装饰的一个应用是为对象状态变化产生审计跟踪。业务应用程序通常创建有状态记录；通常情况下，这些记录在关系数据库中表示为行。我们将在[第9章](ch09.html
    "第9章。序列化和保存 - JSON、YAML、Pickle、CSV和XML")中查看对象表示，*序列化和保存 - JSON、YAML、Pickle、CSV和XML*，[第10章](ch10.html
    "第10章。通过Shelve存储和检索对象")，*通过Shelve存储和检索对象*，和[第11章](ch11.html "第11章。通过SQLite存储和检索对象")，*通过SQLite存储和检索对象*。
- en: Note
  id: totrans-2244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we have stateful records, the state changes need to be auditable. An audit
    can confirm that appropriate changes have been made to the records. In order to
    do the audit, the before and after version of each record must be available somewhere.
    Stateful database records are a long-standing tradition but are not in any way
    required. Immutable database records are a viable design alternative.
  id: totrans-2245
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有有状态的记录时，状态变化需要进行审计。审计可以确认记录已经进行了适当的更改。为了进行审计，每个记录的之前和之后版本必须在某个地方可用。有状态的数据库记录是一个长期的传统，但并不是必需的。不可变的数据库记录是一个可行的设计替代方案。
- en: 'When we design a stateful class, any setter method we write will cause a state
    change. These setter methods often use the `@property` decorator so that they
    appear to be simple attributes. If we do this, we can fold in an `@audit` decorator
    that can track changes to the object, so that we have a proper trail of changes.
    We''ll create an audit log via the `logging` module. We''ll use the `__repr__()`
    method function to produce a complete text representation that can be used to
    examine changes. The following is an audit decorator:'
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们设计有状态的类时，我们编写的任何setter方法都会导致状态变化。这些setter方法通常使用`@property`装饰器，以便它们看起来像简单的属性。如果我们这样做，我们可以加入一个`@audit`装饰器，用于跟踪对象的更改，以便我们有一个正确的更改记录。我们将通过`logging`模块创建审计日志。我们将使用`__repr__()`方法函数生成一个完整的文本表示，用于检查更改。以下是一个审计装饰器：
- en: '[PRE331]'
  id: totrans-2247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'We''ve created a text memento of the *before* version of the object. Then,
    we''ve applied the original method function. If there was an exception, we would
    produce an audit log that includes the exception details. Otherwise, we''ll produce
    an `INFO` entry in the log that has the qualified name of the method, the before
    memento, and the after memento of the object being changed. The following is a
    modification of the `Hand` class that shows how we''d use this decorator:'
  id: totrans-2248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了对象的*之前*版本的文本备忘录。然后，我们应用了原始方法函数。如果出现异常，我们将生成包含异常详细信息的审计日志。否则，我们将在日志中产生一个`INFO`条目，其中包含方法的限定名称、更改前备忘录和更改后备忘录。以下是显示如何使用此装饰器的`Hand`类的修改：
- en: '[PRE332]'
  id: totrans-2249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: This definition modifies the `__iadd__()` method function, so that adding a
    card becomes an auditable event. This decorator will perform the audit operation,
    saving text mementos of `Hand` before and after the operation.
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义修改了`__iadd__()`方法函数，使得添加一张卡变成了一个可审计的事件。这个装饰器将执行审计操作，保存`Hand`操作前后的文本备忘录。
- en: This use of a method decorator makes a formal declaration that a particular
    method function has made a significant state change. We can easily use code reviews
    to be sure that all of the appropriate method functions are marked for audit like
    this. An open issue is auditing object creation. It's not perfectly clear that
    object creation requires an audit record. It can be argued that object creation
    is not a state change.
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法装饰器的使用正式声明了一个特定的方法函数已经进行了重大的状态改变。我们可以轻松地使用代码审查来确保所有适当的方法函数都被标记为像这样的审核。一个悬而未决的问题是审核对象的创建。并不十分清楚对象的创建是否需要审核记录。可以争论说对象的创建不是状态改变。
- en: 'In the event that we want to audit creation, we can''t use this `audit` decorator
    on the `__init__()` method function. That''s because there''s no before image
    prior to the execution of `__init__()`. There are two things we can do as a remedy
    to this, as follows:'
  id: totrans-2252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要审核创建，我们不能在`__init__()`方法函数上使用这个`audit`装饰器。因为在执行`__init__()`之前没有之前的图像。我们可以采取两种补救措施，如下所示：
- en: We can add a `__new__()` method that assures that an empty `_cards` attribute
    is seeded into the class as an empty collection
  id: totrans-2253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以添加一个`__new__()`方法，确保将一个空的`_cards`属性作为一个空集合添加到类中
- en: We can tweak the `audit()` decorator to tolerate `AttributeError` that will
    arise when `__init__()` is being processed
  id: totrans-2254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以调整`audit()`装饰器以容忍`AttributeError`，这将在处理`__init__()`时出现
- en: 'The second option is considerably more flexible. We can do the following:'
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项更加灵活。我们可以这样做：
- en: '[PRE333]'
  id: totrans-2256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'This would record a message such as `AttributeError: ''Hand'' object has no
    attribute ''_cards''` for the before status during initialization.'
  id: totrans-2257
  prefs: []
  type: TYPE_NORMAL
  zh: '这将记录一条消息，例如`AttributeError: ''Hand'' object has no attribute ''_cards''`，用于初始化期间的前状态。'
- en: Creating a class decorator
  id: totrans-2258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个类装饰器
- en: Analogous to decorating a function, we can write a class decorator to add features
    to a class definition. The essential rules are the same. The decorator is a function
    (or callable object). It receives a class object as an argument and returns a
    class object as a result.
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于装饰函数，我们可以编写一个类装饰器来为类定义添加功能。基本规则是相同的。装饰器是一个函数（或可调用对象）。它接收一个类对象作为参数，并返回一个类对象作为结果。
- en: We have a limited number of join points inside a class definition as a whole.
    For the most part, a class decorator will fold additional attributes into a class
    definition. It's technically possible to create a new class that wraps an original
    class definition. This is challenging, since the wrapping class must be very generalized.
    It's also possible to create a new class that is a subclass of the decorated class
    definition. This may be baffling to users of the decorator. It's also possible
    to delete features from a class definition, which seems perfectly awful.
  id: totrans-2260
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个类定义中，我们有有限的连接点。在大多数情况下，类装饰器会将额外的属性合并到类定义中。从技术上讲，可以创建一个包装原始类定义的新类。这是具有挑战性的，因为包装类必须非常通用。还可以创建一个是装饰类定义的子类的新类。这可能会让装饰器的用户感到困惑。还可以从类定义中删除功能，这似乎非常糟糕。
- en: One sophisticated class decorator was shown previously. The `functools.Total_Ordering`
    decorator injects a number of new method functions into the class definition.
    The technique used in this implementation is to create lambda objects and assign
    them to attributes of the class.
  id: totrans-2261
  prefs: []
  type: TYPE_NORMAL
  zh: 之前展示了一个复杂的类装饰器。`functools.Total_Ordering`装饰器将一些新的方法函数注入到类定义中。这个实现中使用的技术是创建lambda对象并将它们分配给类的属性。
- en: 'We''ll look at a somewhat simpler decorator. During debugging and logging,
    we could have a small problem creating loggers that are focused on our classes.
    Often, we''d like to have a unique logger for each class. We''re often forced
    to do something like the following:'
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看一个稍微简单的装饰器。在调试和记录日志期间，我们可能会遇到一个小问题，即创建专注于我们的类的记录器。通常，我们希望每个类都有一个唯一的记录器。我们经常被迫做类似以下的事情：
- en: '[PRE334]'
  id: totrans-2263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: This class has the disadvantage that it creates a `logger` instance variable
    that's really not part of the class's operation, but is a separate aspect of the
    class. We'd like to avoid polluting the class with this additional aspect. That's
    not all. Even though `logging.getLogger()` is very efficient, the cost's nonzero.
    We'd like to avoid this additional overhead every time we create an instance of
    `UglyClass1`.
  id: totrans-2264
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的缺点是它创建了一个`logger`实例变量，它实际上并不是类的操作的一部分，而是类的一个独立方面。我们希望避免用这个额外的方面来污染类。而且，尽管`logging.getLogger()`非常高效，但成本是非零的。我们希望避免在每次创建`UglyClass1`的实例时都产生这种额外的开销。
- en: 'Here''s a slightly better version. The logger is promoted to be a class-level
    instance variable and is separate from each individual object of the class:'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个稍微更好的版本。记录器被提升为类级实例变量，并且与类的每个单独对象分开：
- en: '[PRE335]'
  id: totrans-2266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'This has the advantage that it implements `logging.getLogger()` just once.
    However, it suffers from a profound DRY problem. We can''t automatically set the
    class name within the class definition. The class hasn''t been created yet, so
    we''re forced to repeat the name. The DRY problem is solved by a small decorator
    as follows:'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是只实现了一次`logging.getLogger()`。然而，它存在一个严重的DRY问题。我们无法在类定义中自动设置类名。因为类还没有被创建，所以我们被迫重复类名。通过一个小装饰器解决了DRY问题，如下所示：
- en: '[PRE336]'
  id: totrans-2268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'This decorator tweaks the class definition to add the `logger` reference as
    a class-level attribute. Now, each method can use `self.logger` to produce audit
    or debug information. When we want to use this feature, we can use the `@logged`
    decorator on the class as a whole. The following is an example of a logged class,
    `SomeClass`:'
  id: totrans-2269
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器调整了类定义，将`logger`引用作为类级属性添加进去。现在，每个方法都可以使用`self.logger`来生成审计或调试信息。当我们想要使用这个功能时，我们可以在整个类上使用`@logged`装饰器。以下是一个已记录的类`SomeClass`的示例：
- en: '[PRE337]'
  id: totrans-2270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: Now, our class has a `logger` attribute that can be used by any method. The
    logger value is not a feature of the object, which keeps this aspect separated
    from the rest of the class aspects. This attribute has the added benefit that
    it creates the logger instances during module import, reducing the overhead of
    logging slightly. Let's compare this with `UglyClass1`, where `logging.getLogger()`
    was evaluated for each instance creation.
  id: totrans-2271
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的类有一个`logger`属性，可以被任何方法使用。日志记录器的值不是对象的特性，这使得这个方面与类的其余方面分离开来。这个属性的附加好处是它在模块导入期间创建了日志记录器实例，稍微减少了日志记录的开销。让我们将其与`UglyClass1`进行比较，其中`logging.getLogger()`在每个实例创建时都会被评估。
- en: Adding method functions to a class
  id: totrans-2272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向类添加方法函数
- en: 'A class decorator creates new method functions using a two-step process: by
    creating the method function and then inserting it into the class definition.
    This is often better done via a mixin class than a decorator. The obvious and
    expected use of a mixin is to insert methods. Inserting methods another way is
    less obvious and can be astonishing.'
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器通过两步过程创建新的方法函数：创建方法函数，然后将其插入类定义中。这通常比通过装饰器更好地通过混入类来完成。混入的明显和预期的用途是插入方法。以另一种方式插入方法不太明显，可能会令人惊讶。
- en: In the example of the `Total_Ordering` decorator, the exact method functions
    inserted were flexible and depended on what was already provided. This was a kind
    of special case that was typical but also very clever.
  id: totrans-2274
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Total_Ordering`装饰器的例子中，插入的确切方法函数是灵活的，并且取决于已经提供的内容。这是一种典型但非常聪明的特殊情况。
- en: 'We might want to define a standardized `memento()` method. We''d like to include
    this standard method function in a variety of classes. We''ll look at the decorator
    and mixin versions of this design. The following is the decorator version of adding
    a standard method:'
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能想要定义一个标准的`memento()`方法。我们希望在各种类中包含这个标准方法函数。我们将看一下装饰器和混入版本的设计。以下是添加标准方法的装饰器版本：
- en: '[PRE338]'
  id: totrans-2276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'This decorator includes a method function definition that is inserted into
    the class. The following is how we use this `@memento` decorator to add a method
    function to a class:'
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 这个装饰器包括一个插入到类中的方法函数定义。以下是我们如何使用`@memento`装饰器向类添加方法函数：
- en: '[PRE339]'
  id: totrans-2278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'The decorator incorporates a new method, `memento()`, into the decorated class.
    However, this has the following disadvantages:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器将一个新方法`memento()`合并到装饰类中。然而，这有以下缺点：
- en: We can't override the implementation of the `memento()` method function to handle
    special cases. It's built into the class *after* the definition.
  id: totrans-2280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能覆盖`memento()`方法函数的实现以处理特殊情况。它是在类的定义之后构建的。
- en: We can't extend the decorator function easily. We'd have to upgrade to a callable
    object to provide extensions or specializations. If we're going to upgrade to
    a callable object, we should discard this whole approach and use a mixin to add
    the method.
  id: totrans-2281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不能轻易地扩展装饰器函数。我们必须升级为可调用对象以提供扩展或特殊化。如果我们要升级为可调用对象，我们应该放弃这种方法，并使用混入来添加方法。
- en: 'The following is the mixin class that adds a standard method:'
  id: totrans-2282
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是添加标准方法的混入类：
- en: '[PRE340]'
  id: totrans-2283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'The following is how we use this `Memento` mixin class to define an application
    class:'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们如何使用`Memento`混入类来定义一个应用程序类：
- en: '[PRE341]'
  id: totrans-2285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: The mixin provides a new method, `memento()`; this is the expected, typical
    purpose of a mixin. We can more easily extend the `Memento` mixin class to add
    features. In addition, we can override the `memento()` method function to handle
    special cases.
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 混入提供了一个新方法`memento()`；这是混入的预期和典型目的。我们可以更容易地扩展`Memento`混入类以添加功能。此外，我们可以覆盖`memento()`方法函数以处理特殊情况。
- en: Using decorators for security
  id: totrans-2287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用装饰器进行安全性
- en: Software is filled with cross-cutting concerns, aspects that need to be implemented
    consistently even if they're in separate class hierarchies. It's often a mistake
    to try and impose a class hierarchy around a cross-cutting concern. We've looked
    at a few examples, such as logging and auditing.
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 软件充满了横切关注点，需要一致地实现，即使它们在不同的类层次结构中。试图在横切关注点周围强加一个类层次结构通常是错误的。我们已经看过一些例子，比如日志记录和审计。
- en: We can't reasonably demand that every class that might need to write to the
    log also be a subclass of some `loggable` superclass. We can design a `loggable`
    mixin or a `loggable` decorator. These don't interfere with the proper inheritance
    hierarchy that we need to design to make polymorphism work correctly.
  id: totrans-2289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能合理地要求每个可能需要写入日志的类也是某个`loggable`超类的子类。我们可以设计一个`loggable`混入或一个`loggable`装饰器。这些不会干扰我们需要设计的正确继承层次结构，以使多态性正常工作。
- en: 'Some important cross-cutting concerns revolve around security. Within a web
    application, there are two sides to the security question as follows:'
  id: totrans-2290
  prefs: []
  type: TYPE_NORMAL
  zh: 一些重要的横切关注点围绕着安全性。在Web应用程序中，安全问题有两个方面，如下所示：
- en: '**Authentication**: Do we know who''s making the request?'
  id: totrans-2291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**认证**：我们知道谁在发出请求吗？'
- en: '**Authorization**: Is the authenticated user allowed to make the request?'
  id: totrans-2292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：经过认证的用户是否被允许发出请求？'
- en: 'Some web frameworks allow us to decorate our request handlers with security
    requirements. The Django framework, for example, has a number of decorators that
    allow us to specify security requirements for a view function or a view class.
    Some of these decorators are as follows:'
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Web框架允许我们使用安全要求装饰我们的请求处理程序。例如，Django框架有许多装饰器，允许我们为视图函数或视图类指定安全要求。其中一些装饰器如下：
- en: '`user_passes_test`: This is a low-level decorator that''s very generalized
    and is used to build the other two decorators. It requires a test function; the
    logged-in `User` object associated with the request must pass the given function.
    If the `User` instance is not able to pass the given test, they''re redirected
    to a login page so that the person can provide the credentials required to make
    the request.'
  id: totrans-2294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user_passes_test`：这是一个低级别的装饰器，非常通用，用于构建其他两个装饰器。它需要一个测试函数；与请求相关联的已登录的`User`对象必须通过给定的函数。如果`User`实例无法通过给定的测试，它们将被重定向到登录页面，以便用户提供所需的凭据来发出请求。'
- en: '`login_required`: This decorator is based on `user_passes_test`. It confirms
    that the logged-in user is authenticated. This kind of decorator is used on web
    requests that apply to all people accessing the site. Requests such as changing
    a password or logging out, for example, shouldn''t require any more specific permissions.'
  id: totrans-2295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login_required`：这个装饰器基于`user_passes_test`。它确认已登录用户已经通过身份验证。这种装饰器用于适用于所有访问站点的人的Web请求。例如，更改密码或注销登录等请求不应需要更具体的权限。'
- en: '`permission_required`: This decorator works with Django''s internally defined
    database permission scheme. It confirms that the logged-in user (or the user''s
    group) is associated with the given permission. This kind of decorator is used
    on web requests where specific administrative permissions are required to make
    the request.'
  id: totrans-2296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`permission_required`：这个装饰器与Django内部定义的数据库权限方案一起工作。它确认已登录用户（或用户组）与给定权限相关联。这种装饰器用于需要特定管理权限才能发出请求的Web请求。'
- en: 'Other packages and frameworks also have ways to express this cross-cutting
    aspect of web applications. In many cases, a web application may have even more
    stringent security considerations. We might have a web application where user
    features are selectively unlocked based on contract terms and conditions. Perhaps,
    additional fees will unlock a feature. We might have to design a test like the
    following:'
  id: totrans-2297
  prefs: []
  type: TYPE_NORMAL
  zh: 其他包和框架也有表达Web应用程序的这种横切方面的方法。在许多情况下，Web应用程序可能会有更严格的安全考虑。我们可能有一个Web应用程序，用户功能是基于合同条款和条件有选择地解锁的。也许，额外的费用将解锁一个功能。我们可能需要设计一个像下面这样的测试：
- en: '[PRE342]'
  id: totrans-2298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'We''ve defined a function that checks the logged-in `User` `feature_set` collection
    to see if the named feature is associated with `User`. We''ve used our `has_feature()`
    function with Django''s `user_passes_test` decorator to create a new decorator
    that can be applied to the relevant `view` functions. We can then create a `view`
    function as follows:'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个函数，检查已登录的`User`的`feature_set`集合，以查看命名的功能是否与`User`相关联。我们使用了我们的`has_feature()`函数与Django的`user_passes_test`装饰器来创建一个可以应用于相关`view`函数的新装饰器。然后我们可以创建一个`view`函数如下：
- en: '[PRE343]'
  id: totrans-2300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: This assures that the security concerns will be applied consistently across
    a number of `view` functions.
  id: totrans-2301
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保安全性问题将一致地应用于许多`view`函数。
- en: Summary
  id: totrans-2302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: We've looked at using decorators to modify function and class definitions. We've
    also looked at mixins that allow us to decompose a larger class into components
    that are knitted together.
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过使用装饰器来修改函数和类定义。我们还看过混入，它允许我们将一个较大的类分解为组件，然后将它们组合在一起。
- en: The idea of both of these techniques is to separate application-specific features
    from generic features such as security, audit, or logging. We're going to distinguish
    between the inherent features of a class and aspects that aren't inherent but
    are additional concerns. The inherent features are part of the explicit design.
    They're part of the inheritance hierarchy; they define what an object is. The
    other aspects can be mixins or decorations; they define how an object might also
    act.
  id: totrans-2304
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种技术的想法都是将特定于应用程序的特性与安全性、审计或日志记录等通用特性分开。我们将区分类的固有特性和不固有但是额外关注的方面。固有特性是显式设计的一部分。它们是继承层次结构的一部分；它们定义了对象是什么。其他方面可以是混入或装饰；它们定义了对象可能还会起到的作用。
- en: Design considerations and trade-offs
  id: totrans-2305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计考虑和权衡
- en: In most cases, this division between *is-a* and *acts-as* is quite clear. Inherent
    features are a part of the overall problem domain. When talking about simulating
    Blackjack play, things such as cards, hands, betting, hitting, and standing are
    clearly part of the problem domain. Similarly, the data collection and statistical
    analysis of outcomes is part of the solution. Other things, such as logging, debugging,
    and auditing are not part of the problem domain but associated with solution technology.
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，*是*和*行为*之间的区分是非常明确的。固有特征是整体问题域的一部分。当谈论模拟21点游戏时，诸如卡片、手牌、下注、要牌和停牌等内容显然是问题域的一部分。类似地，数据收集和结果的统计分析是解决方案的一部分。其他事情，如日志记录、调试和审计，不是问题域的一部分，而是与解决方案技术相关的。
- en: 'While most cases are quite clear, the dividing line between inherent and decoration
    aspects can be fine. In some cases, it may devolve to an aesthetic judgment. Generally,
    the decision becomes difficult when writing framework and infrastructure classes
    that aren''t focused on a specific problem. The general strategy is as follows:'
  id: totrans-2307
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然大多数情况都很明确，固有和装饰方面之间的分界线可能很微妙。在某些情况下，这可能会变成审美判断。一般来说，在编写不专注于特定问题的框架和基础设施类时，决策变得困难。一般策略如下：
- en: First, aspects that are central to the problem will lead directly to class definitions.
    Many classes are inherent to the problem and form proper class hierarchies so
    that polymorphism works as expected.
  id: totrans-2308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，与问题相关的方面将直接导致类定义。许多类是问题的固有部分，并形成适当的类层次结构，以便多态性能够正常工作。
- en: 'Second, some aspects will lead to mixin class definitions. This often happens
    when there are aspects that are multidimensional. We might have independent axes
    or dimensions to a design. Each dimension can contribute polymorphic alternatives.
    When we look at Blackjack play, there are two kinds of strategies: play strategies
    and betting strategies. These are independent and might be considered the mixin
    elements of an overall player design.'
  id: totrans-2309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，某些方面会导致混合类定义。当存在多维方面时，这种情况经常发生。我们可能会有独立的设计轴或维度。每个维度都可以提供多态的选择。当我们看21点游戏时，有两种策略：玩牌策略和下注策略。这些是独立的，可以被视为整体玩家设计的混合元素。
- en: When we define separate mixins, we can have separate inheritance hierarchies
    for the mixins. For Blackjack betting strategies, we can define a polymorphic
    hierarchy that's unrelated to the polymorphic hierarchy for play strategies. We
    can then define players that have mixin elements from both hierarchies.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义单独的混合元素时，可以为混合元素定义单独的继承层次结构。对于21点下注策略，我们可以定义一个与玩牌策略的多态层次结构无关的多态层次结构。然后我们可以定义玩家，其混合元素来自两个层次结构。
- en: 'Methods are generally created from class definitions. They''re either part
    of the primary class or a mixin class. As noted above, we have three design strategies:
    Wrap, Extend, and Invent. We can introduce functionality through "wrapping" a
    class with another class. In some cases, we find that we''re forced to expose
    a large number of methods that are simply delegated to the underlying class. There''s
    a hazy boundary where we have too much delegation; a decorator or mixin would
    have been a better idea. In other cases, wrapping a class may be clearer than
    introducing a mixin class definition.'
  id: totrans-2311
  prefs: []
  type: TYPE_NORMAL
  zh: 方法通常是从类定义中创建的。它们可以是主类的一部分，也可以是混合类的一部分。如上所述，我们有三种设计策略：包装、扩展和发明。我们可以通过“包装”一个类来引入功能。在某些情况下，我们发现自己不得不暴露大量方法，这些方法只是委托给底层类。在这种情况下，我们有一个模糊的边界，我们委托过多；装饰器或混合类定义可能是更好的选择。在其他情况下，包装一个类可能比引入混合类定义更清晰。
- en: Aspects that are orthogonal to the problem can often be handled by decorator
    definitions. The decorators can be used to introduce features that are not part
    of the *is-a* relationship that an object has with its class.
  id: totrans-2312
  prefs: []
  type: TYPE_NORMAL
  zh: 与问题正交的方面通常可以通过装饰器定义来处理。装饰器可以用来引入不属于对象与其类之间*is-a*关系的特性。
- en: Looking forward
  id: totrans-2313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 展望未来
- en: The coming chapters will change direction. We've seen almost all of Python's
    special method names. The next five chapters are going to focus on object persistence
    and serialization. We'll start out with serializing and saving objects in various
    external notations, including JSON, YAML, Pickle, CSV, and XML.
  id: totrans-2314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将改变方向。我们已经了解了几乎所有Python的特殊方法名称。接下来的五章将专注于对象持久化和序列化。我们将从将对象序列化和保存到各种外部表示法开始，包括JSON、YAML、Pickle、CSV和XML。
- en: Serialization and persistence introduce yet more object-oriented design considerations
    for our classes. We'll have a look at object relationships and how they're represented.
    We'll also have a look at the cost complexity of serializing and deserializing
    objects, and at the security issues related to the de-serialization of objects
    from untrustworthy sources.
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化和持久化为我们的类引入了更多的面向对象设计考虑。我们将研究对象关系以及它们的表示方式。我们还将研究序列化和反序列化对象的成本复杂性，以及与从不可信来源反序列化对象相关的安全问题。
