- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Planning for the Expansion of Our Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们应用程序的扩展做准备
- en: The application is a real hit! After some initial testing and orientation, the
    data entry staff have been utilizing your new form for a few weeks now. The reduction
    in errors and data entry time is dramatic, and there's a lot of excited talk about
    what other problems this program might solve. With even the director joining in
    on the brainstorming, you have a strong suspicion that you'll be asked to add
    some new features soon.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序非常受欢迎！经过一些初步测试和定位后，数据输入人员已经使用了你新创建的表格几周了。错误和数据输入时间的减少非常显著，关于这个程序可能解决的其他问题的讨论也非常热烈。甚至总监也加入了头脑风暴，你强烈怀疑你很快就会被要求添加一些新功能。
- en: 'There''s a problem, though: the application is already a script of several
    hundred lines, and you''re worried about its manageability as it grows. You need
    to take some time to organize your code base in preparation for future expansion.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然如此，但存在一个问题：应用程序已经是一个包含数百行脚本的程序，随着其增长，你对其可管理性感到担忧。你需要花些时间来组织你的代码库，为未来的扩展做准备。
- en: 'In this chapter, we''ll learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: In *Separating concerns*, you'll learn about using the **model-view-controller**
    (**MVC**) pattern.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*分离关注点*中，你将了解如何使用**模型-视图-控制器**（**MVC**）模式。
- en: In *Structuring our application directory*, you'll learn how to organize your
    code into a Python package.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*结构化我们的应用程序目录*中，你将学习如何将你的代码组织成一个Python包。
- en: In *Splitting our application into multiple files*, you'll reorganize the data
    entry application into an MVC Python package.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*将我们的应用程序拆分为多个文件*中，你将重新组织数据输入应用程序为一个 MVC Python 包。
- en: In *Using version control software*, you'll discover how to use the Git version
    control system to track your changes.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*使用版本控制软件*中，你将发现如何使用Git版本控制系统来跟踪你的更改。
- en: Separating concerns
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分离关注点
- en: Proper architectural design is essential for any project that needs to scale.
    Anyone can prop up some studs and build a garden shed, but a house or skyscraper
    takes careful planning and engineering. Software is no different; simple scripts
    can get away with shortcuts such as global variables or manipulating class properties
    directly, but as the program grows, our code needs to isolate and encapsulate
    different functionalities in a way that limits the amount of complexity we need
    to understand at any given moment.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的架构设计对于任何需要扩展的项目至关重要。任何人都可以用一些支架搭建一个花园小屋，但房屋或摩天大楼则需要仔细规划和工程。软件也是如此；简单的脚本可以通过使用全局变量或直接操作类属性等捷径来逃避，但随着程序的扩展，我们的代码需要以限制在任何给定时刻需要理解复杂性的方式隔离和封装不同的功能。
- en: We call this concept **separation of concerns**, and it's accomplished through
    the use of architectural patterns that describe different application components
    and how they interact.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这个概念为**关注点分离**，它是通过使用描述不同应用程序组件及其交互的架构模式来实现的。
- en: The MVC pattern
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MVC模式
- en: 'Probably the most enduring of these architectural patterns is the **model-view-controller**
    (**MVC**) pattern, which was introduced in the 1970s. While this pattern has evolved
    and spun off variations over the years, the basic gist remains: keep the data,
    the presentation of the data, and the application logic in separate, independent
    components.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些架构模式中，最持久的是**模型-视图-控制器**（**MVC**）模式，该模式在20世纪70年代被引入。虽然这个模式在多年中已经演变并产生了各种变体，但其基本原理保持不变：保持数据、数据的展示和应用程序逻辑在独立、分离的组件中。
- en: 'The roles and relationships of the MVC components are shown in this diagram:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: MVC组件的角色和关系如图所示：
- en: '![](img/B17578_06_01.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_06_01.png)'
- en: 'Figure 6.1: The roles and relationships of Model, View, and Controller'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1：模型、视图和控制器的角色和关系
- en: Let's take a deeper look at each of these components and understand them in
    the context of our current application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地看看这些组件，并在我们当前应用程序的背景下理解它们。
- en: What is a model?
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是模型？
- en: The **model** in MVC represents the data. This includes the storage of the data,
    but also the various ways data can be queried or manipulated. Ideally, the model
    is not concerned with or affected by how the data will be presented (that is,
    what GUI widgets will be used, how the fields will be ordered, and so on), but
    rather presents a high-level interface that only minimally concerns other components
    with its inner workings. In theory, if you decided to completely change the user
    interface of the program (say, from a Tkinter application to a web application),
    the model should be totally unaffected.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MVC中的**模型**代表数据。这包括数据的存储，但也包括数据可以查询或操作的各种方式。理想情况下，模型不关心或不受数据展示方式（即使用什么GUI小部件、字段如何排序等）的影响，而是提供一个高级接口，仅对其他组件的内部工作有最小程度的关注。理论上，如果你决定完全改变程序的用户界面（例如，从Tkinter应用程序到Web应用程序），模型应该完全不受影响。
- en: 'Some examples of functionality or information you find in the model include:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你在模型中可能会找到的功能或信息示例包括：
- en: Preparation and saving of program data to a persistent medium (data file, database,
    and so on)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备和将程序数据保存到持久介质（数据文件、数据库等）
- en: Retrieval of data from a file or database into a format useful to the program
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从文件或数据库中检索数据到程序有用的格式
- en: An authoritative list of the fields in a set of data, along with their data
    types and limits
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组数据字段及其数据类型和限制的权威列表
- en: Validation of data against the data types and limits defined
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证数据与定义的数据类型和限制
- en: Calculations on stored data
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对存储数据进行计算
- en: We don't have a model class in our application currently; the data layout is
    defined in the form class, and the `Application.onsave()` method is the only code
    concerned with data persistence so far. To implement MVC in our application, we're
    going to need to split this logic off into a separate object that will define
    the data layout and handle all the CSV operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序中目前没有模型类；数据布局是在表单类中定义的，而`Application.onsave()`方法是迄今为止唯一涉及数据持久化的代码。为了在我们的应用程序中实现MVC，我们需要将这部分逻辑拆分到一个单独的对象中，该对象将定义数据布局并处理所有CSV操作。
- en: What is a view?
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是视图？
- en: A **view** is an interface for presenting data and controls to the user. Applications
    may have many views, often on the same data. Views may or may not have direct
    access to the model; if they do, they generally have read-only access, sending
    write requests through the controller.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**是向用户展示数据和控件的一个接口。应用程序可能有多个视图，通常基于相同的数据。视图可能或可能没有直接访问模型；如果它们有，通常只有只读访问权限，将写请求通过控制器发送。'
- en: 'Some examples of code you find in a view include:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你在视图中可能会找到的代码示例包括：
- en: GUI layout and widget definitions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GUI布局和小部件定义
- en: Form automations, such as auto-completion of fields, dynamic toggling of widgets,
    or display of error dialogs
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表单自动化，例如字段自动完成、动态切换小部件或显示错误对话框
- en: Formatting of raw data for presentation
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化原始数据以供展示
- en: 'Our `DataRecordForm` class is an example of a view: it contains most of the
    code for our application''s user interface. It also contains the `_vars` dictionary,
    which currently defines the structure of our data records. This dictionary can
    stay in the view, because the view does need a way to store the data temporarily
    before handing it off to the model, but `_vars` shouldn''t be defining our data
    record from here on out — that''s the model''s job. To implement MVC, we''ll need
    to make the view''s concept of the data dependent on the model, not on its own
    definitions.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`DataRecordForm`类是一个视图的例子：它包含了我们应用程序用户界面的大部分代码。它还包含`_vars`字典，该字典目前定义了我们的数据记录结构。这个字典可以留在视图中，因为视图确实需要一种方式在将其传递给模型之前临时存储数据，但`_vars`不应该再定义我们的数据记录——这是模型的工作。为了实现MVC，我们需要使视图中的数据概念依赖于模型，而不是它自己的定义。
- en: What is a controller?
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 什么是控制器？
- en: The **controller** is the "Grand Central Station" for the application. It handles
    requests from the user and takes care of routing data between the views and the
    model. Most variations of MVC change the role (and sometimes the name) of the
    controller, but the important thing is that it acts as the intermediary between
    the view and the model. Our controller object will need to hold references to
    the views and models used by our application and be responsible for managing interactions
    between them.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制器**是应用程序的“中央车站”。它处理来自用户的请求，并负责在视图和模型之间路由数据。MVC的多数变体都会改变控制器的角色（有时还会改变名称），但重要的是它作为视图和模型之间的中介。我们的控制器对象需要持有应用程序使用的视图和模型的引用，并负责管理它们之间的交互。'
- en: 'Examples of code you find in the controller include:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你在控制器中找到的代码示例包括：
- en: Startup and shutdown logic for the application
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的启动和关闭逻辑
- en: Callbacks for user interface events
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户界面事件的回调
- en: Creation of model and view instances
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型和视图实例的创建
- en: Our `Application` object is currently acting as the controller for our application,
    though it has some view and model logic in it as well. Unfortunately, the `Tk`
    object in Tkinter combines both the central point of control and the `root` window,
    so it's not entirely possible to separate the controller from the application's
    main view. Our `Application` object will therefore contain a little of both, but
    in the interest of implementing a more MVC design, we'll need to move some of
    its presentation logic into the views and some of its data logic into the models.
    Ideally, though, we want the `Application` object focused mainly on connecting
    code between the models and views.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Application`对象目前正作为我们应用程序的控制器，尽管它里面也有一些视图和模型逻辑。不幸的是，Tkinter中的`Tk`对象结合了控制中心点和`root`窗口，因此不可能完全将控制器与应用程序的主要视图分开。因此，我们的`Application`对象将包含两者的部分，但为了实现更MVC的设计，我们需要将其部分展示逻辑移动到视图，部分数据逻辑移动到模型。理想情况下，我们希望`Application`对象主要专注于连接模型和视图之间的代码。
- en: Why complicate our design?
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么要使设计复杂化？
- en: Initially, it may seem like a lot of needless overhead to split up the application
    this way. We'll have to shuttle data around between different objects and ultimately
    write more code to do exactly the same thing. Why would we do this?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，这种将应用程序拆分的方式可能看起来有很多不必要的开销。我们将在不同的对象之间传递数据，并最终编写更多的代码来完成完全相同的事情。我们为什么要这样做呢？
- en: Put simply, we're doing it to make expansion manageable. As the application
    grows, the complexity will also grow. Isolating our components from one another
    limits the amount of complexity that any one component has to manage; for example,
    if we wanted to restructure the layout of the Data Record Form, we should not
    have to worry if doing so will change the structure of the data in the output
    file.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们这样做是为了使扩展变得可管理。随着应用程序的增长，复杂性也会增长。将我们的组件相互隔离限制了任何单个组件需要管理的复杂性；例如，如果我们想重新设计数据记录表单的布局，我们不应该担心这样做是否会改变输出文件中的数据结构。
- en: Those two aspects of the program should be independent of one another.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 程序的这两个方面应该相互独立。
- en: It also helps us to be consistent about where we put certain types of logic.
    For example, having a discrete model object helps us to avoid littering our UI
    code with ad hoc data queries or file access attempts.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 它还帮助我们保持一致，关于我们将某些类型的逻辑放在哪里。例如，拥有一个离散的模型对象有助于我们避免在UI代码中随意添加数据查询或文件访问尝试。
- en: The bottom line is, without some guiding architectural strategy, our program
    is in danger of becoming a hopeless tangle of spaghetti logic. Even without adhering
    to a strict definition of MVC design, consistently following even a loose MVC
    pattern will save a lot of headaches as the application becomes more complex.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，如果没有一些指导性的架构策略，我们的程序可能会变成一团糟的意大利面逻辑。即使不严格遵循MVC设计的定义，一致地遵循即使是松散的MVC模式，当应用程序变得更加复杂时，也会节省很多麻烦。
- en: Structuring our application directory
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构化我们的应用程序目录
- en: Just as logically breaking our program into separate concerns helps us manage
    the logical complexity of each component, physically breaking the code into multiple
    files helps us keep the complexity of each file manageable. It also reinforces
    more isolation between components; for example, you can't share global variables
    between files, and you know that if your `models.py` file imports `tkinter`, you're
    doing something wrong.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如将我们的程序分解成单独的关注点有助于我们管理每个组件的逻辑复杂性一样，将代码物理地分解成多个文件有助于我们保持每个文件的复杂性可管理。这也加强了组件之间的隔离；例如，你无法在文件之间共享全局变量，而且你知道如果你的
    `models.py` 文件导入了 `tkinter`，你正在做错事。
- en: Basic directory structure
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本目录结构
- en: There is no official standard for laying out a Python application directory,
    but there are some common conventions that will help us keep things tidy and make
    it easier to package our software later on. Let's set up our directory structure.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Python 应用程序的目录布局没有官方标准，但有一些常见的约定可以帮助我们保持整洁，并在以后更容易打包我们的软件。让我们设置我们的目录结构。
- en: To begin, create a directory called `ABQ_Data_Entry`. This is the root directory
    of our application, so whenever we refer to the **application root**, this is
    it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为 `ABQ_Data_Entry` 的目录。这是我们的应用程序的根目录，因此每当提到**应用程序根目录**时，指的就是这个目录。
- en: Under the application root, create another directory called `abq_data_entry`.
    Notice it's in lowercase. This is going to be a Python package that will contain
    all the code for the application; it should always be given a fairly unique and
    descriptive name so that it won't be confused with existing Python packages. Normally,
    you wouldn't have a different casing between the application root and this main
    module, but it doesn't hurt anything either; we're doing it here to avoid confusion.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序根目录下创建另一个名为 `abq_data_entry` 的目录。注意它是小写的。这将是一个包含应用程序所有代码的 Python 包；它应该有一个相当独特且描述性的名称，以免与现有的
    Python 包混淆。通常，你不会在应用程序根目录和这个主要模块之间使用不同的大小写，但这也没有什么坏处；我们在这里这样做是为了避免混淆。
- en: Python packages and modules should always be named using all lowercase letters
    and underscores to separate words. This convention is spelled out in PEP 8, Python's
    official style guide. See [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008)
    for more information about PEP 8.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Python 包和模块应该始终使用全部小写字母和下划线来分隔单词。这个约定在 PEP 8 中有详细说明，这是 Python 的官方风格指南。有关 PEP
    8 的更多信息，请参阅 [https://www.python.org/dev/peps/pep-0008](https://www.python.org/dev/peps/pep-0008)。
- en: Next, create a `docs` folder under the application root. This folder will be
    for documentation files about the application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在应用程序根目录下创建一个 `docs` 文件夹。这个文件夹将用于存放有关应用程序的文档文件。
- en: 'Finally, create two empty files in the application root: `README.rst` and `abq_data_entry.py`.
    Your directory structure should look as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在应用程序根目录中创建两个空文件：`README.rst` 和 `abq_data_entry.py`。你的目录结构应该如下所示：
- en: '![](img/B17578_06_02.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17578_06_02.png)'
- en: 'Figure 6.2: Directory structure of our application root directory'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2：应用程序根目录的目录结构
- en: Now, let's put some code in these files.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些代码放入这些文件中。
- en: The abq_data_entry.py file
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: abq_data_entry.py 文件
- en: 'The `abq_data_entry.py` file is going to be the main file that gets executed
    to start the program. However, it won''t contain the bulk of our program. In fact,
    it will contain only the following code:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`abq_data_entry.py` 文件将是启动程序时执行的主要文件。然而，它不会包含我们程序的大部分内容。实际上，它将只包含以下代码：'
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Add that code to the file and save it. The only purpose of this file is to import
    our `Application` class, make an instance of it, and run it. The remainder of
    the work will happen inside the `abq_data_entry` package. We haven't created that
    yet, so this file won't run just yet. Before we do anything about the application
    package, let's deal with our documentation.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 将该代码添加到文件中并保存。这个文件的唯一目的是导入我们的 `Application` 类，创建其实例并运行它。其余的工作将在 `abq_data_entry`
    包内部完成。我们还没有创建这个包，所以这个文件现在还不能运行。在我们处理应用程序包之前，让我们先处理我们的文档。
- en: The README.rst file
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: README.rst 文件
- en: Since as far back as the 1970s, programs have included a short text file called
    `README`, containing a condensed summary of the program's documentation. For small
    programs, it may be the only documentation; for larger programs, it usually contains
    essential pre-flight instructions for users or administrators.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从 20 世纪 70 年代开始，程序中就包含了一个简短的文本文件，称为 `README`，其中包含程序文档的简明摘要。对于小型程序，它可能是唯一的文档；对于大型程序，它通常包含用户或管理员在飞行前必须执行的必要指令。
- en: 'There''s no prescribed set of contents for a `README` file, but as a basic
    guideline, consider the following sections:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`README`文件没有规定的内容，但作为一个基本指南，请考虑以下部分：'
- en: '**Description**: A brief description of the program and its function. We can
    reuse the description from our specification, or something like it. This might
    also contain a brief list of the main features.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**描述**：对程序及其功能的简要描述。我们可以重用我们的规范中的描述，或者类似的内容。这还可能包含主要功能的简要列表。'
- en: '**Author information**: The names of the authors and copyright date. This is
    especially important if you plan to share your software, but even for something
    in-house, it''s useful for future maintainers to know who created the software
    and when.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作者信息**：作者的名字和版权日期。如果您计划共享您的软件，这尤为重要，但对于内部使用的软件，对于未来的维护者来说，了解谁创建了软件以及何时创建也是有用的。'
- en: '**Requirements**: A list of the software and hardware requirements for the
    software, if any.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**要求**：如果有的话，列出软件和硬件的要求。'
- en: '**Installation**: Instructions for installing the software, its prerequisites,
    dependencies, and basic setup.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安装**：安装软件的说明、其先决条件、依赖项和基本设置。'
- en: '**Configuration**: How to configure the application and what options are available.
    This is generally aimed at the command-line or configuration file options, not
    options set interactively in the program.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：如何配置应用程序以及可用的选项。这通常针对命令行或配置文件选项，而不是在程序中交互式设置的选项。'
- en: '**Usage**: A description of how to launch the application, command-line arguments,
    and other notes a user would need to know to use the basic functionality of the
    application.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用法**：如何启动应用程序、命令行参数以及其他用户需要了解的基本功能的相关说明。'
- en: '**General notes**: A catch-all for notes or critical information users should
    be aware of.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一般注意事项**：用于收集用户应了解的笔记或关键信息的通用部分。'
- en: '**Bugs**: A list of known bugs or limitations in the application.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：已知错误或应用程序的限制列表。'
- en: Not all of these sections will apply to every program; for example, ABQ Data
    Entry doesn't currently have any configuration options, so there's no reason to
    have a configuration section. You might add other sections as well, depending
    on the situation; for example, publicly distributed software may have an FAQ section
    for common questions, or open source software might have a Contributing section
    with instructions on how to submit patches.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有这些部分都适用于每个程序；例如，ABQ数据输入目前没有任何配置选项，因此没有必要有配置部分。根据情况，您还可以添加其他部分；例如，公开分发的软件可能有常见问题解答部分，或开源软件可能有贡献部分，其中包含提交补丁的说明。
- en: The `README` file is written in plain ASCII or Unicode text, either free-form
    or using a markup language. Since we're doing a Python project, we'll use **reStructuredText**,
    the official markup for Python documentation (which is why our file uses an `rst`
    file extension).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`README`文件使用纯ASCII或Unicode文本编写，可以是自由格式或使用标记语言。由于我们正在进行Python项目，我们将使用**reStructuredText**，这是Python官方文档的标记语言（这也是为什么我们的文件使用`rst`文件扩展名）。'
- en: For more information on reStructuredText, see the *Appendix A*, *A Quick Primer
    on reStructuredText*.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 关于reStructuredText的更多信息，请参阅**附录A**，**reStructuredText快速入门**。
- en: A sample `README.rst` file is included in the example code in the GitHub repo.
    Take a moment to look it over; then, we can move on to the `docs` folder.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub仓库中的示例代码中包含了一个`README.rst`文件的样本。花点时间看看它；然后，我们可以继续到`docs`文件夹。
- en: Populating the docs folder
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 填充文档文件夹
- en: 'The `docs` folder is where documentation goes. This can be any kind of documentation:
    user manuals, program specifications, API references, diagrams, and so on.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`docs`文件夹是放置文档的地方。这可以是任何类型的文档：用户手册、程序规范、API参考、图表等等。'
- en: 'For now, let''s just copy in these things:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需复制这些内容：
- en: The program specification we wrote in the previous chapters
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在前几章中编写的程序规范
- en: Your interface mockups
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的界面原型
- en: A copy of the form used by the technicians
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术人员使用的表格副本
- en: At some point, you might need to write a user manual, but for now, the program
    is simple enough not to need it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您可能需要编写用户手册，但到目前为止，程序足够简单，不需要它。
- en: Making a Python package
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 制作Python包
- en: 'Creating your own Python package is surprisingly easy. A Python package consists
    of the following three things:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自己的Python包出奇地简单。一个Python包由以下三个部分组成：
- en: A directory
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目录
- en: A file called `__init__.py` in the directory
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目录中的`__init__.py`文件
- en: Optionally, one or more Python files in that directory
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选地，该目录中的一个或多个Python文件
- en: Once you've done this, you can import your package in whole or in part, just
    like you would import standard library packages, provided your script is in the
    same parent directory as the package directory.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些操作，你就可以像导入标准库包一样，整体或部分导入你的包，前提是你的脚本与包目录位于同一父目录下。
- en: Note that the `__init__.py` file in a module is somewhat analogous to what the
    initializer method is for a class. Code inside it will run whenever the package
    is imported, and any names created or imported into it are available directly
    under the package namespace. The Python community generally discourages putting
    too much code in this file, though; and since no code is actually required, we'll
    leave this file empty.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模块中的`__init__.py`文件在某种程度上类似于类的初始化方法。其中的代码会在包被导入时运行，并且任何创建或导入到其中的名称都直接在包命名空间下可用。尽管没有实际需要代码，Python社区通常不鼓励在这个文件中放置太多代码；因此，我们将保持这个文件为空。
- en: 'Let''s start building our application''s package. Create the following six
    empty files under `abq_data_entry`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始构建应用程序的包。在`abq_data_entry`下创建以下六个空文件：
- en: '`__init__.py`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__.py`'
- en: '`widgets.py`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`widgets.py`'
- en: '`views.py`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`views.py`'
- en: '`models.py`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`models.py`'
- en: '`application.py`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application.py`'
- en: '`constants.py`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`constants.py`'
- en: 'Each of those Python files is called a **module**. A module is nothing more
    than a Python file inside a package directory. Your directory structure should
    now look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这些Python文件每个都被称为**模块**。模块不过是一个包目录内的Python文件。现在你的目录结构应该看起来像这样：
- en: '![](img/B17578_06_03.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_06_03.png)'
- en: 'Figure 6.3: Updated directory structure, including the package directory'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3：更新后的目录结构，包括包目录
- en: At this point, you have a working package, albeit with no actual code in it.
    To test this, open a Terminal or command-line window, change to your `ABQ_Data_Entry`
    directory, and start a Python shell.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你有一个正在工作的包，尽管里面没有实际的代码。为了测试这一点，打开一个终端或命令行窗口，切换到你的`ABQ_Data_Entry`目录，并启动一个Python
    shell。
- en: 'Now, type the following command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，输入以下命令：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This should execute without error. Of course, it doesn't do anything, but we'll
    get to that next.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会无错误地执行。当然，它什么也不做，但我们会继续下去。
- en: Don't confuse the term *package* here with the actual distributable Python packages,
    such as those you download using `pip`. We will learn how to make distributable
    Python packages in *Chapter 16*, *Packaging with setuptools and cxFreeze*. In
    this context, a package is just a collection of Python modules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将这里的术语*包*与实际的可分发Python包混淆，例如使用`pip`下载的包。我们将在*第16章*，*使用setuptools和cxFreeze打包*中学习如何制作可分发Python包。在这个上下文中，包只是Python模块的集合。
- en: Splitting our application into multiple files
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用程序拆分为多个文件
- en: Now that our directory structure is in order, we need to start dissecting our
    application script and splitting it up into our module files. We'll also need
    to create our model class.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经整理好了目录结构，我们需要开始分解我们的应用程序脚本，并将其拆分到我们的模块文件中。我们还需要创建我们的模型类。
- en: Open up your `data_entry_app.py` file from *Chapter 5*, *Reducing User Error
    with Validation and Automation*, and let's begin!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`data_entry_app.py`文件，来自*第5章*，*通过验证和自动化减少用户错误*，然后我们开始吧！
- en: Creating the models module
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型模块
- en: When your application is all about data, it's good to begin with the model.
    Remember that the job of a model is to manage the storage, retrieval, and processing
    of our application's data, usually with respect to its persistent storage format
    (in this case, CSV). To accomplish this, our model should contain all the knowledge
    about our data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的应用程序全部关于数据时，从模型开始是个好主意。记住，模型的工作是管理应用程序数据的存储、检索和处理，通常与它的持久化存储格式（在本例中是CSV）相关。为了完成这个任务，我们的模型应该包含关于我们数据的所有知识。
- en: Currently, our application has nothing like a model; knowledge about the application's
    data is scattered the form fields, and the `Application` object simply takes whatever
    data the form contains and stuffs it directly into a CSV file when a save operation
    is requested. Since we aren't yet retrieving or updating information, our application
    has no actual knowledge about what's inside the CSV file.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序没有类似模型的东西；关于应用程序数据的知识散布在表单字段中，而`Application`对象在请求保存操作时，只是简单地将表单包含的数据直接填充到CSV文件中。由于我们还没有检索或更新信息，我们的应用程序实际上对CSV文件中的内容一无所知。
- en: To move our application to an MVC architecture, we'll need to create a model
    class that both manages data storage and retrieval, and represents the authoritative
    source of knowledge about our data. In other words, we have to encode the knowledge
    contained in our data dictionary here in our model. We don't really know what
    we'll do with this knowledge yet, but this is where it belongs.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的应用程序迁移到MVC架构，我们需要创建一个模型类，该类既管理数据存储和检索，又代表我们数据的知识权威来源。换句话说，我们必须在这里我们的模型中编码数据字典中包含的知识。我们目前还不知道我们将如何使用这些知识，但这就是它应该属于的地方。
- en: There are a few ways we could store this data, such as creating a custom field
    class or a `namedtuple` object, but we'll keep it simple for now and just use
    a dictionary, mapping field names to field metadata.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 存储这些数据有几种方式，例如创建一个自定义字段类或一个`namedtuple`对象，但为了简单起见，我们现在将只使用字典，将字段名称映射到字段元数据。
- en: 'The field metadata will likewise be stored as a dictionary of attributes about
    the field, which will include:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 字段元数据将同样以关于字段的属性字典的形式存储，它将包括：
- en: The type of data stored in the field
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段中存储的数据类型
- en: Whether or not the field is required
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字段是否必需
- en: The list of possible values, if applicable
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，可能的值列表
- en: The minimum, maximum, and increment of values, if applicable
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果适用，值的范围、最小值、最大值和增量
- en: 'To store the data type for each field, we''re going to define a set of constants
    that will let us refer to the different field types in a consistent and explicit
    way. We''ll place this in the `constants.py` file, so open that file in your editor
    and add the following code:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储每个字段的类型，我们将定义一组常量，这将让我们以一致和明确的方式引用不同的字段类型。我们将把这个放在`constants.py`文件中，所以请在您的编辑器中打开该文件并添加以下代码：
- en: '[PRE2]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We've created a class called `FieldTypes` that simply stores some named integer
    values, which will describe the different types of data we're going to store.
    This class is based on Python's `Enum` class, which is a useful class for defining
    collections of constants like this. The values of these variables are not at all
    important, so long as each one is unique; in an `Enum`, we're really just interested
    in having a set of variable names that are not equal to one another.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`FieldTypes`的类，它只是存储了一些命名整数值，这些值将描述我们将要存储的不同类型的数据。这个类基于Python的`Enum`类，这是一个用于定义此类常量集合的有用类。这些变量的值并不重要，只要每个都是唯一的；在`Enum`中，我们真正感兴趣的是拥有一组不等于彼此的变量名。
- en: We could set them to strings or sequential integers by hand, but the `enum`
    module provides the `auto()` function, which gives each constant of the class
    a unique integer value automatically. Using this approach better communicates
    that the values themselves are not significant; only the names matter.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以手动将它们设置为字符串或顺序整数，但`enum`模块提供了一个`auto()`函数，它可以自动为类的每个常量分配一个唯一的整数值。使用这种方法更好地传达了值本身并不重要；只有名称才是关键。
- en: 'Now that we have these constants, let''s open `models.py` and begin creating
    our model class:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了这些常量，让我们打开`models.py`并开始创建我们的模型类：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We begin by importing the libraries we will need for our model: `csv`, `pathlib`,
    `datetime`, `os`, and our new `FieldTypes` constants. The first three were the
    libraries we needed for our `on_save()` method in `Application`. Now, the model
    class will be handling most of this functionality. The `os` module will be used
    to check file permissions, and the `FieldTypes` constants will be used to define
    our model''s data dictionary.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先导入我们模型所需的库：`csv`、`pathlib`、`datetime`、`os`以及我们的新`FieldTypes`常量。前三个是我们为`Application`中的`on_save()`方法所需的库。现在，模型类将处理大部分这些功能。`os`模块将用于检查文件权限，而`FieldTypes`常量将用于定义我们模型的数据字典。
- en: 'Notice the way we import `FieldTypes`: `from .constants import FieldTypes`.
    The dot in front of `constants` makes this a **relative import**. Relative imports
    can be used inside a Python package to locate other modules in the same package.
    In this case, we''re in the `models` module, and we need to access the `constants`
    module inside the `abq_data_entry` package. The single dot represents our current
    parent module (`abq_data_entry`), and thus `.constants` within this file means
    the `constants` module of the `abq_data_entry` package.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们导入`FieldTypes`的方式：`from .constants import FieldTypes`。`constants`前面的点表示这是一个**相对导入**。相对导入可以在Python包内部使用，以定位同一包中的其他模块。在这种情况下，我们处于`models`模块中，我们需要访问`abq_data_entry`包内的`constants`模块。单个点代表我们的当前父模块（`abq_data_entry`），因此在这个文件中的`.constants`意味着`abq_data_entry`包的`constants`模块。
- en: Relative imports distinguish our custom modules from modules in `PYTHONPATH`.
    By using them, we don't have to worry about any third-party or standard library
    packages conflicting with our module names.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入区分了我们的自定义模块和 `PYTHONPATH` 中的模块。通过使用它们，我们不必担心任何第三方或标准库包与我们的模块名称冲突。
- en: 'Next, we''re going to need to create a class member variable that contains
    a dictionary of all the fields in our model. Each item in the dictionary will
    contain details about the field: its data type, if it''s required, and valid values,
    ranges, and increments.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个包含模型中所有字段字典的类成员变量。字典中的每个条目都将包含有关字段的详细信息：其数据类型、是否必需以及有效值、范围和增量。
- en: In addition to field attributes, we're also documenting the order of fields
    for the CSV here. In Python 3.6 and later, dictionaries retain the order they
    were defined by; if you're using an older version of Python 3, you need to use
    the `OrderedDict` class from the `collections` standard library module to preserve
    the field order.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了字段属性外，我们还在这里记录了CSV字段的顺序。在Python 3.6及以后的版本中，字典保留了它们被定义的顺序；如果你使用的是Python 3的较旧版本，你需要使用
    `collections` 标准库模块中的 `OrderedDict` 类来保留字段顺序。
- en: 'Add this dictionary like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这种方式添加这个字典：
- en: '[PRE4]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This list is straight from our data dictionary, and we've seen these same values
    already in our `DataRecordForm` class; but from now on, this dictionary is going
    to be the authoritative source of this information. Any other class that needs
    information about a model field will have to retrieve it from this dictionary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表直接来自我们的数据字典，我们已经在 `DataRecordForm` 类中看到了这些相同的值；但从现在开始，这个字典将成为这些信息的权威来源。任何需要关于模型字段信息的其他类都必须从该字典中检索。
- en: 'Before we start designing our model class''s methods, let''s take a moment
    to look at the existing file-save logic in our application and consider which
    parts belong to the model. The code in our current script looks like this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计模型类的函数之前，让我们花一点时间看看我们应用程序中现有的文件保存逻辑，并考虑哪些部分属于模型。我们当前脚本中的代码看起来是这样的：
- en: '[PRE5]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s go through this code and determine what goes into the model and what
    stays in the `Application` class:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们审查这段代码，确定哪些内容放入模型，哪些保留在 `Application` 类中：
- en: The first block pulls errors from the `DataRecordForm` class. Since the model
    will have no knowledge of the form, this should stay in `Application`. In fact,
    the model doesn't even need to know about form errors, since the only action taken
    is UI-related (that is, displaying the errors).
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一段代码从 `DataRecordForm` 类中提取错误。由于模型将没有关于表单的了解，这部分应该保留在 `Application` 中。实际上，模型甚至不需要知道表单错误，因为唯一采取的操作是UI相关的（即显示错误）。
- en: The next set of lines define the filename we're going to use. Since this is
    a detail of the file storage, it is clearly the model's concern.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的几行定义了我们将要使用的文件名。由于这是文件存储的细节，这显然是模型关心的问题。
- en: The `newfile` assignment line determines whether the file exists or not. As
    an implementation detail of the data storage medium, this is clearly the model's
    problem, not the application's.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`newfile` 赋值行确定文件是否存在。作为数据存储介质的实现细节，这显然是模型的问题，而不是应用程序的问题。'
- en: The line `data = self.recordform.get()` pulls data from the form. Since our
    model has no knowledge of the form's existence, this needs to stay in `Application`.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这一行 `data = self.recordform.get()` 从表单中获取数据。由于我们的模型对表单的存在没有了解，这部分需要保留在 `Application`
    中。
- en: The next block opens the file, creates a `csv.DictWriter` object, and appends
    the data. This is definitely the model's concern.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一段代码打开文件，创建一个 `csv.DictWriter` 对象，并追加数据。这显然是模型关心的问题。
- en: The final block communicates the results of the file-save operation to the user
    and resets the form. This is all user interface-related, so it does not belong
    in the model.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一段代码将文件保存操作的结果通知用户并重置表单。这完全是用户界面相关的，所以它不属于模型。
- en: So, our model will need to determine the filename and take care of writing the
    data received from the `Application` object to it, while the application will
    be responsible for checking the form for errors, retrieving the data from the
    form, and communicating the results of the save operation to the user.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的模型将需要确定文件名并负责将 `Application` 对象接收到的数据写入其中，而应用程序将负责检查表单错误、从表单中检索数据，并将保存操作的结果通知用户。
- en: 'Let''s create the initializer method for our model class. Because the `CSVModel`
    represents an interface to a specific CSV file, we''re going to determine the
    filename in `__init__()` and keep it for the lifespan of the model object. The
    method begins like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的模型类创建初始化器方法。由于`CSVModel`代表对特定CSV文件的接口，我们将在`__init__()`中确定文件名，并在模型对象的生命周期内保持它。该方法开始如下：
- en: '[PRE6]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `__init__()` method begins by determining the `filename` from the current
    date and converting it into a `Path` object, which it stores as an instance variable.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`__init__()`方法首先确定`filename`，从当前日期转换成`Path`对象，并将其存储为实例变量。'
- en: Since the instance of the model is tied to the filename and represents our access
    to that file, it would be a relatively useless model if we did not have permission
    to append data to the file. Therefore, we will want the initializer to check access
    to the file and alert us if there is any problem with it before we start entering
    data into our form.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型实例与文件名相关联，并代表我们对该文件的访问，如果我们没有权限向文件追加数据，那么这个模型将相对无用。因此，我们希望在开始将数据输入到我们的表单之前，初始化器会检查对文件的访问权限，并在发现任何问题时提醒我们。
- en: 'To do that, we need to use the `os.access()` function, like so:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要使用`os.access()`函数，如下所示：
- en: '[PRE7]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `os.access()` function takes two arguments: a file path string or `Path`
    object, and a constant indicating the mode we want to check. The two constants
    we''ll be using are `os.F_OK`, which checks if the file exists, and `os.W_OK`,
    which checks that we have write permission to it. Note that checking for `W_OK`
    will return `False` if the file doesn''t exist (which is a distinct possibility
    if no data has been saved yet), so we need to check for two possible scenarios:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`os.access()`函数接受两个参数：一个文件路径字符串或`Path`对象，以及一个表示我们想要检查的模式的常量。我们将使用两个常量：`os.F_OK`，它检查文件是否存在，以及`os.W_OK`，它检查我们是否有对该文件的写入权限。请注意，如果文件不存在（如果没有保存任何数据，这是完全可能的），检查`W_OK`将返回`False`，因此我们需要检查两种可能的情况：'
- en: The file exists, but we cannot write to it
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件存在，但我们无法写入它
- en: The file does not exist, and we cannot write to its parent directory
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件不存在，我们无法写入其父目录
- en: In either of these cases, we won't be able to write to the file and should raise
    an exception. You might wonder why we're raising an exception and not displaying
    some kind of error (such as in the status bar or by printing to the console).
    Remember that the model class should not assume anything about the UI or contain
    any UI code. The appropriate way to handle an error situation in a model is to
    pass a message back to the controller using an exception, so that the controller
    can take actions appropriate to our user interface.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们将无法写入文件，应该抛出异常。你可能会想知道为什么我们要抛出异常而不是显示某种错误信息（例如在状态栏中或通过控制台打印）。记住，模型类不应该对UI有任何假设，也不应包含任何UI代码。在模型中处理错误情况的方法是使用异常将消息传递回控制器，以便控制器可以采取适合我们用户界面的适当操作。
- en: The idea of raising an exception on purpose often seems strange to beginners;
    after all, exceptions are something we're trying to avoid, right? This is true
    in the case of small scripts where we are essentially consumers of existing modules;
    when writing your own module, however, exceptions are the correct way for your
    module to communicate problems to the code using its classes and functions. Trying
    to handle – or worse, silence – bad behavior on the part of external code will,
    at best, break the modularization of our code; at worst, it will create subtle
    bugs that are difficult to track down.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 故意抛出异常的想法对初学者来说通常很奇怪；毕竟，异常是我们试图避免的东西，对吧？在小型脚本中，我们实际上是现有模块的消费者时，这是正确的；然而，当你编写自己的模块时，异常是模块通过其类和函数与使用它们的代码通信问题的正确方式。试图处理——或者更糟，压制——外部代码的不良行为，最多会破坏我们代码的模块化；最坏的情况是，它将创建难以追踪的微妙错误。
- en: 'Now that we have our model initialized with a writable filename, we need to
    create a method to save the data. In the `CSVModel` class, let''s create a public
    method to store data. Add the following code for the `save_record()` method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了具有可写文件名的模型，我们需要创建一个方法来保存数据。在`CSVModel`类中，让我们创建一个公共方法来存储数据。为`save_record()`方法添加以下代码：
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the model does not need to know about form errors and already has a filename
    established in its initializer, the only argument this method requires is a dictionary
    of the form data. What remains is to determine if we are dealing with a new file
    and to write the data to the CSV.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模型不需要知道表单错误，并且在其初始化器中已经建立了文件名，因此这个方法只需要一个表单数据的字典作为参数。剩下的是确定我们是否处理的是新文件，并将数据写入CSV。
- en: Note that, when writing the field names to a new CSV file, we use the keys of
    our `fields` dictionary, rather than relying on the keys in the incoming data.
    Remember that `CSVModel.fields` is now the authoritative source of information
    about application data, so it should determine the headers that are used.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当将字段名称写入新的CSV文件时，我们使用`fields`字典的键，而不是依赖于传入数据中的键。请记住，`CSVModel.fields`现在是关于应用程序数据信息的权威来源，因此它应该确定使用的标题。
- en: Our model class is now complete. Let's get to work on the user interface!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的模式类现在已经完成。让我们开始着手用户界面！
- en: Moving the widgets
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动小部件
- en: While we could put all of our UI-related code in one `views` module, we have
    a lot of custom widget classes. It would make sense to put them in their own separate
    module to limit the complexity of the `views` module. So, instead, we're going
    to move all of the code for our widget classes into a `widgets.py` file. The widget
    classes we'll move include all the classes that implement reusable GUI components,
    including compound widgets like `LabelInput`. If we develop more custom widgets,
    we'll add them to this file as well.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以将所有与UI相关的代码放在一个`views`模块中，但我们有很多自定义小部件类。将它们放在自己的单独模块中，以限制`views`模块的复杂性是有意义的。因此，我们将所有小部件类的代码移动到`widgets.py`文件中。我们将移动的小部件类包括所有实现可重用GUI组件的类，包括复合小部件如`LabelInput`。如果我们开发更多的自定义小部件，我们也将它们添加到这个文件中。
- en: Open `widgets.py` and copy in all of the code for `ValidatedMixin`, `DateEntry`,
    `RequiredEntry`, `ValidatedCombobox`, `ValidatedSpinbox`, `ValidatedRadioGroup`,
    `BoundText`, and `LabelInput`. These are all the widget classes we've created
    so far.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`widgets.py`，并将`ValidatedMixin`、`DateEntry`、`RequiredEntry`、`ValidatedCombobox`、`ValidatedSpinbox`、`ValidatedRadioGroup`、`BoundText`和`LabelInput`的所有代码复制进去。这些都是我们迄今为止创建的所有小部件类。
- en: 'The `widgets.py` file will, of course, need to import any module dependencies
    used by the code being copied in. We''ll need to look through our code and find
    what libraries we use and import them. Add the following to the top of the file:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`widgets.py`文件当然需要导入被复制进来的代码所使用的任何模块依赖项。我们需要检查我们的代码，找出我们使用的库并将它们导入。请在文件的顶部添加以下内容：'
- en: '[PRE9]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Obviously, we need `tkinter` and `ttk`; our `DateEntry` class uses the `datetime`
    class from the `datetime` library, and our `ValidatedSpinbox` class makes use
    of the `Decimal` class and `InvalidOperation` exception from the `decimal` library.
    This is all we need in `widgets.py`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们需要`tkinter`和`ttk`；我们的`DateEntry`类使用`datetime`库中的`datetime`类，而我们的`ValidatedSpinbox`类则使用`decimal`库中的`Decimal`类和`InvalidOperation`异常。这就是`widgets.py`中所需的所有内容。
- en: Moving the views
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移动视图
- en: Next, we'll work on the `views.py` file. Recall that views are larger GUI components,
    like our `DataRecordForm` class. Currently, in fact, it is our only view, but
    as we create more large GUI components, they will be added here.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将处理`views.py`文件。回想一下，视图是更大的GUI组件，就像我们的`DataRecordForm`类。实际上，目前它是我们唯一的视图，但随着我们创建更多的大型GUI组件，它们将被添加到这里。
- en: Open the `views.py` file and copy in the `DataRecordForm` class; then, go back
    to the top to deal with the module imports. Again, we'll need `tkinter` and `ttk`,
    as well as `datetime`, since our auto-fill logic requires it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`views.py`文件，并将`DataRecordForm`类复制进去；然后，回到顶部处理模块导入。再次强调，我们需要`tkinter`和`ttk`，以及`datetime`，因为我们的自动填充逻辑需要它们。
- en: 'Add them to the top of the file, as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式将它们添加到文件顶部：
- en: '[PRE10]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We aren''t done, though; our actual widgets aren''t here anymore, so we''ll
    need to import them, like so:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们还没有完成；我们的实际小部件不再在这里，所以我们需要导入它们，如下所示：
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Just as we did with the `FieldTypes` in our `models.py` file, we've imported
    our `widgets` module using a relative import. We've kept the widgets in their
    own namespace to keep our global namespace clean, but given it a short alias,
    `w`, so that our code won't get overly cluttered.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在`models.py`文件中的`FieldTypes`一样，我们使用相对导入导入了我们的`widgets`模块。我们保持小部件在其自己的命名空间中，以保持全局命名空间干净，但给它一个简短的别名`w`，这样我们的代码就不会过于杂乱。
- en: This means, though, that we'll need to go through the code and prepend `w.`
    to all instances of `LabelInput`, `RequiredEntry`, `DateEntry`, `ValidatedCombobox`,
    `ValidatedRadioGroup`, `BoundText`, and `ValidatedSpinbox`. This should be easy
    enough to do in IDLE or any other text editor using a series of search and replace
    actions.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，尽管如此，我们还需要遍历代码，并在所有 `LabelInput`、`RequiredEntry`、`DateEntry`、`ValidatedCombobox`、`ValidatedRadioGroup`、`BoundText`
    和 `ValidatedSpinbox` 实例前添加 `w.`。这应该足够容易在 IDLE 或任何其他文本编辑器中通过一系列搜索和替换操作来完成。
- en: 'For example, line 1 of the form should be as follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，表单的第一行应如下所示：
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Before you go through and change that everywhere, though, let's stop and take
    a moment to refactor some of the redundancy out of this code.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始更改所有这些内容之前，让我们停下来，花点时间重构一些代码中的冗余。
- en: Removing redundancy in our view logic
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 减少视图逻辑中的冗余
- en: 'Consider the arguments we''re passing into the `LabelInput` widgets: they contain
    a lot of information that is also in our model. Minimums, maximums, increments,
    and possible values are defined both here and in our model code. Even the type
    of the input widget we''re choosing is related directly to the type of data being
    stored: numbers get a `ValidatedSpinbox` widget, dates get a `DateEntry` widget,
    and so on. Ideally, our source for information about each field should only be
    defined in one place, and that place should be the model. If we need to update
    the model for some reason, our form should synchronize with those changes.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们传递给 `LabelInput` 小部件的参数：它们包含许多也存在于我们模型中的信息。最小值、最大值、增量以及可能的值在这里和我们的模型代码中都被定义。甚至我们选择的输入小部件的类型也与存储的数据类型直接相关：数字得到一个
    `ValidatedSpinbox` 小部件，日期得到一个 `DateEntry` 小部件，依此类推。理想情况下，关于每个字段的信息来源应该只定义在一个地方，并且那个地方应该是模型。如果我们需要出于某种原因更新模型，我们的表单应该与这些更改同步。
- en: Rather than redundantly define these options in the view, we need to give our
    view access to the field specifications from our model so that the widgets' details
    can be determined from it. Since our widget instances are being defined inside
    the `LabelInput` class, we're going to enhance that class with the ability to
    automatically work out the input class and arguments from our model's field specification
    format.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是在视图中重复定义这些选项，我们需要让我们的视图能够访问来自我们模型的字段规范，以便小部件的详细信息可以从它中确定。由于我们的小部件实例是在 `LabelInput`
    类内部定义的，我们将增强该类，使其能够自动从我们模型的字段规范格式中确定输入类和参数。
- en: 'To do that, open up the `widgets.py` file. We''ll begin by importing the `FieldTypes`
    class, like so:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，打开 `widgets.py` 文件。我们将首先导入 `FieldTypes` 类，如下所示：
- en: '[PRE13]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, we need to tell the `LabelInput` class how to translate a field type
    into a widget class. To do that, locate the `LabelInput` class and add the following
    `field_types` class attribute just above the `__init__()` method:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要告诉 `LabelInput` 类如何将字段类型转换为控件类。为此，定位 `LabelInput` 类，并在 `__init__()`
    方法之上添加以下 `field_types` 类属性：
- en: '[PRE14]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This dictionary will act as a key to translate our model's field types into
    an appropriate widget type.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字典将作为键将我们的模型字段类型转换为适当的控件类型。
- en: Note that all of these widgets need to exist before we can create this dictionary,
    so be sure to place the `LabelInput` class definition at the *end* of `widgets.py`,
    if it's not already there.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有这些控件在我们可以创建这个字典之前都必须存在，所以请确保如果尚未放置在 `widgets.py` 的末尾，将 `LabelInput` 类定义放在
    *末尾*。
- en: 'Now, we need to update `LabelInput.__init__()` to take a `field_spec` argument
    and, if given, use it to define the parameters of the input widget. To begin with,
    update the argument list of the initializer as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新 `LabelInput.__init__()` 方法以接受一个 `field_spec` 参数，并在提供的情况下使用它来定义输入小部件的参数。首先，初始化器的参数列表应更新如下：
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although `field_spec` will largely remove the requirement for the `input_class`
    and `input_args` arguments, we're going to retain them in case we should later
    need to build a form that is not tied to a model.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `field_spec` 将在很大程度上消除对 `input_class` 和 `input_args` 参数的需求，但我们仍将保留它们，以防我们稍后需要构建一个与模型无关的表单。
- en: 'Inside the initializer method, we''ll need to read the field spec and apply
    the information. Add the following code after the variable setup and before the
    label setup:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化方法内部，我们需要读取字段规范并应用这些信息。在变量设置之后和标签设置之前添加以下代码：
- en: '[PRE16]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first thing we'll do with the `field_spec`, if it is supplied, is retrieve
    the field type. This will be used to look up an appropriate widget using the `field_types`
    dictionary. If we want to override this for a particular `LabelInput` instance,
    an explicitly passed `input_class` argument will override the lookup value.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`field_spec`，我们首先会做的是检索字段类型。这将用于使用`field_types`字典查找适当的控件。如果我们想为特定的`LabelInput`实例覆盖此查找值，可以显式传递一个`input_class`参数来覆盖查找值。
- en: Next, we need to set up the field parameters, `min`, `max`, `inc`, and `values`.
    For each of these, we check if the key exists in the field specification and make
    sure the corresponding `from_`, `to`, `increment`, or `values` argument has not
    been passed in explicitly using `input_args`. If so, we'll set up the `input_args`
    with the appropriate value. Now that `input_class` and `input_args` have been
    determined from the field specification, the remainder of the initializer method
    can continue as previously defined.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置字段参数，`min`、`max`、`inc`和`values`。对于这些中的每一个，我们检查键是否存在于字段规范中，并确保相应的`from_`、`to`、`increment`或`values`参数没有使用`input_args`显式传递。如果是这样，我们将使用适当的值设置`input_args`。现在，`input_class`和`input_args`已经从字段规范中确定，初始化方法剩余部分可以继续按照之前定义的方式进行。
- en: With `LabelInput` refactored to accept a `field_spec` argument, we can update
    our view code to take advantage of this new capability. To do this, our `DataRecordForm`
    class will first need access to the `model` object from which it can obtain the
    field specifications for the data model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将`LabelInput`重构为接受一个`field_spec`参数后，我们可以更新我们的视图代码以利用这个新功能。为此，我们的`DataRecordForm`类首先需要访问`model`对象，从而可以获取数据模型的字段规范。
- en: 'Back in the `views.py` file, edit the initializer method for `DataRecordForm`
    so that we can pass in a copy of the `model`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在`views.py`文件中，编辑`DataRecordForm`的初始化方法，以便我们可以传递`model`的一个副本：
- en: '[PRE17]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We've stored the `model` itself in an instance variable, and also extracted
    the `fields` dictionary into a local variable to cut down the code verbosity as
    we use this dictionary in the initializer method. Now, we can go through our `LabelInput`
    calls and replace the `input_args` and `input_class` arguments with a single `field_spec`
    argument.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`model`本身存储在一个实例变量中，并将`fields`字典提取到一个局部变量中，以减少我们使用此字典时的代码冗余。现在，我们可以遍历我们的`LabelInput`调用，并用单个`field_spec`参数替换`input_args`和`input_class`参数。
- en: 'With these changes, the first line looks like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改后，第一行看起来是这样的：
- en: '[PRE18]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Go ahead and update the rest of the widgets in the same way, replacing `input_class`
    and `input_args` with the `field_spec` argument. Note that when you get to the
    height fields, you'll still need to pass in an `input_args` dictionary to define
    the `min_var`, `max_var`, and `focus_update_var` arguments.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 按照同样的方式继续更新其他小部件，用`field_spec`参数替换`input_class`和`input_args`。注意，当你到达高度字段时，你仍然需要传递一个`input_args`字典来定义`min_var`、`max_var`和`focus_update_var`参数。
- en: 'For example, the following is the Min Height input definition:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下是最小高度输入定义：
- en: '[PRE19]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That does it. Now, any changes to a given field specification can be made solely
    in the model, and the form will simply do the correct thing.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在，任何对给定字段规范的更改都可以仅在模型中进行，表单将简单地做正确的事情。
- en: Using custom events to remove tight coupling
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自定义事件来移除紧密耦合
- en: Before we leave the `DataRecordForm` class, there is one fix we should make
    to improve the separation of concerns in our application. Currently, the `savebutton`
    widget on our form is bound to `self.master._on_save()`, which refers to the `_on_save()`
    method of the `Application` class. However, the way we have bound this command
    makes the assumption that `self.master` (that is, the parent widget of the `DataRecordForm`)
    is `Application`. What would happen if we decided to put our `DataRecordForm`
    widget inside a `Notebook` or `Frame` widget, rather than directly under the `Application`
    object? In that case, `self.master` would change and the code would break. Since
    the parent widget is really a layout concern, we would not expect that a change
    to it would impact the save button callback.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在离开`DataRecordForm`类之前，我们应该进行一个修改，以改善我们应用程序的关注点分离。目前，我们表单上的`savebutton`小部件绑定到`self.master._on_save()`，这指的是`Application`类的`_on_save()`方法。然而，我们绑定此命令的方式假设`self.master`（即`DataRecordForm`的父小部件）是`Application`。如果我们决定将我们的`DataRecordForm`小部件放入`Notebook`或`Frame`小部件中，而不是直接在`Application`对象下，会发生什么？在这种情况下，`self.master`将改变，代码将出错。由于父小部件实际上是布局问题，我们不会期望对其的更改会影响保存按钮回调。
- en: A situation like this, where a class depends too much on the architecture of
    the application outside the class, is known as **tight coupling**, and is something
    we should work to avoid in our code. Instead, we want **loose coupling** in our
    code so that changes to one class will not cause unexpected bugs in another.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况，即一个类过度依赖于类外部的应用程序架构，被称为**紧耦合**，这是我们应在代码中努力避免的。相反，我们希望在代码中实现**松耦合**，以便一个类的更改不会在另一个类中引起意外的错误。
- en: There are a few ways we could address this issue. We could pass a reference
    to the callback or the `Application` class to the view so that it could more explicitly
    reference the method in question. This would work, but it would still be tighter
    coupling than we'd ideally like to have.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以解决这个问题的几种方法。我们可以将回调或`Application`类的引用传递给视图，以便它可以更明确地引用相关的方法。这将有效，但仍然比我们理想中想要的耦合更紧密。
- en: A better approach is to utilize **events**. As you know, Tkinter generates an
    event whenever the user interacts with the GUI in some way, like clicking a button
    or making a keystroke. These events can be explicitly bound to a callback function
    using the `bind()` method of any Tkinter widget. Tkinter also allows us to generate
    our own custom events that we can bind just like the built-in ones.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是利用**事件**。正如你所知，Tkinter在用户以某种方式与GUI交互时生成事件，例如点击按钮或按键。这些事件可以使用任何Tkinter小部件的`bind()`方法显式绑定到回调函数。Tkinter还允许我们生成自己的自定义事件，我们可以像绑定内置事件一样绑定它们。
- en: 'Let''s implement a callback method in `DataRecordForm` that will generate a
    custom event, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`DataRecordForm`中实现一个回调方法，该方法将生成一个自定义事件，如下所示：
- en: '[PRE20]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `event_generate()` method can be called on any Tkinter widget to cause it
    to emit the event specified. In this case, we're calling our event `<<SaveRecord>>`.
    All custom event sequences must use double angle brackets to differentiate them
    from built-in event types. Apart from that, you can call them whatever you wish.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在任何Tkinter小部件上调用`event_generate()`方法，以使其发出指定的事件。在这种情况下，我们调用我们的事件`<<SaveRecord>>`。所有自定义事件序列都必须使用双尖括号来区分它们与内置事件类型。除此之外，你可以随意命名它们。
- en: 'Back in the `DataRecordForm.__init__()` method, we''ll update our save button
    definition to use this method as a callback, like so:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DataRecordForm.__init__()`方法中，我们将更新我们的保存按钮定义，使用此方法作为回调，如下所示：
- en: '[PRE21]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now, rather than directly executing the `Application` object's `_on_save()`
    method, the button will simply cause `DataRecordForm` to emit a message that the
    record-save operation was requested by the user. It will be the `Application`
    object's responsibility to deal with that message.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不再直接执行`Application`对象的`_on_save()`方法，按钮将简单地使`DataRecordForm`发出一个消息，表明用户请求了记录保存操作。处理这个消息将是`Application`对象的责任。
- en: We'll be utilizing custom events more extensively in *Chapter 7*, *Creating
    Menus with Menu and Tkinter Dialogs*, when we build our application menu.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建我们的应用程序菜单时，我们将在第7章*使用菜单和Tkinter对话框创建菜单*中更广泛地使用自定义事件。
- en: Creating the application file
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建应用程序文件
- en: The last piece we need to create is our controller and root window class, `Application`.
    Open the `application.py` file and copy in the `Application` class definition
    from the old `data_entry_app.py` file.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的最后一块是控制器和根窗口类，`Application`。打开`application.py`文件，并将`Application`类定义从旧的`data_entry_app.py`文件中复制过来。
- en: 'As before, we need to add the module imports required for this code. At the
    top of the file, add the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们需要添加此代码所需的模块导入。在文件顶部添加以下内容：
- en: '[PRE22]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once again, we need `tkinter` and `ttk`, of course; we also need the `views`
    module for our `DataRecordForm` and the `models` module for our `CSVModel`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们需要`tkinter`和`ttk`，当然；我们还需要`views`模块来使用我们的`DataRecordForm`，以及`models`模块来使用我们的`CSVModel`。
- en: 'Now, we''re going to need to make several changes to the `Application.__init__()`
    method. To begin with, we''ll need to create a model instance that we can pass
    to the `DataRecordForm` and to save our data. Create this object near the top
    of the initializer method:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要对`Application.__init__()`方法进行一些修改。首先，我们需要创建一个模型实例，我们可以将其传递给`DataRecordForm`并保存我们的数据。在初始化方法顶部创建此对象：
- en: '[PRE23]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we need to update the call to `DataRecordForm`, both to add the namespace
    and make sure we pass in the model instance, as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新对`DataRecordForm`的调用，既要添加命名空间，又要确保我们传递了模型实例，如下所示：
- en: '[PRE24]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We will also need to bind our custom event, `<<SaveRecord>>`, to the `Application`
    object''s record-save callback. Add the `bind` command like so:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将我们的自定义事件`<<SaveRecord>>`绑定到`Application`对象的记录保存回调。添加`bind`命令如下所示：
- en: '[PRE25]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to update the code in `Application._on_save()` to use the
    model. The new method should look like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新`Application._on_save()`中的代码以使用模型。新的方法应该看起来像这样：
- en: '[PRE26]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, using our model is pretty seamless; once we have checked for
    errors and retrieved the data from the form, we just pass it to `self.model.save_record()`.
    The `Application` doesn't have to know any details about how the data is saved.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，使用我们的模型非常无缝；一旦我们检查了错误并从表单中检索了数据，我们只需将其传递给`self.model.save_record()`。`Application`不需要了解数据是如何保存的细节。
- en: Note that we've added an argument of `*_` to the method definition. When we
    use `bind` to bind an event to a callback, the callback will receive an `event`
    object. We aren't going to be using this `event` argument, so by Python convention,
    we'll just roll up any positional arguments into a variable called `_` (underscore).
    This way, our callback can handle receiving arguments, but we've indicated we
    aren't going to use them.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在方法定义中添加了一个`*_`参数。当我们使用`bind`将事件绑定到回调时，回调将接收到一个`event`对象。我们不会使用这个`event`参数，所以按照Python的惯例，我们将所有位置参数合并到一个名为`_`（下划线）的变量中。这样，我们的回调可以处理接收参数，但我们已经表明我们不会使用它们。
- en: Running the application
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'The application is now completely migrated to the new data format. To test
    it, navigate to the application root folder, `ABQ_Data_Entry`, and execute the
    following command:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在已完全迁移到新的数据格式。要测试它，导航到应用程序根文件夹`ABQ_Data_Entry`，并执行以下命令：
- en: '[PRE27]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It should look and act just like the single script from *Chapter 5*, *Reducing
    User Error with Validation and Automation*, and run without errors, as shown in
    the following screenshot:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来和表现得就像第5章中的单个脚本一样，*《通过验证和自动化减少用户错误》*，并且运行时没有错误，如下面的截图所示：
- en: '![The application, still looking good!](img/B17578_06_04.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序，看起来依然很好！](img/B17578_06_04.png)'
- en: 'Figure 6.4: The ABQ Data Entry application – still looks the same after MVC
    refactoring!'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4：ABQ数据录入应用程序 – 在MVC重构后依然保持相同的外观！
- en: Success!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！
- en: Using version control software
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用版本控制软件
- en: 'Our code is nicely structured for expansion, but there''s one more critical
    item we should address: **version control**. You may already be familiar with
    a **version control system** (**VCS**), sometimes called **revision control**
    or **source code management**, but if not, it''s an indispensable tool for dealing
    with a large and changing code base.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码结构良好，便于扩展，但还有一个关键问题需要解决：**版本控制**。你可能已经熟悉了**版本控制系统**（**VCS**），有时也称为**修订控制**或**源代码管理**，但如果还不熟悉，它是一个处理大型且不断变化的代码库不可或缺的工具。
- en: When working on an application, we sometimes think we know what needs to be
    changed, but it turns out we're wrong. Sometimes, we don't know exactly how to
    code something, and it takes several attempts to find the correct approach. Sometimes,
    we need to revert to code that was changed a long time ago. Sometimes, we have
    multiple people working on the same piece of code, and we need to merge their
    changes together. Version control systems were created to address these issues
    and more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序上工作时，有时我们认为自己知道需要更改什么，但结果证明我们是错的。有时，我们不知道如何编写代码，需要多次尝试才能找到正确的方法。有时，我们需要恢复到很久以前更改过的代码。有时，有多个人在相同的代码片段上工作，我们需要合并他们的更改。版本控制系统正是为了解决这些问题和其他问题而创建的。
- en: 'There are dozens of different version control systems, but most of them follow
    essentially the same workflow:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 有数十种不同的版本控制系统，但它们大多数遵循本质上相同的流程：
- en: You have a **working copy** of the code to which you make changes
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一个**工作副本**的代码，你可以对其进行更改
- en: You periodically select changes and **commit** them to a **master copy**
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你定期选择更改并将它们**提交**到一个**主副本**
- en: You can **checkout** (that is, retrieve into your working copy) older versions
    of the code at any point, then later revert back to the master copy
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在任何时刻**检出**（即检索到你的工作副本）代码的旧版本，然后稍后恢复到主副本
- en: You can create **branches** of the code to experiment with different approaches,
    new features, or large refactors
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以创建代码的**分支**来尝试不同的方法、新功能或大规模重构
- en: You can later **merge** these branches back into the master copy
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以稍后**合并**这些分支回主副本
- en: 'VCS provides a safety net that gives you the freedom to change your code without
    the fear that you''ll hopelessly ruin it: reverting to a known working state is
    just a few quick commands away. It also helps us to document changes to our code
    and collaborate with others if the opportunity arises.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制系统（VCS）为你提供了一个安全网，让你在更改代码时无需担心会彻底破坏它：只需几个简单的命令就可以恢复到已知的工作状态。它还帮助我们记录代码的更改，并在有机会时与他人协作。
- en: There are dozens of version control systems available, but by far the most popular
    for many years now is **Git**. Let's take a look at how to use Git to track changes
    to our application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有数十种版本控制系统可用，但到目前为止，Git 仍然是许多年来最受欢迎的版本控制系统。让我们看看如何使用 Git 来跟踪应用程序的更改。
- en: A super-quick guide to using Git
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git 使用快速指南
- en: Git was created by Linus Torvalds to be the version control software for the
    Linux kernel project, and has since grown to be the most popular VC software in
    the world. It is utilized by source sharing sites like GitHub, Bitbucket, SourceForge,
    and GitLab. Git is extremely powerful, and mastering it can take months or years;
    fortunately, the basics can be grasped in a few minutes.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是由 Linus Torvalds 创建的，旨在成为 Linux 内核项目的版本控制系统，并从此发展成为世界上最受欢迎的版本控制系统。它被源代码共享网站如
    GitHub、Bitbucket、SourceForge 和 GitLab 所使用。Git 非常强大，掌握它可能需要数月或数年；幸运的是，基础可以在几分钟内掌握。
- en: First, you'll need to install Git; visit [https://git-scm.com/downloads](https://git-scm.com/downloads)
    for instructions on how to install Git on macOS, Windows, Linux, or other Unix
    operating systems.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要安装 Git；访问 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    获取在 macOS、Windows、Linux 或其他 Unix 操作系统上安装 Git 的说明。
- en: Initializing and configuring a Git repository
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 初始化和配置 Git 仓库
- en: 'Once Git is installed, we need to initialize and configure our project directory
    as a Git repository. To do this, open a command terminal, navigate to the application''s
    root directory (`ABQ_Data_Entry`), and run the following command:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: Git 安装完成后，我们需要初始化和配置我们的项目目录作为 Git 仓库。为此，打开一个命令终端，导航到应用程序的根目录（`ABQ_Data_Entry`），然后运行以下命令：
- en: '[PRE28]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This command creates a hidden directory under our project root called `.git`
    and initializes it with the basic files that make up the repository. The `.git`
    directory will contain all the data and metadata about our saved revisions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令会在我们的项目根目录下创建一个名为 `.git` 的隐藏目录，并用构成仓库的基本文件初始化它。`.git` 目录将包含关于我们保存的修订版本的所有数据和元数据。
- en: 'Before we add any files to the repository, we need to instruct Git to ignore
    certain kinds of files. For example, Python creates bytecode (`.pyc`) files whenever
    it executes a file, and we don''t want to save these as part of our code. To do
    this, create a file in your project root called `.gitignore` and put the following
    lines in it:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将任何文件添加到仓库之前，我们需要指导 Git 忽略某些类型的文件。例如，Python 在执行文件时创建字节码（`.pyc`）文件，而我们不想将这些文件作为代码的一部分保存。为此，在您的项目根目录中创建一个名为
    `.gitignore` 的文件，并在其中放入以下行：
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can add more directory names, filenames, or wildcard patterns to ignore
    various file types you don't want to save (for example, some editors create temporary
    files or backup copies by adding particular characters to a filename).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以添加更多的目录名、文件名或通配符模式来忽略您不想保存的文件类型（例如，某些编辑器通过在文件名中添加特定字符来创建临时文件或备份副本）。
- en: Adding and committing code
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加和提交代码
- en: 'Now that our repository has been initialized, we can add files and directories
    to our Git repository using the `git add` command, like so:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然我们的仓库已经初始化，我们可以使用 `git add` 命令将文件和目录添加到我们的 Git 仓库中，如下所示：
- en: '[PRE30]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At this point, our files have been **staged**, but not yet committed to the
    repository. Because a single change to an application may require altering several
    files, Git allows you to stage as many files as you wish to be part of a single
    commit. Note that we can specify directories rather than individual files; in
    this case, all the files currently inside the directory will be staged for our
    next commit.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的文件已经 **暂存**，但尚未提交到仓库。由于单个应用程序的更改可能需要更改多个文件，Git 允许您暂存任意数量的文件以作为单个提交的一部分。请注意，我们可以指定目录而不是单个文件；在这种情况下，目录中当前的所有文件都将为我们的下一次提交进行暂存。
- en: 'You can check the status of your repository and the files in it at any time
    by entering the command `git status`. Try this now and you should get the following
    output:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过输入命令 `git status` 在任何时间检查您仓库的状态以及其中的文件。现在尝试一下，你应该会得到以下输出：
- en: '[PRE31]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This shows you that all the files under `abq_data_entry/` and `docs/`, as well
    as the files you specified directly, are staged to be committed to the repository.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `abq_data_entry/` 和 `docs/` 目录下的所有文件，以及您直接指定的文件，都已准备好提交到仓库中。
- en: 'Let''s go ahead and commit the changes with the following command:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用以下命令提交更改：
- en: '[PRE32]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `-m` flag here allows you to specify a **commit message**, which is stored
    with the commit. Each time you commit code to the repository, you will be required
    to write a message. You should always make these messages as meaningful as possible,
    detailing what changes you made and the rationale behind them.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的 `-m` 标志允许您指定一个 **提交信息**，该信息与提交一起存储。每次您将代码提交到仓库时，您都需要编写一条信息。您应该始终使这些信息尽可能有意义，详细说明您所做的更改及其背后的原因。
- en: Viewing and using our commits
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看和使用我们的提交
- en: 'To view your repository''s history, run the `git log` command, like so:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看您仓库的历史记录，运行 `git log` 命令，如下所示：
- en: '[PRE33]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you can see, the `Author`, `Date`, and commit message is displayed for our
    last commit. If we had more commits, they would be listed here as well, from newest
    to oldest. The long hexadecimal value you see in the first line of output is the
    **commit hash**, a unique value that identifies the commit. This value can be
    used to refer to the commit in other operations.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Author`、`Date` 和提交信息显示为我们上次的提交。如果我们有更多的提交，它们也会按时间顺序从新到旧地列在这里。输出第一行中您看到的长的十六进制值是
    **提交哈希**，这是一个唯一值，用于标识提交。此值可以在其他操作中引用提交。
- en: 'For example, we can use it to reset our repository to a past state. Try this
    out by following these steps:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以用它来将我们的仓库重置到过去的状态。通过以下步骤尝试一下：
- en: Delete the `README.rst` file, and verify that it's completely gone.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `README.rst` 文件，并验证它是否已完全删除。
- en: Run `git log` to get the hash of your last commit.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行 `git log` 获取您上次提交的哈希值。
- en: Now, enter the command `git reset --hard df48707`, replacing `df48707` with
    the first seven characters of your last commit's hash.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入命令 `git reset --hard df48707`，将 `df48707` 替换为您上次提交哈希值的前七个字符。
- en: 'Check your file listing again: the `README.rst` file should be back.'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次检查您的文件列表：`README.rst` 文件应该已经恢复。
- en: What happened here is that we altered our repository, then told Git to **hard
    reset** the state of the repository to the last commit. If you don't want to reset
    your repository, you can also use `git checkout` to switch to an old commit temporarily,
    or use `git branch` to create a new branch using a particular commit as the base.
    As you can see already, this gives us a powerful safety net for experimentation;
    no matter how much you tinker with the code, any commit is just a command away!
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的情况是我们修改了我们的仓库，然后告诉 Git 将仓库的状态**硬重置**到最后的提交。如果你不想重置你的仓库，你也可以使用 `git checkout`
    临时切换到一个旧的提交，或者使用 `git branch` 创建一个新的分支，以特定的提交作为基础。正如你已看到的，这为我们提供了一个强大的安全网，用于实验；无论你对代码进行多少次修改，任何提交都只是命令之遥！
- en: Git has many more features that are beyond the scope of this book. If you'd
    like to learn more, the Git project provides a free online manual at [https://git-scm.com/book](https://git-scm.com/book),
    where you can learn about advanced features like branching and setting up remote
    repositories. For now, the important thing is to commit changes as you go, so
    that you maintain your safety net and document the history of changes.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: Git 有许多超出本书范围的功能。如果你想了解更多，Git 项目提供了一个免费的在线手册，网址为 [https://git-scm.com/book](https://git-scm.com/book)，在那里你可以了解关于分支和设置远程仓库等高级功能。现在，重要的是要边做边提交更改，这样你就可以保持你的安全网并记录更改的历史。
- en: Summary
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned to prepare your simple script for some serious
    expansion. You learned how to divide your application's areas of responsibility
    into separate components using the model-view-controller model. You reimplemented
    the ABQ application as a Python package, splitting the code into multiple modules
    to further enforce separation of concerns and provide an organized framework for
    later expansion. Finally, you set up a Git repository for your code so that you
    can track all your changes with version control.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何为你的简单脚本做一些重大的扩展。你学习了如何使用模型-视图-控制器模型将应用程序的责任区域划分为单独的组件。你将 ABQ 应用程序重新实现为一个
    Python 包，将代码拆分为多个模块，以进一步强化关注点的分离并为后续扩展提供一个有组织的框架。最后，你为你的代码设置了一个 Git 仓库，这样你就可以使用版本控制跟踪所有更改。
- en: In the next chapter, we're going to put the convenience of our new project layout
    to the test by implementing file opening and saving, informational popups, and
    a main menu. You'll also learn how to provide configurable settings for your application
    and save them to disk.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过实现文件打开和保存、信息弹出窗口和主菜单来测试我们新项目布局的便利性。你还将学习如何为你的应用程序提供可配置的设置并将它们保存到磁盘。
