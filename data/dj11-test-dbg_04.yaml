- en: 'Chapter 4. Getting Fancier: Django Unit Test Extensions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。变得更高级：Django单元测试扩展
- en: 'In the last chapter, we started learning how to use unit tests to test Django
    applications. This included learning about some Django-specific support, such
    as how to get test data loaded from fixture files into the database for a particular
    test. So far, though, our testing focus has been on small building blocks that
    make up the application. We have not yet begun to write code to serve up web pages
    for our application, nor considered how we will test whether the pages are served
    properly and contain the correct content. The Django `TestCase` class provides
    support that is useful for this broader kind of testing, which will be the focus
    of this chapter. In this chapter, we will:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们开始学习如何使用单元测试来测试Django应用程序。这包括学习一些Django特定的支持，比如如何将测试数据从装置文件加载到数据库中进行特定的测试。到目前为止，我们的测试重点一直是应用程序的组成部分。我们还没有开始编写用于为我们的应用程序提供网页服务的代码，也没有考虑如何测试页面是否被正确地提供并包含正确的内容。Django的`TestCase`类提供了对这种更广泛的测试有用的支持，这将是本章的重点。在本章中，我们将：
- en: First learn how to use a tests directory for our Django application tests instead
    of a single `tests.py` file. This will allow us to organize the tests logically
    instead of having all sorts of different tests mixed up in a single huge file.
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先学习如何使用一个tests目录来进行Django应用程序的测试，而不是单个的`tests.py`文件。这将使我们能够逻辑地组织测试，而不是将各种不同的测试混合在一个巨大的文件中。
- en: Develop some web pages for the survey application. For each, we will write unit
    tests to verify their correct operation, learning the specifics of the `TestCase`
    support for testing Django applications along the way.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为调查应用程序开发一些网页。对于每一个，我们将编写单元测试来验证它们的正确操作，途中学习测试Django应用程序的`TestCase`支持的具体细节。
- en: Experiment with adding custom validation to the `Survey` model in the admin
    application, and see how to test such customization.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试在管理应用程序的`Survey`模型中添加自定义验证，并查看如何测试这样的定制。
- en: Briefly discuss some aspects of Django's test support that we don't run across
    in our example tests.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要讨论一些Django测试支持中的方面，在我们的示例测试中没有遇到的。
- en: Finally, we will learn under what conditions it may be necessary to use an alternate
    unit test class, `TransactionTestCase`. This class does not perform as well as
    `TestCase`, but it supports testing some database transaction behavior that is
    not possible with `TestCase`.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们将学习在什么条件下可能需要使用替代的单元测试类`TransactionTestCase`。这个类的性能不如`TestCase`，但它支持测试一些使用`TestCase`不可能的数据库事务行为。
- en: Organizing tests
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织测试
- en: 'Before we set out to write code (and tests) for serving web pages from the
    survey application, let''s consider the tests we have so far. If we run `manage.py
    test survey -v2` and examine the tail end of the output, we can see that we''ve
    already accumulated over a dozen individual tests:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写用于为调查应用程序提供网页服务的代码（和测试）之前，让我们先考虑一下我们到目前为止所拥有的测试。如果我们运行`manage.py test
    survey -v2`并检查输出的末尾，我们会看到我们已经积累了超过十几个单独的测试：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Two of those, namely the two doctests with labels that start with `survey.models.Survey`,
    are from the `survey/models.py` file. The remaining 13 tests are all in the `survey/tests.py`
    file, which has grown to around 150 lines. Those numbers are not that big, but
    if you consider that we have barely started writing this application, it is clear
    that continuing to simply add to `tests.py` will soon result in an unwieldy test
    file. Since we are about to start moving on from building and testing the survey
    models to building and testing the code that serves web pages, now would be a
    good time to come up with a better organization for tests than a single file.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其中两个，即以`survey.models.Survey`开头的标签的两个doctest，来自`survey/models.py`文件。其余的13个测试都在`survey/tests.py`文件中，该文件已经增长到大约150行。这些数字并不算大，但是如果考虑到我们几乎刚刚开始编写这个应用程序，很明显，继续简单地添加到`tests.py`将很快导致一个难以管理的测试文件。由于我们即将开始从构建和测试调查模型转移到构建和测试提供网页服务的代码，现在是一个比单个文件更好的测试组织的好时机。
- en: Fortunately, this is not hard to do. Nothing in Django requires that the tests
    all reside in a single file; they simply need to be in a Python module named `tests`.
    So, we can create a subdirectory within `survey` named `tests`, and move our existing
    `tests.py` file into it. Since the tests in this file focus on testing the application's
    models, let's also rename it `model_tests.py`. We should also delete the `tests.pyc`
    file from `marketr/survey` since leaving stray `.pyc` files around after Python
    code reorganization can often cause confusion. Finally we need to create an `__init__.py`
    file inside the `tests` directory, so that Python will recognize it as a module.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这并不难做到。Django中没有要求测试都驻留在单个文件中；它们只需要在名为`tests`的Python模块中。因此，我们可以在`survey`中创建一个名为`tests`的子目录，并将现有的`tests.py`文件移动到其中。由于这个文件中的测试重点是测试应用程序的模型，让我们也将其重命名为`model_tests.py`。我们还应该删除`marketr/survey`中的`tests.pyc`文件，因为在Python代码重组后留下零散的`.pyc`文件通常会引起混乱。最后，我们需要在`tests`目录中创建一个`__init__.py`文件，以便Python将其识别为一个模块。
- en: 'Is that all? Not quite. Django uses `unittest.TestLoader.LoadTestsFromModule`
    to find and automatically load all of the `TestCase` classes in the `tests` module.
    However, we have now moved all of the `TestCase` classes into a submodule of tests,
    named `model_tests`. In order for `LoadTestsFromModule` to find them, we need
    to make them visible in the parent `tests` module, which we can do by adding an
    import for `model_tests` to the `__init__.py` file in `survey/tests`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些吗？并不完全是。Django使用`unittest.TestLoader.LoadTestsFromModule`来查找并自动加载`tests`模块中的所有`TestCase`类。然而，我们现在已经将所有的`TestCase`类移动到了名为`model_tests`的tests子模块中。为了让`LoadTestsFromModule`找到它们，我们需要使它们在父`tests`模块中可见，我们可以通过在`survey/tests`的`__init__.py`文件中添加对`model_tests`的导入来实现这一点：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now are we set? Almost. If we run `manage.py test survey -v2` now, we will
    see that the output reports 14 tests run, whereas the run prior to the reorganization
    reported 15 tests run:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好了吗？几乎。如果我们现在运行`manage.py test survey -v2`，我们会发现输出报告显示运行了14个测试，而在重新组织之前的运行中报告显示运行了15个测试：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Which test is missing? The very last test from the earlier run, that is the
    doctest in the `__test__` dictionary that had been in `tests.py`. Because `__test__`
    starts with an underscore (signaling it is a private attribute), it is not imported
    by `from model_tests import *`. The privacy implied by the naming is not enforced
    by Python, so we could add an explicit import for `__test__` as well to `survey/tests/__init__.py`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个测试丢失了？早期运行的最后一个测试，也就是`tests.py`中的`__test__`字典中的doctest。因为`__test__`以下划线开头（表示它是一个私有属性），所以它不会被`from
    model_tests import *`导入。命名所暗示的私有性并不受Python强制执行，因此我们也可以向`survey/tests/__init__.py`添加对`__test__`的显式导入：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If we did that and ran the tests again, we would see that we were back to having
    15 tests. However that is a poor solution, since it is not extensible to multiple
    files in the `tests` directory. If we add another file to our `tests` directory,
    say `view_tests.py`, and simply replicate the imports used for `model_tests.py`,
    we will have:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们这样做并再次运行测试，我们会发现我们又回到了15个测试。然而，这是一个很差的解决方案，因为它无法扩展到`tests`目录中的多个文件。如果我们向`tests`目录添加另一个文件，比如`view_tests.py`，并简单地复制用于`model_tests.py`的导入，我们将会有：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This will not cause any errors, but it also does not quite work. The second
    import of `__test__` completely replaces the first, so the doctests contained
    in `model_tests.py` are lost if we do this.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会导致任何错误，但也不完全有效。第二次导入`__test__`完全替换了第一次，因此如果我们这样做，`model_tests.py`中包含的doctests将会丢失。
- en: It would be easy enough to devise an approach that would be extensible to multiple
    files, perhaps by creating our own naming convention for doctests defined within
    individual test files. Then, code in `__init__.py` could create the `__test__`
    dictionary for the overall `tests` module by combining dictionaries from the individual
    test files that defined doctests. But for the purposes of the examples we are
    going to be studying here, that is unnecessarily complicated, since the additional
    tests we will be adding are all unit tests, not doctests.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易想出一种方法，可以扩展到多个文件，也许是通过为在单独的测试文件中定义的doctests创建我们自己的命名约定。然后，`__init__.py`中的代码可以通过将定义doctests的各个测试文件的字典合并为整个`tests`模块的`__test__`字典来实现。但是，出于我们将要研究的示例的目的，这是不必要复杂的，因为我们将要添加的额外测试都是单元测试，而不是doctests。
- en: In fact the doctests now in `model_tests.py` have also been re-implemented as
    unit tests, so they are redundant as tests and could safely be dropped. However,
    they do serve to point out an issue with doctests that will arise if you decide
    to move away from the single-file `tests.py` approach in your own projects. We
    can keep the doctests we already have by simply moving the `__test__` dictionary
    definition from the `model_tests.py` file to the `survey/tests/__init__.py` file.
    Then, if we decide additional doctests (beyond ones in `models.py`) would be useful,
    we can either simply add to this dictionary in `survey/tests/__init__.py` or come
    up with a more sophisticated approach to allow splitting out doctests as well
    as unit tests into different files.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，现在在`model_tests.py`中的doctests也已经被重新实现为单元测试，因此它们作为测试是多余的，可以安全地删除。然而，它们确实指出了一个与doctests相关的问题，如果您决定在自己的项目中摆脱单文件`tests.py`方法，这个问题就会出现。我们可以通过简单地将`model_tests.py`文件中的`__test__`字典定义移动到`survey/tests/__init__.py`文件中来保留我们已经拥有的doctests。然后，如果我们决定额外的doctests（超出`models.py`中的doctests）会很有用，我们可以简单地在`survey/tests/__init__.py`中添加到这个字典，或者想出一个更复杂的方法，允许将doctests以及单元测试拆分到不同的文件中。
- en: Note that it is not necessary to limit the `tests` directory tree to a single
    level. We could create a subdirectory for model tests, and one for views, and
    further subdivide these tests into individual files. Using the approach we have
    started with here, all that needs to be done is to include the proper imports
    in the various `__init__.py` files so that the test cases are visible at the top
    level of the `tests` package. How deep to make the tree and how small to make
    the individual test files are matters of personal preference. We will stick to
    a single level for now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不必将`tests`目录树限制在单个级别。我们可以为模型测试创建一个子目录，为视图创建一个子目录，并将这些测试进一步细分为单独的文件。使用我们在这里开始的方法，所需的只是在各种`__init__.py`文件中包含适当的导入，以便测试用例在`tests`包的顶层可见。将树设置多深以及将单个测试文件设置多小是个人偏好的问题。我们现在将坚持单层。
- en: Finally, note that you can take full control of what tests make up your application's
    test suite by defining a `suite()` function in the `models` and/or `tests` module
    for the application. The Django test runner looks for such a function in each
    of these modules, and if `suite()` exists, it is called to create the test suite.
    If provided, the `suite()` function must return an object suitable for passing
    as an argument to `unittest.TestSuite.addTest` (for example, a `unittest.TestSuite`).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，您可以通过在应用的`models`和/或`tests`模块中定义一个`suite()`函数来完全控制组成应用测试套件的测试。Django测试运行程序在这些模块中寻找这样的函数，如果`suite()`存在，就会调用它来创建测试套件。如果提供，`suite()`函数必须返回一个适合作为参数传递给`unittest.TestSuite.addTest`的对象（例如，一个`unittest.TestSuite`）。
- en: Creating the survey application home page
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建调查应用首页
- en: It is now time to turn our attention to building some web pages for the survey
    application. The first page to consider is the home page, which will be the starting
    point for general users doing anything with surveys. Ultimately, we would likely
    plan for this page to have many different elements, such as a standard header
    and footer, also maybe a sidebar or two for news and feedback. We'd plan to develop
    comprehensive stylesheets to give the application a pretty and consistent appearance.
    But all of that is beside the point of what we want to focus on right now, which
    is the main content of the home page.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候把注意力转向为调查应用程序构建一些网页了。首先要考虑的页面是主页，这将是一般用户进行任何与调查相关操作的起点。最终，我们可能计划让这个页面有许多不同的元素，比如标准的页眉和页脚，也可能有一两个侧边栏用于新闻和反馈。我们计划开发全面的样式表，以赋予应用程序漂亮和一致的外观。但所有这些都不是我们现在想要关注的重点，我们现在想要关注的是主页的主要内容。
- en: 'The primary function of the home page will be to provide a snapshot overview
    of the current state of surveys, and to provide links, where appropriate, to allow
    users to see details on individual surveys. The home page will show surveys grouped
    into three categories:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 主页的主要功能将是提供当前调查状态的快照概览，并在适当的情况下提供链接，以允许用户查看各个调查的详细信息。主页将显示分为三类的调查：
- en: First, there will be a list of currently open surveys. Each survey in this list
    will have a link for users to follow if they want to participate in the survey.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，将列出当前开放的调查。此列表中的每个调查都将有一个链接，供用户参与调查。
- en: Second, there will be a list of recently completed surveys. Each of these will
    also have a link to follow, but this link will bring up a page that allows users
    to see the survey results.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，将列出最近完成的调查。这些调查也将有一个链接，但这个链接将带来一个页面，允许用户查看调查结果。
- en: Third, there will be a list of surveys that will be opening soon. Surveys in
    this list will not have links since users cannot participate yet, nor are there
    results to be seen.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，将列出即将开放的调查。此列表中的调查将没有链接，因为用户还不能参与，也没有结果可见。
- en: 'In order to build and test this home page we need to do four things:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建和测试这个主页，我们需要做四件事情：
- en: First, we need to define the URLs that will be used to access the home page
    and any pages it links to, and define in the `urls.py` file how these URLs should
    map to the view code that will serve the pages.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要定义用于访问主页和任何链接到它的页面的URL，并在`urls.py`文件中定义这些URL应该如何映射到将提供页面的视图代码。
- en: Second, we need to implement the view code for serving the pages identified
    in step 1.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，我们需要实现用于提供第1步中识别的页面的视图代码。
- en: Third, we need to define the Django templates that will be used to render the
    responses generated in step 2.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三，我们需要定义Django模板，用于呈现第2步生成的响应。
- en: Finally, we need to write tests for each page.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要为每个页面编写测试。
- en: The following sections will focus on each of these steps in turn.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将依次关注这些步骤中的每一个。
- en: Defining the survey application URLs
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义调查应用程序的URL
- en: 'From the description of the survey home page, it sounds like we may have two
    or three different URLs to define. Certainly there is the home page itself, which
    is most naturally placed at the root of the survey application''s URL tree. We
    can define this by creating a `urls.py` file within the `survey` directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从调查主页的描述来看，我们可能需要定义两个或三个不同的URL。当然，首先是主页本身，最自然地放置在调查应用程序的URL树的根目录下。我们可以通过在`survey`目录中创建`urls.py`文件来定义这一点：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here we have specified that a request for the empty (root) URL should be handled
    by the `home` function in the `survey.views` module. Further we have given this
    URL the name `survey_home`, which we can use to refer to this URL from other code.
    Always using named URLs is good practice, as it allows for changing the actual
    URLs by simply changing the `urls.py` file and no other code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了对空（根）URL的请求应由`survey.views`模块中的`home`函数处理。此外，我们给这个URL命名为`survey_home`，我们可以在其他代码中使用这个名称来引用这个URL。始终使用命名URL是一个好的做法，因为它允许通过简单地更改`urls.py`文件而不需要更改其他代码来更改实际的URL。
- en: Besides the home page, there are also the pages linked from the home page to
    consider. First there are the pages linked from the list of active surveys, which
    allow users to participate in a survey. Second are the pages linked from the list
    of recently completed surveys, which allow users to see the results. You might
    ask, should these be covered by one or two URLs?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 除了主页，还有从主页链接过去的页面需要考虑。首先是从活动调查列表中链接的页面，允许用户参与调查。其次是从最近完成的调查列表中链接的页面，允许用户查看结果。你可能会问，这些是否应该由一个还是两个URL来覆盖？
- en: 'While it sounds like these may need different URLs, since the pages will show
    very different content, in a sense that they are both showing the same thing—the
    details for a particular survey. It is just that the current state of the survey
    will influence what its details page displays. Thus, we can choose to put the
    logic for deciding what exactly to display, based on survey state, into the view
    that handles displaying details for a survey. Then we can cover both of these
    types of pages with a single URL pattern. Taking this approach, the `survey/urls.py`
    file becomes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来这些可能需要不同的URL，因为页面将显示非常不同的内容，但从某种意义上说，它们都显示了同一件事情——特定调查的详细信息。只是调查的当前状态将影响其详细页面的显示。因此，我们可以选择将决定显示什么内容的逻辑，基于调查状态，放入处理显示调查详细信息的视图中。然后我们可以用一个URL模式来覆盖这两种类型的页面。采用这种方法，`survey/urls.py`文件变成了：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we have taken the approach of placing the primary key of the survey in
    the URL. Any URL which consists of a single path component containing one or more
    digits (the primary key) will be mapped to the `survey_detail` function in the
    `survey.views` module. This function will receive the primary key path component
    as an argument, `pk`, in addition to the standard request argument. Finally, this
    URL has been given the name `survey_detail`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们采取了将调查的主键放入URL的方法。任何由一个或多个数字（主键）组成的单个路径组件的URL将被映射到`survey.views`模块中的`survey_detail`函数。该函数将接收主键路径组件作为参数`pk`，以及标准的请求参数。最后，这个URL被命名为`survey_detail`。
- en: 'Those two URL patterns are enough to define the survey application pages we
    have considered so far. However, we still need to hook them into our project''s
    overall URL configuration. To do this, edit the project''s root `urls.py` file
    and add a line for the survey URLs. The `urlpatterns` variable in `urls.py` will
    then be defined like so:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个URL模式足以定义我们到目前为止考虑的调查应用程序页面。但是，我们仍然需要将它们连接到项目的整体URL配置中。为此，请编辑项目的根`urls.py`文件，并为调查URL添加一行。然后，`urls.py`中的`urlpatterns`变量将被定义如下：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last line we have added here specifies an empty URL pattern, `r''`. All
    matching URLs will be tested against the patterns found in the `urls.py` file
    contained in the `survey` module. The pattern `r''` will match every URL, and
    no part of the URL will be removed as already matched when it is tested against
    the URL patterns in `survey/urls.py`, so this essentially mounts the survey `urls.py`
    file at the root of the project's URL tree.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加的最后一行指定了一个空的URL模式`r''`。所有匹配的URL将被测试与`survey`模块中包含的`urls.py`文件中找到的模式相匹配。模式`r''`将匹配每个URL，并且在测试与`survey/urls.py`中的URL模式相匹配时，不会删除URL的任何部分，因此这实质上是将调查`urls.py`文件挂载到项目的URL树的根目录。
- en: Developing views to serve pages
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发视图以提供页面
- en: Now that we have defined our URLs and specified the view functions that should
    be called to serve them, it is time to start writing these functions. Or, perhaps
    we should start with the templates for these pages? Both need to be done and they
    are dependent on each other. The data returned by views is dependent on what the
    templates need, while the specifics of how the templates are written are dependent
    on the naming and structure of the data provided by the views. Thus, it can be
    hard to know which to start with, and it is sometimes necessary to alternate between
    them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的URL并指定了应该调用的视图函数来提供它们，是时候开始编写这些函数了。或者，也许我们应该从这些页面的模板开始？两者都需要完成，它们彼此之间是相互依赖的。视图返回的数据取决于模板的需求，而模板的编写方式取决于视图提供的数据的命名和结构。因此，很难知道从哪里开始，有时需要在它们之间交替进行。
- en: 'However, we have to start somewhere, and we will start with the views. In fact,
    whenever you add a reference to a view in a `urls.py` file, it is a good idea
    to immediately write at least a minimal implementation of that view. For example,
    for the two views we just added to `survey/urls.py`, we might immediately place
    the following in `survey/views.py`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们必须从某个地方开始，我们将从视图开始。实际上，每当您在`urls.py`文件中添加对视图的引用时，立即编写至少该视图的最小实现是一个好主意。例如，对于我们刚刚添加到`survey/urls.py`的两个视图，我们可能会立即将以下内容放在`survey/views.py`中：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These views both simply return an `HttpResponse` describing what the page is
    supposed to display. Creating placeholder views like this ensures that the overall
    URL pattern configuration for the project remains valid. Keeping this configuration
    valid is important because any attempt to perform a reverse URL mapping (from
    the name back to the actual URL) will result in an exception if there is any error
    (such as reference to a non-existent function) in any part of the URL pattern
    configuration. Thus, an invalid URL configuration can easily seem to break other
    perfectly innocent code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图只是简单地返回描述页面应该显示的`HttpResponse`。创建这样的占位视图可以确保项目的整体URL模式配置保持有效。保持这个配置有效很重要，因为任何尝试执行反向URL映射（从名称到实际URL）都会导致异常，如果在URL模式配置的任何部分中存在任何错误（例如引用不存在的函数）。因此，无效的URL配置很容易似乎破坏其他完全无辜的代码。
- en: The admin application, for example, needs to use reverse URL mapping to generate
    links on its pages. Thus an invalid URL pattern configuration can result in an
    exception being raised when a user attempts to access an admin page, even though
    there is no error in the admin code itself. This kind of exception can be very
    hard to debug since at first glance it seems that the problem is caused by code
    that is entirely separate from where the actual error is. Thus, even if you prefer
    to work on writing templates before view functions, it is best to always immediately
    provide at least a bare minimum implementation for any view you add to your URL
    pattern configuration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，管理应用程序需要使用反向URL映射在其页面上生成链接。因此，无效的URL模式配置可能导致在用户尝试访问管理页面时引发异常，即使管理代码本身没有错误。这种异常很难调试，因为乍一看似乎问题是由完全与实际错误位置分离的代码引起的。因此，即使您更喜欢在编写视图函数之前编写模板，最好立即为您添加到URL模式配置中的任何视图提供至少一个最低限度的实现。
- en: 'We can go a step beyond the bare minimum, though, at least for the home page
    view. As previously described, the home page will display three different lists
    of surveys: active, recently completed, and opening soon. It is unlikely that
    the template will need that data to be structured in any way more complicated
    than a simple list (or `QuerySet`), so the view for the home page is straightforward
    to write:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以进一步超越最低限度，至少对于主页视图是这样。如前所述，主页将显示三个不同的调查列表：活动的、最近完成的和即将开放的。模板可能不需要将数据结构化得比简单列表（或`QuerySet`）更复杂，因此主页的视图编写起来很简单：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This view sets three variables to be `QuerySets` containing the appropriate
    subsets of the `Surveys` in the database. The recently completed set is limited
    to surveys that have closed in the last two weeks, and the opening soon set is
    limited to those that will open in the next week. The view then calls the `render_to_response`
    shortcut to render the `survey/home.html` template passing along a context dictionary
    containing the three `Survey` subsets in the `active_surveys`, `completed_surveys`,
    and `upcoming_surveys` context variables.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这个视图设置了三个变量，它们是包含数据库中`Surveys`适当子集的`QuerySets`。最近完成的集合限于在过去两周内关闭的调查，即将开放的集合限于在下周将要开放的调查。然后，视图调用`render_to_response`快捷方式来渲染`survey/home.html`模板，并传递一个上下文字典，其中包含三个`Survey`子集，分别是`active_surveys`、`completed_surveys`和`upcoming_surveys`上下文变量。
- en: At this point, we can either proceed to replace the placeholder `survey_detail`
    view implementation with some real code, or we could get started on some templates.
    Writing the second view does not get us any closer to testing out the first one
    we've written, though, so moving on to the templates is better. The placeholder
    content for the second view will do fine for now.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以继续用一些真实的代码替换占位符`survey_detail`视图的实现，或者我们可以开始一些模板。编写第二个视图并不能让我们更接近测试我们已经编写的第一个视图，所以继续进行模板的工作会更好。暂时用于第二个视图的占位内容现在也可以。
- en: Creating templates for pages
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建页面模板
- en: To get started with writing templates for the survey application, first create
    a `templates` directory under `survey`, and then a `survey` directory under `templates`.
    Placing the templates under a `templates` directory in the application directory
    allows them to be automatically found by the `app_directories` template loader,
    which is enabled by default. Further, placing the templates in a `survey` directory
    under `templates` minimizes the chance of name conflicts with templates used by
    other applications.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写调查应用程序的模板，首先在`survey`下创建一个`templates`目录，然后在`templates`下创建一个`survey`目录。将模板放在应用程序目录下的`templates`目录下，可以使它们被默认启用的`app_directories`模板加载器自动找到。此外，将模板放在`templates`下的`survey`目录下，可以最大程度地减少与其他应用程序使用的模板的名称冲突的机会。
- en: Now, what templates do we need to create? The one named in the home view is
    `survey/home.html`. We could create just that one file and make it a full standalone
    HTTP document. But that would be unrealistic. Django provides a convenient template
    inheritance mechanism to allow for re-use of common page elements and selective
    override of defined blocks. At a minimum, we probably want to use a common base
    template that defines the overall document structure and block components, and
    then implements the individual page templates as child templates that extend the
    base template.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建哪些模板？在主页视图中命名的是`survey/home.html`。我们可以只创建一个文件，并将其作为一个完整的独立HTTP文档。但这是不现实的。Django提供了一个方便的模板继承机制，允许重用常见页面元素并选择性地覆盖已定义的块。至少，我们可能希望使用一个定义了整体文档结构和块组件的通用基础模板，然后将个别页面模板实现为扩展基础模板的子模板。
- en: 'Here''s a minimal `base.html` template we can use to start with:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小的`base.html`模板，我们可以用它来开始：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This document provides the overall HTML structure tags and defines just two
    blocks: `title` and `content`. The `title` block has default content of `Survey
    Central` that may be overridden by child templates, or left as is. The `content`
    block is initially empty, so child templates are expected to always provide something
    to fill in the body of the page.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文档提供了整体的HTML结构标签，并定义了两个块：`title`和`content`。`title`块的默认内容是`Survey Central`，可以被子模板覆盖，或者保持不变。`content`块最初是空的，因此期望子模板始终提供一些内容来填充页面的主体。
- en: 'Given that base template, we can write our `home.html` template as a child
    template that extends `base.html` and provides the content for the block `content`.
    We know that the `home` view is supplying three context variables (`active_surveys`,
    `completed_surveys`, and `upcoming_surveys`) containing the data that should be
    displayed. An initial implementation of the `home.html` template might look like
    this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 有了基础模板，我们可以将`home.html`模板编写为一个扩展`base.html`并为`content`块提供内容的子模板。我们知道`home`视图提供了三个上下文变量（`active_surveys`、`completed_surveys`和`upcoming_surveys`），其中包含应该显示的数据。`home.html`模板的初始实现可能如下所示：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: That may look a little intimidating, but it is straightforward. The template
    starts by specifying that it extends the `survey/base.html` template. It then
    proceeds to define what should be placed in the block `content` defined in `base.html`.
    The first element is a first-level heading `Welcome to Survey Central`. Then,
    if the `active_surveys` context variable is not empty, the heading is followed
    by a paragraph inviting people to take a survey, followed by a list of the active
    surveys. Each item in the list is specified as a link where the link target value
    is obtained by calling the Survey's `get_absolute_url` method (which we have not
    implemented yet). The visible text for each link is set to the `title` value of
    `Survey`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点吓人，但它很简单。模板首先指定它扩展了`survey/base.html`模板。然后继续定义应该放在`base.html`中定义的`content`块中的内容。第一个元素是一个一级标题`欢迎来到调查中心`。然后，如果`active_surveys`上下文变量不为空，标题后面会跟着一个邀请人们参加调查的段落，然后是活动调查的列表。列表中的每个项目都被指定为一个链接，链接目标值是通过调用Survey的`get_absolute_url`方法获得的（我们还没有实现）。每个链接的可见文本都设置为`Survey`的`title`值。
- en: A nearly identical paragraph and list is displayed for the `completed_surveys`,
    if there are any. Finally, the `upcoming_surveys` are handled similarly, except
    in their case no links are generated. Rather, the survey titles are listed along
    with the date when each survey will open.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有任何`completed_surveys`，则会显示一个几乎相同的段落和列表。最后，`upcoming_surveys`也会以类似的方式处理，只是在它们的情况下不会生成链接。相反，调查标题将与每个调查将开放的日期一起列出。
- en: Now, what is the `get_absolute_url` method used to generate the links to the
    active and completed surveys? This is a standard model method we can implement
    to provide the URL for a model instance on our site. In addition to using it in
    our own code, the admin application uses it, if it is implemented by a model,
    to provide a **View on site** link on the change page for model instances.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`get_absolute_url`方法用于生成活动和已完成调查的链接？这是一个标准的模型方法，我们可以实现它来为我们网站上的模型实例提供URL。除了在我们自己的代码中使用它之外，如果模型实现了它，管理应用程序也会使用它，在模型实例的更改页面上提供一个**在网站上查看**链接。
- en: 'Recall that in our `urls.py` file we named the URL for survey details `survey_detail`
    and that this view takes one argument, `pk`, which is the primary key of the `Survey`
    instance to display details about. Knowing that, we can implement this `get_absolute_url`
    method in the `Survey` model:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，在我们的`urls.py`文件中，我们为调查详情命名了URL为`survey_detail`，这个视图需要一个参数`pk`，这是要显示有关`Survey`实例的详细信息的主键。知道了这一点，我们可以在`Survey`模型中实现这个`get_absolute_url`方法：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method uses the `reverse` function provided by `django.core.urlresolvers`
    to construct the actual URL that will map to the URL named `survey_detail` with
    an argument value of the model instance's primary key value.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法使用了`django.core.urlresolvers`提供的`reverse`函数来构造实际的URL，该URL将映射到具有模型实例的主键值作为参数值的URL命名为`survey_detail`。
- en: 'Alternatively, we could use the convenient `models.permalink` decorator and
    avoid having to remember where the `reverse` function needs to be imported from:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，我们可以使用方便的`models.permalink`装饰器，避免记住`reverse`函数需要从哪里导入：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is equivalent to the first way of implementing `get_absolute_url`. This
    way simply hides the details of calling the reverse function, as that is done
    by the `models.permalink` code.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于实现`get_absolute_url`的第一种方式。这种方式只是隐藏了调用`reverse`函数的细节，因为`models.permalink`代码已经完成了这个工作。
- en: 'Now that we have created the home page view and the templates it uses, and
    implemented all of the model methods called from those templates, we can actually
    test the view. Ensure that the development server is running (or start it again
    with `manage.py runserver`), and then from a browser on the same machine, go to
    `http://localhost:8000/`. This should (assuming it has been less than a week since
    the `Winning Answers Test` from the last chapter was created) bring up a page
    that lists that survey as one that can be taken:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经创建了首页视图和它使用的模板，并实现了从这些模板调用的所有模型方法，我们实际上可以测试这个视图。确保开发服务器正在运行（或者使用`manage.py
    runserver`重新启动），然后从同一台机器上的浏览器中，转到`http://localhost:8000/`。这应该（假设自上一章创建的`Winning
    Answers Test`距今不到一周）会显示一个页面，列出可以参与的调查：
- en: '![Creating templates for pages](img/7566_04_01.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![为页面创建模板](img/7566_04_01.jpg)'
- en: If it has been longer than a week since that survey was created, it should show
    up under a paragraph that invites you to **See how your opinions compared to those
    of others!** instead. If it has been more than three weeks, the survey should
    not show up at all, in which case you may want to go back to the admin application
    and change its `closes` date so that it appears on the home page.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自从创建调查以来已经超过一周，它应该显示在一个段落下，邀请您**查看您的观点与他人的观点相比如何！**。如果已经超过三周，调查就不应该出现在首页上，这种情况下，您可能需要返回管理应用程序并更改其`closes`日期，以便它出现在首页上。
- en: 'That **Winning Answers Test** text is a link, which can be followed to verify
    that the `get_absolute_url` method for `Survey` is working, and further that the
    URL configuration we have set up is valid. Since we still have only the placeholder
    view implementation of the survey detail view, clicking the **Winning Answers
    Test** link will bring up a page that looks like this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 那个**Winning Answers Test**文本是一个链接，可以点击以验证`Survey`的`get_absolute_url`方法是否有效，并且我们设置的URL配置是否有效。由于我们仍然只有调查详情视图的占位符视图实现，点击**Winning
    Answers Test**链接将显示一个页面，看起来像这样：
- en: '![Creating templates for pages](img/7566_04_02.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![为页面创建模板](img/7566_04_02.jpg)'
- en: Not overly impressive, perhaps, but it does verify that the various pieces we
    have in place so far are working.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 也许并不是特别令人印象深刻，但它确实验证了我们迄今为止放置的各种部件是否有效。
- en: Of course, since we've only got one Survey in the database, we've only verified
    one part of the view and template. For a full test, we should also verify that
    the surveys in all three categories appear properly. In addition, we should verify
    that surveys in the database that should not appear either because they are too
    old or too far in the future do not in fact appear on the home page.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，由于数据库中只有一个调查，我们只验证了视图和模板的一部分。为了进行全面的测试，我们还应该验证所有三个类别中的调查是否正确显示。此外，我们还应该验证数据库中的调查是否不应该出现在首页上，因为它们太旧或太遥远。
- en: We might do all that now by manually adding surveys in the admin application
    and manually checking the contents of the home page as we make changes. However,
    what we really want to learn is how to write a test to verify that what we have
    now is correct and, more importantly, to allow us to verify that it remains correct
    as we continue to develop the application. Therefore, writing such a test is what
    we will focus on next.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过在管理应用程序中手动添加调查并在进行更改时手动检查首页的内容来完成所有这些工作。然而，我们真正想要学习的是如何编写一个测试来验证我们现在的工作是否正确，并且更重要的是，允许我们在继续开发应用程序时验证它是否保持正确。因此，编写这样的测试是我们接下来要关注的重点。
- en: Testing the survey home page
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试调查首页
- en: Before we think about how to write the test itself, let's consider the data
    the test will need and the best way to get that data into the database for the
    test. This test is going to be much like the `SurveyManagerTest` from the previous
    chapter, since determining correct behavior will depend on the relationship of
    the current date to dates contained in the test data. Therefore, using a fixture
    file for this data is not a good idea; it will be better to dynamically add the
    data in the test's `setUp` method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑如何编写测试本身之前，让我们考虑一下测试所需的数据以及将这些数据放入数据库进行测试的最佳方法。这个测试将与上一章的`SurveyManagerTest`非常相似，因为确定正确的行为将取决于当前日期与测试数据中包含的日期的关系。因此，使用一个fixture文件来存储这些数据并不是一个好主意；最好在测试的`setUp`方法中动态添加数据。
- en: We will begin, then, by writing a `setUp` method to create an appropriate set
    of data for testing the home page. Since we have moved on to testing the application's
    views, let's put it in a new file, `survey/tests/view_tests.py`. When we create
    that file, we need to also remember to add an `import` line for the new file (`from
    view_tests import *`) to the `__init__.py` file in `survey/tests`, so that the
    tests in it will be found by the test runner.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将首先编写一个`setUp`方法，为测试主页创建一个适当的数据集。由于我们已经开始测试应用的视图，让我们将其放在一个新文件`survey/tests/view_tests.py`中。当我们创建该文件时，我们还需要记得在`survey/tests`的`__init__.py`文件中添加一个`import`行，以便找到其中的测试。
- en: 'Here is a `setUp` method for our home page test:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们主页测试的`setUp`方法：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This method starts by stashing today''s date in a local variable `today`. It
    then deletes all existing `Surveys` in the database, just in case there are any
    loaded by initial data fixtures that could interfere with the proper execution
    of the test methods in this test case. It then creates eight `Surveys`: three
    completed, two active, and three upcoming.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法首先将今天的日期存储在一个本地变量`today`中。然后删除数据库中所有现有的`Surveys`，以防初始数据装置加载了任何可能干扰测试用例中的测试方法正确执行的调查。然后创建八个`Surveys`：三个已完成，两个活跃，三个即将到来的。
- en: The closing dates for the completed surveys are specifically set so as to test
    the boundaries of the window for what should appear on the home page. The oldest
    closing date is set just one day too far in the past (15 days) to be listed on
    the home page. The other two are set to the extreme edges of the window for what
    should appear as completed on the home page. The opens date for upcoming surveys
    is set similarly to test the limits of that window. One upcoming survey opens
    just one day too far in the future to appear on the home page while the other
    two open at the limits of the window for what should be shown as upcoming on the
    home page. Finally, there are two active surveys, one that opened yesterday and
    one that opened today, each with a default closing date seven days later, so both
    still open.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 已完成调查的截止日期被特别设置，以测试应该出现在主页上的窗口边界。最早的截止日期设置得比过去的时间多一天（15天），不会出现在主页上。其他两个设置为窗口边缘的极限，应该出现在主页上。即将到来的调查的开放日期也类似地设置，以测试该窗口的极限。一个即将到来的调查开放的时间比未来多一天，不会出现在主页上，而另外两个则在窗口的极限处开放，应该显示为即将到来的调查。最后，有两个活跃的调查，一个是昨天开放的，另一个是今天开放的，每个都有一个默认的截止日期，七天后关闭，所以两者都还在开放中。
- en: Now that we have a `setUp` routine to create test data, how do we write a test
    to check the contents of the home page? Django provides a class, `django.test.Client`,
    to help out here. An instance of this `Client` class acts like a web browser and
    can be used to request pages and examine the responses returned. Each `django.test.TestCase`
    class is automatically assigned a `Client` class instance that can be accessed
    using `self.client`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`setUp`例程来创建测试数据，那么我们如何编写一个测试来检查主页的内容呢？Django提供了一个类`django.test.Client`来帮助这里。这个`Client`类的实例就像一个Web浏览器，可以用来请求页面并检查返回的响应。每个`django.test.TestCase`类都会自动分配一个`Client`类的实例，可以使用`self.client`来访问。
- en: 'To see how to use the test `Client`, let''s examine the beginnings of a test
    for the survey application home page:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用测试`Client`，让我们来看一下调查应用主页测试的开始部分：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we have defined a `testHome` method within the `SurveyHomeTest`. This method
    uses the `get` method of the test's `client` class instance to retrieve the survey
    home page (again using `reverse` to determine the correct URL so as to ensure
    all URL configuration information is isolated in `urls.py`). The return value
    of `get` is the `django.http.HttpResponse` object returned by the view called
    to serve the requested page, annotated with some additional information to facilitate
    testing. The last line of the test verifies that the request was served successfully
    by ensuring that the `status_code` attribute of the returned response is `200`
    (HTTP OK).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SurveyHomeTest`中定义了一个`testHome`方法。这个方法使用测试的`client`类实例的`get`方法来检索调查主页（再次使用`reverse`来确定正确的URL，以确保所有URL配置信息都被隔离在`urls.py`中）。`get`的返回值是由调用来提供请求页面的视图返回的`django.http.HttpResponse`对象，附带一些额外的信息以便于测试。测试的最后一行通过确保返回的响应的`status_code`属性为`200`（HTTP
    OK）来验证请求是否成功。
- en: Note that the `get` method supplied by the test `Client` supports more than
    the single URL parameter we are passing here. In addition, it supports two keyword
    arguments, `data` and `follow`, which default to an empty dictionary and `False`
    respectively. Finally, any number of `extra` keyword arguments may also be supplied.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试`Client`提供的`get`方法支持不止我们在这里传递的单个URL参数。此外，它支持两个关键字参数`data`和`follow`，它们分别默认为空字典和`False`。最后，还可以提供任意数量的`extra`关键字参数。
- en: 'The `data` dictionary, if non-empty, is used to construct a query string for
    the request. For example, consider a `get` method such as this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`data`字典不为空，则用于构造请求的查询字符串。例如，考虑这样一个`get`方法：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The URL created for processing this request would be `/survey/?pk=4&type=results`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理这个请求创建的URL将是`/survey/?pk=4&type=results`。
- en: 'Note you can also include a query string in the URL path passed to `get`. So
    an equivalent call would be:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以在传递给`get`的URL路径中包含查询字符串。因此，等效的调用将是：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If both a `data` dictionary and a query string in the URL path are provided,
    the `data` dictionary is used for processing the request and the query string
    in the URL path is ignored.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了`data`字典和URL路径中的查询字符串，则`data`字典用于处理请求，URL路径中的查询字符串将被忽略。
- en: The `follow` argument to `get` can be set to `True` in order to instruct the
    test client to follow redirects in the response. If it does so, a `redirect_chain`
    attribute will be set on the returned response. This attribute will be a list
    describing the intermediate URLs visited before the end of the redirect chain.
    Each element in the list will be a tuple containing the intermediate URL path
    and the status code that prompted it to be retrieved.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`get`的`follow`参数可以设置为`True`，以指示测试客户端跟随响应中的重定向。如果是这样，返回的响应将设置一个`redirect_chain`属性。这个属性将是一个描述重定向链结束之前访问的中间URL的列表。列表中的每个元素将是一个元组，包含中间URL路径和触发它被检索的状态代码。'
- en: 'Finally, any `extra` keyword arguments can be used to set arbitrary HTTP header
    values in the request. For example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，任何`extra`关键字参数都可以用于在请求中设置任意的HTTP标头值。例如：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This call will set the `HTTP_USER_AGENT` header in the request to `Tester`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用将在请求中将`HTTP_USER_AGENT`标头设置为`Tester`。
- en: Returning to our own test, which supplies only the URL path argument, we can
    run it now with `manage.py test survey.SurveyHomeTest` and verify that so far
    everything looks good. We can retrieve the home page and the response comes back
    with a successful status code. But what about testing the contents of the page?
    We'd like to make sure that the various surveys that should appear are appearing,
    and further that the two surveys in the database that should not appear on the
    page are not listed.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 针对我们自己的测试，只提供URL路径参数，我们现在可以使用`manage.py test survey.SurveyHomeTest`来运行它，并验证到目前为止一切看起来都很好。我们可以检索主页，响应返回成功的状态代码。但是如何测试页面的内容呢？我们希望确保应该出现的各种调查都出现了，并且数据库中不应该出现在页面上的两个调查也没有列出。
- en: The actual page content returned is stored in the `content` attribute of the
    response. We can examine this directly, but the Django `TestCase` class also provides
    two methods to check whether or not certain text appears in the response. These
    methods are named `assertContains` and `assertNotContains`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的实际页面内容存储在响应的`content`属性中。我们可以直接检查这一点，但是Django `TestCase`类还提供了两种方法来检查响应中是否包含某些文本。这些方法分别命名为`assertContains`和`assertNotContains`。
- en: To use the `assertContains` method we pass in the `response` and the text we
    are looking for. We can also optionally specify a `count` of the number of times
    that text should appear. If we specify `count`, the text must appear exactly that
    many times in the response. If we do not specify `count`, `assertContains` simply
    checks that the text appears at least once. Finally, we may specify the `status_code`
    that the response should have. If we do not specify this, then `assertContains`
    verifies that the status code is 200.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`assertContains`方法，我们传入`response`和我们要查找的文本。我们还可以选择指定文本应该出现的次数。如果我们指定了`count`，则文本必须在响应中出现相同的次数。如果我们没有指定`count`，`assertContains`只是检查文本是否至少出现一次。最后，我们可以指定响应应该具有的`status_code`。如果我们没有指定这一点，那么`assertContains`将验证状态代码是否为200。
- en: The `assertNotContains` method takes the same arguments as `assertContains`
    with the exception of `count`. It verifies that the passed text does not appear
    in the response content.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertNotContains`方法与`assertContains`具有相同的参数，但不包括`count`。它验证传递的文本是否不出现在响应内容中。'
- en: 'We can use these two methods to verify that the home page contains two instances
    each of `Completed`, `Active`, and `Upcoming`, and that it does not contain either
    `Too Old` or `Too Far Out`. Furthermore, since these methods check the status
    code, we can remove that check from our own test code. Thus the test method becomes:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这两种方法来验证主页是否包含`Completed`、`Active`和`Upcoming`各两个实例，并且不包含`Too Old`或`Too
    Far Out`。此外，由于这些方法检查状态代码，我们可以从我们自己的测试代码中删除该检查。因此，测试方法变为：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: If we try running this version, we will see that it works. However, it is not
    as specific as we might like it to be. Namely, it does not verify that the listed
    surveys are appearing in the right places on the page. This test as it is right
    now would pass with all of the listed surveys appearing under the paragraph **Take
    a survey now!**, for example. How can we verify that each is appearing in the
    appropriate list?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行这个版本，我们会看到它可以工作。但是，它并不像我们希望的那样具体。换句话说，它没有验证列出的调查是否出现在页面上的正确位置。例如，当前的测试将通过，即使所有列出的调查都出现在段落**现在参与调查！**下面。我们如何验证每个调查是否出现在适当的列表中呢？
- en: One approach would be to manually examine `response.content`, find where each
    of the expected strings is located, and ensure that they all appear in the expected
    order. However, that would make the test very dependent on the exact layout of
    the page. We might in the future decide to reorder the presentation of the lists
    and this test could then break, even though each survey was still being listed
    in the correct category.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是手动检查`response.content`，找到每个预期字符串的位置，并确保它们按预期顺序出现。但是，这将使测试非常依赖页面的确切布局。将来我们可能决定重新排列列表的呈现方式，这个测试可能会失败，即使每个调查仍然被列在正确的类别中。
- en: 'What we really want to do is verify that the surveys are contained in the appropriate
    context variables passed to the template. We can in fact test this, since the
    response returned by `client.get` is annotated with the context used to render
    the template. Thus, we can check the completed survey list, for example, like
    so:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要做的是验证调查是否包含在传递给模板的适当上下文变量中。实际上我们可以测试这一点，因为`client.get`返回的响应带有用于呈现模板的上下文的注释。因此，我们可以这样检查已完成的调查列表：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code retrieves the `completed_surveys` context variable from the response
    context, verifies it has `2` items in it, and further verifies that each of the
    items has a `title` that starts with the string `Completed`. If we run that code,
    we''ll see it works for checking the completed surveys. We can then either duplicate
    that block two more times and tweak it appropriately to check the active and upcoming
    surveys, or we can get a little fancier and write something more like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码从响应上下文中检索 `completed_surveys` 上下文变量，验证其中是否有 `2` 个项目，并进一步验证每个项目是否具有以字符串 `Completed`
    开头的 `title`。如果我们运行该代码，我们会看到它适用于检查已完成的调查。然后，我们可以将该代码块复制两次，并适当调整，以检查活动和即将开始的调查，或者我们可以变得更加复杂，编写类似于这样的代码：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here we have avoided duplicating, essentially, the same block of code three
    times with just minor differences by constructing a list of things to check and
    then iterating through that list. Thus, we only have the code block appearing
    once, but it is looped through three times, once for each of the context variables
    we want to check. This is a common technique used to avoid duplicating code that
    is almost identical multiple times.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过构建一个要检查的事项列表，然后遍历该列表，避免了基本上三次重复相同的代码块，只是有些微的差异。因此，我们只有一个代码块出现一次，但它循环三次，每次都是为了检查我们想要检查的上下文变量之一。这是一种常用的技术，用于避免多次重复几乎相同的代码。
- en: 'Note that when this sort of technique is used in tests, though, it is a good
    idea to take the effort to include specific messages in the assertion checks.
    In the original version of the code, which tested the completed list directly,
    if there was an error such as too many surveys in that list, a test failure would
    produce a reasonably descriptive error report:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当在测试中使用这种技术时，最好在断言检查中包含具体的消息。在代码的原始版本中，直接测试已完成的列表，如果出现错误，比如列表中有太多的调查，测试失败将产生一个相当具体的错误报告：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'There the code that is failing includes the string **completed** so it is clear
    which list is having a problem. With a more generalized version of the code, this
    report becomes much less helpful:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，包含字符串 **completed** 的代码失败，因此清楚哪个列表出了问题。使用代码的更通用版本，这个报告就不那么有帮助了：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The poor programmer encountering that failure report would have no way of knowing
    which of the three lists had too many items. By providing a specific error message
    with the assertion, however, this can be made clear. So a better version of the
    full test method with descriptive errors would be:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到这种失败报告的可怜程序员将无法知道这三个列表中哪一个有太多的项目。然而，通过提供具体的断言错误消息，这一点可以变得清晰。因此，具有描述性错误的完整测试方法的更好版本将是：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now if there is a failure during the checks in the generalized code, the error
    message is specific enough to indicate where the problem is:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果在通用代码的检查过程中出现故障，错误消息已经具体到足以指出问题所在：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We now have a reasonably complete test for our survey home page, or at least
    as much of it as we have implemented so far. It is time to turn our attention
    to the survey detail pages, which we will cover next.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对我们的调查主页有一个相当完整的测试，或者至少是我们迄今为止实施的部分。是时候把注意力转向调查详细页面了，接下来我们将介绍这部分内容。
- en: Creating the survey detail pages
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建调查详细页面
- en: The second URL mapping we added to our project's URL configuration was for the
    survey detail pages. Implementing this view is a little more complicated than
    the home page view since quite different data will need to be presented depending
    on the state of the requested survey. If the survey is completed, we need to display
    the results. If the survey is active, we need to display a form allowing the user
    to participate in the survey. If the survey is upcoming, we don't want the survey
    to be visible at all.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在项目的 URL 配置中添加的第二个 URL 映射是用于调查详细页面的。实现这个视图比主页视图要复杂一些，因为根据请求的调查状态，需要呈现完全不同的数据。如果调查已完成，我们需要显示结果。如果调查正在进行中，我们需要显示一个表单，允许用户参与调查。如果调查即将开始，我们不希望调查可见。
- en: To do all of that at once, without testing along the way to verify we are headed
    in the right direction, would be asking for trouble. It's best to break the task
    down into smaller pieces and test as we go. We'll take the first step in that
    direction in the following sections.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性完成所有这些工作，而不在验证的过程中进行测试以确保我们朝着正确的方向前进，那将是在自找麻烦。最好将任务分解成较小的部分，并在进行测试时逐步进行。我们将在接下来的部分中迈出朝着这个方向的第一步。
- en: Refining the survey detail view
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完善调查详细视图
- en: 'The first thing to do is to replace the simple placeholder view for the survey
    detail page with a view that determines the requested survey''s state and routes
    the request appropriately. For example:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的是用一个视图替换调查详细页面的简单占位符视图，该视图确定请求的调查状态，并适当地路由请求。例如：
- en: '[PRE26]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This `survey_detail` view uses the `get_object_or_404` shortcut to retrieve
    the requested `Survey` from the database. The shortcut will automatically raise
    an `Http404` exception if the requested survey does not exist, so the following
    code does not have to account for that case. The view then checks the `closes`
    date on the returned `Survey` instance. If it closed before today, the request
    is sent on to a function named `display_completed_survey`. Otherwise, if the survey
    has not yet opened, an `Http404` exception is raised. Finally, if neither of those
    conditions hold, the survey must be active so the request is routed to a function
    named `display_active_survey`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `survey_detail` 视图使用 `get_object_or_404` 快捷方式从数据库中检索请求的 `Survey`。如果请求的调查不存在，该快捷方式将自动引发
    `Http404` 异常，因此以下代码不必考虑这种情况。然后，视图检查返回的 `Survey` 实例上的 `closes` 日期。如果它在今天之前关闭，请求将被发送到名为
    `display_completed_survey` 的函数。否则，如果调查尚未开放，将引发 `Http404` 异常。最后，如果这些条件都不成立，调查必须是活动的，因此请求将被路由到名为
    `display_active_survey` 的函数。
- en: 'To start out with, we will implement the two new functions very simply. They
    will not do any of the real work required for their case, but they will each use
    a different template when rendering their response:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将非常简单地实现这两个新函数。它们不会执行它们的情况所需的任何真正工作，但它们在呈现响应时将使用不同的模板：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: With just that much code, we can proceed to test whether surveys in different
    states are being routed correctly. First though, we need to create the two new
    templates that the view code has introduced.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 只需这么多代码，我们就可以继续测试不同州的调查是否被正确路由。不过，首先，我们需要创建视图代码引入的两个新模板。
- en: Templates for the survey detail pages
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查详细页面的模板
- en: 'The two new templates are named `survey/completed_survey.html` and `survey/active_survey.html`.
    Create them under the `survey/templates` directory. To start out with, they can
    be very simple. For example, `completed_survey.html` may be:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个新模板的名称分别是`survey/completed_survey.html`和`survey/active_survey.html`。将它们创建在`survey/templates`目录下。一开始，它们可以非常简单。例如，`completed_survey.html`可能是：
- en: '[PRE28]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Similarly, `active_survey.html` could be:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，`active_survey.html`可能是：
- en: '[PRE29]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Each of these extends the `survey/base.html` template and provides minimal but
    descriptive content for the `content` block. In each case, all that will be displayed
    is a first-level header identifying the survey by title and whether the page is
    showing results or questions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板都扩展了`survey/base.html`模板，并为`content`块提供了最少但描述性的内容。在每种情况下，显示的只是一个一级标题，用标题标识调查，以及页面是否显示结果或问题。
- en: Basic testing of the survey detail pages
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调查详细页面的基本测试
- en: Now consider how we can test whether the routing code in `survey_detail` is
    working correctly. Again, we are going to need test data containing at least one
    survey in each of the three states. We have that with the test data we created
    in the `setUp` method of `SurveyHomeTest`. However, adding methods to the home
    page test case that actually tests survey detail page views would be confusing.
    Duplicating very similar `setUp` code is also not very attractive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑如何测试`survey_detail`中的路由代码是否工作正常。同样，我们需要测试数据，其中至少有一个调查处于三种状态之一。我们在`SurveyHomeTest`的`setUp`方法中创建的测试数据就包含了这些。然而，向主页测试用例添加实际测试调查详细页面视图的方法会很混乱。重复非常相似的`setUp`代码也不太吸引人。
- en: Fortunately, we do not need to do either. What we can do is move the existing
    `setUp` code into a more general test case, say `SurveyTest`, and then base both
    `SurveyHomeTest` and our new `SurveyDetailTest` on this new `SurveyTest`. In this
    way, both the home page test and the detail page test will have the same data
    created in the database by the base `SurveyTest setUp` method. Furthermore, any
    additional tests that need similar data could also inherit from `SurveyTest`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要做任何一种。我们可以将现有的`setUp`代码移到一个更一般的测试用例中，比如`SurveyTest`，然后基于这个新的`SurveyTest`来构建`SurveyHomeTest`和我们的新的`SurveyDetailTest`。通过这种方式，主页测试和详细页面测试将在数据库中由基本的`SurveyTest
    setUp`方法创建相同的数据。此外，任何需要类似数据的其他测试也可以继承自`SurveyTest`。
- en: 'Given we have the test data in place, what can we do to test what we have implemented
    so far of the detail view? The case of an upcoming survey is easy enough, since
    it should simply return an HTTP 404 (NOT FOUND) page. Thus, we can start by creating
    a method for that case in our `SurveyDetailTest`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于我们已经有了测试数据，我们可以做些什么来测试我们迄今为止实现的详细视图？即将到来的调查的情况很容易，因为它应该简单地返回一个HTTP 404（未找到）页面。因此，我们可以从`SurveyDetailTest`中为这种情况创建一个方法开始：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `testUpcoming` method retrieves one of the upcoming surveys from the database,
    and uses the test `client` to request the page containing details on that survey.
    Again we use `reverse` to construct the appropriate URL for the details page,
    passing in the primary key of the survey we are requesting as the single argument
    in the `args` tuple. Correct handling of this request is tested by ensuring that
    the `status_code` of the response is 404\. If we run this test now, we will see:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`testUpcoming`方法从数据库中检索一个即将到来的调查，并使用测试`client`请求包含该调查详细信息的页面。再次使用`reverse`来构建适当的详细页面的URL，将我们请求的调查的主键作为`args`元组中的单个参数传递。通过确保响应的`status_code`为404来测试对这个请求的正确处理。如果我们现在运行这个测试，我们会看到：'
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Oops. In order for the `survey_detail` view to successfully raise an `Http404`
    and have that result in a "page not found" response, a `404.html` template must
    exist in the project. We have not yet created one, so this test generates an error.
    To fix this, we can create a simple `survey/templates/404.html` file containing:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕。为了使`survey_detail`视图成功引发`Http404`并导致“页面未找到”响应，项目中必须存在一个`404.html`模板。我们还没有创建一个，所以这个测试生成了一个错误。为了解决这个问题，我们可以创建一个简单的`survey/templates/404.html`文件，其中包含：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At the same time, we should also create a `survey/templates/500.html` file in
    order to avoid any similar unhelpful errors in cases where a server error is encountered.
    A simple `500.html` file to use for now would be much like this `404.html` file,
    with the text changed to indicate the problem is a server error, and not a page
    not found situation.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还应该创建一个`survey/templates/500.html`文件，以避免在遇到服务器错误的情况下出现类似的无用错误。现在使用的一个简单的`500.html`文件会很像这个`404.html`文件，只是将文本更改为指示问题是服务器错误，而不是页面未找到的情况。
- en: With the `404.html` template in place, we can attempt to run this test again
    and this time, it will pass.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 有了`404.html`模板，我们可以尝试再次运行这个测试，这一次，它会通过。
- en: 'What about testing the pages for completed and active surveys? We could write
    tests that check `response.content` for the header text we have placed in each
    of their respective templates. However, that text may not remain the same as we
    continue development—at this point that is just placeholder text. It would be
    better to verify that the correct templates were used to render each of these
    responses. The `TestCase` class has a method for that: `assertTemplateUsed`. Thus,
    we can write tests for these cases that are likely to continue to work properly
    in the long-run, like so:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 那么如何测试已完成和活动调查的页面呢？我们可以编写测试，检查`response.content`中我们放置在各自模板中的标题文本。然而，随着我们继续开发，该文本可能不会保持不变——在这一点上，它只是占位文本。最好验证正确的模板是否用于呈现每个响应。`TestCase`类有一个用于此目的的方法：`assertTemplateUsed`。因此，我们可以编写这些在长期内可能会继续正常工作的情况的测试，如下所示：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Each of these test methods retrieves a survey from the appropriate category
    and requests the detail page for that survey. So far, the only test done on the
    responses is to check that the expected template was used to render the response.
    Again, we can run these tests now and verify that they pass.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试方法都从适当的类别中检索调查，并请求该调查的详细页面。到目前为止，对响应的唯一测试是检查是否使用了预期的模板来呈现响应。同样，我们现在可以运行这些测试并验证它们是否通过。
- en: In addition to `assertTemplateUsed`, there is an `assertTemplateNotUsed` method
    provided by `TestCase`. It takes the same arguments as `assertTempalteUsed`. As
    you might expect, it verifies that the specified template was not used to render
    the response.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 除了“assertTemplateUsed”之外，`TestCase`还提供了一个`assertTemplateNotUsed`方法。它接受与`assertTempalteUsed`相同的参数。正如你所期望的那样，它验证指定的模板未被用于呈现响应。
- en: At this point, we are going to take a break from implementing `survey` application
    pages. The next unit test topic to cover is how to test pages that accept user
    input. We don't have any of those in the survey application yet, but the Django
    admin application does. Thus, the task of testing an admin customization provides
    a quicker route to learning how to test such pages, since we'll need to write
    less custom code before developing the test. In addition to this, learning how
    to test admin customizations is useful in its own right.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们将暂停实施“survey”应用程序页面。下一个单元测试主题是如何测试接受用户输入的页面。我们在调查应用程序中还没有这样的页面，但Django管理员应用程序有。因此，在开发测试之前，测试管理员自定义提供了学习如何测试这些页面的更快捷的途径，因为我们需要编写更少的自定义代码。此外，学习如何测试管理员自定义本身也是有用的。
- en: Customizing the admin add and change survey pages
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义管理员添加和更改调查页面
- en: We've already seen how the Django admin application provides a convenient way
    to examine and manipulate data in our database. In the previous chapter, we set
    up the admin with some simple customizations to allow editing `Questions` inline
    with `Surveys` and `Answers` inline with `Questions`. Besides those inline customizations,
    however, we made no changes to the admin defaults.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到Django管理员应用程序提供了一种方便的方式来检查和操作数据库中的数据。在上一章中，我们对管理员进行了一些简单的自定义，以允许在“Surveys”中内联编辑“Questions”和在“Questions”中内联编辑“Answers”。除了这些内联自定义之外，我们没有对管理员默认值进行任何更改。
- en: One additional change that would be good to make to the admin is to ensure that
    `Survey opens` and `closes` dates are valid. Clearly for this application, it
    makes no sense to have an `opens` date that is later than `closes`, but there
    is no way for the admin to know that. In this section, we will customize the admin
    to enforce our application requirement on the relationship between `opens` and
    `closes`. We will also develop a test for this customization.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 对管理员进行的另一个很好的改变是确保“Survey opens”和“closes”日期是有效的。显然，对于这个应用程序，拥有一个晚于“closes”的“opens”日期是没有意义的，但管理员无法知道这一点。在这一部分，我们将自定义管理员以强制执行我们的应用程序对“opens”和“closes”之间关系的要求。我们还将为此自定义开发一个测试。
- en: Developing a custom survey form
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发自定义调查表单
- en: 'The first step in implementing this admin customization is to implement a form
    for `Survey` that includes custom validation. For example:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实施此管理员自定义的第一步是为“Survey”实施一个包括自定义验证的表单。例如：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a standard `ModelForm` for the `Survey` model. Since the validation
    we want to perform involves multiple fields on the form, the best place to put
    it is in the overall form `clean` method. The method here retrieves the `opens`
    and `closes` values from the form's `cleaned_data` dictionary. Then, if they have
    both been provided, it checks to see if `opens` is later than `closes`. If so,
    a `ValidationError` is raised, otherwise everything is OK, so the existing `cleaned_data`
    dictionary is returned unmodified from `clean`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Survey`模型的标准`ModelForm`。由于我们想要执行的验证涉及表单上的多个字段，最好的地方是在整体表单的`clean`方法中进行。这里的方法从表单的`cleaned_data`字典中检索`opens`和`closes`的值。然后，如果它们都已提供，它会检查`opens`是否晚于`closes`。如果是，就会引发`ValidationError`，否则一切正常，所以从`clean`中返回未修改的现有`cleaned_data`字典。
- en: As we are going to be using this form for the admin and do not presently anticipate
    the need to use it anywhere else, we can put this form definition in the existing
    `survey/admin.py` file.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在管理员中使用此表单，并且目前不预期需要在其他地方使用它，我们可以将此表单定义放在现有的“survey/admin.py”文件中。
- en: Configuring admin to use the custom form
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理员使用自定义表单
- en: 'The next step is to tell the admin to use this form instead of a default `ModelForm`
    for the `Survey` model. To do this, change the `SurveyAdmin` definition in `survey/admin.py`
    to be:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是告诉管理员使用此表单，而不是默认的`Survey`模型的`ModelForm`。要做到这一点，将`survey/admin.py`中的`SurveyAdmin`定义更改为：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'By specifying the `form` attribute, we tell the admin to use our custom form
    for both adding and editing `Survey` instances. We can quickly verify that this
    works by using the admin to edit our existing `Winning Answers Test` survey and
    attempting to change its `closes` date to something earlier than `opens`. If we
    do so, we will see the error reported like this:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定`form`属性，我们告诉管理员在添加和编辑`Survey`实例时使用我们的自定义表单。我们可以通过使用管理员编辑我们现有的“获奖答案测试”调查并尝试将其`closes`日期更改为早于`opens`的日期来快速验证这一点。如果我们这样做，我们将看到错误报告如下：
- en: '![Configuring admin to use the custom form](img/7566_04_03.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![配置管理员使用自定义表单](img/7566_04_03.jpg)'
- en: It's good that we have been able to manually validate that our customization
    is working, but what we really want is an automated test. That will be covered
    next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够手动验证我们的自定义是否有效是很好的，但我们真正想要的是自动化测试。下面将介绍这一点。
- en: Testing the admin customization
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试管理员自定义
- en: How do we write a test for this admin customization? There are at least a couple
    of things different about testing the behavior of pressing one of the **Save**
    buttons on an admin page than what we've tested so far. First, we need to issue
    an HTTP POST method, not a GET, to make the request. The test `Client` provides
    a `post` method for this, similar to `get`. For `post`, though, we will need to
    specify the form data values to be included with the request. We provide these
    as a dictionary of key / value pairs where the keys are the names of the form
    fields. Since we know the `ModelForm` the admin is using, we know that the key
    values here are the names of the model's fields.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何为这个管理员自定义编写测试？关于测试在管理员页面上按下“保存”按钮的行为，至少有一些不同于我们迄今为止测试的地方。首先，我们需要发出HTTP POST方法，而不是GET，以进行请求。测试`Client`提供了一个`post`方法，用于此目的，类似于`get`。对于`post`，我们需要指定要包含在请求中的表单数据值。我们将这些提供为键/值对的字典，其中键是表单字段的名称。由于我们知道管理员正在使用的`ModelForm`，因此我们知道这里的键值是模型字段的名称。
- en: We'll start with writing a test for the admin add survey page, since for that
    case we do not need to have any pre-existing data in the database. Let's create
    a new file for testing admin views, named `admin_tests.py`, in the tests directory.
    Also, remember to add `from admin_tests import *` to the `tests/__init__.py` file
    so that these tests are found when we run `tests`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从编写一个测试开始，用于管理员添加调查页面，因为在这种情况下，我们不需要在数据库中有任何预先存在的数据。让我们在测试目录中创建一个名为`admin_tests.py`的新文件来测试管理员视图。还要记得将`from
    admin_tests import *`添加到`tests/__init__.py`文件中，以便在运行`tests`时找到这些测试。
- en: 'An initial attempt to implement a test of the admin application''s use of our
    customized `Survey` form might look like this:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 首次尝试实现对管理员应用程序使用我们定制的“调查”表单的测试可能如下所示：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Here we have a test method, `testAddSurveyError`, which creates a `post_data`
    dictionary with `title`, `opens`, and `closes` values for the `Survey ModelForm`.
    We use the test `client` to `post` that dictionary to the admin `Survey` add page
    for the `survey` application (using `reverse` on the documented name for that
    admin view). We expect that the returned `response` should contain the error message
    from our custom `ModelForm`, since we have specified an `opens` date that is later
    than the `closes` date. We use `assertContains` to check that the expected error
    message is found in the response.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个测试方法`testAddSurveyError`，它使用`Survey ModelForm`的`title`，`opens`和`closes`值创建一个`post_data`字典。我们使用测试`client`将该字典`post`到`survey`应用程序的管理员`Survey`添加页面（使用该管理员视图的文档名称的`reverse`）。我们期望返回的`response`应该包含我们自定义`ModelForm`的错误消息，因为我们指定了一个晚于`closes`日期的`opens`日期。我们使用`assertContains`来检查预期的错误消息是否在响应中找到。
- en: Note that as was the case with `get`, our first test that is using `post` is
    only using a subset of the arguments that could be supplied to that method. In
    addition to the URL `path` and the `data` dictionary, `post` accepts a `content_type`
    keyword argument. This argument defaults to a value that results in the client
    sending `mutlipart/form-data`. In addition to `content_type`, `post` also supports
    the same `follow` and `extra` keyword arguments, with the same defaults and processing
    behavior, as `get`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与`get`一样，我们第一个使用`post`的测试只使用了可以提供给该方法的参数的子集。除了URL`path`和`data`字典之外，`post`还接受一个`content_type`关键字参数。此参数默认为一个值，导致客户端发送`mutlipart/form-data`。除了`content_type`，`post`还支持相同的`follow`和`extra`关键字参数，具有与`get`相同的默认值和处理行为。
- en: 'Does our first attempt at an admin customization test work? Unfortunately,
    no. If we run it with `manage.py test survey.AdminSurveyTest`, we will see this
    failure:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对管理员自定义测试的第一次尝试有效吗？不幸的是，不是。如果我们使用`manage.py test survey.AdminSurveyTest`运行它，我们将看到以下失败：
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: What might be wrong? It's hard to say without seeing what is actually contained
    in the returned response. Realizing that, we may be tempted to include the text
    of the response in the error message. However, responses tend to be quite long
    (as they are generally complete web pages) and including them in test failure
    output usually adds more noise than anything else. Thus it is usually better to
    make a temporary change to the test case to print the response, for example, in
    order to figure out what might be going on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 可能出了什么问题？很难说，因为没有看到返回的响应实际包含什么。意识到这一点，我们可能会想要在错误消息中包含响应的文本。然而，响应往往相当长（因为它们通常是完整的网页），通常将它们包含在测试失败输出中通常会增加更多的噪音。因此，通常最好对测试用例进行临时更改以打印响应，以便弄清楚可能发生了什么。
- en: 'If we do that in this case, we will see that the returned response begins (after
    some standard HTML boilerplate):'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在这种情况下这样做，我们将看到返回的响应开始（在一些标准的HTML样板之后）：
- en: '[PRE38]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Oh, right, we forgot that the admin requires a logged-in user for access. We
    did not do anything in our test case to set up and log in a user, so when the
    test attempts to access an admin page, the admin code simply returns a login page.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，对了，我们忘了管理员需要登录用户才能访问。我们在测试用例中没有做任何设置和登录用户的操作，因此当测试尝试访问管理员页面时，管理员代码会简单地返回一个登录页面。
- en: 'Our test, then, will first need to create a user, as the test database is initially
    empty. That user will need appropriate permissions to access the admin, and must
    be logged in before attempting to do anything with the admin application. This
    sort of thing is appropriate for a test `setUp` routine:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的测试首先需要创建一个用户，因为测试数据库最初是空的。该用户需要适当的权限来访问管理，并且必须在尝试对管理应用程序执行任何操作之前登录。这种情况适合于测试`setUp`例程：
- en: '[PRE39]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here the `setUp` routine uses the `create_user` method provided by the standard
    `django.contrib.auth User` model to create a user named `survey_admin`. After
    creating the user, `setUp` sets its `is_staff` and `is_superuser` attributes to
    `True` and saves the user again to the database. This will allow the newly created
    user to access all pages in the admin application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`setUp`例程使用标准`django.contrib.auth User`模型提供的`create_user`方法创建一个名为`survey_admin`的用户。创建用户后，`setUp`将其`is_staff`和`is_superuser`属性设置为`True`，并将用户再次保存到数据库中。这将允许新创建的用户访问管理应用程序中的所有页面。
- en: Finally, `setUp` attempts to log the new user in using the test `Client login`
    method. This method will return `True` if it is successful. Here, `setUp` asserts
    that `login` does return `True`. If it does not, the assertion will provide a
    specific indication of where things went wrong. This should be more helpful than
    simply continuing the test if the `login` call fails.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`setUp`尝试使用测试`Client login`方法登录新用户。如果成功，此方法将返回`True`。在这里，`setUp`断言`login`确实返回`True`。如果没有，断言将提供特定的指示，说明出了什么问题。这应该比如果`login`调用失败后继续测试更有帮助。
- en: 'The `Client login` method has a companion method, `logout`. We should use it
    in a `tearDown` method after we have used `login` in `setUp`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client login`方法有一个伴随方法`logout`。我们应该在`setUp`中使用`login`后，在`tearDown`方法中使用它：'
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now does our test work? No, but it does get farther. This time the error report
    is:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的测试工作了吗？不，但它确实更进一步了。这次的错误报告是：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'That may be a little confusing at first, but searching the Django documentation
    for **ManagementForm** quickly shows that it is something required when formsets
    are being used. Since, as part of our admin customization, we specified that `Questions`
    appear inline on a `Survey` page, the admin page for `Survey` contains a formset
    for `Questions`. However, we did not provide the required `ManagementForm` values
    in our `post_data` dictionary. The two values required are `TOTAL_FORMS` and `INITIAL_FORMS`
    for the `question_set`. Since we do not want to test any of the admin handling
    of the inlines here, we can just set these values to `0` in our data dictionary:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 起初可能有点困惑，但在Django文档中搜索**ManagementForm**很快就会发现，当使用formsets时，这是必需的内容。由于作为我们的管理定制的一部分，我们指定`Questions`内联显示在`Survey`页面上，因此`Survey`的管理页面包含了`Questions`的formset。但是，在我们的`post_data`字典中没有提供所需的`ManagementForm`值。所需的两个值是`question_set`的`TOTAL_FORMS`和`INITIAL_FORMS`。由于我们不想在这里测试内联的管理处理，我们可以在我们的数据字典中将这些值设置为`0`：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now does this test work? Yes, if we run `manage.py test survey.AdminSurveyTest.testAddSurveyError`
    we will see that the test runs successfully.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这个测试工作吗？是的，如果我们运行`manage.py test survey.AdminSurveyTest.testAddSurveyError`，我们会看到测试成功运行。
- en: Note that `TestCase` provides a more specific assertion than `assertContains`
    to check for form errors, named `assertFormError`. The parameters to `assertFormError`
    are the response, the name of the form in the template context, the name of the
    field to check for errors (or `None` if the error is a non-field error), and the
    error string (or a list of error strings) to check for. However, it is not possible
    to use `assertFormError` when testing admin pages because the admin does not provide
    the form directly in the context. Instead, the context contains a wrapper object
    that contains the actual form. Thus, we cannot change this particular test to
    use the more specific `assertFormError` method.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`TestCase`提供了一个比`assertContains`更具体的断言来检查表单错误的方法，名为`assertFormError`。`assertFormError`的参数是响应、模板上下文中表单的名称、要检查错误的字段的名称（如果错误是非字段错误，则为`None`），以及要检查的错误字符串（或错误字符串列表）。但是，在测试管理页面时无法使用`assertFormError`，因为管理页面不会直接在上下文中提供表单。相反，上下文包含一个包含实际表单的包装对象。因此，我们无法将这个特定的测试更改为使用更具体的`assertFormError`方法。
- en: Are we done testing our admin customization? Almost. Since the same form is
    used for both add and change actions in admin, it is not necessary to test the
    change page as well. However, it would be good to add a test that includes valid
    data and ensure that nothing has been broken for that case.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们完成了对管理定制的测试吗？几乎。由于在管理中添加和更改操作都使用相同的表单，因此无需测试更改页面。但是，最好添加一个包含有效数据并确保对于该情况没有出现任何问题的测试。
- en: 'It is easy enough to add a test method that builds a data dictionary containing
    valid data and posts that to the admin add view. But what should it test for in
    response? The admin code does not return a simple `200 OK` response after successfully
    completing some action requested by the POST. Rather, it redirects to a different
    page, so that an attempt to reload the page resulting from the POST request does
    not result in another attempt to POST the same data. In the case of adding an
    object, the admin will redirect to the change list page for the added model. `TestCase`
    provides an `assertRedirects` method to test this sort of behavior. We can use
    this method like so:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个测试方法很容易，该方法构建一个包含有效数据的数据字典，并将其发布到管理添加视图。但是，响应中应该测试什么？管理代码在成功完成POST请求的某些操作后不会返回简单的`200
    OK`响应。相反，它会重定向到另一个页面，以便尝试重新加载POST请求的页面不会导致再次尝试POST相同的数据。在添加对象的情况下，管理将重定向到已添加模型的更改列表页面。`TestCase`提供了一个`assertRedirects`方法来测试这种行为。我们可以这样使用这个方法：
- en: '[PRE43]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This `testAddSurveyOK` method sets up a valid data dictionary for a `Survey`,
    specifying `opens` and `closes` dates that are the same. It then posts that data
    to the admin add survey page, and saves the response. Finally, it asserts that
    the response should redirect to the admin survey application change list page
    for the `Survey` model. Two additional, optional parameters to `assertRedirects`
    are `status_code` and `target_status_code`. These default to `302` and `200` respectively,
    so we did not need to specify them here since those are the codes we expect in
    this case.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`testAddSurveyOK`方法为`Survey`设置了一个有效的数据字典，指定了相同的`opens`和`closes`日期。然后将这些数据发布到管理员添加调查页面，并保存响应。最后，它断言响应应该重定向到`Survey`模型的管理员调查应用程序更改列表页面。`assertRedirects`的两个额外的可选参数是`status_code`和`target_status_code`。它们分别默认为`302`和`200`，所以我们在这里不需要指定它们，因为这些是我们在这种情况下期望的代码。
- en: Additional test support
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 额外的测试支持
- en: The tests that we have developed in this chapter provide a reasonably broad
    overview of how to use the test support provided by Django's `TestCase` and test
    `Client` class. However, the examples neither cover every detail of what these
    classes provide, nor every detail of the additional data available in the annotated
    `response` objects returned by the `Client`. In this section, we briefly mention
    some additional features of `TestCase`, `Client`, and the additional data available
    with `response` objects. We will not develop examples that use all of these features;
    they are mentioned here so that if you encounter a need for this type of support,
    you will know that it exists. The Django documentation provides full details on
    all of these topics.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们开发的测试提供了如何使用Django的`TestCase`和测试`Client`类提供的测试支持的相当广泛的概述。然而，这些示例既没有涵盖这些类提供的每一个细节，也没有涵盖`Client`返回的注释`response`对象中的附加数据的每一个细节。在本节中，我们简要提到了`TestCase`，`Client`和`response`对象可用的一些附加功能。我们不会开发使用所有这些功能的示例；它们在这里提到，以便如果您遇到对这种类型的支持有需求，您将知道它的存在。Django文档提供了所有这些主题的详细信息。
- en: Supporting additional HTTP methods
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 支持额外的HTTP方法
- en: Our example tests only needed to use the HTTP GET and POST methods. The test
    `Client` class also provides methods to issue HTTP HEAD, OPTIONS, PUT, and DELETE
    requests. These methods are named `head`, `options`, `put`, and `delete` respectively.
    Each supports the same `follow` and `extra` arguments as `get` and `post`. In
    addition, `put` supports the same `content_type` argument as `post`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例测试只需要使用HTTP GET和POST方法。测试`Client`类还提供了发出HTTP HEAD、OPTIONS、PUT和DELETE请求的方法。这些方法分别命名为`head`、`options`、`put`和`delete`。每个方法都支持与`get`和`post`相同的`follow`和`extra`参数。此外，`put`支持与`post`相同的`content_type`参数。
- en: Maintaining persistent state
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持持久状态
- en: 'The test `Client` maintains two attributes that maintain persistent state across
    request / response cycles: `cookies` and `session`. The `cookies` attribute is
    a Python `SimpleCookie` object containing any cookies that have been received
    with responses. The `session` attribute is a dictionary-like object containing
    session data.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 测试`Client`维护两个属性，跨请求/响应周期保持持久状态：`cookies`和`session`。`cookies`属性是一个包含已收到的任何cookie的Python
    `SimpleCookie`对象。`session`属性是一个类似字典的对象，包含会话数据。
- en: E-mail services
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 电子邮件服务
- en: Some views in a web application may create and send mail. When testing, we do
    not want such mail to actually be sent, but it is good to be able to verify that
    the code being tested generated and attempted to send the mail. The `TestCase`
    class supports this by replacing the standard Python `SMTPConnection` class (in
    the context of the running tests only) with a custom class that does not send
    the mail, but rather stores it in `django.core.mail.outbox`. Thus, test code can
    check the contents of this `outbox` in order to verify whether the code being
    tested attempted to send the expected mail.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: Web应用程序中的一些视图可能会创建并发送邮件。在测试时，我们不希望实际发送这样的邮件，但能够验证正在测试的代码是否生成并尝试发送邮件是很好的。`TestCase`类通过在运行测试时将标准的Python
    `SMTPConnection`类（仅在运行测试时）替换为一个不发送邮件而是将其存储在`django.core.mail.outbox`中的自定义类来支持这一点。因此，测试代码可以检查这个`outbox`的内容，以验证正在测试的代码是否尝试发送预期的邮件。
- en: Providing test-specific URL configuration
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供特定于测试的URL配置
- en: In the examples developed in this chapter, we were careful to make the tests
    independent of the specifics of the URL configuration in use by always using named
    URLs and using `reverse` to map these symbolic names back to URL path values.
    This is a good technique, but it may not be sufficient in all circumstances.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开发的示例中，我们小心地确保测试独立于URL配置的具体细节，始终使用命名URL并使用`reverse`将这些符号名称映射回URL路径值。这是一个很好的技术，但在某些情况下可能不足够。
- en: Consider that you are developing a reusable application with optional views
    that a particular installation of the application may or may not choose to deploy.
    For testing such an application, you cannot rely on the optional views actually
    being contained in the project's URL configuration, but you would still like to
    be able to include tests for them. To support this, the `TestCase` class allows
    an instance to set a `urls` attribute. If this attribute is set, the `TestCase`
    will use the URL configuration contained in the specified module instead of the
    project's URL configuration.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到您正在开发一个可重用的应用程序，该应用程序的特定安装可能选择部署可选视图。对于测试这样的应用程序，您不能依赖于可选视图实际上包含在项目的URL配置中，但您仍希望能够为它们包括测试。为了支持这一点，`TestCase`类允许实例设置一个`urls`属性。如果设置了这个属性，`TestCase`将使用指定模块中包含的URL配置，而不是项目的URL配置。
- en: Response context and template information
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应上下文和模板信息
- en: 'In testing the survey home page, we examined values in the response `context`
    attribute using simple dictionary-style access. For example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试调查主页时，我们使用简单的字典样式访问检查响应`context`属性中的值。例如：
- en: '[PRE44]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: While this works, it glosses over some complexity involved in considering the
    context used to render a response. Recall that we set up our project to have a
    two-level hierarchy of templates. The `base.html` template is extended by each
    of the individual page templates. Each template used to render a response has
    its own associated context, so the `context` attribute of a response is not a
    simple dictionary, but rather a list of the contexts used for rendering each of
    the templates. In fact, it is something called `django.test.utils.ContextList`,
    which contains a number of `django.template.context.Context` objects.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以工作，但它忽略了在考虑用于呈现响应的上下文时涉及的一些复杂性。回想一下，我们设置了项目，使其具有两级模板层次结构。`base.html`模板由每个单独的页面模板扩展。用于呈现响应的每个模板都有其自己的关联上下文，因此响应的`context`属性不是一个简单的字典，而是用于呈现每个模板的上下文的列表。实际上，它是一种称为`django.test.utils.ContextList`的东西，其中包含许多`django.template.context.Context`对象。
- en: This `ContextList` object supports dictionary-style access for simplicity, and
    searches for the specified key in each of the contexts it contains. We made use
    of that simple style of access in the examples earlier in this chapter. However,
    if you ever have the need to get more specific about which template context you
    want to check something in, the response `context` attribute supports that as
    well, as you can also index by number into a `ContextList` and retrieve the full
    context associated with a particular template.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`ContextList`对象支持字典样式的访问以简化操作，并在它包含的每个上下文中搜索指定的键。我们在本章的早期示例中使用了这种简单的访问方式。但是，如果您需要更具体地检查要在哪个模板上下文中，响应的`context`属性也支持这一点，因为您还可以通过索引号到`ContextList`中检索与特定模板相关的完整上下文。
- en: In addition, the responses returned by the test `Client` have a `template` attribute
    that is a list of the templates used to render the response. We did not need to
    use this attribute directly because we used the `assertTemplateUsed` method provided
    by `TestCase`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，测试`Client`返回的响应具有一个`template`属性，该属性是用于呈现响应的模板的列表。我们没有直接使用这个属性，因为我们使用了`TestCase`提供的`assertTemplateUsed`方法。
- en: Testing transactional behavior
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试事务行为
- en: The final topic to discuss in this chapter involves testing transactional behavior.
    If it is ever necessary to do this, there is an alternative test case class, `TransactionTestCase`,
    that should be used instead of `TestCase`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 本章最后要讨论的主题涉及测试事务行为。如果有必要这样做，有一个替代的测试用例类`TransactionTestCase`，应该使用它来代替`TestCase`。
- en: What does **testing transactional behavior** mean? Suppose you have a view that
    makes a series of database updates, all within a single database transaction.
    Further, suppose you need to test a case where at least one of the updates works,
    but is followed by a failure that should result in the entire set of updates being
    rolled back instead of committed. To test this sort of behavior, you might try
    to verify in the test code that one of the updates that initially worked is not
    visible in the database when the response is received. To successfully run this
    sort of test code, you will need to use `TransactionTestCase` instead of `TestCase`.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**测试事务行为**的意思？假设您有一个视图，它在单个数据库事务中进行一系列数据库更新。此外，假设您需要测试至少一个更新起初有效，但随后失败，应该导致整个更新集被回滚而不是提交的情况。为了测试这种行为，您可能会尝试在测试代码中验证，当收到响应时，最初有效的更新之一在数据库中是不可见的。要成功运行这种测试代码，您需要使用`TransactionTestCase`而不是`TestCase`。
- en: The reason for this is that `TestCase` internally uses transaction rollback
    to reset the database to a clean state in between calling test methods. In order
    for this rollback approach of cleaning up between test methods to work, the code
    under test must not be allowed to issue any database commit or rollback operations
    itself. Thus, `TestCase` intercepts any such calls and simply returns without
    actually forwarding them on to the database. Your test code, then, will be unable
    to verify that updates which should have been rolled back were rolled back, since
    they will not have been when running under `TestCase`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`TestCase`在调用测试方法之间使用事务回滚来将数据库重置为干净状态。为了使这种回滚方法在测试方法之间的清理工作，受测试代码不得允许发出任何数据库提交或回滚操作。因此，`TestCase`拦截任何此类调用，并简单地返回而不实际将它们转发到数据库。因此，您的测试代码将无法验证应该被回滚的更新是否已被回滚，因为在`TestCase`下运行时它们将不会被回滚。
- en: '`TransactionTestCase` does not use rollback between test methods to reset the
    database. Rather it truncates and re-creates all the tables. This is much slower
    than the rollback method, but it does allow test code to verify that any database
    transaction behavior expected from the code under test was performed successfully.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransactionTestCase`在测试方法之间不使用回滚来重置数据库。相反，它截断并重新创建所有表。这比回滚方法慢得多，但它确实允许测试代码验证从受测试代码执行成功的任何数据库事务行为。'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'We have now come to the end of discussing Django''s unit test extensions to
    support testing web applications. In this chapter, we:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经讨论完了Django的单元测试扩展，以支持测试Web应用程序。在本章中，我们：
- en: Learned how to organize unit tests into separate files instead of placing everything
    into a single tests.py file
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了将单元测试组织成单独的文件，而不是将所有内容放入单个tests.py文件
- en: Began to develop views for the survey application, and learned how to use Django's
    unit test extensions to test these views
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始为调查应用程序开发视图，并学会了如何使用Django的单元测试扩展来测试这些视图
- en: Saw how to customize the admin interface by providing custom validation for
    one of our models, and learned how to test that admin customization
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了如何通过为我们的模型提供自定义验证来定制管理界面，并学会了如何测试该管理定制
- en: Briefly discussed some unit test extensions provided by Django that we did not
    encounter in any of our example tests
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简要讨论了Django提供的一些单元测试扩展，我们在任何示例测试中都没有遇到
- en: Learned when it might be necessary to use `TransactionTestCase` instead of `TestCase`
    for a test
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学会了在何时需要使用`TransactionTestCase`而不是`TestCase`进行测试
- en: While we have covered a lot of ground in learning how to test a Django application,
    there are many aspects to testing a web application that we have not even touched
    on yet. Some of these are more appropriately tested using tools other than Django
    itself. The next chapter will explore some of these additional web application
    testing requirements and show how external tools can be integrated with Django's
    testing support in order to meet these requirements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何测试Django应用程序方面，我们已经涵盖了很多内容，但是测试Web应用程序还有许多方面我们甚至还没有涉及。其中一些更适合使用Django本身以外的工具进行测试。下一章将探讨一些额外的Web应用程序测试需求，并展示如何将外部工具集成到Django的测试支持中，以满足这些需求。
