- en: Chapter 2. Creating and Editing Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。创建和编辑对象
- en: In a way, meshes are the most essential type of objects in a 3D application.
    They form the basis of most visible objects and are the raw material that might
    get rigged and animated further down the line. This chapter deals with the creation
    of meshes and with ways to manipulate a mesh object, both as a whole and as the
    individual entities it consists of—the vertices, edges, and faces.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，网格是3D应用程序中最基本的对象类型。它们构成了大多数可见对象的基础，并且是可能进一步绑定和动画的原始材料。本章讨论了网格的创建以及操纵网格对象的方法，无论是作为一个整体还是作为它所包含的各个实体——顶点、边和面。
- en: '![Creating and Editing Objects](img/0400-02-01.jpg)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![创建和编辑对象](img/0400-02-01.jpg)'
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to create configurable mesh objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建可配置的网格对象
- en: How to design a graphical user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设计图形用户界面
- en: How to make your script store user choices for later reuse
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何让脚本存储用户选择以便以后重用
- en: How to select vertices and faces in a mesh
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在网格中选择顶点和面
- en: How to parent an object to another
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将一个对象附加到另一个对象上
- en: How to create groups
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建组
- en: How to modify meshes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何修改网格
- en: How to run Blender from the command line and render in the background
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从命令行运行Blender并在后台渲染
- en: How to process command-line parameters
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何处理命令行参数
- en: Creepy crawlies—a GUI to configure objects
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可怕的爬虫——一个配置对象的图形用户界面
- en: Instantiating a single copy of a one-off Blender object (like we did in the
    "hello world" example in [Chapter 1](ch01.html "Chapter 1. Extending Blender with
    Python"), *Extending Blender with Python*) might be a good programming exercise,
    but an object creation script really comes into its own when built-in methods
    such as copying objects, or modifiers such as the array modifier, are not sufficient.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化一个唯一的Blender对象（就像我们在[第1章](ch01.html "第1章。使用Python扩展Blender")的“hello world”示例中所做的那样）可能是一个好的编程练习，但当一个对象的创建脚本包含内置方法（如复制对象）或修改器（如阵列修改器）不足以满足需求时，它才能真正发挥其作用。
- en: A good example is where we want to create one or many object variants and these
    variants need to be easy to configure for the end user. For example, nuts and
    bolts come in many shapes and sizes so Blender comes included with a script to
    create them. Many more scripts are available on the Web to create anything from
    mechanical gears to stairs, from trees to church domes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的例子是我们想要创建一个或多个对象变体，并且这些变体需要易于最终用户配置。例如，螺母和螺栓有各种形状和尺寸，因此Blender附带了一个脚本来创建它们。网上还有许多其他脚本，可以创建从机械齿轮到楼梯，从树木到教堂圆顶等各种东西。
- en: In this section, we show how to build a small application that can create all
    sorts of bug-like creatures and comes with a simple but effective GUI to set the
    many configurable parameters. This application also stores the user preferences
    for later reuse.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何构建一个小应用程序，它可以创建各种类似虫子的生物，并附带一个简单但有效的图形用户界面来设置许多可配置的参数。此应用程序还会存储用户偏好设置以供以后重用。
- en: Building the user interface
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建用户界面
- en: 'Designing, building, and testing a graphical user interface can be a formidable
    task, but the Blender API provides us with tools to make this task a lot easier.
    The `Blender.Draw` module provides simple, but often used and easy to configure
    components to quickly put a user interface together. The `Blender.BGL` module
    gives access to all the nuts and bolts to design a graphical user interface from
    scratch. We will mostly use the former because it is almost everything we need
    but we give an example of the latter as well to design a simple error pop up.
    Our main user interface will look like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 设计、构建和测试一个图形用户界面可能是一项艰巨的任务，但Blender API为我们提供了工具，使这项任务变得容易得多。`Blender.Draw`模块提供了简单、常用且易于配置的组件，可以快速构建用户界面。`Blender.BGL`模块提供了从头开始设计图形用户界面的所有工具。我们将主要使用前者，因为它几乎包含了我们所需的一切，但我们也会给出后者的一个示例，以设计一个简单的错误弹出窗口。我们的主要用户界面将看起来像这样：
- en: '![Building the user interface](img/0400-02-02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![构建用户界面](img/0400-02-02.jpg)'
- en: When we invoke our script from the **Add** Menu (normally accessible from the
    menu bar at the top of the screen or by pressing the spacebar in the 3D view),
    the previous menu will pop up and the user can tweak the parameters to his or
    her liking. When the **OK** button is pressed the script generates an insect-like
    mesh. The pop up can also be exited by pressing *Esc,* in which case the script
    terminates without generating a mesh.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从 **添加** 菜单（通常可以通过屏幕顶部的菜单栏或按3D视图中的空格键访问）调用我们的脚本时，之前的菜单将弹出，用户可以调整参数以符合自己的喜好。当按下
    **确定** 按钮时，脚本生成一个类似昆虫的网格。也可以通过按 *Esc* 键退出弹出窗口，在这种情况下，脚本将终止而不会生成网格。
- en: Creating bugs—some assembly required
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建虫子——需要一些组装
- en: 'Our mission is to create simple creatures from a small sample of building blocks
    that may be chained together. The outline for our script is this:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的使命是从一小块可能连接在一起的构建块中创建简单的生物。我们脚本的概要如下：
- en: Import the building blocks for our creatures.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入我们生物的构建块。
- en: Draw a user interface.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制用户界面。
- en: Assemble the creature mesh from building blocks as defined by the user.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据用户定义的构建块组装生物网格。
- en: Insert the mesh as an object into the scene.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将网格作为对象插入场景。
- en: We go through the script step-by-step showing the relevant parts in detail.
    (The full script is available as `creepycrawlies.py`.) The first step involves
    creating body parts that are suitable for assembling together. This means we have
    to model these parts in Blender, defining suitable joints and marking those joints
    as vertex groups. Then we export these meshes as Python code by using a script
    that we encounter again in the next chapter as it deals with vertex groups.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们逐步通过脚本，详细展示相关部分。（完整的脚本作为 `creepycrawlies.py` 提供。）第一步涉及创建适合组装的身体部分。这意味着我们必须在Blender中建模这些部分，定义合适的关节并将这些关节标记为顶点组。然后我们通过使用我们在下一章中再次遇到的脚本将这些网格作为Python代码导出，该脚本处理顶点组。
- en: 'For now, we use this generated Python code simply as a module containing several
    lists of vertices defining each body part. We have to make sure that this module
    is somewhere in the Python path, for example, `.blender\scripts\bpymodules` would
    be a logical choice or alternatively the user `scriptdir`. The Python file with
    the mesh building blocks is called `mymesh.py` so the first part of our code contains
    the following `import` statement:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只是将生成的Python代码简单地用作包含定义每个身体部分的几个顶点列表的模块。我们必须确保这个模块在Python路径中的某个位置，例如，`.blender\scripts\bpymodules`
    将是一个合理的选项，或者也可以是用户 `scriptdir`。包含网格构建块的Python文件命名为 `mymesh.py`，因此我们代码的第一部分包含以下
    `import` 语句：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a user interface
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: Drawing a simple user interface is a matter of using `Draw.Create()` to create
    the required buttons and assembling and initializing these buttons with `Draw.PupBlock()`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Draw.Create()` 创建所需的按钮，并通过 `Draw.PupBlock()` 组装和初始化这些按钮，绘制简单的用户界面是一个问题。
- en: This is somewhat limited compared to full-fledged libraries available for some
    programming languages, but very easy to use. The basic idea is to create interactive
    objects, such as buttons, and then assemble them in a dialog box to display to
    the user. At the same time, the dialog box states some of the limitations on the
    values the button may produce. The dialog or pop up will be shown at the position
    of the cursor. Blender is capable of producing a more sophisticated user interface,
    but for now we stick to the basics.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与某些编程语言中可用的完整库相比，这有些局限，但非常容易使用。基本思想是创建交互式对象，如按钮，然后将它们组装在对话框中显示给用户。同时，对话框还说明了按钮可能产生的值的限制。对话框或弹出窗口将在光标位置显示。Blender能够生成更复杂的用户界面，但到目前为止，我们坚持使用基本功能。
- en: Although `Draw.Create()` can produce toggle buttons and input buttons for strings
    as well, for our application we need input buttons only for integer values and
    floating point values. The type of the variable (for example a floating point
    value or an integer) is determined by the type of the default value given to `Draw.Create()`.
    The **OK** button is automatically displayed by `Draw.PupBlock()`. This function
    takes a list of tuples as an argument with each tuple defining a button to display.
    Each tuple consists of a text to display on the button, a button object created
    with `Draw.Create()`, minimum and maximum allowable values, and a tooltip text
    to show when hovering above the button.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `Draw.Create()` 可以生成切换按钮和字符串的输入按钮，但对我们来说，我们的应用只需要整数和浮点值的输入按钮。变量的类型（例如浮点值或整数）由提供给
    `Draw.Create()` 的默认值的类型决定。`**OK**` 按钮由 `Draw.PupBlock()` 自动显示。这个函数接受一个元组列表作为参数，每个元组定义了一个要显示的按钮。每个元组由要显示在按钮上的文本、使用
    `Draw.Create()` 创建的按钮对象、允许的最小和最大值以及当鼠标悬停在按钮上时显示的工具提示文本组成。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, we limit the possible values of our input buttons to a reasonable
    range (up to 50 for the thorax and tail segments) to prevent unwanted results
    (huge values might cripple your system if memory or processing power is scarce).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将输入按钮的可能值限制在一个合理的范围内（胸和尾段最多为 50），以防止出现不希望的结果（如果内存或处理能力稀缺，巨大的值可能会使您的系统瘫痪）。
- en: Remembering choices
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记忆选择
- en: It would be very convenient if we could remember the user's choices so that
    we could present the last settings when the script is run again, but in Blender
    each script is run in isolation and all information within the script is lost
    once the script ends. Therefore, we need some mechanism to store information in
    a persistent way. For this purpose, the Blender API has the `Registry` module
    that allows us to keep values in memory (and on disk as well) indexed by an arbitrary
    key.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够记住用户的选择，以便在脚本再次运行时呈现最后设置，那将非常方便。但在 Blender 中，每个脚本都是独立运行的，一旦脚本结束，脚本内的所有信息都会丢失。因此，我们需要某种机制以持久的方式存储信息。为此，Blender
    API 有一个 `Registry` 模块，允许我们通过任意键索引来保持值（并在磁盘上也是如此）。
- en: 'Our GUI initialization code changes little in itself if we want to add this
    functionality, but is prepended by code retrieving remembered values (if they
    are present) and followed by code saving the user''s choices:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加此功能，我们的 GUI 初始化代码本身变化不大，但前面会添加代码来检索已记住的值（如果有的话），后面会跟随着保存用户选择的代码：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The actual reading and writing of our registry entry is highlighted. The `True`
    argument indicates that we want to retrieve our data from disk if it is not available
    in memory, or write it to disk as well when saving so that our script can access
    this saved information even if we stop Blender and restart it later. The actual
    registry entry received or written is a dictionary that can hold whatever data
    we want. Of course, there might not yet be a registry entry present, in which
    case we get a `None` value—a situation taken care of by the `try` `…` `except`
    `…` statements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上读取和写入我们的注册表条目被突出显示。`True` 参数表示，如果数据不在内存中，我们希望从磁盘检索我们的数据，或者在保存时也将其写入磁盘，以便即使我们停止
    Blender 并稍后重新启动，我们的脚本也能访问这些保存的信息。实际接收或写入的注册表条目是一个可以存储我们想要的任何数据的字典。当然，可能还没有注册表条目，在这种情况下，我们会得到一个
    `None` 值——这种情况通过 `try` `…` `except` `…` 语句得到了处理。
- en: The full power of Blender graphics
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Blender 图形的全部力量
- en: A pop-up dialog is sufficient for many applications but if it does not fit your
    requirements, Blender's `Draw` module has many more building blocks to create
    a user interface but these building blocks require a little bit more effort to
    glue them together in a working application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多应用来说，一个弹出对话框就足够了，但如果它不符合你的要求，Blender 的 `Draw` 模块提供了更多构建块来创建用户界面，但这些构建块需要更多努力才能将它们粘合在一起以形成一个工作应用。
- en: We will use these building blocks to create an error pop up. This pop up merely
    shows a message on an alarmingly colored background but illustrates nicely how
    user actions (such as key presses or button clicks) are linked to the graphical
    elements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这些构建块来创建一个错误弹出窗口。这个弹出窗口仅仅在令人不安的背景色上显示一条消息，但很好地说明了用户操作（如按键或按钮点击）是如何与图形元素相联系的。
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `error()` function is where it all starts and ends for the user; it tells
    Blender what to draw, where to send events such as button clicks, where to send
    key presses, and starts the interaction. The `lambda` function is necessary as
    the function that we pass to `Draw.Register()` to draw things cannot take an argument,
    yet we want to pass a different text argument every time we call `error()`. The
    `lambda` function basically defines a new function without arguments but with
    the text enclosed.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`error()`函数是用户开始和结束的地方；它告诉Blender要绘制什么，将事件（如按钮点击）发送到何处，将按键发送到何处，并开始交互。`lambda`函数是必要的，因为我们传递给`Draw.Register()`以绘制东西的函数不能接受参数，但我们希望在每次调用`error()`时传递不同的文本参数。`lambda`函数基本上定义了一个没有参数但有文本封装的新函数。'
- en: The `msg()` function is responsible for drawing all of the elements on the screen.
    It draws a colored backdrop with the `BGL.glRecti()` function, a label with the
    text to display (with `Draw.Label()`), and an OK button that is assigned an event
    number of `1` (with `Draw.Button()`). When the user clicks the OK button, this
    event number is sent to the event handler—the `button_event()` function that we
    passed to `Draw.Register()`. All that the event handler does when it is called
    with this event number of `1` is to terminate the `Draw.Register()` function by
    calling `Draw.Exit()`, so our `error()` function may return.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`msg()`函数负责在屏幕上绘制所有元素。它使用`BGL.glRecti()`函数绘制一个带有文本的彩色背景（使用`Draw.Label()`），并绘制一个分配有事件编号`1`的OK按钮（使用`Draw.Button()`）。当用户点击OK按钮时，这个事件编号被发送到事件处理器——我们传递给`Draw.Register()`的`button_event()`函数。当事件处理器被调用并带有事件编号`1`时，它所做的所有事情就是通过调用`Draw.Exit()`来终止`Draw.Register()`函数，因此我们的`error()`函数可以返回。'
- en: Creating a new Mesh object
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的网格对象
- en: 'Once we have retrieved our lists of vertex co-ordinates and face indices from
    the `mymesh` module, we need some manner to create a new `Mesh` object in our
    scene and add `MVert` and `MFace` objects to this mesh. This might be implemented
    like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们从`mymesh`模块中检索到我们的顶点坐标和面索引列表，我们需要一种方法在我们的场景中创建一个新的`Mesh`对象，并将`MVert`和`MFace`对象添加到这个网格中。这可能像这样实现：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first line creates a new `Mesh` object with the name `Bug`. It will contain
    no vertices, edges, or faces and will not be embedded in a Blender object nor
    connected to any `Scene` yet. If the name of the mesh already exists, it is appended
    with a unique numerical suffix (for example, `Bug.001`).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行创建了一个名为`Bug`的新`Mesh`对象。它将不包含任何顶点、边或面，并且不会嵌入到Blender对象中，也不会连接到任何`Scene`。如果网格的名字已经存在，它将附加一个唯一的数字后缀（例如，`Bug.001`）。
- en: 'The next two lines actually create geometry inside the mesh. The `verts` attribute
    is where our list of `MVert` objects is referenced. It has a method `extend()`
    that will take a list of tuples, each containing the x, y, and z coordinates of
    the vertices to create. Likewise, the `extend()` method of the `faces` attribute
    will take a list of tuples, each containing three or more indices into the vertex
    list that together define a face. Order is important here: we need to add new
    vertices first; otherwise newly-created faces cannot refer to them. It is not
    necessary to define any edges, as adding faces will also create implied edges
    that are not already present.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行实际上在网格内部创建几何形状。`verts`属性是我们引用`MVert`对象列表的地方。它有一个`extend()`方法，该方法将接受一个包含顶点创建的x、y和z坐标的元组的列表。同样，`faces`属性的`extend()`方法将接受一个包含指向顶点列表的三个或更多索引的元组的列表，这些索引一起定义了一个面。在这里顺序很重要：我们需要首先添加新顶点；否则，新创建的面无法引用它们。没有必要定义任何边，因为添加面也会创建隐含的边，这些边尚未存在。
- en: A mesh in itself is not yet an object that can be manipulated by the user, so
    in the next few lines (highlighted) we retrieve the current scene and add a new
    object to the scene. The arguments to `new()` are the `Mesh` object that we created
    earlier and the name we want to give to the object. The name given to the object
    might be the same as the one given to the mesh, as mesh names and object names
    live in different namespaces. As with meshes, an existing name will be made unique
    by adding a suffix. If the name is left out, the new object will have the type
    of its argument as a default name (`Mesh` in this case).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 网格本身还不是用户可以操作的对象，所以在接下来的几行（突出显示）中，我们检索当前场景并向场景添加一个新对象。`new()`的参数是我们之前创建的`Mesh`对象以及我们想要给对象起的名字。给对象起的名字可能与网格的名字相同，因为网格名字和对象名字存在于不同的命名空间中。与网格一样，现有的名字将通过添加后缀来变得唯一。如果省略了名字，新对象将具有其参数的类型作为默认名字（在这种情况下是`Mesh`）。
- en: A newly-created object will be selected but not active so we correct that by
    assigning our object to `scene.objects.active` .
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的对象将被选中但不会激活，所以我们通过将我们的对象分配给`scene.objects.active`来纠正这一点。
- en: As we add together our mesh from various collections of vertices the result
    might not be as clean as we would like and therefore, the final two actions make
    sure we do not have any vertices that occupy almost the same location in space
    and that all face normals consistently point outward.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从各种顶点集合中组合我们的网格时，结果可能不像我们希望的那样干净，因此，最后的两个动作确保我们没有占据空间中几乎相同位置的顶点，并且所有面的法向量都一致指向外部。
- en: Transforming mesh topology
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换网格拓扑
- en: Creating the creature from building blocks requires that we duplicate, scale,
    and mirror those building blocks before we stick them together. In Blender 2.49,
    this means we have to define some utility functions to perform those actions as
    they are not present in the API. We define these utility functions in the **Tools**
    module, but we highlight some of them here as they show some interesting methods.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 从积木块创建生物体需要我们在将它们粘合在一起之前，对这些积木块进行复制、缩放和镜像。在Blender 2.49中，这意味着我们必须定义一些实用函数来执行这些操作，因为这些操作在API中不存在。我们在**工具**模块中定义了这些实用函数，但在这里我们突出了一些，因为它们展示了有趣的方法。
- en: Some actions such as scaling around a median point or translation of vertices
    are straightforward but connecting a group of vertices to another one is tricky,
    as we would like to prevent edges from crossing each other and keep faces flat
    and undistorted. We cannot simply connect two sets of vertices (or edge loops)
    together. But by trying different starting points on an edge loop and checking
    if such a choice minimizes the distance between all vertex pairs we insure that
    no edges cross and distortion is minimal (although we can't prevent faces to distort
    if the edge loops are very dissimilar in shape).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动作，如围绕中点缩放或顶点的平移是直接的，但将一组顶点连接到另一组是棘手的，因为我们希望防止边交叉并保持面平坦且无扭曲。我们不能简单地连接两组顶点（或边环）。但通过尝试边环上的不同起点并检查这种选择是否最小化所有顶点对之间的距离，我们确保没有边交叉且扭曲最小（尽管如果边环形状非常不同，我们无法防止面扭曲）。
- en: Code outline bridging edge loops
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接边环的代码概述
- en: 'In the function that creates the new faces we have to perform the following
    steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新面的函数中，我们必须执行以下步骤：
- en: Check that both edge loops are equally long and nonzero.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查两个边环是否长度相等且非零。
- en: 'For every edge in loop 1:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于循环1中的每个边：
- en: Find the edge in loop 2 that is closest.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到循环2中最接近的边。
- en: Create a face connecting these two edges.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个连接这两个边的面。
- en: 'The function that implements this outline looks fairly complicated:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此概述的函数看起来相当复杂：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The function takes two lists of edges as an argument and a list of vertices.
    The edges are represented as tuples of two integers (indices into the `verts`
    list) and the vertices are tuples of x, y, and z co-ordinates.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数接受两个边列表和一个顶点列表作为参数。边由两个整数的元组表示（`verts`列表中的索引），顶点由x、y和z坐标的元组表示。
- en: 'The first thing we do is make copies of the two edge lists because we do not
    want to mangle the lists in their original context. The list of faces that we
    will be constructing is initialized to an empty list and we do a sanity check
    on the length of both edge lists. If that checks out we proceed to the next bit:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先做的事情是复制两个边列表，因为我们不希望在原始上下文中破坏这些列表。我们将要构建的面列表初始化为空列表，并对两个边列表的长度进行合理性检查。如果检查无误，我们继续下一步：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We iterate over every edge in the first list, referring to this edge as `a`.
    The `distance` parameter will hold the distance to the closest edge in the second
    edge list and `best` will be a reference to that edge. `enot` is a list that will
    accumulate all edges from the second list that are at a greater distance than
    `best`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历第一个列表中的每个边，将这个边称为`a`。`distance`参数将保存到第二个边列表中最近边的距离，而`best`将是该边的引用。`enot`是一个列表，它将累积第二个列表中距离`best`更远的所有边。
- en: 'At the end of each iteration, `enot` will hold all edges from the second list
    minus one—the one we consider the closest. We then reassign `enot` to the second
    list so the second list will shrink by one edge over each iteration. We are done
    once the second list of edges is exhausted:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每次迭代的末尾，`enot`将保存第二个列表中除一个之外的所有边——我们认为是最近的那个。然后我们将`enot`重新分配给第二个列表，这样第二个列表在每个迭代中就会减少一个边。一旦第二个边列表耗尽，我们就完成了：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The current edge from the second list that we are considering is referred to
    as `b`. For our purposes, we define the distance between `a` and `b` as the sum
    of the distance between corresponding vertices in `a` and `b.`If that one is shorter,
    we define it as the sum of the distance to the flipped vertices of `b`. If the
    last situation applies, we swap the vertices in edge `b`. This may seem a complicated
    way to do things, but by summing the two distances we assure that edges which
    are relatively co-linear are favored thereby diminishing the number of non-flat
    faces that will be constructed. By checking whether flipping the second edge will
    result in a shorter distance, we prevent the formation of warped or bow-tie quads
    as illustrated in the following figure:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在考虑的第二个列表中的当前边被称为`b`。为了我们的目的，我们将`a`和`b`之间的距离定义为`a`和`b`中对应顶点的距离之和。如果这个距离更短，我们将其定义为到`b`翻转顶点的距离之和。如果最后一种情况适用，我们在边`b`中交换顶点。这看起来可能是一种复杂的方法，但通过将两个距离相加，我们确保了相对共线的边被优先考虑，从而减少了将要构建的非平面面的数量。通过检查翻转第二个边是否会缩短距离，我们防止了形成扭曲或蝴蝶结四边形，如下面的图示所示：
- en: '![Code outline bridging edge loops](img/0400-02-03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![连接边环的代码概要](img/0400-02-03.jpg)'
- en: The implementation will look like the previous figure where the highlighted
    vec are aliases to `Mathutil.Vector`, converting our tuples of x, y, and z co-ordinates
    to proper vectors that we can subtract, add, and take the length of.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实现将类似于之前的图示，其中高亮的vec是`Mathutil.Vector`的别名，将我们的x、y和z坐标的元组转换为适当的向量，我们可以从中减去、相加并计算长度。
- en: 'First we calculate the distance:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算距离：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we check whether flipping the b edge results in a shorter distance:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们检查翻转b边是否会导致距离更短：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If the calculated distance is not the shortest, we set aside the edge for the
    next iteration, unless it is the first we encounter:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算出的距离不是最短的，我们将边留到下一次迭代，除非它是我们遇到的第一个：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we convert our list of faces, consisting of tuples of two edges, to
    a list of tuples of four indices:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将由两个边组成的元组列表转换为四个索引的元组列表：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There is much more to this script and we will revisit `creepycrawlies.py` in
    the following chapter as we add modifiers and vertex groups and rig our model.
    The illustration shows a sample of the bestiary that can be created by the script.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本还有很多内容，我们将在下一章中重新访问`creepycrawlies.py`，当我们添加修改器和顶点组并给我们的模型绑定时。插图显示了脚本可以创建的野兽样本。
- en: '![Code outline bridging edge loops](img/0400-02-04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![连接边环的代码概要](img/0400-02-04.jpg)'
- en: Dazzle your boss—bar charts in Blender style
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Blender风格的条形图惊艳你的老板
- en: To prove that Blender is adaptable to many tasks besides the interactive creation
    of 3D graphics, we will show you how to import external data (a spreadsheet in
    CSV format) and automate the task of creating and rendering the 3D representation
    of a bar chart.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明Blender除了交互式创建3D图形之外，还能适应许多任务，我们将向您展示如何导入外部数据（CSV格式的电子表格）并自动化创建和渲染条形图3D表示的任务。
- en: '![Dazzle your boss—bar charts in Blender style](img/0400-02-05.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![用Blender风格的条形图惊艳你的老板](img/0400-02-05.jpg)'
- en: 'The idea is to run Blender with arguments directing it to run a script that
    reads a `.csv` file, renders an image, and saves that image when finished. For
    this to be possible we need a way to call Blender with the correct parameters.
    We get to that script shortly, but first let''s see how to pass parameters to
    Blender to make it run a Python script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是运行Blender，使用参数将其指向运行一个读取`.csv`文件、渲染图像并在完成后保存该图像的脚本。为了实现这一点，我们需要一种方法来使用正确的参数调用Blender。我们将在稍后的脚本中介绍这一点，但首先让我们看看如何传递参数给Blender以使其运行Python脚本：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is also possible to run a script from a text buffer inside a `.blend` file
    by naming that text buffer instead. Notice the order of the parameters in this
    case—the `.blend` file comes first:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过命名文本缓冲区来在`.blend`文件内部运行脚本。注意在这种情况下参数的顺序——`.blend`文件排在前面：
- en: '[PRE13]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We also need a way to specify arguments to pass to our script. In contrast
    to what is described in the API docs, we can just access the command-line arguments
    from Python like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一种方式来指定传递给我们的脚本的参数。与API文档中描述的不同，我们可以像这样从Python中访问命令行参数：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This last snippet will print all arguments, including the name of the Blender
    executable as the first. Our script will have to skip any arguments intended for
    Blender itself when using this list. Any arguments intended only for our script
    that shouldn't be interpreted by Blender itself should come after an **end-of-options**
    **argument**, the double minus (`--`).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这段代码将打印出所有参数，包括作为第一个参数的Blender可执行文件名。当使用这个列表时，我们的脚本必须跳过任何打算用于Blender本身的参数。任何只打算用于我们的脚本且不应该被Blender本身解释的参数应该跟在**选项结束**参数之后，即双横线（`--`）。
- en: 'Finally, we don''t want Blender to pop up and show an interactive GUI. Instead,
    we will instruct it to run in the background and exit when done. This is done
    by passing the `-b` option. Putting all this together, the command line will look
    like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们不希望Blender弹出并显示交互式GUI。相反，我们将指示它在后台运行，并在完成后退出。这是通过传递`-b`选项来完成的。将这些放在一起，命令行将看起来像这样：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If Blender is run in background mode you *must* specify a `.blend` file, otherwise
    Blender will crash. If we have to specify a `.blend` file we can use an internal
    text as our Python script just as well, otherwise we'd have to keep two files
    together instead of one.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Blender以后台模式运行，*必须*指定一个`.blend`文件，否则Blender将会崩溃。如果我们必须指定一个`.blend`文件，我们也可以使用内部文本作为我们的Python脚本，否则我们就必须将两个文件放在一起而不是一个。
- en: The bar chart script
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 柱状图脚本
- en: 'Here, we show the relevant parts of the code in chunks (the complete file is
    available as `barchart.blend` that has `barchart.py` as an embedded text). We
    start by creating a new `World` object and set its zenith and horizon colors to
    a neutral all white (highlighted part of the following code):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以块的形式展示代码的相关部分（完整的文件作为`barchart.blend`提供，其中包含内嵌的`barchart.py`文本）。我们首先创建一个新的`World`对象，并将其天顶和地平线颜色设置为中性全白（以下代码的高亮部分）：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, we retrieve the last argument passed to Blender and check whether the
    extension is that of a `.csv` file. Real world production code would have more
    sophisticated error checking of course:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检索传递给Blender的最后一个参数，并检查扩展名是否为`.csv`文件。在实际的生产代码中，当然会有更复杂的错误检查：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If it has the correct extension we create a new `Scene` named `BarScene` and
    set its `world` attribute to our newly created world (This was inspired by a much
    more elaborate script by *jessethemid* on Blender Artists [http://blenderartists.org/forum/showthread.php?t=79285](http://blenderartists.org/forum/showthread.php?t=79285)).
    The background mode does not load any default `.blend` file so the default scene
    will not contain any objects. However, just to make sure, we create a new empty
    scene with a meaningful name that will hold our objects:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它有正确的扩展名，我们将创建一个名为`BarScene`的新`Scene`，并将它的`world`属性设置为我们的新创建的世界（这受到了Blender
    Artists上*jessethemid*的一个更复杂的脚本的启发[http://blenderartists.org/forum/showthread.php?t=79285](http://blenderartists.org/forum/showthread.php?t=79285))。后台模式不会加载任何默认的`.blend`文件，所以默认场景将不包含任何对象。然而，为了确保这一点，我们创建了一个具有有意义名称的新空场景，它将包含我们的对象：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Then, we pass the filename to a function that adds the `barchart` objects to
    the current scene and returns the center of the chart so that our `addcamera()`
    function can use it to aim the camera. We also add a lamp to make rendering possible
    (otherwise our render would be all black).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将文件名传递给一个函数，该函数将`barchart`对象添加到当前场景中，并返回图表的中心，以便我们的`addcamera()`函数可以使用它来定位相机。我们还添加了一个灯来使渲染成为可能（否则我们的渲染将会是全黑的）。
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The rendering itself is straightforward (we will encounter more elaborate examples
    in [Chapter 8](ch08.html "Chapter 8. Rendering and Image Manipulation"), *Rendering
    and Image Manipulation*). We retrieve the rendering context that holds all information
    about how to render, for example which frame, what output type, the size of the
    render, and so on. And, because most attributes have sensible defaults, we just
    set the format to PNG and render.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染本身很简单（我们将在第8章[Rendering and Image Manipulation](ch08.html "Chapter 8. Rendering
    and Image Manipulation")中遇到更复杂的例子），我们将检索包含所有渲染信息的渲染上下文，例如哪个帧、输出类型、渲染的大小等等。由于大多数属性都有合理的默认值，我们只需将格式设置为PNG并渲染即可。
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Finally, we set the output directory to an empty string to make our output go
    to the current working directory (the directory we were in when we called Blender)
    and save our rendered image. The image will have the same basename as the `.csv`
    file that we passed as the first argument but will have a `.png` extension. We
    checked that the filename ends in `.csv` so it's safe to bluntly strip the last
    four characters from the filename and add `.png`
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将输出目录设置为空字符串，以便我们的输出指向当前工作目录（我们调用Blender时的目录）并保存我们的渲染图像。图像将具有与传递给第一个参数的`.csv`文件相同的基名，但将具有`.png`扩展名。我们检查了文件名以`.csv`结尾，因此可以安全地从文件名中删除最后四个字符并添加`.png`
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Adding a lamp is not much different from adding any other object and is very
    similar to the "hello world" example. We create a new `Lamp` object, add it to
    the current scene, and set its location. A `Lamp` object has of course many configurable
    options but we settle for a default non-directional lamp in this example. The
    highlighted code shows some typical Python idiom: `loc` is a tuple of three values
    but `setLocation()` takes three separate arguments so we indicate we want to unpack
    the tuple as separate values with the `*` notation:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一盏灯与添加任何其他对象并没有太大区别，它与“hello world”示例非常相似。我们创建一个新的`Lamp`对象，将其添加到当前场景中，并设置其位置。`Lamp`对象当然有许多可配置的选项，但在这个例子中我们选择默认的非定向灯。高亮显示的代码显示了某些典型的Python惯用语：`loc`是一个包含三个值的元组，但`setLocation()`需要三个单独的参数，因此我们使用`*`符号来表示我们希望将元组解包为单独的值：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Adding a camera is a little more intricate as we have to point it to our bar
    chart and make sure that the view angle is wide enough to see everything. We define
    a perspective camera here and set a fairly wide angle. Because the default camera
    is already oriented along the z-axis we do not have to set any rotation, just
    set the location 12 units removed from the center along the z-axis as highlighted
    in the second last line of the following code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加相机稍微复杂一些，因为我们必须将其指向我们的条形图并确保视图角度足够宽，以便可以看到一切。在这里我们定义了一个透视相机并设置了一个相当宽的角度。因为默认相机已经沿z轴定位，所以我们不需要设置任何旋转，只需将位置设置为从中心沿z轴远离12个单位，如以下代码的倒数第二行所示：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `barchart` function itself is not much of a surprise. We open the passed-in
    filename and use the standard `csv` module from Python to read the data from the
    file. We store all column headers in `xlabel` and other data in `rows`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`barchart`函数本身并没有太多惊喜。我们打开传入的文件名，并使用Python的标准`csv`模块从文件中读取数据。我们将所有列标题存储在`xlabel`中，并将其他数据存储在`rows`中。'
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In order to scale our bar chart to reasonable values we have to determine the
    extremes of the data. The first column of each record holds the x-value (or label)
    so we exclude that from our calculation. As each value is stored as a string we
    have to convert it to a floating point value for comparisons.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的条形图缩放到合理的值，我们必须确定数据的极值。每个记录的第一列包含x值（或标签），因此我们将其排除在我们的计算之外。因为每个值都存储为字符串，所以我们必须将其转换为浮点值进行比较。
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To create the actual bars we iterate over all rows. Because the x-value might
    be a textual label (such as the name of a month for example), we keep a separate
    numerical x-value in order to position the bars. The x-value itself is added to
    the scene as a `Text3d` object by the `label()` function, whereas the y-values
    are visualized by appropriately scaled `Cube` objects added by the `bar()` function.
    Neither the `label()` nor the `bar()` function are shown here.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建实际的条形图，我们遍历所有行。因为x值可能是一个文本标签（例如，月份的名称），我们保留一个单独的数值x值来定位条形图。x值本身是通过`label()`函数添加到场景中的`Text3d`对象，而y值是通过`bar()`函数添加的适当缩放的`Cube`对象来可视化的。这里没有显示`label()`或`bar()`函数。
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, we label each column (that is, each set of data) with its own column
    header as a label. We stored the number of x-values so we can return the center
    of our bar chart by dividing it by two (the y component is set to 5.0 as we scaled
    all y-values to lie within the range 0-10).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为每个列（即每组数据）添加其自己的列标题作为标签。我们存储了x值的数量，因此我们可以通过将其除以二（y分量设置为5.0，因为我们已将所有y值缩放到0-10的范围内）来返回条形图的中心。
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Tip
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**A Windows trick: SendTo**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows技巧：发送到**'
- en: 'Once you have your `.blend` file containing a correct Python script and you
    have figured out the correct way to invoke it from the command line, you can integrate
    this more closely with Windows XP by creating a `SendTo` program. A `SendTo` program
    (a `.BAT` file in this case) is any program that will take a single filename as
    an argument and acts upon it. It has to reside in the `SendTo` directory—which
    may be located in different places depending on your system configuration. It
    is simple to find by clicking on the **Start** button, selecting **Run**, and
    typing **sendto** instead of a command. This will open the correct directory.
    In this directory you can place the `.BAT` file, in our case we call it `BarChart.BAT`,
    and it will contain a single command: `/full/path/to/blender.exe` `/path/to/barchart.blend`
    `-P` `barchart.py` `--` `%1` (note the percent sign). Now we can simply right-click
    any `.csv` file we encounter and we can then select `BarChart.BAT` from the `SendTo`
    menu and hey presto, a `.png` file will appear alongside our `.csv`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了包含正确Python脚本和已经从命令行中找到正确调用方式`.blend`文件，你可以通过创建一个`SendTo`程序来更紧密地将它集成到Windows
    XP中。在这个例子中，`SendTo`程序（一个`.BAT`文件）是任何接受单个文件名作为参数并对其执行操作的程序。它必须位于`SendTo`目录中——这个目录可能位于系统配置的不同位置。通过点击**开始**按钮，选择**运行**，并输入**sendto**而不是命令，可以轻松找到它。这将打开正确的目录。在这个目录中，你可以放置`.BAT`文件，在我们的例子中我们称之为`BarChart.BAT`，它将包含一个单独的命令：`/full/path/to/blender.exe`
    `/path/to/barchart.blend` `-P` `barchart.py` `--` `%1`（注意百分号）。现在我们只需右键单击我们遇到的任何`.csv`文件，然后可以从`SendTo`菜单中选择`BarChart.BAT`，嘿，
    presto，一个`.png`文件将出现在我们的`.csv`旁边。
- en: Weird faces—selecting and editing faces in meshes
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 奇怪的面——在网格中选择和编辑面
- en: Blender already provides a host of options to select and manipulate the faces,
    edges, and vertices of a mesh, either via built-in methods or via Python extension
    scripts. But if you want to select some elements based on your unique requirements,
    this section shows how to implement that. We build a few small scripts that illustrate
    how to access faces, edges, and vertices and how to work with the various properties
    of these objects.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Blender已经提供了一系列选项来选择和操作网格的面、边和顶点，无论是通过内置方法还是通过Python扩展脚本。但如果你想根据你独特的需求选择一些元素，本节将展示如何实现这一点。我们构建了一些小脚本，展示了如何访问面、边和顶点以及如何处理这些对象的各个属性。
- en: Selecting warped (non-planar) quads
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择扭曲（非平面）四边形
- en: '**Warped** **quads**, also known as **bow-tie** **quads,** are sometimes formed
    when accidentally mixing up the vertex order during face creation. In a less extreme
    case they might be formed when moving a single vertex of a planar quad. This small
    illustration shows how these may look in the 3D-view:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**扭曲** **四边形**，也称为**蝴蝶结** **四边形**，有时在创建面时意外混淆顶点顺序时形成。在不太极端的情况下，它们可能在移动平面四边形的单个顶点时形成。这个小插图显示了这些在3D视图中可能看起来如何：'
- en: '![Selecting warped (non-planar) quads](img/0400-02-06.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![选择扭曲（非平面）四边形](img/0400-02-06.jpg)'
- en: 'In the 3D view, the warped face on the right didn''t seem out of the ordinary
    but when rendered it does not show uniform shading:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在3D视图中，右侧的扭曲面看起来并不异常，但渲染时它并不显示均匀的着色：
- en: '![Selecting warped (non-planar) quads](img/0400-02-07.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![选择扭曲（非平面）四边形](img/0400-02-07.jpg)'
- en: Both objects are planes and consist of a single face with four vertices. The
    one on the left is a bow-tie quad. Its right edge is rotated a full 180 degrees
    resulting in an ugly, black triangle where we see the back of the warped face.
    The plane on the right shows no noticeable distortion in the 3D view even though
    its upper-right vertex is moved a considerable distance along the z-axis (our
    line of sight). When rendered however, the distortion of the right plane is clearly
    visible. The visible distortion of slightly warped quads may be overcome by setting
    the `smooth` attribute of a face that will interpolate the vertex normals along
    the face resulting in a smooth appearance. Slightly warped quads are almost inevitable
    when modeling or deforming a mesh by an armature and whether they result in visible
    problems depends on the situation. Often it is helpful if you can identify and
    select them to make your own judgment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象都是平面，由一个面和四个顶点组成。左边的是一个蝴蝶结四边形。它的右边边旋转了整整 180 度，结果形成了一个难看的黑色三角形，我们可以看到扭曲面的背面。右边的平面在
    3D 视图中没有明显的扭曲，尽管它的右上角顶点在 z 轴（我们的视线）上移动了相当的距离。然而，当渲染时，右平面的扭曲却非常明显。轻微扭曲的四边形的可见扭曲可以通过设置面的
    `smooth` 属性来克服，这将沿面插值顶点法线，从而产生平滑的外观。当通过骨架建模或变形网格时，轻微扭曲的四边形几乎是不可避免的，它们是否导致可见问题取决于具体情况。通常，如果你能识别并选择它们，以便做出自己的判断，这会很有帮助。
- en: 'Warped quads can be identified by checking whether the normals of the triangles
    that form the quad are pointing in the same direction. A flat quad will have its
    triangle normals pointing in the same direction as shown in the following figure:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过检查构成四边形的三角形的法线是否指向同一方向来识别扭曲的四边形。一个平坦的四边形的三角形法线将指向与以下图示相同的方向：
- en: '![Selecting warped (non-planar) quads](img/0400-02-08.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![选择扭曲（非平面）四边形](img/0400-02-08.jpg)'
- en: 'Whereas in a warped quad these normals are not parallel:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 而在一个扭曲的四边形中，这些法线并不平行：
- en: '![Selecting warped (non-planar) quads](img/0400-02-09.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![选择扭曲（非平面）四边形](img/0400-02-09.jpg)'
- en: 'These triangle normals are not the same as vertex normals: those are defined
    as the average of all face normals of the faces sharing a vertex so we will have
    to calculate these triangle normals ourselves. This can be done by taking the
    cross product of the edge vectors, that is, the vectors defined by the two vertices
    at the end of each edge. In the examples shown we have the left triangle normal
    formed by taking the cross product of the edge vectors 1 → 0 and 1 → 2 and the
    right triangle by taking the cross product of the edge vectors 2 → 1 and 2 → 3.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这些三角形法线与顶点法线不同：顶点法线定义为共享顶点的所有面的法线的平均值，因此我们不得不自己计算这些三角形法线。这可以通过计算边向量的叉积来完成，即由每条边的两个端点定义的向量。在所显示的示例中，左边的三角形法线是通过计算边向量
    1 → 0 和 1 → 2 的叉积得到的，右边的三角形是通过计算边向量 2 → 1 和 2 → 3 的叉积得到的。
- en: It does not matter whether we traverse our edges clockwise or counterclockwise
    but we have to be careful to be consistent in ordering edges when calculating
    the cross products because the sign will be reversed. Once we have our triangle
    normals we can check whether they point in exactly the same direction by verifying
    that all components (x, y, and z) of one vector are scaled by the same factor
    when compared to the corresponding components of the second vector. To give us
    somewhat more flexibility however, we would like to calculate the angle between
    the triangle normals and select a face only if that angle exceeds some minimum.
    We do not have to devise such a function ourselves because the `Blender.Mathutils`
    module provides the `AngleBetweenVecs()` function.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是按顺时针还是逆时针遍历边没有关系，但我们必须在计算叉积时注意保持边顺序的一致性，因为符号将会反转。一旦我们有了三角形法线，我们可以通过验证一个向量的所有分量（x、y
    和 z）与第二个向量的相应分量相比是否按相同的因子缩放来检查它们是否指向完全相同的方向。然而，为了给我们提供更多的灵活性，我们希望计算三角形法线之间的角度，并且只有当这个角度超过某个最小值时才选择面。我们不必自己设计这样的函数，因为
    `Blender.Mathutils` 模块提供了 `AngleBetweenVecs()` 函数。
- en: It is possible to construct four different triangles within a quad but is not
    necessary to compare all triangle normals—any two normals will suffice because
    moving a single vertex of a quad will alter three of the possible four triangle
    normals.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个四边形内可以构造四个不同的三角形，但不需要比较所有三角形法线——任何两个法线就足够了，因为移动四边形的一个顶点将改变四个可能三角形法线中的三个。
- en: Code outline warp select
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码轮廓扭曲选择
- en: 'Armed with all this information, the outline for our tool will look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 带着所有这些信息，我们的工具轮廓将如下所示：
- en: Show pop up for minimum angle.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示最小角度的弹出窗口。
- en: Verify that the active object is a mesh and in *edit* mode.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证活动对象是否为网格且处于**编辑**模式。
- en: Enable *face select* mode.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启用**面选择**模式。
- en: 'For all faces, check if the face is a quad and if so:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有面，检查面是否为四边形，如果是，则：
- en: Calculate the triangle normal defined by vertex 0, 1, and 2
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算由顶点0、1和2定义的三角形法线
- en: Calculate the triangle normal defined by vertex 1, 2, and 3
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算由顶点1、2和3定义的三角形法线
- en: Calculate the angle between normals
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算法线之间的角度
- en: If angle > minimum angle, select the face
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果角度 > 最小角度，则选择面
- en: 'This translates in the following code for the actual detection and selection
    (the full script is provided as `warpselect.py`):'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这在以下代码中得到了实际检测和选择的体现（完整的脚本作为`warpselect.py`提供）：
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, our outline corresponds almost one-to-one to the code. Note
    that `AngleBetweenVecs()` returns the angle in degrees so we can directly compare
    it to `maxangle` which is also in degrees. Also, there is no need to implement
    the cross product of two vectors ourselves as Blender''s `Vector` class is well
    stocked with all sorts of operators. Before we can call this function we have
    to take care of an important detail: in order to select faces, *face selection*
    mode should be enabled. This can be done as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的轮廓几乎与代码一一对应。注意，`AngleBetweenVecs()`返回的角度是以度为单位，因此我们可以直接将其与也是以度为单位的最小角度`maxangle`进行比较。此外，我们不需要自己实现两个向量的叉积，因为Blender的`Vector`类已经包含了各种运算符。在我们能够调用此函数之前，我们必须注意一个重要的细节：为了选择面，**面选择**模式应该被启用。这可以通过以下方式完成：
- en: '[PRE29]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To illustrate the less well-known fact that select modes are *not* mutually
    exclusive we set the *face* *select* mode in addition to any mode already selected
    by combining values with a binary or operator (`|`). At the end of the script
    we restore the mode that was active.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个不太为人所知的事实，即选择模式并非**不互斥**，我们除了设置任何已选模式外，还设置了**面选择**模式，通过使用二进制或运算符（`|`）结合值来实现。在脚本结束时，我们恢复到之前激活的模式。
- en: Selecting ultra sharp faces
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择超锐利面
- en: Many tools exist to select faces that are in some sense unwieldy to work with.
    Blender has built-in tools to select faces that have an area that is too small
    or that have a perimeter that is too short. However, it lacks a tool to select
    faces with edges that form angles that are sharper than some limit. In some modeling
    tasks it would be very convenient if we could select such faces, as they are generally
    difficult to manipulate and may give rise to ugly artifacts when applying a subsurface
    modifier or deforming a mesh.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 存在许多工具可以用于选择在某种程度上难以处理的面的选择。Blender内置了选择面积过小或周长过短的面选择工具。然而，它缺少一个用于选择边形成角度比某个限制更锐利的面的工具。在某些建模任务中，如果我们能够选择这样的面，将会非常方便，因为它们通常很难操作，并且在应用次表面修改器或变形网格时可能会产生难看的伪影。
- en: Note
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that Blender's *select* *sharp* *edges* tool (*Ctrl + Alt + Shift + S*)
    does something different despite its name; it selects those edges that are shared
    by exactly two faces whose angle of contact is less than some minimum value or,
    to put it in another way, selects edges between faces that are relatively flat.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管名称如此，Blender的**选择****锐边**工具（*Ctrl + Alt + Shift + S*）实际上做的是不同的事情；它选择那些恰好由两个面共享的边，这两个面的接触角度小于某个最小值，或者换句话说，选择相对平坦的面之间的边。
- en: We already have seen that Blender's `Mathutils` module has a function to calculate
    the angle so our code is very brief as the real work is done by a single function
    shown below. (The full script is provided as `sharpfaces.py`.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，Blender的`Mathutils`模块有一个用于计算角度的函数，因此我们的代码非常简短，因为实际的工作是由下面显示的单个函数完成的。（完整的脚本作为`sharpfaces.py`提供。）
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that we do not distinguish between tris or quads as both may have edges
    that are joined by a sharp angle. The highlighted part in the preceding code shows
    one subtle detail; each time we calculate the angle between our two edge vectors,
    we invert one of them because to calculate the correct angle, each of the vectors
    should originate in the same vertex whereas we calculated them all as pointing
    from one vertex to the next.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们并不区分三角形或四边形，因为两者都可能具有通过锐角相连的边。前述代码中高亮的部分显示了一个细微的细节；每次我们计算两个边向量的角度时，我们都会反转其中一个，因为为了计算正确的角度，每个向量都应该起源于同一个顶点，而我们是将它们都计算为从一个顶点指向下一个顶点。
- en: 'The distinction is illustrated in the following figure:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 区别在下图中展示：
- en: '![Selecting ultra sharp faces](img/0400_02_10.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![选择超尖锐的面](img/0400_02_10.jpg)'
- en: Selecting vertices with many edges
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择具有许多边的顶点
- en: Ideally, a mesh will contain faces that consist of only four vertices (these
    faces are generally referred to as **quads**) and are fairly even sized. Such
    a configuration is optimal when deforming the mesh, as is often necessary with
    animations. Of course, there is nothing intrinsically wrong with three-sided faces
    (**tris**) but in general it is better to avoid them because small triangular
    faces wreck havoc with subsurface modifiers, causing them to show unsightly ripples.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，一个网格将包含只由四个顶点组成的面（这些面通常被称为**四边形**）并且大小相当均匀。这种配置在变形网格时是最优的，这在动画中通常是必要的。当然，三角形面（**tris**）本身并没有内在的错误，但通常最好避免它们，因为小的三角形面会破坏次表面修改器，导致它们出现难看的涟漪。
- en: '![Selecting vertices with many edges](img/0400-02-11.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![选择具有许多边的顶点](img/0400-02-11.jpg)'
- en: Now even when you have a mesh that consists only of quads, some vertices are
    the center of more than four edges. These vertices are sometimes called **poles**,
    hence the name of the scripts in the following sections. If the number of edges
    is excessive, say six or more (as shown in the previous screenshot), such an area
    might become difficult to deform and difficult to manipulate for the modeler.
    In a large and complex mesh these vertices might be difficult to pinpoint and
    therefore we need a selection tool that selects those vertices.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在即使你有一个只由四边形组成的网格，一些顶点也是超过四个边的中心。这些顶点有时被称为**极点**，因此以下章节中脚本的名称。如果边的数量过多，比如说六个或更多（如前一个截图所示），这样的区域可能变得难以变形，并且对于模型师来说难以操作。在一个大而复杂的网格中，这些顶点可能难以定位，因此我们需要一个选择工具来选择这些顶点。
- en: Selecting poles
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择极点
- en: 'In order to select vertices with a certain number of steps we may perform the
    following steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择具有特定步数的顶点，我们可以执行以下步骤：
- en: Check whether the active object is a `Mesh.`
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查活动对象是否为`Mesh。`
- en: Check whether we are in *object* mode.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否处于*对象*模式。
- en: Show a pop-up menu to input the minimum number of edges.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个弹出菜单以输入最小边数。
- en: 'For every vertex:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个顶点：
- en: Iterate over all edges, counting occurrences of the vertex
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历所有边，计算顶点的出现次数
- en: If count is larger or equal to the minimum, select the vertex
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果计数大于或等于最小值，则选择顶点
- en: This approach is straightforward and simple. The function that is responsible
    for the actual work is shown below (the full script is called `poleselect1.py`).
    It follows our outline closely. The actual selection of a vertex is effected by
    assigning to the `sel` attribute of the vertex. Note also that the `v1` and `v2`
    attributes of an `edge` object are not indices into the `verts` attribute of our
    mesh but refer to `MVert` objects. That is why we need to retrieve the `index`
    attributes to compare.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法简单直接。负责实际工作的函数如下所示（完整脚本名为`poleselect1.py`）。它紧密遵循我们的大纲。实际选择一个顶点是通过将顶点的`sel`属性赋值来实现的。注意，`edge`对象的`v1`和`v2`属性并不是我们网格`verts`属性的索引，而是指向`MVert`对象。这就是为什么我们需要检索`index`属性来比较的原因。
- en: '[PRE31]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Selecting poles, again
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次选择极点
- en: 'You probably noticed that we iterated over the list of edges for each and every
    vertex (highlighted in the previous code). This might be costly in terms of performance
    and this cost is even compounded by the need to compare indices which have to
    be retrieved again and again. Is it possible to write more efficient code that
    stays readable nonetheless? It is if we follow this strategy:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们遍历了每个顶点的边列表（在前面的代码中突出显示）。这可能在性能上代价高昂，而且这种成本还因为需要反复检索索引而加剧。是否有可能编写更高效的代码，同时仍然保持可读性？如果遵循以下策略，就可以做到：
- en: Check whether the active object is a `Mesh`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查活动对象是否为`Mesh。`
- en: Check whether we are in *object* mode.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查我们是否处于*对象*模式。
- en: Show a pop-up menu to input the minimum number of edges.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示一个弹出菜单以输入最小边数。
- en: Initialize a dictionary, indexed by vertex index that will contain edge counts.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化一个字典，以顶点索引为索引，将包含边计数。
- en: Iterate over all edges (update the count for both referred vertices).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历所有边（更新两个引用顶点的计数）。
- en: Iterate over the items in the dictionary (if count is larger or equal to the
    minimum, select the vertex).
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历字典中的项（如果计数大于或等于最小值，则选择顶点）。
- en: By using this strategy we perform just two possibly lengthy iterations at the
    cost of needing the memory to store the dictionary (nothing is free). The speed
    increase is negligible for small meshes but might be considerable (I clocked a
    1,000-fold speed boost on a smallish mesh of 3,000 vertices) for large meshes,
    and those are just the kind of meshes where someone might need a tool like this.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这种策略，我们只需进行两次可能很长的迭代，代价是需要存储字典的内存（没有什么是免费的）。对于小网格，速度的提高可以忽略不计，但对于大网格，速度的提高可能相当可观（我在一个小型的3000个顶点的网格上测得速度提高了1000倍），而这些正是可能需要这种工具的网格类型。
- en: Our revised selection function is shown below (the full script is called `poleselect.py`).
    First note the `import` statement. The dictionary that we will be using is called
    a default dictionary and is provided by Python's collections module. A **default**
    **dictionary** is a dictionary that initializes missing items the first time they
    are referred to. As we want to increment the count for every vertex that is referred
    to by an edge, we should either initialize our dictionary with a zero value for
    every vertex in the mesh beforehand or check if a vertex is already indexed every
    time we want to increment the count and, if not, initialize it. A default dictionary
    does away with the need to initialize everything in advance and allows for a very
    readable idiom.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们改进的选择函数如下（完整的脚本名为`poleselect.py`）。首先注意`import`语句。我们将使用的字典被称为默认字典，由Python的collections模块提供。一个**默认**字典是一种在第一次引用缺失项时初始化它的字典。由于我们希望增加每个由边引用的顶点的计数，我们可以在事先为网格中的每个顶点初始化零值，或者在我们想要增加计数时检查顶点是否已经索引，如果没有，则初始化它。默认字典消除了事先初始化所有内容的需要，并允许使用非常易读的语法。
- en: 'We create our dictionary by calling the `defaultdictionary()` function (a function
    returning a new object whose behavior is configured by some argument to the function
    is called a factory in object-oriented circles) with an `int` argument. The argument
    should be a function taking no arguments. The built-in function `int()` that we
    use here will return an integer value of zero when called without arguments. Every
    time we access our dictionary with a non-existing key, a new item is created and
    its value will be the return value of our `int()` function, that is, zero. The
    essential lines are the two where we increment the `edgecount` (highlighted part
    of the following code). We could have written that expression in a slightly different
    way to illustrate why we need a default dictionary:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过调用`defaultdictionary()`函数（在面向对象领域，一个通过函数的某些参数配置其行为的函数返回新对象被称为工厂）并传递一个`int`参数来创建我们的字典。该参数应该是一个不接受任何参数的函数。我们在这里使用的内置函数`int()`在无参数调用时将返回一个整数值零。每次我们使用一个不存在的键访问我们的字典时，都会创建一个新的项，其值将是我们的`int()`函数的返回值，即零。关键行是两个增加`edgecount`（以下代码的高亮部分）的行。我们可以用稍微不同的方式编写那个表达式来展示为什么我们需要默认字典：
- en: '[PRE32]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The dictionary item we refer to on the right-hand side of the expression might
    not yet exist every time we refer to a vertex index that we encounter for the
    first time. Of course, we could check beforehand but that would render the code
    a whole lot less readable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式右侧我们引用的字典项可能每次当我们第一次遇到一个顶点索引时可能还不存在。当然，我们可以在事先进行检查，但这会使代码的可读性大大降低。
- en: '[PRE33]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Determining the volume of a mesh
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定网格的体积
- en: Although Blender is not really a CAD program, many people use it for CAD-like
    issues such as architectural visualization. Blender is capable of importing many
    types of files including those of major CAD programs, so including technical models
    drawn to precise measurements is never a problem.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Blender实际上不是一个CAD程序，但许多人用它来解决类似CAD的问题，如建筑可视化。Blender能够导入许多类型的文件，包括主要CAD程序的文件，因此包括精确测量的技术模型永远不会是问题。
- en: These CAD programs often offer all kinds of tools to measure the dimensions
    of (parts of) your model, yet Blender, by its nature, provides very few of those
    tools. It is possible to inspect the size and location of an object by pressing
    the *N* key in the 3D view window. In *edit* mode you may enable the display of
    edge lengths, edge angles, and face areas (see the panel **Mesh tools more** in
    the editing context (*F9*) of the Buttons window) but that is about as far as
    it gets.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这些CAD程序通常提供各种工具来测量模型（的部件）的尺寸，然而，Blender由于其本质，提供的这些工具非常有限。通过按3D视图窗口中的*N*键，可以检查对象的大小和位置。在*编辑*模式下，您可以启用显示边长、边角和面面积（请参阅按钮窗口编辑上下文（*F9*）中的**网格工具更多**面板），但这只是其中的一部分。
- en: Python may overcome those limitations in situations where we need some specific
    measurement and exporting our model to a CAD tool is not an option. A practical
    example is the calculation of the volume of a mesh. Nowadays, a number of companies
    offer possibilities to re-create your digital model as real world objects by way
    of 3D printing techniques. I have to say it is a rather special feeling to hold
    a plastic or even metal replica of your Blender model in your hands, it really
    adds a whole new dimension to 3D.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们需要某些特定测量且无法将模型导出到CAD工具的情况下，Python可以克服这些限制。一个实际的例子是计算网格的体积。如今，许多公司提供通过3D打印技术将您的数字模型重新创建为现实世界物体的可能性。我得说，握在手中一个塑料或甚至金属的Blender模型复制品是一种相当特殊的感觉，它真的为3D增加了一个全新的维度。
- en: Now a major component of the price of 3D-printing a model is the amount of material
    that will be used. Often, it will be possible to design your model as a hollow
    object that takes less material to produce, but it is quite inconvenient to upload
    intermediate versions of your model again and again to let the manufacturer's
    software calculate the volume and give you a price quote. So what we would like
    to have is a script that can calculate the volume of a mesh in a fairly accurate
    manner.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模型3D打印的主要成本组成部分是所需使用的材料量。通常，您可以将模型设计为空心物体，以减少生产所需的材料，但反复上传模型的中间版本以让制造商的软件计算体积并给出报价是非常不方便的。因此，我们希望有一个可以以相当准确的方式计算网格体积的脚本。
- en: A common method to calculate the volume of a mesh is sometimes referred to as
    the **Surveyor's Formula** as it is related to the way surveyors may calculate
    the volume of a hill or mountain by triangulating its surface.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 计算网格体积的一种常见方法有时被称为**测量员公式**，因为它与测量员通过三角测量其表面来计算山丘或山脉体积的方式有关。
- en: The central idea is to split a triangulated mesh into many columns that have
    their base on the xy-plane.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是将三角剖分的网格分成许多以xy平面为底座的柱体。
- en: The surface area of the triangle projected onto the xy-plane times the average
    z-position of the three vertices then gives the volume of such a column. Summing
    these volumes finally gives the volume of the complete mesh (see the next figure).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 将三角形投影到xy平面上的表面积乘以三个顶点的平均z位置，然后给出这样一个柱体的体积。将这些体积相加，最终给出完整网格的体积（请参见下一图）。
- en: '![Determining the volume of a mesh](img/0400-02-12.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![确定网格体积](img/0400-02-12.jpg)'
- en: There are a couple of things that have to be taken into account. First, a mesh
    may extend below the xy-plane. If we construct a column from a face that lies
    below the xy-plane, the product of the projected area and the average of the z-coordinates
    will be a negative number, so we have to negate its value to get a volume.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 有几点需要注意。首先，网格可能延伸到xy平面以下。如果我们从一个位于xy平面以下的面构建一个柱体，投影面积与z坐标平均值之积将是一个负数，因此我们必须取其相反数以得到体积。
- en: '![Determining the volume of a mesh](img/0400-02-13.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![确定网格体积](img/0400-02-13.jpg)'
- en: Second, a mesh may lie completely or partially above the xy-plane. If we take
    a look at the example in the previous diagram we see that the object has two triangles
    that contribute to the volume of the object, the top and bottom ones (the vertical
    triangles have a projected area of zero, so will contribute nothing). As the top
    and bottom faces both lie above the xy-plane, we have to subtract the volume of
    the column constructed from the bottom face from the one constructed from the
    top face. If the object was completely below the xy-plane it would be the other
    way around, and we would have to subtract the volume of the top column from the
    volume of the bottom column.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，一个网格可能完全或部分位于xy平面之上。如果我们看一下前一张图中的例子，我们会看到物体有两个三角形对物体的体积有贡献，即顶部和底部的三角形（垂直三角形的投影面积为零，因此不会做出贡献）。由于顶部和底部面都位于xy平面之上，我们必须从由顶部面构建的体积中减去由底部面构建的柱体的体积。如果物体完全位于xy平面之下，情况则相反，我们必须从底部柱体的体积中减去顶部柱体的体积。
- en: How we can tell what to do is determined by the direction of the face normal
    of our triangles. If, for example, a triangle is above the xy-plane but its face
    normal is pointing downward (it has a negative z-component), then we have to subtract
    the calculated volume. It is therefore vital that all face normals point consistently
    outward (in *edit* mode, select all faces and press *Ctrl + N*).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何确定要做什么是由我们三角形的面对法线方向决定的。例如，如果一个三角形位于xy平面之上，但其面对法线指向下方（具有负的z分量），那么我们必须减去计算出的体积。因此，所有面对法线始终指向外部（在*编辑*模式下，选择所有面并按*Ctrl
    + N*）至关重要。
- en: 'If we take into account all four possibilities (face normal up or down, face
    above or below the xy-plane) we can write the following outline for our function:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑所有四种可能性（面对法线向上或向下，面对位于xy平面之上或之下），我们可以为我们的函数写出以下大纲：
- en: Make sure all face normals consistently point outward.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有面对法线始终指向外部。
- en: 'For all faces:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有面：
- en: Calculate the z-component of face normal vector **Nz**
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算面对法线向量的z分量**Nz**
- en: Calculate the product **P** of the average z-coordinates and the projected surface
    area.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算平均z坐标和投影表面积的乘积**P**。
- en: 'If Nz is positive: add P'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Nz为正：添加P
- en: 'If Nz is negative: subtract P'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Nz为负：减去P
- en: 'This nifty algorithm works for simple objects without holes and just as well
    for objects containing holes (such as a torus), or even hollow ones (that is,
    containing an object completely enclosed in another object) like the examples
    shown in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个巧妙的算法适用于没有孔的简单物体，同样适用于包含孔的物体（例如环面），甚至空心物体（即完全包含在另一个物体中的物体），如下面的截图所示：
- en: '![Determining the volume of a mesh](img/0400-02-14.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![确定网格体积](img/0400-02-14.jpg)'
- en: Because we allow the product of area and z-coordinates to be negative, we have
    to check only for the direction of the face normal to cover all situations.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们允许面积和z坐标的乘积为负，我们只需要检查面对法线的方向，以涵盖所有情况。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that it is necessary for the mesh to be closed and manifold: There shouldn''t
    be any missing faces nor should there be any edges that do not share exactly two
    faces, such as interior faces.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，网格必须是封闭的和单形的：不应该有任何缺失的面，也不应该有任何不恰好共享两个面的边，例如内部面。
- en: '![Determining the volume of a mesh](img/0400-02-15.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![确定网格体积](img/0400-02-15.jpg)'
- en: 'The important part of the code is shown here (the complete script is called
    `volume.py`):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的重要部分在这里显示（完整的脚本名为`volume.py`）：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The highlighted code shows how we calculate the area of the triangle projected
    on the xy-plane. `TriangleArea()` will calculate the area of a two-dimensional
    triangle when given two dimensional points (points in the xy-plane). So we pass
    not the full coordinate vectors of the vertices, but truncate them (that is, we
    drop the z-coordinate) into two component vectors.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的代码显示了我们是如何计算投影在xy平面上的三角形面积的。`TriangleArea()`将在给定二维点（xy平面上的点）时计算二维三角形的面积。因此，我们不是传递顶点的完整坐标向量，而是将它们截断（即，我们丢弃z坐标）成两个分量向量。
- en: After running the script from the text editor, or from the **Scripts** menu
    when in *object* mode, a pop up is displayed showing the volume in Blender units.
    Before running the script make sure that all modifiers are applied, scale and
    rotation are applied (*Ctrl + A* in *object* mode), the mesh is fully triangulated
    (*Ctrl + T* in *edit* mode), and that the mesh is manifold (closed or water-tight)
    by checking for non-manifold edges (*Ctrl + Alt + Shift +M* in *edge selection*
    mode). **Manifold** **edges** are edges that are shared by exactly two faces.
    Also make sure that all normals are pointing in the right direction. The application
    of modifiers is necessary to make the mesh closed (if it is a mirror modifier)
    and to make the calculation of the volume accurate (if it is a subsurface modifier).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在文本编辑器中运行脚本，或者在*对象*模式下从**脚本**菜单运行后，会弹出一个显示体积的窗口，单位是Blender单位。在运行脚本之前，请确保所有修改器都已应用，缩放和旋转已应用（*Ctrl
    + A*在*对象*模式下），网格已完全三角化（*Ctrl + T*在*编辑*模式下），并且通过检查非流形边来确保网格是流形的（*Ctrl + Alt + Shift
    +M*在*边选择*模式下）。**流形****边**是恰好由两个面共享的边。还要确保所有法线都指向正确的方向。应用修改器是必要的，以使网格封闭（如果它是镜像修改器）并使体积计算准确（如果它是子表面修改器）。
- en: Determining the centre of mass of a mesh
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定网格的质心
- en: 'When printing a three-dimensional object in plastic or metal, a seemingly innocent
    question might pop up once we create our first toy based on a mesh we created;
    what is its center of mass? If our model has legs but we don''t want it to keel
    over, its center of mass better be somewhere over its feet and, preferably, as
    low as possible to keep it stable. This figure shows this schematically:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在塑料或金属中打印三维物体时，一旦我们基于我们创建的网格创建了第一个玩具，可能会出现一个看似无害的问题；它的质心在哪里？如果我们的模型有腿但我们不希望它翻倒，它的质心最好在它的脚上，最好是尽可能低，以保持稳定性。这个图示显示了这一点：
- en: '![Determining the centre of mass of a mesh](img/0400-02-16.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![确定网格的质心](img/0400-02-16.jpg)'
- en: 'Once we know how to determine the volume of a mesh we can reuse many of the
    concepts to devise a script to determine the center of mass. Two additional bits
    of knowledge are needed to compute the position of the center of mass:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了如何确定网格的体积，我们就可以重用许多概念来编写一个脚本来确定质心位置。为了计算质心的位置，还需要两个额外的知识点：
- en: The centers of mass of the projected volumes we construct when calculating the
    volume of the mesh
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算网格体积时，我们构建的投影体积的质心
- en: How to add up the calculated centers of mass of all these individual volumes
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将这些单个体积计算出的质心相加
- en: All of this assumes that solid sections of our mesh have a uniform density.
    A mesh may have any form or even be hollow but the solid parts are assumed to
    be of a uniform density. This is valid assumption for the materials deposited
    by 3D printers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都假设我们的网格的实体部分具有均匀的密度。网格可能具有任何形状，甚至可能是空心的，但假设实体部分具有均匀的密度。这对于3D打印机沉积的材料是有效的假设。
- en: 'The first issue is a bit of geometry: the projected volume is essentially a
    triangular column (or triangular prism) capped by a possibly slanted triangular
    face. Calculating the center of mass might be done as follows: the x and y coordinates
    of the center of mass are the x and y coordinates of the center of the projected
    triangle on the xy-plane—those are simply the averages of the x and y coordinates
    respectively of the three points defining the triangular face. The z-coordinate
    of the center of mass is halfway along the average height of our projected column.
    This is the average of the z-coordinates of the three points of the triangular
    face divided by two.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题涉及一点几何学：投影体积基本上是一个三角形柱体（或三角形棱柱体），顶部可能是一个斜三角形面。计算质心的方法可能如下：质心的x和y坐标是xy平面上投影三角形的中心x和y坐标——这些只是定义三角形面的三个点的x和y坐标的平均值。质心的z坐标位于我们投影柱体平均高度的一半。这是三角形面三个点的z坐标的平均值除以二。
- en: 'The second issue is mainly common sense: given two masses m1 and m2 with their
    centers of mass at v1 and v2 respectively, their combined center of mass is the
    weighted average. That is to say, the center of mass is proportionally closer
    to the center of the mass of the heaviest component.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题主要是常识：给定两个质量分别为m1和m2，它们的质心分别位于v1和v2，它们的组合质心是加权平均值。也就是说，质心与最重部件的质心成比例地更近。
- en: Note
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course it is common sense to us now, but it took someone like Archimedes
    to see that it actually was common sense. After finding out about this 'law of
    levers' (as he called it), he didn't shout 'eureka' or went running around naked,
    so it took somewhat longer to attract attention.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，对我们来说这是常识，但像阿基米德这样的人才能看到这实际上确实是常识。在发现这个“杠杆定律”（他称之为）之后，他没有大喊“我找到了”或光着身子到处跑，因此花了相当长的时间才引起人们的注意。
- en: 'Let''s put all this information into a recipe that we can follow:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些信息放入一个我们可以遵循的食谱中：
- en: Make sure all face normals consistently point outward.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保所有面的法线始终指向外侧。
- en: 'For all faces:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有面：
- en: Calculate the z-component of face normal vector Nz
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算面法线向量的z分量Nz
- en: Calculate the product P of the average z-coordinates and the projected surface
    area
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算平均z坐标和投影表面积的产品P
- en: Calculate CM(x, y, z) with x, y the average of the projected x, y coordinates
    of the face and z (the average of the z-coordinates of the face)/2
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用x，y为面的投影x，y坐标的平均值和z（面的z坐标平均值）/2来计算CM(x, y, z)
- en: 'If Nz is positive: add P times CM'
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Nz是正数：加上P乘以CM
- en: 'If Nz is negative: subtract P times CM'
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果Nz是负数：减去P乘以CM
- en: 'From the outline above, it is clear that calculating the center of mass goes
    hand in hand with the calculation of the partial volumes, so it makes sense to
    redefine the `meshvolume()` function to the following:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 从上面的概述中，很明显，计算质心与计算部分体积是相辅相成的，因此重新定义`meshvolume()`函数是有意义的：
- en: '[PRE35]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The added or changed lines of code are highlighted.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加或更改的代码行被突出显示。
- en: Some remarks about accuracy
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关于精度的几点说明
- en: Although most of us are artists and not engineers, we still may ask how accurate
    the number is that we calculate for our mesh volume or center of mass. There are
    two things to consider—intrinsic accuracy and computational accuracy of our algorithm.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们大多数人是艺术家而不是工程师，但我们仍然可能想知道我们为网格体积或质心计算的数字有多准确。有两件事要考虑——我们算法的内在精度和计算精度。
- en: '**Intrinsic** **accuracy** is what we refer to when we consider the fact that
    our model is made out of small polygons that approximate some imagined shape.
    When doing organic modeling this hardly matters; if our model looks good, it is
    good. However, if we try to approximate some ideal form, for example a sphere,
    by a polygonal model (a uv-sphere say, or an icosphere) there will be a difference
    between the calculated volume and the known volume of the ideal sphere. We can
    improve this approximation by increasing the number of subdivisions (or equivalent
    the size of the polygons) but we will never be able to completely eliminate this
    difference and the algorithm used to calculate the volume cannot change that.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**内在** **精度**是我们考虑我们的模型由小多边形组成，这些多边形近似于某种想象中的形状时所指的。在进行有机建模时，这几乎无关紧要；如果我们的模型看起来不错，那就是好的。然而，如果我们试图通过多边形模型（比如uv球体或二十面体）来近似某种理想形状，例如球体，那么计算出的体积和理想球体的已知体积之间将存在差异。我们可以通过增加细分数量（或相当于多边形的大小）来提高这种近似的精度，但我们永远无法完全消除这种差异，并且用于计算体积的算法无法改变这一点。'
- en: '**Computational** **accuracy** has several aspects. First, there is the precision
    of the numbers we calculate with. On most platforms that Blender runs on, calculations
    are performed using double precision floating point numbers. This amounts to about
    17 digits of precision and there is nothing we can do to improve that. Luckily,
    that is ample precision to work with.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算** **精度**有几个方面。首先，是我们计算时使用的数字的精度。在Blender运行的大多数平台上，计算使用的是双精度浮点数。这相当于大约17位精度，我们无法提高这一点。幸运的是，这已经足够我们使用了。'
- en: Then there is the accuracy of our algorithm. When you look at the code you will
    see that we are adding and multiplying a potentially huge amount of values, as
    a typical high-resolution model may well contain over a hundred thousand faces
    or even a million. For each face we calculate the volume of the projected column
    and all of these volumes are added (or subtracted) together. The problem is that
    these volumes may differ considerably in size, not only because the areas of the
    faces may differ but especially because the projected area of a near vertical
    face is very small compared to a near horizontal one.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 然后是我们的算法的准确性。当你查看代码时，你会看到我们在添加和乘以可能巨大的值，因为典型的高分辨率模型可能包含超过十万甚至一百万个面。对于每个面，我们计算投影柱的体积，并将所有这些体积相加（或相减）。问题是这些体积可能相差很大，不仅因为面的面积可能不同，而且尤其是因为几乎垂直的面投影面积与几乎水平的面相比非常小。
- en: Now if we add a very large and a very small number with limited precision calculations
    we will *lose* the small number. For example, if our precision would be limited
    to three significant digits, adding 0.001 and 0.0001 would end up as 0.001, losing
    the effect of the small number. Now our precision is a lot better (about 17 digits)
    but we add a lot more than two numbers. If we implement the `volume()` function
    by using one of the cited algorithms however, the difference never adds up to
    more than one in million, so as long as we don't aim to do nuclear science with
    Blender there is no need to bother. (For those who do, an alternative is provided
    in the script as the function `volume2()`. Still, be careful that you know what
    you are doing).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们用有限精度的计算将一个非常大的数和一个非常小的数相加，我们会*丢失*小的数。例如，如果我们的精度限制为三个有效数字，则将 0.001 和 0.0001
    相加将得到 0.001，丢失了小数的影响。现在我们的精度要好得多（大约 17 位），但我们添加的数字要多得多。然而，如果我们通过使用引用的算法之一实现 `volume()`
    函数，差异永远不会超过百万分之一，所以只要我们不打算用 Blender 做核科学，就没有必要烦恼。（对于那些这样做的人，脚本中提供了一个替代函数 `volume2()`。不过，仍然要小心，确保你知道你在做什么）。
- en: Note
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Python is able to work with numbers of potentially infinite size and precision
    but this is much slower than doing normal floating point calculations. The functions
    and classes provided in `Mathutils` are primarily coded in C for speed and limited
    to double precision floats. See [http://code.activestate.com/recipes/393090/](http://code.activestate.com/recipes/393090/)
    [http://code.activestate.com/recipes/298339/](http://code.activestate.com/recipes/298339/)
    or Section 18.5 of Python Cookbook, 2nd edition, by O'Reilly for some other techniques
    and mathematical background.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Python 能够处理可能无限大和精确度的数字，但这比进行正常的浮点计算要慢得多。`Mathutils` 中提供的函数和类主要是用 C 语言编写的，以提高速度并限制为双精度浮点数。请参阅
    [http://code.activestate.com/recipes/393090/](http://code.activestate.com/recipes/393090/)
    [http://code.activestate.com/recipes/298339/](http://code.activestate.com/recipes/298339/)
    或 O'Reilly 出版的《Python 烹饪书》第二版的第 18.5 节，了解一些其他技术和数学背景。
- en: Growing sunflowers—parenting and grouping objects
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向日葵生长——亲子关系和分组对象
- en: Creating elaborate assemblies of objects is automated easily enough, but we
    would like to provide the end user with ways to select all of these related objects
    and to move them together. This section shows how we can achieve that by creating
    groups and by parenting objects to each other. You will end up with a bunch of
    nice sunflowers as a result.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 创建复杂的对象组装很容易自动化，但我们希望为最终用户提供选择所有这些相关对象并一起移动它们的方法。本节展示了我们如何通过创建分组和将对象相互关联来实现这一点。结果你会得到一束漂亮的向日葵。
- en: '![Growing sunflowers—parenting and grouping objects](img/0400-02-17.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![向日葵生长——亲子关系和分组对象](img/0400-02-17.jpg)'
- en: Groups
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分组
- en: Groups are devised to make it easier to select, or manipulate, more than one
    object at the same time. Sometimes this behavior is part of a larger scheme. An
    armature for example, is a collection of bones, but then these collections have
    very specific relations (bones in an armature have precisely defined relations
    to each other).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 分组是为了使同时选择或操作多个对象变得更加容易。有时这种行为是更大计划的一部分。例如，骨架是一个骨骼的集合，但然后这些集合具有非常具体的关系（骨架中的骨骼彼此之间有精确的关系）。
- en: 'There are many situations where we would like to identify a bunch of objects
    as belonging together without there being a specific relationship. Blender provides
    two kinds of groups to help us define their loose relations: **object** **groups**
    (or simply groups) for named collections of objects, and **vertex groups** for
    named collections of vertices within mesh objects.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们希望识别一组对象属于同一集合，即使它们之间没有特定的关系。Blender提供了两种类型的组来帮助我们定义它们松散的关系：**对象组**（或简称组）用于命名对象集合，**顶点组**用于命名网格对象内的顶点集合。
- en: 'Object groups allow us to select an otherwise unrelated set of objects we added
    to a group (we could group a mesh, an armature, and a bunch of empties together
    for example). A group relationship is different from a parent-child relationship.
    Groups merely allow us to select objects but parented objects move along when
    their parent is moved. The functionality to define and manipulate groups is provided
    in the `Group` module and its identically named class (a group is just like another
    Blender object, but one containing a list of references to other objects, but
    not to other groups unfortunately). You might, for example, append a group from
    an external `.blend` file just like you would a `Lamp` or a `Mesh`. The following
    table lists some often used group operations (see the `Blender.Group` module in
    the Blender API documentation for additional functionality):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对象组允许我们选择一组原本无关的对象，我们将它们添加到组中（例如，我们可以将网格、骨架和一堆空对象一起分组）。组关系与父子关系不同。组仅仅允许我们选择对象，但父对象移动时，被父化的对象也会移动。定义和操作组的功能由`Group`模块及其同名类（一个组就像另一个Blender对象，但包含其他对象的引用列表，但不幸的是不包括其他组）。例如，你可以像添加`Lamp`或`Mesh`一样添加一个组从外部的`.blend`文件。以下表格列出了一些常用的组操作（有关附加功能，请参阅Blender
    API文档中的`Blender.Group`模块）：
- en: '| Operation | Action |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| Operation | 动作 |'
- en: '| --- | --- |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `group=Group.New(name=''aGroupName'')` | Creates a new group |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `group=Group.New(name=''aGroupName'')` | 创建一个新的组 |'
- en: '| `group=Group.Get(name=''aGroupName'')` | Gets a reference to a group by name
    |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `group=Group.Get(name=''aGroupName'')` | 通过名称获取组的引用 |'
- en: Vertex groups are a convenient way to identify groups of related vertices (such
    as an ear or a leg in a model of a toy for example) but they have their uses beyond
    mere selecting. They can be used to determine the influence of bone deformations
    or to identify emitter regions of particle systems to name a few. Vertex groups
    will be our focus in the next chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点组是一种方便的方式来识别相关顶点的集合（例如玩具模型中的耳朵或腿），但它们的应用远不止于简单的选择。它们可以用来确定骨骼变形的影响，或者识别粒子系统的发射区域等。在下一章中，我们将重点关注顶点组。
- en: Parenting
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 父子关系
- en: '**Parenting** in real life might be difficult at times, but in Blender it is
    rather easy although there is a sometimes bewildering array of options to choose
    from. It is possible to parent an object to another object, to a single bone in
    an armature, or to one or three vertices in a `Mesh` object. The following table
    shows the relevant methods (Refer to `Blender.Object` in the Blender API for additional
    functionality):'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，**父子关系**有时可能很难，但在Blender中却相当简单，尽管有时有令人困惑的选项可供选择。可以将对象绑定到另一个对象、骨架中的一个单一骨骼，或者`Mesh`对象中的一个或三个顶点上。以下表格显示了相关的方法（有关附加功能，请参阅Blender
    API中的`Blender.Object`）。
- en: '| Operator | Action |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| Operator | 动作 |'
- en: '| --- | --- |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| parent.makeParent([child1, child2, child3]) | parent-children to a parent
    object |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| parent.makeParent([child1, child2, child3]) | 将父-子关系应用到父对象上 |'
- en: '| parentmesh.makeParentVertex([child1,child2,child3],vertexindex1) | parent-children
    to a vertex |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| parentmesh.makeParentVertex([child1,child2,child3],vertexindex1) | 将父-子关系应用到顶点上
    |'
- en: '| parentmesh.makeParentVertex([child1,child2,child3],vertexindex1,vertexindex2,vertexindex3)
    | parent-children to three vertices |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| parentmesh.makeParentVertex([child1,child2,child3],vertexindex1,vertexindex2,vertexindex3)
    | 将父-子关系应用到三个顶点上 |'
- en: Growing a sunflower from a seed
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从种子中生长向日葵
- en: We can put all this information to good use when we write a script that will
    create a model of a sunflower (Van Gogh would probably have cut off his other
    ear as well if he saw this "sunflower" but then again, his was another way of
    looking altogether). The single sunflower that we will be creating consists of
    a stalk and a flower head. The head of a sunflower consists of tiny flowers that
    will become the seeds once fertilized and a rim of large petals. (I know, any
    botanist will cringe at my language. The tiny flowers are called "disc florets"—but
    floret is just a "little flower" right? And the ones on the edge are "ray florets".)
    Our head will have seeds and each seed is a separate `Mesh` object that will be
    vertex-parented to our head mesh.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写一个创建向日葵模型（梵高如果看到这个“向日葵”可能也会割掉他的另一只耳朵，但话又说回来，他的方式完全是另一种看待方式）的脚本时，我们可以充分利用所有这些信息。我们将创建的单个向日葵由茎和花头组成。向日葵的花头由小花朵组成，一旦受精就会变成种子，以及一圈大花瓣。（我知道，任何植物学家都会对我的语言感到不适。这些小花朵被称为“花盘小花”——但花蕾不就是一个“小花朵”吗？而边缘上的那些是“辐射小花”。）我们的花头将有种子，每个种子都是一个独立的
    `Mesh` 对象，它将成为花头网格的顶点父对象。
- en: We would like our seeds to not just move along with our seed head, but to follow
    any local curvature and orient themselves perpendicular to the head surface so
    we can, for example, distort the head mesh with proportional editing and all attached
    seeds will follow. To accomplish that we use the three vertex variant of vertex
    parenting.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望我们的种子不仅随着种子头移动，而且要跟随任何局部曲率并相对于头表面垂直定位，这样我们就可以，例如，通过比例编辑扭曲头网格，所有附加的种子都会跟随。为了实现这一点，我们使用顶点父化的三个顶点变体。
- en: 'By parenting an object to three different vertices of a mesh, that object will
    follow the position of those vertices and orient itself relative to the normal
    (see the following illustrations):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将一个对象与网格的三个不同顶点关联，该对象将跟随这些顶点的位置并相对于法线进行定位（参见以下插图）：
- en: '![Growing a sunflower from a seed](img/0400-02-18.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![从种子生长向日葵](img/0400-02-18.jpg)'
- en: We do not need to connect all those triplets of vertices as the head mesh itself
    will not be rendered (it will be fully covered by seeds). We do define a face
    between each triplet of vertices though; otherwise it would be difficult for a
    modeler to see the head mesh in *edit* mode.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要连接所有这些顶点三元组，因为花头网格本身将不会被渲染（它将被种子完全覆盖）。尽管如此，我们确实在每对顶点三元组之间定义了一个面；否则，在 *编辑*
    模式下，建模者将很难看到花头网格。
- en: '![Growing a sunflower from a seed](img/0400-02-19.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![从种子生长向日葵](img/0400-02-19.jpg)'
- en: The petals are separate objects parented in the normal way to the head mesh
    as they need not follow any curvature of the head mesh, just its location and
    rotation. The head in turn is parented to the stalk so we can move the whole assembly
    around by moving the stalk.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 花瓣是独立的对象，按照常规方式附加到花头网格上，因为它们不需要遵循花头网格的任何曲率，只需要其位置和旋转。反过来，花头被附加到茎上，这样我们就可以通过移动茎来移动整个组件。
- en: Finally, we assign all individual objects to a single group. That way it will
    be easy to select everything in one go and it enables us to link or append one
    or more sunflowers from an external file as a single entity.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有单个对象分配到单个组中。这样，我们可以一次性选择所有内容，并使我们能够将一个或多个从外部文件链接或附加的向日葵作为一个单一实体。
- en: Duplication versus instantiation
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复制与实例化
- en: We said that all our seeds and petals are separate objects but it might make
    more sense to instantiate them instead (called **making a linked copy** in Blender).
    As all seeds and all petals as we have modeled them are identical, we can refer
    to the same mesh data and just change the location, rotation, or scale of the
    object as needed—saving possibly a fair amount of memory. When using Blender interactively
    we can instantiate an object by pressing *Alt + D* (instead of *Shift + D* for
    a regular copy). In our script, we simply define a new object and point it to
    the same `Mesh` object by passing a reference to the same mesh when calling `Object.New()`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说过，所有的种子和花瓣都是独立的对象，但用实例化它们可能更有意义（在Blender中称为**创建链接副本**）。因为我们所建模的所有种子和花瓣都是相同的，我们可以引用相同的网格数据，只需根据需要更改对象的位置、旋转或缩放——可能节省相当多的内存。在交互式使用Blender时，我们可以通过按
    *Alt + D*（而不是 *Shift + D* 用于常规复制）来实例化一个对象。在我们的脚本中，我们简单地定义一个新的对象，并通过在调用 `Object.New()`
    时传递对同一网格的引用来将其指向相同的 `Mesh` 对象。
- en: Growing a sunflower
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向日葵的生长
- en: 'Let''s look at the main part of the script that will create the sunflower (the
    full script is available as `sunflower.py`). The first step is to calculate the
    position of the seeds:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看创建向日葵的主要部分脚本（完整的脚本作为 `sunflower.py` 提供）。第一步是计算种子的位置：
- en: '[PRE36]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'From these positions we create the head, vertices, and faces that we can parent
    the kernels to and assemble these into the head mesh (highlighted part of the
    following code):'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些位置，我们创建了头部、顶点和面，可以将内核附加到这些面上，并将它们组装成头部网格（以下代码中的高亮部分）：
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The next step is to create the base mesh for the kernel and create objects
    that reference this mesh (highlighted part of the following code):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建内核的基网格，并创建引用此网格的对象（以下代码中的高亮部分）：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Each kernel is then assigned a suitable location and parented to the appropriate
    vertices in the flower head mesh (highlighted part of the following code):'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每个内核被分配一个合适的位置，并附加到花头网格中的适当顶点上（以下代码中的高亮部分）：
- en: '[PRE39]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we create a petal mesh and arrange duplicates of this mesh along the
    rim of the flower head (highlighted part of the following code):'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建一个花瓣网格，并将该网格的副本沿着花头的边缘排列（以下代码中的高亮部分）：
- en: '[PRE40]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Each petal is positioned and rotated along the rim and parented to the head
    (highlighted part of the following code):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 每个花瓣都沿着边缘定位和旋转，并附加到头部（以下代码中的高亮部分）：
- en: '[PRE41]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, we create a stalk mesh and object and parent the head to the stalk.
    This way the entire flower may be moved by moving the stalk:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个茎网格和对象，并将头部附加到茎上。这样，整个花朵就可以通过移动茎来移动：
- en: '[PRE42]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'All that is left to do is to group the kernels and petals in separate groups
    (highlighted) and then all parts in an overall sunflower group for easy reference:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是将内核和花瓣分组到单独的组中（高亮显示），然后在一个总的向日葵组中包含所有部分，以便于参考：
- en: '[PRE43]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `addmeshduplicate()` function used in the code is implemented in the `Tools`
    module in the following manner:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中使用的 `addmeshduplicate()` 函数是在以下方式实现的：`Tools` 模块中。
- en: '[PRE44]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Given a scene, a mesh, and a name (optional) for the object, it adds a new object
    to the scene. The `Mesh` object passed as an argument might be used again and
    again to create new objects that refer to the same mesh.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个场景、一个网格和一个对象名称（可选），它会在场景中添加一个新的对象。作为参数传递的 `Mesh` 对象可能被反复使用来创建引用相同网格的新对象。
- en: 'Newly created objects will be selected automatically but not be made active,
    so the next step is to make the newly-created object active (highlighted in the
    preceding code). This is not necessary but might be convenient to the user as
    are the next two actions: ensuring that all face normals point consistently outward
    and removing any vertices that are very close together. These last two actions
    can only be performed on a mesh that is embedded in an object.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的对象将被自动选中，但不会变为活动状态，因此下一步是使新创建的对象变为活动状态（前述代码中的高亮部分）。这不是必需的，但可能对用户来说更方便，就像接下来的两个动作一样：确保所有面的法线方向一致向外，并删除任何非常接近的顶点。这些最后两个动作只能在嵌入在对象中的网格上执行。
- en: Also, as a convenience, we set the `smooth` attribute for all faces, to get
    smoother images when rendering. Finally, we update the display list for this mesh
    and notify all Blender windows that there has been a change.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了方便起见，我们为所有面设置了 `smooth` 属性，以便在渲染时获得更平滑的图像。最后，我们更新了这个网格的显示列表，并通知所有 Blender
    窗口已发生更改。
- en: Tip
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**A slight digression, or why rabbits are related to sunflowers.**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**稍微偏离一下主题，或者为什么兔子与向日葵有关。**'
- en: One of the things you may notice is that we have arranged the seeds in a peculiar
    spiral. This type of spiral, where subsequent positions along the spiral are spaced
    by following the so-called *Golden* *ratio* is called **Fermat's** **spiral**.
    Such a spiral results naturally in many seed heads when the florets or seeds are
    formed in the middle and pushed outward, resulting in a highly efficient packing.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，我们以一种奇特的方式排列了种子。这种螺旋，其中螺旋上的后续位置是通过遵循所谓的**黄金比例**来间隔的，被称为**费马螺旋**。当花蕾或种子在中间形成并向外推时，这种螺旋自然地导致许多种子头，从而实现高度有效的包装。
- en: 'When seen from above, the arrangement of seeds also seem to follow both left
    and right turning curves. The numbers of these curves usually are a pair from
    the *Fibonacci* *sequence* *[ 1 1 2 3 5 8 13 21 …]* and the ratio of such a pair
    of numbers tends to converge on the *Golden* *ratio* when they get bigger. (In
    the two illustrations of our seed head below we can discern 13 counterclockwise
    spirals and 21 clockwise spirals.) Fibonacci invented this series in an attempt
    to model the population growth of rabbits. More about sunflowers (and possibly
    rabbits) may be found here: [http://en.wikipedia.org/wiki/Sunflower](http://en.wikipedia.org/wiki/Sunflower).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 从上方看，种子的排列似乎也遵循左右转弯的曲线。这些曲线的数量通常是一对来自**斐波那契****序列**[ 1 1 2 3 5 8 13 21 …]，当这些数字变大时，这样一对数字的比例往往会收敛到**黄金比例**。
    (在我们的种子头部的两个插图下，我们可以辨别出13个逆时针螺旋和21个顺时针螺旋。) 斐波那契发明了这个序列，试图模拟兔子的种群增长。有关向日葵（以及可能还有兔子）的更多信息，请参阅[http://en.wikipedia.org/wiki/Sunflower](http://en.wikipedia.org/wiki/Sunflower)。
- en: '![Growing a sunflower](img/0400-02-20_NEW.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![种植向日葵](img/0400-02-20_NEW.jpg)'
- en: Summary
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have seen how to create complex objects and how to make
    the task of configuring those objects on easy one for the end user by providing
    a graphical user interface that remembers previous choices. We saw that it was
    also possible to recruit Blender as a command-line tool to automate common tasks.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何创建复杂对象，以及如何通过提供一个记住先前选择的图形用户界面，使最终用户配置这些对象的任务变得简单。我们了解到，也可以将Blender作为命令行工具来自动化常见任务。
- en: 'We also learned how to create a parent relation between objects and made a
    first step in editing meshes. Specifically, we saw how to:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了如何创建对象之间的父子关系，并在编辑网格方面迈出了第一步。具体来说，我们看到了如何：
- en: Create configurable mesh objects
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建可配置的网格对象
- en: Design a graphical user interface
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计图形用户界面
- en: Make your script store user choices for later reuse
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让你的脚本存储用户选择以便以后重用
- en: Select vertices and faces in a mesh
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网格中选择顶点和面
- en: Parent an object to another
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个对象关联到另一个对象
- en: Create groups
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建组
- en: Modify meshes
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改网格
- en: Run Blender from the command line and render in the background
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行运行Blender并在后台渲染
- en: Process command-line parameters
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理命令行参数
- en: In the next chapter, we will see how we can assign vertex groups and materials
    to our meshes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何将顶点组和材质分配给我们的网格。
