- en: Metaprogramming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元编程
- en: In the previous chapter, we discussed asynchronous I/O and coroutines. In this
    chapter, we turn our attention to metaprogramming and programmable syntax. We'll
    discuss various ways that Python allows us to control or alter the meaning of
    syntactic elements and use these features beneficially.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了异步I/O和协程。在本章中，我们将注意力转向元编程和可编程语法。我们将讨论Python允许我们控制或更改语法元素意义的各种方法，并有益地使用这些特性。
- en: We'll look at another programmable syntax feature of Python that meshes nicely
    with function decorators. We'll also discuss class decorators and how they're
    similar to, and different from, function decorators. Then we'll see a different
    way of programmatically modifying classes using metaclasses. We'll move on to
    a less esoteric topic and discuss context managers. Finally, we'll look at one
    more way of programming the semantics of basic Python operations when we look
    at descriptors.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨Python的另一个可编程语法特性，它与函数装饰器很好地结合在一起。我们还将讨论类装饰器以及它们与函数装饰器的相似之处和不同之处。然后我们将看到使用元类以不同方式程序化修改类的方法。接下来，我们将转向一个不那么神秘的课题，讨论上下文管理器。最后，当我们查看描述符时，我们将探讨另一种编程Python基本操作语义的方法。
- en: Metaprogramming is a blanket term for techniques where programs use program
    code or data structures constructed directly from program code as data to be manipulated.
    Python has a number of different features that can be thought of as metaprogramming.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 元编程是一个总称，用于描述程序使用程序代码或直接从程序代码构建的数据结构作为数据来操作的技术。Python有许多不同的特性，可以被认为是元编程。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using function decorators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数装饰器
- en: Function annotations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数注解
- en: Class decorators
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类装饰器
- en: Metaclasses
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元类
- en: Context managers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: Descriptors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述符
- en: Using function decorators
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用函数装饰器
- en: In this section, we're going to look at one of the most ubiquitous **function
    decorators**. We'll see how to construct a decorator, how to use it, and how it
    works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨最普遍的**函数装饰器**之一。我们将看到如何构建一个装饰器，如何使用它，以及它是如何工作的。
- en: 'The basic definition of a decorator is simple. It''s just a function that takes
    another function as its input, does something with it, and then returns the result
    of its operations, as shown here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器的基本定义很简单。它只是一个接受另一个函数作为输入，对其进行一些操作，然后返回其操作结果的函数，如下所示：
- en: '![](img/51381066-7461-4764-b3a1-13cf3f4d4a70.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/51381066-7461-4764-b3a1-13cf3f4d4a70.jpg)'
- en: The return value replaces the original input function, so the changes a decorator
    can make are potentially quite drastic. A decorator that doesn't change anything
    at all is a function that accepts one parameter and immediately returns it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值替换了原始输入函数，因此装饰器可以做出的更改可能是相当剧烈的。一个完全不进行任何更改的装饰器是一个接受一个参数并立即返回它的函数。
- en: Using the @ syntax in a function decorator
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数装饰器中使用@语法
- en: 'Python has a special syntax for applying a decorator to a function, using the
    `@` syntax. With this syntax, we just write an `@` symbol, followed by an expression
    that evaluates to a decorator function. We put that on the line right before the
    definition of the function we want to decorate, as shown in the following code
    example:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Python有一种特殊的语法来将装饰器应用于函数，使用`@`语法。使用这种语法，我们只需写一个`@`符号，后跟一个评估为装饰器函数的表达式。我们将它放在我们想要装饰的函数定义之前的行上，如下面的代码示例所示：
- en: '![](img/5e18b84c-bb01-4eef-9114-7ae309e8ab52.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e18b84c-bb01-4eef-9114-7ae309e8ab52.jpg)'
- en: 'This syntax means that as soon as we''re done defining the function, we call
    the decorator function on it and then assign the return value of the decorator
    to the variable that would have contained the function, as shown here:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法意味着一旦我们完成函数的定义，我们就调用装饰器函数，然后将装饰器的返回值赋给原本将包含函数的变量，如下所示：
- en: '![](img/d716911d-7c64-49ce-9e32-5e8b56b94478.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d716911d-7c64-49ce-9e32-5e8b56b94478.jpg)'
- en: Global decorator - @staticmethod
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全局装饰器 - @staticmethod
- en: 'Python includes a few decorators in the global namespace and an expanding list
    of them in the standard library. The most commonly used global decorator is `@staticmethod`.
    It makes the class member function callable through the class, rather than an
    instance, just like `@staticmethod` decorators in other languages. The following
    screenshot illustrates the code example for `@staticmethod`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python 在全局命名空间中包含了一些装饰器，并在标准库中包含了一个不断增长的装饰器列表。最常用的全局装饰器是 `@staticmethod`。它使得类成员函数可以通过类而不是实例来调用，就像其他语言中的
    `@staticmethod` 装饰器一样。以下截图展示了 `@staticmethod` 的代码示例：
- en: '![](img/9d82efa3-3883-4ea2-8aa9-2404de41e4e5.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d82efa3-3883-4ea2-8aa9-2404de41e4e5.jpg)'
- en: 'It''s also possible to use multiple `@` lines before `def`; with this, multiple
    decorators will be invoked. The decorator that''s closest to `def` will be called
    first, and then its return value will be passed to the next closest decorator,
    and so on. Eventually, the return value of the topmost decorator will be assigned
    to the function''s name in the containing scope, as shown in the following code
    example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以在 `def` 前使用多个 `@` 行；这样，多个装饰器将被调用。最接近 `def` 的装饰器将首先被调用，然后其返回值将传递给下一个最接近的装饰器，依此类推。最终，最顶层装饰器的返回值将被分配给包含作用域中函数的名称，如下面的代码示例所示：
- en: '![](img/67e98fdd-2068-47b4-ab75-1ec9e9144f8b.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/67e98fdd-2068-47b4-ab75-1ec9e9144f8b.jpg)'
- en: Attributes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: One of the most common uses of decorators—in fact, the reason they're called
    decorators—is to add attributes to function objects. These attributes can be used
    by code in other parts of the program to distinguish decorated functions from
    each other and from under undecorated functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器最常见的一个用途——实际上，这就是它们被称为装饰器的原因——是向函数对象添加属性。这些属性可以被程序其他部分的代码用来区分装饰过的函数和未装饰的函数。
- en: Adding attributes is easy. Inside the decorator, assign an attribute to the
    function, just like we would for any other object, and then return it. Then, elsewhere
    in the code, check for the attribute and respond accordingly.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 添加属性很容易。在装饰器内部，将一个属性分配给函数，就像我们为任何其他对象做的那样，然后返回它。然后，在代码的其他地方，检查该属性并根据需要进行响应。
- en: That's all well and good and often quite useful, but we could do a lot more
    with decorators. For example, we can enclose the function in a wrapper that performs
    some computation before or after calling the function.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很不错，而且通常非常有用，但我们还可以用装饰器做更多的事情。例如，我们可以在调用函数前后包裹一个执行某些计算的包装器。
- en: Enclosing the function in a wrapper
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在包装器中包裹函数
- en: To enclose a function in a wrapper, first we want the function to find the wrapper
    inside a decorator (refer to the following code example). If you haven't seen
    this before, it is exactly how it looks—the definition of a `wrapper` function
    actually lies inside of `@ints_only`. So when `@ints_only` is called, it defines
    and then returns the `wrapper` function.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要在包装器中包裹一个函数，首先我们希望函数在装饰器内部找到包装器（参考以下代码示例）。如果你之前没有见过，它看起来就是这样——`wrapper` 函数的定义实际上位于
    `@ints_only` 内部。所以当 `@ints_only` 被调用时，它定义并返回 `wrapper` 函数。
- en: Each time `@ints_only` is called, it defines a new `wrapper` function.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `@ints_only` 时，它都会定义一个新的 `wrapper` 函数。
- en: 'When a function is defined inside another function, the containing function''s
    local variables remain available to the inner function. Refer to the following
    code example:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数在另一个函数内部定义时，包含函数的局部变量仍然对内部函数可用。参考以下代码示例：
- en: '![](img/75ea39d1-3bec-4a89-a827-2ff4b3cf394c.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/75ea39d1-3bec-4a89-a827-2ff4b3cf394c.jpg)'
- en: In the preceding case, the `wrapper` does some manipulation of the function
    arguments and then calls the wrapped function and returns its results. We imported
    and used the decorator called `@wraps` in the preceding example.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`wrapper` 对函数参数进行了一些操作，然后调用被包装的函数并返回其结果。我们在前面的例子中导入了并使用了名为 `@wraps`
    的装饰器。
- en: The `@wraps` decorator's job is pretty straightforward; it makes the wrapper
    look like a wrapped function for tools such as `pydoc`. However, `@wraps` takes
    a parameter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`@wraps` 装饰器的工作非常直接；它使包装器看起来像被包装的函数，以便于 `pydoc` 等工具使用。然而，`@wraps` 接受一个参数。'
- en: How does it work if the decorator always accepts just one parameter and that's
    the function it's being applied to? Let's find out.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果装饰器总是只接受一个参数，并且这个参数是它被应用到的函数，那么它将如何工作？让我们来看看。
- en: The @wraps decorator
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@wraps` 装饰器'
- en: The key is that the `@` symbol isn't followed by the name of a decorator per
    se; it's followed by an expression that evaluates to a decorator. So, wraps isn't
    actually a decorator. Strictly speaking, it's a function that returns the decorator.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关键是 `@` 符号后面不是跟一个装饰器的名字；它后面跟着一个表达式，这个表达式会评估为一个装饰器。所以，wraps 实际上不是一个装饰器。严格来说，它是一个返回装饰器的函数。
- en: When Python evaluates the function call expression, `@wraps` returns a decorator
    function, which is then applied to our wrapper.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Python 评估函数调用表达式时，`@wraps` 返回一个装饰器函数，然后将其应用于我们的包装器。
- en: The only function
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 唯一函数
- en: If we were to modify our `@ints_only` decorator so that we could specify an
    arbitrary function that could be applied to all the parameters, it would look
    like the preceding example. So now we have a function called `only`, which returns
    a decorator, which in turn returns a wrapper. This wrapper calls the original
    function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要修改我们的 `@ints_only` 装饰器，以便我们可以指定一个可以应用于所有参数的任意函数，它看起来就像前面的例子。所以现在我们有一个名为
    `only` 的函数，它返回一个装饰器，然后装饰器再返回一个包装器。这个包装器调用原始函数。
- en: That might look terribly inefficient, but in fact the only overhead comes from
    invoking the wrapper. Each time we call the function, the outer two layers of
    code only run once when the function is defined. So that's how you use function
    decorators and taste the sort of things we can use them for.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来效率极低，但实际上，唯一的开销来自于调用包装器。每次我们调用函数时，外层的两层代码在函数定义时只会运行一次。所以这就是使用函数装饰器和体验我们可以用它们做什么的方法。
- en: Function annotations
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数注释
- en: In this section, we'll take a look at how to associate metadata with functions
    beyond docstrings, which we discussed in [Chapter 4](f119f22a-e6c5-40aa-993a-f77c46c6e931.xhtml),
    *Basic Best Practices*. In the previous section, one of our examples was a decorator
    that automatically passed all our decorated function arguments through an adapter.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何将元数据与函数关联起来，而不仅仅是与我们在第 4 章“基本最佳实践”中讨论的文档字符串关联。在前一节中，我们的一个示例是一个自动将所有装饰函数的参数通过适配器传递的装饰器。
- en: That's pretty cool, but what if we want to handle each parameter differently?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷，但如果我们想对每个参数进行不同的处理怎么办？
- en: Sure, we could pass a whole bunch of adapters to the wrapper, but it becomes
    ugly and clumsy as we start dealing with functions that accept more parameters.
    What we'd really like to do is attach metadata directly to a function's parameters.
    Fortunately, that's exactly what function annotations are for.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以向包装器传递一大堆适配器，但随着我们开始处理接受更多参数的函数，这会变得丑陋而笨拙。我们真正想做的就是直接将元数据附加到函数的参数上。幸运的是，这正是函数注释的作用。
- en: Function annotation syntax
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数注释语法
- en: 'The following code example shows off Python''s function annotation syntax:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了 Python 的函数注释语法：
- en: '![](img/e4034570-ef3d-48c6-8bbb-62690b438bce.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e4034570-ef3d-48c6-8bbb-62690b438bce.jpg)'
- en: To associate a value with a parameter, we put a colon (`:`) after the parameter
    name and then write an expression. This expression will be evaluated when the
    function is defined and the result stored along with a parameter name.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一个值与参数关联起来，我们在参数名后放一个冒号（`:`），然后写一个表达式。这个表达式在定义函数时会被评估，并将结果与参数名一起存储。
- en: We can also annotate the return value of a function by writing a `->` arrow
    symbol after the function's parameter list and then an expression, which will
    also be evaluated when the function is defined. The result is stored along with
    the word `return`. Because `return` is a keyword, there is no chance that it will
    collide with a parameter name.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过在函数参数列表后写一个 `->` 箭头符号，然后是一个表达式来注释函数的返回值，这个表达式在定义函数时也会被评估。结果会与单词 `return`
    一起存储。因为 `return` 是一个关键字，所以它不会与参数名冲突。
- en: Accessing annotation data
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问注释数据
- en: 'All the annotations are stored in a dictionary called `__annotations__`, which
    is an attribute of the function itself:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 所有注释都存储在一个名为 `__annotations__` 的字典中，这是函数本身的属性：
- en: '![](img/575c82bf-0238-4b5f-bf6d-bf6a98862028.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/575c82bf-0238-4b5f-bf6d-bf6a98862028.jpg)'
- en: 'As we can see in the preceding code example, annotations are not type declarations,
    though they could certainly be used for that purpose and they resemble the typing
    syntax used in some other languages, as shown here:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码示例所示，注释不是类型声明，尽管它们当然可以用作这种目的，并且它们与某些其他语言中使用的类型语法相似，如下所示：
- en: '![](img/4036a092-3ec6-4849-82ad-6fe8fcaaf69f.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4036a092-3ec6-4849-82ad-6fe8fcaaf69f.jpg)'
- en: They are arbitrary expressions, which means that arbitrary values can be stored
    in the `__annotations__` dictionary. They don't add any meaning to Python itself,
    except that it should store the values. That said, defining parameter and return
    types is a common use of function annotations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是任意表达式，这意味着可以在`__annotations__`字典中存储任意值。它们对Python本身没有增加任何意义，除了应该存储这些值。话虽如此，定义参数和返回类型是函数注解的常见用途。
- en: The @no_type_check decorator
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`@no_type_check`装饰器'
- en: 'If you find yourselves using a tool that assumes annotations are type declarations
    but you want to use them for some other purpose, use the standard `@no_type_check`
    decorator to exempt your function from such processing, as shown here:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是一个假设注解是类型声明的工具，但你希望将它们用于其他目的，请使用标准的`@no_type_check`装饰器来免除你的函数进行此类处理，如下所示：
- en: '![](img/fc411a42-63d4-4823-9c30-000dc64896c5.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fc411a42-63d4-4823-9c30-000dc64896c5.jpg)'
- en: Normally, this isn't needed because most tools that use annotations have a way
    of recognizing the ones meant for them. The decorator is for protecting corner
    cases where things are ambiguous.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这并不是必需的，因为大多数使用注解的工具都有一种识别它们的方法。装饰器是为了保护那些情况模糊的边缘情况。
- en: Annotations as input to function decorators
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将注解作为函数装饰器的输入
- en: Annotations combine well with decorators because annotation values make a good
    way to provide input to a decorator, and decorator-generated wrappers are a good
    place to put code that gives meaning to annotations.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注解与装饰器很好地结合在一起，因为注解值是向装饰器提供输入的好方法，而装饰器生成的包装器是放置赋予注解意义代码的好地方。
- en: 'For example, let''s rewrite the decorator example from the previous section.
    We''ll switch to only accepting keyword arguments, just to keep the example relatively
    simple:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们重写上一节中的装饰器示例。我们将只接受关键字参数，以保持示例相对简单：
- en: '![](img/4b420257-af28-4f46-a3de-ecbcf361539f.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b420257-af28-4f46-a3de-ecbcf361539f.jpg)'
- en: So, the `adapted` decorator encloses the function in a `wrapper`. This `wrapper`
    only accepts keyword arguments, which means that even, if the original function
    could accept positional arguments, they have to be specified by name.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`adapted`装饰器将函数封装在一个`wrapper`中。这个`wrapper`只接受关键字参数，这意味着即使原始函数可以接受位置参数，它们也必须通过名称指定。
- en: Once the function is wrapped, `wrapper` also looks for adapters in the function's
    parameter annotations and applies them before passing the arguments to the real
    function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数被包装，`wrapper`也会在函数的参数注解中查找适配器，并在将参数传递给实际函数之前应用它们。
- en: Once the function returns, the wrapper checks for a return value adapter; if
    it finds one, it applies it to the return value before finally returning it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦函数返回，包装器会检查是否存在返回值适配器；如果找到，它会在最终返回之前将适配器应用于返回值。
- en: When we consider the implications of what's happening here, they're pretty impressive.
    We've actually modified what it means to pass a parameter to a function or return
    a value.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们考虑这里发生的事情的影响时，它们相当令人印象深刻。我们实际上修改了向函数传递参数或返回值的意义。
- en: Keyword arguments
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键字参数
- en: Let's look at another example (refer to the following example). Sometimes, one
    or more of a method's parameters don't require any processing, except assigning
    them to an attribute of self. Can we use decorators and annotations to make this
    happen automatically? Of course we can.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个例子（参考以下示例）。有时，一个方法的一个或多个参数不需要任何处理，除了将它们分配给self的一个属性。我们能否使用装饰器和注解来使这种情况自动发生？当然可以。
- en: '![](img/cc0effef-5ecd-4373-b1bd-e5a849623f27.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc0effef-5ecd-4373-b1bd-e5a849623f27.jpg)'
- en: Let's say that if a parameter is annotated with a string, the value assigned
    to that parameter will be assigned to an attribute of self, using the string as
    the name. And if the parameter is annotated with true, the attribute will have
    the same name as the parameter. If there's no annotation or, if it's not a string
    or true, nothing will happen.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个参数被注解为一个字符串，那么分配给该参数的值将被分配给self的一个属性，使用字符串作为属性名。如果参数被注解为true，则属性将具有与参数相同的名称。如果没有注解，或者注解既不是字符串也不是true，则不会发生任何操作。
- en: Again, for simplicity's sake, let's limit ourselves to keyword arguments. As
    you can see in the preceding example, annotations simplify all sorts of code base
    manipulations of code. Here, we're basically using the same techniques as in the
    previous example but we're doing something entirely different with them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了简单起见，让我们限制自己只使用关键字参数。正如前一个示例中所示，注解简化了代码库中所有类型的代码操作。在这里，我们基本上使用了与上一个示例相同的技巧，但我们用它们做了完全不同的事情。
- en: We've been looking at decorators as the primary consumers of function annotations,
    but that's not necessarily the case. Any code that uses function objects might
    be written to benefit from annotations. This means, anywhere we pass a function
    as a callback, we could potentially use function annotation data to make the code
    smarter about what it does with the function.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直将装饰器视为函数注解的主要消费者，但这并不一定是事实。任何使用函数对象的代码都可能被编写为从注解中受益。这意味着，在任何我们传递函数作为回调的地方，我们都有可能使用函数注解数据来使代码更智能地处理函数。
- en: 'Some of the possibilities are presented in the following list:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表中展示了一些可能性：
- en: Event handlers could be annotated with the names of the values the handler wants
    to receive
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件处理器可以用处理器想要接收的值的名称进行注解
- en: Dependency injection could be automated in a similar way
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖注入可以以类似的方式自动化
- en: Constraint-based systems could be provided with the constraints that could be
    applied to each parameter
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于约束的系统可以提供可以应用于每个参数的约束
- en: Probabilistic reasoning systems could be annotated with prior probability distributions
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 概率推理系统可以用先验概率分布进行注解
- en: Parameters could be annotated with the proper user interface element to display
    in order to have the user input that parameter's value
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数可以用适当的用户界面元素进行注解，以便显示，以便用户输入该参数的值
- en: Inspecting the package signature function
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查包签名函数
- en: 'Before we wrap up this section, I''d like to point out one thing that may be
    helpful down the road. Our example decorators that worked with annotations were
    all limited to keyword arguments for simplicity:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束本节之前，我想指出一个可能对未来有帮助的事情。我们之前使用的示例装饰器都是限于关键字参数以保持简单：
- en: '![](img/03be0ba7-3f74-4b3b-8b16-a5d4821b8ace.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03be0ba7-3f74-4b3b-8b16-a5d4821b8ace.jpg)'
- en: However, if you find yourself wanting to do similar things and also handle all
    sorts of parameters at the same time, the `inspect` package's `signature` function
    will simplify the process significantly.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你发现自己想要做类似的事情，同时还要处理各种参数，`inspect` 包的 `signature` 函数将显著简化这个过程。
- en: So, function annotations are a great way of adding metadata to functions; however,
    they might affect the handling of functions later in all sorts of ways.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数注解是向函数添加元数据的好方法；然而，它们可能会以各种方式影响后续对函数的处理。
- en: Class decorators
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类装饰器
- en: In this section, we'll look at class decorators, which are conceptually similar
    to function decorators but open different doors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨类装饰器，它们在概念上与函数装饰器相似，但打开了不同的途径。
- en: 'Class decorators work in the same basic way that function decorators do. A
    class decorator receives the class as its only parameter, and whatever it returns
    replaces that class. This is illustrated in the following image:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类装饰器的工作方式与函数装饰器基本相同。类装饰器接收类作为其唯一的参数，它返回的任何内容都将替换那个类。这在下图中得到了说明：
- en: '![](img/d485a8e2-ce84-4f26-9116-164f4eb61116.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d485a8e2-ce84-4f26-9116-164f4eb61116.jpg)'
- en: The return value doesn't have to be the same class or even a class at all, but
    it should be something that is meaningful. When it's bound to the class's name,
    it's rarely useful for a decorator to return none.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值不必是相同的类，甚至根本不需要是类，但它应该是具有意义的东西。当它绑定到类的名称时，装饰器返回空值通常是没有用的。
- en: Also, like a function decorator, a class decorator can modify the attributes
    of the class or enclose the whole class in wrapper code. However, modifying the
    attributes of the class is effectively the same as modifying the class of the
    source code. This means that unlike functions, a class decorator can actually
    alter the structure of the decorated code, not just wrap it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于函数装饰器，类装饰器可以修改类的属性或用包装代码包围整个类。然而，修改类的属性实际上与修改源代码中的类是相同的。这意味着与函数不同，类装饰器实际上可以改变装饰代码的结构，而不仅仅是包装它。
- en: Modifying class attributes
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改类属性
- en: 'Modifying class attributes is straightforward; we just use the built-in `getattr`,
    `setattr`, and `delattr` functions, as shown in the following code example:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 修改类属性很简单；我们只需使用内置的`getattr`、`setattr`和`delattr`函数，如下面的代码示例所示：
- en: '![](img/4d0996ef-23ea-4594-91de-cdf706e31fdb.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4d0996ef-23ea-4594-91de-cdf706e31fdb.jpg)'
- en: In the preceding example, we see a simple class decorator that makes the attributes
    of the decorated class readable through the `[]` syntax; at the same time, it
    makes sure the class doesn't allow you to set or delete values through the `[]`
    syntax. While rewriting classes via decorators can be a powerful technique, it's
    not a complicated or surprising task, so there's nothing much to say about it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到一个简单的类装饰器，它使装饰类的属性可以通过`[]`语法读取；同时，它确保类不允许你通过`[]`语法设置或删除值。虽然通过装饰器重写类可以是一个强大的技术，但它并不复杂或令人惊讶，所以对此没有太多可说的。
- en: We can also wrap up classes in their entirety. One common use of this technique
    is that it helps replace a class with a `factory` function. Using a `factory`
    function as an interface to create class instances lets us choose when to return
    an existing object, if there's one interface we think is more appropriate, rather
    than actually creating a new instance.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以完全封装类。这种技术的一个常见用途是它有助于用`factory`函数替换类。使用`factory`函数作为创建类实例的接口，让我们可以选择何时返回现有对象，如果有一个我们认为更合适的接口，而不是实际创建一个新实例。
- en: The factory function
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂函数
- en: Calling a `factory` function means *give me the right object for these parameters,
    rather than giving me a new object for these parameters*. Let's take a look at
    an example class decorator that replaces the class object with a factory function.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调用一个`factory`函数意味着*给我这些参数的正确对象，而不是给我这些参数的新对象*。让我们看看一个用工厂函数替换类对象的示例类装饰器。
- en: 'For instances of this class, we''ll assume that any two instances that were
    created with the same parameters should actually be the same object, as shown
    here:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个类的实例，我们将假设任何使用相同参数创建的两个实例实际上应该是同一个对象，如下所示：
- en: '![](img/9ee20857-154c-46f2-b84d-ac9ba4ced7ce.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9ee20857-154c-46f2-b84d-ac9ba4ced7ce.jpg)'
- en: In the preceding example, we used `WeakValueDictionary` to keep track of the
    existing instances of the class and what parameters that were constructed with.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用了`WeakValueDictionary`来跟踪类的现有实例以及与之构造的参数。
- en: This doesn't have anything to do with class decorators per se; instead, we did
    it because we didn't want the cache to prevent the instances from being garbage
    collected. That's a good practice!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这与类装饰器本身没有关系；相反，我们这样做是因为我们不希望缓存阻止实例被垃圾回收。这是一个好的实践！
- en: Whenever we make a `factory` function, it keeps track of the instances it creates.
    Another bit of good practice that we demonstrated in this example is that we decide
    the class itself as an attribute of the `factory` function. This means that the
    code outside of the `factory` function can still access the class object if it
    really needs to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建一个`factory`函数时，它会跟踪它创建的实例。在这个例子中，我们还展示了一个好的实践，即我们决定将类本身作为`factory`函数的属性。这意味着如果真的需要，`factory`函数外部的代码仍然可以访问类对象。
- en: The factory_constructed function
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂构造函数
- en: 'So, let''s take a look at our factory-making decorator in action. Refer to
    the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看我们的工厂装饰器在实际中的应用。参考以下截图：
- en: '![](img/124cdda1-8000-4723-bbfb-c86d03b81482.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/124cdda1-8000-4723-bbfb-c86d03b81482.jpg)'
- en: Notice that the thing named `Unique` is in fact the `factory` function that
    was created for the `Unique` class, rather than the `Unique` class itself. The
    actual class ends up being named `Unique.type`. Also, notice that `u1` and `u3`
    are not just equal but actually the same object; meanwhile, `u2`, which was created
    with different arguments, is different.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，名为`Unique`的东西实际上是创建给`Unique`类的`factory`函数，而不是`Unique`类本身。实际的类最终被命名为`Unique.type`。此外，注意`u1`和`u3`不仅相等，而且是同一个对象；而`u2`，它使用不同的参数创建，是不同的。
- en: Class definitions
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类定义
- en: Now we're going to take a look at something really wild. The syntax we use for
    defining classes is pretty generic; it could be used to represent all sorts of
    different data structures. So, why not use class decorators to transform class
    definitions into objects of various types?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将看看一些真正疯狂的事情。我们用于定义类的语法相当通用；它可以用来表示各种不同的数据结构。那么，为什么不用类装饰器将类定义转换为各种类型的对象呢？
- en: 'By doing this, we can achieve a sort of sideways decorative programming paradigm.
    For our example (the one that will follow), let''s say we want to connect to a
    sqlite database and create some tables in it if they don''t already exist. We
    can make Python''s class syntax work for us as a convenient way of expressing
    this idea:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以实现一种侧向装饰性编程范式。以我们的示例（接下来将要提到的那个）为例，假设我们想要连接到一个sqlite数据库，并在它不存在的情况下创建一些表。我们可以利用Python的类语法来方便地表达这个想法：
- en: '![](img/f19db3ba-1eb4-4ecb-a14d-5355650eebb1.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f19db3ba-1eb4-4ecb-a14d-5355650eebb1.jpg)'
- en: We want the usage to look something like this code example, where the class
    structure and attributes provide the information that's needed to construct and
    configure a database connection for us. The end result should be a `connection`
    object, which we can use to issue queries according to the Python Database API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望使用方式类似于以下代码示例，其中类结构和属性提供了构建和配置数据库连接所需的信息。最终结果应该是一个`connection`对象，我们可以使用它来根据Python数据库API发出查询。
- en: There are a great many details that are ignored or handled simplistically by
    this example, but it captures the general idea. The class objects that Python
    creates automatically, when it's evaluating these statements, are used to provide
    structured data input to the decorator called `@database` and then discarded.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子忽略了或以简单方式处理了许多细节，但它捕捉了基本概念。Python在评估这些语句时自动创建的类对象，用于向名为`@database`的装饰器提供结构化数据输入，然后被丢弃。
- en: 'The following code example shows the `@database` decorator:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了`@database`装饰器：
- en: '![](img/e90cc3b4-abb2-4b91-9061-869a21cded79.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e90cc3b4-abb2-4b91-9061-869a21cded79.jpg)'
- en: The `@database` decorator returns an open Python Database API connection object,
    not a class of any sort.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`@database`装饰器返回一个打开的Python数据库API连接对象，而不是任何类型的类。'
- en: Metaclasses
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元类
- en: In this section, we'll look at metaclasses, which affect the creation of class
    objects right from the beginning.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨元类，它从一开始就影响类对象的创建。
- en: Like class decorators, metaclasses are a tool we can use to adjust the basic
    meaning of a class. In concept though, they're very different. A class decorator
    takes an already created class and transforms it in some way. A metaclass, on
    the other hand, can affect how a class is created, how it behaves, and even how
    classes that inherit from the modified class are created and behave.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于类装饰器，元类是我们用来调整类基本意义的一种工具。在概念上，它们非常不同。类装饰器接受一个已经创建的类，并以某种方式对其进行转换。另一方面，元类可以影响类的创建方式、行为方式，甚至影响从修改后的类继承的类的创建和行为。
- en: 'To understand metaclasses, first we have to grasp the idea that classes are
    objects, and more than that, they are instances of another class called `type`.
    Whenever we create a new class, we create an instance of `type`, unless the class
    has a metaclass, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解元类，首先我们必须掌握一个概念，即类是对象，而且不仅仅是对象，它们是另一个名为`type`的类的实例。每次我们创建一个新的类时，我们都会创建一个`type`的实例，除非该类有一个元类，如下所示：
- en: '![](img/abd062ca-26bf-4088-ac38-43c25db46e64.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/abd062ca-26bf-4088-ac38-43c25db46e64.jpg)'
- en: If the class we're creating as a metaclass is specified or inherits a metaclass
    from its ancestors, then the new class is an instance of the metaclass rather
    than a direct instance of `type`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建的元类被指定或从其祖先继承了一个元类，那么新类是元类的一个实例，而不是`type`的直接实例。
- en: This sounds like we could change the behavior of a class completely by giving
    it an unusual metaclass, but actually all metaclasses have to resemble `type`
    or Python wouldn't be able to use them properly. Most of the time, metaclasses
    are actually subclasses of `type`, which makes things simple.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来我们可以通过提供一个不寻常的元类来完全改变类的行为，但实际上所有元类都必须类似于`type`，否则Python无法正确使用它们。大多数情况下，元类实际上是`type`的子类，这使得事情变得简单。
- en: What can we do with a metaclass?
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们可以用元类做什么？
- en: First of all, we can run code before the code inside the `class` block is evaluated
    for each class, which is an instance of the metaclass. We do this by having the
    metaclass set as a `__prepare__` method, which should be a class method or a static
    method because it will be called before the instance is created.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们可以在`class`块内的代码被评估之前，为每个类的元类实例运行代码。我们通过将元类设置为`__prepare__`方法来实现这一点，这应该是一个类方法或静态方法，因为它将在实例创建之前被调用。
- en: The __prepare__method
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`__prepare__`方法'
- en: The `__prepare__` method is passed with the name of the new class and its list
    of parent classes as well as any keyword arguments supplied by the user. It can
    do whatever we want it to, but it should also return a dictionary or similar object
    that could be used to hold the class's attributes (refer to the previous example).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`__prepare__` 方法会传递新类的名称、其父类列表以及用户提供的任何关键字参数。它可以执行我们想要的任何操作，但它应该返回一个字典或类似的对象，可以用来存储类的属性（参考前面的示例）。'
- en: We can preassign values to the attribute dictionary from inside of `__prepare__`,
    so we can actually assign attributes to the class before it even exists. That
    brings us to the second thing that metaclasses can easily control-the **class's
    namespace**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `__prepare__` 内部预先分配属性字典的值，这样我们实际上可以在类存在之前就分配属性。这带我们来到了元类可以轻松控制的第二件事——**类的命名空间**。
- en: In our previous example, we returned a `dict()` instance from `__prepare__`,
    so instances of this metaclass use a normal dictionary to store their attributes
    while their code is being evaluated; however, we can return any dictionary-like
    object from `__prepare__`. For example, we can return `OrderedDict` if we want
    to keep track of the order in which attributes were created or `DefaultDict` if
    we want all the attributes to have a default value.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们从 `__prepare__` 返回了一个 `dict()` 实例，因此这个元类的实例在代码评估期间使用正常字典来存储它们的属性；然而，我们可以从
    `__prepare__` 返回任何类似字典的对象。例如，如果我们想跟踪属性创建的顺序，我们可以返回 `OrderedDict`，或者如果我们想所有属性都有一个默认值，我们可以返回
    `DefaultDict`。
- en: We could even use `WeakValueDictionary` if, for some reason, we want the class
    to not protect its attributes from being garbage collected while it is evaluated.
    Of course, `WeakValueDictionary` is a just dictionary-like class that exists in
    the standard library.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用 `WeakValueDictionary`，如果出于某种原因，我们希望类在评估期间不保护其属性不被垃圾回收。当然，`WeakValueDictionary`
    是一个存在于标准库中的类似字典的类。
- en: We can also return a custom dictionary-like class from `__prepare__`, which
    could conceivably do almost anything. If we want a class that ignores the case
    of attribute names while its code is being evaluated, we can do that.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 `__prepare__` 返回一个自定义的类似字典的类，这几乎可以做任何事情。如果我们想要一个在代码评估时忽略属性名称大小写的类，我们可以做到这一点。
- en: The __new__ method
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`__new__` 方法'
- en: 'There''s a reason why I keep saying *while the code is being evaluated*. After
    `__prepare__` is called, the code inside the class block is run and it uses the
    dictionary that was returned from `__prepare__` as its namespace, as shown here:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我之所以一直说 *在代码被评估时*，是有原因的。在调用 `__prepare__` 之后，类块内的代码会被执行，并使用 `__prepare__` 返回的字典作为其命名空间，如下所示：
- en: '![](img/eeef9e1d-33cc-4cde-8ea3-70d5d6abfb65.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eeef9e1d-33cc-4cde-8ea3-70d5d6abfb65.jpg)'
- en: However, after that, the metaclass's `__new__` method is called. One of the
    things `__new__` needs to do is call `type.__new__` to actually allocate and initialize
    a chunk of memory to contain the class data, and one of the things `type.__new__`
    does is convert whatever we pass as a namespace for the object into a normal `dict`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，之后会调用元类的 `__new__` 方法。`__new__` 需要做的一件事是调用 `type.__new__` 来实际分配和初始化一块内存以包含类数据，而
    `type.__new__` 做的一件事是将我们传递给对象命名空间的任何内容转换为正常的 `dict`。
- en: This means that if we want to retain special information that our `namespace`
    object knows, we need to store it somewhere where we can find it later.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果我们想保留 `namespace` 对象知道的特殊信息，我们需要将其存储在我们可以稍后找到的地方。
- en: 'We can make whatever changes we want to the internals of the class, shown in
    the following code example:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对类的内部进行任何我们想要的更改，如下面的代码示例所示：
- en: '![](img/f93207c8-a624-428f-bcf3-98414aacfb10.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/f93207c8-a624-428f-bcf3-98414aacfb10.jpg)'
- en: Once we've created the class object in the `__new__` method of the metaclass,
    we can programmatically add, remove, replace, or wrap the class contents, much
    as we could in a class decorator. We can also return something that isn't actually
    a class object at all, just as we could with a class decorator.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在元类的 `__new__` 方法中创建了类对象，我们就可以像在类装饰器中一样编程地添加、删除、替换或包装类内容。我们也可以返回实际上根本不是类对象的东西，就像我们可以在类装饰器中做的那样。
- en: The difference, aside from a bit of extra typing, is that the subclasses of
    a class that has a metaclass will also inherit that metaclass, while class decorators
    are not inherited.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了多写一点之外，区别在于具有元类的类的子类也会继承那个元类，而类装饰器则不会继承。
- en: This means that using a metaclass, we can make our unusual behaviors inheritable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，使用元类，我们可以使我们的非同寻常的行为可继承。
- en: In this example, you learned that any class that descends from the class where
    the metaclass was originally applied can find all the other classes that also
    descend from that ancestor.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你了解到任何从最初应用元类的类派生的类都可以找到所有其他也从该祖先派生的类。
- en: Context managers
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 上下文管理器
- en: In this section, we'll look at what is maybe Python's most-used programmable
    semantic element—context managers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨可能是 Python 最常用的可编程语义元素——上下文管理器。
- en: Context managers are pieces of code that plug into Python's `with` statement.
    A `with` statement contains a block of code, and the context manager is able to
    run its own code, both before and after that block is executed, along with the
    after code guaranteed to run no matter what happens in the block.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上下文管理器是代码片段，可以插入到 Python 的 `with` 语句中。一个 `with` 语句包含一个代码块，上下文管理器能够在该代码块执行前后运行自己的代码，以及保证无论代码块中发生什么都会运行的代码。
- en: 'The Python standard library makes quite a lot of use of context managers:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Python 标准库大量使用了上下文管理器：
- en: '`open` files can be used as context managers, which guarantees that the file
    will be closed at the end of the block:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`open` 文件可以用作上下文管理器，这保证了文件将在代码块结束时关闭：'
- en: '![](img/02bd6e0c-88b2-4e73-83ff-6dc09dfccef1.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/02bd6e0c-88b2-4e73-83ff-6dc09dfccef1.jpg)'
- en: '`lock` objects could be used as context managers, in which case they acquire
    the lock before the block and release it when the block is finished executing:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lock` 对象可以用作上下文管理器，在这种情况下，它们在代码块开始前获取锁，并在代码块执行完毕后释放锁：'
- en: '![](img/c5a6f978-1fbe-4ee0-a53e-f02daaf68173.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c5a6f978-1fbe-4ee0-a53e-f02daaf68173.jpg)'
- en: 'SQLite database connections can be used as context managers, allowing them
    to automatically commit or roll back the transaction when the block finishes:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 数据库连接可以用作上下文管理器，允许它们在代码块结束时自动提交或回滚事务：
- en: '![](img/8fa45d31-5e26-4665-9af5-93e6d3388439.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8fa45d31-5e26-4665-9af5-93e6d3388439.jpg)'
- en: There are other examples. We can already see in the preceding examples how useful
    context managers can be. They simplify the code by combining setup and cleanup,
    and they improve the code by guaranteeing that they will run the cleanup code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他示例。我们已经在前面的示例中看到了上下文管理器是多么有用。它们通过组合设置和清理来简化代码，并通过保证它们将运行清理代码来改进代码。
- en: Defining a context manager as a generator
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将上下文管理器定义为生成器
- en: So how can we write our own context managers? There are two ways.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何编写自己的上下文管理器呢？有两种方法。
- en: 'The simplest is to use the `@contextlib.contextmanager` decorator on a generator
    function, as we see in the following example:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是在生成器函数上使用 `@contextlib.contextmanager` 装饰器，如下面的示例所示：
- en: '![](img/e80dcba4-2c4f-4603-9052-6c36be7d0e5b.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e80dcba4-2c4f-4603-9052-6c36be7d0e5b.jpg)'
- en: When we create a context manager this way, we can write it as one continuous
    piece of code. We can think of the `yield` statement as a proxy for the whole
    code block that the `with` statement contains.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式创建上下文管理器时，我们可以将其编写为一整段代码。我们可以将 `yield` 语句视为 `with` 语句包含的整个代码块的代理。
- en: If this block raises an exception, it will look toward our context manager code
    as if the `yield` statement was responsible for raising that exception, so we
    can wrap it in a `try` statement to deal with any exceptions that might occur.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这个块引发异常，它将把上下文管理器代码视为如果 `yield` 语句负责引发那个异常，因此我们可以用 `try` 语句包裹它来处理可能发生的任何异常。
- en: We saw the `as` clause of the `with` statement when we used file opening as
    an example of a context manager (refer to the code example of the `open` file);
    it lets us find a value returned from the context manager to a variable accessible
    within the with block. If we yield a value from our context manager code, that
    value will be the one assigned through `as`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用文件打开作为上下文管理器的示例时，我们看到了 `with` 语句的 `as` 子句（请参阅 `open` 文件的代码示例）；它允许我们将上下文管理器返回的值赋给
    `with` 块内可访问的变量。如果我们从上下文管理器代码中产生一个值，那么这个值将通过 `as` 赋值。
- en: In the preceding example, we yield a function that prints the word `during`
    so that the entire result of our `with` statement is that it prints `before`,
    `during`, and `after`, in that order.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们产生一个打印单词 `during` 的函数，以便 `with` 语句的整个结果按顺序打印 `before`、`during` 和 `after`。
- en: Adding context manager behavior to a class
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将上下文管理器行为添加到类中
- en: We can also write context managers by adding `__enter__` and `__exit__` methods
    to objects. Any object that properly implements these methods can be used as a
    context manager, which is how objects such as open files and database connections
    are able to work extra as context managers.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过向对象添加`__enter__`和`__exit__`方法来编写上下文管理器。任何正确实现这些方法的对象都可以用作上下文管理器，这就是为什么像打开文件和数据库连接这样的对象能够作为上下文管理器额外工作。
- en: Synchronous-coroutine-based context managers
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于同步协程的上下文管理器
- en: 'The following is an example in which we create a specialized version of a dictionary,
    which could serve as a context manager:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，其中我们创建了一个字典的专用版本，它可以作为上下文管理器使用：
- en: '![](img/5ad893e2-79d5-4b4b-9352-dfdf85857900.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ad893e2-79d5-4b4b-9352-dfdf85857900.jpg)'
- en: Within the scope of the `with` block, we can read and write data through the
    object that we returned from `__enter__`, but these changes will only be applied
    to the main dictionary. If the block exits without raising an exception, the return
    value of the inner method will be used by the `with` statement for the value to
    be assigned through the `as` clause.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在`with`块的作用域内，我们可以通过从`__enter__`返回的对象读取和写入数据，但这些更改只会应用于主字典。如果块退出而没有引发异常，则内部方法的返回值将由`with`语句用于通过`as`子句分配的值。
- en: Refer to the following code example, the variable `trans` contains the `ChainMap`
    instance. `ChainMap` objects are dictionaries that can have a parent dictionary.
    If `'a'` looking in `ChainMap` fails, it tries to look up the same key in its
    parent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 参考以下代码示例，变量`trans`包含`ChainMap`实例。`ChainMap`对象是具有父字典的字典。如果在`ChainMap`中查找`'a'`失败，它会尝试在其父字典中查找相同的键。
- en: '![](img/5e01cf9b-a024-440a-8da5-40e714ce565f.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5e01cf9b-a024-440a-8da5-40e714ce565f.jpg)'
- en: The `__exit__` method needs to accept parameters that specify the types `exc_type`,
    `exc_val`, and `tb`, if an exception is raised in the `with` block. If no exception
    is raised, all these parameters will contain `None`. If an exception is raised,
    we would need to decide whether and how the context manager will handle them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`__exit__`方法需要接受指定类型`exc_type`、`exc_val`和`tb`的参数，如果在`with`块中引发异常。如果没有引发异常，所有这些参数都将包含`None`。如果引发异常，我们需要决定上下文管理器是否以及如何处理它们。'
- en: In our preceding example, we decided to apply the changes to the main dictionary
    based on whether or not an exception was raised; otherwise, we would have ignored
    the exception. If we want Python to consider the exception to be handled, we could
    return `true` from the `__exit__` method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的示例中，我们决定根据是否引发异常来应用更改到主字典；否则，我们会忽略异常。如果我们想让Python考虑异常已被处理，我们可以从`__exit__`方法返回`true`。
- en: This would be functionally equivalent to catching the function with a `try-except`
    statement. There's another variation of the class-based context manager, which
    supports asynchronous-coroutine-based context management.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这在功能上等同于使用`try-except`语句捕获函数。还有基于类的上下文管理器的另一种变体，它支持基于异步协程的上下文管理。
- en: Creating an asynchronous-coroutine-based context manager
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于异步协程的上下文管理器
- en: 'For the asynchronous protocol, the `__enter__` and `__exit__` methods are replaced
    by `__aenter__` and `__aexit__` coroutine methods and the context manager is invoked
    by an `async with` statement, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于异步协议，`__enter__`和`__exit__`方法被替换为`__aenter__`和`__aexit__`协程方法，上下文管理器通过`async
    with`语句调用，如下所示：
- en: '![](img/c4c0fb06-e0ef-4cca-9f32-035cf276306f.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c4c0fb06-e0ef-4cca-9f32-035cf276306f.jpg)'
- en: This small change buys us the ability to have the `__enter__` and `__exit__`
    methods invoke other coroutines, wait for data to come in from the network, and
    behave nicely in an `asyncio`-based program.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小小的改动让我们能够使`__enter__`和`__exit__`方法调用其他协程，等待从网络传入数据，并在基于`asyncio`的程序中表现得很好。
- en: Descriptors
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 描述符
- en: In this section, we'll take a look at one last way of altering the semantics
    of a Python-based syntax, using descriptors. Reading and writing variables is
    one of the most fundamental aspects of programming. Python's descriptors let us
    alter how it works.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨一种最后一种改变基于Python语法的语义的方法，即使用描述符。读取和写入变量是编程中最基本的部分之一。Python的描述符允许我们改变其工作方式。
- en: A descriptor is an object that is stored in a class and controls what it means
    to get, set, and delete a specific single attribute for instances of that class.
    If we want that sort of control over multiple attributes, we just add a descriptor
    to the class for each attribute we want to control.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 描述符是一个存储在类中的对象，它控制了对于该类的实例来说获取、设置和删除特定单个属性的含义。如果我们想要对多个属性有这种控制，我们只需为每个我们想要控制的属性向类中添加一个描述符。
- en: Using @property to create a descriptor
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@property`创建描述符
- en: 'Python''s built-in `@property` decorator provides a simple way to create a
    descriptor. Let''s consider an example (refer to the following code example) to
    illustrate this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Python的内置`@property`装饰器提供了一种简单的方式来创建描述符。让我们考虑一个示例（参考以下代码示例）来阐述这一点：
- en: '![](img/97a25b0f-b511-4599-acea-cd43681b6189.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/97a25b0f-b511-4599-acea-cd43681b6189.jpg)'
- en: The first `prop` method we wrote in the preceding code example tells Python
    how to figure out the value of an attribute called `prop`, which in this case
    just means fetching it from another attribute and printing the value.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们编写的第一个`prop`方法告诉Python如何确定一个名为`prop`的属性的值，在这种情况下，这仅仅意味着从另一个属性中获取它并打印其值。
- en: The latter two `prop` methods are decorated to turn them into `setter` and `deleter`
    for the `prop` attribute. This means that assigning a value to a prop actually
    means calling the `setter` method, and deleting a prop attribute actually means
    calling the `deleter` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 后两个`prop`方法被装饰以将它们转换为`prop`属性的`setter`和`deleter`。这意味着将值分配给一个属性实际上意味着调用`setter`方法，而删除一个属性实际上意味着调用`deleter`方法。
- en: Both the methods are optional for properties. Leaving them out makes the attribute
    that the property describes into a read-only attribute.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法对于属性都是可选的。省略它们会使属性描述的属性成为只读属性。
- en: Writing descriptors as classes
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将描述符作为类编写
- en: Properties simplify the construction of descriptors for a common case, but there
    are use cases where we need a descriptor that the property can't handle well.
    For example, what if we were planning on making a class that represented remote
    data and we wanted its attributes to push and pull data from a remote source?
    We could do this with properties, but we'd end up writing very similar code over
    and over as we implement each attribute.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 属性简化了常见情况下描述符的构建，但也有一些用例需要我们创建属性无法很好地处理的描述符。例如，如果我们计划创建一个表示远程数据的类，并且希望其属性从远程源推送和拉取数据，我们可以使用属性来实现，但最终我们会反复编写非常相似的代码来实现每个属性。
- en: 'It would be better to have a `RemoteResource` descriptor class and just add
    a bunch of instances to our local stub class. Let''s go ahead and do that as an
    example using the `RemoteResource` descriptor; refer to the following code example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 最好有一个`RemoteResource`描述符类，并仅向我们的本地存根类添加大量实例。让我们使用`RemoteResource`描述符作为示例继续这样做；参考以下代码示例：
- en: '![](img/b509c9e9-e28e-492c-9287-497d8475e376.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b509c9e9-e28e-492c-9287-497d8475e376.jpg)'
- en: Actually, interacting with the network requires a fair amount of code, so it's
    a good thing we can avoid repeating it over and over.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，与网络交互需要相当多的代码，所以能够避免反复重复它是件好事。
- en: The `RemoteResource` class we have in the preceding example has `__get__`, `__set__`,
    and `__delete__` methods, which determine what happens when an attribute that
    is controlled by an instance in this class is accessed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们拥有的`RemoteResource`类有`__get__`、`__set__`和`__delete__`方法，这些方法决定了当由该类的实例控制的属性被访问时会发生什么。
- en: The `__get__` method, perhaps surprisingly, takes two parameters-the `instance`
    through which the attribute's being accessed and the `class` through which the
    attribute is being accessed. It's like this so we can handle both `instance` attribute
    access and `class` attribute access.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__get__`方法可能令人惊讶地接受两个参数——通过该参数访问属性实例和通过该参数访问属性的类。这样做是为了我们可以处理`instance`属性访问和`class`属性访问。'
- en: When accessing a `class` attribute, the `instance` parameter is `None`. In our
    case, we just returned the descriptor in case somebody tries to access the attribute
    as a class member instead of an instance member, which is a reasonable default
    in a lot of cases.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问一个`class`属性时，`instance`参数是`None`。在我们的情况下，我们只是返回了描述符，以防有人试图将属性作为类成员而不是实例成员来访问，这在很多情况下是一个合理的默认值。
- en: The `__set__` method is passed as an instance and value, and it conceptually
    represents setting the control attribute of that instance to the value. Unlike
    `__get__`, it doesn't have support for setting a `class` attribute, so the instance
    will never be `None` and we don't need `class_parameter`.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__set__`方法接收一个实例和值作为参数，在概念上表示将该实例的控制属性设置为该值。与`__get__`不同，它不支持设置`class`属性，因此实例永远不会是`None`，我们也不需要`class_parameter`。'
- en: The `__delete__` method is just passed as an instance and represents removing
    the control attribute from that instance.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__delete__`方法只是传递一个实例，表示从该实例中删除控制属性。'
- en: None of the descriptor methods are told which attribute they represent. The
    assumption is that their `self` parameter will specify that one way or another.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何描述符方法被告知它们代表哪个属性。假设它们的`self`参数会以某种方式指定这一点。
- en: 'In our code (in the preceding code example), we''ve chosen to pass the necessary
    information to the descriptor''s constructor and store it as an attribute of self.
    But, in other circumstances, we might use `self` or `selfs ID` as a key in a dictionary
    to store the per-instance state of the descriptor or use the instance as a key
    in a dictionary stored in `self` as shown in the following code example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码（在先前的代码示例中），我们选择将必要的信息传递给描述符的构造函数，并将其存储为`self`的一个属性。但在其他情况下，我们可能会使用`self`或`selfs
    ID`作为字典中的键来存储描述符的每个实例状态，或者将实例作为存储在`self`中的字典的键，如下面的代码示例所示：
- en: '[PRE0]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can't just store per-instance data as attributes of `self`, though. Descriptors
    are attributes of the class, not the instance, so their self values are shared
    by all the instances of the class that contains them. Either way, we can control
    what it means to get, set, or delete an instance attribute.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，我们并不能仅仅将每个实例的数据存储为`self`的属性。描述符是类的属性，而不是实例的属性，因此它们的`self`值被包含它们的类的所有实例共享。无论如何，我们可以控制获取、设置或删除实例属性的含义。
- en: Once we have the `RemoteResource` class, creating classes that have remote attributes
    becomes easy, as demonstrated by the `Record` class shown in the preceding image.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`RemoteResource`类，创建具有远程属性的类就变得容易了，正如前面图像中显示的`Record`类所示。
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw several other ways of altering the meaning and execution
    of Python code, allowing us to conform the language to our specialized needs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了几种改变Python代码含义和执行方式的其他方法，使我们能够使语言符合我们的特殊需求。
- en: We saw how function decorators use functions as input data for manipulation.
    We took a look at function annotations and particularly how they interact with
    function decorators. We saw how class decorators work exactly as function decorators
    do, but because they operate on classes, the possibilities are very different.
    We saw how to modify classes, wrap them, or even replace them using decorators.
    We discussed how to use a metaclass to affect the construction of a class object
    and how to make unusual behavior inheritable by making it part of a class's metaclass.
    We looked at context manager, both synchronous and asynchronous. We saw how context
    managers work and learned how to make our own for use in either synchronous or
    asynchronous code. We saw how to create simple descriptors using the `property`
    function and more complex descriptors as classes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了函数装饰器如何使用函数作为操作的数据输入。我们考察了函数注解，特别是它们与函数装饰器的交互。我们看到了类装饰器是如何像函数装饰器一样工作的，但由于它们操作的是类，所以可能性非常不同。我们看到了如何使用装饰器修改类、包装它们或甚至用装饰器替换它们。我们讨论了如何使用元类来影响类对象的构建，以及如何通过将其作为类元类的一部分来使异常行为可继承。我们考察了上下文管理器，包括同步和异步的上下文管理器。我们看到了上下文管理器是如何工作的，并学习了如何为我们自己的同步或异步代码创建上下文管理器。我们看到了如何使用`property`函数创建简单的描述符，以及如何创建更复杂的描述符作为类。
- en: In the next chapter, we'll look at automated unit testing—testing a set of techniques
    that could dramatically improve the process of writing a program.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨自动化单元测试——测试一组可能显著提高编写程序过程的技术。
