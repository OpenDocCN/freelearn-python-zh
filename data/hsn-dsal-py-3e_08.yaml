- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Hash Tables
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 哈希表
- en: A hash table is a data structure that implements an associative array in which
    the data is stored by mapping the keys to the values as `key-value` pairs. In
    many applications, we mostly require different operations such as insert, search,
    and delete in a dictionary data structure. For example, a symbol table is a data
    structure based on a hash table that is used by the compiler. A compiler that
    translates a programming language maintains a symbol table in which keys are character
    strings that are mapped to the identifiers. In such situations, a hash table is
    an effective data structure since we can directly compute the index of the required
    record by applying a hash function to the key. So, instead of using the key as
    an array index directly, the array index is computed by applying the hash function
    to the key. It makes it very fast to access an element from any index from the
    hash table. The hash table uses the hashing function to compute the index of where
    the data item should be stored in the hash table.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是一种实现关联数组的抽象数据结构，其中数据通过将键映射到值作为`键值对`进行存储。在许多应用中，我们通常需要在字典数据结构中执行不同的操作，如插入、搜索和删除。例如，符号表是一种基于哈希表的数据结构，由编译器使用。将编程语言翻译成机器语言的编译器维护一个符号表，其中键是映射到标识符的字符串。在这种情况下，哈希表是一种有效的数据结构，因为我们可以通过对键应用哈希函数直接计算所需记录的索引。因此，我们不是直接使用键作为数组索引，而是通过将键应用于哈希函数来计算数组索引。这使得从哈希表的任何索引访问元素变得非常快。哈希表使用哈希函数来计算数据项在哈希表中应存储的位置的索引。
- en: While looking up an element in the hash table, hashing of the key gives the
    index of the corresponding record in the table. Ideally, the hash function assigns
    a unique value to each of the keys; however, in practice, we may get hash collisions
    where the hash function generates the same index for more than one key. In this
    chapter, we will be discussing different techniques that deal with such collisions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在哈希表中查找元素时，键的哈希运算给出表中相应记录的索引。理想情况下，哈希函数为每个键分配一个唯一值；然而，在实践中，我们可能会遇到哈希冲突，即哈希函数为多个键生成相同的索引。在本章中，我们将讨论处理此类冲突的不同技术。
- en: 'In this chapter, we will discuss all the concepts related to these, including:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论与这些概念相关的所有内容，包括：
- en: Hashing methods and hash table techniques
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希方法和哈希表技术
- en: Different collision resolution techniques in hash tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希表中的不同冲突解决技术
- en: Introducing hash tables
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍哈希表
- en: As we know, **arrays** and **lists** store the data elements in sequence. As
    in an array, the data items are accessed by an index number. Accessing array elements
    using index numbers is fast. However, they are very inconvenient to use when it
    is required to access any element when we can’t remember the index number. For
    example, if we wish to extract the phone number for a person from the address
    book at index 56, there is nothing to link a particular contact with number 56\.
    It is difficult to retrieve an entry from the list using the index value.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，**数组**和**列表**按顺序存储数据元素。与数组一样，数据项通过索引号访问。使用索引号访问数组元素是快速的。然而，当需要访问任何元素而我们又无法记住索引号时，它们非常不便。例如，如果我们希望从索引56的地址簿中提取某人的电话号码，没有任何东西可以将特定的联系人与号码56联系起来。使用索引值从列表中检索条目是困难的。
- en: Hash tables are a data structure better suited to this kind of problem. A **hash
    table** is a data structure where elements are accessed by a keyword rather than
    an index number, unlike in **lists** and **arrays**. In this data structure, the
    data items are stored in key-value pairs similar to dictionaries. A hash table
    uses a hashing function in order to find an index position where an element should
    be stored and retrieved. This gives us fast lookups since we are using an index
    number that corresponds to the hash value of the key.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是更适合此类问题的数据结构。**哈希表**是一种数据结构，其中元素通过关键字而不是索引号访问，这与**列表**和**数组**不同。在这个数据结构中，数据项以类似于字典的方式存储在键值对中。哈希表使用哈希函数来找到元素应存储和检索的索引位置。这使我们能够快速查找，因为我们使用的是与键的哈希值相对应的索引号。
- en: An overview of how the hash table stores the data is shown in *Figure 8.1*,
    in which key values are hashed using any hash function to obtain the index position
    of the record in the hash table.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表如何存储数据的概述如图8.1所示，其中使用任何哈希函数对键值进行哈希运算，以获得记录在哈希表中的索引位置。
- en: '![](img/B17217_08_01.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_08_01.png)'
- en: 'Figure 8.1: An example of a hash table'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：哈希表的示例
- en: Dictionaries are a widely used data structure, often built using hash tables.
    A dictionary uses a keyword instead of an index number, and it stores data in
    (`key`, `value`) pairs. That is, instead of accessing the contact with the index
    value, we use the *key* value in the dictionary data structure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 字典是一种广泛使用的数据结构，通常使用哈希表构建。字典使用关键字而不是索引号，并以 (`key`, `value`) 对的形式存储数据。也就是说，我们不是使用索引值来访问联系人，而是使用字典数据结构中的
    *key* 值。
- en: 'The following code demonstrate the working of dictionaries that store the data
    in (`key`, `value`) pairs:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了存储在 (`key`, `value`) 对中的字典的工作原理：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Hash tables stores the data in a very efficient way so that retrieval can be
    very fast. Hash tables are based on a concept called hashing.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表以非常高效的方式存储数据，以便检索可以非常快。哈希表基于称为哈希的概念。
- en: Hashing functions
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哈希函数
- en: Hashing is a technique in which, when we provide data of arbitrary size to a
    function, we get a small, simplified value. This function is called a hash function.
    Hashing uses a hash function to map the keys to another range of data in a way
    that a new range of keys can be used as an index in the hash table; in other words,
    hashing is used to convert the key values to integer values, which can be used
    as an index in the hash table.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一种技术，当我们向函数提供任意大小的数据时，我们得到一个小的、简化的值。这个函数被称为哈希函数。哈希使用哈希函数将键映射到另一个数据范围，以便可以使用新的键范围作为哈希表中的索引；换句话说，哈希用于将键值转换为整数，这些整数可以用作哈希表中的索引。
- en: In our discussions in this chapter, we are using hashing to convert strings
    into integers. We could have used any other data type in place of strings that
    can be converted into integers. Let’s take an example. Say, we want to hash the
    expression `hello world`, that is, we want to get a numeric value corresponding
    to this string that can be used as an index in the hash table.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的讨论中，我们使用哈希将字符串转换为整数。我们本可以使用任何其他可以转换为整数的类型来代替字符串。让我们举一个例子。比如说，我们想要哈希表达式 `hello
    world`，也就是说，我们想要得到与这个字符串相对应的数值，这个数值可以用作哈希表中的索引。
- en: 'In Python, the `ord()` function returns a unique integer value (known as ordinal
    values) that is mapped to a character in the Unicode encoding system. The ordinal
    values map the Unicode character to a unique numerical representation provided
    the character is Unicode-compatible, for example, numbers 0-127 are mapped to
    ASCII characters, which also correspond to the ordinal values within Unicode systems.
    However, the range of Unicode encoding may be larger. So, Unicode encoding is
    a superset of ASCII. For example, in Python, we get a unique ordinal value `102`
    for character ‘`f`'' by using `ord(''f'')`. Further, to get the hash of the whole
    string, we could just sum the ordinal numbers of each character in the string.
    See the following code snippet:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`ord()` 函数返回一个唯一的整数值（称为序数值），该值映射到 Unicode 编码系统中的字符。只要字符是 Unicode
    兼容的，序数值将 Unicode 字符映射到唯一的数值表示，例如，数字 0-127 映射到 ASCII 字符，这些字符也对应于 Unicode 系统中的序数值。然而，Unicode
    编码的范围可能更大。因此，Unicode 编码是 ASCII 的超集。例如，在 Python 中，我们通过使用 `ord('f')` 获取字符 `'f'`
    的唯一序数值 `102`。进一步地，为了获取整个字符串的哈希值，我们只需将字符串中每个字符的序数值相加。请看以下代码片段：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output of the above is as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出的结果如下：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the above output, we obtain a numeric value, `1116`, for the `hello world`
    string, which is the **hash** of the given string. Consider the following *Figure
    8.2* to see the ordinal values of each character in the string that results in
    the hash value `1116`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们获得了字符串 `hello world` 的数值 `1116`，这是给定字符串的**哈希值**。考虑以下**图 8.2**以查看导致哈希值
    `1116` 的字符串中每个字符的序数值：
- en: '![](img/B17217_08_02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_08_02.png)'
- en: 'Figure 8.2: Ordinal values of each character for the hello world string'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：hello world 字符串中每个字符的序数值
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output of the above is as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出的结果如下：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Again, there would be the same hash value for the `''gello xorld''` string,
    as the sum of the ordinal values of the characters for this string would be the
    same since `g` has an ordinal value that is one less than that of `h`, and `x`
    has an ordinal value that is one greater than that of `w`. See the following code
    snippet:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，对于 `'gello xorld'` 字符串，也会有相同的哈希值，因为该字符串中字符的序数值之和是相同的，因为 `g` 的序数值比 `h` 小一，而
    `x` 的序数值比 `w` 大一。请看以下代码片段：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of the above is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出的结果如下：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Look at the following *Figure 8.3*, where we can see that the hash value for
    this `''gello xorld''` string is again `1116`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下*图8.3*，我们可以看到这个`'gello xorld'`字符串的散列值再次是`1116`：
- en: '![](img/B17217_08_03.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_03.png)'
- en: 'Figure 8.3: Ordinal values of each character for the gello xorld string'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：gello xorld字符串中每个字符的序数值
- en: In practice, most of the hashing functions are imperfect and face collisions.
    This means that a hash function gives the same hash value to more than one string.
    Such collisions are undesirable for implementing the hash table.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，大多数散列函数都是不完美的，会面临冲突。这意味着散列函数会给多个字符串相同的散列值。这种冲突对于实现散列表来说是不希望的。
- en: Perfect hashing functions
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完美散列函数
- en: A perfect **hashing function** is one by which we get a unique hash value for
    a given string (it can be any data type; here, we are using a string data type
    as an example). Our aim is to create a hash function that minimizes the number
    of collisions, is fast, easy to compute, and distributes the data items equally
    in the hash table. But, normally, creating an efficient hash function that is
    fast as well as providing a unique hash value for each string is very difficult.
    If we try to develop a hash function that avoids collisions, this becomes very
    slow, and a slow hash function does not serve the purpose of the hash table. So,
    we use a fast hash function and try to find a strategy to resolve the collisions
    rather than trying to find a perfect hash function.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个完美的**散列函数**是指对于给定的字符串（可以是任何数据类型；在这里，我们使用字符串数据类型作为例子），我们得到一个唯一的散列值。我们的目标是创建一个散列函数，该函数最小化冲突的数量，速度快，易于计算，并且在散列表中均匀分布数据项。但是，通常创建一个既快速又为每个字符串提供唯一散列值的效率高的散列函数是非常困难的。如果我们试图开发一个避免冲突的散列函数，这将变得非常慢，而一个慢速的散列函数并不能满足散列表的目的。因此，我们使用一个快速的散列函数，并试图找到一种解决冲突的策略，而不是试图找到一个完美的散列函数。
- en: 'To avoid the collisions in the hash function discussed in the previous section,
    we can add a multiplier to the ordinal value of each character that continuously
    increases as we progress in the string. Furthermore, the hash value of the string
    can be obtained by adding the multiplied ordinal value of each character. To better
    understand the concept, refer to the following *Figure 8.4*:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在前一节讨论的散列函数中的冲突，我们可以在字符串的每个字符的序数值上添加一个乘数，随着我们在字符串中的进展，这个乘数会持续增加。此外，可以通过将每个字符的乘积序数值相加来获得字符串的散列值。为了更好地理解这一概念，请参考以下*图8.4*：
- en: '![](img/B17217_08_04.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_04.png)'
- en: 'Figure 8.4: Ordinal values multiplied by numeric values for each character
    of the hello world string'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：hello world字符串中每个字符的序数值乘以数值
- en: In the preceding *Figure 8.4*, the ordinal value of each character is progressively
    multiplied by a number. Note that row two has the ordinal values of each character;
    row three shows the multiplier value; and, in row four, we get values by multiplying
    the values of rows two and three so that `104 x 1` equals `104`. Finally, we add
    all of these multiplied values to get the hash value of the `hello world` string,
    that is, `6736`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的*图8.4*中，每个字符的序数值逐渐乘以一个数。请注意，第二行有每个字符的序数值；第三行显示乘数值；在第四行，我们通过将第二行和第三行的值相乘得到值，例如`104
    x 1`等于`104`。最后，我们将所有这些乘积值相加，得到`hello world`字符串的散列值，即`6736`。
- en: 'The implementation of this concept is shown in the following function:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数展示了这一概念的实施：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can test this function on the strings that we used earlier, shown as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们之前使用的字符串上测试这个函数，如下所示：
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'When we execute the preceding code, we get the following output:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行前面的代码时，我们得到以下输出：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can see that this time, we get different hash values for these three strings.
    Still, this is not a perfect hash. Let’s now try the strings `ad` and `ga`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，这次，我们为这三个字符串得到了不同的散列值。但这仍然不是一个完美的散列。现在让我们尝试字符串`ad`和`ga`：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of the preceding code snippet is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码片段的输出如下：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: So, we still do not have a perfect hash function since we get the same hash
    values for these two different strings. Therefore, we need to devise a strategy
    for resolving such collisions. We will discuss more strategies to resolve collisions
    in the next sections.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们仍然没有得到一个完美的散列函数，因为我们为这两个不同的字符串得到了相同的散列值。因此，我们需要制定一种解决这种冲突的策略。我们将在下一节中讨论更多解决冲突的策略。
- en: Resolving collisions
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决冲突
- en: Each position in the hash table is often called a **slot** or **bucket** that
    can store an element. Each data item in the form of a (`key`, `value`) pair is
    stored in the hash table at a position that is decided by the hash value of the
    key. Let’s take an example in which firstly we use the hashing function that computes
    the hash value by summing up the ordinal values of all the characters. Then, we
    compute the final hash value (in other words, the index position) by computing
    the total ordinal values of module 256\. Here, we use 256 slots/buckets as an
    example. We can use any number of slots depending upon how many records we require
    in the hash table. We show a sample hash in *Figure 8.5*, which has key strings
    corresponding to data values, for example, the `eggs` key string has the corresponding
    data value `123456789`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表中的每个位置通常被称为**槽**或**桶**，可以存储一个元素。每个以（`键`，`值`）对形式存在的数据项存储在哈希表中，其位置由键的哈希值决定。让我们以一个例子来说明，首先我们使用一个散列函数，通过计算所有字符的序数值之和来计算哈希值。然后，我们通过计算总序数值对256取模来得到最终的哈希值（换句话说，索引位置）。在这里，我们以256个槽/桶为例。我们可以根据在哈希表中需要多少条记录来使用任意数量的槽。我们在*图8.5*中展示了样本哈希，其中包含对应数据值的关键字符串，例如，`eggs`关键字符串对应的值为`123456789`。
- en: 'This hash table uses a hashing function that maps the input string `hello world`
    to a hash value of `92`, which finds a slot position in the hash table:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这个哈希表使用一个散列函数，将输入字符串`hello world`映射到哈希值`92`，这找到了哈希表中的槽位置：
- en: '![](img/B17217_08_05.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_08_05.png)'
- en: 'Figure 8.5: A sample hash table'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：一个样本哈希表
- en: Once we know the hash value of the key, it will be used to find the position
    where the element should be stored in the hash table. So, we need to find an empty
    slot. We start at the slot that corresponds to the hash value of the key. If that
    slot is empty, we insert the data item there. And, if the slot is not empty, that
    means we have a collision. It means that we have a hash value for the item that
    is the same as a previously stored item in the table. We need to ascertain a strategy
    to avoid such collisions or conflicts.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道了键的哈希值，它将被用来找到元素在哈希表中应该存储的位置。因此，我们需要找到一个空槽。我们从与键的哈希值相对应的槽开始。如果那个槽是空的，我们就将数据项插入那里。如果槽不为空，这意味着我们发生了冲突。这意味着我们有一个与表中之前存储的项相同的哈希值。我们需要确定一种策略来避免这种冲突或冲突。
- en: 'For example, in the following diagram, the key string `hello world` is already
    stored in the table at index position `92`, and with a new key string, for example,
    `world hello`, we get the same hash value of `92`. This means that there is a
    collision. Refer to the following *Figure 8.6* depicting this concept:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在下面的图中，关键字符串`hello world`已经存储在索引位置`92`的表中，并且对于一个新的关键字符串，例如`world hello`，我们得到相同的哈希值`92`。这意味着发生了冲突。请参考下面的*图8.6*来展示这个概念：
- en: '![](img/B17217_08_06.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17217_08_06.png)'
- en: 'Figure 8.6: Hash values of two strings are the same'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：两个字符串的哈希值相同
- en: One way of resolving this kind of collision is to find another free slot from
    the position of the collision. This collision resolution process is called **open
    addressing**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这种冲突的一种方法是从冲突的位置找到另一个空闲槽。这种冲突解决过程被称为**开放寻址**。
- en: Open addressing
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放寻址
- en: In open addressing, the key values are stored in the hash table, and collisions
    are resolved using the probing technique. Open addressing a collision resolution
    technique used in hash tables. The collision is resolved by searching (also called
    probing) an alternate position until we get an unused slot in the hash table to
    store the data item.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在开放寻址中，关键值存储在哈希表中，并且使用探测技术来解决冲突。开放寻址是一种在哈希表中使用的冲突解决技术。冲突通过搜索（也称为探测）一个替代位置来解决，直到我们在哈希表中找到一个未使用的槽来存储数据项。
- en: 'There are three popular approaches for an open addressing-based collision resolution
    technique:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于开放寻址的冲突解决技术，有三种流行的方法：
- en: Linear probing
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 线性探测
- en: Quadratic probing
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 二次探测
- en: Double hashing
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双重散列
- en: Linear probing
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线性探测
- en: The systematic way of visiting each slot is a linear way of resolving collisions,
    in which we linearly look for the next available slot by adding `1` to the previous
    hash value where we get the collision. This is known as linear probing. We can
    resolve the conflict by adding `1` to the sum of the ordinal values of each character
    in the key string, which is further used to compute the final hash value by taking
    its modulo according to the size of the hash table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 系统地访问每个槽位的方法是线性解决冲突的方式，其中我们通过将 `1` 加到发生冲突的前一个哈希值上来线性地寻找下一个可用的槽位。这被称为线性探测。我们可以通过将键字符串中每个字符的序数值之和加
    `1` 来解决冲突，这个和进一步用于根据哈希表的大小计算最终的哈希值。
- en: 'Let’s consider an example. First, compute the hash value of the key. If the
    position is occupied, we check the hash table sequentially for the next free slot.
    Let’s use this to resolve a collision, as shown in the following *Figure 8.7*,
    wherein, for the key string `egg`, the sum of ordinal values comes to `307`, and
    then we compute the hash value by taking the module 256, which gives the hash
    value for the `egg` key string as `51`. However, data is already stored at this
    position, so this means a collision. Therefore, we add `1` to the hash value that
    is computed by the sum of the ordinal values of each character of the string.
    In this way, we obtain a new hash value, `52`, for this key string to store the
    data. Refer to the following *Figure 8.7*, which depicts the above process:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子。首先，计算键的哈希值。如果位置已被占用，我们按顺序检查哈希表以找到下一个空闲槽位。让我们用以下 *图8.7* 来解决冲突，其中，对于键字符串
    `egg`，序数值之和为 `307`，然后我们通过取模256来计算哈希值，得到 `egg` 键字符串的哈希值为 `51`。然而，数据已经存储在这个位置，这意味着发生了冲突。因此，我们将字符串中每个字符的序数值之和计算出的哈希值加
    `1`。这样，我们为这个键字符串获得一个新的哈希值 `52` 来存储数据。请参考以下 *图8.7*，它描述了上述过程：
- en: '![](img/B17217_08_07.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_07.png)'
- en: 'Figure 8.7: An example of collision resolution'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：冲突解决的示例
- en: In order to find the next free slot in the hash table, we increment the hashing
    value, and this increment is fixed in the case of linear probing. Due to a fixed
    increment in the hashing value when we get collisions, the new data element is
    always stored at the next available index position given by the hash function.
    This creates a continuous cluster of occupied index positions, with this cluster
    growing whenever we get another data element that has a hash value anywhere within
    the cluster.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在哈希表中找到下一个空闲槽位，我们增加哈希值，在线性探测的情况下，这个增加是固定的。由于在发生冲突时哈希值的增加是固定的，新的数据元素总是存储在由哈希函数给出的下一个可用索引位置。这创建了一个连续的占用索引位置的簇，当我们在簇内的任何位置得到另一个具有哈希值的数据元素时，这个簇就会增长。
- en: So, one major drawback of this approach is that the hash table can have consecutive
    occupied positions that are called clusters of items. In this case, one portion
    of the hash table may become dense, with the other part of the table remaining
    empty. Because of these limitations, we may prefer to use a different strategy
    to resolve collisions such as quadrant probing or double hashing, which we will
    discuss in forthcoming sections. Let us first discuss the implementation of the
    hash table with linear probing as a collision resolution technique, and after
    understanding the concept of linear probing, we will discuss other collision resolution
    techniques.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种方法的一个主要缺点是哈希表可能会有连续的占用位置，这些位置被称为项的簇。在这种情况下，哈希表的一部分可能会变得密集，而表的另一部分则保持为空。由于这些限制，我们可能更喜欢使用不同的策略来解决冲突，例如四分探测或双哈希，这些内容我们将在后续章节中讨论。让我们首先讨论使用线性探测作为冲突解决技术的哈希表实现，在理解了线性探测的概念之后，我们将讨论其他冲突解决技术。
- en: Implementing hash tables
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现哈希表
- en: 'To implement the hash table, we start by creating a class to hold hash table
    items. These need to have a key and a value since the hash table is a `{key-value}`
    store:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现哈希表，我们首先创建一个类来存储哈希表项。由于哈希表是一个 `{键-值}` 存储结构，这些项需要有一个键和一个值：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we start working on the hash table class itself. As usual, we start with
    a constructor:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们开始处理哈希表类本身。像往常一样，我们从构造函数开始：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Standard Python lists can be used to store data elements in a hash table. Let’s
    set the size of the hash table to `256` elements to start with. Later, we will
    look at strategies for how to grow the hash table as we begin filling it up. We
    will now initialize a list containing `256` elements in the code. These are the
    positions where the elements are to be stored—the slots or buckets. So, we have
    `256` slots to store elements in the hash table. It is important to note the difference
    between the size and count of a table. The size of a table refers to the total
    number of slots in the table (used or unused). The count of the table refers to
    the number of slots that are filled, meaning the number of actual `(key-value)`
    pairs that have been added to the table.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的Python列表可以用来在哈希表中存储数据元素。让我们从设置哈希表的大小为`256`个元素开始。稍后，我们将讨论如何随着哈希表的填充而扩展哈希表的战略。现在，我们在代码中初始化一个包含`256`个元素的列表。这些是元素要存储的位置——槽位或桶。因此，我们有`256`个槽位来在哈希表中存储元素。重要的是要注意表的大小和计数的区别。表的大小指的是表中槽位的总数（已使用或未使用）。表的计数指的是已填充的槽位数量，意味着已添加到表中的实际`(键-值)`对的数量。
- en: Now, we have to decide on a hashing function for the table. We can use any hash
    function. Let’s take the same hash function that returns the sum of ordinal values
    for each character in the strings with a slight modification. Since this hash
    table has `256` slots, that means we need a hashing function that returns a value
    in the range of `0` to `255` (the size of the table). A good way of doing it is
    to return the remainder of dividing the hash value by the size of the table since
    the remainder would surely be an integer value between `0` and `255`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须为表选择一个哈希函数。我们可以使用任何哈希函数。让我们采用返回字符串中每个字符序数值之和的相同哈希函数，但稍作修改。由于这个哈希表有`256`个槽位，这意味着我们需要一个返回值在`0`到`255`（表的大小）范围内的哈希函数。一种好的方法是返回哈希值除以表大小的余数，因为余数肯定是一个介于`0`和`255`之间的整数值。
- en: 'Since the hashing function is only meant to be used internally by the class,
    we put an underscore (`_`) at the beginning of the name to indicate this. This
    is a Python convention for indicating that something is intended for internal
    use. Here is the implementation of the `hash` function, which should be defined
    in the `HashTable` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希函数仅打算由类内部使用，我们在名称前加上下划线(`_`)以表示这一点。这是Python表示某物打算用于内部使用的约定。以下是`hash`函数的实现，该函数应在`HashTable`类中定义：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: For the time being, we are assuming that keys are strings. We will discuss how
    non-string keys can be used later. For now, the `_hash()` function is going to
    generate the hash value for a string.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们假设键是字符串。我们将在稍后讨论如何使用非字符串键。现在，`_hash()`函数将生成字符串的哈希值。
- en: Storing elements in a hash table
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在哈希表中存储元素
- en: 'To store the elements in the hash table, we add them to the table with the
    `put()` function and retrieve them with the `get()` function. First, we will look
    at the implementation of the `put()` function. We start by adding the key and
    the value to the `HashItem` class and then compute the hash value of the key.
    The `put()` method should be defined in the `HashTable` class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要在哈希表中存储元素，我们使用`put()`函数将它们添加到表中，并使用`get()`函数检索它们。首先，我们将查看`put()`函数的实现。我们首先将键和值添加到`HashItem`类中，然后计算键的哈希值。`put()`方法应在`HashTable`类中定义：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'After obtaining the hash value of the key and if the slot is not empty, the
    next free slot is checked by adding `1` to the previous hash value by applying
    the linear probing technique. Consider the following code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取键的哈希值并且如果槽位不为空的情况下，通过将前一个哈希值加`1`并应用线性探测技术来检查下一个空闲槽位。考虑以下代码：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the slot is empty, then we increase the count by one and store the new element
    (meaning the slot contained `None` previously) in the list at the required position.
    Refer to the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果槽位为空，则我们将计数增加`1`并将新元素（意味着槽位之前包含`None`）存储在所需位置上的列表中。参考以下代码：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the above code, we have created a hash table and discussed the `put()` method
    for storing the data element in the hash table with the linear probing technique
    at the time of the collision.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们创建了一个哈希表，并讨论了在发生冲突时使用线性探测技术在哈希表中存储数据元素的`put()`方法。
- en: In the last line of the preceding code, we call a `check_growth()` method, which
    is used to expand the size of the hash table when we have a very limited number
    of empty slots remaining in the hash table. We will discuss this in more detail
    in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码的最后一行，我们调用一个 `check_growth()` 方法，该方法用于在我们哈希表中剩余非常有限的空槽位时扩展哈希表的大小。我们将在下一节中更详细地讨论这个问题。
- en: Growing a hash table
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 增加哈希表
- en: In the example that we have discussed, we have fixed the hash table size at
    `256`. It is obvious that, when we add the elements to the hash table, the hash
    table starts filling up, and at some point, all of the slots would be filled up
    and the hash table will be full. To avoid such a situation, we can grow the size
    of the table when it is starting to get full.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的示例中，我们将哈希表的大小固定为 `256`。很明显，当我们向哈希表中添加元素时，哈希表开始填满，在某个时刻，所有的槽位都将被填满，哈希表将满。为了避免这种情况，我们可以在表开始填满时增加表的大小。
- en: 'To grow the size of the hash table, we compare the size and the count in the
    table. `size` is the total number of slots, and `count` denotes the number of
    slots that contain elements. So, if `count` is equal to `size`, this means we
    have filled up the table. The load factor of the hash table is generally used
    to expand the size of the table; that gives us an indication of how many available
    slots of the table have been used. The load factor of the hash table is computed
    by dividing the number of **used** slots by the **total** number of slots in the
    table. It is defined as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加哈希表的大小，我们比较表中的大小和计数。`size` 是槽位的总数，而 `count` 表示包含元素的槽位数量。因此，如果 `count` 等于
    `size`，这意味着我们已经填满了表。哈希表的负载因子通常用于扩展表的大小；这为我们提供了关于表中有多少可用槽位被使用的指示。哈希表的负载因子是通过将已用槽位数量除以表中槽位的总数来计算的。它定义如下：
- en: '*Load factor = n/k*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*负载因子 = n/k*'
- en: Here, n is the number of used slots, and k is the total number of slots. As
    the load factor value approaches 1, this means that the table is going to be filled,
    and we need to grow the size of the table. It is better to grow the size of the
    table before it gets almost full, as the retrieval of elements from the table
    becomes slow when the table fills up. A value of 0.75 for the load factor may
    be a good value to grow the size of the table. Another question is how much we
    should increase the size of the table. One strategy would be to simply double
    its size.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，n 是已用槽位的数量，k 是槽位的总数。当负载因子值接近 1 时，这意味着表将要被填满，我们需要增加表的大小。在表几乎填满之前增加表的大小会更好，因为当表填满时，从表中检索元素会变得缓慢。负载因子为
    0.75 可能是增加表大小的良好值。另一个问题是我们应该增加表的大小多少。一种策略是简单地将其大小加倍。
- en: The problem of linear probing is that as the load factor increases, it takes
    a long time to find the insertion point for the new element. Moreover, in the
    case of the open addressing collision resolution technique, we should grow the
    size of the hash table depending upon the load factor to reduce the number of
    collisions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测的问题在于，随着负载因子的增加，找到新元素插入点所需的时间会变长。此外，在开放寻址冲突解决技术的情况下，我们应该根据负载因子增加哈希表的大小，以减少冲突的数量。
- en: 'The implementation of growing the hash table when the load factor increases
    more than the threshold is as follows. First, we redefine the `HashTable` class
    that includes one more variable, `MAXLOADFACTOR`, that is used to ensure that
    the load factor of the hash table is always below the predefined maximum load
    factor. The `HashTable` class is defined as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当负载因子超过阈值时增加哈希表大小的实现如下。首先，我们重新定义包含一个额外变量 `MAXLOADFACTOR` 的 `HashTable` 类，该变量用于确保哈希表的负载因子始终低于预定义的最大负载因子。`HashTable`
    类定义如下：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, we check the load factor of the hash table after adding any record to
    the hash table using the following `check_growth()` method, which should be defined
    in the `HashTable` class:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下 `check_growth()` 方法检查在向哈希表添加任何记录后哈希表的负载因子，该方法应在 `HashTable` 类中定义：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the preceding code, we compute the load factor of the table, and then we
    check if it is more than the set threshold (in other words, `MAXLOADFACTOR` is
    a variable that we initialize at the time of creating a hash table). In that case,
    we call the `growth()` method that increases the hash table size (in this example,
    we are doubling the hash table size). The `growth()` method, which should be defined
    in the `HashTable` class, is implemented as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们计算表的重载因子，然后检查它是否超过设定的阈值（换句话说，`MAXLOADFACTOR`是一个在创建哈希表时初始化的变量）。在这种情况下，我们调用`growth()`方法来增加哈希表的大小（在这个例子中，我们加倍哈希表的大小）。`growth()`方法应该在`HashTable`类中定义，其实现如下：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding code, we firstly create a new hash table double the size of
    the original hash table and then we initialize all of its slots to be `None`.
    Next, we check all the filled slots in the original hash table where we have the
    data, since we have to insert all these existing records into the new hash table,
    hence, we call the `put()` method with all the key-value pairs of the existing
    hash table. Once we copy all the records to the new hash table, we replace the
    size and slots of the existing table with the new hash table.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码中，我们首先创建一个新的哈希表，其大小是原始哈希表的两倍，然后我们初始化其所有槽位为`None`。接下来，我们检查原始哈希表中所有已填充的槽位，因为我们必须将这些现有记录插入到新的哈希表中，因此，我们使用现有哈希表的所有键值对调用`put()`方法。一旦我们将所有记录复制到新的哈希表中，我们就用新的哈希表替换现有表的大小和槽位。
- en: 'Let’s create a hash table with a maximum capacity of 10 records and a threshold
    load factor of 65% by defining `self.size = 10` in the `__init__` method in the
    `HashTable` class, meaning whenever a seventh record is added to the hash table,
    we call a `check_growth()` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`HashTable`类的`__init__`方法中定义`self.size = 10`来创建一个最大容量为10条记录，阈值负载因子为65%的哈希表，这意味着每当第七条记录被添加到哈希表中时，我们调用一个`check_growth()`方法：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the above code, we add seven records using the `put()` method. The output
    of the preceding code is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们使用`put()`方法添加了七个记录。前述代码的输出如下：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the above output, we can see that the load factor before and after adding
    the seventh record became half of the load factor before growing the hash table.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以看到在添加第七条记录之前和之后，负载因子变成了增长哈希表之前的负载因子的一半。
- en: In the next section, we will discuss the `get()` method for retrieving the data
    element that we have stored in the hash table.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论用于检索存储在哈希表中的数据元素的`get()`方法。
- en: Retrieving elements from the hash table
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从哈希表中检索元素
- en: To retrieve the elements from the hash table, the value stored corresponding
    to the key would be returned. Here, we discuss the implementation of the retrieval
    method—the `get()` method. This method returns the value stored in the table corresponding
    to the given key.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要从哈希表中检索元素，将返回与键存储的值。在这里，我们讨论检索方法的实现——`get()`方法。此方法返回表中存储的与给定键对应的值。
- en: Firstly, we compute the hash of the given key corresponding to the value that
    is to be retrieved. Once we have the hash value of the key, we look up the hash
    table at the position of the hash value. If the key item is matched with the stored
    key value at that location, the corresponding value is retrieved.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们计算给定键对应的要检索的值的哈希值。一旦我们得到了键的哈希值，我们就在哈希表的哈希值位置查找。如果键项与该位置的存储键值匹配，则检索相应的值。
- en: If that does not match, then we add 1 to the sum of the ordinal values of all
    the characters in the string, similar to what we did at the time of storing the
    data, and we look at the newly obtained hash value. We keep searching until we
    get the key element, or we check all the slots in the hash table.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不匹配，那么我们将字符串中所有字符的序数值之和加1，类似于我们在存储数据时所做的，然后我们查看新获得的哈希值。我们继续搜索，直到我们得到键元素，或者检查哈希表中的所有槽位。
- en: 'Here, we used the linear probing technique to resolve the collision, and hence
    we use the same technique when retrieving the data element from the hash table.
    Hence, if we were to use a different technique, let’s say double hashing or quadratic
    probing at the time of storing the data element, we should use the same method
    to retrieve the data element. Consider an example to understand the concept in
    *Figure 8.8*, and in the following four steps:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了线性探测技术来解决冲突，因此在从哈希表中检索数据元素时也使用了同样的技术。因此，如果我们打算在存储数据元素时使用不同的技术，比如说双重哈希或二次探测，那么在检索数据元素时也应该使用相同的方法。考虑*图8.8*中的例子，以及以下四个步骤：
- en: We compute the hash value for the given key string, `egg`, which turns out to
    be `51`. Then, we compare this key with the stored key value at location `51`,
    but it does not match.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算给定键字符串`egg`的哈希值，结果为`51`。然后，我们将这个键与位置`51`处的存储键值进行比较，但它们不匹配。
- en: As the key does not match, we compute a new hash value.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于键不匹配，我们计算一个新的哈希值。
- en: We look up the key at the location of the newly created hash value, which is
    `52`; we compare the key string with the stored key value and, here, it matches,
    as shown in the following diagram.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在新建的哈希值位置查找键，该值为`52`；我们将键字符串与存储的键值进行比较，在这里它们匹配，如下面的图所示。
- en: 'The stored value is returned corresponding to this key value in the hash table.
    See the following *Figure 8.8*:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哈希表返回与该键值对应的存储值。请参考以下*图8.8*：
- en: '![](img/B17217_08_08.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_08.png)'
- en: 'Figure 8.8: Four steps are demonstrated for retrieving an element from the
    hash table'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：演示了从哈希表中检索元素的四步
- en: 'To implement this retrieval method, that is, the `get()` method, we start by
    calculating the hash of the key. Next, we look up the computed hash value in the
    table. If there is a match, we return the corresponding stored value. Otherwise,
    we keep looking at the new hash value location computed as described. Here is
    the implementation of the `get()` method, which should be defined in the `HashTable`
    class:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种检索方法，即`get()`方法，我们首先计算键的哈希值。接下来，我们在表中查找计算出的哈希值。如果找到匹配项，我们返回相应的存储值。否则，我们继续查看按照描述计算出的新哈希值位置。以下是`get()`方法的实现，它应该在`HashTable`类中定义：
- en: '[PRE25]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Finally, we return `None` if the key was not found in the table; we could have
    printed the message that the key is not found in the hash table.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果在表中找不到键，我们返回`None`；我们本可以打印出键在哈希表中未找到的消息。
- en: Testing the hash table
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试哈希表
- en: 'To test the hash table, we create `HashTable` and store a few elements in it,
    and then try to retrieve them. We can use `get()` method to find out if a record
    exists for a given key. We also use the two strings, `ad` and `ga`, that had the
    collision and returned the same hash value with our hashing function. To evaluate
    the work of the hash table, we throw this collision as well, just to see that
    the collision is properly resolved. Refer to the example code, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试哈希表，我们创建`HashTable`并存储一些元素在其中，然后尝试检索它们。我们可以使用`get()`方法来查找是否存在给定键的记录。我们还使用了两个字符串`ad`和`ga`，它们在哈希函数中返回了相同的哈希值，并且发生了冲突。为了评估哈希表的工作，我们将这个冲突也抛出，只是为了看看冲突是否得到了适当的解决。请参考以下示例代码：
- en: '[PRE26]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After executing the above code, we get the following output:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述代码后，我们得到以下输出：
- en: '[PRE27]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, looking up the `worst` key returns `None`, since the key does
    not exist. The `ad` and `ga` keys also return their corresponding values, showing
    that the collision between them is handled properly.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，查找`worst`键返回`None`，因为该键不存在。`ad`和`ga`键也返回它们各自的值，这表明它们之间的冲突得到了适当的处理。
- en: Implementing a hash table as a dictionary
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将哈希表实现为字典
- en: Using the `put()` and `get()` methods to store and retrieve elements in the
    hash table may look slightly inconvenient. However, we can also use the hash table
    as a dictionary, as it would be easier to use. For example, we would like to use
    `ht["good"]` instead of `ht.get("good")` to retrieve elements from the table.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`put()`和`get()`方法在哈希表中存储和检索元素可能看起来有些不便。然而，我们也可以将哈希表用作字典，这样使用起来会更方便。例如，我们希望使用`ht["good"]`而不是`ht.get("good")`来从表中检索元素。
- en: This can easily be done with the special methods, `__setitem__()` and `__getitem__()`,
    which should be defined in the `HashTable` class.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过特殊方法`__setitem__()`和`__getitem__()`轻松实现，这些方法应该在`HashTable`类中定义。
- en: 'See the following code for this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了这一点：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, our test code would be like the following:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试代码如下：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we also print the number of elements already stored in the hash
    table using the `count` variable. The above code does the same thing as we did
    in the previous section, but it is just more convenient to use.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还使用`count`变量打印已存储在哈希表中的元素数量。上述代码与上一节中所做的一样，但使用起来更方便。
- en: In the next section, we discuss the quadratic probing technique for collision
    resolution.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们讨论用于冲突解决的二次探测技术。
- en: Quadratic probing
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二次探测
- en: 'This is also an open addressing scheme for resolving collisions in hash tables.
    It resolves the collision by computing the hash value of the key and adding successive
    values of a quadratic polynomial; the new hash is iteratively computed until an
    empty slot is found. If a collision occurs, the next free slots are checked at
    the locations h + 1², h + 2², h + 3², h + 4², and so on. Hence, the new hash value
    is computed as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一种用于解决哈希表冲突的开放寻址方案。它通过计算键的哈希值并添加二次多项式的连续值来解决冲突；新的哈希值迭代计算，直到找到空槽位。如果发生冲突，则在位置h
    + 1²、h + 2²、h + 3²、h + 4²等位置检查下一个空闲槽位。因此，新的哈希值按以下方式计算：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: When we have a key as strings, we compute the hash value using the sum of the
    ordinal values multiplied by numeric values for each character, and then we pass
    it the hash function to finally obtain the hash of the key string. However, in
    the case of non-string key elements, we can use the hash function directly to
    compute the hash of the key.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有一个字符串键时，我们使用每个字符的序数值乘以数值之和来计算哈希值，然后将其传递给哈希函数，最终获得键字符串的哈希值。然而，在非字符串键元素的情况下，我们可以直接使用哈希函数来计算键的哈希值。
- en: Let us take a simple example of a hash table in which we have seven slots and
    assume that the hash function is `h(key) = key mod 7`. To understand the concept
    of quadratic probing, let’s assume that we have key element values that are the
    hash of the given key strings.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个有七个槽位的简单哈希表为例，并假设哈希函数是`h(key) = key mod 7`。为了理解二次探测的概念，让我们假设我们有键元素值，它们是给定键字符串的哈希值。
- en: 'So, whenever we use the quadratic probing technique to ascertain the next index
    positions to store a data element when we have a collision, we should perform
    the following steps to resolve the collision:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次当我们使用二次探测技术来确定存储数据元素的下一次索引位置时，我们遇到冲突，我们应该执行以下步骤来解决冲突：
- en: Initially, since we have an empty table, when we get a key element of `15` (assuming
    it is a hash of the given string), we compute the hash value using our given hash
    function, in other words, `15 mod 7= 1`. So, the data element is stored at index
    position `1`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始时，由于我们有一个空表，当我们得到一个键元素`15`（假设它是给定字符串的哈希值）时，我们使用我们的给定哈希函数来计算哈希值，换句话说，`15 mod
    7= 1`。因此，数据元素存储在索引位置`1`。
- en: Then, let’s say we get a key element of `22` (assuming it is a hash of the next
    given string), we use the hash function to compute the hash value, in other words,
    `22 mod 7 = 1`, it gives the index position `1`. Since index position `1` is already
    occupied, there is a collision, so we compute a new hash value using quadratic
    probing, which is (1+ 1² = 2). The new index position is `2`. Therefore, the data
    element is stored at index position `2`.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，假设我们得到一个键元素`22`（假设它是下一个给定字符串的哈希值），我们使用哈希函数来计算哈希值，换句话说，`22 mod 7 = 1`，它给出索引位置`1`。由于索引位置`1`已被占用，因此发生冲突，所以我们使用二次探测计算一个新的哈希值，即（1+
    1² = 2）。新的索引位置是`2`。因此，数据元素存储在索引位置`2`。
- en: Next, assuming that we get a data element of `29` (assuming it is a hash of
    the given string), we compute the hash value `29 mod 7 = 1`. Since we have a collision
    here, we compute the hash value again as in *step 2*, but we get another collision
    here, so we have to recompute the hash value once more, in other words (1+2² =
    5), so the data is stored at that location.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，假设我们得到一个数据元素`29`（假设它是给定字符串的哈希值），我们计算哈希值`29 mod 7 = 1`。由于这里发生冲突，我们再次计算哈希值，就像*步骤2*中那样，但在这里我们又遇到了冲突，因此我们必须重新计算哈希值一次，换句话说（1+2²
    = 5），所以数据存储在那个位置。
- en: 'The above example of resolving the process using the quadratic probing technique
    is shown in *Figure 8.9*:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二次探测技术解决过程的上述示例显示在*图8.9*中：
- en: '![](img/B17217_08_09.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_09.png)'
- en: 'Figure 8.9: Example of collision resolution using quadratic probing'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：使用二次探测解决冲突的示例
- en: The quadratic probing technique for collision avoidance does not suffer from
    the formation of clusters of items in the same way as linear probing; however,
    it does suffer from secondary clustering. Secondary clustering creates a long
    run of filled slots since the data elements that have the same hash value will
    also have the same probe sequence.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 用于冲突避免的二次探测技术不会像线性探测那样形成相同项的簇；然而，它确实会遭受次级簇的影响。次级簇会创建一个填充槽位的长时间运行，因为具有相同哈希值的数据元素也将具有相同的探测序列。
- en: 'We discussed the implementation of a hash table in the previous section with
    the addition and retrieval of data elements, and we used the linear probing technique
    to resolve the collision. Now, we can update the implementation of the hash table
    if we want to use any other collision resolution technique, such as the quadratic
    probing technique. All the methods will be the same in the `HashTable` class except
    the following two methods, which should be defined in the `HashTable` class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中讨论了哈希表的实现，包括数据元素的添加和检索，并使用了线性探测技术来解决冲突。现在，如果我们想使用任何其他冲突解决技术，如二次探测技术，我们可以更新哈希表的实现。除了以下两个方法外，`HashTable`类中的所有方法都将保持不变，这两个方法应该在`HashTable`类中定义：
- en: '[PRE32]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The above code of the `get_quadratic()` and `put_quadratic()` methods are similar
    to the implementation of the `get()` and `put()` methods that we discussed earlier,
    except for the fact that the code statements are in bold in the preceding codes.
    The bold statements are indicating that at the time of the collision, we check
    the next empty slot using the quadratic probing formula:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`get_quadratic()`和`put_quadratic()`方法的代码与之前讨论的`get()`和`put()`方法的实现类似，只是前面的代码中代码语句是加粗的。加粗的语句表示在发生冲突时，我们使用二次探测公式检查下一个空槽：
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the above code, we first add three data elements along with their associated
    values, and then we search for a data item with the key `"ga"` in the hash table.
    The output of the preceding code is as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码中，我们首先添加了三个数据元素及其关联的值，然后我们在哈希表中搜索键为`"ga"`的数据项。前面代码的输出如下：
- en: '[PRE34]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The above output corresponds to the key string `"ga"`, which is correct as per
    the input data stored in the hash table. Next, we will discuss another collision
    resolution technique – double hashing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出对应于键字符串`"ga"`，这是正确的，因为输入数据存储在哈希表中。接下来，我们将讨论另一种冲突解决技术——双重哈希。
- en: Double hashing
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双重哈希
- en: In the double hashing collision resolution technique, we use two hashing functions.
    This technique works as follows. Firstly, the primary hash function is used to
    compute the index position in the hash table, and whenever we get a collision,
    we use another hash function to decide the next free slot to store the data by
    incrementing the hashing value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在双重哈希冲突解决技术中，我们使用两个哈希函数。这种技术的工作原理如下。首先，使用主哈希函数计算哈希表中的索引位置，每当发生冲突时，我们使用另一个哈希函数通过增加哈希值来决定存储数据的下一个空闲槽位。
- en: In order to find the next free slot in the hash table, we increment the hashing
    value, and this increment is fixed in the case of linear probing and quadratic
    probing. Due to a fixed increment in the hashing value when we get collisions,
    the record is always moved to the next available index position given by the hash
    function. It creates a continuous cluster of occupied index positions. This cluster
    grows whenever we get another record that has a hash value anywhere within the
    cluster.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在哈希表中找到下一个空闲槽位，我们增加哈希值，在线性探测和二次探测的情况下，这个增加是固定的。由于在发生冲突时哈希值的增加是固定的，记录总是被移动到由哈希函数给出的下一个可用索引位置。这会创建一个连续的占用索引位置的簇。每当有另一个记录的哈希值在簇内任何位置时，这个簇就会增长。
- en: However, in the case of the double hashing technique, the probing interval depends
    on the key data itself, meaning that we always map to the different index positions
    in the hash table whenever we get a collision, which, in turn, helps in avoiding
    the formation of clusters.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在双重哈希技术的情况下，探测间隔取决于键数据本身，这意味着每次发生冲突时，我们总是映射到哈希表中的不同索引位置，这反过来又有助于避免簇的形成。
- en: 'The probing sequence for this collision resolving technique is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这种冲突解决技术的探测序列如下：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is important to note here that the second hash function should be fast, easy
    to compute, should not evaluate to 0, and should be different from the first hash
    function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，第二个散列函数应该是快速的，易于计算，不应等于0，并且应与第一个散列函数不同。
- en: 'One choice for the second hash function can be defined as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个散列函数的一个选择可以定义为以下内容：
- en: '[PRE36]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the above hash function, the prime number should be less than the table size.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述散列函数中，素数应该小于表的大小。
- en: 'For example, let’s say we have a hash table that can have a maximum of seven
    slots when we add data elements `{15, 22, 29}` to this table in sequence. The
    following steps are performed to store these data elements in the hash table using
    the double hashing technique when we get a collision:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们有一个最多可以容纳七个槽位的哈希表，当我们按顺序将数据元素`{15, 22, 29}`添加到该表中时。以下步骤是在发生碰撞时使用双散列技术将这些数据元素存储在哈希表中的步骤：
- en: Firstly, we have data element `15`, and we compute the hash value using the
    primary hash function, in other words, `(15 mod 7 = 1)`. Since the table is empty
    initially, we store the data at index position `1`.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们有数据元素`15`，我们使用主散列函数计算散列值，换句话说，`(15 mod 7 = 1)`。由于表最初是空的，我们将数据存储在索引位置`1`。
- en: Next, the data element is `22`, and we compute the hash value using the primary
    hash function, in other words, `(22 mod 7 = 1)`. Since the index position 1 is
    already filled, this means there is a collision. Next, we use the secondary hashing
    function defined above as `h`²`(key) = prime_number - (key mod prime_number)`
    to ascertain the next index positions in the hash table. Here, we assume that
    the prime number less than the table size is 5\. This means that the next index
    position in the hash table will be `(1 + 1*(5 - (22 mod 5))) mod 7`, which is
    equivalent to 4\. So, we store this data element at index position `4`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，数据元素是`22`，我们使用主散列函数计算散列值，换句话说，`(22 mod 7 = 1)`。由于索引位置1已经被占用，这意味着发生了碰撞。接下来，我们使用上面定义的二级散列函数`h²(key)
    = prime_number - (key mod prime_number)`来确定哈希表中的下一个索引位置。这里，我们假设小于表大小的素数是5。这意味着哈希表中的下一个索引位置将是`(1
    + 1*(5 - (22 mod 5))) mod 7`，这相当于4。因此，我们将此数据元素存储在索引位置`4`。
- en: Next, we have data element 29, so we compute the hash value using the primary
    hashing function, in other words, `(29 mod 7 =1)`. We get a collision, and now
    we use the secondary hash function to establish the next index position for storing
    the data element, in other words, `(1 + 1*(5 - (29 mod 5))) mod 7`, which turns
    out to be 2, so we store this data element at location 2.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有数据元素29，因此我们使用主散列函数计算散列值，换句话说，`(29 mod 7 =1)`。我们遇到了碰撞，现在我们使用二级散列函数来确定存储数据元素的下一个索引位置，换句话说，`(1
    + 1*(5 - (29 mod 5))) mod 7`，结果是2，因此我们将此数据元素存储在位置2。
- en: 'The above example of the process of resolving the collision using double hashing
    is shown in *Figure 8.10*:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用双散列法解决碰撞的过程示例如*图8.10*所示：
- en: '![Diagram, table  Description automatically generated](img/B17217_08_10.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图表，表格 描述自动生成](img/B17217_08_10.png)'
- en: 'Figure 8.10: Example of collision resolution using double hashing'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：使用双散列法解决碰撞的示例
- en: Let us now see how we can implement the hash table with the double hashing technique
    to resolve the collision. The `put_double_hashing()` and `get_ double_hashing
    ()` methods are given as follows, which should be defined in the `HashTable` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看如何实现具有双散列技术以解决碰撞的哈希表。`put_double_hashing()`和`get_double_hashing()`方法如下，这些方法应在`HashTable`类中定义。
- en: 'The following `h2()` method is used to compute the sum of the ordinal values
    since, in our examples, we have strings as a key element:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 以下`h2()`方法用于计算序数值之和，因为在我们示例中，我们将字符串作为键元素：
- en: '[PRE37]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Furthermore, we should redefine the hash table to include a prime number as
    a variable that will be used in computing the secondary hash function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们应该重新定义哈希表，包括一个作为变量使用的素数，该变量将用于计算二级散列函数：
- en: '[PRE38]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The following code is designed to insert a data element and associated value
    in the hash table and use the double hashing technique at the time of collision:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码旨在在哈希表中插入数据元素及其关联值，并在碰撞时使用双散列技术：
- en: '[PRE39]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The above code of the `get_doubleHashing()` and `put_doubleHashing()` methods
    are very similar to the implementation of the `get()` and `put()` methods that
    we discussed earlier, except for the statements that are in bold in the preceding
    codes. The statements in bold are showing that at the time of the collision, we
    use the double hashing technique formula to get the next empty slot in the hash
    table:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_doubleHashing()` 和 `put_doubleHashing()` 方法的上述代码与之前讨论的 `get()` 和 `put()`
    方法的实现非常相似，除了前述代码中加粗的语句。加粗的语句表明在发生冲突时，我们使用双哈希技术公式来获取散列表中的下一个空槽位：'
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the above code, we first insert seven different data elements along with
    their associated values, and then we search and check a few random data items
    in the hash table. The output of the preceding code is as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们首先插入七个不同的数据元素及其关联的值，然后我们在散列表中搜索和检查一些随机数据项。前述代码的输出如下：
- en: '[PRE41]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the above output, we can observe that the key string `worst` is not present
    in the hash table, meaning the output corresponding to this is `None`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述输出中，我们可以观察到键字符串 `worst` 不在散列表中，这意味着对应的输出是 `None`。
- en: Linear probing leads to primary clustering, while quadratic probing may lead
    to secondary clustering, whereas the double hashing technique is one of the most
    effective methods for collision resolution since it does not yield any clusters.
    The advantage of this technique is that it produces a uniform distribution of
    records in the hash table.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 线性探测会导致主要聚簇，而二次探测可能会导致次级聚簇，而双哈希技术是解决冲突的最有效方法之一，因为它不会产生任何聚簇。这种技术的优点是它在散列表中产生记录的均匀分布。
- en: In open addressing collision resolution techniques, we search for another empty
    slot within the hash table, as we did in linear probing, quadratic probing, and
    double hashing. “closed” in “closed hashing” refers to the fact that we do not
    leave the hash table, and every record is stored at an index position given by
    the hash function, hence “closed hashing” and “open addressing” are synonyms.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在开放寻址冲突解决技术中，我们像在线性探测、二次探测和双哈希中做的那样，在散列表中搜索另一个空槽位。“closed”在“closed hashing”中指的是我们不会离开散列表，并且每个记录都存储在哈希函数给出的索引位置，因此“closed
    hashing”和“open addressing”是同义词。
- en: On the other hand, when a record is always stored at an index position given
    by the hash function, this is known as the “closed addressing,” or “open hashing,”
    technique. Here, “open” in “open hashing” refers to the fact that we are open
    to leaving the hash table through a separate list where the data elements can
    be stored; for example, separate chaining is a closed addressing technique.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当一个记录始终存储在哈希函数给出的索引位置时，这被称为“closed addressing”或“open hashing”技术。在这里，“open”在“open
    hashing”中指的是我们愿意通过一个单独的列表离开散列表，其中可以存储数据元素；例如，链地址法是一种封闭寻址技术。
- en: In the next section, we will discuss another collision resolution technique
    – the chaining technique.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论另一种冲突解决技术——链表技术。
- en: Separate chaining
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链地址法
- en: Separate chaining is another method to handle the problem of collision in hash
    tables. It solves this problem by allowing each slot in the hash table to store
    a reference to many items at the position of a collision. So, at the index of
    a collision, we are allowed to store multiple items in the hash table.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 链地址法是另一种处理散列表中冲突问题的方法。它通过允许散列表中的每个槽位存储多个项的引用来解决此问题。因此，在冲突的位置，我们允许在散列表中存储多个项。
- en: 'In chaining, the slots in the hash table are initialized with empty lists.
    When a data element is inserted, it is appended to the list that corresponds to
    that element’s hash value. For example, in the following *Figure 8.11*, there
    is a collision for the key strings `hello world`and `world hello`. In the case
    of chaining, both data elements are stored using a list at the index position
    given by the hash function, in other words, `92` in the example shown in *Figure
    8.11*. Here is an example to show collision resolution using chaining:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中，散列表的槽位被初始化为空列表。当插入一个数据元素时，它被追加到对应该元素哈希值的列表中。例如，在以下 *图8.11* 中，键字符串 `hello
    world` 和 `world hello` 发生了冲突。在链地址法的情况下，两个数据元素都使用哈希函数给出的索引位置存储，也就是说，在 *图8.11* 中的示例中是
    `92`。以下是一个使用链地址法解决冲突的示例：
- en: '![Diagram, table  Description automatically generated](img/B17217_08_11.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图表，表格  自动生成的描述](img/B17217_08_11.png)'
- en: 'Figure 8.11: Example of collision resolution using chaining'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.11*：使用链式连接解决冲突的示例'
- en: 'One more example is shown in *Figure 8.12*, wherein if we have many data elements
    that have a hash value of `51`, all of these elements would be added to the list
    that exists in the same slot of the hash table:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个示例在*图8.12*中展示，其中如果我们有多个具有哈希值`51`的数据元素，所有这些元素都会被添加到哈希表相同槽位中存在的列表中：
- en: '![](img/B17217_08_12.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_12.png)'
- en: 'Figure 8.12: More than one element having the same hash value stored in a list'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.12*：存储在列表中的多个具有相同哈希值的元素'
- en: Chaining then avoids conflict by allowing multiple elements to have the same
    hash value. Hence, there is no limit in terms of the number of elements that can
    be stored in a hash table, whereas, in the case of open addressing collision resolution
    techniques, we had to fix the size of the table, which we need to later grow when
    the table is filled up. Moreover, the hash table can hold more values than the
    number of available slots, since each slot holds a list that can grow.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许多个元素具有相同的哈希值，链式连接避免了冲突。因此，在哈希表中存储元素的数量没有限制，而在开放寻址冲突解决技术的情况下，我们必须固定表的大小，当表被填满时，我们还需要扩展它。此外，哈希表可以存储比可用槽位更多的值，因为每个槽位都包含一个可以增长的列表。
- en: 'However, there is a problem with chaining—it becomes inefficient when a list
    grows at a particular hash value location. As a particular slot has many items,
    searching them can become very slow since we have to do a linear search through
    the list until we find the element that has the key we want. This can slow down
    retrieval, which is not good since hash tables are meant to be efficient. Hence,
    the worst-case time complexity for searching in a separate chaining algorithm
    using linked lists is O(n), because in the worst case, all the items will be added
    to only one index position in the hash table, and searching an item will work
    just similar to a linked list. The following *Figure 8.13* demonstrates a linear
    search through list items until we find a match:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，链式连接存在一个问题——当特定哈希值位置的列表增长时，它会变得低效。由于特定槽位中有许多项目，搜索它们可能会变得非常缓慢，因为我们必须对列表进行线性搜索，直到找到具有我们想要的键的元素。这可能会减慢检索速度，这对哈希表来说并不好，因为哈希表旨在高效。因此，使用链表进行单独链式连接算法搜索的最坏情况时间复杂度为O(n)，因为在最坏的情况下，所有项目都将添加到哈希表中的唯一索引位置，搜索一个项目的工作方式将与链表相似。以下*图8.13*展示了通过列表项进行线性搜索直到找到匹配项：
- en: '![A picture containing text, clock  Description automatically generated](img/B17217_08_13.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![包含文本的图片，时钟  描述自动生成](img/B17217_08_13.png)'
- en: 'Figure 8.13: Demonstration of a linear search for the hash value of 51'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.13*：演示线性搜索以找到哈希值为51的匹配项'
- en: So, there is a problem with the slow retrieval of items when a particular position
    in a hash table has many entries. This problem can be resolved using another data
    structure in place of using a list that can perform fast searching and retrieval.
    There is a nice choice of using **binary search trees** (**BSTs**), which provide
    fast retrieval, as we discussed in the previous chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当哈希表中的特定位置有多个条目时，检索项目会变得缓慢。这个问题可以通过使用另一种数据结构来解决，而不是使用可以快速搜索和检索的列表。一个很好的选择是使用**二叉搜索树**（**BST**），正如我们在上一章中讨论的那样，它提供了快速的检索。
- en: 'We could simply insert an (initially empty) BST into each slot, as shown in
    the following *Figure 8.14*:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在每个槽位中简单地插入一个（最初为空的）二叉搜索树（BST），如下面的*图8.14*所示：
- en: '![](img/B17217_08_14.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_14.png)'
- en: 'Figure 8.14: BST for a bucket for the hash value of 51'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.14*：哈希值为51的桶的二叉搜索树'
- en: In the preceding diagram, the `51` slot holds a BST, which we use to store and
    retrieve the data items. However, we would still have a potential problem—depending
    on the order in which the items were added to the BST, we could end up with a
    search tree that is as inefficient as a list. That is, each node in the tree has
    exactly one child. To avoid this, we would need to ensure that our BST is self-balancing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`51`槽位包含一个BST，我们用它来存储和检索数据项。然而，我们仍然可能遇到一个问题——取决于项目添加到BST中的顺序，我们可能会得到一个与列表一样低效的搜索树。也就是说，树中的每个节点恰好有一个子节点。为了避免这种情况，我们需要确保我们的BST是自平衡的。
- en: 'Here is the implementation of the hash table with separate chaining. Firstly,
    we create a `Node` class to store the key-value pairs and one pointer for pointing
    to the next node in the linked list:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是具有单独链式连接的哈希表的实现。首先，我们创建一个`Node`类来存储键值对，并有一个指针指向链表中的下一个节点：
- en: '[PRE42]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, we define the singly linked list, the details of which are provided in
    *Chapter 4*, *Linked Lists*. Here, we have defined the `append()` method for adding
    a new data record to the linked list:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义单链表，其详细信息在*第4章*，*链表*中提供。在这里，我们已定义了`append()`方法，用于向链表中添加新的数据记录：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we define the `traverse()` method, which prints all the data records
    with `key-value` pairs. The `traverse()` method should be defined in the `SinglyLinkedList`
    class. We start from the head node, and move the next nodes while iterating through
    the `while` loop:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`traverse()`方法，该方法打印出所有带有`键值对`的数据记录。`traverse()`方法应在`SinglyLinkedList`类中定义。我们从头节点开始，在迭代`while`循环时移动下一个节点：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Next, we define a `search()` method that matches the key that we want to search
    in the linked list. If the key matches any of the nodes, the corresponding key-value
    pair is printed. The `search()` method should be defined in the `SinglyLinkedList`
    class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个`search()`方法，该方法匹配我们想要在链表中搜索的键。如果键与任何节点匹配，则打印相应的键值对。`search()`方法应在`SinglyLinkedList`类中定义：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Once, we have defined the linked list and all the required methods, we define
    the `HashTableChaining` class, in which we initialize the hash table with its
    size and all the slots with an empty linked list:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了链表和所有必需的方法，我们定义`HashTableChaining`类，在其中我们初始化哈希表的大小和所有槽位为空链表：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we define the hash function, in other words, `_hash()`, similar to what
    we have discussed in previous sections:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义哈希函数，即`_hash()`，类似于我们在前面的章节中讨论的内容：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, we define the `put()` method to insert a new data record in the hash
    table. Firstly, we create a node with key-pair pairs and then compute the index
    position based on the hash function. Then, we append the node at the end of the
    linked list associated with the given index position. The `put()` method should
    be defined in the `HashTableChaining` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义`put()`方法，用于在哈希表中插入新的数据记录。首先，我们创建一个带有键值对的节点，然后根据哈希函数计算索引位置。然后，我们将节点追加到与给定索引位置关联的链表的末尾。`put()`方法应在`HashTableChaining`类中定义：
- en: '[PRE48]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we define the `get()` method to retrieve the data elements given the
    key value from the hash table. Firstly, we compute the index position using the
    same hash function that we used at the time of adding the records to the hash
    table, and then we search the required data record in the linked list associated
    with the given index position computed. The `get()` method should be defined in
    the `HashTableChaining` class:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义`get()`方法，用于根据哈希表中的键值检索数据元素。首先，我们使用与在哈希表中添加记录时相同的哈希函数计算索引位置，然后我们在与计算出的给定索引位置关联的链表中搜索所需的数据记录。`get()`方法应在`HashTableChaining`类中定义：
- en: '[PRE49]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, we can define the `printHashTable()` method, which prints the complete
    hash table showing all the records of the hash table:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以定义`printHashTable()`方法，该方法打印出完整的哈希表，显示哈希表中的所有记录：
- en: '[PRE50]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can use the following code to insert a few sample data records in the hash
    table and we use the chaining technique to store the data. Then, we search a data
    record with the key string `best`, and we also print the complete hash table:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下代码在哈希表中插入一些示例数据记录，并使用链式技术存储数据。然后，我们使用键字符串`best`搜索数据记录，并打印出完整的哈希表：
- en: '[PRE51]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output of the preceding code is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出如下：
- en: '[PRE52]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The above output shows how all the data records are stored at each index position
    in the hash table. We can observe that multiple data records are stored at the
    same index position given by the hash function.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出显示了所有数据记录如何存储在哈希表的每个索引位置。我们可以观察到，根据哈希函数给出的相同索引位置，存储了多个数据记录。
- en: Hash tables are important data structures for storing data in key-value pairs,
    and we can use any of the collision resolution techniques, in other words, open
    addressing or separate chaining. Open addressing techniques are very fast when
    the keys are uniformly distributed in the hash table, but there is a possible
    complication of cluster formation.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希表是存储键值对数据的重要数据结构，我们可以使用任何冲突解决技术，即开放寻址或单独链表。当键在哈希表中均匀分布时，开放寻址技术非常快，但可能存在集群形成的复杂性。
- en: The separate chaining technique does not have the problem of clustering, but
    it may become slower when all the data records are hashed to a very few index
    positions in the hash table.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 单链表技术没有聚集问题，但当所有数据记录都哈希到哈希表中的非常少数索引位置时，它可能会变慢。
- en: Symbol tables
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 符号表
- en: Symbol tables are used by compilers and interpreters to keep track of the symbols
    and different entities, such as objects, classes, variables, and function names,
    that have been declared in a program. Symbol tables are often built using hash
    tables since it is important to efficiently retrieve a symbol from the table.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表被编译器和解释器用来跟踪程序中声明的符号和不同实体，例如对象、类、变量和函数名。由于从表中高效检索符号很重要，符号表通常使用哈希表构建。
- en: 'Let’s look at an example. Suppose we have the following Python code in the
    `symb.py` file:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。假设我们在`symb.py`文件中有以下Python代码：
- en: '[PRE53]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Here, we have two symbols, `name` and `age`. Each symbol has a value; for example,
    the `name` symbol has the value `Joe`, and the `age` symbol has the value `27`.
    A symbol table allows the compiler or the interpreter to look up these values.
    So, the `name` and `age` symbols become keys in the hash table. All of the other
    information associated with them becomes the `value` of the symbol table entry.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有两个符号，`name`和`age`。每个符号都有一个值；例如，`name`符号的值是`Joe`，而`age`符号的值是`27`。符号表允许编译器或解释器查找这些值。因此，`name`和`age`符号成为哈希表中的键。所有与之相关的其他信息成为符号表条目的`value`。
- en: 'In compilers, symbol tables can have other symbols as well, such as functions
    and class names. For example, the `greet()` function and two variables, in other
    words, `name` and `age`, are stored in the symbol table as shown in *Figure 8.15*:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在编译器中，符号表还可以包含其他符号，例如函数和类名。例如，`greet()`函数和两个变量，换句话说，`name`和`age`，如*图8.15*所示存储在符号表中：
- en: '![](img/B17217_08_15.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17217_08_15.png)'
- en: 'Figure 8.15: Example of a symbol table'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：符号表示例
- en: The compiler creates a symbol table for each of its modules that are loaded
    in memory at the time of its execution. Symbol tables are one of the important
    applications of hash tables, which are mostly used in the compilers and interpreters
    to efficiently store and retrieve the symbols and associated values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器为它在执行时加载到内存中的每个模块创建一个符号表。符号表是哈希表的重要应用之一，主要用于编译器和解释器中高效存储和检索符号及其相关值。
- en: Summary
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed hashing techniques and the data structure of hash
    tables. We learned about the implementation and concepts of different operations
    performed on hash tables. We also discussed several collision resolution techniques,
    including open addressing techniques, namely, linear probing, quadratic probing,
    and double hashing. Furthermore, we discussed another kind of collision resolution
    method – separate chaining. Finally, we looked at symbol tables, which are often
    built using hash tables. Symbol tables allow a compiler or an interpreter to look
    up a symbol (such as a variable, function, or class) that has been defined and
    retrieve all the information about it. In the next chapter, we will discuss graph
    algorithms in detail.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了哈希技术和哈希表的数据结构。我们学习了在哈希表上执行的不同操作的实现和概念。我们还讨论了几种冲突解决技术，包括开放寻址技术，即线性探测、二次探测和双重哈希。此外，我们还讨论了另一种冲突解决方法——分离链接。最后，我们探讨了通常使用哈希表构建的符号表。符号表允许编译器或解释器查找已定义的符号（如变量、函数或类），并检索有关它的所有信息。在下一章中，我们将详细讨论图算法。
- en: Exercise
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: There is a hash table with 40 slots and there are 200 elements stored in the
    table. What will be the load factor of the hash table?
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有一个包含40个槽位的哈希表，表中存储了200个元素。哈希表的负载因子是多少？
- en: What is the worst-case search time of hashing using a separate chaining algorithm?
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用分离链接算法进行哈希的最坏情况搜索时间是什么？
- en: Assume a uniform distribution of keys in the hash table. What will be the time
    complexities for the Search/Insert/Delete operations?
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设哈希表中的键分布均匀。搜索/插入/删除操作的时间复杂度将是什么？
- en: What will be the worst-case complexity for removing duplicate characters from
    an array of characters?
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符数组中删除重复字符的最坏情况复杂度是什么？
- en: Join our community on Discord
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的Discord社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers: [https://packt.link/MEvK4](https://packt.link/MEvK4)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们社区的Discord空间，与作者和其他读者进行讨论：[https://packt.link/MEvK4](https://packt.link/MEvK4)
- en: '![](img/QR_Code1421249772551223062.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code1421249772551223062.png)'
