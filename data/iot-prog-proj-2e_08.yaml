- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Creating an IoT Alarm Dashboard
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物联网警报仪表板
- en: 'In today’s digitalized age, IoT has revolutionized security, transforming basic
    alarm dashboards into comprehensive, real-time security monitors. In [*Chapter
    6*](B21282_06.xhtml#_idTextAnchor091), we started constructing an IoT alarm system
    by building an IoT alarm module that could detect motion and relay MQTT messages.
    [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107), introduced two versions of the
    IoT button: the first uses the M5Stack ATOM Matrix with an LCD matrix screen,
    and the second incorporates an OLED screen, buzzer, arcade-style button for arming
    our IoT alarm module, and a toggle switch for disarming:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '在当今数字化时代，物联网已经革命性地改变了安全，将基本的警报仪表板转变为全面、实时的安全监控器。在[*第6章*](B21282_06.xhtml#_idTextAnchor091)中，我们通过构建一个能够检测运动并中继MQTT消息的物联网警报模块开始了构建物联网警报系统的过程。[*第7章*](B21282_07.xhtml#_idTextAnchor107)介绍了两种版本的物联网按钮：第一个使用M5Stack
    ATOM Matrix和LCD矩阵屏幕，第二个集成了OLED屏幕、蜂鸣器、用于启动我们的物联网警报模块的街机式按钮以及用于解除的切换开关：  '
- en: '![Figure 8.1 – IoT alarm system](img/B21282_08_01.jpg)'
  id: totrans-3
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 物联网警报系统](img/B21282_08_01.jpg)'
- en: Figure 8.1 – IoT alarm system
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 物联网警报系统
- en: In this chapter, we will use our Raspberry Pi 5 with a 7-inch touchscreen to
    serve as our IoT alarm dashboard (*Figure 8**.1*). This dashboard will let us
    arm and disarm our IoT alarm module, review the latest MQTT notification, and
    observe a map pinpointing the location where our alarm was activated. It will
    subscribe and publish to the same MQTT topic, `IoTAlarm`, as the other IoT alarm
    system devices – that is, the IoT alarm module, the M5Stack ATOM Matrix IoT button,
    and the Raspberry Pi Pico W IoT button.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用带有7英寸触摸屏的Raspberry Pi 5作为我们的物联网警报仪表板（*图8**.1*）。这个仪表板将允许我们启动和解除我们的物联网警报模块，查看最新的MQTT通知，并观察一个标记我们警报激活位置的地图。它将订阅并发布到与其他物联网警报系统设备相同的MQTT主题，即物联网警报模块、M5Stack
    ATOM Matrix物联网按钮和Raspberry Pi Pico W物联网按钮。
- en: The IoT alarm dashboard completes our advanced IoT alarm system. Our system
    utilizes IoT technology and the internet’s vast reach for global application deployment.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网警报仪表板完成了我们的高级物联网警报系统。我们的系统利用物联网技术和互联网的广泛覆盖范围进行全球应用部署。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Exploring IoT alarm dashboards
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索物联网警报仪表板
- en: Creating a Raspberry Pi 5 IoT alarm dashboard
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Raspberry Pi 5物联网警报仪表板
- en: Building the external alarm buzzer stand
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建外部警报蜂鸣器支架
- en: Running our application
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: Let’s begin!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following are the requirements for completing this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章所需的以下要求：
- en: Intermediate knowledge of Python programming
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具备Python编程的中级知识
- en: A late model Raspberry Pi, such as the Raspberry Pi 5
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一款新型Raspberry Pi，例如Raspberry Pi 5
- en: A Raspberry Pi branded 7-inch touchscreen with a compatible case
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有兼容机箱的Raspberry Pi品牌7英寸触摸屏
- en: 1x SFM-27 active buzzer
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个SFM-27主动蜂鸣器
- en: 2x M2 5mm screws
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个M2 5mm螺丝
- en: 2x M4 20mm bolts
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个M4 20mm螺栓
- en: 2x M4 nuts
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2个M4螺母
- en: 1x M5 20mm bolt
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个M5 20mm螺栓
- en: 1x M5 nut
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1个M5螺母
- en: Composite (multi-wire) cable with USB plug (a discarded USB charging cable works
    well)
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复合（多线）带USB插头的电缆（废弃的USB充电电缆效果很好）
- en: Hot glue gun
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 热胶枪
- en: Access to a 3D printer or 3D printer service to print an optional case
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问3D打印机或3D打印服务以打印可选的机箱
- en: 'The code for this chapter can be found here:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下位置找到：
- en: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8](https://github.com/PacktPublishing/-Internet-of-Things-Programming-Projects-2nd-Edition/tree/main/Chapter8)'
- en: Exploring IoT alarm dashboards
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索物联网警报仪表板
- en: IoT’s true strength is its limitless capabilities, as seen in IoT alarm dashboards.
    Integrating devices such as the Raspberry Pi 5 with the expansive network of IoT
    opens up new possibilities, especially in security systems. Using the Raspberry
    Pi in alarm systems, whether for homes or businesses, offers immense innovation
    potential. This versatile device opens up possibilities for advanced security
    solutions beyond traditional alarm systems.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网的真正优势是其无限的能力，正如物联网警报仪表板所示。将Raspberry Pi 5等设备与物联网的广泛网络集成，开辟了新的可能性，尤其是在安全系统中。在家庭或商业警报系统中使用Raspberry
    Pi，提供了巨大的创新潜力。这款多功能设备为超越传统警报系统的先进安全解决方案打开了可能性。
- en: Using IoT alarm dashboards for industrial processes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用物联网警报仪表板进行工业流程
- en: In modern industrial settings, monitoring safety and efficiency is essential.
    The industrial IoT alarm dashboard, which is typically integrated into a control
    room, provides an overview of the facility’s operations. It shows real-time metrics
    and system statuses and sends alarms if equipment deviates from standard parameters.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代工业环境中，监控安全和效率至关重要。通常集成到控制室的工业物联网警报仪表盘提供了设施运营的概述。它显示实时指标和系统状态，并在设备偏离标准参数时发送警报。
- en: 'The dashboard’s strength lies in its ability to detect and communicate issues
    quickly via the Internet. For example, in a petrochemical plant, sensors on a
    tank send data to the dashboard, as illustrated in *Figure 8**.2*. Here, sensors
    on the tank publish “temp” and “level” MQTT messages to indicate the temperature
    of the liquid in the tank and the level, respectively. The Raspberry Pi has been
    set up to subscribe to these messages and passes this information onto the web
    interface and analog meter. If the tank’s level drops or its temperature changes
    drastically, the system flags this discrepancy:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 仪表盘的优势在于其能够通过互联网快速检测和沟通问题。例如，在石化厂中，罐体上的传感器将数据发送到仪表盘，如图*图8.2*所示。在这里，罐体上的传感器发布“temp”和“level”MQTT消息，分别指示罐内液体的温度和液位。Raspberry
    Pi已被设置为订阅这些消息，并将此信息传递到网络界面和模拟仪表。如果罐体的液位下降或温度发生剧烈变化，系统会标记这种差异：
- en: '![Figure 8.2 – Industrial IoT application](img/B21282_08_02.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 工业物联网应用](img/B21282_08_02.jpg)'
- en: Figure 8.2 – Industrial IoT application
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 工业物联网应用
- en: Alarms alert the team, allowing for prompt action to be taken to ensure worker
    safety and prevent potential hazards. The dashboard can also initiate automated
    responses, such as shutting down affected areas.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 警报会通知团队，以便及时采取行动确保工人安全并预防潜在危险。仪表盘还可以启动自动化响应，例如关闭受影响区域。
- en: Beyond safety, the IoT dashboard enhances operational efficiency. Analyzing
    long-term data can help industries predict maintenance needs, reducing downtimes.
    The dashboard can also connect to supply systems, updating raw material levels
    and product counts. By using data from various sources, industries can improve
    safety and efficiency.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安全之外，物联网仪表盘还提高了运营效率。分析长期数据可以帮助行业预测维护需求，减少停机时间。仪表盘还可以连接到供应系统，更新原材料水平和产品计数。通过使用来自各种来源的数据，行业可以提高安全和效率。
- en: Exploring the IoT security alarm dashboard
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索物联网安全警报仪表盘
- en: For modern security, the integration of IoT has redefined the capabilities of
    alarm dashboards. These aren’t the traditional systems of the past; IoT-enhanced
    alarm dashboards are dynamic, offering remote access and responsive actions. For
    instance, with the rise of smart homes and businesses, a breach in security doesn’t
    just trigger a loud siren but can instantly notify homeowners through their mobile
    devices, initiate real-time video footage capture, and even communicate with local
    law enforcement, all powered by IoT connectivity.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于现代安全，物联网的集成重新定义了警报仪表盘的功能。这些不再是过去的传统系统；增强型物联网警报仪表盘是动态的，提供远程访问和响应性操作。例如，随着智能家居和企业的兴起，安全漏洞不仅会触发响亮的警报器，还能通过业主的移动设备即时通知他们，启动实时视频画面捕捉，甚至与当地执法部门沟通，这一切都得益于物联网的连接性。
- en: 'Armed with our Raspberry Pi 5 and its 7-inch touchscreen display, we will build
    an alarm dashboard (*Figure 8**.3*) for our IoT alarm system. With this dashboard,
    we can arm and disarm our IoT alarm module using a 4-digit pin. Our dashboard
    will display the latest `IoTAlarm` MQTT message and provide a map of the area
    where our alarm has been triggered:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 配备我们的Raspberry Pi 5及其7英寸触摸屏显示器，我们将为我们的物联网警报系统构建一个警报仪表盘（*图8.3**）。使用这个仪表盘，我们可以使用4位数字密码来启用和禁用我们的物联网警报模块。我们的仪表盘将显示最新的`IoTAlarm`
    MQTT消息，并提供触发警报的区域地图：
- en: '![Figure 8.3 – IoT alarm dashboard](img/B21282_08_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 物联网警报仪表盘](img/B21282_08_03.jpg)'
- en: Figure 8.3 – IoT alarm dashboard
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 物联网警报仪表盘
- en: Since our Raspberry Pi 5 doesn’t have a built-in buzzer, we will add an external
    one that we will connect via the GPIO port using a composite (multi-wire) cable.
    This external buzzer will sit in a custom-designed 3D-printed stand and play a
    melody whenever our armed IoT alarm module is triggered.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的Raspberry Pi 5没有内置蜂鸣器，我们将添加一个外部蜂鸣器，并通过复合（多线）电缆通过GPIO端口连接。这个外部蜂鸣器将放置在一个定制设计的3D打印支架上，并在我们的启用物联网警报模块被触发时播放旋律。
- en: We will start our development by upgrading the code for our IoT alarm module
    so that it works with the map feature of the IoT alarm dashboard.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过升级物联网警报模块的代码开始开发，使其能够与物联网警报仪表板的地图功能协同工作。
- en: Creating a Raspberry Pi 5 alarm dashboard
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Raspberry Pi 5 警报仪表板
- en: Since its release in late 2023, the Raspberry Pi 5 has set a new standard for
    compact computing, enabling developers to build more efficient and powerful applications
    across various domains.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2023 年底发布以来，Raspberry Pi 5 为紧凑型计算设定了新的标准，使开发者能够在各个领域构建更高效、更强大的应用程序。
- en: The Raspberry Pi 5 boasts an advanced processor that enhances our IoT alarm
    dashboard’s data processing speed and multitasking capabilities. Its robust software
    support and extensive Python support offer unparalleled programming flexibility,
    tailored to the IoT alarm system’s needs. Paired with the 7-inch touchscreen,
    our Raspberry Pi 5 provides us with a user-friendly and efficient interface for
    our system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Raspberry Pi 5 拥有先进的处理器，提高了我们的物联网警报仪表板的数据处理速度和多任务处理能力。其强大的软件支持和广泛的 Python 支持，提供了无与伦比的编程灵活性，适用于物联网警报系统的需求。搭配
    7 英寸触摸屏，我们的 Raspberry Pi 5 为我们的系统提供了一个用户友好且高效的界面。
- en: We will begin developing our IoT alarm dashboard by modifying the IoT alarm
    module code from [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091) so that it publishes
    the `location` data on the `IoTAlarm` MQTT topic. This data will enable our dashboard
    to identify the geographic position of the IoT alarm module with precision once
    it’s armed and activated.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将开始开发我们的物联网警报仪表板，通过修改来自 [*第 6 章*](B21282_06.xhtml#_idTextAnchor091) 的物联网警报模块代码，使其在
    `IoTAlarm` MQTT 主题上发布 `location` 数据。一旦该数据被激活，我们的仪表板将能够精确地识别物联网警报模块的地理位置。
- en: Modifying the IoT alarm module code
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改物联网警报模块代码
- en: '*Figure 8**.1* shows a slightly modified version of our IoT alarm module with
    the addition of a `location` message that sends geolocation data to our IoT alarm
    dashboard. In this case, we could integrate a GPS module, like the shown one in
    *Figure 8**.4*, into our IoT alarm module:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.1* 展示了我们的物联网警报模块的一个略微修改版本，其中添加了一个 `location` 消息，该消息将地理位置数据发送到我们的物联网警报仪表板。在这种情况下，我们可以将类似图
    *图 8.4* 中所示的 GPS 模块集成到我们的物联网警报模块中：'
- en: '![Figure 8.4 – The GPS module next to a Raspberry Pi Pico](img/B21282_08_04.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – GPS 模块紧邻 Raspberry Pi Pico](img/B21282_08_04.jpg)'
- en: Figure 8.4 – The GPS module next to a Raspberry Pi Pico
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – GPS 模块紧邻 Raspberry Pi Pico
- en: GPS test code
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: GPS 测试代码
- en: This chapter’s GitHub repository contains test code for a BN-180 GPS module
    and a Raspberry Pi Pico.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的 GitHub 仓库包含 BN-180 GPS 模块和 Raspberry Pi Pico 的测试代码。
- en: 'However, despite its compact size and ability to easily connect to the Raspberry
    Pi Pico W, its value is limited as our IoT alarm module is for indoor use, and
    the GPS would struggle to obtain a strong signal:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管其体积紧凑且易于连接到 Raspberry Pi Pico W，但由于我们的物联网警报模块是室内使用，GPS 将难以获得强信号：
- en: '![Figure 8.5 – Worldwide deployment of the IoT alarm module](img/B21282_08_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 物联网警报模块的全球部署](img/B21282_08_05.jpg)'
- en: Figure 8.5 – Worldwide deployment of the IoT alarm module
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 物联网警报模块的全球部署
- en: Instead, we’ll embed the GPS coordinates directly into our IoT alarm module’s
    code, operating under the assumption that the module’s location will remain static
    post-deployment. As the code requires Wi-Fi configuration updates, it’s straightforward
    to adjust the GPS details when we deploy the IoT alarm module on-site. This geolocation
    data will be published within the `location` message as part of enhancing our
    module code. This approach allows us to deploy our IoT alarm modules globally,
    as illustrated in *Figure 8**.5*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将直接将 GPS 坐标嵌入到我们的物联网警报模块代码中，假设模块的位置在部署后保持静态。由于代码需要 Wi-Fi 配置更新，因此在我们现场部署物联网警报模块时调整
    GPS 详细信息非常简单。这部分地理位置数据将作为增强我们模块代码的一部分，在 `location` 消息中发布。这种方法使我们能够将物联网警报模块全球部署，如图
    *图 8.5* 所示。
- en: To publish the geolocation information, we will modify the `motion_handler()`
    method from the `main.py` file, which is stored on our IoT alarm module.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布地理位置信息，我们将修改存储在我们的物联网警报模块上的 `main.py` 文件中的 `motion_handler()` 方法。
- en: The advantage of using MicroPython over C with microcontrollers
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微控制器时，与 C 相比使用 MicroPython 的优势
- en: While MicroPython runs slower than C, its adaptability is evident when it comes
    to modifying the code for the IoT alarm module. With C, changes require recompilation
    and external code tracking. MicroPython, however, can be edited directly on the
    microcontroller, bypassing filesystem searches during alterations.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 MicroPython 的运行速度比 C 语言慢，但当涉及到修改物联网警报模块的代码时，其适应性是显而易见的。使用 C 语言时，更改需要重新编译和外部代码跟踪。然而，MicroPython
    可以直接在微控制器上编辑，在更改过程中绕过文件系统搜索。
- en: 'To modify the code, we must do the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改代码，我们必须执行以下操作：
- en: First, we connect our Raspberry Pi Pico W to a USB port on your computer and
    launch Thonny.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将Raspberry Pi Pico W连接到计算机的USB端口并启动Thonny。
- en: 'Then, we activate the MicroPython environment on our Pico W by selecting it
    from the bottom right-hand side of the screen:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从屏幕的右下角选择Pico W上的MicroPython环境以激活它：
- en: '![Figure 8.6 – Selecting MicroPython and Pico in Thonny (Windows version shown)](img/B21282_08_06.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 在Thonny中选择MicroPython和Pico（显示Windows版本）](img/B21282_08_06.jpg)'
- en: Figure 8.6 – Selecting MicroPython and Pico in Thonny (Windows version shown)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 在Thonny中选择MicroPython和Pico（显示Windows版本）
- en: 'Under the `main.py` file to open it:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main.py`文件下打开它：
- en: '![Figure 8.7 – Selecting the main.py file](img/B21282_08_07.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7 – 选择main.py文件](img/B21282_08_07.jpg)'
- en: Figure 8.7 – Selecting the main.py file
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 选择main.py文件
- en: 'Then, we rewrite the `motion_handler()` method so that it reads as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们重写`motion_handler()`方法，使其如下所示：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Our only change here is the addition of another publish method on the `mqtt_client`
    object. In the new `publish()` method, we create a message called `location` that
    provides the approximate GPS coordinates of the CN Tower in Toronto, Canada.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里的唯一更改是在`mqtt_client`对象上添加另一个发布方法。在新的`publish()`方法中，我们创建了一个名为`location`的消息，它提供了加拿大多伦多CN塔的大致GPS坐标。
- en: IoT alarm module geolocation
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 物联网警报模块地理位置
- en: We’ve designed our IoT alarm module to be permanently installed at an indoor
    location – that is, the hard-coded geolocation. We are using the CN Tower in Toronto,
    Canada as an example. You’re encouraged to provide your own unique GPS coordinates.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的物联网警报模块旨在永久安装在室内位置——即硬编码的地理位置。我们以加拿大多伦多的CN塔为例。我们鼓励您提供您自己的独特GPS坐标。
- en: We then save our changes to our Raspberry Pi Pico W.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接着将我们的更改保存到我们的Raspberry Pi Pico W。
- en: We’ll see the impact of this adjustment when we set up and launch the IoT alarm
    dashboard on our Raspberry Pi 5 in the upcoming section.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节设置和启动Raspberry Pi 5上的物联网警报仪表板时看到这次调整的影响。
- en: Writing the dashboard code
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写仪表板代码
- en: For the IoT alarm dashboard, we’ll use the Raspberry Pi 5, the Raspberry Pi
    7-inch touchscreen, and its compatible case. This configuration is like what we
    established in [*Chapter 4*](B21282_04.xhtml#_idTextAnchor068), with the addition
    of an external buzzer exclusive to the IoT alarm dashboard.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于物联网警报仪表板，我们将使用Raspberry Pi 5、7英寸触摸屏Raspberry Pi及其兼容的机箱。此配置类似于我们在[*第4章*](B21282_04.xhtml#_idTextAnchor068)中建立的配置，增加了专用于物联网警报仪表板的外部蜂鸣器。
- en: We’ll begin by setting up our development environment and installing the packages
    required for our code.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从设置我们的开发环境和安装代码所需的包开始。
- en: Setting up our development environment
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置我们的开发环境
- en: 'We will use a Python virtual environment for our development. As there are
    libraries that only work with the root installation of Python, we will use system
    packages in our Python virtual environment. To do so, we must do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的开发使用Python虚拟环境。由于有一些库只与Python的根安装版本兼容，我们将在Python虚拟环境中使用系统包。为此，我们必须执行以下操作：
- en: On our Raspberry Pi 5, we open a Terminal application.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的Raspberry Pi 5上，我们打开一个终端应用程序。
- en: 'To store our project files, we create a new directory by running the following
    command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要存储我们的项目文件，我们运行以下命令创建一个新的目录：
- en: '[PRE1]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we navigate to the new directory:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们导航到新目录：
- en: '[PRE2]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we create a new Python virtual environment for our project:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的项目创建一个新的Python虚拟环境：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our new Python virtual environment created, we source into it with the
    following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建了新的Python虚拟环境后，我们使用以下命令将其源代码导入：
- en: '[PRE4]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![Figure 8.8 – Terminal showing the use of the dashboard-env environment](img/B21282_08_08.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8 – 显示使用dashboard-env环境的终端](img/B21282_08_08.jpg)'
- en: Figure 8.8 – Terminal showing the use of the dashboard-env environment
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 显示使用dashboard-env环境的终端
- en: 'Next, we install the extra packages that are required for our code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们安装代码所需的额外包：
- en: '[PRE5]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With the extra packages installed, we close the Terminal:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装了额外的包后，我们关闭终端：
- en: '[PRE6]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We are now ready to load up Thonny. To do so, we click on the **Menu** icon
    in the Raspberry Pi taskbar, navigate to the **Programming** category, and select
    **Thonny**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经准备好加载Thonny。为此，我们点击Raspberry Pi任务栏中的**菜单**图标，导航到**编程**类别，并选择**Thonny**。
- en: By default, Thonny uses the Raspberry Pi’s built-in version of Python. For our
    project, we will use the Python virtual environment we just created. To start,
    we need to view the project files by clicking on **View** and selecting **Files**
    if it isn’t already selected.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Thonny使用Raspberry Pi的内置Python版本。对于我们的项目，我们将使用我们刚刚创建的Python虚拟环境。首先，我们需要通过点击**查看**并选择**文件**来查看项目文件（如果它还没有被选中）。
- en: In the `Files` section, we locate and open the `dashboard-env` directory.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`文件`部分，我们定位并打开`dashboard-env`目录。
- en: 'Then, right-click on the `pyvenv.cfg` file and select the **Activate virtual**
    **environment** option:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，右键单击`pyvenv.cfg`文件，并选择**激活虚拟环境**选项：
- en: '![Figure 8.9 – Activating a Python virtual environment in Thonny](img/B21282_08_09.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9 – 在Thonny中激活Python虚拟环境](img/B21282_08_09.jpg)'
- en: Figure 8.9 – Activating a Python virtual environment in Thonny
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 在Thonny中激活Python虚拟环境
- en: Activating the Python virtual environment
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 激活Python虚拟环境
- en: In the steps above we activated the Python virtual environment by clicking on
    the `pyvenv.cfg` file. The step was outlined this way to show an alternative way
    to activate the Python virtual environment than the way shown in previous chapters.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述步骤中，我们通过点击`pyvenv.cfg`文件激活了Python虚拟环境。这一步骤以这种方式概述是为了展示一种激活Python虚拟环境的方法，而不是之前章节中展示的方法。
- en: With our project folder created, our Python virtual environment set up, and
    the packages we need for our project installed, we can start writing the code
    for our IoT alarm dashboard. We will divide our code into two files – one for
    the GUI that creates the dashboard and the other to activate the buzzer. But before
    we do, we must wire up the buzzer to the GPIO port of our Raspberry Pi 5.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建项目文件夹、设置Python虚拟环境并安装我们项目所需的包后，我们可以开始编写我们的物联网警报仪表板的代码。我们将把我们的代码分成两个文件——一个用于创建仪表板的GUI，另一个用于激活蜂鸣器。但在我们这样做之前，我们必须将蜂鸣器连接到我们的Raspberry
    Pi 5的GPIO端口。
- en: Wiring up the buzzer
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接蜂鸣器
- en: 'For our project, we will use an SFM-27 active buzzer. We wire the buzzer with
    the positive wire (red) connected to GPIO 4 and the negative wire (black) connected
    to GND on the Raspberry Pi 5\. We have the option of installing the buzzer into
    a custom case, something we’ll cover later in this chapter. For our code development
    and testing purposes, it is enough to wire the SFM-127 active buzzer directly
    to the Raspberry Pi 5:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们将使用一个SFM-27主动蜂鸣器。我们将蜂鸣器的正极线（红色）连接到GPIO 4，负极线（黑色）连接到Raspberry Pi 5上的GND。我们有将蜂鸣器安装到定制外壳的选项，我们将在本章后面讨论这一点。为了我们的代码开发和测试目的，直接将SFM-127主动蜂鸣器连接到Raspberry
    Pi 5就足够了：
- en: '![Figure 8.10 – Wiring the buzzer to the Raspberry Pi 5’s GPIO port](img/B21282_08_10.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10 – 将蜂鸣器连接到Raspberry Pi 5的GPIO端口](img/B21282_08_10.jpg)'
- en: Figure 8.10 – Wiring the buzzer to the Raspberry Pi 5’s GPIO port
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 将蜂鸣器连接到Raspberry Pi 5的GPIO端口
- en: With the buzzer connected to our Raspberry Pi 5, it is now time to write and
    test the buzzer code. We will use this code to activate the buzzer when our dashboard
    receives a `buzzer` message from the MQTT server.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在蜂鸣器连接到我们的Raspberry Pi 5后，现在是时候编写和测试蜂鸣器代码了。我们将使用此代码在仪表板从MQTT服务器接收到`buzzer`消息时激活蜂鸣器。
- en: Writing and testing the buzzer code
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写和测试蜂鸣器代码
- en: We write our buzzer code using Thonny on our Raspberry Pi 5, which has a 7-inch
    screen. For more screen space to assist in coding, we can add another monitor
    through the Raspberry Pi 5’s mini-HDMI port, creating a dual-monitor setup.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Thonny在我们的7英寸屏幕的Raspberry Pi 5上编写蜂鸣器代码。为了有更多的屏幕空间来辅助编码，我们可以通过Raspberry Pi
    5的mini-HDMI端口添加另一个显示器，创建一个双显示器设置。
- en: 'To write and test our buzzer code, do the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写和测试我们的蜂鸣器代码，请按照以下步骤操作：
- en: We launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过点击Raspberry Pi任务栏中的**菜单**图标，导航到**编程**类别，并选择**Thonny**来启动Thonny。
- en: We then activate the `dashboard-env` Python virtual environment.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们激活`dashboard-env` Python虚拟环境。
- en: Once inside Thonny, we create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦进入Thonny，我们通过选择**文件**然后**新建**或按键盘上的*Ctrl* + *N*来创建一个新的标签页。
- en: 'In our new file, we enter the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的新文件中，我们输入以下代码：
- en: '[PRE7]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We save the file as `buzzer.py` in the `dashboard` project folder on our Raspberry
    Pi 5.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将文件保存为 `buzzer.py`，位于 Raspberry Pi 5 的 `dashboard` 项目文件夹中。
- en: 'Before we test our code, let’s examine it:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在测试我们的代码之前，让我们检查它：
- en: We start by importing the `TonalBuzzer` class from the `gpiozero` module.
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从 `gpiozero` 模块导入 `TonalBuzzer` 类。
- en: Then, we import the `Tone` class from `gpiozero.tones`.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们从 `gpiozero.tones` 导入 `Tone` 类。
- en: We finish our imports by importing the `sleep` function from the `time` module.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过从 `time` 模块导入 `sleep` 函数来完成我们的导入。
- en: 'Next, we define a `BuzzerMelody` class: Initializer (`__init__()`) accepts
    a pin and a list of notes with their durations. The list has a default melody.
    Within the initializer, we do the following:'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个 `BuzzerMelody` 类：初始化器 (`__init__`) 接受一个引脚和一个包含音符及其时长的列表。列表有一个默认旋律。在初始化器中，我们执行以下操作：
- en: Initialize a `TonalBuzzer` object with the provided pin
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用提供的引脚初始化一个 `TonalBuzzer` 对象
- en: Set the melody
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置旋律
- en: 'Then, we define the `play_melody()` method. In this method, we do the following:'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义 `play_melody()` 方法。在这个方法中，我们执行以下操作：
- en: Iterate through the melody notes
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 遍历旋律音符
- en: Play each note for its specified duration
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按指定时长播放每个音符
- en: Ensure the buzzer stops after the notes are played
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保音符播放后蜂鸣器停止
- en: Add a brief pause between notes
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在音符之间添加短暂的暂停
- en: 'If the script is executed as the main program, we do the following:'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果脚本作为主程序执行，我们执行以下操作：
- en: Create an instance of the `BuzzerMelody` class with pin 4
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用引脚 4 创建 `BuzzerMelody` 类的实例
- en: Play the melody using the `play_melody()` method
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `play_melody()` 方法播放旋律
- en: We run the code in Thonny by clicking on the green run button, hitting *F5*
    on your keyboard, or clicking on the **Run** menu option at the top and then **Run**
    **current script**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过点击 Thonny 中的绿色运行按钮，按键盘上的 *F5*，或在顶部菜单中选择 **运行** 然后选择 **运行当前脚本** 来运行代码。
- en: We should hear a melody play from our buzzer.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该会听到蜂鸣器播放旋律。
- en: With our buzzer code in place, it’s time to write our main dashboard code using
    Kivy.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的蜂鸣器代码就绪后，是时候使用 Kivy 编写我们的主仪表盘代码了。
- en: Creating our Kivy dashboard
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建我们的 Kivy 仪表盘
- en: As mentioned previously, we will be using the Raspberry Pi 5’s 7-inch touchscreen
    to display our dashboard. The use of this screen is optional as we may use a standard
    monitor with our Raspberry Pi.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用 Raspberry Pi 5 的 7 英寸触摸屏来显示我们的仪表盘。使用此屏幕是可选的，因为我们可能使用标准显示器与 Raspberry
    Pi 一起使用。
- en: 'To write and test our Kivy dashboard code, follow these steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写和测试我们的 Kivy 仪表盘代码，请按照以下步骤操作：
- en: Launch Thonny by clicking on the **Menu** icon in the Raspberry Pi taskbar,
    navigating to the **Programming** category, and selecting **Thonny**.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 Raspberry Pi 任务栏中的 **菜单** 图标，导航到 **编程** 类别，然后选择 **Thonny** 来启动 Thonny。
- en: We then activate the `dashboard-env` Python virtual environment.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们激活 `dashboard-env` Python 虚拟环境。
- en: Once inside Thonny, create a new tab by selecting **File** and then **New**
    or by hitting *Ctrl* + *N* on your keyboard.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦在 Thonny 中，通过选择 **文件** 然后选择 **新建** 或按键盘上的 *Ctrl* + *N* 创建一个新标签。
- en: 'We will start our code with the necessary imports:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用必要的导入开始我们的代码：
- en: '[PRE8]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let’s examine this code:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查这段代码：
- en: '`kivy.config`: Our code imports the configuration settings from Kivy to tailor
    the application’s behavior.'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy.config`：我们的代码从 Kivy 导入配置设置，以调整应用程序的行为。'
- en: '`fullscreen`: We configure the application to run in fullscreen mode.'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fullscreen`：我们配置应用程序以全屏模式运行。'
- en: '`borderless`: Our settings eliminate the window border.'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`borderless`：我们的设置消除了窗口边框。'
- en: '`kivy.app`: Our code accesses the primary application class from Kivy that’s
    used for initializing and operating Kivy apps.'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy.app`：我们的代码访问 Kivy 的主要应用程序类，用于初始化和操作 Kivy 应用程序。'
- en: '`kivy.uix.floatlayout`: We import `FloatLayout`, a flexible layout mechanism
    that places widgets based on relative coordinates.'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy.uix.floatlayout`：我们导入 `FloatLayout`，这是一种灵活的布局机制，根据相对坐标放置小部件。'
- en: '`kivy.uix.label`: Our code uses the `Label` widget, letting us display text
    within the application.'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy.uix.label`：我们的代码使用 `Label` 小部件，允许我们在应用程序中显示文本。'
- en: '`kivy.uix.button`: We integrate the `Button` widget so that it can be used
    with our keypad.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy.uix.button`：我们整合了 `Button` 小部件，以便它可以与我们的键盘一起使用。'
- en: '`kivy.clock`: We utilize the `Clock` class to schedule specific functions to
    run at timed intervals.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy.clock`：我们利用 `Clock` 类来安排在定时间隔运行特定函数。'
- en: '`Threading`: To ensure smooth multitasking, our code uses threading for parallel
    operations. We use threading to run the `start_mqtt()` method in a separate thread.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Threading`：为了确保平滑的多任务处理，我们的代码使用线程进行并行操作。我们使用线程在单独的线程上运行`start_mqtt()`方法。'
- en: '`paho.mqtt.client`: We use the MQTT client library in our code to communicate
    with our MQTT server.'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paho.mqtt.client`：我们在代码中使用MQTT客户端库与我们的MQTT服务器进行通信。'
- en: '`kivy_garden.mapview`: Our code pulls in classes for presenting maps (`MapView`)
    and interactive map markers (`MapMarkerPopup`). We use these classes to visually
    represent the exact location on the map where the alarm has been triggered.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kivy_garden.mapview`：我们的代码引入了用于展示地图（`MapView`）和交互式地图标记（`MapMarkerPopup`）的类。我们使用这些类在地图上直观地表示警报被触发的确切位置。'
- en: '`buzzer.BuzzerMelody`: We import the `BuzzerMelody` class so that we can activate
    the external buzzer.'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`buzzer.BuzzerMelody`：我们导入`BuzzerMelody`类，以便我们可以激活外部蜂鸣器。'
- en: 'Then, set the variable declarations for our code:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，为我们的代码设置变量声明：
- en: '[PRE9]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'From here, we must define the `AlarmDashboard` class, which inherits from the
    `FloatLayout` class, and define the initialization method:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从这里，我们必须定义继承自`FloatLayout`类的`AlarmDashboard`类，并定义初始化方法：
- en: '[PRE10]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let’s examine this code:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查这段代码：
- en: First, we initialize specific attributes, such as the default password (`password_toggle`),
    the currently entered password (`entered_password`), a system status flag (`system_armed`),
    a lockout status (`lockout`), and the last received message (`last_message`).
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们初始化特定的属性，例如默认密码（`password_toggle`）、当前输入的密码（`entered_password`）、系统状态标志（`system_armed`）、锁定状态（`lockout`）和最后接收到的消息（`last_message`）。
- en: Then, we set up an MQTT client with a unique `client_id` and provide it with
    the necessary authentication details using the `username_pw_set` method.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们设置一个具有唯一`client_id`的MQTT客户端，并使用`username_pw_set`方法提供必要的认证细节。
- en: The `on_message` attribute of the client is set to a method named `on_message()`,
    which our code will use to handle incoming MQTT messages.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端的`on_message`属性被设置为名为`on_message()`的方法，我们的代码将使用该方法来处理传入的MQTT消息。
- en: We start the MQTT connection on a separate thread using the `start_mqtt` method
    to avoid blocking the main application.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`start_mqtt`方法在单独的线程上启动MQTT连接，以避免阻塞主应用程序。
- en: The `init_widgets` method, which we’ll define later, is called to initialize
    and arrange the user interface elements.
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在后面定义的`init_widgets`方法被调用以初始化和排列用户界面元素。
- en: Lastly, we initialize the `buzzer` attribute with an instance of the `BuzzerMelody`
    class, setting it up on GPIO pin 4.
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`BuzzerMelody`类的实例初始化`buzzer`属性，并将其设置在GPIO引脚4上。
- en: 'Now, use the `on_message()` method to handle messages coming from our MQTT
    server:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`on_message()`方法来处理来自我们的MQTT服务器的消息：
- en: '[PRE11]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s examine this code:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查这段代码：
- en: Upon receiving a message, our code decodes the message payload from bytes to
    a string
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接收到消息后，我们的代码将解码消息有效载荷，从字节转换为字符串
- en: The most recent message is stored with the `Last` `message:` prefix
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最新的消息存储时带有`Last` `message:`前缀
- en: If the received message starts with `location:`, it extracts latitude and longitude
    values
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接收到的消息以`location:`开头，它将提取纬度和经度值
- en: These values are then used to update the displayed map, scheduling the `update_map()`
    method
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些值随后用于更新显示的地图，并安排调用`update_map()`方法
- en: If the message that’s received is `arm`, the system’s status is updated to `armed`
    via the `update_system_status()` method
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接收到的消息是`arm`，系统状态将通过`update_system_status()`方法更新为`armed`
- en: If the message that’s received is `disarm`, the system’s status is updated to
    `disarmed` via the `update_system_status()` method
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接收到的消息是`disarm`，系统状态将通过`update_system_status()`方法更新为`disarmed`。
- en: If the message that’s received is `buzzer`, a melody is played through the `buzzer`
    instance via the `play_melody()` method
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果接收到的消息是`buzzer`，将通过`buzzer`实例的`play_melody()`方法播放旋律
- en: Regardless of the message’s content, the message that’s displayed is updated
    using the `update_message_display()` method
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 无论消息内容如何，都会使用`update_message_display()`方法更新显示的消息
- en: Using the lambda() function in our code
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码中使用lambda()函数
- en: The `lambda()` function is used as an anonymous, inline function in Python.
    It’s typically used for brief operations that are expressed in a single statement.
    Specifically, in our code, the `lambda()` function pairs with Kivy’s `Clock.schedule_once()`
    method to delay certain method executions. By using the `Clock.schedule_once()`
    method, a function can be scheduled to run after a specified delay. When `0` is
    given as its second argument, it indicates the function should be called immediately
    on the next frame.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，`lambda()` 函数用作匿名内联函数。它通常用于表达为单个语句的简短操作。具体来说，在我们的代码中，`lambda()` 函数与
    Kivy 的 `Clock.schedule_once()` 方法配对，以延迟某些方法的执行。通过使用 `Clock.schedule_once()` 方法，可以安排一个函数在指定延迟后运行。当第二个参数为
    `0` 时，表示函数应在下一个帧上立即调用。
- en: 'Each instance of the `lambda()` function in our code follows the `lambda dt:
    some_method(arguments)` pattern. Here, `dt` represents the time that’s elapsed
    since the last frame. It’s an argument that `Clock.schedule_once()` automatically
    provides. For example, `Clock.schedule_once(lambda dt: self.update_map(lat, lon),
    0)` schedules the `self.update_map(lat, lon)` method for execution on the upcoming
    frame, with the already parsed `lat` and `lon` values as its arguments. Essentially,
    these `lambda()` functions act as a conduit, passing arguments to methods and
    setting them up for execution on the next frame via Kivy’s scheduling mechanism.
    Utilizing the `Clock()` function ensures that our UI updates remain smooth and
    synchronized with the display’s refresh rate, and also prevents blocking of the
    main thread, thus enhancing the responsiveness of the application.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '我们代码中的每个 `lambda()` 函数都遵循 `lambda dt: some_method(arguments)` 模式。在这里，`dt` 代表自上一帧以来经过的时间。它是
    `Clock.schedule_once()` 自动提供的参数。例如，`Clock.schedule_once(lambda dt: self.update_map(lat,
    lon), 0)` 将 `self.update_map(lat, lon)` 方法安排在即将到来的帧上执行，并使用已解析的 `lat` 和 `lon` 值作为其参数。本质上，这些
    `lambda()` 函数充当一个通道，将参数传递给方法，并通过 Kivy 的调度机制在下一帧上设置它们以执行。利用 `Clock()` 函数确保我们的 UI
    更新保持平滑并与显示的刷新率同步，同时也防止了主线程的阻塞，从而提高了应用程序的响应性。'
- en: 'Our code defines a method called `update_map()`, whose purpose is to update
    the displayed map in two main ways:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码定义了一个名为 `update_map()` 的方法，其主要目的是以两种主要方式更新显示的地图：
- en: '[PRE12]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let’s examine this code:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码：
- en: Our code adjusts the center of the map to the new latitude and longitude coordinates,
    which are provided as arguments (`lat` and `lon`).
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码将地图的中心调整到新的纬度和经度坐标，这些坐标作为参数（`lat` 和 `lon`）提供。
- en: Then, it places a marker (specifically an interactive marker that can show a
    popup) on the map at the specified coordinates. This marker indicates the exact
    location of the IoT alarm module that triggered the alarm.
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它在地图上指定的坐标处放置一个标记（具体来说是一个可以显示弹出窗口的交互式标记）。这个标记指示触发警报的物联网警报模块的确切位置。
- en: 'The `update_system_status()` method updates the status message on our dashboard
    based on the value of `is_armed`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update_system_status()` 方法根据 `is_armed` 的值更新我们的仪表板上的状态消息：'
- en: '[PRE13]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, our code defines a method named `start_mqtt()` that sets up and initiates
    the MQTT communication for the application:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们的代码定义了一个名为 `start_mqtt()` 的方法，用于设置和初始化应用程序的 MQTT 通信：
- en: '[PRE14]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let’s examine this code:'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们来看看这段代码：
- en: The method connects the MQTT client to the specified MQTT server using the given
    server address (`MQTT_SERVER`) and port number (`MQTT_PORT`).
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该方法使用给定的服务器地址 (`MQTT_SERVER`) 和端口号 (`MQTT_PORT`) 将 MQTT 客户端连接到指定的 MQTT 服务器。
- en: Once connected, the client subscribes to a specific topic (`TOPIC`), meaning
    it will start listening for messages that are published on that topic.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接，客户端会订阅一个特定的主题 (`TOPIC`)，这意味着它将开始监听在该主题上发布的消息。
- en: Finally, the `loop_forever()` method of the client is called, which keeps the
    MQTT client continuously checking for incoming messages and handling them for
    as long as the application runs.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，调用客户端的 `loop_forever()` 方法，该方法使 MQTT 客户端持续不断地检查传入的消息，并在应用程序运行期间处理这些消息。
- en: 'Our code defines a method named `init_widgets()` for initializing and placing
    various user interface components on our dashboard. We will start with the **keypad**
    **initialization** process:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们的代码定义了一个名为 `init_widgets()` 的方法，用于初始化并在我们的仪表板上放置各种用户界面组件。我们将从**键盘**初始化过程开始：
- en: '[PRE15]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, a keypad layout is set up with buttons arranged in a 3x3 grid. The positions
    of these buttons are specified using the `positions` list, where each tuple represents
    the relative `x` and `y` coordinates. As we loop through these positions, we create
    a button with a corresponding number and bind its `on_press` event to the `handle_key_press()`
    method, which will capture the button press actions. Each button, once initialized,
    is added to the dashboard using the `add_widget()` method.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，设置了一个按键布局，按钮以 3x3 网格排列。这些按钮的位置使用 `positions` 列表指定，其中每个元组代表相对的 `x` 和 `y`
    坐标。当我们遍历这些位置时，我们创建一个带有相应数字的按钮，并将其 `on_press` 事件绑定到 `handle_key_press()` 方法，该方法将捕获按钮按下动作。每个按钮一旦初始化，就使用
    `add_widget()` 方法添加到仪表板中。
- en: 'Now, write the code for the **system** **status label**:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写 **系统状态标签** 的代码：
- en: '[PRE16]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This label displays the status of the system, indicating whether it is armed
    or disarmed. It’s styled with a specific text size, color, and positioning. Once
    initialized, the label is added to the dashboard.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个标签显示系统的状态，指示它是处于警戒状态还是解除警戒状态。它使用特定的文本大小、颜色和定位进行样式设置。一旦初始化，该标签就被添加到仪表板中。
- en: 'Next, set up a label for the **MQTT** **message display**:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置一个用于 **MQTT 消息显示** 的标签：
- en: '[PRE17]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, a label has been set up to display incoming MQTT messages. It has a default
    text of `Waiting for message...` and is styled similarly to the system status
    label. Once it’s been created, it’s added to the dashboard.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，已经设置了一个标签来显示传入的 MQTT 消息。它有一个默认文本 `Waiting for message...`，并且与系统状态标签的样式相似。一旦创建，它就被添加到仪表板中。
- en: 'Finally, add a **MapView widget**:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个 **MapView 小部件**：
- en: '[PRE18]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we initialize a `MapView` widget to display geographical locations. It’s
    preset to a specific zoom level and initial latitude and longitude coordinates.
    This map view allows us to visualize locations on a map. Once initialized, it’s
    added to our dashboard.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们初始化一个 `MapView` 小部件来显示地理位置。它预设了特定的缩放级别和初始纬度和经度坐标。这个地图视图允许我们在地图上可视化位置。一旦初始化，它就被添加到我们的仪表板中。
- en: 'The `update_message_display()` method is used to refresh or update the text
    that’s displayed in the `message_display` widget to show the latest message that’s
    been received by the system:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`update_message_display()` 方法用于刷新或更新 `message_display` 小部件中显示的文本，以显示系统接收到的最新消息：'
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `handle_key_press()` method manages the user’s interactions with the virtual
    keypad when inputting the alarm system’s passcode, determines the validity of
    the entered code, and adjusts the alarm system’s status based on the passcode
    input:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`handle_key_press()` 方法管理用户在输入警报系统密码时与虚拟键盘的交互，确定输入代码的有效性，并根据密码输入调整警报系统的状态：'
- en: '[PRE20]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s examine this code:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查这段代码：
- en: '`self.entered_password` string, representing the user’s current passcode input.'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`self.entered_password` 字符串，表示用户当前输入的密码。'
- en: '`handle_key_press()` method verifies if it matches the predefined alarm system
    code. If the code is correct, the following occurs:'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`handle_key_press()` 方法验证它是否与预定义的警报系统代码匹配。如果代码正确，以下操作会发生：'
- en: The alarm system’s status toggles between `armed` and `disarmed`.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 警报系统的状态在 `armed` 和 `disarmed` 之间切换。
- en: A corresponding message (`arm` or `disarm`) is sent to the `IoTAlarm` topic.
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `IoTAlarm` 主题发送相应的消息（`arm` 或 `disarm`）。
- en: '`lockout` mode:'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lockout` 模式：'
- en: A timer is initiated to end the lockout state after a specified duration (5
    seconds in this case).
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个计时器，在指定的时间（本例中为 5 秒）后结束锁定状态。
- en: The code that was entered is reset in anticipation of another attempt.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入的代码已重置，以备再次尝试。
- en: 'The `end_lockout()` function is designed to terminate the lockout state of
    the system. Setting the `lockout` attribute to `False` ensures that subsequent
    operations or interactions that were restricted during the lockout are now permitted:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`end_lockout()` 函数旨在终止系统的锁定状态。将 `lockout` 属性设置为 `False` 确保在锁定期间被限制的操作或交互现在被允许：'
- en: '[PRE21]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At this point, our code introduces the main application class, `MyApp`, which
    is built upon Kivy’s App framework. Inside this class, the `build()` method constructs
    and returns an instance of `AlarmDashboard`. If we run this code directly (not
    imported into another script), the `if __name__ == ''__main__'':` check ensures
    that a new `MyApp` instance is created and launched, initiating the entire alarm
    application:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，我们的代码引入了主应用程序类 `MyApp`，该类基于 Kivy 的 App 框架构建。在这个类中，`build()` 方法构建并返回一个
    `AlarmDashboard` 实例。如果我们直接运行此代码（未导入到另一个脚本中），则 `if __name__ == '__main__':` 检查确保创建并启动一个新的
    `MyApp` 实例，从而启动整个警报应用程序：
- en: '[PRE22]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save our code as `dashboard.py` in the project folder.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们的代码保存为`dashboard.py`在项目文件夹中。
- en: With our dashboard code written and our buzzer tested, it is time to build the
    custom stand for our buzzer. As always, this is optional; we may run our application
    without encasing the buzzer into a stand. However, doing so makes our application
    more professional-looking, enhances user experience, and offers a more polished
    presentation, ensuring that the buzzer is positioned securely and easily accessible
    when needed.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了仪表板代码并测试了蜂鸣器后，是时候为我们的蜂鸣器构建定制支架了。像往常一样，这是可选的；我们可以在不将蜂鸣器封装到支架中的情况下运行我们的应用程序。然而，这样做可以使我们的应用程序看起来更专业，增强用户体验，并提供更精致的展示，确保蜂鸣器在需要时可以安全且易于访问。
- en: Building the external alarm buzzer stand
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建外部报警蜂鸣器支架
- en: Encasing our buzzer in a custom stand enhances our IoT alarm dashboard. In this
    section, we will build the stand. We will start by identifying the parts that
    make up our custom buzzer stand before we assemble it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的蜂鸣器封装在定制支架中增强了我们的物联网报警仪表板。在本节中，我们将构建支架。在我们组装之前，我们将首先识别组成定制蜂鸣器支架的部件。
- en: Identifying the parts
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别部件
- en: The parts that make up the custom buzzer stand can be made with either a 3D
    printer or a 3D printing service such as Shapeways ([https://www.shapeways.com](https://www.shapeways.com)).
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 组成定制蜂鸣器支架的部件可以使用3D打印机或3D打印服务（如Shapeways [https://www.shapeways.com](https://www.shapeways.com)）制作。
- en: 'These parts are shown in *Figure 8**.11*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部件在*图8**.11中显示：
- en: '*A*: This is a 3D-printed version of the `Stand.stl` file, which is located
    in the `Build Files/Buzzer Stand` folder of this chapter’s GitHub repository.
    This version of the file was 3D printed using a liquid resin 3D printer and was
    subsequently painted. For those of us who prefer to use an FDM printer, the split
    stand located under `Build Files/Split Stand` would be a better option:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A*：这是位于本章GitHub仓库`Build Files/Buzzer Stand`文件夹中的`Stand.stl`文件的3D打印版本。这个版本的文件是用液体树脂3D打印机打印的，随后进行了喷漆。对于那些更喜欢使用FDM打印机的人来说，位于`Build
    Files/Split Stand`下的分体支架将是一个更好的选择：'
- en: '![Figure 8.11 – Parts of the custom buzzer stand](img/B21282_08_11.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11 – 定制蜂鸣器支架的部件](img/B21282_08_11.jpg)'
- en: Figure 8.11 – Parts of the custom buzzer stand
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 定制蜂鸣器支架的部件
- en: '*B*: This is our standard hook. It’s a liquid resin 3D-printed version of the
    `Hook.stl` file, which is located in the `Build Files` folder of this chapter’s
    GitHub repository.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*B*：这是我们标准的钩子。它是由液体树脂3D打印的`Hook.stl`文件版本，该文件位于本章GitHub仓库的`Build Files`文件夹中。'
- en: '*C*: This is the standard SFM-127 active buzzer that this stand was designed
    to hold.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C*：这是为该支架设计的标准SFM-127主动蜂鸣器。'
- en: '*D*: This is a painted FDM 3D-printed version of the `Front.stl` file, which
    is also located in the `Build` `Files` folder.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D*：这是涂漆的FDM 3D打印的`Front.stl`文件版本，它也位于`Build` `Files`文件夹中。'
- en: '*E*: An FDM 3D printer was used to create a version of the `Back.stl` file.
    This part connects the front (*D*) to the stand (*A*) using the hook (*B*).'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*E*：使用FDM 3D打印机创建了一个`Back.stl`文件的版本。该部件通过钩子(*B*)将前面(*D*)与支架(*A*)连接起来。'
- en: 'Not shown: A multi-conductor cable such as a discarded USB cable.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：一根多芯电缆，如废弃的USB电缆。
- en: 'Not shown: 2x M4 20mm bolts.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：2个M4 20mm螺栓。
- en: 'Not shown: 2x M3 10mm bolts.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：2个M3 10mm螺栓。
- en: 'Not shown: 2x M2 5mm bolts.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：2个M2 5mm螺栓。
- en: 'Not shown: 1x M5 20mm bolt.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：1个M5 20mm螺栓。
- en: 'Not shown: 1x M5 nut.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：1个M5螺母。
- en: 'Not shown: 2x female jumper terminals for connecting the buzzer to the GPIO
    port.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未显示：2个用于将蜂鸣器连接到GPIO端口的雌性跳线端子。
- en: Which type of 3D printer should be used to create the parts?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 应使用哪种类型的3D打印机来创建部件？
- en: In *Figure 8**.9*, parts were created using both FDM and liquid resin 3D printers.
    The choice of printer depends on the user’s experience and the part’s design.
    Flat parts, such as *E* and *D* in *Figure 8**.10*, are ideal for FDM printers.
    Ornamental designs, such as part *A*, benefit from liquid resin printers. While
    hook (*B*) can use either method, we chose a liquid resin printer with an engineering-grade
    resin (Siraya Tech Blu) for added strength.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8**.9中，使用了FDM和液体树脂3D打印机创建了部件。打印机的选择取决于用户的经验和部件的设计。如图8**.10中的*E*和*D*所示的平面部件，适用于FDM打印机。如图8**.10中的部件*A*所示的装饰性设计，则更适合液体树脂打印机。虽然钩子(*B*)可以使用任何一种方法，但我们选择了一种使用工程级树脂（Siraya
    Tech Blu）的液体树脂打印机，以增加强度。
- en: With our parts identified, it is time to build our custom buzzer stand.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定了部件后，是时候构建我们的定制蜂鸣器支架了。
- en: Building the stand
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建支架
- en: 'To build the custom buzzer stand, we must follow the steps shown in *Figure
    8**.12*:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建定制的蜂鸣器支架，我们必须遵循 *图 8**.12* 中所示的步骤：
- en: '![Figure 8.12 – Steps to build the custom buzzer stand](img/B21282_08_12.jpg)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 构建定制蜂鸣器支架的步骤](img/B21282_08_12.jpg)'
- en: Figure 8.12 – Steps to build the custom buzzer stand
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 构建定制蜂鸣器支架的步骤
- en: 'Let’s take a closer look:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细看看：
- en: Using two M4 10mm bolts, secure the buzzer (see *C* in *Figure 8**.11*) to the
    front casing (see *D* in *Figure 8**.11*). The bolts should screw tightly into
    the buzzer. If they’re loose, we may tighten them with two M4 nuts.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个 M4 10mm 螺栓，将蜂鸣器（见 *C* 在 *图 8**.11* 中）固定到前壳上（见 *D* 在 *图 8**.11* 中）。螺栓应紧紧拧入蜂鸣器。如果它们松动，我们可以用两个
    M4 螺母拧紧。
- en: Using a multi-conductor cable, such as a discarded USB cable, solder two wires
    to the buzzer (see *C* in *Figure 8**.11*).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多芯电缆，例如废弃的 USB 电缆，将两根线焊接到蜂鸣器上（见 *C* 在 *图 8**.11* 中）。
- en: Thread the multi-conductor cable through the hole on the front casing (see *D*
    in *Figure 8**.11*) and apply glue via a hot glue gun to secure the cable to the
    casing.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将多芯电缆穿过前壳上的孔（见 *D* 在 *图 8**.11* 中），并通过热胶枪涂抹胶水，将电缆固定到壳体上。
- en: Using the same two wires (red and black, in our example) of the multi-conductor
    cable, crimp two female jumper terminals to the ends of the wire. An option here
    is to solder pre-existing jumper cables to the end instead of crimping.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多芯电缆（在我们的例子中是红色和黑色）的两根相同电线，将两个母跳线端子压接到线的末端。另一种选择是将预先存在的跳线电缆焊接到末端而不是压接。
- en: Then, secure the hook (see *B* in *Figure 8**.11*) to the back plate (see *E*
    in *Figure 8**.11*) by either using two M2 5mm screws or epoxy glue.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过使用两个 M2 5mm 螺丝或环氧树脂胶水，将钩子（见 *B* 在 *图 8**.11* 中）固定到背板上（见 *E* 在 *图 8**.11*
    中）。
- en: Using two M3 10mm bolts, secure the back plate (see *E* in *Figure 8**.11*)
    to the front casing (see *D* in *Figure 8**.11*).
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个 M3 10mm 螺栓，将背板（见 *E* 在 *图 8**.11* 中）固定到前壳（见 *D* 在 *图 8**.11* 中）。
- en: Using an M5 20mm bolt and M5 nut, secure the assembled casing to the stand (see
    *A* in *Figure 8**.11*).
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 M5 20mm 螺栓和 M5 螺母，将组装好的壳体固定到支架上（见 *A* 在 *图 8**.11* 中）。
- en: With the custom stand built, we may re-connect our buzzer to the GPIO port of
    the Raspberry Pi 5 by following the wiring diagram shown in *Figure 8**.10*.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建好定制支架后，我们可以按照 *图 8**.10* 中所示的接线图，将我们的蜂鸣器重新连接到 Raspberry Pi 5 的 GPIO 端口。
- en: We are now ready to test our application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已准备好测试我们的应用程序。
- en: Running our application
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的应用程序
- en: 'It’s now time for the moment we have been building toward over the last few
    chapters: testing our entire IoT alarm system. With the IoT alarm dashboard built,
    our IoT alarm system is complete:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是我们一直在过去几章中构建的时刻：测试我们的整个物联网报警系统。在构建好物联网报警仪表板后，我们的物联网报警系统就完成了：
- en: '![Figure 8.13 – Completed IoT alarm system](img/B21282_08_13.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 完成的物联网报警系统](img/B21282_08_13.jpg)'
- en: Figure 8.13 – Completed IoT alarm system
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 完成的物联网报警系统
- en: We started by building the IoT alarm module (see *E* in *Figure 8**.13*) in
    [*Chapter 6*](B21282_06.xhtml#_idTextAnchor091), before proceeding to build IoT
    buttons (see *A* and *D* in *Figure 8**.13*) in [*Chapter 7*](B21282_07.xhtml#_idTextAnchor107).
    In this chapter, we used the Raspberry Pi 5 with an active buzzer (see *B* and
    *C* in *Figure 8**.13*), a Raspberry Pi 7-inch screen and case (see *B* in *Figure
    8**.13*), a keyboard (see *F* in *Figure 8**.13*), and a mouse (see *G* in *Figure
    8**.13*) to build the IoT alarm dashboard.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 [*第 6 章*](B21282_06.xhtml#_idTextAnchor091) 中构建了物联网报警模块（见 *E* 在 *图 8**.13*
    中），然后继续在 [*第 7 章*](B21282_07.xhtml#_idTextAnchor107) 中构建物联网按钮（见 *A* 和 *D* 在 *图
    8**.13* 中）。在本章中，我们使用了带有活动蜂鸣器（见 *B* 和 *C* 在 *图 8**.13* 中）的 Raspberry Pi 5、7 英寸屏幕和外壳（见
    *B* 在 *图 8**.13* 中）、键盘（见 *F* 在 *图 8**.13* 中）和鼠标（见 *G* 在 *图 8**.13* 中）来构建物联网报警仪表板。
- en: 'To test the IoT alarm dashboard, we simply need to arm the IoT alarm module
    and activate it by moving an object in front of its PIR sensor. To do so, follow
    these steps:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试物联网报警仪表板，我们只需启动物联网报警模块，并通过在其 PIR 传感器前移动物体来激活它。为此，请按照以下步骤操作：
- en: To arm the IoT alarm module, using our mouse, we type the four-digit PIN code
    (1234) into the keypad of the IoT alarm dashboard.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启动物联网报警模块，使用我们的鼠标，将四位 PIN 码（1234）输入到物联网报警仪表板的键盘上。
- en: We should observe that the IoT alarm module goes into armed mode by the long
    blinking of the LED. To activate the alarm, we wave our hands in front of the
    PIR sensor.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该注意到，物联网报警模块通过 LED 的长闪烁进入警戒模式。要激活报警，我们在 PIR 传感器前挥动手臂。
- en: After a few seconds, we should hear the buzzer on the IoT alarm module, followed
    by the buzzers on the IoT button (version 2) and the IoT alarm dashboard.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟后，我们应该听到物联网警报模块上的蜂鸣器声音，接着是物联网按钮（版本2）和物联网警报仪表板上的蜂鸣器。
- en: 'We should also observer that a map of Toronto with a marker at the CN Tower
    should be displayed on the screen of the IoT alarm dashboard:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该注意到，在物联网警报仪表板的屏幕上应该显示一个带有CN塔标记的多伦多地图：
- en: '![Figure 8.14 – IoT alarm dashboard showing the location where the alarm was
    activated](img/B21282_08_14.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 显示警报激活位置的物联网警报仪表板](img/B21282_08_14.jpg)'
- en: Figure 8.14 – IoT alarm dashboard showing the location where the alarm was activated
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 显示警报激活位置的物联网警报仪表板
- en: Having successfully tested the IoT alarm system, we’ve concluded the second
    part of this book. Throughout this journey, we’ve explored internet-based device
    communication and harnessed the capabilities of the Raspberry Pi Pico W microcontroller
    and Raspberry Pi 5 computer. This foundation will be invaluable for the advanced
    projects in this book.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功测试了物联网警报系统之后，我们完成了本书的第二部分。在整个这一过程中，我们探索了基于互联网的设备通信，并利用了Raspberry Pi Pico
    W微控制器和Raspberry Pi 5计算机的能力。这个基础对于本书中的高级项目将非常有价值。
- en: If we really want a challenge, we could position each component of the IoT alarm
    system as far apart as possible, perhaps by giving a component to a friend in
    another city. Doing such an activity will help us appreciate not only IoT but
    our internet-connected world in general.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想接受挑战，我们可以尽可能地将物联网警报系统的每个组件放置得远一些，也许可以通过将一个组件给另一个城市的友人来实现。进行这样的活动将帮助我们不仅欣赏物联网，而且总体上欣赏我们的互联网连接的世界。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we completed our IoT alarm system by building an IoT alarm
    dashboard. We began by understanding IoT alarm dashboards and their usage by considering
    an example of the level and temperature of a tank. Throughout this chapter, we
    went through the step-by-step process of setting up, coding, and testing our IoT
    alarm dashboard, including adding a custom stand for an external buzzer.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过构建物联网警报仪表板完成了我们的物联网警报系统。我们首先通过考虑一个油罐的液位和温度的例子来理解物联网警报仪表板及其用法。在本章中，我们逐步介绍了设置、编码和测试我们的物联网警报仪表板的过程，包括添加一个外部蜂鸣器的定制支架。
- en: We constructed a dashboard for our IoT alarm system using Kivy on the Raspberry
    Pi 5\. The dashboard integrated map functionality to pinpoint the location of
    any activated IoT alarm module.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Kivy在Raspberry Pi 5上构建了我们的物联网警报系统仪表板。该仪表板集成了地图功能，以确定任何激活的物联网警报模块的位置。
- en: 'As we close this section on the IoT alarm system, we look forward to the next
    exciting challenge: building a remote monitoring station using LoRa. This next
    section will introduce us to long-range communication, broadening our understanding
    and capabilities in IoT projects.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束对物联网警报系统的讨论时，我们期待着下一个令人兴奋的挑战：使用LoRa构建一个远程监控站。下一节将介绍我们关于长距离通信的知识，这将拓宽我们在物联网项目中的理解和能力。
- en: 'Part 3: Creating a LoRa-Enabled IoT Monitoring Station'
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：创建一个LoRa支持的物联网监控站
- en: In this part, we will create a remote environmental monitoring station, using
    LoRa to collect and transmit data on temperature and humidity and transmit it
    over the internet. We will use this data to control an analog weather indicator.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将创建一个远程环境监控站，使用LoRa收集和传输温度和湿度数据，并通过互联网传输。我们将使用这些数据来控制一个模拟的天气指示器。
- en: 'This part has the following chapters:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 9*](B21282_09.xhtml#_idTextAnchor140), *Understanding LoRa*'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B21282_09.xhtml#_idTextAnchor140)，*理解LoRa*'
- en: '[*Chapter 10*](B21282_10.xhtml#_idTextAnchor157), *Integrating LoRa with the
    Internet*'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B21282_10.xhtml#_idTextAnchor157)，*将LoRa与互联网集成*'
