- en: <st c="0">7</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">7</st>
- en: <st c="2">Using Non-Relational Data Storage</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用非关系型数据存储</st>
- en: <st c="35">Most applications that use voluminous or big data, and continuously
    increase every user transaction, do not use relational databases for storage.</st>
    <st c="182">Applications such as scientific information management systems, sales-related
    applications, stocks and investment-related software, and location finders are
    some applications that may utilize data from various types of data structures,
    such as objects, lists, dictionaries, and bytes.</st> <st c="467">This data can
    be structured (for example, Excel-formatted medical records and CSV-formatted
    location data), semi-structured (for example, XML data of sales inventory and
    emails), and non-structured (for example, images, videos, social media postings,
    and Word documents).</st> <st c="739">Relational databases do not have the support
    to manage this data, but</st> **<st c="809">NoSQL</st>** <st c="814">databases
    do.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35">大多数使用大量或大数据，并且用户交易持续增加的应用程序，不使用关系型数据库进行存储。</st> <st c="182">例如，科学信息管理系统、与销售相关的应用程序、股票和投资相关软件以及位置查找器等应用程序可能会利用来自各种类型的数据结构（如对象、列表、字典和字节）的数据。</st>
    <st c="467">这些数据可以是结构化的（例如，Excel格式的医疗记录和CSV格式的位置数据），半结构化的（例如，销售库存的XML数据和电子邮件），以及非结构化的（例如，图像、视频、社交媒体帖子以及Word文档）。</st>
    <st c="739">关系型数据库没有支持管理此类数据，但</st> **<st c="809">NoSQL</st>** <st c="814">数据库可以。</st>
- en: <st c="828">NoSQL, which stands for</st> **<st c="853">Not Only SQL</st>**<st
    c="865">, is a schemaless form</st> <st c="887">of data storage that has no concepts
    of rows and columns to hold records of information.</st> <st c="977">Like any
    framework, Flask, when used to build big data applications, can support access
    to these non-relational databases to manage data for data mining, modeling, analytics,
    and</st> <st c="1156">graphical projections.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="828">NoSQL，代表</st> **<st c="853">不仅限于SQL</st>**<st c="865">，是一种无模式的存储形式，没有行和列的概念来存储信息记录。</st>
    <st c="977">像任何框架一样，Flask，当用于构建大数据应用程序时，可以支持访问这些非关系型数据库，以管理数据用于数据挖掘、建模、分析和</st>
    <st c="1156">图形投影。</st>
- en: <st c="1178">The main goal of this chapter is to showcase how to install and
    configure the different NoSQL databases and how a Flask application can connect
    to these databases and perform</st> **<st c="1354">INSERT</st>**<st c="1360">,</st>
    **<st c="1362">UPDATE</st>**<st c="1368">,</st> **<st c="1370">DELETE</st>**<st
    c="1376">, and</st> **<st c="1382">QUERY</st>** <st c="1387">transactions.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1178">本章的主要目标是展示如何安装和配置不同的NoSQL数据库，以及Flask应用程序如何连接到这些数据库并执行</st> **<st
    c="1354">INSERT</st>**<st c="1360">,</st> **<st c="1362">UPDATE</st>**<st c="1368">,</st>
    **<st c="1370">DELETE</st>**<st c="1376">, 和</st> **<st c="1382">QUERY</st>**
    <st c="1387">事务。</st>
- en: <st c="1401">This chapter will cover the following topics – this will provide
    you with an initial step toward building big data applications</st> <st c="1530">with
    Flask:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1401">本章将涵盖以下主题——这将为您构建大数据应用程序</st> <st c="1530">使用Flask</st>：
- en: <st c="1541">Managing non-relational data using</st> <st c="1577">Apache HBase</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1541">使用Apache HBase管理非关系型数据</st>
- en: <st c="1589">Utilizing the column storage of</st> <st c="1622">Apache Cassandra</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1589">利用Apache Cassandra的列存储</st>
- en: <st c="1638">Storing search data</st> <st c="1659">in Redis</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1638">在Redis中存储搜索数据</st> <st c="1659"></st>
- en: <st c="1667">Handling BSON-based documents</st> <st c="1698">with MongoDB</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1667">使用MongoDB处理BSON文档</st> <st c="1698"></st>
- en: <st c="1710">Managing key-based JSON documents</st> <st c="1745">with Couchbase</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1710">使用Couchbase管理基于键的JSON文档</st> <st c="1745"></st>
- en: <st c="1759">Establishing a data relationship</st> <st c="1793">with Neo4J</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1759">与Neo4J建立数据关系</st> <st c="1793"></st>
- en: <st c="1803">Technical requirements</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1803">技术要求</st>
- en: <st c="1826">This chapter highlights a</st> *<st c="1853">Tutor Finder</st>*
    <st c="1865">application that accepts students and tutor profiles.</st> <st c="1920">The
    application’s main objective is to provide a platform for vying students looking
    for personal tutors or trainers with different expertise.</st> <st c="2063">Aside
    from profiling, it has a</st> *<st c="2094">payment module</st>* <st c="2108">for
    students to pay their tutor’s fees based on payment modes,</st> *<st c="2172">course
    modules</st>* <st c="2186">for course details, and</st> *<st c="2211">search modules</st>*
    <st c="2225">to find the appropriate tutor and student profiles.</st> <st c="2278">The
    application is unique and experimental because it showcases all the NoSQL databases
    as its backend storage to serve as a specimen for this chapter.</st> <st c="2430">On
    the other hand, the application utilizes the</st> *<st c="2478">factory pattern</st>*
    <st c="2493">as its main project structure design.</st> <st c="2532">All files
    are available</st> <st c="2556">at</st> [<st c="2559">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch07</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch07)<st
    c="2640">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1826">本章重点介绍一个</st> *<st c="1853">导师查找器</st>* <st c="1865">应用程序，该应用程序接受学生和导师的资料。</st>
    <st c="1920">该应用程序的主要目标是提供一个平台，供寻找不同专业导师或教练的个人学生使用。</st> <st c="2063">除了资料外，它还有一个</st>
    *<st c="2094">支付模块</st>* <st c="2108">，学生可以根据支付方式支付导师的费用，</st> *<st c="2172">课程模块</st>*
    <st c="2186">用于课程详情，以及</st> *<st c="2211">搜索模块</st>* <st c="2225">用于查找合适的导师和学生资料。</st>
    <st c="2278">该应用程序独特且实验性，因为它展示了所有NoSQL数据库作为其后端存储，作为本章的示例。</st> <st c="2430">另一方面，该应用程序利用了</st>
    *<st c="2478">工厂模式</st>* <st c="2493">作为其主要项目结构设计。</st> <st c="2532">所有文件均可在</st>
    <st c="2556">[<st c="2559">https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch07</st>](https://github.com/PacktPublishing/Mastering-Flask-Web-Development/tree/main/ch07)<st
    c="2640">找到。</st>
- en: <st c="2641">Managing non-relational data using Apache HBase</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2641">使用Apache HBase管理非关系型数据</st>
- en: <st c="2689">One of the</st> <st c="2700">most popular</st> <st c="2713">NoSQL
    databases is the</st> `<st c="3208">byte[]</st>` <st c="3214">type.</st> <st c="3221">This</st>
    `<st c="3226">byte[]</st>` <st c="3232">data is handled by the column families,
    which are composed of</st> *<st c="3295">column qualifiers</st>* <st c="3312">or</st>
    *<st c="3316">columns</st>*<st c="3323">, each stored in a</st> *<st c="3342">cell</st>*<st
    c="3346">. Each column qualifier addresses one</st> *<st c="3384">data field</st>*
    <st c="3394">with a</st> *<st c="3402">timestamp</st>* <st c="3411">that keeps
    track of the versions of each column field in</st> <st c="3469">every update.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2689">最受欢迎的</st> <st c="2700">NoSQL数据库之一是</st> `<st c="3208">byte[]</st>`
    <st c="3214">类型。</st> <st c="3221">这种</st> `<st c="3226">byte[]</st>` <st c="3232">数据由列族处理，列族由</st>
    *<st c="3295">列限定符</st>* <st c="3312">或</st> *<st c="3316">列</st>*<st c="3323">组成，每个存储在一个</st>
    *<st c="3342">单元格</st>*<st c="3346">中。每个列限定符对应一个</st> *<st c="3384">数据字段</st>*
    <st c="3394">，并带有</st> *<st c="3402">时间戳</st>* <st c="3411">，用于跟踪每次更新中每个列字段的版本。</st>
- en: <st c="3482">Regarding column-oriented databases, this chapter will concentrate
    solely on integrating Apache HBase into our Flask application.</st> <st c="3613">Initially,
    like any database, we’ll design the HBase tables first before integrating them</st>
    <st c="3703">into Flask.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3482">关于列式数据库，本章将专注于将Apache HBase集成到我们的Flask应用程序中。</st> <st c="3613">最初，就像任何数据库一样，我们将首先设计HBase表，然后再将其</st>
    <st c="3703">集成到Flask中。</st>
- en: <st c="3714">Designing HBase tables</st>
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3714">设计HBase表</st>
- en: <st c="3737">One of the leverages of using</st> <st c="3767">relational databases
    is the availability of many design tools that can assist us with planning and
    organizing the table schema using different normalization levels.</st> <st c="3933">Only
    a few data modeling</st> <st c="3957">tools, such as</st> `<st c="4168">payments</st>`
    <st c="4176">and</st> `<st c="4181">bookings</st>` <st c="4189">HBase tables using
    the UML class diagramming approach.</st> *<st c="4245">Figure 7</st>**<st c="4253">.1</st>*
    <st c="4255">shows the UML design for the</st> `<st c="4285">payments</st>` <st
    c="4293">and</st> `<st c="4298">bookings</st>` <st c="4306">tables:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3737">使用关系数据库的一个优势是，有许多设计工具可以帮助我们使用不同的规范化级别来规划和组织表模式。</st> <st c="3933">只有少数数据建模</st>
    <st c="3957">工具，例如</st> `<st c="4168">支付</st>` <st c="4176">和</st> `<st c="4181">预订</st>`
    <st c="4189">HBase表使用UML类图方法。</st> *<st c="4245">图7</st>**<st c="4253">.1</st>*
    <st c="4255">显示了</st> `<st c="4285">支付</st>` <st c="4293">和</st> `<st c="4298">预订</st>`
    <st c="4306">表的UML设计：</st>
- en: '![Figure 7.1 – HBase table design for payments and bookings](img/B19383_07_001.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 付款和预订的 HBase 表设计](img/B19383_07_001.jpg)'
- en: <st c="4372">Figure 7.1 – HBase table design for payments and bookings</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4372">图 7.1 – 付款和预订的 HBase 表设计</st>
- en: <st c="4429">The</st> `<st c="4434">payments</st>` <st c="4442">and</st> `<st
    c="4447">bookings</st>` <st c="4455">contexts signify the two tables of the HBase
    database.</st> <st c="4511">The</st> `<st c="4515">payments</st>` <st c="4523">table
    has two column families, namely</st> `<st c="4562">PaymentDetails</st>` <st c="4576">and</st>
    `<st c="4581">PaymentItems</st>`<st c="4593">. The</st> `<st c="4599">bookings</st>`
    <st c="4607">table has one column</st> <st c="4629">family,</st> `<st c="4637">BookingDetails</st>`<st
    c="4651">.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4429">`<st c="4434">payments</st>` <st c="4442">和</st> `<st c="4447">bookings</st>`
    <st c="4455">上下文表示 HBase 数据库的两个表。</st> `<st c="4515">payments</st>` <st c="4523">表有两个列族，即</st>
    `<st c="4562">PaymentDetails</st>` <st c="4576">和</st> `<st c="4581">PaymentItems</st>`<st
    c="4593">。`<st c="4599">bookings</st>` <st c="4607">表有一个列族，即</st> `<st c="4629">BookingDetails</st>`<st
    c="4651">。</st>
- en: <st c="4652">Note that</st> `<st c="4663">PaymentDetails</st>` <st c="4677">has</st>
    `<st c="4682">id</st>`<st c="4684">,</st> `<st c="4686">stud_id</st>`<st c="4693">,</st>
    `<st c="4695">tutor_id</st>`<st c="4703">,</st> `<st c="4705">ccode</st>`<st c="4710">,
    and</st> `<st c="4716">fee</st>` <st c="4719">as column qualifiers, while</st>
    `<st c="4748">PaymentItems</st>` <st c="4760">has</st> `<st c="4765">id</st>`<st
    c="4767">,</st> `<st c="4769">receipt_id</st>`<st c="4779">, and</st> `<st c="4785">amount</st>`<st
    c="4791">. Furthermore,</st> `<st c="4806">BookingDetails</st>` <st c="4820">has</st>
    `<st c="4825">id</st>`<st c="4827">,</st> `<st c="4829">tutor_id</st>`<st c="4837">,</st>
    `<st c="4839">stud_id</st>`<st c="4846">, and</st> `<st c="4852">date_booked</st>`
    <st c="4863">columns.</st> <st c="4873">A sample record in JSON format will look</st>
    <st c="4914">like this:</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4652">请注意</st> `<st c="4663">PaymentDetails</st>` <st c="4677">包含</st>
    `<st c="4682">id</st>`<st c="4684">,</st> `<st c="4686">stud_id</st>`<st c="4693">,</st>
    `<st c="4695">tutor_id</st>`<st c="4703">,</st> `<st c="4705">ccode</st>`<st c="4710">,
    和</st> `<st c="4716">fee</st>` <st c="4719">作为列限定符，而</st> `<st c="4748">PaymentItems</st>`
    <st c="4760">包含</st> `<st c="4765">id</st>`<st c="4767">,</st> `<st c="4769">receipt_id</st>`<st
    c="4779">, 和</st> `<st c="4785">amount</st>`<st c="4791">。此外，</st> `<st c="4806">BookingDetails</st>`
    <st c="4820">包含</st> `<st c="4825">id</st>`<st c="4827">,</st> `<st c="4829">tutor_id</st>`<st
    c="4837">,</st> `<st c="4839">stud_id</st>`<st c="4846">, 和</st> `<st c="4852">date_booked</st>`
    <st c="4863">列。</st> <st c="4873">一个 JSON 格式的示例记录将看起来像这样：</st>
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="5302">The actual name of the column qualifier, when accessed via the
    Flask app, is a</st> *<st c="5382">concatenation</st>* <st c="5395">of the column
    family and the column name itself.</st> <st c="5445">An example from the given
    record</st> <st c="5478">is</st> `<st c="5481">details:stud_id</st>`<st c="5496">.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5302">当通过 Flask 应用程序访问时，列限定符的实际名称是列族和列名本身的</st> *<st c="5382">连接</st>*
    <st c="5395">。</st> <st c="5445">给定记录的一个示例</st> <st c="5478">是</st> `<st c="5481">details:stud_id</st>`<st
    c="5496">。</st>
- en: <st c="5497">Now that we’ve designed</st> <st c="5521">the table structure,
    let’s look at how we can install and configure the Apache HBase and Apache Hadoop
    platforms.</st> <st c="5636">We’ll start by</st> <st c="5651">using Java.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5497">现在我们已经设计了</st> <st c="5521">表结构，让我们看看我们如何安装和配置 Apache HBase 和 Apache
    Hadoop 平台。</st> <st c="5636">我们将从</st> <st c="5651">使用 Java 开始。</st>
- en: <st c="5662">Setting up the baseline requirements</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="5662">设置基本要求</st>
- en: <st c="5699">Apache HBase is a Java-based platform, and all</st> <st c="5746">its
    components</st> <st c="5761">depend on</st> `<st c="5933">JAVA_HOME</st>` <st
    c="5942">system environment variable in your Windows, Linux, or macOS environment
    and update</st> `<st c="6027">CLASSPATH</st>` <st c="6036">to help HBase access
    the JDK commands in Java’s</st> `<st c="6085">/bin</st>` <st c="6089">folder so
    that it can perform server startup and</st> <st c="6139">shutdown operations.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5699">Apache HBase 是一个基于 Java 的平台，并且所有</st> <st c="5746">其组件</st> <st
    c="5761">都依赖于</st> `<st c="5933">JAVA_HOME</st>` <st c="5942">系统环境变量在您的 Windows、Linux
    或 macOS 环境中，并更新</st> `<st c="6027">CLASSPATH</st>` <st c="6036">以帮助 HBase 访问 Java
    的</st> `<st c="6085">/bin</st>` <st c="6089">文件夹中的 JDK 命令，以便它可以执行服务器启动和</st> <st
    c="6139">关闭操作。</st>
- en: <st c="6159">Since Apache HBase</st> <st c="6178">is a distributed storage that
    uses</st> `<st c="6255">hadoop-3.3.6/hadoop-3.3.6.tar.gz</st>` <st c="6287">file
    from</st> [<st c="6298">https://hadoop.apache.org/releases.html</st>](https://hadoop.apache.org/releases.html)
    <st c="6337">and unzip it to the same local drive where the HBase installation
    folder is.</st> <st c="6415">Create a</st> `<st c="6424">HADOOP_HOME</st>` <st
    c="6435">file and update the</st> `<st c="6456">CLASSPATH</st>` <st c="6465">variable
    of the operating system to make the Hadoop</st> `<st c="6518">/bin</st>` <st c="6522">commands
    available to HBase during startup.</st> <st c="6567">Let’s have a brief look at
    the Apache Hadoop framework to understand</st> <st c="6636">this better.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6159">由于 Apache HBase</st> <st c="6178">是一个使用</st> `<st c="6255">hadoop-3.3.6/hadoop-3.3.6.tar.gz</st>`
    <st c="6287">文件（来自 [<st c="6298">https://hadoop.apache.org/releases.html</st>](https://hadoop.apache.org/releases.html)）<st
    c="6337">并将其解压缩到与 HBase 安装文件夹相同的本地驱动器上。</st> <st c="6415">创建一个</st> `<st c="6424">HADOOP_HOME</st>`
    <st c="6435">文件，并更新操作系统的</st> `<st c="6456">CLASSPATH</st>` <st c="6465">变量，以便在启动时使
    Hadoop</st> `<st c="6518">/bin</st>` <st c="6522">命令对 HBase 可用。</st> <st c="6567">让我们简要了解一下
    Apache Hadoop 框架，以便更好地理解。</st>
- en: <st c="6648">Configuring Apache Hadoop</st>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6648">配置 Apache Hadoop</st>
- en: <st c="6674">Apache Hadoop is a Java-based</st> <st c="6704">framework that
    manages scalable big data processing across a distributed cluster setup.</st>
    <st c="6793">It is popular due to its</st> *<st c="6818">MapReduce</st>* <st c="6827">algorithm,
    which performs data processing in parallel across cluster(s) of nodes, making
    the framework’s distributed operations fast.</st> <st c="6962">Moreover, the</st>
    <st c="6975">framework has</st> **<st c="6990">HDFS</st>** <st c="6994">a filesystem.</st>
    <st c="7009">This is where it contains the input and</st> <st c="7049">output
    datasets.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6674">Apache Hadoop 是一个基于 Java 的</st> <st c="6704">框架，它管理着分布式集群设置中的可扩展大数据处理。</st>
    <st c="6793">它因其</st> *<st c="6818">MapReduce</st>* <st c="6827">算法而流行，该算法在节点集群上并行执行数据处理，使框架的分布式操作快速。</st>
    <st c="6962">此外，该</st> <st c="6975">框架具有</st> **<st c="6990">HDFS</st>** <st c="6994">文件系统。</st>
    <st c="7009">这是它包含输入和</st> <st c="7049">输出数据集的地方。</st>
- en: <st c="7065">The</st> *<st c="7070">MapReduce</st>* <st c="7079">process starts
    with these big</st> <st c="7109">datasets being stored in HDFS by the Flask application.</st>
    <st c="7166">They’re passed through the internal Hadoop servers, which run the</st>
    `<st c="7232">Map()</st>` <st c="7237">function to break down this data into tuples
    of key-value pairs.</st> <st c="7303">Then, these groups of key-value data blocks
    undergo another process called</st> `<st c="7378">Reduce()</st>`<st c="7386">,
    which is performed by other Hadoop servers.</st> <st c="7432">This exposes these
    data blocks to various reduce functions, such as summation, averaging, concatenation,
    compression, ordering, and shuffling, and then saves them as output datasets</st>
    <st c="7614">in HDFS.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7065">The</st> *<st c="7070">MapReduce</st>* <st c="7079">过程始于这些大数据集通过
    Flask 应用程序存储在 HDFS 中。</st> <st c="7166">它们通过内部 Hadoop 服务器传递，这些服务器运行 <st c="7232">Map()</st>
    <st c="7237">函数，将数据分解成键值对的元组。</st> <st c="7303">然后，这些键值数据块组经过另一个称为 <st c="7378">Reduce()</st><st
    c="7386"> 的过程，由其他 Hadoop 服务器执行。</st> <st c="7432">这将这些数据块暴露给各种 reduce 函数，如求和、平均、连接、压缩、排序和洗牌，然后将其作为输出数据集
    <st c="7614">存储在 HDFS 中。</st>
- en: <st c="7622">Aside from the</st> *<st c="7638">MapReduce</st>* <st c="7647">distributed
    data process, HBase needs Hadoop’s HDFS because of the high latency batch processing
    operations it gives to the HBase platform.</st> <st c="7788">In return, HBase
    enables read/write transactions to access the data stored in HDFS and can provide
    a thrift server so that third-party applications can access the</st> <st c="7951">big
    datasets.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7622">除了</st> *<st c="7638">MapReduce</st>* <st c="7647">分布式数据处理之外，HBase
    需要使用 Hadoop 的 HDFS，因为它为 HBase 平台提供了高延迟的批量处理操作。</st> <st c="7788">作为回报，HBase 允许读写事务访问存储在
    HDFS 中的数据，并且可以提供一个 thrift 服务器，以便第三方应用程序可以访问</st> <st c="7951">大数据集。</st>
- en: <st c="7964">Important note</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7964">重要提示</st>
- en: <st c="7979">A</st> *<st c="7982">thrift server</st>* <st c="7995">is a Hive-compatible</st>
    <st c="8017">interface in HBase that enables multi-language support, allowing
    applications developed in Python, Java, C#, C++, NodeJS, Go, PHP, and JavaScript
    to access big data.</st> <st c="8183">The term</st> *<st c="8192">Hive</st>*<st
    c="8196">, on the other</st> <st c="8211">hand, refers to a client application
    that runs on top of Hadoop and has powerful SQL utilities that are used to implement
    CRUD operations for</st> <st c="8353">large datasets.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7979">一个</st> *<st c="7982">Thrift 服务器</st>* <st c="7995">是 HBase 中一个兼容
    Hive 的接口，它支持多语言，允许使用 Python、Java、C#、C++、NodeJS、Go、PHP 和 JavaScript 开发的应用程序访问大数据。</st>
    <st c="8183">另一方面，术语</st> *<st c="8192">Hive</st>*<st c="8196">指的是运行在 Hadoop 之上并具有强大
    SQL 工具的客户端应用程序，这些工具用于实现大型数据集的 CRUD 操作。</st>
- en: <st c="8368">Here’s the step-by-step procedure to set up a Hadoop platform with
    a</st> <st c="8438">single-node cluster:</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8368">以下是使用单节点集群设置 Hadoop 平台的步骤：</st>
- en: <st c="8458">Go to the installation folder of</st> *<st c="8492">Apache Hadoop
    3.3.6</st>* <st c="8511">and open</st> `<st c="8521">/etc/hadoop/core-site.xml</st>`<st
    c="8546">. Then, set the</st> `<st c="8562">fs.defaultFS</st>` <st c="8574">property.</st>
    <st c="8585">This indicates the default location of</st> *<st c="8624">NameNode</st>*
    <st c="8632">(master node) in the cluster – in our case, the default</st> <st
    c="8688">filesystem.</st> <st c="8701">Its value is a URL address to which</st>
    *<st c="8737">DataNode</st>* <st c="8745">(slave node) will send a heartbeat.</st>
    *<st c="8782">NameNode</st>* <st c="8790">contains the metadata of the data stored
    in HDFS, while</st> *<st c="8847">DataNode</st>* <st c="8855">contains the big
    datasets.</st> <st c="8883">Here is our</st> `<st c="8895">core-site.xml</st>`
    <st c="8908">file:</st>
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8458">前往</st> *<st c="8492">Apache Hadoop 3.3.6</st>* <st c="8511">的安装文件夹，并打开</st>
    `<st c="8521">/etc/hadoop/core-site.xml</st>`<st c="8546">。然后，设置</st> `<st c="8562">fs.defaultFS</st>`
    <st c="8574">属性。</st> <st c="8585">这表示集群中</st> *<st c="8624">NameNode</st>* <st
    c="8632">(主节点)的默认位置 – 在我们的案例中，是默认的</st> <st c="8688">文件系统。</st> <st c="8701">它的值是一个
    URL 地址，DataNode</st> <st c="8737">（从节点）将向其发送心跳。</st> *<st c="8782">NameNode</st>*
    <st c="8790">包含存储在 HDFS 中的数据的元数据，而</st> *<st c="8847">DataNode</st>* <st c="8855">包含大数据集。</st>
    <st c="8883">以下是我们的</st> `<st c="8895">core-site.xml</st>` <st c="8908">文件：</st>
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="9033">Inside the same installation folder, create a custom folder called</st>
    `<st c="9101">data</st>` <st c="9105">with two sub-folders called</st> `<st c="9134">datanode</st>`
    <st c="9142">and</st> `<st c="9147">namenode</st>`<st c="9155">, as shown in</st>
    *<st c="9169">Figure 7</st>**<st c="9177">.2</st>*<st c="9179">. These folders
    will eventually contain the configuration files of</st> *<st c="9246">DataNode</st>*
    <st c="9254">and</st> *<st c="9259">NameNode</st>*<st c="9267">, respectively:</st>
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="8438">在同一个安装文件夹内，创建一个名为</st> `<st c="9101">data</st>` <st c="9105">的自定义文件夹，其中包含两个子文件夹，分别命名为</st>
    `<st c="9134">datanode</st>` <st c="9142">和</st> `<st c="9147">namenode</st>`<st
    c="9155">，如图 7.2 所示**<st c="9169">**<st c="9177">.2</st>**<st c="9179">。这些文件夹最终将包含</st>
    *<st c="9246">DataNode</st>* <st c="9254">和</st> *<st c="9259">NameNode</st>*<st
    c="9267">的配置文件，分别：</st>
- en: '![Figure 7.2 – The DataNode and NameNode config folders](img/B19383_07_002.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – DataNode 和 NameNode 配置文件夹](img/B19383_07_002.jpg)'
- en: <st c="9388">Figure 7.2 – The DataNode and NameNode config folders</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9388">图 7.2 – DataNode 和 NameNode 配置文件夹</st>
- en: <st c="9441">Next, open</st> `<st c="9453">/etc/hadoop/hdfs-site.xml</st>` <st
    c="9478">and declare the newly created</st> `<st c="9509">datanode</st>` <st c="9517">and</st>
    `<st c="9522">namenode</st>` <st c="9530">folders as the final config locations
    of their respective nodes.</st> <st c="9596">Also, set the</st> `<st c="9610">dfs.replication</st>`
    <st c="9625">property to</st> `<st c="9638">1</st>` <st c="9639">since we only
    have a single node</st> <st c="9673">cluster for our</st> *<st c="9689">Tutor
    Finder</st>* <st c="9701">project.</st> <st c="9711">Here is our</st> `<st c="9723">hdf-site.xml</st>`
    <st c="9735">file:</st>
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="9441">接下来，打开</st> `<st c="9453">/etc/hadoop/hdfs-site.xml</st>` <st c="9478">并声明新创建的</st>
    `<st c="9509">datanode</st>` <st c="9517">和</st> `<st c="9522">namenode</st>`
    <st c="9530">文件夹作为各自节点的最终配置位置。</st> <st c="9596">此外，将</st> `<st c="9610">dfs.replication</st>`
    <st c="9625">属性设置为</st> `<st c="9638">1</st>` <st c="9639">，因为我们只有一个节点</st> <st
    c="9673">集群用于我们的</st> *<st c="9689">Tutor Finder</st>* <st c="9701">项目。</st> <st
    c="9711">以下是我们的</st> `<st c="9723">hdf-site.xml</st>` <st c="9735">文件：</st>
- en: '[PRE2]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="10125">Since our project will use Hadoop installed in Windows, download
    the</st> `<st c="10195">hadoop-3.3.6-src.tar.gz</st>` <st c="10218">file from</st>
    `<st c="10229">https://hadoop.apache.org/releases.html</st>` <st c="10268">and
    compile the Hadoop source files using Maven to generate Hadoop binaries for Windows,
    such as</st> `<st c="10366">winutils.exe</st>`<st c="10378">,</st> `<st c="10380">hadoop.dll</st>`<st
    c="10390">, and</st> `<st c="10396">hdfs.dll</st>`<st c="10404">. Drop these files
    into the</st> `<st c="10432">/</st>``<st c="10433">bin</st>` <st c="10436">folder.</st>
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10125">由于我们的项目将使用安装在Windows上的Hadoop，请从</st> `<st c="10195">hadoop-3.3.6-src.tar.gz</st>`
    <st c="10218">文件从</st> `<st c="10229">https://hadoop.apache.org/releases.html</st>`
    <st c="10268">下载并使用Maven编译Hadoop源文件以生成Windows的Hadoop二进制文件，例如</st> `<st c="10366">winutils.exe</st>`<st
    c="10378">,</st> `<st c="10380">hadoop.dll</st>`<st c="10390">, 和</st> `<st c="10396">hdfs.dll</st>`<st
    c="10404">。将这些文件放入</st> `<st c="10432">/</st>``<st c="10433">bin</st>` <st c="10436">文件夹。</st>
- en: <st c="10444">Format the new active</st> *<st c="10467">NameNode</st>*<st c="10475">(s)
    by running the following command at the</st> <st c="10520">command line:</st>
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="10444">通过在命令行运行以下命令来格式化新的活动</st> *<st c="10467">NameNode</st>*<st c="10475">(s)：</st>
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="10555">This command will clean up the</st> *<st c="10587">NameNode</st>*<st
    c="10595">(s) if they have existing</st> <st c="10622">stored metadata.</st>
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="10555">此命令将清理</st> *<st c="10587">NameNode</st>*<st c="10595">(s) 如果它们有现有的</st>
    <st c="10622">存储元数据。</st>
- en: <st c="10638">Now, we can start setting</st> <st c="10664">up a version of Apache
    HBase that’s compatible with Apache</st> <st c="10724">Hadoop 3.3.6.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10638">现在，我们可以开始设置</st> <st c="10664">一个与Apache</st> <st c="10724">Hadoop
    3.3.6兼容的Apache HBase版本。</st>
- en: <st c="10737">Configuring Zookeeper and Apache HBase</st>
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10737">配置Zookeeper和Apache HBase</st>
- en: <st c="10776">Apache HBase depends</st> <st c="10797">on Apache Zookeeper</st>
    <st c="10817">when running its clusters, so the next step is to install and configure
    a Zookeeper server.</st> **<st c="10910">Apache Zookeeper</st>** <st c="10926">is
    a high-performance service that manages distributed and cloud-based applications
    by providing synchronization and centralized services and maintains details of
    these applications.</st> <st c="11110">Note that this project utilizes Zookeeper
    bundled with HBase, so you shouldn’t install Zookeeper separately unless the setup
    involves</st> <st c="11244">multiple clusters.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10776">Apache HBase在运行其集群时依赖于Apache Zookeeper</st> <st c="10797">，因此下一步是安装和配置一个Zookeeper服务器。</st>
    **<st c="10910">Apache Zookeeper</st>** <st c="10926">是一个高性能服务，通过提供同步和集中式服务来管理分布式和基于云的应用程序，并维护这些应用程序的详细信息。</st>
    <st c="11110">请注意，此项目使用与HBase捆绑的Zookeeper，因此除非设置涉及</st> <st c="11244">多个集群</st>，否则您不应单独安装Zookeeper。
- en: <st c="11262">Now, download</st> *<st c="11277">Apache HBase 2.5.5</st>*<st
    c="11295">, the most compatible HBase distribution, to Apache Hadoop 3.3.6\.</st>
    <st c="11361">Unzip it to the folder where Hadoop resides.</st> <st c="11406">Then,
    configure HBase by performing the</st> <st c="11446">following steps:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11262">现在，下载</st> *<st c="11277">Apache HBase 2.5.5</st>*<st c="11295">，与Apache
    Hadoop 3.3.6最兼容的HBase发行版，到Apache Hadoop 3.3.6。</st> <st c="11361">将其解压到Hadoop所在的文件夹。</st>
    <st c="11406">然后，通过执行以下步骤来配置HBase：</st>
- en: <st c="11462">First, create an</st> `<st c="11480">HBASE_HOME</st>` <st c="11490">system
    environment variable that registers the HBase</st> <st c="11544">installation
    folder.</st>
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个<st c="11462">系统环境变量</st> `<st c="11480">HBASE_HOME</st>` <st c="11490">来注册HBase</st>
    <st c="11544">安装文件夹。</st>
- en: <st c="11564">Create two folders inside the installation folder,</st> `<st c="11616">hbase</st>`
    <st c="11621">and</st> `<st c="11626">zookeeper</st>`<st c="11635">. These will
    serve as the root folders of HBase and the built-in Zookeeper</st> <st c="11710">server,
    respectively.</st>
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11564">在安装文件夹内创建两个文件夹，</st> `<st c="11616">hbase</st>` <st c="11621">和</st>
    `<st c="11626">zookeeper</st>`<st c="11635">。这些将分别作为HBase和内置Zookeeper</st> <st
    c="11710">服务器的根文件夹。</st>
- en: <st c="11731">Inside the installation folder, open</st> `<st c="11769">/conf/hbase-site.xml</st>`<st
    c="11789">. Here, set the</st> `<st c="11805">hbase.rootdir</st>` <st c="11818">property
    so that it points to the</st> `<st c="11853">hbase</st>` <st c="11858">folder
    and the</st> `<st c="11874">hbase.zookeeper.property.dataDir</st>` <st c="11906">property
    so that it points to the</st> `<st c="11941">zookeeper</st>` <st c="11950">folder.</st>
    <st c="11959">Now, register the</st> `<st c="11977">hbase.zookeeper.quorum</st>`
    <st c="11999">property.</st> <st c="12010">This will indicate the Zookeeper server’s
    host.</st> <st c="12058">Then, set the</st> `<st c="12072">hbase.cluster.distributed</st>`
    <st c="12097">property.</st> <st c="12108">This will specify the type of HBase
    server setup.</st> <st c="12158">The following is our</st> `<st c="12179">hbase-site.xml</st>`
    <st c="12193">file:</st>
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="11731">在安装文件夹中，打开</st> `<st c="11769">/conf/hbase-site.xml</st>`<st c="11789">。在此，设置</st>
    `<st c="11805">hbase.rootdir</st>` <st c="11818">属性，使其指向</st> `<st c="11853">hbase</st>`
    <st c="11858">文件夹，并设置</st> `<st c="11874">hbase.zookeeper.property.dataDir</st>`
    <st c="11906">属性，使其指向</st> `<st c="11941">zookeeper</st>` <st c="11950">文件夹。</st>
    <st c="11959">现在，注册</st> `<st c="11977">hbase.zookeeper.quorum</st>` <st c="11999">属性。</st>
    <st c="12010">这将指示 Zookeeper 服务器的主机。</st> <st c="12058">然后，设置</st> `<st c="12072">hbase.cluster.distributed</st>`
    <st c="12097">属性。</st> <st c="12108">这将指定 HBase 服务器设置的类型。</st> <st c="12158">以下是我们</st>
    `<st c="12179">hbase-site.xml</st>` <st c="12193">文件：</st>
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="12744">Next, open</st> `<st c="12756">/bin/hbase.cmd</st>` <st c="12770">if
    you’re on Windows and search for the</st> `<st c="12811">java_arguments</st>`
    <st c="12825">property.</st> <st c="12836">Remove</st> `<st c="12843">%HEAP_SETTINGS%</st>`
    <st c="12858">so that the new statement will be</st> <st c="12893">as follows:</st>
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12744">接下来，打开</st> `<st c="12756">/bin/hbase.cmd</st>` <st c="12770">如果您使用的是
    Windows，并搜索</st> `<st c="12811">java_arguments</st>` <st c="12825">属性。</st> <st
    c="12836">删除</st> `<st c="12843">%HEAP_SETTINGS%</st>` <st c="12858">以便新的声明将是</st>
    <st c="12893">如下所示：</st>
- en: '[PRE5]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="12995">Open</st> `<st c="13001">/conf/hbase-env.cmd</st>` <st c="13020">and
    add</st> <st c="13028">the following</st> `<st c="13043">JAVA_HOME</st>` <st c="13052">and</st>
    `<st c="13057">HBASE_*</st>` <st c="13064">details</st> <st c="13072">to</st>
    <st c="13076">the file:</st>
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="12995">打开</st> `<st c="13001">/conf/hbase-env.cmd</st>` <st c="13020">并添加</st>
    <st c="13028">以下</st> `<st c="13043">JAVA_HOME</st>` <st c="13052">和</st> `<st
    c="13057">HBASE_*</st>` <st c="13064">详细信息</st> <st c="13072">到</st> <st c="13076">文件：</st>
- en: '[PRE6]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="14017">Our</st> *<st c="14022">Tutor Finding</st>* <st c="14035">project
    uses</st> *<st c="14049">Java JDK 11</st>* <st c="14060">to run the HBase database
    server.</st> <st c="14095">So, the usual garbage collectors that work with Java
    1.8 are now deprecated and invalid.</st> <st c="14184">The most suitable GC option
    for the HBase platform that uses Java JDK 11 to achieve better server performance</st>
    <st c="14294">is</st> *<st c="14297">G1GC</st>*<st c="14301">.</st>
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="14017">我们的</st> *<st c="14022">导师寻找</st> <st c="14035">项目使用</st> *<st
    c="14049">Java JDK 11</st> <st c="14060">来运行 HBase 数据库服务器。</st> <st c="14095">因此，与
    Java 1.8 一起工作的常规垃圾收集器现在已弃用且无效。</st> <st c="14184">对于使用 Java JDK 11 的 HBase 平台，最合适的
    GC 选项是</st> <st c="14294">G1GC</st> <st c="14297">，以实现更好的服务器性能。</st>
- en: <st c="14302">Finally, go to the</st> `<st c="14322">/bin</st>` <st c="14326">folder</st>
    <st c="14333">and run the</st> `<st c="14346">start-hbase</st>` <st c="14357">command</st>
    <st c="14365">to start the server.</st> *<st c="14387">Figure 7</st>**<st c="14395">.3</st>*
    <st c="14397">shows a snapshot of the HBase logs while</st> <st c="14439">at startup:</st>
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="14302">最后，转到</st> `<st c="14322">/bin</st>` <st c="14326">文件夹</st> <st
    c="14333">并运行</st> `<st c="14346">start-hbase</st>` <st c="14357">命令</st> <st
    c="14365">以启动服务器。</st> *<st c="14387">图 7</st>**<st c="14395">.3</st>* <st c="14397">显示了启动时的
    HBase 日志快照：</st>
- en: '![Figure 7.3 – Starting up the HBase server](img/B19383_07_003.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 启动 HBase 服务器](img/B19383_07_003.jpg)'
- en: <st c="15289">Figure 7.3 – Starting up the HBase server</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15289">图 7.3 – 启动 HBase 服务器</st>
- en: <st c="15330">To stop the server, run</st> `<st c="15355">stop-hbase</st>`<st
    c="15365">, then</st> `<st c="15372">hbase master stop --</st>``<st c="15392">shutDownCluster</st>`<st
    c="15408">.</st>
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="15330">要停止服务器，运行</st> `<st c="15355">stop-hbase</st>`<st c="15365">，然后</st>
    `<st c="15372">hbase master stop --</st>``<st c="15392">shutDownCluster</st>`<st
    c="15408">。</st>
- en: <st c="15409">The HBase server log, shown in</st> *<st c="15441">Figure 7</st>**<st
    c="15449">.4</st>*<st c="15451">, shows the Zookeeper server fetching all the
    Hadoop configuration files to handle all the Hadoop cluster(s) and providing the
    necessary</st> <st c="15588">operational services:</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15409">HBase 服务器日志，如</st> *<st c="15441">图 7</st>**<st c="15449">.4</st>*<st
    c="15451">所示，显示了 Zookeeper 服务器检索所有 Hadoop 配置文件以处理所有 Hadoop 集群并提供必要的</st> <st c="15588">操作服务：</st>
- en: '![Figure 7.4 – Starting up Zookeeper with the Hadoop cluster(s)](img/B19383_07_004.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 使用Hadoop集群启动Zookeeper](img/B19383_07_004.jpg)'
- en: <st c="16885">Figure 7.4 – Starting up Zookeeper with the Hadoop cluster(s)</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16885">图7.4 – 使用Hadoop集群启动Zookeeper</st>
- en: <st c="16946">Now that we’ve made</st> <st c="16966">these server</st> <st c="16979">configurations,
    let’s run the HBase client so that we can create our</st> `<st c="17049">payments</st>`
    <st c="17057">and</st> `<st c="17062">bookings</st>` <st c="17070">tables.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16946">现在我们已经完成了</st> <st c="16966">这些服务器</st> <st c="16979">配置，让我们运行HBase客户端，以便我们可以创建我们的</st>
    `<st c="17049">支付</st>` <st c="17057">和</st> `<st c="17062">预订</st>` <st c="17070">表</st>。
- en: <st c="17078">Setting up the HBase shell</st>
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17078">设置HBase壳</st>
- en: <st c="17105">Apache HBase has a built-in interactive</st> <st c="17145">shell
    client created via Java that can communicate with HDFS for big data.</st> <st
    c="17221">The command to spawn the shell is</st> `<st c="17255">hbase shell</st>`<st
    c="17266">. In Apache HBase 2.5.5, running this command will give us the following</st>
    <st c="17339">error message:</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17105">Apache HBase有一个内置的交互式</st> <st c="17145">shell客户端，通过Java创建，可以与HDFS进行大数据通信。</st>
    <st c="17221">启动shell的命令是</st> `<st c="17255">hbase shell</st>`<st c="17266">。在Apache
    HBase 2.5.5中，运行此命令将给出以下</st> <st c="17339">错误信息</st>：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="17663">The reason behind this error is the missing JAR files that the
    client shell requires from the installation.</st> <st c="17772">So, to fix this
    error, download</st> `<st c="17804">jansi-1.18.jar</st>` <st c="17818">and</st>
    `<st c="17823">jruby-complete-9.2.13.0.jar</st>` <st c="17850">from the Maven
    repository and place them in the</st> `<st c="17899">/lib</st>` <st c="17903">directory.</st>
    <st c="17915">Then, go to the</st> `<st c="17931">/lib</st>` <st c="17935">folder
    and run the following command to open the</st> <st c="17985">client shell:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17663">这个错误的背后原因是客户端壳缺少安装所需的JAR文件。</st> <st c="17772">因此，为了修复这个错误，从Maven仓库下载</st>
    `<st c="17804">jansi-1.18.jar</st>` <st c="17818">和</st> `<st c="17823">jruby-complete-9.2.13.0.jar</st>`
    <st c="17850">，并将它们放置在</st> `<st c="17899">/lib</st>` <st c="17903">目录中。</st>
    <st c="17915">然后，进入</st> `<st c="17931">/lib</st>` <st c="17935">文件夹，并运行以下命令以打开</st>
    <st c="17985">客户端壳</st>：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*<st c="18085">Figure 7</st>**<st c="18094">.5</st>* <st c="18096">shows the
    given command opening the</st> <st c="18133">HBase shell:</st>'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="18085">图7</st>**<st c="18094">.5</st>* <st c="18096">显示了打开</st> <st
    c="18133">HBase壳</st>的给定命令：'
- en: '![Figure 7.5 – Invoking the HBase shell](img/B19383_07_005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5 – 调用HBase壳](img/B19383_07_005.jpg)'
- en: <st c="19652">Figure 7.5 – Invoking the HBase shell</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19652">图7.5 – 调用HBase壳</st>
- en: <st c="19689">The warnings that appear in the logs are due to the collisions
    of SL4J log libraries from Hadoop’s</st> `<st c="19789">/common/lib</st>` <st
    c="19800">and HBase’s</st> `<st c="19813">/lib/client-facing-thirdparty</st>`<st
    c="19842">. Removing redundancies from among these logger libraries can fix these
    warnings.</st> <st c="19924">Now that we’ve finalized the table</st> <st c="19958">designs
    and set up the HBase environment, we’ll build the</st> <st c="20017">HBase tables.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19689">日志中出现的警告是由于Hadoop的</st> `<st c="19789">/common/lib</st>` <st c="19800">和HBase的</st>
    `<st c="19813">/lib/client-facing-thirdparty</st>`<st c="19842">中的SL4J日志库冲突引起的。</st>
    <st c="19924">现在我们已经最终确定了表</st> <st c="19958">设计并设置了HBase环境，我们将构建</st> <st c="20017">HBase表</st>。
- en: <st c="20030">Creating the HBase tables</st>
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="20030">创建HBase表</st>
- en: <st c="20056">The HBase client application</st> <st c="20085">has different
    commands ready to pursue administrative, table, data manipulation, cluster-related,
    and general operations for HBase datasets.</st> <st c="20227">It can interact
    with HBase storage based on these commands.</st> *<st c="20287">Figure 7</st>**<st
    c="20295">.6</st>* <st c="20297">shows common general-purpose commands, such as</st>
    `<st c="20345">whoami</st>`<st c="20351">, which checks the user information that’s
    been logged in the shell, and</st> `<st c="20424">version</st>`<st c="20431">,
    which specifies the version of the running HBase.</st> <st c="20483">It also shows
    the</st> `<st c="20501">status</st>` <st c="20507">command, which specifies the
    status of the server and the average load value – that is, the average number
    of regions per region server across</st> <st c="20651">all servers:</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20056">HBase 客户端应用程序</st> <st c="20085">提供了不同的命令，用于执行 HBase 数据集的管理、表、数据操作、集群相关和通用操作。</st>
    <st c="20227">它可以根据这些命令与 HBase 存储进行交互。</st> *<st c="20287">图 7</st>**<st c="20295">.6</st>*
    <st c="20297">显示了常见的通用命令，例如</st> `<st c="20345">whoami</st>`<st c="20351">，该命令检查已记录在
    shell 中的用户信息，以及</st> `<st c="20424">version</st>`<st c="20431">，该命令指定正在运行的 HBase
    的版本。</st> <st c="20483">它还显示了</st> `<st c="20501">status</st>` <st c="20507">命令，该命令指定服务器状态和平均负载值
    – 即所有服务器中每个区域服务器跨所有服务器的平均区域数：</st>
- en: '![Figure 7.6 – Running general-purpose HBase commands](img/B19383_07_006.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 运行通用的 HBase 命令](img/B19383_07_006.jpg)'
- en: <st c="21320">Figure 7.6 – Running general-purpose HBase commands</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21320">图 7.6 – 运行通用的 HBase 命令</st>
- en: <st c="21371">Most enterprise applications rely on DBA</st> <st c="21412">for
    table design and creation.</st> <st c="21444">For HBase database users, the data
    modelers allow the application’s data layer to generate the tables at every server
    startup.</st> <st c="21571">But often, developers build the tables before development
    using the HBase shell.</st> <st c="21652">In our application, for instance, the</st>
    `<st c="21690">payments</st>` <st c="21698">and</st> `<st c="21703">bookings</st>`
    <st c="21711">tables are generated beforehand using the HBase</st> `<st c="21760">create</st>`
    <st c="21766">command.</st> *<st c="21776">Figure 7</st>**<st c="21784">.7</st>*
    <st c="21786">shows how to use the</st> `<st c="21808">create</st>` <st c="21814">command:</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21371">大多数企业应用程序依赖于 DBA</st> <st c="21412">进行表设计和创建。</st> <st c="21444">对于
    HBase 数据库用户，数据模型器允许在每次服务器启动时生成应用程序的数据层表。</st> <st c="21571">但是，通常开发人员会在开发前使用 HBase
    shell 构建表。</st> <st c="21652">在我们的应用程序中，例如，</st> `<st c="21690">payments</st>`
    <st c="21698">和</st> `<st c="21703">bookings</st>` <st c="21711">表是使用 HBase 的</st>
    `<st c="21760">create</st>` <st c="21766">命令预先生成的。</st> *<st c="21776">图 7</st>**<st
    c="21784">.7</st>* <st c="21786">显示了如何使用</st> `<st c="21808">create</st>` <st
    c="21814">命令：</st>
- en: '![Figure 7.7 – Using the create and list commands](img/B19383_07_007.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 使用创建和列表命令](img/B19383_07_007.jpg)'
- en: <st c="22250">Figure 7.7 – Using the create and list commands</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22250">图 7.7 – 使用创建和列表命令</st>
- en: <st c="22297">To create an HBase table, use the</st> `<st c="22332">create</st>`
    <st c="22338">command with the</st> <st c="22356">following parameters:</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22297">要创建 HBase 表，请使用</st> `<st c="22332">create</st>` <st c="22338">命令并带有以下参数：</st>
- en: <st c="22377">The single or double-quoted table name (for example,</st> `<st
    c="22431">'bookings'</st>` <st c="22441">or</st> `<st c="22445">"payments"</st>`<st
    c="22455">).</st>
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="22377">单引号或双引号表名（例如，</st> `<st c="22431">'bookings'</st>` <st c="22441">或</st>
    `<st c="22445">"payments"</st>`<st c="22455">）。</st>
- en: <st c="22458">The quoted column family’s name(s) or dictionaries containing
    the column family’s attributes, including</st> `<st c="22563">NAME</st>` <st c="22567">and
    other properties such as</st> `<st c="22597">VERSIONS</st>`<st c="22605">, with
    their values all</st> <st c="22629">in quotes.</st>
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="22458">引号中的列族名称（或包含列族属性的字典），包括</st> `<st c="22563">NAME</st>` <st c="22567">和其他属性，如</st>
    `<st c="22597">VERSIONS</st>`<st c="22605">，它们的值都在引号中。</st>
- en: '*<st c="22639">Figure 7</st>**<st c="22648">.7</st>* <st c="22650">shows the</st>
    `<st c="22661">payments</st>` <st c="22669">table being created</st> <st c="22689">with
    the</st> `<st c="22699">details</st>` <st c="22706">and</st> `<st c="22711">items</st>`
    <st c="22716">column families, each with only a maximum of five versions.</st>
    <st c="22777">The</st> `<st c="22781">VERSIONS</st>` <st c="22789">property sets
    the maximum allowable number of updates imposed on the column family’s columns.</st>
    <st c="22884">So, if the</st> `<st c="22895">payments</st>` <st c="22903">table
    has</st> `<st c="22914">VERSIONS</st>` <st c="22922">set to</st> `<st c="22930">5</st>`<st
    c="22931">, the maximum number of allowed updates on the values of its column
    families is at most five times only.</st> <st c="23036">The timestamp that’s given
    to each cell storage of the column qualifier traces</st> <st c="23115">these updates.</st>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="22639">图7</st>**<st c="22648">.7</st>* <st c="22650">显示了使用</st> `<st
    c="22661">payments</st>` <st c="22669">表创建</st> <st c="22689">带有</st> `<st c="22699">details</st>`
    <st c="22706">和</st> `<st c="22711">items</st>` <st c="22716">列族，每个列族最多只有五个版本。</st>
    <st c="22777">`VERSIONS` <st c="22781">属性设置了可以施加在列族列上的最大更新数量。</st> <st c="22884">因此，如果`payments`
    <st c="22895">表将`VERSIONS` <st c="22914">设置为</st> `<st c="22930">5</st>`<st c="22931">，则其列族值允许的最大更新次数最多只有五次。</st>
    <st c="23036">分配给每个单元格存储的列限定符的时间戳追踪这些更新。</st>'
- en: <st c="23129">Now, to view all the tables, use the</st> `<st c="23167">list</st>`
    <st c="23171">command.</st> <st c="23181">There is also the</st> `<st c="23199">describe</st>`
    <st c="23207">command, which you can use to check the metadata information of
    each table (for example,</st> `<st c="23297">describe "bookings"</st>`<st c="23316">).</st>
    <st c="23320">To drop a table, disable the table first (for example,</st> `<st
    c="23375">disable "bookings"</st>`<st c="23393">) before dropping it (for example,
    via</st> `<st c="23433">drop "bookings"</st>`<st c="23448">).</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23129">现在，要查看所有表格，请使用</st> `<st c="23167">list</st>` <st c="23171">命令。</st>
    <st c="23181">还有</st> `<st c="23199">describe</st>` <st c="23207">命令，您可以使用它来检查每个表格的元数据信息（例如，</st>
    `<st c="23297">describe "bookings"</st>`<st c="23316">）。</st> <st c="23320">要删除一个表格，首先禁用该表格（例如，</st>
    `<st c="23375">disable "bookings"</st>`<st c="23393">），然后再删除它（例如，通过</st> `<st
    c="23433">drop "bookings"</st>`<st c="23448">）。</st>
- en: <st c="23451">After creating the tables</st> <st c="23477">in HBase storage,
    we can integrate our HBase database into our</st> <st c="23541">Flask application.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23451">在HBase存储中创建表格后</st> <st c="23477">，我们可以将我们的HBase数据库集成到我们的</st>
    <st c="23541">Flask应用程序中。</st>
- en: <st c="23559">Establishing an HBase connection</st>
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23559">建立HBase连接</st>
- en: '<st c="23592">Many modern Python libraries</st> <st c="23621">that can integrate
    HBase into Flask are proprietary, such as</st> <st c="23682">this CData Python
    driver (</st>[<st c="23709">https://www.cdata.com/drivers/hbase/download/python/</st>](https://www.cdata.com/drivers/hbase/download/python/)<st
    c="23762">), which can utilize SQLAlchemy to manage HBase storage.</st> <st c="23820">But
    there is one reliable and popular Python driver in the</st> *<st c="23879">PyPI</st>*
    <st c="23883">repository that can integrate any Python application into Hbase:
    the</st> <st c="23953">HappyBase library.</st>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23592">许多现代Python库可以将HBase集成到Flask中，这些库是专有的，例如</st> <st c="23621">这个CData
    Python驱动程序（</st>[<st c="23709">https://www.cdata.com/drivers/hbase/download/python/</st>](https://www.cdata.com/drivers/hbase/download/python/)<st
    c="23762">），它可以利用SQLAlchemy来管理HBase存储。</st> <st c="23820">但是，在</st> *<st c="23879">PyPI</st>*
    <st c="23883">仓库中有一个可靠且流行的Python驱动程序，可以将任何Python应用程序集成到Hbase中：`HappyBase`库。</st>
- en: <st c="23971">The</st> `<st c="23976">happybase</st>` <st c="23985">module is
    a standard Python library that uses the</st> *<st c="24036">Python Thrift</st>*
    <st c="24049">library to connect to any HBase database using the</st> *<st c="24101">Thrift</st>*
    <st c="24107">service, which is already part of the Apache HBase</st> <st c="24159">2.5.5
    platform.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23971">`<st c="23976">happybase</st>` <st c="23985">模块是一个标准的Python库，它使用</st>
    *<st c="24036">Python Thrift</st>* <st c="24049">库通过</st> *<st c="24101">Thrift</st>*
    <st c="24107">服务连接到任何HBase数据库，该服务已经是Apache HBase</st> <st c="24159">2.5.5平台的一部分。</st>
- en: <st c="24174">To utilize the</st> `<st c="24190">happybase</st>` <st c="24199">module,
    install it using the</st> `<st c="24229">pip</st>` <st c="24232">command:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24174">要使用</st> `<st c="24190">happybase</st>` <st c="24199">模块，请使用</st>
    `<st c="24229">pip</st>` <st c="24232">命令安装：</st>
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="24263">For</st> *<st c="24268">Tutor Finder</st>* <st c="24280">to establish
    a connection to HBase and create multiple threads for reusable connections, the
    application factory function in</st> `<st c="24406">__init__.py</st>` <st c="24417">must
    import</st> `<st c="24430">ConnectionPool</st>` <st c="24444">from the</st> `<st
    c="24454">happybase</st>` <st c="24463">module and provide it the</st> `<st c="24490">host</st>`
    <st c="24494">and</st> `<st c="24499">port</st>` <st c="24503">values of the Thrift
    gateway, as well as the number of connections in the pool.</st> <st c="24584">The
    following script shows the application factory function,</st> `<st c="24645">create_app()</st>`<st
    c="24657">, that initiates the</st> `<st c="24678">happybase</st>` <st c="24687">setup:</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24263">为了</st> *<st c="24268">Tutor Finder</st>* <st c="24280">建立与 HBase
    的连接并创建多个线程以重用连接，`<st c="24406">__init__.py</st>` <st c="24417">中的应用程序工厂函数必须从 `<st
    c="24430">ConnectionPool</st>` <st c="24444">模块中导入</st> `<st c="24454">happybase</st>`
    <st c="24463">，并提供 Thrift 网关的</st> `<st c="24490">主机</st>` <st c="24494">和</st>
    `<st c="24499">端口</st>` <st c="24503">值，以及池中的连接数。</st> <st c="24584">以下脚本显示了初始化</st>
    `<st c="24678">happybase</st>` <st c="24687">设置的</st> `<st c="24645">create_app()</st>`<st
    c="24657">应用程序工厂函数：</st>
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="25016">The entry point to the HBase platform is the</st> `<st c="25062">Connection</st>`
    <st c="25072">class.</st> <st c="25080">The</st> `<st c="25084">Connection</st>`
    <st c="25094">class creates an open socket to the HBase database through the Thrift
    service.</st> <st c="25174">But</st> `<st c="25178">ConnectionPool</st>` <st c="25192">provides
    faster access than the single</st> `<st c="25232">Connection</st>` <st c="25242">instance,
    especially if the Flask application is in asynchronous mode.</st> <st c="25314">The
    only requirement is for the application to use a</st> `<st c="25367">with</st>`
    <st c="25371">context manager for the connection pool to spawn a</st> `<st c="25423">Connection</st>`
    <st c="25433">instance, assign a thread to it, and dispose of the thread when
    the transaction ends, eventually returning</st> <st c="25540">the connection’s
    state to</st> <st c="25567">the pool.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25016">HBase 平台的入口点是</st> `<st c="25062">Connection</st>` <st c="25072">类。</st>
    <st c="25080">`<st c="25084">Connection</st>` <st c="25094">类通过 Thrift 服务创建一个到
    HBase 数据库的开放套接字。</st> <st c="25174">但是</st> `<st c="25178">ConnectionPool</st>`
    <st c="25192">比单个</st> `<st c="25232">Connection</st>` <st c="25242">实例提供更快的访问速度，尤其是在
    Flask 应用程序处于异步模式时。</st> <st c="25314">唯一的要求是应用程序使用一个</st> `<st c="25367">with</st>`
    <st c="25371">上下文管理器</st>来为连接池生成一个</st> `<st c="25423">Connection</st>` <st c="25433">实例，分配一个线程给它，并在事务结束时处理线程，最终将连接的状态返回到</st>
    `<st c="25540">池中</st>` <st c="25567">。</st>
- en: <st c="25576">Let’s use</st> `<st c="25587">ConnectionPool</st>` <st c="25601">to
    build the</st> <st c="25615">repository layer.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25576">让我们使用</st> `<st c="25587">ConnectionPool</st>` <st c="25601">来构建</st>
    `<st c="25615">仓库层</st>。</st>
- en: <st c="25632">Building the repository layer</st>
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="25632">构建仓库层</st>
- en: <st c="25662">The</st> `<st c="25667">ConnectionPool</st>` <st c="25681">instance</st>
    <st c="25690">from</st> `<st c="25696">create_app()</st>` <st c="25708">provides
    the</st> `<st c="25722">Connection</st>` <st c="25732">instance that implements
    the CRUD transactions.</st> <st c="25781">But it needs a</st> `<st c="25796">with</st>`
    <st c="25800">context manager to spawn a</st> `<st c="25828">Connection</st>`
    <st c="25838">instance or reuse a connection state from the pool so that the thread
    can run the CRUD transactions using the</st> `<st c="25949">happybase</st>` <st
    c="25958">utility methods.</st> <st c="25976">The following script shows the repository
    class that uses the</st> `<st c="26038">ConnectionPool</st>` <st c="26052">instance
    to implement the CRUD transactions for the</st> `<st c="26105">payments</st>`
    <st c="26113">table:</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25662">从</st> `<st c="25667">ConnectionPool</st>` <st c="25681">实例</st>
    <st c="25690">中</st> `<st c="25696">create_app()</st>` <st c="25708">提供的</st>
    `<st c="25722">Connection</st>` <st c="25732">实例</st> <st c="25781">实现了 CRUD 事务。</st>
    <st c="25796">但它需要一个</st> `<st c="25800">with</st>` <st c="25828">上下文管理器</st>来生成一个</st>
    `<st c="25838">Connection</st>` <st c="25838">实例</st> 或从池中重用连接状态，以便线程可以使用</st>
    `<st c="25949">happybase</st>` <st c="25958">实用方法</st> <st c="25976">运行 CRUD 事务。</st>
    <st c="25976">以下脚本显示了使用</st> `<st c="26038">ConnectionPool</st>` <st c="26052">实例</st>
    来实现</st> `<st c="26105">payments</st>` <st c="26113">表</st> 的 CRUD 事务的仓库类：</st>
- en: '[PRE11]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="26674">The</st> `<st c="26679">PaymentRepository</st>` <st c="26696">class
    requires a</st> `<st c="26714">ConnectionPool</st>` <st c="26728">instance (</st>`<st
    c="26739">pool</st>`<st c="26744">) as a constructor argument</st> <st c="26772">for
    its instantiation.</st> <st c="26796">The</st> `<st c="26800">pool</st>` <st c="26804">object
    has a</st> `<st c="26818">connection()</st>` <st c="26830">method that returns
    an HBase connection that provides the</st> `<st c="26889">happybase</st>` <st
    c="26898">utility methods for CRUD transactions.</st> <st c="26938">With the help
    of a thread, the connection object has a</st> `<st c="26993">table()</st>` <st
    c="27000">utility that accesses the HBase table and returns a</st> `<st c="27053">Table</st>`
    <st c="27058">object that provides several methods to execute database transactions,
    such</st> <st c="27135">as</st> `<st c="27138">put()</st>`<st c="27143">.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26674">The</st>` `<st c="26679">PaymentRepository</st>` `<st c="26696">类需要一个`<st
    c="26714">ConnectionPool</st>` `<st c="26728">实例（`<st c="26739">pool</st>`）`作为其构造函数参数以进行实例化。</st>
    `<st c="26796">该`<st c="26800">pool</st>` `<st c="26804">对象有一个`<st c="26818">connection()</st>`
    `<st c="26830">方法，它返回一个HBase连接，该连接提供了`<st c="26889">happybase</st>` `<st c="26898">实用方法，用于CRUD事务。</st>`
    `<st c="26938">借助线程的帮助，连接对象有一个`<st c="26993">table()</st>` `<st c="27000">实用方法，它访问HBase表并返回一个`<st
    c="27053">Table</st>` `<st c="27058">对象，该对象提供了一些方法来执行数据库事务，例如`<st c="27138">put()</st>`
    `<st c="27143">。</st>'
- en: <st c="27144">The</st> `<st c="27149">put()</st>` <st c="27154">method performs
    both</st> *<st c="27176">INSERT</st>* <st c="27182">and</st> *<st c="27187">UPDATE</st>*
    <st c="27193">transactions.</st> <st c="27208">It requires</st> `<st c="27220">rowkey</st>`
    <st c="27226">as its primary parameter for inserting a record in dictionary format.</st>
    <st c="27297">The dictionary record consists of a</st> *<st c="27333">column qualifier-value
    pair</st>*<st c="27360">, wherein all the values should be byte strings or any
    type converted into</st> `<st c="27435">bytes</st>` <st c="27440">by the</st>
    `<st c="27448">encode('utf-8')</st>` <st c="27463">method.</st> <st c="27472">Also,</st>
    `<st c="27478">rowkey</st>` <st c="27484">should always be a byte string.</st>
    <st c="27517">The given</st> `<st c="27527">upsert_details()</st>` <st c="27543">inserts
    payment records into the</st> `<st c="27577">payments</st>` <st c="27585">table
    of the</st> <st c="27599">HBase database.</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27144">The</st>` `<st c="27149">put()</st>` `<st c="27154">方法执行了` *<st
    c="27176">INSERT</st>` *和` *<st c="27187">UPDATE</st>` *事务。它需要`<st c="27220">rowkey</st>`作为其主要参数，以便以字典格式插入记录。</st>
    `<st c="27297">字典记录由一个` *<st c="27333">列限定符-值对</st>` *组成，其中所有值都应该是字节字符串或任何转换为`<st
    c="27435">bytes</st>`的类型的值。</st> `<st c="27472">此外，`<st c="27478">rowkey</st>`
    `<st c="27484">应始终是字节字符串。</st>` `<st c="27517">给定的`<st c="27527">upsert_details()</st>`
    `<st c="27543">将支付记录插入到HBase数据库的`<st c="27577">payments</st>` `<st c="27585">表`中。</st>'
- en: <st c="27614">Aside from</st> `<st c="27626">put()</st>`<st c="27631">, the</st>
    `<st c="27637">Table</st>` <st c="27642">object has a</st> `<st c="27656">delete()</st>`
    <st c="27664">method that deletes a record using its</st> `<st c="27704">rowkey</st>`<st
    c="27710">. The following</st> `<st c="27726">delete_payment_details()</st>` <st
    c="27750">function of</st> `<st c="27763">PaymentRepository</st>` <st c="27780">highlights
    payment details being deleted from the</st> `<st c="27831">payments</st>` <st
    c="27839">table:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`<st c="27614">put()</st>`之外，`<st c="27637">Table</st>`对象还有一个`<st c="27656">delete()</st>`方法，它使用其`<st
    c="27704">rowkey</st>`来删除记录。以下`<st c="27726">delete_payment_details()</st>``<st
    c="27750">函数`<st c="27763">PaymentRepository</st>``<st c="27780">突出了从`<st c="27831">payments</st>``<st
    c="27839">表`中删除的支付详情：</st>
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="28082">Aside from</st> `<st c="28094">rowkey</st>`<st c="28100">, the</st>
    `<st c="28106">delete()</st>` <st c="28114">method</st> <st c="28121">needs the
    name of the column family or families in its</st> `<st c="28177">columns</st>`
    <st c="28184">parameter, which means deleting the whole record.</st> <st c="28235">But
    sometimes, deletion requires only removing the column qualifier(s) or column(s)
    instead of the entire row so that only the column qualifier name(s) appear in
    the</st> `<st c="28401">columns</st>` <st c="28408">parameter.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="28082">除了`<st c="28094">rowkey</st>`之外，`<st c="28106">delete()</st>`
    `<st c="28114">方法` `<st c="28121">需要其`<st c="28177">columns</st>` `<st c="28184">参数中的列族或列族的名称，这意味着删除整个记录。</st>`
    `<st c="28235">但有时，删除只需要删除列限定符（s）或列（s）而不是整个行，这样只有列限定符名称（s）出现在`<st c="28401">columns</st>`
    `<st c="28408">参数中。</st>`'
- en: <st c="28419">The</st> `<st c="28424">Table</st>` <st c="28429">object has a</st>
    `<st c="28443">rows()</st>` <st c="28449">method that returns a</st> `<st c="28472">Tuple</st>`
    <st c="28477">value or list of tuples, each containing</st> `<st c="28519">rowkey</st>`
    <st c="28525">and the record in</st> `<st c="28544">bytes</st>`<st c="28549">.
    This method has two parameters, the</st> *<st c="28587">row key</st>* <st c="28594">and</st>
    *<st c="28599">column family or families</st>* <st c="28624">of the data records
    in the search.</st> <st c="28660">Here,</st> `<st c="28666">select_records_ids()</st>`
    <st c="28686">returns a list of payment records based on a selected list of row
    keys with some specified</st> <st c="28778">column families:</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28419">`<st c="28424">Table</st>` <st c="28429">对象有一个`<st c="28443">rows()</st>`
    <st c="28449">方法，该方法返回一个`<st c="28472">Tuple</st>` <st c="28477">值或元组列表，每个元组包含`<st
    c="28519">rowkey</st>` <st c="28525">和以`<st c="28544">bytes</st>`<st c="28549">形式存储的记录。</st>
    此方法有两个参数，即搜索中数据记录的`<st c="28587">行键</st>` <st c="28594">和`<st c="28599">列族或列族</st>`
    <st c="28624">。</st> 这里，`<st c="28666">select_records_ids()</st>` <st c="28686">根据所选行键列表和一些指定的列族返回支付记录列表：</st>
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="29281">The</st> `<st c="29286">rows()</st>` <st c="29292">method returns
    a</st> `<st c="29310">Tuple</st>` <st c="29315">value or tuples</st> <st c="29331">containing
    the</st> *<st c="29347">row key</st>* <st c="29354">as the first element and the</st>
    *<st c="29384">records</st>* <st c="29391">in dictionary format as the second
    element.</st> <st c="29436">Thus, we only need to shift the dictionary part using
    a list comprehension, as depicted in the code.</st> <st c="29537">Also, decoding
    each dictionary of fields will avoid JSON errors in Flask during its</st> `<st
    c="29621">Response</st>` <st c="29629">generation.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29281">`<st c="29286">rows()</st>` <st c="29292">方法返回一个</st> `<st c="29310">Tuple</st>`
    <st c="29315">值或包含</st> *<st c="29347">行键</st>* <st c="29354">作为第一个元素和</st> *<st
    c="29384">字典格式的记录</st>* <st c="29391">作为第二个元素的元组。</st> <st c="29436">因此，我们只需要使用列表推导来移动字典部分，如代码所示。</st>
    <st c="29537">此外，解码每个字段字典将避免在Flask生成响应时的JSON错误。</st>
- en: <st c="29641">For its input, the</st> `<st c="29661">select_records_ids()</st>`
    <st c="29681">function can accept JSON requests containing the row keys of the
    records in search, as</st> <st c="29769">shown here:</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29641">对于其输入，`<st c="29661">select_records_ids()</st>` <st c="29681">函数可以接受包含搜索中记录行键的JSON请求，如下所示：</st>
    <st c="29769">这里：</st>
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="29825">Alternatively, it can accept both the row keys and the column
    families, such as for the following</st> <st c="29924">request data:</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29825">或者，它还可以接受行键和列族，例如以下</st> <st c="29924">请求数据：</st>
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: <st c="29991">It can also accept specific column qualifiers that need to appear
    in the search output, as shown in the</st> <st c="30095">following code:</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29991">它还可以接受需要在搜索输出中出现的特定列限定符，如下面的代码所示：</st> <st c="30095">以下代码：</st>
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: <st c="30215">Another way of retrieving data</st> <st c="30245">in the</st>
    `<st c="30253">happybase</st>` <st c="30262">module is through the</st> `<st c="30285">scan()</st>`
    <st c="30291">method, which returns a generator of tuples – similar tuples returned
    by</st> `<st c="30365">rows()</st>`<st c="30371">. Here,</st> `<st c="30379">select_all_records()</st>`
    <st c="30399">shows how to use</st> `<st c="30417">scan()</st>` <st c="30423">to
    retrieve all the</st> <st c="30444">payment records:</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30215">在`<st c="30253">happybase</st>` <st c="30262">模块中检索数据的另一种方法是使用`<st
    c="30285">scan()</st>` <st c="30291">方法，该方法返回一个元组的生成器——类似于`<st c="30365">rows()</st>`<st
    c="30371">返回的元组。</st> 这里，`<st c="30379">select_all_records()</st>` <st c="30399">展示了如何使用`<st
    c="30417">scan()</st>` <st c="30423">检索所有</st> `<st c="30444">支付记录：</st>`
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: <st c="30805">The method requires a</st> `<st c="30828">for</st>` <st c="30831">loop
    to extract all these records from the generator and decode all the details, which
    includes the column qualifier as the key and the value of each key, before adding
    them to a list.</st> <st c="31017">This retrieval consumes less running time than
    using lots of list and dictionary comprehensions</st> <st c="31113">with</st>
    `<st c="31118">rows()</st>`<st c="31124">.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30805">该方法需要一个</st> `<st c="30828">for</st>` <st c="30831">循环来从生成器中提取所有这些记录并解码所有详细信息，包括列限定符作为键和每个键的值，然后将它们添加到列表中。</st>
    <st c="31017">这种检索比使用许多列表和字典推导使用`<st c="31118">rows()</st>`<st c="31124">`消耗的运行时间更少。</st>
- en: <st c="31125">Another advantage</st> <st c="31143">of using</st> `<st c="31153">scan()</st>`
    <st c="31159">instead of</st> `<st c="31171">rows()</st>` <st c="31177">is its
    advanced feature to filter records using the predicate conditions on columns,
    similar to a</st> `<st c="31276">WHERE</st>` <st c="31281">clause in a SQL statement.</st>
    <st c="31309">The following query transaction retrieves all payment records with
    a specific</st> *<st c="31387">tutor ID</st>* <st c="31395">specified by</st>
    <st c="31409">the client:</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31125">使用</st> <st c="31143">`scan()`</st> <st c="31159">而不是</st> <st
    c="31171">`rows()`</st> 的另一个优点是其高级功能，可以通过列上的谓词条件来过滤记录，类似于 SQL 语句中的 `<st c="31276">WHERE</st>`
    <st c="31281">子句。</st> <st c="31309">以下查询事务检索所有具有特定</st> *<st c="31387">导师 ID</st>*
    <st c="31395">的支付记录，该 ID 由</st> <st c="31409">客户指定：</st>
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: <st c="31866">The</st> `<st c="31871">scan()</st>` <st c="31877">method has
    a</st> `<st c="31891">filter</st>` <st c="31897">parameter that accepts a</st>
    *<st c="31923">filter string</st>* <st c="31936">constituting the</st> *<st c="31954">filter
    class</st>* <st c="31966">and its</st> *<st c="31975">constructor arguments</st>*<st
    c="31996">, which will streamline the search.</st> <st c="32032">The</st> `<st
    c="32036">filter</st>` <st c="32042">parameter indicates what filter class to
    instantiate to build the appropriate search constraints.</st> <st c="32141">The
    given</st> `<st c="32151">select_records_tutor()</st>` <st c="32173">function
    uses</st> `<st c="32188">SingleColumnValueFilter</st>`<st c="32211">, which filters
    rows based on a value constraint given to the</st> *<st c="32273">column family</st>*<st
    c="32286">,</st> *<st c="32288">column qualifier</st>*<st c="32304">,</st> *<st
    c="32306">conditional operator</st>*<st c="32326">, and</st> `<st c="32332">BinaryComparator
    (binary)</st>`<st c="32357">. Aside from</st> `<st c="32370">SingleColumnValueFilter</st>`<st
    c="32393">, here are some widely used types of filter classes that can create
    search conditions for the</st> `<st c="32487">scan()</st>` <st c="32493">method:</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31866">`scan()`</st> <st c="31871">方法有一个</st> <st c="31877">`filter`</st>
    <st c="31891">参数，它接受一个</st> *<st c="31923">过滤字符串</st>* <st c="31936">，该字符串构成</st>
    *<st c="31954">过滤类</st>* <st c="31966">及其</st> *<st c="31975">构造函数参数</st>*<st
    c="31996">，这将简化搜索。</st> <st c="32032">`filter`</st> <st c="32042">参数指示要实例化哪个过滤类以构建适当的搜索约束。</st>
    <st c="32141">给定的</st> `<st c="32151">select_records_tutor()</st>` <st c="32173">函数使用</st>
    `<st c="32188">SingleColumnValueFilter</st>`<st c="32211">，它根据提供给</st> *<st c="32273">列族</st>*<st
    c="32286">，*<st c="32288">列限定符</st>*<st c="32304">，*<st c="32306">条件运算符</st>*<st
    c="32326">，以及</st> `<st c="32332">BinaryComparator (二进制)</st>`<st c="32357">的值约束来过滤行。</st>
    除了 `<st c="32370">SingleColumnValueFilter</st>`<st c="32393">之外，这里还有一些广泛使用的过滤类类型，可以为
    `<st c="32487">scan()</st>` <st c="32493">方法创建搜索条件：</st>
- en: '`<st c="32501">RowFilter</st>`<st c="32511">: Accepts a comparison operator
    and the preferred comparator (for example,</st> `<st c="32587">ByteComparator</st>`<st
    c="32601">,</st> `<st c="32603">RegexStringComparator</st>`<st c="32624">, and
    so on) needed to compare the indicated value with each</st> <st c="32685">row
    key.</st>'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="32501">RowFilter</st>`<st c="32511">：接受一个比较运算符和所需的比较器（例如，`<st c="32587">ByteComparator</st>`<st
    c="32601">，`<st c="32603">RegexStringComparator</st>`<st c="32624">，等等），用于将指示值与每一行的键进行比较。</st>'
- en: '`<st c="32693">QualifierFilter</st>`<st c="32709">: Accepts a conditional operator
    and the preferred comparator (for example,</st> `<st c="32786">ByteComparator</st>`<st
    c="32800">,</st> `<st c="32802">RegexStringComparator</st>`<st c="32823">, and
    so on) needed to compare the column qualifier name of each row with the</st> <st
    c="32901">given value.</st>'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="32693">QualifierFilter</st>`<st c="32709">：接受一个条件运算符和所需的比较器（例如，`<st
    c="32786">ByteComparator</st>`<st c="32800">，`<st c="32802">RegexStringComparator</st>`<st
    c="32823">，等等），用于将每一行的列限定符名称与给定的值进行比较。</st>'
- en: '`<st c="32913">ColumnRangeFilter</st>`<st c="32931">: Accepts the minimum range
    column and maximum range column and then checks if the indicated value falls between
    the range</st> <st c="33055">column values.</st>'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="32913">ColumnRangeFilter</st>`<st c="32931">：接受最小范围列和最大范围列，然后检查指示值是否位于列值范围内。</st>'
- en: '`<st c="33069">ValueFilter</st>`<st c="33081">: Accepts a conditional operator
    and the preferred comparator needed to compare the value to each</st> <st c="33180">field
    value.</st>'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="33069">ValueFilter</st>`<st c="33081">：接受一个条件运算符和所需的比较器，用于将值与每一字段的值进行比较。</st>'
- en: <st c="33192">Aside from</st> `<st c="33204">BinaryComparator</st>`<st c="33220">,
    other comparators that provide conversion and comparison methods</st> <st c="33286">for
    a filter class are</st> `<st c="33310">BinaryPrefixComparator</st>`<st c="33332">,</st>
    `<st c="33334">RegexStringComparator</st>`<st c="33355">,</st> <st c="33357">and</st>
    `<st c="33361">SubStringComparator</st>`<st c="33380">.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33192">除了</st> `<st c="33204">BinaryComparator</st>`<st c="33220">之外，其他提供转换和比较方法的比较器，用于过滤类，包括</st>
    `<st c="33310">BinaryPrefixComparator</st>`<st c="33332">、</st> `<st c="33334">RegexStringComparator</st>`<st
    c="33355">、</st> `<st c="33357">和</st> `<st c="33361">SubStringComparator</st>`<st
    c="33380">。</st>
- en: <st c="33381">In the next section, we’ll apply</st> `<st c="33415">PaymentsRepository</st>`
    <st c="33433">so that we can store and retrieve payment details in and from the</st>
    `<st c="33500">payments</st>` <st c="33508">table.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将应用<st c="33381">`PaymentsRepository`</st> <st c="33415">以便我们可以在`payments`
    <st c="33500">表</st>中存储和检索支付详情。</st>
- en: <st c="33515">Applying a repository to API functions</st>
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="33515">将仓库应用于 API 函数</st>
- en: <st c="33554">The following API function</st> <st c="33581">uses</st> `<st c="33587">upsert_details()</st>`
    <st c="33603">from</st> `<st c="33609">PaymentRepository</st>` <st c="33626">to
    perform an</st> *<st c="33641">INSERT</st>* <st c="33647">transaction after receiving
    JSON request data from</st> <st c="33699">the client:</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33554">以下 API 函数</st> <st c="33581">使用</st> `<st c="33587">upsert_details()`</st>
    <st c="33603">从</st> `<st c="33609">PaymentRepository</st>` <st c="33626">执行一个</st>
    *<st c="33641">INSERT</st> <st c="33647">事务</st>，在从客户端收到 JSON 请求数据后：</st>
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="34135">The repository’s</st> `<st c="34153">select_all_records()</st>`
    <st c="34173">provides the following</st> `<st c="34197">list_all_payments()</st>`
    <st c="34216">function to render</st> <st c="34235">all the records from the</st>
    `<st c="34261">payments</st>` <st c="34269">table:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34135">仓库的</st> `<st c="34153">select_all_records()</st>` <st c="34173">提供了以下</st>
    `<st c="34197">list_all_payments()</st>` <st c="34216">函数，用于渲染</st> `<st c="34235">所有来自`</st>
    `<st c="34261">payments</st>` <st c="34269">表的</st> `<st c="34235">记录：</st>
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="34473">Here,</st> `<st c="34480">pool</st>` <st c="34484">is the</st>
    `<st c="34492">ConnectionPool</st>` <st c="34506">instance that was created in
    the</st> `<st c="34540">create_app()</st>` <st c="34552">factory from the</st>
    `<st c="34570">__init__.py</st>` <st c="34581">file of the</st> `<st c="34594">modules</st>`
    <st c="34601">package.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34473">在这里，</st> `<st c="34480">pool</st>` <st c="34484">是</st> `<st
    c="34492">ConnectionPool</st>` <st c="34506">实例，该实例是在</st> `<st c="34540">create_app()</st>`
    <st c="34552">工厂中从</st> `<st c="34570">__init__.py</st>` <st c="34581">文件中的</st>
    `<st c="34594">modules</st>` <st c="34601">包创建的。</st>
- en: <st c="34610">Now, for</st> `<st c="34620">happybase</st>` <st c="34629">to
    work, start up the</st> *<st c="34652">thrift server</st>*<st c="34665">. Let’s
    showcase the Apache Thrift framework in the</st> <st c="34717">HBase platform.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34610">现在，为了使</st> `<st c="34620">happybase</st>` <st c="34629">工作，启动</st>
    *<st c="34652">thrift 服务器</st>**<st c="34665">。让我们在 HBase 平台上展示 Apache Thrift
    框架。</st>
- en: <st c="34732">Running the thrift server</st>
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="34732">运行 thrift 服务器</st>
- en: '`<st c="35027">hbase thrift start</st>` <st c="35045">command.</st> *<st c="35055">Figure
    7</st>**<st c="35063">.8</st>* <st c="35065">shows the logs after starting up
    the</st> <st c="35103">thrift server:</st>'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="35027">hbase thrift start</st>` <st c="35045">命令。</st> *<st c="35055">图
    7</st>**<st c="35063">.8</st>* <st c="35065">显示了启动 thrift 服务器后的日志：</st>'
- en: '![Figure 7.8 – Running a built-in HBase thrift server](img/B19383_07_008.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 运行内置的 HBase thrift 服务器](img/B19383_07_008.jpg)'
- en: <st c="35871">Figure 7.8 – Running a built-in HBase thrift server</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35871">图 7.8 – 运行内置的 HBase thrift 服务器</st>
- en: <st c="35922">Apache Thrift will only run if Apache HBase, Hadoop, and Zookeeper
    are</st> <st c="35994">all running.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35922">Apache Thrift 仅在 Apache HBase、Hadoop 和 Zookeeper 都运行时才会运行。</st>
- en: <st c="36006">The</st> `<st c="36011">happybase</st>` <st c="36020">module is
    non-Flask-specific, which means any Python client can use it to connect to the</st>
    `<st c="36110">HBase</st>` <st c="36115">server.</st> <st c="36124">The thrift
    server will always bridge between the client and HBase considering that the Python
    library uses the</st> *<st c="36235">Thrift 1</st>* <st c="36243">or</st> *<st
    c="36247">2</st>* <st c="36248">library to establish a connection.</st> <st c="36284">The</st>
    `<st c="36288">happybase</st>` <st c="36297">module uses the Thrift</st> <st c="36321">1
    library.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36006">The</st> `<st c="36011">happybase</st>` <st c="36020">模块是非Flask特定的，这意味着任何Python客户端都可以使用它来连接到</st>
    `<st c="36110">HBase</st>` <st c="36115">服务器。</st> <st c="36124">考虑到Python库使用</st>
    *<st c="36235">Thrift 1</st>* <st c="36243">或</st> *<st c="36247">2</st>* <st
    c="36248">库来建立连接，thrift服务器将始终在客户端和HBase之间建立桥梁。</st> <st c="36284">`happybase`
    <st c="36288">模块使用Thrift</st> <st c="36297">1库。</st>
- en: <st c="36331">Now that we’ve created Flask repository transactions for the HBase
    database, let’s explore a type of NoSQL storage that uses columns and rows for</st>
    <st c="36478">data storage.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36331">现在我们已经为HBase数据库创建了Flask仓库事务，让我们探索一种使用列和行进行</st> <st c="36478">数据存储的NoSQL存储。</st>
- en: <st c="36491">Utilizing the column storage of Apache Cassandra</st>
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="36491">利用Apache Cassandra的列存储</st>
- en: '**<st c="36540">Apache Cassandra</st>** <st c="36557">is a</st> *<st c="36563">column-family</st>*
    <st c="36576">NoSQL database</st> <st c="36591">that can also hold</st> <st c="36610">large
    amounts of data.</st> <st c="36634">HBase can share big data</st> <st c="36658">across
    its regions using auto-sharding, which makes HBase horizontally scalable.</st>
    <st c="36740">Likewise, Cassandra supports adding more nodes horizontally to improve
    server throughput, a characteristic of horizontal scaling.</st> <st c="36870">But
    there are also some differences between the two storages in terms of their architectures,
    table read and write performances, data</st> <st c="37004">modeling approaches,
    and</st> <st c="37029">query</st> <st c="37035">languages.</st>'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="36540">Apache Cassandra</st>** <st c="36557">是一个*<st c="36563">列族</st>*
    <st c="36576">NoSQL数据库</st> <st c="36591">，也可以存储大量数据。</st> <st c="36610">HBase可以通过自动分片在各个区域之间共享大数据，这使得HBase具有水平可扩展性。</st>
    <st c="36634">同样，Cassandra支持水平添加更多节点以提高服务器吞吐量，这是水平扩展的一个特性。</st> <st c="36740">但是，在架构、表读写性能、数据</st>
    <st c="37004">建模方法以及</st> <st c="37029">查询</st> <st c="37035">语言方面，这两种存储之间也存在一些差异。</st>'
- en: <st c="37045">Let’s start by designing our</st> `<st c="37075">course</st>`<st
    c="37081">,</st> `<st c="37083">degree_level</st>`<st c="37095">,</st> `<st c="37097">student</st>`<st
    c="37104">, and</st> `<st c="37110">student_perf</st>` <st c="37122">Cassandra
    tables.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37045">让我们首先设计我们的</st> `<st c="37075">课程</st>`<st c="37081">，</st> `<st
    c="37083">学位水平</st>`<st c="37095">，</st> `<st c="37097">学生</st>`<st c="37104">，以及</st>
    `<st c="37110">学生表现</st>` <st c="37122">Cassandra表。</st>
- en: <st c="37140">Designing Cassandra tables</st>
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="37140">设计Cassandra表</st>
- en: <st c="37167">Unlike HBase, Cassandra stores</st> <st c="37198">its data per
    row, grouping all column fields, thus why the data model approach is a</st> *<st
    c="37283">column family</st>*<st c="37296">. Its database transactions are atomic,
    isolated, and durable, but with eventual</st> <st c="37376">or tunable consistency,
    so it doesn’t offer an</st> **<st c="37424">Atomicity, Consistency, Isolation,
    Durability</st>** <st c="37469">(</st>**<st c="37471">ACID</st>**<st c="37475">)
    model like a</st> **<st c="37491">relational database management system</st>**
    <st c="37528">(</st>**<st c="37530">RDBMS</st>**<st c="37535">).</st> <st c="37539">Sometimes,
    the Cassandra setup favors</st> <st c="37576">higher-availability performance
    over atomic and</st> <st c="37625">isolated transactions.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37167">与HBase不同，Cassandra按行存储其数据，将所有列字段分组，因此数据模型方法是一个*<st c="37283">列族</st>*<st
    c="37296">。其数据库事务是原子性、隔离性和持久性的，但具有最终</st> <st c="37376">或可调的一致性，因此它不提供类似关系数据库管理系统（</st>
    **<st c="37424">原子性、一致性、隔离性、持久性</st>** <st c="37469">(</st> **<st c="37471">ACID</st>**
    <st c="37475">)）的模型，如</st> **<st c="37491">关系数据库管理系统</st>** <st c="37528">(</st>
    **<st c="37530">RDBMS</st>** <st c="37535">)。</st> <st c="37539">有时，Cassandra的配置更倾向于</st>
    <st c="37576">高可用性性能而不是原子性和</st> <st c="37625">隔离性事务。</st>
- en: <st c="37647">This project used</st> *<st c="37666">draw.io</st>* <st c="37673">to
    design the tables in Cassandra using UML class diagrams.</st> *<st c="37734">Figure
    7</st>**<st c="37742">.9</st>* <st c="37744">shows the data model for the project’s
    Cassandra</st> <st c="37794">data storage:</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37647">该项目使用了</st> *<st c="37666">draw.io</st>* <st c="37673">来使用 UML
    类图设计 Cassandra 中的表。</st> *<st c="37734">图 7.9</st>**<st c="37742">.9</st>* <st
    c="37744">显示了项目 Cassandra 数据存储的数据模型：</st> <st c="37794">数据存储：</st>
- en: '![Figure 7.9 – Cassandra table designs using UML](img/B19383_07_009.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 使用 UML 设计的 Cassandra 表](img/B19383_07_009.jpg)'
- en: <st c="38370">Figure 7.9 – Cassandra table designs using UML</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38370">图 7.9 – 使用 UML 设计的 Cassandra 表</st>
- en: <st c="38416">Each Cassandra table must</st> <st c="38442">have a primary key.</st>
    <st c="38463">But, unlike in RDBMS, a primary key in</st> *<st c="38502">column-family</st>*
    <st c="38515">storage has at least one</st> *<st c="38541">partition key</st>*
    <st c="38554">and zero or more</st> *<st c="38572">clustering keys</st>*<st c="38587">.
    Since Cassandra storage runs on a distributed environment of clusters and nodes,
    the</st> *<st c="38674">partition key</st>* <st c="38687">evenly distributes the
    row data across the clustered storage.</st> <st c="38750">On the other hand, the</st>
    *<st c="38773">clustering key</st>* <st c="38787">sorts and manages the rows of
    data in a table.</st> <st c="38835">Also, the performance of the query transactions
    is the ultimate basis of the table design; the faster the query will be, the better</st>
    <st c="38967">the design.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38416">每个 Cassandra 表都必须</st> <st c="38442">有一个主键。</st> <st c="38463">但是，与
    RDBMS 不同，*<st c="38502">列族</st>* <st c="38515">存储中的主键至少有一个</st> *<st c="38541">分区键</st>*
    <st c="38554>和零个或多个</st> *<st c="38572">聚类键</st>*<st c="38587">。由于 Cassandra 存储运行在集群和节点分布的环境中，因此</st>
    *<st c="38674">分区键</st>* <st c="38687">将行数据均匀分布在集群存储中。</st> <st c="38750">另一方面，</st>
    *<st c="38773">聚类键</st>* <st c="38787">对表中的数据进行排序和管理。</st> <st c="38835">此外，查询事务的性能是表设计的最终依据；查询越快，设计就越好</st>
    <st c="38967">。</st>
- en: <st c="38978">Let’s install Apache Cassandra so that we can realize our</st>
    <st c="39037">table design.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38978">让我们安装 Apache Cassandra，以便我们可以实现我们的</st> <st c="39037">表设计。</st>
- en: <st c="39050">Installing and configuring Apache Cassandra</st>
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="39050">安装和配置 Apache Cassandra</st>
- en: <st c="39094">Download the ZIP</st> <st c="39111">file for Apache</st> <st c="39127">Cassandra
    at</st> [<st c="39141">https://cassandra.apache.org/_/download.html</st>](https://cassandra.apache.org/_/download.html)<st
    c="39185">. The</st> **<st c="39191">general availability</st>** <st c="39211">(</st>**<st
    c="39213">GA</st>**<st c="39215">) versions 3.x and below</st> <st c="39240">support
    Windows but not version 4.x.</st> <st c="39278">Since the project uses version
    4.1.3, Windows PowerShell with WSL2 installed must be used to configure and run</st>
    <st c="39389">the server.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39094">在</st> [<st c="39141">https://cassandra.apache.org/_/download.html</st>](https://cassandra.apache.org/_/download.html)<st
    c="39185">下载 Apache Cassandra 的 ZIP 文件。3.x 及以下版本</st> **<st c="39191">通用可用性</st>**
    <st c="39211">(</st>**<st c="39213">GA</st>**<st c="39215">) 版本支持 Windows，但不支持
    4.x 版本。</st> <st c="39240">由于项目使用的是 4.1.3 版本，因此必须使用安装了 WSL2 的 Windows PowerShell
    来配置和运行</st> <st c="39389">服务器。</st>
- en: <st c="39400">After unzipping the file, enable the Ubuntu firewall using the</st>
    `<st c="39464">sudo</st>` <st c="39468">command:</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39400">解压文件后，使用</st> `<st c="39464">sudo</st>` <st c="39468">命令启用 Ubuntu
    防火墙：</st>
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="39493">Then, allow non-WSL clients to access ports</st> *<st c="39538">7000</st>*
    <st c="39542">(port for cluster communication),</st> *<st c="39577">9042</st>*
    <st c="39581">(default port for client access), and</st> *<st c="39620">7199</st>*
    <st c="39624">(port for JMX) using the following</st> `<st c="39660">sudo</st>`
    <st c="39664">commands:</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39493">然后，使用以下</st> `<st c="39660">sudo</st>` <st c="39664">命令允许非 WSL
    客户端访问端口</st> *<st c="39538">7000</st>* <st c="39542">(集群通信端口)，</st> *<st c="39577">9042</st>*
    <st c="39581">(客户端访问的默认端口)，以及</st> *<st c="39620">7199</st>* <st c="39624">(JMX
    端口)：</st>
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <st c="39734">Apache Cassandra 4.1.3 requires</st> *<st c="39767">Java 11</st>*
    <st c="39774">as its virtual machine, so run the following</st> `<st c="39820">sudo</st>`
    <st c="39824">command to install Java SDK 11 in the</st> <st c="39863">Ubuntu
    environment:</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39734">Apache Cassandra 4.1.3 需要</st> *<st c="39767">Java 11</st>* <st
    c="39774">作为其虚拟机，因此运行以下</st> `<st c="39820">sudo</st>` <st c="39824">命令在 Ubuntu
    环境中安装 Java SDK 11：</st>
- en: '[PRE23]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <st c="39914">After, go to the</st> `<st c="39932">/conf</st>` <st c="39937">directory
    of Cassandra’s installation folder and open the</st> `<st c="39996">jvm11-server.options</st>`
    <st c="40016">file.</st> <st c="40023">Comment all the</st> *<st c="40039">CMS</st>*
    <st c="40042">GC option details and uncomment</st> *<st c="40075">G1GC</st>*<st
    c="40079">, the default GC option for</st> <st c="40107">Java 11.</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39914">之后，进入Cassandra安装文件夹的</st> `<st c="39932">/conf</st>` <st c="39937">目录并打开</st>
    `<st c="39996">jvm11-server.options</st>` <st c="40016">文件。</st> <st c="40023">注释掉所有</st>
    *<st c="40039">CMS</st>* <st c="40042">GC选项的详细信息，并取消注释</st> *<st c="40075">G1GC</st>*<st
    c="40079">，这是Java 11的默认GC选项。</st>
- en: <st c="40115">Finally, run the following command from the</st> `<st c="40160">/</st>``<st
    c="40161">conf</st>` <st c="40165">directory:</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40115">最后，从</st> `<st c="40160">/</st>``<st c="40161">conf</st>` <st
    c="40165">目录中运行以下命令：</st>
- en: '[PRE24]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <st c="40189">To shut down the Cassandra server, use the</st> `<st c="40233">nodetool</st>`
    `<st c="40242">drain</st>` <st c="40247">command.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40189">要关闭Cassandra服务器，请使用</st> `<st c="40233">nodetool</st>` `<st c="40242">drain</st>`
    <st c="40247">命令。</st>
- en: <st c="40256">Now, let’s open the Cassandra shell client to create</st> <st
    c="40309">the project’s tables and learn</st> **<st c="40341">Cassandra Query
    Language</st>** <st c="40365">(</st>**<st c="40367">CQL</st>**<st c="40370">)
    commands.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40256">现在，让我们打开Cassandra shell客户端来创建</st> <st c="40309">项目的表，并学习</st>
    **<st c="40341">Cassandra查询语言</st>** <st c="40365">(</st>**<st c="40367">CQL</st>**<st
    c="40370">) 命令。</st>
- en: <st c="40382">Running the CQL shell client</st>
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="40382">运行CQL shell客户端</st>
- en: <st c="40411">Cassandra 4.1.3 has</st> <st c="40431">a query language called</st>
    `<st c="40625">cqlsh</st>` <st c="40630">command in the</st> `<st c="40646">/conf</st>`
    <st c="40651">directory.</st> *<st c="40663">Figure 7</st>**<st c="40671">.10</st>*
    <st c="40674">shows the process of opening the</st> *<st c="40708">CQL</st>* *<st
    c="40712">shell</st>* <st c="40717">(</st>`<st c="40719">cqlsh</st>`<st c="40724">):</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40411">Cassandra 4.1.3有一个名为</st> `<st c="40625">cqlsh</st>` <st c="40630">的查询语言命令，位于</st>
    `<st c="40646">/conf</st>` <st c="40651">目录中。</st> *<st c="40663">图7</st>**<st
    c="40671">.10</st>* <st c="40674">显示了打开</st> *<st c="40708">CQL</st>* *<st c="40712">shell</st>*
    <st c="40717">(</st>`<st c="40719">cqlsh</st>`<st c="40724">):</st>
- en: '![Figure 7.10 – Running the cqlsh command](img/B19383_07_010.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图7.10 – 运行cqlsh命令](img/B19383_07_010.jpg)'
- en: <st c="40952">Figure 7.10 – Running the cqlsh command</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40952">图7.10 – 运行cqlsh命令</st>
- en: <st c="40991">CQL has</st> `<st c="41130">create</st>` <st c="41136">|</st>`<st
    c="41138">alter</st>` <st c="41143">|</st> `<st c="41146">drop keyspace</st>`<st
    c="41159">,</st> `<st c="41161">create</st>` <st c="41167">|</st> `<st c="41170">alter</st>`
    <st c="41175">|</st> `<st c="41178">drop table</st>`<st c="41188">,</st> `<st
    c="41190">use</st>`<st c="41193">, and</st> `<st c="41199">truncate</st>` <st
    c="41207">statements.</st> <st c="41220">For DML, it has</st> `<st c="41236">insert</st>`<st
    c="41242">,</st> `<st c="41244">delete</st>`<st c="41250">,</st> `<st c="41252">update</st>`<st
    c="41258">, and</st> `<st c="41264">batch</st>` <st c="41269">commands.</st> <st
    c="41280">For query transactions, it utilizes the</st> `<st c="41320">select</st>`
    <st c="41326">clause like in SQL.</st> <st c="41347">However, the</st> `<st c="41360">where</st>`
    <st c="41365">clause is limited only to partition, clustering, and composite keys.</st>
    <st c="41435">Some CQL commands end with</st> <st c="41462">a semicolon.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40991">CQL有</st> `<st c="41130">create</st>` <st c="41136">|</st> <st
    c="41138">alter</st>` <st c="41143">|</st> `<st c="41146">drop keyspace</st>`<st
    c="41159">,</st> `<st c="41161">create</st>` <st c="41167">|</st> `<st c="41170">alter</st>`
    <st c="41175">|</st> `<st c="41178">drop table</st>`<st c="41188">,</st> `<st
    c="41190">use</st>`<st c="41193">, 和</st> `<st c="41199">truncate</st>` <st c="41207">语句。</st>
    <st c="41220">对于DML，它有</st> `<st c="41236">insert</st>`<st c="41242">,</st> `<st
    c="41244">delete</st>`<st c="41250">,</st> `<st c="41252">update</st>`<st c="41258">,
    和</st> `<st c="41264">batch</st>` <st c="41269">命令。</st> <st c="41280">对于查询事务，它使用SQL中的</st>
    `<st c="41320">select</st>` <st c="41326">子句。</st> <st c="41347">然而，</st> `<st
    c="41360">where</st>` <st c="41365">子句仅限于分区、聚簇和复合键。</st> <st c="41435">一些CQL命令以</st>
    <st c="41462">分号</st> 结尾。
- en: <st c="41474">CQL has general-purpose</st> <st c="41498">commands such as</st>
    `<st c="41516">show version</st>`<st c="41528">,</st> `<st c="41530">expand</st>`<st
    c="41536">, and</st> `<st c="41542">describe</st>`<st c="41550">. To check all
    the clusters, run the</st> `<st c="41587">describe cluster</st>` <st c="41603">command.</st>
    <st c="41613">To check all the keyspaces, run the</st> `<st c="41649">describe
    keyspaces</st>` <st c="41667">command.</st> <st c="41677">To list all the tables
    in a keyspace, run the</st> `<st c="41723">describe tables</st>` <st c="41738">command.</st>
    *<st c="41748">Figure 7</st>**<st c="41756">.11</st>* <st c="41759">shows a series
    of CQL commands that view Cassandra’s</st> <st c="41813">data storage:</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41474">CQL具有通用</st> <st c="41498">命令，例如</st> `<st c="41516">show version</st>`<st
    c="41528">,</st> `<st c="41530">expand</st>`<st c="41536">, 和</st> `<st c="41542">describe</st>`<st
    c="41550">。要检查所有集群，请运行</st> `<st c="41587">describe cluster</st>` <st c="41603">命令。</st>
    <st c="41613">要检查所有键空间，请运行</st> `<st c="41649">describe keyspaces</st>` <st c="41667">命令。</st>
    <st c="41677">要列出键空间中的所有表，请运行</st> `<st c="41723">describe tables</st>` <st c="41738">命令。</st>
    *<st c="41748">图7</st>**<st c="41756">.11</st>* <st c="41759">显示了查看Cassandra数据存储的一系列CQL命令：</st>
- en: '![Figure 7.11 – Running CQL general-purpose commands](img/B19383_07_011.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图7.11 – 运行CQL通用命令](img/B19383_07_011.jpg)'
- en: <st c="42521">Figure 7.11 – Running CQL general-purpose commands</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42521">图7.11 – 运行CQL通用命令</st>
- en: <st c="42571">Running the</st> `<st c="42584">describe</st>` <st c="42592">command
    on a table returns the metadata description of the Cassandra table, as shown in</st>
    *<st c="42681">Figure 7</st>**<st c="42689">.12</st>*<st c="42692">:</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42571">在表上运行</st> `<st c="42584">describe</st>` <st c="42592">命令将返回Cassandra表的元数据描述，如图</st>
    *<st c="42681">图7</st>**<st c="42689">.12</st>*<st c="42692">所示：</st>
- en: '![Figure 7.12 – Running the describe command on tables](img/B19383_07_012.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![图7.12 – 在表上运行describe命令](img/B19383_07_012.jpg)'
- en: <st c="43661">Figure 7.12 – Running the describe command on tables</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43661">图7.12 – 在表上运行describe命令</st>
- en: <st c="43713">A</st> *<st c="43716">cluster</st>* <st c="43723">contains more
    than one data</st> <st c="43751">center, and a</st> *<st c="43766">data center</st>*
    <st c="43777">can have more than one node.</st> <st c="43807">Each</st> *<st c="43812">node</st>*
    <st c="43816">must have a keyspace to hold all the tables, materialized views,
    user-defined types, functions, and aggregates.</st> <st c="43929">So, the first
    thing you must do with the CQL shell client is run the</st> `<st c="43998">create
    keyspace</st>` <st c="44013">command before building the project’s tables.</st>
    <st c="44060">The following code creates</st> `<st c="44087">packtspace</st>`<st
    c="44097">, which holds the tables of</st> <st c="44125">our application:</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43713">一个</st> *<st c="43716">cluster</st>* <st c="43723">包含多个数据中心，一个</st>
    *<st c="43766">data center</st>* <st c="43777">可以有多个节点。</st> <st c="43807">每个</st>
    *<st c="43812">node</st>* <st c="43816">必须有一个键空间来存储所有表、物化视图、用户定义的类型、函数和聚合。</st>
    <st c="43929">因此，在使用CQL shell客户端构建项目表之前，你必须首先运行</st> `<st c="43998">create keyspace</st>`
    <st c="44013">命令。</st> <st c="44060">以下代码创建</st> `<st c="44087">packtspace</st>`<st
    c="44097">，它存储我们应用程序的表：</st>
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: <st c="44272">The</st> *<st c="44277">replication strategy</st>* <st c="44297">that’s
    used is called</st> `<st c="44320">NetworkTopologyStrategy</st>`<st c="44343">.
    It makes</st> `<st c="44354">packtspace</st>` <st c="44364">open for replication
    and data storage expansion in the long run and also applicable for</st> <st c="44453">production
    deployment.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44272">所使用的复制策略称为</st> *<st c="44277">replication strategy</st>* <st
    c="44297">，称为</st> `<st c="44320">NetworkTopologyStrategy</st>`<st c="44343">。它使</st>
    `<st c="44354">packtspace</st>` <st c="44364">在长期内对复制和数据存储扩展开放，并且也适用于</st> <st
    c="44453">生产部署。</st>
- en: <st c="44475">After creating</st> `<st c="44491">packspace</st>`<st c="44500">,
    you can manually create the</st> `<st c="44530">course</st>`<st c="44536">,</st>
    `<st c="44538">student</st>`<st c="44545">,</st> `<st c="44547">degree_level</st>`<st
    c="44559">, and</st> `<st c="44565">student_perf</st>` <st c="44577">tables in</st>
    `<st c="44588">keyspace</st>` <st c="44596">using the CQL command.</st> <st c="44620">However,
    DataStax has a</st> `<st c="44644">cassandra-driver</st>` <st c="44660">module
    that establishes a database connection to Cassandra and generates tables using
    the entity or model classes.</st> <st c="44776">Let’s use this external module</st>
    <st c="44806">to build the application’s</st> <st c="44834">model layer.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44475">在创建</st> `<st c="44491">packspace</st>`<st c="44500">后，您可以使用CQL命令在</st>
    `<st c="44588">keyspace</st>` <st c="44596">中手动创建</st> `<st c="44530">course</st>`<st
    c="44536">,</st> `<st c="44538">student</st>`<st c="44545">,</st> `<st c="44547">degree_level</st>`<st
    c="44559">, 和</st> `<st c="44565">student_perf</st>` <st c="44577">表。</st> <st
    c="44620">然而，DataStax有一个</st> `<st c="44644">cassandra-driver</st>` <st c="44660">模块，该模块可以建立到Cassandra的数据库连接，并使用实体或模型类生成表。</st>
    <st c="44776">让我们使用这个外部模块</st> <st c="44806">来构建应用程序的</st> <st c="44834">模型层。</st>
- en: <st c="44846">Establishing a database connection</st>
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="44846">建立数据库连接</st>
- en: <st c="44881">The</st> `<st c="44886">cassandra-driver</st>` <st c="44902">module
    is a Python</st> <st c="44921">client driver that integrates Apache Cassandra
    into the Flask application.</st> <st c="44997">It contains classes and methods
    that will only be available after installing the module using the</st> `<st c="45095">pip</st>`
    <st c="45098">command:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44881">cassandra-driver</st> <st c="44902">模块是一个Python</st> <st c="44921">客户端驱动程序，它将Apache
    Cassandra集成到Flask应用程序中。</st> <st c="44997">它包含在安装模块后才会可用的类和方法，使用</st> `<st c="45095">pip</st>`
    <st c="45098">命令安装模块：</st>
- en: '[PRE26]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="45136">For our</st> *<st c="45145">Tutor Finder</st>* <st c="45157">to
    establish a Cassandra database connection, import</st> `<st c="45211">setup()</st>`
    <st c="45218">from the</st> `<st c="45228">cassandra.cqlengine.connection</st>`
    <st c="45258">module in the</st> `<st c="45273">__init__.py</st>` <st c="45284">file
    of the</st> `<st c="45297">modules</st>` <st c="45304">package and invoke</st>
    `<st c="45324">setup()</st>` <st c="45331">inside the</st> `<st c="45343">create_app()</st>`
    <st c="45355">factory method with the arguments for its</st> `<st c="45398">hosts</st>`<st
    c="45403">,</st> `<st c="45405">default_keyspace</st>`<st c="45421">, and</st>
    `<st c="45427">protocol_version</st>` <st c="45443">parameters.</st> <st c="45456">The
    following snippet shows the</st> <st c="45488">whole process:</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45136">为了我们的</st> *<st c="45145">导师搜索器</st>* <st c="45157">建立Cassandra数据库连接，从</st>
    `<st c="45211">setup()</st>` <st c="45218">导入</st> `<st c="45228">cassandra.cqlengine.connection</st>`
    <st c="45258">模块中的</st> `<st c="45273">__init__.py</st>` <st c="45284">文件中的</st>
    `<st c="45297">modules</st>` <st c="45304">包，并在</st> `<st c="45343">create_app()</st>`
    <st c="45355">工厂方法中调用</st> `<st c="45324">setup()</st>` <st c="45331">，传入其</st>
    `<st c="45398">hosts</st>`<st c="45403">,</st> `<st c="45405">default_keyspace</st>`<st
    c="45421">, 和</st> `<st c="45427">protocol_version</st>` <st c="45443">参数。</st>
    <st c="45456">以下代码片段展示了整个</st> <st c="45488">过程：</st>
- en: '[PRE27]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: import uuid <st c="46941">from cassandra.cqlengine.columns import UUID, Text,
    Float,</st> <st c="46999">DateTime, Integer, Blob</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: import uuid <st c="46941">从cassandra.cqlengine.columns导入UUID, Text, Float,</st>
    <st c="46999">DateTime, Integer, Blob</st>
- en: <st c="47023">from cassandra.cqlengine.models import Model</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47023">从cassandra.cqlengine.models导入Model</st>
- en: '<st c="47068">from cassandra.cqlengine.management import sync_table</st> class
    Course(<st c="47136">Model</st>):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="47068">从cassandra.cqlengine.management模块中导入sync_table</st> class Course(<st
    c="47136">Model</st>):'
- en: id      = <st c="47151">UUID</st>(primary_key=True, default=uuid.uuid4)
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: id      = <st c="47151">UUID</st>(primary_key=True, default=uuid.uuid4)
- en: code    = <st c="47202">Text</st>(primary_key=True, max_length=20, required=True,clustering_order="ASC")
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: code    = <st c="47202">Text</st>(primary_key=True, max_length=20, required=True,
    clustering_order="ASC")
- en: title   = <st c="47287">Text</st>(required=True, max_length=100)
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: title   = <st c="47287">Text</st>(required=True, max_length=100)
- en: req_hrs = <st c="47334">Float</st>(required=True, default = 0)
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: req_hrs = <st c="47334">Float</st>(required=True, default = 0)
- en: total_cost = <st c="47382">Float</st>(required=True, default = 0.0)
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: total_cost = <st c="47382">Float</st>(required=True, default = 0.0)
- en: course_offered  = <st c="47436">DateTime</st>()
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: course_offered  = <st c="47436">DateTime</st>()
- en: level = <st c="47456">Integer</st>(required=True, default=-1)
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: level = <st c="47456">Integer</st>(required=True, default=-1)
- en: description   = <st c="47506">Text</st>(required=False, max_length=200) <st
    c="47544">def get_json(self):</st> return {
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description   = <st c="47506">Text</st>(required=False, max_length=200) <st
    c="47544">def get_json(self):</st> return {
- en: '''id'': str(self.id),'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''id'': str(self.id),'
- en: '''code'': self.code,'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''code'': self.code,'
- en: '''title'' : self.title,'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''title'' : self.title,'
- en: '''req_hrs'': self.req_hrs,'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''req_hrs'': self.req_hrs,'
- en: '''total_cost'': self.total_cost,'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''total_cost'': self.total_cost,'
- en: '''course_offered'': self.course_offered,'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''course_offered'': self.course_offered,'
- en: '''level'': self.level,'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''level'': self.level,'
- en: '''description'': self.description'
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''description'': self.description'
- en: '}'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'class DegreeLevel(<st c="48401">Model</st>):'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 'class DegreeLevel(<st c="48401">模型</st>):'
- en: id = <st c="48416">UUID</st>(primary_key=True, default=uuid.uuid4)
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: id = <st c="48416">UUID</st>(主键=True, 默认=uuid.uuid4)
- en: code = <st c="48467">Integer</st>(primary_key=True,required=True, clustering_order="ASC")
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: code = <st c="48467">整数</st>(主键=True, 必填=True, 聚簇顺序="ASC")
- en: description = <st c="48546">Text</st>(required=True)
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: description = <st c="48546">文本</st>(必填=True)
- en: … … … … … …
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: … … … … … …
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: 'class Student(Model):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 'class Student(模型):'
- en: id = UUID(primary_key=True, default=uuid.uuid4)
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: id = UUID(主键=True, 默认=uuid.uuid4)
- en: std_id = Text(primary_key=True,required=True, max_length=12, clustering_order="ASC")
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: std_id = Text(主键=True, 必填=True, 最大长度=12, 聚簇顺序="ASC")
- en: firstname = Text(required=True, max_length=60)
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: firstname = Text(必填=True, 最大长度=60)
- en: midname = Text(required=True, max_length=60)
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: midname = Text(必填=True, 最大长度=60)
- en: … … … … … …
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: … … … … … …
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: 'class StudentPerf(Model):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 'class StudentPerf(模型):'
- en: id = UUID(primary_key=True, default=uuid.uuid4)
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: id = UUID(主键=True, 默认=uuid.uuid4)
- en: std_id = Text(primary_key=True,required=True, max_length=12)
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: std_id = Text(主键=True, 必填=True, 最大长度=12)
- en: course_code = Text(required=True, max_length=20)
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: course_code = Text(必填=True, 最大长度=20)
- en: … … … … … …
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: … … … … … …
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: … … … … … …
- en: sync_table(Course)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: sync_table(Course)
- en: sync_table(DegreeLevel)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: sync_table(DegreeLevel)
- en: sync_table(Student)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: sync_table(Student)
- en: sync_table(StudentPerf)
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: sync_table(StudentPerf)
- en: '[PRE29]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="51070">from modules.models.db.cassandra_models import Course</st> from
    datetime import datetime
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51070">从 modules.models.db.cassandra_models 导入 Course</st> from datetime
    import datetime
- en: from typing import Dict, Any
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: from typing import Dict, Any
- en: 'class CourseRepository:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 'class CourseRepository:'
- en: 'def __init__(self):'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: pass
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: pass
- en: 'def insert_course(self, details:Dict[str, Any]):'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def insert_course(self, details:Dict[str, Any]):'
- en: 'try: <st c="51287">Course.create(**details)</st> return True'
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="51287">Course.create(**details)</st> return True'
- en: 'except Exception as e:'
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE30]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'def update_course(self, details:Dict[str, Any]):'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update_course(self, details:Dict[str, Any]):'
- en: 'try: <st c="51622">rec = Course.objects.filter(</st><st c="51650">code=str(details[''code'']))</st><st
    c="51677">.allow_filtering().get()</st> del details[''id'']'
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="51622">rec = Course.objects.filter(</st><st c="51650">code=str(details[''code'']))</st><st
    c="51677">.allow_filtering().get()</st> del details[''id'']'
- en: del details['code'] <st c="51740">rec.update(**details)</st> return True
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: del details['code'] <st c="51740">rec.update(**details)</st> return True
- en: 'except Exception as e:'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE31]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'def delete_course_code(self, code):'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 'def delete_course_code(self, code):'
- en: 'try: <st c="52369">rec = Course.objects.filter(code=code)</st><st c="52407">.allow_filtering().get()</st><st
    c="52431">rec.delete()</st> return True'
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="52369">rec = Course.objects.filter(code=code)</st><st c="52407">.allow_filtering().get()</st><st
    c="52431">rec.delete()</st> return True'
- en: 'except Exception as e:'
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'def search_by_code(self, code:str): <st c="53087">result = Course.objects.filter(code=code).allow_filtering().get()</st><st
    c="53152">records = dict(result)</st> return records'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 'def search_by_code(self, code:str): <st c="53087">result = Course.objects.filter(code=code).allow_filtering().get()</st><st
    c="53152">records = dict(result)</st> return records'
- en: 'def search_all_courses(self): <st c="53221">result = Course.objects.all()</st><st
    c="53250">records = [course.get_json() for course in result]</st> return records'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def search_all_courses(self): <st c="53221">result = Course.objects.all()</st><st
    c="53250">records = [course.get_json() for course in result]</st> return records'
- en: '[PRE33]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: sudo apt-add-repository ppa:redislabs/redis
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-add-repository ppa:redislabs/redis
- en: sudo apt-get update
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get update
- en: sudo apt-get upgrade
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get upgrade
- en: sudo apt-get install redis-server
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: sudo apt-get install redis-server
- en: '[PRE34]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: pip install redis-om
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: pip install redis-om
- en: '[PRE35]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '<st c="60274">import redis</st> def create_app(config_file):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="60274">导入 redis</st> def create_app(config_file):'
- en: app = Flask(__name__)
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = Flask(__name__)
- en: app.config.from_file(config_file, toml.load) <st c="60478">redis</st> in the
    URI indicates that the connection is a Redis standalone one to database <st c="60563">0</st>
    in localhost at port <st c="60586">6379</st>. All responses of the <st c="60613">redis-om</st>
    transactions are decoded into strings because the <st c="60672">decode_responses</st>
    parameter is assigned a value of <st c="60722">True</st>. All these string results
    are in <st c="60760">UTF-8</st> encoding.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.config.from_file(config_file, toml.load) <st c="60478">redis</st> 在 URI
    中表示连接是 Redis 独立数据库 <st c="60563">0</st> 在 localhost 的 <st c="60586">6379</st>
    端口。所有 <st c="60613">redis-om</st> 事务的响应都解码为字符串，因为 <st c="60672">decode_responses</st>
    参数被分配了 <st c="60722">True</st> 的值。所有这些字符串结果都是 <st c="60760">UTF-8</st> 编码。
- en: <st c="60775">At this point, the</st> `<st c="60795">redis-om</st>` <st c="60803">module
    is ready</st> <st c="60819">to build the application’s</st> <st c="60847">model
    layer.</st>
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60775">在此阶段，</st> `<st c="60795">redis-om</st>` <st c="60803">模块已准备好</st>
    <st c="60819">构建应用程序的</st> <st c="60847">模型层。</st>
- en: <st c="60859">Implementing the model layer</st>
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="60859">实现模型层</st>
- en: '`<st c="61031">redis-py</st>` <st c="61039">module.</st> <st c="61048">Each
    model class contains the hash fields with types validated by Pydantic validators.</st>
    <st c="61135">Once instantiated, the model object will hold the values of the
    keys before inserting them into</st> <st c="61230">the database with the auto-generated</st>
    **<st c="61268">hash value</st>** <st c="61278">or</st> **<st c="61282">pk</st>**<st
    c="61284">.</st>'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="61031">redis-py</st>` <st c="61039">模块。</st> <st c="61048">每个模型类都包含由Pydantic验证器验证的类型哈希字段。</st>
    <st c="61135">一旦实例化，模型对象将持有键的值，在将它们插入</st> <st c="61230">数据库时，使用自动生成的</st> **<st
    c="61268">哈希值</st>** <st c="61278">或</st> **<st c="61282">pk</st>**<st c="61284">。</st>'
- en: <st c="61285">The</st> `<st c="61290">redis-om</st>` <st c="61298">module has
    the</st> `<st c="61314">HashModel</st>` <st c="61323">class, which will implement
    the entity classes of the application.</st> <st c="61391">The</st> `<st c="61395">HashModel</st>`
    <st c="61404">class is a representation of a Redis hash.</st> <st c="61448">It
    captures the key-value pairs and uses its instance methods to manage the data.</st>
    <st c="61530">It automatically generates the primary key or hash key for each
    model object.</st> <st c="61608">The following are the</st> `<st c="61630">HashModel</st>`
    <st c="61639">classes for the</st> *<st c="61656">course</st>*<st c="61662">,</st>
    *<st c="61664">student</st>*<st c="61671">, and</st> *<st c="61677">tutor</st>*
    <st c="61682">data:</st>
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="61285">The</st> `<st c="61290">redis-om</st>` <st c="61298">模块具有</st>
    `<st c="61314">HashModel</st>` <st c="61323">类，该类将实现应用程序的实体类。</st> <st c="61391">The</st>
    `<st c="61395">HashModel</st>` <st c="61404">类是Redis哈希的表示。</st> <st c="61448">它捕获键值对，并使用其实例方法来管理数据。</st>
    <st c="61530">它为每个模型对象自动生成主键或哈希键。</st> <st c="61608">以下是为</st> `<st c="61630">HashModel</st>`
    <st c="61639">类创建的</st> *<st c="61656">课程</st>*, *<st c="61664">学生</st>*, 和 *<st
    c="61671">导师</st> <st c="61682">数据：</st>
- en: '[PRE36]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: <st c="63322">from modules.models.db.redis_models import SearchCourse</st> from
    typing import Dict, Any
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63322">from modules.models.db.redis_models import SearchCourse</st> from
    typing import Dict, Any
- en: 'class SearchCourseRepository:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SearchCourseRepository:'
- en: 'def __init__(self):'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def __init__(self):'
- en: pass
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: pass
- en: 'def insert_course(self, details:Dict[str, Any]):'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def insert_course(self, details:Dict[str, Any]):'
- en: 'try: <st c="63517">course = SearchCourse(**details)</st><st c="63549">course.save()</st>
    return True'
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="63517">课程 = SearchCourse(**details)</st><st c="63549">课程.save()</st>
    return True'
- en: 'except Exception as e:'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE37]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'def update_course(self, details:Dict[str, Any]):'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 'def update_course(self, details:Dict[str, Any]):'
- en: 'try: <st c="64071">record = SearchCourse.get(details[''pk''])</st><st c="64111">record.update(**details)</st>
    return True'
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="64071">记录 = SearchCourse.get(details[''pk''])</st><st c="64111">记录.update(**details)</st>
    return True'
- en: 'except Exception as e:'
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE38]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'def delete_course(self, pk):'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 'def delete_course(self, pk):'
- en: 'try: <st c="64389">SearchCourse.delete(pk)</st> return True'
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="64389">SearchCourse.delete(pk)</st> return True'
- en: 'except Exception as e:'
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'except Exception as e:'
- en: print(e)
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: '[PRE39]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'def select_course(self, pk):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 'def select_course(self, pk):'
- en: 'try: <st c="64992">record = SearchCourse.get(pk)</st><st c="65021">return record.dict()</st>
    except Exception as e:'
  id: totrans-295
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="64992">记录 = SearchCourse.get(pk)</st><st c="65021">return 记录.dict()</st>
    except Exception as e:'
- en: print(e)
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return None
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return None
- en: 'def select_all_course(self):'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def select_all_course(self):'
- en: records = list() <st c="65133">for id in SearchCourse.all_pks():</st><st c="65166">records.append(SearchCourse.get(id).dict())</st>
    return records
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: records = list() <st c="65133">for id in SearchCourse.all_pks():</st><st c="65166">records.append(SearchCourse.get(id).dict())</st>
    return records
- en: '[PRE40]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '{'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '{'
- en: '"records": ['
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"records": ['
- en: '{'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"code": "PY-201",'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"code": "PY-201",'
- en: '"description": "Advanced Python",'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"description": "高级Python",'
- en: '"level": 3, <st c="65496">"pk": "01HDH2VPZBGJJ16JKE3KE7RGPQ",</st> "req_hrs":
    50.0,'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"level": 3, <st c="65496">"pk": "01HDH2VPZBGJJ16JKE3KE7RGPQ",</st> "req_hrs":
    50.0,'
- en: '"title": "Advanced Python Programming",'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"title": "高级Python编程",'
- en: '"total_cost": 15000.0'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"total_cost": 15000.0'
- en: '},'
  id: totrans-309
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '{'
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '"code": "PY-101",'
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"code": "PY-101",'
- en: '"description": "Intro to Python programming",'
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"description": "Python编程入门",'
- en: '"level": 1, <st c="65692">"pk": "01HDH2SVYR7AYMRD28RE6HSHYB",</st> "req_hrs":
    45.0,'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"level": 1, <st c="65692">"pk": "01HDH2SVYR7AYMRD28RE6HSHYB",</st> "req_hrs":
    45.0,'
- en: '"title": "Python Basics",'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"title": "Python基础",'
- en: '"total_cost": 5000.0'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '"total_cost": 5000.0'
- en: '},'
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '},'
- en: '[PRE41]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: mongod.exe --dbpath="c:\data\db"
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: mongod.exe --dbpath="c:\data\db"
- en: '[PRE42]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '<st c="69233">from mongoengine.connection import connect</st> def create_app(config_file):'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="69233">from mongoengine.connection 导入 连接</st> def 创建应用(配置文件):'
- en: app = Flask(__name__)
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = Flask(__name__)
- en: app.config.from_file(config_file, toml.load <st c="69455">connect()</st> method
    requires <st c="69481">db name</st>, <st c="69490">host</st>, <st c="69496">port</st>,
    and the type of <st c="69518">UUID</st> the server will use to recognize the UUID
    primary key. This can be <st c="69590">unspecified</st>, <st c="69603">standard</st>,
    <st c="69613">pythonLegacy</st>, <st c="69627">javaLegacy</st>, or <st c="69642">csharpLegacy</st>.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.config.from_file(配置文件, toml.load <st c="69455">连接()</st> 方法需要 <st c="69481">数据库名</st>，<st
    c="69490">主机</st>，<st c="69496">端口</st>，以及服务器将用于识别 UUID 主键的 <st c="69518">UUID</st>
    类型。这可以是 <st c="69590">未指定</st>，<st c="69603">标准</st>，<st c="69613">pythonLegacy</st>，<st
    c="69627">javaLegacy</st>，或 <st c="69642">csharpLegacy</st>。
- en: <st c="69655">On the other hand, the client</st> <st c="69685">can invoke the</st>
    `<st c="69701">disconnect()</st>` <st c="69713">method to close</st> <st c="69730">the
    connection.</st>
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="69655">另一方面，客户端</st> <st c="69685">可以调用</st> `<st c="69701">断开连接()</st>`
    <st c="69713">方法来关闭</st> <st c="69730">连接。</st>
- en: <st c="69745">Now, let’s build the model layer using the helper classes from
    the</st> `<st c="69813">flask-mongoengine</st>` <st c="69830">module.</st>
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="69745">现在，让我们使用来自</st> `<st c="69813">flask-mongoengine</st>` <st c="69830">模块的辅助类来构建模型层。</st>
- en: <st c="69838">Building the model layer</st>
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="69838">构建模型层</st>
- en: <st c="69863">The</st> `<st c="69868">flask-mongoengine</st>` <st c="69885">module
    has a</st> `<st c="70151">Document</st>` <st c="70159">base class to build the
    login details of</st> <st c="70201">our application:</st>
  id: totrans-326
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="69863">`<st c="69868">flask-mongoengine</st>` <st c="69885">模块有一个</st>
    `<st c="70151">文档</st>` <st c="70159">基类来构建我们应用的登录详细信息：</st>
- en: '[PRE43]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: from typing import Dict, Any
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: from typing 导入 Dict, Any
- en: from modules.models.db.mongo_models import TutorLogin
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: from 模块.模型.db.mongo_models 导入 导师登录
- en: import json
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: import json
- en: 'class TutorLoginRepository:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 'class 导师登录存储库:'
- en: 'def insert_login(self, details:Dict[str, Any]) -> bool:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def 插入登录(self, 详细信息: Dict[str, Any]) -> bool:'
- en: 'try: <st c="74051">login = TutorLogin(**details)</st><st c="74080">login.save()</st>
    except Exception as e:'
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="74051">登录 = 导师登录(**详细信息)</st><st c="74080">登录保存()</st> except Exception
    as e:'
- en: print(e)
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 True
- en: '[PRE44]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'def update_login(self, id:int, details:Dict[str, Any]) -> bool:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 更新登录(self, id: int, 详细信息: Dict[str, Any]) -> bool:'
- en: 'try: <st c="74894">login = TutorLogin.objects(id=id).get()</st><st c="74933">login.update(**details)</st>
    except:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="74894">登录 = 导师登录对象(id=id).获取()</st><st c="74933">登录更新(**详细信息)</st>
    except:'
- en: return False
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 True
- en: '[PRE45]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'def delete_login(self, id:int) -> bool:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 删除登录(self, id: int) -> bool:'
- en: 'try: <st c="75360">login = TutorLogin.objects(id=id).get()</st><st c="75399">login.delete()</st>
    except:'
  id: totrans-344
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="75360">登录 = 导师登录对象(id=id).获取()</st><st c="75399">登录删除()</st> except:'
- en: return False
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 True
- en: '[PRE46]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: <st c="75840">def get_all_login(self):</st><st c="75865">login = TutorLogin.objects()</st>
    return json.loads(login.to_json()) <st c="75930">def get_login(self, id:int):</st><st
    c="75958">login = TutorLogin.objects(id=id).get()</st><st c="75998">return login.to_json()</st><st
    c="76021">def get_login_username(self, username:str,</st> <st c="76064">password:str):</st><st
    c="76079">login = TutorLogin.objects(username=username,</st> <st c="76125">password=password).get()</st>
    return login.to_json()
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="75840">def 获取所有登录(self):</st><st c="75865">登录 = 导师登录对象()</st> return
    json.loads(登录.to_json()) <st c="75930">def 获取登录(self, id: int):</st><st c="75958">登录
    = 导师登录对象(id=id).获取()</st><st c="75998">返回 登录.to_json()</st><st c="76021">def 获取登录用户名(self,
    用户名: str,</st> <st c="76064">密码: str):</st><st c="76079">登录 = 导师登录对象(username=用户名,</st>
    <st c="76125">密码=密码).获取()</st> return 登录.to_json()'
- en: '[PRE47]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: from typing import Dict, Any
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: from typing 导入 Dict, Any
- en: from modules.models.db.mongo_models import TutorLogin, Tutor
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: from 模块.模型.db.mongo_models 导入 导师登录, 导师
- en: 'class TutorProfileRepository:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 'class 导师档案存储库:'
- en: 'def add_tutor_profile(self, details:Dict[str, Any]) -> bool:'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'def 添加导师档案(self, 详细信息: Dict[str, Any]) -> bool:'
- en: 'try: <st c="76949">login = TutorLogin.objects(id=details[''id''])</st> <st
    c="76993">.get()</st> del details[''id''] <st c="77018">profile = Tutor(**details)</st><st
    c="77044">login.update(tutor=profile)</st> except Exception as e:'
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="76949">登录 = 导师登录对象(id=详细信息[''id''])</st> <st c="76993">.获取()</st>
    del 详细信息[''id''] <st c="77018">档案 = 导师(**详细信息)</st><st c="77044">登录更新(导师=档案)</st>
    except Exception as e:'
- en: print(e)
  id: totrans-355
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 True
- en: '[PRE48]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'def delete_tutor_profile(self, id:int) -> bool:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 'def 删除导师档案(self, id: int) -> bool:'
- en: 'try: <st c="77462">login = TutorLogin.objects(id=id).get()</st><st c="77501">login.update(tutor=None)</st>
    except Exception as e:'
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'try: <st c="77462">登录 = 导师登录对象(id=id).获取()</st><st c="77501">登录更新(导师=None)</st>
    except Exception as e:'
- en: print(e)
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 False
- en: return True
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回 True
- en: '[PRE49]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: from typing import Dict, Any
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: from typing import Dict, Any
- en: from modules.models.db.mongo_models import Savings, TutorLogin
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: from modules.models.db.mongo_models import Savings, TutorLogin
- en: 'class SavingsRepository: <st c="78396">def add_savings(self, details:Dict[str,
    Any]):</st> try: <st c="78448">login = TutorLogin.objects(id=details[''id''])</st>
    <st c="78492">.get()</st><st c="78498">del details[''id'']</st><st c="78516">savings
    = Savings(**details)</st><st c="78545">login.update(push__tutor__savings=savings)</st>
    except Exception as e:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 'class SavingsRepository: <st c="78396">def add_savings(self, details:Dict[str,
    Any]):</st> try: <st c="78448">login = TutorLogin.objects(id=details[''id''])</st>
    <st c="78492">.get()</st><st c="78498">del details[''id'']</st><st c="78516">savings
    = Savings(**details)</st><st c="78545">login.update(push__tutor__savings=savings)</st>
    except Exception as e:'
- en: print(e)
  id: totrans-368
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-369
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: '[PRE50]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '<st c="78843">def delete_savings(self, details:Dict[str, Any]):</st> try: <st
    c="78899">login = TutorLogin.objects(id=details[''id''])</st> .get() <st c="78950">login.update(pull__tutor__savings__acct_number=</st>
    <st c="78997">details[''acct_number''])</st> except Exception as e:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="78843">def delete_savings(self, details:Dict[str, Any]):</st> try: <st
    c="78899">login = TutorLogin.objects(id=details[''id''])</st> .get() <st c="78950">login.update(pull__tutor__savings__acct_number=</st>
    <st c="78997">details[''acct_number''])</st> except Exception as e:'
- en: print(e)
  id: totrans-373
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: print(e)
- en: return False
  id: totrans-374
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return False
- en: return True
  id: totrans-375
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: return True
- en: '[PRE51]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: pip install couchbase
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: pip 安装 couchbase
- en: '[PRE52]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: <st c="83840">from couchbase.auth import PasswordAuthenticator</st>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83840">from couchbase.auth import PasswordAuthenticator</st>
- en: <st c="83889">from couchbase.cluster import Cluster</st>
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="83889">from couchbase.cluster import Cluster</st>
- en: '<st c="83927">from couchbase.options import ClusterOptions</st> def create_app(config_file):'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="83927">from couchbase.options import ClusterOptions</st> def create_app(config_file):'
- en: app = Flask(__name__)
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app = Flask(__name__)
- en: app.config.from_file(config_file, toml.load) <st c="84069">auth = PasswordAuthenticator("sjctrags",
    "packt2255",)</st><st c="84123">cluster = Cluster('couchbase://localhost',</st>
    <st c="84166">ClusterOptions(auth))</st> cluster.wait_until_ready(timedelta(seconds=5))
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: app.config.from_file(config_file, toml.load) <st c="84069">auth = PasswordAuthenticator("sjctrags",
    "packt2255",)</st><st c="84123">cluster = Cluster('couchbase://localhost',</st>
    <st c="84166">ClusterOptions(auth))</st> cluster.wait_until_ready(timedelta(seconds=5))
- en: global cb <st c="84285">Cluster</st> object has a <st c="84306">wait_until_ready()</st>
    method that pings to the Couchbase services regarding the connection status and
    returns control to <st c="84424">create_app()</st> once the connection is ready.
    But calling this method slows down the startup of the Flask server. Our application
    has only invoked the method for experimentation purposes.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 全局 cb <st c="84285">Cluster</st> 对象有一个 <st c="84306">wait_until_ready()</st>
    方法，它会ping Couchbase服务以检查连接状态，并在连接就绪后返回控制权给 <st c="84424">create_app()</st>。但是调用此方法会减慢Flask服务器的启动速度。我们的应用程序仅出于实验目的调用了该方法。
- en: <st c="84608">After a successful</st> <st c="84628">setup, we must ensure the</st>
    `<st c="84654">Bucket</st>` <st c="84660">object is ready for implementing the</st>
    <st c="84698">repository layer.</st>
  id: totrans-385
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="84608">在成功</st> `<st c="84628">设置</st>` `<st c="84654">Bucket</st>`
    `<st c="84660">对象后，我们必须确保</st>` `<st c="84698">存储层</st>` `<st c="84698">可以实施。</st>`'
- en: <st c="84715">Creating the repository layer</st>
  id: totrans-386
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="84715">创建存储层</st>
- en: <st c="84745">The repository layer</st> <st c="84766">needs the</st> `<st c="84777">Bucket</st>`
    <st c="84783">object from</st> `<st c="84796">create_app()</st>` <st c="84808">to
    implement the CRUD transactions.</st> <st c="84845">The</st> `<st c="84849">Bucket</st>`
    <st c="84855">object has a</st> `<st c="84869">scope()</st>` <st c="84876">method
    that will access the container space that contains the collections.</st> <st c="84952">It
    returns a</st> `<st c="84965">Scope</st>` <st c="84970">object that emits</st>
    `<st c="84989">collection()</st>`<st c="85001">, which retrieves the preferred
    document collections.</st> <st c="85055">Here,</st> `<st c="85061">DirectMessageRepository</st>`
    <st c="85084">manages all the direct messages that students send to trainers and</st>
    <st c="85152">vice versa:</st>
  id: totrans-387
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="84745">存储层</st> <st c="84766">需要</st> `<st c="84777">Bucket</st>` <st
    c="84783">对象从</st> `<st c="84796">create_app()</st>` <st c="84808">中实现CRUD事务。</st>
    `<st c="84849">Bucket</st>` <st c="84855">对象有一个</st> `<st c="84869">scope()</st>`
    <st c="84876">方法，它将访问包含集合的容器空间。</st> `<st c="84952">它返回一个</st> `<st c="84965">Scope</st>`
    <st c="84970">对象，该对象会发出</st> `<st c="84989">collection()</st>`<st c="85001">，以检索首选文档集合。</st>
    `<st c="85055">在此处，</st>` `<st c="85061">DirectMessageRepository</st>` <st c="85084">管理学生向教练发送的所有直接消息以及</st>
    `<st c="85152">反之亦然：</st>`
- en: '[PRE53]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: <st c="85455">The</st> `<st c="85460">dm_insert()</st>` <st c="85471">method
    gives us access to the</st> `<st c="85502">tfs</st>` <st c="85505">scope and its</st>
    `<st c="85520">direct_messages</st>` <st c="85535">document collections.</st>
    <st c="85558">Its main goal is to insert the details of a chat message between
    the tutor and trainer into the document collection using the given key through
    the collection’s</st> `<st c="85719">insert()</st>` <st c="85727">method.</st>
  id: totrans-389
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="85455">The</st>` `<st c="85460">dm_insert()</st>` <st c="85471">方法使我们能够访问</st>
    `<st c="85502">tfs</st>` <st c="85505">范围及其</st> `<st c="85520">direct_messages</st>`
    <st c="85535">文档集合。</st> <st c="85558">其主要目标是使用集合的</st> `<st c="85719">insert()</st>`
    <st c="85727">方法通过给定的键将导师和训练师之间的聊天消息的详细信息插入文档集合。</st>'
- en: <st c="85735">On the other hand, the</st> `<st c="85759">update_dm()</st>` <st
    c="85770">method uses the collection’s</st> `<st c="85800">upsert()</st>` <st
    c="85808">method to update a JSON document using</st> <st c="85848">a key:</st>
  id: totrans-390
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="85735">另一方面，</st>` `<st c="85759">update_dm()</st>` <st c="85770">方法使用集合的</st>
    `<st c="85800">upsert()</st>` <st c="85808">方法通过键来更新JSON文档：</st>'
- en: '[PRE54]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: <st c="86115">The collection’s</st> `<st c="86133">remove()</st>` <st c="86141">method
    deletes</st> <st c="86156">a document from the collection.</st> <st c="86189">This
    can be seen in the following</st> `<st c="86223">delete_dm()</st>` <st c="86234">transaction,
    where it removes a chat message using</st> <st c="86286">its</st> `<st c="86290">key</st>`<st
    c="86293">:</st>
  id: totrans-392
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="86115">集合的</st>` `<st c="86133">remove()</st>` <st c="86141">方法从集合中删除一个文档。</st>
    <st c="86189">这可以在以下</st> `<st c="86223">delete_dm()</st>` <st c="86234">事务中看到，其中它使用</st>
    `<st c="86286">其</st>` `<st c="86290">键</st>`<st c="86293">删除一个聊天消息：</st>'
- en: '[PRE55]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: <st c="86551">Couchbase, unlike MongoDB, uses a SQL-like</st> <st c="86594">mechanism
    called</st> *<st c="86612">N1QL</st>* <st c="86616">to retrieve documents.</st>
    <st c="86640">The following</st> *<st c="86654">DELETE</st>* <st c="86660">transaction
    uses the N1QL query transaction instead of the collection’s</st> `<st c="86733">delete()</st>`
    <st c="86741">method:</st>
  id: totrans-394
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Couchbase与MongoDB不同，使用一种类似SQL的机制，称为*<st c="86612">N1QL</st>*来检索文档。<st c="86616">以下</st>
    *<st c="86654">DELETE</st>* <st c="86660">事务使用N1QL查询事务而不是集合的</st> `<st c="86733">delete()</st>`
    <st c="86741">方法：</st>
- en: '[PRE56]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: <st c="86969">The</st> `<st c="86974">Scope</st>` <st c="86979">instance, derived
    from the</st> `<st c="87007">Bucket</st>` <st c="87013">object’s</st> `<st c="87023">scope()</st>`
    <st c="87030">method, has a</st> `<st c="87045">query()</st>` <st c="87052">method
    that executes a query statement in string form.</st> <st c="87108">The query statement
    should have its collection and field names enclosed in ticks (</st>[PRE57]<st
    c="87193">), while its string constraint values should be in single quotes.</st>
    <st c="87260">Thus, we have the</st> ``<st c="87278">delete from `direct_messages`
    where `sender_id` LIKE '{sender},'</st>`` <st c="87342">query statement in</st>
    `<st c="87362">delete_dm_sender()</st>`<st c="87380">, where</st> `<st c="87388">sender</st>`
    <st c="87394">is a</st> <st c="87400">parameter value.</st>
  id: totrans-396
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="86969">The</st>` `<st c="86974">Scope</st>` <st c="86979">实例，由</st>
    `<st c="87007">Bucket</st>` <st c="87013">对象的</st> `<st c="87023">scope()</st>`
    <st c="87030">方法派生而来，有一个</st> `<st c="87045">query()</st>` <st c="87052">方法，用于执行字符串形式的查询语句。</st>
    <st c="87108">查询语句应将集合和字段名称用引号括起来（</st>[PRE57]<st c="87193">），而其字符串约束值应使用单引号。</st>
    <st c="87260">因此，我们有了</st> ``<st c="87278">delete from `direct_messages` where
    `sender_id` LIKE ''{sender},''</st>`` <st c="87342">查询语句在</st> `<st c="87362">delete_dm_sender()</st>`<st
    c="87380">中，其中</st> `<st c="87388">sender</st>` <st c="87394">是一个</st> <st c="87400">参数值。</st>'
- en: <st c="87416">The advantage of using N1QL queries in</st> *<st c="87456">DELETE</st>*
    <st c="87462">and</st> *<st c="87467">UPDATE</st>* <st c="87473">transactions
    is that the key is not the only basis</st> <st c="87524">for performing these
    operations.</st> <st c="87558">The</st> *<st c="87562">DELETE</st>* <st c="87568">operation
    can base its document removal on other fields, such as removing a chat message
    using the given</st> <st c="87674">sender ID:</st>
  id: totrans-397
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="87416">在</st> *<st c="87456">DELETE</st>* <st c="87462">和</st> *<st
    c="87467">UPDATE</st>* <st c="87473">事务中使用N1QL查询的优势在于，键不是执行这些操作的唯一依据。</st> <st
    c="87524">*<st c="87562">DELETE</st>* <st c="87568">操作可以基于其他字段来删除文档，例如使用给定的</st>
    <st c="87674">sender ID</st> <st c="87678">删除聊天消息：</st>'
- en: '[PRE58]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '*<st c="87904">N1QL</st>* <st c="87909">is popular in retrieving JSON documents
    from the keyspace with or without constraints.</st> <st c="87997">The following
    query transaction uses the</st> *<st c="88038">SELECT</st>* <st c="88044">query
    statement to retrieve all the documents in the</st> `<st c="88098">direct_messages</st>`
    <st c="88113">collections:</st>'
  id: totrans-399
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="87904">N1QL</st>* <st c="87909">在从键空间中检索 JSON 文档时，无论是否有约束，都很受欢迎。</st>
    <st c="87997">以下查询事务使用</st> *<st c="88038">SELECT</st>* <st c="88044">查询语句来检索</st>
    `<st c="88098">direct_messages</st>` <st c="88113">集合中的所有文档：</st>'
- en: '[PRE59]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: <st c="88327">Couchbase can be a suitable form of backend storage for Flask
    applications when managing a dump of JSON data.</st> <st c="88438">Flask and Couchbase
    can build fast, scalable, and efficient microservices or distributed applications
    with rapid development and less database administration.</st> <st c="88597">However,
    compared to HBase, Redis, Cassandra, MongoDB, and Couchbase, Flask can integrate</st>
    <st c="88686">with graph databases, such as Neo4J, for</st> <st c="88728">graph-related
    algorithms.</st>
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="88327">Couchbase 可以是 Flask 应用程序管理 JSON 数据转储的合适后端存储形式。</st> <st c="88438">Flask
    和 Couchbase 可以构建快速、可扩展且高效的微服务或分布式应用程序，具有快速开发和较少的数据库管理。</st> <st c="88597">然而，与
    HBase、Redis、Cassandra、MongoDB 和 Couchbase 相比，Flask 可以与图数据库，如 Neo4J，集成以进行</st>
    <st c="88686">图相关算法。</st>
- en: <st c="88753">Establishing a data relationship with Neo4J</st>
  id: totrans-402
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="88753">与 Neo4J 建立数据关系</st>
- en: '**<st c="88797">Neo4J</st>** <st c="88803">is a NoSQL database that focuses</st>
    <st c="88836">on relationships</st> <st c="88853">between data.</st> <st c="88868">Instead</st>
    <st c="88875">of documents, it stores nodes, relationships, and the properties
    that link these nodes.</st> <st c="88964">Neo4J is also known as a popular graph
    database because the concept relies on a graph model composed of nodes and lines
    directed</st> <st c="89093">between nodes.</st>'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**<st c="88797">Neo4J</st>** <st c="88803">是一个专注于数据之间关系的 NoSQL 数据库。</st> <st
    c="88836">它不存储文档，而是存储节点、关系以及连接这些节点的属性。</st> <st c="88964">Neo4J 也因其基于由节点和节点之间有向线组成的图模型的概念而被称为流行的图数据库。</st>'
- en: <st c="89107">Before integrating our application into the Neo4J database, we
    must install the current version of the Neo4J platform using</st> <st c="89232">Neo4J
    Desktop.</st>
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="89107">在将我们的应用程序集成到 Neo4J 数据库之前，我们必须使用 Neo4J 桌面安装当前版本的 Neo4J 平台。</st>
    <st c="89232">。</st>
- en: <st c="89246">Installing Neo4J Desktop</st>
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="89246">安装 Neo4J 桌面</st>
- en: <st c="89271">Neo4J Desktop provides</st> <st c="89294">a local development
    environment and includes all the functionality needed to learn the database, from
    creating a custom local database to starting</st> <st c="89441">the Neo4J browser.</st>
    <st c="89461">Its installer can be found</st> <st c="89488">at</st> [<st c="89491">https://neo4j.com/download/</st>](https://neo4j.com/download/)<st
    c="89518">.</st>
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="89271">Neo4J 桌面提供了一个本地开发环境，并包括学习数据库所需的所有功能，从创建自定义本地数据库到启动</st> <st c="89441">Neo4J
    浏览器。</st> <st c="89461">其安装程序可在</st> <st c="89488">[<st c="89491">https://neo4j.com/download/</st>](https://neo4j.com/download/)<st
    c="89518">找到。</st>
- en: <st c="89519">Once it’s been installed, create a Neo4J project that will contain
    the local databases and configuration settings.</st> <st c="89635">Aside from
    the project’s name, the process will also ask for a username and password for
    its authentication details.</st> <st c="89752">Once you’ve done this, delete its
    default Movie database and create the necessary graph database.</st> *<st c="89850">Figure
    7</st>**<st c="89858">.20</st>* <st c="89861">shows</st> **<st c="89868">Packt
    Flask Project</st>** <st c="89887">with a</st> **<st c="89895">Tutor</st>** <st
    c="89900">database:</st>
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="89519">安装完成后，创建一个包含本地数据库和配置设置的 Neo4J 项目。</st> <st c="89635">除了项目名称外，此过程还会要求输入用户名和密码以供身份验证详情使用。</st>
    <st c="89752">完成这些操作后，删除其默认的 Movie 数据库，并创建必要的图数据库。</st> *<st c="89850">图 7</st>**<st
    c="89858">.20</st>* <st c="89861">显示</st> **<st c="89868">Packt Flask 项目</st>**
    <st c="89887">与一个</st> **<st c="89895">导师</st>** <st c="89900">数据库：</st>
- en: '![Figure 7.20 – The Neo4J Desktop dashboard](img/B19383_07_020.jpg)'
  id: totrans-408
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 7.20 – Neo4J 桌面仪表板](img/B19383_07_020.jpg)'
- en: <st c="90213">Figure 7.20 – The Neo4J Desktop dashboard</st>
  id: totrans-409
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="90213">图 7.20 – Neo4J 桌面仪表板</st>
- en: <st c="90254">There are so many ways Flask can connect to a graph database,
    and one of them is through the</st> `<st c="90348">py2neo</st>` <st c="90354">library.</st>
    <st c="90364">We’ll take a closer look at this in the</st> <st c="90404">next
    section.</st>
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="90254">Flask 可以通过多种方式连接到图数据库，其中之一是通过</st> `<st c="90348">py2neo</st>`
    <st c="90354">库。</st> <st c="90364">我们将在下一节中对此进行更详细的探讨。</st>
- en: <st c="90417">Establishing a connection to the database</st>
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="90417">建立数据库连接</st>
- en: <st c="90459">To start, install</st> `<st c="90478">py2neo</st>` <st c="90484">using</st>
    <st c="90491">the</st> `<st c="90495">pip</st>` <st c="90498">command:</st>
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="90459">首先，使用</st> `<st c="90478">py2neo</st>` <st c="90484">通过</st> `<st
    c="90491">pip</st>` <st c="90498">命令安装：</st>
- en: '[PRE60]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: <st c="90526">Next, create a</st> `<st c="90542">neo4j_config.py</st>` <st c="90557">module
    in the main project folder with the following script to ensure</st> <st c="90628">database
    connectivity:</st>
  id: totrans-414
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="90526">接下来，在主项目文件夹中创建一个</st> `<st c="90542">neo4j_config.py</st>` <st
    c="90557">模块，包含以下脚本以确保</st> <st c="90628">数据库连接：</st>
- en: '[PRE61]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: <st c="90771">Now, calling the given</st> `<st c="90795">db_auth()</st>` <st
    c="90804">method will initiate the bolts connection protocol with the host, port,
    and authentication details to open a connection for our</st> *<st c="90933">Tutor
    Finder</st>* <st c="90945">application through</st> <st c="90965">the</st> `<st
    c="90970">Graph</st>` <st c="90975">instance, the object responsible for repository</st>
    <st c="91024">layer implementation.</st>
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="90771">现在，调用给定的</st> `<st c="90795">db_auth()</st>` <st c="90804">方法将启动与主机、端口和认证详情的
    bolts 连接协议，通过</st> `<st c="90970">Graph</st>` <st c="90975">实例（负责仓库层实现的对象）为我们的</st>
    *<st c="90933">导师查找器</st>* <st c="90945">应用程序打开一个连接。</st>
- en: <st c="91045">Implementing the repository</st>
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="91045">实现仓库</st>
- en: '`<st c="91333">Graph</st>` <st c="91338">instance has several utility methods
    to derive the building blocks of the module, namely</st> `<st c="91428">SubGraph</st>`<st
    c="91436">,</st> `<st c="91438">Node</st>`<st c="91442">,</st> `<st c="91444">NodeMatcher</st>`<st
    c="91455">, and</st> `<st c="91461">Relationship</st>`<st c="91473">. Here,</st>
    `<st c="91481">StudentNodeRepository</st>` <st c="91502">showcases the use of
    py2neo’s API classes and methods in managing the</st> <st c="91573">student nodes:</st>'
  id: totrans-418
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="91333">Graph</st>` <st c="91338">实例具有几个实用方法来推导模块的构建块，即</st> `<st c="91428">SubGraph</st>`<st
    c="91436">,</st> `<st c="91438">Node</st>`<st c="91442">,</st> `<st c="91444">NodeMatcher</st>`<st
    c="91455">, 和</st> `<st c="91461">Relationship</st>`<st c="91473">。在这里，</st> `<st
    c="91481">StudentNodeRepository</st>` <st c="91502">展示了如何使用 py2neo 的 API 类和方法来管理</st>
    `<st c="91573">学生节点</st>`：</st>'
- en: '[PRE62]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: <st c="92018">The</st> `<st c="92023">insert_student_node()</st>` <st c="92044">method
    creates a</st> `<st c="92062">Student</st>` <st c="92069">node and stores its
    details in the graph database.</st> <st c="92121">A node is the fundamental unit
    of data in Neo4J; it can be an independent node or connected to other nodes through</st>
    <st c="92236">a relationship.</st>
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="92018">`<st c="92023">insert_student_node()</st>` <st c="92044">方法创建一个</st>
    `<st c="92062">Student</st>` <st c="92069">节点并将它的详细信息存储在图数据库中。</st> <st c="92121">节点是
    Neo4J 中的基本数据单元；它可以是一个独立的节点，也可以通过</st> `<st c="92236">关系</st>` <st c="92251">与其他节点相连。</st>
- en: <st c="92251">There are two ways to create a node</st> <st c="92287">using the</st>
    `<st c="92298">py2neo</st>` <st c="92304">library:</st>
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="92251">使用</st> `<st c="92298">py2neo</st>` <st c="92304">库创建节点有两种方式：</st>
- en: <st c="92313">Running a query with Cypher’s</st> *<st c="92344">CREATE</st>*
    <st c="92350">transaction using Graph’s</st> `<st c="92377">query()</st>` <st
    c="92384">or</st> `<st c="92388">run()</st>` <st c="92393">methods.</st>
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="92313">使用 Cypher 的</st> *<st c="92344">CREATE</st>* <st c="92350">事务通过
    Graph 的</st> `<st c="92377">query()</st>` <st c="92384">或</st> `<st c="92388">run()</st>`
    <st c="92393">方法运行查询。</st>
- en: <st c="92402">Persisting the</st> `<st c="92418">Node</st>` <st c="92422">object
    using the</st> `<st c="92440">Graph</st>` <st c="92445">object’s</st> `<st c="92455">create()</st>`
    <st c="92463">method.</st>
  id: totrans-423
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="92402">使用</st> `<st c="92418">Node</st>` <st c="92422">对象通过</st> `<st
    c="92440">Graph</st>` <st c="92445">对象的</st> `<st c="92455">create()</st>` <st
    c="92463">方法持久化。</st>
- en: <st c="92471">Creating a node requires transaction</st> <st c="92508">management,
    so we must start a</st> `<st c="92540">Transaction</st>` <st c="92551">context
    to commit all the data manipulation operations.</st> <st c="92608">Here,</st>
    `<st c="92614">insert_student_node()</st>` <st c="92635">creates a</st> `<st c="92646">Transaction</st>`
    <st c="92657">object to create a logical context for the node creation operation
    for the</st> `<st c="92733">Graph</st>` <st c="92738">object’s</st> `<st c="92748">commit()</st>`
    <st c="92756">method</st> <st c="92764">to commit:</st>
  id: totrans-424
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="92471">创建节点需要事务管理，因此我们必须启动一个</st> `<st c="92540">事务</st>` <st c="92551">上下文来提交所有数据操作。</st>
    <st c="92608">在此处，</st> `<st c="92614">insert_student_node()</st>` <st c="92635">创建一个</st>
    `<st c="92646">事务</st>` <st c="92657">对象，为</st> `<st c="92733">图</st>` <st c="92738">对象的</st>
    `<st c="92748">commit()</st>` <st c="92756">方法</st> <st c="92764">创建一个逻辑上下文，以便提交：</st>
- en: '[PRE63]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '*<st c="93173">NodeManager</st>* <st c="93185">can locate a specific node</st>
    <st c="93212">given the criteria in key-value pairs.</st> <st c="93252">Here,</st>
    `<st c="93258">update_student_node()</st>` <st c="93279">uses the</st> `<st c="93289">match()</st>`
    <st c="93296">method from</st> `<st c="93309">NodeManager</st>` <st c="93320">to
    single out a</st> `<st c="93337">Node</st>` <st c="93341">object with the specific</st>
    `<st c="93367">student_id</st>` <st c="93377">value.</st> <st c="93385">After
    retrieving a graph node, if there is one, you must call the</st> `<st c="93451">Node</st>`
    <st c="93455">object’s</st> `<st c="93465">update()</st>` <st c="93473">method
    with the</st> `<st c="93490">kwargs</st>` <st c="93496">value of the new data.</st>
    <st c="93520">To merge the updated</st> `<st c="93541">Node</st>` <st c="93545">object
    with its committed version, invoke the</st> `<st c="93592">Graph</st>` <st c="93597">object’s</st>
    `<st c="93607">push()</st>` <st c="93613">method and perform</st> <st c="93633">a
    commit.</st>'
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="93173">节点管理器</st>* <st c="93185">可以根据键值对中的条件定位特定的节点</st> <st c="93212">。</st>
    <st c="93252">在此处，</st> `<st c="93258">update_student_node()</st>` <st c="93279">使用</st>
    `<st c="93289">match()</st>` <st c="93296">方法从</st> `<st c="93309">节点管理器</st>`
    <st c="93320">中筛选出一个具有特定</st> `<st c="93337">节点</st>` <st c="93341">对象和</st> `<st
    c="93367">student_id</st>` <st c="93377">值</st>。</st> <st c="93385">在检索到图节点后，如果有的话，你必须调用</st>
    `<st c="93451">节点</st>` <st c="93455">对象的</st> `<st c="93465">update()</st>` <st
    c="93473">方法，并使用新数据的</st> `<st c="93490">kwargs</st>` <st c="93496">值。</st> <st
    c="93520">要将更新的</st> `<st c="93541">节点</st>` <st c="93545">对象与其提交版本合并，调用</st>
    `<st c="93592">图</st>` <st c="93597">对象的</st> `<st c="93607">push()</st>` <st
    c="93613">方法并执行</st> <st c="93633">提交。</st>'
- en: <st c="93642">Another way of searching and retrieving a</st> `<st c="93685">Node</st>`
    <st c="93689">match is through the</st> `<st c="93711">Graph</st>` <st c="93716">object’s</st>
    `<st c="93726">query()</st>` <st c="93733">method.</st> <st c="93742">It can execute</st>
    *<st c="93757">CREATE</st>* <st c="93763">and other Cipher manipulation commands
    because it has auto-commit features.</st> <st c="93840">But in most cases, it
    is applied in node retrieval transactions.</st> <st c="93905">Here,</st> `<st
    c="93911">delete_student_node()</st>` <st c="93932">uses the</st> `<st c="93942">query()</st>`
    <st c="93949">method with the</st> `<st c="93966">MATCH</st>` <st c="93971">command
    to retrieve a specific node</st> <st c="94008">for deletion:</st>
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="93642">另一种搜索和检索</st> `<st c="93685">节点</st>` <st c="93689">匹配的方法是通过</st>
    `<st c="93711">图</st>` <st c="93716">对象的</st> `<st c="93726">query()</st>` <st
    c="93733">方法。</st> <st c="93742">它可以执行</st> *<st c="93757">CREATE</st>* <st c="93763">和其他Cipher操作命令，因为它具有自动提交功能。</st>
    <st c="93840">但在大多数情况下，它应用于节点检索事务。</st> <st c="93905">在此处，</st> `<st c="93911">delete_student_node()</st>`
    <st c="93932">使用带有</st> `<st c="93966">MATCH</st>` <st c="93971">命令的</st> `<st
    c="93942">query()</st>` <st c="93949">方法检索要删除的特定节点：</st>
- en: '[PRE64]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: <st c="94342">The</st> `<st c="94347">Graph</st>` <st c="94352">object’s</st>
    `<st c="94362">query()</st>` <st c="94369">method returns</st> `<st c="94385">Cursor</st>`<st
    c="94391">, which is a navigator for streams of nodes.</st> <st c="94436">The</st>
    `<st c="94440">Graph</st>` <st c="94445">object has a</st> `<st c="94459">delete()</st>`
    <st c="94467">method that can delete any nodes retrieved by</st> `<st c="94514">query()</st>`<st
    c="94521">, but the nodes should be in</st> *<st c="94550">SubGraph</st>* <st
    c="94558">form.</st> <st c="94565">To delete the retrieved nodes, convert the</st>
    `<st c="94608">Cursor</st>` <st c="94614">object into a</st> *<st c="94629">SubGraph</st>*
    <st c="94637">by calling it from the</st> `<st c="94661">to_subgraph()</st>` <st
    c="94674">method.</st> <st c="94683">Then, call</st> `<st c="94694">commit()</st>`
    <st c="94702">to handle the whole</st> <st c="94723">delete transaction.</st>
  id: totrans-429
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="94342">The</st>` `<st c="94347">Graph</st>` <st c="94352">对象上的</st>
    `<st c="94362">query()</st>` <st c="94369">方法返回</st> `<st c="94385">Cursor</st>`<st
    c="94391">，它是节点流的导航器。</st> `<st c="94436">Graph</st>` <st c="94440">对象有一个</st>
    `<st c="94459">delete()</st>` <st c="94467">方法，可以删除通过</st> `<st c="94514">query()</st>`<st
    c="94521">检索到的任何节点，但节点应该以</st> *<st c="94550">SubGraph</st>* <st c="94558">形式存在。</st>
    `<st c="94565">要删除检索到的节点，需要通过调用</st> `<st c="94661">to_subgraph()</st>` <st c="94674">方法将</st>
    `<st c="94608">Cursor</st>` <st c="94614">对象转换为</st> *<st c="94629">SubGraph</st>*
    <st c="94637">。</st> `<st c="94683">然后，调用</st> `<st c="94694">commit()</st>` <st
    c="94702">来处理整个</st> <st c="94723">删除事务。</st>'
- en: <st c="94742">Retrieving nodes in</st> `<st c="94763">py2neo</st>` <st c="94769">can
    utilize</st> <st c="94781">either</st> `<st c="94789">NodeManager</st>` <st c="94800">or
    the</st> `<st c="94808">Graph</st>` <st c="94813">object’s</st> `<st c="94823">query()</st>`
    <st c="94830">method.</st> <st c="94839">Here,</st> `<st c="94845">get_student_node()</st>`
    <st c="94863">retrieves a specific</st> `<st c="94885">Student</st>` <st c="94892">node
    filtered by student ID using</st> `<st c="94927">NodeMatcher</st>`<st c="94938">,
    while</st> `<st c="94946">select_student_nodes()</st>` <st c="94968">uses</st>
    `<st c="94974">query()</st>` <st c="94981">to retrieve a list of</st> `<st c="95004">Student</st>`
    <st c="95011">nodes:</st>
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="94742">在</st> `<st c="94763">py2neo</st>` <st c="94769">中检索节点可以利用</st>
    `<st c="94781">NodeManager</st>` <st c="94800">或</st> `<st c="94808">Graph</st>`
    <st c="94813">对象的</st> `<st c="94823">query()</st>` <st c="94830">方法。</st> `<st
    c="94839">在此，</st> `<st c="94845">get_student_node()</st>` <st c="94863">使用</st>
    `<st c="94927">NodeMatcher</st>`<st c="94938">通过学生ID过滤检索特定的</st> `<st c="94885">Student</st>`
    <st c="94892">节点，而</st> `<st c="94946">select_student_nodes()</st>` <st c="94968">使用</st>
    `<st c="94974">query()</st>` <st c="94981">检索</st> `<st c="95004">Student</st>`
    <st c="95011">节点列表：</st>'
- en: '[PRE65]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: <st c="95351">The</st> `<st c="95356">dict()</st>` <st c="95362">function converts
    a</st> `<st c="95383">Node</st>` <st c="95387">object into a dictionary, thus
    wrapping a</st> `<st c="95430">Student</st>` <st c="95437">node with the</st>
    `<st c="95452">dict()</st>` <st c="95458">function in the given</st> `<st c="95481">get_student_node()</st>`<st
    c="95499">. On the other hand,</st> `<st c="95520">Cursor</st>` <st c="95526">has
    a</st> `<st c="95533">data()</st>` <st c="95539">function to convert the streams
    of</st> `<st c="95575">Node</st>` <st c="95579">objects into a list of dictionary
    elements.</st> <st c="95624">So,</st> `<st c="95628">select_student_nodes()</st>`
    <st c="95650">returns the stream of</st> `<st c="95673">Student</st>` <st c="95680">nodes</st>
    <st c="95686">as a list of</st> `<st c="95700">Student</st>` <st c="95707">records.</st>
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="95351">The</st>` `<st c="95356">dict()</st>` <st c="95362">函数将一个</st>
    `<st c="95383">Node</st>` <st c="95387">对象转换为字典，从而通过给定的</st> `<st c="95481">get_student_node()</st>`<st
    c="95499">函数使用</st> `<st c="95452">dict()</st>` <st c="95458">函数将</st> `<st c="95430">Student</st>`
    <st c="95437">节点包装起来。另一方面，</st> `<st c="95520">Cursor</st>` <st c="95526">有一个</st>
    `<st c="95533">data()</st>` <st c="95539">函数，可以将</st> `<st c="95575">Node</st>`
    <st c="95579">对象的流转换为字典元素的列表。</st> <st c="95624">因此，</st> `<st c="95628">select_student_nodes()</st>`
    <st c="95650">返回的</st> `<st c="95673">Student</st>` <st c="95680">节点流是一个</st>
    `<st c="95686">Student</st>` <st c="95700">记录的列表。</st>'
- en: <st c="95716">Summary</st>
  id: totrans-433
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="95716">Summary</st>`'
- en: <st c="95724">There are lots of NoSQL databases that can store non-relational
    data for big data applications built with Flask 3.x.</st> <st c="95842">Flask
    can</st> `<st c="95852">PUT</st>`<st c="95855">,</st> `<st c="95857">GET</st>`<st
    c="95860">, and</st> `<st c="95866">SCAN</st>` <st c="95870">data in HBase using
    HDFS, access the Cassandra database, execute</st> `<st c="95936">HGET</st>` <st
    c="95940">an</st> `<st c="95944">HSET</st>` <st c="95948">with Redis, perform
    CRUD operations in Couchbase and MongoDB, and manage nodes with Neo4J.</st> <st
    c="96040">Although there are changes in some support modules, such as in</st>
    `<st c="96103">flask-mongoengine</st>`<st c="96120">, because of the transformations
    in the Flask internal modules (for example, the removal of</st> `<st c="96212">flask.json</st>`<st
    c="96222">), Flask can still adapt to other Python module extensions and workarounds
    to connect to and manage its data, such as using the FastAPI-compatible</st> <st
    c="96370">Redis OM.</st>
  id: totrans-434
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="95724">有许多 NoSQL 数据库可以存储 Flask 3.x 构建的大数据应用的非关系型数据。</st> <st c="95842">Flask
    可以</st> `<st c="95852">PUT</st>`<st c="95855">,</st> `<st c="95857">GET</st>`<st
    c="95860">, 和</st> `<st c="95866">SCAN</st>` <st c="95870">数据在 HBase 中使用 HDFS，访问
    Cassandra 数据库，执行</st> `<st c="95936">HGET</st>` <st c="95940">一个</st> `<st c="95944">HSET</st>`
    <st c="95948">与 Redis，在 Couchbase 和 MongoDB 中执行 CRUD 操作，并使用 Neo4J 管理节点。</st> <st
    c="96040">尽管一些支持模块（例如在</st> `<st c="96103">flask-mongoengine</st>`<st c="96120">中）有所变化，因为
    Flask 内部模块（例如，移除</st> `<st c="96212">flask.json</st>`<st c="96222">）发生了变化，但 Flask
    仍然可以适应其他 Python 模块扩展和解决方案来连接和管理其数据，例如使用与 FastAPI 兼容的</st> <st c="96370">Redis
    OM。</st>
- en: <st c="96379">In general, this chapter showcased Flask’s compatibility with
    almost all the efficient, popular, and widely used NoSQL databases.</st> <st c="96510">It
    is also a Python framework that’s fit for building big data applications for many
    enterprises and scientific development because it supports many</st> <st c="96659">NoSQL
    storages.</st>
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="96379">总的来说，本章展示了 Flask 几乎与所有高效、流行和广泛使用的 NoSQL 数据库的兼容性。</st> <st c="96510">它也是一个适合构建许多企业和科学发展的大数据应用的
    Python 框架，因为它支持许多</st> <st c="96659">NoSQL 存储。</st>
- en: <st c="96674">The next chapter is about using Flask to implement task management</st>
    <st c="96742">with workflows.</st>
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="96674">下一章将介绍如何使用 Flask 通过工作流实现任务管理</st> <st c="96742">。</st>
- en: '[PRE66]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
