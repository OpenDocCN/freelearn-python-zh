- en: Chapter 11. Debugging – Solving the Bugs
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。调试-解决错误
- en: The previous chapter showed you how to add logging and tests to your code, but
    no matter how many tests you have, you will always have bugs. The biggest problem
    is always user input, as it is simply impossible to test all possible inputs,
    implying that at one point, we will need to debug the code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章向您展示了如何向代码添加日志记录和测试，但无论您有多少测试，您总会有bug。最大的问题始终是用户输入，因为不可能测试所有可能的输入，这意味着在某个时候，我们将需要调试代码。
- en: There are many debugging techniques, and most certainly, you have already used
    a few of them. Within this chapter, we are going to focus on print/trace debugging
    and interactive debugging.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多调试技术，而且很可能您已经使用了其中一些。在本章中，我们将专注于打印/跟踪调试和交互式调试。
- en: Debugging using print statements, stack traces, and logging is one of the most
    versatile methods to work with, and it is most likely the first type of debugging
    you've ever used. Even a `print 'Hello world'` can be considered this type, as
    the output will show you that your code is being executed correctly. There is
    obviously no point in explaining how and where to place print statements to debug
    your code, but there are quite a few nice tricks using decorators and other Python
    modules that render this type of debugging a lot more useful, such as `faulthandler`.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用打印语句、堆栈跟踪和日志记录进行调试是最通用的方法之一，很可能是您使用过的第一种调试方法。即使`print 'Hello world'`也可以被视为这种类型，因为输出将向您显示代码正在正确执行。显然没有必要解释如何以及在何处放置打印语句来调试代码，但使用装饰器和其他Python模块有一些很好的技巧，使得这种类型的调试更加有用，比如`faulthandler`。
- en: Interactive debugging is a more complicated debugging method. It allows you
    to debug a program while it's still running. Using this method, it's even possible
    to change variables while the application is running and pause the application
    at any point desired. The downside is that it requires some knowledge about the
    debugger commands to be really useful.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 交互式调试是一种更复杂的调试方法。它允许您在程序运行时调试程序。使用这种方法，甚至可以在应用程序运行时更改变量并在任何所需的地方暂停应用程序。缺点是它需要一些关于调试器命令的知识才能真正有用。
- en: 'To summarize, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们将涵盖以下主题：
- en: Debugging using `print`, `trace`, `logging`, and `faulthandler`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`print`、`trace`、`logging`和`faulthandler`进行调试
- en: Interactive debugging using `pdb`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pdb`进行交互式调试
- en: Non-interactive debugging
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非交互式调试
- en: The most basic form of debugging is adding a simple print statement into your
    code to see what is still working and what isn't. This is useful in a variety
    of cases and likely to help solve most of your issues. Later in this chapter,
    we will show some interactive debugging methods, but those are not always suitable.
    Interactive debugging tends to become difficult or even impossible in multithreaded
    environments, while on a closed-off remote server, you might need a different
    solution as well. Both methods have their merits, but I personally opt for non-interactive
    debugging 90% of the time since a simple print/log statement is usually enough
    to analyze the cause of a problem.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的调试形式是在代码中添加简单的打印语句，以查看仍在工作和不在工作的内容。这在各种情况下都很有用，并且可能有助于解决大部分问题。在本章后面，我们将展示一些交互式调试方法，但这些方法并不总是适用。在多线程环境中，交互式调试往往变得困难甚至不可能，而在封闭的远程服务器上，您可能也需要不同的解决方案。这两种方法都有其优点，但我个人90%的时间都选择非交互式调试，因为简单的打印/日志语句通常足以分析问题的原因。
- en: 'A basic example of this (I''ve been known to do similar) with a generator can
    be as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本示例（我已经知道做类似的事情）使用生成器可以如下所示：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This shows exactly where the code does, and consequently, does not reach. Without
    this example, you might have expected the first print to come immediately after
    the `spam_generator()` call, since it's a generator. However, the execution completely
    stalls until we `yield` an item. Assuming you would have some setup code before
    the first `yield`, it won't run until `next` is actually called.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地显示了代码的执行情况，因此也清楚地显示了代码未执行的情况。如果没有这个例子，您可能会期望在`spam_generator()`调用之后立即出现第一个打印，因为它是一个生成器。然而，执行完全停滞，直到我们`yield`一个项目。假设在第一个`yield`之前有一些设置代码，它将不会在实际调用`next`之前运行。
- en: 'Although this is one of the simplest ways to debug functions using print statements,
    it''s definitely not the best way. We can start by making an auto-print function
    that automatically increments the letter:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是使用打印语句调试函数的最简单方法之一，但绝对不是最佳方法。我们可以从制作一个自动打印函数开始，该函数会自动递增字母：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While the print statement generator is slightly better than bare print statements,
    it doesn't help that much yet. It would be much more useful to see which lines
    were actually executed while running the code. We can do this manually using `inspect.currentframe`,
    but there is no need for hacking. Python has you covered with some dedicated tools.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然打印语句生成器比裸打印语句稍好一些，但帮助并不是很大。在运行代码时，看到实际执行了哪些行将更有用。我们可以使用`inspect.currentframe`手动执行此操作，但没有必要进行黑客攻击。Python为您提供了一些专用工具。
- en: Inspecting your script using trace
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用跟踪检查脚本
- en: Simple print statements are useful in a lot of cases since you can easily incorporate
    print statements in nearly every application. It does not matter whether it's
    remote or local, threaded or using multiprocessing. It works almost everywhere,
    making it the most universal solution available, in addition to logging that is.
    The general solution is often not the best solution, however. There are better
    solutions available for the most common scenarios. One of them is the `trace`
    module. It offers you a way to trace every execution, relationships between functions,
    and a few others.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的打印语句在许多情况下都很有用，因为您几乎可以在几乎每个应用程序中轻松地加入打印语句。无论是远程还是本地，使用线程还是使用多进程，都没有关系。它几乎可以在任何地方工作，使其成为最通用的解决方案，除了日志记录之外。然而，通用解决方案通常不是最佳解决方案。对于最常见的情况，有更好的解决方案可用。其中之一是`trace`模块。它为您提供了一种跟踪每次执行、函数之间关系以及其他一些内容的方法。
- en: 'To demonstrate, we will use our previous code but without print statements:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示，我们将使用我们之前的代码，但不包括打印语句：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We will execute it with the trace module:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用trace模块执行它：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Quite nice, isn't it? It shows you exactly which line is being executed with
    function names and, more importantly, which line was caused by which statement
    (or statements). Additionally, it shows you at what time it was executed relative
    to the start time of the program. This is due to the `--timing` flag.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 相当不错，不是吗？它准确地显示了正在执行的每一行代码以及函数名称，更重要的是，显示了每一行代码是由哪个语句（或多个语句）引起的。此外，它还显示了它相对于程序开始时间的执行时间。这是由于`--timing`标志。
- en: 'As you might expect, this output is a bit too verbose to be universally useful.
    In spite of the fact that you can opt to ignore specific modules and directories
    by using command-line parameters, it is still too verbose in many cases. So let''s
    go for the next solution—a context manager. The preceding output has already revealed
    some of the `trace` internals. The last line shows a `sys.settrace` call, which
    is exactly what we need for manual tracing:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望，这个输出有点太啰嗦了，不能普遍适用。尽管你可以选择使用命令行参数来忽略特定的模块和目录，但在许多情况下仍然太啰嗦了。所以让我们来尝试下一个解决方案——上下文管理器。前面的输出已经揭示了一些`trace`的内部情况。最后一行显示了一个`sys.settrace`调用，这正是我们需要的手动跟踪：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When executed as a regular Python file, this returns:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为常规Python文件执行时，返回：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code immediately reveals what the trace code does internally as well:
    it uses `sys.settrace` to tell the Python interpreter where to send every statement
    that is being executed. Given this, it''s obviously trivial to write the function
    as a decorator, but I''ll leave that as an exercise to you if you need it.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码立即揭示了跟踪代码的内部操作：它使用`sys.settrace`告诉Python解释器在执行每个语句时将其发送到哪里。鉴于此，将函数编写为装饰器显然是微不足道的，但如果你需要的话，我会把它留给你作为一个练习。
- en: 'Another take-away from this is that you can easily add extra filters to your
    trace function by wrapping `tracer.globaltrace`. The function takes the following
    parameters (from the standard Python documentation):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 从中还可以得到的另一个收获是，你可以通过包装`tracer.globaltrace`轻松地向你的跟踪函数添加额外的过滤器。该函数接受以下参数（来自标准Python文档）：
- en: '| Parameter | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Call` | A function is called (or some other code block entered). The global
    trace function is called; `arg` is `None`. The return value specifies the local
    trace function. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `Call` | 调用函数（或进入某些其他代码块）。调用全局跟踪函数；`arg`是`None`。返回值指定了本地跟踪函数。|'
- en: '| `Line` | The interpreter is about to execute a new line of code or re-execute
    the condition of a loop. The local trace function is called; `arg` is `None`.
    The return value specifies the new local trace function. See `Objects/lnotab_notes.txt`
    for a detailed explanation of how this works. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `Line` | 解释器即将执行新的一行代码或重新执行循环的条件。调用本地跟踪函数；`arg`是`None`。返回值指定了新的本地跟踪函数。有关其工作原理的详细解释，请参阅`Objects/lnotab_notes.txt`。|'
- en: '| `return` | A function (or another code block) is about to return. The local
    trace function is called; `arg` is the value that will be returned or `None` if
    the event is caused by an exception being raised. The trace function''s return
    value is ignored. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 一个函数（或其他代码块）即将返回。调用本地跟踪函数；`arg`是将要返回的值，或者如果事件是由引发异常引起的，则为`None`。跟踪函数的返回值被忽略。|'
- en: '| `exception` | This means an exception has occurred. The local trace function
    is called; `arg` is a tuple (`exception`, `value`, `traceback`). The return value
    specifies the new local trace function. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `exception` | 这意味着发生了异常。调用本地跟踪函数；`arg`是一个元组（`exception`，`value`，`traceback`）。返回值指定了新的本地跟踪函数。|'
- en: '| `c_call` | A C function is about to be called. This may be an extension function
    or a built-in function. The `arg` is the C function object. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `c_call` | 即将调用一个C函数。这可能是一个扩展函数或内置函数。`arg`是C函数对象。|'
- en: '| `c_return` | A C function has returned, and `arg` is the C function object.
    |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `c_return` | 一个C函数已经返回，`arg`是C函数对象。|'
- en: '| `c_exception` | A C function has raised an exception, and `arg` is the C
    function object. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `c_exception` | 一个C函数引发了异常，`arg`是C函数对象。|'
- en: As you must have expected, with a simple filter function, you can easily make
    sure that only specific functions will be returned, instead of the long list you
    would normally get. You really shouldn't underestimate the amount of data generated
    by tracing code with a few imports. The preceding context manager code gives over
    300 lines of output.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，通过一个简单的过滤函数，你可以轻松地确保只返回特定的函数，而不是通常会得到的长列表。你真的不应该低估使用几个导入来跟踪代码生成的数据量。前面的上下文管理器代码产生了300多行输出。
- en: Debugging using logging
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用日志进行调试
- en: In [Chapter 10](ch10.html "Chapter 10. Testing and Logging – Preparing for Bugs"),
    *Testing and Logging – Preparing for Bugs*, our chapter about testing and logging,
    we saw how to create custom loggers, set the levels for them, and add handlers
    to specific levels. We are going to use the `logging.DEBUG` level to log now,
    which is nothing special by itself, but with a few decorators, we can add some
    very useful debug-only code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](ch10.html "第10章。测试和日志 - 为错误做准备")中，*测试和日志 - 为错误做准备*，我们看到了如何创建自定义记录器，为它们设置级别，并为特定级别添加处理程序。我们将使用`logging.DEBUG`级别进行日志记录，这本身并不特别，但通过一些装饰器，我们可以添加一些非常有用的仅用于调试的代码。
- en: 'Whenever I''m debugging, I always find it very useful to know the input and
    output for a function. The basic version with a decorator is simple enough to
    write; just print the `args` and `kwargs` and you are done. The following example
    goes a little further. By using the `inspect` module, we can retrieve the default
    arguments as well, making it possible to show all arguments with the argument
    names and values in all cases, even if the argument was not specified:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我调试时，我总是发现了解函数的输入和输出非常有用。使用装饰器的基本版本足够简单；只需打印`args`和`kwargs`，就完成了。以下示例稍微深入一些。通过使用`inspect`模块，我们还可以检索默认参数，从而可以在所有情况下显示所有参数及其参数名和值，即使未指定参数也可以。
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following output is returned:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 返回以下输出：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Very nice of course, as we have a clear sight of when the function is called,
    which parameters were used, and what is returned. However, this is something you
    will probably only execute when you are actively debugging your code. You can
    also make the regular `logging.debug` statements in your code quite a bit more
    useful by adding a debug-specific logger, which shows more information. Simply
    replace the logging config of the preceding example with this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当然非常好，因为我们清楚地知道函数何时被调用，使用了哪些参数，以及返回了什么。但是，这可能只有在您积极调试代码时才会执行。您还可以通过添加特定于调试的记录器使代码中的常规`logging.debug`语句更加有用，该记录器显示更多信息。只需用前面示例的日志配置替换此示例：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then your result will be something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么你的结果会是这样的：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It shows the time relative to the start of the application in milliseconds and
    the log level. This is followed by an identification block that shows the filename,
    line number, and function name that originated the logs. Of course, there is a
    message at the end.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 它显示相对于应用程序启动的时间（毫秒）和日志级别。然后是一个标识块，显示产生日志的文件名、行号和函数名。当然，最后还有一条消息。
- en: Showing call stack without exceptions
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示无异常的调用堆栈
- en: 'When looking at how and why a piece of code is being run, it''s often useful
    to see the entire stack trace. Simply raising an exception is, of course, an option.
    However, that will kill the current code execution, which is generally not something
    we are looking for. This is where the `traceback` module comes in handy. With
    just a few simple lines, we get a full (or limited, if you prefer) stack list:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看代码的运行方式和原因时，通常有必要查看整个堆栈跟踪。当然，简单地引发异常是一个选择。但是，那将终止当前的代码执行，这通常不是我们要寻找的。这就是`traceback`模块派上用场的地方。只需几行简单的代码，我们就可以得到完整的（或有限的，如果您愿意的话）堆栈列表：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This results in the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the traceback simply prints without any exceptions. The `traceback`
    module actually has quite a few other methods for printing tracebacks based on
    exceptions and such, but you probably won''t need them often. The most useful
    one is probably the `limit` parameter; this parameter allows you to limit the
    stack trace to the useful part. For example, if you''ve added this code using
    a decorator or helper function, you probably have no need to include those in
    the stack trace. That''s where the `limit` parameter helps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，回溯只是简单地打印而没有任何异常。`traceback`模块实际上有很多其他方法，用于基于异常等打印回溯，但您可能不经常需要它们。最有用的可能是`limit`参数；此参数允许您将堆栈跟踪限制为有用的部分。例如，如果您使用装饰器或辅助函数添加了此代码，则可能不需要在堆栈跟踪中包含它们。这就是`limit`参数的作用所在：
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This results in the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下结果：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, the `print_stack` function itself has now been hidden from the
    stack trace, which makes everything a bit cleaner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`print_stack`函数本身现在已从堆栈跟踪中隐藏，这使得一切都变得更加清晰。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The negative limit support was added in Python 3.5\. Before that, only positive
    limits were supported.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 3.5中添加了负限制支持。在那之前，只支持正限制。
- en: Debugging asyncio
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试asyncio
- en: The `asyncio` module has a few special provisions to make debugging somewhat
    easier. Given the asynchronous nature of functions within `asyncio`, this is a
    very welcome feat. While debugging of multithreaded/multiprocessing functions
    or classes can be difficult—since concurrent classes can easily change environment
    variables in parallel—with `asyncio`, it's just as difficult if not more.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块有一些特殊规定，使得调试变得更容易一些。鉴于`asyncio`内部函数的异步特性，这是一个非常受欢迎的功能。在调试多线程/多进程函数或类时可能会很困难——因为并发类可以轻松并行更改环境变量——而使用`asyncio`，情况可能会更加困难。'
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Within most Linux/Unix/Mac shell sessions, environment variables can be set
    using it as a prefix:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数Linux/Unix/Mac shell会话中，可以使用它作为前缀设置环境变量：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, it can be configured for the current shell session using `export`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用`export`为当前shell会话进行配置：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The current value can be fetched using the following line:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下行来获取当前值：
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On Windows, you can configure an environment variable for your local shell
    session using the `set` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，可以使用`set`命令为本地shell会话配置环境变量：
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The current value can be fetched using this line:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下行来获取当前值：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When enabling the debug mode using the `PYTHONASYNCIODEBUG` environment setting
    the `asyncio` module will check whether every defined coroutine is actually run:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PYTHONASYNCIODEBUG`环境设置启用调试模式时，`asyncio`模块将检查每个定义的协程是否实际运行：
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This results in an error for the printer coroutine, which is never yielded
    here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致打印器协程出现错误，这里从未产生过：
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Additionally, the `event` loop has some log messages by default:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`event`循环默认会有一些日志消息：
- en: '[PRE21]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This results in debug messages such as the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致以下调试消息：
- en: '[PRE22]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You might wonder why we are using the `PYTHONASYNCIODEBUG` flag instead of `loop.set_debug(True)`.
    The reason is that there are cases where this won't work because debugging is
    enabled too late. For example, when trying that with the preceding `printer()`,
    you will see that you won't get any errors when using `loop.set_debug(True)` alone.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想为什么我们使用`PYTHONASYNCIODEBUG`标志而不是`loop.set_debug(True)`。原因是有些情况下这种方法不起作用，因为调试启用得太晚。例如，当尝试在前面的`printer()`中使用`loop.set_debug(True)`时，你会发现单独使用`loop.set_debug(True)`时不会出现任何错误。
- en: 'When enabling debugging, the following will change:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 启用调试后，以下内容将发生变化：
- en: Coroutines that have not been yielded (as can be seen in the preceding lines)
    will raise an exception.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未被yield的协程（如前面的行所示）将引发异常。
- en: Calling coroutines from the "wrong" thread raises an exception.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从“错误”的线程调用协程会引发异常。
- en: The execution time of the selector will be logged.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择器的执行时间将被记录。
- en: Slow callbacks (more than 100 ms) will be logged. This timeout can be modified
    through `loop.slow_callback_duration`.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢回调（超过100毫秒）将被记录。可以通过`loop.slow_callback_duration`修改此超时时间。
- en: Warnings will be raised when resources are not closed properly.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当资源未正确关闭时，将引发警告。
- en: Tasks that were destroyed before execution will be logged.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行之前被销毁的任务将被记录。
- en: Handling crashes using faulthandler
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用faulthandler处理崩溃
- en: The `faulthandler` module helps when debugging really low-level crashes, that
    is, crashes that should only be possible when using low-level access to memory,
    such as C extensions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`faulthandler`模块在调试真正低级的崩溃时很有帮助，也就是说，只有在使用对内存的低级访问时才可能发生的崩溃，比如C扩展。'
- en: 'For example, here''s a bit of code that will cause your Python interpreter
    to crash:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里有一小段代码，会导致你的Python解释器崩溃：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It results in something similar to the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生类似以下的结果：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That''s quite an ugly response of course and gives you no possibility to handle
    the error. Just in case you are wondering, having a `try/except` structure won''t
    help you in these cases either. The following code will crash exactly in the same
    way:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是一个相当丑陋的响应，而且没有处理错误的可能性。以防你想知道，使用`try/except`结构在这些情况下也无济于事。以下代码将以完全相同的方式崩溃：
- en: '[PRE25]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is where the `faulthandler` module helps. It will still cause your interpreter
    to crash, but at least you will see a proper error message raised, so it''s a
    good default if you (or any of the sublibraries) have any interaction with raw
    memory:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`faulthandler`模块的作用。它仍然会导致解释器崩溃，但至少你会看到一个正确的错误消息，所以如果你（或任何子库）与原始内存有任何交互，这是一个很好的默认选择：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It results in something along these lines:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 它会产生类似以下的结果：
- en: '[PRE27]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Obviously, it's not desirable to have a Python application exit in this manner
    as the code won't exit with a normal cleanup. Resources won't be closed cleanly
    and your exit handler won't be called. If you somehow need to catch this behavior,
    your best bet is to wrap the Python executable in a separate script.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，以这种方式退出Python应用程序是不可取的，因为代码不会以正常的清理退出。资源不会被干净地关闭，退出处理程序也不会被调用。如果你以某种方式需要捕获这种行为，最好的办法是将Python可执行文件包装在一个单独的脚本中。
- en: Interactive debugging
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 交互式调试
- en: Now that we have discussed basic debugging methods that will always work, we
    will look at interactive debugging for some more advanced debugging techniques.
    The previous debugging methods made variables and stacks visible through modifying
    the code and/or foresight. This time around, we will look at a slightly smarter
    method, which constitutes doing the same thing interactively, but once the need
    arises.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些基本的调试方法，这些方法总是有效的，我们将看一些更高级的调试技术。之前的调试方法通过修改代码和/或预见使变量和堆栈可见。这一次，我们将看一种稍微更智能的方法，即在需要时以交互方式执行相同的操作。
- en: Console on demand
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按需控制台
- en: 'When testing some Python code, you may have used the interactive console a
    couple of times, since it''s a simple yet effective tool for testing your Python
    code. What you might not have known is that it is actually simple to start your
    own shell from within your code. So, whenever you want to drop into a regular
    shell from a specific point in your code, that''s easily possible:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试一些Python代码时，你可能已经使用过交互式控制台几次，因为它是测试Python代码的一个简单而有效的工具。你可能不知道的是，从你的代码中启动自己的shell实际上是很简单的。因此，每当你想从代码的特定点进入常规shell时，这是很容易实现的：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When executing that, we will drop into an interactive console halfway:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行时，我们将在交互式控制台中间停下来：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: To exit this console, we can use *^d* (*Ctrl* + *d*) on Linux/Mac systems and
    *^z* (*Ctrl* + *Z*) on Windows systems.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要退出这个控制台，我们可以在Linux/Mac系统上使用*^d*（*Ctrl* + *d*），在Windows系统上使用*^z*（*Ctrl* + *Z*）。
- en: One important thing to note here is that the scope is not shared between the
    two. Even though we passed along `locals()` to share the local variables for convenience,
    this relation is not bidirectional. The result is that even though we set `eggs`
    to `456` in the interactive session, it does not carry over to the outside function.
    You can modify variables in the outside scope through direct manipulation (for
    example, setting the properties) if you wish, but all variables declared locally
    will remain local.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一件重要的事情是，这两者之间的范围是不共享的。尽管我们传递了`locals()`以便共享本地变量以方便使用，但这种关系并不是双向的。结果是，即使我们在交互会话中将`eggs`设置为`456`，它也不会传递到外部函数。如果你愿意，你可以通过直接操作（例如设置属性）来修改外部范围的变量，但所有在本地声明的变量都将保持本地。
- en: Debugging using pdb
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pdb进行调试
- en: 'When it comes to actually debugging code, the regular interactive console just
    isn''t suited. With a bit of effort, you can make it work, but it''s just not
    all that convenient for debugging since you can only see the current scope and
    can''t jump around the stack easily. With `pdb` (Python debugger), this is easily
    possible. So let''s look at a simple example of using `pdb`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际调试代码时，常规的交互式控制台并不适用。通过一些努力，你可以让它工作，但它并不方便调试，因为你只能看到当前的范围，不能轻松地在堆栈中跳转。使用`pdb`（Python调试器）可以轻松实现这一点。让我们看一个使用`pdb`的简单例子：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This example is pretty much identical to the one in the previous paragraph,
    except that this time we end up in the `pdb` console instead of a regular interactive
    console. So let''s give the interactive debugger a try:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子与前一段中的例子几乎完全相同，只是这一次我们最终进入了`pdb`控制台，而不是常规的交互式控制台。所以让我们试试交互式调试器：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, we've actually modified the value of `eggs` now. In this case,
    we used the full `continue` command, but all the `pdb` commands have short versions
    as well. So, using `c` instead of `continue` gives the same result. Just typing
    `eggs` (or any other variable) will show the contents and setting the variable
    will simply set it, just as we would expect from an interactive session.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们现在实际上修改了`eggs`的值。在这种情况下，我们使用了完整的`continue`命令，但所有`pdb`命令也有简写版本。因此，使用`c`而不是`continue`会得到相同的结果。只需输入`eggs`（或任何其他变量）将显示内容，并且设置变量将简单地设置它，就像我们从交互式会话中期望的那样。
- en: 'To get started with `pdb`, first of all, a list of the most useful (full) commands
    with shorthands is shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用`pdb`，首先显示了最有用的（完整）命令列表及其简写：
- en: '| Command | Explanation |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Command | Explanation |'
- en: '| --- | --- |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `h(elp)` | This shows the list of commands (this list). |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `h(elp)` | 显示命令列表（本列表）。 |'
- en: '| `h(elp) command` | This shows the help for the given command. |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| `h(elp) command` | 显示给定命令的帮助信息。 |'
- en: '| `w(here)` | Current stack trace with an arrow at the current frame. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| `w(here)` | 当前堆栈跟踪，箭头指向当前帧。 |'
- en: '| `d(own)` | Move down/to a newer frame in the stack. |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `d(own)` | 移动到堆栈中的下一个帧。 |'
- en: '| `u(p)` | Move up/to an older frame in the stack. |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `u(p)` | 移动到堆栈中的较旧帧。 |'
- en: '| `s(tep)` | Execute the current line and stop as soon as possible. |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `s(tep)` | 执行当前行并尽快停止。 |'
- en: '| `n(ext)` | Execute the current line and stop at the next line within the
    current function. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `n(ext)` | 执行当前行并停在当前函数内的下一行。 |'
- en: '| `r(eturn)` | Continue execution until the function returns. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `r(eturn)` | 继续执行，直到函数返回。 |'
- en: '| `c(ont(inue))` | Continue execution up to the next breakpoint. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `c(ont(inue))` | 继续执行直到下一个断点。 |'
- en: '| `l(ist) [first[, last]]` | List the lines of source code (by default, 11
    lines) around the current line. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `l(ist) [first[, last]]` | 列出（默认情况下，11行）当前行周围的源代码行。 |'
- en: '| `ll &#124; longlist` | List all of the source code for the current function
    or frame. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `ll &#124; longlist` | 列出当前函数或帧的所有源代码。 |'
- en: '| `source expression` | List the source code for the given object. This is
    similar to longlist. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `source expression` | 列出给定对象的源代码。这类似于longlist。 |'
- en: '| `a(rgs)` | Print the arguments for the current function. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `a(rgs)` | 打印当前函数的参数。 |'
- en: '| `pp expression` | Pretty-print the given expression. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `pp expression` | 漂亮地打印给定的表达式。 |'
- en: '| `b(reak)` | Show the list of breakpoints. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak)` | 显示断点列表。 |'
- en: '| `b(reak) [filename:]lineno` | Place a breakpoint at the given line number
    and, optionally, file. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak) [filename:]lineno` | 在给定的行号和（可选）文件处设置断点。 |'
- en: '| `b(reak) function[, condition]` | Place a breakpoint at the given function.
    The condition is an expression that must evaluate to `True` for the breakpoint
    to work. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `b(reak) function[, condition]` | 在给定的函数处设置断点。条件是一个必须评估为`True`的表达式，断点才能起作用。
    |'
- en: '| `cl(ear) [filename:]lineno` | Clear the breakpoint (or breakpoints) at this
    line. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `cl(ear) [filename:]lineno` | 清除这一行的断点（或断点）。 |'
- en: '| `cl(ear) breakpoint [breakpoint ...]` | Clear the breakpoint (or breakpoints)
    with these numbers. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `cl(ear) breakpoint [breakpoint ...]` | 清除这些编号的断点（或断点）。 |'
- en: '| `Command` | List all defined commands. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `Command` | 列出所有定义的命令。 |'
- en: '| `command breakpoint` | Specify a list of commands to execute whenever the
    given breakpoint is encountered. The list is ended using the `end` command. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `command breakpoint` | 指定在遇到给定断点时执行的命令列表。使用`end`命令结束列表。 |'
- en: '| `Alias` | List all aliases. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `Alias` | 列出所有别名。 |'
- en: '| `alias name command` | Create an alias. The command can be any valid Python
    expression, so you can do the following to print all properties for an object:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '| `alias name command` | 创建一个别名。命令可以是任何有效的Python表达式，所以你可以这样做来打印对象的所有属性：'
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '|'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `unalias name` | Remove an alias. |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| `unalias name` | 删除别名。 |'
- en: '| `! statement` | Execute the statement at the current point in the stack.
    Normally the `!` sign is not needed, but this can be useful if there are collisions
    with debugger commands. For example, try `b = 123`. |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `! statement` | 在堆栈的当前位置执行语句。通常情况下不需要`!`符号，但如果与调试器命令发生冲突，这可能会有用。例如，尝试`b =
    123`。'
- en: '| `Interact` | Open an interactive session similar to the previous paragraph.
    Note that variables set within that local scope will not be transferred. |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `Interact` | 打开一个类似于前一段的交互式会话。请注意，设置在该局部范围内的变量不会被传递。 |'
- en: Breakpoints
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断点
- en: 'It''s quite a long list, but you will probably use most of these quite regularly.
    To highlight one of the options shown in the preceding table, let''s demonstrate
    the setting and use of breakpoints:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的列表，但你可能会经常使用其中的大部分。为了突出显示前表中显示的选项之一，让我们演示断点的设置和使用：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'So far, nothing new has happened, but let''s now open the interactive debugging
    session, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，没有发生什么新的事情，但现在让我们打开交互式调试会话，如下所示：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That was a lot of output, but it''s actually not as complex as it seems:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 输出很多，但实际上并不像看起来那么复杂：
- en: First, we used the `source spam` command to see the source for the `spam` function.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们使用`source spam`命令查看`spam`函数的源代码。
- en: After that, we knew the line number of the first `print` statement, which we
    used to place a breakpoint (`b 5`) at line 5.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那之后，我们知道了第一个`print`语句的行号，我们用它在第5行放置了一个断点(`b 5`)。
- en: To check whether we were still at the right position, we used the `w` command.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了检查我们是否仍然在正确的位置，我们使用了`w`命令。
- en: Since the breakpoint was set, we used `c` to continue up to the next breakpoint.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于断点已设置，我们使用`c`继续到下一个断点。
- en: Having stopped at the breakpoint at line 5, we used `w` again to confirm that.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第5行的断点停下后，我们再次使用`w`来确认。
- en: Listing the code of the current function using `ll`.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ll`列出当前函数的代码。
- en: Listing the breakpoints using `b`.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`b`列出断点。
- en: Removing the breakpoint again using `cl 1` with the breakpoint number from the
    previous command.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`cl 1`移除断点，断点号来自于前一个命令。
- en: It all seems a bit complicated in the beginning, but you'll see that it's actually
    a very convenient way of debugging once you've tried a few times.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一开始似乎有点复杂，但你会发现，一旦你尝试了几次，它实际上是一种非常方便的调试方式。
- en: 'To make it even better, this time we will execute the breakpoint only when
    `eggs = 3`. The code is pretty much the same, although we need a variable in this
    case:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使它更好用，这次我们将只在`eggs = 3`时执行断点。代码基本上是一样的，尽管在这种情况下我们需要一个变量：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let''s execute the code and make sure that it only breaks at certain times:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们执行代码，并确保它只在特定时间中断：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To list what we have done:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 总结我们所做的：
- en: First, using `source` spam, we looked for the line number.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用`source` spam，我们查找了行号。
- en: After that, we placed a breakpoint with the `eggs == 3` condition.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们使用`eggs == 3`条件放置了一个断点。
- en: Then we continued execution using `c`. As you can see, the values `0`, `1`,
    and `2` are printed as normal.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用`c`继续执行。如你所见，值`0`、`1`和`2`都正常打印出来了。
- en: The breakpoint was reached at value `3`. To verify this we used `a` to see the
    function arguments.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断点在值`3`处被触发。为了验证这一点，我们使用`a`来查看函数参数。
- en: And we continued to execute the rest of the code.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们继续执行剩下的代码。
- en: Catching exceptions
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捕获异常
- en: 'All of these have been manual calls to the `pdb.set_trace()` function, but
    in general, you are just running your application and not really expecting issues.
    This is where exception catching can be very handy. In addition to importing `pdb`
    yourself, you can run scripts through `pdb` as a module as well. Let''s examine
    this bit of code, which dies as soon as it reaches zero division:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是手动调用`pdb.set_trace()`函数，但一般情况下，你只是运行你的应用程序，并不真的期望出现问题。这就是异常捕获非常有用的地方。除了自己导入`pdb`，你也可以将脚本作为模块通过`pdb`运行。让我们来看看这段代码，一旦它遇到零除法就会中断：
- en: '[PRE37]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'If we run it using the `pdb` parameter, we can end up in the Python Debugger
    whenever it crashes:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`pdb`参数运行它，每当它崩溃时我们就会进入Python调试器：
- en: '[PRE38]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: A useful little trick within `pdb` is to use the *Enter* button, which, by default,
    will execute the previously executed command again. This is very useful when stepping
    through the program.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`中一个有用的小技巧是使用*Enter*按钮，默认情况下，它会再次执行先前执行的命令。当逐步执行程序时，这非常有用。'
- en: Commands
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'The `commands` command is a little complicated but very useful. It allows you
    to execute commands whenever a specific breakpoint is encountered. To illustrate
    this, let''s start from a simple example again:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`commands`命令有点复杂，但非常有用。它允许你在遇到特定断点时执行命令。为了说明这一点，让我们再从一个简单的例子开始：'
- en: '[PRE39]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The code is simple enough, so now we''ll add the breakpoint and the commands,
    as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 代码足够简单，所以现在我们将添加断点和命令，如下所示：
- en: '[PRE40]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As you can see, we can easily add commands to the breakpoint. After removing
    the breakpoint, these commands obviously won't be executed anymore.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们可以很容易地向断点添加命令。在移除断点后，这些命令显然不会再被执行。
- en: Debugging using ipdb
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ipdb进行调试
- en: While the generic Python console is useful, it can be a little rough around
    the edges. The IPython console offers a whole new world of extra features, which
    make it a much nicer console to work with. One of those features is a more convenient
    debugger.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通用的Python控制台虽然有用，但有时会有点粗糙。IPython控制台提供了许多额外功能，使其成为一个更好用的控制台。其中一个功能是更方便的调试器。
- en: 'First, make sure you have `ipdb` installed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 首先确保你已经安装了`ipdb`：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Next, let''s try the debugger again with our previous script. The only small
    change is that we now import `ipdb` instead of `pdb`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们再次尝试使用我们之前的脚本进行调试。唯一的小改变是，我们现在导入的是`ipdb`而不是`pdb`：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we execute it:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们执行它：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The commands are all the same, but the output is just a tad more legible in
    my opinion. The actual version also includes syntax highlighting, which makes
    the output even easier to follow.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 命令都是一样的，但在我看来输出更易读一些。实际版本还包括语法高亮，使输出更容易跟踪。
- en: 'In short, you can just replace `pdb` with `ipdb` in most situations to simply
    get a more intuitive debugger. But I will give you the recommendation as well,
    to the `ipdb` context manager:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，在大多数情况下，你可以简单地用`ipdb`替换`pdb`来获得一个更直观的调试器。但我也会给你推荐`ipdb`上下文管理器：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This is as convenient as it looks. It simply hooks `ipdb` into your exceptions
    so that you can easily debug whenever needed. Combine that with a debug flag to
    your application to easily allow debugging when needed.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这就像看起来的那样方便。它只是将`ipdb`连接到你的异常中，这样你可以在需要时轻松调试。将其与应用程序的调试标志结合使用，可以轻松地在需要时允许调试。
- en: Other debuggers
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他调试器
- en: '`pdb` and `ipdb` are just two of the large number of debuggers available for
    Python. Some of the currently noteworthy debuggers are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`pdb`和`ipdb`只是众多可用于Python的调试器中的两个。目前一些值得注意的调试器如下：'
- en: '`pudb`: This offers a a full-screen command-line debugger'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pudb`：这提供了一个全屏命令行调试器'
- en: '`pdbpp`: This hooks into the regular `pdb`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pdbpp`：这是对常规`pdb`的一个钩子'
- en: '`rpdb2`: This is a remote debugger that allows hooking into running (remote)
    applications'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rpdb2`：这是一个允许连接到运行中（远程）应用程序的远程调试器'
- en: '`Werkzeug`: This is a web-based debugger that allows debugging of web applications
    while they are running'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Werkzeug`：这是一个基于Web的调试器，允许在运行时调试Web应用程序'
- en: There are many others, of course, and there isn't a single one that's the absolute
    best. As is the case with all tools, they all have their advantages and their
    fallacies, and the one that is best for your current purpose can be properly decided
    only by you. Chances are that your current Python IDE already has an integrated
    debugger.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当然还有许多其他调试器，并没有一个绝对最好的。就像所有工具一样，它们都有各自的优势和缺陷，而最适合你当前目的的工具只有你自己才能决定。很可能你当前使用的Python
    IDE已经集成了调试器。
- en: Debugging services
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试服务
- en: In addition to debugging when you encounter a problem, there are times when
    you simply need to keep track of errors for later debugging. Especially when working
    with remote servers, these can be invaluable to detect when and how a Python process
    is malfunctioning. Additionally, these services offer grouping of errors as well,
    making them far more useful than a simple e-mail-on-exception type of script,
    which can quickly spam your inbox.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在遇到问题时进行调试之外，有时您只需要跟踪错误以供以后调试。特别是在与远程服务器一起工作时，这些可以非常宝贵，可以检测 Python 进程何时以及如何发生故障。此外，这些服务还提供错误分组，使它们比简单的异常类型脚本更有用，后者可能会快速填满您的收件箱。
- en: A nice open source solution for keeping track of errors is `sentry`. If you
    need a full-fletched solution that offers performance tracking as well, then Opbeat
    and Newrelic are very nice solutions; they offer both free and paid versions.
    Note that all of these also support tracking of other languages, such as JavaScript.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的开源解决方案，用于跟踪错误的是`sentry`。如果您需要一个提供性能跟踪的完整解决方案，那么 Opbeat 和 Newrelic 都是非常好的解决方案；它们提供免费和付费版本。请注意，所有这些解决方案还支持跟踪其他语言，例如
    JavaScript。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter explained a few different debugging techniques and gotchas. There
    is, of course, much more that can be said about debugging, but I hope you have
    acquired a nice vantage point for debugging your Python code now. Interactive
    debugging techniques are very useful for single-threaded applications and locations
    where interactive sessions are available. But since that's not always the case,
    we also discussed some non-interactive options.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了一些不同的调试技术和陷阱。当然，关于调试还有很多可以说的，但我希望您现在已经获得了一个很好的调试 Python 代码的视角。交互式调试技术对于单线程应用程序和可用交互式会话的位置非常有用。但由于情况并非总是如此，我们还讨论了一些非交互式选项。
- en: 'Here''s an overview of all the points discussed in this chapter:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章讨论的所有要点概述：
- en: 'Non-interactive debugging using:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用非交互式调试：
- en: '`print`'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印
- en: '`logging`'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: '`trace`'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪
- en: '`traceback`'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回溯
- en: '`asyncio`'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`'
- en: '`faulthandler`'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故障处理程序
- en: Interactive debugging using both `pdb` and `ipdb`
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`pdb`和`ipdb`进行交互式调试
- en: In the next chapter, we will see how to monitor and improve both CPU and memory
    performance, as well as finding and fixing memory leaks.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将看到如何监视和改善 CPU 和内存性能，以及查找和修复内存泄漏。
