- en: Chapter 4
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章
- en: 'Data Acquisition Features: Web APIs and Scraping'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数据获取功能：Web API和抓取
- en: Data analysis often works with data from numerous sources, including databases,
    web services, and files prepared by other applications. In this chapter, you will
    be guided through two projects to add additional data sources to the baseline
    application from the previous chapter. These new sources include a web service
    query, and scraping data from a web page.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析通常与来自多个来源的数据一起工作，包括数据库、Web服务和由其他应用程序准备好的文件。在本章中，您将指导完成两个项目，以向上一章的基线应用程序添加额外的数据源。这些新源包括Web服务查询和从网页抓取数据。
- en: 'This chapter’s projects cover the following essential skills:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目涵盖了以下基本技能：
- en: Using the **requests** package for Web API integration. We’ll look at the Kaggle
    API, which requires signing up to create an API token.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**requests**包进行Web API集成。我们将探讨Kaggle API，它需要注册以创建API令牌。
- en: Using the **Beautiful Soup** package to parse an HTML web page.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Beautiful Soup**包解析HTML网页。
- en: Adding features to an existing application and extending the test suite to cover
    these new alternative data sources.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有应用程序添加功能并扩展测试套件以涵盖这些新的替代数据源。
- en: 'It’s important to recognize this application has a narrow focus on data acquisition.
    In later chapters, we’ll validate the data and convert it to a more useful form.
    This reflects a separation of the following distinct concerns:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 认识到这个应用程序在数据获取方面有狭窄的焦点是很重要的。在后面的章节中，我们将验证数据并将其转换为更有用的形式。这反映了以下不同关注点的分离：
- en: Downloading and extracting data from the source are the foci of this chapter
    and the next.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从源下载和提取数据是本章和下一章的重点。
- en: 'Inspection begins in [*Chapter** 6*](ch010.xhtml#x1-1460006), [*Project 2.1:
    Data Inspection Notebook*](ch010.xhtml#x1-1460006).'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查从[*第6章*](ch010.xhtml#x1-1460006)、[*项目2.1：数据检查笔记本*](ch010.xhtml#x1-1460006)开始。
- en: 'Validating and cleaning the data starts in [*Chapter** 9*](ch013.xhtml#x1-2080009),
    [*Project 3.1: Data* *Cleaning Base Application*](ch013.xhtml#x1-2080009).'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证和清理数据从[*第9章*](ch013.xhtml#x1-2080009)、[*项目3.1：数据清理基础应用*](ch013.xhtml#x1-2080009)开始。
- en: Each stage in the processing pipeline is allocated to separate projects. For
    more background, see [*Chapter** 2*](ch006.xhtml#x1-470002), [*Overview of the
    Projects*](ch006.xhtml#x1-470002).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 处理流程中的每个阶段都分配给不同的项目。更多背景信息，请参阅[*第2章*](ch006.xhtml#x1-470002)、[*项目概述*](ch006.xhtml#x1-470002)。
- en: We’ll start by looking at getting data using an API and a RESTful web service.
    This will focus on the Kaggle site, which means you will need to sign up with
    Kaggle to get your own, unique API key. The second project will scrape HTML content
    from a website that doesn’t offer a useful API.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨使用API和RESTful Web服务获取数据。这将侧重于Kaggle网站，这意味着您需要注册Kaggle以获取自己的唯一API密钥。第二个项目将从不提供有用API的网站上抓取HTML内容。
- en: '4.1 Project 1.2: Acquire data from a web service'
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 项目1.2：从Web服务获取数据
- en: It’s common to need data provided by a Web API. One common design approach for
    web services is called RESTful; it’s based on a number of concepts related to
    using the HTTP protocol to transfer a representation of an object’s state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 需要由Web API提供的数据是很常见的。一种常见的Web服务设计方法称为RESTful；它基于与使用HTTP协议传输对象状态表示相关的一系列概念。
- en: For more information on RESTful services, see *Building RESTful Python Web Services*
    ([https://www.packtpub.com/product/building-restful-python-web-services/9781786462251](https://www.packtpub.com/product/building-restful-python-web-services/9781786462251)).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于RESTful服务的信息，请参阅*构建RESTful Python Web服务*([https://www.packtpub.com/product/building-restful-python-web-services/9781786462251](https://www.packtpub.com/product/building-restful-python-web-services/9781786462251))。
- en: A RESTful service generally involves using the HTTP protocol to respond to requests
    from client applications. The spectrum of request types includes a number of verbs
    like get, post, put, patch, and delete. In many cases, the service responds with
    a JSON document. It’s also possible to receive a file that’s a stream of NDJSON
    documents, or even a file that’s a ZIP archive of data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful服务通常涉及使用HTTP协议响应用户应用程序的请求。请求类型包括get、post、put、patch和delete等动词。在许多情况下，服务以JSON文档响应。也有可能接收一个包含NDJSON文档流的文件，甚至是一个包含数据ZIP存档的文件。
- en: We’ll start with a description of the application, and then move on to talk
    about the architectural approach. This will be followed with a detailed list of
    deliverables.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从对应用程序的描述开始，然后转向讨论架构方法。这将随后是一个详细的交付物清单。
- en: 4.1.1 Description
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 描述
- en: Analysts and decision-makers need to acquire data for further analysis. In this
    case, the data is available from a RESTful web service. One of the most fun small
    data sets to work with is Anscombe’s Quartet – [https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet](https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 分析师和决策者需要获取数据以进行进一步分析。在这种情况下，数据可以从 RESTful 网络服务中获得。最有趣的小数据集之一是安斯康姆四重奏 – [https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet](https://www.kaggle.com/datasets/carlmcbrideellis/data-anscombes-quartet)
- en: 'Parts of this application are an extension to the project in [*Chapter** 9*](ch013.xhtml#x1-2080009),
    [*Project* *3.1: Data Cleaning Base Application*](ch013.xhtml#x1-2080009). The
    essential behavior of this application will be similar to the previous project.
    This project will use a CLI application to grab data from a source.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用程序的部分是第 9 章[*项目* 3.1：数据清洗基础应用程序](ch013.xhtml#x1-2080009)中项目的扩展。此应用程序的基本行为将与之前的类似。本项目将使用
    CLI 应用程序从源抓取数据。
- en: 'The **User Experience** (**UX**) will also be a command-line application with
    options to fine-tune the data being gathered. Our expected command line should
    like something like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户体验**（**UX**）也将是一个命令行应用程序，具有微调正在收集的数据的选项。我们期望的命令行可能如下所示：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `-o`` quartet` argument specifies a directory into which four results are
    written. These will have names like `quartet/series_1.json`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` `quartet` 参数指定了一个目录，四个结果将被写入其中。这些将具有类似 `quartet/series_1.json` 的名称。'
- en: The `-k`` kaggle.json` argument is the name of a file with the username and
    Kaggle API token. This file is kept separate from the application software. In
    the example, the file was in the author’s `Downloads` folder.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`-k` `kaggle.json` 参数是包含用户名和 Kaggle API 令牌的文件名。这个文件与应用程序软件分开保存。在示例中，该文件位于作者的
    `下载` 文件夹中。'
- en: The `--zip` argument provides the ”reference” — the owner and data set name
    — to open and extract. This information is found by examining the details of the
    Kaggle interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`--zip` 参数提供了“参考”——所有者和数据集名称——以打开和提取。这些信息可以通过检查 Kaggle 界面的详细信息来找到。'
- en: An additional feature is to get a filtered list of Kaggle data sets. This should
    be a separate `--search` operation that can be bundled into a single application
    program.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个功能是获取 Kaggle 数据集的筛选列表。这应该是一个单独的 `--search` 操作，可以捆绑到一个单一的应用程序中。
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will apply some search criteria to emit a list of data sets that match
    the requirements. The lists tend to be quite large, so this needs to be used with
    care.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将对一些搜索标准进行应用，以输出符合要求的数据集列表。这些列表往往相当庞大，因此需要谨慎使用。
- en: The credentials in the file are used to make the Kaggle API request. In the
    next sections, we’ll look at the Kaggle API in general. After that, we’ll look
    at the specific requests required to locate the reference to the target data set.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的凭证用于发出 Kaggle API 请求。在接下来的几节中，我们将一般性地查看 Kaggle API。之后，我们将查看定位目标数据集引用所需的具体请求。
- en: The Kaggle API
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kaggle API
- en: See [https://www.kaggle.com/docs/api](https://www.kaggle.com/docs/api) for information
    on the Kaggle API. This document describes some command-line code (in Python)
    that uses the API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Kaggle API 的信息，请参阅 [https://www.kaggle.com/docs/api](https://www.kaggle.com/docs/api)。这份文档描述了一些使用
    API 的命令行代码（Python 语言）。
- en: The technical details of the RESTful API requests are at [https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml](https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml).
    This document describes the requests and responses from the Kaggle API server.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API 请求的技术细节可以在 [https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml](https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml)
    找到。这份文档描述了 Kaggle API 服务器端的请求和响应。
- en: To make use of the RESTful API or the command-line applications, you should
    register with Kaggle. First, sign up with `Kaggle.com`. Next, navigate to the
    public profile page. On this page, there’s an API section. This section has the
    buttons you will use to generate a unique API token for your registered username.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 RESTful API 或命令行应用程序，您应该在 Kaggle 上注册。首先，在 `Kaggle.com` 上注册。然后，导航到公共个人资料页面。在这个页面上，有一个
    API 部分。这个部分有您将使用的按钮，用于为您注册的用户名生成唯一的 API 令牌。
- en: The third step is to click the **Create New Token** button to create the token
    file. This will download a small JSON file with your registered username and unique
    key. These credentials are required by the Kaggle REST API.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第三步是点击 **创建新令牌** 按钮，以创建令牌文件。这将下载一个包含您注册的用户名和唯一密钥的小型 JSON 文件。这些凭证是 Kaggle REST
    API 所必需的。
- en: 'The ownership of this file can be changed to read-only by the owner. In Linux
    and macOS, this is done with the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的所有权可以被所有者更改为只读。在 Linux 和 macOS 上，这可以通过以下命令完成：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Do not move the Kaggle credentials file named `kaggle.json` into a directory
    where your code is also located. It’s tempting, but it’s a terrible security mistake
    because the file could get saved to a code repository and become visible to anyone
    browsing your code. In some enterprises, posting keys in code repositories — even
    internal repositories — is a security lapse and a good reason for an employee
    to be terminated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将名为 `kaggle.json` 的 Kaggle 凭证文件移动到包含你代码的目录中。这样做很诱人，但这是一个严重的安全错误，因为文件可能会被保存到代码仓库中，任何人浏览你的代码时都能看到。在一些企业中，即使在内部仓库中发布密钥也是安全漏洞，这可能是解雇员工的好理由。
- en: Because Git keeps a very complete history, it’s challenging to remove a commit
    that contains keys.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Git 保存了非常完整的历史记录，因此很难删除包含密钥的提交。
- en: '**Keep the credentials file separate from your code.**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**请将凭证文件与你的代码分开存放。**'
- en: It’s also a good idea to add `kaggle.json` to a `.gitignore` file to make extra
    sure that it won’t be uploaded as part of a commit and push.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个好主意是将 `kaggle.json` 添加到 `.gitignore` 文件中，以确保它不会作为提交的一部分被上传。
- en: About the source data
  id: totrans-41
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关于源数据
- en: This project will explore two separate kinds of source data. Both sources have
    the same base path of [https://www.kaggle.com/api/v1/](https://www.kaggle.com/api/v1/).
    Trying to query this base path won’t provide a useful response; it’s only the
    starting point for the paths that are built to locate specific resources.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目将探索两种不同的源数据。这两个源都有相同的 [https://www.kaggle.com/api/v1/](https://www.kaggle.com/api/v1/)
    基本路径。尝试查询此基本路径不会提供有用的响应；它只是构建用于定位特定资源的路径的起点。
- en: JSON documents with summaries of data sets or metadata about data sets. These
    come from appending `datasets/list` to the base path.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含数据集摘要或数据集元数据的 JSON 文档。这些来自于将 `datasets/list` 添加到基本路径。
- en: A ZIP archive that contains the data we’ll use as an example. This comes from
    appending `datasets/download/{ownerSlug}/{datasetSlug}` to the base path. The
    `ownerSlug` value is ”carlmcbrideellis”. The `datasetSlug` value is ”data-anscombes-quartet”.
    A given data set has a `ref` value as a reference string with the required ”ownerSlug/datasetSlug”
    format.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含我们将用作示例的数据的 ZIP 归档。这来自于将 `datasets/download/{ownerSlug}/{datasetSlug}` 添加到基本路径。`ownerSlug`
    的值是 ”carlmcbrideellis”。`datasetSlug` 的值是 ”data-anscombes-quartet”。给定数据集有一个 `ref`
    值，作为具有所需 ”ownerSlug/datasetSlug” 格式的参考字符串。
- en: The JSON documents require a function to extract a few relevant fields like
    `title`, `ref`, `url`, and `totalBytes`. This subset of the available metadata
    can make it easier to locate useful, interesting data sets. There are numerous
    other properties available for search, like `usabilityRating`; these attributes
    can distinguish good data sets from experiments or classroom work.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 文档需要一个函数来提取一些相关的字段，如 `title`、`ref`、`url` 和 `totalBytes`。这个可用的元数据子集可以更容易地定位有用的、有趣的数据集。还有许多其他可用于搜索的属性，如
    `usabilityRating`；这些属性可以区分好的数据集与实验或课堂作业。
- en: 'The suggested data set — the Anscombe Quartet — is available as a ZIP-compressed
    archive with a single item inside it. This means the application must handle ZIP
    archives and expand a file contained within the archive. Python offers the `zipfile`
    package to handle locating the CSV file within the archive. Once this file is
    found, the existing programming from the previous chapter ([*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data Acquisition Base Application*](ch007.xhtml#x1-560003)) can
    be used.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 建议的数据集——Anscombe 四重奏——作为一个包含单个项目的 ZIP 压缩归档提供。这意味着应用程序必须处理 ZIP 归档并展开归档中的文件。Python
    提供了 `zipfile` 包来处理在归档中定位 CSV 文件。一旦找到这个文件，就可以使用上一章中现有的编程（[*第 3 章*](ch007.xhtml#x1-560003)，[*项目
    1.1：数据获取基础应用程序*](ch007.xhtml#x1-560003)）。
- en: There are thousands of Kaggle data sets. We’ll suggest some alternatives to
    the Anscombe Quartet in the [*Extras*](#x1-1080004).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Kaggle 上有成千上万的数据集。我们将在 [*附加内容*](#x1-1080004) 中建议一些 Anscombe 四重奏的替代方案。
- en: This section has looked at the input, processing, and output of this application.
    In the next section, we’ll look at the overall architecture of the software.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了该应用程序的输入、处理和输出。在下一节中，我们将探讨该软件的整体架构。
- en: 4.1.2 Approach
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 方法
- en: 'We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视我们的方法时，我们将借鉴 C4 模型（[https://c4model.com](https://c4model.com)）的一些指导原则：
- en: '**Context**: For this project, a context diagram would show a user extracting
    data from a source. You may find it helpful to draw this diagram.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：对于这个项目，上下文图将显示用户从源提取数据。你可能觉得绘制这个图有帮助。'
- en: '**Containers**: One container is the user’s personal computer. The other container
    is the Kaggle website, which provides the data.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**：一个是用户的个人电脑。另一个容器是Kaggle网站，它提供数据。'
- en: '**Components**: We’ll address the components below.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**：我们将讨论以下组件。'
- en: '**Code**: We’ll touch on this to provide some suggested directions.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**：我们将简要提及，以提供一些建议的方向。'
- en: 'It’s important to consider this application as an extension to the project
    in [*Chapter** 3*](ch007.xhtml#x1-560003), [*Project 1.1: Data Acquisition Base
    Application*](ch007.xhtml#x1-560003). The base level of architectural design is
    provided in that chapter.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个应用程序是[*第3章*](ch007.xhtml#x1-560003)，[*项目1.1：数据采集基础应用*](ch007.xhtml#x1-560003)项目的扩展是很重要的。该章节提供了架构设计的基线。
- en: In this project, we’ll be adding a new `kaggle_client` module to download the
    data. The overall application in the `acquire` module will change to make use
    of this new module. The other modules should remain unchanged.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将添加一个新的`kaggle_client`模块以下载数据。`acquire`模块中的整体应用程序将改变以使用这个新模块。其他模块应保持不变。
- en: The legacy component diagram is shown in [*Figure 4.1*](#4.1).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 遗留组件图如图[*图4.1*](#4.1)所示。
- en: '![Figure 4.1: Legacy Components ](img/file14.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1：遗留组件](img/file14.jpg)'
- en: 'Figure 4.1: Legacy Components'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：遗留组件
- en: A new architecture can handle both the examination of the JSON data set listing,
    as well as the download of a single ZIP file. This is shown in [*Figure 4.2*](#4.2).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 新架构可以处理JSON数据集列表的检查以及单个ZIP文件的下载。这如图[*图4.2*](#4.2)所示。
- en: '![Figure 4.2: Revised Component Design ](img/file15.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：修订后的组件设计](img/file15.jpg)'
- en: 'Figure 4.2: Revised Component Design'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：修订后的组件设计
- en: The new module here is the `kaggle_client` module. This has a class, `RestAccess`,
    that provides methods to access Kaggle data. It can reach into the Kaggle data
    set collection and retrieve a desired ZIP file. Additional methods can be added
    to examine the list of data sets or get data set metadata.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的新模块是`kaggle_client`模块。它有一个名为`RestAccess`的类，提供了访问Kaggle数据的方法。它可以访问Kaggle数据集集合并检索所需的ZIP文件。还可以添加其他方法来检查数据集列表或获取数据集元数据。
- en: The `RestAccess` class is initialized with the contents of the `kaggle.json`
    file. As part of initialization, it can create the required authentication object
    for use in all subsequent calls.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestAccess`类使用`kaggle.json`文件的内容进行初始化。作为初始化的一部分，它可以创建所有后续调用所需的认证对象。'
- en: 'In the following sections, we’ll look at these features of the `RestAccess`
    class:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将查看`RestAccess`类的这些功能：
- en: Making API requests in general.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以通用方式发出API请求。
- en: Getting the ZIP archive.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取ZIP存档。
- en: Getting the list of data sets.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取数据集列表。
- en: Handling the rate-limiting response.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理速率限制响应。
- en: We’ll start with the most important feature, making API requests in a general
    way.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最重要的功能开始，即以通用方式发出API请求。
- en: Making API requests
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发出API请求
- en: The component diagram shows the `requests` package as the preferred way to access
    RESTful APIs. This package should be added to the project’s `pyproject.toml` and
    installed as part of the project’s virtual environment.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 组件图显示`requests`包是访问RESTful API的首选方式。这个包应该添加到项目的`pyproject.toml`文件中，并在项目的虚拟环境中安装。
- en: It’s also sensible to make RESTful API requests with the `urllib` package. This
    is part of the standard library. It works nicely and requires no additional installation.
    The code can become rather complicated-looking, however, so it’s not as highly
    recommended as the `requests` package.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`urllib`包发出RESTful API请求也是合理的。这是标准库的一部分。它工作得很好，不需要额外的安装。然而，代码可能会变得相当复杂，因此它不如`requests`包那样被高度推荐。
- en: 'The essential benefit of using `requests` is creating an authentication object
    and providing it in each request. We often use code like the following example:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requests`的基本好处是创建一个认证对象并在每个请求中提供它。我们经常使用如下示例代码：
- en: '[PRE3]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This can be part of the `__init__()` method of the `RestAccess` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以是`RestAccess`类的`__init__()`方法的一部分。
- en: The `auth` object created here can be used to make all subsequent requests.
    This will provide the necessary username and API token to validate the user. This
    means other methods can, for example, use `requests.get()` with a keyword parameter
    value of `auth=self.auth`. This will correctly build the needed `Authorization`
    headers in each request.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这里创建的`auth`对象可以用来进行所有后续请求。这将提供必要的用户名和API令牌以验证用户。这意味着其他方法可以使用`requests.get()`，并带有`auth=self.auth`的关键字参数值。这将正确构建每个请求中所需的`Authorization`头。
- en: Once the class is initialized properly, we can look at the method for downloading
    a ZIP archive
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类被正确初始化，我们就可以查看下载ZIP存档的方法
- en: Downloading a ZIP archive
  id: totrans-79
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 下载ZIP存档
- en: The `RestAccess` class needs a `get_zip()` method to download the ZIP file.
    The parameter is the URL for downloading the requested data set.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestAccess`类需要一个`get_zip()`方法来下载ZIP文件。参数是请求的数据集的下载URL。'
- en: 'The best approach to building this URL for this data set is to combine three
    strings:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为此数据集构建此URL的最佳方法是将三个字符串组合起来：
- en: The base address for the APIs, `https://www.kaggle.com/api/v1`.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API的基本地址，`https://www.kaggle.com/api/v1`。
- en: The path for downloads, `/datasets/download/`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载路径，`/datasets/download/`。
- en: 'The reference is a string with the form: `{ownerSlug}/{datasetSlug}`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考是一个具有以下形式的字符串：`{ownerSlug}/{datasetSlug}`。
- en: This is an ideal place for a Python f-string to replace the reference in the
    URL pattern.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在Python f-string替换URL模式中引用的理想位置。
- en: The output from the `get_zip()` method should be a `Path` object. In some cases,
    the ZIP archives are gigantic and can’t be processed entirely in memory. In these
    extreme cases, a more complicated, chunked download is required. For these smaller
    files used by this project, the download can be handled entirely in memory. Once
    the ZIP file has been written, the client of this `RestAccess` class can then
    open it and extract the useful member.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_zip()`方法的输出应该是一个`Path`对象。在某些情况下，ZIP存档非常大，无法完全在内存中处理。在这些极端情况下，需要更复杂的分块下载。对于本项目使用的这些较小的文件，下载可以完全在内存中处理。一旦ZIP文件被写入，这个`RestAccess`类的客户端就可以打开它并提取有用的成员。'
- en: A separate client function or class will process the content of the ZIP archive
    file. The following is **not** part of the `RestAccess` class but is part of some
    client class or function that uses the `RestAccess` class.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个单独的客户端函数或类将处理ZIP存档文件的内容。以下内容**不属于**`RestAccess`类，而是属于使用`RestAccess`类的某个客户端类或函数的一部分。
- en: 'Processing an element of an archive can be done with two nested `with` contexts.
    They would work like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用两个嵌套的`with`上下文可以处理存档的元素。它们将这样工作：
- en: An outer `with` statement uses the `zipfile` module to open the archive, creating
    a `ZipFile` instance.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部`with`语句使用`zipfile`模块打开存档，创建一个`ZipFile`实例。
- en: An inner `with` statement can open the specific member with the Anscombe quartet
    CSV file. Inside this context, the application can create a `csv.DictReader` and
    use the existing `Extract` class to read and process the data.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部`with`语句可以打开包含安斯康姆四重奏CSV文件的特定成员。在这个上下文中，应用程序可以创建一个`csv.DictReader`并使用现有的`Extract`类来读取和处理数据。
- en: What’s important here is we don’t need to unpack the ZIP archive and litter
    our storage with unzipped files. An application can open and process the elements
    using the `ZipFile.open()` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是我们不需要解压ZIP存档，也不需要在我们的存储中散布未解压的文件。应用程序可以使用`ZipFile.open()`方法打开并处理元素。
- en: In addition to downloading the ZIP archive, we may also want to survey the available
    data sets. For this, a special iterator method is helpful. We’ll look at that
    next.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了下载ZIP存档外，我们还可能想调查可用的数据集。为此，一个特殊的迭代方法很有帮助。我们将在下一节中查看它。
- en: Getting the data set list
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 获取数据集列表
- en: 'The catalog of data sets is found by using the following path:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集目录是通过以下路径找到的：
- en: '[https://www.kaggle.com/api/v1/datasets/list](https://www.kaggle.com/api/v1/datasets/list)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/api/v1/datasets/list](https://www.kaggle.com/api/v1/datasets/list)'
- en: The `RestAccess` class can have a `dataset_iter()` method to iterate through
    the collection of data sets. This is helpful for locating other data sets. It’s
    not required for finding the Anscombe’s Quartet, since the `ownerSlug` and `datasetSlug`
    reference information is already known.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`RestAccess`类可以有一个`dataset_iter()`方法来遍历数据集集合。这对于定位其他数据集很有帮助。对于寻找安斯康姆四重奏，这不是必需的，因为`ownerSlug`和`datasetSlug`引用信息已经已知。'
- en: This method can make a `GET` request via the `requests.get()` function to this
    URL. The response will be on the first page of available Kaggle data sets. The
    results are provided in pages, and each request needs to provide a page number
    as a parameter to get subsequent pages.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法可以通过`requests.get()`函数向此URL发出`GET`请求。响应将是可用的Kaggle数据集的第一页。结果以分页形式提供，并且每个请求都需要提供一个页面号参数以获取后续页面。
- en: 'Each page of results will be a JSON document that contains a sequence of dictionary
    objects. It has the following kind of structure:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 每页的结果将是一个包含一系列字典对象的JSON文档。它具有以下类型的结构：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This kind of two-tiered structure — with pages and items within each page —
    is the ideal place to use a generator function to iterate through the pages. Within
    an outer cycle, an inner iteration can yield the individual data set rows from
    each page.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种两层结构——包含每个页面内的页面和项目——是使用生成器函数遍历页面的理想场所。在外部循环中，内部迭代可以生成每个页面的单个数据集行。
- en: 'This nested iteration can look something like the following code snippet:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌套迭代可能看起来像以下代码片段：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This shows the nested processing of the `while` statement ends when a response
    contains a page of results with zero entries in it. The processing to handle too
    many requests is omitted. Similarly, the logging of unexpected responses is also
    omitted.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了嵌套处理的`while`语句何时结束，即当响应包含一个结果为零的页面时。处理过多请求的步骤被省略。同样，意外响应的记录也被省略。
- en: 'A client function would use the `RestAccess` class to scan data sets and would
    look like the following example:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端函数将使用`RestAccess`类来扫描数据集，如下面的示例所示：
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This will process all of the data set descriptions returned by the `RestReader`
    object, `reader`. The `dataset_iter()` method needs to accept a `query` parameter
    that can limit the scope of the search. We encourage you to read the OpenAPI specification
    to see what options are possible for the `query` parameter. These values will
    become part of the query string in the HTTP `GET` request.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这将处理由`RestReader`对象`reader`返回的所有数据集描述。`dataset_iter()`方法需要接受一个`query`参数，该参数可以限制搜索范围。我们鼓励您阅读OpenAPI规范，以了解`query`参数可能的选项。这些值将成为HTTP
    `GET`请求中的查询字符串的一部分。
- en: 'Here’s the formal definition of the interface:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这是接口的正式定义：
- en: '[https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml](https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml](https://github.com/Kaggle/kaggle-api/blob/master/KaggleSwagger.yaml)'
- en: 'Some of the query parameters include the following:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一些查询参数包括以下内容：
- en: The `filetype` query is helpful in locating data in JSON or CSV formats.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filetype`查询有助于定位JSON或CSV格式的数据。'
- en: The `maxSize` query can constrain the data sets to a reasonable size. For initial
    exploration, 1MB is a good upper limit.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxSize`查询可以限制数据集的大小在合理范围内。对于初始探索，1MB是一个良好的上限。'
- en: Initial spike solutions — without regard to the rate limiting — will turn up
    at least 80 pages of possible data sets. Handling the rate-limiting response will
    produce more extensive results, at the cost of some time spent waiting. In the
    next section, we’ll expand this method to handle the error response.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的峰值解决方案——不考虑速率限制——至少会显示80页可能的数据集。处理速率限制响应会产生更广泛的结果，但会花费一些等待时间。在下一节中，我们将扩展此方法以处理错误响应。
- en: Rate limiting
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 速率限制
- en: As with many APIs, the Kaggle API imposes rate-limiting to avoid a **Denial-of-Service**
    (**DoS**) attack. For more information see [https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多API一样，Kaggle API通过速率限制来避免**拒绝服务**（**DoS**）攻击。更多信息请参阅[https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Denial_of_Service_Cheat_Sheet.html)。
- en: Each user has a limited number of requests per second. While the limit is generous
    for most purposes, it will tend to prevent a simple scan of **all** data sets.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户每秒都有一定数量的请求限制。虽然对于大多数用途来说这个限制很宽松，但它往往会防止对**所有**数据集进行简单扫描。
- en: A status code of 429 in a Kaggle response tells the client application that
    too many requests were made. This ”too many requests” error response will have
    a header with the key `Retry-After`. This header’s value is the timeout interval
    (in seconds) before the next request can be made.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Kaggle响应中的状态码429告诉客户端应用程序已发出过多请求。这个“过多请求”错误响应将包含一个键为`Retry-After`的标题。此标题的值是下一次请求可以发出之前的超时间隔（以秒为单位）。
- en: 'A reliable application will have a structure that handles the 429 vs. 200 responses
    gracefully. The example in the previous section has a simple `if` statement to
    check the condition `if`` response.status_code`` ==`` 200`. This needs to be expanded
    to handle these three alternatives:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可靠的应用程序将有一个能够优雅处理 429 与 200 响应的结构。前一个示例中有一个简单的 `if` 语句来检查条件 `if response.status_code
    == 200`。这需要扩展以处理这三个替代方案：
- en: A status code of 200 is a good response. If the page has any details, these
    can be processed; the value of `page` can be incremented. Otherwise, there’s no
    more data making it appropriate to break from the containing `while` statement.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态码 200 是一个良好的响应。如果页面有任何详细信息，可以对其进行处理；`page` 的值可以增加。否则，没有更多数据，这使得从包含的 `while`
    语句中退出是合适的。
- en: A status code of 429 means too many requests were made. Get the value of the
    `Retry-After` and sleep for this period of time.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态码 429 表示请求过多。获取 `Retry-After` 的值并在此期间休眠。
- en: Any other status code indicates a problem and should be logged or raised as
    an exception.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何其他状态码表示存在问题，应该记录或抛出异常。
- en: One possible algorithm for return rows and handling rate limiting delays is
    shown in [*Figure 4.3*](#4.3).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能的算法用于返回行和处理速率限制延迟，如图 [*4.3*](#4.3) 所示。
- en: '![Figure 4.3: Kaggle rate-limited paging ](img/file16.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：Kaggle 速率限制分页](img/file16.jpg)'
- en: 'Figure 4.3: Kaggle rate-limited paging'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：Kaggle 速率限制分页
- en: Handling rate limiting will make the application much easier to use. It will
    also produce more complete results. Using an effective search filter to reduce
    the number of rows to a sensible level will save a lot of waiting for the retry-after
    delays.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 处理速率限制将使应用程序更容易使用。它还将产生更完整的结果。使用有效的搜索过滤器将行数减少到合理的水平将节省大量的重试延迟等待时间。
- en: The main() function
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`main()` 函数'
- en: 'The current application design has these distinct features:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当前应用程序设计具有以下独特功能：
- en: Extract data from a local CSV file.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本地 CSV 文件中提取数据。
- en: Download a ZIP archive and extract data from a CSV member of the archive.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载 ZIP 存档并从存档的 CSV 成员中提取数据。
- en: (Optionally) Survey the data set list to find other interesting data sets to
    process.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: （可选）调查数据集列表以找到其他有趣的数据集进行处理。
- en: 'This suggests that our `main()` function should be a container for three distinct
    functions that implement each separate feature. The `main()` function can parse
    the command-line arguments, and then make a number of decisions:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的 `main()` 函数应该是一个容器，包含三个实现每个单独功能的独立函数。`main()` 函数可以解析命令行参数，然后做出一系列决定：
- en: '**Local Extract**: If the `-o` option is present (without the `-k` option),
    then this is a local file extract. This was the solution from an earlier chapter.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地提取**：如果存在 `-o` 选项（没有 `-k` 选项），则这是一个本地文件提取。这是前面章节中的解决方案。'
- en: '**Download and Extract**: If the `-k` and `-o` options are present, then this
    will be a download and extract. It will use the `RestAccess` object to get the
    ZIP archive. Once the archive is opened, the member processing is the solution
    from an earlier chapter.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下载和提取**：如果存在 `-k` 和 `-o` 选项，则这将是一个下载和提取操作。它将使用 `RestAccess` 对象获取 ZIP 存档。一旦存档打开，成员处理是前面章节中的解决方案。'
- en: '**Survey**: If the `-k` and `-s` (or `--search`) options are present, then
    this is a search for interesting data sets. You are encouraged to work out the
    argument design to provide the needed query parameters to the application.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调查**：如果存在 `-k` 和 `-s`（或 `--search`）选项，则这是对有趣数据集的搜索。鼓励您设计参数以向应用程序提供所需的查询参数。'
- en: '**Otherwise**: If none of the above patterns match the options, this is incoherent,
    and an exception should be raised.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**其他情况**：如果上述任何模式都不匹配选项，这是不连贯的，应该抛出异常。'
- en: Each of these features requires a distinct function. A common alternative design
    is to use the **Command** pattern and create a class hierarchy with each of the
    features as a distinct subclass of some parent class.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能中的每一个都需要一个不同的函数。一个常见的替代设计方案是使用 **命令** 模式，并创建一个类层次结构，其中每个功能作为一个父类的不同子类。
- en: One central idea is to keep the `main()` function small, and dispatch the detailed
    work to other functions or objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一个中心思想是保持 `main()` 函数小巧，并将详细工作分配给其他函数或对象。
- en: The other central idea is **Don’t Repeat Yourself** (**DRY**). This principle
    makes it imperative to **never** copy and paste code between the ”Download-and-Extract”
    feature and the ”Local-Extract” feature. The ”Download-and-Extract” processing
    must reuse the ”Local-Extract” processing either through subclass inheritance
    or calling one function from another.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个核心思想是**不要重复自己**（**DRY**）。这一原则使得在“下载并提取”功能和“本地提取”功能之间**永远**不要复制和粘贴代码变得至关重要。“下载并提取”处理必须通过子类继承或从一个函数调用另一个函数来重用“本地提取”处理。
- en: Now that we have a technical approach, it’s time to look at the deliverables
    for this project.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了技术方法，是时候看看这个项目的交付成果了。
- en: 4.1.3 Deliverables
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 交付成果
- en: 'This project has the following deliverables:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目有以下交付成果：
- en: Documentation in the `docs` folder.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`文件夹中的文档。'
- en: Acceptance tests in the `tests/features` and `tests/steps` folders.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests/features`和`tests/steps`文件夹中的验收测试。'
- en: A miniature RESTful web service that provides test responses will be part of
    the acceptance test.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个微型RESTful Web服务，提供测试响应，将是验收测试的一部分。
- en: Unit tests for the application modules in the `tests` folder.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`文件夹中的应用程序模块的单元测试。'
- en: Mock objects for the `requests` module will be part of the unit tests.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requests`模块的模拟对象将是单元测试的一部分。'
- en: Application to download and acquire data from a RESTful web service.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下载并从RESTful Web服务获取数据的程序。
- en: Be sure to include additional packages like `requests` and `beautifulsoup4`
    in the `pyproject.toml` file. The **pip-compile** command can be used to create
    a `requirements.txt` usable by the **tox** tool for testing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在`pyproject.toml`文件中包含额外的包，如`requests`和`beautifulsoup4`。可以使用**pip-compile**命令创建一个`requirements.txt`文件，该文件可用于**tox**工具进行测试。
- en: We’ll look at a few of these deliverables in a little more detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看其中的一些交付成果。
- en: Unit tests for the RestAccess class
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: RestAccess类的单元测试
- en: For unit testing, we don’t want to involve the `requests` module. Instead, we
    need to make a mock interface for the `requests` module to confirm the application
    `RestAccess` module uses the `requests` classes properly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单元测试，我们不希望涉及`requests`模块。相反，我们需要为`requests`模块创建一个模拟接口，以确认应用程序`RestAccess`模块正确使用了`requests`类。
- en: 'There are two strategies for plugging in mock objects:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种策略用于插入模拟对象：
- en: Implement a dependency injection technique, where the target class is named
    at run time.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一种依赖注入技术，其中目标类在运行时命名。
- en: Use *Monkey Patching* to inject a mock class at test time.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用*猴子补丁*在测试时注入模拟类。
- en: When working with external modules — modules where we don’t control the design
    — monkey patching is often easier than trying to work out a dependency injection
    technique. When we’re building the classes in a module, we often have a need to
    extend the definitions via subclasses. One of the reasons for creating unique,
    customized software is to implement change in the unique features of an application
    rapidly. The non-unique features (RESTful API requests, in this case) change very
    slowly and don’t benefit from flexibility.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当与外部模块（我们无法控制其设计的模块）一起工作时，猴子补丁通常比尝试使用依赖注入技术更容易。当我们在一个模块中构建类时，我们经常需要通过子类扩展定义。创建独特、定制软件的一个原因是为了快速实现应用程序独特功能的变更。非独特功能（在本例中为RESTful
    API请求）变化非常缓慢，并且不受益于灵活性。
- en: We want to create two mock classes, one to replace the `requests.auth.HTTPBasicAuth`
    class, and one to replace the `requests.get()` function. The mock for the `HTTPBasicAuth`
    class doesn’t do anything; we want to examine the mock object to be sure it was
    called once with the proper parameters. The mock for the `requests.get()` function
    needs to create mock `Response` objects for various test scenarios.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想创建两个模拟类，一个用于替换`requests.auth.HTTPBasicAuth`类，另一个用于替换`requests.get()`函数。`HTTPBasicAuth`类的模拟不做任何事情；我们想检查模拟对象是否被一次且仅一次以正确的参数调用。`requests.get()`函数的模拟需要为各种测试场景创建模拟`Response`对象。
- en: We’ll need to use the `monkeypatch` fixture of the `pytest` module to replace
    the real objects with the mock objects for unit testing.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用`pytest`模块的`monkeypatch`配置来用模拟对象替换真实对象，以便进行单元测试。
- en: 'The idea is to create unit tests that have a structure similar to the following
    example:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 策略是创建具有以下示例类似结构的单元测试：
- en: '[PRE7]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This test case creates a mock for the `HTTPBasicAuth` class. When the class
    is called to create an instance, it returns a `sentinel` object that can be verified
    by a test case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试用例为`HTTPBasicAuth`类创建了一个模拟对象。当调用该类以创建实例时，它返回一个可以被测试用例验证的`sentinel`对象。
- en: The `monkeypatch` fixture replaces the `requests.auth.HTTPBasicAuth` class with
    the mock object. After this patch is applied, when the `RestAccess` class initialization
    attempts to create an instance of the `HTTPBasicAuth` class, it will invoke the
    mock, and will get a `sentinel` object instead.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`monkeypatch`固定装置用模拟对象替换了`requests.auth.HTTPBasicAuth`类。在此修补程序应用后，当`RestAccess`类初始化尝试创建`HTTPBasicAuth`类的实例时，它将调用模拟，并得到一个`sentinel`对象。'
- en: The case confirms the `sentinel` object is used by the `RestAccess` instance.
    The test case also confirms the mock class was called exactly once with the expected
    values taken from the mocked value loaded from the `kaggle.json` file.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该用例确认了`RestAccess`实例使用了`sentinel`对象。测试用例还确认了模拟类恰好被调用了一次，使用从`kaggle.json`文件加载的模拟值。
- en: This test case relies on looking inside the `RestAccess` instance. This isn’t
    the best strategy for writing unit tests. A better approach is to provide a mock
    object for `requests.get()`. The test case should confirm the `requests.get()`
    is called with a keyword parameter, `auth`, with an argument value of the `sentinel.AUTH`
    object. The idea of this test strategy is to examine the external interfaces of
    the `RestAccess` class instead of looking at internal state changes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试用例依赖于查看`RestAccess`实例内部。这不是编写单元测试的最佳策略。一个更好的方法是提供一个模拟对象给`requests.get()`。测试用例应确认`requests.get()`使用关键字参数`auth`，其参数值为`sentinel.AUTH`对象。这种测试策略的想法是检查`RestAccess`类的外部接口，而不是查看内部状态变化。
- en: Acceptance tests
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验收测试
- en: The acceptance tests need to rely on a *fixture* that mocks the Kaggle web service.
    The mock will be a process on your local computer, making it easy to stop and
    start the mock service to test the application. Using an address of `127.0.0.1:8080`
    instead of `www.kaggle.com` will direct RESTful API requests back to your own
    computer. The name `localhost:8080` can be used instead of the numeric address
    `127.0.0.1:8080`. (This address is called the *Loopback Address* because the requests
    loop back to the same host that created them, allowing testing to proceed without
    any external network traffic.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 验收测试需要依赖于一个模拟Kaggle网络服务的**固定装置**。模拟将在你的本地计算机上作为一个进程，这使得停止和启动模拟服务以测试应用程序变得容易。使用地址`127.0.0.1:8080`而不是`www.kaggle.com`将使RESTful
    API请求返回到你的计算机。可以使用`localhost:8080`这个名字代替数字地址`127.0.0.1:8080`。（这个地址被称为**环回地址**，因为请求会回环到创建它们的同一主机，允许在没有外部网络流量的情况下进行测试。）
- en: Note that the URL scheme will change to `http:` from `https:`, also. We don’t
    want to implement the full Socket Security Layer (SSL) for acceptance testing.
    For our purposes, we can trust those components work.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，URL方案也将从`https:`更改为`http:`。我们不想为验收测试实现完整的Socket安全层（SSL）。为了我们的目的，我们可以信任这些组件是有效的。
- en: This change to the URLs suggests the application should be designed in such
    a way to have the `https://www.kaggle.com` portion of each URL provided by a configuration
    parameter. Then acceptance tests can use `http://127.0.0.1:8080` without having
    to make any changes to the code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对URL的更改表明应用程序应该设计成以配置参数提供每个URL的`https://www.kaggle.com`部分。然后验收测试可以使用`http://127.0.0.1:8080`而不需要对代码进行任何更改。
- en: The mock service must offer a few features of the Kaggle service. The local
    service needs to respond to `dataset/download` requests properly, providing a
    reply with the expected status code and the content with bytes that are a proper
    ZIP archive.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟服务必须提供Kaggle服务的一些功能。本地服务需要正确响应`dataset/download`请求，提供一个包含预期状态码和正确ZIP存档字节的回复。
- en: This mock service will run as a separate application. It will be started (and
    stopped) by **behave** for a scenario that needs the fixture.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模拟服务将作为一个独立的应用程序运行。它将由**behave**启动（并停止），以应对需要固定装置的场景。
- en: We’ll start by looking at the way this service is described in a feature file.
    This will lead us to look at how to build the mock service. After that, we can
    look at how this is implemented using **behave** step definitions.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看这个服务在功能文件中的描述方式。这将引导我们了解如何构建模拟服务。之后，我们可以查看这是如何通过**behave**步骤定义来实现的。
- en: The feature file
  id: totrans-170
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 功能文件
- en: The downloading feature is clearly separate from the data acquisition feature.
    This suggests a new `.feature` file to provide scenarios to describe this feature.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下载功能显然与数据获取功能是分开的。这表明需要一个新的`.feature`文件来提供描述此功能的场景。
- en: 'Within this new feature file, we can have scenarios that specifically name
    the required fixture. A scenario might look like the following example:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个新功能文件中，我们可以有具体命名所需固定装置的场景。一个场景可能看起来像以下示例：
- en: '[PRE8]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `@fixture.` tag follows the common tagging convention for associating specific
    fixtures with scenarios. There are many other purposes for tagging scenarios in
    addition to specifying the fixture to use.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`@fixture.`标签遵循将特定固定装置与场景关联的常见标记约定。除了指定要使用的固定装置外，还有许多其他用途可以标记场景。'
- en: In previous projects, a command to run the application was provided in the `When`
    step. For this scenario (and many others), the command text became too long to
    be usefully presented in the Gherkin text. This means the actual command needs
    to be provided by the function that implements this step.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的项目中，在`When`步骤中提供了一个运行应用的命令。对于这个场景（以及许多其他场景），命令文本变得太长，无法在Gherkin文本中有用。这意味着实际的命令需要由实现此步骤的函数提供。
- en: This scenario’s `Then` steps look at the log created by the application to confirm
    the contents of the file.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景的`Then`步骤检查应用程序创建的日志以确认文件内容。
- en: A test scenario is part of the overall application’s requirements and design.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 测试场景是整体应用需求设计的组成部分。
- en: In the description provided in [*Description*](#x1-800001) there isn’t any mention
    of a log. This kind of gap is common. The test scenario provided additional definitions
    of the feature omitted from the plain test description.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供的[*描述*](#x1-800001)中，没有提到日志。这种类型的差距很常见。提供的测试场景对从普通测试描述中省略的功能进行了额外的定义。
- en: Some people like to update the documentation to be complete and fully consistent.
    We encourage flexibility when working on enterprise applications where there are
    numerous stakeholders. It can be difficult to get everyone’s input into the initial
    presentation or document. Sometimes, requirements appear later in the process
    when more concrete issues, like expected operating scenarios, are discussed in
    detail.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人喜欢将文档更新得完整且完全一致。我们在处理涉及众多利益相关者的企业应用时，鼓励灵活性。在初始演示或文档中获取每个人的意见可能很困难。有时，在详细讨论更具体的问题，如预期的操作场景时，需求会在过程中出现。
- en: The tag information will be used by the **behave** tool. We’ll look at how to
    write a `before_tag()` function to start (and stop) the special mock server for
    any scenario that needs it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 标签信息将被**behave**工具使用。我们将探讨如何编写一个`before_tag()`函数来启动（并停止）任何需要它的特殊模拟服务器。
- en: 'Before we look at the **behave** integration via a step definition, we’ll look
    at two approaches to testing the client application. The core concept is to create
    a mock-up of the few elements of the Kaggle API used by the data acquisition application.
    This mock-up must return responses used by test scenarios. There are two approaches:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看通过步骤定义进行**behave**集成之前，我们将探讨两种测试客户端应用的方法。核心概念是创建数据获取应用使用的Kaggle API的少数元素的模拟。这个模拟必须返回测试场景使用的响应。有两种方法：
- en: Create a web service application. For acceptance tests, this service must be
    started and stopped. The acquire application can be configured with a `http://localhost:8080`
    URL to connect to the test server instead of the Kaggle server. (There are a few
    common variations on the “localhost” address including `127.0.0.1` and `0.0.0.0`.)
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个网络服务应用。对于验收测试，此服务必须启动和停止。获取应用可以通过配置`http://localhost:8080` URL连接到测试服务器，而不是Kaggle服务器。（“localhost”地址有一些常见的变体，包括`127.0.0.1`和`0.0.0.0`。）
- en: The other approach is to provide a way to replace the `requests` module with
    a mocked version of the module. This mocked module returns responses appropriate
    to the test scenario. This can be done by manipulating the `sys.path` variable
    to include the directory containing the mocked version of `requests` in front
    of the `site-packages` directory, which has the real version. It can also be done
    by providing some application configuration settings that can be replaced with
    the mocked package.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种方法是提供一个替换`requests`模块的模拟版本的方法。这个模拟模块会返回适合测试场景的响应。这可以通过操作`sys.path`变量来实现，将包含模拟`requests`版本的目录放在`site-packages`目录之前，后者包含真实版本。也可以通过提供一些可以替换为模拟包的应用配置设置来实现。
- en: One approach to creating a complete service that will implement the fixture.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个将实现固定装置的完整服务的方法之一。
- en: Injecting a mock for the requests package
  id: totrans-185
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 注入`requests`包的模拟
- en: 'Replacing the `requests` package requires using dependency injection techniques
    in the acquire application. A static dependency arises from code like the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 替换`requests`包需要在获取应用程序中使用依赖注入技术。以下代码示例中会出现静态依赖：
- en: '[PRE9]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Later in the module, there may be code like `requests.get(...)` or `requests.auth.HTTPBasicAuth(...)`.
    The binding to the `requests` module is fixed by both the `import` statement and
    the references to `requests` and `requests.auth`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在模块的后面，可能会有像`requests.get(...)`或`requests.auth.HTTPBasicAuth(...)`这样的代码。`requests`模块的绑定由`import`语句以及`requests`和`requests.auth`的引用固定。
- en: The `importlib` module permits more dynamic binding of modules names, allowing
    some run-time flexibility. The following, for example, can be used to tailor imports.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`importlib`模块允许更动态地绑定模块名称，从而提供一些运行时灵活性。例如，以下内容可以用来定制导入。'
- en: '[PRE10]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The global variable, `requests`, has the imported module assigned to it. This
    module variable **must** be global; it’s an easy requirement to overlook when
    trying to configure the application for acceptance testing.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 全局变量`requests`被分配了导入的模块。这个模块变量**必须**是全局的；在尝试为验收测试配置应用程序时，这是一个容易忽视的要求。
- en: Note that the import of the `requests` module (or the mock version) is separated
    from the remaining `import` statements. This can be the source of some confusion
    for folks reading this code later, and suitable comments are important for clarifying
    the way this dependency injection works.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`requests`模块（或模拟版本）的导入与剩余的`import`语句是分开的。这可能是后来阅读此代码的人的一些困惑的来源，因此适当的注释对于阐明这种依赖注入的工作方式非常重要。
- en: When we looked at unit testing in [*Unit tests for the RestAccess class*](#x1-900003),
    we used the **pytest** fixture named `monkeypatch` to properly isolate modules
    for testing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看[*RestAccess类的单元测试*](#x1-900003)时，我们使用了**pytest**的`monkeypatch`固定装置来正确隔离模块进行测试。
- en: Monkey patching isn’t a great technique for acceptance testing because the code
    being tested is not **exactly** the code that will be used. While monkey patching
    and dependency injection are popular, there are always questions about testing
    patched software instead of the actual software. In some industries — particularly
    those where human lives might be at risk from computer-controlled machinery —
    the presence of a patch for testing may not be allowed. In the next section, we’ll
    look at building a mock service to create and test the acquire application without
    any patching or changes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Monkey patching并不是一个很好的验收测试技术，因为被测试的代码并不**完全**是最终将使用的代码。虽然monkey patching和依赖注入很受欢迎，但总是会有关于测试修补软件而不是实际软件的问题。在某些行业——尤其是那些人类生命可能因计算机控制机械而处于危险中的行业——测试中存在修补程序可能是不允许的。在下一节中，我们将探讨构建模拟服务以创建和测试获取应用程序，而不需要任何修补或更改。
- en: Creating a mock service
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建模拟服务
- en: 'A mock service can be built with any web services framework. There are two
    that are part of the standard library: the `http.server` package and the `wsgiref`
    package. Either of these can respond to HTTP requests, and can be used to create
    local services that can mock the Kaggle web service to permit testing our client.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何Web服务框架构建模拟服务。其中有两个是标准库的一部分：`http.server`包和`wsgiref`包。这两个都可以响应HTTP请求，可以用来创建本地服务，模拟Kaggle
    Web服务以允许测试我们的客户端。
- en: Additionally, any of the well-known web service frameworks can be used to create
    the mock service. Using a tool like **flask** or **bottle** can make it slightly
    easier to build a suitable mock service.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，任何知名的Web服务框架都可以用来创建模拟服务。使用像**flask**或**bottle**这样的工具可以稍微简化构建合适的模拟服务的过程。
- en: To keep the server as simple as possible, we’ll use the **bottle** framework.
    This means adding `bottle==0.12.23` to the `pyproject.toml` file in the `[project.optional-dependencies]`
    section. This tool is only needed by developers.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使服务器尽可能简单，我们将使用**bottle**框架。这意味着在`pyproject.toml`文件的`[project.optional-dependencies]`部分添加`bottle==0.12.23`。这个工具仅由开发者需要。
- en: 'The **Bottle** implementation of a RESTful API might look like this:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: RESTful API的**Bottle**实现可能看起来像这样：
- en: '[PRE11]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While the Kaggle service has numerous paths and methods, this data acquisition
    project application doesn’t use all of them. The mock server only needs to provide
    routes for the paths the application will actually use.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Kaggle服务有众多路径和方法，但这个数据获取项目应用程序并不使用所有这些。模拟服务器只需要提供应用程序实际使用的路径的路由。
- en: 'The `datasets_list` function might include the following example response:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`datasets_list`函数可能包含以下示例响应：'
- en: '[PRE12]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `HTTPResponse` object contains the essential features of the responses as
    seen by the acquisition application’s download requests. Each response has content,
    a status code, and a header that is used to confirm the type of response.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '`HTTPResponse`对象包含由获取应用程序的下载请求看到的响应的基本特征。每个响应都有内容、状态码和用于确认响应类型的标题。'
- en: For more comprehensive testing, it makes sense to add another kind of response
    with the status code of 429 and a header dictionary with `{’Retry-After’:`` ’30’}`.
    For this case, the two values of `response` will be more dramatically distinct.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '为了进行更全面的测试，添加另一种带有状态码429和包含`{''Retry-After'': ''30''}`的标题字典的响应是有意义的。在这种情况下，`response`的两个值将更加明显地区分开来。'
- en: 'The download needs to provide a mocked ZIP archive. This can be done as shown
    in the following example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 下载需要提供一个模拟的ZIP存档。这可以通过以下示例中的方式完成：
- en: '[PRE13]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This function will only respond to one specifically requested combination of
    `ownerSlug` and `datasetSlug`. Other combinations will get a 404 response, the
    status code for a resource that can’t be found.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数只会响应一个特定请求的`ownerSlug`和`datasetSlug`组合。其他组合将返回404响应，这是无法找到资源的状态码。
- en: The `io.BytesIO` object is an in-memory buffer that can be processed like a
    file. It is used by the `zipfile.ZipFile` class to create a ZIP archive. A single
    member is written to this archive. The member has a header row and a single row
    of data, making it easy to describe in a Gherkin scenario. The response is built
    from the bytes in this file, a status code of 200, and a header telling the client
    the content is a ZIP archive.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.BytesIO`对象是一个内存缓冲区，可以像文件一样处理。它被`zipfile.ZipFile`类用于创建ZIP存档。存档中写入一个成员，该成员包含标题行和一行数据，这使得在Gherkin场景中描述变得容易。响应由文件中的字节、状态码200和告知客户端内容为ZIP存档的标题构建。'
- en: This service can be run on the desktop. You can use a browser to interact with
    this server and confirm it works well enough to test our application.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 此服务可以在桌面上运行。您可以使用浏览器与此服务器交互并确认它工作得足够好，可以测试我们的应用程序。
- en: Now that we’ve seen the mock service that stands in for Kaggle.com, we can look
    at how to make the **behave** tool run this service when testing a specific scenario.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了代表Kaggle.com的模拟服务，我们可以看看如何使**behave**工具在测试特定场景时运行此服务。
- en: Behave fixture
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Behave fixture
- en: 'We’ve added a `fixture.kaggle_server` to the scenario. There are two steps
    to make this tag start the server process running for a given scenario. These
    steps are:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已将`fixture.kaggle_server`添加到场景中。要使此标签启动给定场景的服务进程，有两个步骤。这些步骤是：
- en: Define a generator function. This will start a subprocess, yield something,
    and then kill the subprocess.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个生成器函数。这将启动一个子进程，产生一些东西，然后终止子进程。
- en: Define a `before_tag()` function to inject the generator function into the step
    processing.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个`before_tag()`函数，用于将生成器函数注入到步骤处理中。
- en: Here’s a generator function that will update the context, and start the mock
    Kaggle service.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个生成器函数，它将更新上下文并启动模拟Kaggle服务。
- en: '[PRE14]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The portion of the function before the `yield` statement is used during the
    scenario setup. This will add value to the context that will be used to start
    the application under test. After the yielded value has been consumed by the **Behave**
    runner, the scenario executes. When the scenario is finished, one more value is
    requested from this generator; this request will execute the statements after
    the `yield` statement. There’s no subsequent `yield` statement; the `StopIteration`
    is the expected behavior of this function.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在`yield`语句之前的函数部分在场景设置期间使用。这将向上下文中添加用于启动测试应用程序的值。在**Behave**运行器消耗了已产生的值之后，场景执行。当场景完成后，从这个生成器请求另一个值；这个请求将执行`yield`语句之后的语句。没有后续的`yield`语句；`StopIteration`是这个函数预期的行为。
- en: 'This `kaggle_server()` function must be used in a scenario when the `@fixture`
    tag is present. The following function will do this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在`@fixture`标签时，必须使用此`kaggle_server()`函数在场景中。以下函数将这样做：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the `@fixture.kaggle_server` tag is present, this function will inject
    the `kaggle_server()` generator function into the overall flow of processing by
    the runner. The runner will make appropriate requests of the `kaggle_server()`
    generator function to start and stop the service.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在`@fixture.kaggle_server`标签时，此函数将通过运行器将`kaggle_server()`生成器函数注入到整体处理流程中。运行器将向`kaggle_server()`生成器函数发出适当的请求以启动和停止服务。
- en: These two functions are placed into the `environment.py` module where the **behave**
    tool can find and use them.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数被放置在`environment.py`模块中，以便**behave**工具可以找到并使用它们。
- en: Now that we have an acceptance test suite, we can turn to implement the required
    features of the `acquire` application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了接受测试套件，我们可以转向实现`acquire`应用所需的功能。
- en: Kaggle access module and refactored main application
  id: totrans-224
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Kaggle访问模块和重构后的主应用
- en: 'The goal, of course, is two-fold:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，目标有两个：
- en: Add a `kaggle_client.py` module. The unit tests will confirm this works.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个`kaggle_client.py`模块。单元测试将确认其工作正常。
- en: 'Rewrite the `acquire.py` module from [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data* *Acquisition Base Application*](ch007.xhtml#x1-560003) to
    add the download feature.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将[*第3章*](ch007.xhtml#x1-560003)，[*项目1.1：数据* *获取基础应用*](ch007.xhtml#x1-560003)中的`acquire.py`模块重写，以添加下载功能。
- en: 'The [*Approach*](#x1-830002) section provides some design guidance for building
    the application. Additionally, the previous chapter, [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data Acquisition Base* *Application*](ch007.xhtml#x1-560003) provides
    the baseline application into which the new acquisition features should be added.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[*方法*](#x1-830002)部分提供了构建应用的某些设计指导。此外，上一章[*第3章*](ch007.xhtml#x1-560003)，[*项目1.1：数据获取基础应用*](ch007.xhtml#x1-560003)提供了应添加新获取功能的基线应用。'
- en: The acceptance tests will confirm the application works correctly.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试将确认应用运行正确。
- en: Given this extended capability, you are encouraged to hunt for additional, interesting
    data sets. The new application can be revised and extended to acquire new, interesting
    data in other formats.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种扩展功能，我们鼓励您寻找更多有趣的数据集。新应用可以修订和扩展以获取其他格式的有趣数据。
- en: Now that we have data acquired from the web in a tidy, easy-to-use format, we
    can look at acquiring data that isn’t quite so tidy. In the next section, we’ll
    look at how to scrape data out of an HTML page.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经以整洁、易于使用的格式从网络获取了数据，我们可以查看获取不那么整洁的数据。在下一节中，我们将探讨如何从HTML页面中抓取数据。
- en: '4.2 Project 1.3: Scrape data from a web page'
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 项目1.3：从网页抓取数据
- en: In some cases, we want data that’s provided by a website that doesn’t have a
    tidy API. The data is available via an HTML page. This means the data is surrounded
    by HTML *markup*, text that describes the semantics or structure of the data.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望获取由没有整洁API的网站提供的数据。这些数据通过HTML页面提供。这意味着数据被HTML *标记* 所包围，这些标记描述了数据的语义或结构。
- en: We’ll start with a description of the application, and then move on to talk
    about the architectural approach. This will be followed with a detailed list of
    deliverables.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先描述该应用，然后继续讨论架构方法。接下来将是一个详细的交付物列表。
- en: 4.2.1 Description
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 描述
- en: We’ll continue to describe projects designed to acquire some data for further
    analysis. In this case, we’ll look at data that is available from a website, but
    is embedded into the surrounding HTML markup. We’ll continue to focus on Anscombe’s
    Quartet data set because it’s small and diagnosing problems is relatively simple.
    A larger data set introduces additional problems with time and storage.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续描述旨在获取用于进一步分析的数据的项目。在这种情况下，我们将查看来自网站的数据，但这些数据被嵌入到周围的HTML标记中。我们将继续关注Anscombe的四重奏数据集，因为它很小，诊断问题相对简单。更大的数据集会引入与时间和存储相关的问题。
- en: 'Parts of this application are an extension to the project in [*Project 1.2:
    Acquire* *data from a web service*](#x1-790001). The essential behavior of this
    application will be similar to the previous project. This project will use a CLI
    application to grab data from a source.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用的某些部分是对[*项目1.2：从网络服务* *获取数据*](#x1-790001)项目的扩展。该应用的基本行为将与之前的类似。本项目将使用CLI应用从源抓取数据。
- en: 'The User Experience (UX) will also be a command-line application with options
    to fine-tune the data being gathered. Our expected command line should like something
    like the following:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 用户体验（UX）也将是一个命令行应用，具有调整收集数据的选项。我们期望的命令行可能如下所示：
- en: '[PRE16]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `-o`` quartet` argument specifies a directory into which four results are
    written. These will have names like `quartet/series_1.json`.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '`-o` `quartet`参数指定一个目录，四个结果将被写入其中。这些结果将具有如`quartet/series_1.json`的名称。'
- en: 'The table is buried in the HTML of the URL given by the `--page` argument.
    Within this HTML, the target table has a unique `<caption>` tag: `<caption>Anscombe’s`` quartet</caption>`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 表格隐藏在由`--page`参数给出的URL的HTML中。在这个HTML中，目标表格有一个独特的`<caption>`标签：`<caption>Anscombe的四重奏</caption>`。
- en: 4.2.2 About the source data
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 关于源数据
- en: 'This data embedded in HTML markup is generally marked up with the `<table>`
    tag. A table will often have the following markup:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这种嵌入HTML标记的数据通常使用`<table>`标签进行标记。表格通常具有以下标记：
- en: '[PRE17]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In this example, the overall `<table>` tag will have two child tags, a `<caption>`
    and a `<tbody>`.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，整体的`<table>`标签将有两个子标签，一个`<caption>`和一个`<tbody>`。
- en: The table’s body, within `<tbody>`, has a number of rows wrapped in `<tr>` tags.
    The first row has headings in `<th>` tags. The second row also has headings, but
    they use the `<td>` tags. The remaining rows have data, also in `<td>` tags.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 表格的主体，在`<tbody>`内，有多个由`<tr>`标签包裹的行。第一行有`<th>`标签的标题。第二行也有标题，但它们使用`<td>`标签。其余行有数据，也在`<td>`标签中。
- en: This structure has a great deal of regularity, making it possible to use a parser
    like **Beautiful Soup** to locate the content.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这种结构具有很大的规律性，使得可以使用像**Beautiful Soup**这样的解析器来定位内容。
- en: 'The output will match the extraction processing done for the previous projects.
    See [*Chapter** 3*](ch007.xhtml#x1-560003), [*Project 1.1: Data Acquisition Base
    Application*](ch007.xhtml#x1-560003), for the essence of the data acquisition
    application.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将与之前项目所做的提取处理相匹配。参见[*第3章*](ch007.xhtml#x1-560003)，[*项目1.1：数据获取基础应用*](ch007.xhtml#x1-560003)，了解数据获取应用的本质。
- en: This section has looked at the input and processing for this application. The
    output will match earlier projects. In the next section, we’ll look at the overall
    architecture of the software.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了该应用的输入和处理。输出将与早期项目相匹配。在下一节中，我们将探讨软件的整体架构。
- en: 4.2.3 Approach
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 方法
- en: 'We’ll take some guidance from the C4 model ( [https://c4model.com](https://c4model.com))
    when looking at our approach:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在审视我们的方法时，我们将借鉴C4模型（[https://c4model.com](https://c4model.com)）的一些指导：
- en: '**Context**: For this project, a context diagram would show a user extracting
    data from a source. You may find it helpful to draw this diagram.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**: 对于这个项目，上下文图将显示用户从源中提取数据。你可能觉得绘制这个图会有所帮助。'
- en: '**Containers**: One container is the user’s personal computer. The other container
    is the Wikipedia website, which provides the data.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器**: 一个容器是用户的个人电脑。另一个容器是维基百科网站，它提供数据。'
- en: '**Components**: We’ll address the components below.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**: 我们将讨论以下组件。'
- en: '**Code**: We’ll touch on this to provide some suggested directions.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码**: 我们将简要提及，以提供一些建议的方向。'
- en: 'It’s important to consider this application as an extension to the project
    in [*Chapter** 3*](ch007.xhtml#x1-560003), [*Project 1.1: Data Acquisition Base
    Application*](ch007.xhtml#x1-560003). The base level of architectural design is
    provided in that chapter.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将此应用视为对[*第3章*](ch007.xhtml#x1-560003)，[*项目1.1：数据获取基础应用*](ch007.xhtml#x1-560003)中项目的扩展是很重要的。该章节提供了架构设计的基线。
- en: In this project, we’ll be adding a new `html_extract` module to capture and
    parse the data. The overall application in the `acquire` module will change to
    use the new features. The other modules should remain unchanged.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将添加一个新的`html_extract`模块来捕获和解析数据。`acquire`模块中的整体应用将改为使用新功能。其他模块应保持不变。
- en: A new architecture that handles the download of HTML data and the extraction
    of a table from the source data is shown in [*Figure 4.4*](#4.4).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*图4.4*](#4.4)中展示了一种新的架构，该架构处理HTML数据的下载和从源数据中提取表格。
- en: '![Figure 4.4: Revised Component Design ](img/file17.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：修订后的组件设计](img/file17.jpg)'
- en: 'Figure 4.4: Revised Component Design'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：修订后的组件设计
- en: This diagram suggested classes for the new `html_extract` module. The `Download`
    class uses `urllib.request` to open the given URL and read the contents. It also
    uses the `bs4` module (**Beautiful Soup**) to parse the HTML, locate the table
    with the desired caption, and extract the body of the table.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此图建议了新`html_extract`模块的类。`Download`类使用`urllib.request`打开给定的URL并读取内容。它还使用`bs4`模块（**Beautiful
    Soup**）解析HTML，定位具有所需标题的表格，并提取表格的主体。
- en: 'The `PairBuilder` class hierarchy has four implementations, each appropriate
    for one of the four data series. Looking back at [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data* *Acquisition Base Application*](ch007.xhtml#x1-560003), there’s
    a profound difference between the table of data shown on the Wikipedia page, and
    the CSV source file shown in that earlier project. This difference in data organization
    requires slightly different pair-building functions.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`PairBuilder`类层次结构有四种实现，每种实现适用于四个数据系列中的一个。回顾[*第3章*](ch007.xhtml#x1-560003)，[*项目1.1：数据*
    *获取基础应用*](ch007.xhtml#x1-560003)，维基百科页面上显示的数据表与早期项目中显示的CSV源文件之间存在深刻差异。这种数据组织差异需要稍微不同的配对构建函数。'
- en: Making an HTML request with urllib.request
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`urllib.request`进行HTML请求
- en: The process of reading a web page is directly supported by the `urllib.request`
    module. The `url_open()` function will perform a GET request for a given URL.
    The return value is a file-like object — with a `read()` method — that can be
    used to acquire the content.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 读取网页的过程直接由`urllib.request`模块支持。`url_open()`函数将对给定的URL执行GET请求。返回值是一个文件-like对象——具有`read()`方法——可以用来获取内容。
- en: This is considerably simpler than making a general RESTful API request where
    there are a variety of pieces of information to be uploaded and a variety of kinds
    of results that might be downloaded. When working with common GET requests, this
    standard library module handles the ordinary processing elegantly.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这比制作一个通用的RESTful API请求简单得多，在通用的RESTful API请求中，有各种信息需要上传，以及可能下载的各种结果。当处理常见的GET请求时，这个标准库模块优雅地处理了普通处理。
- en: 'A suggested design for the first step in the operation is the following function:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 操作的第一步的一个建议设计如下函数：
- en: '[PRE18]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `urlopen()` function will open the URL as a file-like object, and provide
    that file to the `BeautifulSoup` class to parse the resulting HTML.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlopen()`函数将URL作为文件-like对象打开，并将该文件提供给`BeautifulSoup`类以解析生成的HTML。'
- en: A `try:` statement to handle potential problems is not shown. There are innumerable
    potential issues when reaching out to a web service, and trying to parse the resulting
    content. You are encouraged to add some simple error reporting.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 未显示用于处理潜在问题的`try:`语句。在接触网络服务并尝试解析结果内容时，有无数潜在的问题。鼓励添加一些简单的错误报告。
- en: In the next section, we’ll look at extracting the relevant table from the parsed
    HTML.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将查看从解析的HTML中提取相关表格。
- en: HTML scraping and Beautiful Soup
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTML抓取和Beautiful Soup
- en: The Beautiful Soup data structure has a `find_all()` method to traverse the
    structure. This will look for tags with specific kinds of properties. This can
    examine the tag, the attributes, and even the text content of the tag.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 美味汤数据结构有一个`find_all()`方法来遍历结构。这将查找具有特定类型属性的标签。这可以检查标签、属性，甚至标签的文本内容。
- en: See [https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all](https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all](https://www.crummy.com/software/BeautifulSoup/bs4/doc/#find-all)。
- en: In this case, we need to find a `<table>` tag with a `caption` tag embedded
    within it. That `caption` tag must have the desired text. This search leads to
    a bit more complex investigation of the structure. The following function can
    locate the desired table.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们需要找到一个包含`caption`标签的`<table>`标签。这个`caption`标签必须包含所需的文本。这个搜索导致对结构的更复杂调查。以下函数可以定位所需的表格。
- en: '[PRE19]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Some of the tables lack captions. This means the expression `table.caption.text`
    won’t work for string comparison because it may have a `None` value for `table.caption`.
    This leads to a nested cascade of `if` statements to be sure there’s a `<caption>`
    tag before checking the text value of the tag.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 一些表格缺少标题。这意味着表达式`table.caption.text`在字符串比较中不会工作，因为`table.caption`可能有一个`None`值。这导致嵌套的`if`语句级联，以确保在检查标签的文本值之前有一个`<caption>`标签。
- en: The `strip()` functions are used to remove leading and trailing whitespace from
    the text because blocks of text in HTML can be surrounded by whitespace that’s
    not displayed, making it surprising when it surfaces as part of the content. Stripping
    the leading and trailing whitespace makes it easier to match.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`strip()`函数用于从文本中移除前导和尾随空白，因为HTML中的文本块可能被不显示的空白包围，这使得它作为内容的一部分出现时令人惊讶。移除前导和尾随空白使得匹配更容易。'
- en: The rest of the processing is left for you to design. This processing involves
    finding all of the `<tr>` tags, representing rows of the table. Within each row
    (except the first) there will be a sequence of `<td>` tags representing the cell
    values within the row.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的处理工作留给你来设计。这个处理包括找到所有的`<tr>`标签，代表表格的行。在每一行（除了第一行）中，将会有一个`<td>`标签的序列，代表行内的单元格值。
- en: Once the text has been extracted, it’s very similar to the results from a `csv.reader`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文本被提取，它与`csv.reader`的结果非常相似。
- en: After considering the technical approach, it’s time to look at the deliverables
    for this project.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑了技术方法之后，是时候看看这个项目的可交付成果了。
- en: 4.2.4 Deliverables
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 可交付成果
- en: 'This project has the following deliverables:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目有以下可交付成果：
- en: Documentation in the `docs` folder.
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docs`文件夹中的文档。'
- en: Acceptance tests in the `tests/features` and `tests/steps` folders.
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`tests/features`和`tests/steps`文件夹中的验收测试。
- en: Unit tests for the application modules in the `tests` folder.
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tests`文件夹中应用模块的单元测试。'
- en: Mock HTML pages for unit testing will be part of the unit tests.
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试的模拟HTML页面将是单元测试的一部分。
- en: Application to acquire data from an HTML page.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从HTML页面获取数据的应用程序。
- en: We’ll look at a few of these deliverables in a little more detail.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更详细地查看其中的一些可交付成果。
- en: Unit test for the html_extract module
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: html_extract模块的单元测试。
- en: The `urlopen()` function supports the `http:` and `https:` schemes. It also
    supports the `file:` protocol. This allows a test case to use a URL of the form
    `file:///path/to/a/file.html` to read a local HTML file. This facilitates testing
    by avoiding the complications of accessing data over the internet.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`urlopen()`函数支持`http:`和`https:`方案。它还支持`file:`协议。这允许测试用例使用形式为`file:///path/to/a/file.html`的URL来读取本地HTML文件。这通过避免通过互联网访问数据的复杂性来简化测试。'
- en: For testing, it makes sense to prepare files with the expected HTML structure,
    as well as invalid structures. With some local files as examples, a developer
    can run test cases quickly.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 对于测试，准备具有预期HTML结构和无效结构的文件是有意义的。有了几个本地文件作为示例，开发者可以快速运行测试用例。
- en: Generally, it’s considered a best practice to mock the `BeautifulSoup` class.
    A fixture would respond to the various `find_all()` requests with mock tag objects.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，模拟`BeautifulSoup`类被认为是一种最佳实践。固定值会对各种`find_all()`请求做出模拟标签对象的响应。
- en: When working with HTML, however, it seems better to provide mock HTML. The wide
    variety of HTML seen in the wild suggests that time spent with real HTML is immensely
    valuable for debugging.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当与HTML一起工作时，提供模拟HTML似乎更好。野外看到的HTML的广泛多样性表明，与真实HTML一起花费的时间对于调试来说价值巨大。
- en: Creating `BeautifulSoup` objects means the unit testing is more like integration
    testing. The benefits of being able to test a wide variety of odd and unusual
    HTML seems to be more valuable than the cost of breaking the ideal context for
    a unit test.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`BeautifulSoup`对象意味着单元测试更像是集成测试。能够测试各种奇怪和不同寻常的HTML的好处似乎比打破单元测试理想环境的花费更有价值。
- en: Having example HTML files plays well with the way **pytest** fixtures work.
    A fixture can create a file and return the path to the file in the form of a URL.
    After the test, the fixture can remove the file.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有示例HTML文件与**pytest**固定值的工作方式相得益彰。一个固定值可以创建一个文件，并以URL的形式返回文件的路径。测试完成后，固定值可以删除该文件。
- en: 'A fixture with a test HTML page might look like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含测试HTML页面的固定值可能看起来像这样：
- en: '[PRE20]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This fixture uses the `tmp_path` fixture to provide access to a temporary directory
    used only for this test. The file, `works.html`, is created, and filled with an
    HTML page. The test case should include multiple `<table>` tags, only one of which
    was the expected `<caption>` tag.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此固定值使用`tmp_path`固定值来提供对仅用于此测试的临时目录的访问。创建文件`works.html`，并填充HTML页面。测试用例应包含多个`<table>`标签，其中只有一个期望的`<caption>`标签。
- en: The `dedent()` function is a handy way to provide a long string that matches
    the prevailing Python indent. The function removes the indenting whitespace from
    each line; the resulting text object is not indented.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`dedent()`函数是一种方便的方法，可以提供与当前Python缩进匹配的长字符串。该函数从每一行中移除缩进空格；生成的文本对象没有缩进。'
- en: The return value from this fixture is a URL that can be used by the `urlopen()`
    function to open and read this file. After the test is completed, the final step
    (after the `yield` statement) will remove the file.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 此固定值的返回值可以由`urlopen()`函数使用，以打开和读取此文件。测试完成后，最后的步骤（在`yield`语句之后）将删除文件。
- en: 'A test case might look something like the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试用例可能看起来像以下这样：
- en: '[PRE21]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The test case uses the `example_1` fixture to create a file and return a URL
    referring to the file. The URL is provided to a function being tested. The functions
    within the `html_extract` module are used to parse the HTML, locate the target
    table, and extract the individual rows.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 测试用例使用 `example_1` 固定值来创建一个文件，并返回一个指向该文件的 URL。该 URL 被提供给正在测试的函数。`html_extract`
    模块中的函数用于解析 HTML，定位目标表格，并提取单个行。
- en: The return value tells us the functions work properly together to locate and
    extract data. You are encouraged to work out the necessary HTML for good — and
    bad — examples.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 返回值告诉我们函数能够正确地一起定位和提取数据。我们鼓励您为好和坏的示例编写必要的 HTML。
- en: Acceptance tests
  id: totrans-305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 验收测试
- en: As noted above in [*Unit test for the html**_extract module*](#x1-1040004),
    the acceptance test case HTML pages can be local files. A scenario can provide
    a local `file://` URL to the application and confirm the output includes properly
    parsed data.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，在 [*HTML 提取模块单元测试*](#x1-1040004) 中，验收测试用例的 HTML 页面可以是本地文件。一个场景可以为应用程序提供一个指向本地
    `file://` URL，并确认输出包含正确解析的数据。
- en: The Gherkin language permits including large blocks of text as part of a scenario.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 语言允许将大块文本作为场景的一部分包含在内。
- en: 'We can imagine writing the following kinds of scenarios in a feature file:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象在功能文件中编写以下类型的场景：
- en: '[PRE22]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The HTML extract command is quite long. The content is available as the `context.text`
    parameter of the step definition function. Here’s what the step definition for
    this given step looks like:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: HTML 提取命令相当长。内容作为步骤定义函数的 `context.text` 参数可用。以下是这个给定步骤的步骤定义看起来像：
- en: '[PRE23]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The step definition puts the path into the context and then writes the HTML
    page to the given path. The `dedent()` function removes any leading spaces that
    may have been left in place by the **behave** tool. Since the path information
    is available in the context, it can be used by the **When** step. The `context.add_cleanup()`
    function will add a function that can be used to clean up the file when the scenario
    is finished. An alternative is to use the environment module’s `after_scenario()`
    function to clean up.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤定义将路径放入上下文中，然后将 HTML 页面写入给定的路径。`dedent()` 函数移除可能由 **behave** 工具留下的任何前导空格。由于路径信息在上下文中可用，它可以由
    **When** 步骤使用。`context.add_cleanup()` 函数将添加一个函数，可以在场景完成后用于清理文件。另一种选择是使用环境模块的 `after_scenario()`
    函数进行清理。
- en: 'This scenario requires an actual path name for the supplied HTML page to be
    injected into the text. For this to work out well, the step definition needs to
    build a command from pieces. Here’s one approach:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此场景需要实际路径名来注入提供的 HTML 页面。为了使这一过程顺利进行，步骤定义需要构建一个命令。以下是一个方法：
- en: '[PRE24]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the command is broken down into individual parameter strings.
    One of the strings must be replaced with the actual file name. This works out
    nicely because the `subprocess.run()` function works well with a parsed shell
    command. The `shlex.split()` function can be used to decompose a line, honoring
    the complex quoting rules of the shell, into individual parameter strings.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，命令被分解成单个参数字符串。其中一个字符串必须替换为实际的文件名。这做得很好，因为 `subprocess.run()` 函数与解析的 shell
    命令配合得很好。可以使用 `shlex.split()` 函数将一行分解成单个参数字符串，同时遵守 shell 的复杂引号规则。
- en: Now that we have an acceptance test suite, we may find the `acquire` application
    doesn’t pass all of the tests. It’s helpful to define done via an acceptance test
    and then develop the required HTML extract module and refactor the main application.
    We’ll look at these two components next.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了验收测试套件，我们可能会发现 `acquire` 应用程序没有通过所有测试。通过验收测试定义完成，然后开发所需的 HTML 提取模块和重构主应用程序是有帮助的。我们将接下来查看这两个组件。
- en: HTML extract module and refactored main application
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: HTML 提取模块和重构主应用
- en: 'The goal for this project is two-fold:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的目标是双重的：
- en: Add an `html_extract.py` module. The unit tests will confirm this module works.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个 `html_extract.py` 模块。单元测试将确认此模块工作正常。
- en: 'Rewrite the `acquire.py` module from [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data* *Acquisition Base Application*](ch007.xhtml#x1-560003) to
    add the HTML download and extract the feature.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `acquire.py` 模块从 [*第 3 章*](ch007.xhtml#x1-560003)、[*项目 1.1：数据获取基础应用程序*](ch007.xhtml#x1-560003)
    重新编写，以添加 HTML 下载和提取功能。
- en: 'The [*Approach*](#x1-1000003) section provides some design guidance for building
    the application. Additionally, the previous chapter, [*Chapter** 3*](ch007.xhtml#x1-560003),
    [*Project 1.1: Data Acquisition Base* *Application*](ch007.xhtml#x1-560003), provides
    the baseline application into which the new acquisition features should be added.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[方法](#x1-1000003)部分提供了构建应用程序的一些设计指导。此外，上一章[第3章](ch007.xhtml#x1-560003) [项目1.1：数据获取基础应用程序](ch007.xhtml#x1-560003)提供了应添加新获取功能的基本应用程序。'
- en: The acceptance tests will confirm the application works correctly to gather
    data from the Kaggle API.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试将确认应用程序能够正确地从Kaggle API收集数据。
- en: Given this extended capability, you can hunt for data sets that are presented
    in web pages. Because of the consistency of Wikipedia, it is a good source of
    data. Many other sites provide relatively consistent HTML tables with interesting
    data.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种扩展功能，您可以搜索网页中呈现的数据集。由于维基百科的一致性，它是一个良好的数据来源。许多其他网站提供了相对一致且包含有趣数据的HTML表格。
- en: In these two projects, we’ve extended our ability to acquire data from a wide
    variety of sources.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个项目中，我们扩展了从各种来源获取数据的能力。
- en: 4.3 Summary
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 摘要
- en: 'This chapter’s projects have shown examples of the following features of a
    data acquisition application:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的项目展示了数据获取应用程序的以下功能示例：
- en: Web API integration via the **requests** package. We’ve used the Kaggle API
    as an example of a RESTful API that provides data for download and analysis.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过**requests**包进行Web API集成。我们以Kaggle API为例，展示了提供数据下载和分析的RESTful API。
- en: Parsing an HTML web page using the **Beautiful Soup** package.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Beautiful Soup**包解析HTML网页。
- en: Adding features to an existing application and extending the test suite to cover
    these new alternative data sources.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向现有应用程序添加功能，并扩展测试套件以涵盖这些新的替代数据源。
- en: A challenging part of both of these projects is creating a suite of acceptance
    tests to describe the proper behavior. Pragmatically, a program without automated
    tests cannot be trusted. The tests are every bit as important as the code they’re
    exercising.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个项目的挑战性部分之一是创建一套接受测试来描述适当的行为。从实用主义的角度来看，没有自动化测试的程序是不可信的。测试与它们所执行的代码一样重要。
- en: In some enterprises, the definition of done is breezy and informal. There may
    be a presentation or an internal memo or a whitepaper that describes the desired
    software. Formalizing these concepts into tangible test cases is often a significant
    effort. Achieving agreements can become a source of turmoil as stakeholders slowly
    refine their understanding of how the software will behave.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些企业中，完成的定义是轻松且非正式的。可能会有一个演示文稿或内部备忘录或白皮书来描述所需的软件。将这些概念正式化为可触摸的测试用例通常是一项重大努力。达成协议可能成为冲突的来源，因为利益相关者逐渐细化对软件行为的理解。
- en: Creating mock web services is fraught with difficulty. Some API’s permit downloading
    an `openapi.json` file with the definition of the API complete with examples.
    Having concrete examples, provided by the host of the API, makes it much easier
    to create a mock service. A mock server can load the JSON specification, navigate
    to the example, and provide the official response.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 创建模拟Web服务充满困难。一些API允许下载包含API定义及其示例的`openapi.json`文件。由API提供者提供的具体示例使得创建模拟服务变得容易得多。模拟服务器可以加载JSON规范，导航到示例，并提供官方响应。
- en: Lacking an OpenAPI specification with examples, developers need to write spike
    solutions that download detailed responses. These responses can then be used to
    build mock objects. You are strongly encouraged to write side-bar applications
    to explore the Kaggle API to see how it works.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 缺乏带有示例的OpenAPI规范，开发者需要编写激进行为的解决方案来下载详细响应。然后可以使用这些响应来构建模拟对象。强烈建议您编写侧边栏应用程序来探索Kaggle
    API，以了解其工作方式。
- en: 'In the next chapter, we’ll continue this data extraction journey to include
    extracting data from SQL databases. Once we’ve acquired data, we’ll want to inspect
    it. [*Chapter** 6*](ch010.xhtml#x1-1460006), [*Project 2.1: Data Inspection Notebook*](ch010.xhtml#x1-1460006),
    will introduce an inspection step.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续这一数据提取之旅，包括从SQL数据库中提取数据。一旦我们获取了数据，我们就会想要检查它。[第6章](ch010.xhtml#x1-1460006)
    [项目2.1：数据检查笔记本](ch010.xhtml#x1-1460006)将介绍检查步骤。
- en: 4.4 Extras
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 额外内容
- en: Here are some ideas for you to add to these projects.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些想法供您添加到这些项目中。
- en: 4.4.1 Locate more JSON-format data
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.1 定位更多JSON格式数据
- en: A search of Kaggle will turn up some other interesting data sets in JSON format.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kaggle上搜索将出现一些其他有趣的JSON格式数据集。
- en: '[https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version](https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version):
    This data set is famous and available in a number of distinct formats.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version](https://www.kaggle.com/datasets/rtatman/iris-dataset-json-version)：这个数据集很著名，并以多种不同的格式提供。'
- en: '[https://www.kaggle.com/datasets/conoor/stack-overflow-tags-usage](https://www.kaggle.com/datasets/conoor/stack-overflow-tags-usage)'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/datasets/conoor/stack-overflow-tags-usage](https://www.kaggle.com/datasets/conoor/stack-overflow-tags-usage)'
- en: '[https://www.kaggle.com/datasets/queyrusi/the-warship-dataset](https://www.kaggle.com/datasets/queyrusi/the-warship-dataset)'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.kaggle.com/datasets/queyrusi/the-warship-dataset](https://www.kaggle.com/datasets/queyrusi/the-warship-dataset)'
- en: One of these is a JSON download. The other two are ZIP archives that contain
    JSON-format content.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是JSON下载。其他两个是包含JSON格式内容的ZIP存档。
- en: This will require revising the application’s architecture to extract the JSON
    format data instead of CSV format data.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这将需要修改应用程序的架构，以提取JSON格式数据而不是CSV格式数据。
- en: 'An interesting complication here is the distinction between CSV data and JSON
    data:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个有趣的复杂性在于CSV数据和JSON数据之间的区别：
- en: CSV data is pure text, and later conversions are required to make useful Python
    objects.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV数据是纯文本，需要后续转换才能制作成有用的Python对象。
- en: Some JSON data is converted to Python objects by the parser. Some data (like
    datestamps) will be left as text.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些JSON数据通过解析器转换为Python对象。一些数据（如日期戳）将保留为文本。
- en: 'At acquisition time, this doesn’t have a significant impact. However, when
    we get to [*Chapter** 9*](ch013.xhtml#x1-2080009), [*Project 3.1: Data Cleaning
    Base Application*](ch013.xhtml#x1-2080009), we’ll have to account for data in
    a text-only form distinct from data with some conversions applied.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取数据时，这不会产生重大影响。然而，当我们到达[*第9章*](ch013.xhtml#x1-2080009)，[*项目3.1：数据清洗基础应用*](ch013.xhtml#x1-2080009)时，我们必须考虑以纯文本形式存在的数据，这些数据与经过某些转换的数据是不同的。
- en: 'The Iris data set is quite famous. You can expand on the designs in this chapter
    to acquire Iris data from a variety of sources. The following steps could be followed:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 菊花数据集相当著名。你可以在此基础上扩展本章的设计，从各种来源获取菊花数据。以下步骤可以遵循：
- en: Start with the Kaggle data set in JSON format. Build the needed model, and extract
    modules to work with this format.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从JSON格式的Kaggle数据集开始。构建所需的模型和提取模块以处理此格式。
- en: Locate other versions of this data set in other formats. Build the needed extract
    modules to work with these alternative formats.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其他格式中定位此数据集的其他版本。构建所需的提取模块以处理这些替代格式。
- en: Once a core acquisition project is complete, you can leverage this other famous
    data set as an implementation choice for later projects.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦核心获取项目完成，你可以利用这个其他著名的数据集作为后续项目的实现选择。
- en: 4.4.2 Other data sets to extract
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.2 其他要提取的数据集
- en: See the **CO****2** **PPM — Trends in Atmospheric Carbon Dioxide** data set,
    available at [https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm),
    for some data that is somewhat larger. This page has a link to an HTML table with
    the data.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://datahub.io/core/co2-ppm](https://datahub.io/core/co2-ppm)上的**CO****2**
    **PPM — 大气二氧化碳趋势**数据集，其中包含一些相对较大的数据。此页面有一个链接到包含数据的HTML表格。
- en: 'See [https://datahub.io/core/co2-ppm/r/0.html](https://datahub.io/core/co2-ppm/r/0.html)
    for a page with the complete data set as an HTML table. This data set is larger
    and more complicated than Anscombe’s Quartet. In [*Chapter** 6*](ch010.xhtml#x1-1460006),
    [*Project 2.1: Data* *Inspection Notebook*](ch010.xhtml#x1-1460006), we’ll address
    some of the special cases in this data set.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[https://datahub.io/core/co2-ppm/r/0.html](https://datahub.io/core/co2-ppm/r/0.html)上的页面，其中包含完整数据集的HTML表格。这个数据集比Anscombe的四重奏更大、更复杂。在[*第6章*](ch010.xhtml#x1-1460006)，[*项目2.1：数据检查笔记本*](ch010.xhtml#x1-1460006)中，我们将讨论这个数据集中的某些特殊情况。
- en: 4.4.3 Handling schema variations
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.3 处理模式变化
- en: The two projects in this chapter each reflect a distinct schema for the source
    data.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的两个项目各自反映了源数据的独特模式。
- en: One CSV format can be depicted via an **Entity-Relationship Diagram** (**ERD**),
    shown in [*Figure 4.5*](#4.5)*.*
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CSV格式可以通过一个**实体-关系图**（**ERD**），如[*图4.5*](#4.5)*.*所示来表示。
- en: '![Figure 4.5: Source entity-relationship diagram ](img/file22.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图4.5：源实体关系图](img/file22.jpg)'
- en: 'Figure 4.5: Source entity-relationship diagram'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.5：源实体关系图
- en: One column, `x_123`, is the x-value of three distinct series. Another column,
    `x_4`, is the x-value for one series.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 一列，`x_123`，是三个不同系列中的x值。另一列，`x_4`，是一个系列中的x值。
- en: A depiction of the HTML format as an ERD is shown in [*Figure 4.6*](#4.6)*.*
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*图4.6*](#4.6)*.*所示，HTML格式的ERD表示。
- en: '![Figure 4.6: Notional entity-relationship diagram ](img/file23.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图4.6：概念实体关系图](img/file23.jpg)'
- en: 'Figure 4.6: Notional entity-relationship diagram'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6：概念实体关系图
- en: The x-values are repeated as needed.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: x值按需重复。
- en: This difference requires several distinct approaches to extracting the source
    data.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这种差异需要几种不同的方法来提取源数据。
- en: In these projects, we’ve implemented this distinction as distinct subclasses
    of a `PairBuilder` superclass.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些项目中，我们已将这种区别作为`PairBuilder`超类的不同子类来实现。
- en: 'An alternative design is to create distinct functions with a common type signature:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一种替代设计是创建具有公共类型签名的不同函数：
- en: '[PRE25]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Making each conversion a function eliminates the overhead of the class definition.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个转换变成一个函数消除了类定义的开销。
- en: This rewrite can be a large simplification. It will not change any acceptance
    tests. It will, however, require numerous changes to unit tests.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 这次重写可以是一个大的简化。它不会改变任何验收测试。然而，它将需要对单元测试进行许多更改。
- en: The functional design offers some simplification over class-based design. You
    are encouraged to perform the functional redesign of the suggestions in this book.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 功能设计在类设计的基础上提供了一些简化。鼓励您执行本书中建议的功能重设计。
- en: 4.4.4 CLI enhancements
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.4 CLI增强
- en: The CLI for these two projects is left wide open, permitting a great deal of
    design flexibility and alternatives. Because the CLI is part of externally visible
    behavior, it becomes necessary to write acceptance tests for the various CLI options
    and arguments.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个项目的CLI被留得很开放，允许有很大的设计灵活性和替代方案。由于CLI是外部可见行为的一部分，因此有必要为各种CLI选项和参数编写验收测试。
- en: As noted in [*Additional acceptance scenarios*](ch007.xhtml#x1-670002), there
    are a number of acceptance test scenarios that are not on the ”happy path” where
    the application works. These additional scenarios serve to catalog a number of
    erroneous uses of the application.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如[*附加验收场景*](ch007.xhtml#x1-670002)中所述，有一些验收测试场景不在“快乐路径”上，即应用程序正常工作。这些额外的场景旨在记录应用程序的许多错误使用。
- en: This becomes more important as more features are added and the CLI becomes more
    complicated. You are encouraged to write acceptance tests for invalid CLI use.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多功能的添加和CLI变得更加复杂，这一点变得更加重要。鼓励您为无效的CLI使用编写验收测试。
- en: 4.4.5 Logging
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4.5 记录
- en: Logging is an important part of data acquisition. There are a number of potential
    problems exposed by these two projects. A website might be unresponsive, or the
    API may have changed. The HTML may have been reformatted in some subtle way.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是数据获取的重要部分。这两个项目暴露了许多潜在问题。网站可能无响应，或API可能已更改。HTML可能以某种微妙的方式重新格式化。
- en: A *debug* or *verbose* mode should be available to expose the interactions with
    external services to be sure of the HTTP status codes and headers.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提供一个 *调试* 或 *详细* 模式，以便暴露与外部服务的交互，确保HTTP状态码和头信息。
- en: Additionally, count values should be displayed to summarize the bytes downloaded,
    the lines of text examined, and the number of `XYPair` objects created. The idea
    is to characterize the inputs, the various processing steps, and the outputs.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应显示计数值以总结下载的字节数、检查的文本行数以及创建的`XYPair`对象数量。这个想法是描述输入、各种处理步骤和输出。
- en: These counts are essential for confirming that data is processed and filtered
    correctly. They’re an important tool for making parts of the processing more observable.
    A user wants to confirm that all of the downloaded data is either part of the
    results or filtered and discarded for a good reason.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 这些计数对于确认数据是否正确处理和过滤至关重要。它们是使处理部分更易于观察的重要工具。用户希望确认所有下载的数据要么是结果的一部分，要么是因合理原因而被过滤和丢弃。
- en: You are encouraged to include counts for input, processing, and output in the
    log.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您在日志中包含输入、处理和输出的计数。
