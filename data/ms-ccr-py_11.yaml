- en: Building Communication Channels with asyncio
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用asyncio构建通信渠道
- en: Communication channels are a big part of applied concurrency in the field of
    computer science. In this chapter, we will cover the fundamental theories of transports,
    which are classes provided by the `asyncio` module in order to abstract various
    forms of communication channels. We will also cover an implementation of a simple
    echoing server-client logic in Python, in order to further illustrate the use
    of `asyncio` and concurrency in communication systems. The code for this example
    will serve as the foundation for an advanced example that will appear later in
    this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 通信渠道是计算机科学领域中应用并发性的重要组成部分。在本章中，我们将介绍传输的基本理论，这些理论是由`asyncio`模块提供的类，以便抽象各种形式的通信渠道。我们还将介绍Python中简单回显服务器-客户端逻辑的实现，以进一步说明`asyncio`和通信系统中并发性的使用。这个例子的代码将成为本书后面出现的一个高级例子的基础。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The fundamentals of communication channels and applying asynchronous programming
    to them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信渠道的基础知识以及将异步编程应用于它们
- en: How to build an asynchronous server in Python by using `asyncio` and `aiohttp`
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`asyncio`和`aiohttp`在Python中构建异步服务器
- en: How to make requests to multiple servers asynchronously and handle asynchronous
    file reading and writing
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何异步地向多个服务器发出请求，并处理异步文件的读取和写入
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The following is a list of prerequisites for this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章的先决条件列表：
- en: Ensure that you have Python 3 installed on your computer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上已安装Python 3
- en: Ensure that you have Telnet installed on your computer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您的计算机上已安装Telnet
- en: Ensure that you have the Python module `aiohttp` installed with your Python
    3 distribution
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您已经在您的Python 3发行版中安装了Python模块`aiohttp`
- en: Download the GitHub repository at [https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)下载GitHub存储库
- en: In this chapter, we will be working with the subfolder named `Chapter11`
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用名为`Chapter11`的子文件夹
- en: Check out the following video to see the Code in Action: [http://bit.ly/2FMwKL8](http://bit.ly/2FMwKL8)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[http://bit.ly/2FMwKL8](http://bit.ly/2FMwKL8)
- en: The ecosystem of communication channels
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信渠道的生态系统
- en: Communication channels are used to denote both the physical wiring connection
    between different systems and the logical communication of data that facilitates
    computer networks. In this chapter, we will only be concerned with the latter,
    as it is a problem that is related to computing and is more germane to the idea
    of asynchronous programming. In this section, we will be discussing the general
    structure of a communication channel, and two specific elements in that structure
    that are particularly relevant to asynchronous programming.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通信渠道用于表示不同系统之间的物理接线连接和促进计算机网络的逻辑数据通信。在本章中，我们只关注后者，因为这是与计算相关的问题，更与异步编程的概念相关。在本节中，我们将讨论通信渠道的一般结构，以及该结构中与异步编程特别相关的两个特定元素。
- en: Communication protocol layers
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议层
- en: Most data transmission processes that are done through communication channels
    are facilitated in the form of the **Open Systems Interconnection** (**OSI**)
    model protocol layers. The OSI model lays out the major layers and topics in an
    intersystem communication process.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数通过通信渠道进行的数据传输过程都是通过**开放系统互连**（**OSI**）模型协议层来实现的。OSI模型规定了系统间通信过程中的主要层和主题。
- en: 'The following diagram shows the general structure of an OSI model:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了OSI模型的一般结构：
- en: '![](assets/8ddd0769-bc8d-4cf0-95ab-05baf817c9aa.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/8ddd0769-bc8d-4cf0-95ab-05baf817c9aa.png)'
- en: OSI model structure
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: OSI模型结构
- en: As indicated in the preceding diagram, there are seven main layers of communication
    in a data transmission process, with varying degrees of computing level. We will
    not be going into the details of the purposes and specific functions of each layer,
    but it is still important that you understand the general ideas behind the media
    and host layers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，数据传输过程中有七个主要的通信层，具有不同程度的计算级别。我们不会详细介绍每个层的目的和具体功能，但重要的是您要理解媒体和主机层背后的一般思想。
- en: The three bottom layers contain fairly low-level operations that interact with
    the underlying process of the communication channel. The operations in the physical
    and data link layers include coding schemes, access schemes, low-level error detection
    and correction, bit synchronization, and so on. These operations are used to implement
    and specify the logic of processing and preparing data before transferring it.
    The network layer, on the other hand, handles forwarding packets of data from
    one system (for example, the server) to another (for example, the client) in a
    computer network, via determining the address of the recipient and which path
    of data transfer to take.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 底层的三个层包含与通信渠道的底层操作相当相关的操作。物理和数据链路层的操作包括编码方案、访问方案、低级错误检测和纠正、位同步等。这些操作用于在传输数据之前实现和指定数据的处理和准备逻辑。另一方面，网络层处理从一个系统（例如服务器）到另一个系统（例如客户端）的数据包转发，通过确定接收者的地址和数据传输路径。
- en: On the other hand, the top layers deal with high-level data communication and
    manipulation. Among these layers, we will be focusing on the transport layer,
    as it is directly utilized by the `asyncio` module in implementing communication
    channels. This layer is often viewed as the conceptual transition between the
    media layers and the host layers (for example, the client and the server), responsible
    for sending data along end-to-end connections between different systems. Additionally,
    because packets of data (prepared by the network layer) might be lost or corrupted
    during transmission processes due to network errors, the transport layer is also
    in charge of detecting these errors via methods in error detection code.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，顶层处理高级数据通信和操作。在这些层中，我们将专注于传输层，因为它直接被`asyncio`模块用于实现通信渠道。这一层通常被视为媒体层和主机层（例如客户端和服务器）之间的概念性过渡，负责在不同系统之间的端到端连接中发送数据。此外，由于数据包（由网络层准备）可能在传输过程中由于网络错误而丢失或损坏，传输层还负责通过错误检测代码中的方法检测这些错误。
- en: The other host layers implement mechanisms for handling, interpreting, and providing
    the data sent from another system. After receiving data from the transport layer,
    the session layer handles the authentication, authorization, and session restoration
    processes. The presentation layer then translates the same data and reorganizes
    it into an interpretable representation. Finally, the application layer displays
    that data in user-friendly formats.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 其他主机层实现处理、解释和提供来自另一个系统发送的数据的机制。在从传输层接收数据后，会话层处理身份验证、授权和会话恢复过程。表示层然后将相同的数据进行翻译并重新组织成可解释的表示形式。最后，应用层以用户友好的格式显示数据。
- en: Asynchronous programming for communication channels
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信渠道的异步编程
- en: 'Given the nature of asynchronous programming, it is no surprise that the programming
    model can provide functionalities that complement the process of facilitating
    communication channels efficiently. Using the topic of HTTP communication as an
    example, the server can asynchronously handle multiple clients at the same time;
    while it is waiting for a specific client to make an HTTP request, it can switch
    to another client and process that client''s request. Similarly, if a client needs
    to make HTTP requests to multiple servers, and has to wait for large responses
    from some servers, it can process the more lightweight responses, which have already
    been processed and were sent back to the client first. The following diagram shows
    an example of how servers and clients interact with each other asynchronously
    in HTTP requests:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于异步编程的性质，编程模型可以提供与有效促进通信渠道的过程相辅相成的功能，这并不奇怪。以HTTP通信为例，服务器可以异步处理多个客户端；当它在等待特定客户端发出HTTP请求时，它可以切换到另一个客户端并处理该客户端的请求。同样，如果客户端需要向多个服务器发出HTTP请求，并且必须等待某些服务器的大型响应，它可以处理更轻量级的响应，这些响应已经被处理并首先发送回客户端。以下图表显示了服务器和客户端在HTTP请求中如何异步地相互交互：
- en: '![](assets/d3a27a5c-2ea2-4165-ad7b-83439d70ec22.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/d3a27a5c-2ea2-4165-ad7b-83439d70ec22.png)'
- en: Asynchronous, interleaved HTTP requests
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 异步交错的HTTP请求
- en: Transports and protocols in asyncio
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在asyncio中的传输和协议
- en: The `asyncio` module provides a number of different transport classes. In essence,
    these classes are the implementations of the functionalities of the transport
    layer that were discussed in the preceding section. You already know that the
    transport layer plays an integral role in communication channels; the transport
    classes, therefore, give `asyncio` (and consequently, the developers) more control
    over the process of implementing our own communication channels.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块提供了许多不同的传输类。实质上，这些类是在前一节讨论的传输层功能的实现。您已经知道传输层在通信渠道中发挥着重要作用；因此，传输类给`asyncio`（因此也给开发人员）更多控制权，以实现我们自己的通信渠道的过程。'
- en: The `asyncio` module combines the abstract of transports with the implementation
    of an asynchronous program. Specifically, even though transports are the central
    elements of communication channels, in order to utilize the transport classes
    and other relevant communication channel tools, we need to initiate and call an
    event loop, which is an instance of the `asyncio.AbstractEventLoop` class. The
    event loop itself will then create the transports and manage the low-level communication
    procedures.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncio`模块将传输的抽象与异步程序的实现结合在一起。特别是，尽管传输是通信渠道的核心元素，但为了利用传输类和其他相关的通信渠道工具，我们需要初始化和调用事件循环，这是`asyncio.AbstractEventLoop`类的一个实例。事件循环本身将创建传输并管理低级通信过程。'
- en: It is important to note that a `transport` object in an established communication
    channel in `asyncio` is always associated with an instance of the `asyncio.Protocol`
    class. As the name suggests, the `Protocol` class specifies the underlying protocols
    that the communication channels use; for each connection made with another system,
    a new protocol object from this class will be created. While working closely with
    a `transport` object, a protocol object can call various methods from the `transport`
    object; this is the point where we can implement the specific inner workings of
    a communication channel.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，在`asyncio`中建立的通信渠道中，`transport`对象始终与`asyncio.Protocol`类的实例相关联。正如其名称所示，`Protocol`类指定了通信渠道使用的基础协议；对于与另一个系统建立的每个连接，将创建此类的新协议对象。在与`transport`对象密切合作时，协议对象可以从`transport`对象调用各种方法；这是我们可以实现通信渠道的具体内部工作的地方。
- en: 'For this reason, generally we need to focus on the implementation of an `asyncio.Protocol` subclass
    and its methods while building a connection channel. In other words, we use `asyncio.Protocol` as
    a parent class to derive a subclass that meets the needs of our communication
    channel. To do this, we overwrite the following methods from the `asyncio.Protocol`
    base class in our own custom protocol subclass:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通常在构建连接通道时，我们需要专注于实现`asyncio.Protocol`子类及其方法。换句话说，我们使用`asyncio.Protocol`作为父类来派生一个满足通信通道需求的子类。为此，我们在自定义协议子类中覆盖`asyncio.Protocol`基类中的以下方法：
- en: '`Protocol.connection_made(transport)`: This method is automatically called
    whenever a connection from another system is made. The `transport` argument holds
    the `transport` object that is associated with the connection. Again, each `transport`
    needs to be paired with a protocol; we generally store this `transport` object
    as an attribute of this specific protocol object in the `connection_made()` method.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protocol.connection_made(transport)`: 每当来自另一个系统的连接建立时，将自动调用此方法。`transport`参数保存与连接相关联的`transport`对象。同样，每个`transport`都需要与协议配对；我们通常将此`transport`对象作为特定协议对象的属性存储在`connection_made()`方法中。'
- en: '`Protocol.data_received(data)`: This method is automatically called whenever
    the one system that we are connected to sends its data. Note that the `data` argument,
    which holds the sent information, is usually represented in bytes, so the `encode()`
    function of Python should be used before `data` is processed further.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Protocol.data_received(data)`: 每当我们连接的系统发送其数据时，将自动调用此方法。请注意，`data`参数中保存的发送信息通常以字节表示，因此在进一步处理`data`之前应使用Python的`encode()`函数。'
- en: 'Next, let us consider the important methods from the transport classes from
    `asyncio`. All transport classes inherit from a parent transport class, called
    `asyncio.BaseTransport`, for which we have the following common methods:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们考虑来自`asyncio`传输类的重要方法。所有传输类都继承自一个名为`asyncio.BaseTransport`的父传输类，对于该类，我们有以下常用方法：
- en: '`BaseTransport.get_extra_info()`: This method returns, as the name suggests,
    additional channel-specific information for the calling `transport` object. The
    result can include information regarding the socket, the pipe, and the subprocess
    associated with that transport. Later in this chapter, we will be calling `BaseTransport.get_extra_info(''peername'')`,
    in order to obtain the remote address from which the transport traveled.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseTransport.get_extra_info()`: 此方法返回调用的`transport`对象的额外通道特定信息，正如其名称所示。结果可以包括有关与该传输相关联的套接字、管道和子进程的信息。在本章后面，我们将调用`BaseTransport.get_extra_info(''peername'')`，以获取传输的远程地址。'
- en: '`BaseTransport.close()`: This method is used to close the calling `transport`
    object, after which the connections between different systems will be stopped.
    The corresponding protocol of the transport will automatically call its `connection_lost()`
    method.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BaseTransport.close()`: 此方法用于关闭调用的`transport`对象，之后不同系统之间的连接将被停止。传输的相应协议将自动调用其`connection_lost()`方法。'
- en: Out of the many implementations of transport classes, we will focus on the `asyncio.WriteTransport`
    class, which again inherits the methods from the `BaseTransport` class, and additionally
    implements other methods that are used to facilitate write-only transport functionalities.
    Here, we will be using the `WriteTransport.write()` method, which will write the
    data that we would like to send to the other system that we communicate with via
    the `transport` object. As a part of the `asyncio` module, this method is not
    a blocking function; instead, it buffers and sends out the written data in an
    asynchronous way.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多传输类的实现中，我们将专注于`asyncio.WriteTransport`类，它再次继承自`BaseTransport`类的方法，并且还实现了其他用于实现仅写传输功能的方法。在这里，我们将使用`WriteTransport.write()`方法，该方法将写入我们希望通过`transport`对象与另一个系统通信的数据。作为`asyncio`模块的一部分，此方法不是阻塞函数；相反，它以异步方式缓冲并发送已写入的数据。
- en: The big picture of asyncio's server client
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`asyncio`服务器客户端的大局观'
- en: You have learned that asynchronous programming, and `asyncio` specifically,
    can drastically improve the execution of your communication channels. You have
    also seen the specific methods that you will need to use when implementing an
    asynchronous communication channel. Before we dive into a working example in Python,
    let us briefly discuss the big picture of what we are trying to accomplish – or,
    in other words, the general structure of our program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经了解到异步编程，特别是`asyncio`，可以显著改善通信通道的执行。您还看到了在实现异步通信通道时需要使用的特定方法。在我们深入研究Python中的一个工作示例之前，让我们简要讨论一下我们试图实现的大局观，或者换句话说，我们程序的一般结构。
- en: As mentioned earlier, we need to implement a subclass of `asyncio.Protocol`
    to specify the underlying organization of our communication channel. Again, there
    is an event loop at the heart of each asynchronous program, so we also need to
    create a server outside of the context of the protocol class, and initiate that
    server inside of the event loop of our program. This process will set up the asynchronous
    architecture of our entire server, and can be done via the `asyncio.create_server()`
    method, which we will look at in our upcoming example.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，我们需要实现`asyncio.Protocol`的子类来指定通信通道的基本组织。同样，在每个异步程序的核心都有一个事件循环，因此我们还需要在协议类的上下文之外创建一个服务器，并在程序的事件循环中启动该服务器。这个过程将设置整个服务器的异步架构，并且可以通过`asyncio.create_server()`方法来完成，我们将在接下来的示例中进行讨论。
- en: 'Finally, we will run the event loop of our asynchronous program forever by
    using the `AbstractEventLoop.run_forever()` method. Similar to an actual, real-life
    server, we would like to keep our sever running until it encounters a problem,
    in which case we will close the server gracefully. The following diagram illustrates
    this whole process:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用`AbstractEventLoop.run_forever()`方法永久运行我们异步程序的事件循环。与实际的服务器类似，我们希望保持服务器运行，直到遇到问题，然后我们将优雅地关闭服务器。以下图表说明了整个过程：
- en: '![](assets/5a5d7c16-ff13-4ee0-9eb3-9a55389b7bdb.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a5d7c16-ff13-4ee0-9eb3-9a55389b7bdb.png)'
- en: Asynchronous program structure in communication channels
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通信通道中的异步程序结构
- en: Python example
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python示例
- en: Now, let us look at a specific Python example that implements a server that
    facilitates asynchronous communication. Download the code for this book from the
    GitHub page ([https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)),
    and navigate to the `Chapter11` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个具体的Python示例，实现了一个促进异步通信的服务器。从GitHub页面（[https://github.com/PacktPublishing/Mastering-Concurrency-in-Python](https://github.com/PacktPublishing/Mastering-Concurrency-in-Python)）下载本书的代码，并转到`Chapter11`文件夹。
- en: Starting a server
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动服务器
- en: 'In the `Chapter11/example1.py` file, let''s look at the `EchoServerClientProtocol`
    class, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Chapter11/example1.py`文件中，让我们来看一下`EchoServerClientProtocol`类，如下所示：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, our `EchoServerClientProtocol` class is a subclass of `asyncio.Protocol`.
    As we discussed earlier, inside of this class, we need to implement the `connection_made(transport)`
    and `data_received(data)` methods. In the `connection_made()` method, we simply
    obtain the address of the connected system via the `get_extra_info()` method (with
    the `'peername'` argument), print a message out with that information, and finally
    store the `transport` object in an attribute of the class. In order to print out
    a similar message in the `data_received()` method, again we use the `decode()`
    method to obtain a string object from byte data.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们的`EchoServerClientProtocol`类是`asyncio.Protocol`的子类。正如我们之前讨论的那样，在这个类的内部，我们需要实现`connection_made(transport)`和`data_received(data)`方法。在`connection_made()`方法中，我们简单地通过`get_extra_info()`方法（使用`'peername'`参数）获取连接系统的地址，打印出带有该信息的消息，并最终将`transport`对象存储在类的属性中。为了在`data_received()`方法中打印出类似的消息，我们再次使用`decode()`方法从字节数据中获取一个字符串对象。
- en: 'Let us move on to the main program of our script, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看一下我们脚本的主程序，如下所示：
- en: '[PRE1]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are using the familiar `asyncio.get_event_loop()` function to create an event
    loop for our asynchronous program. Then, we create a server for our communication
    by having that event loop call the `create_server()` method; this method takes
    in a subclass from the `asyncio.Protocol` class, an address for our server (in
    this case, it is our local host: `127.0.0.1`), and finally, a port for that address
    (typically, `8888`).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用熟悉的`asyncio.get_event_loop()`函数为我们的异步程序创建一个事件循环。然后，我们通过让该事件循环调用`create_server()`方法来为我们的通信创建一个服务器；这个方法接受`asyncio.Protocol`类的子类、服务器的地址（在本例中是本地主机：`127.0.0.1`）以及该地址的端口（通常为`8888`）。
- en: Note that this method does not create the server itself; it only initiates the
    process of creating the server asynchronously, and returns a coroutine that will
    finish the process. For this reason, we need to store the returned coroutine from
    the method in a variable (`coro`, in our case) and have our event loop run that
    coroutine. After printing out a message using the `sockets` attribute of our server
    object, we will run the event loop forever, in order to keep the server running,
    except for the case of a `KeyboardInterrupt` exception being invoked.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个方法并不会创建服务器本身；它只会异步地启动创建服务器的过程，并返回一个完成该过程的协程。因此，我们需要将该方法返回的协程存储在一个变量中（在我们的例子中是`coro`），并让我们的事件循环运行该协程。在使用服务器对象的`sockets`属性打印出一条消息之后，我们将事件循环永远运行，以保持服务器运行，除非出现`KeyboardInterrupt`异常。
- en: Finally, at the end of our program, we will handle the house cleaning portion
    of the script, which is closing the server gracefully. This is typically done
    by having the server object call the `close()` method (to initiate the closing
    process of the server) and using the event loop to run the `wait_closed()` method on
    the server object, to make sure that the server is properly closed. Finally, we
    close the event loop.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们的程序结束时，我们将处理脚本的清理部分，即优雅地关闭服务器。这通常是通过让服务器对象调用`close()`方法（启动服务器关闭过程）并使用事件循环在服务器对象上运行`wait_closed()`方法来完成的，以确保服务器正确关闭。最后，我们关闭事件循环。
- en: Installing Telnet
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Telnet
- en: Before we can run our sample Python program, we have to install the Telnet program,
    in order to correctly simulate a connection channel between a client and a server.
    Telnet is a program that provides Terminal commands that facilitate protocols
    for bidirectional, interactive, text-oriented communication. If you already have
    Telnet working on your computer, simply skip to the next section; otherwise, find
    the information appropriate to your system in this section.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行我们的示例Python程序之前，我们必须安装Telnet程序，以便正确模拟客户端和服务器之间的连接通道。Telnet是一个提供终端命令的程序，用于促进双向交互式的文本通信协议。如果您的计算机上已经安装了Telnet，只需跳过下一节；否则，请在本节中找到适合您系统的信息。
- en: 'In Windows systems, Telnet is already installed, but might not be enabled.
    To enable it, you can either utilize the Turn Windows features on or off window
    and make sure that the Telnet Client box is checked, or run the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows系统中，Telnet已经安装，但可能未启用。要启用它，您可以使用“打开或关闭Windows功能”窗口，并确保Telnet客户端框被选中，或者运行以下命令：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Linux systems typically come with Telnet preinstalled, so if you own a Linux
    system, simply move on to the next section.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Linux系统通常预装了Telnet，因此如果您拥有Linux系统，只需继续下一节。
- en: 'In macOS systems, it is possible that Telnet has already been installed on
    your computer. If not, you will need to do it via the package management software
    Homebrew, as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在macOS系统中，Telnet可能已经安装在您的计算机上。如果没有，您需要通过软件包管理软件Homebrew进行安装，如下所示：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that macOS systems do have a preinstalled alternative to Telnet, called
    Netcat. If you do not want Telnet installed on your macOS computer, simply use
    the `nc` command instead of `telnet` in the following examples, and you will achieve
    the same effect.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，macOS系统确实有一个预安装的Telnet替代品，称为Netcat。如果您不希望在macOS计算机上安装Telnet，只需在以下示例中使用`nc`命令而不是`telnet`，即可实现相同的效果。
- en: Simulating a connection channel
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟连接通道
- en: 'There are multiple steps to running the following server example. First, we
    need to run the script to start the server, from which you will obtain the following
    output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下服务器示例有多个步骤。首先，我们需要运行脚本以启动服务器，从中您将获得以下输出：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Notice that the program will run until you invoke the *Ctrl* + *C* key combination.
    With the program still running in one Terminal (this is our server Terminal),
    open another Terminal and connect to the server (`127.0.0.1`) at the specified
    port (`8888`); this will server as our client Terminal:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，程序将一直运行，直到您调用*Ctrl* + *C*键组合。在一个终端（这是我们的服务器终端）中仍在运行程序的情况下，打开另一个终端并连接到指定端口（`8888`）的服务器（`127.0.0.1`）；这将作为我们的客户端终端：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, you will see some changes in both the server and the client Terminals.
    Most likely, your client Terminal will have the following output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您将在服务器和客户端终端中看到一些变化。很可能，您的客户端终端将有以下输出：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This is from the interface of the Telnet program, which indicates that we have
    successfully connected to our local server. The more interesting output is on
    our server Terminal, and it will be similar to the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Telnet程序的界面，它表示我们已成功连接到本地服务器。更有趣的输出在我们的服务器终端上，它将类似于以下内容：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Recall that this is an information message that we implemented in our `EchoServerClientProtocol`
    class—specifically in the `connection_made()` method. Again, as a connection between
    the server and a new client is made, this method will be called automatically,
    in order to initiate the communication. From the output message, we know that
    the client is making their requests from port `60332` of server `127.0.0.1` (which
    is the same as the running server, since they are both local).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这是我们在`EchoServerClientProtocol`类中实现的信息消息，具体在`connection_made()`方法中。同样，当服务器与新客户端之间建立连接时，将自动调用此方法，以启动通信。从输出消息中，我们知道客户端正在从服务器`127.0.0.1`的端口`60332`发出请求（与运行服务器相同，因为它们都是本地的）。
- en: Another feature that we implemented in the `EchoServerClientProtocol` class
    was in the `data_received()` method. Specifically, we print the decoded data that
    is sent from the client. To simulate this type of communication, simply type a
    message in your client Terminal and press the *Return* (*Enter,* for Windows)
    key. You will not see any changes in the client Terminal output, but the server
    Terminal should print out a message, as specified in the `data_received()` method
    of our protocol class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`EchoServerClientProtocol`类中实现的另一个功能是在`data_received()`方法中。具体来说，我们打印从客户端发送的解码数据。要模拟这种类型的通信，只需在客户端终端中输入一条消息，然后按*Return*（对于Windows，按*Enter*）键。您将不会在客户端终端输出中看到任何更改，但服务器终端应该打印出一条消息，如我们协议类的`data_received()`方法中指定的那样。
- en: 'For example, the following is my server Terminal output when I send the message
    `Hello, World!` from my client Terminal:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我从客户端终端发送消息`Hello, World!`时，以下是我的服务器终端输出：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `\r` and `\n` characters are simply the return characters included in the
    message string. With our current protocol, you can send multiple messages to the
    server, and can even have multiple clients send messages to the server. To implement
    this, simply open another Terminal and connect to the local server again. You
    will see from your server Terminal that a different client (from a different port)
    has made a connection to the server, while the original communication of our server
    with the old client is still being maintained. This is another result achieved
    from asynchronous programming, allowing multiple clients to communicate with the
    same server seamlessly, without using threading or multiprocessing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`\r`和`\n`字符只是消息字符串中包含的返回字符。使用我们当前的协议，您可以向服务器发送多条消息，甚至可以让多个客户端向服务器发送消息。要实现这一点，只需打开另一个终端并再次连接到本地服务器。您将从服务器终端看到，不同的客户端（来自不同的端口）已连接到服务器，而服务器与旧客户端的原始通信仍在维持。这是异步编程实现的另一个结果，允许多个客户端与同一服务器无缝通信，而无需使用线程或多进程。'
- en: Sending messages back to clients
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将消息发送回客户端
- en: So, in our current example, we are able to have our asynchronous server receive,
    read, and process messages from clients. However, in order for our communication
    channel to be useful, we would also like to send messages from the server to the
    clients. In this section, we will update our server to an echo server, which,
    by definition, will send any and all data that it receives from a specific client
    back to the client.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们当前的示例中，我们能够使我们的异步服务器接收、读取和处理来自客户端的消息。但是，为了使我们的通信渠道有用，我们还希望从服务器向客户端发送消息。在本节中，我们将更新我们的服务器到一个回显服务器，根据定义，它将发送从特定客户端接收到的任何和所有数据回到客户端。
- en: 'To do this, we will be using the `write()` method from the `asyncio.WriteTransport`
    class. Examine the `Chapter11/example2.py` file, in the `data_received()` method
    of the `EchoServerClientProtocol` class, as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，我们将使用`asyncio.WriteTransport`类的`write()`方法。请查看`EchoServerClientProtocol`类的`data_received()`方法中的`Chapter11/example2.py`文件，如下所示：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'After receiving the data from the `transport` object and printing it out, we
    write a corresponding message to the `transport` object, which will go back to
    the original client. By running the `Chapter11/example2.py` script and simulating
    the same communication that we implemented in the last example with Telnet or
    Netcat, you will see that after typing a message in the client Terminal, the client
    receives an echoed message from the server. The following is my output after initiating
    the communication channel and typing in the `Hello, World!` message:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在从`transport`对象接收数据并将其打印出来后，我们向`transport`对象写入相应的消息，该消息将返回给原始客户端。通过运行`Chapter11/example2.py`脚本，并模拟上一个例子中使用Telnet或Netcat实现的相同通信，您会发现在客户端终端输入消息后，客户端会收到服务器的回显消息。在启动通信通道并输入`Hello,
    World!`消息后，以下是我的输出：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In essence, this example illustrates the capability of a bidirectional communication
    channel that we can implement through a custom `asyncio.Protocol` class. While
    running a server, we can obtain data sent from various clients connected to the
    server, process the data, and finally send the desired result back to the appropriate
    clients.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，这个例子说明了通过自定义的`asyncio.Protocol`类，我们可以实现双向通信通道的能力。在运行服务器时，我们可以获取从连接到服务器的各个客户端发送的数据，处理数据，最终将所需的结果发送回适当的客户端。
- en: Closing the transports
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关闭传输
- en: Occasionally, we will want to forcefully close a transport in a communication
    channel. For example, even with asynchronous programming and other forms of concurrency,
    it is possible for your server to be overwhelmed with constant communications
    from multiple clients. On the other hand, it is undesirable to have the server
    completely handle some of the sent requests and plainly reject the rest of the
    requests as soon as the server is at its maximum capacity.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们会希望强制关闭通信通道中的传输。例如，即使使用异步编程和其他形式的并发，您的服务器可能会因来自多个客户端的不断通信而不堪重负。另一方面，当服务器达到最大容量时，完全处理一些发送的请求并明确拒绝其余请求是不可取的。
- en: 'So, instead of keeping the communication open for each and every client connected
    to the server, we can specify in our protocol that each connection should be closed
    after a successful communication. We will do this by using the `BaseTransport.close()`
    method to forcefully close the calling `transport` object, which will stop the
    connection between the server and that specific client. Again, we are modifying
    the `data_received()` method of the `EchoServerClientProtocol` class in `Chapter11/example3.py`,
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以在服务器上为每个连接指定在成功通信后关闭连接，而不是为每个连接保持通信开放。我们将通过使用`BaseTransport.close()`方法来强制关闭调用的`transport`对象，从而停止服务器和特定客户端之间的连接。同样，我们将修改`Chapter11/example3.py`中`EchoServerClientProtocol`类的`data_received()`方法如下：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Run the script, try to connect to the specified server, and type in some messages,
    in order to see the changes that we implemented. With our current setup, after
    a client connects and sends a message to the server, it will receive an echoed
    message back, and its connection with the server will be closed. The following
    is the output (again, from the interface of the Telnet program) that I obtained
    after simulating this process with our current implementation of the protocol:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 运行脚本，尝试连接到指定的服务器，并输入一些消息，以查看我们实现的更改。使用我们当前的设置，客户端连接并向服务器发送消息后，将收到回显消息，并且其与服务器的连接将被关闭。以下是我在使用当前协议模拟此过程后获得的输出（同样来自Telnet程序的界面）：
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Client-side communication with aiohttp
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用aiohttp进行客户端通信
- en: In previous sections, we covered examples of implementing asynchronous communication
    channels with the `asyncio` module, mostly from the perspective of the server
    side of the communication process. In other words, we have been considering handling
    and processing requests sent from external systems. This, however, is only one
    side of the equation, and we also have the client side of communication to explore.
    In this section, we will discuss applying asynchronous programming to make requests
    to servers.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们涵盖了使用`asyncio`模块实现异步通信通道的示例，主要是从通信过程的服务器端的角度。换句话说，我们一直在考虑处理和处理来自外部系统的请求。然而，这只是方程式的一面，我们还有客户端通信的另一面要探索。在本节中，我们将讨论应用异步编程来向服务器发出请求。
- en: As you have most likely guessed, the end goal of this process is to efficiently
    collect data from external systems by asynchronously making requests to those
    systems. We will be revisiting the concept of web scraping, which is the process
    of automating HTTP requests to various websites and extracting specific information
    from their HTML source code. If you have not read [Chapter 5](39ccf044-7fef-4716-acae-a8024f15d67a.xhtml),
    *Concurrent Web Requests*, I highly recommend going through it before proceeding
    with this section, as that chapter covers the foundational ideas of web scraping,
    and other relevant, important concepts.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经猜到的那样，这个过程的最终目标是通过异步向这些系统发出请求，有效地从外部系统中收集数据。我们将重新讨论网络爬虫的概念，即自动化对各种网站进行HTTP请求并从其HTML源代码中提取特定信息的过程。如果您尚未阅读[第5章](39ccf044-7fef-4716-acae-a8024f15d67a.xhtml)，*并发网络请求*，我强烈建议在继续本节之前阅读该章，因为该章涵盖了网络爬虫的基本思想和其他相关重要概念。
- en: 'In this section, you will also be introduced to another module that supports
    asynchronous programming options: `aiohttp` (which stands for **Asynchronous I/O
    HTTP**). This module provides high-level functionalities that streamline HTTP
    communication procedures, and it also works seamlessly with the `asyncio` module,
    in order to facilitate asynchronous programming.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您还将了解另一个支持异步编程选项的模块：`aiohttp`（代表**异步I/O HTTP**）。该模块提供了简化HTTP通信过程的高级功能，并且与`asyncio`模块无缝配合，以便进行异步编程。
- en: Installing aiohttp and aiofiles
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装aiohttp和aiofiles
- en: 'The `aiohttp` module does not come preinstalled with your Python distribution;
    however, similarly to other packages, you can easily install the module by using
    the `pip` or `conda` commands. We will also be installing another module, `aiofiles`,
    which facilitates asynchronous file-writing. If you use `pip` as your package
    manager, simply run the following commands:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`aiohttp`模块不会预装在您的Python发行版中；然而，类似于其他包，您可以通过使用`pip`或`conda`命令轻松安装该模块。我们还将安装另一个模块`aiofiles`，它可以促进异步文件写入。如果您使用`pip`作为您的包管理器，只需运行以下命令：'
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you''d like to use Anaconda, run the following commands:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用Anaconda，请运行以下命令：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As always, to confirm that you have successfully installed a package, open
    your Python interpreter and try to import the module. In this case, run the following
    code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 始终要确认您已成功安装了一个包，打开您的Python解释器并尝试导入模块。在这种情况下，运行以下代码：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There will be no error messages if the package has been successfully installed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果包已成功安装，将不会出现错误消息。
- en: Fetching a website's HTML code
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取网站的HTML代码
- en: 'First, let''s look at how to make a request and obtain the HTML source code
    from a single website with `aiohttp`. Note that even with only one task (a website),
    our application remains asynchronous, and the structure of an asynchronous program
    still needs to be implemented. Now, navigate to the `Chapter11/example4.py` file,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看一下如何使用`aiohttp`从单个网站发出请求并获取HTML源代码。请注意，即使只有一个任务（一个网站），我们的应用程序仍然是异步的，并且异步程序的结构仍然需要实现。现在，导航到`Chapter11/example4.py`文件，如下所示：
- en: '[PRE16]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's consider the `main()` coroutine first. We are initiating an instance from
    the `aiohttp.ClientSession` class within a context manager; note that we are also
    placing the `async` keyword in front of this declaration, since the whole context
    block itself will also be treated as a coroutine. Inside of this block, we are
    calling and waiting for the `get_html()` coroutine to process and return.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先考虑`main()`协程。我们在上下文管理器中初始化了一个`aiohttp.ClientSession`类的实例；请注意，我们还在这个声明前面加上了`async`关键字，因为整个上下文块本身也将被视为一个协程。在这个块内部，我们调用并等待`get_html()`协程进行处理和返回。
- en: Turning our attention to the `get_html()` coroutine, we can see that it takes
    in a session object and a URL for the website that we want to extract the HTML
    source code from. Inside of this function, we make another context manager asynchronous,
    which is used to make a `GET` request and store the response from the server to
    the `res` variable. Finally, we return the HTML source code stored in the response;
    since the response is an object returned from the `aiohttp.ClientSession` class,
    its methods are asynchronous functions, and therefore we need to specify the `await`
    keyword when we call the `text()` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将注意力转向`get_html()`协程，我们可以看到它接受一个会话对象和一个要从中提取HTML源代码的网站的URL。在这个函数内部，我们另外使用了一个异步上下文管理器，用于发出`GET`请求并将来自服务器的响应存储到`res`变量中。最后，我们返回存储在响应中的HTML源代码；由于响应是从`aiohttp.ClientSession`类返回的对象，其方法是异步函数，因此在调用`text()`函数时需要指定`await`关键字。
- en: 'As you run the program, the entire HTML source code of Packt''s website will
    be printed out. For example, the following is a portion of my output:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行程序时，将打印出Packt网站的整个HTML源代码。例如，以下是我的输出的一部分：
- en: '![](assets/a5fb1256-d1a8-42fd-981b-6fe29204e1e1.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a5fb1256-d1a8-42fd-981b-6fe29204e1e1.png)'
- en: HTML source code from aiohttp
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 来自aiohttp的HTML源代码
- en: Writing files asynchronously
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步写文件
- en: Most of the time, we would like to collect data by making requests to multiple
    websites, and simply printing out the response HTML code is inappropriate (for
    many reasons); instead, we'd like to write the returned HTML code to output files.
    In essence, this process is asynchronous downloading, which is also implemented
    in the underlying architecture of popular download managers. To do this, we will
    use the `aiofiles` module, in combination with `aiohttp` and `asyncio`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，我们希望通过向多个网站发出请求来收集数据，并且简单地打印出响应的HTML代码是不合适的（出于许多原因）；相反，我们希望将返回的HTML代码写入输出文件。实质上，这个过程是异步下载，也是流行的下载管理器的底层架构中实现的。为此，我们将使用`aiofiles`模块，结合`aiohttp`和`asyncio`。
- en: 'Navigate to the `Chapter11/example5.py` file. First, we will look at the `download_html()`
    coroutine, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 导航到`Chapter11/example5.py`文件。首先，我们将看一下`download_html()`协程，如下所示：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is an updated version of the `get_html()` coroutine from the last example.
    Instead of using an `aiohttp.ClientSession` instance to make a `GET` request and
    print out the returned HTML code, now we write the HTML code to the file using
    the `aiofiles` module. For example, to facilitate asynchronous file writing, we
    use the asynchronous `open()` function from `aiofiles` to read in a file in a
    context manager. Furthermore, we read the returned HTML in chunks, asynchronously,
    using the `read()` function for the `content` attribute of the response object;
    this means that after reading `1024` bytes of the current response, the execution
    flow will be released back to the event loop, and the task-switching event will
    take place.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是上一个示例中`get_html()`协程的更新版本。现在，我们不再使用`aiohttp.ClientSession`实例来发出`GET`请求并打印返回的HTML代码，而是使用`aiofiles`模块将HTML代码写入文件。例如，为了便于异步文件写入，我们使用`aiofiles`的异步`open()`函数来在上下文管理器中读取文件。此外，我们使用`read()`函数以异步方式按块读取返回的HTML，使用响应对象的`content`属性；这意味着在读取当前响应的`1024`字节后，执行流将被释放回事件循环，并且将发生任务切换事件。
- en: 'The `main()` coroutine and the main program of this example remain relatively
    the same as those in our last example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例的`main()`协程和主程序与我们上一个示例中的相对相同：
- en: '[PRE18]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `main()` coroutine takes in a URL and passes it to the `download_html()`
    coroutine, along with an `aiohttp.ClientSession` instance. Finally, in our main
    program, we create an event loop and pass each item in a specified list of URLs
    to the `main()` coroutine. After running the program, your output should look
    similar to the following, although the time it takes to run the program might
    vary:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`main()`协程接收一个URL，并将其传递给`download_html()`协程，同时传入一个`aiohttp.ClientSession`实例。最后，在我们的主程序中，我们创建一个事件循环，并将指定的URL列表中的每个项目传递给`main()`协程。运行程序后，输出应该类似于以下内容，尽管运行程序所需的时间可能会有所不同：'
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Additionally, a subfolder named `output` (inside of the `Chapter11` folder)
    will be filled with the downloaded HTML code from each website in our list of
    URLs. Again, these files were created and written asynchronously, via the functionalities
    of the `aiofiles` module, which we discussed earlier. As you can see, to compare
    the speed of this program and its corresponding synchronous version, we are also
    keeping track of the time it takes to run the entire program.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`Chapter11`文件夹内会有一个名为`output`的子文件夹，其中将填充我们URL列表中每个网站的下载HTML代码。同样，这些文件是通过`aiofiles`模块的功能异步创建和写入的，这是我们之前讨论过的。如您所见，为了比较这个程序及其对应的同步版本的速度，我们还在跟踪整个程序运行所需的时间。
- en: 'Now, head to the `Chapter11/example6.py` file. This script contains the code
    of the synchronous version of our current program. Specifically, it makes HTTP
    `GET` requests to individual websites in order, and the process of file writing
    is also implemented sequentially. This script produced the following output:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到`Chapter11/example6.py`文件。这个脚本包含了我们当前程序的同步版本的代码。具体来说，它按顺序对各个网站进行HTTP `GET`请求，并且文件写入的过程也是按顺序实现的。这个脚本产生了以下输出：
- en: '[PRE20]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: While it achieved the same results (downloading the HTML code and writing it
    to files), our sequential program took significantly more time than its asynchronous
    counterpart.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它达到了相同的结果（下载HTML代码并将其写入文件），但我们的顺序程序花费的时间明显比其异步对应版本多得多。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: There are seven main layers of communication in a data transmission process,
    with varying degrees of computing level. The media layers contain fairly low-level
    operations that interact with the underlying process of the communication channel,
    while the host layers deals with high-level data communication and manipulation.
    Of the seven, the transport layer is often viewed as the conceptual transition
    between the media layers and the host layers, responsible for sending data along
    end-to-end connections between different systems. Asynchronous programming can
    provide functionalities that complement the process of efficiently facilitating
    communication channels.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 数据传输过程中有七个主要的通信层，具有不同程度的计算级别。媒体层包含与通信通道的底层过程交互的相当低级别的操作，而主机层处理高级数据通信和操作。在这七个层中，传输层通常被视为媒体层和主机层之间的概念性过渡，负责在不同系统之间的端到端连接中发送数据。异步编程可以提供补充有效促进通信通道的过程的功能。
- en: Server-wise, the `asyncio` module combines the abstract of transports with the
    implementation of an asynchronous program. Specifically, via its `BaseTransport`
    and `BaseProtocol` classes, `asyncio` provides different ways to customize the
    underlying architecture of a communication channel. Together with the `aiohttp`
    module, `asyncio` offers efficiency and flexibility regarding client-side communication
    processes. The `aiofiles` module, which can work in conjunction with the other
    two asynchronous programming modules, can also help to facilitate asynchronous
    file reading and writing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器方面，`asyncio`模块将传输的抽象与异步程序的实现结合在一起。具体来说，通过其`BaseTransport`和`BaseProtocol`类，`asyncio`提供了不同的方式来定制通信通道的底层架构。与`aiohttp`模块一起，`asyncio`在客户端通信过程中提供了效率和灵活性。`aiofiles`模块可以与其他两个异步编程模块一起使用，还可以帮助促进异步文件读取和写入。
- en: 'We have now explored three of the biggest, most important topics in concurrent
    programming: threading, multiprocessing, and asynchronous programming. We have
    shown how each of them can be applied to various programming problems and provide
    significant improvements in speed. In the next chapter of this book, we will start
    to discuss problems that concurrent programming commonly poses to developers and
    programmers, starting with deadlocks.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经探讨了并发编程中最重要的三个主题：线程、多进程和异步编程。我们已经展示了它们如何应用于各种编程问题，并在速度上提供了显著的改进。在本书的下一章中，我们将开始讨论并发编程对开发人员和程序员常见的问题，从死锁开始。
- en: Questions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a communication channel? What is its connection to asynchronous programming?
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是通信通道？它与异步编程有什么联系？
- en: What are the two main parts of the OSI model protocol layers? What purposes
    do each of them serve?
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OSI模型协议层有哪两个主要部分？它们各自的目的是什么？
- en: What is the transport layer? Why is it crucial to communication channels?
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输层是什么？它对通信通道为什么至关重要？
- en: How does `asyncio` facilitate the implementation of server-side communication
    channels?
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`如何促进服务器端通信通道的实现？'
- en: How does `asyncio` facilitate the implementation of client-side communication
    channels?
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asyncio`如何促进客户端通信通道的实现？'
- en: What is `aiofiles`?
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aiofiles`是什么？'
- en: Further reading
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information, you can refer to the following links:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，您可以参考以下链接：
- en: '*IoT Systems and Communication Channels* ([bridgera.com/iot-communication-channels/](https://bridgera.com/iot-communication-channels/)),
    by Bridgera'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*IoT系统和通信通道*（[bridgera.com/iot-communication-channels/](https://bridgera.com/iot-communication-channels/)），作者：Bridgera'
- en: '*Automate the boring stuff with Python: practical programming for total beginners*, No
    Starch Press, Al. Sweigart'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用Python自动化无聊的事情：面向完全初学者的实用编程*，No Starch Press，Al. Sweigart'
- en: '*Transports and protocols* ([docs.python.org/3/library/asyncio-protocol](https://docs.python.org/3/library/asyncio-protocol.html)), Python
    documentation'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*传输和协议*（[docs.python.org/3/library/asyncio-protocol](https://docs.python.org/3/library/asyncio-protocol.html)），Python
    文档'
