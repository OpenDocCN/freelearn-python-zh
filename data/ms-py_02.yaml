- en: Chapter 2. Pythonic Syntax, Common Pitfalls, and Style Guide
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章。Pythonic语法，常见陷阱和风格指南
- en: 'The design and development of the Python programming language have always been
    in the hands of its original author, Guido van Rossum, in many cases lovingly
    referred to as the **Benevolent Dictator For Life** (**BDFL**). Even though van
    Rossum is thought to have a time machine (he has repeatedly answered feature requests
    with "I just implemented that last night": [http://www.catb.org/jargon/html/G/Guido.html](http://www.catb.org/jargon/html/G/Guido.html)),
    he is still just a human and needs help with the maintenance and development of
    Python. To facilitate that, the **Python Enhancement Proposal** (**PEP**) process
    has been developed. This process allows anyone to submit a PEP with a technical
    specification of the feature and a rationale to defend its usefulness. After a
    discussion on the Python mailing lists and possibly some improvements, the BDFL
    will make a decision to accept or reject the proposal.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Python编程语言的设计和开发一直由其原始作者Guido van Rossum掌握，他常常被亲切地称为**终身仁慈独裁者**（**BDFL**）。尽管van
    Rossum被认为拥有一台时光机（他曾多次回答功能请求说“我昨晚刚实现了这个”：[http://www.catb.org/jargon/html/G/Guido.html](http://www.catb.org/jargon/html/G/Guido.html)），但他仍然只是一个人，需要帮助来维护和发展Python。为了方便这一点，**Python
    Enhancement Proposal**（**PEP**）流程已经被开发出来。这个流程允许任何人提交一个带有功能技术规范和为其有用性辩护的理由的PEP。在Python邮件列表上进行讨论并可能进行一些改进后，BDFL将做出接受或拒绝提案的决定。
- en: 'The Python style guide (`PEP 8`: [https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/))
    was once submitted as one of those PEPs, and it is has been accepted and improved
    regularly since. It has a lot of great and widely accepted conventions as well
    as a few disputed ones. Especially, the maximum line length of 79 characters is
    a topic of many discussions. Limiting a line to 79 characters does have some merits,
    however. In addition to this, while just the style guide itself does not make
    code Pythonic, as "The Zen of Python" (`PEP 20`: [https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/))
    elegantly says: "Beautiful is better than ugly." `PEP 8` defines how code should
    be formatted in an exact way, and `PEP 20` is more of a philosophy and mindset.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Python风格指南（`PEP 8`：[https://www.python.org/dev/peps/pep-0008/](https://www.python.org/dev/peps/pep-0008/)）曾经作为其中一个PEP提交，自那以后它一直被接受和不断改进。它有很多伟大和广泛接受的惯例，也有一些有争议的。特别是，79个字符的最大行长度是许多讨论的话题。然而，将一行限制在79个字符确实有一些优点。除此之外，虽然风格指南本身并不能使代码成为Pythonic，正如“Python之禅”（`PEP
    20`：[https://www.python.org/dev/peps/pep-0020/](https://www.python.org/dev/peps/pep-0020/)）所说的那样：“美丽胜过丑陋。”
    `PEP 8`定义了代码应该以确切的方式进行格式化，而`PEP 20`更多的是一种哲学和心态。
- en: The common pitfalls are a list of common mistakes made, varying from beginner
    mistakes to advanced ones. They range from passing a list or dictionary (which
    are mutable) as arguments to late-binding problems in closures. An even more important
    issue is how to work around circular imports in a clean way.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的陷阱是一系列常见的错误，从初学者的错误到高级错误不等。它们范围广泛，从将列表或字典（可变的）作为参数传递到闭包中的延迟绑定问题。更重要的问题是如何以一种清晰的方式解决循环导入的问题。
- en: Some of the techniques used in the examples in this chapter might be a bit too
    advanced for such an early chapter, but please don't worry. This chapter is about
    style and common pitfalls. The inner workings of the techniques used will be covered
    in later chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的一些技术可能对于这样一个早期的章节来说有点过于先进，但请不要担心。本章是关于风格和常见陷阱的。使用的技术的内部工作将在后面的章节中介绍。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Code style (`PEP 8`, `pyflakes`, `flake8`, and more)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码风格（`PEP 8`，`pyflakes`，`flake8`等）
- en: Common pitfalls (lists as function arguments, pass by value versus pass by reference,
    and inheritance behavior)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见陷阱（列表作为函数参数，按值传递与按引用传递，以及继承行为）
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The definition of Pythonic code is highly subjective and mainly reflects the
    opinion of this author. When working on a project, it is more important to stay
    consistent with the coding styles of that project than with the coding guidelines
    given by Python or this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonic代码的定义是非常主观的，主要反映了本作者的观点。在项目中工作时，与该项目的编码风格保持一致比遵循Python或本书给出的编码指南更重要。
- en: Code style – or what is Pythonic code?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码风格 - 或者什么是Pythonic代码？
- en: '*Pythonic code*—when you first hear of it, you might think it is a programming
    paradigm, similar to object-oriented or functional programming. While some of
    it could be considered as such, it is actually more of a design philosophy. Python
    leaves you free to choose to program in an object-oriented, procedural, functional,
    aspect-oriented or even logic-oriented way. These freedoms make Python a great
    language to write in, but as always, freedom has the drawback of requiring a lot
    of discipline to keep the code clean and readable. The `PEP8` standard tells us
    how to format code, but there is more to Pythonic code than syntax alone. That
    is what the Pythonic philosophy (`PEP20`) is all about, code that is:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonic code - 当你第一次听到它时，你可能会认为它是一种编程范式，类似于面向对象或函数式编程。虽然有些地方可以被认为是这样，但实际上它更多的是一种设计哲学。Python让你可以自由选择以面向对象，过程式，函数式，面向方面甚至逻辑导向的方式进行编程。这些自由使Python成为一个很好的编程语言，但是，自由总是需要很多纪律来保持代码的清晰和可读性。`PEP8`标准告诉我们如何格式化代码，但Pythonic代码不仅仅是语法。这就是Pythonic哲学（`PEP20`）的全部内容，即代码应该是：
- en: Clean
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清晰
- en: Simple
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单
- en: Beautiful
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美丽
- en: Explicit
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式
- en: Readable
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读性
- en: Most of these sound like common sense, and I think they should be. There are
    cases however, where there is not a single obvious way to do it (unless you're
    Dutch, of course, as you'll read later in this chapter). That is the goal of this
    chapter—to learn what code is beautiful and why certain decisions have been made
    in the Python style guide.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数听起来都像是常识，我认为它们应该是。然而，也有一些情况，没有一个明显的方法来做（除非你是荷兰人，当然，你将在本章后面读到）。这就是本章的目标 -
    学习什么样的代码是美丽的，以及为什么在Python风格指南中做出了某些决定。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some programmers once asked Guido van Rossum whether Python would ever support
    braces. Since that day, braces have been available through a `__future__` import:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有些程序员曾经问过Guido van Rossum，Python是否会支持大括号。从那天起，大括号就可以通过`__future__`导入使用了：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Formatting strings – printf-style or str.format?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化字符串 - `printf-style`还是`str.format`？
- en: Python has supported both `printf-style` (`%`) and `str.format` for a long time,
    so you are most likely familiar with both already.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Python长期以来一直支持`printf-style`（`%`）和`str.format`，所以你很可能已经对两者都很熟悉了。
- en: 'Within this book, `printf-style` formatting will be used for a few reasons:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，`printf-style`格式将被用于一些原因：
- en: The most important reason is that it comes naturally to me. I have been using
    `printf` in many different programming languages for about 20 years now.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的原因是这对我来说很自然。我已经在许多不同的编程语言中使用`printf`大约20年了。
- en: The `printf` syntax is supported in most programming languages, which makes
    it familiar for a lot of people.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大多数编程语言都支持`printf`语法，这使得它对很多人来说很熟悉。
- en: While only relevant for the purposes of the examples in this book, it takes
    up slightly less space, requiring less formatting changes. As opposed to monitors,
    books have not gotten wider over the years.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管这只与本书中的示例有关，但它占用的空间稍微少一些，需要较少的格式更改。与显示器相反，书籍多年来并没有变得更宽。
- en: In general most people recommend `str.format` these days, but it mainly comes
    down to preference. The `printf-style` is simpler, while the `str.format` method
    is more powerful.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，大多数人现在推荐使用`str.format`，但这主要取决于个人偏好。`printf-style`更简单，而`str.format`方法更强大。
- en: If you wish to learn more about how `printf-style` formatting can be replaced
    with `str.format` (or the other way around, of course), then I recommend the PyFormat
    site at [https://pyformat.info/](https://pyformat.info/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于如何用`str.format`替换`printf-style`格式（或者反过来，当然也可以），我推荐访问PyFormat网站[https://pyformat.info/](https://pyformat.info/)。
- en: PEP20, the Zen of Python
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PEP20，Python之禅
- en: 'Most of the Pythonic philosophy can be explained through PEP20\. Python has
    a nice little Easter egg to always remind you of `PEP20`. Simply type `import
    this` in a Python console and you will get the `PEP20` lines. To quote `PEP20`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分Python哲学可以通过PEP20来解释。Python有一个小彩蛋，可以始终提醒你`PEP20`。只需在Python控制台中键入`import this`，就会得到`PEP20`的内容。引用`PEP20`：
- en: '*"Long time Pythoneer Tim Peters succinctly channels the BDFL''s guiding principles
    for Python''s design into 20 aphorisms, only 19 of which have been written down."*'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"长期的Python程序员Tim Peters简洁地表达了BDFL对Python设计的指导原则，总共有20条格言，其中只有19条被记录下来。"*'
- en: The next few paragraphs will explain the intentions of these 19 lines.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几段将解释这19行的意图。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The examples within the PEP20 section are not necessarily all identical in working,
    but they do serve the same purpose. Many of the examples here are fictional and
    serve no purpose other than explaining the rationale of the paragraph.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: PEP20部分的示例在工作上并不完全相同，但它们确实有相同的目的。这里的许多示例都是虚构的，除了解释段落的理由外，没有其他目的。
- en: 'For clarity, let''s see the output of `import this` before we begin:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了清晰起见，在我们开始之前，让我们看一下`import this`的输出：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Beautiful is better than ugly
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 美丽胜过丑陋
- en: 'While beauty is quite subjective, there are some Python style rules to adhere
    to: limiting line lengths, keeping statements on separate lines, splitting imports
    on separate lines, and so on.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管美是相当主观的，但有一些Python风格规则需要遵守：限制行长度，保持语句在单独的行上，将导入拆分为单独的行等等。
- en: 'In short, instead of a somewhat complex function such as this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，与这样一个相当复杂的函数相比：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者这样：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Just do the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 只需执行以下操作：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Simpler, easier to read, and a bit more beautiful!
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 更简单，更易读，更美丽一些！
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: These examples are not identical in results. The first two return lists whereas
    the last returns a generator. Generators will be discussed more thoroughly in
    [Chapter 6](ch06.html "Chapter 6. Generators and Coroutines – Infinity, One Step
    at a Time"), *Generators and Coroutines – Infinity, One Step at a Time*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例的结果并不相同。前两个返回列表，而最后一个返回生成器。生成器将在[第6章](ch06.html "第6章。生成器和协程-无限，一步一次")中更详细地讨论，*生成器和协程-无限，一步一次*。
- en: Explicit is better than implicit
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式胜过隐式
- en: Imports, arguments, and variable names are just some of the many cases where
    explicit code is far easier to read at the cost of a little bit more effort and/or
    verbosity when writing the code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 导入、参数和变量名只是许多情况中的一些，显式代码更容易阅读，但编写代码时需要付出更多的努力和/或冗长。
- en: 'Here is an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个例子：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While this saves you some typing, it becomes quite difficult to see where `some_function`
    is defined. Is it defined in `foo`? In `bar`? Perhaps in both modules? There are
    editors with advanced introspection that can help you here, but why not keep it
    explicit so that everyone (even when simply viewing the code online) can see what
    it's doing?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样可以节省一些输入，但很难看出`some_function`是在哪里定义的。它是在`foo`中定义的吗？在`bar`中定义的吗？也许在两个模块中都定义了？有一些具有高级内省功能的编辑器可以帮助你，但为什么不明确地保持，这样每个人（即使只是在线查看代码）都能看到它在做什么呢？
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The added benefit is that we can explicitly call the function from either `spam`
    or `eggs` here, and everyone will have a better idea what the code does.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的好处是我们可以明确地从`spam`或`eggs`中调用函数，每个人都会更清楚代码的作用。
- en: 'The same goes for functions with `*args` and `**kwargs`. They can be very useful
    at times, but they do have the downside of making it less obvious which arguments
    are valid for a function:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有`*args`和`**kwargs`的函数也是一样。它们有时可能非常有用，但它们的缺点是很难确定哪些参数对于函数是有效的：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Documentation can obviously help for cases like these and I don't disagree with
    the usage of `*args` and `**kwargs` in general, but it is definitely a good idea
    to keep at least the most common arguments explicit. Even when it requires you
    to repeat the arguments for a parent class, it just makes the code that much clearer.
    When refactoring the parent class in future, you'll know whether there are subclasses
    that still use some parameters.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 文档显然对这样的情况有所帮助，我并不反对一般情况下使用`*args`和`**kwargs`，但至少保留最常见的参数是个好主意。即使这需要你重复父类的参数，这样代码会更清晰。在未来重构父类时，你会知道是否还有子类使用了一些参数。
- en: Simple is better than complex
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单胜于复杂
- en: '*"Simple is better than complex. Complex is better than complicated."*'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"简单胜于复杂。复杂胜于混乱。"*'
- en: 'The most important question to ask yourself when starting a new project is:
    how complex does it need to be?'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始一个新项目时，问自己最重要的问题是：它需要多复杂？
- en: For example, let's assume that we've written a small program and now we need
    to store a bit of data. What options do we have here?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们已经编写了一个小程序，现在我们需要存储一些数据。我们有哪些选择？
- en: A full database server, such as PostgreSQL or MySQL
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完整的数据库服务器，比如PostgreSQL或MySQL
- en: A simple file system database, such as SQLite or AnyDBM
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的文件系统数据库，比如SQLite或AnyDBM
- en: Flat file storage, such as CSV and TSV
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平面文件存储，比如CSV和TSV
- en: Structured storage, such as JSON, YAML, or XML
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构化存储，比如JSON、YAML或XML
- en: Serialized Python, such as Pickle or Marshal
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化的Python，比如Pickle或Marshal
- en: 'All of these options have their own use cases as well as advantages and disadvantages
    depending on the use case:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些选项都有自己的用例以及根据用例的优势和劣势：
- en: Are you storing a lot of data? Then full database servers and flat file storage
    are generally the most convenient options.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你存储了大量数据吗？那么完整的数据库服务器和平面文件存储通常是最方便的选择。
- en: Should it be easily portable to different systems without any package installation?
    That makes anything besides full database servers convenient options.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否能够轻松地在不需要任何包安装的不同系统上移植？这使得除了完整的数据库服务器之外的任何选项都很方便。
- en: Do we need to search the data? This is much easier using one of the database
    systems, both filesystem and full servers.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要搜索数据吗？这在使用其中一个数据库系统时要容易得多，无论是文件系统还是完整的服务器。
- en: Are there other applications that need to be able to edit the data? That makes
    universal formats such as flat file storage and the structured storage convenient
    options, but excludes serialized Python.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否有其他应用需要能够编辑数据？这使得像平面文件存储和结构化存储这样的通用格式成为方便的选择，但排除了序列化的Python。
- en: 'Many questions! But the most important one is: how complex does it need to
    be? Storing data in a `pickle` file is something you can do in three lines, while
    connecting to a database (even with SQLite) will be more complicated and, in many
    cases, not needed:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 很多问题！但最重要的一个是：它需要多复杂？在`pickle`文件中存储数据是可以在三行内完成的，而连接到数据库（即使是SQLite）将会更复杂，并且在许多情况下是不需要的：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Versus:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对比：
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These examples are far from identical, of course, as one stores a complete data
    object whereas the other simply stores some key/value pairs within a SQLite database.
    That is not the point, however. The point is that the code is far more complex
    while it is actually less versatile in many cases. With proper libraries, this
    can be simplified, but the basic premise stays the same. Simple is better than
    complex and if the complexity is not needed, it's better to avoid it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这些例子远非相同，一个存储了完整的数据对象，而另一个只是在SQLite数据库中存储了一些键值对。然而，重点不在于此。重点是，尽管使用适当的库可以简化这个过程，但在许多情况下，代码更加复杂，而实际上却不够灵活。简单胜于复杂，如果不需要复杂性，最好避免它。
- en: Flat is better than nested
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扁平胜于嵌套
- en: Nested code quickly becomes unreadable and hard to understand. There are no
    strict rules here, but generally when you have three levels of nested loops, it
    is time to refactor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套的代码很快变得难以阅读和理解。这里没有严格的规则，但通常当你有三层嵌套循环时，就是重构的时候了。
- en: 'Just take a look the following example, which prints a list of two-dimensional
    matrices. While nothing is specifically wrong here, splitting it into a few more
    functions might make it easier to understand the purpose and easier to test:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 只需看下面的例子，它打印了一个二维矩阵的列表。虽然这里没有明显的错误，但将其拆分为更多的函数可能会使目的更容易理解，也更容易测试：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The somewhat flatter version is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 稍微扁平化的版本如下：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example might be a bit convoluted, but the idea is sound. Having deeply
    nested code can easily become very unreadable.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能有点复杂，但思路是正确的。深度嵌套的代码很容易变得难以阅读。
- en: Sparse is better than dense
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 稀疏胜于密集
- en: 'Whitespace is generally a good thing. Yes, it will make your files longer and
    your code will take more space, but it can help a lot with readability if you
    split your code logically:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 空白通常是件好事。是的，它会使你的文件变得更长，你的代码会占用更多的空间，但如果你按逻辑拆分你的代码，它可以帮助很多可读性：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While technically correct, this is not all that readable. I''m certain that
    it would take me some effort to find out what the code actually does and what
    number it would print without trying it:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然从技术上讲是正确的，但这并不是所有人都能读懂的。我相信这需要一些努力才能找出代码实际在做什么，以及它会打印出什么数字，而不是尝试它。
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Still, this is not the best code, but at least it's a bit more obvious what
    is happening in the code.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，这还不是最佳代码，但至少在代码中发生了什么更加明显了一些。
- en: Readability counts
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可读性很重要
- en: 'Shorter does not always mean easier to read:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 更短并不总是意味着更容易阅读：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Although the short version has a certain beauty in conciseness, I personally
    find the following far more beautiful:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简短的版本在简洁上有一定的美感，但我个人觉得下面的更美观：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Practicality beats purity
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实用性胜过纯粹
- en: '*"Special cases aren''t special enough to break the rules. Although practicality
    beats purity."*'
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"特殊情况并不足以打破规则。尽管实用性胜过纯粹。"*'
- en: Breaking the rules can be tempting at times, but it tends to be a slippery slope.
    Naturally, this applies to all rules. If your quick fix is going to break the
    rules, you should really try to refactor it immediately. Chances are that you
    won't have the time to fix it later and will regret it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 违反规则有时会很诱人，但往往会导致一连串的问题。当然，这适用于所有规则。如果你的快速修复会违反规则，你应该立即尝试重构它。很可能你以后没有时间来修复它，并会后悔。
- en: No need to go overboard though. If the solution is good enough and refactoring
    would be much more work, then choosing the working method might be better. Even
    though all of these examples pertain to imports, this guideline applies to nearly
    all cases.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要过分。如果解决方案已经足够好，而重构会更费力，那么选择有效的方法可能更好。尽管所有这些例子都涉及导入，但这个指导原则几乎适用于所有情况。
- en: 'To prevent long lines, imports can be made shorter by using a few methods,
    adding a backslash, adding parentheses, or just shortening the imports:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止行过长，可以通过几种方法使导入变得更短，比如添加反斜杠、添加括号，或者只是缩短导入：
- en: '[PRE16]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This case can easily be avoided by just following `PEP8` (one import per line):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况可以很容易地避免，只需遵循`PEP8`（每行一个导入）：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: But what about really long imports?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是长导入怎么办？
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Yes… even though adding a backslash for imports is generally not recommended,
    there are some cases where it''s still the best option:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 是的…即使通常不建议为导入添加反斜杠，但在某些情况下这仍然是最佳选择：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Errors should never pass silently
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误不应该悄悄地传递
- en: '*"Errors should never pass silently. Unless explicitly silenced."*'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“错误不应该悄悄地传递。除非明确地被压制。”'
- en: 'To paraphrase Jamie Zawinsky: Some people, when confronted with an error, think
    "I know, I''ll use a `try`/`except`/`pass` block." Now they have two problems.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 用Jamie Zawinsky的话来说：有些人在遇到错误时，会想“我知道了，我会使用`try`/`except`/`pass`块。”现在他们有了两个问题。
- en: 'Bare or too broad exception catching is already a bad idea. Not passing them
    along will make you (or some other person working on the code) wonder for ages
    what is happening:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 裸露或过于宽泛的异常捕获已经是一个坏主意了。不传递它们会让你（或者其他人在处理代码时）长时间猜测发生了什么：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you really need to catch all errors, be very explicit about it:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的需要捕获所有错误，就要非常明确地表达出来：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Or even better, catch it specifically and add a sane default:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的是，明确捕获并添加一个合理的默认值：
- en: '[PRE22]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The problem is actually even more complicated. What about blocks of code that
    depend on whatever is happening within the exception? For example, consider the
    following code block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 问题实际上更加复杂。对于依赖异常内部发生情况的代码块怎么办？例如，考虑以下代码块：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If `ValueError` is raised, which line is causing it? Is it `int(user_input)`,
    `do_some_processing(value)`, or `do_some_other_processing(value)`? With silent
    catching of the error, there is no way to know when regularly executing the code,
    and this can be quite dangerous. If for some reason the processing of the other
    functions changes, it becomes a problem to handle exceptions in this way. So,
    unless it was actually intended to behave like that, use this instead:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引发了`ValueError`，是哪一行导致的？是`int(user_input)`，`do_some_processing(value)`，还是`do_some_other_processing(value)`？如果错误被悄悄地捕获，那么在正常执行代码时就无法知道，这可能非常危险。如果由于某种原因其他函数的处理发生了变化，那么以这种方式处理异常就会成为一个问题。所以，除非确实打算这样做，否则请使用这种方式：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the face of ambiguity, refuse the temptation to guess
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 面对模棱两可，拒绝猜测
- en: While guesses will work in many cases, they can bite you if you're not careful.
    As already demonstrated in the "explicit is better than implicit" paragraph, when
    having a few `from ... import *`, you cannot always be certain which module is
    providing you the variable you were expecting.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然猜测在许多情况下都有效，但如果不小心就会出问题。正如在“明确胜于含糊”一段中已经展示的，当有一些`from ... import *`时，你并不能总是确定哪个模块提供了你期望的变量。
- en: 'Ambiguity should generally be avoided, so guessing can be avoided. Clear and
    unambiguous code generates fewer bugs. A useful case where ambiguity is likely
    is function calling. Take, for example, the following two function calls:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应该避免模棱两可，以避免猜测。清晰明了的代码会产生更少的错误。模棱两可可能出现的一个有用情况是函数调用。比如，以下两个函数调用：
- en: '[PRE25]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'They could be the same, but they might also not be. It''s impossible to say
    without seeing the function. If the function were implemented in the following
    way, the results would be vastly different between the two:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可能是相同的，但也可能不是。没有看到函数的情况下是无法说的。如果函数是以以下方式实现的，那么两者之间的结果将会大不相同：
- en: '[PRE26]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: I'm not saying you should use keyword arguments in all cases, but if there are
    many arguments involved and/or hard-to-identify parameters (such as numbers),
    it would be a good idea. Instead of using keyword arguments, you can choose logical
    variable names to pass the arguments as well, as long as the meaning is clearly
    conveyed from the code.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是说你应该在所有情况下使用关键字参数，但如果涉及许多参数和/或难以识别的参数（比如数字），那么这是个好主意。你可以选择逻辑变量名来传递参数，只要从代码中清楚地传达了含义。
- en: 'For example, the following is a similar call that uses custom variable names
    to convey the intent:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，以下是一个类似的调用，使用自定义变量名来传达意图：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: One obvious way to do it
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一种明显的方法
- en: '*"There should be one—and preferably only one—obvious way to do it. Although
    that way may not be obvious at first unless you''re Dutch."*'
  id: totrans-130
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“应该有一种——最好只有一种——明显的方法来做。虽然一开始可能不明显，除非你是荷兰人。”'
- en: In general, after thinking about a difficult problem for a while, you will find
    that there is one solution that is clearly preferable over the alternatives. There
    are cases where this is not the case, however, and in that case, it can be useful
    if you're Dutch. The joke here is that Guido van Rossum, the BDFL and original
    author of Python, is Dutch (as is yours truly).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，经过一段时间思考一个困难的问题后，你会发现有一种解决方案明显优于其他选择。当然也有例外情况，这时如果你是荷兰人就会很有用。这里的笑话是指Python的BDFL和原始作者Guido
    van Rossum是荷兰人（就像我一样）。
- en: Now is better than never
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在总比永远好
- en: '*"Now is better than never. Although never is often better than *right* now."*'
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“现在比不做要好。尽管不做通常比*立刻*做要好。”*'
- en: 'It''s better to fix a problem right now than push it into the future. There
    are cases, however, where fixing it right away is not an option. In those cases,
    a good alternative can be to mark a function as deprecated instead so that there
    is no chance of accidentally forgetting the problem:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 最好立即解决问题，而不是将问题推到未来。然而，有些情况下，立即解决问题并不是一个选择。在这些情况下，一个很好的选择可能是将一个函数标记为已弃用，这样就不会有意外忘记问题的机会：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Hard to explain, easy to explain
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 难以解释，易于解释
- en: '*"If the implementation is hard to explain, it''s a bad idea. If the implementation
    is easy to explain, it may be a good idea."*'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“如果实现很难解释，那就是一个坏主意。如果实现很容易解释，那可能是一个好主意。”*'
- en: As always, keep things as simple as you can. While complicated code can be nice
    to test with, it is more prone to bugs. The simpler you can keep things, the better.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，尽量保持简单。虽然复杂的代码可能很好测试，但更容易出现错误。你能保持事情简单，就越好。
- en: Namespaces are one honking great idea
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命名空间是一个非常棒的想法
- en: '*"Namespaces are one honking great idea—let''s do more of those!"*'
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“命名空间是一个非常棒的想法——让我们做更多这样的事情！”*'
- en: Namespaces can make code a lot clearer to use. Naming them properly makes it
    even better. For example, what does the following line of code do?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间可以使代码更加清晰易用。正确命名它们会让它们变得更好。例如，下面这行代码是做什么的？
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Not too clear, right?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 不太清楚，对吧？
- en: How about the version with the namespace?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 带有命名空间的版本怎么样？
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: And now we do understand.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们明白了。
- en: 'To give an example of a namespace, the full length of which renders it impractical
    to use, we will take a look at the `User` class in Django. Within the Django framework,
    the `User` class is stored in `django.contrib.auth.models.User`. Many projects
    use the object in the following way:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 举一个命名空间的例子，其完整长度使其难以使用，我们将看一下Django中的`User`类。在Django框架中，`User`类存储在`django.contrib.auth.models.User`中。许多项目以以下方式使用该对象：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'While this is fairly clear, it might make someone think that the `User` class
    is local to the current class. Doing the following instead lets people know that
    it is in a different module:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这相当清晰，但可能会让人认为`User`类是当前类的本地类。而以下做法让人们知道它在另一个模块中：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This quickly clashes with other models'' imports though, so personally I would
    recommend the following instead:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这很快就会与其他模块的导入发生冲突，所以我个人建议改用以下方式：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is another alternative:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一种选择：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Conclusion
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结论
- en: 'Now we should have some idea of what the Pythonic ideology is about. Creating
    code that is:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该对Python的思想有了一些了解。创建代码：
- en: Beautiful
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 美观
- en: Readable
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可读
- en: Unambiguous
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 明确的
- en: Explicit enough
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 足够明确
- en: Not completely void of whitespace
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非完全没有空格
- en: So let's move on to some more examples of how to create beautiful, readable,
    and simple code using the Python style guide.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们继续看一些使用Python风格指南创建美观、可读和简单代码的更多例子。
- en: Explaining PEP8
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解释PEP8
- en: The previous paragraphs have already shown a lot of examples using `PEP20` as
    a reference, but there are a few other important guidelines to note as well. The
    PEP8 style guide specifies the standard Python coding conventions. Simply following
    the PEP8 standard doesn't make your code Pythonic though, but it is most certainly
    a good start. Which style you use is really not that much of a concern as long
    as you are consistent. The only thing worse than not using a proper style guide
    is being inconsistent with it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的段落已经展示了很多使用`PEP20`作为参考的例子，但还有一些其他重要的指南需要注意。PEP8风格指南规定了标准的Python编码约定。简单地遵循PEP8标准并不能使你的代码变得Pythonic，但这绝对是一个很好的开始。你使用哪种风格并不是那么重要，只要你保持一致。没有比不使用适当的风格指南更糟糕的事情了，不一致地使用更糟糕。
- en: Duck typing
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鸭子类型
- en: 'Duck typing is a method of handling variables by behavior. To quote Alex Martelli
    (one of my Python heroes, also nicknamed the MartelliBot by many):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型是一种通过行为处理变量的方法。引用Alex Martelli（我的Python英雄之一，也被许多人称为MartelliBot）的话：
- en: '*"Don''t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a
    duck, etc, etc, depending on exactly what subset of duck-like behaviour you need
    to play your language-games with. If the argument fails this specific-ducklyhood-subset-test,
    then you can shrug, ask "why a duck?"*'
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*“不要检查它是否是一只鸭子：检查它是否像一只鸭子一样嘎嘎叫，像一只鸭子一样走路，等等，根据你需要玩语言游戏的鸭子行为子集。如果参数未通过这个特定的鸭子测试，那么你可以耸耸肩，问一句‘为什么是一只鸭子？’”*'
- en: In many cases, when people make a comparison such as `if spam != '':`, they
    are actually just looking for anything that is considered a true value. While
    you can compare the value to the string value `''`, you generally don't have to
    make it so specific. In many cases, simply doing `if spam:` is more than enough
    and actually functions better.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，当人们进行比较，比如`if spam != '':`，他们实际上只是在寻找任何被认为是真值的东西。虽然你可以将值与字符串值`''`进行比较，但你通常不必这么具体。在许多情况下，只需使用`if
    spam:`就足够了，而且实际上功能更好。
- en: 'For example, the following lines of code use the value of `timestamp` to generate
    a filename:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码行使用`timestamp`的值生成文件名：
- en: '[PRE35]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Because it is named `timestamp`, one might be tempted to check whether it is
    actually a `date` or `datetime` object, like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它被命名为`timestamp`，有人可能会想要检查它实际上是一个`date`或`datetime`对象，像这样：
- en: '[PRE36]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'While this is not inherently wrong, comparing types is considered a bad practice
    in Python, as there is oftentimes no need for it. In Python, duck typing is preferred
    instead. Just try converting it to a string and don''t care what it actually is.
    To illustrate how little difference this can make for the end result, see the
    following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这并不是本质上错误的，但在Python中，比较类型被认为是一种不好的做法，因为通常情况下并不需要。在Python中，更倾向于鸭子类型。只需尝试将其转换为字符串，不必在乎它实际上是什么。为了说明这对最终结果几乎没有什么影响，看下面的代码：
- en: '[PRE37]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you might expect, the result is identical:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的那样，结果是相同的：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The same goes for converting a number to a float or an integer; instead of enforcing
    a certain type, just require certain features. Need something that can pass as
    a number? Just try to convert to `int` or `float`. Need a `file` object? Why not
    just check whether there is a `read` method with `hasattr`?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于将数字转换为浮点数或整数；而不是强制执行某种类型，只需要求某些特性。需要一个可以作为数字传递的东西？只需尝试转换为`int`或`float`。需要一个`file`对象？为什么不只是检查是否有一个带有`hasattr`的`read`方法呢？
- en: 'So, don''t do this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要这样做：
- en: '[PRE39]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead, just use the following:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，只需使用以下内容：
- en: '[PRE40]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'And instead of this:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是这样：
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Simply use the following line:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用以下行：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Differences between value and identity comparisons
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 值和身份比较之间的差异
- en: 'There are several methods of comparing objects in Python, the standard greater
    than and less than, equal and unequal. But there are actually a few more, and
    one of them is a bit special. That''s the identity comparison operator: instead
    of using `if spam == eggs`, you use `if spam is eggs`. The big difference is that
    one compares the value and the other compares the identity. This sounds a little
    vague, but it''s actually fairly simple. At least within the CPython implementation,
    the memory address is being compared, which means that it is one of the lightest
    lookups you can get. Whereas a value needs to make sure that the types are comparable
    and perhaps check the sub-values, the identity check just checks whether the unique
    identifier is the same.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有几种比较对象的方法，标准的大于和小于，等于和不等于。但实际上还有一些其他方法，其中一个有点特殊。那就是身份比较运算符：不是使用`if
    spam == eggs`，而是使用`if spam is eggs`。最大的区别在于一个比较值，另一个比较身份。这听起来有点模糊，但实际上相当简单。至少在CPython实现中，比较的是内存地址，这意味着这是你可以得到的最轻量级的查找之一。而值需要确保类型是可比较的，也许需要检查子值，身份检查只是检查唯一标识符是否相同。
- en: Note
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you've ever written Java, you should be familiar with this principle. In
    Java, a regular string comparison (`spam == eggs`) will use the identity instead
    of the value. To compare the value, you need to use `spam.equals(eggs)` to get
    the correct results.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经写过Java，你应该对这个原则很熟悉。在Java中，普通的字符串比较（`spam == eggs`）将使用身份而不是值。要比较值，你需要使用`spam.equals(eggs)`来获得正确的结果。
- en: 'Look at this example:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这个例子：
- en: '[PRE43]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'While the values are the same, the identities are different. The actual result
    from this code is as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然值是相同的，但身份是不同的。这段代码的实际结果如下：
- en: '[PRE44]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The catch is that Python keeps an internal array of integer objects for all
    integers between `-5` and `256`; that's why it works for `256` but not for `257`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于Python为所有介于`-5`和`256`之间的整数保留了一个内部整数对象数组；这就是为什么对`256`有效但对`257`无效的原因。
- en: You might wonder why anyone would ever want to use `is` instead of `==`. There
    are multiple valid answers; depending on the case, one is correct and the other
    isn't. But performance can also be a very important consideration. The basic guideline
    is that when comparing Python singletons such as `True`, `False`, and `None`,
    always compare using `is`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么有人会想要使用`is`而不是`==`。有多个有效的答案；取决于情况，一个是正确的，另一个不是。但性能也可以是一个非常重要的考虑因素。基本准则是，当比较Python的单例对象，如`True`、`False`和`None`时，总是使用`is`进行比较。
- en: 'As for the performance consideration, think of the following example:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 至于性能考虑，考虑以下例子：
- en: '[PRE45]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: When doing `spam == eggs`, this will compare every item in both lists to each
    other, so effectively it is doing 1,000,000 comparisons internally. Compare this
    with only one simple identity check when using `spam is eggs`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行`spam == eggs`时，这将比较两个列表中的每个项目，因此在内部实际上进行了100万次比较。将其与使用`spam is eggs`时的简单身份检查进行比较。
- en: To look at what Python is actually doing internally with the `is` operator,
    you can use the `id` function. When executing `if spam is eggs`, Python will actually
    execute `if id(spam) == id(eggs)` internally.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Python在内部实际上使用`is`运算符时的操作，可以使用`id`函数。当执行`if spam is eggs`时，Python实际上会在内部执行`if
    id(spam) == id(eggs)`。
- en: Loops
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环
- en: 'Coming from other languages, one might be tempted to use `for` loops or even
    `while` loops to process the items of a `list`, `tuple`, `str`, and so on. While
    valid, it is more complex than needed. For example, consider this code:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于来自其他语言的人来说，可能会倾向于使用`for`循环或甚至`while`循环来处理`list`、`tuple`、`str`等的项目。虽然有效，但比必要的复杂。例如，考虑这段代码：
- en: '[PRE46]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Instead you can do the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是你可以这样做：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'While this can be written even shorter, it''s generally not recommended, as
    it does not improve readability:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可以写得更短，但通常不建议这样做，因为它不会提高可读性：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The last option might be clear to some but not all. Personally, I prefer to
    limit the usage of list comprehensions, dict comprehensions, and map and filter
    statements for when the result is actually being stored.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个选项对一些人可能是清晰的，但对一些人可能不是。我个人更倾向于在实际存储结果时才使用列表推导、字典推导和map和filter语句。
- en: 'For example:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE49]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: But still, only if it doesn't hurt the readability of the code.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 但前提是不会影响代码的可读性。
- en: 'Consider this bit of code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下这段代码：
- en: '[PRE50]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Instead of putting everything in the list comprehension, why not split it into
    a few functions?
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 不要把所有东西都放在列表推导中，为什么不把它分成几个函数呢？
- en: '[PRE51]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: While this code is a bit longer, I would personally argue that it's more readable
    this way.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这段代码有点长，但我个人认为这样更易读。
- en: Maximum line length
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 最大行长度
- en: Many Python programmers think 79 characters is too constricting and just keep
    the lines longer. While I am not going to argue for 79 characters specifically,
    setting a low and fixed limit such as 79 or 99 is a good idea. While monitors
    get wider and wider, limiting your lines can still help a lot with readability
    and it allows you to put multiple files next to each other. It's a regular occurrence
    for me to have four Python files opened next to each other. If the line width
    were more than 79 characters, that simply wouldn't fit.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Python程序员认为79个字符太过约束，只是保持行长。虽然我不会特别为79个字符辩论，但设置一个低且固定的限制，比如79或99是一个好主意。虽然显示器变得越来越宽，限制你的行仍然可以帮助你提高可读性，并且允许你将多个文件放在一起。我经常会打开四个Python文件并排放在一起。如果行宽超过79个字符，那就根本放不下了。
- en: 'The PEP8 guide tells us to use backslashes in cases where lines get too long.
    While I agree that backslashes are preferable over long lines, I still think they
    should be avoided if possible. Here''s an example from PEP8:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: PEP8指南告诉我们在行变得太长的情况下使用反斜杠。虽然我同意反斜杠比长行更可取，但我仍然认为应尽量避免使用。以下是PEP8的一个例子：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Instead of using backslashes, I would reformat it like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我会重新格式化它，而不是使用反斜杠：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Or perhaps the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可能是以下内容：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Not always an option, of course, but it's a good consideration to keep the code
    short and readable. It actually gives a bonus of adding more information to the
    code. If, instead of `filename_1`, you use a name that conveys the goal of the
    filename, it immediately becomes clearer what you are trying to do.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当然并非总是一个选择，但保持代码简洁和可读是一个很好的考虑。它实际上为代码添加了更多信息的奖励。如果您使用传达文件名目标的名称，而不是`filename_1`，那么您正在尝试做什么就立即变得更清晰。
- en: Verifying code quality, pep8, pyflakes, and more
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证代码质量，pep8，pyflakes等
- en: There are many tools for checking code quality in Python. The simplest ones,
    such as `pep8`, just validate a few simple `PEP8` errors. The more advanced ones,
    such as `pylint`, do advanced introspections to detect potential bugs in otherwise
    working code. A large portion of what `pylint` offers is a bit over the top for
    many projects, but still interesting to look at.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多用于检查Python代码质量的工具。最简单的工具，比如`pep8`，只验证一些简单的`PEP8`错误。更先进的工具，比如`pylint`，进行高级内省，以检测潜在的错误在其他情况下工作的代码。`pylint`提供的大部分内容对许多项目来说有点过头，但仍然值得一看。
- en: flake8
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: flake8
- en: The `flake8` tool combines pep8, pyflakes, and McCabe to set up a quality standard
    for code. The `flake8` tool is one of the most important packages for maintaining
    code quality in my packages. All the packages that I maintain have a 100% `flake8`
    compliance requirement. It does not promise readable code, but at least it requires
    a certain level of consistency, which is very important when writing on a project
    with multiple programmers.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`flake8`工具将pep8、pyflakes和McCabe结合起来，为代码设置了一个质量标准。`flake8`工具是我维护代码质量中最重要的包之一。我维护的所有包都要求100%的`flake8`兼容性。它并不承诺可读的代码，但至少要求一定程度的一致性，这在与多个程序员一起编写项目时非常重要。'
- en: Pep8
  id: totrans-229
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Pep8
- en: 'One of the simplest tools used to check the quality of Python code is the `pep8`
    package. It doesn''t check everything that is in the PEP8 standard, but it goes
    a long way and is still updated regularly to add new checks. Some of the most
    important things checked by `pep8` are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 用于检查Python代码质量的最简单的工具之一是`pep8`包。它并不检查PEP8标准中的所有内容，但它走了很长一段路，并且仍然定期更新以添加新的检查。`pep8`检查的一些最重要的事情如下：
- en: Indentation, while Python will not check how many spaces you use to indent,
    it does not help with the readability of your code
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进，虽然Python不会检查你用多少空格缩进，但这并不有助于你的代码可读性
- en: Missing whitespace, such as `spam=123`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少空格，比如`spam=123`
- en: Too much whitespace, such as `def eggs(spam = 123):`
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太多的空格，比如`def eggs(spam = 123):`
- en: Too many or too few blank lines
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 太多或太少的空行
- en: Too long lines
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行太长
- en: Syntax and indentation errors
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法和缩进错误
- en: Incorrect and/or superfluous comparisons (`not in`, `is not`, `if spam is True`,
    and type comparisons without `isinstance`)
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确和/或多余的比较（`not in`，`is not`，`if spam is True`，以及没有`isinstance`的类型比较）
- en: The conclusion is that the `pep8` tool helps a lot with testing whitespace and
    some of the more common styling issues, but it is still fairly limited.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 结论是，`pep8`工具在测试空格和一些常见的样式问题方面帮助很大，但仍然相当有限。
- en: pyflakes
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: pyflakes
- en: 'This is where pyflakes comes in. pyflakes is a bit more intelligent than `pep8`
    and warns you about style issues such as:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是pyflakes的用武之地。pyflakes比`pep8`更智能，它会警告你一些风格问题，比如：
- en: Unused imports
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的导入
- en: Wildcard imports (`from module import *`)
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通配符导入（`from module import *`）
- en: Incorrect `__future__` imports (after other imports)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不正确的`__future__`导入（在其他导入之后）
- en: 'But more importantly, it warns about potential bugs, such as the following:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 但更重要的是，它会警告潜在的错误，比如以下内容：
- en: Redefinitions of names that were imported
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新定义已导入的名称
- en: Usage of undefined variables
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用未定义的变量
- en: Referencing variables before assignment
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赋值之前引用变量
- en: Duplicate argument names
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复的参数名称
- en: Unused local variables
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未使用的局部变量
- en: 'The last bit of PEP8 is covered by the pep8-naming package. It makes sure that
    your naming is close to the standard dictated by PEP8:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: PEP8的最后一部分由pep8-naming包涵盖。它确保您的命名接近PEP8规定的标准：
- en: Class names as *CapWord*
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类名为*CapWord*
- en: Function, variable, and argument names all in lowercase
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数、变量和参数名称全部小写
- en: Constants as full uppercase and being treated as constants
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量全大写并被视为常量
- en: The first argument of instance methods and class methods as *self* and *cls*,
    respectively
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法和类方法的第一个参数分别为*self*和*cls*
- en: McCabe
  id: totrans-255
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: McCabe
- en: 'Lastly, there is the McCabe complexity. It checks the complexity of code by
    looking at the **Abstract Syntax Tree** (**AST**). It finds out how many lines,
    levels, and statements are there and warns you if your code has more complexity
    than a preconfigured threshold. Generally, you will use McCabe through `flake8`,
    but a manual call is possible as well. Using the following code:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有McCabe复杂性。它通过查看**抽象语法树**（**AST**）来检查代码的复杂性。它会找出有多少行、级别和语句，并在您的代码比预先配置的阈值更复杂时警告您。通常，您将通过`flake8`使用McCabe，但也可以手动调用。使用以下代码：
- en: '[PRE55]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'McCabe will give us the following output:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: McCabe将给我们以下输出：
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Your maximum threshold is configurable, of course, but the default is 10\. The
    McCabe test returns a number that is influenced by parameters such as the size
    of a function, the nested depths, and a few others. If your function reaches 10,
    it might be time to refactor the code.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您的最大阈值是可配置的，但默认值为10。 McCabe测试返回一个受函数大小、嵌套深度和其他一些参数影响的数字。如果您的函数达到10，可能是时候重构代码了。
- en: flake8
  id: totrans-261
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: flake8
- en: All of this combined is `flake8`, a tool that combines these tools and outputs
    a single report. Some of the warnings generated by `flake8` might not fit your
    taste, so each and every one of the checks can be disabled, both per file and
    for the entire project if needed. For example, I personally disable `W391` for
    all my projects, which warns about blank lines at the end of a file. This is something
    I find useful while working on code so that I can easily jump to the end of the
    file and start writing code instead of having to append a few lines first.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组合在一起就是`flake8`，这是一个将这些工具结合起来并输出单个报告的工具。`flake8`生成的一些警告可能不符合您的口味，因此如果需要，每一项检查都可以在文件级别和整个项目级别上禁用。例如，我个人在所有项目中都禁用`W391`，它会警告文件末尾的空行。这是我在编写代码时发现很有用的，这样我就可以轻松地跳到文件末尾并开始编写代码，而不必先添加几行。
- en: In general, before committing your code and/or putting it online, just run `flake8`
    from your source directory to check everything recursively.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，在提交代码和/或将其放在网上之前，只需从源目录运行`flake8`以递归检查所有内容。
- en: 'Here is a demonstration with some poorly formatted code:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些格式不佳的代码演示：
- en: '[PRE57]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'It results in the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 它的结果如下：
- en: '[PRE58]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Pylint
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pylint
- en: '`pylint` is a far more advanced—and in some cases better—code quality checker.
    The power of `pylint` does come with a few drawbacks, however. Whereas `flake8`
    is a really fast, light, and safe quality check, `pylint` has far more advanced
    introspection and is much slower for this reason. In addition, `pylint` will most
    likely give you a large number of warnings, which are irrelevant or even wrong.
    This could be seen as a flaw in `pylint`, but it''s actually more of a restriction
    of passive code analysis. Tools such as `pychecker` actually load and execute
    your code. In many cases, this is safe, but there are cases where it is not. Just
    think of what could happen when executing a command that deletes files.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`pylint`是一个更先进的——在某些情况下更好的——代码质量检查器。然而，`pylint`的强大功能也带来了一些缺点。而`flake8`是一个非常快速、轻量级和安全的质量检查工具，`pylint`具有更先进的内省，因此速度要慢得多。此外，`pylint`很可能会给出大量无关或甚至错误的警告。这可能被视为`pylint`的缺陷，但实际上更多的是被动代码分析的限制。诸如`pychecker`之类的工具实际上会加载和执行您的代码。在许多情况下，这是安全的，但也有一些情况是不安全的。想象一下执行一个删除文件的命令可能会发生什么。'
- en: While I have nothing against `pylint`, in general I find that most important
    problems are handled by `flake8`, and others can easily be avoided with some proper
    coding standards. It can be a very useful tool if configured correctly, but without
    configuration, it is very verbose.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我对`pylint`没有意见，但一般来说，我发现大多数重要的问题都可以通过`flake8`来处理，其他问题也可以通过一些适当的编码标准轻松避免。如果配置正确，它可能是一个非常有用的工具，但如果没有配置，它会非常冗长。
- en: Common pitfalls
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见陷阱
- en: Python is a language meant to be clear and readable without any ambiguities
    and unexpected behaviors. Unfortunately, these goals are not achievable in all
    cases, and that is why Python does have a few corner cases where it might do something
    different than what you were expecting.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Python是一种旨在清晰可读且没有任何歧义和意外行为的语言。不幸的是，这些目标并非在所有情况下都能实现，这就是为什么Python确实有一些特殊情况，它可能会做一些与您期望的不同的事情。
- en: This section will show you some issues that you might encounter when writing
    Python code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将向您展示编写Python代码时可能遇到的一些问题。
- en: Scope matters!
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围很重要！
- en: There are a few cases in Python where you might not be using the scope that
    you are actually expecting. Some examples are when declaring a class and with
    function arguments.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中有一些情况，您可能没有使用您实际期望的范围。一些例子是在声明类和使用函数参数时。
- en: Function arguments
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数参数
- en: 'The following example shows a case that breaks due to a careless choice in
    default parameters:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了由于默认参数的粗心选择而导致的一个案例：
- en: '[PRE59]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You would probably expect the following output:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会期望以下输出：
- en: '[PRE60]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But it''s actually this:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 但实际上是这样的：
- en: '[PRE61]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The reason is that `list_` and `dict_` are actually shared between multiple
    calls. The only time this is actually useful is if you are doing something hacky,
    so please avoid using mutable objects as default parameters in a function.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`list_`和`dict_`实际上是在多次调用之间共享的。唯一有用的情况是在做一些巧妙的事情时，所以请避免在函数中使用可变对象作为默认参数。
- en: 'The safe alternative of the same example is as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 相同示例的安全替代如下：
- en: '[PRE62]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Class properties
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类属性
- en: 'The problem also occurs when defining classes. It is very easy to mix class
    attributes and instance attributes. Especially when coming from other languages
    such as C#, this can be confusing. Let''s illustrate it:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义类时也会出现问题。很容易混淆类属性和实例属性。特别是对于从其他语言（如C#）转过来的人来说，这可能会令人困惑。让我们来举个例子：
- en: '[PRE63]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'As with the function arguments, the list and dictionaries are shared. So, the
    output is as follows:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数参数一样，列表和字典是共享的。因此，输出如下：
- en: '[PRE64]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A better alternative is to initialize the mutable objects within the `__init__`
    method of the class. This way, they are not shared between instances:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的选择是在类的`__init__`方法中初始化可变对象。这样，它们不会在实例之间共享：
- en: '[PRE65]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Another important thing to note when dealing with classes is that a class property
    will be inherited, and that''s where things might prove to be confusing. When
    inheriting, the original properties will stay (unless overwritten), even in subclasses:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 处理类时需要注意的另一件重要事情是，类属性将被继承，这可能会让事情变得混乱。在继承时，原始属性将保留（除非被覆盖），即使在子类中也是如此：
- en: '[PRE66]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: While this is to be expected due to inheritance, someone else using the class
    might not suspect the variable to change in the meantime. After all, we modified
    `A.spam`, not `B.spam`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然由于继承而可以预料到这一点，但使用类的其他人可能不会怀疑变量在此期间发生变化。毕竟，我们修改了`A.spam`，而不是`B.spam`。
- en: There are two easy ways to prevent this. It is obviously possible to simply
    set `spam` for every class separately. But the better solution is never to modify
    class properties. It's easy to forget that the property will change in multiple
    locations, and if it has to be modifiable anyway, it's usually better to put it
    in an instance variable instead.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种简单的方法可以避免这种情况。显然，可以简单地为每个类单独设置`spam`。但更好的解决方案是永远不要修改类属性。很容易忘记属性将在多个位置更改，如果它必须是可修改的，通常最好将其放在实例变量中。
- en: Modifying variables in the global scope
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改全局范围的变量
- en: A common problem when accessing variables from the global scope is that setting
    a variable makes it local, even when accessing the global variable.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 从全局范围访问变量时的一个常见问题是，设置变量会使其成为局部变量，即使访问全局变量也是如此。
- en: 'This works:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这样可以工作：
- en: '[PRE67]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'But the following does not:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 但以下内容不是：
- en: '[PRE68]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The problem is that `spam += 1` actually translates to `spam = spam + 1`, and
    anything containing `spam =` makes the variable local to your scope. Since the
    local variable is being assigned at that point, it has no value yet and you are
    trying to use it. For these cases, there is the `global` statement, although I
    would really recommend that you avoid globals altogether.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`spam += 1`实际上转换为`spam = spam + 1`，而包含`spam =`的任何内容都会使变量成为您的范围内的局部变量。由于在那一点上正在分配局部变量，它还没有值，您正在尝试使用它。对于这些情况，有`global`语句，尽管我真的建议您完全避免使用全局变量。
- en: Overwriting and/or creating extra built-ins
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖和/或创建额外的内置函数
- en: While it can be useful in some cases, generally you will want to avoid overwriting
    global functions. The `PEP8` convention for naming your functions—similar to built-in
    statements, functions, and variables—is to use a trailing underscore.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下可能有用，但通常您会希望避免覆盖全局函数。命名函数的`PEP8`约定-类似于内置语句、函数和变量-是使用尾随下划线。
- en: 'So, do not use this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要使用这个：
- en: '[PRE69]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Instead, use the following:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 而是使用以下方法：
- en: '[PRE70]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'For lists and such, this is just a good convention. For statements such as
    `from`, `import`, and `with`, it''s a requirement. Forgetting about this can lead
    to very confusing errors:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于列表等，这只是一个很好的约定。对于`from`、`import`和`with`等语句，这是一个要求。忘记这一点可能会导致非常令人困惑的错误：
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'If you actually want to define a built-in that is available everywhere, it''s
    possible. For debugging purposes, I''ve been known to add this code to a project
    while developing:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您确实想要定义一个在任何地方都可用的内置函数，是可能的。出于调试目的，我已经知道在开发项目时向项目中添加此代码：
- en: '[PRE72]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Much too hacky for production code, but it is still useful when working on a
    large project where you need print statements to debug. Alternative (and better)
    debugging solutions can be found in Chapter 11, *Debugging – Solving the Bugs*.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产代码来说太过狡猾，但在需要打印语句进行调试的大型项目中仍然很有用。替代（更好的）调试解决方案可以在第11章“调试-解决错误”中找到。
- en: 'The usage is quite simple:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 使用起来非常简单：
- en: '[PRE73]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Here is the output:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是输出：
- en: '[PRE74]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Modifying while iterating
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在迭代时修改
- en: 'At one point or another, you will run into this problem: while iterating through
    mutable objects such as lists, dicts, or sets, you cannot modify them. All of
    these result in a `RuntimeError` telling you that you cannot modify the object
    during iteration:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个时候，您将遇到这个问题：在迭代可变对象（如列表、字典或集合）时，您不能修改它们。所有这些都会导致`RuntimeError`告诉您在迭代期间不能修改对象：
- en: '[PRE75]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'This can be avoided by copying the object. The most convenient option is by
    using the `list` function:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过复制对象来避免。最方便的选项是使用`list`函数：
- en: '[PRE76]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Catching exceptions – differences between Python 2 and 3
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获异常- Python 2和3之间的区别
- en: 'With Python 3, catching an exception and storing it has been made more obvious
    with the `as` statement. The problem is that many people are still used to the
    `except Exception, variable` syntax, which doesn''t work anymore. Luckily, the
    Python 3 syntax has been backported to Python 2, so now you can use the following
    syntax everywhere:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Python 3，捕获异常并存储它已经变得更加明显，使用`as`语句。问题在于许多人仍然习惯于`except Exception, variable`语法，这种语法已经不再起作用。幸运的是，Python
    3的语法已经回溯到Python 2，所以现在您可以在任何地方使用以下语法：
- en: '[PRE77]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Another important difference is that Python 3 makes this variable local to
    the exception scope. The result is that you need to declare the exception variable
    before the `try`/`except` block if you want to use it later:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的区别是，Python 3使这个变量局限于异常范围。结果是，如果您想要在`try`/`except`块之后使用它，您需要在之前声明异常变量：
- en: '[PRE78]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: You might expect that since we get an exception here, this works; but actually,
    it doesn't, because `exception` does not exist at the point of the `return` statement.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望由于我们在这里得到一个异常，这样可以工作；但实际上，它不起作用，因为在`return`语句的那一点上`exception`不存在。
- en: 'The actual output is as follows:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 实际输出如下：
- en: '[PRE79]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Personally I would argue that the preceding code is broken in any case: what
    if there isn''t an exception somehow? It would have raised the same error. Luckily,
    the fix is simple; just write the value to a variable outside of the scope. One
    important thing to note here is that you explicitly need to save the variable
    to the parent scope. This code does not work either:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 就个人而言，我会认为前面的代码在任何情况下都是错误的：如果没有异常怎么办？它会引发相同的错误。幸运的是，修复很简单；只需将值写入到作用域之外的变量中。这里需要注意的一点是，你需要明确保存变量到父作用域。这段代码也不起作用：
- en: '[PRE80]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'We really need to save it explicitly because Python 3 automatically deletes
    anything saved with `as variable` at the end of the `except` statements. The reason
    for this is that exceptions in Python 3 contain a `__traceback__` attribute. Having
    this attribute makes it much more difficult for the garbage collector to handle
    as it introduces a recursive self-referencing cycle (*exception -> traceback ->
    exception -> traceback… ad nauseum*). To solve this, Python essentially does the
    following:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的需要明确保存它，因为Python 3会自动删除在`except`语句结束时使用`as variable`保存的任何内容。这样做的原因是Python
    3的异常包含一个`__traceback__`属性。拥有这个属性会让垃圾收集器更难处理，因为它引入了一个递归的自引用循环（*exception -> traceback
    -> exception -> traceback… ad nauseum*）。为了解决这个问题，Python基本上执行以下操作：
- en: '[PRE81]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'The solution is simple enough—luckily—but you should keep in mind that this
    can introduce memory leaks into your program. The Python garbage collector is
    smart enough to understand that the variables are not visible anymore and will
    delete it eventually, but it can take a lot more time. How the garbage collection
    actually works is covered in [Chapter 12](ch12.html "Chapter 12. Performance –
    Tracking and Reducing Your Memory and CPU Usage"), *Performance – Tracking and
    Reducing Your Memory and CPU Usage*. Here is the working version of the code:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案非常简单 - 幸运的是 - 但你应该记住，这可能会在程序中引入内存泄漏。Python的垃圾收集器足够聪明，可以理解这些变量不再可见，并最终会删除它，但这可能需要更长的时间。垃圾收集实际上是如何工作的在[第12章](ch12.html
    "第12章。性能 - 跟踪和减少内存和CPU使用情况")中有介绍，*性能 - 跟踪和减少内存和CPU使用情况*。这是代码的工作版本：
- en: '[PRE82]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Late binding – be careful with closures
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 延迟绑定 - 要小心闭包
- en: 'Closures are a method of implementing local scopes in code. They make it possible
    to locally define variables without overriding variables in the parent (or global)
    scope and hide the variables from the outside scope later. The problem with closures
    in Python is that Python tries to bind its variables as late as possible for performance
    reasons. While generally useful, it does have some unexpected side effects:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是在代码中实现局部作用域的一种方法。它使得可以在本地定义变量，而不会覆盖父（或全局）作用域中的变量，并且稍后将变量隐藏在外部作用域中。Python中闭包的问题在于出于性能原因，Python尝试尽可能晚地绑定其变量。虽然通常很有用，但它确实具有一些意想不到的副作用：
- en: '[PRE83]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The expected result? Should be something along the lines of this, right?
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 预期结果？应该是这样的，对吧？
- en: '[PRE84]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: No, unfortunately not. This is similar to how class inheritance works with properties.
    Due to late binding, the variable `i` gets called from the surrounding scope at
    call time, and not when it's actually defined.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 不，不幸的是。这类似于类继承与属性的工作方式。由于延迟绑定，变量`i`在调用时从周围的作用域中调用，而不是在实际定义时调用。
- en: 'The actual result is as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 实际结果如下：
- en: '[PRE85]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'So what to do instead? As with the cases mentioned earlier, the variable needs
    to be made local. One alternative is to force immediate binding by currying the
    function with `partial`:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 那么应该怎么做呢？与前面提到的情况一样，需要将变量设为局部变量。一种替代方法是通过使用`partial`对函数进行柯里化来强制立即绑定。
- en: '[PRE86]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: A better solution would be to avoid binding problems altogether by not introducing
    extra scopes (the `lambda`), that use external variables. If both `i` and `a`
    were specified as arguments to `lambda`, this will not be a problem.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的解决方案是通过不引入额外的作用域（`lambda`）来避免绑定问题，这些作用域使用外部变量。如果`i`和`a`都被指定为`lambda`的参数，这将不是一个问题。
- en: Circular imports
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 循环导入
- en: Even though Python is fairly tolerant towards circular imports, there are some
    cases where you will get errors.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python对循环导入相当宽容，但也有一些情况会出现错误。
- en: Let's assume we have two files.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有两个文件。
- en: '`eggs.py`:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`eggs.py`：'
- en: '[PRE87]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '`spam.py`:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam.py`：'
- en: '[PRE88]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Running `spam.py` will result in a circular `import` error:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`spam.py`将导致循环`import`错误：
- en: '[PRE89]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: There are a few ways to work around this. Restructuring the code is usually
    the best to go around, but the best solution depends on the problem. In the preceding
    case, it can be solved easily. Just use module imports instead of function imports
    (which I recommend regardless of circular imports).
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决这个问题。重新构造代码通常是最好的方法，但最佳解决方案取决于问题。在前面的情况下，可以很容易地解决。只需使用模块导入而不是函数导入（无论是否存在循环导入，我都建议这样做）。
- en: '`eggs.py`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`eggs.py`：'
- en: '[PRE90]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`spam.py`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam.py`：'
- en: '[PRE91]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: An alternative solution is to move the imports within the functions so that
    they occur at runtime. This is not the prettiest solution but it does the trick
    in many cases.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种解决方案是将导入语句移到函数内部，以便在运行时发生。这不是最漂亮的解决方案，但在许多情况下都能解决问题。
- en: '`eggs.py`:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`eggs.py`：'
- en: '[PRE92]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`spam.py`:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam.py`：'
- en: '[PRE93]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Lastly there is the solution of moving the imports below the code that actually
    uses them. This is generally not recommended because it can make it non-obvious
    where the imports are, but I still find it preferable to having the `import` within
    the function calls.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 最后还有一种解决方案，即将导入移到实际使用它们的代码下面。这通常不被推荐，因为它可能会使导入的位置不明显，但我仍然认为这比在函数调用中使用`import`更可取。
- en: '`eggs.py`:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`eggs.py`：'
- en: '[PRE94]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`spam.py`:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`spam.py`：'
- en: '[PRE95]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: And yes, there are still other solutions such as dynamic imports. One example
    of this is how the Django `ForeignKey` fields support strings instead of actual
    classes. But those are generally a really bad idea to use since they will be checked
    only at runtime. Because of this, bugs will introduce themselves only when executing
    any code that uses it instead of when modifying the code. So please try to avoid
    these whenever possible, or make sure you add proper automated tests to prevent
    unexpected bugs. Especially when they cause circular imports internally, they
    become an enormous pain to debug.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，还有其他解决方案，比如动态导入。其中一个例子是Django的`ForeignKey`字段支持字符串而不是实际类。但这些通常是一个非常糟糕的想法，因为它们只会在运行时进行检查。因此，错误只会在执行使用它的任何代码时引入，而不是在修改代码时引入。因此，请尽量避免这些情况，或者确保添加适当的自动化测试以防止意外错误。特别是当它们在内部引起循环导入时，它们将成为一个巨大的调试痛点。
- en: Import collisions
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入冲突
- en: 'One problem that can be extremely confusing is having colliding imports—multiple
    packages/modules with the same name. I have had more than a few bug reports on
    my packages where, for example, people tried to use my `numpy-stl` project, which
    resides in a package named `stl` from a test file named `stl.py`. The result:
    it was importing itself instead of the `stl` package. While this case is difficult
    to avoid, at least within packages, a relative import is generally a better option.
    This is because it also tells other programmers that the import comes from the
    local scope instead of another package. So, instead of writing `import spam`,
    write `from . import spam`. This way, the code will always load from the current
    package instead of any global package that happens to have the same name.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 一个极其令人困惑的问题是导入冲突——多个具有相同名称的包/模块。我在我的包上收到了不少bug报告，例如，有人试图使用我的`numpy-stl`项目，它位于名为`stl`的包中的一个名为`stl.py`的测试文件。结果是：它导入了自身而不是`stl`包。虽然这种情况很难避免，至少在包内部，相对导入通常是一个更好的选择。这是因为它还告诉其他程序员，导入来自本地范围而不是另一个包。因此，不要写`import
    spam`，而是写`from . import spam`。这样，代码将始终从当前包加载，而不是任何偶然具有相同名称的全局包。
- en: In addition to this there is also the problem of packages being incompatible
    with each other. Common names might be used by several packages, so be careful
    when installing those packages. When in doubt, just create a new virtual environment
    and try again. Doing this can save you a lot of debugging.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，还存在包之间不兼容的问题。常见名称可能被几个包使用，因此在安装这些包时要小心。如果有疑问，只需创建一个新的虚拟环境，然后再试一次。这样做可以节省大量的调试时间。
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed us what the Pythonic philosophy is all about and explained
    to us what the Zen of Python is all about. While code style is highly personal,
    Python has a few, very helpful guidelines that at least keep people mostly on
    the same page and style. In the end, we are all consenting adults; everyone has
    the right to write code as he/she sees fit. But I do request you. Please read
    through the style guides and try to adhere to them unless you have a really good
    reason not to.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们展示了Python哲学的全部内容，并向我们解释了Python之禅的含义。虽然代码风格是非常个人化的，但Python至少有一些非常有帮助的指导方针，至少能让人们大致保持在同一页面和风格上。最后，我们都是成年人；每个人都有权利按照自己的意愿编写代码。但我请求您。请阅读风格指南，并尽量遵守它们，除非您有一个真正充分的理由不这样做。
- en: With all that power comes great responsibility, and so do a few pitfalls, though
    there aren't too many. Some are tricky enough to fool me regularly and I've been
    writing Python for a long time! Python improves all the time though. Many pitfalls
    have been taken care of since Python 2, but some will always remain. For example,
    recursive imports and definitions can easily bite you in most languages that support
    them, but that doesn't mean we'll stop trying to improve Python.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这种力量而来的是巨大的责任，也有一些陷阱，尽管并不多。有些陷阱足够棘手，以至于经常会让我困惑，而我已经写了很长时间的Python了！Python不断改进。自Python
    2以来，许多陷阱已经得到解决，但有些将永远存在。例如，递归导入和定义在大多数支持它们的语言中很容易让你掉进陷阱，但这并不意味着我们会停止努力改进Python。
- en: A good example of the improvements in Python over the years is the collections
    module. It contains many useful collections that have been added by users because
    there was a need. Most of them are actually implemented in pure Python, and because
    of that, they are easy enough to be read by anyone. Understanding might take a
    bit more effort, but I truly believe that if you make it to the end of this book,
    you will have no problem understanding what the collections do. Fully understanding
    how the internals work is something I cannot promise though; some parts of that
    go more towards generic computer science than Python mastery.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Python多年来的改进的一个很好的例子是collections模块。它包含了许多有用的集合，这些集合是由用户添加的，因为有这样的需求。其中大多数实际上是用纯Python实现的，因此它们很容易被任何人阅读。理解可能需要更多的努力，但我真的相信，如果你能读完这本书，你将没有问题理解这些集合的作用。但我不能保证完全理解内部工作；其中一些部分更多地涉及通用计算机科学而不是Python掌握。
- en: The next chapter will show you some of the collections available in Python and
    how they are constructed internally. Even though you are undoubtedly familiar
    with collections such as lists and dictionaries, you might not be aware of the
    performance characteristics involved with some of the operations. If some of the
    examples in this chapter were less than clear, you don't have to worry. The next
    chapter will at least revisit some of them, and more will come in later chapters.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将向您展示Python中可用的一些集合以及它们的内部构造。尽管您无疑熟悉列表和字典等集合，但您可能不清楚某些操作涉及的性能特征。如果本章中的一些示例不够清晰，您不必担心。下一章将至少重新讨论其中一些，并且更多内容将在后续章节中介绍。
