- en: Cryptography and Tokens
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密和令牌
- en: '"Three may keep a Secret, if two of them are dead."– Benjamin Franklin, Poor
    Richard''s Almanack'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '"三人可以保守一个秘密，如果其中两人已经死了。" – 本杰明·富兰克林，《穷查理年鉴》'
- en: In this short chapter, I am going to give you a brief overview of the cryptographic
    services offered by the Python standard library. I am also going to touch upon
    something called JSON Web Token, which is a very interesting standard to represent
    claims securely between two parties.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一简短的章节中，我将简要概述Python标准库提供的加密服务。我还将涉及一种称为JSON Web Token的东西，这是一种非常有趣的标准，用于在两个方之间安全地表示声明。
- en: 'In particular, we are going to explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，我们将探讨以下内容：
- en: Hashlib
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hashlib
- en: Secrets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 秘密
- en: HMAC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HMAC
- en: JSON Web Tokens with PyJWT, which seems to be the most popular Python library
    for dealing with JWTs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PyJWT的JSON Web Tokens，这似乎是处理JWTs最流行的Python库。
- en: Let's start by spending a moment talking about cryptography and why it is so
    important.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花点时间谈谈加密以及为什么它如此重要。
- en: The need for cryptography
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加密的需求
- en: According to the statistics you can find all over the web, the estimated amount
    of smartphone users in 2019 will be around 2.5 billion. Each of those people know
    the PIN to unlock their phone, the credentials to log in to applications we all
    use to do, well, basically everything, from buying food to finding a street, from
    sending a message to a friend, to seeing if our bitcoin wallet has increased in
    value since we last checked 10 seconds ago.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 根据网上可以找到的统计数据，2019年智能手机用户的估计数量将达到25亿左右。这些人中的每一个都知道解锁手机的PIN码，登录到我们所有用来做基本上所有事情的应用程序的凭据，从购买食物到找到一条街，从给朋友发消息到查看我们的比特币钱包自上次检查10秒钟前是否增值。
- en: 'If you are an application developer, you have to take security very, very seriously.
    It doesn''t matter how small or apparently insignificant your application is:
    security should always be a concern for you.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个应用程序开发者，你必须非常、非常认真地对待安全性。无论你的应用程序有多小或者看似不重要：安全性应该始终是你关注的问题。
- en: Security in information technology is achieved by employing several different
    means, but by far, the most important one is cryptography. Everything you do with
    your computer or phone should include a layer where cryptography takes place (and
    if not, that's really bad). It is used to pay online with a credit card, to transfer
    messages over the network in a way that even if someone intercepts them, they
    won't be able to read them, and it is used to encrypt your files when you back
    them up in the cloud (because you do, right?). Lists of examples are endless.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 信息技术中的安全性是通过采用多种不同的手段来实现的，但到目前为止，最重要的手段是加密。你在电脑或手机上做的每件事情都应该包括一个加密发生的层面（如果没有，那真的很糟糕）。它用于用信用卡在线支付，以一种方式在网络上传输消息，即使有人截获了它们，他们也无法阅读，它用于在你将文件备份到云端时对文件进行加密（因为你会这样做，对吧？）。例子的列表是无穷无尽的。
- en: Now, the purpose of this chapter is not that of teaching you the difference
    between hashing and encryption, as I could write a whole other book on the subject.
    Rather, it is that of showing you how you can use the tools that Python offers
    you to create digests, tokens, and in general, to be on the safe(r) side when
    you need to implement something cryptography-related.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，本章的目的并不是教你区分哈希和加密的区别，因为我可以写一本完全不同的书来讨论这个话题。相反，它的目的是向你展示如何使用Python提供的工具来创建摘要、令牌，以及在一般情况下，当你需要实现与加密相关的东西时，如何更安全地操作。
- en: Useful guidelines
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的指导方针
- en: 'Always remember the following rules:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 永远记住以下规则：
- en: '**Rule number one**: Do not attempt to create your own hash or encryption functions.
    Simply don''t. Use tools and functions that are there already. It is incredibly
    tough to come up with a good, solid, robust algorithm to do hashing or encryption,
    so it''s best to leave it to professional cryptographers.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则一**：不要尝试创建自己的哈希或加密函数。真的不要。使用已经存在的工具和函数。要想出一个好的、稳固的算法来进行哈希或加密是非常困难的，所以最好将其留给专业的密码学家。'
- en: '**Rule number two**: Follow rule number one.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则二**：遵循规则一。'
- en: Those are the only two rules you need. Apart from them, it is very useful to
    understand cryptography, so you need to try and learn as much as you can about
    this subject. There is plenty of information on the web, but for your convenience,
    I'll put some useful references at the end of this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你需要的唯一两条规则。除此之外，了解加密是非常有用的，所以你需要尽量多地了解这个主题。网上有大量的信息，但为了方便起见，我会在本章末尾放一些有用的参考资料。
- en: 'Now, let''s dig into the first of the standard library modules I want to show
    you: `hashlib`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入研究我想向你展示的标准库模块中的第一个：`hashlib`。
- en: Hashlib
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hashlib
- en: 'This module exposes a common interface to many different secure hash and message
    digest algorithms. The difference in those two terms is simply historical: older
    algorithms were called **digests**, while the modern algorithms are called **hashes**.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块向许多不同的安全哈希和消息摘要算法公开了一个通用接口。这两个术语的区别只是历史上的：旧算法被称为**摘要**，而现代算法被称为**哈希**。
- en: In general, a hash function is any function that can be used to map data of
    an arbitrary size to data of a fixed size. It is a one-way type of encryption,
    in that it is not expected to be able to recover the message given its hash.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，哈希函数是指任何可以将任意大小的数据映射到固定大小数据的函数。它是一种单向加密，也就是说，不希望能够根据其哈希值恢复消息。
- en: 'There are several algorithms that can be used to calculate a hash, so let''s
    see how to find out which ones are supported by your system (note, your results
    might be different than mine):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种算法可以用来计算哈希值，所以让我们看看如何找出你的系统支持哪些算法（注意，你的结果可能与我的不同）：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'By opening a Python shell, we can get the list of available algorithms for
    our system. If our application has to talk to third-party applications, it''s
    always best to pick an algorithm out of those guaranteed, though, as that means
    every platform actually supports them. Notice that a lot of them start with **sha**,
    which means **secure hash algorithm**. Let''s keep going in the same shell: we
    are going to create a hash for the binary string `b''Hash me now!''`, and we''re
    going to do it in two ways:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过打开Python shell，我们可以获取系统中可用的算法列表。如果我们的应用程序必须与第三方应用程序通信，最好从那些有保证的算法中选择一个，因为这意味着每个平台实际上都支持它们。注意到很多算法都以**sha**开头，这意味着**安全哈希算法**。让我们在同一个shell中继续：我们将为二进制字符串`b'Hash
    me now!'`创建一个哈希，我们将以两种方式进行：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have used the `blake2b` cryptographic function, which is quite sophisticated
    and was added in Python 3.6\. After creating the hash object `h`, we update its
    message in two steps. Not that we need to, but sometimes we need to hash data
    that is not available all at once, so it's good to know we can do it in steps.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`blake2b`加密函数，这是一个相当复杂的函数，它是在Python 3.6中添加的。创建哈希对象`h`后，我们以两步更新其消息。虽然我们不需要，但有时我们需要对不一次性可用的数据进行哈希，所以知道我们可以分步进行是很好的。
- en: 'When the message is like we want it to be, we get the hex representation of
    the digest. This will use two characters per byte (as each character represents
    4 bits, which is half a byte). We also get the byte representation of the digest,
    and then we inspect its details: it has a block size (the internal block size
    of the hash algorithm in bytes) of 128 bytes, a digest size (the size of the resulting
    hash in bytes) of 64 bytes, and a name. Could all this be done in one simpler
    line? Yes, of course:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息符合我们的要求时，我们得到摘要的十六进制表示。这将使用每个字节两个字符（因为每个字符代表4位，即半个字节）。我们还得到摘要的字节表示，然后检查其细节：它有一个块大小（哈希算法的内部块大小，以字节为单位）为128字节，一个摘要大小（结果哈希的大小，以字节为单位）为64字节，还有一个名称。所有这些是否可以在一行中完成？是的，当然：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice how the same message produces the same hash, which of course is expected.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意相同的消息产生相同的哈希，这当然是预期的。
- en: 'Let''s see what we get if, instead of the `blake2b` function, we use `sha256`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果我们使用`sha256`而不是`blake2b`函数会得到什么：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The resulting hash is shorter (and therefore less secure).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的哈希较短（因此不太安全）。
- en: 'Hashing is a very interesting topic, and of course the simple examples we''ve
    seen so far are just the start. The `blake2b` function allows us a great deal
    of flexibility in terms of customization. This is extremely useful to prevent
    some kinds of attacks (for the full explanation of those threats, please do refer
    to the standard documentation at: [https://docs.python.org/3.7/library/hashlib.html](https://docs.python.org/3.7/library/hashlib.html)
    for the `hashlib` module). Let''s see another example where we customize a hash
    by adding a `key`, a `salt`, and a `person`. All of this extra information will
    cause the hash to be different than the one we would get if we didn''t provide
    them, and are crucial in adding extra security to the data handled in our system:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是一个非常有趣的话题，当然，我们迄今为止看到的简单示例只是开始。`blake2b`函数允许我们在定制方面有很大的灵活性。这对于防止某些类型的攻击非常有用（有关这些威胁的完整解释，请参考标准文档：[https://docs.python.org/3.7/library/hashlib.html](https://docs.python.org/3.7/library/hashlib.html)中的`hashlib`模块）。让我们看另一个例子，我们通过添加`key`、`salt`和`person`来定制一个哈希。所有这些额外信息将导致哈希与我们没有提供它们时得到的哈希不同，并且在为我们系统处理的数据添加额外安全性方面至关重要：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The resulting hash is only 16 bytes long. Among the customization parameters,
    `salt` is probably the most famous one. It is random data that is used as an additional
    input to a one-way function that hashes data. It is commonly stored alongside
    the resulting hash, in order to provide the means to recover the same hash given
    the same message.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的哈希只有16字节长。在定制参数中，`salt`可能是最著名的一个。它是用作哈希数据的额外输入的随机数据。通常与生成的哈希一起存储，以便提供恢复相同哈希的手段，给定相同的消息。
- en: 'If you want to make sure you hash a password properly, you can use `pbkdf2_hmac`,
    a key derivation algorithm that allows you to specify a `salt` and also the number
    of iterations used by the algorithm itself. As computers get more and more powerful,
    it is important to increase the amount of iterations we do over time, otherwise
    the likelihood of a successful brute-force attack on our data increases as time
    passes. Here''s how you would use such an algorithm:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想确保正确地哈希一个密码，你可以使用`pbkdf2_hmac`，这是一种密钥派生算法，它允许你指定算法本身使用的`salt`和迭代次数。随着计算机变得越来越强大，增加随时间进行的迭代次数非常重要，否则随着时间的推移，成功的暴力破解攻击的可能性会增加。以下是你如何使用这样的算法：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Notice I have used `os.urandom` to provide a 16 byte random salt, as recommended
    by the documentation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已经使用`os.urandom`提供了一个16字节的随机盐，这是文档推荐的。
- en: I encourage you to explore and experiment with this module, as sooner or later
    you will have to use it. Now, let's move on to the `secrets` one.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励你去探索和尝试这个模块，因为迟早你会不得不使用它。现在，让我们继续`secrets`。
- en: Secrets
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 秘密
- en: 'This nice, small module is used for generating cryptographically strong, random
    numbers suitable for managing data such as passwords, account authentication,
    security tokens, and related secrets. It was added in Python 3.6, and basically
    deals with three things: random numbers, tokens, and digest comparison. Let''s
    explore them very quickly.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小巧的模块用于生成密码强度的随机数，适用于管理密码、账户认证、安全令牌和相关秘密。它是在Python 3.6中添加的，基本上处理三件事：随机数、令牌和摘要比较。让我们快速地探索一下它们。
- en: Random numbers
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随机数
- en: 'We can use three functions in order to deal with random numbers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用三个函数来处理随机数：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first one, `choice`, picks an element at random from a non-empty sequence.
    The second one, `randbelow`, generates a random integer between `0` and the argument
    you call it with, and the third one, `randbits`, generates an integer with *n* random
    bits in it. Running that code produces the following output (which is always different):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`choice`从非空序列中随机选择一个元素。第二个函数`randbelow`生成一个介于`0`和您调用它的参数之间的随机整数，第三个函数`randbits`生成一个具有*n*个随机位的整数。运行该代码会产生以下输出（始终不同）：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: You should use these functions instead of those from the `random` module whenever
    you need randomness in the context of cryptography, as these are specially designed
    for this task. Let's see what the module gives us for tokens.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要在密码学环境中需要随机性时，您应该使用这些函数，而不是`random`模块中的函数，因为这些函数是专门为此任务设计的。让我们看看模块为我们提供了什么样的令牌。
- en: Token generation
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 令牌生成
- en: 'Again, we have three functions that all produce a token, albeit in different
    formats. Let''s see the example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们有三个函数，它们都以不同的格式生成令牌。让我们看一个例子：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first one, `token_bytes`, simply returns a random byte string containing *n*
    bytes (`16`, in this example). The other two do the same, but `token_hex` returns
    a token in hexadecimal format, and `token_urlsafe` returns a token that only contains
    characters suitable for being included in a URL. Let''s see the output (which
    is a continuation from the previous run):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数`token_bytes`简单地返回一个包含*n*个字节（在本例中为`16`）的随机字节字符串。另外两个函数也是如此，但`token_hex`以十六进制格式返回一个令牌，而`token_urlsafe`返回一个仅包含适合包含在URL中的字符的令牌。让我们看看输出（这是上一次运行的延续）：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This is all nice, so why don't we have some fun and write a random password
    generator using these tools?
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，那么为什么我们不用这些工具写一个随机密码生成器来玩一下呢？
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the previous code, we defined two functions. `generate_pwd` simply generates
    a random string of given length by joining together `length` characters picked
    at random from a string that contains all the letters of the alphabet (lowercase
    and uppercase), and the 10 decimal digits.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们定义了两个函数。`generate_pwd`简单地通过从包含字母表（小写和大写）和10个十进制数字的字符串中随机选择`length`个字符，并将它们连接在一起来生成给定长度的随机字符串。
- en: Then, we define another function, `generate_secure_pwd`, that simply keeps calling `generate_pwd`
    until the random string we get matches the requirements, which are quite simple.
    The password must have at least one lowercase character, `upper` uppercase characters, `digits`
    digits, and `length` length.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义另一个函数`generate_secure_pwd`，它简单地不断调用`generate_pwd`，直到我们得到的随机字符串符合要求，这些要求非常简单。密码必须至少有一个小写字符，`upper`个大写字符，`digits`个数字，和`length`长度。
- en: Before we dive into the `while`loop, it's worth noting that if we sum together
    the requirements (uppercase, lowercase, and digits) and that sum is greater than
    the overall length of the password, there is no way we can ever satisfy the condition
    within the loop. So, in order to avoid getting stuck in an infinite loop, I have
    put a check clause in the first line of the body, and I raise a `ValueError` in
    case I need it. Could you think of how to write a test for this edge case?
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入`while`循环之前，值得注意的是，如果我们将要求（大写、小写和数字）相加，而这个和大于密码的总长度，那么我们永远无法在循环内满足条件。因此，为了避免陷入无限循环，我在主体的第一行放了一个检查子句，并在需要时引发`ValueError`。你能想到如何为这种边缘情况编写测试吗？
- en: 'The body of the `while` loop is straightforward: first we generate the random
    password, and then we verify the conditions by using `any` and `sum`. `any` returns `True`
    if any of the items in the iterable it''s called with evaluate to `True`. The
    use of sum is actually slightly more tricky here, in that it exploits polymorphism.
    Can you see what I''m talking about before you read on?'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`while`循环的主体很简单：首先我们生成随机密码，然后我们使用`any`和`sum`来验证条件。`any`如果可迭代的项目中有任何一个评估为`True`，则返回`True`。在这里，使用sum实际上稍微棘手一些，因为它利用了多态性。在继续阅读之前，你能看出我在说什么吗？'
- en: Well, it's very simple: `True` and `False` in Python are subclasses of integer
    numbers, therefore when summing on an iterable of `True`/`False` values, they
    will automatically be interpreted like integers by the `sum` function. That is
    called **polymorphism**, and we've briefly talked about it in [Chapter 6](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe),
    *OOP, Decorators, and Iterators*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很简单：在Python中，`True`和`False`是整数数字的子类，因此在`True`/`False`值的可迭代上求和时，它们将自动被`sum`函数解释为整数。这被称为**多态性**，我们在[第6章](part0163.html#4REBM0-2ddb708647cc4530a187c2c6c0e9acfe)中简要讨论过，*OOP，装饰器和迭代器*。
- en: 'Running the example produces the following result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例会产生以下结果：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The second password is probably not too secure...
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个密码可能不太安全...
- en: 'One last example, before we move on to the next module. Let''s generate a reset
    password URL:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一个模块之前，最后一个例子。让我们生成一个重置密码的URL：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This function is so easy I will only show you the output:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数非常简单，我只会向你展示输出：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Digest comparison
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要比较
- en: This is probably quite surprising, but within `secrets`, you can find the `compare_digest(a,
    b)` function, which is the equivalent of comparing two digests by simply doing `a
    == b`. So, why do we need that function? It's because it has been designed to
    prevent timing attacks. These kind of attacks can infer information about where
    the two digests start being different, according to the time it takes for the
    comparison to fail. So, `compare_digest` prevents this attack by removing the
    correlation between time and failures. I think this is a brilliant example of
    how sophisticated attacking methods can be. If you raised your eyebrows in astonishment,
    maybe now it's clearer why I said to never implement cryptography functions by
    yourself.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能相当令人惊讶，但在`secrets`中，您可以找到`compare_digest(a, b)`函数，它相当于通过简单地执行`a == b`来比较两个摘要。那么，为什么我们需要该函数呢？因为它旨在防止时序攻击。这种攻击可以根据比较失败所需的时间推断出两个摘要开始不同的位置。因此，`compare_digest`通过消除时间和失败之间的相关性来防止此类攻击。我认为这是一个很好的例子，说明了攻击方法可以有多么复杂。如果您因惊讶而挑起了眉毛，也许现在我说过永远不要自己实现加密函数的原因更加清楚了。
- en: And that's it! Now, let's check out `hmac`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！现在，让我们来看看`hmac`。
- en: HMAC
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HMAC
- en: 'This module implements the HMAC algorithm, as described by RFC 2104 ([https://tools.ietf.org/html/rfc2104.html](https://tools.ietf.org/html/rfc2104.html)).
    Since it is very small, but nonetheless important, I will provide you with a simple
    example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块实现了HMAC算法，如RFC 2104所述（[https://tools.ietf.org/html/rfc2104.html](https://tools.ietf.org/html/rfc2104.html)）。由于它非常小，但仍然很重要，我将为您提供一个简单的示例：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, the interface is always the same or similar. We first convert
    the key and the message into bytes, and then create a `digest` instance that we
    will use to get a hexadecimal representation of the hash. Not much else to say,
    but I thought to add this module anyway, for completeness.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，接口始终是相同或相似的。我们首先将密钥和消息转换为字节，然后创建一个`digest`实例，我们将使用它来获取哈希的十六进制表示。没有什么别的可说的，但我还是想添加这个模块，以保持完整性。
- en: 'Now, let''s move on to a different type of token: JWTs.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向不同类型的令牌：JWT。
- en: JSON Web Tokens
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSON Web Tokens
- en: A **JSON Web Token**, or **JWT**, is a JSON-based open standard for creating
    tokens that assert some number of claims. You can learn all about this technology
    on the website ([https://jwt.io/](https://jwt.io/)). In a nutshell, this type
    of token is comprised of three sections, separated by a dot, in the format *A.B.C*. *B*
    is the payload, which is where we put the data and the claims. *C* is the signature,
    which is used to verify the validity of the token, and *A* is the algorithm used
    to compute the signature. *A*, *B*, and *C* are all encoded with a URL safe Base64
    encoding (which I'll refer to as Base64URL).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**JSON Web Token**，或**JWT**，是用于创建断言某些声明的令牌的基于JSON的开放标准。您可以在网站上了解有关此技术的所有信息（[https://jwt.io/](https://jwt.io/)）。简而言之，这种类型的令牌由三个部分组成，用点分隔，格式为*A.B.C*。*B*是有效载荷，其中我们放置数据和声明。*C*是签名，用于验证令牌的有效性，*A*是用于计算签名的算法。*A*、*B*和*C*都使用URL安全的Base64编码（我将其称为Base64URL）进行编码。'
- en: Base64 is a very popular binary-to-text encoding scheme that represents binary
    data in an ASCII string format by translating it into a radix-64 representation.
    The radix-64 representation uses the letters *A-Z*, *a-z*, and the digits *0-9*,
    plus the two symbols *+* and */* for a grand total of 64 symbols altogether. Therefore,
    not surprisingly, the Base64 alphabet is made up of these 64 symbols. Base64 is
    used, for example, to encode images attached in an email. It happens seamlessly,
    so the vast majority of people are completely oblivious of this fact.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Base64是一种非常流行的二进制到文本编码方案，它通过将二进制数据转换为基64表示形式来以ASCII字符串格式表示二进制数据。基64表示法使用字母*A-Z*、*a-z*和数字*0-9*，再加上两个符号*+*和*/*，总共共64个符号。因此，毫不奇怪，Base64字母表由这64个符号组成。例如，Base64用于编码电子邮件中附加的图像。这一切都是无缝进行的，因此绝大多数人完全不知道这一事实。
- en: The reason why a JWT is encoded using Base64URL is because of the characters `+`
    and `/`, which in a URL context mean space, and path separator, respectively.
    Therefore in the URL safe version, they are replaced with `-` and `_`. Moreover,
    any padding character (`=`), which is normally used in Base64, is stripped out,
    as this too has a specific meaning within a URL.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: JWT使用Base64URL进行编码的原因是因为在URL上下文中，字符`+`和`/`分别表示空格和路径分隔符。因此，在URL安全版本中，它们被替换为`-`和`_`。此外，任何填充字符（`=`），通常在Base64中使用，都被删除，因为在URL中它也具有特定含义。
- en: The way this type of token works is therefore slightly different than what we
    are used to when we work with hashes. In fact, the information that the token
    carries is always visible. You just need to decode *A* and *B* to get the algorithm
    and the payload. However, the security lies in part *C*, which is a HMAC hash
    of the token. If you try to modify the *B* part by editing the payload, encoding
    it back to Base64, and replacing it in the token, the signature won't match any
    more, and therefore the token will be invalid.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这种类型的令牌的工作方式与我们在处理哈希时习惯的方式略有不同。实际上，令牌携带的信息始终是可见的。您只需要解码*A*和*B*以获取算法和有效载荷。但是，安全性部分在于*C*，它是令牌的HMAC哈希。如果您尝试通过编辑有效载荷，将其重新编码为Base64，并替换令牌中的有效载荷，那么签名将不再匹配，因此令牌将无效。
- en: This means that we can build a payload with claims such as *logged in as admin*,
    or something along those lines, and as long as the token is valid, we know we
    can trust that that user is actually logged in as an admin.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以构建一个带有声明的有效载荷，例如*作为管理员登录*，或类似的内容，只要令牌有效，我们就知道我们可以信任该用户实际上是作为管理员登录的。
- en: When dealing with JWTs, you want to make sure you have researched how to handle
    them safely. Things like not accepting unsigned tokens, or restricting the list
    of algorithms you use to encode and decode, as well as other security measures,
    are very important and you should take the time to investigate and learn them.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 处理JWT时，您希望确保已经研究了如何安全处理它们。诸如不接受未签名的令牌，或限制您用于编码和解码的算法列表，以及其他安全措施等事项非常重要，您应该花时间调查和学习它们。
- en: For this part of the code, you will have to have the `PyJWT` and `cryptography`
    Python packages installed. As always, you will find them in the requirements of
    the source code of this book.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对于代码的这一部分，您需要安装`PyJWT`和`cryptography` Python包。与往常一样，您将在本书源代码的要求中找到它们。
- en: 'Let''s start with a simple example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的例子开始：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We define the `data` payload, which contains an ID and some payload data. Then,
    we create a token using the `jwt.encode` function, which takes at least the payload
    and a secret key, which is used to compute the signature. The default algorithm
    used to calculate the token is `HS256`. Let''s see the output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了包含ID和一些有效载荷数据的`data`有效载荷。然后，我们使用`jwt.encode`函数创建一个令牌，该函数至少需要有效载荷和一个用于计算签名的秘钥。用于计算令牌的默认算法是`HS256`。让我们看一下输出：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, as you can see, the token is a binary string of Base64URL-encoded pieces
    of data. We have called `jwt.decode`, providing the correct secret key. Had we
    done otherwise, the decoding would have broken.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所看到的，令牌是Base64URL编码的数据片段的二进制字符串。我们调用了`jwt.decode`，提供了正确的秘钥。如果我们做了其他操作，解码将会失败。
- en: 'Sometimes, you might want to be able to inspect the content of the token without
    verifying it. You can do so by simply calling `decode` this way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望能够检查令牌的内容而不进行验证。您可以通过简单地调用`decode`来实现：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This is useful, for example, when values in the token payload are needed to
    recover the secret key, but that technique is quite advanced so I won''t be spending
    time on it in this context. Instead, let''s see how we can specify a different
    algorithm for computing the signature:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当需要使用令牌有效载荷中的值来恢复秘钥时，这是很有用的，但是这种技术相当高级，所以在这种情况下我不会花时间讨论它。相反，让我们看看如何指定一个不同的算法来计算签名：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output is our original payload dictionary. In case you want to allow more
    than one algorithm in the decoding phase, you can even specify a list of them,
    instead of only one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 输出是我们的原始有效载荷字典。如果您想在解码阶段允许多个算法，您甚至可以指定一个算法列表，而不仅仅是一个。
- en: Now, while you are free to put whatever you want in the token payload, there
    are some claims that have been standardized, and they enable you to have a great
    deal of control over the token.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，虽然您可以在令牌有效载荷中放入任何您想要的内容，但有一些声明已经被标准化，并且它们使您能够对令牌有很大的控制权。
- en: Registered claims
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 已注册的声明
- en: 'At the time of writing this book, these are the registered claims:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，这些是已注册的声明：
- en: '`iss`: The *issuer* of the token'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iss`：令牌的*发行者*'
- en: '`sub`: The *subject* information about the party this token is carrying information
    about'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sub`：关于此令牌所携带信息的*主题*信息'
- en: '`aud`: The *audience* for the token'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`aud`：令牌的*受众*'
- en: '`exp`: The *expiration time*, after which the token is considered to be invalid'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp`：*过期时间*，在此时间之后，令牌被视为无效'
- en: '`nbf`: The *not before (time)*, or the time before which the token is considered
    to be not valid yet'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nbf`：*不早于（时间）*，或者在此时间之前，令牌被视为尚未有效'
- en: '`iat`: The time at which the token was *issued*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iat`：令牌*发行*的时间'
- en: '`jti`: The token *ID*'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jti`：令牌*ID*'
- en: 'Claims can also be categorized as public or private:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 声明也可以被归类为公共或私有：
- en: '**Private**: Are those that are defined by users (consumers and producers)
    of the JWTs. In other words, these are ad hoc claims used for a particular case.
    As such, care must be taken to prevent collisions.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：由JWT的用户（消费者和生产者）定义的声明。换句话说，这些是用于特定情况的临时声明。因此，必须小心防止碰撞。'
- en: '**Public**: Are claims that are either registered with the IANA JSON Web Token
    Claims Registry (a registry where users can register their claims and thus prevent
    collisions), or named using a collision resistant name (for instance, by prepending
    a namespace to its name).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**：是在IANA JSON Web Token声明注册表中注册的声明（用户可以在其中注册他们的声明，从而防止碰撞），或者使用具有碰撞抵抗名称的名称（例如，通过在其名称前加上命名空间）。'
- en: To learn all about claims, please refer to the official website. Now, let's
    see a couple of code examples involving a subset of these claims.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解有关声明的所有内容，请参考官方网站。现在，让我们看一些涉及这些声明子集的代码示例。
- en: Time-related claims
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与时间相关的声明
- en: 'Let''s see how we might use the claims related to time:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用与时间相关的声明：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this example, we set the issued at (`iat`) claim to the current UTC time
    (**UTC** stands for **Universal Time Coordinated**). We then set the not before
    (`nbf`) and expire time (`exp`) at `1` and `3` seconds from now, respectively.
    We then defined a decode helper function that reacts to a token not being valid
    yet, or being expired, by trapping the appropriate exceptions, and then we call
    it three times, interspersed by two calls to sleep. This way, we will try to decode
    the token when it''s not valid yet, then when it''s valid, and finally when it''s
    already expired. This function also prints a useful timestamp before attempting
    decryption. Let''s see how it goes (blank lines have been added for readability):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们将`iat`声明设置为当前的UTC时间（**UTC**代表**协调世界时**）。然后，我们将`nbf`和`exp`设置为分别从现在开始的`1`和`3`秒。然后，我们定义了一个解码辅助函数，它会对尚未有效或已过期的令牌做出反应，通过捕获适当的异常，然后我们调用它三次，中间隔着两次调用睡眠。这样，我们将尝试在令牌尚未有效时解码它，然后在它有效时解码，最后在它已经过期时解码。此函数还在尝试解密之前打印了一个有用的时间戳。让我们看看它是如何执行的（为了可读性已添加了空行）：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As you can see, it all executed as expected. We get nice, descriptive messages
    from the exceptions, and get the original payload back when the token is actually
    valid.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，一切都如预期执行。我们从异常中得到了很好的描述性消息，并且在令牌实际有效时得到了原始有效载荷。
- en: Auth-related claims
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与认证相关的声明
- en: 'Let''s see another quick example involving the issuer (`iss`) and audience
    (`aud`) claims. The code is conceptually very similar to the previous example,
    and we''re going to exercise it in the same way:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看另一个涉及发行者（`iss`）和受众（`aud`）声明的快速示例。代码在概念上与上一个示例非常相似，我们将以相同的方式进行练习：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, this time, we have specified `issuer` and `audience`. It turns
    out that if we don't provide the issuer when decoding the token, it won't cause
    the decoding to break. However, providing the wrong issuer will actually break
    decoding. On the other hand, both failing to provide the audience, or providing
    the wrong audience, will break decoding.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所看到的，这一次我们指定了`issuer`和`audience`。事实证明，如果我们在解码令牌时不提供发行者，它不会导致解码失败。但是，提供错误的发行者将导致解码失败。另一方面，未提供受众，或提供错误的受众，都将导致解码失败。
- en: 'As in the previous example, I have written a custom decode function that reacts
    to the appropriate exceptions. See if you can follow along with the calls and
    the relative output that follows (I''ll help with some blank lines):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一个示例一样，我编写了一个自定义解码函数，以响应适当的异常。看看您是否能跟上调用和随后的输出（我会在一些空行上帮助）：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now, let's see one final example for a more complex use case.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看一个更复杂的用例的最后一个例子。
- en: Using asymmetric (public-key) algorithms
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用非对称（公钥）算法
- en: Sometimes, using a shared secret is not the best option. In those cases, it
    might be useful to adopt a different technique. In this example, we are going
    to create a token (and decode it) using a pair of RSA keys.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用共享密钥并不是最佳选择。在这种情况下，采用不同的技术可能会很有用。在这个例子中，我们将使用一对RSA密钥创建一个令牌（并解码它）。
- en: 'Public key cryptography, or asymmetrical cryptography, is any cryptographic
    system that uses pairs of keys: public keys which may be disseminated widely,
    and private keys which are known only to the owner. If you are interested in learning
    more about this topic, please see the end of this chapter for recommendations.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码学，或非对称密码学，是使用公钥（可以广泛传播）和私钥（只有所有者知道）的密钥对的任何加密系统。如果您有兴趣了解更多关于这个主题的内容，请参阅本章末尾的推荐书目。
- en: 'Now, let''s create two pairs of keys. One pair will have no password, and one
    will. To create them, I''m going to use the `ssh-keygen` utils from OpenSSH ([https://www.ssh.com/ssh/keygen/](https://www.ssh.com/ssh/keygen/)).
    In the folder where my scripts for this chapter are, I created an `rsa` subfolder.
    Within it, run the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建两对密钥。一对将没有密码，另一对将有密码。为了创建它们，我将使用OpenSSH的`ssh-keygen`工具（[https://www.ssh.com/ssh/keygen/](https://www.ssh.com/ssh/keygen/)）。在我为本章编写脚本的文件夹中，我创建了一个`rsa`子文件夹。在其中，运行以下命令：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Give the name `key` to the path (it will be saved in the current folder), and
    simply hit the *Enter* key when asked for the password. When done, do the same
    again, but this time use the name `keypwd` for the key, and give it a password.
    The one I chose is the classic `Password123`. When you are done, change back to
    the `ch9` folder, and run this code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将路径命名为`key`（它将保存在当前文件夹中），并在要求密码时简单地按下*Enter*键。完成后，再做一次相同的操作，但这次使用`keypwd`作为密钥的名称，并给它设置一个密码。我选择的密码是经典的`Password123`。完成后，切换回`ch9`文件夹，并运行以下代码：
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the previous example, we defined a couple of custom functions to encode and
    decode tokens using private/public keys. As you can see in the signature of the `encode`
    function, we are using the `RS256` algorithm this time. We need to open the private
    key file by using the special `load_pem_private_key` function, which allows us
    to specify a content, password, and backend. `.pem` is the name of the format
    in which our keys have been created. If you take a look at those files, you will
    probably recognize them, since they are quite popular.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们定义了一对自定义函数来使用私钥/公钥对编码和解码令牌。正如您在`encode`函数的签名中所看到的，这次我们使用了`RS256`算法。我们需要使用特殊的`load_pem_private_key`函数打开私钥文件，该函数允许我们指定内容、密码和后端。`.pem`是我们的密钥创建的格式的名称。如果您查看这些文件，您可能会认出它们，因为它们非常流行。
- en: The logic is pretty straightforward, and I would encourage you to think about
    at least one use case where this technique might be more suitable than using a
    shared key.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非常简单，我鼓励您至少考虑一个使用这种技术可能比使用共享密钥更合适的用例。
- en: Useful references
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有用的参考资料
- en: 'Here, you can find a list of useful references if you want to dig deeper in
    to the fascinating world of cryptography:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以找到一些有用的参考资料，如果您想深入了解密码学的迷人世界：
- en: Cryptography: [https://en.wikipedia.org/wiki/Cryptography](https://en.wikipedia.org/wiki/Cryptography)
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学：[https://en.wikipedia.org/wiki/Cryptography](https://en.wikipedia.org/wiki/Cryptography)
- en: JSON Web Tokens: [https://jwt.io](https://jwt.io)
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSON Web Tokens：[https://jwt.io](https://jwt.io)
- en: Hash functions: [https://en.wikipedia.org/wiki/Cryptographic_hash_function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哈希函数：[https://en.wikipedia.org/wiki/Cryptographic_hash_function](https://en.wikipedia.org/wiki/Cryptographic_hash_function)
- en: HMAC: [https://en.wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HMAC：[https://en.wikipedia.org/wiki/HMAC](https://en.wikipedia.org/wiki/HMAC)
- en: Cryptography services (Python STD library): [https://docs.python.org/3.7/library/crypto.html](https://docs.python.org/3.7/library/crypto.html)
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学服务（Python STD库）：[https://docs.python.org/3.7/library/crypto.html](https://docs.python.org/3.7/library/crypto.html)
- en: IANA JSON Web Token Claims Registry: [https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IANA JSON Web Token Claims Registry：[https://www.iana.org/assignments/jwt/jwt.xhtml](https://www.iana.org/assignments/jwt/jwt.xhtml)
- en: PyJWT library: [https://pyjwt.readthedocs.io/](https://pyjwt.readthedocs.io/)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PyJWT库：[https://pyjwt.readthedocs.io/](https://pyjwt.readthedocs.io/)
- en: Cryptography library: [https://cryptography.io/](https://cryptography.io/)
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码学库：[https://cryptography.io/](https://cryptography.io/)
- en: There is way more on the web, and plenty of books you can also study, but I'd
    recommend that you start with the main concepts and then gradually dive into the
    specifics you want to understand more thoroughly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上还有更多内容，还有很多书籍可以学习，但我建议您从主要概念开始，然后逐渐深入研究您想更全面了解的具体内容。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this short chapter, we explored the world of cryptography in the Python standard
    library. We learned how to create a hash (or digest) for a message using different
    cryptographic functions. We also learned how to create tokens and deal with random
    data when it comes to the cryptography context.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一短章中，我们探索了Python标准库中的密码学世界。我们学会了如何使用不同的密码学函数为消息创建哈希（或摘要）。我们还学会了如何在密码学上下文中创建令牌并处理随机数据。
- en: We then took a small tour outside the standard library to learn about JSON Web
    Tokens, which are used intensively today in authentication and claims-related
    functionalities by modern systems and applications.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在标准库之外进行了小小的探索，了解了JSON Web令牌，这在现代系统和应用程序中的认证和声明相关功能中被广泛使用。
- en: The most important thing is to understand that doing things manually can be
    very risky when it comes to cryptography, so it's always best to leave it to the
    professionals and simply use the tools we have available.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要明白，在涉及密码学时，手动操作可能非常危险，因此最好还是把它交给专业人士，简单地使用我们现有的工具。
- en: The next chapter will be all about moving away from one line of software execution.
    We're going to learn how software works in the real world, explore concurrent
    execution, and learn about threads, processes, and the tools Python gives us to
    do *more than one thing at a time*, so to speak.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将完全关于摆脱单行软件执行。我们将学习软件在现实世界中的运行方式，探索并发执行，并了解Python提供给我们的线程、进程和工具，以便同时执行*多项任务*，可以这么说。
