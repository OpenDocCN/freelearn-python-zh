- en: 'Chapter 11. Graphs: Values with Relationships'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。图：具有关系的值
- en: The final data structure that we will examine is the **Graph**. Graphs are sets
    of objects with no specifically structured relationship, where each object can
    have links to one or many other objects in the collection. Objects in graphs are
    typically referred to as nodes, vertices, or points. Links, or the relationships
    between the objects, are referred to as edges, lines, or arcs. These links can
    be simple references or they can be objects with values of their own. More formally
    stated, graphs are a pair of sets *(N, E)*, where *N* is the set of nodes and
    *E* is the set of edges in the collection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要考察的最终数据结构是**图**。图是一组没有特定结构关系的对象，其中每个对象可以与集合中一个或多个其他对象有链接。图中的对象通常被称为节点、顶点或点。链接，或对象之间的关系，被称为边、线或弧。这些链接可以是简单的引用，也可以是具有自己值的对象。更正式地说，图是一对集合
    *(N, E)*，其中 *N* 是节点的集合，*E* 是边的集合。
- en: One excellent example of graph applications would be visualizing the relationships
    between individuals in a social media database. In such a database, each person
    in the database represents one node, and each of their links to other people in
    their circle of acquaintances represents an edge. In such a circle of acquaintances,
    it would be perfectly reasonable to see circular or even intertwined relationships
    between nodes as one person can share many of the same friends or coworkers as
    another person. Tree and heap structures would very rapidly break down when attempting
    to rationalize these sets, while the graph data structure was practically designed
    with such scenarios in mind.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 图应用的一个优秀例子将是可视化社交媒体数据库中个人之间的关系。在这样的数据库中，数据库中的每个人代表一个节点，他们与其朋友圈中其他人的每个链接代表一条边。在这样的朋友圈中，看到节点之间呈环形或甚至交织的关系是完全合理的，因为一个人可以和另一个人分享许多相同的朋友或同事。当试图合理化这些集合时，树和堆结构会迅速崩溃，而图数据结构实际上正是为了这样的场景而设计的。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Definition of the graph data structure
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图数据结构的定义
- en: Visual conception of the graph structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图结构的视觉概念
- en: Common operations
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见操作
- en: Graph implementations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图的实现
- en: Visual graph concepts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视觉图概念
- en: 'It is sometimes easier to grasp the concept of graph data structures using
    visual representations of some collections. Consider the following diagram:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用某些集合的视觉表示来理解图数据结构的概念更容易。考虑以下图示：
- en: '![Visual graph concepts](img/00016.jpeg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![视觉图概念](img/00016.jpeg)'
- en: 'This is a basic graph consisting of eleven nodes and twelve edges. Sets *N*
    and *E* can be described as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个由十一个节点和十二条边组成的基本图。集合 *N* 和 *E* 可以描述如下：
- en: '*N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '*N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}*'
- en: '*E = {2:38, 2:77, 2:97, 3:19, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5, 11:52, 77:9}*'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '*E = {2:38, 2:77, 2:97, 3:19, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5, 11:52, 77:9}*'
- en: 'Note that, in this example, there are only unidirectional edges between nodes.
    This is perfectly acceptable, but graphs are much more powerful when bidirectional
    nodes are permitted. Consider the following example:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，节点之间只有单向边。这是完全可以接受的，但当允许双向节点时，图就更加强大。考虑以下示例：
- en: '![Visual graph concepts](img/00017.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![视觉图概念](img/00017.jpeg)'
- en: 'This is the same graph we saw earlier, but set *E* now contains several new
    reciprocal edges between existing nodes. Sets *N* and *E* can now be described
    as follows:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们在前面看到的同一个图，但现在集合 *E* 包含了现有节点之间的一些新互惠边。集合 *N* 和 *E* 现在可以描述如下：
- en: '*N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*N = {2, 3, 4, 5, 9, 11, 19, 38, 52, 77, 97}*'
- en: '*E = {2:5, 2:38, 2:77, 2:97, 3:19, 4:11, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5,
    11:52, 77:9, 97:2}*'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '*E = {2:5, 2:38, 2:77, 2:97, 3:19, 4:11, 4:77, 5:2, 5:19, 11:2, 11:4, 11:5,
    11:52, 77:9, 97:2}*'
- en: 'Finally, edges between nodes can also be defined with a particular value. Consider
    the following example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，节点之间的边也可以定义为一个特定的值。考虑以下示例：
- en: '![Visual graph concepts](img/00018.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![视觉图概念](img/00018.jpeg)'
- en: 'In this figure, we see a graph with a set of six nodes and seven edges. In
    this case, however, the edges are further defined by a specific value. This value
    is not limited to integers, but it can be represented by any type or custom object
    you need. Sets *N* and *E* for this graph can be described as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们看到一个包含六个节点和七条边的图。然而，在这种情况下，边被进一步定义为特定的值。这个值不仅限于整数，它可以表示任何类型或所需的自定义对象。对于这个图的集合
    *N* 和 *E* 可以描述如下：
- en: '*N = {2, 4, 5, 52, 97}*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*N = {2, 4, 5, 52, 97}*'
- en: '*E = {2:5(84), 4:11(97), 11:2(70), 11:4(97), 11:5(16), 11:52(102), 97:2(14)}*'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '*E = {2:5(84), 4:11(97), 11:2(70), 11:4(97), 11:5(16), 11:52(102), 97:2(14)}*'
- en: Graph operations
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图操作
- en: 'Since graphs support bidirectional references between nodes and nodes can virtually
    have unlimited neighbors, it is necessary to define two basic objects in order
    to implement the collection. These include the nodes that make up the graph as
    well as the graph collection itself. Optionally, an edge object may be required
    if the implementation supports edges that contain a value. Therefore, note that
    some of these common graph operations will have components in more than one class:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于图支持节点之间的双向引用，并且节点可以几乎无限地拥有邻居，因此为了实现集合，有必要定义两个基本对象。这些包括构成图的节点以及图集合本身。如果实现支持包含值的边，则可能还需要一个边对象。因此，请注意，一些常见的图操作将在多个类中具有组件：
- en: '**AddNode**: This operation is sometimes called the **AddVertex** or **AddPoint**
    operation, and is dependent on the language used to define the graph. The AddNode
    operation simply inserts new nodes into the graph without defining any edges or
    references to neighboring nodes. Since a node does not necessarily need to have
    neighbors to exist in the graph, the AddNode operation represents an **O**(1)
    operation. Also note that the AddNode operation is exclusively implemented in
    the graph collection object.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加节点**：这个操作有时被称为**添加顶点**或**添加点**操作，并且取决于定义图的所用语言。添加节点操作只是将新节点插入到图中，而不定义任何边或对相邻节点的引用。由于一个节点不一定需要邻居才能存在于图中，因此添加节点操作代表一个**O**(1)操作。此外，请注意，添加节点操作仅由图集合对象实现。'
- en: '**RemoveNode**: This operation is sometimes called the **RemoveVertex** or
    RemovePoint operation, and it is dependent on the language used to define the
    graph. The RemoveNode operation deletes the node from the graph and removes any
    edges or references to and from neighboring nodes. This operation has an **O**(*n*
    + *k*) operational cost, where *n* is the number of nodes in our graph and *k*
    is the number of edges. The RemoveNode operation is exclusively implemented in
    the graph collection object.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**删除节点**：这个操作有时被称为**删除顶点**或**删除点**操作，并且取决于定义图的所用语言。删除节点操作从图中删除节点，并删除任何到和从相邻节点的边或引用。此操作的操作成本为**O**(*n*
    + *k*)，其中*n*是我们图中节点的数量，*k*是边的数量。删除节点操作仅由图集合对象实现。'
- en: Note
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This may seem expensive for a simple remove operation, but keep in mind that
    references in a graph can be bidirectional, meaning that our node could potentially
    have edges to every other node in the graph while every other node in the graph
    could simultaneously have edges pointing back to our node.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于简单的删除操作，这可能会显得有些昂贵，但请记住，图中的引用可以是双向的，这意味着我们的节点可能潜在地有指向图中每个其他节点的边，同时图中的每个其他节点也可能同时有指向我们的节点的边。
- en: This is primarily a concern with graphs designed to support edges that contain
    a value. In that case, each edge must be individually examined to determine if
    it points to the node being removed, and it must be handled accordingly if that
    is the case. In graphs where edges are merely pointers between objects, setting
    an object to `null` or `nil` will effectively eliminate any edges that point to
    it, potentially reducing this operation's cost to **O**(1).
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这主要是针对设计为支持包含值的边的图而言的。在这种情况下，必须逐个检查每条边，以确定它是否指向要删除的节点，如果确实如此，则必须相应地处理。在边仅仅是对象之间指针的图中，将对象设置为`null`或`nil`将有效地消除指向它的任何边，这可能会将此操作的成本降低到**O**(1)。
- en: '**AddEdge**: This operation is sometimes called the **AddArc** or **AddLine**
    operation, and it is dependent on the language used to define the node. The AddEdge
    operation simply adds a new edge from node `x` to node `y`. The AddEdge operation
    is implemented in both the collection object and the node object. At the node
    level, only the target node `y` must be passed as a parameter; while at the graph
    level, both `x` and `y` must be provided. If the graph supports edges with values,
    the new value must also be passed as a parameter, to the graph operation. Since
    graphs support bidirectional relationships between nodes, there is no need to
    first confirm that an edge already exists from node `y` to node `x`. This means
    adding a new edge between nodes is a simple process with an **O**(1) operational
    cost.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AddEdge**: 此操作有时被称为**AddArc**或**AddLine**操作，它依赖于定义节点的语言。AddEdge操作简单地从节点`x`到节点`y`添加一条新边。AddEdge操作在集合对象和节点对象中实现。在节点级别，只需传递目标节点`y`作为参数；而在图级别，则需要提供`x`和`y`。如果图支持具有值的边，则新值也必须作为参数传递给图操作。由于图支持节点之间的双向关系，因此无需首先确认从节点`y`到节点`x`是否存在边。这意味着在节点之间添加新边是一个简单的过程，具有**O**(1)的操作成本。'
- en: '**RemoveEdge**: This operation is sometimes called the **RemoveArc** or **RemoveLine**
    operation, and it is dependent on the language used to define the node. The RemoveEdge
    operation simply removes an existing edge from node `x` to node `y` if it exists.
    At the node level, only the target node `y` must be passed as a parameter, while
    at the graph level, both `x` and `y` must be provided. If the graph supports edges
    with values, the new value must also be passed as a parameter to the graph operation.
    Since graphs support bidirectional relationships between nodes, removing an edge
    from node `x` to node `y` as an operation is completely independent of existing
    edges from node `y` to node `x`; and this process, therefore, has an **O**(1)
    operational cost.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RemoveEdge**: 此操作有时被称为**RemoveArc**或**RemoveLine**操作，它依赖于定义节点的语言。RemoveEdge操作简单地从节点`x`到节点`y`删除现有边（如果存在）。在节点级别，只需传递目标节点`y`作为参数，而在图级别，则需要提供`x`和`y`。如果图支持具有值的边，则新值也必须作为参数传递给图操作。由于图支持节点之间的双向关系，从节点`x`到节点`y`删除边作为操作与从节点`y`到节点`x`的现有边完全独立；因此，这个过程具有**O**(1)的操作成本。'
- en: '**GetNodeValue**: The GetNodeValue operation is sometimes called the **GetVertexValue**
    or **GetPointValue** operation, and this is dependent on the language used to
    define the node. This operation returns the value associated with the node, whether
    it is a primitive or some custom object type, and the operation has an **O**(1)
    operational cost. This operation can be defined at either the graph or node level,
    but if it is defined as a part of the graph object, the node to be interrogated
    must be passed into the operation as a parameter.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetNodeValue**: GetNodeValue操作有时被称为**GetVertexValue**或**GetPointValue**操作，这取决于定义节点的语言。此操作返回与节点关联的值，无论是原始类型还是某种自定义对象类型，并且操作具有**O**(1)的操作成本。此操作可以在图或节点级别定义，但如果它作为图对象的一部分定义，则必须将需要查询的节点作为参数传递给操作。'
- en: '**SetNodeValue**: The SetNodeValue operation is sometimes called the **SetVertexValue**
    or **SetPointValue** operation, and it is dependent on the language used to define
    the node. This operation sets the value of the node and has an **O**(1) operational
    cost. Again, this operation can be defined at either the graph or node level but,
    if it is defined as a part of the graph object, the node to be set must be passed
    into the operation as a parameter.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetNodeValue**: SetNodeValue操作有时被称为**SetVertexValue**或**SetPointValue**操作，它依赖于定义节点的语言。此操作设置节点的值，并具有**O**(1)的操作成本。再次强调，此操作可以在图或节点级别定义，但如果它作为图对象的一部分定义，则必须将需要设置的节点作为参数传递给操作。'
- en: '**Adjacent**: The Adjacent operation checks whether an edge exists from node
    `x` to node `y`, and typically returns a Boolean value representing the result.
    This operation is typically defined at the graph level and requires both node
    `x` and node `y` to be provided. This simple operation has an **O**(1) operational
    cost.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Adjacent**: Adjacent操作检查是否存在从节点`x`到节点`y`的边，通常返回表示结果的布尔值。此操作通常在图级别定义，并需要提供节点`x`和`y`。这个简单的操作具有**O**(1)的操作成本。'
- en: '**Neighbors**: This operation functions similarly to the children operation
    in a tree data structure. The Neighbors operation returns a list containing all
    of the nodes `y` where there is an edge from node `x` to node `y`. This operation
    is typically defined at the graph level and requires node `x` be provided. This
    operation has an **O**(1) operational cost.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Neighbors**：这个操作在树数据结构中的子操作功能类似。`Neighbors`操作返回一个包含所有节点`y`的列表，其中从节点`x`到节点`y`存在边。这个操作通常在图级别定义，并需要提供节点`x`。这个操作具有**O**(1)的操作成本。'
- en: '**Count**: As with many other collections, graphs typically expose a count
    operation that returns the number of nodes contained in the collection. Although
    dependent on the implementation, this operation typically has an **O**(1) operational
    cost.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Count**：与其他许多集合一样，图通常公开一个计数操作，该操作返回集合中包含的节点数。尽管这取决于实现，但这个操作通常具有**O**(1)的操作成本。'
- en: '**GetEdgeValue**: This operation is sometimes called the GetArcValue or GetLineValue
    operation, and it is dependent on the language used to define the node. In graphs
    that support edges with values, this operation returns the value associated with
    the edge, whether it is a primitive or some custom object type, and the operation
    has an **O**(1) operational cost. This operation can also be defined as a part
    of the node object, in which case the edge to be interrogated must be passed into
    the operation as a parameter.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GetEdgeValue**：这个操作有时被称为GetArcValue或GetLineValue操作，这取决于定义节点的语言。在支持带值边的图中，这个操作返回与边关联的值，无论是原始类型还是某种自定义对象类型，并且操作具有**O**(1)的操作成本。这个操作也可以定义为节点对象的一部分，在这种情况下，必须将需要查询的边作为参数传递给操作。'
- en: '**SetEdgeValue**: This operation is sometimes called the **SetArcValue** or
    **SetLineValue** operation, and this is dependent on the language used to define
    the edge. This operation sets the value of the edge and has an **O**(1) operational
    cost. Again, this operation can be defined as a part of the node object, in which
    case the edge to be set must be passed into the operation as a parameter.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetEdgeValue**：这个操作有时被称为**SetArcValue**或**SetLineValue**操作，这取决于定义边的语言。这个操作设置边的值，并且具有**O**(1)的操作成本。再次强调，这个操作可以定义为节点对象的一部分，在这种情况下，要设置的边必须作为参数传递给操作。'
- en: Graph implementations
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图实现
- en: As with heaps, graphs are a form of tree data structure and, therefore, we will
    not find a native concrete implementation in the languages we are discussing.
    However, the graph data structure is surprisingly easy to implement, so we will
    build our own `Graph` class from scratch.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆一样，图是树数据结构的一种形式，因此在我们讨论的语言中，我们不会找到原生的具体实现。然而，图数据结构实现起来出奇地简单，因此我们将从头开始构建自己的`Graph`类。
- en: The graph data structure
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图数据结构
- en: Before we begin, we need to detail a few characteristics that our graph structure
    will possess. Our graph will support nodes that have no edges to or from other
    nodes. Our graph will also support exclusive and bidirectional edges. For the
    sake of brevity, the edges in our graph collection will not support edge values,
    but adding values to edges is a simple matter if you decide to use them in your
    custom implementations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要详细说明我们的图结构将具有的一些特性。我们的图将支持没有与其他节点相连的节点。我们的图还将支持单向和双向边。为了简洁起见，我们的图集合中的边将不支持边值，但如果您决定在自定义实现中使用它们，添加值到边是一个简单的问题。
- en: 'Our graph will be made up of two classes. The first is the `Graph` class itself,
    which in our implementation will contain most of the standard graph operations.
    The next is a `GraphNode` class, which will represent the nodes of our collection.
    Note that this class could also be named `GraphVertex` or `GraphPoint`, but in
    keeping with our tree `Node` class example from [Chapter 9](part0050_split_000.html#1FLS41-77f2b5b248f04368a6f723b0e9357ef3
    "Chapter 9. Trees: Non-Linear Structures"), *Trees: Non-linear Structures*, we
    will stick with nodes.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用两个类来构建我们的图。第一个是`Graph`类本身，在我们的实现中，它将包含大多数标准图操作。下一个是`GraphNode`类，它将代表我们的集合中的节点。请注意，这个类也可以命名为`GraphVertex`或`GraphPoint`，但为了与我们的第9章中的树`Node`类示例保持一致，即“非线性结构：树”，我们将坚持使用节点。
- en: The `Graph` class will be based on an array or list that contains the root references
    to the nodes. Each `GraphNode` object will also contain an array or list that
    holds the references to other nodes. In this implementation, these references
    represent the edges in our data structure. This class will support instantiation
    from scratch or by passing in an existing list of `GraphNode` objects. Operations
    for adding and removing both nodes and edges will be implemented in the `Graph`
    class. The `Graph` class will also contain operations for checking node adjacency,
    node neighbors, and the total count of nodes in the collection.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 类将基于一个包含节点根引用的数组或列表。每个 `GraphNode` 对象也将包含一个数组或列表，它持有对其他节点的引用。在这个实现中，这些引用代表我们的数据结构中的边。这个类将支持从头开始实例化或通过传递现有的
    `GraphNode` 对象列表进行实例化。在 `Graph` 类中实现添加和删除节点和边的操作。`Graph` 类还将包含检查节点相邻性、节点邻居和集合中节点总数操作的函数。'
- en: '**C#**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**C#**'
- en: 'C# does not provide a concrete `Graph` or `GraphNode` class out of the box,
    so we will need to create our own. We will start with the `GraphNode` class. Here
    is what a basic implementation of a `GraphNode` class might look like in C#:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: C# 并没有提供具体的 `Graph` 或 `GraphNode` 类，因此我们需要自己创建。我们将从 `GraphNode` 类开始。以下是一个基本的
    `GraphNode` 类实现示例，在 C# 中可能看起来是这样的：
- en: '[PRE0]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This class is very simple, containing a public field named `Value` to store
    our integer data and a `List<GraphNode>` object named `neighbors` that represents
    the edges between this node and its neighbors. The class also has two constructors
    both of which instantiate the `_neighbors` list. The overloaded `GraphNode(Int16
    value)` constructor also allows a value to be defined at instantiation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单，包含一个名为 `Value` 的公共字段来存储我们的整数数据，以及一个名为 `neighbors` 的 `List<GraphNode>`
    对象，它表示此节点与其邻居之间的边。该类还有两个构造函数，它们都实例化了 `_neighbors` 列表。重载的 `GraphNode(Int16 value)`
    构造函数还允许在实例化时定义一个值。
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `Graph` class might look like in C#:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现我们的图函数。以下是一个 `Graph` 类的具体实现示例，在 C# 中可能看起来是这样的：
- en: '[PRE1]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Our `Graph` class includes one public field, a `List<GraphNode>` collection
    named `Nodes` that exposes read-only access to the private `List<GraphNode> _nodes`
    field. This field maintains the list of edges to neighboring nodes. Finally, our
    constructor accepts one parameter of the type `List<Graphnode>` and sets `_nodes`
    to this value if it is not null; otherwise, it initializes the `_nodes` collection:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Graph` 类包括一个公共字段，一个名为 `Nodes` 的 `List<GraphNode>` 集合，它公开了私有 `List<GraphNode>
    _nodes` 字段的只读访问。该字段维护了到相邻节点的边列表。最后，我们的构造函数接受一个类型为 `List<Graphnode>` 的参数，如果它不为空，则将
    `_nodes` 设置为这个值；否则，初始化 `_nodes` 集合：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first two public methods in `Graph` are `AddNode(GraphNode node)` and `AddNodeForValue(Int16
    value)`, which add two versions of the AddNode functionality to our class. The
    first adds a pre-existing node to the `_nodes` collection, while the second instantiates
    a new node using `value`, then adds that node to the `_nodes` collection. Both
    of these methods add nodes without defining any edges and, therefore, these operations
    have an **O**(1) cost:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph` 中的前两个公共方法是 `AddNode(GraphNode node)` 和 `AddNodeForValue(Int16 value)`，它们为我们这个类添加了两种版本的
    `AddNode` 功能。第一个将一个预存在的节点添加到 `_nodes` 集合中，而第二个使用 `value` 实例化一个新的节点，然后将该节点添加到 `_nodes`
    集合中。这两个方法添加节点时不定义任何边，因此这些操作的成本为 **O**(1)：'
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `RemoveNode(Int16 value)` method provides the RemoveNode functionality to
    our class. This method accepts one parameter of type `Int16` and named `value`,
    representing the node that the caller is asking to remove. The method begins by
    using a **LINQ** statement to examine each of the nodes in the collection, searching
    for a match to `value`. If no match is found, the method returns `false`. Otherwise,
    the matching node is removed from the `_nodes` collection and the method execution
    continues.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveNode(Int16 value)` 方法为我们这个类提供了 `RemoveNode` 功能。此方法接受一个类型为 `Int16` 且命名为
    `value` 的参数，代表调用者请求删除的节点。该方法首先使用一个 **LINQ** 语句检查集合中的每个节点，寻找与 `value` 匹配的节点。如果没有找到匹配项，则方法返回
    `false`。否则，匹配的节点将从 `_nodes` 集合中移除，并且方法执行继续。'
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node's neighbors to find a match for `nodeToRemove`. A match found
    means an edge exists from the `node` object to the `nodeToRemove` object and returns
    an index value for that match. By removing the `nodeToRemove` object from the
    `node.Neighbors` collection using `index`, we eliminate the reference and delete
    the edge.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的后半部分遍历集合中的每个节点，检查每个节点的邻居以找到`nodeToRemove`的匹配项。找到匹配项意味着从`node`对象到`nodeToRemove`对象存在一条边，并返回该匹配项的索引值。通过使用`index`从`node.Neighbors`集合中删除`nodeToRemove`对象，我们消除了引用并删除了边。
- en: 'As we examined in the discussion on graph operations, the `RemoveNode` operation
    has an operational cost of **O**(*n* + *k*), where *n* is the number of nodes
    in the collection and *k* is the number of edges. In the `RemoveNode(Int16 value)`
    method, the first half represents *n* and the second half represents *k* in that
    equation:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在关于图操作的讨论中所考察的，`RemoveNode`操作的操作成本为**O**(*n* + *k*)，其中*n*是集合中节点的数量，*k*是边的数量。在`RemoveNode(Int16
    value)`方法中，方程的前半部分代表*n*，后半部分代表*k*：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `AddEdge(GraphNode from, GraphNode to)` and `AddBidirectedEdge(GraphNode
    from, GraphNode to)` methods provide the AddEdge functionality to the `Graph`
    class. The first method is the standard AddEdge operation, while the second method
    exists more as a convenience in case the caller wants to immediately add bidirectional
    references. The first method has an **O**(1) operational cost, while the second
    technically has a more unusual **O**(2) operational cost:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEdge(GraphNode from, GraphNode to)`和`AddBidirectedEdge(GraphNode from,
    GraphNode to)`方法为`Graph`类提供了AddEdge功能。第一个方法是标准的AddEdge操作，而第二个方法更多是作为一种便利存在，以防调用者希望立即添加双向引用。第一个方法具有**O**(1)的操作成本，而第二个实际上具有更不寻常的**O**(2)操作成本：'
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Adjacent(GraphNode from, GraphNode to)` method returns a Boolean value
    denoting whether an edge exists between two nodes, `from` and `to`. Hopefully
    the signature makes the direction of this edge clear but, for clarity, this method
    only confirms that an edge exists from the `from` node and to the `to` node, but
    not the reciprocal. Since this method is based on the `contains` function, it
    has an **O**(*n*) operational cost where *n* is the number of edges contained
    in `from.Neighbors`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adjacent(GraphNode from, GraphNode to)`方法返回一个布尔值，表示两个节点`from`和`to`之间是否存在边。希望签名使这条边的方向清晰，但为了清晰起见，此方法仅确认从`from`节点到`to`节点存在边，但不确认反向。由于此方法基于`contains`函数，它具有**O**(*n*)的操作成本，其中*n*是`from.Neighbors`中包含的边的数量：'
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `Neighbors(Int16 value)` method provides the Neighbors functionality to
    our class. This method accepts one parameter of type `Int16` and named `value`,
    representing the node the caller is asking to examine. The method begins by using
    a LINQ statement to examine each of the nodes in the collection searching for
    a match to `value`. If no match is found, the method returns `null`. Otherwise,
    the method returns the matching node''s `Neighbors` collection. If the `GraphNode`
    object was known in advance, this operation would have an **O**(1) operational
    cost. However, since we are examining the entire collection of `_nodes` at the
    `Graph` level based on the value of a specific node, this implementation has an
    **O**(*n*) operational cost:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Neighbors(Int16 value)`方法为我们类提供了邻居功能。此方法接受一个类型为`Int16`的参数，命名为`value`，代表调用者请求检查的节点。该方法首先使用LINQ语句检查集合中的每个节点，寻找与`value`匹配的节点。如果没有找到匹配项，则方法返回`null`。否则，该方法返回匹配节点的`Neighbors`集合。如果事先知道`GraphNode`对象，则此操作将具有**O**(1)的操作成本。然而，由于我们根据特定节点的值在`Graph`级别检查整个`_nodes`集合，因此此实现具有**O**(*n*)的操作成本：'
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Finally, the `Count` field is a read-only value that returns the total number
    of nodes contained in the collection by returning `_nodes.Count`. This field provides
    the Count functionality to our `Graph` class and has an **O**(1) operational cost.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`Count`字段是一个只读值，通过返回`_nodes.Count`来返回集合中包含的节点总数。该字段为我们`Graph`类提供了Count功能，并且具有**O**(1)的操作成本。
- en: '**Java**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java**'
- en: 'Like C#, Java does not provide a concrete `Graph` or `GraphNode` class out-of-the-box,
    so we will need to create our own. Again, we will start with the `GraphNode` class.
    Here is what a basic implementation of a `GraphNode` class will look like in Java:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 与C#一样，Java不提供具体的`Graph`或`GraphNode`类，因此我们需要自己创建。同样，我们将从`GraphNode`类开始。以下是一个基本的`GraphNode`类实现示例在Java中看起来像什么：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This class is very simple, containing a public field named `Value` to store
    our integer data and a private `LinkedList<GraphNode>` object named `_neighbors`
    that represents the edges between this node and its neighbors. There is also a
    public method called `GetNeighbors()` that exposes the private `_neighbors` list.
    The class also has two constructors, both of which instantiate the `_neighbors`
    list. The overloaded `GraphNode(Int16 value)` constructor also allows a value
    to be defined at instantiation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类非常简单，包含一个名为`Value`的公共字段来存储我们的整数数据，以及一个名为`_neighbors`的私有`LinkedList<GraphNode>`对象，它表示该节点与其邻居之间的边。还有一个名为`GetNeighbors()`的公共方法，它公开了私有`_neighbors`列表。该类还有两个构造函数，它们都实例化了`_neighbors`列表。重载的`GraphNode(Int16
    value)`构造函数还允许在实例化时定义一个值。
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `Graph` class will look like in Java:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现我们的图函数。以下是一个`Graph`类在Java中的具体实现示例：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Our `Graph` class includes one private field, a `List<GraphNode>` collection
    named `_nodes` and a method named `GetNodes()`, which exposes read-only access
    to the private `List<GraphNode> _nodes` field. This field maintains a list of
    edges between the current node and its neighboring nodes. Finally, our constructor
    accepts one parameter of the type `List<Graphnode>`, and sets `_nodes` to this
    value if it is not `null`; otherwise, it initializes the `_nodes` collection:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Graph`类包含一个私有字段，一个名为`_nodes`的`List<GraphNode>`集合和一个名为`GetNodes()`的方法，该方法提供了对私有`List<GraphNode>
    _nodes`字段的只读访问。该字段维护了当前节点与其相邻节点之间的边列表。最后，我们的构造函数接受一个类型为`List<Graphnode>`的参数，如果它不是`null`，则将`_nodes`设置为该值；否则，初始化`_nodes`集合：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The first two public methods in `Graph` are `AddNode(GraphNode node)` and `AddNodeForValue(int
    value)`, which add two versions of the AddNode functionality to our class. The
    first adds a pre-existing node to the `_nodes` collection, while the second instantiates
    a new node using `value` and then adds that node to the `_nodes` collection. Both
    of these methods add nodes without defining any edges, and therefore these operations
    have an **O**(1) cost:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Graph`中的前两个公共方法是`AddNode(GraphNode node)`和`AddNodeForValue(int value)`，它们为我们这个类添加了两种版本的AddNode功能。第一个将一个现有的节点添加到`_nodes`集合中，而第二个使用`value`实例化一个新的节点，然后将该节点添加到`_nodes`集合中。这两个方法添加节点时不定义任何边，因此这些操作的成本为**O**(1)：'
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `RemoveNode(int value)` method provides the `RemoveNode` functionality to
    our class. This method accepts one parameter of type `int` named `value`, representing
    the node the caller is asking to remove. The method begins by looping through
    each of the nodes, searching for a match for `value`. If no match is found, the
    method returns `false`. Otherwise, the matching node is removed from the `_nodes`
    collection using the `remove(E)` function and method execution continues.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveNode(int value)`方法为我们这个类提供了`RemoveNode`功能。该方法接受一个类型为`int`的参数`value`，表示调用者请求删除的节点。方法开始时遍历每个节点，搜索`value`的匹配项。如果没有找到匹配项，则方法返回`false`。否则，使用`remove(E)`函数和方法从`_nodes`集合中删除匹配的节点，并继续方法执行。'
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node's neighbors to find a match for `nodeToRemove`. A match found
    means an edge exists from `node` and `nodeToRemove` and returns an index value
    for that match. By removing `nodeToRemove` from that `node.Neighbors` using `index`,
    we eliminate the reference and delete the edge.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的后半部分遍历集合中的每个节点，检查每个节点的邻居以找到`nodeToRemove`的匹配项。找到匹配项意味着从`node`到`nodeToRemove`存在一条边，并返回该匹配项的索引值。通过使用`index`从`node.Neighbors`中删除`nodeToRemove`，我们消除了引用并删除了边。
- en: 'The operational cost in Java is the same as that in C#. The `RemoveNode` operation
    has a cost of **O**(*n* + *k*), where *n* is the number of nodes in the collection
    and *k* is the number of edges. In the `RemoveNode(int value)` method, the first
    half represents *n* and the second half represents *k* in that equation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中的操作成本与在C#中相同。`RemoveNode`操作的成本为**O**(*n* + *k*)，其中*n*是集合中节点的数量，*k*是边的数量。在`RemoveNode(int
    value)`方法中，方程中的前半部分代表*n*，后半部分代表*k*：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `AddEdge(GraphNode from, GraphNode to)` and `AddBidirectedEdge(GraphNode
    from, GraphNode to)` methods provide the `AddEdge` functionality to the `Graph`
    class. The first method is the standard AddEdge operation, while the second is
    more of a convenience method in case the caller wants to immediately add bidirectional
    references. The first method has an **O**(1) operational cost, while the second
    technically has a more unusual **O**(2) operational cost:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddEdge(GraphNode from, GraphNode to)` 和 `AddBidirectedEdge(GraphNode from,
    GraphNode to)` 方法为 `Graph` 类提供了 `AddEdge` 功能。第一个方法执行标准的 `AddEdge` 操作，而第二个方法则更像是方便调用者立即添加双向引用的便捷方法。第一个方法具有
    **O**(1) 的操作成本，而第二个方法在技术上具有更不寻常的 **O**(2) 操作成本：'
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `Adjacent(GraphNode from, GraphNode to)` method returns a Boolean value
    denoting whether an edge exists between two nodes, `from` and `to`. Hopefully,
    the signature makes the direction of this edge clear, but for clarity, this method
    only confirms that an edge exists from the `from` node and to the `to` node, but
    not the reciprocal. Since this method is based on the `contains` function, it
    has an **O**(*n*) operational cost, where *n* is the number of edges contained
    in `from.Neighbors`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adjacent(GraphNode from, GraphNode to)` 方法返回一个布尔值，表示两个节点 `from` 和 `to` 之间是否存在边。希望这个签名使这条边的方向清晰，但为了清晰起见，此方法仅确认从
    `from` 节点到 `to` 节点存在边，但不确认反向。由于此方法基于 `contains` 函数，它具有 **O**(*n*) 的操作成本，其中 *n*
    是 `from.Neighbors` 中包含的边的数量：'
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `Neighbors(int value)` method provides the Neighbors functionality to our
    class. This method accepts one parameter of type `int` and named `value`, representing
    the node the caller is asking to examine. The method begins by looping through
    the collection of nodes, searching for a match for `value`. If no match is found,
    the method returns `null`. Otherwise, the method returns the matching node''s
    `Neighbors` collection using `GetNeighbors()`. If the `GraphNode` object was known
    in advance, this operation will have an **O**(1) operational cost. However, since
    we are examining the entire collection of `_nodes` at the `Graph` level based
    on the value of a specific node, this implementation has an **O**(*n*) operational
    cost:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Neighbors(int value)` 方法为我们类提供 Neighbors 功能。此方法接受一个类型为 `int` 的参数，名为 `value`，表示调用者请求检查的节点。方法首先遍历节点集合，寻找
    `value` 的匹配项。如果没有找到匹配项，则方法返回 `null`。否则，方法使用 `GetNeighbors()` 返回匹配节点的 `Neighbors`
    集合。如果事先知道 `GraphNode` 对象，此操作将具有 **O**(1) 的操作成本。然而，由于我们根据特定节点的值在 `Graph` 层面上检查整个
    `_nodes` 集合，此实现具有 **O**(*n*) 的操作成本：'
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, the `GetCount()` method exposes read-only access to the total number
    of nodes contained in the collection by returning `_nodes.size()`. This field
    provides the Count functionality to our `Graph` class and has an **O**(1) operational
    cost.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`GetCount()` 方法通过返回 `_nodes.size()` 提供对集合中包含的总节点数的只读访问。此字段为我们 `Graph` 类提供
    Count 功能，并具有 **O**(1) 的操作成本。
- en: '**Objective-C**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Objective-C**'
- en: 'Objective-C does not provide a concrete `Graph` or `GraphNode` class, but it
    does provide the basic components necessary to build them. Here is what a basic
    implementation of a `EDSGraphNode` class will look like in Objective-C:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 不提供具体的 `Graph` 或 `GraphNode` 类，但它提供了构建它们所需的基本组件。以下是一个 `EDSGraphNode`
    类在 Objective-C 中的基本实现示例：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This class contains two ivar properties named `_value` and `_neighbors`. The
    `_value` property is an `NSInteger` object and stores our integer data, while
    `_neighbors` is an `NSMutableArray` object that represents the edges between this
    node and its neighbors. The class has two initializers, both of which instantiate
    the `_neighbors` list. The `initGraphNode:` method simply instantiates the `_neighbors`
    array, while the `initGraphNodeWithValue:` also sets `_value` to the passed value
    property.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此类包含两个 ivar 属性，名为 `_value` 和 `_neighbors`。`_value` 属性是一个 `NSInteger` 对象，用于存储我们的整数数据，而
    `_neighbors` 是一个 `NSMutableArray` 对象，表示此节点与其邻居之间的边。该类有两个初始化器，两者都实例化了 `_neighbors`
    列表。`initGraphNode:` 方法仅实例化 `_neighbors` 数组，而 `initGraphNodeWithValue:` 还将 `_value`
    设置为传递的值属性。
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `EDSGraph` class will look like in Objective-C:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现我们的图函数。以下是一个 `EDSGraph` 类在 Objective-C 中的具体实现示例：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Our `EDSGraph` class includes one ivar property, an `NSMutableArray<EDSGraphNode*>*`
    named `_nodes` that maintains the list of edges to neighboring nodes. There is
    also a method named `nodes` that exposes read-only access to the private `_nodes`
    property. Finally, our initializer `initGraphWithNodes:(NSMutableArray<EDSGraphNode
    *> *)nodes` accepts one array of `EDSGraphnode` and sets `_nodes` to this value
    if it is not `nil`. Otherwise, the initializer method initializes the `_nodes`
    collection:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`EDSGraph`类包括一个ivar属性，一个名为`_nodes`的`NSMutableArray<EDSGraphNode*>`，它维护了到相邻节点的边列表。还有一个名为`nodes`的方法，它提供了对私有`_nodes`属性的只读访问。最后，我们的初始化器`initGraphWithNodes:(NSMutableArray<EDSGraphNode
    *> *)nodes`接受一个`EDSGraphnode`数组，如果它不是`nil`，则将`_nodes`设置为该值。否则，初始化器方法初始化`_nodes`集合：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `countOfNodes` method exposes read-only access to the total number of nodes
    contained in the collection by returning `[_nodes count]`. This method provides
    the Count functionality to our `EDSGraph` class and has an **O**(1) operational
    cost:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`countOfNodes`方法通过返回`[_nodes count]`来提供对集合中包含的总节点数的只读访问。此方法为我们提供的`EDSGraph`类提供了计数功能，并且具有**O**(1)的操作成本：'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first two public methods in `EDSGraph` are `addNode:` and `addNodeForValue:`
    that add two versions of the `AddNode` functionality to our class. The first adds
    a pre-existing node to the `_nodes` collection, while the second instantiates
    a new node using `value` and then adds that node to the `_nodes` collection. Both
    of these methods add nodes without defining any edges, and therefore these operations
    have an **O**(1) cost:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`EDSGraph`中的前两个公共方法是`addNode:`和`addNodeForValue:`，它们为我们提供的类添加了两种版本的`AddNode`功能。第一个方法将现有的节点添加到`_nodes`集合中，而第二个方法使用`value`实例化一个新的节点，然后将该节点添加到`_nodes`集合中。这两个方法在添加节点时没有定义任何边，因此这些操作的成本为**O**(1)：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `removeNodeForValue:` method provides the RemoveNode functionality to our
    class. This method accepts one parameter of type `NSInteger` and named `value`,
    representing the node the caller is asking to remove. The method begins by looping
    through the collection of nodes searching for a match for `value`. If no match
    is found, the method returns `NO`. Otherwise, the matching node is removed from
    the `_nodes` collection using `removeObject:` and the method execution continues.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNodeForValue:`方法为我们提供的类提供了移除节点的功能。此方法接受一个类型为`NSInteger`的参数，命名为`value`，表示调用者请求移除的节点。方法首先遍历节点集合，寻找与`value`匹配的对象。如果没有找到匹配项，则方法返回`NO`。否则，使用`removeObject:`从`_nodes`集合中移除匹配的节点，并继续方法执行。'
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node's neighbors to find a match for `nodeToRemove`. A match found
    means an edge exists from `node` and `nodeToRemove` and returns an index value
    for that match. By removing `nodeToRemove` from that `node.Neighbors` using `index`,
    we eliminate the reference and delete the edge.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的后半部分遍历集合中的每个节点，检查每个节点的邻居以找到与`nodeToRemove`匹配的对象。找到匹配项意味着从`node`到`nodeToRemove`存在一条边，并返回该匹配项的索引值。通过使用`index`从`node.Neighbors`中移除`nodeToRemove`，我们消除了引用并删除了边。
- en: 'As we examined in the discussion on graph operations, the `RemoveNode` operation
    has an operational cost of **O**(*n* + *k*), where *n* is the number of nodes
    in the collection and *k* is the number of edges. In the `removeNodeForValue:`
    method, the first half represents *n* and the second half represents *k* in that
    equation:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在图操作讨论中所考察的，`RemoveNode`操作的操作成本为**O**(*n* + *k*)，其中*n*是集合中节点的数量，*k*是边的数量。在`removeNodeForValue:`方法中，方程的前半部分代表*n*，后半部分代表*k*：
- en: '[PRE21]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `addEdgeFromNode:toNode:` and `addBidirectionalEdgeFromNode:toNode:` methods
    provide the AddEdge functionality to the `Graph` class. The first method is the
    standard AddEdge operation, while the second is more of a convenience method in
    case the caller wants to immediately add bidirectional references. The first method
    has an **O**(1) operational cost, while the second has an **O**(2) operational
    cost:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEdgeFromNode:toNode:`和`addBidirectionalEdgeFromNode:toNode:`方法为`Graph`类提供了添加边的功能。第一个方法是标准的添加边操作，而第二个方法则更方便，如果调用者希望立即添加双向引用。第一个方法的操作成本为**O**(1)，而第二个方法的操作成本为**O**(2)：'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `adjacent:toNode:` method returns a `BOOL` value denoting whether an edge
    exists between two nodes, `from` and `to`. Hopefully, the signature makes the
    direction of this edge clear, but for clarity, this method only confirms that
    an edge exists from the `from` node and to the `to` node, but not the reciprocal.
    Since this method is based on the `containsObject:` function, it has an **O**(*n*)
    operational cost, where *n* is the number of edges contained in `from.neighbors`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjacent:toNode:` 方法返回一个 `BOOL` 值，表示两个节点 `from` 和 `to` 之间是否存在边。希望这个签名使这条边的方向变得清晰，但为了清晰起见，此方法仅确认从
    `from` 节点到 `to` 节点存在边，但不确认反向。由于此方法基于 `containsObject:` 函数，它具有 **O**(*n*) 的操作成本，其中
    *n* 是 `from.neighbors` 中包含的边的数量：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `neighborsOfValue:` method provides the Neighbors functionality to our class.
    This method accepts one parameter of type `NSInteger` and named `value`, representing
    the node the caller is asking to examine. The method begins by looping through
    the collection of nodes searching for a match for `value`. If no match is found,
    the method returns `nil`. Otherwise, the method returns the matching node's `neighbors`
    collection. If the `EDSGraphNode` object was known in advance, this operation
    would have an **O**(1) operational cost. However, since we are examining the entire
    collection of `_nodes` at the `EDSGraph` level based on the value of a specific
    node, this implementation has an **O**(*n*) operational cost.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighborsOfValue:` 方法为我们提供了类中的邻居功能。此方法接受一个类型为 `NSInteger` 并命名为 `value` 的参数，表示调用者请求检查的节点。该方法首先遍历节点集合以寻找
    `value` 的匹配项。如果没有找到匹配项，则方法返回 `nil`。否则，该方法返回匹配节点的 `neighbors` 集合。如果事先知道 `EDSGraphNode`
    对象，则此操作的成本为 **O**(1)。然而，由于我们根据特定节点的值在 `EDSGraph` 级别检查整个 `_nodes` 集合，因此此实现具有 **O**(*n*)
    的操作成本。'
- en: '**Swift**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift**'
- en: 'Like its counterparts, Swift does not provide a concrete `Graph` or `GraphNode`
    class by default, so we will need to create our own. We will start with the `GraphNode`
    class. Here is what a basic implementation of a `GraphNode` class might look like
    in Swift:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与其对应物一样，Swift 默认不提供具体的 `Graph` 或 `GraphNode` 类，因此我们需要创建自己的。我们将从 `GraphNode`
    类开始。以下是一个 `GraphNode` 类在 Swift 中的基本实现示例：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This class extends `Equatable`. This is necessary to support searching by value
    and by object. The class contains two public properties. The first is an array
    of `GraphNode` objects named `neighbors` that represents the edges between the
    node and its neighboring nodes. The second is an `Int` variable named `value`,
    and it is used to store our integer data for the object. The class has one custom
    constructor that accepts `Int` and assigns that value to the `value` variable.
    Finally, the class defines an overloaded comparison operator to support the `Equatable`
    functionality.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了 `Equatable`。这是为了支持按值和按对象进行搜索。该类包含两个公共属性。第一个是一个名为 `neighbors` 的 `GraphNode`
    对象数组，它表示节点与其相邻节点之间的边。第二个是一个名为 `value` 的 `Int` 变量，它用于存储对象的整数数据。该类有一个自定义构造函数，它接受
    `Int` 并将该值分配给 `value` 变量。最后，该类定义了一个重载的比较运算符以支持 `Equatable` 功能。
- en: 'Next, we can implement our graph functions. Here''s what a concrete implementation
    of a `Graph` class might look like in Swift:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以实现我们的图函数。以下是一个 `Graph` 类在 Swift 中的具体实现示例：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our `Graph` class includes one public `Array` property named `nodes`. This
    property maintains the list of edges to neighboring nodes. The class has one custom
    constructor that accepts one parameter of the type `Array<GraphNode>` and sets
    `_nodes` to this value if it is not `nil`. Since the `nodes` object is initialized
    when it is declared, there is no need to initialize it here:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `Graph` 类包含一个名为 `nodes` 的公共 `Array` 属性。该属性维护了到相邻节点的边列表。该类有一个自定义构造函数，它接受一个类型为
    `Array<GraphNode>` 的参数，并将 `_nodes` 设置为该值，如果它不是 `nil`。由于 `nodes` 对象在声明时就已经初始化，因此在这里不需要初始化它：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The first method in this class is `count()`, which exposes read-only access
    to the total number of nodes contained in the collection by returning `nodes.count`.
    This method provides the Count functionality to our `Graph` class and has an **O**(1)
    operational cost:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 该类中的第一个方法是 `count()`，它通过返回 `nodes.count` 提供对集合中包含的总节点数的只读访问。此方法为我们 `Graph` 类提供计数功能，并且具有
    **O**(1) 的操作成本：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next two public methods in `Graph`, `AddNode(node: GraphNode)` and `AddNodeForValue(value:
    Int)`, add two versions of the `AddNode` functionality to our class. The first
    adds a pre-existing node to the `nodes` collection, while the second instantiates
    a new node using `value` and then adds that node to the `nodes` collection. Both
    of these methods add nodes without defining any edges, and therefore these operations
    have an **O**(1) cost:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '在`Graph`中的下一个两个公共方法`AddNode(node: GraphNode)`和`AddNodeForValue(value: Int)`，为我们的类添加了两种版本的`AddNode`功能。第一个将预存在的节点添加到`nodes`集合中，而第二个使用`value`实例化一个新的节点，然后将该节点添加到`nodes`集合中。这两个方法在添加节点时没有定义任何边，因此这些操作的成本为**O**(1)：'
- en: '[PRE28]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `removeNodeForValue(value: Int)` method provides the `RemoveNode` functionality
    to our class. This method accepts one parameter of type `Int` and named `value`
    representing the node the caller is asking to remove. The method begins by looping
    through each of the nodes in the collection searching for a match to the `value`,
    object. If no match is found, the method returns `false`. Otherwise, the matching
    node is removed from the `nodes` collection and method execution continues.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeNodeForValue(value: Int)`方法为我们类提供了`RemoveNode`功能。此方法接受一个类型为`Int`的参数，命名为`value`，代表调用者请求删除的节点。方法首先遍历集合中的每个节点，寻找与`value`对象的匹配项。如果没有找到匹配项，则方法返回`false`。否则，匹配的节点将从`nodes`集合中移除，并且方法执行继续。'
- en: The second half of this method loops through each of the nodes in the collection,
    examining each node element's neighbors to find a match for `nodeToRemove`. A
    match found means an edge exists between the `node` and `nodeToRemove` objects
    and returns an index value for that match. By removing `nodeToRemove` from `node.neighbors`
    using `index`, we eliminate the reference and delete the edge.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法的后半部分遍历集合中的每个节点，检查每个节点元素的邻居以找到`nodeToRemove`的匹配项。找到匹配项意味着`node`和`nodeToRemove`对象之间存在边，并返回该匹配项的索引值。通过使用`index`从`node.neighbors`中移除`nodeToRemove`，我们消除了引用并删除了边。
- en: 'As we examined in the discussion on graph operations, the `RemoveNode` operation
    has an operational cost of **O**(*n* + *k*), where *n* is the number of nodes
    in the collection and *k* is the number of edges. In the `removeNodeForValue(value:
    Int)` method, the first half represents *n* and the second half represents *k*
    in that equation:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们在图操作讨论中所考察的，`RemoveNode`操作的操作成本为**O**(*n* + *k*)，其中*n*是集合中节点的数量，*k*是边的数量。在`removeNodeForValue(value:
    Int)`方法中，方程的前半部分代表*n*，后半部分代表*k*：'
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `addEdgeFromNodeToNode(from: GraphNode, to: GraphNode)` and `addBidirectedEdge(from:
    GraphNode, to: GraphNode)` methods provide the `AddEdge` functionality to the
    `Graph` class. The first method is the standard AddEdge operation, while the second
    is more of a convenience method in case the caller wants to immediately add bidirectional
    references. The first method has an **O**(1) operational cost, while the second
    technically has an **O**(2) operational cost:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`addEdgeFromNodeToNode(from: GraphNode, to: GraphNode)`和`addBidirectedEdge(from:
    GraphNode, to: GraphNode)`方法为`Graph`类提供了`AddEdge`功能。第一个方法是标准的AddEdge操作，而第二个方法更像是方便方法，以防调用者想要立即添加双向引用。第一个方法具有**O**(1)的操作成本，而第二个方法在技术上具有**O**(2)的操作成本：'
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `adjacent(from: GraphNode, to: GraphNode)` method returns a `Bool` value
    denoting whether an edge exists between two nodes, `from` and `to`. Hopefully,
    the signature makes the direction of this edge clear, but for clarity, this method
    only confirms that an edge exists from the `from` node and to the `to` node, but
    not the reciprocal. Since this method is based on the `contains` function, it
    has an **O**(*n*) operational cost, where *n* is the number of edges contained
    in `from.Neighbors`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`adjacent(from: GraphNode, to: GraphNode)`方法返回一个`Bool`值，表示两个节点`from`和`to`之间是否存在边。希望这个签名使这条边的方向清晰，但为了清晰起见，此方法仅确认从`from`节点到`to`节点的边存在，但不确认反向。由于此方法基于`contains`函数，它具有**O**(*n*)的操作成本，其中*n*是`from.Neighbors`中包含的边的数量：'
- en: '[PRE31]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `neighborsOfValue(value: Int)` provides the Neighbors functionality to
    our class. This method accepts one parameter of type `Int` and named `value` representing
    the node the caller is asking to examine. The method begins by looping through
    the collection of nodes searching for a match to `value`. If no match is found,
    the method returns `nil`. Otherwise, the method returns the matching node''s `neighbors`
    collection. If the `GraphNode` object was known in advance, this operation would
    have an **O**(1) operational cost. However, since we are examining the entire
    collection of `nodes` at the `Graph` level based on the value of a specific node,
    this implementation has an **O**(*n*) operational cost.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`neighborsOfValue(value: Int)` 为我们的类提供了邻居功能。此方法接受一个类型为 `Int` 的参数，命名为 `value`，代表调用者请求检查的节点。该方法首先通过遍历节点集合来寻找与
    `value` 匹配的节点。如果没有找到匹配项，则方法返回 `nil`。否则，该方法返回匹配节点的 `neighbors` 集合。如果事先知道 `GraphNode`
    对象，则此操作的成本为 **O**(1)。然而，由于我们根据特定节点的值在 `Graph` 层面上检查整个 `nodes` 集合，因此此实现具有 **O**(*n*)
    的操作成本。'
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about graph data structures. We used visual representations
    of graphs to gain a better understanding of how they are structured and how they
    can be used. Next, we examined the most common operations when working with graphs
    and discussed their typical complexity cost. Following this, we created our own
    simple graph node object and graph data structure class from scratch in each of
    the four languages we have examined in this book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了图数据结构。我们通过图形的视觉表示来更好地理解它们的结构和它们的使用方式。接下来，我们考察了与图操作最常见的情况，并讨论了它们的典型复杂度成本。随后，我们从头开始，在本书中考察的四种语言中，分别创建了自己的简单图节点对象和图数据结构类。
