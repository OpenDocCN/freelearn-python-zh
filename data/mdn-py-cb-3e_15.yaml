- en: '15'
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '15'
- en: Testing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 测试
- en: 'Testing is central to creating working software. Here’s the canonical statement
    describing the importance of testing:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 测试对于创建可工作的软件至关重要。以下是描述测试重要性的经典陈述：
- en: ”Any program feature without an automated test simply doesn’t exist”.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “任何没有自动化测试的程序功能实际上是不存在的”。
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '(Kent Beck, Extreme Programming Explained: Embrace Change)'
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: (Kent Beck，《极限编程解释：拥抱变化》)
- en: 'We can distinguish several kinds of testing:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以区分几种测试类型：
- en: 'Unit testing:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试：
- en: 'This applies to independent units of software: functions, classes, or modules.
    The unit is tested in isolation to confirm that it works correctly.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于独立的软件单元：函数、类或模块。单元在隔离状态下进行测试，以确认其正确性。
- en: Integration testing
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试
- en: ': This combines units to be sure they integrate properly.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: ': 这将组合单位以确保它们正确集成。'
- en: System testing
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试
- en: ': This tests an entire application or a system of interrelated applications
    to be sure that the suite of software components works properly. This is also
    called end-to-end testing or functional testing. This is often used for acceptance
    testing to confirm that software is fit for use.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: ': 这测试整个应用程序或一系列相互关联的应用程序，以确保软件组件套件正常工作。这也被称为端到端测试或功能测试。这通常用于验收测试，以确认软件适合使用。'
- en: Performance testing
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试
- en: ': This ensures that a unit, subsystem, or whole system meets performance objectives
    (also often known as load testing). In some cases, performance testing includes
    the study of resources such as memory, threads, or file descriptors. The goal
    is to be sure that software makes appropriate use of system resources. This is
    sometimes called benchmarking, when the goal is to measure resource usage instead
    of ensuring that the usage is below some threshold.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ': 这确保了单元、子系统或整个系统满足性能目标（也常称为负载测试）。在某些情况下，性能测试包括对资源（如内存、线程或文件描述符）的研究。目标是确保软件适当地使用系统资源。这有时被称为基准测试，当目标是衡量资源使用而不是确保使用低于某个阈值时。'
- en: These are some of the more common types. In this chapter, we’ll focus on unit
    testing since it is foundational to creating trust that software works reliably.
    Other forms of testing rest on the foundation of reasonably complete unit tests.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些更常见的类型。在本章中，我们将重点关注单元测试，因为它是创建对软件可靠工作的信任的基础。其他测试形式建立在合理完整的单元测试的基础上。
- en: 'It’s sometimes helpful to summarize a test scenario following the Gherkin language.
    In this test specification language, each scenario is described by GIVEN-WHEN-THEN
    steps. Here’s an example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有时根据 Gherkin 语言总结测试场景是有帮助的。在这种测试规范语言中，每个场景都由 GIVEN-WHEN-THEN 步骤描述。以下是一个示例：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This approach to writing tests describes the given starting state or arrangement,
    an action to perform, and one or more assertions about the resulting state after
    the action. This is sometimes called the ”arrange-act-assert” pattern.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编写测试的方法描述了给定的起始状态或安排，要执行的操作，以及关于操作后结果状态的一个或多个断言。这有时被称为“安排-执行-断言”模式。
- en: 'In this chapter, we’ll look at the following recipes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下食谱：
- en: '[Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 docstrings 进行测试](ch019_split_000.xhtml#x1-7950001)'
- en: '[Testing functions that raise exceptions](ch019_split_000.xhtml#x1-8040002)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试引发异常的函数](ch019_split_000.xhtml#x1-8040002)'
- en: '[Handling common doctest issues](ch019_split_000.xhtml#x1-8100003)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[处理常见的 doctest 问题](ch019_split_000.xhtml#x1-8100003)'
- en: '[Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 unittest 模块进行单元测试](ch019_split_000.xhtml#x1-8190004)'
- en: '[Combining unittest and doctest tests](ch019_split_000.xhtml#x1-8250005)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结合 unittest 和 doctest 测试](ch019_split_000.xhtml#x1-8250005)'
- en: '[Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用 pytest 模块进行单元测试](ch019_split_001.xhtml#x1-8310006)'
- en: '[Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[结合 pytest 和 doctest 测试](ch019_split_001.xhtml#x1-8370007)'
- en: '[Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试涉及日期或时间的事物](ch019_split_001.xhtml#x1-8430008)'
- en: '[Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试涉及随机性的事物](ch019_split_001.xhtml#x1-8490009)'
- en: '[Mocking external resources](ch019_split_001.xhtml#x1-85500010)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[模拟外部资源](ch019_split_001.xhtml#x1-85500010)'
- en: We’ll start by including tests within the docstring of a module, class, or function.
    This makes the test case act as both documentation of the design intent and a
    verifiable confirmation that it really does work as advertised.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从在模块、类或函数的 docstring 中包含测试开始。这使得测试案例既充当设计意图的文档，也充当可验证的确认，确实按广告宣传的方式工作。
- en: 15.1 Using docstrings for testing
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.1 使用文档字符串进行测试
- en: Good Python includes docstrings inside every module, class, function, and method.
    Many tools can create useful, informative documentation from docstrings. Refer
    back to the [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)
    recipe in Chapter [3](ch007_split_000.xhtml#x1-1610003) for an example of how
    to create docstrings.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 Python 代码在每个模块、类、函数和方法中都包含文档字符串。许多工具可以从文档字符串中创建有用、信息丰富的文档。请参考第 3 章（ch007_split_000.xhtml#x1-1610003）中关于如何创建文档字符串的示例菜谱
    [Writing clear documentation strings with RST markup](ch007_split_001.xhtml#x1-2030007)。
- en: One important element of a docstring is a concrete example. The examples provided
    in docstrings can become unit-test cases that are exercised by Python’s doctest
    tool.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 文档字符串的一个重要元素是具体的示例。文档字符串中提供的示例可以成为由 Python 的 doctest 工具执行的单元测试用例。
- en: In this recipe, we’ll look at ways to turn examples into proper automated test
    cases.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何将示例转换为合适的自动化测试用例。
- en: 15.1.1 Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.1 准备工作
- en: We’ll look at a small function definition as well as a class definition. Each
    of these will contain docstrings that include examples that can be used as automated
    tests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个小的函数定义以及一个类定义。每个都将包含包含可以用于自动化测试的示例的文档字符串。
- en: 'We’ll use a function to compute the binomial coefficient of two numbers. It
    shows the number of combinations of n things taken in groups of size k. For example,
    how many ways a 52-card deck can be dealt into 5-card hands is computed like this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个函数来计算两个数字的二项式系数。它显示了从大小为 k 的组中取 n 件事物的组合数。例如，如何计算一副 52 张牌被分成 5 张牌的手牌的方法如下：
- en: '![( ) n = ----n!--- k k!(n− k)! ](img/file80.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![公式](img/file80.png)'
- en: 'This can be implemented by a Python function that looks like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过一个类似这样的 Python 函数来实现：
- en: '[PRE1]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Functions, generally, have no internal state, making a function like this relatively
    easy to test. This will be one of the examples used for showing the unit testing
    tools available.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，函数没有内部状态，这使得像这样的函数相对容易测试。这将是用于展示可用的单元测试工具的示例之一。
- en: We’ll also look at a class that uses lazy calculation of the mean and median
    of a collection of numbers. Objects often have internal state, defined by the
    various self. attributes. State changes are often difficult. This is similar to
    the classes shown in Chapter [7](ch011_split_000.xhtml#x1-3760007). The [Designing
    classes with lots of processing](ch011_split_000.xhtml#x1-3890003) and [Using
    properties for lazy attributes](ch011_split_001.xhtml#x1-43100010) recipes both
    have classes similar to this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看一个使用一组数字的平均值和中位数进行懒计算的类。对象通常具有由各种 self. 属性定义的内部状态。状态变化通常是困难的。这与第 7 章（ch011_split_000.xhtml#x1-3760007）中展示的类类似。[Designing
    classes with lots of processing](ch011_split_000.xhtml#x1-3890003) 和 [Using properties
    for lazy attributes](ch011_split_001.xhtml#x1-43100010) 菜谱中都有类似的类。
- en: 'Here is an outline of the Summary class, with some implementation details omitted:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是 Summary 类的概述，省略了一些实现细节：
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The add() method changes the internal state of a Summary object. Because of
    this state change to the self.counts attribute, we’ll need to provide more sophisticated
    examples to show how an instance of the Summary class behaves.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: add() 方法改变了 Summary 对象的内部状态。由于这个状态变化到 self.counts 属性，我们需要提供更复杂的示例来展示 Summary
    类的实例是如何表现的。
- en: 15.1.2 How to do it...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.2 如何做...
- en: We’ll show two variations in this recipe. The first variation can be applied
    to functions like the binom() function where there is no object with a mutable
    state. The second is more appropriate for stateful operations, such as the Summary
    class. We’ll look at them together because they’re very similar, even though they
    apply to different kinds of applications.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将展示两种变体。第一种变体可以应用于 binom() 函数这样的函数，其中没有具有可变状态的对象。第二种更适合状态操作，如 Summary
    类。我们将一起查看它们，因为它们非常相似，尽管它们适用于不同类型的应用。
- en: Writing examples for functions
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为函数编写示例
- en: 'This recipe starts by creating the function’s docstring, and then adds an example
    of how the function works:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱首先创建函数的文档字符串，然后添加一个示例来说明函数的工作方式：
- en: 'Start the docstring with a summary:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档字符串中开始一个总结：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Include the parameter definitions and the return value definition:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含参数定义和返回值定义：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Mock up an example of using the function at Python’s >>> prompt:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Python 的 >>> 提示符下模拟使用该函数的示例：
- en: '[PRE5]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Close the docstring with the appropriate quotation marks:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的引号关闭文档字符串：
- en: '[PRE6]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Writing examples for stateful objects
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为状态对象编写示例
- en: 'This recipe also starts with writing a docstring. The docstring will show several
    steps using the stateful object to show the object’s internal state changes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方也是从编写文档字符串开始的。文档字符串将展示使用有状态对象来展示对象内部状态变化的几个步骤：
- en: 'Write a class-level docstring with a summary. It can help to leave some blank
    lines in front of the doctest example:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个类级别的文档字符串，并包含一个摘要。这有助于在doctest示例之前留下一些空白行：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Extend the class-level docstring with a concrete example of how the class works.
    In this case, we’ll show how the add() method sets the state of the object. We’ll
    also show how to interrogate the state of the object:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用类如何工作的具体示例扩展类级别的文档字符串。在这种情况下，我们将展示add()方法如何设置对象的状态。我们还将展示如何查询对象的状态：
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finish with the triple quotes to end the docstring for this class:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三引号结束这个类的文档字符串：
- en: '[PRE9]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Because this example uses floating-point values, we’ve rounded the result of
    the mean in the docstring example. Floating-point values might not have the exact
    same text representation on all platforms and an exact test for equality may fail
    unexpectedly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个例子使用了浮点值，所以我们已经在文档字符串示例中对平均值的结果进行了四舍五入。浮点值可能在所有平台上不具有相同的文本表示，并且精确的相等性测试可能会意外失败。
- en: Running the tests
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行测试
- en: When we run the doctest program, we’ll generally get a silent response because
    the test passed.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行doctest程序时，我们通常会得到一个静默的响应，因为测试通过了。
- en: 'The interaction looks like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 交互看起来像这样：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When the tests pass, there is no output. We can add a -v command-line option
    to see an enumeration of the tests run. This can be helpful to confirm that all
    of the tests in the module were found.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试通过时，没有输出。我们可以添加一个-v命令行选项来查看运行测试的枚举。这有助于确认模块中找到了所有测试。
- en: 'What happens when something doesn’t work? We’ll modify a test case to have
    a wrong answer and force a failure. When we run the doctest program – using a
    broken test case – we’ll see output like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当某件事不工作时会发生什么？我们将修改一个测试用例，使其有错误答案并强制失败。当我们运行doctest程序时——使用一个损坏的测试用例——我们会看到如下输出：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This shows where the error is. It shows an expected value from the test example,
    and the actual answer that failed to match the expected answer. Ordinarily – without
    the -v option – silence means all tests were passed successfully.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了错误所在的位置。它显示了测试示例中的预期值，以及未能匹配预期答案的实际答案。通常——没有使用-v选项——沉默意味着所有测试都成功通过。
- en: 15.1.3 How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.3 它是如何工作的...
- en: 'The doctest module includes a main program – as well as several functions –
    that scan a Python file for examples. The scanning operation looks for blocks
    of text that have a characteristic pattern of the Python REPL: a >>> prompt with
    code, followed by lines that show the response from the code, followed by a blank
    line to end the example output. Clearly, these must be formatted to precisely
    match the Python REPL output to be found.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: doctest模块包括一个主程序以及几个函数，这些函数会扫描Python文件中的示例。扫描操作会寻找具有Python REPL特征模式的文本块：一个带有代码的>>>提示符，随后是显示代码响应的行，然后是一个空白行来结束示例输出。显然，这些必须格式化得与找到的Python
    REPL输出完全匹配。
- en: 'The doctest parser creates a small test case object from the prompt line and
    the block of response text. There are three common cases:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: doctest解析器从提示行和响应文本块创建一个小测试用例对象。有三种常见情况：
- en: 'No expected response text: We saw this pattern when we defined the tests for
    the add() method of the Summary class.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有预期的响应文本：我们在定义Summary类的add()方法测试时看到了这种模式。
- en: 'A single line of response text: This was exemplified by the binom() function
    and the mean() method of the Summary class.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单行响应文本：这由Summary类的binom()函数和mean()方法所体现。
- en: 'Multiple lines of response: Responses are bounded by either the next >>> prompt
    or a blank line. This was exemplified by the str() example of the Summary class.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多行响应：响应由下一个>>>提示符或一个空白行界定。这由Summary类的str()示例所体现。
- en: Unless special annotations are used, the output text must precisely match the
    expectation text. In general, every space counts.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除非使用特殊注释，否则输出文本必须精确匹配预期文本。一般来说，每个空格都很重要。
- en: This testing protocol imposes some software design constraints. Functions and
    classes must be designed to work from the >>> prompt. Because it can become awkward
    to create very complex objects as part of a docstring example, class designs must
    be kept simple enough to be demonstrated at the interactive prompt. These constraints
    often have the benefit of keeping a design understandable.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这种测试协议对软件设计施加了一些限制。函数和类必须设计成可以从`>>>`提示符工作。因为将非常复杂的对象作为文档字符串示例的一部分可能会变得尴尬，所以类设计必须足够简单，以便在交互式提示符中演示。这些限制通常有助于保持设计可理解。
- en: The simplicity of the final comparison with the expected result can create some
    complications. In the example, we rounded the value of the mean to two decimal
    places. This is because the display of floating-point values may vary slightly
    from platform to platform.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 与预期结果的最终比较的简单性可能会造成一些复杂性。在示例中，我们将平均值四舍五入到两位小数。这是因为浮点数的显示可能会因平台而异。
- en: 15.1.4 There’s more...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.4 更多内容...
- en: One of the important considerations in test design is identifying edge cases.
    An edge case generally focuses on the limits for which a calculation is designed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 测试设计中一个重要的考虑因素是识别边缘情况。边缘情况通常关注计算设计的极限。
- en: 'There are, for example, two edge cases for the binomial function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，二项式函数有两个边缘情况：
- en: '![( ) ( ) n n 0 = n = 1 ](img/file81.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![（ ）（ ） n n 0 = n = 1](img/file81.png)'
- en: 'We can add these to the examples to be sure that our implementation is sound.
    This leads to a docstring that looks like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些添加到示例中，以确保我们的实现是可靠的。这将导致一个看起来像以下的文档字符串：
- en: '[PRE12]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: To keep the examples straight in the source code files, we’ve changed the name
    of this function to binom2\. This hack lets us keep both examples in a single
    Python module.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在源代码文件中保持示例的一致性，我们已经将此函数的名称更改为`binom2`。这个技巧让我们可以在单个Python模块中保持两个示例。
- en: In some cases, we might need to test values that are outside the valid range
    of values. These cases raise exceptions, which means they aren’t really ideal
    for putting into the docstring. The examples can clutter the explanation with
    details of things that should never normally happen. Fortunately, we have a place
    to put additional examples.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能需要测试超出有效值范围的值。这些情况会引发异常，这意味着它们实际上不适合放入文档字符串中。示例可能会用应该永远不会发生的事情的细节来杂乱无章地解释说明。幸运的是，我们有一个地方可以放置额外的示例。
- en: In addition to reading docstrings, the tool also looks for test cases in a global
    variable named __test__. This variable must refer to a mapping. The keys to the
    mapping will be test case names, and the values of the mapping must be doctest
    examples. Generally, each value will need to be a triple-quoted string.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了阅读文档字符串外，该工具还会在一个名为`__test__`的全局变量中查找测试用例。此变量必须引用一个映射。映射的键将是测试用例名称，映射的值必须是doctest示例。通常，每个值都需要是一个三引号字符串。
- en: Because the examples in the __test__ variable are not inside the docstrings,
    they don’t show up when using the built-in help() function. Nor do they show up
    when using other tools to create documentation from source code. This might be
    a place to put examples of failures or complex exceptions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`__test__`变量中的示例不在文档字符串中，所以在使用内置的`help()`函数时它们不会显示。同样，当使用其他工具从源代码创建文档时，它们也不会显示。这可能是一个放置失败示例或复杂异常示例的地方。
- en: 'We might add something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能添加如下内容：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can use this for tests that don’t need to be as visible as the docstring
    examples.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这来测试那些不需要像文档字符串示例那样可见的测试。
- en: 15.1.5 See also
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.1.5 参见
- en: In the [Testing functions that raise exceptions](ch019_split_000.xhtml#x1-8040002)
    and [Handling common doctest issues](ch019_split_000.xhtml#x1-8100003) recipes
    later in this chapter, we’ll look at two additional doctest techniques.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章后面的[测试引发异常的函数](ch019_split_000.xhtml#x1-8040002)和[处理常见的doctest问题](ch019_split_000.xhtml#x1-8100003)的食谱中，我们将探讨两种额外的doctest技术。
- en: For more background to the concept of stateless functions, see Chapter [3](ch007_split_000.xhtml#x1-1610003)
    and Chapter [9](ch013_split_000.xhtml#x1-5020009).
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于无状态函数概念的更多背景信息，请参阅第[3](ch007_split_000.xhtml#x1-1610003)章和第[9](ch013_split_000.xhtml#x1-5020009)章。
- en: 15.2 Testing functions that raise exceptions
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.2 测试引发异常的函数
- en: Python permits docstrings inside packages, modules, classes, functions, and
    methods. A good docstring should contain an example of how the feature is used.
    The example may need to include common exceptions, too. There’s one complicating
    factor, however, to including exceptions.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许在包、模块、类、函数和方法中包含文档字符串。一个好的文档字符串应该包含一个如何使用该功能的示例。示例可能还需要包括常见的异常。然而，包含异常有一个复杂因素。
- en: When an exception is raised, the traceback messages created by Python are not
    completely predictable. The message may include object ID values that are impossible
    to predict or module line numbers that may vary slightly depending on the context
    in which the test is executed. The general matching rules for doctest compare
    expected and actual results precisely. In this recipe, we’ll look at additional
    techniques to add flexibility.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当引发异常时，Python创建的跟踪消息并不完全可预测。消息可能包括无法预测的对象ID值或可能根据测试执行的上下文略有变化的模块行号。doctest的一般匹配规则精确地比较预期和实际结果。在本食谱中，我们将探讨额外的技术来增加灵活性。
- en: 15.2.1 Getting ready
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.1 准备工作
- en: We’ll look at a small function definition as well as a class definition. Each
    of these will contain docstrings that include examples that can be used as formal
    tests.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看一个小的函数定义以及一个类定义。每个都将包含包含可以用于正式测试的示例的文档字符串。
- en: We’ll use the function from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe, shown earlier in this chapter, that computes the binomial coefficient
    of two numbers. It shows the number of combinations of n things taken in groups
    of k. For example, it shows how many ways a 52-card deck can be dealt into 5-card
    hands.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用本章前面展示的[使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001)食谱中的函数，该函数计算两个数字的二项式系数。它显示了n个事物以k组取出的组合数。例如，它显示了52张牌的牌组如何被分成5张牌的手牌。
- en: This function does a simple calculation and returns a value; it lacks any internal
    state, making each request independent. We’d like to include some additional test
    cases in the __test__ variable to show what this does when given values outside
    the expected ranges.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数执行简单的计算并返回一个值；它没有内部状态，使得每个请求都是独立的。我们希望在`__test__`变量中包含一些额外的测试用例，以显示当给定预期范围之外的值时会发生什么。
- en: 15.2.2 How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.2 如何做...
- en: 'We start by running the binom function we defined previously. This output provides
    a handy template to show the expected output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先运行之前定义的binom函数。这个输出提供了一个方便的模板来显示预期的输出：
- en: Run the function manually at the interactive Python prompt to collect the actual
    exception details. Copy and paste these results.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在交互Python提示符下手动运行函数以收集实际的异常详情。复制并粘贴这些结果。
- en: 'Create a global __test__ variable at the end of the module. One approach is
    to build the mapping from all global variables with names that start with test_:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模块的末尾创建一个全局的`__test__`变量。一种方法是从所有以test_开头的全局变量中构建映射：
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Define each test case as a global variable with a block of text containing the
    doctest example. This can include additional notes about the scenario. These variables
    must be set before the final creation of the __test__ mapping.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个测试用例定义为全局变量，包含包含doctest示例的文本块。这可以包括关于场景的额外说明。这些变量必须在创建最终的`__test__`映射之前设置。
- en: Paste in the interactive session session output.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将交互会话的输出粘贴进来。
- en: 'It will start like this:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它将像这样开始：
- en: '[PRE15]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Replace the traceback details with .... Leave the initial line and the final
    exception in place. Add a directive to doctest, by putting # doctest: +ELLIPSIS
    after the line to be executed. It will look like this:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将跟踪回溯详情替换为......保留初始行和最终异常。在要执行的行后添加一个doctest指令，通过放置`# doctest: +ELLIPSIS`来实现。它看起来像这样：'
- en: '[PRE16]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can now use a command like this to test the entire module’s features:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用这样的命令来测试整个模块的功能：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Because each test is a separate global variable, we can easily add test scenarios.
    All of the names starting with test_ will become part of the final __test__ mapping
    that’s used by the doctest tool.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个测试都是一个单独的全局变量，我们可以轻松地添加测试场景。所有以test_开头的名称都将成为doctest工具使用的最终`__test__`映射的一部分。
- en: 15.2.3 How it works...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.3 它是如何工作的...
- en: Because eliding traceback details is so common, the doctest tool recognizes
    the ellipsis (...) in the context of a traceback. The ellipsis is also available
    in other contexts as one of many directives to modify the testing behavior. The
    directives are included as special comments with the line of code that performs
    the test action. They can also be provided as general instructions on the command
    line.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 由于省略跟踪信息非常常见，doctest工具识别跟踪信息上下文中的省略号(...)。省略号也在其他上下文中作为修改测试行为的许多指令之一可用。这些指令包含在执行测试操作的代码行的特殊注释中。它们也可以作为命令行上的通用指令提供。
- en: 'We have two additional ways to handle tests that include an exception:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种处理包含异常的测试的额外方法：
- en: 'We can use a # doctest: +IGNORE_EXCEPTION_DETAIL directive on the line of code
    that will raise the exception. This lets us provide a full traceback error message.
    The details of the traceback are ignored, and only the final exception line is
    matched against the expected value. This makes it possible to copy an actual error
    and paste it into the documentation.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以在将引发异常的代码行上使用#doctest: +IGNORE_EXCEPTION_DETAIL指令。这让我们可以提供一个完整的跟踪错误消息。跟踪信息的细节被忽略，并且只有最后的异常行与预期值匹配。这使得将实际错误复制并粘贴到文档中成为可能。'
- en: 'We can use a # doctest: +ELLIPSIS directive and replace parts of the traceback
    message with .... This directive is redundant for traceback messages.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们可以使用#doctest: +ELLIPSIS指令，并用...替换跟踪消息的部分。此指令对于跟踪消息是多余的。'
- en: The use of an explicit directive can help to make it clear what the intent is.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 显式指令的使用可以帮助清楚地表明意图。
- en: 15.2.4 There’s more...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.4 更多...
- en: 'There are two more directives that are often useful:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个其他指令通常很有用：
- en: '+NORMALIZE_WHITESPACE: Using this directive allows some flexibility in the
    whitespace for the expected value.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +NORMALIZE_WHITESPACE：使用此指令允许在预期值中对空白有一些灵活性。
- en: '+SKIP: The test is skipped.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: +SKIP：跳过测试。
- en: There are a few more directives, but they’re rarely needed.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个更多的指令，但它们很少需要。
- en: 15.2.5 See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.2.5 参见
- en: See the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001) recipe
    earlier in this chapter. This recipe shows the basics of doctest.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章前面，请参阅[使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001)的配方。这个配方展示了doctest的基本知识。
- en: See the [Handling common doctest issues](ch019_split_000.xhtml#x1-8100003) recipe
    next in this chapter. This shows other special cases that require doctest directives.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章中，接下来请参阅[处理常见的doctest问题](ch019_split_000.xhtml#x1-8100003)的配方。这展示了需要doctest指令的其他特殊案例。
- en: 15.3 Handling common doctest issues
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.3 处理常见的doctest问题
- en: A docstring that contains an example is part of good Python programming. The
    way the doctest tool uses literal matching of the expected text output against
    the actual text can make testing complicated for Python objects that do not have
    a consistent text representation.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 包含示例的文档字符串是良好Python编程的一部分。doctest工具通过将预期的文本输出与实际文本进行字面匹配的方式来使用，这可能会使得对于没有一致文本表示的Python对象进行测试变得复杂。
- en: 'For example, object hash values are randomized. This often results in the order
    of elements in a set collection being unpredictable. We have several choices for
    creating test case example output:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对象的哈希值是随机的。这通常会导致集合集合中元素顺序不可预测。我们有几种选择来创建测试用例示例输出：
- en: Write examples that can tolerate randomization. One technique is by sorting
    the elements of a set into a defined order.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写可以容忍随机化的示例。一种技术是将集合的元素排序到定义的顺序中。
- en: Stipulate a specific value for the PYTHONHASHSEED environment variable.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定PYTHONHASHSEED环境变量的特定值。
- en: 'There are several other considerations beyond simple variability in the location
    of keys or items in a set. Here are some other concerns:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的键或集合中项的位置变化之外，还有其他一些考虑因素。以下是一些其他关注点：
- en: The id() and repr() functions may expose an internal object ID. No guarantees
    can be made about these values.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: id()和repr()函数可能会暴露内部对象ID。无法对这些值做出保证。
- en: Floating-point values may vary across platforms.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浮点值可能在平台之间有所不同。
- en: The current date, time, and local timezone cannot meaningfully be used in a
    test case.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前日期、时间和本地时区在测试用例中无法有意义地使用。
- en: Random numbers using the default seed are difficult to predict.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用默认种子生成的随机数难以预测。
- en: OS resources may not exist, or may not be in the proper state.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OS资源可能不存在，或者可能不在适当的状态。
- en: It’s important to note that doctest examples require an exact match with the
    text. This means our test cases must avoid unpredictable results stemming from
    hash randomization or floating-point implementation details.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，doctest 示例需要与文本完全匹配。这意味着我们的测试用例必须避免由哈希随机化或浮点实现细节引起的不可预测的结果。
- en: 15.3.1 Getting ready
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.1 准备工作
- en: 'We’ll look at three separate versions of this recipe. The first will include
    a function where the output includes the contents of a set. Because the order
    of items in a set can vary, this isn’t as easy to test as we’d like. Here’s the
    function definition:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看这个配方的三个不同版本。第一个将包括一个输出包括集合内容的函数。由于集合中元素的顺序可能变化，这不像我们希望的那样容易测试。以下是函数定义：
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Testing the unique_letters() function is difficult because the order of items
    within a set is unpredictable.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 unique_letters() 函数很困难，因为集合内元素的顺序是不可预测的。
- en: 'The second example will be a class that doesn’t define a unique __repr__()
    definition. The default definition of the __repr__() method will expose an internal
    object ID. Since these vary, the test results will vary. Here’s the class definition:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例将是一个没有定义唯一 __repr__() 定义的类。__repr__() 方法的默认定义将暴露内部对象ID。由于这些ID是可变的，因此测试结果也会变化。以下是类定义：
- en: '[PRE19]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For the third example, we’ll look at a real-valued function so that we can
    work with floating-point values:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个示例，我们将查看一个实值函数，这样我们就可以处理浮点值：
- en: '![ϕ (n) = 1[1 + erf√n-] 2 2 ](img/file82.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![ϕ (n) = 1[1 + erf√n-] 2 2 ](img/file82.png)'
- en: This function is the cumulative probability density function for standard z-scores.
    See the [Creating a partial function](ch013_split_001.xhtml#x1-5560008) recipe
    in Chapter [9](ch013_split_000.xhtml#x1-5020009), for more information on the
    idea of normalized scores.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是标准z分数的累积概率密度函数。参见第[9](ch013_split_000.xhtml#x1-5020009)章中关于创建部分函数的[Creating
    a partial function](ch013_split_001.xhtml#x1-5560008)配方，了解更多关于标准化分数的概念。
- en: 'Here’s the Python implementation:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 Python 实现：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The phi() and frequency() functions involve some rather complicated numeric
    processing. The unit tests have to reflect the floating-point precision issues.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: phi() 和 frequency() 函数涉及一些相当复杂的数值处理。单元测试必须反映浮点精度问题。
- en: 15.3.2 How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.2 如何操作...
- en: We’ll look at set ordering and object representation in three mini-recipes.
    We’ll start with set ordering, then look at object IDs, and finally, floating-point
    values.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在三个小配方中查看集合排序和对象表示。我们首先查看集合排序，然后查看对象ID，最后查看浮点值。
- en: Writing doctest examples with unpredictable set ordering
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写具有不可预测集合排序的 doctest 示例
- en: 'Write a draft of the test that seems to capture the essence:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个似乎能够捕捉本质的测试草案：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This test will work when the hash values for these strings happen to fall into
    this specific order.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当这些字符串的哈希值恰好落入这个特定顺序时，这个测试将有效。
- en: One possible fix is to sort the results to impose an order.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一种可能的解决方案是对结果进行排序以强制执行顺序。
- en: 'Another alternative is to compare the output to a set object. The two choices
    look like this:'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个替代方案是将输出与集合对象进行比较。这两个选择看起来像这样：
- en: '[PRE22]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A third choice is to set the PYTHONHASHSEED environment variable to force known
    orderings. We’ll look at this alternative below.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选择是将 PYTHONHASHSEED 环境变量设置为强制已知顺序。我们将在下面查看这个替代方案。
- en: Writing doctest examples with object IDs
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写具有对象ID的 doctest 示例
- en: 'Ideally, our applications won’t display object IDs. These are essentially impossible
    to predict. Here’s what we can do:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们的应用程序不会显示对象ID。这些基本上是不可预测的。以下是我们可以做的事情：
- en: 'Define a happy path doctest scenario to show that the class performs its essential
    methods correctly. In this case, we’ll create a Point instance and use the text
    property to see a representation of the point:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个快乐的路径 doctest 场景，以显示类正确执行其基本方法。在这种情况下，我们将创建一个 Point 实例，并使用文本属性来查看点的表示：
- en: '[PRE23]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we define a test that displays the object’s representation string, the
    test will include results that include the unpredictable object ID. The doctest
    might look like the following:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们定义一个显示对象表示字符串的测试时，该测试将包括包含不可预测对象ID的结果。doctest可能看起来像以下这样：
- en: '[PRE24]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We need to change the test by using a # doctest: +ELLIPSIS directive. This
    means changing the >>> Point(36.8439, -76.2936) line in the test, and using an
    ellipsis on the exception displayed in the expected output to look like this:'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '我们需要通过使用 # doctest: +ELLIPSIS 指令来更改测试。这意味着更改测试中的 >>> Point(36.8439, -76.2936)
    行，并在预期输出中显示的异常上使用省略号，使其看起来像这样：'
- en: '[PRE25]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This kind of test suggest a design improvement. It’s often best to define __repr__().
    Another choice is to avoid tests where __repr__() may be used.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这类测试建议进行设计改进。通常最好定义 __repr__(). 另一个选择是避免使用 __repr__() 可能被使用的测试。
- en: Writing doctest examples for floating-point values
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为浮点值编写 doctest 示例
- en: 'We have two choices when working with float values. We can round the values
    to a certain number of decimal places. An alternative is to use the math.isclose()
    function. We’ll show both:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理浮点值时，我们有两种选择。我们可以将值四舍五入到一定的小数位数。另一种选择是使用 math.isclose() 函数。我们将展示两者：
- en: Import the necessary libraries and define the phi() and frequency() functions
    as shown previously.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入必要的库，并定义如前所述的 phi() 和 frequency() 函数。
- en: 'For each example, include an explicit use of round():'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个示例，包括一个显式的 round() 使用：
- en: '[PRE26]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'An alternative is to use the isclose() function from the math module:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个选择是使用 math 模块中的 isclose() 函数：
- en: '[PRE27]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Because float values can’t be compared exactly, it’s best to display values
    that have been rounded to an appropriate number of decimal places. It’s sometimes
    nicer for readers of examples to use round() because it may be slightly easier
    to visualize how the function works, compared to the isclose() alternative.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于浮点值无法精确比较，最好显示已四舍五入到适当小数位数的值。对于示例的读者来说，有时使用 round() 更为方便，因为它可能比 isclose()
    选项更容易可视化函数的工作方式。
- en: 15.3.3 How it works...
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.3 它是如何工作的...
- en: 'Because of hash randomization, the hash keys used for sets are unpredictable.
    This is an important security feature, used to defeat a subtle denial-of-service
    attack. For details, see url: [http://www.ocert.org/advisories/ocert-2011-003.html.](https://packt.link/dHrHU)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希随机化，集合使用的哈希键是不可预测的。这是一个重要的安全特性，用于抵御一种微妙的拒绝服务攻击。有关详细信息，请参阅url：[http://www.ocert.org/advisories/ocert-2011-003.html.](https://packt.link/dHrHU)
- en: Since Python 3.7, dictionary keys are guaranteed to be kept in insertion order.
    This means that an algorithm that builds a dictionary will provide a consistent
    sequence of key values. The same ordering guarantee is not made for sets. Interestingly,
    sets of integers tend to have a consistent ordering because of the way hash values
    are computed for numbers. Sets of other types of objects, however, will not show
    consistent ordering of items.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Python 3.7 开始，字典键的插入顺序得到了保证。这意味着构建字典的算法将提供一系列一致的键值序列。对于集合，并没有做出相同的顺序保证。有趣的是，由于整数哈希值的计算方式，整数集合往往具有一致的顺序。然而，其他类型对象的集合则不会显示一致的元素顺序。
- en: When confronted with unpredictable results like set ordering or internal object
    identification revealed by the __repr__() method, we have a testability issue.
    We can either change the software to be more testable, or we can change the test
    to tolerate some unpredictability.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当面对如集合顺序或由 __repr__() 方法揭示的内部对象标识等不可预测的结果时，我们遇到了一个可测试性问题。我们可以要么修改软件使其更具可测试性，要么修改测试以容忍一些不可预测性。
- en: Most floating-point implementations are reasonably consistent. However, there
    are few formal guarantees about the last few bits of any given floating-point
    number. Rather than trusting that all of the bits have exactly the right value,
    it’s often a good practice to round the value to a precision consistent with other
    values in the problem domain.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数浮点数实现都是相当一致的。然而，对于任何给定浮点数的最后几位，很少有正式的保证。与其相信所有位都恰好具有正确的值，不如通常将值四舍五入到与问题域中其他值一致的精度。
- en: Being tolerant of unpredictability can be taken too far, allowing the test to
    tolerate bugs. For more in-depth testing of mathematical functions, the [hypothesis](https://hypothesis.readthedocs.io/en/latest/)
    package provides ways to define a domain of robust test cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对不可预测性的容忍可能过度，允许测试容忍错误。对于数学函数的更深入测试，[hypothesis](https://hypothesis.readthedocs.io/en/latest/)
    包提供了定义稳健测试案例域的方法。
- en: 15.3.4 There’s more...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.4 更多...
- en: 'We can run the tests with the PYTHONHASHSEED environment variable set. In Linux
    (and macOS X) we can do this in a single command-line statement:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过设置 PYTHONHASHSEED 环境变量来运行测试。在 Linux（以及 macOS X）中，我们可以在单个命令行语句中完成此操作：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will provide a fixed, reproducible hash randomization while running doctest.
    We can also use PYTHONHASHSEED=0 to disable hash randomization.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在运行 doctest 时提供固定的、可重复的哈希随机化。我们还可以使用 PYTHONHASHSEED=0 来禁用哈希随机化。
- en: The tox tool has a --hashseed=x option to allow setting a consistent hash seed
    to an integer value prior to running tests.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: tox 工具有一个 --hashseed=x 选项，允许在运行测试之前将一致的哈希种子设置为整数值。
- en: 15.3.5 See also
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.3.5 参见
- en: The [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    recipe, in particular, the now() method of datetime requires some care.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特别是 [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    的配方，datetime 的 now() 方法需要一些注意。
- en: The [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)
    recipe shows how to test processing that involves using the random module.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[测试涉及随机性的事物](ch019_split_001.xhtml#x1-8490009) 的配方展示了如何测试涉及使用 random 模块的处理。'
- en: We’ll look at how to work with external resources in the [Mocking external resources](ch019_split_001.xhtml#x1-85500010)
    recipe later in this chapter.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将在本章后面的 [Mocking external resources](ch019_split_001.xhtml#x1-85500010) 配方中查看如何处理外部资源。
- en: 15.4 Unit testing with the unittest module
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.4 使用 unittest 模块进行单元测试
- en: The unittest module allows us to step beyond the examples used by doctest. Each
    test case can have one more scenario built as a subclass of the TestCase class.
    These use result checks that are more sophisticated than the literal text matching
    used by the doctest tool.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: unittest 模块允许我们超越 doctest 使用的示例。每个测试用例可以有一个额外的场景，作为 TestCase 类的子类构建。这些使用比 doctest
    工具使用的文本匹配更复杂的检查结果。
- en: The unittest module also allows us to package tests outside docstrings. This
    can be helpful for tests for edge cases that might be too detailed to be helpful
    documentation. Often, doctest cases focus on the happy path – the most common
    use cases, where everything works as expected. We can use the unittest module
    to more easily define test cases that diverge from the happy path.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: unittest 模块还允许我们将测试打包在 docstrings 之外。这对于测试边缘情况可能很有帮助，这些边缘情况可能过于详细，无法作为有用的文档。通常，doctest
    案例集中在幸福路径上——即最常见的使用案例，其中一切按预期工作。我们可以使用 unittest 模块更容易地定义偏离幸福路径的测试用例。
- en: This recipe will show how we can use the unittest module to create more sophisticated
    tests.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示我们如何使用 unittest 模块创建更复杂的测试。
- en: 15.4.1 Getting ready
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.1 准备工作
- en: 'It’s sometimes helpful to summarize a test following ideas behind the Gherkin
    language. In this test specification language, each scenario is described by GIVEN-WHEN-THEN
    steps. For this case, we have a scenario like this:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，根据 Gherkin 语言的思路总结测试是有帮助的。在这种测试规范语言中，每个场景都由给定-当-然后步骤来描述。对于这种情况，我们有一个类似这样的场景：
- en: '[PRE29]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The TestCase class doesn’t precisely follow this three-part given-when-then
    (or arrange-act-assert) structure. A TestCase class generally has two parts:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: TestCase 类并不严格遵循这个三部分给定-当-然后（或安排-行动-断言）结构。TestCase 类通常有两个部分：
- en: A setUp() method must implement the Given steps of the test case.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: setUp() 方法必须实现测试用例的给定步骤。
- en: A runTest() method must handle the Then steps to confirm the results using a
    number of assertion methods to confirm the actual results match the expected results.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: runTest() 方法必须处理然后步骤，使用多种断言方法来确认实际结果与预期结果相匹配。
- en: The When steps can be in either method. The choice of where to implement the
    When steps is often tied to the question of reuse. For example, a class or function
    may have a number of methods to take different actions or make a number of state
    changes. In this case, it makes sense to pair each When step with distinct Then
    steps to confirm correct operation. The runTest() method can implement both When
    and Then steps. A number of subclasses can share the common setUp() method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当步骤可以在两种方法中任选其一。何时实现当步骤的选择通常与重用问题相关。例如，一个类或函数可能有多个方法来执行不同的操作或进行多个状态变化。在这种情况下，将每个当步骤与不同的然后步骤配对以确认正确操作是有意义的。runTest()
    方法可以实现当和然后步骤。多个子类可以共享共同的 setUp() 方法。
- en: As another example, a class hierarchy may offer a number of alternative implementations
    for the same algorithm. In this case, the Then step confirmation of correct behavior
    is in the runTest() method. Each alternative implementation has a distinct subclass
    with a unique setup() method for the Given and When steps.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 作为另一个例子，一个类层次结构可能为相同的算法提供多种不同的实现。在这种情况下，正确行为的然后步骤确认在 runTest() 方法中。每种不同的实现都有一个独特的子类，具有为给定和当步骤的独特
    setup() 方法。
- en: An optional tearDown() method is available for those tests that need to perform
    some cleanup of left-over resources. This is outside the test’s essential scenario
    specification.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 对于需要执行一些清理剩余资源的测试，有一个可选的 tearDown() 方法。这超出了测试的基本场景规范。
- en: We’ll create some tests for a class that is designed to compute some basic descriptive
    statistics. The unittest test cases let us define sample data that’s larger than
    anything we’d ever choose to enter as doctest examples. We can easily use thousands
    of data points rather than two or three as part of evaluating performance.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为一个设计用来计算一些基本描述性统计的类创建一些测试。unittest测试用例让我们能够定义比我们选择作为doctest示例的任何内容都要大的样本数据。我们可以轻松地使用数千个数据点，而不是作为评估性能的一部分的两个或三个。
- en: The bulk of the code that we’re going to test was shown in the [Using docstrings
    for testing](ch019_split_000.xhtml#x1-7950001) recipe earlier in this chapter.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要测试的大多数代码在本书前面的[使用docstrings进行测试](ch019_split_000.xhtml#x1-7950001)配方中已经展示过。
- en: Because we’re not looking at the implementation details, we can think of this
    as opaque-box testing; the implementation details are not known to the tester.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们没有查看实现细节，我们可以将其视为不透明盒测试；实现细节对测试者来说是未知的。
- en: We’d like to be sure that when we use thousands of samples, the class performs
    correctly. We’d also like to ensure that it works quickly; we’ll use this as part
    of an overall performance test, as well as a unit test.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望确保当我们使用数千个样本时，该类能正确执行。我们还希望确保它运行得快；我们将将其作为整体性能测试的一部分，以及单元测试的一部分。
- en: 15.4.2 How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.2 如何做...
- en: 'We’ll need to create a separate module and a subclass of TestCase in that module.
    Tools like pytest can discover test modules if their names begin with test_, giving
    us a naming convention for these additional modules. Here’s how we can creates
    tests separate from the module’s code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个单独的模块和该模块中的一个TestCase子类。像pytest这样的工具可以检测以test_开头的测试模块，为我们这些额外的模块提供了一个命名约定。以下是如何创建与模块代码分离的测试的示例：
- en: Create a file with a name related to the module under test. If the module was
    named summary.py, then a good name for a test module would be test_summary.py.
    Using the test_ prefix makes it easier for tools like pytest to find the test.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与待测试模块相关的文件。如果模块名为summary.py，那么一个合适的测试模块名称将是test_summary.py。使用test_前缀可以使像pytest这样的工具更容易找到测试。
- en: 'We’ll use the unittest module for creating test classes. We’ll also be using
    the random module to scramble the input data. We’ll also import the module under
    test:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用unittest模块来创建测试类。我们还将使用random模块来打乱输入数据。我们还将导入待测试的模块：
- en: '[PRE30]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Create a subclass of TestCase. Provide this class with a name that shows the
    intent of the test. We’ve chosen a name with a summary of the three steps:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个TestCase的子类。为这个类提供一个名称，以显示测试的意图。我们选择了一个包含三个步骤总结的名称：
- en: '[PRE31]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Define a setUp() method in this class that handles the Given step of the test.
    We’ve created a collection of 1,001 samples shuffled into a random order:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中定义一个setUp()方法来处理测试的Given步骤。我们创建了一个包含1,001个样本的集合，这些样本被随机排序：
- en: '[PRE32]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Define a runTest() method that handles the When step of the test:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个runTest()方法来处理测试的When步骤：
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add assertions to the runTest() method to implement the Then steps of the test:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在runTest()方法中添加断言以实现测试的Then步骤：
- en: '[PRE34]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If our test module is called recipe_04.py, we can use the following command
    to find TestCase classes in the recipe_04 module and run them:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的测试模块名为recipe_04.py，我们可以使用以下命令在recipe_04模块中查找TestCase类并运行它们：
- en: '[PRE35]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If all of the assertions pass, then the test suite will pass and the test run
    will be successful overall.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的断言都通过，那么测试套件将通过，整个测试运行将成功。
- en: 15.4.3 How it works...
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.3 它是如何工作的...
- en: The TestCase class is used to define one test case. The class can have a setUp()
    method to create the unit and possibly the request. The class must have at least
    a runTest() method to make a request of the unit and check the response.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: TestCase类用于定义一个测试用例。该类可以有一个setUp()方法来创建单元和可能请求。该类必须至少有一个runTest()方法来对单元提出请求并检查响应。
- en: 'A single test often isn’t sufficient. If we created three separate test classes
    in the recipe_04.py module, then we would see output that looks like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 单个测试通常是不够的。如果我们创建了三个独立的测试类在recipe_04.py模块中，那么我们会看到如下输出：
- en: '[PRE36]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As each test is passed, a . is displayed. This shows that the test suite is
    making progress. The summary shows the number of tests run and the time. If there
    are failures or exceptions, the counts shown at the end will reflect these.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个测试的通过，会显示一个.。这表明测试套件正在取得进展。总结显示了运行的测试数量和时间。如果有失败或异常，最后的计数将反映这些情况。
- en: Finally, there’s a summary line. In this case, it consists of OK, showing that
    all the tests passed.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，有一行总结。在这种情况下，它由OK组成，表明所有测试都通过了。
- en: 'If we include a test that fails, we’ll see the following output when we use
    the -v option to get verbose output:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们包含一个失败的测试，当我们使用-v选项来获取详细输出时，我们会看到以下输出：
- en: '[PRE37]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There’s a final summary of FAILED. This includes (failures=1) to show how many
    tests failed.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个最终的总结是FAILED。这包括(failures=1)来显示有多少测试失败了。
- en: 15.4.4 There’s more...
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.4 更多内容...
- en: In these examples, we have two assertions for the two Then steps inside the
    runTest() method. If one fails, the test stops as a failure, and the other step
    is not exercised.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们在runTest()方法内部有两个Then步骤的断言。如果一个失败了，测试将作为一个失败停止，其他步骤将不会被执行。
- en: This is a weakness in the design of this test. If the first assertion fails,
    we may not get all of the diagnostic information we might want. We should avoid
    having a sequence of otherwise independent assertions in the runTest() method.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在这个测试设计中的一个弱点。如果第一个断言失败，我们可能得不到我们可能想要的全部诊断信息。我们应该避免在runTest()方法中有多个其他独立的断言序列。
- en: 'When we want more diagnostic details, we have two general choices:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要更多的诊断细节时，我们有两种一般的选择：
- en: Use multiple test methods instead of a single runTest(). We can create multiple
    methods with names that start with test_. The default implementation of the test
    loader will execute the setUp() method prior to each separate test_ method when
    there is no overall runTest() method. This is often the simplest way to group
    a number of related tests together.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个测试方法而不是单个runTest()。我们可以创建多个以test_开头命名的多个方法。默认的测试加载器实现将在没有整体runTest()方法的情况下，在执行每个单独的test_方法之前执行setUp()方法。这通常是将多个相关测试组合在一起的最简单方法。
- en: Use multiple subclasses of the TestCase subclass, each with a separate Then
    step implementation. When the setUp() is inherited, this will be shared by each
    subclass.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TestCase子类的多个子类，每个子类都有一个单独的Then步骤实现。当setUp()被继承时，这将由每个子类共享。
- en: 'Following the first alternative, the test class would look like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 按照第一个选择，测试类将看起来像这样：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We’ve refactored the setUp() method to include the Given and When steps of the
    test. The two independent Then steps are refactored into their own separate test_mean()
    and test_median() methods. These two methods are used instead of the runTest()
    method.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经重构了setUp()方法，包括测试的Given和When步骤。两个独立的Then步骤被重构为它们自己的单独的test_mean()和test_median()方法。这两个方法代替了runTest()方法。
- en: Since each test is run separately, we’ll see separate error reports for problems
    with computing the mean or with computing the median.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个测试都是单独运行的，所以对于计算平均值或中值的问题，我们会看到单独的错误报告。
- en: The TestCase class defines numerous assertions that can be used as part of the
    Then steps. We encourage careful study of the unittest section of the Python Standard
    Library documentation to see all of the variations available.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: TestCase类定义了众多断言，可以用作Then步骤的一部分。我们鼓励仔细研究Python标准库文档中的unittest部分，以查看所有可用的变体。
- en: In all but the smallest projects, it’s common practice to sequester the test
    files into a separate directory, often called tests. When this is done, we can
    rely on the discovery application that’s part of the unittest framework.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有但最小的项目中，将测试文件隔离到单独的目录中是一种常见的做法，通常称为tests。当这样做时，我们可以依赖unittest框架中的发现应用程序。
- en: The unittest loader can search each module in a given directory for all classes
    that are derived from the TestCase class. This collection of classes within the
    larger collection of modules becomes the complete TestSuite.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: unittest加载器可以在给定的目录中搜索所有从TestCase类派生的类。这个类集合在更大的模块集合中成为完整的TestSuite。
- en: 'We can do this with the discover command of the unittest package:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用unittest包的discover命令来完成这个操作：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This will locate all test cases in all test modules in the tests directory of
    a project.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定位项目tests目录中所有测试模块中的所有测试用例。
- en: 15.4.5 See also
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.4.5 参见
- en: We’ll combine unittest and doctest in the [Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)
    recipe next in this chapter. We’ll look at mocking external objects in the [Mocking
    external resources](ch019_split_001.xhtml#x1-85500010) recipe later in this chapter.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本章的[Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007)配方中，我们将结合unittest和doctest。在本章后面的[Mocking
    external resources](ch019_split_001.xhtml#x1-85500010)配方中，我们将查看模拟外部对象。
- en: The [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe later in this chapter covers the same test case from the perspective of
    the pytest tool.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章后面的[使用pytest模块进行单元测试](ch019_split_001.xhtml#x1-8310006)示例从pytest工具的角度覆盖了相同的测试用例。
- en: 15.5 Combining unittest and doctest tests
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.5 结合unittest和doctest测试
- en: In some cases, we’ll want to combine tests written for the unittest and doctest
    tools. For examples of using the doctest tool, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in this chapter. For examples of using the unittest tool, see the
    [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004) recipe
    earlier in this chapter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能希望将针对unittest和doctest工具编写的测试组合在一起。关于使用doctest工具的示例，请参阅本章前面的[使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001)示例。关于使用unittest工具的示例，请参阅本章前面的[使用unittest模块进行单元测试](ch019_split_000.xhtml#x1-8190004)示例。
- en: The doctest examples are an essential element of the documentation strings on
    modules, classes, methods, and functions. The unittest cases will often be in
    a separate tests directory in files with names that match the pattern test_*.py.
    An important part of creating trustworthy software is running as wide a variety
    of tests as possible.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: doctest示例是模块、类、方法和函数文档字符串的一个基本元素。unittest用例通常位于一个单独的tests目录中，文件名符合test_*.py的模式。创建可信赖的软件的一个重要部分是运行尽可能广泛的测试。
- en: In this recipe, we’ll look at ways to combine a variety of tests into one tidy
    package.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨将各种测试组合成一个整洁包的方法。
- en: 15.5.1 Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.1 准备工作
- en: We’ll refer back to the example from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe, shown earlier in this chapter. This recipe created tests for a class,
    Summary, that does some statistical calculations. In that recipe, we included
    examples in the docstrings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾本章前面提到的[使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001)示例。这个示例为名为Summary的类创建了一些统计计算测试。在那个示例中，我们在文档字符串中包含了示例。
- en: In the [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe earlier in this chapter, we wrote some TestCase classes to provide additional
    tests for this class.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的[使用unittest模块进行单元测试](ch019_split_000.xhtml#x1-8190004)示例中，我们编写了一些TestCase类，为这个类提供了额外的测试。
- en: 'As context, we’ll assume there’s a project folder structure that looks like
    the following directory tree:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 作为上下文，我们假设有一个项目文件夹结构，如下所示：
- en: '[PRE40]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This means tests are in both the src/summary.py module and in the tests/test_summary.py
    file.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着测试既在src/summary.py模块中，也在tests/test_summary.py文件中。
- en: We need to combine all of the tests into a single, comprehensive test suite.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将所有测试组合成一个单一、全面的测试套件。
- en: The recipe examples use recipe_01.py instead of some cooler name such as summary.py.
    Ideally, a module should have a memorable, meaningful name. The book content is
    quite large, and the names are designed to match the overall chapter and recipe
    outline.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中使用的模块名为recipe_01.py，而不是像summary.py这样的更酷的名字。理想情况下，一个模块应该有一个易于记忆且意义明确的名称。本书内容相当庞大，名称是为了与整体章节和示例大纲相匹配。
- en: 15.5.2 How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.2 如何做...
- en: 'To combine unittest and doctest test cases, we’ll start with an existing test
    module, and add a load_tests() function to merge the relevant doctest with the
    existing unittest test cases. A function named load_tests() must be provided.
    This name is required so the unittest loader will use it:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要结合unittest和doctest测试用例，我们将从一个现有的测试模块开始，并添加一个load_tests()函数来合并相关的doctest与现有的unittest测试用例。必须提供一个名为load_tests()的函数。这个名称是必需的，以便unittest加载器可以使用它：
- en: 'To use doctest tests, import the doctest module. To write TestCase classes,
    import the unittest module. We’ll also need the random module so we can control
    the random seeds in use:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用doctest测试，导入doctest模块。要编写TestCase类，导入unittest模块。我们还需要导入random模块，以便我们可以控制使用的随机种子：
- en: '[PRE41]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Import the modules containing doctest examples:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入包含doctest示例的模块：
- en: '[PRE42]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'To implement the load_tests protocol, define a load_tests() function in the
    test module. We’ll combine the standard tests automatically discovered by unittest
    with the additional tests found by the doctest module:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要实现load_tests协议，在测试模块中定义一个load_tests()函数。我们将自动由unittest发现的常规测试与doctest模块找到的附加测试相结合：
- en: '[PRE43]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The loader argument value to the load_tests() function is the test case loader
    currently being used; this is generally ignored. The standard_tests argument value
    will be all of the tests loaded by default. Generally, this is the suite of all
    subclasses of TestCase. The function updates this object with the additional tests.
    The pattern value is the value provided to the loader to locate tests; this is
    also ignored.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: load_tests() 函数的加载器参数值是当前正在使用的测试用例加载器；这通常被忽略。standard_tests 参数值将是默认加载的所有测试。通常，这是
    TestCase 所有子类的套件。该函数使用额外的测试更新此对象。模式值是提供给加载器的值，用于定位测试；这也被忽略。
- en: 'When we run this from the OS command prompt, we see the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从操作系统命令提示符运行它时，我们看到以下内容：
- en: '[PRE44]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This shows us that the unittest test cases were included as well as doctest
    test cases.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 unittest 测试用例以及 doctest 测试用例都被包含在内。
- en: 15.5.3 How it works...
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.3 的工作原理...
- en: The unittest.main() application uses a test loader to find all of the relevant
    test cases. The loader is designed to find all classes that extend TestCase. It
    will also look for a load_tests() function. This function can provide a suite
    of additional tests. It can also do non-default searches for tests when that’s
    needed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: unittest.main() 应用程序使用一个测试加载器来查找所有相关的测试用例。加载器被设计用来查找所有扩展 TestCase 的类。它还会寻找一个
    load_tests() 函数。这个函数可以提供一系列额外的测试。它也可以在需要时执行非默认的测试搜索。
- en: Generally, we can import a module with docstrings and use a DocTestSuite to
    build a test suite from the imported module. We can, of course, import other modules
    or even scan the README file for more examples to test. The goal is to make sure
    every example in both the code and the documentation actually works.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们可以导入一个带有文档字符串的模块，并使用 DocTestSuite 从导入的模块构建测试套件。我们当然可以导入其他模块，甚至扫描 README
    文件以获取更多测试示例。目标是确保代码和文档中的每个示例都实际可行。
- en: 15.5.4 There’s more...
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.4 更多...
- en: In some cases, a module may be quite complicated; this can lead to multiple
    test modules. The test modules may have names such as tests/test_module_feature_X.py
    to show that there are tests for separate features of a very complex module. The
    volume of code for test cases can be quite large, and keeping the features separate
    can be helpful.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个模块可能相当复杂；这可能导致多个测试模块。测试模块可能有如 tests/test_module_feature_X.py 这样的名称，以表明对一个非常复杂的模块的各个单独功能都有测试。测试用例的代码量可能相当大，保持功能分离可能是有帮助的。
- en: In other cases, we might have a test module that has tests for several different
    but closely related small modules. A single test module may employ inheritance
    techniques to cover all the modules in a package.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，我们可能有一个测试模块，它为几个不同但紧密相关的较小模块提供测试。一个单独的测试模块可能使用继承技术来覆盖一个包中的所有模块。
- en: 'When combining many smaller modules, there may be multiple suites built in
    the load_tests() function. The body might look like this:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当组合许多较小的模块时，load_tests() 函数中可能会构建多个套件。主体可能看起来像这样：
- en: '[PRE45]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will incorporate doctest examples from multiple modules into a single,
    comprehensive test suite.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把多个模块中的 doctest 示例合并到一个单一的、全面的测试套件中。
- en: 15.5.5 See also
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.5.5 参见
- en: For examples of doctest, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in the chapter. For examples of unittest, see the [Unit testing
    with the unittest module](ch019_split_000.xhtml#x1-8190004) recipe earlier in
    this chapter.
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 doctest 的示例，请参阅本章前面的 [使用文档字符串进行测试](ch019_split_000.xhtml#x1-7950001) 配方。关于
    unittest 的示例，请参阅本章前面的 [使用 unittest 模块进行单元测试](ch019_split_000.xhtml#x1-8190004)
    配方。
- en: 15.6 Unit testing with the pytest module
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.6 使用 pytest 模块进行单元测试
- en: The pytest tool allows us to step beyond the examples used by doctest in docstrings.
    Instead of using a subclass of TestCase, the pytest tool lets us use function
    definitions. The pytest approach uses Python’s built-in assert statement, leaving
    the test case looking somewhat simpler.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 工具允许我们超越 doctest 在文档字符串中使用的示例。而不是使用 TestCase 的子类，pytest 工具让我们使用函数定义。pytest
    方法使用 Python 内置的 assert 语句，使测试用例看起来相对简单。
- en: 'The pytest tool is not part of Python; it needs to be installed separately.
    Use a command like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 工具不是 Python 的一部分；它需要单独安装。使用如下命令：
- en: '[PRE46]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this recipe, we’ll look at how we can use pytest to simplify our test cases.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨如何使用 pytest 简化我们的测试用例。
- en: 15.6.1 Getting ready
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.1 准备工作
- en: 'The Gherkin language can help to structure a test. For this recipe, we have
    a scenario like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Gherkin 语言可以帮助结构化测试。对于这个配方，我们有一个这样的场景：
- en: '[PRE47]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A pytest test function doesn’t precisely follow the Gherkin three-part structure.
    A test function generally has two parts:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: pytest 测试函数并不严格遵循 Gherkin 的三部分结构。测试函数通常有两个部分：
- en: If necessary, fixtures are defined to establish the Given steps. Fixtures are
    designed for reuse as well as composition. A fixture can also tear down resources
    after a test has finished.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，定义固定对象以建立 Given 步骤。固定对象旨在用于重用和组合。固定对象还可以在测试完成后拆除资源。
- en: The body of the function will usually handle the When steps to exercise the
    object being tested and the Then steps to confirm the results.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数的主体通常处理 When 步骤以测试被测试的对象，以及 Then 步骤以确认结果。
- en: These boundaries are not fixed. A fixture might, for example, create an object
    and also take action, executing both the Given and When steps. This permits multiple
    test functions to apply several independent Then steps.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边界不是固定的。例如，一个固定对象可能创建一个对象并采取行动，执行 Given 和 When 步骤。这允许多个测试函数应用多个独立的 Then 步骤。
- en: We’ll create some tests for a class that is designed to compute some basic descriptive
    statistics. The bulk of the code was shown in the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为一个设计用来计算一些基本描述性统计的类创建一些测试。代码的主体已在[使用 docstrings 进行测试](ch019_split_000.xhtml#x1-7950001)的菜谱中展示。
- en: 'This is an outline of the class, provided as a reminder of what the method
    names are:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个类的概要，提供作为方法名称的提醒：
- en: '[PRE48]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We want to duplicate testing shown in the [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe. We’ll use the pytest features to do this.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望复制[使用 unittest 模块进行单元测试](ch019_split_000.xhtml#x1-8190004)菜谱中展示的测试。我们将使用
    pytest 功能来完成这个任务。
- en: 15.6.2 How to do it...
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.2 如何做到...
- en: 'It’s often best to start with a separate test file, perhaps even a separate
    tests directory:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好从一个单独的测试文件开始，甚至是一个单独的测试目录：
- en: Create a test file with a name similar to the module under test. If the module
    file was named summary.py, then a good name for a test module would be test_summary.py.
    Using the test_ prefix makes the test easier to find.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个与被测试模块名称相似的测试文件。如果模块文件名为 summary.py，那么一个合适的测试模块名称将是 test_summary.py。使用 test_
    前缀可以使测试更容易找到。
- en: 'We’ll use the pytest module for creating test classes. We’ll also be using
    the random module to scramble the input data. Also, we need to import the module
    under test:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 pytest 模块来创建测试类。我们还将使用 random 模块来打乱输入数据。此外，我们需要导入被测试的模块：
- en: '[PRE49]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Implement the Given step as a fixture. This is marked with the @pytest.fixture
    decorator. It creates a function that can return a useful object, data for creating
    an object, or a mocked object:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Given 步骤实现为一个固定对象。这通过 @pytest.fixture 装饰器标记。它创建了一个可以返回有用对象、创建对象的必要数据或模拟对象的函数：
- en: '[PRE50]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Implement the When and Then steps as a test function with a name visible to
    pytest. This means the function name must begin with test_:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 When 和 Then 步骤实现为一个对 pytest 可见的测试函数。这意味着函数名称必须以 test_ 开头：
- en: '[PRE51]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: When a parameter name in a test function definition is the name of a fixture
    function, the fixture function is evaluated automatically. The results of the
    fixture function are provided at runtime. This means the shuffled set of 1,000
    values will be provided as an argument value for the flat_data parameter.
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当测试函数定义中的参数名称是固定函数的名称时，固定函数会自动评估。固定函数的结果在运行时提供。这意味着打乱的 1,000 个值的集合将作为 flat_data
    参数的参数值提供。
- en: 'Implement a When step to perform an operation on an object:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个 When 步骤以对一个对象执行操作：
- en: '[PRE52]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Implement the Then steps to validate the outcome:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 Then 步骤以验证结果：
- en: '[PRE53]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If our test module is called test_summary.py, we can often execute the tests
    found in it with a command like the following:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的测试模块名为 test_summary.py，我们通常可以使用如下命令来执行其中的测试：
- en: '[PRE54]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will invoke the main application that’s part of the pytest package. It
    will search the given file for functions with names starting with test_ and execute
    those test functions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这将调用 pytest 包的一部分主应用程序。它将在给定的文件中搜索以 test_ 开头的函数并执行这些测试函数。
- en: 15.6.3 How it works...
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.3 它是如何工作的...
- en: 'We’re using several parts of the pytest package:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 pytest 包的几个部分：
- en: The @fixture decorator can be used to create reusable test fixtures with objects
    in known states, ready for further processing.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '@fixture 装饰器可以用来创建具有已知状态的、可重用的测试固定对象，以便进行进一步处理。'
- en: 'The pytest application to do several things:'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: pytest 应用程序可以执行多项任务：
- en: Discover tests. By default, it searches a directory named tests for module names
    starting with test_. Within those, it looks for functions with names starting
    with test_. It also finds unittest.TestCase classes.
  id: totrans-334
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现测试。默认情况下，它搜索名为 tests 的目录，查找以 test_ 开头的模块名称。在这些模块中，它查找以 test_ 开头的函数。它还找到 unittest.TestCase
    类。
- en: Run all of the tests, evaluating the fixtures as needed.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行所有测试，根据需要评估夹具。
- en: Display a summary of the results.
  id: totrans-336
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示结果的摘要。
- en: 'When we run the pytest command, we’ll see output that looks like this:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 pytest 命令时，我们将看到类似以下的输出：
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As each test is passed, a . is displayed. This shows that the test suite is
    making progress. The summary shows the number of tests run and the time. If there
    are failures or exceptions, the counts on the last line will reflect this.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 随着每个测试的通过，将显示一个 .。这表明测试套件正在取得进展。摘要显示了运行的测试数量和时间。如果有失败或异常，最后一行的计数将反映这一点。
- en: 'If we change one test slightly to be sure that it fails, we’ll see the following
    output:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们稍微改变一个测试以确保它失败，我们将看到以下输出：
- en: '[PRE56]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This shows a summary of passing and failing tests and the details of each failure.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了通过和失败的测试的摘要以及每个失败的详细信息。
- en: 15.6.4 There’s more...
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.4 更多...
- en: In this example, we have two Then steps inside the test_flat() function. These
    are implemented as two assert statements. If the first one fails, the test stops
    as a failure, and the following step will be skipped. This means we might not
    see all the diagnostic information we might need.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在 test_flat() 函数内部有两个 Then 步骤。这些步骤被实现为两个 assert 语句。如果第一个失败，测试将作为失败停止，并且后续步骤将被跳过。这意味着我们可能看不到我们可能需要的所有诊断信息。
- en: 'A better design is to use multiple test functions. All of the functions can
    share a common fixture. In this case, we can create a second fixture that depends
    on the flat_data fixture and builds a Summary object to be used by a number of
    tests:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的设计是使用多个测试函数。所有这些函数都可以共享一个共同的夹具。在这种情况下，我们可以创建一个依赖于 flat_data 夹具的第二个夹具，并构建一个
    Summary 对象，供多个测试使用：
- en: '[PRE57]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Since each of these test functions are run separately, we’ll see separate error
    reports for problems when computing the mean and the median, or possibly when
    computing both.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个测试函数都是单独运行的，因此当计算平均值和中位数时，我们将看到单独的错误报告，或者可能在同时计算两者时。
- en: 15.6.5 See also
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.6.5 参见
- en: The [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe in this chapter covers the same test case from the perspective of the unittest
    module.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 [使用 unittest 模块进行单元测试](ch019_split_000.xhtml#x1-8190004) 菜单从 unittest 模块的角度覆盖了相同的测试案例。
- en: 15.7 Combining pytest and doctest tests
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.7 结合 pytest 和 doctest 测试
- en: In most cases, we’ll have a combination of pytest and doctest test cases. For
    examples of using the doctest tool, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe. For examples of using the pytest tool, see the [Unit testing with the
    pytest module](ch019_split_001.xhtml#x1-8310006) recipe.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，我们将有 pytest 和 doctest 测试案例的组合。有关使用 doctest 工具的示例，请参阅 [使用 docstrings
    进行测试](ch019_split_000.xhtml#x1-7950001) 菜谱。有关使用 pytest 工具的示例，请参阅 [使用 pytest 模块进行单元测试](ch019_split_001.xhtml#x1-8310006)
    菜谱。
- en: Frequently, documentation will contain doctest. We need to be sure all examples
    – in docstrings and documentation – work correctly. In this recipe, we’ll combine
    these doctest examples and the pytest test cases into one tidy package.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 经常，文档将包含 doctest。我们需要确保所有示例（在 docstrings 和文档中）都能正确工作。在这个菜谱中，我们将把这些 doctest 示例和
    pytest 测试案例组合成一个整洁的包。
- en: 15.7.1 Getting ready
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.1 准备工作
- en: We’ll refer back to the example from the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe. This recipe created tests for a class, Summary, that does some statistical
    calculations. In that recipe, we included examples in the docstrings.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将参考 [使用 docstrings 进行测试](ch019_split_000.xhtml#x1-7950001) 菜谱中的示例。这个菜谱为 Summary
    类创建了一些测试，该类执行一些统计计算。在那个菜谱中，我们在 docstrings 中包含了示例。
- en: In the [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe, we wrote some test functions to provide additional tests for this class.
    These tests were put into a separate module, with a name starting with test_,
    specifically, test_summary.py.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [使用 pytest 模块进行单元测试](ch019_split_001.xhtml#x1-8310006) 菜谱中，我们编写了一些测试函数来为这个类提供额外的测试。这些测试被放入了一个单独的模块中，模块名称以
    test_ 开头，具体为 test_summary.py。
- en: 'Following the [Combining unittest and doctest tests](ch019_split_000.xhtml#x1-8250005)
    recipe, we’ll also assume there’s a project folder structure that looks like the
    following directory tree:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 按照结合unittest和doctest测试的[配方](ch019_split_000.xhtml#x1-8250005)，我们还将假设有一个项目文件夹结构，如下所示：
- en: '[PRE58]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The tests directory should contain all the module files with tests. We’ve chosen
    the directory named tests and a module named test_*.py so that they fit well with
    the automated test discovery features of the pytest tool.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 测试目录应包含所有包含测试的模块文件。我们选择了名为tests的目录和一个名为test_*.py的模块，这样它们就可以很好地与pytest工具的自动化测试发现功能相匹配。
- en: The recipe examples use recipe_07 instead of a cooler name such as summary.
    As a general practice, a module should have a memorable, meaningful name. The
    book’s content is quite large, and the names are designed to match the overall
    chapter and recipe outline.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 配方示例使用recipe_07而不是像summary这样的更酷的名字。作为一般实践，一个模块应该有一个易于记忆、有意义的名字。本书的内容相当庞大，名字是为了与整体章节和配方大纲相匹配。
- en: 15.7.2 How to do it...
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.2 如何做...
- en: 'It turns out that we don’t need to write any Python code to combine the tests.
    The pytest module will locate test functions. It can also be used to locate doctest
    cases:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，我们不需要编写任何Python代码来组合测试。pytest模块将定位测试函数。它也可以用来定位doctest用例：
- en: 'Create a shell command to run the test suite in the recipe_07.py file, as well
    as to examine the recipe_01.py module for the additional doctest cases:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个shell命令来运行recipe_07.py文件中的测试套件，以及检查recipe_01.py模块中的额外doctest用例：
- en: '[PRE59]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'When we run this from the OS command prompt, we see the following:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从操作系统命令提示符运行这个程序时，我们会看到以下内容：
- en: '[PRE60]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The pytest command worked with both files. The dots after recipe_07.py show
    that two test cases were found in this file. This was 28% of the test suite. The
    dots after recipe_01.py show that five test cases more were found; this was the
    remaining 72% of the suite.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: pytest命令与这两个文件都兼容。recipe_07.py后面的点表示在这个文件中找到了两个测试用例，这是测试套件的28%。recipe_01.py后面的点表示找到了更多的五个测试用例；这是套件剩余的72%。
- en: This shows us that the pytest test cases were included as well as doctest test
    cases. What’s helpful is that we don’t have to adjust anything in either of the
    test suites to execute all of the available test cases.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明pytest测试用例以及doctest测试用例都被包含在内。有帮助的是，我们不需要在任一测试套件中调整任何内容来执行所有可用的测试用例。
- en: 15.7.3 How it works...
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.3 它是如何工作的...
- en: The pytest application has a variety of ways to search for test cases. The default
    is to search the given paths for all functions with names that start with test_
    in a given module. It will also search for all subclasses of TestCase. If we provide
    a directory, it will search it for all modules with names that begin with test_.
    Often, we’ll collect our test files in a directory named tests because this is
    the default directory that will be searched.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: pytest应用程序有多种方式来搜索测试用例。默认情况下，它会在给定模块中搜索所有以test_开头的函数名称的给定路径。它也会搜索所有TestCase的子类。如果我们提供一个目录，它将搜索以test_开头的所有模块。通常，我们会将测试文件收集在名为tests的目录中，因为这是默认将被搜索的目录。
- en: The --doctest-modules command-line option is used to mark modules that contain
    doctest examples. These examples are also added to the test suite as test cases.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: --doctest-modules命令行选项用于标记包含doctest示例的模块。这些示例也被添加到测试套件中作为测试用例。
- en: This level of sophistication in finding and executing a variety of types of
    tests makes pytest a very powerful tool. It makes it easy to create tests in a
    variety of forms to create confidence that our software will work as intended.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找和执行各种类型测试的复杂程度方面，pytest是一个非常强大的工具。它使得创建各种形式的测试变得容易，从而增加了我们软件按预期工作的信心。
- en: 15.7.4 There’s more...
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.4 更多...
- en: 'Adding the -v option provides a more detailed view of the tests found by the
    pytest tool. Here’s how the additional details are displayed:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 添加-v选项提供了pytest工具找到的测试的更详细视图。以下是显示额外细节的方式：
- en: '[PRE61]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Each individual test is identified, providing us with a detailed explanation
    of the test processing. This can help confirm that all of the expected doctest
    examples were properly located in the module under test.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 每个单独的测试都会被标识，为我们提供了测试处理的详细解释。这有助于确认所有预期的doctest示例都已正确地定位在测试的模块中。
- en: 15.7.5 See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.7.5 参见
- en: For examples of doctest, see the [Using docstrings for testing](ch019_split_000.xhtml#x1-7950001)
    recipe earlier in this chapter.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于doctest的示例，请参阅本章前面的[使用docstrings进行测试](ch019_split_000.xhtml#x1-7950001)配方。
- en: The [Unit testing with the pytest module](ch019_split_001.xhtml#x1-8310006)
    recipe earlier in this chapter has the pytest test cases used for this recipe.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面的[使用pytest模块进行单元测试](ch019_split_001.xhtml#x1-8310006)菜谱有用于此菜谱的pytest测试用例。
- en: For examples of the unittest version of these tests, see the [Unit testing with
    the unittest module](ch019_split_000.xhtml#x1-8190004) recipe earlier in this
    chapter.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于这些测试的unittest版本示例，请参阅本章前面的[使用unittest模块进行单元测试](ch019_split_000.xhtml#x1-8190004)菜谱。
- en: 15.8 Testing things that involve dates or times
  id: totrans-380
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.8 测试涉及日期或时间的事物
- en: 'Many applications rely on functions like datetime.datetime.now() or time.time()
    to create a timestamp. When we use one of these functions with a unit test, the
    results are essentially impossible to predict. This is an interesting dependency
    injection problem here: our application depends on a class that we would like
    to replace only when we’re testing.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序依赖于像datetime.datetime.now()或time.time()这样的函数来创建时间戳。当我们使用这些函数之一进行单元测试时，结果基本上是不可预测的。这是一个有趣的依赖注入问题：我们的应用程序依赖于一个我们希望在测试时才替换的类。
- en: One option is to design our application to avoid functions like now(). Instead
    of using this method directly, we can create a factory function that emits timestamps.
    For test purposes, this function can be replaced with one that produces known
    results.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是设计我们的应用程序以避免使用像now()这样的函数。我们不是直接使用这种方法，而是可以创建一个工厂函数来输出时间戳。为了测试目的，这个函数可以被替换为产生已知结果的函数。
- en: The alternative is called monkey-patching – injecting a new object at test time.
    This can reduce the design complexity; it tends to increase the test complexity.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是猴子补丁 - 在测试时注入一个新的对象。这可以减少设计复杂性；它往往会增加测试复杂性。
- en: In this recipe, we’ll write tests with datetime objects. We’ll need to create
    mock objects for datetime instances to create repeatable test values. We’ll use
    the pytest package features for monkey-patching.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用datetime对象编写测试。我们需要为datetime实例创建模拟对象以创建可重复的测试值。我们将使用pytest包的特性进行猴子补丁。
- en: 15.8.1 Getting ready
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.1 准备工作
- en: We’ll work with a small function that creates a CSV file. This file’s name will
    include the date and time in the format of YYYYMMDDHHMMSS as a long string of
    digits. This kind of file-naming convention might be used by a long-running server
    application. The name helps match a file and related log events. It can help to
    trace the work being done by the server.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个创建CSV文件的小函数进行工作。这个文件的名称将包括日期和时间，格式为YYYYMMDDHHMMSS，作为一长串数字。这种文件命名约定可能被长期运行的服务器应用程序使用。这个名称有助于匹配文件和相关日志事件。它有助于追踪服务器正在执行的工作。
- en: 'The application uses this function to create these files:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用此函数创建这些文件：
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This function has the use of now(), which produces a distinct value each time
    this is run. Since this value is difficult to predict, it makes test assertions
    difficult to write.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数使用了now()函数，每次运行都会产生一个不同的值。由于这个值难以预测，因此编写测试断言变得困难。
- en: To create a reproducible test output, we can create a mock version of the datetime
    module. We can then monkey patch the test context to use this mock object instead
    of the actual datetime module. Within the mocked module, we can create a mock
    class with a mock now() method to provide a fixed, easy-to-test response.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建可重复的测试输出，我们可以创建datetime模块的模拟版本。然后我们可以猴子补丁测试上下文以使用这个模拟对象而不是实际的datetime模块。在模拟的模块中，我们可以创建一个带有模拟now()方法的模拟类，以提供固定且易于测试的响应。
- en: 'For this case, we have a scenario like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况，我们有一个类似的场景：
- en: '[PRE63]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This can be implemented as a test case using the pytest constructs.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过使用pytest构造函数实现为一个测试用例。
- en: 15.8.2 How to do it...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.2 如何做...
- en: 'This recipe will create and patch mock objects to create a test fixture:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将创建和修补模拟对象以创建测试固件：
- en: 'We’ll need to import a number of modules required by the module we’re testing:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导入我们正在测试的模块所需的多个模块：
- en: '[PRE64]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We’ll also need the core tools for creating mock objects and test fixtures.
    Also, we’ll need the module we’re going to test:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建模拟对象和测试固件的核心工具。此外，我们还需要我们打算测试的模块：
- en: '[PRE65]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We must create an object that will behave like the datetime module for the
    purposes of the test scenario. This mocked module must contain a name that appears
    to be a class, also named datetime. The class must appear to contain a method,
    now(), which returns a known object rather than a date that changes each time
    the test is run. We’ll create a fixture, and the fixture will return this mock
    object with a small set of attributes and behaviors defined:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须创建一个对象，使其在测试场景中表现得像 datetime 模块。这个模拟模块必须包含一个看起来像类的名称，也命名为 datetime。这个类必须看起来包含一个方法，now()，它返回一个已知的对象，而不是每次测试运行时都变化的日期。我们将创建一个
    fixture，并且该 fixture 将返回这个模拟对象，并定义一组小的属性和行为：
- en: '[PRE66]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The Mock object is a namespace, a feature that packages, modules, and classes
    all share. In this example, each attribute name is another Mock object. The most
    deeply-buried object has a return_value attribute to make it behave like a function.
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Mock 对象是一个命名空间，这是包、模块和类都共享的特性。在这个例子中，每个属性名都是另一个 Mock 对象。最深层嵌套的对象有一个 return_value
    属性，使其表现得像一个函数。
- en: We also need a way to isolate the behavior of the filesystem into test directories.
    The tmppath fixture is built in to pytest and provides temporary directories into
    which test files can be written safely.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一种方法来隔离文件系统的行为到测试目录中。tmppath fixture 内置于 pytest 中，并提供临时目录，可以在其中安全地写入测试文件。
- en: 'We can now define a test function that will use the mock_datetime fixture and
    the tmppath fixture. It will use the monkeypatch fixture to adjust the context
    of the module under test:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以定义一个测试函数，该函数将使用 mock_datetime fixture 和 tmppath fixture。它将使用 monkeypatch
    fixture 来调整被测试模块的上下文：
- en: '[PRE67]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can use the monkeypatch fixture to replace an attribute of the recipe_08
    module. The datetime attribute value will be replaced with the Mock object created
    by the mock_datetime fixture:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 monkeypatch fixture 来替换 recipe_08 模块的一个属性。datetime 属性值将被 mock_datetime
    fixture 创建的 Mock 对象所替换：
- en: '[PRE68]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Between the fixture definitions and this patch, we’ve created a Given step that
    defines the test arrangement.
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 fixture 定义和这个补丁之间，我们创建了一个 Given 步骤，用于定义测试安排。
- en: 'We can now exercise the save_data() function in a controlled test environment.
    This is the When step that exercises the code under test:'
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在一个受控的测试环境中执行 save_data() 函数。这是 When 步骤，用于执行被测试的代码：
- en: '[PRE69]'
  id: totrans-410
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Since the date and time are fixed by the Mock object, the output file has a
    known, predictable name. We can read and validate the expected data in the file.
    Further, we can interrogate the Mock object to be sure it was called exactly once
    with no argument values. This is a Then step to confirm the expected results:'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于日期和时间由 Mock 对象固定，输出文件有一个已知、可预测的名称。我们可以读取和验证文件中的预期数据。此外，我们可以查询 Mock 对象以确保它恰好被调用一次，并且没有参数值。这是一个
    Then 步骤，用于确认预期结果：
- en: '[PRE70]'
  id: totrans-412
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This test confirms the application’s save_data() function will create the expected
    file with the proper content.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试确认应用程序的 save_data() 函数将创建预期的文件，并包含正确的内容。
- en: 15.8.3 How it works...
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.3 它是如何工作的...
- en: The unittest.mock module has a wonderfully sophisticated class definition, the
    Mock class. A Mock object can behave like other Python objects, while offering
    a limited subset of behaviors. In this example, we’ve created three different
    kinds of Mock objects.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: unittest.mock 模块有一个非常复杂的类定义，即 Mock 类。Mock 对象可以表现得像其他 Python 对象，同时提供有限的行为子集。在这个例子中，我们创建了三种不同类型的
    Mock 对象。
- en: The Mock(wraps="datetime", ...) object mocks a complete module. It will behave,
    to the extent needed by this test scenario, like the standard library datetime
    module. Within this object, we created a mock class definition but didn’t assign
    it to any variable.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: The Mock(wraps="datetime", ...) 对象模拟了一个完整的模块。它在测试场景所需的范围内将表现得像标准库的 datetime
    模块。在这个对象内部，我们创建了一个模拟类定义，但没有将其分配给任何变量。
- en: The Mock(now=...) object behaves like a mock class definition inside the mock
    module. We’ve created a single now attribute value, which will behave like a static
    function.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: Mock(now=...) 对象在 mock 模块内部表现得像一个模拟类定义。我们创建了一个单一的 now 属性值，它将表现得像一个静态函数。
- en: The Mock(return_value=...) object behaves like an ordinary function or method.
    We provide the return value required for this test.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: Mock(return_value=...) 对象表现得像一个普通函数或方法。我们提供这个测试所需的返回值。
- en: In addition to returning the given value, a Mock object records the history
    of calls. This means an assertion can checks those calls. The call() function
    from the Mock module provides a way to describe the arguments that are expected
    in the function call.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 除了返回给定值外，Mock对象还记录了调用历史。这意味着断言可以检查这些调用。Mock模块中的call()函数提供了一种描述函数调用中预期参数的方法。
- en: 15.8.4 There’s more...
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.4 更多内容...
- en: In this example, we created a mock for the datetime module that had a very narrow
    feature set for this test. The module contained a mocked class named datetime.
    This class has a single attribute, a mocked function, now().
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们创建了一个针对datetime模块的模拟，该模块具有非常窄的功能集以供此测试使用。该模块包含一个名为datetime的模拟类。这个类有一个单一属性，一个模拟函数，now()。
- en: Instead of the return_value attribute, we can use the side_effect attribute
    to raise an exception instead of returning a value. We can use this to spot code
    that’s not using the now() method properly, but using the deprecated utcnow()
    or the today() methods.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用副作用属性而不是return_value属性来引发异常而不是返回值。我们可以使用这种方法来发现未正确使用now()方法，而是使用已弃用的utcnow()或today()方法的代码。
- en: 'We can extend this pattern and mock more than one attribute to behave like
    a function. Here’s an example that mocks several functions:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以扩展这个模式并模拟多个属性以表现得像函数。以下是一个模拟几个函数的示例：
- en: '[PRE71]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Two of the mocked methods, utcnow() and today(), each define a side effect that
    will raise an exception. This allows us confirm legacy code has been converted
    to make proper use of the now() method.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模拟方法，utcnow()和today()，每个都定义了一个会引发异常的副作用。这允许我们确认旧代码已被转换为正确使用now()方法。
- en: 15.8.5 See also
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.8.5 参见
- en: The [Unit testing with the unittest module](ch019_split_000.xhtml#x1-8190004)
    recipe earlier in this chapter has more information about the basic use of the
    unittest module.
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面关于使用unittest模块进行单元测试的[示例](ch019_split_000.xhtml#x1-8190004)提供了有关unittest模块基本使用的信息。
- en: 15.9 Testing things that involve randomness
  id: totrans-428
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.9 测试涉及随机性的内容
- en: Many applications rely on the random module to create random values or put values
    into a random order. In many statistical tests, repeated random shuffling or random
    selection is done. When we want to test one of these algorithms, any intermediate
    results or details of the processing are essentially impossible to predict.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序依赖于随机模块来生成随机值或将值放入随机顺序。在许多统计测试中，重复的随机洗牌或随机选择是进行的。当我们想要测试这些算法之一时，任何中间结果或处理细节基本上是无法预测的。
- en: 'We have two choices for trying to make the random module predictable enough
    to write detailed unit tests:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个选择来尝试使随机模块足够可预测，以便编写详细的单元测试：
- en: Use the random module with a known seed value.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有已知种子值的随机模块。
- en: Use a Mock object to replace the random module with a Mock object to produce
    predictable values.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Mock对象用Mock对象替换随机模块以产生可预测的值。
- en: In this recipe, we’ll look at ways to unit test algorithms that involve randomness.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨如何对涉及随机性的算法进行单元测试。
- en: 15.9.1 Getting ready
  id: totrans-434
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.1 准备工作
- en: Given a sample dataset, we can compute a statistical measure such as a mean
    or median. A common next step is to determine the likely values of these statistical
    measures for some overall population. This can be done by a technique called bootstrapping.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个样本数据集，我们可以计算一个统计量，例如平均值或中位数。下一步常见的操作是确定这些统计量对于某个总体人群的可能值。这可以通过一种称为自助法的技术来完成。
- en: The idea is to resample the initial set of data repeatedly. Each of the resamples
    provides a different estimate of the statistical measures for the population.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是重复对初始数据集进行重采样。每个重采样都提供了对总体统计量的不同估计。
- en: In order to be sure that a resampling algorithm is implemented correctly, it
    helps to eliminate randomness from the processing. We can resample a carefully
    planned set of data with a non-randomized version of the random.choice() function.
    If this works properly, then we have confidence that the randomized version will
    also work.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保重采样算法被正确实现，有助于消除处理中的随机性。我们可以使用非随机版本的random.choice()函数对精心策划的数据集进行重采样。如果这能正常工作，那么我们有信心随机版本也会正常工作。
- en: 'Here’s our candidate resampling function:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的候选重采样函数：
- en: '[PRE72]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'For our example, we’ll compute alternative values of the mean based on resampling.
    The overall resampling procedure looks like this:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将根据重采样计算平均值的替代值。整体重采样过程看起来像这样：
- en: '[PRE73]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This evaluates the resample() function to create a number of subsets. Each subset’s
    mean populates the means collection. The histogram created by this mean_distribution()
    function will provide a helpful estimate for population variance.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这评估resample()函数以创建多个子集。每个子集的平均值填充了平均值集合。由mean_distribution()函数创建的直方图将为人口方差提供一个有用的估计。
- en: 'Here’s what the output looks like:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是输出看起来像什么：
- en: '[PRE74]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This shows us that the most likely value for the mean of the overall population
    could be between 7.1 and 7.8\. There’s more to this kind of analysis than we’re
    showing here. Our focus is limited to the narrow question of testing the resample()
    function.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，总体平均值的可能值可能在7.1到7.8之间。这种分析的内容远不止我们在这里展示的。我们的关注点仅限于测试resample()函数的狭隘问题。
- en: 'The test for resampling involves a scenario like the following:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 重采样的测试涉及以下场景：
- en: '[PRE75]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 15.9.2 How to do it...
  id: totrans-448
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.2 如何做到...
- en: 'We’ll define a mock object that can be used instead of the random.choice()
    function. With this fixture in place, the results are fixed and predictable:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个可以替代random.choice()函数的模拟对象。有了这个夹具，结果就是固定和可预测的：
- en: 'We’ll need the core tools for creating mock objects and test fixtures. Also,
    we’ll need the module we’re going to test:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要创建模拟对象和测试夹具的核心工具。我们还需要我们打算测试的模块：
- en: '[PRE76]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'We’ll need an object that will behave like the choice() function. We’ll create
    a fixture built on another fixture:'
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个类似于choice()函数的对象。我们将创建一个基于另一个夹具的夹具：
- en: '[PRE77]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The expected_resample_data fixture provides a specific list of values that will
    provide expected results. Using this fixture, the mock_random_choice choice fixture
    returns the expected values in response to the choice() function.
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: expected_resample_data测试夹具提供了一组特定的值，这些值将提供预期的结果。使用此夹具，mock_random_choice选择夹具在choice()函数的响应中返回预期值。
- en: 'We can now define a test function that will use the mock_random_choice fixture,
    which creates a mock object, and the monkeypatch fixture, which lets us adjust
    the context of the module under test:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以定义一个测试函数，该函数将使用mock_random_choice测试夹具，它创建一个模拟对象，以及monkeypatch测试夹具，它允许我们调整被测试模块的上下文：
- en: '[PRE78]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'We can use the monkeypatch fixture to replace the choice attribute of the random
    module with the Mock object created by the mock_random_choice fixture:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用monkeypatch夹具用mock_random_choice夹具创建的Mock对象替换random模块的choice属性：
- en: '[PRE79]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Between the fixture definitions and this patch, we’ve created a Given step that
    defines the test arrangement.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在夹具定义和这个补丁之间，我们创建了一个Given步骤，该步骤定义了测试安排。
- en: 'We can now exercise the resample() function in a controlled test environment.
    This is the When step that exercises the code under test:'
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以在一个受控的测试环境中练习resample()函数。这是当步骤，用于测试被测试的代码：
- en: '[PRE80]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Since the random choices are fixed by the Mock object, the result is fixed.
    We can confirm that the data created by the mock_random_choice fixture was used
    for resampling. We can also confirm that the mocked choice function was properly
    called with the input data:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于随机选择被Mock对象固定，结果是固定的。我们可以确认由mock_random_choice夹具创建的数据被用于重采样。我们还可以确认模拟的选择函数是否正确地用输入数据调用了：
- en: '[PRE81]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This test helps to confirm that our resample() function will create the output
    based on the given input and the random.choice() function.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试有助于确认我们的resample()函数将根据给定的输入和random.choice()函数创建输出。
- en: 15.9.3 How it works...
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.3 它是如何工作的...
- en: When we create a Mock object, we must provide the methods and attributes to
    define the behavior of the object being mocked. When we create an instance of
    Mock that provides the side_effect argument value, we’re creating a callable object.
    The callable object will return the next value from the side_effect sequence each
    time the Mock object is called. This gives us a handy way to mock iterators.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个Mock对象时，我们必须提供方法和属性来定义被模拟对象的行为。当我们创建一个提供side_effect参数值的Mock实例时，我们正在创建一个可调用对象。每次调用Mock对象时，可调用对象将返回side_effect序列中的下一个值。这为我们提供了一个方便的方式来模拟迭代器。
- en: If any value in side_effect is an exception, this is raised.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 如果side_effect中的任何值是异常，则会引发异常。
- en: We can also see the call history using the mock_calls attribute of a Mock object.
    This lets us confirm that the callable was provided proper argument values.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过Mock对象的mock_calls属性查看调用历史。这使我们能够确认可调用对象提供了适当的参数值。
- en: 15.9.4 There’s more...
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.4 更多...
- en: 'The resample() function has an interesting pattern to it. When we take a step
    back from the details, we see this:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: resample()函数有一个有趣的模式。当我们从细节中退一步时，我们看到的是这个：
- en: '[PRE82]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The X argument value is simply passed through to another function without any
    processing. For testing purposes, it doesn’t matter what the value of X is. What
    we’re testing is that the parameter’s value in the resample() function is provided
    to the another_function() function, untouched.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: X参数值简单地传递给另一个函数，没有任何处理。对于测试目的，X的值无关紧要。我们正在测试的是resample()函数中的参数值是否被提供给另一个_function()函数，且未被改变。
- en: The mock library provides an object called sentinel that can be used to create
    an opaque argument value in these circumstances. When we refer to an attribute
    of the sentinel object, this reference creates a distinct object. We might use
    sentinel.POPULATION as a kind of mock for a collection of values. The exact collection
    doesn’t matter since it’s simply passed as an argument to another function (called
    random.choice() in the actual code).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟库提供了一个名为sentinel的对象，可以在这种情况下创建一个不透明的参数值。当我们引用哨兵对象的属性时，这个引用创建了一个不同的对象。我们可能会使用sentinel.POPULATION作为一组值的模拟。确切的集合无关紧要，因为它只是作为另一个函数（在实际情况中称为random.choice()）的参数传递。
- en: 'Here’s how this use of a sentinel object can change this test:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用哨兵对象来改变这个测试的示例：
- en: '[PRE83]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The output from the mocked choice() function is a recognizable sentinel object.
    Similarly, the parameter to the resample() function is a different sentinel object.
    We expect this to be called 8 times, because the N parameter is set to 8 in the
    test case.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟的choice()函数的输出是一个可识别的哨兵对象。同样，resample()函数的参数是另一个哨兵对象。我们预计这将被调用8次，因为测试用例中N参数被设置为8。
- en: When an object should pass through a function untouched, we can write test assertions
    to confirm this expected behavior. If the code we’re testing uses the population
    object improperly, the test can fail when the result is not the untouched sentinel
    object.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个对象应该通过一个函数而不被改变时，我们可以编写测试断言来确认这种预期的行为。如果我们正在测试的代码不正确地使用了总体对象，当结果不是未被改变的哨兵对象时，测试可能会失败。
- en: 'The 1.7.1 release of the mypy tool struggles with the imports in the recipe_09
    module. We used a # type: ignore [attr-defined] comment to suppress a confusing
    mypy message.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: mypy工具的1.7.1版本在recipe_09模块的导入上遇到了困难。我们使用了# type: ignore [attr-defined]注释来抑制一个令人困惑的mypy消息。
- en: This test gives us confidence that the population of values is provided, untouched,
    to the random.choice() function and the N parameter value defines the size of
    the returned set of items from the population.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试让我们有信心，值集的总体是直接提供给random.choice()函数的，而N参数值定义了从总体中返回的项目集合的大小。
- en: 15.9.5 See also
  id: totrans-480
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.9.5 参见
- en: The [Building sets – literals, adding, comprehensions, and operators](ch008_split_001.xhtml#x1-2670007)
    recipe in Chapter [4](ch008_split_000.xhtml#x1-2240004), and the [Creating dictionaries
    – inserting and updating](ch009.xhtml#x1-2900001) recipe in Chapter [5](ch009.xhtml#x1-2890005),
    the [Using cmd to create command-line applications](ch010.xhtml#x1-3610006) recipe
    in Chapter [6](ch010.xhtml#x1-3300006) show how to seed the random number generator
    to create a predictable sequence of values.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第[4](ch008_split_000.xhtml#x1-2240004)章中的[构建集合 – 字面量、添加、列表推导和运算符](ch008_split_001.xhtml#x1-2670007)配方，第[5](ch009.xhtml#x1-2890005)章中的[创建字典
    – 插入和更新](ch009.xhtml#x1-2900001)配方，第[6](ch010.xhtml#x1-3300006)章中的[使用cmd创建命令行应用程序](ch010.xhtml#x1-3610006)配方展示了如何设置随机数生成器的种子以创建一个可预测的值序列。
- en: In Chapter [7](ch011_split_000.xhtml#x1-3760007), there are several other recipes
    that show an alternative approach, for example, [Using a class to encapsulate
    data and processing](ch011_split_000.xhtml#x1-3770001), [Designing classes with
    lots of processing](ch011_split_000.xhtml#x1-3890003), [Optimizing small objects
    with __slots__](ch011_split_001.xhtml#x1-4130007), and [Using properties for lazy
    attributes](ch011_split_001.xhtml#x1-43100010).
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在第[7](ch011_split_000.xhtml#x1-3760007)章中，有其他几个配方展示了替代方法，例如，[使用类封装数据和处理](ch011_split_000.xhtml#x1-3770001)，[设计具有大量处理的类](ch011_split_000.xhtml#x1-3890003)，[使用__slots__优化小对象](ch011_split_001.xhtml#x1-4130007)，以及[使用属性实现懒属性](ch011_split_001.xhtml#x1-43100010)。
- en: Also, in Chapter [8](ch012.xhtml#x1-4520008), see the [Choosing between inheritance
    and composition – the ”is-a” question](ch012.xhtml#x1-4530001), [Separating concerns
    via multiple inheritance](ch012.xhtml#x1-4610002), [Leveraging Python’s duck typing](ch012.xhtml#x1-4670003),
    and [Creating a class that has orderable objects](ch012.xhtml#x1-4870006) recipes.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，在第[8](ch012.xhtml#x1-4520008)章中，请参阅[在继承和组合之间选择——“是”问题](ch012.xhtml#x1-4530001)、[通过多重继承分离关注点](ch012.xhtml#x1-4610002)、[利用Python的鸭子类型](ch012.xhtml#x1-4670003)和[创建具有可排序对象的类](ch012.xhtml#x1-4870006)的配方。
- en: 15.10 Mocking external resources
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 15.10 模拟外部资源
- en: In earlier recipes in this chapter, namely, [Testing things that involve dates
    or times](ch019_split_001.xhtml#x1-8430008) and [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009),
    we wrote tests for involving resources with states that we could predict and mock.
    In one case, we created a mock datetime module that had a fixed response for the
    current time. In the other case, we created a mock function from the random module.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的配方中，即[测试涉及日期或时间的事物](ch019_split_001.xhtml#x1-8430008)和[测试涉及随机性的事物](ch019_split_001.xhtml#x1-8490009)，我们为具有可预测和模拟状态的资源编写了测试。在一个案例中，我们创建了一个具有固定当前时间响应的模拟datetime模块。在另一个案例中，我们创建了一个来自random模块的模拟函数。
- en: A Python application can use the os, subprocess, and pathlib modules to make
    significant changes to the internal states of a running computer. We’d like to
    be able to test these external requests in a safe environment, using mocked objects,
    and avoid the horror of corrupting a working system with a misconfigured test.
    Another example is database access, which requires mock objects to respond to
    create, retrieve, update, and delete requests.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Python应用程序可以使用os、subprocess和pathlib模块对正在运行的计算机的内部状态进行重大更改。我们希望能够在安全的环境中测试这些外部请求，使用模拟对象，并避免因配置不当的测试而破坏工作系统的恐怖。另一个例子是数据库访问，它需要模拟对象来响应创建、检索、更新和删除请求。
- en: In this recipe, we’ll look at ways to create more sophisticated mock objects.
    These will allow the safe testing of changes to precious OS resources like files
    and directories.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将探讨创建更复杂的模拟对象的方法。这将允许安全地测试对宝贵的OS资源（如文件和目录）的更改。
- en: 15.10.1 Getting ready
  id: totrans-488
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.1 准备工作
- en: We’ll revisit an application that makes a number of OS changes. In Chapter [11](ch015_split_000.xhtml#x1-61500011),
    the [Replacing a file while preserving the previous version](ch015_split_000.xhtml#x1-6260002)
    recipe showed how to write a new file and then rename it so that the previous
    copy was always preserved.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新访问一个进行多项OS更改的应用程序。在第[11](ch015_split_000.xhtml#x1-61500011)章中，[替换文件同时保留上一个版本](ch015_split_000.xhtml#x1-6260002)配方展示了如何编写一个新文件，然后重命名它，以便始终保留上一个副本。
- en: A thorough set of test cases would present a variety of failure modes. Having
    tests for several different kinds of errors can help provide confidence that the
    function behaves properly.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一套详尽的测试用例将展示各种故障模式。对几种不同类型的错误进行测试可以帮助我们确信该函数的行为是正确的。
- en: 'The essential design was a definition of a class of objects, Quotient, and
    a save_data() function to write one of those objects to a file. Here’s an overview
    of the code:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 核心设计是一个对象的类定义，名为Quotient，以及一个save_data()函数，用于将其中一个对象写入文件。以下是代码的概述：
- en: '[PRE84]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Consider what happens when there’s a failure in the middle of the save_data()
    function. Outcomes include a file that’s partially rewritten, and useless to other
    applications. To prevent this, the recipe presented a safe_write() function that
    included several steps to create a temporary file and then rename that file to
    be the desired output file. Essentially, the function looked like this:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到在save_data()函数中间出现故障时会发生什么。结果包括部分重写的文件，对其他应用程序无用。为了防止这种情况，配方中提出了一个safe_write()函数，该函数包括创建临时文件并将该文件重命名为所需输出文件的几个步骤。本质上，该函数看起来是这样的：
- en: '[PRE86]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The safe_write() function is shown in detail in Chapter [11](ch015_split_000.xhtml#x1-61500011).
    This is designed to handle a number of scenarios:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: safe_write()函数在第[11](ch015_split_000.xhtml#x1-61500011)章中有详细说明。它旨在处理多种场景：
- en: Everything works – sometimes called the ”happy path” – and the file is created
    properly.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一切都正常工作——有时被称为“幸福路径”——并且文件被正确创建。
- en: The save_data() function raises an exception. The corrupted file is removed
    and the original left in place.
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: save_data()函数引发异常。损坏的文件被删除，原始文件保留在原位。
- en: Failure occurs elsewhere in the processing of the safe_write() processing. There
    are three scenarios where a Path method raises an exception.
  id: totrans-500
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 故障发生在safe_write()处理过程中的其他地方。有三个场景中，Path方法会引发异常。
- en: 'Each of the above scenarios can be translated into Gherkin to help clarify
    precisely what it means; for example:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 上述每个场景都可以翻译成Gherkin来帮助精确地说明其含义；例如：
- en: '[PRE88]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Detailing each of the five scenarios helps us define Mock objects to provide
    the various kinds of external resource behaviors we need. Each scenario suggests
    a distinct fixture to reflect the distinct failure mode.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 详细说明这五个场景有助于我们定义模拟对象，以提供所需的各类外部资源行为。每个场景都建议一个独特的固定装置来反映不同的故障模式。
- en: 15.10.2 How to do it...
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.2 如何做到...
- en: 'We’ll use a variety of testing techniques. The pytest package offers the tmp_path
    fixture, which can be used to create isolated files and directories. In addition
    to an isolated directory, we’ll also want to use a Mock to stand in for the parts
    of the application that we’re not testing:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用各种测试技术。pytest包提供了tmp_path固定装置，可以用来创建隔离的文件和目录。除了隔离目录外，我们还想使用模拟来代替我们未测试的应用程序部分：
- en: Identify all of the fixtures required for the various scenarios. For the happy
    path, where the mocking is minimal, the tmp_path fixture is all we need. For scenario
    two, where the save_data() function is broken, this function should be mocked.
    For the remaining three scenarios, mock objects can be defined that will replace
    methods of Path objects.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定各种场景所需的全部固定装置。对于快乐的路径，即模拟最少的情况，我们只需要tmp_path固定装置。对于第二个场景，即save_data()函数出现故障的情况，这个函数应该被模拟。对于剩余的三个场景，可以定义模拟对象来替换Path对象的方法。
- en: 'This test will use a number of features from the pytest and unittest.mock modules.
    It will be creating Path objects and test functions defined in the recipe_10 module:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个测试将使用pytest和unittest.mock模块的多个功能。它将在recipe_10模块中创建Path对象和定义的测试函数：
- en: '[PRE89]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Write a test fixture to create the original file, which should not be disturbed
    unless everything works correctly. We’ll use a sentinel object to provide some
    text that is unique and recognizable as part of this test scenario:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个测试固定装置来创建原始文件，除非一切正常，否则不应被干扰。我们将使用哨兵对象提供一些独特且可识别的文本，作为本测试场景的一部分：
- en: '[PRE90]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Write a mock to replace the save_data() function. This will create mock data
    used to validate that the safe_write() function works. In this, too, we’ll use
    a sentinel object to create a unique string that is recognizable later in the
    test:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个模拟来替换save_data()函数。这将创建用于验证safe_write()函数是否正常工作的模拟数据。在此，我们也将使用哨兵对象来创建一个在测试中可识别的唯一字符串：
- en: '[PRE91]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Write the happy path scenario. The save_data_good() function can be given as
    the side_effect of a Mock object and used in place of the original save_data()
    function. Using a Mock means the call history will be tracked. This helps to confirm
    that the overall safe_write() function being tested really does use the save_data()
    function to create the expected resulting file:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写快乐的路径场景。可以将save_data_good()函数作为模拟对象的副作用，并用来替代原始的save_data()函数。使用模拟意味着将跟踪调用历史，这有助于确认正在测试的整体safe_write()函数确实使用了save_data()函数来创建预期的结果文件：
- en: '[PRE92]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Write a mock for scenario two, in which the save_data() function fails to work
    correctly. The mock can rely on a save_data_failure() function to write recognizably
    corrupt data, and then also raise an unexpected exception:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写第二个场景的模拟，其中save_data()函数无法正确工作。模拟可以依赖于save_data_failure()函数来写入可识别的损坏数据，然后也引发一个意外的异常：
- en: '[PRE93]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Write the test case for scenario two, using the save_data_failure() function
    as the side_effect of a Mock object:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用save_data_failure()函数作为模拟对象的副作用，编写第二个场景的测试用例：
- en: '[PRE94]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The save_data_failure() function wrote corrupt data, but the safe_write() function
    preserved the original file.
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: save_data_failure()函数写入了损坏的数据，但safe_write()函数保留了原始文件。
- en: This recipe produced two test scenarios that confirm the safe_write() function
    will work. We’ll turn to the remaining three scenarios in the There’s more… section
    later in this recipe.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方产生了两个测试场景，确认safe_write()函数将正常工作。我们将在本配方中的“还有更多...”部分稍后讨论剩余的三个场景。
- en: 15.10.3 How it works...
  id: totrans-521
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.3 它是如何工作的...
- en: When testing software that makes OS, network, or database requests, it’s imperative
    to include cases where the external resource fails to operate as expected. The
    principal tools for doing this are Mock objects and the monkeypatch fixture. A
    test can replace Python library functions with Mock objects that raise exceptions
    instead of working correctly.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试制作操作系统、网络或数据库请求的软件时，包括外部资源无法按预期操作的情况的测试案例是至关重要的。完成这项工作的主要工具是 Mock 对象和 monkeypatch
    夹具。一个测试可以用引发异常而不是正确工作的 Mock 对象替换 Python 库函数。
- en: For the happy path scenario, we replaced the save_data() function with a Mock
    object that wrote some recognizable data. Because we’re using the tmp_path fixture,
    the file was written into a safe, temporary directory, where it could be examined
    to confirm that new, good data replaced the original data.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 对于愉快的路径场景，我们用 Mock 对象替换了 save_data() 函数，并写入了一些可识别的数据。因为我们使用了 tmp_path 夹具，所以文件被写入到一个安全、临时的目录中，可以检查以确认新、良好的数据替换了原始数据。
- en: For the first of the failure scenarios, we used the monkeypatch fixture to replace
    the save_data() function with a function that both wrote corrupt data and also
    raised an exception as if an OS problem occurred. This is one way to simulate
    a broad spectrum of application failures that involve some kind of persistent
    filesystem artifact. In simpler cases, where there is no artifact, a Mock object
    with an exception class as the value of the side_effect parameter is all that’s
    required to simulate a failure.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个故障场景，我们使用 monkeypatch 夹具替换了 save_data() 函数，用一个既写入损坏数据又引发异常（仿佛发生了操作系统问题）的函数。这是模拟涉及某种持久文件系统实体的广泛应用程序故障的一种方法。在更简单的情况下，如果没有实体，只需要一个具有异常类作为
    side_effect 参数值的 Mock 对象来模拟故障。
- en: These test scenarios also made use of unique sentinel objects. Evaluating the
    value of the hex(id(x)) provides a distinct string value that’s difficult to predict.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这些测试场景还使用了独特的哨兵对象。评估 hex(id(x)) 的值提供了一个难以预测的独特字符串值。
- en: 15.10.4 There’s more...
  id: totrans-526
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.4 更多内容...
- en: 'The remaining scenarios are very similar; they can all share the following
    test function:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的场景非常相似；它们都可以共享以下测试函数：
- en: '[PRE95]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This function uses the save_data_good() function as the side effect when the
    mocked save_data() function is invoked. The given save_data_good() function will
    be executed and will write a known good test file. Each of these scenarios involve
    exceptions from Path operations after the good file was created.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用模拟的 save_data() 函数时，此函数使用 save_data_good() 函数作为副作用。给定的 save_data_good() 函数将被执行，并将写入一个已知良好的测试文件。这些场景中的每一个都涉及在创建良好文件之后的路径操作异常。
- en: We’ve omitted showing any scenario-specific details. The key feature of this
    test is preserving the original good data in spite of exceptions.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了展示任何特定场景的细节。这个测试的关键特性是即使在出现异常的情况下也能保留原始的良好数据。
- en: To support multiple exception scenarios, we want to use three different versions
    of the mock_pathlib_path mock object.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持多个异常场景，我们希望使用三个不同版本的 mock_pathlib_path 模拟对象。
- en: 'We can use a parameterized fixture to spell out these three alternative configurations
    of the mock objects. First, we’ll package the choices as three separate dictionaries
    that provide the side_effect values:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用参数化夹具来指定这些模拟对象的三个替代配置。首先，我们将选择打包为三个单独的字典，提供 side_effect 值：
- en: '[PRE96]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We’ve used RuntimeError as the exception to raise, triggering alternative execution
    paths. In some cases, it may be necessary to use a IOError exception. In this
    case, any exception would be fine.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用 RuntimeError 作为引发异常，以触发替代执行路径。在某些情况下，可能需要使用 IOError 异常。在这种情况下，任何异常都行。
- en: 'Given these three dictionary objects, we can plug the values into a fixture
    via the request.params option provided by pytest:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这三个字典对象，我们可以通过 pytest 提供的 request.params 选项将值插入到夹具中：
- en: '[PRE97]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Because this fixture has three parameter values, any test using this fixture
    will be run three times, once with each of the values. This lets us reuse the
    test_safe_write_scenarios() test case to be sure it works with a variety of system
    failures.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个夹具有三个参数值，任何使用这个夹具的测试都将运行三次，每次使用其中一个值。这使得我们可以重用 test_safe_write_scenarios()
    测试用例，以确保它能够与各种系统故障一起工作。
- en: We’ve created a variety of mock objects to inject failures throughout the processing
    in a complex function. Using parameterized fixture helps to define consistent
    mock objects for these tests.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了许多 Mock 对象，以在复杂函数的处理过程中注入故障。使用参数化夹具有助于为这些测试定义一致的 Mock 对象。
- en: There’s yet another scenario that involves a successful operation followed by
    a failing operation on the same file. This doesn’t fit the above pattern and requires
    another test case with a slightly more sophisticated set of mock objects. We leave
    this as an exercise for you.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种场景涉及对同一文件的成功操作随后是失败操作。这不符合上述模式，需要另一个稍微复杂一些的模拟对象测试用例。我们将这个作为你的练习。
- en: 15.10.5 See also
  id: totrans-540
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 15.10.5 参见
- en: The [Testing things that involve dates or times](ch019_split_001.xhtml#x1-8430008)
    and [Testing things that involve randomness](ch019_split_001.xhtml#x1-8490009)
    recipes earlier in this chapter show techniques for dealing with unpredictable
    data.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章前面的[测试涉及日期或时间的项目](ch019_split_001.xhtml#x1-8430008)和[测试涉及随机性的项目](ch019_split_001.xhtml#x1-8490009)的食谱展示了处理不可预测数据的技术。
- en: Elements of this can be tested with the doctest module. See the [Using docstrings
    for testing](ch019_split_000.xhtml#x1-7950001) recipe earlier in this chapter
    for examples. It’s also important to combine these tests with any doctests. See
    the [Combining pytest and doctest tests](ch019_split_001.xhtml#x1-8370007) recipe
    earlier in this chapter for more information on how to do this.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用doctest模块测试这些元素。参见本章前面的[使用docstrings进行测试](ch019_split_000.xhtml#x1-7950001)食谱中的示例。同时结合这些测试与任何doctests也很重要。参见本章前面的[结合pytest和doctest测试](ch019_split_001.xhtml#x1-8370007)食谱，了解更多如何进行这种结合的信息。
- en: Join our community Discord space
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的社区Discord空间
- en: 'Join our Python Discord workspace to discuss and find out more about the book:
    [https://packt.link/dHrHU](https://packt.link/dHrHU)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的Python Discord工作空间，讨论并了解更多关于这本书的信息：[https://packt.link/dHrHU](https://packt.link/dHrHU)
- en: '![PIC](img/file1.png)'
  id: totrans-545
  prefs: []
  type: TYPE_IMG
  zh: '![PIC](img/file1.png)'
