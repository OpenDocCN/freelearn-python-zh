- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Splitting the Monolith
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分割单体
- en: In the previous chapter, we created a monolithic application to serve as an
    assistant; we did so rapidly, concentrating on adding features rather than long-term
    architecture. There is nothing wrong with that approach—after all if the application
    never needs to scale up then the engineering effort is wasted.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个单体应用程序作为助手；我们这样做非常迅速，专注于添加功能而不是长期架构。这种做法没有错——毕竟，如果应用程序永远不需要扩展，那么工程努力就是浪费。
- en: 'But let us assume that our service is very popular, and the number of requests
    it receives is growing. We now have to make sure it performs well under load,
    and also ensure that it is easy to maintain for a growing team of developers.
    How should we proceed from here? In this chapter, we will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们假设我们的服务非常受欢迎，接收到的请求数量正在增长。我们现在必须确保它在负载下表现良好，同时也确保它对不断增长的开发团队来说易于维护。我们应该如何继续？在本章中，我们将：
- en: Examine how to identify the best components to migrate to a new microservice
    based on code complexity and data we collect about usage
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查如何根据代码复杂度和我们收集的使用数据来确定迁移到新微服务的最佳组件
- en: Show techniques for preparing and performing that migration, as well as checking
    on its success
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示准备和执行迁移的技术，以及检查其成功情况
- en: Identifying potential microservices
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别潜在的微服务
- en: For an application that is familiar to us, we might have a lot of intuition
    about which components are overloaded or unreliable. After all, either we wrote
    it, or have rewritten large parts of it, and tested it, along with making decisions
    about its architecture. It's also natural to have made notes about the database
    growing larger, or noticing that one particular function takes a long time to
    run during testing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们熟悉的应用程序，我们可能对哪些组件过载或不稳定有很多直觉。毕竟，要么我们编写了它，要么我们重写了它的大部分内容，并对其进行了测试，同时对其架构做出了决策。在数据库变得更大或注意到在测试期间某个特定函数运行时间过长时，做笔记也是自然的。
- en: 'Our own intuition may lead us astray, however, and it is a good idea to let
    our decisions be informed by the data we collect. Developers and operations people
    will have specific questions that should be answered to make a decision about
    the future direction of a service. Product management and other business-oriented
    people will also have questions that need answering, which are often not specific
    to the technology. Questions a developer may ask include:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的直觉可能会误导我们，因此让我们的决定受到我们收集的数据的指导是一个好主意。开发人员和运维人员将会有具体的问题需要回答，以便决定服务的未来方向。产品管理和其他面向业务的人员也会有需要回答的问题，这些问题通常不特定于技术。开发者可能提出的问题包括：
- en: How fast are responses to HTTP requests?
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP请求的响应速度有多快？
- en: What are the success and error rates on HTTP requests for different endpoints?
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不同的端点，HTTP请求的成功率和错误率是多少？
- en: Which parts of the system are troublesome when making changes?
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在进行更改时，系统的哪些部分是麻烦的？
- en: How many active connections does a component have to deal with, on average,
    at peak use?
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在峰值使用时，一个组件平均需要处理多少个活动连接？
- en: 'Some non-technical business questions to consider are:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一些需要考虑的非技术性业务问题包括：
- en: Does a slow response mean a user will stop checking with our Slack bot and start
    using other tools instead?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 慢速响应是否意味着用户将停止使用我们的Slack机器人检查，并开始使用其他工具？
- en: In a web-based shop, what is the conversion rate—that is, how many customers
    viewed items, compared to how many bought something?
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个基于网络的商店中，转化率是多少——也就是说，有多少客户查看了商品，与有多少人购买了东西相比？
- en: How accurate and up to date is the information we provide through the service?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过服务提供的信息有多准确和及时？
- en: 'For our discussion, we will focus on technical questions, but it is always
    worth remembering why software exists, and how best to answer the questions put
    forward by the people who need an application—as well as the people who produce
    it. To make our decisions about splitting our monolithic application, we will
    keep two questions in mind:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的讨论中，我们将关注技术问题，但始终值得记住软件存在的目的以及如何最好地回答需要应用程序的人以及生产它的人提出的问题。为了做出关于分割我们的单体应用程序的决定，我们将牢记两个问题：
- en: Which components are the slowest and cause the most delays when they are run?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当运行时，哪些组件最慢，导致最多的延迟？
- en: Which components are tightly coupled to the rest of the application, and so
    fragile when changed?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些组件与应用程序的其他部分紧密耦合，因此在更改时变得脆弱？
- en: Two terms often heard are *data-driven* and *data-informed*. To be data-driven
    involves collecting data about a situation and always basing decisions on that
    information. Being data-informed also involves collecting data, but using it alongside
    personal experience and knowledge of the wider situation.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 经常听到的两个术语是**数据驱动**和**数据信息**。要成为数据驱动，意味着收集关于某个情况的数据，并始终基于该信息做出决策。成为数据信息也涉及收集数据，但将其与个人经验和更广泛情况的知识相结合使用。
- en: There are many aspects to software and what it does—network connections, reading
    files, querying databases, and so on. It is tempting to think that collecting
    everything and looking for patterns in the data will be the best way to monitor
    the application. There is often too much data to sift through, however, and too
    many variables to account for. Instead, we should start with a qualitative question.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 软件及其功能有许多方面——网络连接、读取文件、查询数据库等等。认为收集所有信息并在数据中寻找模式将是监控应用程序的最佳方式是很诱人的。然而，通常有太多数据需要筛选，以及太多变量需要考虑。相反，我们应该从定性问题开始。
- en: However, the question should not be, "which parts of the application would work
    as a microservice?"; instead, we should consider questions such as "which parts
    of the application are having the most impact on performance?" and "which parts
    of the application are difficult to change?" The answer might be a microservice—and
    since this book is about that option, we will investigate it in depth—but there
    are other performance problems that can arise, and other solutions, such as optimizing
    a database or caching common query results.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，问题不应该是“哪些应用程序的部分可以作为微服务运行？”；相反，我们应该考虑诸如“哪些应用程序的部分对性能影响最大？”和“哪些应用程序的部分难以更改？”等问题。答案可能是微服务——既然本书是关于这个选项的，我们将深入探讨它——但还可能存在其他性能问题，以及其他解决方案，例如优化数据库或缓存常见查询结果。
- en: Let us look at some ways that we can identify the parts of an application that
    need refactoring, and that would make good microservices.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些方法，我们可以识别出应用程序中需要重构的部分，以及哪些部分适合作为微服务。
- en: Code complexity and maintenance
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码复杂度和维护
- en: As we discussed in *Chapter 1*, *Understanding Microservices*, as the size of
    a project increases it becomes more difficult to reason about, especially for
    people new to the team. Keeping different logical parts of the system separate
    and having a clean interface between them helps us think more effectively about
    the interactions between all the different components—making it easier to understand
    where to make changes—without having to worry about accidentally breaking something
    in code that seems unrelated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在**第一章**中讨论的，在理解微服务时，随着项目规模的增加，推理变得更加困难，尤其是对于新加入团队的人来说。保持系统不同逻辑部分的分离，并在它们之间保持清晰的接口，有助于我们更有效地思考所有不同组件之间的交互——使理解在哪里进行更改变得更容易——而无需担心意外破坏看似无关的代码。
- en: 'Many of the decisions made when looking at maintenance will be based on experience:
    when reading the code, developers get a sense of what areas they understand well,
    and which areas they do not, as well as how risky it is to change various parts
    of a project.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看维护时做出的许多决策将基于经验：在阅读代码时，开发者会感觉到哪些区域他们理解得很好，哪些区域他们不熟悉，以及更改项目各个部分的风险程度。
- en: We can also take a data-informed approach by using tools that assess the **cyclomatic
    complexity** of the code. Cyclomatic complexity is a software metric, developed
    in the 1970s, to assess how many branches and paths of code execution a program
    has. Understanding the mathematics is outside the scope of this book, so for our
    purposes we should understand that a higher score indicates more complex code,
    and code that scores 1.0 has no decisions in it at all.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过使用评估代码**循环复杂度**的工具来采取数据驱动的策略。循环复杂度是一个软件度量，于20世纪70年代开发，用于评估程序有多少代码执行分支和路径。理解数学原理超出了本书的范围，因此，为了我们的目的，我们应该理解分数越高表示代码越复杂，而得分为1.0的代码则完全没有决策。
- en: '**Radon** ([https://pypi.org/project/radon/](https://pypi.org/project/radon/))
    is a Python tool for quickly assessing code complexity; it also groups the complexity
    scores into bands, similar to academic grades such as A through F. Since our examples
    so far have been simple, let''s run `Radon` against `Quart` itself.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Radon** ([https://pypi.org/project/radon/](https://pypi.org/project/radon/))
    是一个用于快速评估代码复杂度的Python工具；它还将复杂度评分分组到不同的区间，类似于A到F的学术等级。由于我们之前的示例都很简单，让我们运行`Radon`对`Quart`本身进行评估。'
- en: 'Here, we tell Radon to calculate the cyclomatic complexity and only report
    on those areas that have a complexity rating of C or worse:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们告诉Radon计算循环复杂度，并且只报告那些复杂度评分为C或更差的区域：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It's easy to think that a high-complexity function is always bad, but that's
    not necessarily the case. We should strive for simplicity, but not over-simplification
    to the point where we lose usefulness in the software. We should use scores like
    these as guides for our decisions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 容易认为高复杂度的函数总是不好的，但情况并不一定如此。我们应该追求简单，但不要过度简化到失去软件中的实用性。我们应该将这些分数作为我们决策的指南。
- en: Now, we will look at other sorts of data we can collect about our code, to help
    us make informed decisions.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨我们可以收集的其他关于我们代码的数据，以帮助我们做出明智的决策。
- en: Metrics and Monitoring
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指标和监控
- en: 'It is easy to think of monitoring tools as being useful to alert us when something
    is broken, but there are other valuable uses. **Operational health** monitoring
    relies on a wide range of high-resolution metrics that arrive with low latency
    to allow us to notice and fix problems with the system. To determine if a change
    in architecture is needed, we might look at the operational health of a service,
    but we also want to look at the service''s quality: **quality assurance** discovers
    whether or not the service is meeting our standards.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 容易认为监控工具在提醒我们有问题时是有用的，但还有其他有价值的用途。**操作健康**监控依赖于一系列高分辨率指标，这些指标以低延迟到达，使我们能够注意到并修复系统中的问题。为了确定是否需要更改架构，我们可能会查看服务的操作健康，但我们还希望查看服务的质量：**质量保证**发现服务是否满足我们的标准。
- en: How is this different from operational health? In a complex system, there can
    be components that are unreliable or slow, but the overall performance of the
    system is acceptable to the people using it. If we ask software to send an email
    for us, and it arrives ten seconds later, then most people would consider that
    quality of service acceptable, even if behind the scenes there are numerous failed
    nodes, connection timeouts, and retrying operations. Such a service is working
    but needs maintenance, or it will continue with a higher risk of a large outage
    or lack of burst capacity.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这与操作健康有何不同？在一个复杂的系统中，可能会有不可靠或运行缓慢的组件，但系统的整体性能对于使用它的人来说是可以接受的。如果我们要求软件为我们发送电子邮件，并且它晚十秒钟到达，那么大多数人会认为这种服务质量是可以接受的，即使幕后有大量的失败节点、连接超时和重试操作。这样的服务正在运行，但需要维护，否则它将继续以更高的风险出现大规模故障或缺乏突发容量。
- en: 'Gathering data about what our application is doing leaves us more informed
    about which components need attention, which are slow, and which are responding
    well. What does it mean to take a measurement? It has historically been tricky
    to pin down a good definition. Psychologist Stanley Smith Stevens, however, describes
    it in a useful way:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 收集关于我们的应用程序正在做什么的数据，使我们更了解哪些组件需要关注，哪些运行缓慢，哪些响应良好。进行测量的意义是什么？从历史上看，确定一个良好的定义一直很棘手。然而，心理学家斯坦利·史密斯·史蒂文斯以有用的方式描述了它：
- en: Measurement, in the broadest sense, is defined as the assignment of numerals
    to objects and events according to rules.
  id: totrans-37
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在最广泛的意义上，测量被定义为根据规则将数字分配给对象和事件。
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —On the Theory of Scales of Measurement, S. S. Stevens (1946)
  id: totrans-39
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——《测量尺度理论》，S. S. Stevens（1946年）
- en: What is a good measurement to make? Giving a firm answer to this is difficult
    too, although for our purposes, there are three main categories of data we could
    collect. The first is gauges, which are an absolute measure at a certain point
    in time. A fuel gauge in a car will tell you how much fuel is remaining, and a
    tool such as netstat will tell you how many open network connections a server
    has. Inside a service, a measurement, such as the number of active connections,
    is a gauge.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 做一个好的测量是什么？对这个问题的明确回答也很困难，尽管为了我们的目的，我们可以收集三种主要类型的数据。第一种是仪表，它是在某个时间点的绝对度量。汽车中的燃油表会告诉你剩余多少燃料，而像netstat这样的工具会告诉你服务器有多少个打开的网络连接。在服务内部，一个测量值，如活动连接数，就是一个仪表。
- en: Counters are measurements that continue to grow incrementally and cumulatively—you
    will often see measurements about the amount of network traffic or disk I/O as
    a counter. Whenever you ask the kernel how many bytes have been transferred out
    of a network interface, you will get a number that doesn't mean much by itself,
    as it will be the total amount of traffic since counting started. But ask again
    one second later, subtract one number from the other, and now you have a value
    that is bytes per second. Unix tools such as `iostat` and `vmstat` do this for
    you, which is why the first set of numbers they display is often very high and
    should be discounted.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器是持续增长和累积的测量值——你经常会看到关于网络流量或磁盘I/O的测量值作为计数器。无论何时你询问内核从网络接口传输了多少字节，你都会得到一个本身没有太多意义的数字，因为它将是自计数开始以来的总流量。但一秒后再问一次，从另一个数字中减去一个，现在你就有了一个每秒字节的值。Unix工具如`iostat`和`vmstat`会为你做这件事，这就是为什么它们显示的第一组数字通常非常高，应该被忽略。
- en: It is important to understand what your gauges and counters are collecting,
    as it changes the ways in which they can be used. Taking an average value—mostly
    the mean, but sometimes a median—usually gives us a meaningful number. If we record
    that, in the last second, our laptop's six CPU cores have used 0, 0, 0, 1, 1,
    and 1 seconds of CPU time, it makes sense to say our average CPU usage is 50%.
    It is also reasonable to say that we have used a sum of three seconds of CPU time
    in the last one second. However, if we are measuring the temperature of our laptop
    and its three sensors tell us the values of 65, 70, and 75^°C, the average value
    is still useful, but it would be meaningless to say the total temperature is 210
    degrees!
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 理解你的仪表和计数器正在收集什么信息很重要，因为它会改变它们的使用方式。取平均值——通常是平均值，但有时是中位数——通常给我们一个有意义的数字。如果我们记录在最后1秒内，我们的笔记本电脑的六个CPU核心使用了0、0、0、1、1和1秒的CPU时间，那么说我们的平均CPU使用率为50%是有意义的。同样，如果我们测量笔记本电脑的温度，并且其三个传感器告诉我们65、70和75°C的值，那么平均值仍然是有用的，但说总温度是210度就没有意义了！
- en: Ratios are the third category of data we are concerned about. These describe
    how the other measurements relate to one another. We have already seen a useful
    ratio when discussing counters, as "the number of bytes transferred" divided by
    "the time it took" gives us a ratio, as does "the number of bytes transferred"
    divided by the number of API calls.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 比率是我们关心的第三类数据。这些描述了其他测量值之间的关系。在讨论计数器时，我们已经看到了一个有用的比率，即“传输的字节数”除以“所需时间”给出了一个比率，同样“传输的字节数”除以API调用次数也给出了一个比率。
- en: 'Choosing what metrics to collect is often a difficult choice, as there are
    so many possibilities. It is best to start with specific questions and work toward
    answering them, rather than trying to collect everything at once. If people report
    that our application is slow, then we need to discover what parts are slow to
    respond, and why. Thankfully we can start with two of the easiest things to monitor
    in a web application:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要收集哪些指标通常是一个困难的选择，因为可能性有很多。最好从具体问题开始，朝着解答它们的方向努力，而不是试图一次性收集所有内容。如果人们报告我们的应用程序运行缓慢，那么我们需要找出哪些部分响应缓慢，以及原因是什么。幸运的是，我们可以从在Web应用程序中监控的两种最容易的事情开始：
- en: Counting how many times each endpoint is visited
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计数每个端点被访问的次数
- en: How long each endpoint takes to finish processing a request
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个端点完成请求处理所需的时间
- en: Once we have information about these two things, this will hopefully direct
    us to a specific endpoint that is overloaded, or that takes too long to process
    requests and falls behind. If it doesn't help, then we need to start investigating
    similar high-level information about other components of the system, such as the
    database or network throughput. To investigate this in a cloud-agnostic way, we
    will turn to a common tool for operational monitoring, called **Prometheus** ([https://prometheus.io/](https://prometheus.io/)).
    Prometheus operates by scraping endpoints—we configure it with some URLs to query,
    and it expects some metrics to be returned when it sends a request. To easily
    integrate metrics into our application, we can use the `aioprometheus` library.
    Its documentation can be found at [https://aioprometheus.readthedocs.io/en/latest/](https://aioprometheus.readthedocs.io/en/latest/).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了这两方面的信息，这可能会引导我们到一个特定的端点，该端点过载，或者处理请求太慢而落后。如果不起作用，那么我们需要开始调查系统其他组件的类似高级信息，例如数据库或网络吞吐量。为了以云无关的方式调查这个问题，我们将转向一个称为**Prometheus**（[https://prometheus.io/](https://prometheus.io/)）的通用操作监控工具。Prometheus通过抓取端点来操作——我们通过一些查询URL来配置它，并且它期望在发送请求时返回一些指标。为了轻松地将指标集成到我们的应用程序中，我们可以使用`aioprometheus`库。其文档可以在[https://aioprometheus.readthedocs.io/en/latest/](https://aioprometheus.readthedocs.io/en/latest/)找到。
- en: 'To begin with, we will have to set up the metrics that we want to collect.
    For now, let''s assume that we are interested in how many concurrent requests
    an endpoint is responding to, and how long each request takes. We can use `aioprometheus`
    to set up a `Registry` object to store these until a Prometheus server asks for
    the information. The number of active requests is a gauge, since it is a snapshot
    of the current state at a single point in time. The duration of each request is
    recorded as a `Summary` object, as once the data is in Prometheus, we will want
    to aggregate it, and perhaps look at the distribution of values. We can create
    both registries and then add them to our application:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们想要收集的指标。目前，让我们假设我们感兴趣的是端点正在响应多少并发请求，以及每个请求需要多长时间。我们可以使用`aioprometheus`来设置一个`Registry`对象来存储这些信息，直到Prometheus服务器请求这些信息。活跃请求的数量是一个仪表，因为它是在某个时间点的当前状态的快照。每个请求的持续时间被记录为一个`Summary`对象，因为一旦数据进入Prometheus，我们希望对其进行聚合，并可能查看值的分布。我们可以创建这两个注册表，然后将它们添加到我们的应用程序中：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We also need to add an endpoint for Prometheus to reach our application and
    ask for the metrics that have been collected. `aioprometheus` also provides a
    `render` function to generate this data for us, and so the metrics handler is
    short:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要添加一个端点，让Prometheus能够访问我们的应用程序并请求收集的指标。`aioprometheus`还提供了一个`render`函数来为我们生成这些数据，因此指标处理程序很短：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once that is done, we can make use of some helper functions provided by `aioprometheus`
    to record the duration of a function, and also to automatically increment and
    decrement a gauge. The contents of the function here are just to provide some
    content that takes some time—we will sleep for between 1 and 1.5 seconds to generate
    a set of values for how long the response takes. Let''s add it all together into
    a working example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，我们可以利用`aioprometheus`提供的辅助函数来记录函数的持续时间，以及自动增加和减少仪表。这里函数的内容只是为了提供一些需要花费一些时间的内容——我们将睡眠1到1.5秒来生成一组响应所需时间的值。让我们将所有这些整合到一个工作示例中：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For a production service, the metrics collection service is another component
    that needs to be deployed and managed; however, for our own experiments while
    developing, a local copy of Prometheus is enough, and we can run it in a container.
    If we set up a basic configuration file, we will need to make sure that the targets
    match the IP address of the computer we are running our application on—it cannot
    be localhost, as Prometheus is running inside its own container, and so traffic
    to localhost will never leave that container. Here is our configuration, which
    we can place in a file called `prometheus.yml`, which we will then include in
    the container:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产服务，指标收集服务是另一个需要部署和管理的组件；然而，在我们开发自己的实验时，Prometheus的本地副本就足够了，我们可以在容器中运行它。如果我们设置了一个基本的配置文件，我们需要确保目标匹配我们运行应用程序的计算机的IP地址——它不能是localhost，因为Prometheus在其自己的容器内运行，因此流量永远不会离开该容器。以下是我们的配置，我们可以将其放置在一个名为`prometheus.yml`的文件中，然后将其包含在容器中：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we run Prometheus and visit the web interface, which, if you are running
    the container on your laptop, will be at `http://localhost:9090/`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们运行Prometheus并访问Web界面，如果你在笔记本电脑上运行容器，它将在`http://localhost:9090/`：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '*Figure 5.1* shows the data we collect after running a series of queries against
    our running application, using the **Boom** ([https://github.com/tarekziade/boom](https://github.com/tarekziade/boom))
    tool that we introduced in *Chapter 3*, *Coding, Testing, and Documentation: the
    Virtuous Cycle*, when discussing load testing. Because we randomized which endpoints
    we call in the test, we can see the different rates of use in the graph. The Prometheus
    query asks for the rate of the number of active requests each minute, using the
    name of the gauge we set above in `quart_metrics.py`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*图5.1*显示了我们对运行中的应用程序运行一系列查询后收集的数据，使用的是我们在*第3章*，“编码、测试和文档：良性循环”中讨论负载测试时介绍的**Boom**
    ([https://github.com/tarekziade/boom](https://github.com/tarekziade/boom))工具。由于我们在测试中随机化了调用的端点，我们可以看到图中的不同使用率。Prometheus查询请求每分钟活动请求数量的速率，使用我们在`quart_metrics.py`中设置的仪表名称。'
- en: 'More information about querying Prometheus can be found here: [https://prometheus.io/docs/prometheus/latest/getting_started/](https://prometheus.io/docs/prometheus/latest/getting_started/).'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于查询Prometheus的更多信息，请在此处查看：[https://prometheus.io/docs/prometheus/latest/getting_started/](https://prometheus.io/docs/prometheus/latest/getting_started/)。
- en: '![image2.png](img/B17108_05_01.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![image2.png](img/B17108_05_01.png)'
- en: 'Figure 5.1: An example of Prometheus showing how many active requests each
    endpoint is serving'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：Prometheus显示每个端点正在服务的活动请求数量的示例
- en: Now we have a much clearer picture of how many times each endpoint in our API
    is queried, and how long those requests take. We could also add extra metrics,
    such as how much CPU time is used, how much memory is consumed, or how long we
    are waiting for other network calls to complete. Data like this helps us pinpoint
    exactly which parts of our application consume the most resources, and which have
    trouble scaling up.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对API中每个端点被查询的次数以及这些请求所需的时间有了更清晰的了解。我们还可以添加额外的指标，例如CPU使用时间、内存消耗量或我们等待其他网络调用完成的时间。这样的数据有助于我们精确地找出应用程序中哪些部分消耗了最多的资源，哪些部分在扩展时遇到困难。
- en: Logging
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: Numbers can tell us a lot about what's going on in an application, but not the
    whole story. We also need to use logging, which is the act of producing some text
    or data that will be recorded, but is not part of the essential operation of the
    software. This does not mean that logging isn't important—it is—but the application
    could run happily without any messages being written out.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以告诉我们应用程序中发生了很多事情，但不是全部。我们还需要使用日志记录，这是产生将被记录的某些文本或数据的行为，但它不是软件基本操作的一部分。这并不意味着日志不重要——它很重要——但应用程序可以在没有任何消息输出的情况下正常运行。
- en: Once we have an idea of which parts of a system are operating slowly, the next
    question is going to be "what, exactly, is it doing?" Reading the code will only
    give us part of the answer—logging will give us the rest, by recording which decisions
    were taken, what data was sent, and what errors were encountered.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们了解系统哪些部分运行缓慢，接下来的问题将是“它到底在做什么？”阅读代码只能给我们部分答案——通过记录所做的决策、发送的数据和遇到的错误，日志记录将给我们其余的答案。
- en: Recording absolutely everything will increase the I/O requirements of the application,
    either sending those messages across the network or using up disk resources writing
    the files locally. We should carefully consider what gets written out, and why.
    This is especially true when log messages might contain sensitive information,
    such as personal details about people or passwords. For a service running in production,
    logs should be sanitized whenever possible, removing anything that might leak
    personal data.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 记录所有内容将增加应用程序的I/O需求，无论是通过网络发送这些消息还是使用磁盘资源在本地写入文件。我们应该仔细考虑要写入的内容以及原因。当日志消息可能包含敏感信息，如关于个人或密码的详细信息时，这一点尤其正确。对于在生产中运行的服务，应尽可能对日志进行清理，移除可能泄露个人数据的任何内容。
- en: Python has powerful logging options that can automatically format messages for
    us, and filter the messages based on their severity. The log message's severity
    is graded on a scale of debug, info, warning, error, and critical, which allows
    us to easily change how many messages our application produces with one setting,
    instead of changing each line that produces a message.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Python拥有强大的日志选项，可以自动为我们格式化消息，并根据消息的严重性进行过滤。日志消息的严重性按调试、信息、警告、错误和严重等级别划分，这使得我们可以通过一个设置轻松地更改应用程序产生的消息数量，而不是逐行更改产生消息的代码。
- en: 'Quart provides an interface that allows the use of Python''s built-in logging
    with ease, within the application. Let''s take a look at a basic example where
    we use `app.logger` to produce log messages whenever `hello_handler` is called:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Quart提供了一个接口，允许在应用程序中轻松使用Python的内置日志记录。让我们看看一个基本示例，其中我们使用`app.logger`在`hello_handler`被调用时产生日志消息：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When we run our application and the `/hello` endpoint is queried, `Quart` will
    display one extra message in the terminal where it is running:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序，并且查询`/hello`端点时，`Quart`将在其运行的终端中显示一条额外的消息：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Why only one message? The second call is using the "debug" severity, and we
    set the log level to `INFO` so that only messages of informational importance
    and above are produced. If we want our debugging messages to appear, we can change
    `app.logger.setLevel(logging.INFO)` to `app.logger.setLevel(logging.DEBUG)`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么只有一个消息？第二次调用使用了“调试”严重性，而我们设置了日志级别为`INFO`，因此只有信息重要性和以上的消息会被产生。如果我们想让调试消息显示出来，我们可以将`app.logger.setLevel(logging.INFO)`改为`app.logger.setLevel(logging.DEBUG)`。
- en: While there is a specific format to our log messages so far, what gets produced
    is still a single text string. This can be awkward to process if you have a program
    that wants to examine the log entries for important errors or find patterns in
    what is happening.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们的日志消息目前有一个特定的格式，但产生的仍然是一个单一的文本字符串。如果有一个程序想要检查日志条目中的重要错误或寻找事件中的模式，这可能会很尴尬。
- en: 'For log messages that should be readable by a computer, structured logging
    is the best option. Structured logging is commonly a log message produced in JSON
    format, so that the date, text description, source of the message, and any other
    metadata are all separate fields in the JSON. Python''s `structlog` library does
    a good job of formatting the output correctly, and also makes it easy to add processors
    to the log message to censor names, passwords, and other similar private information:
    [https://www.structlog.org/en/stable/index.html](https://www.structlog.org/en/stable/index.html).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应该由计算机读取的日志消息，结构化日志是最佳选择。结构化日志通常是以JSON格式生成的日志消息，这样日期、文本描述、消息来源以及任何其他元数据都作为JSON中的单独字段。Python的`structlog`库能够正确地格式化输出，并且使得向日志消息中添加处理器以屏蔽名称、密码和其他类似私人信息变得容易：[https://www.structlog.org/en/stable/index.html](https://www.structlog.org/en/stable/index.html)。
- en: 'Using it with Quart involves setting up `structlog`, and replacing the functions
    used to create log messages:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Quart中使用它需要设置`structlog`，并替换创建日志消息所用的函数：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Using the code above, we now get structured log entries—still surrounded by
    human-readable text, but now there are entries that a computer can easily parse:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上面的代码，我们现在得到了结构化日志条目——仍然被人类可读的文本包围，但现在有了一些计算机可以轻松解析的条目：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Further configuration of `structlog` allows you to send the JSON directly to
    a central logging server, such as **Graylog** ([https://www.graylog.org/](https://www.graylog.org/)),
    which will be useful for collecting logs from multiple different copies of your
    software running on different computers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步配置`structlog`允许您将JSON直接发送到中央日志服务器，例如**Graylog** ([https://www.graylog.org/](https://www.graylog.org/))，这对于从运行在不同计算机上的多个不同副本的软件中收集日志非常有用。
- en: With all this information about code complexity and how well each component
    in our monolith is working, we should have a good idea as to which areas need
    the most work, and which would benefit the most from being extracted into their
    own microservice. Once we have identified those components, we can begin this
    process.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了关于代码复杂性和我们单体中每个组件的工作情况的所有这些信息后，我们应该对哪些区域需要最多的工作，以及哪些可以从自己的微服务中提取出来以获得最大的好处有一个很好的想法。一旦我们确定了这些组件，我们就可以开始这个过程。
- en: Splitting a Monolith
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拆分单体
- en: Now that we know which components are consuming the most resources and taking
    the most time, how should we split them up?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了哪些组件消耗了最多的资源，并且花费了最多的时间，我们应该如何将它们拆分？
- en: It's already possible to move several components in our service to separate
    servers. RabbitMQ, Celery, and the database all communicate over the network,
    and so while there are a lot of steps to setting up new servers and configuring
    them, it is a well-understood process to install those hosts and update our application
    to use new URLs. This lets our API concentrate on handling network connections
    and moves the larger tasks to their own workers.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经可以将我们服务中的几个组件移动到单独的服务器上。RabbitMQ、Celery和数据库都通过网络进行通信，因此虽然设置新服务器和配置它们有很多步骤，但安装这些主机并更新我们的应用程序以使用新的URL是一个被充分理解的过程。这使得我们的API能够专注于处理网络连接，并将更大的任务移动到它们自己的工作者上。
- en: A developer must also consider setting up network security, accounts, access
    control and other concerns relating to running and securing a service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者还必须考虑设置网络安全、账户、访问控制和与运行和保障服务相关的其他问题。
- en: 'The parts of our own application are trickier: we call functions to invoke
    our own features, and we will need to call a REST API instead. Should this be
    done using one large deployment and all the changes in one go? Should we run the
    old and new versions side by side for a while?'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自己应用程序的部分更复杂：我们调用函数来调用我们自己的功能，我们将需要调用REST API。这是否应该通过一次大规模部署和一次性完成所有更改来完成？我们应该运行旧版本和新版本一段时间并行运行吗？
- en: 'A cautious, measured change is always safer. Being cautious does not mean you
    have to be slow, but it does involve planning. How do we tell if the migration
    is successful? What happens if we need to reverse the changes? Asking these questions
    lets us discover difficult situations in the migration before they happen—although
    things may not always go according to plan. There is an old saying that plans
    never survive contact with the enemy, but there''s an important nuance, attributed
    to former US President Dwight D. Eisenhower:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎、有节制的改变总是更安全。谨慎并不意味着你必须慢，但它确实涉及到规划。我们如何判断迁移是否成功？如果我们需要撤销更改，会发生什么？提出这些问题让我们在迁移发生之前发现困难的情况——尽管事情可能不会总是按计划进行。有句老话说计划永远无法在接触敌人时存活，但有一个重要的细微差别，归功于前美国总统德怀特·D·艾森豪威尔：
- en: Plans are worthless, but planning is everything.
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计划是没有价值的，但规划本身是一切。
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Dwight D. Eisenhower, 1957
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ——德怀特·D·艾森豪威尔，1957年
- en: It doesn't matter if the plans you make don't end up being useful. The act of
    making those plans helps you to better understand a situation and leaves you with
    the tools to deal with the changing situation in front of you.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你制定的计划最终没有用，那没关系。制定这些计划的行为帮助你更好地理解一个情况，并让你拥有处理面前变化情况所需的工具。
- en: 'An excellent first step with any approach is to return to our service-oriented
    architecture principles and define a clear interface between the future microservice
    and the rest of the application. Let''s look back at our monolithic application,
    at the function that works out which action to perform, and the other that gets
    chosen if the user wants to look up the weather. This code has plenty of issues,
    but we will address the relevant ones:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法的一个优秀的第一步是回到我们的面向服务的架构原则，并定义未来微服务与应用程序其余部分之间的清晰接口。让我们回顾一下我们的单体应用程序，看看哪个函数负责确定要执行的操作，以及如果用户想要查找天气，另一个被选中的函数。这段代码有很多问题，但我们将解决相关的问题：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We see that our `weather_action` function gets all the information it needs
    from the `process_message`, but it also needs to understand how to parse the text
    received as part of the message, and how to interpret the metadata about replying.
    Ideally only the function that replies needs to understand that metadata. If we
    wanted to turn the weather feature into a microservice, then we would need to
    have some way of understanding the messages from different sources, which would
    require reading the User table to learn where someone is if they haven't told
    us during the query. We can refactor this to make the function call very clear
    with regards to what data it needs.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到，我们的`weather_action`函数从`process_message`中获取了它所需的所有信息，但它还需要理解如何解析作为消息一部分接收到的文本，以及如何解释关于回复的元数据。理想情况下，只有回复功能的函数需要理解这些元数据。如果我们想将天气功能转变为微服务，那么我们就需要有一种方式来理解来自不同来源的消息，这需要读取用户表来了解如果他们在查询期间没有告诉我们，那么某人现在在哪里。我们可以重构这段代码，使函数调用非常清晰，关于它需要哪些数据。
- en: 'First, it''s not easy to test the way in which the location is extracted from
    the received message. Two new specialist functions should help with that, and
    ensure that these are more easily tested—the text processing in `extract_location`
    only relies on its inputs, and `fetch_user_location` is now just a database lookup,
    which we can mock in testing:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，测试从接收到的消息中提取位置的方式并不容易。两个新的专业函数应该有助于解决这个问题，并确保这些函数更容易测试——`extract_location`中的文本处理仅依赖于其输入，而`fetch_user_location`现在只是一个数据库查找，我们可以在测试中模拟：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The ability to generate a more complex analysis of the text to find a location
    within it is now easier too, as it can be done without affecting any other code.
    What should call these two functions? The answer is a new pre-processor that can
    accept the freeform text of a message written by a human and try to structure
    the data within it. We will also adjust our weather action so that it is now very
    simple and calls a function that performs the web request we need, and passes
    that text on to the component that sends messages back to Slack:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在生成更复杂的文本分析以找到其中的位置也更容易了，因为这可以在不影响任何其他代码的情况下完成。应该调用这两个函数的是什么？答案是新的预处理器，它可以接受人类编写的自由格式文本消息，并尝试结构化其中的数据。我们还将调整我们的天气动作，使其现在非常简单，调用执行所需Web请求的函数，并将该文本传递给发送消息回Slack的组件：
- en: '[PRE12]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, when the time comes to move to a microservice, we have a clear model of
    what the microservice should accept and what data it needs to return. Because
    the function call can be replaced with one that will perform a web-based query
    with the same well-structured data, we can incorporate this data into our tests
    and become more confident that the new microservice will operate as expected.
    We are also changing the way responses are sent, so that we do not rely on the
    code that called `weather_action`, but can instead pass a message on to a dedicated
    handler. Once we swap to a microservice, the calling code no longer needs to wait
    for a reply.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当迁移到微服务的时候，我们有一个清晰的模型，知道微服务应该接受什么以及需要返回什么数据。因为函数调用可以被替换为执行基于Web查询的函数，并且使用相同结构化的数据，我们可以将此数据纳入我们的测试中，并更有信心新微服务将按预期运行。我们也在改变发送响应的方式，这样我们就不再依赖于调用`weather_action`的代码，而是可以将消息传递给一个专门的处理程序。一旦我们切换到微服务，调用代码就不再需要等待回复。
- en: Feature Flags
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特性标志
- en: Changing a large codebase often involves multiple large patches, which in professional
    environments will be reviewed by peers before they are accepted and merged. With
    large changes, it can be confusing when you must determine exactly which set of
    patches must exist in order for a new feature to work. Even worse, if something
    goes wrong and the changes need to be reverted, this can cause problems in a fast-moving
    environment where others may have already made new changes that make assumptions
    about what is already there.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 更改大型代码库通常涉及多个大型补丁，在专业环境中，这些补丁在被接受和合并之前将经过同行审查。在大型更改中，当你必须确定确切哪些补丁集必须存在才能使新功能正常工作时，可能会感到困惑。更糟糕的是，如果出现问题并且需要撤销更改，这可能会在快速变化的环境中引起问题，其他人可能已经做出了新的更改，这些更改假设了已经存在的内容。
- en: A feature flag is a configuration option that exists purely to turn a specific
    feature on or off. They operate in a similar way to normal configuration options,
    letting you choose the behavior of the software, but they primarily exist to help
    with new features, fixes, and migrations. Instead of coordinating multiple large
    software patches, those changes can arrive in production whenever is most convenient,
    and they will not be used unless a new configuration option is turned on.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 特性标志是一种仅用于开启或关闭特定功能的配置选项。它们以类似于正常配置选项的方式运作，让您选择软件的行为，但它们主要存在是为了帮助处理新特性、修复和迁移。而不是协调多个大型软件补丁，这些更改可以在最方便的时候到达生产环境，除非新的配置选项被开启，否则它们将不会被使用。
- en: Turning a new feature on is then simply a case of adjusting the configuration
    file—whether that's through a new release, some configuration management software,
    or updating a service discovery tool such as **etcd** ([https://etcd.io/](https://etcd.io/)),
    which we discuss in *Chapter 10*, *Deploying on AWS*. There will also be situations—despite
    all the careful planning—in which you need to turn off a new behavior in a hurry.
    A feature flag means that this is a simple operation, easily understood by anyone
    who has to review and understands the change.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 启用新功能只是一个调整配置文件的问题——无论是通过新版本发布、某些配置管理软件，还是更新服务发现工具，例如**etcd** ([https://etcd.io/](https://etcd.io/))，我们将在第10章“在AWS上部署”中讨论。尽管进行了所有细致的计划，但在某些情况下，你可能需要紧急关闭新行为。功能标志意味着这是一个简单的操作，任何需要审查和理解变更的人都能轻松理解。
- en: A feature flag does not have to be an all-or-nothing switch. Given a choice
    between either a "call a local function" or "make a web request" path, it could
    be told to send 99% of the traffic to the first path and 1% to the second to let
    you examine how successful those queries are. A migration can continue slowly,
    gradually increasing the proportion of traffic going to the new code. You could
    also choose to duplicate calls and send real traffic to a test system to see how
    it copes under the load.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志不必是全有或全无的开关。在“调用本地函数”或“发起网络请求”路径之间进行选择时，可以指示将99%的流量发送到第一条路径，1%发送到第二条路径，以便您检查这些查询的成功率。迁移可以缓慢进行，逐渐增加流向新代码的流量比例。您还可以选择复制调用并将真实流量发送到测试系统，以查看其在负载下的表现。
- en: 'Implementing a feature flag should not be complicated—the code only exists
    while the migration is happening, after all. A simple on/off flag and a router
    for a proportion of traffic can be as simple as the following examples. The first
    example will swap to the new worker completely when the configuration value changes,
    and the second is configured to send a percentage of the traffic to the new worker
    to allow a controlled rollout of the new code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现功能标志不应复杂——毕竟，代码只存在于迁移过程中。一个简单的开关标志和一个用于部分流量的路由器可以像以下示例一样简单。第一个示例将在配置值更改时完全切换到新工作者，第二个配置为将一定百分比的流量发送到新工作者，以允许新代码的受控发布：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Using Prometheus, we can monitor the migration. *Figure 5.2* is an example of
    a graph showing how the rate of the `original_worker` and `new_worker` calls that
    our application performs change over time with respect to the number of requests
    they process, as we steadily increase the percentage of calls that should use
    the new function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Prometheus，我们可以监控迁移过程。*图5.2*是一个示例图表，展示了我们的应用程序在处理请求数量随时间变化时，`original_worker`和`new_worker`调用的速率如何变化，随着我们稳步增加应该使用新功能的调用百分比。
- en: '![image4.png](img/B17108_05_02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image4.png](img/B17108_05_02.png)'
- en: 'Figure 5.2: Using Prometheus to track how a gradual feature migration is progressing'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：使用Prometheus跟踪渐进式功能迁移的进度
- en: Once a new feature is stable, the default state for the configuration option
    can be changed—until now, if the option is missing, the feature is off. By now
    it should be safe to assume that if the option is missing, it should be turned
    on. This should catch any piece of the code that is not using the configuration
    properly! It will let you remove the feature flag, and also let you remove the
    old version of the feature and any code that checks the flag, finishing a migration.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦新功能稳定，可以更改配置选项的默认状态——到目前为止，如果选项缺失，则功能关闭。现在应该可以安全地假设，如果选项缺失，则应该开启。这将捕获任何未正确使用配置的代码片段！这将让您移除功能标志，并允许您移除旧版本的功能以及任何检查标志的代码，完成迁移。
- en: Refactoring Jeeves
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构Jeeves
- en: Examining Jeeves to see what aspects could be improved as a microservice, we
    might discover some external queries are slowing down our responses or using too
    many resources.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Jeeves以查看哪些方面可以作为微服务进行改进，我们可能会发现一些外部查询正在减慢我们的响应速度或使用过多的资源。
- en: However, we also discover a more fundamental change to the architecture. Responding
    to an incoming message is purely for the benefit of Slack's infrastructure, as
    the user does not see that message. Sending messages to Slack is independent of
    receiving messages, and so those two elements could be separate services. Instead
    of a monolithic application, we could have a microservice that simply accepts
    incoming messages, and routes them appropriately to other microservices that perform
    the actions the user has asked for. Then those services can all contact a microservice
    that specializes in sending messages to Slack.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们也发现架构有一个更根本的改变。响应收到的消息纯粹是为了Slack基础设施的利益，因为用户看不到那条消息。向Slack发送消息与接收消息是独立的，所以这两个元素可以是独立的服务。而不是一个单体应用，我们可以有一个简单的微服务，它只接受收到的消息，并将它们适当地路由到其他执行用户请求的操作的微服务。然后这些服务都可以联系一个专门向Slack发送消息的微服务。
- en: Some of these services will need to contact the database, and if we were to
    keep our current database architecture then each of these new microservices would
    need the database models. This is a tightly coupled design, meaning that any change
    in the database schema will need to be duplicated in all these new services, and
    the deployment managed so that the old and new versions are not running at the
    same time. To prevent this, we can convert our database into its own microservice,
    and set it up to answer the questions we know it will get.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些服务将需要联系数据库，如果我们保持当前的数据库架构，那么每个新的微服务都需要数据库模型。这是一个紧密耦合的设计，意味着任何数据库模式的更改都需要在这些所有新的服务中重复，并且部署管理以确保旧版本和新版本不会同时运行。为了防止这种情况，我们可以将我们的数据库转换为其自己的微服务，并设置它来回答我们知道它会得到的问题。
- en: No other service needs to know the internal structure of the data, as it must
    simply know where to ask, and that the answer will always be structured the same
    way—or be obvious through a version marker in the data that it should read differently.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他服务需要知道数据的内部结构，因为它只需要知道在哪里询问，并且答案总是以相同的方式结构化——或者通过数据中的版本标记明显地表明应该以不同的方式读取。
- en: '![](img/B17108_05_03.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17108_05_03.png)'
- en: 'Figure 5.3: Our new microservice architecture; the Celery workers are left
    out for simplicity'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3：我们新的微服务架构；为了简化，Celery工作进程被省略了
- en: 'This has an additional benefit: All these microservices can be used by any
    other tool. We could have a service that receives email, or messages through Signal
    and Telegram, or reads an IRC channel, and each of those could parse and understand
    the incoming messages, package up some instructions on how to reply, and send
    them on to the right service to perform the actions.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这还有一个额外的优点：所有这些微服务都可以被任何其他工具使用。我们可以有一个接收电子邮件或通过Signal和Telegram接收消息的服务，或者读取一个IRC频道，每个这样的服务都可以解析和理解收到的消息，打包一些如何回复的指令，并将它们发送到正确的服务去执行操作。
- en: With the microservice version of the architecture, we can respond quickly to
    the needs of the organization and start controlling services, while also processing
    data in a consistent way, and allowing people flexibility in how they make automated
    requests and get notified of the results.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微服务架构版本，我们可以快速响应组织的需要，开始控制服务，同时以一致的方式处理数据，并允许人们在如何进行自动化请求和接收结果通知方面有灵活性。
- en: Let us look at the workflow in more detail.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看工作流程。
- en: Workflow
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作流程
- en: Everything looks the same from Slack's perspective. When a user types a message,
    the URL we have configured will be sent some JSON-formatted information. This
    data is received by our Slack Request API, which is where all the Slack message
    processing happens, and where we choose the right microservice as a destination.
    We also build a data structure that can contain information about where to send
    a reply that will act as an envelope for our message. The action processing services
    don't need to understand it, but the tools that post a reply to Slack do—and in
    the future, other ways to reply can be added with their own information in this
    metadata.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从Slack的角度来看，一切看起来都一样。当用户输入一条消息时，我们配置的URL会发送一些JSON格式的信息。这些数据被我们的Slack请求API接收，所有Slack消息处理都发生在这里，我们选择正确的微服务作为目的地。我们还构建了一个可以包含有关发送回复位置的信息的数据结构，这个回复将作为我们消息的封皮。动作处理服务不需要理解它，但向Slack发布回复的工具需要理解它——在未来，可以通过在元数据中添加自己的信息来添加其他回复方式。
- en: If our Slack Request service then makes a web request to the microservice, we
    must wait for it to respond, accounting for the time it has to wait for all the
    calls it makes. This can make our API very slow; its toleration of faults is also
    poor, as in the event of components breaking the entire chain falls apart and
    the message is lost.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的 Slack 请求服务随后向微服务发起网络请求，我们必须等待其响应，考虑到它需要等待所有调用的响应时间。这可能会使我们的 API 非常慢；其容错性也较差，因为如果组件出现问题，整个链条就会崩溃，信息就会丢失。
- en: '![](img/B17108_05_04.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4](img/B17108_05_04.png)'
- en: 'Figure 5.4: How messages traverse the new microservices architecture'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4：消息如何穿越新的微服务架构
- en: Thankfully, we have a message queue! Instead of directly calling each step in
    sequence, we can pass a message to RabbitMQ and immediately return an appropriate
    status code to Slack's infrastructure. It will accept the messages and ensure
    that they are delivered to workers that can perform the actions we need.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有一个消息队列！我们不需要直接按顺序调用每个步骤，我们可以将消息传递给 RabbitMQ 并立即向 Slack 的基础设施返回适当的状态码。它将接受这些消息并确保它们被传递到可以执行我们需要的操作的工人那里。
- en: If one of our workers has a failure, the messages will queue up and still be
    there when we come back online—unless we tell them to expire after a certain period
    of time.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的某个工人出现故障，消息将排队并保留在那里，直到我们恢复在线——除非我们告诉它们在一段时间后过期。
- en: Once a reply has been created, we can then use RabbitMQ again and send a message
    to the Slack Posting service. We gain the same reliability improvements using
    the message queue as we do for the incoming messages, only now they are more resilient in
    the event of any failures.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了回复，我们就可以再次使用 RabbitMQ 并向 Slack 发布服务发送消息。我们使用消息队列获得的可靠性改进与我们对传入消息的改进相同，但现在它们在出现任何故障时更加具有弹性。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have discussed how to examine a monolithic service and determine
    which components should be converted to microservices, along with what sort of
    metrics to collect to allow us to gain a good understanding of a service's operational
    health and capacity.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何检查单体服务并确定哪些组件应该转换为微服务，以及我们应该收集哪些指标以便我们能够对服务的运行健康和容量有一个良好的理解。
- en: This splitting process should be conservative and iterative, otherwise it is
    quite easy to end up with a system where the overhead for building and maintaining
    microservices outweighs the benefits of splitting an application up.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这个拆分过程应该是保守和迭代的，否则很容易最终得到一个系统，其中构建和维护微服务的开销超过了拆分应用程序的好处。
- en: However, we have moved from a single application to many that need to interact
    with each other. Every link in *Figure 5.4* can be a weak point for your application.
    What happens, for instance, if RabbitMQ goes down, or if there is a network split
    between the message processor and the Slack Posting service? We also need to consider
    how quickly our application responds to external requests, so that if a caller
    does not need to wait around for a response then they do not have to.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们已经从单一的应用程序转变为许多需要相互交互的应用程序。*图 5.4* 中的每个链接都可能成为你应用程序的弱点。例如，如果 RabbitMQ 崩溃，或者消息处理程序和
    Slack 发布服务之间存在网络分割，会发生什么？我们还需要考虑我们的应用程序对外部请求的响应速度，这样如果调用者不需要等待响应，他们就不必等待。
- en: The same question goes for every new network link that was added to our architecture.
    We need to be resilient when something goes wrong. We need to know where we are
    and what to do when a service that was down is back online.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们架构中添加的每个新的网络链接，同样的问题也存在。当出现问题的时候，我们需要有弹性。我们需要知道当某个服务恢复在线时，我们身处何处以及应该做什么。
- en: All these problems are addressed in the next chapter.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些问题都在下一章中得到解决。
