- en: Caching in on the Top 10
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在前10部电影中进行缓存
- en: In this chapter, we'll use the votes that our users have cast to build a list
    of the top 10 movies in MyMDB. In order to ensure that this popular page remains
    quick to load, we'll take a look at tools to help us optimize our site. Finally,
    we'll look at Django's caching API and how to use it to optimize our project.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用我们的用户投票的票数来构建MyMDB中前10部电影的列表。为了确保这个受欢迎的页面保持快速加载，我们将看看帮助我们优化网站的工具。最后，我们将看看Django的缓存API以及如何使用它来优化我们的项目。
- en: 'In this chapter, we will do the following things:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将做以下事情：
- en: Create a top 10 movie list using an aggregate query
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用聚合查询创建一个前10部电影列表
- en: Learn about Django instrumentation tools to measure optimization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Django的工具来衡量优化
- en: Use Django's cache API to cache results of expensive operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django的缓存API来缓存昂贵操作的结果
- en: Let's start by making our top 10 movies list page.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从制作我们的前10部电影列表页面开始。
- en: Creating a top 10 movies list
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建前10部电影列表
- en: For building our top 10 list, we'll start off by creating a new `MovieManager`
    method and then use it in a new view and template. We'll also update the top header
    in our base template to make the list easily accessible from every page.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的前10部电影列表，我们将首先创建一个新的`MovieManager`方法，然后在新的视图和模板中使用它。我们还将更新基本模板中的顶部标题，以便从每个页面轻松访问列表。
- en: Creating MovieManager.top_movies()
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建MovieManager.top_movies()
- en: Our `MovieManager` class needs to be able to return a `QuerySet` object of the
    most popular movies as voted by our users. We're using a naive formula for popularity,
    that is, the sum of ![](img/e7400a23-0fe5-4725-8751-68f43e1455d2.png) votes minus
    the sum of ![](img/933b0552-c3d0-4633-bbf3-87a483749b81.png)votes. Just like in
    Chapter 2, *Adding Users to MyMDB*, we will use the `QuerySet.annotate()` method
    to make an aggregate query to count the votes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`MovieManager`类需要能够返回一个由我们的用户投票选出的最受欢迎电影的`QuerySet`对象。我们使用了一个天真的受欢迎度公式，即![](img/e7400a23-0fe5-4725-8751-68f43e1455d2.png)票数减去![](img/933b0552-c3d0-4633-bbf3-87a483749b81.png)票数的总和。就像在第2章*将用户添加到MyMDB*中一样，我们将使用`QuerySet.annotate()`方法来进行聚合查询以计算投票数。
- en: 'Let''s add our new method to `django/core/models.py`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的新方法添加到`django/core/models.py`：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We order our results by the sum of their votes (descending) to get our top movies
    list. However, we face the problem that some movies won't have a vote and so will
    have `NULL` as their `vote_sum` value. Unfortunately, `NULL` will be ordered first
    by Postgres. We'll solve this by adding the constraint that a movie with no votes
    will, by definition, not be one of the top movies. We use `QuerySet.exclude` (which
    is the opposite of `QuerySet.filter`) to remove movies that don't have a vote.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照它们的票数总和（降序）对结果进行排序，以获得我们的前10部电影列表。然而，我们面临的问题是，一些电影没有投票，因此它们的`vote_sum`值将为`NULL`。不幸的是，`NULL`将首先被Postgres排序。我们将通过添加一个约束来解决这个问题，即没有投票的电影，根据定义，不会成为前10部电影之一。我们使用`QuerySet.exclude`（与`QuerySet.filter`相反）来删除没有投票的电影。
- en: This is the first time that we see a `QuerySet` object being sliced. A `QuerySet` object
    is not evaluated by slicing unless a step is provided (for example, `qs [10:20:2]`
    would make the `QuerySet` object be evaluated immediately and return rows 10,
    12, 14, 16, and 18).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到一个`QuerySet`对象被切片。除非提供步长，否则`QuerySet`对象不会被切片评估（例如，`qs [10:20:2]`会使`QuerySet`对象立即被评估并返回第10、12、14、16和18行）。
- en: Now that we have a `QuerySet` object with the proper `Movie` model instances,
    we can use the `QuerySet` object in our view.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个合适的`Movie`模型实例的`QuerySet`对象，我们可以在视图中使用`QuerySet`对象。
- en: Creating the TopMovies view
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建TopMovies视图
- en: 'Since our `TopMovies` view will need to show a list, we can use Django''s `ListView`
    like we have before. Let''s update `django/core/views.py`:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`TopMovies`视图需要显示一个列表，我们可以像以前一样使用Django的`ListView`。让我们更新`django/core/views.py`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Unlike the previous `ListView` classes, we will need to specify a `template_name` attribute.
    Otherwise, `ListView` would try to use `core/movie_list.html`, which is used by
    the `MovieList` view.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前的`ListView`类不同，我们需要指定一个`template_name`属性。否则，`ListView`将尝试使用`core/movie_list.html`，这是`MovieList`视图使用的。
- en: Next, let's create our template.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的模板。
- en: Creating the top_movies_list.html template
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建top_movies_list.html模板
- en: 'Our Top 10 Movies page will not need pagination, so the template is pretty
    simple. Let''s create `django/core/templates/core/top_movies_list.html`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的前10部电影页面不需要分页，所以模板非常简单。让我们创建`django/core/templates/core/top_movies_list.html`：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Extending `base.html`, we will redefine two template `block` tags. The new `title`
    template `block` has our new title. The `main` template `block` lists the movies
    in the `object_list`, including a link to each movie.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展`base.html`，我们将重新定义两个模板`block`标签。新的`title`模板`block`有我们的新标题。`main`模板`block`列出了`object_list`中的电影，包括每部电影的链接。
- en: 'Finally, let''s update `django/templates/base.html` to include a link to our
    Top 10 Movies page:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们更新`django/templates/base.html`，以包括一个链接到我们的前10部电影页面：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, let's add a `path()` object to our URLConf so that Django can route requests
    to our `TopMovies` view.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的URLConf中添加一个`path()`对象，这样Django就可以将请求路由到我们的`TopMovies`视图。
- en: Adding a path to TopMovies
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加到TopMovies的路径
- en: 'As always, we will need to add a `path()` to help Django route requests to
    our view. Let''s update `django/core/urls.py`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，我们需要添加一个`path()`来帮助Django将请求路由到我们的视图。让我们更新`django/core/urls.py`：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With that, we're done. We now have a Top 10 Movies page on MyMDB.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，我们就完成了。现在我们在MyMDB上有了一个前10部电影页面。
- en: However, looking through all the votes means scanning the largest table in the
    project. Let's look at ways to optimize our project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，浏览所有的投票意味着扫描项目中最大的表。让我们看看如何优化我们的项目。
- en: Optimizing Django projects
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Django项目
- en: There is no single correct answer for how to optimize a Django project because
    different projects have different constraints. To succeed, it's important to be
    clear about what you're optimizing and what to use in hard numbers, not intuition.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如何优化Django项目没有单一正确答案，因为不同的项目有不同的约束。要成功，重要的是要清楚你要优化什么，以及在硬数据中使用什么，而不是直觉。
- en: 'It’s important to be clear about what we''re optimizing because optimization
    usually involves trade-offs. Some of the constraints you may wish to optimize
    for are as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 清楚地了解我们要进行优化的内容很重要，因为优化通常涉及权衡。您可能希望进行优化的一些约束条件如下：
- en: Response time
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应时间
- en: Web server memory
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器内存
- en: Web server CPU
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web服务器CPU
- en: Database memory
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库内存
- en: Once you know what you're optimizing, you will need a way to measure current
    performance and the optimized code's performance. Optimized code is often more
    complex than unoptimized code. You should always confirm that the optimization
    is effective before taking on the burden of the complexity.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您知道要进行优化的内容，您将需要一种方法来测量当前性能和优化代码的性能。优化代码通常比未优化代码更复杂。在承担复杂性之前，您应始终确认优化是否有效。
- en: Django is just Python, so you can use a Python profiler to measure performance.
    This is a useful but complicated technique. Discussing the details of Python profiling
    goes beyond the scope of this book. However, it's important to remember that Python
    profiling is a useful tool at our disposal.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Django只是Python，因此您可以使用Python分析器来测量性能。这是一种有用但复杂的技术。讨论Python分析的细节超出了本书的范围。然而，重要的是要记住Python分析是我们可以使用的有用工具。
- en: Let's take a look at some Django-specific ways that you can measure performance.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些特定于Django的测量性能的方法。
- en: Using the Django Debug Toolbar
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django调试工具栏
- en: The Django Debug Toolbar is a third-party package that provides a lot of useful
    debug information right in the browser. The toolbar is composed of a list of panels.
    Each panel provides a distinct set of information.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Django调试工具栏是一个第三方包，可以在浏览器中提供大量有用的调试信息。工具栏由一系列面板组成。每个面板提供不同的信息集。
- en: 'Some of the most useful panels (which are enabled by default) are as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最有用的面板（默认情况下启用）如下：
- en: '**Request Panel:** It shows information related to the request, including the
    view that processed the request, arguments it received (parsed out of the path),
    cookies, session data, and `GET`/`POST` data in the request.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求面板：它显示与请求相关的信息，包括处理请求的视图、接收到的参数（从路径中解析出来）、cookie、会话数据以及请求中的GET/POST数据。
- en: '**SQL Panel:** It shows how many queries are made, a timeline of their execution,
    and a button to run `EXPLAIN` on the query. Data-driven web applications are often
    slowed down by their database queries.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL面板：显示进行了多少查询，它们的执行时间线以及在查询上运行`EXPLAIN`的按钮。数据驱动的Web应用程序通常会因其数据库查询而变慢。
- en: '**Templates Panel:** It shows the templates that were rendered and their context.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板面板：显示已呈现的模板及其上下文。
- en: '**Logging Panel:** It shows any log messages produced by the view. We''ll discuss
    logging more in the next section.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志面板：它显示视图产生的任何日志消息。我们将在下一节讨论更多关于日志记录的内容。
- en: The profile panel is an advanced panel that is available but not enabled by
    default. This panel runs a profiler on your view and shows you the results. The
    panel comes with some caveats, which are explained in the Django Debug Toolbar
    documentation online ([https://django-debug-toolbar.readthedocs.io/en/stable/panels.html#profiling](https://django-debug-toolbar.readthedocs.io/en/stable/panels.html#profiling)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件面板是一个高级面板，默认情况下不启用。该面板在您的视图上运行分析器并显示结果。该面板带有一些注意事项，这些注意事项在Django调试工具栏在线文档中有解释（[https://django-debug-toolbar.readthedocs.io/en/stable/panels.html#profiling](https://django-debug-toolbar.readthedocs.io/en/stable/panels.html#profiling)）。
- en: Django Debug Toolbar is useful in development, but should not be run in production.
    By default, it will only work if `DEBUG = True` (a setting you must **never**
    use in production).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Django调试工具栏在开发中很有用，但不应在生产中运行。默认情况下，只有在`DEBUG = True`时才能工作（这是您在生产中绝对不能使用的设置）。
- en: Using Logging
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用日志记录
- en: Django uses Python's built-in logging system, which you can configure using
    `settings.LOGGING` . It's configured using a `DictConfig`, as documented in the
    Python documentation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Django使用Python的内置日志系统，您可以使用`settings.LOGGING`进行配置。它使用`DictConfig`进行配置，如Python文档中所述。
- en: As a refresher, here's how Python's logging system works. The system is composed
    of *loggers*, which receive a *message* and *log level* (for example, `DEBUG` and `INFO`)
    from our code. If the logger is configured to not filter out messages at that
    log level (or higher), it creates a *log record* that is passed to all its *handlers*.
    A handler will check whether it matches the handler's log level, then it will
    format the log record (using a *formatter*) and emit the message. Different handlers
    will emit messages differently. `StreamHandler` will write to a stream (`sys.stderr`
    by default), `SysLogHandler` writes to `SysLog`, and `SMTPHandler` sends an email.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个复习，这是Python的日志系统的工作原理。该系统由*记录器*组成，它们从我们的代码接收*消息*和*日志级别*（例如`DEBUG`和`INFO`）。如果记录器被配置为不过滤掉该日志级别（或更高级别）的消息，它将创建一个*日志记录*，并将其传递给所有其*处理程序*。处理程序将检查它是否与处理程序的日志级别匹配，然后它将格式化日志记录（使用*格式化程序*）并发出消息。不同的处理程序将以不同的方式发出消息。`StreamHandler`将写入流（默认为`sys.stderr`），`SysLogHandler`写入`SysLog`，`SMTPHandler`发送电子邮件。
- en: By logging how long operations take, you can get a meaningful sense of what
    you need to optimize. Using the correct log levels and handlers, you can measure
    resource consumption in production.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过记录操作所需的时间，您可以对需要进行优化的内容有一个有意义的了解。使用正确的日志级别和处理程序，您可以在生产中测量资源消耗。
- en: Application Performance Management
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用性能管理
- en: '**Application Performance Management** (**APM**) is the name for services that
    (often) run as part of your application server and trace performed operations.
    The trace is sent to a reporting server, which combines all the traces, and can
    give you code line-level insight into the performance of your production servers.
    This can be helpful for large and complicated deployments, but may be overkill
    for smaller, simpler web applications.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应用性能管理（APM）是指作为应用服务器一部分运行并跟踪执行操作的服务。跟踪结果被发送到报告服务器，该服务器将所有跟踪结果合并，并可以为您提供对生产服务器性能的代码行级洞察。这对于大型和复杂的部署可能有所帮助，但对于较小、较简单的Web应用程序可能过于复杂。
- en: A quick review of the section
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本节的快速回顾
- en: In this section, we reviewed the importance of knowing what to optimize before
    you actually start optimizing. We also looked at some tools to help us measure
    whether our optimization was successful.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们回顾了在实际开始优化之前知道要优化什么的重要性。我们还看了一些工具，帮助我们衡量我们的优化是否成功。
- en: Next, we'll take a look at how we can solve some common performance problems
    with Django's cache API.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使用Django的缓存API解决一些常见的性能问题。
- en: Using Django's cache API
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Django的缓存API
- en: Django provides a caching API out of the box. In `settings.py`, you can configure
    one or more caches. Caching can be used to store a whole site, a single page's
    response, a template fragment, or any pickleable object. Django provides a single
    API that can be configured with a variety of backends.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Django提供了一个开箱即用的缓存API。在`settings.py`中，您可以配置一个或多个缓存。缓存可用于存储整个站点、单个页面的响应、模板片段或任何可pickle的对象。Django提供了一个可以配置多种后端的单一API。
- en: 'In this section, we will perform the following functions:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将执行以下功能：
- en: Look at the different backends for Django's cache API
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Django缓存API的不同后端
- en: Use Django to cache a page
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django缓存页面
- en: Use Django to cache a template fragment
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django缓存模板片段
- en: Use Django to cache a `QuerySet`
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Django缓存`QuerySet`
- en: One thing we won't be looking at is *downstream* caching, such as **Content
    Delivery Networks** (**CDNs**) or proxy caches. These are not Django specific,
    and there is a wide variety of options. Generally speaking, these kinds of caches
    will rely on the same `VARY` headers that Django has already sent.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会研究*下游*缓存，例如**内容交付网络**（**CDN**）或代理缓存。这些不是Django特有的，有各种各样的选择。一般来说，这些类型的缓存将依赖于Django已发送的相同`VARY`标头。
- en: Next, let's look at configuring the backends for the cache API.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何配置缓存API的后端。
- en: Examining the trade-offs between Django cache backends
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Django缓存后端之间的权衡
- en: Different backends can be appropriate for different situations. However, the
    golden rule of caches is that they must be *faster* than the source they're caching
    or else you've made your application slower. Deciding which backend is appropriate
    for which task is best done by instrumenting your project, as discussed in the
    preceding section. Different backends have different trade-offs.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的后端可能适用于不同的情况。但是，缓存的黄金法则是它们必须比它们缓存的源*更快*，否则您会使应用程序变慢。决定哪个后端适合哪个任务最好是通过对项目进行仪器化来完成的，如前一节所讨论的。不同的后端有不同的权衡。
- en: Examining Memcached trade-offs
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查Memcached的权衡
- en: '**Memcached** is the most popular cache backend, but it still comes with trade-offs
    that you need to evaluate. Memcached is an in-memory key value store for small
    data that can be shared by several clients (for example, Django processes) using
    one or more Memcached hosts. However, Memcached will not be appropriate for caching
    large blocks of data (1 MB of data, by default). Also, since Memcached is all
    in-memory, if the process is restarted then the entire cache is cleared. On the
    other hand, Memcached has remained popular because it is fast and simple.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**Memcached**是最受欢迎的缓存后端，但仍然存在需要评估的权衡。Memcached是一个用于小数据的内存键值存储，可以由多个客户端（例如Django进程）使用一个或多个Memcached主机进行共享。但是，Memcached不适合缓存大块数据（默认情况下为1
    MB的数据）。另外，由于Memcached全部在内存中，如果进程重新启动，则整个缓存将被清除。另一方面，Memcached因为快速和简单而保持受欢迎。'
- en: 'Django comes with two Memcached backends, depending on the `Memcached` library
    that you want to use:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Django带有两个Memcached后端，取决于您想要使用的`Memcached`库：
- en: '`django.core.cache.backends.memcached.MemcachedCache`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.core.cache.backends.memcached.MemcachedCache`'
- en: '`django.core.cache.backends.memcached.PyLibMCCache`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`django.core.cache.backends.memcached.PyLibMCCache`'
- en: You must also install the appropriate library (`python-memcached` or `pylibmc`,
    respectively). To specify the address(es) of your Memcached servers set `LOCATION`
    to a list in the format `address:PORT` (for example, `['memcached.example.com:11211',]`). An
    example configuration is listed at the end of this section.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须安装适当的库（`python-memcached`或`pylibmc`）。要将您的Memcached服务器的地址设置为`LOCATION`，请将其设置为格式为`address:PORT`的列表（例如，`['memcached.example.com:11211',]`）。示例配置在本节末尾列出。
- en: Using Memcached in *development* and *testing* is unlikely to be very useful,
    unless you have evidence to the contrary (for example, you need to replicate a
    complex bug).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在*开发*和*测试*中使用Memcached可能不会很有用，除非您有相反的证据（例如，您需要复制一个复杂的错误）。
- en: Memcached is popular in production environments because it is fast and easy
    to set up. It avoids duplication of data by letting all your Django processes
    connect to the same host(s). However, it uses a lot of memory (and degrades quickly
    and poorly when it runs out of available memory). It's also important to be mindful
    of the operational costs of running another service.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Memcached在生产环境中很受欢迎，因为它快速且易于设置。它通过让所有Django进程连接到相同的主机来避免数据重复。但是，它使用大量内存（并且在可用内存用尽时会迅速且不良地降级）。另外，注意运行另一个服务的操作成本是很重要的。
- en: 'Here’s an example config for using `memcached`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用`memcached`的示例配置：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Examining dummy cache trade-offs
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查虚拟缓存的权衡
- en: The **dummy cache** (`django.core.cache.backends.dummy.DummyCache`) will check
    whether a key is valid, but otherwise will perform no operations.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**虚拟缓存**（`django.core.cache.backends.dummy.DummyCache`）将检查密钥是否有效，但否则不执行任何操作。'
- en: This cache can be useful for *development* and *testing* when you want to make
    sure that you're definitely seeing the results of your code changes, not something
    cached.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想确保您确实看到代码更改的结果而不是缓存时，此缓存在*开发*和*测试*中可能很有用。
- en: Don't use this cache in *production*, as it has no effect.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在*生产*中使用此缓存，因为它没有效果。
- en: 'Here''s an example config for the dummy cache:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个虚拟缓存的示例配置：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Examining local memory cache trade-offs
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查本地内存缓存的权衡
- en: The **local memory cache** (`django.core.cache.backends.locmem.LocMemCache`)
    uses a Python dictionary as a global in-memory cache. If you want to use multiple
    separate local memory caches, give each unique string in `LOCATION`. It's called
    a local cache because it's local to each process. If you're spinning up multiple
    processes (as you would in production), then you might cache the same value multiple
    times as different processes handle requests. This inefficiency may be preferable
    for its simplicity, as it does not require another service.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**本地内存缓存**（`django.core.cache.backends.locmem.LocMemCache`）使用Python字典作为全局内存缓存。如果要使用多个单独的本地内存缓存，请在`LOCATION`中给出每个唯一的字符串。它被称为本地缓存，因为它是每个进程的本地缓存。如果您正在启动多个进程（就像在生产中一样），那么不同进程处理请求时可能会多次缓存相同的值。这种低效可能更简单，因为它不需要另一个服务。'
- en: This is a useful cache to use in *development* and *testing* to confirm that
    your code is caching correctly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个在*开发*和*测试*中使用的有用缓存，以确认您的代码是否正确缓存。
- en: You may want to use this in *production,* but keep in mind the potential inefficiency
    of different processes caching the same data.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想在*生产*中使用这个，但要记住不同进程缓存相同数据的潜在低效性。
- en: 'The following is an example config for the local memory cache:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本地内存缓存的示例配置：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Examine file-based cache trade-offs
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查基于文件的缓存权衡
- en: Django's **file-based cache** (`django.core.cache.backends.filebased.FileBasedCache`)
    uses compressed files in a specified `LOCATION` directory to cache data. Using
    files may seem strange; aren't caches supposed to be *fast* and files *slow*?
    The answer, again, depends on what you're caching. As an example, network requests
    to an external API may be slower than your local disk. Remember that each server
    will have a separate disk, so there will be some duplication of data if you're
    running a cluster.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Django的**基于文件的缓存**（`django.core.cache.backends.filebased.FileBasedCache`）使用指定的`LOCATION`目录中的压缩文件来缓存数据。使用文件可能看起来很奇怪；缓存不应该是*快速*的，而文件是*慢*的吗？答案再次取决于您要缓存的内容。例如，对外部API的网络请求可能比本地磁盘慢。请记住，每个服务器都将有一个单独的磁盘，因此如果您运行一个集群，数据将会有一些重复。
- en: You probably don't want to use this in *development* or *testing* unless you
    are heavily memory constrained.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 除非内存受限，否则您可能不想在*开发*或*测试*中使用这个。
- en: You may want to use this in production to cache resources that are particularly
    large or slow to request. Remember that you should give your server's process
    write permission to the `LOCATION` directory. Also, make sure that you give your
    server(s) enough disk space for your cache.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想在生产中缓存特别大或请求速度慢的资源。请记住，您应该给服务器进程写入`LOCATION`目录的权限。此外，请确保为缓存给服务器提供足够的磁盘空间。
- en: 'The following is an example config to use the file-based cache:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用基于文件的缓存的示例配置：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Examining database cache trade-offs
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查数据库缓存权衡
- en: The **database cache** backend (`django.core.cache.backends.db.DatabaseCache`)
    uses a database table (named in `LOCATION`) to store the cache. Obviously, this
    works best if your database is fast. Depending on the scenario, this may be helpful
    even when caching results of database queries if the queries are complex but single
    row lookups are fast. There are upsides to this, as the cache is not ephemeral
    like a memory cache and can be easily shared across processes and servers (such
    as Memcached).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据库缓存**后端（`django.core.cache.backends.db.DatabaseCache`）使用数据库表（在`LOCATION`中命名）来存储缓存。显然，如果您的数据库速度很快，这将效果最佳。根据情况，即使在缓存数据库查询结果时，这也可能有所帮助，如果查询复杂但单行查找很快。这有其优势，因为缓存不像内存缓存那样是短暂的，可以很容易地在进程和服务器之间共享（如Memcached）。'
- en: 'The database cache table is not managed by a migration but by a `manage.py`
    command, as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库缓存表不是由迁移管理的，而是由`manage.py`命令管理，如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You probably don't want to use this in *development* or *testing* unless you
    want to replicate your production environment locally.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除非您想在*开发*或*测试*中复制您的生产环境，否则您可能不想使用这个。
- en: You may want to use this in *production* if your testing proves that it's appropriate.
    Remember to consider what the increased database load will do to its performance.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的测试证明它是合适的，您可能想在*生产*中使用这个。请记住考虑增加的数据库负载对性能的影响。
- en: 'The following is an example config to use the database cache:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是使用数据库缓存的示例配置：
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Configuring a local memory cache
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置本地内存缓存
- en: In our case, we will use a local memory cache with a very low timeout. This
    will mean that most requests we make while writing our code will skip the cache
    (old values, if any, will have expired), but if we quickly click on refresh, we'll
    be able to get confirmation that our cache is working.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们将使用一个具有非常低超时的本地内存缓存。这意味着我们在编写代码时大多数请求将跳过缓存（旧值（如果有）将已过期），但如果我们快速点击刷新，我们将能够确认我们的缓存正在工作。
- en: 'Let''s update `django/config/settings.py` to use a local memory cache:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新`django/config/settings.py`以使用本地内存缓存：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Although we can have multiple differently configured caches, the default cache
    is expected to be named `'default'` .
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以有多个配置不同的缓存，但默认缓存的名称应为`'default'`。
- en: '`Timeout` is how long (in seconds) a value should be kept in the cache before
    it''s culled (removed/ignored). If `Timeout` is `None`, then the value will be
    considered to never expire.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Timeout`是值在被清除（移除/忽略）之前在缓存中保留的时间（以秒为单位）。如果`Timeout`为`None`，则该值将被视为永不过期。'
- en: Now that we have a cache configured, let's cache the `MovieList` page.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了缓存，让我们缓存`MovieList`页面。
- en: Caching the movie list page
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存电影列表页面
- en: We will proceed on the assumption that the `MovieList` page is very popular
    and expensive for us generate. To reduce the cost of serving these requests, we
    will use Django to cache the entire page.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将假设`MovieList`页面对我们来说非常受欢迎且昂贵。为了降低提供这些请求的成本，我们将使用Django来缓存整个页面。
- en: Django provides the decorator (function) `django.views.decorators.cache.cache_page`,
    which can be used to cache a single page. It may seem strange that this is a decorator
    instead of a mixin. When Django was initially launched, it didn't have **Class-Based
    Views** (**CBVs**), only **Function-Based Views** (**FBVs**). As Django matured,
    much of the code switched to using CBVs, but there are still some features implemented
    as FBV decorators.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Django 提供了装饰器（函数）`django.views.decorators.cache.cache_page`，它可以用来缓存单个页面。这是一个装饰器而不是一个
    mixin，可能看起来有点奇怪。当 Django 最初发布时，它没有 **基于类的视图**（**CBVs**），只有 **基于函数的视图**（**FBVs**）。随着
    Django 的成熟，很多代码切换到使用 CBVs，但仍然有一些功能实现为 FBV 装饰器。
- en: There are a few different ways to use function decorators in CBVs. Our approach
    will be to build our own mixin. Much of the power of CBVs comes off from the power
    of being able to mix in new behavior to existing classes. Knowing how to do that
    is a useful skill.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CBVs 中，有几种不同的使用函数装饰器的方式。我们的方法是构建我们自己的 mixin。CBVs 的很多功能来自于能够将新行为混入到现有类中的能力。了解如何做到这一点是一项有用的技能。
- en: Creating our first mixin – CachePageVaryOnCookieMixin
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个 mixin – CachePageVaryOnCookieMixin
- en: 'Let''s create a new class in `django/core/mixins.py`:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `django/core/mixins.py` 中创建一个新的类：
- en: '[PRE12]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our new mixin overrides the `as_view()` class method that we use in URLConfs
    and decorates the view with the `vary_on_cookie()` and `cache_page()` decorators.
    This effectively acts as if we were decorating the `as_view()` method with our
    function decorator.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新 mixin 覆盖了我们在 URLConfs 中使用的 `as_view()` 类方法，并使用 `vary_on_cookie()` 和 `cache_page()`
    装饰器装饰视图。这实际上就像我们在 `as_view()` 方法上使用我们的函数装饰器一样。
- en: Let's look at the `cache_page()` decorator first. `cache_page()` requires a
    `timeout` argument and optionally takes a `cache` argument. `timeout` is how long
    (in seconds) before the cached page should expire and must be recached. Our default
    timeout value is the default for the cache we're using. Classes that subclass
    `CachePageVaryOnCookieMixin` can provide a new `timeout` attribute just like our
    `MovieList` class provides a `model` attribute. The `cache` argument expects the
    string name of the desired cache. Our mixin is set up to use the `default` cache,
    but by referencing it via a class attribute, that too can be changed by a subclass.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `cache_page()` 装饰器。`cache_page()` 需要一个 `timeout` 参数，并且可以选择接受一个 `cache`
    参数。`timeout` 是缓存页面应该过期并且必须重新缓存之前的时间（以秒为单位）。我们的默认超时值是我们正在使用的缓存的默认值。子类化 `CachePageVaryOnCookieMixin`
    的类可以提供一个新的 `timeout` 属性，就像我们的 `MovieList` 类提供了一个 `model` 属性一样。`cache` 参数期望所需缓存的字符串名称。我们的
    mixin 被设置为使用 `default` 缓存，但通过引用一个类属性，这也可以被子类更改。
- en: When caching a page such as `MoveList`, we must remember that the resulting
    page is different for different users. In our case, the header of `MovieList`
    looks different for logged in users (shows a *log out* link) and for logged out
    users (shows *log in* and *register* links). Django, again, does the heavy work
    for us by providing the `vary_on_cookie()` decorator.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当缓存一个页面，比如 `MoveList`，我们必须记住，对于不同的用户，生成的页面是不同的。在我们的情况下，`MovieList` 的头对已登录用户（显示
    *注销* 链接）和已注销用户（显示 *登录* 和 *注册* 链接）是不同的。Django 再次为我们提供了 `vary_on_cookie()` 装饰器。
- en: The `vary_on_cookie()` decorator adds a `VARY cookie` header to the response.
    The `VARY` header is used by caches (both downstream and Django's) to let them
    know about variants of that resource. `VARY cookie` tells the cache that each
    different cookie/URL pair is a different resource and should be cached separately.
    This means that logged in users and logged out users will not see the same page
    because they will have different cookies.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`vary_on_cookie()` 装饰器将一个 `VARY cookie` 头添加到响应中。`VARY` 头被缓存（包括下游缓存和 Django
    的缓存）用来告诉它们有关该资源的变体。`VARY cookie` 告诉缓存，每个不同的 cookie/URL 对都是不同的资源，应该分别缓存。这意味着已登录用户和已注销用户将看到不同的页面，因为它们将有不同的
    cookie。'
- en: This has an important impact on our hit ratio (the proportion of times a cache
    is *hit* instead of the resource being regenerated). A cache with a low hit ratio
    will have minimal effect, as most requests will *miss* the cache and result in
    a processed request.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这对我们的命中率（缓存被 *命中* 而不是重新生成资源的比例）有重要影响。命中率低的缓存将几乎没有效果，因为大多数请求将 *未命中* 缓存，并导致处理请求。
- en: In our case, we also use cookies for CSRF protection. While session cookies
    may lower a hit ratio a bit, depending on the circumstance (look at your user's
    activity to confirm), a CSRF cookie is practically fatal. The nature of a CSRF
    cookie is to change a lot so that attackers cannot predict it. If that constantly
    changing value is sent with many requests, then very few can be cached. Luckily,
    we can move our CSRF value out of cookies and into the server side session with
    a `settings.py` change.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，我们还使用 cookie 进行 CSRF 保护。虽然会话 cookie 可能会降低命中率一点，具体取决于情况（查看用户的活动以确认），但
    CSRF cookie 几乎是致命的。CSRF cookie 的性质是经常变化，以便攻击者无法预测。如果那个不断变化的值与许多请求一起发送，那么很少能被缓存。幸运的是，我们可以将我们的
    CSRF 值从 cookie 移出，并将其存储在服务器端会话中，只需通过 `settings.py` 进行更改。
- en: Deciding on the right CSRF strategy for your app can be complex. For example,
    AJAX applications will want to add CSRF tokens through headers. For most sites,
    the default Django configuration (using cookies) is fine. If you need to change
    it, it's worth reviewing Django's CSRF protection documentation ([https://docs.djangoproject.com/en/2.0/ref/csrf/](https://docs.djangoproject.com/en/2.0/ref/csrf/)).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的应用程序决定正确的 CSRF 策略可能是复杂的。例如，AJAX 应用程序将希望通过标头添加 CSRF 令牌。对于大多数站点，默认的 Django
    配置（使用 cookie）是可以的。如果您需要更改它，值得查看 Django 的 CSRF 保护文档（[https://docs.djangoproject.com/en/2.0/ref/csrf/](https://docs.djangoproject.com/en/2.0/ref/csrf/)）。
- en: 'In `django/conf/settings.py`, add the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `django/conf/settings.py` 中，添加以下代码：
- en: '[PRE13]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, Django won't send the CSRF token in a cookie, but will store it in the
    user's session (stored on the server).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Django 不会将 CSRF 令牌发送到 cookie 中，而是将其存储在用户的会话中（存储在服务器上）。
- en: If users already have CSRF cookies, they will be ignored; however, it will still
    have a dampening effect on the hit ratio. In production, you may wish to consider
    adding a bit of code to delete those CSRF cookies.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户已经有CSRF cookie，它们将被忽略；但是，它仍然会对命中率产生抑制作用。在生产环境中，您可能希望考虑添加一些代码来删除这些CSRF cookie。
- en: Now that we have a way of easily mixing in caching behavior, let's use it in
    our `MovieList` view.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一种轻松混合缓存行为的方法，让我们在`MovieList`视图中使用它。
- en: Using CachePageVaryOnCookieMixin with MovieList
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用CachePageVaryOnCookieMixin与MovieList
- en: 'Let''s update our view in `django/core/views.py`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`django/core/views.py`中更新我们的视图：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now when `MovieList` gets a request routed to it, `cache_page` will check whether
    it has already been cached. If it has been cached, Django will return the cached
    response without doing any more work. If it hasn't been cached, our regular `MovieList`
    view will create a new response. The new response will have a `VARY cookie` header
    added and then get cached.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当`MovieList`收到路由请求时，`cache_page`将检查它是否已被缓存。如果已经被缓存，Django将返回缓存的响应，而不做任何其他工作。如果没有被缓存，我们常规的`MovieList`视图将创建一个新的响应。新的响应将添加一个`VARY
    cookie`头，然后被缓存。
- en: Next, let's try to cache a part of our Top 10 movie list inside a template.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试在模板中缓存我们的前10部电影列表的一部分。
- en: Caching a template fragment with {% cache %}
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`{% cache %}`缓存模板片段
- en: Sometimes, pages load slowly because a part of our template is slow. In this
    section, we'll take a look at how to solve this problem by caching a fragment
    of our template. For example, if you are using a tag that takes a long time to
    resolve (say, because it makes a network request), then it will slow down any
    page that uses that tag. If you can't optimize the tag itself, it may be sufficient
    to cache its result in the template.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，页面加载缓慢是因为我们模板的某个部分很慢。在本节中，我们将看看如何通过缓存模板的片段来解决这个问题。例如，如果您使用的标签需要很长时间才能解析（比如，因为它发出了网络请求），那么它将减慢使用该标签的任何页面。如果无法优化标签本身，将模板中的结果缓存可能就足够了。
- en: 'Let''s cache our rendered Top 10 Movies list by editing `django/core/templates/core/top_movies.html`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑`django/core/templates/core/top_movies.html`来缓存我们渲染的前10部电影列表：
- en: '[PRE15]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This block introduces us to the `{% load %}` tag and the `{% cache %}` tag.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这个块向我们介绍了`{% load %}`标签和`{% cache %}`标签。
- en: The `{% load %}` tag is used to load a library of tags and filters and make
    them available for use in a template. A library may provide one or more tags and/or
    filters. For example, `{% load humanize %}` loads tags and filters to make values
    look more human. In our case, `{% load cache %}` provides only the `{% cache %}`
    tag.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% load %}`标签用于加载标签和过滤器的库，并使它们可用于模板中使用。一个库可以提供一个或多个标签和/或过滤器。例如，`{% load humanize
    %}`加载标签和过滤器，使值看起来更人性化。在我们的情况下，`{% load cache %}`只提供了`{% cache %}`标签。'
- en: '`{% cache 300 top10 %}` will cache the body of the tag for the provided number
    of seconds under the provided key. The second argument must be a hardcoded string
    (not a variable), but we can provide more arguments if the fragment needs to have
    variants (for example, `{% cache 300 mykey request.user.id %}` to cache a separate
    fragment for each user). The tag will use the `default` cache unless the last
    argument is `using=''cachename''`, in which case the named cache will be used
    instead.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`{% cache 300 top10 %}`将在提供的秒数下缓存标签的主体，并使用提供的键。第二个参数必须是一个硬编码的字符串（而不是一个变量），但如果片段需要有变体，我们可以提供更多的参数（例如，`{%
    cache 300 mykey request.user.id %}`为每个用户缓存一个单独的片段）。该标签将使用`default`缓存，除非最后一个参数是`using=''cachename''`，在这种情况下，将使用命名缓存。'
- en: Caching with `{% cache %}` happens at a different level than when using `cache_page`
    and `vary_on_cookie`. All the code in the view will still be executed. Any slow
    code in the view will still slow us down. Caching a template fragment solves only
    one very particular case of a slow fragment in our template code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`{% cache %}`进行缓存发生在不同的级别，而不是使用`cache_page`和`vary_on_cookie`。视图中的所有代码仍将被执行。视图中的任何缓慢代码仍将减慢我们的速度。缓存模板片段只解决了我们模板代码中一个非常特定的缓慢片段的问题。
- en: Since `QuerySets` are lazy by putting our `for` loop inside `{% cache %}`, we've
    avoided evaluating the `QuerySet`. If we want to cache a value to avoid querying
    it, our code would be much clearer if we did it in the view.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`QuerySets`是懒惰的，通过将我们的`for`循环放在`{% cache %}`中，我们避免了评估`QuerySet`。如果我们想缓存一个值以避免查询它，如果我们在视图中这样做，我们的代码会更清晰。
- en: Next, let's look at how to cache an object using Django's cache API.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何使用Django的缓存API缓存对象。
- en: Using the cache API with objects
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象的缓存API
- en: The most granular use of Django's cache API is to store objects compatible with
    Python's `pickle` serialization module. The `cache.get()`/`cache.set()` methods
    we'll see here are used internally by the `cache_page()` decorator and the `{%
    cache %}` tag. In this section, we'll use these methods to cache the `QuerySet`
    returned by `Movie.objects.top_movies()` .
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Django的缓存API最精细的用法是存储与Python的`pickle`序列化模块兼容的对象。我们将在这里看到的`cache.get()`/`cache.set()`方法在`cache_page()`装饰器和`{%
    cache %}`标签内部使用。在本节中，我们将使用这些方法来缓存`Movie.objects.top_movies()`返回的`QuerySet`。
- en: Conveniently, `QuerySet` objects are pickleable. When a `QuerySets` is pickled,
    it will immediately be evaluated, and the resulting models will be stored in the
    built-in cache of the `QuerySet`. When unpickling a `QuerySet`, we can iterate
    over it without causing new queries. If the `QuerySet` had `select_related` or
    `prefetch_related`, those queries would execute on pickling and *not* rerun on
    unpickling.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 方便的是，`QuerySet`对象是可pickle的。当`QuerySets`被pickled时，它将立即被评估，并且生成的模型将存储在`QuerySet`的内置缓存中。在unpickling一个`QuerySet`时，我们可以迭代它而不会引起新的查询。如果`QuerySet`有`select_related`或`prefetch_related`，那些查询将在pickling时执行，而在unpickling时不会重新运行。
- en: 'Let''s remove our `{% cache %}` tag from `top_movies_list.html` and instead
    update `django/core/views.py`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`top_movies_list.html`中删除`{% cache %}`标签，而是更新`django/core/views.py`：
- en: '[PRE16]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Our new `TopMovies` view overrides the `get_queryset` method and checks the
    cache before using `MovieManger.top_movies()`. Pickling `QuerySet` objects does
    come with one caveat—they are not guaranteed to be compatible across Django versions,
    so we should check the version used before proceeding.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新`TopMovies`视图重写了`get_queryset`方法，并在使用`MovieManger.top_movies()`之前检查缓存。对`QuerySet`对象进行pickling确实有一个警告——不能保证在不同的Django版本中兼容，因此在继续之前应该检查所使用的版本。
- en: '`TopMovies` also shows a different way of accessing the default cache than
    what `VaryOnCookieCache` used. Here, we import and use `django.core.cache.cache`,
    which is a proxy for `django.core.cache.caches[''default'']` .'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`TopMovies`还展示了一种访问默认缓存的不同方式，而不是`VaryOnCookieCache`使用的方式。在这里，我们导入并使用`django.core.cache.cache`，它是`django.core.cache.caches[''default'']`的代理。'
- en: It's important to remember the importance of consistent keys when caching using
    a low-level API. In a large code base, it's easy to store the same data under
    different keys leading to inefficiency. It can be convenient to put the caching
    code into your manager or into a utility module.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用低级API进行缓存时，记住一致的键的重要性是很重要的。在大型代码库中，很容易在不同的键下存储相同的数据，导致效率低下。将缓存代码放入管理器或实用程序模块中可能很方便。
- en: Summary
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we made a Top 10 Movies view, reviewed tools for instrumenting
    your Django code, and covered how to use Django's cache API. Django and Django's
    community provide tools for helping you discover where to optimize your code using
    profilers, the Django Debug Toolbar, and logging. Django's caching API helps us
    with a rich API to cache whole pages with `cache_page`, the `{% cache %}` template
    tag for template fragments, and `cache.set`/`cache.get` for caching any picklable
    object.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个Top 10电影视图，审查了用于检测Django代码的工具，并介绍了如何使用Django的缓存API。Django和Django社区提供了帮助您发现在哪里优化代码的工具，包括使用分析器、Django调试工具栏和日志记录。Django的缓存API通过`cache_page`缓存整个页面，通过模板标签`{%
    cache %}`缓存模板片段，以及通过`cache.set`/`cache.get`缓存任何可picklable对象，为我们提供了丰富的API。
- en: Next, we'll deploy MyMDB with Docker.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用Docker部署MyMDB。
