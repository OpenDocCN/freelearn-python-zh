- en: Dockerizing Your Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的服务Docker化
- en: Now that we have an understanding of continuous integration and continuous delivery/deployment
    from the previous chapter, it is the right time to dive deeply into container-based
    technologies, such as Docker, where we will deploy our application. In this chapter,
    we will take a look at Docker and its features, and we will deploy our cloud native
    application on Docker.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经从上一章了解了持续集成和持续交付/部署，现在是深入研究基于容器的技术，比如Docker，我们将在其中部署我们的应用程序的正确时机。在本章中，我们将看一下Docker及其特性，并在Docker上部署我们的云原生应用。
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding Docker and how it is different from virtualization
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Docker及其与虚拟化的区别
- en: Installing Docker and Docker Swarm on a different OS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同操作系统上安装Docker和Docker Swarm
- en: Deploying a cloud native app on Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Docker上部署云原生应用
- en: Using Docker Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Docker Compose
- en: Understanding Docker
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解Docker
- en: Docker is a **Container Management System** (**CMS**) that enables you to separate
    your application from your infrastructure, which makes it easier to develop, ship,
    and run your application. It is useful for managing **Linux Containers** (**LXC**).
    This let's you create images, and also perform actions on the containers as well
    as run commands or operations against containers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker是一个**容器管理系统**（**CMS**），它使您能够将应用程序与基础架构分离，这样更容易开发、部署和运行应用程序。它对管理**Linux容器**（**LXC**）很有用。这让您可以创建镜像，并对容器执行操作，以及对容器运行命令或操作。
- en: In simple words, Docker provides a platform to package and run your application
    in an isolated environment called a **container**, and then ship it across different
    of software release environments, such as stage, pre-production, production, and
    so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Docker提供了一个在被称为**容器**的隔离环境中打包和运行应用程序的平台，然后在不同的软件发布环境中进行部署，如阶段、预生产、生产等。
- en: '**Docker** is lightweight in comparison to any **Traditional VMs**, as depicted
    in the following image:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**与任何**传统VM**相比都更轻量，如下图所示：'
- en: '![](img/00130.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00130.jpeg)'
- en: Few facts about Docker versus virtualization
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于Docker与虚拟化的一些事实
- en: 'There are a lot of organizations that are still working successfully on traditional
    VMs. Having said that, there are organizations that have either moved their application
    to Docker or are ready to do so. Here are a few reasons why Docker has more potential
    than virtual machines:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然成功地在传统VM上工作的组织有很多。话虽如此，有些组织已经将他们的应用程序迁移到了Docker上，或者准备这样做。以下是Docker比虚拟机具有更多潜力的几个原因：
- en: When it comes to comparing Docker and virtual machines, Docker presents a lower
    system overhead than the virtual machine.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在比较Docker和虚拟机时，Docker的系统开销比虚拟机低。
- en: Secondly, applications in the Docker environment have a generally higher performance
    than the virtual machines.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，在Docker环境中的应用程序通常比虚拟机性能更高。
- en: While the VM software technology named **Hypervisor**, which acts as an agent
    between the VM environment and the underlying hardware, providing the necessary
    layer of abstraction; in Docker, we have the Docker engine that gives us more
    control than the Docker machine.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而VM软件技术名为**Hypervisor**，它充当VM环境和底层硬件之间的代理，提供必要的抽象层；在Docker中，我们有Docker引擎，它比Docker机器给我们更多的控制。
- en: Also, as you can see in the preceding image, Docker shares the **Host O.S.**
    across the Docker environment, whereas, the virtual machine needs its own OS for
    application deployment. This makes Docker lightweight and spin up and destroy
    them much faster, as compared to the virtual machine. Docker is similar to any
    other processes running on top of the host OS.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，正如您在上图中所看到的，Docker在Docker环境中共享**主机操作系统**，而虚拟机需要自己的操作系统进行应用程序部署。这使得Docker更轻量化，可以更快地启动和销毁，与虚拟机相比。Docker类似于在主机操作系统上运行的任何其他进程。
- en: In the case of a cloud native application, where we need to test our microservices
    quickly after every stage of development, Docker would be a good platform option
    to test our application, which is highly recommended.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在云原生应用的情况下，我们需要在每个开发阶段之后快速测试我们的微服务，Docker将是一个很好的平台选项来测试我们的应用程序，这是强烈推荐的。
- en: Docker Engine - The backbone of Docker
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Engine - Docker的支柱
- en: 'Docker Engine is a client-server application that has the following components:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine是一个客户端服务器应用程序，具有以下组件：
- en: '**Dockerd**: This is a daemon process that keeps running in the background
    of the host OS to keep a track of the Docker container attributes, such as status
    (up/running/stopped)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerd**：这是一个守护进程，以在主机操作系统的后台持续运行，以跟踪Docker容器属性，如状态（启动/运行/停止）'
- en: '**Rest API**: This provides the interface to interact with daemon and perform
    actions on containers'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Rest API**：这提供了与守护程序交互并在容器上执行操作的接口'
- en: '**Docker command line**: This provides the command-line interface to create
    and manage Docker objects, such as images, containers, networks, and volumes'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker命令行**：这提供了命令行界面来创建和管理Docker对象，如镜像、容器、网络和卷'
- en: Setting up the Docker environment
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker环境
- en: In this section, we will take a look at the installation procedure for Docker
    on different operating systems, such as Debian and Windows, among others.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看一下在不同操作系统上安装Docker的过程，比如Debian和Windows等。
- en: Installing Docker on Ubuntu
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Ubuntu上安装Docker
- en: Setting up Docker is pretty straightforward. There are mainly two editions of
    Docker in the marketplace.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 设置Docker非常简单。市场上主要有两个版本的Docker。
- en: Docker Inc., which owns the **containerization** Docker product, renamed the
    Docker **Commercially Supported** (**CS**) edition to Docker **Enterprises Edition**
    (**EE**), and also converted the Docker Engine to Docker **Community Edition**
    (**CE**).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Inc.拥有**容器化**Docker产品，将Docker **商业支持**（**CS**）版更名为Docker **企业版**（**EE**），并将Docker
    Engine转换为Docker **社区版**（**CE**）。
- en: There are a couple of changes from EE and CE; obviously, the commercial support
    being one of them. However, in the Docker Enterprise Edition, they have built
    a couple of certifications around the container content, platform plugins, and
    many more.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: EE和CE有一些变化；显然，商业支持是其中之一。但是，在Docker企业版中，他们围绕容器内容、平台插件等构建了一些认证。
- en: 'In this book, we will use the Docker Community Edition, so we will begin by
    updating the APT repository:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用Docker社区版，因此我们将从更新APT存储库开始：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s add the GPG key from the Docker official system as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下步骤从Docker官方系统添加GPG密钥：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then let''s add the Docker repository to the APT source list of Ubuntu:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后让我们将Docker存储库添加到Ubuntu的APT源列表中：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, in Ubuntu 14.04/16.04, the `apt-add-repository` utility is not found.
    In order to install the mentioned utility, use the following command to install
    the `software-properties-common` package: **$ sudo apt-get install software-properties-common
    -y**.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在Ubuntu 14.04/16.04中找不到`apt-add-repository`实用程序。为了安装所述的实用程序，请使用以下命令安装`software-properties-common`软件包：**$
    sudo apt-get install software-properties-common -y**。
- en: 'Next, update your APT package manager to download the latest Docker list as
    follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，更新APT软件包管理器以下载最新的Docker列表，如下所示：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If you want to download and install the Docker Engine from the Docker repository
    instead of the default 14.04 repository, use the following command to do so:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想从Docker存储库而不是默认的14.04存储库下载并安装Docker Engine，请使用以下命令：
- en: '**$ apt-cache policy docker-engine**.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**$ apt-cache policy docker-engine**。'
- en: 'You will see the following output on the terminal:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在终端上看到以下输出：
- en: '![](img/00131.jpeg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00131.jpeg)'
- en: 'Now, we are ready to install our Docker Engine, so let''s fire the following
    command to install it:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备安装我们的Docker Engine，所以让我们执行以下命令来安装它：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Since Docker depends on a couple of system libraries, it might face an error
    similar to the one shown in the following screenshot:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker依赖于一些系统库，可能会遇到类似于以下截图显示的错误：
- en: '![](img/00132.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00132.jpeg)'
- en: If you catch this kind of error, then make sure that you have these libraries
    installed with the defined version as well.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到此类错误，请确保已安装这些库并且版本已定义。
- en: 'After the Docker Engine installation is successful, it''s time to validate
    it by executing the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine安装成功后，现在是时候通过执行以下命令来验证它了：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you see a version similar to the one shown in the preceding terminal, then
    we are good to go.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似于前面终端显示的版本，则我们可以开始了。
- en: 'To get help on Docker, you can execute the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取有关Docker的帮助，可以执行以下命令：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If you really want to go with the Docker Enterprise Edition, you can go ahead
    with the installation steps shown on the official Docker website ([https://docs.docker.com/engine/installation/linux/ubuntu/](https://docs.docker.com/engine/installation/linux/ubuntu/)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您真的想使用Docker企业版，可以按照官方Docker网站上显示的安装步骤进行操作（[https://docs.docker.com/engine/installation/linux/ubuntu/](https://docs.docker.com/engine/installation/linux/ubuntu/)）。
- en: Installation on Windows
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Windows上安装
- en: Ideally, Windows is not suitable for Docker, and that's why you don't see the
    container technology around on the Windows system. Having said that, we have a
    couple of workarounds for it. One of them is using Chocolatey.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，Windows不适合Docker，这就是为什么您在Windows系统上看不到容器技术的原因。话虽如此，我们有一些解决方法。其中之一是使用Chocolatey。
- en: 'In order to install Docker on the Windows system using Chocolatey, follow these
    steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Chocolatey在Windows系统上安装Docker，请按照以下步骤进行操作：
- en: Install Chocolatey from their official website ([https://chocolatey.org/install](https://chocolatey.org/install)).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从官方网站安装Chocolatey（[https://chocolatey.org/install](https://chocolatey.org/install)）。
- en: There are couple of ways shown in the preceding link to install Chocolatey.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的链接中显示了安装Chocolatey的几种方法。
- en: 'Once Chocolatey is installed, you simply have to execute the following command
    in cmd or PowerShell:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装了Chocolatey后，您只需在cmd或PowerShell中执行以下命令：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will install Docker on Windows 7 and 8 operating systems.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在Windows 7和8操作系统上安装Docker。
- en: 'Similarly, if you want to go with the Docker Enterprise edition, you can follow
    the steps shown in this link:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果您想使用Docker企业版，可以按照此链接中显示的步骤进行操作：
- en: '[https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee](https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee](https://docs.docker.com/docker-ee-for-windows/install/#install-docker-ee)。'
- en: Setting up Docker Swarm
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker Swarm
- en: Docker Swarm is a popular term for a pool of Docker machines. Docker Swarm is
    very useful for hosting your website as it can be used to scale your infrastructure
    up or down very quickly.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm是Docker机器池的常用术语。 Docker Swarm非常有用，因为它可以快速扩展或缩小基础架构，用于托管您的网站。
- en: In the Docker Swarm, we can club together a couple of Docker machines that work
    as one unit and share their resources, such as CPU, memory, and so on, where one
    machine becomes the master that we call leader, and the remaining nodes work as
    a worker.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker Swarm中，我们可以将几台Docker机器组合在一起，作为一个单元共享其资源，例如CPU、内存等，其中一台机器成为我们称之为领导者的主机，其余节点作为工作节点。
- en: '![](img/00133.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00133.jpeg)'
- en: Setting up the Docker environment
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Docker环境
- en: In this section, we will be setting up the Docker Swarm by selecting the leader
    from the Docker machine and connecting the remaining machines with the leader.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将通过从Docker机器中选择领导者并将其余机器连接到领导者来设置Docker Swarm。
- en: Assumption
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: 'The following are a few assumptions for the Docker environment:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Docker环境的一些假设：
- en: We are taking two machines, which could be VM's or instances from the cloud
    platform, for the demo purpose named master and node1\. Also, we have installed
    Docker on both the machines by following the procedure described in the Docker
    installation section.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用两台机器，可以是虚拟机或来自云平台的实例，以演示为目的命名为master和node1。此外，我们已经按照Docker安装部分中描述的过程在这两台机器上安装了Docker。
- en: Port `2377` must be opened for communication between the master and node1.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口`2377`必须打开以便主节点和节点1之间进行通信。
- en: Make sure the required port for application access should be opened; we will
    need port `80` for nginx, just like in our example.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保应用程序访问所需的端口应该是打开的；我们将需要端口`80`来使用nginx，就像我们的示例中一样。
- en: The master Docker machine could be based on any kind of OS, such as Ubuntu,
    Windows, and so on.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主Docker机器可以基于任何类型的操作系统，例如Ubuntu、Windows等。
- en: Now, let's begin with our Docker Swarm setup.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始我们的Docker Swarm设置。
- en: Initializing the Docker manager
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化Docker管理器
- en: 'At this point, we need to decide which node should be the leader. Let''s select
    the master node as our Docker manager. So, login into the master machine and execute
    the following command to initialize this machine to be a leader for the Docker
    Swarm:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们需要决定哪个节点应该成为领导者。让我们选择主节点作为我们的Docker管理器。因此，请登录到主机并执行以下命令，以初始化此机器为Docker
    Swarm的领导者：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This command will set the provided host to be the master (leader) and generate
    a token for the node to connect to. See the following output for your reference:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将设置提供的主机为主（领导者），并为节点生成一个连接的令牌。请参考以下输出：
- en: '![](img/00134.jpeg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00134.jpeg)'
- en: 'A few important points to keep in mind:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一些重要点：
- en: Don't share your token and IP address with anyone
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要与任何人分享您的令牌和IP地址
- en: Secondly, it is possible to have multiple masters in case of failovers
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，在故障转移的情况下可能会有多个主节点
- en: Add node1 to master
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将节点1添加到主节点
- en: 'Now that we selected the leader, we will need to add a new node to the cluster
    to complete the setup. Log in to node1 and execute the following command, which
    is specified in the previous command output:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经选择了领导者，我们需要添加一个新节点到集群中以完成设置。登录到节点1并执行前面命令输出中指定的以下命令：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can refer to the following screenshot for an output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以参考以下截图输出：
- en: '![](img/00135.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00135.jpeg)'
- en: This means our setup is successful. Let's check if it is added in the master
    Docker machine or not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的设置是成功的。让我们检查它是否已添加到主Docker机器中。
- en: 'Execute the following command to verify it:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令进行验证：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![](img/00136.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00136.jpeg)'
- en: Testing the Docker Swarm
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试Docker Swarm
- en: 'Now that we have set up the Docker Swarm, it''s time to run some services on
    top of it, say, the nginx service. Execute the following command on the master
    Docker machine to start your nginx service on port `80`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置了Docker Swarm，现在是时候在其上运行一些服务了，比如nginx服务。在主Docker机器上执行以下命令，以在端口`80`上启动您的nginx服务：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command should be similar to the following screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出应该类似于以下截图：
- en: '![](img/00137.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00137.jpeg)'
- en: 'Let''s use the following Docker command to see if our service is running or
    not:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下Docker命令来查看我们的服务是否正在运行：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The output of preceding command should be similar to the following screenshot:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 前面命令的输出应该类似于以下截图：
- en: '![](img/00138.jpeg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00138.jpeg)'
- en: 'A few other commands to validate are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些验证命令如下：
- en: 'To validate which services are running and on which port, use the following
    command:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证哪些服务正在运行以及在哪个端口上，请使用以下命令：
- en: '[PRE13]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If you are seeing output similar to the following screenshot, then we are good:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到类似以下截图的输出，那么一切正常：
- en: '![](img/00139.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00139.jpeg)'
- en: 'To scale up the Docker instances for the service, use the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展服务的Docker实例，请使用以下命令：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![](img/00140.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00140.jpeg)'
- en: 'Let''s check if our nginx is up or not by accessing its default page. Try to
    hit `http://master-ip-address:80/` on your browser. If you see the following output,
    then your service is deployed successfully:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问其默认页面来检查我们的nginx是否已经启动。尝试在浏览器中输入`http://master-ip-address:80/`。如果您看到以下输出，则您的服务已成功部署：
- en: '![](img/00141.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00141.jpeg)'
- en: Awesome! In the upcoming section, we will deploy our cloud native application
    on Docker machines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！在接下来的部分，我们将在Docker机器上部署我们的云原生应用程序。
- en: Deploying an application on Docker
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Docker上部署应用程序
- en: 'In this section, we will deploy our cloud native application, which we developed
    in the previous chapters. However, before we begin with the creation of our application
    architecture, there are a few concepts of Docker one should be aware of, some
    of which are as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署我们的云原生应用程序，这是我们在前几章中开发的。然而，在我们开始创建应用程序架构之前，有一些Docker的概念是应该了解的，其中一些如下：
- en: '**Docker images**: These are basically a combination of library and the applications
    deployed on top of it. These images can be downloaded from the Docker Hub public
    repository, or you can create your customized images as well.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker镜像**：这些基本上是库和部署在其上的应用程序的组合。这些图像可以从Docker Hub公共存储库下载，或者您也可以创建自定义图像。'
- en: '**Dockerfile**: This is a configuration file to build your images that can
    be used to run your Docker machine later on.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dockerfile**：这是一个配置文件，用于构建可以在以后运行Docker机器的图像。'
- en: '**Docker Hub**: This is a centralized repository where you can keep your images,
    which can be shared across the team.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：这是一个集中的存储库，您可以在其中保存图像，并可以在团队之间共享。'
- en: We will use all these concepts during our application deployment. Also, we will
    keep using our Docker Swarm setup to deploy our application as we don't want to
    run out of resources.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在应用部署过程中使用所有这些概念。此外，我们将继续使用我们的Docker Swarm设置来部署我们的应用程序，因为我们不想耗尽资源。
- en: 'We will follow this architecture to deploy our application, where we are deploying
    our application and MongoDB (basically, application data) in separate Docker instances
    as it is recommended to always keep your application and data separate:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循这个架构来部署我们的应用程序，我们将我们的应用程序和MongoDB（基本上是应用程序数据）部署在单独的Docker实例中，因为建议始终将应用程序和数据分开：
- en: '![](img/00142.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00142.jpeg)'
- en: Building and running our MongoDB Docker service
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建和运行我们的MongoDB Docker服务
- en: In this section, we will be creating the Dockerfile to build `MongoDB`, which
    will have all the information, such as base image, port to be exposed, how to
    install the `MongoDB` service, and so on.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建Dockerfile来构建`MongoDB`，其中将包含所有信息，例如基本图像、要公开的端口、如何安装`MongoDB`服务等。
- en: 'Now, let''s log in to your Docker master (leader) account and create a Dockerfile
    with the name `Dockerfile` using the following contents:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们登录到您的Docker主（领导）帐户，并使用以下内容创建名为`Dockerfile`的Docker文件：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save it, and, before we move ahead, let''s understand its different sections
    as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 保存它，在我们继续之前，让我们了解其不同的部分，如下所示：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code will tell you to pull the Ubuntu public image from the Docker
    Hub and make it the base image on which the following command needs to be run:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将告诉您从Docker Hub拉取Ubuntu公共图像，并将其作为基础图像运行以下命令：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding section of code is similar to the one where we execute these commands
    manually for `MongoDB`; however, in this case, it is automatically taken care
    of by Docker.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码部分类似于我们手动执行这些命令为`MongoDB`；但是，在这种情况下，Docker会自动处理。
- en: Next is the volume section, which is kind of optional. It is creating mountable
    directories where we can store the data to keep it safe in an external volume.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是卷部分，这在某种程度上是可选的。它正在创建可挂载的目录，我们可以在其中存储数据以在外部卷中保持安全。
- en: '[PRE18]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The next section is to expose the ports by which users/clients will be able
    to communicate with the MongoDB server:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分是通过这些端口公开的，用户/客户端将能够与MongoDB服务器进行通信：
- en: '[PRE19]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once you have saved the file, execute the following command to build the image:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 保存文件后，执行以下命令构建图像：
- en: '[PRE20]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Building an image can take around 4-5 minutes, depending on the internet bandwidth
    and system performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 构建图像可能需要大约4-5分钟，这取决于互联网带宽和系统性能。
- en: 'The following screen shows the output of the Docker build command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕显示了Docker构建命令的输出：
- en: '![](img/00143.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00143.jpeg)'
- en: In the preceding screenshot, as it's showing a successful build, you can now
    see the images list to validate, whether the image with the mentioned tag name
    (**ms-packtpub-mongodb**) is present or not.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，由于显示了成功构建，现在您可以查看图像列表以验证是否存在具有所述标记名称（**ms-packtpub-mongodb**）的图像。
- en: 'Use the following command to list the images:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令列出图像：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The following screen lists the Docker images available:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕列出了可用的Docker图像：
- en: '![](img/00144.jpeg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00144.jpeg)'
- en: 'Awesome! Our image is present. Now let''s run the `mongodb` service on the
    master Docker machine using the following command:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的图像已经存在。现在让我们使用以下命令在主Docker机器上运行`mongodb`服务：
- en: '[PRE22]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the output, you will get a random Docker ID, as shown in the following screenshot:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，您将获得一个随机的Docker ID，如下面的截图所示：
- en: '![](img/00145.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00145.jpeg)'
- en: 'Let''s check the state of the Docker container by executing the `docker ps`
    command. It should have an output similar to the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行`docker ps`命令来检查Docker容器的状态。它的输出应该类似于以下截图：
- en: '![](img/00146.jpeg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00146.jpeg)'
- en: A very few developers as well as sysadmins know that there is an HTTP interface
    for the `mongoDB` service, which we exposed using port `28017`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 很少有开发人员和系统管理员知道`mongoDB`服务有一个HTTP接口，我们使用端口`28017`进行了暴露。
- en: 'So, if we try to access `http://your-master-ip-address:28017/` in the browser,
    we will see a screen similar to the following screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们尝试在浏览器中访问`http://your-master-ip-address:28017/`，我们将看到类似于以下截图的屏幕：
- en: '![](img/00147.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00147.jpeg)'
- en: Awesome! Our MongoDB is up and running now!!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的MongoDB现在已经运行起来了！
- en: Before we move ahead with launching containers for the application, let's understand
    how the Docker Hub is useful for us.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续为应用程序启动容器之前，让我们了解一下Docker Hub对我们有何用处。
- en: Docker Hub - what is it all about?
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Hub - 它是关于什么的？
- en: As per the Docker Hub official documentation, Docker Hub is a cloud-based registry
    service that allows you to link to code repositories, build your images and test
    them, and store manually pushed images, and links to Docker Cloud so you can deploy
    images to your hosts.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Docker Hub官方文档，Docker Hub是一个基于云的注册表服务，允许您链接到代码存储库，构建图像并对其进行测试，并存储手动推送的图像，并链接到Docker
    Cloud，以便您可以将图像部署到您的主机。
- en: In simpler words, Docker Hub is a centralized store for images which anyone
    around the globe can access, provided they have the required privileges and can
    perform operations around images to deploy and run their application on their
    hosts.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Docker Hub是一个集中存储图像的地方，全球任何人都可以访问，只要他们具有所需的权限，并且可以执行围绕图像的操作，以在其主机上部署和运行其应用程序。
- en: 'Advantages of Docker Hub are as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub的优点如下：
- en: Docker Hub provides the functionality for automated create builds if any change
    in the source code repository is reported
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub提供了自动创建构建的功能，如果源代码存储库中报告了任何更改
- en: It provides WebHook to trigger for application deployment after a successful
    push to the repository
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了WebHook，用于在成功推送到存储库后触发应用程序部署
- en: It provides functionality to create a private work space to store images and
    is accessible only within your organization or team
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了创建私有工作空间以存储图像的功能，并且只能在您的组织或团队内部访问
- en: Docker Hub has an integration with your version control system, such as GitHub,
    BitBucket, and so on, which is useful with continuous integration and delivery
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub与您的版本控制系统（如GitHub、BitBucket等）集成，这对持续集成和交付非常有用
- en: Now, let's see how we can push our custom `MongoDB` images to a private repository
    that we created recently.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何将我们的自定义`MongoDB`图像推送到我们最近创建的私有存储库。
- en: 'First, you need to create an account at [https://hub.docker.com](https://hub.docker.com)
    and activate it. Once you are logged in, you need to create a private/public repository
    based on your preference, as shown in the following screenshot:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要在[https://hub.docker.com](https://hub.docker.com)创建一个帐户并激活它。一旦登录，您需要根据自己的喜好创建私有/公共存储库，如下所示：
- en: '![](img/00148.jpeg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00148.jpeg)'
- en: 'Click on the Create button to set up the repository and you will be redirected
    to the following screen:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 单击“创建”按钮设置仓库，您将被重定向到以下屏幕：
- en: '![](img/00149.jpeg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00149.jpeg)'
- en: Docker Hub provides only one private repository on a free account.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Hub在免费帐户上只提供一个私有仓库。
- en: 'Now that we have created the repository, let''s come back to our master Docker
    machine and execute the following command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了仓库，让我们回到我们的主Docker机器并执行以下命令：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will ask for your credentials for the Docker Hub account, as shown in
    the following screenshot:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这将要求您输入Docker Hub帐户的凭据，如下截图所示：
- en: '![](img/00150.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00150.jpeg)'
- en: 'Once the login is successful, it''s time to tag the image you want to push
    to the repository using the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，是时候使用以下命令为要推送到仓库的镜像打标签了：
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If we don't specify the tag, then it will take the latest tag by default.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定标签，那么它将默认使用最新的标签。
- en: 'Once the tag is created, it''s time to push the tag to the repository. Use
    the following command to do so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 标签创建完成后，是时候将标签推送到仓库了。使用以下命令来执行：
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Following screen shows the Docker `push` command output:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕显示了Docker `push`命令的输出：
- en: '![](img/00151.jpeg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00151.jpeg)'
- en: 'Once the push is completed, you will see the image in Docker Hub in the Tags
    tab, as shown here:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 推送完成后，您将在Docker Hub的“标签”选项卡中看到镜像，如此处所示：
- en: '![](img/00152.jpeg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00152.jpeg)'
- en: This means that your image is pushed successfully.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您的镜像已成功推送。
- en: 'In order to pull this image, you will simply have to use the following command:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要拉取此镜像，您只需使用以下命令：
- en: '[PRE26]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Oh, wow! It's too simple and you can access it from anywhere, provided you have
    credentials.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，哇！这太简单了，只要您有凭据，就可以从任何地方访问它。
- en: There are other Docker registry providers such as AWS (EC2 container registry),
    Azure (Azure container registry), and so on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他Docker注册表提供者，如AWS（EC2容器注册表）、Azure（Azure容器注册表）等。
- en: For now, this is all we have from the Docker Hub side. We will keep on using
    Docker Hub during this chapter to push the images.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这就是我们从Docker Hub那边得到的全部内容。在本章中，我们将继续使用Docker Hub来推送镜像。
- en: 'Moving ahead now, we are ready to deploy our cloud native application to another
    container, but, before that, we need to build an image for it using the Dockerfile.
    So, let''s create a directory called `app` and also create an empty Dockerfile
    with the following contents:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续，我们准备将我们的云原生应用部署到另一个容器中，但在此之前，我们需要使用Dockerfile为其构建一个镜像。因此，让我们创建一个名为`app`的目录，并创建一个空的Dockerfile，其中包含以下内容：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: I believe I have explained most of the section inside the Dockerfile earlier,
    although, there are a few sections that still need to be explained.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信我之前已经解释了Dockerfile中大部分部分，尽管还有一些部分需要解释。
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding section of the Dockerfile, we copied the contents of the application,
    that is, the code, from a local machine to the Docker container. Alternatively,
    we can also use ADD to do the same.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在Dockerfile的前面部分，我们将应用程序的内容，即代码，从本地机器复制到Docker容器中。或者，我们也可以使用ADD来执行相同的操作。
- en: 'The `CMD` is short for the command that we want to execute inside the Docker
    container, which is defined as follows in the Dockerfile:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD`是我们想要在Docker容器内执行的命令的缩写，它在Dockerfile中定义如下：'
- en: '[PRE29]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, save the file and run the following command to build the image:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在保存文件并运行以下命令来构建镜像：
- en: '[PRE30]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This might take a while as there are lot of libraries that need to be installed
    and compiled as well. It is good practice to build an image after every change
    to make sure images are updated with the current config. The output will be similar
    to one shown here:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能需要一些时间，因为需要安装和编译许多库。每次更改后构建镜像是一个好习惯，以确保镜像与当前配置更新。输出将类似于此处显示的输出：
- en: '![](img/00153.jpeg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00153.jpeg)'
- en: Make sure every section of the build process is successful.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 确保构建过程的每个部分都成功。
- en: Now that we are ready with our image, it's time to spin our container with the
    latest image.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了我们的镜像，是时候使用最新的镜像启动我们的容器了。
- en: 'Execute the following command to spin the container, and always remember to
    expose port `5000` to access our application:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下命令来启动容器，并始终记住要暴露端口`5000`以访问我们的应用程序：
- en: '[PRE31]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, run the `docker ps` command to check the container status:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行`docker ps`命令来检查容器状态：
- en: '![](img/00154.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00154.jpeg)'
- en: 'As you can see, there are two containers running in the `myapp` container:
    we will have our application running and on the `mongodb` container, you will
    have your `mongodb` service running.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`myapp`容器中有两个容器在运行：我们的应用程序在运行，而`mongodb`容器中将运行您的`mongodb`服务。
- en: 'Next, check the application URL (`http://your-master-ip-address:5000/`). If
    you see the following screen, it means that our application is deployed successfully
    and we are live on Docker:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，检查应用程序的URL（`http://your-master-ip-address:5000/`）。如果看到以下屏幕，这意味着我们的应用程序已成功部署，并且我们在Docker上已经上线了：
- en: '![](img/00155.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00155.jpeg)'
- en: Now we can test out our application by creating new users and logging in, and
    then posting tweets. I will not do it again as we have already done it at the
    time of application creation.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过创建新用户并登录，然后发布推文来测试我们的应用程序。我不会再次执行，因为我们在创建应用程序时已经执行过了。
- en: From experience, I know there may be some challenges to the communication between
    your application and database, that is, MongoDB, as both, the app and the database
    are on separate containers and might be in a separate network. In order to deal
    with this kind of problem, you can create a network and connect both the containers
    to that network.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 根据经验，我知道应用程序和数据库（即MongoDB）之间的通信可能会存在一些挑战，因为应用程序和数据库都在单独的容器中，可能在单独的网络中。为了解决这种问题，您可以创建一个网络，并将两个容器连接到该网络。
- en: 'For instance, if we have to do so for our container (`myapp` and `mongodb`),
    we will follow these steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们需要为我们的容器（`myapp`和`mongodb`）这样做，我们将按照以下步骤进行：
- en: 'Use the following command to create a separate network:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个单独的网络：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now that our network is created, we can add both containers to this network
    using the following commands:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了网络，可以使用以下命令将两个容器添加到这个网络中：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In order to find the IP that is assigned to these containers, we can use the
    following commands:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了找到分配给这些容器的IP，我们可以使用以下命令：
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This network creation is an alternative way to set up the communication between
    application and database.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这个网络的创建是一种设置应用程序和数据库之间通信的替代方式。
- en: Alright, we have deployed our application on Docker and learned its different
    concepts. The only concept that is left is Docker Compose. Let's understand what
    it is and how different it is from the others.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，我们已经在Docker上部署了我们的应用程序，并了解了它的不同概念。唯一剩下的概念是Docker Compose。让我们了解一下它是什么，以及它与其他工具有何不同。
- en: Docker Compose
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose
- en: As per the official Docker Compose website ([https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)),
    Compose is a tool for defining and running multicontainer Docker applications.
    With Compose, you use a Compose file to configure your application's services.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方Docker Compose网站（[https://docs.docker.com/compose/overview/](https://docs.docker.com/compose/overview/)），Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，您可以使用Compose文件来配置应用程序的服务。
- en: In simpler terms, it helps us build and run our application in a much simpler
    and faster way.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，它帮助我们以更简单和更快的方式构建和运行我们的应用程序。
- en: In the previous section, where we were deploying our application and building
    the images, we first created a Dockerfile and then executed the `Docker build`
    command to build it. Once it is built, we usually use the `docker run` command
    to spin up the container, but, instead of that, in Docker Compose, we will define
    a `.yml` file with config details, such as ports, command to execute, and so on.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，我们部署应用程序并构建镜像时，首先创建了一个Dockerfile，然后执行了`Docker build`命令来构建它。一旦构建完成，我们通常使用`docker
    run`命令来启动容器，但是，在Docker Compose中，我们将定义一个包含配置细节的`.yml`文件，例如端口、执行命令等。
- en: 'Firstly, Docker Compose is a separate utility from Docker Engine and can be
    installed using the following link, based on the type of OS you are working on:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Docker Compose是一个独立于Docker Engine的实用程序，可以根据您所使用的操作系统类型使用以下链接进行安装：
- en: '`https://docs.docker.com/compose/install/`.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`https://docs.docker.com/compose/install/`。'
- en: Once you have installed it, let's see how we can use Docker Compose to run our
    containers. Let's assume we have to run the cloud native application container
    using Docker Compose. We already have the Dockerfile generated for it, and we
    also have the application at the same location (path).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，让我们看看如何使用Docker Compose来运行我们的容器。假设我们需要使用Docker Compose运行云原生应用程序容器。我们已经为其生成了Dockerfile，并且应用程序也在相同的位置（路径）上。
- en: 'Next, using the following content, we will need to create a `Docker-compose.yml`
    file in the same location where the Dockerfile is present:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下内容，我们需要在与Dockerfile相同的位置创建一个`Docker-compose.yml`文件：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once you have added the config in `docker-compose.yml`, save it and execute
    the `docker-compose up` command. After building the image, we will see the following
    output:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`中添加配置后，保存并执行`docker-compose up`命令。构建镜像后，我们将看到以下输出：
- en: '![](img/00156.jpeg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00156.jpeg)'
- en: 'Also, if you see the container''s state, you will find multiple containers
    (in our case, `app_web-1` and `app_flask_1`) spin by compose, which is why it
    is useful for mutlicontainer applications that need large-scale infrastructure,
    as it creates a cluster of Docker machines similar to the Docker Swarm. The following
    screen shows the status of the Docker machine:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果查看容器的状态，您会发现多个容器（在我们的情况下，`app_web-1`和`app_flask_1`）由compose启动，这就是为什么它对于需要大规模基础设施的多容器应用程序非常有用，因为它创建了类似Docker
    Swarm的Docker机器集群。以下屏幕显示了Docker机器的状态：
- en: '![](img/00157.jpeg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00157.jpeg)'
- en: Awesome! We have deployed our application through Docker-compose as well. Now
    you can try to access the public URL for the application ([http://your-ip-address:5000](http://your-ip-address:5000))
    to confirm the successful application deployment.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们还通过Docker-compose部署了我们的应用程序。现在您可以尝试访问应用程序的公共URL（[http://your-ip-address:5000](http://your-ip-address:5000)）来确认成功部署应用程序。
- en: 'Finally, make sure you push your images to the Docker Hub to keep it in a centralized
    repository. Since we have already pushed the MongoDB images, use the following
    command to push the `cloud-native-app` image as well:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，确保将您的镜像推送到Docker Hub以将其保存在集中式存储库中。由于我们已经推送了MongoDB镜像，请使用以下命令来推送`cloud-native-app`镜像：
- en: '[PRE36]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We should see similar output for, Docker `push` command as shown:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似的输出，用于Docker `push`命令如下：
- en: '![](img/00158.jpeg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00158.jpeg)'
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we first looked at one of the most interesting technologies--Docker--,
    which is based on containers. We looked at the different concepts around Docker,
    and we already deployed our application and looked at the way we can manage it
    over Docker. We also explored multiple ways to deploy our application using Docker
    Compose and Dockerfile.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先看了一个最有趣的技术--Docker--，它是基于容器的。我们研究了Docker周围的不同概念，已经部署了我们的应用程序，并研究了我们如何通过Docker来管理它。我们还探索了使用Docker
    Compose和Dockerfile部署应用程序的多种方式。
- en: In the upcoming chapter, things will be a lot more interesting as we will finally
    reach a stage where we will be exposed to the cloud platform, build our infrastructure
    over the platform based on our application, and also try to deploy it as well.
    So, stay tuned for the next chapter! See you there.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，情况将变得更加有趣，因为我们最终将接触到云平台，根据我们的应用程序在平台上构建基础设施，并尝试部署它。所以，请继续关注下一章！到时见。
