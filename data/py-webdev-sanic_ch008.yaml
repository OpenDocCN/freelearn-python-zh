- en: 7 Dealing with Security Concerns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 处理安全关注
- en: 'When building a web application, it might be very tempting to sit down, plan
    out your functionality, build it, test it, and only then come back to think about
    security. For example, when building a single-page application, you might not
    even consider CORS until the first time you see this message in the browser while
    testing:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建Web应用程序时，可能会非常诱人坐下来，规划您的功能，构建它，测试它，然后才回来考虑安全问题。例如，在构建单页应用程序时，您可能甚至直到第一次在浏览器测试中看到这条消息之前都不会考虑CORS：
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To a large extent, this is how we have been building in this book. We see a
    feature and build it. Anytime we have run up against a potential security issue
    in this book, we have pushed it off to a later date. We finally are at this point
    where we will learn how to deal with security issues in Sanic. The topic of web
    security is, of course, extremely broad, and it is beyond the scope of this book
    to be an exhaustive study.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在很大程度上，这就是我们在本书中一直在构建的方式。我们看到一个功能，就构建它。任何时候我们在本书中遇到潜在的安全问题，我们都会将其推迟到以后。我们最终到了这个阶段，将学习如何处理Sanic中的安全问题。网络安全这个话题当然非常广泛，本书的范围并不包括对其进行全面研究。
- en: 'Instead, in this chapter we will explore:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在本章中，我们将探讨：
- en: Setting up an effective CORS policy
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置有效的CORS策略
- en: Protecting applications from CSRF
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护应用程序免受CSRF攻击
- en: Protecting your Sanic app with authentication
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用身份验证保护您的Sanic应用程序
- en: In particular, we want to gain a basic understanding of the security issues
    so we can build Sanic solutions to solve them. The bigger takeaway from this Chapter
    will be to make you feel comfortable enough with these topics that they do not
    become the after-thought. When these issues are broken down, we can see that building
    them into application design from the beginning will make them more effective
    and less burdensome to implement.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是我们希望对安全问题有一个基本的了解，这样我们就可以构建Sanic解决方案来解决它们。本章的更大收获将是让您对这些主题感到足够舒适，以至于它们不会成为事后之想。当这些问题被分解时，我们可以看到，从一开始就将它们构建到应用程序设计中会使它们更有效，并且实施起来不那么繁重。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The requirements for this chapter will again build upon what we have been using
    in previous chapters. Since web security often includes the interaction between
    frontend Javascript applications and backend Python applications, we may see some
    examples that use Javascript that is widely available in major web browsers. You
    can find all of the source code for this chapter at: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的要求将再次建立在我们在前几章中使用的内容之上。由于网络安全通常包括前端JavaScript应用程序和后端Python应用程序之间的交互，我们可能会看到一些使用在主流网络浏览器中广泛可用的JavaScript的示例。您可以在以下位置找到本章的所有源代码：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07)。
- en: 'In addition, we are going to use three common (and battle tested) security
    libraries: `cryptography`, `bcrypt`, and `pyjwt`. If you do not already have them
    installed in your virtual environment, you can add them now:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用三个常见（且经过实战考验）的安全库：`cryptography`、`bcrypt`和`pyjwt`。如果您还没有在虚拟环境中安装它们，现在可以添加它们：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Setting up an effective CORS policy
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置有效的CORS策略
- en: If you are building a web application where the server exclusively responds
    to requests on a single computer, and that computer is physically disconnected
    from the Internet, perhaps this section is not as relevant to you. For anyone
    else, pay attention! To be clear, you are part of “anyone else”. This is important
    stuff.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在构建一个服务器仅对单台计算机上的请求做出响应的Web应用程序，并且该计算机物理上与互联网断开连接，那么这个部分可能对您来说并不那么相关。对于其他人来说，请注意！为了清楚起见，您是“其他人”的一部分。这是重要的事情。
- en: In simple terms, **cross-origin resource sharing (CORS)** is a fancy way of
    saying *accessing one domain from another domain with a browser*. Without an effective
    strategy for handling this, your application could open up a security risk for
    your users.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**跨源资源共享（CORS）**是一种说法，即通过浏览器从一个域访问另一个域。如果没有有效的处理策略，您的应用程序可能会为您的用户打开一个安全风险。
- en: What is the security issue with ineffective CORS?
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无效的CORS存在哪些安全问题？
- en: The modern web uses a lot of Javascript in web browsers. It, of course, enables
    all kinds of interactive and quality user experiences. One of those capabilities
    is to issue requests for data on behalf of the user without them knowing about
    it. This feature is one of the biggest differentiators between web applications
    today and web applications from the late ’90s. Requesting data while the user
    is on a website is what makes web pages feel like applications. That is to say
    that it makes them interactive and engaging.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络在浏览器中使用了大量的JavaScript。它当然能够实现各种交互性和高质量的用户体验。这些能力之一就是代表用户发出数据请求，而用户并不知道这一点。这个特性是当今网络应用程序与90年代末的网络应用程序之间最大的区别之一。当用户在网站上时请求数据，这就是使网页感觉像应用程序的原因。也就是说，它使它们交互性和引人入胜。
- en: 'So imagine that you have a hypothetical application that appears to the user
    as: `https://superawesomecatvideos.com`. It is a super successful website, and
    lots of people like to come to visit it to see their favorite car videos. If it
    starts requesting information in the background (because of a hacker attack, or
    otherwise) from `https://mybank.com`, well, we of course do not want to allow
    that to succeed. There is no reason that the Super Awesome Cat Videos website
    should be able to access anything from My Bank, especially if I have an authenticated
    web session at My Bank’s website.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个假设的应用程序，对用户来说看起来是这样的：`https://superawesomecatvideos.com`。这是一个非常成功的网站，很多人喜欢来访问它，看看他们最喜欢的汽车视频。如果它开始在后台请求信息（因为黑客攻击或其他原因）从`https://mybank.com`，那么，我们当然不希望让它成功。没有任何理由让超级神奇猫视频网站能够访问我的银行中的任何内容，尤其是如果我正在我的银行网站上有一个经过验证的Web会话。
- en: 'For this reason, web browsers will not allow this by default because of the
    **same-origin policy**. This means that web applications may only interact with
    resources that are of the same-origin. An origin is comprised of:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，默认情况下，网络浏览器不会允许这样做，因为存在**同源策略**。这意味着网络应用程序只能与同源的资源进行交互。一个源由以下部分组成：
- en: The HTTP scheme
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方案
- en: The domain
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名
- en: The port
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 端口
- en: 'Let’s look at some examples of URLs that are and are not considered to be same-origin:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些被认为是和不是同源的URL的例子：
- en: '| **URL A** | **URL B** | **Same-origin?** |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **URL A** | **URL B** | **同源？** |'
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://sacv.com`](http://sacv.com)
    | Yes |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| [http://sacv.com](http://sacv.com) | [http://sacv.com](http://sacv.com) |
    是 |'
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://sacv.com`](http://sacv.com)
    `/about` | Yes, path does not matter |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| [http://sacv.com](http://sacv.com) | [http://sacv.com](http://sacv.com) `/about`
    | 是，路径无关紧要 |'
- en: '| [`http://sacv.com`](http://sacv.com) | [`https://sacv.com`](https://sacv.com)
    | No, different HTTP schemes |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| [http://sacv.com](http://sacv.com) | [https://sacv.com](https://sacv.com)
    | 不，不同的HTTP方案 |'
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://sacv.com`](http://sacv.com)
    `:8080` | NO, different ports |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| [http://sacv.com](http://sacv.com) | [http://sacv.com](http://sacv.com) `:8080`
    | 不，不同的端口 |'
- en: '| [`http://sacv.com`](http://sacv.com) | [`http://api.sacv.com`](http://api.sacv.com)
    | No, different domains |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| [http://sacv.com](http://sacv.com) | [http://api.sacv.com](http://api.sacv.com)
    | 不，不同的域名 |'
- en: Table 7.1 - Comparison of URLs and their same-origin status
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 - URL及其同源状态的比较
- en: 'We’ll assume that our Super Awesome Cat Video website also has the domain:
    sacv.com. For example, if `https://superawesomecatvideos.com` wants to load: `https://superawesomecatvideos.com/catvid1234.mp4`,
    that is fine. When the only difference is the path or resource being loaded, the
    URLs are considered same-origin. In our example, both URLs contain the same HTTP
    scheme, domain, and port designation. But, when the same website [https://superawesomecatvideos](https://superawesomecatvideos)
    tries to fetch data from `https://api.superawesomecatvideos.com/videos`, uh oh,
    error time. These are the sorts of potential attack vectors that the same-origin
    policy is meant to protect from. So, the question becomes: how can we allow legitimate
    cross-origin requests, without allowing *all* cross-origin requests? The answer
    is that we essentially need to create a whitelist and let the browser know which
    origins our server will accept requests from.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们的超级酷猫视频网站也有域名：sacv.com。例如，如果 `https://superawesomecatvideos.com` 想要加载：`https://superawesomecatvideos.com/catvid1234.mp4`，这是可以的。当只有路径或加载的资源不同时，URL被认为是同源的。在我们的例子中，两个URL都包含相同的HTTP方案、域名和端口指定。但是，当同一个网站
    [https://superawesomecatvideos](https://superawesomecatvideos) 尝试从 `https://api.superawesomecatvideos.com/videos`
    获取数据时，哎呀，出错了。这些都是同源策略旨在保护免受的潜在攻击向量。因此，问题变成了：我们如何允许合法的跨源请求，而不允许 *所有* 跨源请求？答案是，我们实际上需要创建一个白名单，并让浏览器知道我们的服务器将接受来自哪些源请求。
- en: Let’s build a super simple example that will show us the problem. We are going
    to build two webservers here. One will be a stand-in for the frontend application,
    and the other will be the backend meant to feed data to the frontend.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个超级简单的示例，以展示问题。我们将在这里构建两个web服务器。一个将作为前端应用程序的替代品，另一个将是向前端提供数据的后端。
- en: 'We begin by building and running a simple API endpoint that looks no different
    than anything we have seen before. Stand up the application using the same method
    we have already used. Here is what your endpoint can look like:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先构建并运行一个简单的API端点，它看起来与我们之前看到的没有任何不同。使用我们之前使用的方法搭建应用程序。以下是您的端点可能的样子：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You should now have a Sanic server running on port `7777` using what we have
    already learned. You can test it out by accessing: `http://localhost:7777/Adam`.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个在端口 `7777` 上运行的Sanic服务器，使用我们已学到的知识。您可以通过访问：`http://localhost:7777/Adam`
    来测试它。
- en: 'Create a directory somewhere and add this file called `index.html` to it. For
    my example it will be `/path/to/directory`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某个位置创建一个目录，并将这个名为 `index.html` 的文件添加到其中。以我的例子来说，它将是 `/path/to/directory`：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, this application will run a background request to our application
    that is running on `http://localhost:7777`. After it gets the content, it will
    dump it on the screen in place of the `Loading ...` text.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这个应用程序将在后台向运行在 `http://localhost:7777` 的应用程序发送请求。在获取内容后，它将把内容替换为屏幕上的 `Loading
    ...` 文本。
- en: 'To run this application, we are going to use a neat little trick that Sanic
    includes called “*Sanic Simple Server*”. Instead of building a Sanic application,
    we will point the Sanic CLI at a directory and it will serve that for us as a
    website:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行此应用程序，我们将使用Sanic包含的一个小巧的技巧，称为“*Sanic Simple Server*”。我们不会构建一个Sanic应用程序，而是将Sanic
    CLI指向一个目录，然后它将为我们提供网站服务：
- en: '[PRE4]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Tip**'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is a super helpful tool to keep in your back pocket, even when not building
    a Sanic application. In the course of development, I often find a need to quickly
    standup a web application to view static content in a browser. This could be useful
    when building an application that uses only static content, or when building a
    Javascript application and you need a development server.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个超级有用的工具，即使在不构建Sanic应用程序时也应该放在您的口袋里。在开发过程中，我经常发现需要快速搭建一个Web应用程序来在浏览器中查看静态内容。当构建仅使用静态内容的应用程序或构建需要开发服务器的JavaScript应用程序时，这可能很有用。
- en: 'Open up a web browser and go to this application that should be running at
    [http://localhost:8000](http://localhost:8000). You should see something like
    this:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个网页浏览器，并访问这个应该运行在 [http://localhost:8000](http://localhost:8000) 的应用程序。您应该看到类似这样的内容：
- en: '![Figure 3.1 - Screenshot of the web application with CORS issue](img/file8.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 - 带有CORS问题的Web应用程序截图](img/file8.png)'
- en: Figure 3.1 - Screenshot of the web application with CORS issue
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 - 带有CORS问题的Web应用程序截图
- en: 'Uh oh, something went wrong. Our application is throwing an error:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀，出错了。我们的应用程序抛出了一个错误：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For most of us getting into web development, this experience would be our first
    with CORS. What on Earth does this mean? What is a “*Cross-Origin Request*”, and
    why is it blocked? What is a CORS header? And, most importantly, how do I make
    this go away?! This last question is the one that bothers me. We are not going
    to “*make it go away*”, we are going to understand what this means, why the browser
    decided to throw up a road block, and then move on to creating a solution.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数刚开始接触网页开发的人来说，这次经历将是他们第一次遇到CORS。这究竟是什么意思？什么是“*跨源请求*”，为什么会被阻止？CORS头信息是什么？最重要的是，我该如何让它消失？！这个问题让我很烦恼。我们不会“*让它消失*”，我们会理解它的含义，为什么浏览器决定设置障碍，然后继续寻找解决方案。
- en: The naive web developer upon seeing this error will immediately go online to
    search how to deal with this, find a mess of partial or way-too-in-depth information,
    and then move on without ever understanding the actual issue. Making it go away
    will get you back to developing since the error is no longer blocking your progress,
    but it will not solve the problem. In fact, you just created a new one. To become
    a better developer, we are not going to just implement an off-the-shelf solution
    without understanding it. Instead we will pause to learn what is happening and
    why. Maybe you have come up against this issue yourself, if not, you surely will
    at some point. Whether you have or have not “solved” this problem in the past,
    we are going to take some time to learn the rationale behind this error before
    coming up with an appropriate—or rather, *obvious*—solution. Once you peel back
    the layers of CORS, you will see that it starts to make a lot of sense and can
    become simple to master.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个天真的网页开发者看到这个错误时，会立即上网搜索如何处理这个问题，找到一堆部分或过于深入的信息，然后继续前进，却从未真正理解实际的问题。让错误消失会让你回到开发中，因为错误不再阻碍你的进度，但这并不能解决问题。事实上，你只是创造了一个新的问题。为了成为一名更好的开发者，我们不会在不理解的情况下仅仅实施现成的解决方案。相反，我们会停下来学习正在发生的事情以及为什么会这样。也许你自己也遇到过这个问题，如果没有，你迟早会遇到的。无论你是否在过去“解决了”这个问题，我们都会花些时间来学习这个错误背后的原因，然后再提出一个适当——或者更确切地说，*明显*——的解决方案。一旦你揭开了CORS的层层面纱，你会发现它开始变得很有道理，并且可以变得简单易掌握。
- en: 'I was one such naive person that searched this error, clicked the first link,
    copied and pasted a solution that made the error go away, and then moved on with
    life not giving it another thought. The browser no longer complained: problem
    solved. At least that is what I thought. I did not think about the consequences
    of my action and the security hole I had introduced. What was that security hole
    masquerading as a fix? The solution I found was to add a simple header, and I
    gave it no further thought: `Access-Control-Allow-Origin: *`. *DO NOT DO THIS!*
    I did not know any better and I moved on never thinking twice about CORS, except
    that it was the pesky thing in browsers that seemed to cause me problems.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '我就是那些搜索这个错误、点击第一个链接、复制粘贴解决方案以消除错误然后继续生活的人之一。浏览器不再抱怨：问题解决了。至少我认为是这样。我没有考虑我行动的后果以及我引入的安全漏洞。那个安全漏洞伪装成解决方案是什么？我找到的解决方案是添加一个简单的头信息，我没有再想它：`Access-Control-Allow-Origin:
    *`。*不要这样做!* 我不知道更好的做法，我继续前进，从未再次考虑过CORS，除了它似乎在浏览器中给我带来麻烦之外。'
- en: 'The issue here is that the frontend application is trying to access details
    from another origin: hence *cross origin*. When I added that header, I was effectively
    disabling the same-origin protection that the browser was creating. The `*` means:
    *allow this application to request any cross origin information it wants*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于前端应用程序试图访问另一个源的数据：因此是*跨源*。当我添加那个头信息时，我实际上是在禁用浏览器创建的同源保护。`*`的意思是：*允许这个应用程序请求它想要的任何跨源信息*。
- en: My browser had created a castle for protection. Rather than learn about how
    to effectively handle CORS, I decided to drop the drawbridge, open all of the
    gates, and send the guards home to their beds.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我的浏览器为保护我创建了一个城堡。而不是学习如何有效处理CORS，我决定放下吊桥，打开所有的城门，让守卫们回家睡觉。
- en: What should I have done? Let’s find out.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该做什么呢？让我们来找出答案。
- en: Developing a strategy for effectively dealing with CORS
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 制定有效处理CORS的策略
- en: 'Obviously, my strategy to completely disable the browser defenses was not the
    best approach. It was the easy way out, the lazy way out, and the irresponsible
    way out. What I should have done is go to a resource like the one that Mozilla
    provides and read up on the issue: [https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS).
    If I did, then this would have caught my attention:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '显然，我完全禁用浏览器防御的策略并不是最好的方法。这是条捷径，是懒惰的方法，也是不负责任的方法。我应该做的是去像Mozilla提供的那种资源上了解这个问题：[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS)。如果那样做了，这会吸引我的注意： '
- en: '*Who should read this article?*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**谁应该阅读这篇文章**？'
- en: '*Everyone, really.*'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**每个人，真的**。'
- en: 'Oh, *everyone* should read it? If you have not read it, you have the opportunity
    now to take a different path than me, and to go read it now. I am not kidding.
    Please do yourself a favor: put a bookmark in this book and go read that webpage.
    Then come back here. I promise we will wait for you. It is written in fairly simple
    terms to understand and is an authoritative resource to keep in your back pocket.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，**每个人都**应该阅读它吗？如果你还没有读过，现在你有机会选择与我不同的路径，现在就去读它。我不是在开玩笑。请自己做个好事：在这本书里做个书签，然后去读那个网页。然后回来这里。我保证我们会等你。它用相当简单的术语来理解，并且是一个值得你放在口袋里的权威资源。
- en: According to the official HTTP specification, the `OPTIONS` method *allows a
    client to determine the options and/or requirements associated with a resource,
    or the capabilities of a server, without implying a resource action* ([https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7)).
    In other words, it gives an HTTP client the ability to check what an endpoint
    might require from it before sending an actual request. If you have ever built
    a browser-based web application, or if you intend to, this method is extremely
    important. Therefore, as we dive into what the CORS headers are, we will also
    revisit and heavily make use of our `OPTIONS` handler from back in *Chapter 3*,
    *Routing and intaking HTTP requests*. Take a flip back to that section to reacquaint
    yourself with how we will automatically attach `OPTIONS` handlers for all of our
    routes.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 根据官方HTTP规范，`OPTIONS`方法**允许客户端确定与资源相关联的选项和/或要求，或服务器的功能，而不涉及资源操作**（[https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7](https://datatracker.ietf.org/doc/html/rfc7231#section-4.3.7)）。换句话说，它给HTTP客户端提供了在发送实际请求之前检查端点可能需要什么的能力。如果你曾经构建过基于浏览器的Web应用程序，或者打算这样做，这个方法非常重要。因此，当我们深入研究CORS头信息时，我们也会重新回顾并大量使用我们在**第3章**中提到的`OPTIONS`处理器，即**路由和接收HTTP请求**。请翻回那一节，重新熟悉我们将如何自动为所有路由附加`OPTIONS`处理器。
- en: Understanding CORS headers
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解CORS头信息
- en: Solving these cross origin access issues is accomplished through the application
    of response headers. Therefore, we will need to learn what some of these headers
    are and when they should be applied and used. Our job in this section will be
    to build HTTP responses with some basic CORS headers that we can use in our applications.
    We, of course, could take the easy way out and install one of the third-party
    packages on PyPI that will automatically add the headers for us.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过应用响应头来解决这些跨源访问问题。因此，我们需要了解这些头信息是什么，以及它们应该在何时应用和使用。在本节中，我们的任务将是构建包含一些基本CORS头的HTTP响应，我们可以在我们的应用程序中使用这些头。当然，我们可以选择走捷径，安装PyPI上的第三方包，它会自动为我们添加这些头。
- en: In actuality, I do suggest that you do this for a production application. CORS
    issues can be complex, and implementing a *trusted* solution should bring some
    level of comfort and peace of mind. However, relying upon one of these packages
    without knowing the basics is only slightly better than my first solution of disabling
    the same-origin policy completely.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我确实建议你在生产应用中这样做。CORS问题可能很复杂，实施一个**可信**的解决方案应该能带来一定程度的安慰和安心。然而，在不了解基础知识的情况下依赖这些包，与完全禁用同源策略的第一种解决方案相比，也只是稍微好一点。
- en: 'Here are some of the common CORS response headers we should know about:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些我们应该知道的常见CORS响应头：
- en: '**Access-Control-Allow-Origin**: This is used by the server to tell the client
    which origins it will and will not accept cross-origin requests from;'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access-Control-Allow-Origin**：这是服务器用来告诉客户端它将接受和拒绝哪些来源进行跨源请求的；'
- en: '**Access-Control-Expose-Headers**: This is used by the server to tell the browser
    which HTTP headers it can allow Javascript to access safely (meaning it does not
    contain sensitive data);'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access-Control-Expose-Headers**：服务器使用此选项告诉浏览器它可以允许 JavaScript 安全访问哪些 HTTP
    头部（意味着它不包含敏感数据）；'
- en: '**Access-Control-Max-Age**: This is used by the server to tell the client how
    long it could cache the results of a **preflight request** (see the next section
    to learn what a preflight request is);'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access-Control-Max-Age**：服务器使用此选项告诉客户端它可以缓存预检请求结果多长时间（有关预检请求的详细信息，请参阅下一节）；'
- en: '**Access-Control-Allow-Credentials**: This is used by the server to tell the
    client whether it can or cannot include credentials when sending in requests;'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access-Control-Allow-Credentials**：服务器使用此选项告诉客户端在发送请求时是否可以或不能包含凭据；'
- en: '**Access-Control-Allow-Methods**: This is used by the server in preflight requests
    to tell the client what HTTP methods it will accept on a given endpoint;'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access-Control-Allow-Methods**：在预检请求中，服务器使用此选项告诉客户端在给定端点上它将接受哪些 HTTP 方法；'
- en: '**Access-Control-Allow-Headers**: This is used by the server in preflight requests
    to tell the client which HTTP headers it will allow it to add.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Access-Control-Allow-Headers**：在预检请求中，服务器使用此选项告诉客户端它允许它添加哪些 HTTP 头部。'
- en: Understanding preflight requests
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 理解预检请求
- en: In certain scenarios, before a browser tries to access a cross-origin *something*,
    it will issue what is known as a **preflight request**. This is a request to the
    same domain and endpoint as the intended resource that happens before the actual
    call, except with an `OPTIONS` HTTP method. The goal of this request is to get
    access to the CORS headers to learn what the server will and will not allow. If
    the browser determines that the response is not “safe”, it will not allow it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些场景下，在浏览器尝试访问跨源 *某物* 之前，它将发出一个被称为 **预检请求** 的请求。这是一个针对目标资源相同域名和端点的请求，发生在实际调用之前，除了使用
    `OPTIONS` HTTP 方法。这个请求的目的是获取访问 CORS 头部信息，以了解服务器将允许和不允许什么操作。如果浏览器确定响应不是“安全的”，则不会允许它。
- en: 'When will a browser decide to issue a preflight request? Mozilla provides a
    great overview on their CORS page ([https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests)).
    In summary, a preflight request will *not* be issued by the browser when:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器决定发出预检请求时？Mozilla 在他们的 CORS 页面上提供了一个很好的概述（[https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests)）。总之，当：
- en: It is a `GET`, `HEAD`, or `POST`
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 它是 `GET`、`HEAD` 或 `POST`
- en: Does not contain any manually set headers, except for `Accept`, `Accept-Language`,
    `Content-Language`, or `Content-Type`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不包含任何手动设置的头部，除了 `Accept`、`Accept-Language`、`Content-Language` 或 `Content-Type`
- en: The request headers include `Content-Type`, and it is set to one of `application/x-www-form-urlencoded`,
    `multipart/form-data`, or `text/plain`
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 请求头部包括 `Content-Type`，并设置为 `application/x-www-form-urlencoded`、`multipart/form-data`
    或 `text/plain` 之一
- en: There are no Javascript event listeners on the request
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请求上没有 JavaScript 事件监听器
- en: The response is not going to be streamed by the client
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端不会对响应进行流式传输
- en: 'These requests are generally meant to cover the scenarios encountered by *normal*
    web traffic: navigating to a page, submitting an HTML form, and basic AJAX requests.
    As soon as your application starts adding in functionality that is typical of
    most single-page web applications, you will begin to notice your browser issuing
    preflight requests. In this context, the two most common types of requests that
    trigger preflight are:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些请求通常旨在涵盖正常网络流量遇到的场景：导航到页面、提交 HTML 表单和基本的 AJAX 请求。一旦你的应用程序开始添加大多数单页网络应用程序典型的功能，你将开始注意到你的浏览器发出预检请求。在这种情况下，触发预检请求的最常见的两种类型是：
- en: JS applications that inject custom headers (`Authorization`, `X-XSRF-Token`,
    `Foobar`, etc)
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注入自定义头部（`Authorization`、`X-XSRF-Token`、`Foobar` 等）的 JS 应用程序
- en: 'JS applications that submit JSON data using `Content-Type`: `application/json`'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 `Content-Type`: `application/json` 提交 JSON 数据的 JS 应用程序'
- en: 'You may be wondering: why does this matter? It is important to understand this
    so that we know when we need to respond with each of the six CORS response headers
    we saw in the last section.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想：这有什么关系？了解这一点很重要，这样我们才知道何时需要响应上一节中看到的六个 CORS 响应头部。
- en: Solving for CORS with Sanic
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决 CORS 问题的 Sanic
- en: Up until this point, we have entirely avoided the usage of any third-party plugins.
    That is, to say that we have steered away from any implementation that would require
    us to `pip install` a solution. This has been a conscious decision so that we
    learn the principles needed to build our web applications before we just outsource
    the solution to someone else. While this is still valid here and is the reason
    we are about to handle CORS requests by hand, it is also important to point out
    that this is a problem that has been solved already. The officially supported
    `sanic-ext` package and the community-supported `sanic-cors` package are both
    reputable options for implementing CORS protection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们完全避免了使用任何第三方插件。也就是说，我们避免采用任何需要我们`pip install`解决方案的实现。这是一个有意识的决策，以便我们在将解决方案外包给他人之前，先学习构建我们的Web应用程序所需的原则。虽然这在这里仍然有效，也是我们即将手动处理CORS请求的原因，但重要的是指出，这已经是一个已经被解决的问题。官方支持的`sanic-ext`包和社区支持的`sanic-cors`包都是实现CORS保护的可信选项。
- en: With that said, let’s think about each of the six (6) response headers and *when*
    and how we will need to implement them. We have some headers we want to add regardless
    of the type of request, and some that will `only` be added on preflight requests.
    We will need a standard and repeatable method for adding response headers in these
    two scenarios. What is our go-to strategy for that? Middleware.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们考虑每个六个（6）个响应头，以及我们将在何时以及如何实现它们。我们有一些头无论请求类型如何都要添加，还有一些只有在预请求中才会添加。我们需要一个标准且可重复的方法来在这两种情况下添加响应头。我们在这个问题上的首选策略是什么？中间件。
- en: 'Let’s start with this basic middleware and add code to it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个基本的中间件开始，并向其中添加代码：
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We are doing two things to determine that a request is indeed a preflight request:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在做两件事来确定一个请求确实是一个预请求：
- en: First, we know that the browser will always issue it as an `OPTIONS` request
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们知道浏览器将始终以`OPTIONS`请求的形式发出它
- en: Second, the browser will always attach a request header called `Access-Control-Request-Method`
    with the value of the type of HTTP request that it is about to send
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，浏览器将始终附加一个名为`Access-Control-Request-Method`的请求头，其值为它即将发送的HTTP请求类型
- en: 'To simulate a preflight request, we will use the following curl request that
    adds the two headers we need to trigger the preflight request response (the `Origin`
    header and the `Access-Control-Request-Method` header):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟预请求，我们将使用以下curl请求，该请求添加了触发预请求响应所需的两个头（`Origin`头和`Access-Control-Request-Method`头）：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The last thing we need is some ability for adding `OPTIONS` as a viable HTTP
    method for every existing route in our application. This is something that `sanic-ext`
    adds, and we will learn an easy way to accomplish this in *Chapter 11*, *A complete
    real-world example*, using that package. But first, you might recall that this
    is something that we built way back in *Chapter 3*, *Routing and intaking HTTP
    requests*. We will reuse the code that looped through all of our defined routes
    and added an `OPTIONS` endpoint. You can find it in that chapter in the *Blanket
    support for OPTIONS and HEAD* section.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要的是一种能力，可以为我们的应用程序中每个现有的路由添加`OPTIONS`作为可行的HTTP方法。这是`sanic-ext`添加的功能，我们将在第11章“一个完整的真实世界示例”中学习一种简单的方法来实现这一点。但首先，你可能还记得这是我们在第3章“路由和接收HTTP请求”中构建的。我们将重用遍历所有定义的路由并添加`OPTIONS`端点的代码。你可以在该章节的“对OPTIONS和HEAD的全面支持”部分找到它。
- en: With this established, we will look at each response header to understand them
    more completely.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在建立这一点之后，我们将查看每个响应头，以更全面地了解它们。
- en: Access-Control-Allow-Origin
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Origin
- en: This header alone is arguably the most important one to add. It is also the
    one that is most tempting to be the nuclear option and just disable CORS protection
    completely as discussed earlier. Unless you have a specific reason to accept requests
    from any browser origin, you should avoid `*`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头可能是最重要的一个，也是最容易被当作核选项，完全禁用CORS保护，正如之前讨论的那样。除非你有特定的理由接受来自任何浏览器源头的请求，你应该避免使用`*`。
- en: The value should, instead, be the address that you anticipate requests coming
    from. You should *NOT* just recycle the incoming request’s `Origin` header and
    apply that. This is effectively the same as `*`. Instead, it is a good practice
    to have a predefined list of allowed origins and cross-reference the incoming
    `Origin` with those. If there is not a match, simply do not add any CORS headers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 该值应该是您预期请求来源的地址。您 *不应* 只是回收传入请求的 `Origin` 头部并将其应用。这实际上等同于 `*`。相反，有一个预定义的允许来源列表并与传入的
    `Origin` 进行交叉引用是一个好的做法。如果没有匹配项，则简单地不要添加任何CORS头部。
- en: 'Here is the first snippet we will add to our middleware to do that:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将添加到中间件中的第一个片段以实现此目的：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Make sure that you set the configuration `ALLOWED_ORIGINS` value as well. This
    could be done wherever you create your app instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您还设置了配置 `ALLOWED_ORIGINS` 的值。这可以在创建应用程序实例的任何地方完成。
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As you can see, we will add this to all responses that are coming from the browser.
    How do we know it is a browser request? Because we can expect that browsers will
    add the `Origin` header.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们将将其添加到所有来自浏览器的响应中。我们如何知道这是一个浏览器请求？因为我们预期浏览器会添加 `Origin` 头部。
- en: Access-Control-Expose-Headers
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Access-Control-Expose-Headers
- en: The `Access-Control-Expose-Headers` header provides the server with the ability
    to control which headers are exposed to Javascript access. It is a security measure
    to provide a whitelist control of what information is available to the in-browser
    application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Access-Control-Expose-Headers` 头部提供了服务器控制哪些头部可以被JavaScript访问的能力。这是一个安全措施，用于提供白名单控制，以确定浏览器应用程序可以访问哪些信息。'
- en: Let’s start adding some tests into the browser. For these examples, we will
    use a similar basic HTML structure as before.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在浏览器中开始添加一些测试。对于这些示例，我们将使用与之前类似的基本HTML结构。
- en: 'We start by setting up our HTML. The goal here is to read the header `foobar`
    in Javascript and output it on the screen:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先设置HTML。这里的目的是在JavaScript中读取 `foobar` 头部并在屏幕上输出：
- en: '[PRE10]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We need to set up our application to see the HTML and add the header:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要设置我们的应用程序以查看HTML并添加头部信息：
- en: '[PRE11]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To verify our curiosity, we will double-check the response with `curl` to make
    sure the header is actually being sent:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们的好奇心，我们将使用 `curl` 重新检查响应，以确保确实发送了头部信息：
- en: '[PRE12]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, open your browser to `http://127.0.0.1:7777/test`. You should see:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开您的浏览器到 `http://127.0.0.1:7777/test`。您应该看到：
- en: '[PRE13]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What happened is that the browser was blocked from accessing the header. If
    we want to allow it, then we need to be explicit.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发生的事情是浏览器被阻止访问头部。如果我们想允许它，那么我们需要明确指出。
- en: 'Therefore, heading back to the `add_cors_headers` middleware that we were building,
    let’s add the following snippet:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，回到我们正在构建的 `add_cors_headers` 中间件，让我们添加以下片段：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Do not forget that since we are actually testing this on a browser, we need
    to set the `ALLOWED_ORIGINS` configuration value appropriately:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要忘记，由于我们实际上是在浏览器上测试这个，我们需要适当地设置 `ALLOWED_ORIGINS` 配置值：
- en: '[PRE15]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This time when you access the browser, you should see that the Javascript was
    able to reach in and get the value from the `Foobar` header:'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次当您访问浏览器时，您应该看到JavaScript能够深入获取 `Foobar` 头部的值：
- en: '[PRE16]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Therefore, if you intend to use any sort of meta-data on the client-side of
    your application, you will need to properly use `access-control-expose-headers`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您打算在应用程序的客户端使用任何类型的元数据，您需要正确使用 `access-control-expose-headers`。
- en: Access-Control-Max-Age
  id: totrans-122
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Access-Control-Max-Age
- en: When a browser *does* issue a preflight request, it has the ability to cache
    that response so that the next time it makes the same request it does not need
    to hit the server. This performance improvement can be controlled (to some extent)
    by the server using the `Access-Control-Max-Age`, which specifies the length of
    time (in seconds) that the preflight request can be cached.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器 *确实* 发出一个预检请求时，它有缓存该响应的能力，以便下次它发出相同的请求时不需要击中服务器。这种性能提升可以通过服务器使用 `Access-Control-Max-Age`
    来控制（在一定程度上），该选项指定了预检请求可以被缓存的时长（以秒为单位）。
- en: Typically, web browsers will set a maximum value for this. If you tried to set
    it to some absurdly large number, they will drop it down to their predefined maximum
    value. For this reason, I usually recommend going with a value that is around
    10 minutes. Some browsers will allow you to go up to 24 hours, but that is probably
    about the maximum allowed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，网络浏览器会为此设置一个最大值。如果你尝试将其设置为一些荒谬的大数字，它们会将其降低到预定义的最大值。因此，我通常建议使用大约10分钟的值。一些浏览器允许你设置到24小时，但这可能就是允许的最大值了。
- en: 'We will see this now in our middleware:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将在我们的中间件中看到这一点：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Access-Control-Allow-Credentials
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Credentials
- en: This header is for preflight requests only. So, the snippet we will add here
    needs to go inside our `is_preflight(request)` block.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这个头部仅用于预检请求。因此，我们将添加的片段需要放在我们的`is_preflight(request)`块内部。
- en: When a Javascript application makes a request, it must *explicitly* make the
    call allowing for credentials to be sent. If not, then the browser will not include
    them in the request. The server can then play its part to tell the browser that
    this request that includes credentials is—or is not—safe to expose to the Javascript
    application.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个JavaScript应用程序发起请求时，它必须**明确地**调用允许发送凭证的调用。如果不这样做，浏览器就不会在请求中包含它们。然后服务器可以发挥作用，告诉浏览器这个包含凭证的请求是否安全地暴露给JavaScript应用程序。
- en: 'To allow it, we set the header like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要允许它，我们设置头部如下：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Access-Control-Allow-Methods
  id: totrans-132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Access-Control-Allow-Methods
- en: Up until this point, there really has not been a need for any plugins. Adding
    these CORS headers has been fairly straightforward. The next part, however, is
    something that could become a little more tricky.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，实际上并没有必要使用任何插件。添加这些CORS头部相对直接。然而，下一部分可能会变得稍微复杂一些。
- en: 'The `Access-Control-Allow-Methods` header is meant to be a warning to the browser
    during the preflight request about what HTTP methods the browser is allowed to
    send to the endpoint cross-origin. A lot of applications disable this protection
    by allowing everything:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`Access-Control-Allow-Methods`头部旨在在预检请求期间向浏览器发出警告，告知浏览器允许发送到端点的跨源HTTP方法。许多应用程序通过允许一切来禁用这种保护。'
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This certainly is a simple solution. It is less harmful than that first CORS
    solution I came across that allowed any origin. But, we can still do better.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这当然是一个简单的解决方案。它比我在网上找到的第一个允许任何源头的CORS解决方案要安全得多。但，我们仍然可以做得更好。
- en: To accomplish the ability to have dynamic methods that match the *actual* endpoint
    possibilities, we are going to change some things around in our code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现动态方法，这些方法与*实际*端点可能性相匹配，我们将在我们的代码中做一些调整。
- en: Remember how we are defining a request as preflight? Let’s do that up front
    in the request middleware.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 记得我们是如何定义预检请求的吗？让我们在请求中间件中提前这样做。
- en: '[PRE20]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, when we generate the handlers for `OPTIONS` requests, we will inject
    a list of all of the allowed methods like this:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，当我们为`OPTIONS`请求生成处理程序时，我们将注入一个包含所有允许方法的列表，如下所示：
- en: '[PRE21]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we have access to the preflight check in our options handler, we can
    do our check and add the headers there. We also can take the list of methods that
    were passed in and concatenate them into a comma-delimited list. This should now
    provide an automated set of `OPTIONS` endpoints with exactly the HTTP methods
    that will be used.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经可以在我们的选项处理程序中访问预检检查，我们可以在那里进行检查并添加头部。我们还可以将传入的方法列表连接成一个逗号分隔的列表。现在，这应该提供了一组自动化的`OPTIONS`端点，这些端点正好使用了将要使用的HTTP方法。
- en: '[PRE22]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will look at the preflight response using curl to see all of our headers:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用curl查看预检响应，以查看所有我们的头部信息：
- en: '[PRE23]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Access-Control-Request-Headers
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Access-Control-Request-Headers
- en: The final header we are concerned with here is `Access-Control-Request-Headers`,
    and is also one that should be sent in preflight responses. It is an indication
    to the browser which non-standard headers can be sent in the cross-origin request.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里关注的最后一个头部是`Access-Control-Request-Headers`，它也是应该在预检响应中发送的头部。它是向浏览器指示哪些非标准头部可以在跨源请求中发送的指示。
- en: 'If the Javascript wanted to send a header called *counting*, then it would
    do this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果JavaScript想要发送一个名为*counting*的头部，那么它会这样做：
- en: '[PRE24]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: However, because this would trigger a preflight request, the browser will fail
    with a CORS error because the server has not explicitly allowed counting as an
    acceptable header.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这会触发预检请求，浏览器会因为服务器没有明确允许计数作为一个可接受的头而失败，并显示CORS错误。
- en: 'To do that, we enable it in our preflight block:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们在预检块中启用它：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Our review of CORS headers has added a lot of code. To see the completed version,
    please checkout the GitHub repository: [https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue).
    Now that we have completed our CORS review, we are onto the next topic that is
    similarly related: CSRF'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对CORS头的审查增加了大量的代码。要查看完整版本，请查看GitHub仓库：[https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue](https://github.com/PacktPublishing/Web-Development-with-Sanic/tree/main/chapters/07/corsissue)。现在我们已经完成了CORS的审查，接下来是类似相关的话题：CSRF
- en: Protecting applications from CSRF
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护应用程序免受CSRF攻击
- en: The next step in our journey is handling cross-site request forgery (CSRF).
    It should also be noted that this often also carries the acronym XSRF. If you
    see these two on the web, they refer to the same issue. So, what is the issue?
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旅程的下一步是处理跨站请求伪造（CSRF）。还应注意的是，这通常也带有缩写XSRF。如果你在网上看到这两个词，它们指的是同一个问题。那么，这个问题是什么呢？
- en: You know that suspiciously awkward email that you received that says “click
    here to claim your $500 prize”? Likely that link brings you to a malicious website
    controlled by someone that is trying to hack you. They may have placed some links
    or caused you to do something on their site that sends off a background request
    to a legitimate website to do something bad. If your application is not protected
    from CSRF attacks like this, it could be possible for that bad actor to induce
    your users to changing their passwords without them even knowing it!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你收到的那封可疑的尴尬电子邮件，上面写着“点击这里领取你的500美元奖金”吗？很可能那个链接会把你带到由试图黑客攻击你的人控制的恶意网站。他们可能放置了一些链接或者在他们的网站上诱导你做一些事情，从而向合法网站发送后台请求以执行不良行为。如果你的应用程序没有保护免受这种CSRF攻击，那么恶意行为者可能会诱导你的用户更改密码，而他们甚至都不知道这一点！
- en: Thwarting these attacks can be done on both sides. Your users could, of course,
    take better care not to open their email in the Spam box. But you, as a responsible
    web application developer, also have a responsibility to protect your users.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 阻止这些攻击可以在两个方面进行。当然，你的用户可以更加小心，不要在垃圾邮件箱中打开他们的电子邮件。但作为负责任的Web应用程序开发者，你也有责任保护你的用户。
- en: Solutions that do not work
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不起作用的解决方案
- en: Cookies. You may be surprised if you skipped ahead to peak at the solution that
    I offer you will see that it does include cookies. Indeed, cookies can play a
    part in solving the problem. However, they are a flawed security measure and *cannot*
    be the answer to the CSRF problem by themselves.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Cookies。如果你跳过前面的内容，提前查看我提供的解决方案，你会发现它确实包括了cookies。确实，cookies可以在解决问题中发挥作用。然而，它们是一个有缺陷的安全措施，**不能**单独作为解决CSRF问题的答案。
- en: How would this even work? Imagine that you set a session ID in a cookie. It
    is a decently good mixture of random characters so that it would be impractical
    for someone to guess it correctly. The problem is that cookies are sent with every
    request based not upon where the request is initiated, but where it is headed.
    So, if your browser sees that it has a cookie in storage for `yourapplication.com`,
    then even if the request was initiated at `h4ck3rsp4r4d1se.com`, the browser would
    send the cookies.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这究竟是如何工作的呢？想象一下，你在cookie中设置了一个会话ID。它是一个相当好的随机字符混合，使得有人猜对它是不切实际的。问题是，cookie是随着每个请求发送的，不是基于请求发起的地方，而是它要去的地方。所以，如果你的浏览器看到它存储了`yourapplication.com`的cookie，那么即使请求是在`h4ck3rsp4r4d1se.com`发起的，浏览器也会发送cookie。
- en: It also should be noted that introducing TLS and reading the Origin header are
    not sufficient solutions either. Of course, these are useful and valid things
    your application should be done, but alone they do not add protection from CSRF.
    The `Origin` header, for example, could easily be spoofed.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 还应注意的是，引入TLS和读取Origin头也不是充分的解决方案。当然，这些是应用程序应该执行的有用和有效的事情，但单独它们并不能提供对CSRF的保护。例如，`Origin`头很容易被欺骗。
- en: Solutions that do work
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 起作用的解决方案
- en: Now that we know what will not protect us from CSRF attacks, we can look into
    a few solutions that will work and help protect our web applications. These are
    not mutually exclusive, and I suggest you consider implementing them all in one
    form or another. Your decision will be contextual, of course, but here are some
    good practices to keep in mind while protecting your application from CSRF attacks.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了什么不能保护我们免受CSRF攻击，我们可以看看一些可行的解决方案，它们将有助于保护我们的Web应用程序。这些方案不是相互排斥的，我建议您考虑以某种形式实施它们。当然，您的决定将取决于具体情况，但以下是一些在保护应用程序免受CSRF攻击时需要记住的良好实践。
- en: Do not change state on `GET`
  id: totrans-164
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要在`GET`请求中改变状态
- en: This is incredibly important. We discussed the issue back in *Chapter 3*, but
    `GET` requests should not be state-changing. That means that the application should
    not take any direction from a `GET` request to go do something. These should be
    for information only. By removing `GET` from the hackers’ arsenal, we are forcing
    them into using Javascript exploits on their malicious websites.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常重要。我们之前在*第3章*中讨论了这个问题，但是`GET`请求不应该改变状态。这意味着应用程序不应该从`GET`请求中获取任何指示去做某事。这些请求应该只用于获取信息。通过从黑客的武器库中移除`GET`，我们迫使他们在其恶意网站上使用JavaScript漏洞。
- en: The reason that we want to allow this is because the browser has some built-in
    security measures we know about and can use to our advantage. First, from within
    the browser, the Origin header cannot be spoofed.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要允许这样做的原因是，浏览器有一些内置的安全措施，我们知道这些措施，并且可以利用它们来获得优势。首先，从浏览器内部，无法伪造Origin头。
- en: 'Let’s say our bad website had this code in it:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的不良网站中包含以下代码：
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you went to `somebadwebsite.com`, the origin would still be `http://somebadwebsite.com`.
    That is why CORS protection works. By disallowing stateful changes from `GET`
    requests, we make it so that a hack like this will not work:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问了`somebadwebsite.com`，源地址仍然是`http://somebadwebsite.com`。这就是为什么CORS保护起作用的原因。通过禁止`GET`请求进行状态改变，我们确保了这种类型的攻击不会成功：
- en: '[PRE27]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Forcing the hacker into Javascript—especially Javascript requests that are forced
    into issuing preflight requests—gives us some more control as we are about to
    see.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 将黑客强制使用JavaScript——尤其是那些被强制发出预检请求的JavaScript请求——在接下来我们将看到的情况下，这给了我们更多的控制权。
- en: Cookies
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Cookies
- en: The next helpful solution involves cookies.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个有用的解决方案涉及Cookies。
- en: Wait? Cookies were in the *do not work* solution category, what gives?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下？Cookies不是在“不起作用”的解决方案类别中吗？这是怎么回事？
- en: 'We just said that we want to force malicious attackers to use Javascript in
    their exploits. This is because we also know that browser cookies have a feature
    that we can control: `HttpOnly`. When a server creates a cookie, it can decide
    whether or not Javascript should be able to access that cookie. This means that
    the cookie will continue to be sent on every web request when enabled, but it
    will be inaccessible to any Javascript code. This makes it an ideal location for
    storing secure credentials like session tokens. Absent this, cookies are subject
    to what is known as Cross-Site Scripting attacks (aka “XSS”). This is an attack
    where some hacker is able to extract secure details from a frontend browser using
    Javascript.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚说过，我们想要迫使恶意攻击者在其漏洞中使用JavaScript。这是因为我们也知道浏览器Cookies有一个我们可以控制的功能：“HttpOnly”。当服务器创建一个Cookies时，它可以决定JavaScript是否应该能够访问该Cookies。这意味着当启用时，Cookies将在每个Web请求中继续发送，但任何JavaScript代码都无法访问它。这使得它成为存储像会话令牌这样的安全凭证的理想位置。如果没有这个，Cookies就会受到所谓的跨站脚本攻击（也称为“XSS”）的威胁。这是一种攻击，其中一些黑客能够使用JavaScript从前端浏览器中提取安全细节。
- en: '**Important Note**'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If your browser application can access some piece of information with Javascript,
    so can a hacker.
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果您的浏览器应用程序可以使用JavaScript访问某些信息，黑客也可以。
- en: We also mentioned that there was a problem that cookies for `yourapplication.com`
    can still be sent unknowingly from `h4ck3rsp4r4d1se.com`. Since Javascript ,when
    it is allowed to access cookie,s can only do so on the current domain, we have
    another tool in our belt we can use while building our solution.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还提到，`yourapplication.com`的Cookies仍然可能从`h4ck3rsp4r4d1se.com`不知情地发送。由于JavaScript在允许访问Cookies时，只能在其当前域上操作，我们在构建解决方案时又多了一个工具可以使用。
- en: When a user logs in, if we set two cookies (one for the session and one for
    the CSRF protection) we can set the `HttpOnly` value based upon the intended usage.
    The session cookie remains inaccessible, and the cookie that is set aside for
    CSRF protection could be Javascript accessible. We then could require that the
    Javscript uses that cookie’s value when sending in a request. This will work because
    the Javascript that is running on `h4ck3rsp4r4d1se.com` will not be able to access
    cookies that are marked for another domain.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户登录时，如果我们设置两个cookie（一个用于会话，一个用于CSRF保护），我们可以根据预期的使用情况设置`HttpOnly`值。会话cookie保持不可访问，而专门为CSRF保护设置的cookie可以是JavaScript可访问的。然后我们可以要求JavaScript在发送请求时使用该cookie的值。这将有效，因为运行在`h4ck3rsp4r4d1se.com`上的JavaScript将无法访问标记为其他域的cookie。
- en: What should the value of this cookie be? Well, really anything that could be
    impossible to guess. It is best to keep that value user specific so that you are
    able to verify its contents and be assured that the token is authentic. Also,
    the value should change and not be static. This will help make it more difficult
    for any would-be attackers. This dual cookie method is not 100% fault-proof. But
    it should be reasonably secure for most applications' needs. The problem comes
    when your users start accidentally downloading malware that is capable of circumventing
    the browser protections. We’ll leave that issue aside as it is an issue outside
    our ability to control, and a much more in-depth conversation beyond the scope
    of this book.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个cookie的值应该是什么？好吧，实际上任何难以猜测的东西都可以。最好保持该值与用户特定相关，这样你才能验证其内容并确信令牌是真实的。此外，该值应该改变，而不是静态的。这将使任何潜在的攻击者更难攻击。这种双重cookie方法并非100%无懈可击。但对于大多数应用程序的需求来说，应该是相当安全的。问题是当你的用户开始意外下载能够绕过浏览器保护的恶意软件时。我们将把这个问题放在一边，因为它超出了我们控制的能力，并且超出了这本书的范围的深入讨论。
- en: 'It should be noted that we do not necessarily care that the CSRF token could
    be compromised and used by a bad actor. That is fine. Because even if they could
    access it, they have no way to then send with both: the correct origin, and the
    correct session token.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，我们并不一定关心CSRF令牌可能被破坏并被恶意行为者使用。这是可以的。因为即使他们能够访问它，他们也没有办法发送带有正确的来源和正确的会话令牌。
- en: Form fields
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 表单字段
- en: 'There is another form of CSRF protection that other frameworks use. For example,
    Django made popular the idea of injecting some hidden HTML onto the page:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 其他框架还使用另一种形式的CSRF保护。例如，Django使注入一些隐藏的HTML到页面上的想法变得流行：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This value would then be included in form responses, or read into the request
    in some expected way. This is essentially the exact same idea that I am proposing
    here. The only difference is that instead of injecting the value into a hidden—although
    Javascript accessible location—input, we are storing it in a cookie. Both solutions
    will ultimately depend upon what happens in the next section when that value is
    sent back to the server.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此值将被包含在表单响应中，或者以某种预期的方式读取到请求中。这本质上是我在这里提出的完全相同的想法。唯一的区别是，我们不是将值注入到一个隐藏的（尽管可以通过JavaScript访问）位置输入中，而是将其存储在cookie中。这两种解决方案最终都将取决于下一节中该值发送回服务器时发生的情况。
- en: Putting a solution into practice
  id: totrans-187
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将解决方案付诸实践
- en: 'Now that we have a general idea of our approach let’s recap to be clear. We
    want to allow stateful changes in our application to authenticated users only.
    To achieve confidence that the changes are coming from our users and not hackers,
    we will allow the change when:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对我们的方法有一个大致的了解，让我们回顾一下，以便明确。我们希望只允许认证用户在我们的应用程序中进行状态更改。为了确保更改来自我们的用户而不是黑客，我们将在以下情况下允许更改：
- en: The HTTP method is `POST`, `PATCH`, `PUT`, or `DELETE`
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP方法为`POST`、`PATCH`、`PUT`或`DELETE`
- en: The origin of the incoming request matches what we would expect
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入请求的来源与我们预期的相符
- en: The incoming request has a cookie that was stored with `HttpOnly`
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入请求有一个使用`HttpOnly`存储的cookie
- en: The incoming request has a valid CSRF token
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入的请求有一个有效的CSRF令牌
- en: 'To accomplish our goal, we need to decide where we will put our code that is
    going to accomplish this goal. We, therefore, come back to the debate we have
    seen a few times already: decorators or middleware. There is not a correct choice,
    and the answer will, of course, depend upon what you are building.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的目标，我们需要决定我们将把实现这个目标的代码放在哪里。因此，我们回到了我们已经看到几次的辩论：装饰器或中间件。没有正确的选择，答案当然将取决于你正在构建的内容。
- en: 'For our example, we will build it as a decorator. When we come to authentication
    in the next section, it will become more clear why we are using the decorator
    pattern here. If you think middleware works for you, go ahead and try to rebuild
    this as middleware. Both options are legitimate patterns and may serve your needs
    in different circumstances. To be honest, however, I usually find the decorator
    pattern to be more easily adoptable with a broader set of use cases. Here are
    the steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们将构建它作为一个装饰器。当我们进入下一节的认证时，将更清楚地了解为什么在这里使用装饰器模式。如果你认为中间件适合你，那就继续尝试将其重建为中间件。这两种选项都是合法的模式，可能在不同的环境下满足你的需求。然而，说实话，我通常发现装饰器模式更容易适应更广泛的使用案例。以下是步骤：
- en: 'To start, we will make a barebones decorator. To make the job easier, you can
    grab a decorator template from the Sanic User Guide: [https://sanicframework.org/en/guide/best-practices/decorators.html#templates](https://sanicframework.org/en/guide/best-practices/decorators.html#templates).'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个基本的装饰器。为了使工作更容易，你可以从Sanic用户指南中获取装饰器模板：[https://sanicframework.org/en/guide/best-practices/decorators.html#templates](https://sanicframework.org/en/guide/best-practices/decorators.html#templates)。
- en: '[PRE29]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'When there is a CSRF failure, the correct response should be a `403 Forbidden`.
    We will make a custom exception that we can raise whenever this happens:'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当发生CSRF失败时，正确的响应应该是`403 Forbidden`。我们将创建一个自定义异常，以便在发生这种情况时抛出：
- en: '[PRE30]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Thinking about our goals and our requirements, we want to somehow determine
    that the request is coming from a browser. This is because a browser request will
    be subject to CSRF protection. There is no need to implement it on direct access
    API requests. Personally, I like to do this by adding a `HttpOnly` cookie on every
    request if it does not exist. The value is completely irrelevant. The only thing
    we care about is that the value was sent. The same is with the origin header.
    If an `Origin` was sent, we will assume it is a browser request and subject it
    to the stiffer requirements we will impose next. This is, for sure, a belt and
    suspenders approach since they are a bit duplicative. It does still, however,
    give you an idea of the types of strategies you should be thinking about when
    designing your own solutions.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到我们的目标和需求，我们想要以某种方式确定请求来自浏览器。这是因为浏览器请求将受到CSRF保护。没有必要在直接访问API请求上实现它。我个人喜欢通过在每个请求上添加一个`HttpOnly`
    cookie（如果不存在的话）来做这件事。这个值完全无关紧要。我们唯一关心的是这个值被发送了。对于`Origin`头也是如此。如果发送了`Origin`，我们将假设这是一个浏览器请求，并对其施加我们接下来将施加的更严格的要求。这确实是一个腰带加背带的方法，因为它们有点重复。然而，它确实给你一个想法，在设计自己的解决方案时应该考虑哪些类型的策略。
- en: '[PRE31]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '**TIP**'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Marking the `browser_check` cookie on every request is overkill. I generally
    recommend doing this on a landing page. Or, in someway catching the case when
    there is an `Origin` and no cookie to set it then. I will leave this to your discretion
    to determine an appropriate place and method to setting this cookie. If you control
    the frontend application, you might even consider setting it there. The point
    of this cookie is just to give us an additional indication that this is not a
    direct access API request.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在每个请求上标记`browser_check` cookie是过度的。我通常建议在着陆页上这样做。或者，以某种方式捕捉到存在`Origin`但没有cookie设置的情况。我将把这个决定权交给你，以确定设置此cookie的适当位置和方法。如果你控制前端应用程序，你甚至可以考虑在那里设置它。这个cookie的目的只是给我们一个额外的指示，表明这不是一个直接访问API请求。
- en: 'Looking at our list of requirements again, let’s add some code into the decorated_function
    of our decorator that makes sure that the origin matches. This is necessary because
    as we already know when the request is coming from the browser’s Javascript, this
    value cannot be spoofed:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次查看我们的需求列表，让我们在我们的装饰器装饰函数中添加一些代码，以确保来源匹配。这是必要的，因为我们已经知道当请求来自浏览器的JavaScript时，这个值不能被伪造：
- en: '[PRE32]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The next requirement that we have is to make sure an `HttpOnly` token is present.
    For now, we will just use our `browser_check` cookie. This could also be satisfied
    with a session cookie if you have one:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一个需求是确保存在一个`HttpOnly`令牌。目前，我们将使用我们的`browser_check` cookie。如果你有一个会话cookie，这也可以满足：
- en: '[PRE33]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Lastly, we need to verify our CSRF token. I know we have not discussed what
    that is, how to generate it, so of course we have not gotten to the verification
    bit yet. We will get there momentarily. Until then, let’s simply add a function
    to round out our decorator:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要验证我们的 CSRF 令牌。我知道我们还没有讨论这是什么，如何生成它，所以当然我们还没有到达验证的部分。我们很快就会到达那里。在此之前，让我们简单地添加一个函数来完善我们的装饰器：
- en: '[PRE34]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We now finally turn to CSRF tokens. For our implementation we are going to
    use a Fernet token. This is a method of encrypting some bit of text with a secret
    key so that it cannot be changed or read without that key. We are going to set
    this token in a cookie that will explicitly *not* be `HttpOnly`. We want the frontend
    Javascript application to read this value and send it back in the application
    via the headers. When the potentially harmful state-changing request comes in,
    we will verify that the header and the cookie match. We also will extract the
    payload of the Fernet token and validate its contents. The actual value of that
    token we will store in a second cookie that will be `HttpOnly`. The purpose of
    this dual cookie, and dual submit verification is to protect our applications
    from various types of attacks that might otherwise compromise our strategy. The
    solution might sound much more complicated than it actually is, so let’s look
    at some code to start piecing this together:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们终于转向 CSRF 令牌。对于我们的实现，我们将使用 Fernet 令牌。这是一种使用密钥加密一些文本的方法，这样在没有该密钥的情况下就无法更改或读取。我们将把这个令牌设置在一个cookie中，这个cookie将明确地**不是**`HttpOnly`。我们希望前端
    JavaScript 应用程序读取这个值，并通过头部将其发送回应用程序。当可能有害的状态改变请求到来时，我们将验证头部和cookie是否匹配。我们还将提取
    Fernet 令牌的有效负载并验证其内容。该令牌的实际值我们将存储在第二个cookie中，该cookie将是`HttpOnly`。这个双重cookie和双重提交验证的目的是为了保护我们的应用程序免受可能破坏我们策略的各种攻击。解决方案可能听起来比实际要复杂得多，所以让我们看看一些代码来开始拼凑这个解决方案：
- en: We will begin by setting up some configuration values that we will need.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先设置一些我们将需要的配置值。
- en: '[PRE35]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '**IMPORTANT NOTE**'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: It should come as no surprise that you should never, *never*, *NEVER* hard code
    a secret like this in your applications. This is for example purposes only. Instead,
    you should be injecting secret values via environment variables or some other
    more secure method than this.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 毫不奇怪，你绝对不应该，**绝对不应该**，**绝对不应该**在你的应用程序中硬编码这样的秘密。这只是为了示例目的。相反，你应该通过环境变量或比这更安全的方法注入秘密值。
- en: 'We need a function that will generate our CSRF reference value and token. To
    accomplish this, we will use the cryptography library mentioned at the beginning
    of this chapter. It is battle tested and reliable. It should be the obvious first
    place to turn for all cryptographic needs in Python. Here’s the code:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来生成我们的 CSRF 引用值和令牌。为了完成这个任务，我们将使用本章开头提到的加密库。它经过实战检验，是可靠的。它应该是我们在 Python
    中解决所有加密需求时的首选之地。以下是代码：
- en: '[PRE36]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can see, this is fairly simple. We create the cipher object using our
    secret. Then, as per the recommendation from the cryptography library, we use
    the operating system’s random generator logic with `os.urandom` to make our reference
    value, and some extra fluff. The reference is encrypted, and our token is then
    padded and returned along with the reference value.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，这相当简单。我们使用我们的密钥创建加密对象。然后，根据加密库的建议，我们使用操作系统的随机生成器逻辑，通过 `os.urandom` 来生成我们的引用值和一些额外的填充。引用值被加密，然后我们的令牌被填充并返回，同时附带引用值。
- en: 'Creating the reverse for verifying our token is a matter of performing these
    steps in reverse, and then comparing the encrypted value to the passed referenced
    value:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了验证我们的令牌，我们需要执行这些步骤的逆操作，并将加密值与传递的引用值进行比较：
- en: '[PRE37]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We will need a way to make sure these values exist as cookies. Therefore, we
    will generate them in middleware for this example. However, it might be logical
    to instead perform this function on a login endpoint:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一种方法来确保这些值作为cookie存在。因此，我们将在这个示例中在中间件中生成它们。然而，在登录端点执行此功能可能更合理：
- en: '[PRE38]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Remember, the plan is for the `csrf_token` to be Javascript accessible. We
    want the incoming request to not only include this in a cookie value but also
    have this value injected in the HTTP headers. This can only be done by Javascript
    running on our applications because of the same-origin policy. CORS to the rescue.
    This means, do not forget to whitelabel our request header that we will see next:
    `X-XSRF-Token`.'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，我们的计划是让 `csrf_token` 可由 JavaScript 访问。我们希望传入的请求不仅包含在 cookie 值中，还要在 HTTP 头部注入这个值。由于同源策略，这只能通过在我们应用程序上运行的
    JavaScript 来完成。CORS 来拯救。这意味着，不要忘记白名单我们即将看到的请求头部：`X-XSRF-Token`。
- en: 'Remember back in our `@csrf_protected` decorator, one of the checks was `csrf_check(request)`.
    We will finally now uncover what that function is:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在我们之前的 `@csrf_protected` 装饰器中，有一个检查是 `csrf_check(request)`。现在我们终于要揭露这个函数是什么了：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'There should be three values that we care about: the two cookies we just set,
    and the incoming `X-XSRF-Token` header. This header as we know will be generated
    on the client-side by extracting the cookie and injecting the value in the header.
    It should now be simply a matter of verifying that:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该关注三个值：我们刚刚设置的两个 cookie 和传入的 `X-XSRF-Token` 头部。正如我们所知，这个头部将在客户端生成，通过提取 cookie
    并将其值注入头部。现在，简单地验证这一点就足够了：
- en: The cookie and the header match
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cookie 和头部匹配
- en: The protected `HttpOnly` reference value is the same as the encrypted value
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的 `HttpOnly` 引用值与加密值相同
- en: If that all checks out, we can be confident that the request is genuine.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有检查都无误，我们可以确信请求是真实的。
- en: '**TIP**'
  id: totrans-230
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**提示**'
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may be wondering why I chose XSRF here instead of `X-CSRF-Token`, or even
    just `CSRF-Token` for the header name. The reason is that there are some frontend
    frameworks that automatically add this header injection for you client side. Since
    it is not important from our perspective what the header is called, we might as
    well play nice with some other tooling that likes it named this way.
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我选择在这里使用 XSRF 而不是 `X-CSRF-Token`，甚至只是 `CSRF-Token` 作为头部名称。原因是一些前端框架会自动为你客户端添加这个头部注入。由于从我们的角度来看，头部的名称并不重要，我们不妨与其他喜欢这样命名的工具友好地合作。
- en: Samesite cookies
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Samesite cookies
- en: You may be familiar with a newer concept in CSRF protection known as **samesite**
    cookies. This is a value that can be appended to the cookie that provides extra
    directions to the browser about how to treat that cookie. In short, by setting
    this value on the cookies on the server, we allow the application to dictate to
    the browser when it is and is not acceptable to send the cookie. This alone *nearly*
    mitigates the issues with CSRF, but it should *NOT* be used by itself as the solution.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉 CSRF 保护中的一个较新的概念，称为 **samesite** cookies。这是一个可以附加到 cookie 上的值，为浏览器提供了额外的指示，说明如何处理该
    cookie。简而言之，通过在服务器上的 cookie 上设置此值，我们允许应用程序告诉浏览器何时可以发送 cookie，何时不可以。仅此一项几乎可以缓解
    CSRF 的问题，但它**不应**单独作为解决方案使用。
- en: In fact, the **Open Web Application Security Project (OWASP)**—a nonprofit foundation
    that promotes the enhancement of security practices online—specifically states
    that the samesite attribute “*should not replace having a CSRF Token. Instead,
    it should co-exist with that token in order to protect the user in a more robust
    way.*” [https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute)
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，**开放网络应用安全项目 (OWASP)**——一个促进在线安全实践增强的非营利性基金会——明确指出，samesite 属性“*不应取代 CSRF
    Token。相反，它应该与该令牌共存，以便以更稳健的方式保护用户。*” [https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute)
- en: 'We will now learn about samesite cookie protection, and how to integrate it
    into our solution. There are three allowed values: `None`, `Lax`, and `Strict`'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将了解 samesite cookie 保护以及如何将其集成到我们的解决方案中。有三个允许的值：`None`、`Lax` 和 `Strict`
- en: Samesite=None
  id: totrans-237
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Samesite=None
- en: Cookies that use `Samesite=None` should be considered only for non-security
    related cookies. This is because they will be sent with every request, no matter
    what site they are originating from. Therefore, if you are on the hacker’s website,
    that hacker will be able to submit requests on your behalf to other sites that
    you have visited and making use of the cookies you have on your computer. Not
    cool.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Samesite=None` 的cookies应仅考虑用于非安全相关的cookies。这是因为它们将与每个请求一起发送，无论它们来自哪个网站。因此，如果你在黑客的网站上，那个黑客将能够代表你向其他你访问过的网站提交请求，并利用你电脑上的cookies。这可不是什么好事。
- en: But, for the right kind of cookies, this is not really an issue. As long as
    the value has nothing to do with security or sessions, this is acceptable. It
    should be also noted, however, that for this to work it will also only be allowed
    when the cookie is marked Secure. That is to say that it is only allowed to be
    passed across `https` requests. In your production level code, you should be doing
    this regardless. You are using TLS encryption right? If not, we will see super
    simple solution to this in Chapters 8 and 10.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，对于正确类型的cookies，这实际上并不是一个问题。只要这个值与安全或会话无关，这是可以接受的。然而，也应该注意的是，为了使这个功能生效，它也只有在cookie被标记为Secure时才允许。也就是说，它只允许在
    `https` 请求中传递。在你的生产级代码中，你应该始终这样做。你使用TLS加密吗？如果不使用，我们将在第8章和第10章中看到这个问题的简单解决方案。
- en: 'Setting `Samesite=None` is as simple as the following:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `Samesite=None` 就像以下这样简单：
- en: '[PRE40]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This will result in the following cookie:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致以下cookie：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Samesite=Lax
  id: totrans-244
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Samesite=Lax
- en: This is the default in most modern web browsers now. You should not, however,
    rely upon that fact, and it is certainly still best practice to do so explicitly.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数现代网络浏览器默认就是这样。然而，你不应该依赖于这个事实，并且明确地这样做仍然是最佳实践。
- en: What does this value mean? It means that the cross-site `POST` requests we have
    been worried about will not include the cookies (which is a big part of CSRF protection).
    However, it will allow them in some contexts. To be sent in a cross-site request,
    the request must be a top-level navigation (think of this as the address bar in
    the browser), and the HTTP method must be `GET` or `HEAD`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这个值是什么意思？它的意思是，我们一直担心的跨站 `POST` 请求将不会包含cookies（这是CSRF保护的一大部分）。然而，在某些情况下，它将允许它们存在。要在一个跨站请求中发送，请求必须是顶级导航（可以想象成浏览器的地址栏），并且HTTP方法必须是
    `GET` 或 `HEAD`。
- en: This basically boils down to protection from AJAX requests, but allowing the
    cookie to be sent when someone navigates to the site from a third-party link.
    This actually makes a lot of sense and is probably what you want to use for a
    lot of your cookies.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上归结为对AJAX请求的保护，但允许当有人从第三方链接导航到网站时发送cookie。这实际上很有道理，可能是你想要为许多cookies使用的。
- en: For example, if your session cookies were *not* set to Lax (and instead were
    `Strict`) when someone clicked a link from another website that brought them to
    your site, they would not appear as logged in. However, once they started clicking
    around, suddenly their session would appear. This might be an awkward experience
    for the user. Therefore, it is suggested that session management and authentication
    cookies should be `Lax` for most typical applications. If you are building a secured
    banking application, you probably have no use for someone to link to a secured
    banking page, and maybe `Lax` is not the right answer. However, it is generally
    acceptable to use Lax for authentication.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你的会话cookies没有被设置为Lax（而是 `Strict`），当有人从另一个网站点击链接来到你的网站时，他们不会显示为已登录。然而，一旦他们开始浏览，他们的会话突然出现。这可能会给用户带来尴尬的体验。因此，建议对于大多数典型应用，会话管理和认证cookies应使用
    `Lax`。如果你正在构建一个安全的银行应用程序，你可能不希望有人链接到安全的银行页面，也许 `Lax` 不是一个正确的答案。然而，通常使用Lax进行认证是可以接受的。
- en: As mentioned, you do not need to explicitly state the samesite attribute anymore,
    but explicit is better than implicit.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你不再需要明确声明samesite属性，但明确总是优于隐含。
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This will generate a cookie that looks like this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个看起来像这样的cookie：
- en: '[PRE43]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Samesite=Strict
  id: totrans-253
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Samesite=Strict
- en: As alluded to in the last section, a `Strict` cookie will only be sent when
    the request originated from the correct site. This means that the user must first
    be on your application, and *then* submit the request. In my opinion, this really
    sounds like the type of request that would be performed that is state-changing.
    Do you see where I am headed with this?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一节所暗示的，只有当请求来自正确的网站时，才会发送`Strict` cookie。这意味着用户必须首先登录你的应用，然后才能提交请求。在我看来，这听起来就像是一种会改变状态的请求。你明白我的意思了吗？
- en: 'In my opinion (and you will undoubtedly come across different opinions), CSRF
    protection cookies should be `Samesite=Strict`. There is no legitimate use case
    (at least not in my applications) where I can think that I would not want my user
    to be on my application first before initiating the types of requests that I am
    trying to protect. You may have different needs, and this might not work for you.
    If `Lax` makes sense, then go with it. I’ll stick to this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来（而且你无疑会遇到不同的观点），CSRF 保护cookie应该设置为`Samesite=Strict`。至少在我的应用中，我想不出任何合法的使用场景（至少不是我想保护的请求类型），我会希望用户在发起这些请求之前先登录我的应用。你可能有不同的需求，这可能不适合你。如果你觉得`Lax`更合适，那就按你的去做。我会坚持我的选择：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'As you can probably guess, our cookies now look like this:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如你大概能猜到的，我们的cookie现在看起来是这样的：
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '**IMPORTANT NOTE**'
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'As mentioned, support for samesite cookies is not universal. You should check
    a website like CanIUse to see if any browsers you are targetting do not implement
    it: [https://caniuse.com/same-site-cookie-attribute](https://caniuse.com/same-site-cookie-attribute).
    Also, a “same” site in this context does include subdomains. There is a public
    list of addresses that are considered “top-level” for this context, which does
    not completely line up with .com, .org, io, etc. For example, two websites on
    github.io are not considered samesite. For the full list, check it out here: [https://publicsuffix.org](https://publicsuffix.org).'
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 正如之前提到的，samesite cookie的支持并不是普遍的。你应该检查像CanIUse这样的网站，看看你目标浏览器是否实现了它：[https://caniuse.com/same-site-cookie-attribute](https://caniuse.com/same-site-cookie-attribute)。此外，在这个上下文中，“相同”的网站也包括子域名。有一个公共地址列表被认为是这个上下文中的“顶级”地址，它并不完全与.com、.org、.io等匹配。例如，github.io上的两个网站不被认为是samesite。完整的列表，请查看这里：[https://publicsuffix.org](https://publicsuffix.org)。
- en: In our review of CSRF, there was a lot of mention of session tokens and authentication,
    but we have not looked at that yet. While this is an incredibly deep topic by
    itself, we will explore how you can implement authentication on your applications
    using Sanic.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对CSRF的审查中，提到了很多关于会话令牌和身份验证的内容，但我们还没有探讨这一点。虽然这是一个非常深入的话题，我们将探讨如何使用Sanic在你的应用中实现身份验证。
- en: Protecting your Sanic app with authentication
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用身份验证保护你的 Sanic 应用
- en: 'When many people think about a web application, what comes to mind is some
    type of a platform on the web where they login to do… *something*. The activity
    is not what we care about here. When you are done reading this book, you are going
    to go off and build some amazing applications. What we care about is the journey
    and the process. And, the part of the process that we care about right now is:
    login.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当许多人思考一个Web应用时，他们脑海中浮现的是一种在Web上的平台类型，他们登录后去做…*某件事*。这里的活动并不是我们关心的。当你读完这本书后，你将去构建一些令人惊叹的应用。我们关心的是旅程和过程。而我们现在关心的过程部分是：登录。
- en: To be more specific and correct, what we are about to look is **authentication**
    and not so much about **authorization**. While these two ideas are very closely
    related, they are not the same and are not interchangeable. In fact, authorization
    usually presumes that authentication already happened.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体和准确地说，我们即将探讨的是**身份验证**，而不是那么多的**授权**。虽然这两个概念非常紧密相关，但它们并不相同，也不能互换。事实上，授权通常假定身份验证已经发生。
- en: What’s the difference?
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有什么区别？
- en: '**Authentication**: answers the question: who are you?'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**：回答的问题是：你是谁？'
- en: '**Authorization**: answers the question: what are you allowed to do?'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**授权**：回答的问题是：你被允许做什么？'
- en: To confuse matters even more, a failure of **authentication** is a `401 Unauthorized`
    response. This is super unfortunate naming from the early days of the Internet.
    A failure of **authorization** is a `403 Forbidden` response.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 更让人困惑的是，**身份验证**失败会返回`401 Unauthorized`响应。这是互联网早期的一个非常不幸的命名。**授权**失败会返回`403
    Forbidden`响应。
- en: 'In 2020, I spoke at EuroPython about access control issues. The slides and
    a link to the YouTube presentation are on my GitHub page: [https://github.com/ahopkins/europython2020-overcoming-access-control](https://github.com/ahopkins/europython2020-overcoming-access-control).
    If you have about 30 minutes to watch a riveting presentation about this thrilling
    topic, its “don’t miss” opportunity.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020年，我在EuroPython会议上讨论了访问控制问题。幻灯片和YouTube演示文稿的链接在我的GitHub页面上：[https://github.com/ahopkins/europython2020-overcoming-access-control](https://github.com/ahopkins/europython2020-overcoming-access-control)。如果你有大约30分钟的时间观看关于这个激动人心的主题的引人入胜的演示，这是一个“不容错过”的机会。
- en: 'The presentation covers this authentication/authorization topic, but also largely
    tries to answer the question: “what are the different methods for protecting my
    API?” It answers this by comparing session-based authentication with non-session
    based (aka stateless). We will review both of these strategies here, but also
    include how to implement API keys (which is not covered in that presentation).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 演示涵盖了认证/授权这个主题，但同时也很大程度上试图回答这个问题：“保护我的API的不同方法有哪些？”它通过比较基于会话的认证与非基于会话的（即无状态）来回答这个问题。我们在这里将回顾这两种策略，同时也会包括如何实现API密钥（这在那个演示中未涉及）。
- en: To do this, there is a set of questions that need to be answered. Before we
    dive into how to implement some of the common strategies with Sanic, we will review
    some of the questions that you should ask yourself before deciding upon a strategy.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，有一系列问题需要回答。在我们深入探讨如何使用Sanic实现一些常见策略之前，我们将回顾一些在决定策略之前你应该问自己的问题。
- en: Who will consume the API?You should think about whether the API is going to
    be used by other applications or scripts, or by actual people. Will it be used
    by programmers who are integrating it into their applications? Or, will it be
    used to power a mobile application? Does a frontend Javascript application need
    to access it?The reason you should care is you must have an understanding of the
    technical abilities, but also the weaknesses of your intended use case. If your
    API will only ever be consumed by other backend scripts and applications, then
    you will have an easier time securing it. Most of that stuff we talked about cookies
    is highly irrelevant; and CORS is a non-issue.On the other hand, if you intend
    to power a browser-based single page application, then you likely need a more
    robust authentication strategy than simple API keys.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 谁将消费这个API？你应该考虑API是否将被其他应用程序或脚本使用，或者由实际的人使用。它将被用于将集成到其应用程序中的程序员吗？或者，它将被用于为移动应用程序提供动力？前端JavaScript应用程序需要访问它吗？你应该关心的原因是你必须了解你的预期用例的技术能力，但也要了解其弱点。如果你的API将仅由其他后端脚本和应用程序消费，那么你将更容易保护它。我们之前讨论的大部分关于cookie的内容都高度不相关；而且CORS不是一个问题。另一方面，如果你打算为基于浏览器的单页应用程序提供动力，那么你可能需要一个比简单的API密钥更健壮的认证策略。
- en: Do you have control over the client?The core of this question is whether you
    (or your organization) will be the consumer of the API. Contrast this with an
    API that is meant to be consumed by integrations and other applications, and you
    should see that this can have a difference on how you control access. For example,
    if you are building a microservice that is not exposed to the Internet, but only
    exists within a highly controlled network, you obviously have a different set
    of security concerns than the API that powers your bank’s website.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你是否控制着客户？这个问题的核心在于你（或你的组织）是否会成为API的消费者。将此与旨在被集成和其他应用程序消费的API进行对比，你应该看到这会在你如何控制访问上产生差异。例如，如果你正在构建一个不面向互联网、仅存在于高度受控网络中的微服务，那么你显然会有与为你的银行网站提供动力的API不同的安全担忧。
- en: Will this power a web browser frontend application?This is a bit of a subset
    of the first question, but it is important enough to think about on its own. The
    reason that this is so much of an issue is that the browser is flawed. When the
    Internet was first created and web browsers were first being released, no one
    could quite predict the direction and level of importance that would become of
    the Internet. The security concerns—and the solutions to mitigate them—were born
    out of years of hackers attempting to exploit a system that was never really designed
    with a security first mindset.For example, the fact that non-encrypted `http://`
    websites even exist in today’s world is really mind-boggling. This Chapter devoted
    a lot of energy so far to how to deal with certain security concerns that only
    exist because the web browser is broken. Therefore, knowing that there is even
    a possibility of frontend usage for your application should trigger warning bells
    early on that you **must** dedicate time and attention to this topic.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将支持一个网络浏览器前端应用程序吗？这实际上是第一个问题的子集，但它的重要性足以单独考虑。这个问题之所以如此重要，是因为浏览器存在缺陷。当互联网最初被创建，并且网络浏览器最初被发布时，没有人能够准确预测互联网的方向和重要性。安全问题是——以及缓解这些问题的解决方案——是在多年的黑客试图利用一个从未真正以安全为首要考虑的系统后产生的。例如，在当今世界，非加密的`http://`网站甚至存在，这真的很令人震惊。到目前为止，本章已经投入了大量精力来探讨如何处理仅因为网络浏览器存在缺陷而存在的某些安全问题。因此，知道你的应用程序甚至存在前端使用的可能性，应该在你早期就触发警告，你必须为此话题投入时间和精力。
- en: With those three questions in our mind, we will now look at three potential
    schemes for authenticating users. But first, another reminder that just because
    I do something some way here does not mean you should as well. Use your skills
    to take what is provided to build the solutions you need for your application.
    We are talking security, so maybe you should be careful before you stray too far.
    If you ever have a question about whether a strategy, feel free to bring the question
    to the community on Discord or in the Forums.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在心中牢记这三个问题后，我们现在将探讨三种潜在的认证用户方案。但首先，还有一个提醒，即我这里所做的一些事情并不意味着你也应该这样做。运用你的技能，利用所提供的内容构建你应用程序所需的解决方案。我们谈论的是安全，所以在你走得太远之前可能需要小心。如果你对某个策略有疑问，随时可以将问题带到Discord社区或论坛上。
- en: Next, we will explore *some* of the strategies you may find.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨你可能会发现的一些策略。
- en: Using API Keys
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用API密钥
- en: By far, API keys are the simplest authentication scheme. They are easy to set
    up and easy for the end-user to implement. It also means that they offer lesser
    security. That does not mean they should be overlooked. In the right context,
    API keys can be the exact right tool to get the job done, provided you take measures
    to mitigate any security concerns.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，API密钥是最简单的认证方案。它们易于设置，也易于最终用户实施。这也意味着它们提供的安全性较低。但这并不意味着它们应该被忽视。在适当的背景下，如果采取缓解安全问题的措施，API密钥可以成为完成工作的确切工具。
- en: 'API keys go by many names, but they boil down to a simple concept: your application
    provides a secure persistent token. When the request is accompanied by that token,
    it works. If not, it fails. It is as simple as that. One of the main benefits—besides
    simplicity—is that the keys are easy to invalidate. Since you are storing the
    keys *somewhere*, all you need to do is change the stored value or remove it and
    that key will no longer work.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥有许多名称，但它们归结为一个简单的概念：你的应用程序提供了一个安全的持久令牌。当请求伴随该令牌时，它就会生效。如果没有，它就会失败。就是这样简单。除了简单之外，主要好处之一是密钥易于作废。由于你将密钥存储在某个地方，你只需要更改存储的值或删除它，该密钥就不再有效。
- en: The reason that API keys are more susceptible to attacks is that they are a
    single, persistent value. This means that it is in theory easier for the value
    to be brute force attacked. A hacker could set up a machine and try every single
    combination until one worked. Therefore, the first step in making sure that your
    API scheme is secure is to **use strong keys**. This means a high amount of entropy.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥更容易受到攻击的原因是它们是一个单一、持久的值。这意味着理论上更容易对其进行暴力破解。黑客可以设置一台机器并尝试每一个组合，直到找到一个有效的。因此，确保您的API方案安全的第一步是**使用强密钥**。这意味着需要高熵量。
- en: Once a sufficiently complex API key has been generated, it should be hashed
    before storing. **Do not encrypt** your keys. What is the difference between hashing
    and encrypting? When you “encrypt” data, it can be reversed. Like we saw with
    Fernet encryption, we were able to reverse the process and decrypt the original
    value. This is a no-no for API keys. Hashing, on the other hand, is a one-way
    street. Once it is hashed, there is no way to recover the original value. Therefore,
    to validate a value against it, you need to hash the incoming value using the
    same strategy, and compare the result to the stored hash.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了一个足够复杂的API密钥，在存储之前应该对其进行散列。**不要加密**你的密钥。散列和加密有什么区别？当你“加密”数据时，它可以被反转。就像我们看到的Fernet加密一样，我们能够反转这个过程并解密原始值。这对于API密钥来说是不允许的。另一方面，散列是一条单行道。一旦散列，就无法恢复原始值。因此，为了验证值，你需要使用相同的策略对传入的值进行散列，并将结果与存储的散列值进行比较。
- en: 'This might sound to you like password management, right? That is because you
    should basically treat an API key exactly as you would a password. This brings
    up the second potential security pitfall when using API keys: storage. **Never**
    store it in plain text, **never** store it in a format where the original value
    can be retrieved, and **never** store it so that the hashed value can easily be
    predicted.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来可能像是密码管理，对吧？这是因为你应该基本上将API密钥当作密码来处理。这提出了使用API密钥时的第二个潜在安全陷阱：存储。**永远**不要以纯文本形式存储，**永远**不要以原始值可以恢复的格式存储，**永远**不要以散列值可以轻易预测的方式存储。
- en: Once you have the value of a newly generated key, you will add a “salt” before
    storing it. A password salt is a random bit of text that is added to a password
    so that when the password is hashed, it is done so in an unpredictable format.
    If you do not salt the password, then the hashed value can be cracked by comparing
    to known hashes for common passwords. Hackers keep databases of the hashed values
    of common passwords for this reason. Even though they might not be able to decrypt
    a hashed value, if you fail to salt it, then it is super simple for them to backwards
    engineer the value by simply looking at known values. Luckily, the `bcrypt` module
    makes this easy. Let’s dive into some code.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到了新生成密钥的值，你将在存储之前添加一个“盐”。密码盐是一段随机文本，它被添加到密码中，以便在密码被散列时，它以不可预测的格式进行。如果你不加盐密码，那么散列值可以通过与常见密码的已知散列值进行比较而被破解。黑客出于这个原因保留了常见密码的散列值数据库。即使他们可能无法解密散列值，如果你没有加盐，那么他们通过简单地查看已知值就可以非常容易地反向工程出值。幸运的是，`bcrypt`模块使这变得简单。让我们深入一些代码。
- en: 'We will begin by creating a function to generate an API key. To do this, we
    will use the `secrets` module that comes from the Python standard library. In
    our example, we will use `secrets.token_urlsafe` to generate the value. You also
    could use `secrets.token_hex`, but it will produce a slightly longer string to
    represent the same value. The reason I suggest using this library with its default
    settings is that the maintainers of Python will change the amount of entropy needed
    based upon current best practices. As of the time of this writing, the default
    is 32 bytes. If you feel more is required, feel free to increase that value:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先创建一个生成API密钥的函数。为此，我们将使用来自Python标准库的`secrets`模块。在我们的例子中，我们将使用`secrets.token_urlsafe`来生成值。你也可以使用`secrets.token_hex`，但它将产生一个稍长的字符串来表示相同的值。我建议使用这个库及其默认设置的原因是，Python的维护者将根据当前最佳实践更改所需的熵量。在撰写本文时，默认值是32字节。如果你觉得需要更多，你可以自由地增加这个值：
- en: '[PRE46]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We also used the `bcrypt` module for generating a salt. What this does is adds
    random text, creates a hash, and then repeats the cycle several times. By folding
    the hashed value with multiple rounds of salting, it becomes more difficult to
    compare against a known value (it also becomes computationally more expensive,
    so setting the value too high might be super-time consuming). We will use `gensalt`
    with the default value of 12 rounds.
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还使用了`bcrypt`模块来生成盐。这样做是添加随机文本，创建散列，然后重复这个过程几次。通过将散列值与多轮盐值折叠，它变得难以与已知值进行比较（它也变得计算上更昂贵，所以设置得太高可能会非常耗时）。我们将使用`gensalt`并使用默认的12轮。
- en: 'You will need some endpoint that generates and stores these values. A typical
    implementation will have a frontend UI where the user clicks a button to generate
    the API key. The value is returned on screen just long enough for them to copy
    it. Once they navigate away, that value is gone and cannot be recovered. In the
    backend, this means that we need an endpoint that uses the `generate_token`, sends
    the API key to the user, and stores the hashed key in the database:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要一个生成并存储这些值的端点。一个典型的实现将有一个前端UI，用户点击按钮生成API密钥。该值在屏幕上显示的时间足够长，以便他们复制。一旦他们离开，该值就会消失，无法恢复。在后端，这意味着我们需要一个端点，该端点使用
    `generate_token`，将API密钥发送给用户，并将散列密钥存储在数据库中：
- en: '[PRE47]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As a reminder, you can look back to *Chapter 4* for strategies on how to extract
    data from the request to get the user, for example. In the above, `get_user_from_request`
    is a stand-in to show that you would be pulling the user information based upon
    the incoming request. Similarly, since we have not looked at how to interact with
    databases yet, `store_hashed_key` is just a stand-in to show that you would need
    to use the user and the hashed key to *somehow* store the value.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为提醒，你可以回顾一下 *第4章* 中关于如何从请求中提取数据以获取用户等策略。在上文中，`get_user_from_request` 是一个占位符，表示你将根据传入的请求提取用户信息。同样，由于我们还没有查看如何与数据库交互，`store_hashed_key`
    只是一个占位符，表示你需要使用用户和散列密钥以某种方式存储值。
- en: 'We will create a new decorator to protect endpoints with our API key. In this
    decorator, we will extract the user from the request, and compare the hashed key
    to whatever the user has sent:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个新的装饰器来保护我们的API密钥。在这个装饰器中，我们将从请求中提取用户，并将散列密钥与用户发送的内容进行比较：
- en: '[PRE48]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'One thing that is helpful to point out here is that Sanic will extract a token
    from the `Authorization` header for us. It is a very common scheme to send tokens
    in headers as so-called **bearer tokens**. They look like this:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里指出的一点是，Sanic会为我们从 `Authorization` 标头中提取一个令牌。将令牌发送在头部的这种方案被称为所谓的 **bearer
    tokens**。它们看起来像这样：
- en: '[PRE49]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Or:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者：
- en: '[PRE50]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Therefore, to get access to that token valued, all you need to use is `request.token`
    and Sanic will find it from either location.
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，要获取该令牌的访问权限，你只需要使用 `request.token`，Sanic就会从任一位置找到它。
- en: 'Now, to implement this, all we need to do is wrap our endpoints:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，要实现这一点，我们只需要将我们的端点包装起来：
- en: '[PRE51]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Another thing to point out is the inherent security leak in failing to use the
    correct status codes and exception messages when something goes wrong. We mentioned
    this back in *Chapter 6*, and it is worth seeing how to address the concern here.
    You may have noticed that we are allowing our decorator to pass in an Exception
    class and message. This is so that we have control over what information is sent
    to the end-user.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要指出的是，当出现问题时未能使用正确的状态码和异常消息，这会存在固有的安全漏洞。我们之前在 *第6章* 中提到过这一点，并且在这里看到如何解决这个问题是有价值的。你可能已经注意到，我们允许装饰器传递一个异常类和消息。这样做是为了让我们能够控制发送给最终用户的信息。
- en: 'Now that we have seen how easy it is to implement *proper* API keys, the only
    remaining question is: when is it appropriate to use them?'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到实现 *正确* 的API密钥是多么容易，唯一剩下的问题是：何时使用它们是合适的？
- en: '*Never use an API key to secure a browser-based UI*.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '*永远不要使用API密钥来保护基于浏览器的UI*。'
- en: The security afforded by the API key is not sufficient to handle all of the
    issues that the browser raises by virtue of storage of credentials. This is really
    only appropriate for integrations coming from outside scripts or applications.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: API密钥提供的安全性不足以处理浏览器由于存储凭据而引发的所有问题。这实际上只适用于来自外部脚本或应用程序的集成。
- en: 'Because of that reason, I like to use `check_request` middleware we created
    earlier in this Chapter in conjunction with my authorization decorator. Since
    `@api_key_required` should never be valid for a request from the browser, I like
    to change:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，我喜欢使用我们在本章早期创建的 `check_request` 中间件，以及我的授权装饰器。由于 `@api_key_required`
    从来不应该对来自浏览器的请求有效，我喜欢将其改为：
- en: '[PRE52]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'to this:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到这里为止：
- en: '[PRE53]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now that we know how and when to use API keys, let’s look at approaches to handling
    authentication in a scenario that is appropriate for web applications.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何以及何时使用API密钥，让我们看看在适合Web应用的场景中处理身份验证的方法。
- en: Understanding session versus non-session based authentication
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 理解基于会话和非会话的身份验证
- en: User sessions are perhaps the most common approach to handling authentication
    in web applications. A more recent strategy employs tokens known as **JSON Web
    Tokens (JWT)**. In most other contexts, you will hear about these referred to
    as *stateful* versus *stateless*. User sessions are *stateful* and JWTs are *stateless*.
    This is all true, but I like to refer to them as **session based** and **non-session
    based**. Call me a rebel, but I think that this more clearly describes what we
    are trying to achieve.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 用户会话可能是处理Web应用程序中身份验证最常见的方法。一种较新的策略采用被称为**JSON Web Tokens (JWT)**的令牌。在大多数其他情况下，你会听到它们被称作*有状态*与*无状态*。用户会话是有状态的，JWT是无状态的。这些都是真的，但我喜欢将它们称为**基于会话**和**非基于会话**。叫我叛逆者吧，但我觉得这样更清楚地描述了我们试图实现的目标。
- en: First, what is a session? If a user logs into your application, and you record
    that login in your database so that it can be invalidated at will, then you are
    creating a session. This means that so long as that record exists in your database,
    there is an active session that can be authenticated against that particular user.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是会话？如果一个用户登录到你的应用程序，并且你在数据库中记录这次登录以便可以随意使其失效，那么你就是在创建一个会话。这意味着只要这个记录存在于你的数据库中，就有一个活跃的会话可以用来验证该特定用户。
- en: Session-based authentication is very simple to implement on both the frontend
    and the backend. And, because it offers a high degree of security, it is the reason
    that it has become a default approach for many web applications. One of its huge
    benefits is that any active session can be inactivated at any time. Have you ever
    been on a web application (perhaps your email provider) that lists out everywhere
    you are logged in? With a click of a button, you can log out the other locations.
    This is really helpful in case a session is compromised or hacked.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 基于会话的身份验证在前后端都非常简单易实现。而且，因为它提供了高度的安全性，这就是为什么它已经成为许多Web应用程序的默认方法。它的一大好处是任何活跃的会话都可以在任何时候被停用。你有没有在Web应用程序（可能是你的电子邮件提供商）上看到列出你所有登录位置的情况？点击一个按钮，你就可以注销其他位置。这在会话被破坏或被黑客攻击的情况下非常有帮助。
- en: On the other hand, non-session based authentication provides a great deal more
    flexibility. The typical example of a non-session based token is a JWT. So even
    though I am talking specifically about JWTs, they are not the only way to handle
    non-session based authentication. The most critical component that is offered
    by this strategy is that the token itself is self-authentication. That means that
    a server only needs to look at the token to determine if it is genuine, and if
    it has been tampered with.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，非会话基于身份验证提供了更大的灵活性。非会话基于令牌的典型例子是JWT。所以尽管我在具体谈论JWT，但它们并不是处理非会话基于身份验证的唯一方式。这种策略提供最关键组件是令牌本身是自我认证的。这意味着服务器只需要查看令牌就能确定它是否真实，以及是否被篡改。
- en: Because of this, authenticating a JWT becomes highly portable. You can have
    one microservice that handles authentication and generating tokens, and then other
    services can verify them without having to involve the authentication service
    at all! This allows for very scalable architectures. This also highlights another
    benefit. Every time a session token is received, in order to authenticate it you
    *must* make a round-trip to your storage engine. This means every single API call
    includes at least one more network call to the database. This is completely avoided
    with self-authenticating tokens, and can lead to overall performance benefits.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个原因，JWT的身份验证变得高度便携。你可以有一个处理身份验证和生成令牌的微服务，然后其他服务可以验证它们，而无需涉及任何身份验证服务！这允许非常可扩展的架构。这也突出了另一个好处。每次收到会话令牌时，为了验证它，你*必须*对你的存储引擎进行往返调用。这意味着每个API调用至少包含一个额外的网络调用到数据库。通过自我认证的令牌，这可以完全避免，并可能导致整体性能的提升。
- en: JWTs specifically also carry the benefit that they can be embedded with non-secret
    payloads. This often means that you can include a list of permissions, or meta
    information about a user that the frontend application can make use of.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: JWT特别的好处是它们可以嵌入非秘密的有效负载。这通常意味着你可以包含一个权限列表，或者关于用户的前端应用程序可以使用的元信息。
- en: That all sounds great, but the downside to JWTs is that once issued they cannot
    be invalidated. When they are created, they are given an expiration time. The
    token will remain valid until that time expires. This is the reason why these
    expiration times are usually quite short, and usually measured in minutes (not
    hours or days as may be typical of sessions). If a token expires every ten (10)
    minutes, it would be super inconvenient for a web application user to need to
    login again so frequently. Therefore, JWTs are often accompanied by a refresh
    token. This token is a value that allows a user to exchange an expired JWT for
    a fresh new one.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很棒，但 JWT 的缺点是，一旦发行，它们就不能被撤销。当它们被创建时，它们会被赋予一个过期时间。令牌将保持有效，直到那个时间过期。这就是为什么这些过期时间通常非常短，通常以分钟为单位（而不是像会话那样可能是小时或天）。如果一个令牌每十分钟过期一次，那么对于网络应用程序用户来说，需要频繁地重新登录将非常不方便。因此，JWT
    通常伴随着刷新令牌。这个令牌是一个值，允许用户用新的 JWT 交换过期的 JWT。
- en: Furthermore, session-based tokens are generally easier to protect from XSS attacks
    using the `HttpOnly` cookies as we saw earlier. Since JWTs are usually sent as
    a bearer token like API keys, implementing them also means revisiting how we are
    going to protect them inside the browser. If your head is starting to spin thinking
    about all of the concerns that exist with trying to implement JWTs as both a secure
    and user-friendly approach, then you are not alone. Adding JWTs to an application
    is certainly much more involved than sessions. Therefore, you must think about
    your specific application needs when deciding which strategy to use.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，基于会话的令牌通常更容易通过使用我们之前看到的 `HttpOnly` cookies 来保护免受 XSS 攻击。由于 JWT 通常像 API 密钥一样作为携带令牌发送，实现它们也意味着我们需要重新考虑如何在浏览器内部保护它们。如果你在思考所有试图以既安全又用户友好的方式实现
    JWT 的担忧，那么你并不孤单。将 JWT 添加到应用程序中肯定比会话更复杂。因此，在决定使用哪种策略时，你必须考虑你特定的应用程序需求。
- en: “*Hold up!*” You might be saying to yourself. “*If JWTs have so many benefits,
    why not just treat them like session tokens and store them as cookies? Also, we
    can get around invalidating tokens by comparing them against a black list! Then,
    we can make them longer and just add them to the blacklist when we want to logout
    or invalidate them. Both problems solved.*”
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: “*等等！*” 你可能正在对自己说，“*如果 JWT 有这么多好处，为什么不把它们当作会话令牌来处理，并将它们存储为 cookies？此外，我们可以通过将它们与黑名单进行比较来绕过令牌的失效！然后，我们可以使它们更长，并在想要登出或使它们失效时将它们添加到黑名单中。两个问题都解决了。””
- en: Yes, that is true. Let’s look at both of those proposals in turn.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，这是真的。让我们依次查看这两个建议。
- en: 'First, storing JWTs as a cookie like a session token does work. But, you now
    lose out on one of its big benefits: the authenticated payload. Remember that
    one of its benefits is that they can carry meta details that your frontend application
    could use. If they are stuck inside of an `HttpOnly` cookie, then that information
    is not available. (We will look at a way to address this when we look at JWT implementations).'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 JWT 存储为类似于会话令牌的 cookie 是可行的。但是，你现在失去了一个很大的好处：认证的有效载荷。记住，其中一个好处是它们可以携带元数据，这些数据可以被你的前端应用程序使用。如果它们被困在
    `HttpOnly` cookie 中，那么这些信息将不可用。（当我们查看 JWT 实现时，我们将探讨解决这个问题的一种方法）。
- en: Second, if you are maintaining a blacklist of tokens to allow a token to be
    *revoked* or *invalidated*, then you no longer are using non-session based authentication.
    Instead, you are using JWTs in a session based scheme. This is acceptable and
    people do it. However, it makes your tokens less portable since they require a
    centralized store to be validated, and also include additional network calls.
    Implement at your own risk.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，如果你在维护一个令牌黑名单以允许撤销或使令牌失效，那么你不再使用基于非会话的认证。相反，你正在使用基于 JWT 的会话方案。这是可以接受的，人们确实这么做。然而，这使得你的令牌更不便携，因为它们需要一个集中的存储库来验证，并且还需要额外的网络调用。自行承担风险。
- en: We now turn to implementation strategies within Sanic. Because we have not looked
    at database implementation, we will still use some stand-in functions for getting
    and storing information when needed. Try to look over those details for now since
    we are focusing more upon how to handle authentication not persisting data. If
    you look on the GitHub repository at these examples, there will be some dummy
    versions of these functions just to make the examples operational. Try not to
    get hung up on those details right now.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向Sanic中的实现策略。因为我们还没有查看数据库实现，所以当需要获取和存储信息时，我们仍然会使用一些替代函数。现在先尝试了解这些细节，因为我们更关注如何处理不持久化数据的身份验证。如果你查看GitHub仓库中的这些示例，将会有一些这些函数的模拟版本，以便使示例能够运行。现在尽量不要纠结于这些细节。
- en: Using sessions
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用会话
- en: You have decided after reading the *Session v. non-session based authentication*
    section that stateful sessions are the right options for your application. Super,
    you really already know just about everything you need.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了*基于会话的身份验证与非基于会话的身份验证*这一节之后，你已经决定状态会话是你的应用程序的正确选择。太好了，你实际上已经知道了你需要的几乎所有东西。
- en: We have already seen how to handle passwords (the same as API keys). Therefore,
    implementing a login route should be simple.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何处理密码（与API密钥相同）。因此，实现登录路由应该是简单的。
- en: We already know that the session token needs to *not* be accessible from Javascript
    to combat XSS. Therefore, we will use `HttpOnly` cookies.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道会话令牌需要*不*从JavaScript中访问，以对抗XSS攻击。因此，我们将使用`HttpOnly`cookie。
- en: We also know that using an `HttpOnly` cookie by itself leaves an application
    vulnerable to CSRF attacks. Therefore, we will couple our implementation with
    the CSRF protection scheme we came up with earlier.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也知道，仅使用`HttpOnly`cookie会使应用程序容易受到CSRF攻击。因此，我们将我们的实现与之前提出的CSRF保护方案相结合。
- en: 'What’s left? Not much. We need endpoints for:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下什么？不多。我们需要为以下内容创建端点：
- en: registering a use (which will be responsible for storing the password securely);
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注册用户（负责安全地存储密码）；
- en: logging in (which takes a username and password and verifies it, just like in
    the API key example, creates a session key, stores it, and sets it as a cookie);
    and
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 登录（接受用户名和密码并验证它，就像在API密钥示例中一样，创建会话密钥，存储它，并将其设置为cookie）；以及
- en: logging out (which deletes the session from the database).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 登出（从数据库中删除会话）。
- en: This is a great opportunity for you to take these requirements and try and build
    your own solution. Put the book down and build these three endpoints. If you get
    stuck, there is an example solution in the GitHub repository.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的机会，让你尝试根据这些要求构建自己的解决方案。放下这本书，构建这三个端点。如果你卡住了，GitHub仓库中有一个示例解决方案。
- en: In order to protect your endpoints, we will have a similar approach with a decorator.
    Do you remember the `@csrf_protected` decorator we built earlier? If you are using
    session-based authentication, then I suggest combining that decorator with the
    one we are building here. They compliment each other nicely and then it makes
    it easier for you to properly protect your endpoints.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护您的端点，我们将采用与装饰器类似的方法。你还记得我们之前构建的`@csrf_protected`装饰器吗？如果你正在使用基于会话的身份验证，那么我建议将这个装饰器与我们正在构建的装饰器结合起来。它们很好地互补，这样就可以更容易地正确保护您的端点。
- en: 'Here is how we will rebuild it. We are adding a similar block to our decorator
    like the API key decorator that will raise an exception if session verification
    fails:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这里是我们将如何重建它的方法。我们正在添加一个类似于API密钥装饰器的块，如果会话验证失败，它将引发异常：
- en: '[PRE54]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The verification of the session does depend upon your database implementation.
    But, in general, it should look something like this:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会话验证确实取决于你的数据库实现。但，一般来说，它应该看起来像这样：
- en: '[PRE55]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: If the session token exists, then we can proceed. If it does not, then return
    False.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果会话令牌存在，那么我们可以继续。如果不存在，则返回False。
- en: As you can see, sessions tend to be easy to implement once you have the basic
    functionality for storing and retrieving data from a database. We now turn to
    the more complicated alternative.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，一旦你有了从数据库存储和检索数据的基本功能，会话通常很容易实现。我们现在转向更复杂的替代方案。
- en: JWT (JSON Web Token)
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JWT (JSON Web Token)
- en: 'So, you have read the section on *Session v. non-session based authentication*
    and decided to implement JWTs. Now what? The problem that we need to solve is
    that to use them to their full capacity within a frontend application poses two
    problems:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经阅读了关于*基于会话和非会话认证*的部分，并决定实施JWT。现在怎么办？我们需要解决的问题是，在前端应用程序中充分利用它们会带来两个问题：
- en: How to store and send them to not compromise on functionality or security?
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何存储和发送它们，既不牺牲功能也不牺牲安全性？
- en: How to maintain a reasonable user experience without sacrificing security?
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在不牺牲安全性的情况下保持合理的用户体验？
- en: We will address these questions in turn, and then develop a solution that gives
    us satisfaction on both.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次解决这些问题，然后开发一个既能让我们满意的解决方案。
- en: To cookie, or not to cookie?
  id: totrans-345
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 要cookie，还是不要cookie？
- en: 'There are two competing interests when deciding how to send the access token
    (please note that from here on out access token is synonymous with JWT): usability
    and security. If we send the token via the headers, it would look like this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定如何发送访问令牌（请注意，从现在开始，访问令牌与JWT同义）时，有两个相互竞争的利益：可用性和安全性。如果我们通过头部发送令牌，它看起来会是这样：
- en: '[PRE56]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To accomplish this, we need some client-side Javascript to read the value and
    inject it into our request:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们需要一些客户端JavaScript来读取值并将其注入到我们的请求中：
- en: '[PRE57]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'You should (by now) already be suspecting the problem with this: XSS vulnerability!
    If our frontend application can access the token from Javascript, then that means
    that any bad script can as well. Bummer.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可能已经怀疑了这个问题：XSS漏洞！如果我们的前端应用程序可以从JavaScript中访问令牌，那么这意味着任何恶意脚本也可以。真糟糕。
- en: '**IMPORTANT NOTE**'
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**重要提示**'
- en: ''
  id: totrans-352
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: You may be thinking to yourself, why is the JWT being stored client-side in
    a cookie and not in web storage (either localStorage or sessionStorage)? The reason
    is that both of those solutions are great for handling non-sensitive details.
    They are subject to the XSS attacks we are trying to prevent. You may see a lot
    of advice online suggesting that you use these for JWTs. *Don’t do it!* The solution
    that is offered here will be much more secure and still not sacrifice on usability.
    All it takes is a little extra work server-side, so please be patient and do not
    rush off to this sub-standard alternative.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 你可能自己在想，为什么JWT被存储在客户端的cookie中，而不是在web存储（无论是localStorage还是sessionStorage）中？原因在于，这两个解决方案都非常适合处理非敏感细节。它们容易受到我们试图防止的XSS攻击。你可能在网上看到很多建议说你可以用这些来存储JWT。*不要这么做!*
    这里提供的解决方案将更加安全，并且仍然不会牺牲可用性。这只需要在服务器端做一点额外的工作，所以请耐心等待，不要匆忙选择这个次标准的替代方案。
- en: To fix the problem we use `HttpOnly` and let our application just send the cookie
    back by itself. In this situation we will rely on the server to write and read
    the cookie as needed. But, in doing this, we cannot access the JWT payload. There
    also is the problem of CSRF that we have seen a few times already, but by now
    you should already understand how to solve that problem. If not, please go back
    to read the section *Protecting applications from CSRF* in this Chapter.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们使用`HttpOnly`，并让我们的应用程序自己发送cookie。在这种情况下，我们将依赖服务器根据需要写入和读取cookie。但是，在这样做的时候，我们无法访问JWT的有效载荷。还有我们之前已经看到几次的CSRF问题，但现在你应该已经理解如何解决这个问题。如果不理解，请回到本章阅读*保护应用程序免受CSRF攻击*的部分。
- en: 'One option might be to return the payload of the access token when you first
    login. These details you could store in web storage safely and use them whenever
    you want. That might look something like this on the server:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是在你首次登录时返回访问令牌的有效载荷。这些细节可以安全地存储在web存储中，并在需要时使用。在服务器上，这可能看起来像这样：
- en: '[PRE58]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: I support this approach, and it certainly will work. You gain access to the
    payload, and you have a secure way to transport and store the access token.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 我支持这种方法，并且它肯定能行。你可以访问有效载荷，并且有安全的方式来传输和存储访问令牌。
- en: A second option would be to use split cookies. More on that in just a bit. Feel
    free to skip ahead, or go back and reference that EuroPython talk I mentioned
    at the beginning of the Chapter where I discussed this approach.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择是使用分割的cookie。关于这一点，稍后我会详细说明。您可以随意跳过，或者回到本章开头我提到的那个EuroPython演讲，我在那里讨论了这种方法。
- en: “Your session expired after 10 minutes, please login again?”
  id: totrans-359
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: “您的会话在10分钟后已过期，请重新登录？”
- en: Have you ever been on a website that does this? Usually, it is banking or financial
    applications because they are concerned about a user standing up from their computer
    and walking away to leave a logged in session. Maybe this is your need, so great!
    You can rest comfortably with JWTs as a solution and expire your tokens often
    with no concern.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾访问过这样做的一个网站？通常，这是银行或金融应用程序，因为它们担心用户从电脑上站起来离开，留下登录会话。也许这正是你的需求，太好了！你可以安心地使用
    JWT 作为解决方案，并且无需担心频繁地使令牌过期。
- en: For most applications, however, this would lead to a terrible user experience.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于大多数应用程序来说，这会导致糟糕的用户体验。
- en: Remember, the reason we are expiring our access tokens at such a short interval
    is to reduce the potential attack surface. If a token were to fall into the wrong
    hands, it can only be used for a very small window. The shorter the expiration,
    the more secure the token.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们之所以在如此短的时间内使访问令牌过期，是为了减少潜在的攻击面。如果令牌落入错误的手中，它只能在一个非常小的窗口中使用。过期时间越短，令牌就越安全。
- en: 'The solution to the problem requires a little bit of frontend complexity. But,
    I think it is worth the protection it affords. There are actually two solutions
    that you can choose from:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的解决方案需要一点前端复杂性。但，我认为它提供的保护是值得的。实际上有两种解决方案你可以选择：
- en: Use Javascript’s `setInterval` to periodically send a request to refresh the
    token in the background unknown to the user
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JavaScript 的 `setInterval` 在用户不知情的情况下定期发送请求以刷新令牌
- en: Wrap your Javascript fetch call with a proper exception handler. It catches
    the scenario where an expired token was submitted, sends a request to refresh
    the token, and then retries the original request with the new token
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 JavaScript fetch 调用包裹在一个合适的异常处理器中。它捕获了提交了过期令牌的场景，发送请求来刷新令牌，然后使用新的令牌重试原始请求
- en: Feel free to choose the approach that works for you. The GitHub repository has
    some sample Javascript for implementing each strategy.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 随意选择对你来说有效的方法。GitHub 仓库有一些实现每种策略的示例 JavaScript 代码。
- en: To implement a refresh token, we will borrow some of the concepts we used earlier
    for making the API token. When a user performs a login, we will continue to generate
    the access token, but we will also generate and store a refresh token by reusing
    the API token logic.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现刷新令牌，我们将借用我们之前用于制作 API 令牌的一些概念。当用户执行登录时，我们将继续生成访问令牌，但我们将通过重用 API 令牌逻辑生成和存储刷新令牌。
- en: 'Create a login endpoint that also generates and stores a refresh token:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个同时生成和存储刷新令牌的登录端点：
- en: '[PRE59]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Go back to the *Using API Keys* section to see the `generate_token` function.
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 返回到 *使用 API 密钥* 部分，查看 `generate_token` 函数。
- en: 'To issue a new access token, we need to create a new endpoint that will validate
    the refresh token (like we did the API token). As an added level of security (since
    a single point of authentication from the browser is not a good idea), we also
    will require a previously issued access token even if it is already expired:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发行新的访问令牌，我们需要创建一个新的端点来验证刷新令牌（就像我们验证 API 令牌一样）。作为额外的安全级别（因为从浏览器来的单一认证点不是一个好主意），即使它已经过期，我们也将要求提供一个之前发行的访问令牌：
- en: '[PRE60]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have not seen how to validate JWT yet, so do not worry that you are not sure
    how to implement `check_access_token`. We will do that next.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有看到如何验证 JWT，所以不要担心你不确定如何实现 `check_access_token`。我们将在下一步做那件事。
- en: Solving for JWTs in browser-based applications
  id: totrans-374
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 解决基于浏览器的应用程序中的 JWT
- en: 'By now we generally have an understanding of what we want to achieve. What
    we need to look at now is:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，我们一般已经理解了我们想要实现的目标。我们现在需要关注的是：
- en: How to generate the access token
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何生成访问令牌
- en: How to verify the access token (both with and without expiration)
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何验证访问令牌（无论是带过期还是不带过期）
- en: How to “split” the token to make it usable and secure
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何“分割”令牌使其可用且安全
- en: To generate the token, we will use `pyjwt`. The first thing we will need to
    do is create an application with secret. Just like before, I will hardcode it
    in my example, but you will get the value from an environment variable or other
    secure method.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成令牌，我们将使用 `pyjwt`。我们首先需要做的是创建一个带有密钥的应用程序。就像之前一样，我将在示例中硬编码它，但你会从环境变量或其他安全方法中获取值。
- en: 'Set the secret and some other configuration values that we will need:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置密钥和一些其他我们需要配置的值：
- en: '[PRE61]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Create a model that will hold our JWT details:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将保存我们的 JWT 细节的模型：
- en: '[PRE62]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Generate the token with some payload. In JWT-speak, a payload is essentially
    just a dictionary of values. It can contain a “claim” which is a special key-value
    pair that can be used in authenticating a token. If you get into JWT, I suggest
    you dig deeper into some of the standard claims. In our example, the only one
    we are using is the expiration claim: `exp`. Other than that, feel free to add
    whatever you want to the payload:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些负载生成令牌。在JWT的术语中，负载本质上只是一个值的字典。它可以包含一个“声明”，这是一个特殊的键值对，可以用于验证令牌。如果你开始使用JWT，我建议你深入研究一些标准的声明。在我们的例子中，我们只使用了一个，那就是过期声明：`exp`。除此之外，你可以随意将任何你想要的内容添加到负载中：
- en: '[PRE63]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Once you have generated the `AccessToken` object, it will be super easy to
    split it up into two cookies. One of them will be Javascript accessible, and one
    of them will be `HttpOnly`. We also want the refresh token to be `HttpOnly`. Your
    login handler would have something like this:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你生成了`AccessToken`对象，将其拆分为两个cookie将变得非常简单。其中一个将是JavaScript可访问的，另一个将是`HttpOnly`。我们还想让刷新令牌也是`HttpOnly`。你的登录处理程序可能如下所示：
- en: '[PRE64]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'We then set all of our cookies with a convenience function. Pay careful attention
    to the how these cookies are set with respect to `httponly` and `samesite`:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们随后使用便利函数设置所有cookie。请仔细注意这些cookie是如何设置与`httponly`和`samesite`相关的：
- en: '[PRE65]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: We now have all the building blocks needed to build out our endpoints and our
    decorator. It is time for you to put your skills to the test and try and piece
    together the endpoints from the knowledge in this chapter. Don’t worry, there
    is a full solution in the GitHub repository, including the `set_cookie` convenience
    function used above.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了构建端点和装饰器所需的所有构建块。现在是时候检验你的技能，并尝试从本章的知识中拼凑出端点。不用担心，GitHub仓库中有一个完整的解决方案，包括上面使用的`set_cookie`便利函数。
- en: 'A bit of self-promotion here: one of the first libraries I built for Sanic
    was a package to handle authentication and authorization for Sanic using JWTs.
    It allows for handling this split token approach and includes all other sorts
    of goodies and protections. If you do not want to roll your own solution, it has
    become widely adopted within the community. Check out my personal GitHub page
    for more details: [https://github.com/ahopkins/sanic-jwt](https://github.com/ahopkins/sanic-jwt).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一点自我推销：我为Sanic构建的第一个库之一是一个用于处理JWT的认证和授权的包。它允许处理这种拆分令牌的方法，并包括所有其他各种好东西和保护。如果你不想自己构建解决方案，它已经在社区中得到了广泛采用。查看我的个人GitHub页面以获取更多详细信息：[https://github.com/ahopkins/sanic-jwt](https://github.com/ahopkins/sanic-jwt)。
- en: Summary
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This Chapter has covered a *lot* of material. Even still, it has only scratched
    the surface of Web security. To truly raise the security bar, you should continue
    to do some of your own research. There are some other common headers like: `Content-Security-Policy`,
    `X-Content-Type-Options`, and `X-Frame-Options` that we did not have a chance
    to cover. Nonetheless, with the information you have gathered here, and with your
    own self-ingenuity, you should be able to implement—for example—a `Content-Security-Policy`
    that works for your application. The first place I look for this kind of material
    is Mozilla’s MDN website: [https://developer.mozilla.org/en-US/.](https://developer.mozilla.org/en-US/.)
    I highly recommend you visit it to learn about web standards and practices.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了大量的内容。即便如此，它也只是触及了Web安全的表面。要真正提高安全标准，你应该继续做一些自己的研究。还有一些其他常见的头部信息，比如：`Content-Security-Policy`、`X-Content-Type-Options`和`X-Frame-Options`，我们没有机会涉及。尽管如此，凭借你在这里收集的信息和你的独创性，你应该能够实现——例如——适用于你应用的`Content-Security-Policy`。我寻找这类材料的第一地方是Mozilla的MDN网站：[https://developer.mozilla.org/en-US/](https://developer.mozilla.org/en-US/)。我强烈建议你访问它，了解Web标准和实践。
- en: So, what did we cover?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们涵盖了哪些内容？
- en: 'You should be familiar with the concept of same-origin, and how to develop
    a CORS policy to defeat both CSRF and XSS attacks. We also looked at three common
    schemes for authenticating users: API keys, session tokens, and JWT. And, of course,
    by looking through all of the examples you should be learning how to use the Sanic
    tool belt to craft your own unique and *obvious* patterns to serve your applications’
    needs. At this point in the book, we really have covered most of what you will
    need in order to build a web application. You should be familiar with all of the
    basic building blocks, and start to have some ideas on how to piece them together
    to build solutions.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该熟悉同源概念，以及如何开发CORS策略来抵御CSRF和XSS攻击。我们还探讨了三种常见的用户认证方案：API密钥、会话令牌和JWT。当然，通过查看所有示例，你应该正在学习如何使用Sanic工具集来定制你自己的独特且*明显*的模式以满足应用程序的需求。在本书的这一部分，我们实际上已经涵盖了构建Web应用程序所需的大部分内容。你应该熟悉所有基本构建块，并开始有一些想法，了解如何将它们组合起来构建解决方案。
- en: What we are missing now is knowledge on how to deploy our applications and run
    them. This is what we will cover next.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在所缺少的是关于如何部署我们的应用程序和运行它们的知识。这正是我们将要探讨的内容。
