- en: Using Generators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器
- en: Generators are another of those features that makes Python a peculiar language
    over more traditional ones. In this chapter, we will explore their rationale,
    why they were introduced in the language, and the problems they solve. We will
    also cover how to address problems idiomatically by using generators, and how
    to make our generators (or any iterable, for that matter) Pythonic.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是Python作为一种特殊语言的另一个特性。在本章中，我们将探讨它们的基本原理，它们为什么被引入到语言中以及它们解决的问题。我们还将介绍如何通过使用生成器来惯用地解决问题，以及如何使我们的生成器（或任何可迭代对象）符合Python的风格。
- en: We will understand why iteration (in the form of the iterator pattern) is automatically
    supported in the language. From there, we will take another journey and explore
    how generators became such a fundamental feature of Python in order to support
    other functionality, such as coroutines and asynchronous programming.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解为什么迭代（以迭代器模式的形式）在语言中得到了自动支持。从那里，我们将再次探索生成器如何成为Python的一个基本特性，以支持其他功能，如协程和异步编程。
- en: 'The goals for this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标如下：
- en: To create generators that improve the performance of our programs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建提高程序性能的生成器
- en: To study how iterators (and the iterator pattern, in particular) are deeply
    embedded in Python
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究迭代器（特别是迭代器模式）如何深度嵌入Python
- en: To solve problems that involve iteration idiomatically
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决涉及迭代的问题
- en: To understand how generators work as the basis for coroutines and asynchronous
    programming
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解生成器作为协程和异步编程的基础是如何工作的
- en: To explore the syntactic support for coroutines—`yield from`, `await`, and `async
    def`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索协程的语法支持——`yield from`、`await`和`async def`
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The examples in this chapter will work with any version of Python 3.6 on any
    platform.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将适用于任何平台上的Python 3.6的任何版本。
- en: The code used in this chapter can be found at [https://github.com/PacktPublishing/Clean-Code-in-Python.](https://github.com/PacktPublishing/Clean-Code-in-Python)
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码可以在[https://github.com/PacktPublishing/Clean-Code-in-Python](https://github.com/PacktPublishing/Clean-Code-in-Python)找到
- en: The instructions are available in the `README` file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 说明可在`README`文件中找到。
- en: Creating generators
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建生成器
- en: Generators were introduced in Python a long time ago (PEP-255), with the idea
    of introducing iteration in Python while improving the performance of the program
    (by using less memory) at the same time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在很久以前就被引入Python中（PEP-255），其目的是在Python中引入迭代的同时提高程序的性能（通过使用更少的内存）。
- en: The idea of a generator is to create an object that is iterable, and, while
    it's being iterated, will produce the elements it contains, one at a time. The
    main use of generators is to save memory—instead of having a very large list of
    elements in memory, holding everything at once, we have an object that knows how
    to produce each particular element, one at a time, as they are required.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器的想法是创建一个可迭代的对象，当被迭代时，它将逐个产生它包含的元素。生成器的主要用途是节省内存——而不是在内存中拥有一个非常大的元素列表，一次性保存所有元素，我们有一个知道如何逐个产生每个特定元素的对象，只要它们被需要。
- en: This feature enables lazy computations or heavyweight objects in memory, in
    a similar manner to what other functional programming languages (Haskell, for
    instance) provide. It would even be possible to work with infinite sequences because
    the lazy nature of generators allows for such an option.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性使得惰性计算或内存中的重量级对象成为可能，类似于其他函数式编程语言（例如Haskell）提供的方式。甚至可以处理无限序列，因为生成器的惰性特性允许这样的选项。
- en: A first look at generators
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 首先看一下生成器
- en: Let's start with an example. The problem at hand now is that we want to process
    a large list of records and get some metrics and indicators over them. Given a
    large data set with information about purchases, we want to process it in order
    to get the lowest sale, highest sale, and the average price of a sale.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个例子开始。现在手头的问题是，我们想处理一个大量的记录列表，并对它们进行一些指标和度量。给定一个包含有关购买信息的大型数据集，我们希望处理它以获得最低销售额、最高销售额和销售额的平均价格。
- en: 'For the simplicity of this example, we will assume a CSV with only two fields,
    in the following format:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这个例子，我们将假设一个只有两个字段的CSV，格式如下：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are going to create an object that receives all the purchases, and this will
    give us the necessary metrics. We could get some of these values out of the box
    by simply using the `min()` and `max()` built-in functions, but that would require
    iterating all of the purchases more than once, so instead, we are using our custom
    object, which will get these values in a single iteration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个接收所有购买的对象，并且这将为我们提供必要的指标。我们可以通过简单地使用`min()`和`max()`内置函数来获得其中一些值，但这将需要多次迭代所有的购买，因此我们使用我们的自定义对象，它将在单次迭代中获取这些值。
- en: 'The code that will get the numbers for us looks rather simple. It''s just an
    object with a method that will process all prices in one go, and, at each step,
    will update the value of each particular metric we are interested in. First, we
    will show the first implementation in the following listing, and, later on in
    this chapter (once we have seen more about iteration), we will revisit this implementation
    and get a much better (and compact) version of it. For now, we are settling on
    the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将为我们获取数字的代码看起来相当简单。它只是一个具有一种方法的对象，该方法将一次性处理所有价格，并且在每一步中，将更新我们感兴趣的每个特定指标的值。首先，我们将在以下清单中显示第一个实现，然后在本章的后面（一旦我们更多地了解迭代），我们将重新访问这个实现，并获得一个更好（更紧凑）的版本。现在，我们暂时采用以下方式：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This object will receive all the totals for the `purchases` and process the
    required values. Now, we need a function that loads these numbers into something
    that this object can process. Here is the first version:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象将接收`purchases`的所有总数并处理所需的值。现在，我们需要一个函数，将这些数字加载到这个对象可以处理的东西中。以下是第一个版本：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This code works; it loads all the numbers of the file into a list that, when
    passed to our custom object, will produce the numbers we want. It has a performance
    issue, though. If you run it with a rather large dataset, it will take a while
    to complete, and it might even fail if the dataset is large enough as to not fit
    into the main memory.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以工作；它将文件中的所有数字加载到一个列表中，当传递给我们的自定义对象时，将产生我们想要的数字。但它有一个性能问题。如果你用一个相当大的数据集运行它，它将需要一段时间才能完成，如果数据集足够大以至于无法放入主内存中，甚至可能会失败。
- en: If we take a look at our code that consumes this data, it is processing the
    `purchases`, one at a time, so we might be wondering why our producer fits everything
    in memory at once. It is creating a list where it puts all of the content of the
    file, but we know we can do better.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下消耗这些数据的代码，它是逐个处理`purchases`的，所以我们可能会想知道为什么我们的生产者一次性将所有内容都放入内存。它创建了一个列表，将文件的所有内容都放入其中，但我们知道我们可以做得更好。
- en: 'The solution is to create a generator. Instead of loading the entire content
    of the file in a list, we will produce the results one at a time. The code will
    now look like this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建一个生成器。我们不再将文件的整个内容加载到列表中，而是逐个产生结果。现在的代码看起来是这样的：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you measure the process this time, you will notice that the usage of memory
    has dropped significantly. We can also see how the code looks simpler—there is
    no need to define the list (therefore, there is no need to append to it), and
    that the `return` statement also disappeared.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你这次测量这个过程，你会注意到内存的使用显著减少了。我们还可以看到代码看起来更简单——不需要定义列表（因此也不需要向其添加元素），`return`语句也消失了。
- en: In this case, the `load_purchases` function is a generator function, or simply
    a generator.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`load_purchases`函数是一个生成器函数，或者简单地说是一个生成器。
- en: 'In Python, the mere presence of the keyword `yield` in any function makes it
    a generator, and, as a result, when calling it, nothing other than creating an
    instance of the generator will happen:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，任何函数中存在`yield`关键字都会使其成为一个生成器，因此，当调用它时，除了创建一个生成器实例之外，什么都不会发生：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A generator object is an iterable (we will revisit iterables in more detail
    later on), which means that it can work with `for` loops. Notice how we did not
    have to change anything on the consumer code—our statistics processor remained
    the same, with the `for` loop unmodified, after the new implementation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器对象是可迭代的（我们稍后会更详细地讨论可迭代对象），这意味着它可以与`for`循环一起工作。请注意，我们在消费者代码上没有改变任何东西——我们的统计处理器保持不变，在新实现后`for`循环也没有修改。
- en: Working with iterables allows us to create these kinds of powerful abstractions
    that are polymorphic with respect to `for` loops. As long as we keep the iterable
    interface, we can iterate over that object transparently.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可迭代对象使我们能够创建这些强大的抽象，这些抽象对`for`循环是多态的。只要我们保持可迭代接口，我们就可以透明地迭代该对象。
- en: Generator expressions
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器表达式
- en: Generators save a lot of memory, and since they are iterators, they are a convenient
    alternative to other iterables or containers that require more space in memory such
    as lists, tuples, or sets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器节省了大量内存，而且由于它们是迭代器，它们是其他需要更多内存空间的可迭代对象或容器的方便替代品，比如列表、元组或集合。
- en: Much like these data structures, they can also be defined by comprehension,
    only that it is called a generator expression (there is an ongoing argument about
    whether they should be called generator comprehensions. In this book, we will
    just refer to them by their canonical name, but feel free to use whichever you
    prefer).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像这些数据结构一样，它们也可以通过推导来定义，只是它被称为生成器表达式（关于它们是否应该被称为生成器推导有一个持续的争论。在本书中，我们将只用它们的规范名称来提及它们，但请随意使用你更喜欢的名称）。
- en: 'In the same way, we would define a list comprehension. If we replace the square
    brackets with parenthesis, we get a generator that results from the expression.
    Generator expressions can also be passed directly to functions that work with
    iterables, such as `sum()`, and, `max()`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以定义一个列表推导。如果我们用括号替换方括号，我们就得到了一个生成器，它是表达式的结果。生成器表达式也可以直接传递给那些与可迭代对象一起工作的函数，比如`sum()`和`max()`：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Always pass a generator expression, instead of a list comprehension, to functions
    that expect iterables, such as `min()`, `max()`, and `sum()`. This is more efficient
    and pythonic.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 总是传递一个生成器表达式，而不是列表推导，给那些期望可迭代对象的函数，比如`min()`、`max()`和`sum()`。这样更有效率和符合Python的风格。
- en: Iterating idiomatically
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代习语
- en: In this section, we will first explore some idioms that come in handy when we
    have to deal with iteration in Python. These code recipes will help us get a better
    idea of the types of things we can do with generators (especially after we have
    already seen generator expressions), and how to solve typical problems in relation
    to them.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将首先探讨一些在Python中处理迭代时非常有用的习语。这些代码示例将帮助我们更好地了解我们可以用生成器做什么类型的事情（特别是在我们已经看过生成器表达式之后），以及如何解决与它们相关的典型问题。
- en: Once we have seen some idioms, we will move on to exploring iteration in Python
    in more depth, analyzing the methods that make iteration possible, and how iterable
    objects work.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们看过一些习语，我们将继续更深入地探讨Python中的迭代，分析使迭代成为可能的方法，以及可迭代对象的工作原理。
- en: Idioms for iteration
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代的习语
- en: 'We are already familiar with the built-in `enumerate()` function that, given
    an iterable, will return another one on which the element is a tuple, whose first
    element is the enumeration of the second one (corresponding to the element in
    the original iterable):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经熟悉了内置的`enumerate()`函数，它给定一个可迭代对象，将返回另一个可迭代对象，其中元素是一个元组，其第一个元素是第二个元素的枚举（对应于原始可迭代对象中的元素）：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We wish to create a similar object, but in a more low-level fashion; one that
    can simply create an infinite sequence. We want an object that can produce a sequence
    of numbers, from a starting one, without any limits.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望创建一个类似的对象，但以更低级的方式；一个可以简单地创建一个无限序列的对象。我们想要一个对象，可以从一个起始数字开始产生一个数字序列，没有任何限制。
- en: 'An object as simple as the following one can do the trick. Every time we call
    this object, we get the next number of the sequence *ad infinitum*:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的对象就可以解决问题。每次调用这个对象，我们都会得到序列的下一个数字*无穷*：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Based on this interface, we would have to use this object by explicitly invoking
    its `next()` method:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这个接口，我们必须通过显式调用它的`next()`方法来使用这个对象：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'But with this code, we cannot reconstruct the `enumerate()` function as we
    would like to, because its interface does not support being iterated over a regular
    Python `for` loop, which also means that we cannot pass it as a parameter to functions
    that expect something to iterate over. Notice how the following code fails:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，使用这段代码，我们无法像我们想要的那样重建`enumerate()`函数，因为它的接口不支持在常规的Python `for`循环中进行迭代，这也意味着我们无法将其作为参数传递给期望迭代的函数。请注意以下代码的失败：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The problem lies in the fact that `NumberSequence` does not support iteration.
    To fix this, we have to make the object an iterable by implementing the magic
    method `__iter__()`. We have also changed the previous `next()` method, by using
    the magic method `__next__`, which makes the object an iterator:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`NumberSequence`不支持迭代。为了解决这个问题，我们必须通过实现魔术方法`__iter__()`使对象成为可迭代的。我们还改变了之前的`next()`方法，使用了魔术方法`__next__`，这使得对象成为了迭代器：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This has an advantage—not only can we iterate over the element, we also don''t
    even need the `.next()` method any more because having `__next__()` allows us
    to use the `next()` built-in function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这有一个优点——不仅可以迭代元素，而且我们甚至不再需要`.next()`方法，因为有了`__next__()`，我们可以使用`next()`内置函数：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The next() function
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: next()函数
- en: 'The `next()` built-in function will advance the iterable to its next element
    and return it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`next()`内置函数将使可迭代对象前进到它的下一个元素并返回它：'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If the iterator does not have more elements to produce, the `StopIteration`
    exception is raised:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果迭代器没有更多的元素产生，就会引发`StopIteration`异常：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This exception signals that the iteration is over and that there are no more
    elements to consume.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常表示迭代已经结束，没有更多的元素可以消耗了。
- en: 'If we wish to handle this case, besides catching the `StopIteration` exception,
    we could provide this function with a default value in its second parameter. Should
    this be provided, it will be the return value in lieu of throwing `StopIteration`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望处理这种情况，除了捕获`StopIteration`异常，我们可以在第二个参数中为这个函数提供一个默认值。如果提供了这个值，它将成为`StopIteration`抛出时的返回值：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Using a generator
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用生成器
- en: 'The previous code can be simplified significantly by simply using a generator.
    Generator objects are iterators. This way, instead of creating a class, we can
    define a function that `yield` the values as needed:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地使用生成器，可以显著简化上述代码。生成器对象是迭代器。这样，我们可以定义一个函数，根据需要`yield`值，而不是创建一个类：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Remember that from our first definition, the `yield` keyword in the body of
    the function makes it a generator. Because it is a generator, it''s perfectly
    fine to create an infinite loop like this, because, when this generator function
    is called, it will run all the code until the next `yield `statement is reached.
    It will produce its value and suspend there:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，根据我们的第一个定义，函数体中的`yield`关键字使其成为一个生成器。因为它是一个生成器，所以像这样创建一个无限循环是完全可以的，因为当调用这个生成器函数时，它将运行到下一个`yield`语句被执行之前的所有代码。它将产生它的值并在那里暂停：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Itertools
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Itertools
- en: Working with iterables has the advantage that the code blends better with Python
    itself because iteration is a key component of the language. Besides that, we
    can take full advantage of the `itertools` module (ITER-01). Actually, the `sequence()`
    generator we just created is fairly similar to `itertools.count()`. However, there
    is more we can do.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可迭代对象的好处在于，代码与Python本身更好地融合在一起，因为迭代是语言的一个关键组成部分。除此之外，我们还可以充分利用`itertools`模块（ITER-01）。实际上，我们刚刚创建的`sequence()`生成器与`itertools.count()`非常相似。但是，我们还可以做更多的事情。
- en: One of the nicest things about iterators, generators, and itertools, is that
    they are composable objects that can be chained together.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器、生成器和itertools最好的一点是它们是可组合的对象，可以链接在一起。
- en: 'For instance, getting back to our first example that processed `purchases`
    in order to get some metrics, what if we want to do the same, but only for those
    values over a certain threshold? The naive approach of solving this problem would
    be to place the condition while iterating:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，回到我们的第一个例子，处理`purchases`以获得一些指标，如果我们想做同样的事情，但只针对某个阈值以上的值怎么办？解决这个问题的天真方法是在迭代时放置条件：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This is not only non-Pythonic, but it's also rigid (and rigidity is a trait
    that denotes bad code). It doesn't handle changes very well. What if the number
    changes now? Do we pass it by parameter? What if we need more than one? What if
    the condition is different (less than, for instance)? Do we pass a lambda?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅不符合Python的风格，而且也很死板（死板是一个表明糟糕代码的特征）。它不能很好地处理变化。如果数字现在改变了怎么办？我们通过参数传递吗？如果我们需要多个怎么办？如果条件不同（比如小于），我们传递一个lambda吗？
- en: These questions should not be answered by this object, whose sole responsibility
    is to compute a set of well-defined metrics over a stream of purchases represented
    as numbers. And, of course, the answer is no. It would be a huge mistake to make
    such a change (once again, clean code is flexible, and we don't want to make it
    rigid by coupling this object to external factors). These requirements will have
    to be addressed elsewhere.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题不应该由这个对象来回答，它的唯一责任是计算一组以数字表示的购买流的明确定义的指标。当然，答案是否定的。将这样的改变是一个巨大的错误（再次强调，清晰的代码是灵活的，我们不希望通过将这个对象与外部因素耦合来使其变得死板）。这些要求必须在其他地方解决。
- en: It's better to keep this object independent of its clients. The less responsibility
    this class has, the more useful it will be for more clients, hence enhancing its
    chances of being reused.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最好让这个对象独立于它的客户端。这个类的责任越少，对更多客户端来说就越有用，从而增加它被重用的机会。
- en: Instead of changing this code, we're going to keep it as it is and assume that
    the new data is filtered according to whatever requirements each customer of the
    class has.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会改变这段代码，而是保持原样，并假设新数据根据该类的每个客户的要求进行了过滤。
- en: 'For instance, if we wanted to process only the first `10` `purchases` that
    amount to more than `1,000`, we would do the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们只想处理前10个购买金额超过1,000的购买，我们将执行以下操作：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is no memory penalization for filtering this way because since they all
    are generators, the evaluation is always lazy. This gives us the power of thinking
    as if we had filtered the entire set at once and then passed it to the object,
    but without actually fitting everything in memory.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这种过滤方式不会对内存造成惩罚，因为它们都是生成器，评估总是延迟的。这使我们有能力像一次性过滤整个集合然后将其传递给对象一样思考，但实际上并没有将所有内容都适应到内存中。
- en: Simplifying code through iterators
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过迭代器简化代码
- en: Now, we will briefly discuss some situations that can be improved with the help
    of iterators, and occasionally the `itertools` module. After discussing each case,
    and its proposed optimization, we will close each point with a corollary.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将简要讨论一些可以通过迭代器和偶尔的`itertools`模块帮助改进的情况。在讨论每种情况及其提出的优化后，我们将用一个推论来结束每个观点。
- en: Repeated iterations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重复迭代
- en: 'Now that we have seen more about iterators, and introduced the `itertools` module,
    we can show you how one of the first examples of this chapter (the one for computing
    statistics about some purchases), can be dramatically simplified:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更多地了解了迭代器，并介绍了`itertools`模块，我们可以向您展示本章的第一个示例（用于计算有关某些购买的统计信息）如何被大大简化：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this example, `itertools.tee`will split the original iterable into three
    new ones. We will use each of these for the different kinds of iterations that
    we require, without needing to repeat three different loops over `purchases`*.*
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`itertools.tee`将原始可迭代对象分成三个新的可迭代对象。我们将使用每个对象进行不同类型的迭代，而无需重复三个不同的循环。
- en: The reader can simply verify that if we pass an iterable object as the `purchases`
    parameter, this one is traversed only once (thanks to the `itertools.tee` function
    [see references]), which was our main requirement. It is also possible to verify
    how this version is equivalent to our original implementation. In this case, there
    is no need to manually raise `ValueError` because passing an empty sequence to
    the `min()` function will do the same.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可以简单地验证，如果我们将可迭代对象作为`purchases`参数传递，这个对象只被遍历一次（感谢`itertools.tee`函数[参见参考资料]），这是我们的主要要求。还可以验证这个版本如何等价于我们的原始实现。在这种情况下，不需要手动引发`ValueError`，因为将空序列传递给`min()`函数将产生相同的效果。
- en: If you are thinking about running a loop over the same object more than one
    time, stop and think if `itertools.tee` can be of any help.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在考虑在同一个对象上多次运行循环，请停下来思考一下`itertools.tee`是否有所帮助。
- en: Nested loops
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 嵌套循环
- en: In some situations, we need to iterate over more than one dimension, looking
    for a value, and nested loops come as the first idea. When the value is found,
    we need to stop iterating, but the `break` keyword doesn't work entirely because
    we have to escape from two (or more) `for` loops, not just one.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们需要在多个维度上进行迭代，寻找一个值，嵌套循环是第一个想法。当找到值时，我们需要停止迭代，但`break`关键字并不完全起作用，因为我们需要从两个（或更多）`for`循环中逃离，而不仅仅是一个。
- en: What would be the solution for this? A flag signaling escape? No. Raising an
    exception? No, this would be the same as the flag, but even worse because we know
    that exceptions are not to be used for control flow logic. Moving the code to
    a smaller function and return it? Close, but not quite.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的解决方案是什么？一个信号逃脱的标志？不是。引发异常？不，这与标志相同，但更糟，因为我们知道异常不应该用于控制流逻辑。将代码移到一个更小的函数并返回它？接近，但不完全。
- en: The answer is, whenever possible, flat the iteration to a single `for` loop.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是，尽可能将迭代简化为单个`for`循环。
- en: 'This is the kind of code we would like to avoid:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们想要避免的代码类型：
- en: '[PRE20]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And here is a simplified version of it that does not rely on flags to signal
    termination, and has a simpler, more compact structure of iteration:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个简化版本，它不依赖于标志来表示终止，并且具有更简单、更紧凑的迭代结构：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It's worth mentioning how the auxiliary generator that was created works as
    an abstraction for the iteration that's required. In this case, we just need to
    iterate over two dimensions, but if we needed more, a different object could handle
    this without the client needing to know about it. This is the essence of the iterator
    design pattern, which, in Python, is transparent, since it supports iterator objects
    automatically, which is the topic covered in the next section.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是，创建的辅助生成器如何作为所需迭代的抽象。在这种情况下，我们只需要在两个维度上进行迭代，但如果我们需要更多，不同的对象可以处理这一点，而客户端无需知道。这就是迭代器设计模式的本质，在Python中是透明的，因为它自动支持迭代器对象，这是下一节讨论的主题。
- en: Try to simplify the iteration as much as possible with as many abstractions
    as are required, flatting the loops whenever possible.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量简化迭代，使用尽可能多的抽象，尽可能将循环展平。
- en: The iterator pattern in Python
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python中的迭代器模式
- en: Here, we will take a small detour from generators to understand iteration in
    Python more deeply. Generators are a particular case of iterable objects, but
    iteration in Python goes beyond generators, and being able to create good iterable
    objects will give us the chance to create more efficient, compact, and readable
    code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从生成器中稍微偏离，更深入地了解Python中的迭代。生成器是可迭代对象的特殊情况，但Python中的迭代超越了生成器，能够创建良好的可迭代对象将使我们有机会创建更高效、更紧凑和更可读的代码。
- en: In the previous code listings, we have been seeing examples of iterable objects
    that are also iterators, because they implement both the `__iter__()` and `__next__()`magic
    methods. While this is fine in general, it's not strictly required that they always
    have to implement both methods, and here we'll show the subtle differences between
    an iterable object (one that implements `__iter__`) and an iterator (that implements `__next__`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码清单中，我们一直在看一些可迭代对象的示例，这些对象也是迭代器，因为它们实现了`__iter__()`和`__next__()`魔术方法。虽然这在一般情况下是可以的，但并不严格要求它们总是必须实现这两个方法，这里我们将展示可迭代对象（实现`__iter__`）和迭代器（实现`__next__`）之间的细微差别。
- en: We also explore other topics related to iterations, such as sequences and container
    objects.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了与迭代相关的其他主题，如序列和容器对象。
- en: The interface for iteration
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代的接口
- en: An iterable is an object that supports iteration, which, at a very high level,
    means that we can run a `for .. in ...` loop over it, and it will work without
    any issues. However, iterable does not mean the same as iterator*.*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可迭代对象是支持迭代的对象，从非常高的层次来看，这意味着我们可以在其上运行`for .. in ...`循环，并且不会出现任何问题。然而，可迭代并不意味着与迭代器相同。
- en: Generally speaking, an iterable is just something we can iterate, and it uses
    an iterator to do so. This means that in the `__iter__` magic method, we would
    like to return an iterator, namely, an object with a `__next__()` method implemented.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，可迭代只是我们可以迭代的东西，并且它使用迭代器来实现。这意味着在`__iter__`魔术方法中，我们希望返回一个迭代器，即一个实现了`__next__()`方法的对象。
- en: An iterator is an object that only knows how to produce a series of values,
    one at a time, when it's being called by the already explored built-in `next()`
    function. While the iterator is not called, it's simply frozen, sitting idly by
    until it's called again for the next value to produce. In this sense, generators
    are iterators.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是一个只知道如何产生一系列值的对象，每次被已探索的内置`next()`函数调用时，它都会一次产生一个值。当迭代器没有被调用时，它只是被冻结，静静地坐着，直到再次为下一个值调用它。在这个意义上，生成器是迭代器。
- en: '| **Python concept** | **Magic method** | **Considerations** |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| **Python概念** | **魔术方法** | **注意事项** |'
- en: '| Iterable | `__iter__` | They work with an iterator to construct the iteration
    logic.These objects can be iterated in a `for ... in ...:` loop |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 可迭代对象 | `__iter__` | 它们与迭代器一起工作，构建迭代逻辑。这些对象可以在`for ... in ...:`循环中迭代 |'
- en: '| Iterator | `__next__` | Define the logic for producing values one at the
    time.The `StopIteration` exception signals that the iteration is over.The values
    can be obtained one by one via the built-in `next()` function. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 迭代器 | `__next__` | 定义逐个产生值的逻辑。`StopIteration`异常表示迭代结束。可以通过内置的`next()`函数逐个获取值。
    |'
- en: 'In the following code, we will see an example of an iterator object that is
    not iterable—it only supports invoking its values, one at a time. Here, the name
    `sequence` refers just to a series of consecutive numbers, not to the sequence
    concept in Python, which will we explore later on:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将看到一个迭代器对象的示例，它不是可迭代的——它只支持一次调用其值。在这里，名称`sequence`只是指一系列连续的数字，并不是Python中的序列概念，我们稍后会探讨：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that we can get the values of the sequence one at a time, but we can''t
    iterate over this object (this is fortunate because it would otherwise result
    in an endless loop):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以逐个获取序列的值，但我们无法迭代这个对象（这是幸运的，否则将导致无限循环）：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The error message is clear, as the object doesn't implement `__iter__()`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息很清楚，因为对象没有实现`__iter__()`。
- en: Just for explanatory purposes, we can separate the iteration in another object
    (again, it would be enough to make the object implement both `__iter__` and `__next__`,
    but doing so separately will help clarify the distinctive point we're trying to
    make in this explanation).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 仅仅为了说明的目的，我们可以将迭代分离到另一个对象中（同样，只需使对象分别实现`__iter__`和`__next__`即可，但这样做可以帮助澄清我们在这个解释中试图阐明的不同点）。
- en: Sequence objects as iterables
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列对象作为可迭代对象
- en: As we have just seen, if an object implements the `__iter__()` magic method,
    it means it can be used in a `for` loop. While this is a great feature, it's not
    the only possible form of iteration we can achieve. When we write a `for` loop,
    Python will try to see if the object we're using implements `__iter__`, and, if
    it does, it will use that to construct the iteration, but if it doesn't, there
    are fallback options.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们刚刚看到的，如果一个对象实现了`__iter__()`魔术方法，这意味着它可以在`for`循环中使用。虽然这是一个很好的特性，但我们可以实现的迭代形式并不仅限于此。当我们编写`for`循环时，Python会尝试查看我们使用的对象是否实现了`__iter__`，如果实现了，它将使用它来构建迭代，但如果没有，还有备用选项。
- en: If the object happens to be a sequence (meaning that it implements `__getitem__()`
    and `__len__()` magic methods), it can also be iterated. If that is the case,
    the interpreter will then provide values in sequence, until the `IndexError`exception
    is raised, which,  analogous to the aforementioned `StopIteration`, also signals
    the stop for the iteration.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对象恰好是一个序列（意味着它实现了`__getitem__()`和`__len__()`魔术方法），它也可以被迭代。如果是这种情况，解释器将按顺序提供值，直到引发`IndexError`异常，这与前面提到的`StopIteration`类似，也表示迭代的结束。
- en: 'With the sole purpose of illustrating such a behavior, we run the following
    experiment that shows a sequence object that implements `map()` over a range of
    numbers:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这种行为，我们运行以下实验，展示了一个实现`map()`在一系列数字上的序列对象：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Keep in mind that this example is only designed to illustrate that an object
    such as this one can be iterated with a regular `for` loop. There is a logging
    line placed in the `__getitem__` method to explore what values are passed while
    the object is being iterated, as we can see from the following test:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，这个示例只是为了说明这样一个对象可以用常规的`for`循环进行迭代。在`__getitem__`方法中放置了一个日志行，以探索在迭代对象时传递了哪些值，正如我们从以下测试中所看到的：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As a word of caution, it's important to highlight that while it is useful to
    know this, it's also a fallback mechanism for when the object doesn't implement `__iter__`,
    so most of the time we'll want to resort to these methods by thinking in creating
    proper sequences, and not just objects we want to iterate over.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，重要的是要强调，虽然了解这一点很有用，但它也是对象不实现`__iter__`时的后备机制，因此大多数时候我们会希望通过考虑创建适当的序列来使用这些方法，而不仅仅是我们想要迭代的对象。
- en: When thinking about designing an object for iteration, favor a proper iterable
    object (with `__iter__`), rather than a sequence that can coincidentally also
    be iterated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计用于迭代的对象时，更倾向于一个适当的可迭代对象（带有`__iter__`），而不是一个偶然也可以被迭代的序列。
- en: Coroutines
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: As we already know, generator objects are iterables. They implement `__iter__()`
    and `__next__()`. This is provided by Python automatically so that when we create
    a generator object function, we get an object that can be iterated or advanced
    through the `next()` function.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经知道的，生成器对象是可迭代的。它们实现了`__iter__()`和`__next__()`。这是由Python自动提供的，因此当我们创建一个生成器对象函数时，我们会得到一个可以通过`next()`函数进行迭代或推进的对象。
- en: 'Besides this basic functionality, they have more methods so that they can work
    as coroutines (PEP-342). Here, we will explore how generators evolved into coroutines
    to support the basis of asynchronous programming before we go into more detail
    in the next section, where we explore the new features of Python and the syntax
    that covers programming asynchronously. The basic methods added in (PEP-342) to
    support coroutines are as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这个基本功能，它们还有更多的方法，以便它们可以作为协程（PEP-342）工作。在这里，我们将探讨生成器如何演变成协程，以支持异步编程的基础，然后在下一节中更详细地探讨Python的新特性和涵盖异步编程的语法。用于支持协程的(PEP-342)中添加的基本方法如下：
- en: '`.close()`'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.close()`'
- en: '`.throw(ex_type[, ex_value[, ex_traceback]])`'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.throw(ex_type[, ex_value[, ex_traceback]])`'
- en: '`.send(value)`'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.send(value)`'
- en: The methods of the generator interface
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成器接口的方法
- en: In this section, we will explore what each of the aforementioned methods does,
    how it works, and how it is expected to be used. By understanding how to use these
    methods, we will be able to make use of simple coroutines.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨上述每个方法的作用，工作原理以及预期的使用方式。通过理解如何使用这些方法，我们将能够使用简单的协程。
- en: Later on, we will explore more advanced uses of coroutines, and how to delegate
    to sub-generators (coroutines) in order to refactor code, and how to orchestrate
    different coroutines.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 稍后，我们将探讨协程的更高级用法，以及如何委托给子生成器（协程）以重构代码，以及如何编排不同的协程。
- en: close()
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: close()
- en: When calling this method, the generator will receive the `GeneratorExit` exception.
    If it's not handled, then the generator will finish without producing any more
    values, and its iteration will stop.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个方法时，生成器将接收`GeneratorExit`异常。如果没有处理，那么生成器将在不产生更多值的情况下结束，并且它的迭代将停止。
- en: This exception can be used to handle a finishing status. In general, if our
    coroutine does some sort of resource management, we want to catch this exception
    and use that control block to release all resources being held by the coroutine.
    In general, it is similar to using a context manager or placing the code in the
    `finally` block of an exception control, but handling this exception specifically
    makes it more explicit.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个异常可以用来处理完成状态。一般来说，如果我们的协程进行某种资源管理，我们希望捕获这个异常并使用该控制块来释放协程持有的所有资源。一般来说，这类似于使用上下文管理器或将代码放在异常控制的`finally`块中，但专门处理这个异常使得它更加明确。
- en: 'In the following example, we have a coroutine that makes use of a database
    handler object that holds a connection to a database, and runs queries over it,
    streaming data by pages of a fixed length (instead of reading everything that
    is available at once):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个协程，它利用一个持有数据库连接的数据库处理程序对象，并在其上运行查询，通过固定长度的页面流式传输数据（而不是一次性读取所有可用的数据）：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At each call to the generator, it will return `10` rows obtained from the database
    handler, but when we decide to explicitly finish the iteration and call `close()`,
    we also want to close the connection to the database:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次调用生成器时，它将返回从数据库处理程序获取的`10`行，但当我们决定明确完成迭代并调用`close()`时，我们还希望关闭与数据库的连接：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Use the `close()` method on generators to perform finishing-up tasks when needed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`close()`方法关闭生成器以在需要时执行收尾任务。
- en: throw(ex_type[, ex_value[, ex_traceback]])
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: throw(ex_type[, ex_value[, ex_traceback]])
- en: This method will `throw` the exception at the line where the generator is currently
    suspended. If the generator handles the exception that was sent, the code in that
    particular `except` clause will be called, otherwise, the exception will propagate
    to the caller.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法将在生成器当前暂停的地方`throw`异常。如果生成器处理了发送的异常，那么特定的`except`子句中的代码将被调用，否则，异常将传播到调用者。
- en: 'Here, we are modifying the previous example slightly to show the difference
    when we use this method for an exception that is handled by the coroutine, and
    when it''s not:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们稍微修改了之前的例子，以展示当我们使用这个方法处理协程处理的异常和未处理的异常时的区别：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now, it is a part of the control flow to receive a `CustomException`, and, in
    such a case, the generator will log an informative message (of course, we can
    adapt this according to our business logic on each case), and move on to the next
    `yield` statement, which is the line where the coroutine reads from the database
    and returns that data.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，接收`CustomException`已经成为控制流的一部分，如果出现这种情况，生成器将记录一条信息性消息（当然，我们可以根据每种情况的业务逻辑进行调整），然后继续执行下一个`yield`语句，这是协程从数据库读取并返回数据的地方。
- en: 'This particular example handles all exceptions, but if the last block (`except
    Exception:`) wasn''t there, the result would be that the generator is raised at
    the line where the generator is paused (again, the `yield`*),* and it will propagate
    from there to the caller:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子处理了所有异常，但如果最后一个块（`except Exception:`）不在那里，结果将是生成器在生成器暂停的地方被引发（再次是`yield`*），然后从那里传播到调用者：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When our exception from the domain was received, the generator continued. However,
    when it received another exception that was not expected, the default block caught
    where we closed the connection to the database and finished the iteration, which
    resulted in the generator being stopped. As we can see from the `StopIteration`
    that was raised, this generator can't be iterated further.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们收到来自领域的异常时，生成器继续。然而，当它收到另一个意外的异常时，捕获了默认块，我们关闭了与数据库的连接并完成了迭代，这导致生成器停止。正如我们从引发的`StopIteration`中看到的，这个生成器不能进一步迭代。
- en: send(value)
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: send(value)
- en: In the previous example, we created a simple generator that reads rows from
    a database, and when we wished to finish its iteration, this generator released
    the resources linked to the database. This is a good example of using one of the
    methods that generators provide (close), but there is more we can do.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个简单的生成器，从数据库中读取行，当我们希望完成它的迭代时，这个生成器释放了与数据库相关的资源。这是使用生成器提供的方法之一（close）的一个很好的例子，但我们还可以做更多的事情。
- en: An obvious of such a generator is that it was reading a fixed number of rows
    from the database.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的生成器很明显是从数据库中读取了固定数量的行。
- en: We would like to parametrize that number (`10`) so that we can change it throughout
    different calls. Unfortunately, the `next()` function does not provide us with
    options for that. But luckily, we have `send()`*:*
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望参数化那个数字（`10`），以便我们可以在不同的调用中更改它。不幸的是，`next()`函数不为我们提供这样的选项。但幸运的是，我们有`send()`：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The idea is that we have now made the coroutine able to receive values from
    the caller by means of the `send()` method. This method is the one that actually
    distinguishes a generator from a coroutine because when it's used, it means that
    the `yield` keyword will appear on the right-hand side of the statement, and its
    return value will be assigned to something else.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在的想法是，我们现在已经使协程能够通过`send()`方法从调用者那里接收值。这个方法实际上是区分生成器和协程的方法，因为当它被使用时，意味着`yield`关键字将出现在语句的右侧，并且它的返回值将被分配给其他东西。
- en: 'In coroutines, we generally find the `yield` keyword to be used in the following
    form:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程中，我们通常发现`yield`关键字以以下形式使用：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `yield`, in this case, will do two things. It will send `produced` back
    to the caller, which will pick it up on the next round of iteration (after calling
    `next()`*,* for example), and it will suspend there. At a later point, the caller
    will want to send a value back to the coroutine by using the `send()` method.
    This value will become the result of the `yield` statement, assigned in this case
    to the variable named `receive`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`yield`将做两件事。它将`produced`发送回调用者，调用者将在下一轮迭代（例如在调用`next()`之后）中接收到它，并在那里暂停。稍后，调用者将想要通过使用`send()`方法向协程发送一个值。这个值将成为`yield`语句的结果，在这种情况下赋给名为`receive`的变量。
- en: 'Sending values to the coroutine only works when this one is suspended at a
    `yield` statement, waiting for something to produce. For this to happen, the coroutine
    will have to be advanced to that status. The only way to do this is by calling
    `next()` on it. This means that before sending anything to the coroutine, this
    has to be advanced at least once via the `next()` method. Failure to do so will
    result in an exception:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当协程在`yield`语句处暂停等待某些东西产生时，向协程发送值才有效。为了实现这一点，协程必须被推进到这种状态。唯一的方法是通过调用`next()`来做到这一点。这意味着在向协程发送任何东西之前，必须通过`next()`方法至少推进一次。如果不这样做，将导致异常：
- en: '[PRE32]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Always remember to advance a coroutine by calling `next()` before sending any
    values to it.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在向协程发送任何值之前，请记住通过调用`next()`来推进协程。
- en: Back to our example. We are changing the way elements are produced or streamed
    to make it able to receive the length of the records it expects to read from the
    database.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的例子。我们正在改变元素被生成或流式传输的方式，使其能够接收它期望从数据库中读取的记录的长度。
- en: The first time we call `next()`, the generator will advance up to the line containing
    `yield`; it will provide a value to the caller (`None`, as set in the variable),
    and it will suspend there). From here, we have two options. If we choose to advance
    the generator by calling `next()`, the default value of `10` will be used, and
    it will go on with this as usual. This is because `next()` is technically the
    same as `send(None)`, but this is covered in the `if` statement that will handle
    the value that we previously set.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次调用`next()`时，生成器将前进到包含`yield`的行；它将向调用者提供一个值（如变量中设置的`None`），并在那里暂停。从这里，我们有两个选择。如果我们选择通过调用`next()`来推进生成器，将使用`10`的默认值，并且它将像往常一样继续进行。这是因为`next()`在技术上与`send(None)`相同，但这是在我们之前设置的值的`if`语句中处理的。
- en: If, on the other hand, we decide to provide an explicit value via `send(<value>)`,
    this one will become the result of the `yield` statement, which will be assigned
    to the variable containing the length of the page to use, which, in turn, will
    be used to read from the database.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们决定通过`send(<value>)`提供一个显式值，这个值将成为`yield`语句的结果，这将被赋给包含要使用的页面长度的变量，而这个变量将被用来从数据库中读取。
- en: Successive calls will have this logic, but the important point is that now we
    can dynamically change the length of the data to read in the middle of the iteration,
    at any point.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 后续的调用将具有这种逻辑，但重要的是现在我们可以在迭代中间动态改变要读取的数据的长度。
- en: 'Now that we understand how the previous code works, most Pythonistas would
    expect a simplified version of it (after all, Python is also about brevity and
    clean and compact code):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了之前的代码是如何工作的，大多数Pythonistas都希望有一个简化版本（毕竟，Python也是关于简洁和干净紧凑的代码）：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This version is not only more compact, but it also illustrates the idea better.
    The parenthesis around the `yield` makes it clearer that it's a statement (think
    of it as if it were a function call), and that we are using the result of it to
    compare it against the previous value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本不仅更紧凑，而且更好地说明了这个想法。`yield`周围的括号使它更清晰，表明它是一个语句（把它想象成一个函数调用），我们正在使用它的结果与先前的值进行比较。
- en: This works as we expect it does, but we always have to remember to advance the
    coroutine before sending any data to it. If we forget to call the first `next()`,
    we'll get a `TypeError`. This call could be ignored for our purposes because it
    doesn't return anything we'll use.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这符合我们的预期，但我们总是要记住在向其发送任何数据之前先推进协程。如果我们忘记调用第一个`next()`，我们将得到一个`TypeError`。这个调用可以被忽略，因为它不会返回我们将使用的任何东西。
- en: 'It would be good if we could use the coroutine directly, right after it is
    created without having to remember to call `next()` the first time, every time
    we are going to use it. Some authors (PYCOOK) devised an interesting decorator
    to achieve this. The idea of this decorator is to advance the coroutine, so the
    following definition works automatically:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能够直接使用协程，在创建后不必记住每次使用它时都调用`next()`第一次，那将是很好的。一些作者（PYCOOK）设计了一个有趣的装饰器来实现这一点。这个装饰器的想法是推进协程，所以下面的定义可以自动工作：
- en: '[PRE34]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Let's take an example we create the `prepare_coroutine()`, decorator.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举个例子，我们创建了`prepare_coroutine()`装饰器。
- en: More advanced coroutines
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更高级的协程
- en: So far, we have a better understanding of coroutines, and we are able to create
    simple ones to handle small tasks. We can say that these coroutines are, in fact,
    just more advanced generators (and that would be right, coroutines are just fancy
    generators), but, if we actually want to start supporting more complex scenarios,
    we usually have to go for a design that handles many coroutines concurrently,
    and that requires more features.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们对协程有了更好的理解，并且能够创建简单的协程来处理小任务。我们可以说这些协程实际上只是更高级的生成器（这是正确的，协程只是花哨的生成器），但是，如果我们真的想要开始支持更复杂的场景，通常我们必须采用一种处理许多协程并发的设计，并且需要更多的功能。
- en: When handling many coroutines, we find new problems. As the control flow of
    our application becomes more complex, we want to pass values up and down the stack
    (as well as exceptions), be able to capture values from sub-coroutines we might
    call at any level, and finally schedule multiple coroutines to run toward a common
    goal.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 处理许多协程时，我们发现了新的问题。随着应用程序的控制流变得更加复杂，我们希望能够在堆栈上传递值和异常，能够捕获我们可能在任何级别调用的子协程的值，并最终安排多个协程朝着共同的目标运行。
- en: To make things simpler, generators had to be extended once again. This is what
    PEP-380 addressed—by changing the semantic of generators so that they are able
    to return values, and introducing the new `yield from` construction.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化事情，生成器必须再次扩展。这就是PEP-380所解决的问题——通过改变生成器的语义，使其能够返回值，并引入新的`yield from`构造。
- en: Returning values in coroutines
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在协程中返回值
- en: As introduced at the beginning of this chapter, the iteration is a mechanism
    that calls `next()` on an iterable object many times until a `StopIteration` exception
    is raised.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本章开头介绍的那样，迭代是一种机制，它在可迭代对象上多次调用`next()`，直到引发`StopIteration`异常。
- en: So far, we have been exploring the iterative nature of generators—we produce
    values one at a time, and, in general, we only care about each value as it's being
    produced at every step of the `for` loop. This is a very logical way of thinking
    about generators, but coroutines have a different idea; even though they are technically
    generators, they weren't conceived with the idea of iteration in mind, but with
    the goal of suspending the execution of a code until it's resumed later on.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在探索生成器的迭代性质——我们一次产生一个值，并且通常只关心`for`循环的每一步产生的每个值。这是一种非常逻辑的生成器思维方式，但是协程有一个不同的想法；尽管它们在技术上是生成器，但它们并不是以迭代为目的而构思的，而是以挂起代码的执行直到稍后恢复为目标。
- en: This is an interesting challenge; when we design a coroutine, we usually care
    more about suspending the state rather than iterating (and iterating a coroutine
    would be an odd case). The challenge lies in that it is easy to mix them both.
    This is because of a technical implementation detail; the support for coroutines
    in Python was built upon generators.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有趣的挑战；当我们设计一个协程时，我们通常更关心挂起状态而不是迭代（迭代协程将是一个奇怪的情况）。挑战在于很容易混合它们两者。这是因为技术实现细节；Python中对协程的支持是建立在生成器之上的。
- en: If we want to use coroutines to process some information and suspend its execution,
    it would make sense to think of them as lightweight threads (or green threads,
    as they are called in other platforms). In such a case, it would make sense if
    they could return values, much like calling any other regular function.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要使用协程来处理一些信息并挂起其执行，那么把它们看作轻量级线程（或者在其他平台上称为绿色线程）是有意义的。在这种情况下，如果它们能够返回值，就像调用任何其他常规函数一样，那将是有意义的。
- en: But let's remember that generators are not regular functions, so in a generator,
    the construction `value = generator()` will do nothing other than create a `generator`
    object. What would be the semantics for making a generator return a value? It
    will have to be after the iteration is done.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但让我们记住生成器不是常规函数，因此在生成器中，构造`value = generator()`除了创建一个`generator`对象之外什么也不会做。那么使生成器返回一个值的语义是什么？它将必须在迭代完成后。
- en: When a generator returns a value, it iteration is immediately stopped (it can't
    be iterated any further). To preserve the semantics, the `StopIteration` exception
    is still raised, and the value to be returned is stored inside the `exception`
    object. It's the responsibility of the caller to catch it.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当生成器返回一个值时，迭代立即停止（不能再迭代）。为了保持语义，`StopIteration`异常仍然被引发，并且要返回的值存储在`exception`对象中。捕获它是调用者的责任。
- en: 'In the following example, we are creating a simple `generator` that produces
    two values and then returns a third. Notice how we have to catch the exception
    in order to get this `value`, and how it''s stored precisely inside the exception
    under the attribute named `value`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们创建了一个简单的`generator`，产生两个值，然后返回第三个值。请注意，我们必须捕获异常以获取这个`value`，以及它如何精确地存储在异常的属性`value`下：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Delegating into smaller coroutines – the yield from syntax
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托到更小的协程 - yield from语法
- en: The previous feature is interesting in the sense that it opens up a lot of new
    possibilities with coroutines (generators), now that they can return values. But
    this feature, by itself, would not be so useful without proper syntax support,
    because catching the returned value this way is a bit cumbersome.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的特性很有趣，因为它为协程（生成器）打开了许多新的可能性，现在它们可以返回值。但是，这个特性本身如果没有适当的语法支持，就不会那么有用，因为以这种方式捕获返回值有点麻烦。
- en: This is one of the main features of the `yield from` syntax. Among other things
    (that we'll review in detail), it can collect the value returned by a sub-generator.
    Remember that we said that returning data in a generator was nice, but that, unfortunately,
    writing statements as `value = generator()` wouldn't work? Well, writing it as `value
    = yield from generator()` would.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`yield from`语法的主要特性之一。除了其他事情（我们将详细审查），它可以收集子生成器返回的值。记住我们说过在生成器中返回数据很好，但不幸的是，编写语句`value
    = generator()`是行不通的吗？好吧，将其编写为`value = yield from generator()`就可以了。
- en: The simplest use of yield from
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`yield from`的最简单用法'
- en: In its most basic form, the new `yield from` syntax can be used to chain generators
    from nested `for` loops into a single one, which will end up with a single string
    of all the values in a continuous stream.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最基本的形式中，新的`yield from`语法可以用于将嵌套的`for`循环中的生成器链接成一个单一的生成器，最终将得到一个连续流中所有值的单个字符串。
- en: The canonical example is about creating a function similar to `itertools.chain()`
    from the `standard` library. This is a very nice function because it allows you
    to pass any number of `iterables`, and will return them all together in one stream.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的例子是创建一个类似于`standard`库中的`itertools.chain()`的函数。这是一个非常好的函数，因为它允许您传递任意数量的`iterables`，并将它们一起返回一个流。
- en: 'The naive implementation might look like this:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 天真的实现可能看起来像这样：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It receives a variable number of `iterables`, traverses through all of them,
    and since each value is `iterable`, it supports a `for... in..` construction,
    so we have another `for` loop to get every value inside each particular iterable,
    which is produced by the caller function. This might be helpful in multiple cases,
    such as chaining generators together or trying to iterate things that it wouldn't
    normally be possible to compare in one go (such as lists with tuples, and so on).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 它接收可变数量的`iterables`，遍历所有这些iterables，由于每个值都是`iterable`，它支持`for... in..`结构，因此我们有另一个`for`循环来获取每个特定iterable中的每个值，这是由调用函数产生的。这在多种情况下可能会有所帮助，例如将生成器链接在一起或尝试迭代通常不可能一次比较的东西（例如列表与元组等）。
- en: 'However, the `yield from` syntax allows us to go further and avoid the nested
    loop because it''s able to produce the values from a sub-generator directly. In
    this case, we could simplify the code like this:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`yield from`语法允许我们更进一步，避免嵌套循环，因为它能够直接从子生成器产生值。在这种情况下，我们可以简化代码如下：
- en: '[PRE37]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Notice that for both implementations, the behavior of the generator is exactly
    the same:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于这两种实现，生成器的行为完全相同：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This means that we can use `yield from` over any other iterable, and it will
    work as if the top-level generator (the one the `yield from` is using) were generating
    those values itself.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以在任何其他可迭代对象上使用`yield from`，它将起到作用，就好像顶层生成器（使用`yield from`的那个）自己生成这些值一样。
- en: 'This works with any iterable, and even generator expressions aren''t the exception.
    Now that we''re familiar with its syntax, let''s see how we could write a simple
    generator function that will produce all the powers of a number (for instance,
    if provided with `all_powers(2, 3)`, it will have to produce `2^0, 2^1,... 2^3`):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这适用于任何可迭代对象，甚至生成器表达式也不例外。现在我们熟悉了它的语法，让我们看看如何编写一个简单的生成器函数，它将产生一个数字的所有幂（例如，如果提供`all_powers(2,
    3)`，它将产生`2^0, 2^1,... 2^3`）：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: While this simplifies the syntax a bit, saving one line of a `for` statement
    isn't a big advantage, and it wouldn't justify adding such a change to the language.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这样简化了语法，节省了一个`for`语句的行数并不是一个很大的优势，这并不能证明向语言中添加这样的更改是合理的。
- en: Indeed, this is actually just a side effect and the real raison d'être of the `yield
    from` construction is what we are going to explore in the following two sections.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这实际上只是一个副作用，而`yield from`结构的真正存在意义是我们将在接下来的两个部分中探讨的。
- en: Capturing the value returned by a sub-generator
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 捕获子生成器返回的值
- en: 'In the following example, we have a generator that calls another two nested
    generators, producing values in a sequence. Each one of these nested generators
    returns a value, and we will see how the top-level generator is able to effectively
    capture the return value since it''s calling the internal generators through `yield
    from`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们有一个生成器调用另外两个嵌套的生成器，按顺序产生值。每一个嵌套的生成器都返回一个值，我们将看到顶层生成器如何能够有效地捕获返回值，因为它通过`yield
    from`调用内部生成器：
- en: '[PRE40]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This is a possible execution of the code in main while it''s being iterated:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在主函数中迭代时代码的可能执行方式：
- en: '[PRE41]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The first line of main delegates into the internal generator, and produces the
    values, extracting them directly from it. This is nothing new, as we have already
    seen. Notice, though, how the `sequence()` generator function returns the end
    value, which is assigned in the first line to the variable named `step1`, and
    how this value is correctly used at the start of the following instance of that
    generator.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: main的第一行委托给内部生成器，并产生值，直接从中提取。这并不是什么新鲜事，因为我们已经见过了。请注意，`sequence()`生成器函数返回结束值，在第一行赋给名为`step1`的变量，这个值在下一个生成器实例的开始正确使用。
- en: In the end, this other generator also returns the second end value (`10`), and
    the main generator, in turn, returns the sum of them (`5+10=15`), which is the
    value we see once the iteration has stopped.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个其他生成器也返回第二个结束值（`10`），而主生成器则返回它们的和（`5+10=15`），这是我们在迭代停止后看到的值。
- en: We can use `yield from` to capture the last value of a coroutine after it has
    finished its processing.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`yield from`在协程完成处理后捕获最后一个值。
- en: Sending and receiving data to and from a sub-generator
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向子生成器发送和接收数据
- en: Now, we will see the other nice feature of the `yield from` syntax, which is
    probably what gives it its full power. As we have already introduced when we explored
    generators acting as coroutines, we know that we can send values and throw exceptions
    at them, and, in such cases, the coroutine will either receive the value for its
    internal processing, or it will have to handle the exception accordingly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看到`yield from`语法的另一个很好的特性，这可能是它赋予它完整力量的原因。正如我们在探索生成器作为协程时已经介绍的，我们知道我们可以向它们发送值和抛出异常，在这种情况下，协程要么接收值进行内部处理，要么必须相应地处理异常。
- en: If we now have a coroutine that delegates into other ones (such as in the previous
    example), we would also like to preserve this logic. Having to do so manually
    would be quite complex (you can take a look at the code described in PEP-380 if
    we didn't have this handled by `yield from` automatically.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在我们有一个委托给其他协程的协程（就像在前面的例子中），我们也希望保留这个逻辑。手动这样做将会相当复杂（如果我们没有通过`yield from`自动处理的话，可以看一下PEP-380中描述的代码）。
- en: 'In order to illustrate this, let''s keep the same top-level generator (main)
    unmodified with respect to the previous example (calling other internal generators),
    but let''s modify the internal generators to make them able to receive values
    and handle exceptions. The code is probably not idiomatic, only for the purposes
    of showing how this mechanism works:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们保持相同的顶层生成器（main）与之前的例子相同，但让我们修改内部生成器，使它们能够接收值并处理异常。这段代码可能不是惯用的，只是为了展示这个机制是如何工作的。
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we will call the `main` coroutine, not only by iterating it, but also
    by passing values and throwing exceptions at it to see how they are handled inside `sequence`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将调用`main`协程，不仅通过迭代它，还通过向它传递值和抛出异常，以查看它们在`sequence`内部是如何处理的：
- en: '[PRE43]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This example is showing us a lot of different things. Notice how we never send
    values to `sequence`, but only to `main`, and even so, the code that is receiving
    those values is the nested generators. Even though we never explicitly send anything
    to `sequence`, it's receiving the data as it's being passed along by `yield from`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子向我们展示了很多不同的东西。请注意，我们从未向`sequence`发送值，而只是向`main`发送，即使如此，接收这些值的代码是嵌套生成器。即使我们从未明确向`sequence`发送任何东西，它也会接收数据，因为它是通过`yield
    from`传递的。
- en: The `main` coroutine calls two other coroutines internally, producing their
    values, and it will be suspended at a particular point in time in any of those.
    When it's stopped at the first one, we can see the logs telling us that it is
    that instance of the coroutine that received the value we sent. The same happens
    when we throw an exception to it. When the first coroutine finishes, it returns
    the value that was assigned in the variable named `step1`, and passed as input
    for the second coroutine, which will do the same (it will handle the `send()`
    and `throw()` calls, accordingly).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`协程在内部调用另外两个协程，产生它们的值，并且在任何一个特定时间点被挂起。当它停在第一个时，我们可以看到日志告诉我们，正是这个协程实例接收了我们发送的值。当我们向它抛出异常时也是一样的。当第一个协程完成时，它返回了在名为`step1`的变量中分配的值，并作为第二个协程的输入，第二个协程也会做同样的事情（它将相应地处理`send()`和`throw()`调用）。'
- en: The same happens for the values that each coroutine produces. When we are at
    any given step, the return from calling `send()` corresponds to the value that
    the subcoroutine (the one that `main` is currently suspended at) has produced.
    When we throw an exception that is being handled, the `sequence` coroutine produces
    the value `OK`, which is propagated to the called (`main`), and which in turn
    will end up at main's caller.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个协程产生的值也是如此。当我们处于任何给定步骤时，调用`send()`返回的值对应于子协程（`main`当前挂起的那个）产生的值。当我们抛出一个正在处理的异常时，`sequence`协程产生值`OK`，这个值传播到被调用的（`main`），然后最终到达main的调用者。
- en: Asynchronous programming
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程
- en: With the constructions we have seen so far, we are able to create asynchronous
    programs in Python. This means that we can create programs that have many coroutines,
    schedule them to work in a particular order, and switch between them when they're
    suspended after a `yield from` has been called on each of them.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们迄今为止看到的构造，我们能够在Python中创建异步程序。这意味着我们可以创建具有许多协程的程序，安排它们按特定顺序工作，并在每个协程上调用`yield
    from`后挂起时在它们之间切换。
- en: The main advantage that we can take out of this is the possibility of parallelizing
    I/O operations in a non-blocking way. What we would need is a low-level generator
    (usually implemented by a third-party library) that knows how to handle the actual
    I/O while the coroutine is suspended. The idea is for the coroutine to effect
    suspension so that our program can handle another task in the meantime. The way
    the application would retrieve the control back is by means of the `yield from` statement,
    which will suspend and produce a value to the caller (as in the examples we saw
    previously when we used this syntax to alter the control flow of the program).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从中获得的主要优势是以非阻塞的方式并行化I/O操作的可能性。我们需要的是一个低级生成器（通常由第三方库实现），它知道如何在协程被挂起时处理实际的I/O。协程的目的是实现挂起，以便我们的程序可以在此期间处理另一个任务。应用程序重新获取控制的方式是通过`yield
    from`语句，它将挂起并向调用者产生一个值（就像我们之前看到的例子中使用这个语法来改变程序的控制流）。
- en: This is roughly the way asynchronous programming had been working in Python
    for quite a few years, until it was decided that better syntactic support was
    needed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这大致是多年来Python中异步编程的工作方式，直到决定需要更好的语法支持。
- en: The fact that coroutines and generators are technically the same causes some
    confusion. Syntactically (and technically), they are the same, but semantically,
    they are different. We create generators when we want to achieve efficient iteration.
    We typically create coroutines with the goal of running non-blocking I/O operations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 协程和生成器在技术上是相同的，这导致了一些混淆。从语法上（和技术上）来看，它们是相同的，但从语义上来看，它们是不同的。当我们想要实现高效的迭代时，我们创建生成器。我们通常创建协程的目的是运行非阻塞I/O操作。
- en: 'While this difference is clear, the dynamic nature of Python would still allow
    developers to mix these different type of objects, ending up with a runtime error
    at a very late stage of the program. Remember that in the simplest and most basic
    form of the `yield from`syntax, we used this construction over iterables (we created
    a sort of `chain` function applied over strings, lists, and so on). None of these
    objects were coroutines, and it still worked. Then, we saw that we can have multiple
    coroutines, use `yield from` to send the value (or exceptions), and get some results
    back. These are clearly two very different use cases, however, if we write something along
    the lines of the following statement:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种差异是明显的，Python的动态特性仍然允许开发人员混合这些不同类型的对象，在程序的非常后期出现运行时错误。记住，在最简单和最基本的`yield
    from`语法中，我们使用这个结构来迭代（我们创建了一种在字符串、列表等上应用的`chain`函数）。这些对象都不是协程，但它仍然有效。然后，我们看到我们可以有多个协程，使用`yield
    from`发送值（或异常），并获得一些结果。这显然是两种非常不同的用例，但是，如果我们写出类似以下语句的内容：
- en: '[PRE44]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: It's not clear what `iterable_or_awaitable` returns. It can be a simple iterable
    such as a string, and it might still be syntactically correct. Or, it might be
    an actual coroutine. The cost of this mistake will be paid much later.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 不清楚`iterable_or_awaitable`返回什么。它可以是一个简单的可迭代对象，比如字符串，这可能仍然是语法上正确的。或者，它可能是一个实际的协程。这个错误的代价将在以后付出。
- en: For this reason, the typing system in Python had to be extended. Before Python
    3.5, coroutines were just generators with a `@coroutine` decorator applied, and
    they were to be called with the `yield from` syntax. Now, there is a specific
    type of object, that is, a coroutine.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Python中的输入系统必须得到扩展。在Python 3.5之前，协程只是应用了`@coroutine`装饰器的生成器，并且它们需要使用`yield
    from`语法进行调用。现在，有一种特定类型的对象，即协程。
- en: This change heralded, syntax changes as well. The `await` and `async def` syntax
    were introduced. The former is intended to be used instead of `yield from,` and
    it only works with `awaitable` objects (which coroutines conveniently happen to
    be). Trying to call `await` with something that doesn't respect the interface
    of an `awaitable` will raise an exception. The `async def` is the new way of defining
    coroutines, replacing the aforementioned decorator, and this actually creates
    an object that, when called, will return an instance of a coroutine.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变也带来了语法的改变。引入了`await`和`async def`语法。前者旨在替代`yield from`，它只能与`awaitable`对象一起使用（方便地，协程恰好是这种对象）。尝试使用不符合`awaitable`接口的东西来调用`await`将引发异常。`async
    def`是定义协程的新方法，取代了前面提到的装饰器，实际上创建了一个对象，当调用时，将返回一个协程的实例。
- en: Without going into all the details and possibilities of asynchronous programming
    in Python, we can say that despite the new syntax and the new types, this is not
    doing anything fundamentally different from concepts we have covered in this chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不去深入讨论Python中异步编程的所有细节和可能性，我们可以说，尽管有新的语法和新的类型，但这并没有从本质上做任何不同于我们在本章中介绍的概念。
- en: The idea of programming asynchronously in Python is that there is an `event`
    loop (typically `asyncio` because it's the one that is included in the `standard`
    library, but there are many others that will work just the same) that manages
    a series of coroutines. These coroutines belong to the event loop, which is going
    to call them according to its scheduling mechanism. When each one of these runs,
    it will call our code (according to the logic we have defined inside the coroutine
    we programmed), and when we want to get control back to the event loop, we call `await
    <coroutine>`*,* which will process a task asynchronously. The event loop will
    resume and another coroutine will take place while that operation is left running.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中异步编程的思想是有一个事件循环（通常是`asyncio`，因为它是`标准`库中包含的一个，但还有许多其他可以正常工作的），它管理一系列协程。这些协程属于事件循环，事件循环将根据其调度机制来调用它们。当这些协程中的每一个运行时，它将调用我们的代码（根据我们在编写的协程中定义的逻辑），当我们想要将控制返回给事件循环时，我们调用`await
    <coroutine>`，这将异步处理一个任务。事件循环将恢复，另一个协程将代替正在运行的操作。
- en: In practice, there are more particularities and edge cases that are beyond the
    scope of this book. It is, however, worth mentioning that these concepts are related
    to the ideas introduced in this chapter and that this arena is another place where
    generators demonstrate being a core concept of the language, as there are many
    things constructed on top of them.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有更多的细节和边缘情况超出了本书的范围。然而，值得一提的是，这些概念与本章介绍的思想相关，并且这个领域是生成器证明是语言的核心概念的另一个地方，因为有许多东西是在它们的基础上构建的。
- en: Summary
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Generators are everywhere in Python. Since their inception in Python a long
    time ago, they proved to be a great addition that makes programs more efficient
    and iteration much simpler.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器在Python中随处可见。自它们在Python中诞生以来，它们被证明是一个很好的补充，使程序更加高效，迭代更加简单。
- en: As time moved on, and more complex tasks needed to be added to Python, generators
    helped again in supporting coroutines.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，以及需要向Python添加更复杂的任务，生成器再次帮助支持协程。
- en: And, while in Python, coroutines are generators, we still don't have to forget
    that they're semantically different. Generators are created with the idea of iteration,
    while coroutines have the goal of asynchronous programming (suspending and resuming
    the execution of a part of our program at any given time). This distinction became
    so important that it made Python's syntax (and type system) evolve.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 而在Python中，协程是生成器，我们仍然不必忘记它们在语义上是不同的。生成器是为了迭代而创建的，而协程的目标是异步编程（在任何给定时间暂停和恢复程序的执行部分）。这种区别变得如此重要，以至于它使Python的语法（和类型系统）发生了演变。
- en: Iteration and asynchronous programming constitute the last of the main pillars
    of Python programming. Now, it's time to see how everything fits together and
    to put all of these concepts we have been exploring over the past few chapters
    into action.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代和异步编程构成了Python编程的最后一根主要支柱。现在，是时候看看所有这些概念如何结合在一起，并将我们在过去几章中探讨的所有这些概念付诸实践了。
- en: The following chapters will describe other fundamental aspects of Python projects,
    such as testing, design patterns, and architecture.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将描述Python项目的其他基本方面，如测试、设计模式和架构。
- en: References
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考资料
- en: 'Here is a list of information you can refer to:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是您可以参考的信息列表：
- en: '*PEP-234*: Iterators ([https://www.python.org/dev/peps/pep-0234/](https://www.python.org/dev/peps/pep-0234/))'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-234*：迭代器（[https://www.python.org/dev/peps/pep-0234/](https://www.python.org/dev/peps/pep-0234/)）'
- en: '*PEP-255*: Simple Generators ([https://www.python.org/dev/peps/pep-0255/](https://www.python.org/dev/peps/pep-0255/))'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-255*：简单生成器（[https://www.python.org/dev/peps/pep-0255/](https://www.python.org/dev/peps/pep-0255/)）'
- en: '*ITER-01*: Python''s itertools module ([https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html))'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ITER-01*：Python的itertools模块（[https://docs.python.org/3/library/itertools.html](https://docs.python.org/3/library/itertools.html)）'
- en: '*GoF*: The book written by Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides
    named *Design Patterns: Elements of Reusable Object-Oriented Software*'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*GoF*：由Erich Gamma, Richard Helm, Ralph Johnson, John Vlissides撰写的书籍*Design
    Patterns: Elements of Reusable Object-Oriented Software*'
- en: '*PEP-342*: Coroutines via Enhanced Generators([https://www.python.org/dev/peps/pep-0342/](https://www.python.org/dev/peps/pep-0342/))'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PEP-342*：通过增强生成器实现协程（[https://www.python.org/dev/peps/pep-0342/](https://www.python.org/dev/peps/pep-0342/)）'
- en: '*PYCOOK*: The book  written by Brian Jones, David Beazley named *Python Cookbook:
    Recipes for Mastering Python 3, Third Edition*'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PYCOOK*：由Brian Jones, David Beazley撰写的书籍*Python Cookbook: Recipes for Mastering
    Python 3, Third Edition*'
- en: '*PY99*: Fake threads (generators, coroutines, and continuations) ([https://mail.python.org/pipermail/python-dev/1999-July/000467.html](https://mail.python.org/pipermail/python-dev/1999-July/000467.html))'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*PY99*：虚拟线程（生成器、协程和续延）（[https://mail.python.org/pipermail/python-dev/1999-July/000467.html](https://mail.python.org/pipermail/python-dev/1999-July/000467.html)）'
- en: '*CORO-01*: Co Routine ([http://wiki.c2.com/?CoRoutine](http://wiki.c2.com/?CoRoutine))'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORO-01*：协程（[http://wiki.c2.com/?CoRoutine](http://wiki.c2.com/?CoRoutine)）'
- en: '*CORO-02*: Generators Are Not Coroutines ([http://wiki.c2.com/?GeneratorsAreNotCoroutines](http://wiki.c2.com/?GeneratorsAreNotCoroutines))'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CORO-02*：生成器不是协程（[http://wiki.c2.com/?GeneratorsAreNotCoroutines](http://wiki.c2.com/?GeneratorsAreNotCoroutines)）'
- en: '*TEE*: The `itertools.tee` function ([https://docs.python.org/3/library/itertools.html#itertools.tee](https://docs.python.org/3/library/itertools.html#itertools.tee))'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*TEE*：`itertools.tee` 函数（[https://docs.python.org/3/library/itertools.html#itertools.tee](https://docs.python.org/3/library/itertools.html#itertools.tee)）'
