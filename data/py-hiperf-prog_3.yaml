- en: Chapter 3. C Performance with Cython
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。使用 Cython 的 C 性能
- en: Cython is a language that extends Python by adding static typing to functions,
    variables, and classes. Cython combines the simplicity of Python and the efficiency
    of C. After rewriting your scripts in Cython you can compile them to C or C++,
    generating efficient code in a straightforward way.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 是一种通过向函数、变量和类添加静态类型来扩展 Python 的语言。Cython 结合了 Python 的简洁性和 C 语言的效率。在将脚本重写为
    Cython 之后，您可以编译它们为 C 或 C++，以简单直接的方式生成高效代码。
- en: Cython also acts as a bridge between Python and C, as it can be used to create
    interfaces to external C code. By creating bindings, you can reuse fast C routines
    in your scripts, effectively using Python as a glue language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 还充当 Python 和 C 之间的桥梁，因为它可以用来创建对外部 C 代码的接口。通过创建绑定，您可以在脚本中重用快速的 C 例程，有效地使用
    Python 作为粘合语言。
- en: 'In this chapter we will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: Cython syntax basics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 语法基础
- en: How to compile Cython programs
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编译 Cython 程序
- en: How to use **static typing** to generate fast code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 **静态类型** 生成快速代码
- en: How to efficiently manipulate arrays by making use of typed **memoryviews.**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过使用类型化的 **memoryviews** 高效地操作数组。
- en: Finally, we will apply our new Cython skills to profile and optimize the particle
    simulator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将应用我们新的 Cython 技能来分析和优化粒子模拟器。
- en: While a minimum knowledge of C is helpful, this chapter focuses only on Cython
    in the context of Python optimization. Therefore, it doesn't require any C background.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然对 C 语言有最小了解有帮助，但本章仅关注在 Python 优化背景下使用 Cython。因此，它不需要任何 C 语言背景知识。
- en: Compiling Cython extensions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译 Cython 扩展
- en: By design, the Cython syntax is a superset of Python. Cython can typically compile
    a Python module without requiring any change. Cython source files have the extension
    `.pyx` and they can be compiled to C using the `cython` command.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 按照设计，Cython 语法是 Python 的超集。Cython 通常可以编译 Python 模块而不需要任何更改。Cython 源文件具有 `.pyx`
    扩展名，并且可以使用 `cython` 命令编译为 C 语言。
- en: 'Our first Cython script will contain a simple function that prints *Hello,
    World!* to the output. Create a new file `hello.pyx` containing the following
    code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一篇 Cython 脚本将包含一个简单的函数，该函数将 *Hello, World!* 打印到输出。创建一个名为 `hello.pyx` 的新文件，包含以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `cython` command will read `hello.pyx` and generate the `hello.c` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '`cython` 命令将读取 `hello.pyx` 并生成 `hello.c` 文件：'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To compile `hello.c` to a Python extension module we will use the gcc compiler.
    We need to add some Python-specific compilation options that depend on the operating
    system. On Ubuntu 13.10, with the default Python installation, you can use the
    following options to compile:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 `hello.c` 编译为 Python 扩展模块，我们将使用 gcc 编译器。我们需要添加一些依赖于操作系统的特定于 Python 的编译选项。在
    Ubuntu 13.10 上，使用默认的 Python 安装，您可以使用以下选项进行编译：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This will produce a file called `hello.so`: a C extension module importable
    from Python.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个名为 `hello.so` 的文件：一个可以从 Python 导入的 C 扩展模块。
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Cython accepts both Python 2 and Python 3 as input and output languages. In
    other words, you can compile a Python 3 `hello.pyx` file using the `-3` option:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 既可以接受 Python 2，也可以接受 Python 3 作为输入和输出语言。换句话说，您可以使用 `-3` 选项编译 Python 3
    的 `hello.pyx` 文件：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The generated `hello.c` can be compiled without any changes to Python 2 and
    Python 3 by including the corresponding headers with the `-I` option in gcc as
    follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `hello.c` 可以通过在 gcc 中包含相应的头文件（使用 `-I` 选项）而不做任何更改地编译为 Python 2 和 Python 3：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'A Cython program can be compiled in a more straightforward way by using `distutils`—the
    standard Python packaging tool. By writing a `setup.py` script we can compile
    the `.pyx` file directly to an extension module. To compile our `hello.pyx` example
    we need to write a `setup.py` containing the following code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `distutils`（标准的 Python 打包工具），Cython 程序可以以更直接的方式编译。通过编写 `setup.py` 脚本，我们可以直接将
    `.pyx` 文件编译为扩展模块。为了编译我们的 `hello.pyx` 示例，我们需要编写一个包含以下代码的 `setup.py`：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the first two lines of the previous code, we import the `setup` function
    and the `cythonize` helper. The `setup` function contains a few key-value pairs
    that tell `distutils` the name of the application and which extensions need to
    be built.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面代码的前两行中，我们导入了 `setup` 函数和 `cythonize` 辅助函数。`setup` 函数包含一些键值对，告诉 `distutils`
    应用程序的名称以及需要构建哪些扩展。
- en: 'The `cythonize` helper takes either a string or a list of strings containing
    the Cython modules we want to compile. You can also use glob patterns using the
    following code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`cythonize` 辅助函数接受一个字符串或包含我们想要编译的 Cython 模块的字符串列表。您还可以使用以下代码使用 glob 模式：'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To compile our extension module using `distutils` you can execute the `setup.py`
    script using the following code:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `distutils` 编译我们的扩展模块，您可以执行以下代码的 `setup.py` 脚本：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `build_ext` option tells the script to build the extension modules indicated
    in `ext_modules`, and the `--inplace` option places the output `hello.so` file
    in the same location as the source file (instead of a build directory).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`build_ext` 选项指示脚本构建 `ext_modules` 中指定的扩展模块，而 `--inplace` 选项将输出文件 `hello.so`
    放置在源文件相同的目录中（而不是构建目录）。'
- en: Cython modules can automatically be compiled using `pyximport`. By adding `pyximport.install()`
    at the beginning of your script (or issuing the command in your interpreter) you
    can import `.pyx` files directly; `pyximport` will transparently compile the corresponding
    Cython modules.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 模块可以自动使用 `pyximport` 编译。通过在脚本开头添加 `pyximport.install()`（或在解释器中发出该命令），您可以直接导入
    `.pyx` 文件；`pyximport` 将透明地编译相应的 Cython 模块。
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Unfortunately, `pyximport` will not work for all kinds of configurations (for
    example when they involve a combination of C and Cython files), but it comes in
    handy for testing simple scripts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`pyximport` 并不适用于所有类型的配置（例如涉及 C 和 Cython 文件组合的情况），但它对于测试简单的脚本来说很有用。
- en: 'Since version 0.13, IPython includes the `cythonmagic` extension to interactively
    write and test a series of Cython statements. You can load the extensions in an
    IPython shell using `load_ext`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自 0.13 版本以来，IPython 包含了 `cythonmagic` 扩展，可以交互式地编写和测试一系列 Cython 语句。您可以使用 `load_ext`
    在 IPython 壳中加载扩展：
- en: '[PRE10]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once the extension is loaded you can use the `%%cython` *cell magic* to write
    a multi-line Cython snippet. In the following example, we define a `hello_snippet`
    function that will be compiled and added to the `session` namespace:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了扩展，您就可以使用 `%%cython` *单元格魔法* 来编写多行 Cython 片段。在以下示例中，我们定义了一个 `hello_snippet`
    函数，该函数将被编译并添加到 `session` 命名空间中：
- en: '[PRE11]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding static types
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加静态类型
- en: In Python, variables have an associated type that can change during the execution.
    While this feature is desirable, as it makes the language more flexible, the interpreter
    needs to do type-checks and method look-ups to correctly handle operations between
    variables—an extra step that introduces a significant overhead. Cython extends
    the Python language with static type declarations; in this way it can generate
    efficient C code by avoiding the Python interpreter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，变量有一个关联的类型，该类型在执行过程中可以改变。虽然这个特性是可取的，因为它使语言更加灵活，但解释器需要进行类型检查和方法查找来正确处理变量之间的操作——这是一个引入了显著开销的额外步骤。Cython
    通过静态类型声明扩展了 Python 语言；这样，它可以通过避免 Python 解释器来生成高效的 C 代码。
- en: 'The main way to declare data types in Cython is by using `cdef` statements.
    The `cdef` keyword can be used in multiple contexts: to declare variables, functions,
    and extension types (`cdef` classes).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中声明数据类型的主要方式是通过使用 `cdef` 语句。`cdef` 关键字可以在多个上下文中使用：声明变量、函数和扩展类型（`cdef`
    类）。
- en: Variables
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: 'In Cython you can declare the type of a variable by prepending the variable
    with `cdef` and its respective type. For example, we can declare the variable
    `i` as a 16 bit integer in the following way:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Cython 中，您可以通过在变量前加上 `cdef` 和相应的类型来声明变量的类型。例如，我们可以以下这种方式声明变量 `i` 为 16 位整数：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `cdef` statement supports multiple variable names on the same line, along
    with optional initialization values, as seen in the following line of code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef` 语句支持在同一行上使用多个变量名，以及可选的初始化值，如下面的代码行所示：'
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Typed variables are treated differently in comparison to standard variables.
    In Python, variables are often regarded as *labels* referring to objects in memory.
    At any point in the program, we can assign a string to a variable as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准变量相比，类型化变量被处理得不同。在 Python 中，变量通常被视为 *标签*，指代内存中的对象。在任何程序点，我们都可以将一个字符串赋给变量，如下所示：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The string *hello* will be bound to the variable `a`. At a different place
    in the program, we can assign to the same variable another value, for example
    an integer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串 *hello* 将绑定到变量 `a`。在程序的不同位置，我们可以将另一个值赋给相同的变量，例如一个整数：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Python will assign the integer object *1* to the variable `a` without any problem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Python 会将整数对象 *1* 赋给变量 `a` 而不会出现任何问题。
- en: 'Typed variables can be considered more like *data containers*; we *store* the
    value in the variable and only values of the same type are allowed to get in.
    For example, if we declare the variable `a` as an `int` type variable, and then
    we try to assign it to a `double`, Cython will trigger an error, as shown in the
    following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 带有类型的变量可以被认为是更类似于 *数据容器*；我们在变量中 *存储* 值，并且只有相同类型的值被允许进入。例如，如果我们将变量 `a` 声明为 `int`
    类型的变量，然后我们尝试将其赋值为 `double`，Cython 将触发错误，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Static typing allows useful optimizations. If we declare indexes to be used
    in a loop as integers, Cython will rewrite the loops in pure C without stepping
    into the Python interpreter. In the following example, we do an iteration 100
    times and each time we increment the `int` variable `j`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 静态类型允许有用的优化。如果我们声明在循环中使用的索引为整数，Cython 将将循环重写为纯 C，而无需进入 Python 解释器。在下面的示例中，我们迭代
    100 次，每次都递增 `int` 变量 `j`：
- en: '[PRE17]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To understand how big the improvement is, we will compare the speed with an
    analogous, pure Python loop:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解改进有多大，我们将将其速度与类似的纯 Python 循环进行比较：
- en: '[PRE18]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The speedup obtained by writing the loop with typing information is a whopping
    100x! This works because the Cython loop has first been converted to pure C and
    then to efficient machine code, while the Python loop still relies on the slow
    interpreter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编写带有类型信息的循环获得的加速效果高达 100 倍！这是因为 Cython 循环首先被转换为纯 C，然后转换为高效的机器代码，而 Python 循环仍然依赖于慢速的解释器。
- en: 'We can declare a variable of any available C type, and we can also define custom
    types by using C structs, enums, and typedefs. An interesting example is that
    if we declare a variable to be of `object` type, the variable will accept any
    kind of Python object:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明任何可用的 C 类型的变量，我们也可以通过使用 C 结构体、枚举和 `typedef` 来定义自定义类型。一个有趣的例子是，如果我们声明一个变量为
    `object` 类型，该变量将接受任何类型的 Python 对象：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Sometimes, certain types of variables are compatible (such as `float` and `int`
    numbers) but not exactly the same. In Cython it is possible to convert (*cast*)
    between types by surrounding the destination type with `<` and `>` pointy brackets,
    as shown in the following code snippet:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，某些类型的变量是兼容的（例如 `float` 和 `int` 数字），但并不完全相同。在 Cython 中，可以通过将目标类型用 `<` 和 `>`
    括号包围来在类型之间进行转换（*cast*），如下面的代码片段所示：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Functions
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数
- en: 'You can add type information to the arguments of a Python function by specifying
    the type in front of the argument name. Such functions will work and perform like
    a regular Python function but its arguments will be type-checked. We can write
    a `max_python` function, which returns the greater value between two integers
    in the following way:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在参数名称前指定类型来向 Python 函数的参数添加类型信息。这样的函数将像常规 Python 函数一样工作并执行，但其参数将进行类型检查。我们可以编写一个
    `max_python` 函数，以下是这样返回两个整数之间较大值的示例：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'That function doesn''t provide much benefit except for type-checking. To take
    advantage of Cython optimizations we have to declare the function using a `cdef`
    statement and an optional return type, as in the following code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那个函数除了类型检查外没有提供太多好处。为了利用 Cython 优化，我们必须使用 `cdef` 语句和可选的返回类型来声明该函数，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Functions declared in this way are translated to native C functions, which are
    not callable from Python. They have much less overhead compared to Python functions,
    and using them results in a substantial increase in performance. Their scope is
    restricted to the same Cython file, unless they're exposed in a definition file
    (refer to the *Sharing Declarations* section).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式声明的函数会被转换为原生 C 函数，这些函数不能从 Python 中调用。与 Python 函数相比，它们的开销要小得多，使用它们会导致性能显著提升。它们的范围限制在相同的
    Cython 文件中，除非它们在定义文件中公开（参考 *共享声明* 部分）。
- en: 'Cython allows you to define functions that are both callable from Python and
    translatable to native C functions. If you declare a function with the keyword
    `cpdef`, Cython will generate two versions of the function—a Python version available
    to the interpreter, and a fast C function usable from Cython—achieving both convenience
    and speed. The `cpdef` syntax is equivalent to `cdef`, shown as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 允许你定义既可以从 Python 调用也可以转换为原生 C 函数的函数。如果你使用关键字 `cpdef` 声明一个函数，Cython 将生成该函数的两个版本——一个可供解释器使用的
    Python 版本和一个可从 Cython 使用的快速 C 函数，从而实现便利性和速度。`cpdef` 语法与 `cdef` 相当，如下所示：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Sometimes, the call overhead can be a performance issue even with C functions,
    especially when the same function is called many times in a critical loop. When
    the function body is small, it is convenient to add the `inline` keyword in front
    of the function definition; the function call will be removed and replaced by
    the function body. For instance, our following `max` function is a good candidate
    for *inlining*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，即使有 C 函数，调用开销也可能成为性能问题，尤其是在关键循环中多次调用同一函数时。当函数体较小时，在函数定义前添加 `inline` 关键字是很方便的；函数调用将被移除并替换为函数体。例如，我们下面的
    `max` 函数是 *内联* 的一个很好的候选：
- en: '[PRE24]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Classes
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: The`cdef` keyword can also be put in front of a class definition to create an
    *extension type*. An extension type is similar to a Python class but its attributes
    must have a type and are stored in an efficient C *struct*.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`cdef` 关键字也可以放在类定义的前面来创建一个 *扩展类型*。扩展类型类似于 Python 类，但其属性必须具有类型，并且存储在高效的 C *结构体*
    中。'
- en: 'We can define an extension type by using the `cdef class` statement and declaring
    its attributes in the class body. For example, we can create an extension type
    `Point`, as shown in the following code, which stores two coordinates (x, y) of
    type `double`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `cdef class` 语句定义扩展类型，并在类体中声明其属性。例如，我们可以创建一个扩展类型 `Point`，如下面的代码所示，它存储两个坐标（x，y）的类型为
    `double`：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Accessing the declared attributes in the class methods allows Cython to avoid
    the Python attribute look-up by replacing it with direct access to the `struct`
    fields. In this way, attribute access becomes an extremely fast operation.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在类方法中访问声明的属性允许 Cython 通过将其替换为直接访问 `struct` 字段来避免 Python 属性查找。这样，属性访问就变得非常快速。
- en: 'To take advantage of the `struct` access, Cython needs to know that the variable
    is an extension type at the time of compilation. You can use the extension type
    name (such as `Point`) in any context where you would use a standard one (such
    as `double`, `float`, `int`). For example, if we want a Cython function that calculates
    the `norm` of a `Point`, we have to declare the input variable as `Point`, as
    shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用 `struct` 访问，Cython 需要知道在编译时变量是一个扩展类型。你可以在任何可以使用标准类型（如 `double`、`float`、`int`）的地方使用扩展类型名称（如
    `Point`）。例如，如果我们想编写一个计算 `Point` 的 `norm` 的 Cython 函数，我们必须将输入变量声明为 `Point`，如下面的代码所示：
- en: '[PRE26]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'By default, access to the attributes is restricted to Cython code. If you try
    to access an extension type attribute from Python, you will get an `AttributeError`
    shown as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，对属性的访问限制在 Cython 代码中。如果你尝试从 Python 访问扩展类型属性，你会得到一个 `AttributeError`，如下所示：
- en: '[PRE27]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In order to access attributes from Python code you have to use the `public`
    (for read-write access) or `readonly` specifiers in the attribute declaration,
    as shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从 Python 代码中访问属性，你必须使用属性声明中的 `public`（用于读写访问）或 `readonly` 说明符，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Extension types do not support the addition of extra attributes. A workaround
    for this problem is subclassing the extension type, creating a derived Python
    class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展类型不支持添加额外的属性。对于这个问题的一个解决方案是子类化扩展类型，创建一个派生的 Python 类。
- en: Sharing declarations
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分享声明
- en: When writing your Cython modules, you may want to encapsulate generic functions
    and types in a separate file. Cython allows you to reuse those components with
    the `cimport` statement by writing a *definition file.*
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写你的 Cython 模块时，你可能希望在一个单独的文件中封装通用的函数和类型。Cython 允许你通过编写 *定义文件* 来使用 `cimport`
    语句重用这些组件。
- en: Let's say we have a module with the functions `max` and `min`, and we want to
    reuse those functions in multiple Cython programs. If we simply write a `.pyx`
    file—also called *implementation file*—the functions declared are confined in
    the same module.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含 `max` 和 `min` 函数的模块，并且我们想在多个 Cython 程序中重用这些函数。如果我们简单地编写一个 `.pyx` 文件——也称为
    *实现文件*——声明的函数将局限于同一模块中。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Definition files are also used to interface Cython with an external C code.
    The idea is to copy the types and function prototypes in the definition file and
    leave the implementation to the external C code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 定义文件也用于将 Cython 与外部 C 代码接口。其思路是将定义文件中的类型和函数原型复制过来，并将实现留给外部 C 代码。
- en: 'To share those functions we need to write a definition file, with a `.pxd`
    extension. Such a file only contains the types and function prototypes that we
    want share to other modules—a *public* interface. We can write the prototypes
    of our `max` and `min` functions in a file named `mathlib.pxd` as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要共享这些函数，我们需要编写一个定义文件，具有`.pxd`扩展名。这样的文件只包含我们想要与其他模块共享的类型和函数原型——一个*公共*接口。我们可以在名为`mathlib.pxd`的文件中编写我们的`max`和`min`函数的原型，如下所示：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As you can see, we only write the function name and arguments, without implementing
    the function body.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们只编写了函数名和参数，而没有实现函数体。
- en: 'The function implementation goes into the implementation file with the same
    base name but `.pyx` extension—`mathlib.pyx`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 函数实现将放入具有相同基本名称但`.pyx`扩展名的实现文件中——`mathlib.pyx`：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `mathlib` module is now importable from another Cython module.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathlib`模块现在可以从另一个Cython模块导入。'
- en: To test our Cython module we will create a file named `distance.pyx` containing
    a function named `chebyshev`. The function will calculate the Chebyshev distance
    between two points, as shown in the following code. The Chebyshev distance between
    two coordinates (x1, y1) and (x2, y2) is defined as the maximum value of the difference
    between each coordinate.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试我们的Cython模块，我们将创建一个名为`distance.pyx`的文件，其中包含一个名为`chebyshev`的函数。该函数将计算两点之间的Chebyshev距离，如下面的代码所示。两点坐标（x1,
    y1）和（x2, y2）之间的Chebyshev距离定义为每个坐标之间差异的最大值。
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To implement the `chebyshev` function we will use the `max` function, declared
    in `mathlib.pxd` by importing it with the `cimport` statement, as shown in the
    following code snippet:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`chebyshev`函数，我们将使用`max`函数，它在`mathlib.pxd`中声明，通过使用`cimport`语句导入，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `cimport` statement will read `hello.pxd` and the `max` definition will
    be used to generate the `distance.c` file.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`cimport`语句将读取`hello.pxd`，并将`max`定义用于生成`distance.c`文件。'
- en: Working with arrays
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组
- en: Numerical and high performance calculations often make use of arrays. Cython
    provides an easy way to interact with them, from the low-level approach of C arrays,
    to the more general *typed memoryviews*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 数值和高性能计算通常使用数组。Cython提供了一种简单的方法来与之交互，从C数组的底层方法到更通用的*类型化内存视图*。
- en: C arrays and pointers
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C数组和指针
- en: C arrays are a collection of items of the same size stored contiguously in memory.
    Before digging into the details, it is helpful to understand (or review) how memory
    is managed in C.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: C数组是一系列大小相同的项，在内存中连续存储。在深入了解细节之前，了解（或复习）C语言中内存的管理方式是有帮助的。
- en: Variables in C are like containers. When creating a variable, a space in memory
    is reserved to store its value. For example, if we create a variable containing
    a 64 bit floating point number (`double`), the program will allocate 64 bit (16
    bytes) of memory. This portion of memory can be accessed through an address to
    that memory location.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: C语言中的变量就像容器。当创建一个变量时，会在内存中预留一个空间来存储其值。例如，如果我们创建一个包含64位浮点数（`double`）的变量，程序将分配64位（16字节）的内存。这部分内存可以通过该内存位置的地址来访问。
- en: 'To obtain the address of a variable we can use the *address operator*, denoted
    with the `&` symbol. We can also use the `printf` function, as follows, available
    in the `libc.stdio` Cython module to print the address of this variable:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取变量的地址，我们可以使用*地址运算符*，用`&`符号表示。我们还可以使用`printf`函数，如下所示，在`libc.stdio` Cython模块中可用，以打印该变量的地址：
- en: '[PRE33]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Memory addresses can be stored in special variables—*pointers*—declared by
    putting a `*` prefix on the variable name as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 内存地址可以存储在特殊的变量中——*指针*，通过在变量名前放置`*`前缀来声明，如下所示：
- en: '[PRE34]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If we have a pointer and we want to grab the value contained in the address
    it's pointing at, we can use the *dereference operator*, denoted with the `*`
    symbol, as shown in the following code. Be careful, the `*` used in this context
    has a different meaning from the `*` used in the variable declaration.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个指针，并且想要获取它所指向的地址中的值，我们可以使用*解引用运算符*，用`*`符号表示，如下面的代码所示。请注意，在此上下文中使用的`*`与在变量声明中使用的`*`有不同的含义。
- en: '[PRE35]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When declaring a C array, the program allocates enough space to contain several
    elements of the specified size. For instance, to create an array that has 10 `double`
    values (8 bytes each), the program will reserve *8 * 10 = 80* bytes of contiguous
    space in memory. In Cython we can declare such an array using the following syntax:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当声明一个C数组时，程序会分配足够的空间来包含指定大小的多个元素。例如，要创建一个包含10个`double`值（每个8字节）的数组，程序将在内存中保留*8
    * 10 = 80*字节的连续空间。在Cython中，我们可以使用以下语法声明这样的数组：
- en: '[PRE36]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can also declare a multidimensional array, like an array with 5 rows and
    2 columns using the following syntax:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用以下语法声明一个多维数组，例如一个有5行2列的数组：
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The memory will be allocated in a single block of memory, row after row. This
    order is commonly referred to as *row-major* and is represented in the following
    figure. Arrays can also be ordered *column-mayor*, as it happens in the FORTRAN
    programming language.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 内存将在一个单独的内存块中分配，一行接一行。这种顺序通常被称为*行主序*，如下图中所示。数组也可以按*列主序*排序，正如在FORTRAN编程语言中发生的那样。
- en: '![C arrays and pointers](img/8458_03_1.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![C数组和指针](img/8458_03_1.jpg)'
- en: Tip
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Array ordering has important consequences. When iterating a C array over the
    last dimension, we access contiguous memory blocks (in our example 0, 1, 2, 3
    …)while when we iterate on the first dimension, we skip a few positions (0, 2,
    4, 6, 8, 1 … ). You should always try to access memory contiguously as this optimizes
    cache usage.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 数组排序有重要的影响。当我们对C数组的最后一个维度进行迭代时，我们访问连续的内存块（在我们的例子中是0, 1, 2, 3 …），而当我们对第一个维度进行迭代时，我们会跳过一些位置（0,
    2, 4, 6, 8, 1 …）。你应该始终尝试连续访问内存，因为这优化了缓存的使用。
- en: 'We can store and retrieve elements from the array by using standard indexing,
    C arrays don''t support fancy indexing or slices:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用标准索引来存储和检索数组中的元素，C数组不支持花哨的索引或切片：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'C arrays can also be used as pointers. The `arr` variable, in fact, is a pointer
    to the first element of the array. We can verify that the address of the first
    element of the array is the same as the address contained in the variable `arr`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: C数组也可以用作指针。实际上，`arr`变量是一个指向数组第一个元素的指针。我们可以验证数组第一个元素的地址与变量`arr`中包含的地址相同：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You should use C arrays and pointers when interfacing with existing C libraries
    or when you need a fine control over the memory. For more common use-cases you
    can employ NumPy arrays or typed memoryviews.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当与现有的C库接口或需要精细控制内存时，应使用C数组和指针。对于更常见的用例，可以使用NumPy数组或类型化内存视图。
- en: NumPy arrays
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NumPy数组
- en: NumPy arrays can be used in Cython as normal Python objects, by using their
    already optimized broadcasted operations.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组可以作为常规Python对象在Cython中使用，通过使用它们的已优化的广播操作。
- en: The problem comes when we want to efficiently iterate over the array. When we
    do an indexing operation on a NumPy array, a few other operations take place at
    the interpreter level causing a major overhead. Cython can optimize those indexing
    operations by acting directly on the underlying memory area used by NumPy arrays,
    allowing us to treat them just like C arrays.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要高效地遍历数组时，问题就出现了。当我们对NumPy数组进行索引操作时，解释器级别会发生一些其他操作，导致大量开销。Cython可以通过直接作用于NumPy数组使用的底层内存区域来优化这些索引操作，使我们能够像C数组一样处理它们。
- en: 'NumPy array support comes in the form of a `ndarray` data type. We first have
    to `cimport` the `numpy` module. We assign it to the name `c_np` to differentiate
    it from the regular `numpy` Python module as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy数组支持以`ndarray`数据类型的形式提供。我们首先必须`cimport` `numpy`模块。我们将其分配给名称`c_np`以区分它和常规的`numpy`
    Python模块，如下所示：
- en: '[PRE40]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We can now declare a NumPy array by specifying the type of the array elements
    and the number of dimensions, with a special syntax called *buffer syntax*. To
    declare a two-dimensional array of type `double` we can use the following code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以通过指定数组元素的类型和维度数，使用一种称为*缓冲区语法*的特殊语法来声明NumPy数组。要声明一个类型为`double`的两维数组，我们可以使用以下代码：
- en: '[PRE41]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: An array defined in this way will be indexed by acting directly on the underlying
    memory area; the operation will avoid the Python interpreter giving us a tremendous
    speed boost.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式定义的数组将通过直接作用于底层内存区域来进行索引；这种操作将避免Python解释器给我们带来巨大的速度提升。
- en: In the next example, we will show the usage of the buffer syntax and compare
    it with the normal Python version.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将展示缓冲区语法的用法，并将其与常规Python版本进行比较。
- en: 'We first write the `numpy_bench_py` function that increments each element of
    `py_arr` by 1000\. We declared the index `i` as integer so that we avoid the `for`
    loop overhead:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先编写了 `numpy_bench_py` 函数，该函数将 `py_arr` 的每个元素增加 1000。我们将索引 `i` 声明为整数，以避免 `for`
    循环的开销：
- en: '[PRE42]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then we write the same function using the buffer syntax. Notice that after
    we define the `c_arr` variable using `c_np.ndarray`, we can assign to it an array
    from the `numpy` Python module:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用缓冲区语法编写相同的函数。注意，在定义 `c_arr` 变量使用 `c_np.ndarray` 之后，我们可以从 `numpy` Python
    模块给它分配一个数组：
- en: '[PRE43]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can time the results using `timeit`, obtaining an impressive 50x speedup:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `timeit` 来计时结果，获得令人印象深刻的 50 倍速度提升：
- en: '[PRE44]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Typed memoryviews
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化内存视图
- en: C and NumPy arrays are both objects that act on a memory area. Cython provides
    a universal object—the *typed memoryview*—to access arrays and other data structures
    that expose the so called *buffer interface*, such as the built-ins `bytes`, `bytearray`,
    and `array.array`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: C 和 NumPy 数组都是作用于内存区域的对象。Cython 提供了一个通用的对象——*类型化内存视图*——以访问数组和其他暴露所谓 *缓冲区接口*
    的数据结构，例如内置的 `bytes`、`bytearray` 和 `array.array`。
- en: A **memoryview** is an object that maintains a reference on a certain memory
    area. It doesn't actually own the memory, but it can read and change its content
    (it is a *view*). By using typed memoryviews we can interact with both C and NumPy
    arrays in the same way.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**内存视图**是一个维护对某个内存区域的引用的对象。它实际上并不拥有内存，但它可以读取和更改其内容（它是一个 *视图*）。通过使用类型化内存视图，我们可以以相同的方式与
    C 和 NumPy 数组进行交互。'
- en: 'Memoryviews can be defined using a special syntax. We can define a memoryview
    of `int` and a 2D memoryview of `double` in the following way:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 内存视图可以使用特殊语法定义。我们可以以下这种方式定义一个 `int` 类型的内存视图和一个 2D `double` 类型的内存视图：
- en: '[PRE45]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The same syntax applies to function definitions, class attributes, and so on.
    Any object that exposes a buffer interface will automatically be bound to the
    memoryview. We can bind the memoryview to an array by the following simple assignment:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的语法适用于函数定义、类属性等。任何暴露缓冲区接口的对象都将自动绑定到内存视图。我们可以通过以下简单的赋值来绑定内存视图到数组：
- en: '[PRE46]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The new memoryview will share the data with the NumPy array. Changes in the
    array elements will be shared between the two data structures:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 新的内存视图将与 NumPy 数组共享数据。数组元素的变化将在两个数据结构之间共享：
- en: '[PRE47]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In a certain sense, the memoryview is a generalization of a NumPy array. As
    we have seen in [Chapter 2](ch02.html "Chapter 2. Fast Array Operations with NumPy"),
    *Fast Array Operations with Numpy*, slicing a NumPy array does not copy the data
    but returns a view on the same memory area.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，内存视图是 NumPy 数组的一种推广。正如我们在[第 2 章](ch02.html "第 2 章。使用 NumPy 的快速数组操作")中看到的，“使用
    NumPy 的快速数组操作”，切片 NumPy 数组不会复制数据，而是返回对同一内存区域的视图。
- en: 'Memoryviews also support array slicing with the following standard NumPy syntax:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 内存视图还支持以下标准 NumPy 语法进行数组切片：
- en: '[PRE48]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'To copy data between a memoryview and another, you can use a syntax similar
    to the slice assignment, as shown in the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要在内存视图和另一个对象之间复制数据，你可以使用类似于切片赋值的语法，如下面的代码所示：
- en: '[PRE49]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the next section, we will use the typed memoryviews to handle the arrays
    in our particle simulator application.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将使用类型化内存视图来处理我们的粒子模拟器应用程序中的数组。
- en: Particle simulator in Cython
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Cython 中的粒子模拟器
- en: Now that we have a basic understanding on how Cython works we can rewrite the
    `ParticleSimulator.evolve` method. Thanks to Cython, we can convert our loops
    in C, thus removing the overhead introduced by the Python interpreter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对 Cython 的工作原理有了基本的了解，我们可以重写 `ParticleSimulator.evolve` 方法。多亏了 Cython，我们可以将我们的循环转换为
    C，从而消除由 Python 解释器引入的开销。
- en: 'In [Chapter 2](ch02.html "Chapter 2. Fast Array Operations with NumPy"), *Fast
    Array Operations with Numpy*, we wrote a fairly efficient version of the `evolve`
    method using NumPy. We can rename the old version as `evolve_numpy` to differentiate
    it from the new version:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 2 章](ch02.html "第 2 章。使用 NumPy 的快速数组操作")中，我们编写了一个相当高效的 `evolve` 方法版本，使用
    NumPy。我们可以将旧版本重命名为 `evolve_numpy` 以区分新旧版本：
- en: '[PRE50]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We want to convert this code to Cython. Our strategy will be to take advantage
    of the fast indexing operations by removing the NumPy array broadcasting, thus
    reverting to an indexing-based algorithm. Since Cython generates efficient C code,
    we are free to use as many loops as we like without any performance penalty.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将此代码转换为 Cython。我们的策略将是利用快速索引操作，通过删除 NumPy 数组广播，从而回到基于索引的算法。由于 Cython 生成高效的
    C 代码，我们可以自由地使用尽可能多的循环，而不会产生任何性能惩罚。
- en: As a design choice, we can decide to encapsulate the loop in a function that
    we will rewrite in a Cython module called `cevolve.pyx.` The module will contain
    a single Python function `c_evolve` that will take the particle positions, the
    angular velocities, the timestep, and the number of steps as input.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计选择，我们可以决定将循环封装在一个函数中，我们将用名为 `cevolve.pyx` 的 Cython 模块重写这个函数。该模块将包含一个单一的
    Python 函数 `c_evolve`，它将接受粒子位置、角速度、时间步长和步数作为输入。
- en: At first, we are not adding typing information; we just want to isolate the
    function and make sure that we can compile our module without errors.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，我们并没有添加类型信息；我们只是想隔离函数并确保我们可以无错误地编译我们的模块。
- en: '[PRE51]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Notice that we don''t need a return value for `c_evolve`, as values are updated
    in the `r_i` array in-place. We can benchmark the untyped Cython version against
    the old NumPy version by slightly changing our benchmark function, as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为 `c_evolve` 返回值，因为值是在 `r_i` 数组中就地更新的。我们可以通过稍微改变我们的基准函数，将无类型的 Cython
    版本与旧的 NumPy 版本进行基准测试，如下所示：
- en: '[PRE52]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can time the different versions in an IPython shell:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 IPython 壳中计时不同的版本：
- en: '[PRE53]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The two versions have the same speed. Compiling the Cython module without static
    typing doesn't have any advantage over pure Python. The next step, is to declare
    the type of all the important variables so that Cython can perform its optimizations.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个版本的速度相同。编译不带静态类型的 Cython 模块并不比纯 Python 有任何优势。下一步，是声明所有重要变量的类型，以便 Cython 可以执行其优化。
- en: We can start by adding types to the function arguments. We will declare the
    arrays as typed memoryviews containing `double` values. It is worth mentioning
    that if we pass an array of `int` or `float32` type, the casting won't happen
    automatically and we would get an error.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先从添加函数参数的类型开始。我们将声明数组为包含 `double` 值的已类型化内存视图。值得一提的是，如果我们传递一个 `int` 或 `float32`
    类型的数组，转换不会自动发生，我们会得到一个错误。
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'At that point, we want to rewrite the loops over the particles and time steps.
    We can declare the iteration variables `i, j` and the particle number `nparticles`
    as `int`:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们想要重写粒子和时间步的循环。我们可以将迭代变量 `i`、`j` 和粒子数 `nparticles` 声明为 `int`：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'At this point the algorithm is very similar to the pure Python version; we
    iterate over the particles and time steps and we compute the velocity and displacement
    vectors for each particle coordinate, using the following code:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，算法与纯 Python 版本非常相似；我们遍历粒子和时间步，并计算每个粒子坐标的速度和位移向量，如下所示：
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the previous code, we added the `x`, `y`, `ang_speed`, `norm`, `vx`, `vy`,
    `dx`, and `dy` variables. To avoid the Python interpreter overhead we have to
    declare them with their corresponding types at the beginning of the function as
    follows:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们添加了 `x`、`y`、`ang_speed`、`norm`、`vx`、`vy`、`dx` 和 `dy` 变量。为了避免 Python
    解释器的开销，我们必须在函数开始时声明它们对应的类型，如下所示：
- en: '[PRE57]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'We also used a function called `sqrt` to calculate the norm. If we use the
    `sqrt` present in the `math` module or the one in `numpy`, we would again include
    a slow Python function in our critical loop, thus killing our performance. A fast
    `sqrt` is available in the standard C library, already wrapped in the `libc.math`
    Cython module:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了一个名为 `sqrt` 的函数来计算范数。如果我们使用 `math` 模块或 `numpy` 中的 `sqrt`，我们又会将一个慢速的 Python
    函数包含在我们的关键循环中，从而降低我们的性能。标准 C 库中有一个快速的 `sqrt`，已经包含在 `libc.math` Cython 模块中：
- en: '[PRE58]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'After recompiling, we can re-run our benchmark to assess our improvements,
    as follows:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编译后，我们可以重新运行我们的基准测试来评估我们的改进，如下所示：
- en: '[PRE59]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'For small particle numbers the speed-up is massive, we obtained a 40x performance
    improvement over the previous version. However, we should also try with a larger
    number of particles to test the performance scaling, as in the following code:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 对于小的粒子数，速度提升非常巨大，我们获得了比上一个版本 40 倍的性能提升。然而，我们也应该尝试使用更多的粒子来测试性能缩放，如下面的代码所示：
- en: '[PRE60]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As we increase the number of particles, the two versions get closer in speed.
    By increasing the particle size to 1000 we already decreased our speed-up to a
    more modest 6x. This is likely due to the fact that as we increase the number
    of particles the Python for-loop overhead gets less and less significant compared
    to the speed of the other operations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 随着粒子数的增加，两个版本的速度越来越接近。通过将粒子大小增加到 1000，我们已经将速度提升降低到更适度的 6 倍。这很可能是由于随着粒子数的增加，Python
    for 循环的开销与其它操作的速度相比变得越来越不显著。
- en: Profiling Cython
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析 Cython
- en: 'Cython gives us a wonderful tool to quickly find the slow spots due to the
    Python interpreter—a feature called *annotated view*. We can turn on this feature
    by compiling a Cython file with the `-a` option, using the following command line.
    Cython will generate a HTML file containing our code annotated with some useful
    information:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 给我们一个很棒的工具，可以快速找到由于 Python 解释器引起的缓慢区域——一个称为 *注释视图* 的功能。我们可以通过使用 `-a`
    选项编译 Cython 文件来打开此功能，使用以下命令行。Cython 将生成一个包含我们代码的 HTML 文件，并附有有用的注释：
- en: '[PRE61]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The HTML file displayed in the following screenshot shows our Cython file line-by-line:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示的 HTML 文件显示了我们的 Cython 文件逐行内容：
- en: '![Profiling Cython](img/8458_03_2.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![分析 Cython](img/8458_03_2.jpg)'
- en: Each line has a background color in different shades of yellow; an intense color
    means that the code has a lot of interpreter-related calls, while white lines
    gets translated to pure C. Since interpreter calls are typically slow, the objective
    is to make the function body as white as possible. By clicking on any of the lines
    we can see the C code generated by the Cython compiler. For example, the line
    `v_y = x/norm` checks that the norm is not 0, raising a `ZeroDivisionError` otherwise.
    The line `x = r_i[j, 0]` shows that Cython checks that the indexes are within
    the bounds of the array. You may notice that the last line is of a very intense
    color, by inspecting the code we can see that this is actually a glitch; the code
    refers to a boilerplate related to the end of the function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 每一行都有不同深浅的黄色背景色；深色表示代码有很多与解释器相关的调用，而白色行则被转换为纯 C 代码。由于解释器调用通常较慢，目标是使函数体尽可能为白色。通过点击任何一行，我们可以看到
    Cython 编译器生成的 C 代码。例如，行 `v_y = x/norm` 检查 norm 是否为 0，否则引发 `ZeroDivisionError`。行
    `x = r_i[j, 0]` 显示 Cython 检查索引是否在数组的边界内。您可能会注意到最后一行颜色非常强烈，通过检查代码我们可以看到这实际上是一个错误；代码引用了与函数结束相关的样板代码。
- en: 'Cython can shut down those checks to improve speed using its compiler directives.
    There are three different ways to add compiler directives:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 可以通过其编译器指令关闭这些检查以提高速度。有三种不同的方式来添加编译器指令：
- en: Using a decorator or a context manager
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用装饰器或上下文管理器
- en: Using a comment at the beginning of the file
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件开头使用注释
- en: Using the Cython command line options
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Cython 命令行选项
- en: Note
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of the Cython compiler directives you can refer to the official
    documentation at [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives)
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到 Cython 编译器指令的完整列表，链接为 [http://docs.cython.org/src/reference/compilation.html#compiler-directives](http://docs.cython.org/src/reference/compilation.html#compiler-directives)
- en: 'For example, to disable the "bounds" checking of arrays, it is sufficient to
    decorate a function with `cython.boundscheck` in the following way:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要禁用数组的 "bounds" 检查，只需以下方式装饰一个函数 `cython.boundscheck`：
- en: '[PRE62]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'We can use `cython.boundscheck` to wrap a block of code into a context manager,
    as follows:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `cython.boundscheck` 将代码块包装到上下文管理器中，如下所示：
- en: '[PRE63]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If we want to disable bounds checking for a whole module we can add the following
    line of code at the beginning of the file:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要禁用整个模块的边界检查，我们可以在文件开头添加以下代码行：
- en: '[PRE64]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To alter the directives with the command line options you can use `-X` as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行选项更改指令，您可以使用 `-X` 如下所示：
- en: '[PRE65]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can now try to avoid the extra checks in our function by disabling the `boundscheck`
    directive and enabling `cdivision` (this disables the checks for `ZeroDivisionError`)
    as in the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以尝试通过禁用 `boundscheck` 指令并启用 `cdivision`（这将禁用 `ZeroDivisionError` 的检查）来避免函数中的额外检查，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we look at the annotated view again, the loop body is completely white;
    we removed all traces of the interpreter from the loop. In the following case
    however, we didn''t obtain a performance improvement:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次查看注释视图，循环体完全为白色；我们从循环中移除了所有解释器的痕迹。然而，在以下情况下，我们没有获得性能提升：
- en: '[PRE67]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We can profile Cython code with `cProfile` by including the `profile=True`
    directive in our files. To show its usage we can write a function that calculates
    the Chebyshev distance between two arrays of coordinates. Create a file `cheb.py`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在文件中包含 `profile=True` 指令来使用 `cProfile` 对 Cython 代码进行性能分析。为了展示其用法，我们可以编写一个函数来计算两个坐标数组之间的
    Chebyshev 距离。创建一个名为 `cheb.py` 的文件：
- en: '[PRE68]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'If we try profiling this script as-is, we won''t get any statistics regarding
    the functions that we implemented in Cython. If we want to know the profile metrics
    for the `max` and `min` functions we have to add the `profile=True` option to
    the `mathlib.pyx` file, as shown in the following code:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试以当前状态分析此脚本，我们将不会得到关于我们在Cython中实现的函数的任何统计信息。如果我们想了解`max`和`min`函数的配置文件指标，我们必须将`profile=True`选项添加到`mathlib.pyx`文件中，如下所示：
- en: '[PRE69]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can now profile our script with `%prun` using IPython, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用IPython中的`%prun`来分析我们的脚本，如下所示：
- en: '[PRE70]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: From the output, we can see that the `max` function is present and is not a
    bottleneck. The problem seems to be lying in the `benchmark` function; the issue
    is likely to be the Python for-loop overhead. In this case, the best strategy
    would be rewriting the loop in NumPy or port the code to Cython.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到`max`函数存在并且不是瓶颈。问题似乎出在`benchmark`函数上；问题很可能是Python循环的开销。在这种情况下，最佳策略是将循环重写为NumPy或移植代码到Cython。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Cython will bring the speed of your programs to another level. Cython programs
    are much easier to maintain in comparison to C, thanks to the tight integration
    with Python and the availability of profiling tools.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Cython将把您程序的运行速度提升到另一个层次。与C语言相比，Cython程序更容易维护，这得益于与Python的紧密集成以及可用性分析工具。
- en: In this chapter, we introduced the basics of the Cython language and how to
    make our programs faster by adding static types. We also learned how to work with
    C arrays, NumPy arrays, and memoryviews.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了Cython语言的基础知识以及如何通过添加静态类型来使我们的程序更快。我们还学习了如何处理C数组、NumPy数组和内存视图。
- en: We optimized our particle simulator by rewriting the critical `evolve` function,
    obtaining a tremendous speed gain. Finally, we learned how to use the annotated
    view to quickly spot interpreter related calls and how to enable `cProfile` for
    Cython scripts.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过重写关键的`evolve`函数优化了我们的粒子模拟器，获得了巨大的速度提升。最后，我们学会了如何使用注释视图快速定位与解释器相关的调用，以及如何为Cython脚本启用`cProfile`。
- en: In the next chapter, we will learn the parallel processing basics and see how
    to write Python programs that take advantage of multiple processors so that you
    can write faster programs and solve larger problems.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习并行处理的基础知识，并了解如何编写利用多个处理器的Python程序，以便您可以编写更快的程序并解决更大的问题。
