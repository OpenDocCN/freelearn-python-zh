- en: Movement with Servos, Motors, and Steppers
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用舵机、电机和步进电机进行运动
- en: In the previous chapter, we covered how to measure temperature, humidity, light,
    and moisture. In this chapter, we will turn our attention to the control of motors
    and servos, which are common devices for creating physical movement and motion.
    The core concepts, circuits, and code you will learn in this chapter will open
    up a world of physical automation and robotics using your Raspberry Pi.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何测量温度、湿度、光线和湿度。在本章中，我们将把注意力转向控制电机和舵机，这些是用于创建物理运动和动作的常见设备。本章中您将学习的核心概念、电路和代码将为您打开使用树莓派进行物理自动化和机器人技术的大门。
- en: We will be learning how **Pulse Width Modulation** (**PWM**) is used to set
    the angle of a servo, and how we use an H-Bridge IC to control the direction and
    speed of a DC motor. We will look at stepper motors and how they can be controlled
    for precise movement.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将学习如何使用**脉冲宽度调制**（**PWM**）来设置舵机的角度，以及如何使用H桥集成电路来控制直流电机的方向和速度。我们将研究步进电机以及如何控制它们进行精确的运动。
- en: 'Here is what we will cover in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下内容：
- en: Using PWM to rotate a servo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PWM来旋转舵机
- en: Using an H-Bridge IC to control a motor
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用H桥集成电路控制电机
- en: Introduction to stepper motor control
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步进电机控制简介
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To perform the exercises in this chapter, you will need the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行本章的练习，您需要以下物品：
- en: Raspberry Pi 4 Model B
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 树莓派4型B
- en: Raspbian OS Buster (with desktop and recommended software)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Raspbian OS Buster（带桌面和推荐软件）
- en: Minimum Python version 3.5
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低Python版本3.5
- en: These requirements are what the code examples in this book are based on. It's
    reasonable to expect that the code examples should work without modification on
    Raspberry Pi 3 Model B or a different version of Raspbian OS as long as your Python
    version is 3.5 or higher.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这些要求是本书中代码示例的基础。可以合理地期望，只要您的Python版本为3.5或更高，代码示例应该可以在树莓派3型B或不同版本的Raspbian OS上无需修改即可运行。
- en: You will find this chapter's source code in the `chapter10` folder in the GitHub
    repository available at [https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在GitHub存储库的`chapter10`文件夹中找到本章的源代码，该存储库位于[https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT](https://github.com/PacktPublishing/Practical-Python-Programming-for-IoT)。
- en: 'You will need to execute the following commands in a terminal to set up a virtual
    environment and install the Python libraries required for the code in this chapter:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在终端中执行以下命令来设置虚拟环境并安装本章代码所需的Python库：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following dependency is installed from `requirements.txt`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下依赖项已从`requirements.txt`中安装：
- en: '**PiGPIO**: The PiGPIO GPIO library ([https://pypi.org/project/pigpio](https://pypi.org/project/pigpio))'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PiGPIO**：PiGPIO GPIO库（[https://pypi.org/project/pigpio](https://pypi.org/project/pigpio)）'
- en: 'The electronic components we will need for this chapter''s exercises are as
    follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章练习所需的电子元件如下：
- en: 1 x MG90S hobby servo (or an equivalent 3-wire 5-volt hobby servo). Reference
    datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1132104/ETC2/MG90S.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1132104/ETC2/MG90S.html)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x MG90S业余舵机（或等效的3线5伏特业余舵机）。参考资料表：[https://www.alldatasheet.com/datasheet-pdf/pdf/1132104/ETC2/MG90S.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1132104/ETC2/MG90S.html)
- en: 1 x L293D **integrated circuit** (**IC**) (make sure it has the D – that is,
    L293**D**, not L293). Reference datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/89353/TI/L293D.html](https://www.alldatasheet.com/datasheet-pdf/pdf/89353/TI/L293D.html)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x L293D **集成电路**（**IC**）（确保它带有D - 也就是L293**D**，而不是L293）。参考资料表：[https://www.alldatasheet.com/datasheet-pdf/pdf/89353/TI/L293D.html](https://www.alldatasheet.com/datasheet-pdf/pdf/89353/TI/L293D.html)
- en: 1 x 28BYJ-48 stepper motor (5 volts, 64 steps, 1:64 gearing). Note: 28BYJ-48
    comes in 5-volt and 12-volt varieties and different configuration steps and gearings. Reference
    datasheet: [https://www.alldatasheet.com/datasheet-pdf/pdf/1132391/ETC1/28BYJ-48.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1132391/ETC1/28BYJ-48.html)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 x 28BYJ-48步进电机（5伏特，64步，1:64齿轮）。注意：28BYJ-48有5伏特和12伏特两种，不同的配置步数和齿轮。参考资料表：[https://www.alldatasheet.com/datasheet-pdf/pdf/1132391/ETC1/28BYJ-48.html](https://www.alldatasheet.com/datasheet-pdf/pdf/1132391/ETC1/28BYJ-48.html)
- en: 2 x size 130 (R130) DC motor rated 3-6 volts (ideally with a stall current <
    800 mA), or alternate DC motor with compatible voltage and current ratings
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 x 尺寸130（R130）直流电机额定为3-6伏特（最好具有静态电流<800毫安），或具有兼容电压和电流额定值的替代直流电机
- en: External power source – at a minimum, a 3.3 V/5 V breadboard-mountable power
    supply
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部电源 - 至少是3.3V/5V的面包板可安装电源
- en: Let's commence by learning how to use a servo with our Raspberry Pi, Python,
    and PiGPIO.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始学习如何在树莓派、Python和PiGPIO中使用舵机。
- en: Using PWM to rotate a servo
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PWM来旋转舵机
- en: Common servomotors, or servos, are internally geared motors that allow you to
    rotate its shaft to a precise angle within a 180-degree arc. They are a core component
    of industrial robots, and toys alike, and we're all familiar with hobby servos
    found in toys such as radio-controlled cars, planes, and drones.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的舵机或舵机是内部齿轮电机，允许您将其轴精确旋转到180度弧度内的特定角度。它们是工业机器人和玩具的核心组件，我们都熟悉玩具中的舵机，如遥控汽车、飞机和无人机中的舵机。
- en: 'Pictured in *Figure 10.1* are a full-size hobby-style servo, a micro servo,
    and a set of header pins, which are useful to help connect a servo to a breadboard,
    which we will need to do later in this section as we build our circuit:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图10.1*中显示了一个全尺寸的业余风格舵机、一个微型舵机和一组排针，这些对于帮助将舵机连接到面包板非常有用，我们将在本节后面构建电路时需要用到：
- en: '![](assets/2de779f7-fcbb-40f5-830f-0182445471ba.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2de779f7-fcbb-40f5-830f-0182445471ba.png)'
- en: Figure 10.1 – Servos
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 - 舵机
- en: The great feature of servos is that they are essentially a Plug'n'Play style
    device – after we connect them to the power supply, we just need to send them
    a PWM signal that encodes the angle we want the servo to rotate to, and presto!
    We're done. No ICs, no transistors, or any other external circuitry. What's even
    better is that servo control is so common that many GPIO libraries – including
    PiGPIO – include convenience methods for their control.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 舵机的一个很好的特性是它们基本上是一种即插即用的设备——在我们将它们连接到电源后，我们只需要发送一个编码了我们想要舵机旋转到的角度的PWM信号，然后就完成了。没有集成电路、没有晶体管，也没有任何其他外部电路。更好的是，舵机控制是如此普遍，以至于许多GPIO库——包括PiGPIO——都包括了方便的控制方法。
- en: Let's start our servo exploration by connecting one to our Raspberry Pi.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过连接一个舵机到我们的树莓派来开始我们的舵机探索。
- en: Connecting a servo to your Raspberry Pi
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接舵机到你的树莓派
- en: 'Our first task for our servo example is to wire it up to a power source and
    our Raspberry Pi. A schematic representing this wiring is shown here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们舵机示例的第一个任务是将其连接到电源和我们的树莓派。显示这种布线的原理图如下：
- en: '![](assets/e4baeb96-c9b1-447e-93e6-e6b9e0e9d56e.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e4baeb96-c9b1-447e-93e6-e6b9e0e9d56e.png)'
- en: Figure 10.2 – Servo wiring schematic
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 舵机布线原理图
- en: 'Let''s get started wiring our servo using a breadboard, as shown:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用面包板布线我们的舵机，如下所示：
- en: '![](assets/39734f78-1f47-465b-b1bb-b622f221f12c.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/39734f78-1f47-465b-b1bb-b622f221f12c.png)'
- en: Figure 10.3 – Servo breadboard layout
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 舵机面包板布局
- en: Before we step through the wiring procedure, first I want to briefly discuss
    the wire colors coming out of a servo. While servo wire colors are somewhat standard,
    they can vary between different manufacturers and servos. Use the following pointers
    when connecting your servo at *steps 4*, *5*, and *6*. If your servo has colored
    wires that I do not list in the following list, you will need to consult the datasheet
    for your servo.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们逐步介绍布线程序之前，我首先想简要讨论一下舵机出线的颜色。虽然舵机线的颜色有些是标准的，但在不同的制造商和舵机之间可能会有所不同。在连接你的舵机时，请使用以下提示在*步骤4*、*5*和*6*。如果你的舵机有我没有列在下面列表中的颜色线，你需要查阅你舵机的数据表。
- en: 'Common servo wire colors are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的舵机线颜色如下：
- en: The brown or black wire connects to GND
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 棕色或黑色的线连接到GND
- en: The red wire connects to +5-volts
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 红色线连接到+5伏
- en: The orange, yellow, white, or blue wire is the signal/PWM input wire that connects
    to a GPIO pin
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 橙色、黄色、白色或蓝色的线是信号/PWM输入线，连接到GPIO引脚
- en: 'Here are the steps to follow to create your breadboard build. The step numbers
    match the numbers in the black circles in *Figure 10.3*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建面包板构建的步骤。步骤编号与*图10.3*中的黑色圆圈中的数字相匹配：
- en: Connect the left-hand side and right-hand side negative power rails together.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将左侧和右侧的负电源轨道连接在一起。
- en: Connect a GND pin on your Raspberry Pi to the left-hand side negative power
    rail.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派上的GND引脚连接到左侧的负电源轨道。
- en: Connect the servo into the breadboard. As mentioned previously and shown in *Figure
    10.1*, you will need a set of header pins (or alternatively, male-to-male jumper
    cables) to connect your servo to your breadboard.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将舵机连接到面包板。如前所述，并如*图10.1*所示，你需要一组排针（或者，作为替代，公对公跳线）来将你的舵机连接到你的面包板。
- en: Connect the black wire (negative/GND) from the servo to the negative rail of
    the right-hand side power rail.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将舵机的黑色线（负/GND）连接到右侧电源轨道的负极。
- en: Connect the red wire (5-volt power) from the servo to the positive rail of the
    right-hand side power rail.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将舵机的红色线（5伏电源）连接到右侧电源轨道的正极。
- en: Connect the signal wire from the servo to GPIO 21 on your Raspberry Pi.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将舵机的信号线连接到树莓派上的GPIO 21。
- en: Connect the positive output terminal of a 5-volt power supply to the positive
    rail of the right-hand side power rail.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将外部5伏电源的正输出端连接到右侧电源轨道的正极。
- en: Connect the negative output terminal of the power supply to the negative rail
    of the right-hand side power rail.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源供应的负输出端连接到右侧电源轨道的负极。
- en: You will need to use an external 5-volt power source (*steps 7* and *8*) to
    power your servo. A small servo such as an MG90S uses ~200mA as it rotates with
    no load on the shaft/horn (the horn is the arm connected to the shaft of the servo),
    and ~400+mA maximum current if you attach a heavy load to the horn or you forcefully
    stop a rotation. Drawing this current directly from your Raspberry Pi's 5-volt
    pin may be enough to cause it to reset.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用外部的5伏电源(*步骤7*和*8*)来为你的舵机供电。像MG90S这样的小型舵机在没有负载的情况下旋转时使用的电流约为200毫安，如果你在舵机上连接了重负载或者强行阻止旋转，最大电流为400毫安。直接从你的树莓派的5伏引脚中提取这个电流可能足以导致它重置。
- en: Many cheap car-like toys have a hard left/right mock servo for their steering
    mechanisms. It might look like a servo on the outside, but in truth, it's just
    a basic DC motor with some gears and a spring that create the hard left/right
    steering angle. It's the spring that returns the servo to center when the motor
    is not engaged. If you do not have granular control over the angle, it's not a
    true servo.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 许多廉价的类似汽车的玩具都有一个硬左/右模拟舵机用于他们的转向机构。它可能看起来像一个舵机，但实际上，它只是一个带有一些齿轮和弹簧的基本直流电机，用于创建硬左/右转向角度。当电机没有参与时，弹簧会将舵机返回到中心。如果你不能对角度进行精细控制，那它就不是一个真正的舵机。
- en: Before we get into some code, we'll take a quick look at how PWM is used to
    control a servo. This will give you some background on what's happening when we
    get to the code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写一些代码之前，让我们快速看一下PWM是如何用来控制舵机的。这将让你了解当我们到达代码时发生了什么。
- en: How a servo is controlled using PWM
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何使用PWM控制舵机
- en: 'Servos typically require around a 50 Hz PWM signal (some variation around 50
    Hz is okay, but we''ll stick with 50 Hz as this is the common reference point),
    and a pulse width between 1.0 milliseconds and 2.0 milliseconds that determines
    the angle of rotation. The relation between pulse widths, duty cycles, and angle
    is illustrated in *Figure 10.4*. Don''t worry if all this does not sink in just
    yet. It should become more clear as we see our servo in action and review our
    servo-related code in the next section:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 舵机通常需要大约50赫兹的PWM信号（50赫兹左右的一些变化是可以的，但我们将坚持使用50赫兹作为常见参考点），以及在1.0毫秒和2.0毫秒之间的脉冲宽度来确定旋转角度。脉冲宽度、占空比和角度之间的关系在*图10.4*中有所说明。如果你现在还没有完全理解，不要担心。当我们看到我们的舵机动作并在下一节中审查与舵机相关的代码时，这些应该会更清楚：
- en: '![](assets/ba7e9381-16b5-46d7-bda5-9ed6e7582115.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ba7e9381-16b5-46d7-bda5-9ed6e7582115.png)'
- en: Figure 10.4 – Servo's pulse width, duty cycle, and angles
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 - 舵机的脉冲宽度、占空比和角度
- en: We have not covered pulse width in relation to our earlier coverage of PWM;
    however, it's just another way of describing the duty cycle.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前没有涵盖脉冲宽度与我们之前对PWM的覆盖范围的关系；然而，这只是描述占空比的另一种方式。
- en: 'Here is an example:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: If we have a PWM signal at 50 Hz (that is, 50 cycles per second), then this
    means that 1 PWM cycle takes *1 / 50 = 0.02* seconds, or 20 ms.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们有一个50赫兹的PWM信号（即每秒50个周期），那么这意味着1个PWM周期需要*1 / 50 = 0.02*秒，或者20毫秒。
- en: Thus, a pulse width of 1.5 ms expressed as a duty cycle is *1.5 ms / 20 ms =
    0.075*, multiplied by 100 gives us a duty cycle of 7.5%.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因此，以1.5毫秒的脉冲宽度表示的占空比为*1.5毫秒/20毫秒=0.075*，乘以100得到占空比为7.5%。
- en: 'To work backward, we have the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 往回推，我们有以下内容：
- en: A duty cycle of 7.5% divided by 100 is 0.075\. Then, *0.075 x 20 ms = 1.5 ms
    – *that is, a 1.5 ms pulse width.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 7.5%的占空比除以100是0.075。然后，*0.075 x 20毫秒=1.5毫秒*，即1.5毫秒的脉冲宽度。
- en: 'If you''d prefer a formula to relate *pulse width*, *frequency*, and *duty
    cycle*, here it is:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢一个公式来描述*脉冲宽度*、*频率*和*占空比*的关系，这里有一个：
- en: '![](assets/5a2e6517-ec08-4b37-8577-1529da534f55.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/5a2e6517-ec08-4b37-8577-1529da534f55.png)'
- en: 'To convert back, we have the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要转换回来，我们有以下内容：
- en: '![](assets/2290e598-7bf5-4ddf-b717-e37eab32ec44.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/2290e598-7bf5-4ddf-b717-e37eab32ec44.png)'
- en: Okay, enough with the math. Let's run and review the Python code to make our
    servo move.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，数学的部分就到此为止。让我们运行并查看Python代码来让我们的舵机移动。
- en: Running and exploring the servo code
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和探索舵机代码
- en: The code we are about to run can be found in the `chapter10/servo.py` file.
    I recommend reviewing the source code before proceeding so that you have an overall
    idea about what the file contains.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将运行的代码可以在`chapter10/servo.py`文件中找到。我建议在继续之前先查看源代码，以便对文件的内容有一个整体的了解。
- en: When you run the code found in the `chapter10/servo.py` file, your servo should
    rotate left and then right several times.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`chapter10/servo.py`文件中的代码时，你的舵机应该会左右旋转几次。
- en: 'Let''s look at the code, starting with some pulse width variables defined at
    line 1:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从代码开始，首先是在第1行定义的一些脉冲宽度变量：
- en: '[PRE1]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These pulse widths represent our servo's extreme left and right rotation.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脉冲宽度代表了我们舵机的极端左右旋转。
- en: Note that the `LEFT_PULSE` and `RIGHT_PULSE` values are in nanoseconds, as this
    is the unit used by the PiGPIO servo functions.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`LEFT_PULSE`和`RIGHT_PULSE`的值以纳秒为单位，因为这是PiGPIO舵机函数使用的单位。
- en: These values of `LEFT_PULSE = 1000` and  `RIGHT_PULSE = 2000` are the perfect
    world values that you will see sighted often. In reality, you may need to make
    slight adjustments to these variables to get the full rotation out of your servo.
    For example, my test servo needed the `LEFT_PULSE = 600` and ` RIGHT_PULSE = 2450` values to
    achieve full rotation. You'll know if you have adjusted too far if your servo
    motor stays engaged and makes a groaning noise when it is at full left or right
    rotation. If this happens, disconnect power immediately to prevent damage to the
    servo and readjust your values.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`LEFT_PULSE = 1000`和`RIGHT_PULSE = 2000`这些值是你经常看到的完美世界值。实际上，你可能需要对这些变量进行轻微调整，以便使舵机完全旋转。例如，我的测试舵机需要`LEFT_PULSE
    = 600`和`RIGHT_PULSE = 2450`这些值才能实现完全旋转。如果你调整得太远，舵机在完全左转或右转时会保持连接并发出嘎吱嘎吱的声音。如果发生这种情况，立即断开电源以防止对舵机造成损坏，并重新调整数值。'
- en: If your serve rotates backward – for example, it rotates to the left when you
    expect it to rotate to the right – swap the values for  `LEFT_PULSE` and `RIGHT_PULSE`.
    Or, just turn your servo upside down.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的舵机向后旋转 - 例如，当你期望它向右旋转时它向左旋转 - 交换`LEFT_PULSE`和`RIGHT_PULSE`的值。或者，只需将你的舵机倒置。
- en: 'At line 2, we define the `MOVEMENT_DELAY_SECS= 0.5` variable, which we need
    later to add a delay between servo movements:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2行，我们定义了`MOVEMENT_DELAY_SECS= 0.5`变量，我们稍后需要在舵机移动之间添加延迟：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you work with servos and send them a PWM rotation signal, you will find that
    they behave asynchronously. That is, the code does not block until the servo finishes
    its rotation. If we intend to make many rapid servo movements that you want to
    complete in full, we must add a short delay to ensure the servo has time to complete
    the rotation. An example of this is found in the `sweep()` function we will cover
    shortly. The delay of 0.5 seconds is only a suggestion, so feel free to experiment
    with different numbers.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用舵机并发送PWM旋转信号时，你会发现它们的行为是异步的。也就是说，代码不会阻塞，直到舵机完成旋转。如果我们打算进行许多快速的舵机移动，并希望它们完全完成，我们必须添加一个短暂的延迟，以确保舵机有时间完成旋转。我们很快将介绍的`sweep()`函数中就有一个例子。0.5秒的延迟只是一个建议，所以可以随意尝试不同的数字。
- en: 'Starting at line 3, we define three basic functions to control our servo:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从第3行开始，我们定义了三个基本函数来控制我们的舵机：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `left()` function simply sets the PWM pulse width to `LEFT_PULSE` on the
    servo's GPIO pin using the PiGPIO `set_servo_pulsewidth()` method. This is a convenience function for
    servo control offered by PiGPIO as a practical alternative to using the `set_PWM_dutycycle()` and `set_PWM_frequency()` methods that
    we have seen in many previous chapters. We'll say more about these methods after
    we've reviewed the code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`left()`函数只是使用PiGPIO的`set_servo_pulsewidth()`方法将PWM脉冲宽度设置为`LEFT_PULSE`在伺服的GPIO引脚上。这是PiGPIO提供的伺服控制的便利函数，作为使用我们在许多先前章节中看到的`set_PWM_dutycycle()`和`set_PWM_frequency()`方法的实际替代方案。在我们回顾了代码之后，我们将更多地谈论这些方法。'
- en: The `center()` and `right()` functions perform their respective equivalent action
    to `left()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`center()`和`right()`函数执行与`left()`相应的等效操作。'
- en: If you rotate your servo to a specified angle and try to move the horn with
    your hand, you will notice that the servo resists the change. This is because
    the servo is continuously receiving (at a rate of 50 Hz) the last pulse set via
    `set_servo_pulsewidth()`, so it resists any attempt to change its set position.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将伺服旋转到指定的角度并尝试用手移动齿轮，您会注意到伺服会抵抗变化。这是因为伺服持续以50赫兹的速率接收通过`set_servo_pulsewidth()`设置的最后一个脉冲，因此它会抵制任何试图改变其设置位置的尝试。
- en: In the previous section, when we wired the servo to your Raspberry Pi, we mentioned
    the servo's maximum current of ~400+mA. The preceding paragraph is an example
    where this maximum current is drawn by the servo. When the servo is receiving
    its pulse width instruction, it resists any force to change its position, resulting
    in more current usage. It is similar in principle to the stall current of a DC
    motor we discussed back in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml),
    *Turning Things On and Off*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中，当我们将伺服连接到树莓派时，我们提到了伺服的最大电流约为~400+mA。前面的段落是一个例子，其中伺服吸取了这个最大电流。当伺服接收到脉冲宽度指令时，它会抵抗任何改变其位置的力，导致更多的电流使用。这与我们在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中讨论的直流电机的空载电流原理类似，*打开和关闭物品*。
- en: 'If you set the servo''s pulse width to zero, as we do in the `idle()` function
    shown at line 4, you will now find that you can freely rotate the servo by hand
    with little force. When my test servo was idle (or at rest), it used approximately
    6.5 mA:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将伺服的脉冲宽度设置为零，就像我们在第4行的`idle()`函数中所做的那样，您现在会发现可以轻松地用手旋转伺服。当我的测试伺服处于空闲状态（或静止状态）时，它大约使用了6.5毫安：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So far, we''ve seen how to make the servo rotate to the left, center, and right,
    but what if we want to rotate it to a particular angle? Easy(-ish), we just need
    a little math, as shown in the `angle()` function at line 5:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了如何使伺服向左、中间和右边旋转，但是如果我们想将其旋转到特定的角度怎么办？很简单（有点），我们只需要一点数学，就像在第5行的`angle()`函数中所示：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `angle()` function takes an angle in the range -90 to +90 degrees (0 degrees being
    center), works out the ratio of our input angle relative to the 180-degree range
    of our servo at line 6, before deriving the corresponding pulse width at line
    7\. This pulse width is then sent to the servo and it will adjust its angle accordingly.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`angle()`函数接受-90到+90度范围内的角度（0度为中心），在第6行计算出我们输入角度相对于我们伺服180度范围的比率，然后在第7行推导出相应的脉冲宽度。然后将此脉冲宽度发送到伺服，它将相应地调整其角度。'
- en: 'Finally, we encounter the `sweep()` function at line 10\. This is the function
    that provided the left/right sweeping movement of the servo when you ran this
    code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在第10行遇到了`sweep()`函数。这是在您运行此代码时提供了伺服左右扫描运动的函数：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this function, we see the use of `sleep(MOVEMENT_DELAY_SECS)`, which is necessary
    to give the servo time to complete each rotation request due to the asynchronous
    nature of servos. If you were to comment out the two `sleep()` calls, you will
    find that the servo rotates to the left and stops. This happens because as the
    `for` loop iterates (without `sleep()`), each `left()` call overrides the previous `right()` call,
    and so on, and it's `left()` that is called last before the loop completes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们看到了`sleep(MOVEMENT_DELAY_SECS)`的使用，这是必要的，以便给伺服完成每个旋转请求的时间，因为伺服的异步性质。如果您注释掉两个`sleep()`调用，您会发现伺服向左旋转并停止。这是因为当`for`循环迭代（没有`sleep()`）时，每个`left()`调用会覆盖先前的`right()`调用，依此类推，最后在循环完成之前调用的是`left()`。
- en: We've just seen how to control a servo using PiGPIO and its servo-orientated
    PWM function, `set_servo_pulsewidth()`. If you are interested in how a servo implementation
    looks with the `set_PWM_frequency()` and `set_PWM_dutycycle()` functions, you'll
    find a file in the `chapter10` folder named `servo_alt.py`. It's functionally
    equivalent to the `servo.py` code we have just covered.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何使用PiGPIO及其面向伺服的PWM函数`set_servo_pulsewidth()`来控制伺服。如果您对使用`set_PWM_frequency()`和`set_PWM_dutycycle()`函数实现伺服的实现感兴趣，您会在`chapter10`文件夹中找到一个名为`servo_alt.py`的文件。它在功能上等同于我们刚刚介绍的`servo.py`代码。
- en: This now concludes our servo examples. The knowledge you have learned together
    with the code examples will provide you with everything you need to start using
    servos in your own projects! Our focus has been on using angular motion servos;
    however, the core of what you have learned will also be adaptable with some trial
    and error and experimenting (mostly around identifying the correct pulse widths)
    for use with a *continuous rotation servo*, which I'll briefly mention in the
    next section.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就结束了我们的伺服示例。您学到的知识以及代码示例将为您提供开始在自己的项目中使用伺服所需的一切！我们的重点是使用角度运动伺服；然而，您学到的核心内容也可以通过一些试验和实验（主要是确定正确的脉冲宽度）来适应*连续旋转伺服*，我将在下一节中简要提到。
- en: Let's conclude our discussion of servos with a brief consideration of the different
    types of servos.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用一个简短的考虑来结束我们对伺服的讨论，讨论不同类型的伺服。
- en: Different types of servos
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同类型的伺服
- en: 'Our example used a common 3-wire, 180-degree angular servo. While this is a
    very common type of servo, there are other variations as well, including continuous
    rotation servos, servos with more than three wires, and special purpose servos:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例使用了常见的3线，180度角舵机。虽然这是一种非常常见的舵机类型，但也有其他变体，包括连续旋转舵机，具有三根以上线的舵机和特殊用途舵机：
- en: '**Continuous rotation servos**:Have 3 wires and work on the same PWM principles
    as a 3-wire angular servo, except the PWM pulse width determines the rotational
    *direction* (clockwise/counter-clockwise) and *speed* of the servo.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连续旋转舵机**：有3根线，使用与3线角度舵机相同的PWM原理，只是PWM脉冲宽度确定了舵机的旋转*方向*（顺时针/逆时针）和*速度*。'
- en: Due to their internal control circuitry and gearing, continuous rotation servos
    are a convenient low-speed/high-torque alternative to a DC motor and H-Bridge
    controller (which we will be covering in the next section).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们的内部控制电路和齿轮装置，连续旋转舵机是直流电机和H-Bridge控制器的便捷低速/高扭矩替代品（我们将在下一节中介绍）。
- en: '**4-wire servos**: These come with one set of three wires and a fourth loose
    wire. This fourth wire is an analog output of the servo that can be used to detect
    the angle. It''s useful if you need to know your servo''s resting angle when you
    start your program.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4线舵机**：这些舵机有一组三根线和一根松散的第四根线。这第四根线是舵机的模拟输出，可用于检测角度。如果您需要在启动程序时知道舵机的静止角度，这将非常有用。'
- en: Servos track their position using an embedded potentiometer. This fourth wire
    is attached to such a potentiometer.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 舵机使用嵌入电位器来跟踪它们的位置。第四根线连接到这样的电位器。
- en: '**Special purpose or heavy-duty industrial use servos**: Have different wiring
    configurations and usage requirements – for example, they may not have the internal
    circuitry to decode PWM signals and require the user to supply and create the
    circuit to perform this function.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特殊用途或重型工业用途舵机**：具有不同的接线配置和使用要求-例如，它们可能没有内部电路来解码PWM信号，并且需要用户提供和创建电路来执行此功能。'
- en: We have now learned how common hobby-style servos work, and also discovered
    how to set their angle of rotation in Python using PWM. In the next section, we
    will learn more about DC motors and how to control them using an IC known as an
    H-Bridge.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经了解了常见的业余舵机的工作原理，并且还发现了如何使用PWM在Python中设置它们的旋转角度。在下一节中，我们将学习更多关于直流电机以及如何使用H-Bridge这种集成电路来控制它们。
- en: Using an H-Bridge IC to control a motor
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用H-Bridge集成电路来控制电机
- en: In [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning Things
    On and Off*, we learned how to use a transistor to turn a DC motor on and off,
    and we also saw how to control the motor's speed using PWM. One limitation of
    our single transistor circuit was that the motor only rotated in one direction. In
    this section, we will explore a way to let us spin our motor in both the forward
    and backward directions – using what is known as an *H-Bridge* circuit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中，*打开和关闭东西*，我们学习了如何使用晶体管打开和关闭直流电机，并且还看到了如何使用PWM控制电机的速度。我们单个晶体管电路的一个限制是电机只能单向旋转。在本节中，我们将探讨一种让我们能够让电机在前后两个方向旋转的方法-使用所谓的*H-Bridge*电路。
- en: The H in H-Bridge comes from the perception that a basic H-Bridge circuit schematic
    (created from four individual transistors) make a letter H.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: H-Bridge中的H来自于基本H-Bridge电路原理图（由四个单独的晶体管创建）形成字母H的感知。
- en: If you search around sites such as eBay for an H-Bridge module, you will identify
    many ready-made modules for the same purpose that we will cover in this section.
    What we will do is build a replica module on our breadboard. Once you have your
    breadboard replica working and understand how it works, you will be in a position
    to understand the construction of these ready-made modules.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在eBay等网站上搜索H-Bridge模块，您将会发现许多相同目的的现成模块，我们将在本节中介绍。我们将在面包板上构建一个复制模块。一旦您的面包板复制品运行并了解其工作原理，您就能够理解这些现成模块的构造。
- en: 'We can create an H-Bridge to drive our motor in a few ways:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式创建H-Bridge来驱动我们的电机：
- en: Just use a pre-built module (modules and ICs may also be called or labeled motor
    drivers, or motor controllers). This is the easiest way.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只需使用预制模块（模块和集成电路也可以称为电机驱动器或电机控制器）。这是最简单的方法。
- en: Create an H-Bridge circuit using discrete components – for example, four transistors,
    many diodes, a handful of resistors, and a lot of wire to connect them all. This
    is the hardest way.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用离散元件创建H-Bridge电路-例如，四个晶体管，许多二极管，一些电阻和大量的导线连接它们。这是最困难的方法。
- en: Use an IC (that internally combines all the necessary discrete parts).
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集成电路（内部组合了所有必要的离散部件）。
- en: A servo, just like we used in the previous section, is made up of a DC motor
    connected to an H-Bridge-style circuit that allows the motor to move forward and
    backward to create the servo's left and right rotation.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 舵机，就像我们在上一节中使用的那样，由连接到H-Bridge样式电路的直流电机组成，该电路允许电机前后移动，以创建舵机的左右旋转。
- en: We will opt for the last option and use an L293D, which is a common and low-cost
    H-Bridge IC that we can use to build a motor controller circuit.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将选择最后一种选择，并使用L293D，这是一种常见且低成本的H-Bridge集成电路，我们可以用它来构建电机控制电路。
- en: 'Here are the basic specifications for the L293D extracted from its datasheet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是从L293D的数据表中提取的基本规格：
- en: Continuous current of 600 mA, 1.2 A peak/pulsed. As a reminder, we explored
    motors and current use in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning
    Things On and Off.*
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续电流为600毫安，峰值/脉冲为1.2安。作为提醒，我们在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中探讨了电机和电流的使用，*打开和关闭东西*。
- en: It can control a motor with a voltage between 4.5 volts and 36 volts.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以控制电压在4.5伏至36伏之间的电机。
- en: It includes internal fly-back diodes, so we do not need to add our own. This
    is what the D means in L293**D**. If you need a refresher on fly-back diodes,
    please also see [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning
    Things On and Off.*
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括内部飞回二极管，因此我们不需要添加自己的。这就是L293**D**中D的含义。如果您需要复习飞回二极管，请参阅[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)，*打开和关闭*。
- en: It comprises two channels, so it is capable of driving two DC motors simultaneously.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它包括两个通道，因此可以同时驱动两个直流电机。
- en: If you are looking to purchase a different motor driver IC for a project (for
    example, if you need one with more current), remember to check the datasheet to
    see whether it has fly-back diodes embedded, or else you will need to provide
    your own.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想购买一个不同的电机驱动IC用于项目（例如，如果您需要一个更大电流的IC），请记住要检查数据表，看看它是否嵌入了飞回二极管，否则您将需要自己提供。
- en: Let's build our circuit to control our motors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们建立电路来控制我们的电机。
- en: Building the motor driver circuit
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建电机驱动电路
- en: 'In this section, we will build our H-Bridge circuit that we will use to control
    two DC motors. The following schematic describes the circuit we will create. While
    this circuit looks busy, most of our work will be simply connecting the legs of
    the L293D IC to our Raspberry Pi, power source, and motors:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将构建H桥电路，用于控制两个直流电机。以下原理图描述了我们将创建的电路。虽然这个电路看起来很繁忙，但我们的大部分工作将只是连接L293D
    IC的引脚到树莓派、电源和电机：
- en: '![](assets/655775d0-d70a-48ac-927a-ccd34687f67a.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/655775d0-d70a-48ac-927a-ccd34687f67a.png)'
- en: Figure 10.5 – L293D and motor schematic diagram
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 - L293D和电机原理图
- en: As there are a lot of wire connections to get through, we will build this circuit
    on our breadboard in four parts.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有很多导线连接要完成，我们将在面包板上分四部分构建这个电路。
- en: We will be using an IC in our circuit build. Many ICs (including the L293D)
    are sensitive to static **electricity discharge** (**ESD**), and if exposed to
    static discharge, they can be damaged. As a general rule, you should avoid touching
    the pins/legs of an IC with your fingers so that any static charge you have in
    your body does not get discharged to the IC.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在电路构建中使用一个IC。许多IC（包括L293D）对静电放电（ESD）敏感，如果暴露于静电放电，它们可能会受到损坏。一般规则是，您应该避免用手指触摸IC的引脚/腿，以免您体内的任何静电荷被释放到IC上。
- en: 'Let''s get started with the first part, as illustrated in the following diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一部分开始，如下图所示：
- en: '![](assets/de40640a-3ebe-4491-ac76-5062cc6c3766.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/de40640a-3ebe-4491-ac76-5062cc6c3766.png)'
- en: Figure 10.6 – L293D breadboard layout (Part 1 of 3)
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 - L293D面包板布局（第1部分，共3部分）
- en: 'Here are the steps to follow to start our breadboard build. The step numbers
    match the numbers in black circles in *Figure 10.6*:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们开始面包板构建的步骤。步骤编号与*图10.6*中黑色圆圈中的数字相匹配：
- en: Start by placing the L293D IC in your breadboard, making sure that that IC is
    orientated correctly with pin/leg 1 facing toward the top of your breadboard.
    Pin 1 of an IC is commonly indicated by a small circular indentation or dot beside
    the pin. In our illustration, this dot is white for visibility; however, it'll
    most likely be the same color as the casing on your IC. In the absence of a dot,
    there is also commonly a cutout section on one end of an IC. Pin 1 is the top-left
    pin when you hold the IC with the cutout facing *away* from you.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先将L293D IC放入面包板中，确保IC的引脚/腿朝向面包板顶部。IC的引脚1通常由引脚旁边的小圆凹陷或点指示。在我们的插图中，为了方便查看，这个点是白色的；然而，它很可能与IC的外壳颜色相同。如果没有点，IC的一端通常也有一个凹口部分。当您将IC的凹口朝向远离您时，引脚1是顶部左侧的引脚。
- en: Connect a 5-volt pin on your Raspberry Pi to the positive rail of the left-hand
    side power rail.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的5V引脚连接到左侧电源轨的正电源。
- en: Connect a GND pin on your Raspberry Pi to the negative rail of the left-hand
    side power rail.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将树莓派的GND引脚连接到左侧电源轨的负电源。
- en: Connect GPIO 18 to pin 1 of the L293D.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GPIO 18连接到L293D的引脚1。
- en: Connect GPIO 23 to pin 2 of the L293D.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GPIO 23连接到L293D的引脚2。
- en: Connect GPIO 24 to pin 7 of the L293D.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GPIO 24连接到L293D的引脚7。
- en: Connect a jumper lead to pin 3 of the L293D. The other end of this lead (labeled
    **Output 1Y**) is not connected to anything for the moment.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将跳线引脚连接到L293D的引脚3。此引脚的另一端（标有**Output 1Y**）目前未连接到任何东西。
- en: Connect a jumper lead to pin 6 of the L293D. The other end of this lead (labeled
    **Output 2Y**) is not connected to anything for the moment.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将跳线引脚连接到L293D的引脚6。此引脚的另一端（标有**Output 2Y**）目前未连接到任何东西。
- en: Using a jumper wire, connect pin 4 and pin 5 on the L293D together.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线，将L293D的引脚4和引脚5连接在一起。
- en: Finally, connect pin 4 and pin 5 of the L293D to the negative rail of the left-hand
    side power rail.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将L293D的引脚4和引脚5连接到左侧电源轨的负电源。
- en: The bulk of the work we just performed involved the wiring of *channel 1* of
    the L293D. As a reminder, the L293D has two output channels, which, for the content
    in this section, means we can control two DC motors.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成的大部分工作涉及L293D的*通道1*的布线。作为提醒，L293D有两个输出通道，这意味着我们可以控制两个直流电机。
- en: If you refer back to *Figure 10.6*, you will notice the wires (placed at *steps
    7* and *8*) comprise the output for channel 1\. Later in this section, we will
    attach a motor to these wires. Furthermore, in the diagram, you will notice that
    GPIOs 18, 23, and 24 are labeled as Channel 1 Control GPIOs*.* We will learn how
    these GPIOs are used to control the larger channel 1 motor when we discuss the
    code that accompanies this circuit.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您回顾*图10.6*，您会注意到（放置在*步骤7*和*8*处）的导线构成了通道1的输出。在本节的后面，我们将把电机连接到这些导线。此外，在图中，您会注意到GPIO
    18、23和24被标记为通道1控制GPIOs。我们将学习这些GPIO是如何用于控制通道1电机的，当我们讨论伴随这个电路的代码时。
- en: 'Moving on, the next part of our build largely involves wiring up channel 2
    of the L293D. This is more or less a mirror of the wiring we just performed:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们构建的下一部分主要涉及布线L293D的通道2。这更多或多是我们刚刚执行的布线的镜像：
- en: '![](assets/f520647e-b1bc-49df-b7d9-7ba16d839315.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/f520647e-b1bc-49df-b7d9-7ba16d839315.png)'
- en: Figure 10.7 – L293D breadboard layout (Part 2 of 3)
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.7 - L293D面包板布局（第2部分）
- en: 'Here are the steps to follow to complete the second part of our breadboard
    build. The step numbers match the numbers in black circles in *Figure 10.7*:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成我们面包板搭建的第二部分所需遵循的步骤。 步骤编号与*图10.7*中黑色圆圈中的数字相匹配：
- en: Connect pin 16 of the L293D to the positive rail of the left-hand side power
    rail. This 5-volt connection to pin 16 provides the power for the *IC's internal
    circuitry* – it is not the power source for the channel outputs (that is our motors).
    We will connect the external power source to the IC in part 3 of the build for
    powering the channels' motors.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将L293D的引脚16连接到左侧电源轨道的正轨道。 连接到引脚16的这个5伏电源为*IC的内部电路*提供电源-它不是通道输出的电源（那是我们的电机）。
    我们将在搭建的第3部分中将外部电源连接到IC以为通道的电机供电。
- en: Connect GPIO 16 to pin 9 of the L293D.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GPIO 16连接到L293D的引脚9。
- en: Connect GPIO 20 to pin 10 of the L293D.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GPIO 20连接到L293D的引脚10。
- en: Connect GPIO 21 to pin 15 of the L293D.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将GPIO 21连接到L293D的引脚15。
- en: Connect a jumper lead to pin 14 of the L293D. The other end of this lead (labeled
    **Output 4Y**) is not connected to anything for the moment.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将跳线引线连接到L293D的引脚14。 此引线的另一端（标有**Output 4Y**）目前未连接到任何东西。
- en: Connect a jumper lead to pin 11 of the L293D. The other end of this lead (labeled
    **Output 3Y**) is not connected to anything for the moment.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将跳线引线连接到L293D的引脚11。 此引线的另一端（标有**Output 3Y**）目前未连接到任何东西。
- en: Using a jumper wire, connect pin 12 and pin 13 on the L293D together.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用跳线将L293D的引脚12和引脚13连接在一起。
- en: Finally, connect pin 12 and pin 13 of the L293D to the negative rail of the
    right-hand side power rail.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将L293D的引脚12和引脚13连接到右侧电源轨道的负轨道。
- en: 'Now that we have wired the channel 2 output, our third task is to connect the
    external power supply:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经连接了通道2的输出，我们的第三个任务是连接外部电源：
- en: '![](assets/ab5d7593-df76-4bdd-811b-04ce6417ee24.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ab5d7593-df76-4bdd-811b-04ce6417ee24.png)'
- en: Figure 10.8 – L293D breadboard layout (Part 3 of 3)
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 - L293D面包板布局（第3部分）
- en: 'Here are the steps to follow to complete the third part of our breadboard build.
    The step numbers match the numbers in black circles in *Figure 10.8*:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是完成我们面包板搭建的第三部分所需遵循的步骤。 步骤编号与*图10.8*中黑色圆圈中的数字相匹配：
- en: Connect the positive output terminal of your power supply to the positive rail
    of the right-hand side power rail.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源的正输出端连接到右侧电源轨道的正轨道。
- en: Connect the negative output terminal of your power supply to the negative rail
    of the right-hand side power rail.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将电源的负输出端连接到右侧电源轨道的负轨道。
- en: Connect pin 8 of the L293D to the positive rail of the right-hand side power
    rail. Pin 8 of the L293D provides the input power used to drive the output channels.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将L293D的引脚8连接到右侧电源轨道的正轨道。 L293D的引脚8提供了用于驱动输出通道的输入电源。
- en: Finally, using a jumper wire, connect the negative rails of the left-hand side
    and right-hand side power rails.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用跳线将左侧和右侧电源轨道的负轨道连接起来。
- en: 'This is our breadboard layout complete. However, there is one final task where
    we connect our motors. Following the example in the following diagram, you can
    connect a motor to each output channel:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的面包板布局完成。 但是，还有一个最后的任务，我们要连接我们的电机。 根据以下图表中的示例，您可以将一个电机连接到每个输出通道：
- en: '![](assets/04f2999e-7469-4e8a-9e33-336abaed04d8.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/04f2999e-7469-4e8a-9e33-336abaed04d8.png)'
- en: Figure 10.9 – L293D motor connections
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 - L293D电机连接
- en: Well done! That was a lot of wiring. I imagine that the tangle of wires you
    now have on your breadboard does not look nearly as graceful as the illustrations!
    Please do take the time to double-check your wirings for this circuit, as an incorrectly
    placed wire will prevent the circuit from working as intended.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！那是很多布线。 我想你现在面包板上的电线纠结看起来并不像插图那样优雅！ 请务必花时间仔细检查这个电路的布线，因为错误放置的电线会阻止电路按预期工作。
- en: During our circuit build, in part 3, *step 3*, we connected an external 5-volt
    power source to pin 8 of the L293D. This is the power used to drive each output
    channel, and hence our motors. If you ever wish to use motors that require a voltage
    different to 5 volts, you can alter this supply voltage to suit your needs, subject
    to the condition that the source voltage for the L293D must be within the range
    of 4.5 volts to 36 volts. Also remember (as mentioned at the start of this section)
    that your motors should not draw more than a 600 mA continuous current (fully
    on) or 1.2 A peak current (for instance, when using PWM, which we will cover when
    we get to the code).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的电路搭建中，在第3部分，*步骤3*中，我们将外部5伏电源连接到L293D的引脚8。 这是用于驱动每个输出通道和因此我们的电机的电源。 如果您希望使用需要与5伏不同电压的电机，您可以更改此供电电压以满足您的需求，但前提是L293D的电源电压必须在4.5伏至36伏的范围内。
    还要记住（如本节开头提到的），您的电机不应该吸取超过600毫安的持续电流（全开）或1.2安的峰值电流（例如，当使用PWM时，我们将在编码时介绍）。
- en: 'If you read a datasheet for the L293D, it may be entitled *Quadruple Half-H
    Drivers*. Datasheets for driver type ICs can have all sorts of different titles
    and wordings. The important point here is that to drive our motor forward and
    backward, we require a full H-Bridge circuit, hence, for the L293D: Quad=4 and
    half=0.5, so *4 x 0.5 = 2 –* that is, 2 full H-Bridges – therefore, we can control
    2 motors.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读L293D的数据表，它可能被称为*四路半H驱动器*。 驱动器类型IC的数据表可能具有各种不同的标题和措辞。 这里的重要一点是，为了驱动我们的电机向前和向后，我们需要一个完整的H-Bridge电路，因此对于L293D：Quad=4和half=0.5，因此*4
    x 0.5 = 2 -*也就是说，2个完整的H-Bridge-因此，我们可以控制2个电机。
- en: Once you have created your breadboard circuit and connected your motors, we
    will run the example code and discuss how it works.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了面包板电路并连接了电机，我们将运行示例代码并讨论其工作原理。
- en: Running the example H-Bridge code to control a motor
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行示例H-Bridge代码以控制电机
- en: Now that you have created your H-Bridge driver circuit and connected your motors,
    let's run the code that will make the motors spin.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经创建了H桥驱动器电路并连接了电机，让我们运行能让电机旋转的代码。
- en: There are two files for this section, and they can be found in `chapter10/motor_class.py`
    and `chapter10/motor.py`. Run the code found in `chapter10/motor.py` and your
    motors will turn on, change speeds, and change direction.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这一节有两个文件，它们可以在`chapter10/motor_class.py`和`chapter10/motor.py`中找到。运行`chapter10/motor.py`中的代码，您的电机将会转动，改变速度和方向。
- en: Place a piece of tape on the shaft of your motors to make it easier to see when
    they rotate and in what direction.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在电机轴上贴一张胶带，以便更容易地看到它们旋转的方向。
- en: When you have confirmed that your circuit works with the example code, we will next proceed
    and discuss the code. Since the L293D can drive two motors, the common code has
    been abstracted out into `motor_class.py`, which is imported and used by `motor.py`
    to drive our two individual motors.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当您确认您的电路可以与示例代码一起工作时，我们将继续讨论代码。由于L293D可以驱动两个电机，公共代码已经被抽象成了`motor_class.py`，它被`motor.py`导入并用于驱动我们的两个独立电机。
- en: We'll start by looking at `motor.py`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将从`motor.py`开始。 '
- en: motor.py
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: motor.py
- en: 'Starting at line 1, we import PiGPIO and the `Motor` class defined in the `motor_class.py`
    file, before defining several variables describing how we are connecting the L293D
    to our Raspberry Pi''s GPIO pins:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从第1行开始，我们导入PiGPIO和`motor_class.py`文件中定义的`Motor`类，然后定义了几个变量，描述了我们如何将L293D连接到树莓派的GPIO引脚：
- en: '[PRE7]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Referring back to *Figure 10.3* and *Figure 10.4*, if we consider the **Motor
    A** (channel 1) side of the circuits, we see that the logic pins are connected
    to GPIOs 23 and 24 at line 2 – `INPUT_1Y_GPIO = 23` and `INPUT_2Y_GPIO = 24`.
    These logic pins (together with the enable pin that we will cover shortly) are
    used to set the state and rotational direction of the motor. The truth table for
    these states is shown as follows.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾*图10.3*和*图10.4*，如果我们考虑电机A（通道1）电路的一侧，我们会看到逻辑引脚连接到第2行的GPIO 23和24 - `INPUT_1Y_GPIO
    = 23` 和 `INPUT_2Y_GPIO = 24`。这些逻辑引脚（以及我们很快将介绍的使能引脚）用于设置电机的状态和旋转方向。这些状态的真值表如下所示。
- en: 'This table was sourced from the L293D datasheet and reformatted and supplemented
    to match our code and circuit:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格是从L293D的数据表中获取的，并进行了重新格式化和补充，以匹配我们的代码和电路：
- en: '| **Row #** | **Enable GPIO** | **Logic 1 GPIO** | **Logic 2 GPIO** | ** Motor
    Function** |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| **行号** | **使能GPIO** | **逻辑1 GPIO** | **逻辑2 GPIO** | **电机功能** |'
- en: '| 1 | `HIGH` or > 0% duty cycle | Low | High | Turns right |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 1 | `HIGH` 或 > 0% 占空比 | 低 | 高 | 向右转 |'
- en: '| 2 | `HIGH` or > 0% duty cycle | High | Low | Turns left |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 2 | `HIGH` 或 > 0% 占空比 | 高 | 低 | 向左转 |'
- en: '| 3 | `HIGH` or > 0% duty cycle | Low | Low | Break |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 3 | `HIGH` 或 > 0% 占空比 | 低 | 低 | 刹车 |'
- en: '| 4 | `HIGH` or > 0% duty cycle | High | High | Break |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 4 | `HIGH` 或 > 0% 占空比 | 高 | 高 | 刹车 |'
- en: '| 5 | `LOW` or 0% duty cycle | N/A | N/A | Motor off |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 5 | `LOW` 或 0% 占空比 | N/A | N/A | 关闭电机 |'
- en: The L293D has two enable pins – one for each channel (that is, one for each motor)
    – for instance, `CHANNEL_1_ENABLE_GPIO = 18` at line 3 in the preceding code. The
    enable pins are like a master switch for each channel. When the enable pin is
    set high, it turns the associated channel on, thus applying power to the motor.
    Alternatively, we can control the speed of a motor if we instead pulse the enable
    pin using PWM. We'll see the code that works with the logic and enables pins shortly
    when we explore the `motor_class.py` file.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: L293D有两个使能引脚 - 每个通道一个（即每个电机一个） - 例如，在前面的代码中的第3行，`CHANNEL_1_ENABLE_GPIO = 18`。使能引脚就像每个通道的主开关。当使能引脚设置为高时，它会打开相关的通道，从而给电机供电。或者，如果我们使用PWM脉冲使能引脚，我们可以控制电机的速度。当我们探索`motor_class.py`文件时，我们将很快看到处理逻辑和使能引脚的代码。
- en: 'Next, we will create a single instance of `pigpio.pi()`, as shown in line 4,
    and then we will create two instances of `Motor` to represent our two physical
    motors:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`pigpio.pi()`的单个实例，如第4行所示，然后我们将创建两个`Motor`的实例来代表我们的两个物理电机：
- en: '[PRE8]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'After we have created the `motor_A` and `motor_B` classes, we perform a few
    actions with these class to control the motors, as shown in the following code,
    starting at line 5 – this is what you witnessed in the previous section when you
    ran the code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们创建了`motor_A`和`motor_B`类之后，我们使用这些类对电机进行了一些操作，如下面的代码所示，从第5行开始 - 这就是您在上一节运行代码时所见到的：
- en: '[PRE9]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Take note of the braking at line 6 and observe the motors. Did one motor brake
    better than the other? We will discuss this further when we cover the two brake
    functions toward the end of the next section.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第6行的刹车，并观察电机。一个电机的刹车效果比另一个好吗？当我们在下一节的最后讨论两个刹车功能时，我们将进一步讨论这个问题。
- en: Let's move on and look at `motor_class.py`. This is where the code that integrates
    our Raspberry Pi with the L293D is found.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看`motor_class.py`。这是我们的树莓派与L293D集成的代码所在之处。
- en: motor_class.py
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: motor_class.py
- en: 'First, we see the `Motor` class definition and its constructor:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们看到`Motor`类的定义及其构造函数：
- en: '[PRE10]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At line 1, we are defining the PiGPIO PWM duty cycle range for the enable pin
    to be in the range `0..100`. This defines the maximum range value (that is, `100`)
    that we can use with the `set_speed()` function that we'll come to shortly.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在第1行，我们定义了PiGPIO PWM使能引脚的占空比范围为`0..100`。这定义了我们可以在`set_speed()`函数中使用的最大范围值（即`100`）。
- en: The range `0..100` means we have 101 discrete integer PWM steps, which maps
    conveniently to a 0% to 100% duty cycle. If you specify a higher number, this
    does not mean more duty cycles (or more motor speed); it just changes the granularity
    of the steps – for example, the default PWM range of `0..255` gives us 256 discrete
    steps, where 255 = 100% duty cycle.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 范围`0..100`表示我们有101个离散的整数PWM步骤，这方便地映射到0%到100%的占空比。如果您指定一个更高的数字，这并不意味着更多的占空比（或更高的电机速度）；它只是改变了步骤的粒度
    - 例如，默认的PWM范围`0..255`给我们256个离散的步骤，其中255 = 100%的占空比。
- en: Remember what we're about to discuss covers one channel (one motor) of the L293D
    IC circuit. Everything we cover applies to the other channel too – it's just the
    GPIO pins and IC pins that change.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们即将讨论的内容涵盖了L293D IC电路的一个通道（一个电机）。我们讨论的所有内容也适用于另一个通道 - 只是GPIO引脚和IC引脚会有所变化。
- en: Our constructor finishes by initializing the motor to be off (zero speed) and
    defaults the motor to the right rotational direction, as shown in the preceding
    code at line 2.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数通过将电机初始化为关闭（零速度），并将电机默认为右旋转方向来完成，如前面代码中的第2行所示。
- en: 'Next, we encounter several functions that we use to make our motor(s) spin.
    We see at line 3 and line 4 the `right()` and `left()` methods, which alter the
    high/low states of the logic pins of the L293D, according to rows 1 and 2 in the
    preceding table:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遇到了几个函数，我们用它们来使我们的电机旋转。我们在第3行和第4行看到了`right()`和`left()`方法，它们根据前表中的第1行和第2行改变了L293D的逻辑引脚的高低状态。
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can check whether our motor is set to rotate left or right by querying the
    current states of the logic pins, as shown in `is_right()` at line 5\. Notice
    that the queried GPIO states in `is_right()` match the states set in `right()`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过查询逻辑引脚的当前状态来检查我们的电机是否设置为左旋转或右旋转，就像在`is_right()`中所示的那样。请注意，`is_right()`中查询的GPIO状态与`right()`中设置的状态相匹配。
- en: '[PRE12]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We see the use of  `set_PWM_dutycycle()` in the `set_speed()` method in the
    following code at line 6, where we set the speed of our motor by pulsing the enable
    pin of the L293D. Pulsing the enable pin is done using the same basic principles
    we used back in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml), *Turning
    Things On and Off*, when we pulsed a transistor to set our motor''s speed:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第6行的以下代码中看到了`set_speed()`方法中使用`set_PWM_dutycycle()`，在这里我们通过脉冲L293D的使能引脚来设置电机的速度。脉冲使能引脚的脉冲是使用我们在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中使用的相同基本原理进行的，*打开和关闭事物*，当我们脉冲一个晶体管来设置电机的速度时。
- en: '[PRE13]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can stop the motor by setting the speed to `0`, which effectively is cutting
    off the motor's power (0% duty cycle = pin low).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将速度设置为`0`来停止电机，这实际上是切断电机的电源（0%占空比=引脚低电平）。
- en: 'Moving forward, we find two methods named `brake()` and `brake_pwm()` at lines
    7 and 8, which can be used to stop the motor *quickly*. The difference between
    braking and stopping a motor by cutting its power (that is, `set_speed(0)`) is
    that `set_speed(0)` allows the motor to slow down gradually over time – which
    is the state at row 5 in the preceding table:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们发现了两种方法，即`brake()`和`brake_pwm()`，它们可以用于*快速*停止电机。制动和通过切断电源（即`set_speed(0)`）来停止电机的区别在于，`set_speed(0)`允许电机逐渐减速
    - 这是前表中第5行的状态：
- en: '[PRE14]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you ran this code in the previous section, and if you experiment with
    the two brake functions on your own, my guess is that you will find `brake()` does
    not work well (if at all), while the `brake_pwm()` function does:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在上一节中运行此代码，并且如果您自己尝试两种制动功能，我的猜测是您会发现`brake()`不起作用（或者根本不起作用），而`brake_pwm()`函数会起作用。
- en: '[PRE15]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let's discuss why we have defined two different braking methods and why one
    works better than the other.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论为什么我们定义了两种不同的制动方法，以及为什么一种方法比另一种方法更有效。
- en: The implementation of `brake()` is the classic way a motor brake is implemented,
    where both logic GPIOs are set high or low together, as in rows 3 or 4 in the
    preceding table. The catch, however, is that the performance of this logic can
    vary depending on the IC you are using (how it's constructed internally), your
    motor, and the voltage and current use are using. For our example, we are using
    a small motor (with no load on its shaft), small voltage and currents, and an
    L293D IC. The net of all this is that classic braking does not work well, if at
    all.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`brake()`的实现是经典的电机制动实现方式，其中逻辑GPIO同时设置为高电平或低电平，就像前表中的第3行或第4行。然而，问题在于，这种逻辑的性能可能会因您使用的IC（内部构造方式）、电机、电压和电流使用情况而有所不同。在我们的示例中，我们使用的是一个小电机（轴上没有负载）、小电压和电流，以及一个L293D
    IC。所有这些的结果是，经典制动方法不起作用，或者效果不佳。'
- en: We're using the L293D IC because of its popularity, availability, and low cost.
    It's been in production for many years, and you will have no problem finding example
    circuits and code based around this IC for all sorts of applications. It's not
    the most efficient IC, however. This is a contributing factor in classic braking
    not working in some scenarios.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用L293D IC是因为它很受欢迎、易得、成本低。它已经生产了很多年，您将毫无问题地找到基于这个IC的示例电路和代码，用于各种应用。然而，它并不是最有效的IC。这是经典制动在某些情况下不起作用的一个因素。
- en: The `break_pwm(reverse_speed, delay_secs)` implementation takes a different
    and more reliable approach to braking by applying a small and opposite voltage
    to the motor. You can use the `brake_speed` and `delay_millisecs` parameters to
    tune the braking if required – too little speed and delay and the brake will not
    work, too much and the motor will reverse direction.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`brake_pwm(reverse_speed, delay_secs)`的实现采用了一种不同且更可靠的制动方式，即向电机施加一个小的相反电压。您可以使用`brake_speed`和`delay_millisecs`参数来调整制动，如果需要的话
    - 速度和延迟太小，制动将不起作用，太大则电机会反向。'
- en: Have you noticed that at full speed (that is, `set_speed(100)`), your motor
    spins slower than if it were connected directly to 5 volts? There is a ~2 voltage
    drop inherent in the L293D. Even though V[cc1] (motor power source) is connected
    to 5 volts, the motor is not getting this full 5 volts (it's more like ~3 volts).
    If you are using a variable power supply (that is, not a 3.3 V/5 V breadboard
    power supply), you can increase the input voltage to V[cc1 ]to around 7 volts.
    This will then see the motor getting around 5 volts (you can use your multimeter
    to verify this).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否注意到在全速（即`set_speed(100)`）时，您的电机转速比直接连接到5伏特时要慢？L293D中存在一个约2伏特的电压降。即使V[cc1]（电机电源）连接到5伏特，电机也没有获得这个完整的5伏特（更像是约3伏特）。如果您使用的是可变电源（即不是3.3V/5V面包板电源），您可以将输入电压增加到V[cc1]周围的7伏特。然后电机将获得约5伏特（您可以使用万用表来验证）。
- en: Congratulations! You have just learned how to operate a servo and master the
    control of a DC motor in terms of speed and the direction of braking. The circuits,
    code, and skills you have just acquired can be adapted to many applications where
    you need to create motion and angular movement – for example, a robotic car or
    arm. You could even use these skills to retrofit motorized toys and other motorized
    gadgets and make them controllable by your Raspberry Pi.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚学会了如何操作伺服并掌握了直流电机在速度和制动方向上的控制。您刚刚获得的电路、代码和技能可以适应许多需要创建运动和角运动的应用，例如机器人车或机械臂。您甚至可以使用这些技能来改装电动玩具和其他电动小工具，并使它们可以由您的树莓派控制。
- en: If you would like to extend your knowledge further, you might like to explore
    how to create an H-Bridge circuit from individual components – such as transistors,
    resistors, and diodes. While there are various ways to accomplish this circuit,
    we covered the core basics in terms of concepts and components between this chapter
    and our use of transistors back in [Chapter 7](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml),
    *Turning Things On and Off*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步扩展您的知识，您可能想探索如何从单独的元件（如晶体管、电阻和二极管）创建H桥电路。虽然有各种方法可以完成这个电路，但我们在本章和我们在[第7章](36313176-0d8b-4a0e-916a-7d4ffd58305a.xhtml)中使用晶体管时，涵盖了概念和组件的核心基础，*打开和关闭东西*。
- en: Well done! We covered a lot in this section as we learned how to use an L293D
    H-Bridge to make a DC motor spin, reverse direction, and brake. In the next section,
    we will look at an alternative use of the L293D and see how to use it to control
    a stepper motor.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在本节中，我们学习了如何使用L293D H桥使直流电机旋转、改变方向和制动。在下一节中，我们将看看L293D的另一种用途，并了解如何使用它来控制步进电机。
- en: Introduction to stepper motor control
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 步进电机控制简介
- en: Stepper motors are a unique type of motor in terms of their precision and torque.
    Similar to a DC motor, a stepper motor can rotate in both directions continuously,
    while they can be precisely controlled similar to a servo.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 步进电机在精度和扭矩方面是一种独特的电机类型。与直流电机类似，步进电机可以在两个方向上连续旋转，同时它们可以像伺服一样被精确控制。
- en: 'In the following diagram is a 28BYJ-48 stepper motor, together with headpins
    that can be used to connect the motor to a breadboard:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在下图中是一个28BYJ-48步进电机，以及可以用来将电机连接到面包板的引脚：
- en: '![](assets/e7d525e8-4b34-4f5b-acc9-555258724de3.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/e7d525e8-4b34-4f5b-acc9-555258724de3.png)'
- en: Figure 10.10 – 28BYJ-48 stepper motor
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.10 - 28BYJ-48步进电机
- en: Stepper motor theory and practice can get complex quickly! There are different
    forms and types of stepper motors and many variables, such as stride angles and
    gearing, that all need to be accounted for, plus various ways to wire and control
    them. We can't possibly cover all these parameters here, nor can we go into the
    low-level details of how stepper motors work.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 步进电机的理论和实践可能会很快变得复杂！有不同形式和类型的步进电机，许多需要考虑的变量，如步距角和齿轮，以及各种布线和控制方式。我们不可能在这里涵盖所有这些参数，也不能深入了解步进电机的低级细节。
- en: Instead, we will cover the practical operation of a common and readily available
    stepper motor, a 28BYJ-48. Once you understand the basic principles as they apply
    to a 28BYJ-48, you will be well-positioned to broaden your knowledge of stepper
    motors.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们将介绍一种常见且易得的步进电机28BYJ-48的实际操作。一旦您了解了适用于28BYJ-48的基本原理，您就可以扩展对步进电机的知识。
- en: Controlling stepper motors can be confusing and fiddly when you first start
    using them. Unlike DC motors and servos, you need to appreciate how stepper motors
    work at both a mechanical and code level to control them.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次开始使用步进电机时，控制步进电机可能会令人困惑和琐碎。与直流电机和伺服不同，您需要了解步进电机在机械和代码层面上的工作原理才能控制它们。
- en: 'The basic specifications for our reference 28BYJ-48 are as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们参考的28BYJ-48的基本规格如下：
- en: 5 volts (make sure your stepper is 5 volts because the 28BYJ-48 also comes in
    12 volts).
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 5伏特（确保您的步进电机是5伏特，因为28BYJ-48也有12伏特）。
- en: A stride angle of 64, a 1:64 gearing ratio, giving *64 x 64 = 4,096* steps per
    360 degree revolution.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 64的步距角，1:64的齿轮比，每360度旋转*64 x 64 = 4,096*步。
- en: 'Using the stride angle, gearing ratio, and sequence, we can calculate the number
    of logical steps needed to rotate our stepper motor 360 degrees: *64 x 64 / 8
    = 512* *steps*.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 使用步距角、齿轮比和序列，我们可以计算旋转我们的步进电机360度所需的逻辑步数：*64 x 64 / 8 = 512* *步*。
- en: Next, we will connect our stepper motor to our Raspberry Pi.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把我们的步进电机连接到我们的树莓派。
- en: Connecting the stepper motor to the L293D circuit
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将步进电机连接到L293D电路
- en: 'To connect our stepper motor to our Raspberry Pi, we are going to reuse our
    L293D circuit, as shown in *Figure 10.8* in the previous section. Here is what
    we need to do:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的步进电机连接到树莓派，我们将重复使用我们的L293D电路，如前一节中的*图10.8*所示。我们需要做的是：
- en: '![](assets/6cac6ea0-8f96-4692-80ec-3fff638d1ff2.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/6cac6ea0-8f96-4692-80ec-3fff638d1ff2.png)'
- en: Figure 10.11 – 28BYJ-48 stepper motor wiring connection
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 - 28BYJ-48步进电机接线连接
- en: 'The following steps match the numbering shown in *Figure 10.11*. Remember that
    we are starting with the circuit you completed previously in the section entitled
    *Building the motor driver circuit* and shown in *Figure 10.8*:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤与*图10.11*中显示的编号相匹配。请记住，我们从您在*构建电机驱动器电路*部分完成的电路开始，并在*图10.8*中显示：
- en: In *steps 2* through *5*, we will connect the stepper motor in our breadboard
    circuit. A suggestion is to use header pins (as pictured in *Figure 10.10*) to
    connect your motor to a run of vacant rows on your breadboard, and then connect
    the output wires from the L293D to the appropriate row matching the wire colors
    mentioned in the steps.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在*步骤2*到*5*中，我们将在我们的面包板电路中连接步进电机。建议使用引脚排针（如*图10.10*中所示）将电机连接到面包板上的空行，然后将L293D的输出线连接到与步骤中提到的线颜色相匹配的适当行。
- en: If you have not done so already, disconnect the two DC motors from the existing
    circuit.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您还没有这样做，请断开两个直流电机与现有电路的连接。
- en: Connect the orange wire of your stepper motor to the wire labeled **Output 4Y**
    in *Figure 10.8.*
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的步进电机的橙线连接到*图10.8.*中标有**Output 4Y**的线上。
- en: Connect the yellow wire of your stepper motor to the wire labeled **Output 3Y**
    in *Figure 10.8.*
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的步进电机的黄线连接到*图10.8.*中标有**Output 3Y**的线上。
- en: Connect the pink wire of your stepper motor to the wire labeled **Output 2Y**
    in *Figure 10.8.*
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的步进电机的粉红线连接到*图10.8.*中标有**Output 2Y**的线上。
- en: Connect the blue wire of your stepper motor to the wire labeled **Output 1Y**
    in *Figure 10.8.*
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的步进电机的蓝线连接到*图10.8.*中标有**Output 1Y**的线上。
- en: 'In our example scenario, we are using our L293D H-Bridge to drive our stepper
    motor as a *bipolar* stepper motor. You will come across the terms *bipolar* and
    *unipolar* in relation to stepper motors. These terms relate to how the motor
    is wired, and this influences how you will control them. A discussion of the differences
    between bipolar and unipolar stepper motors can quickly get complex; however,
    a simplified distinction at this stage of learning is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例场景中，我们使用我们的L293D H-Bridge来驱动我们的步进电机作为*双极*步进电机。在步进电机方面，你会遇到*双极*和*单极*这两个术语。这些术语与电机的接线方式有关，这影响了你将如何控制它们。在学习的这个阶段，对双极和单极步进电机之间的区别进行简化的区分如下：
- en: A *bipolar* stepper motor requires a driving circuit that is capable of reversing
    the current flow.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个*双极*步进电机需要一个能够改变电流流向的驱动电路。
- en: A *unipolar* stepper motor *does not* require a circuit that is capable of reversing
    the current flow.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单极*步进电机*不需要*一个能够改变电流流向的电路。'
- en: In our example with bipolar wiring, we use an H-Bridge circuit because it is
    capable of reversing current flow to a coil (for example, this is how we made
    our DC motor reverse direction in the previous section).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的双极接线示例中，我们使用H-Bridge电路，因为它能够改变电流流向到线圈（例如，这就是我们在前一节中使直流电机改变方向的方法）。
- en: The ULN2003 IC is a popular, low-cost Darlington transistor array (with built-in
    fly-back diodes); you could also use it to drive your stepper motor as a *unipolar*
    stepper motor. In this setup, you would use the red wire connected to +5 volts
    because the ULN2003 is unable to reverse current.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ULN2003 IC是一种流行的、低成本的达林顿晶体管阵列（带有内置飞回二极管）；你也可以使用它来驱动你的步进电机作为*单极*步进电机。在这种设置中，你将使用连接到+5伏特的红线，因为ULN2003无法改变电流的方向。
- en: With our stepper motor connected, we can continue on to control it with code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 连接好步进电机后，我们可以继续使用代码来控制它。
- en: Running and exploring the stepper motor code
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行和探索步进电机代码
- en: The code we are about to run can be found in the `chapter10/stepper.py` file.
    I recommend reviewing the source code before proceeding so that you have an overall
    idea of what the file contains.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们即将运行的代码可以在`chapter10/stepper.py`文件中找到。我建议在继续之前先查看源代码，以便对文件的内容有一个整体的了解。
- en: When you run the code found in the `chapter10/stepper.py` file, your stepper
    motor should rotate a complete 360 degrees in one direction, and then back again.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行`chapter10/stepper.py`文件中的代码时，你的步进电机应该在一个方向上旋转360度，然后再返回。
- en: Place a piece of tape on the shaft of your stepper motor to make it easier to
    see when it rotates and in what direction.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的步进电机轴上贴一块胶带，以便在旋转时更容易看到它的方向。
- en: Starting at the top of the source file, we define all our GPIO variables, including
    our enable pins at line 1, plus variables starting at line 2 relating to our stepper
    motor coil wires. These wires must be **identified and ordered correctly, as coil
    wire order matters!**
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 从源文件的顶部开始，我们定义了所有的GPIO变量，包括我们的使能引脚在第1行，以及从第2行开始与我们的步进电机线圈线有关的变量。这些线必须**正确识别和排序，因为线圈线的顺序很重要！**
- en: '[PRE16]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will see later in code the use of `STEP_DELAY_SECS` at line 3 to add a slight
    delay in between coil steps. A higher delay will result in a slower rotation of
    the stepper motor's shaft; however, too small a number and the shaft may not rotate
    at all or the rotation may be erratic and stutter. Feel free to experiment with
    different delay values to suit your needs.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在代码中稍后看到使用`STEP_DELAY_SECS`在第3行，以在线圈步进之间增加一些延迟。更长的延迟会导致步进电机轴的旋转速度变慢；然而，如果数字太小，轴可能根本不会旋转，或者旋转会不稳定和抖动。随时尝试不同的延迟值以满足你的需求。
- en: 'Next, starting at line 4, we group our coil GPIOs into a Python list (array)
    and initialize these GPIOs as outputs at line 5. We''re storing the GPIOs in a
    list because we will be iterating over these GPIOs later when we use the `rotate()` function. We
    also have the `off()` function at line 6 that we use to turn off all the coils:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从第4行开始，我们将我们的线圈GPIO分组到一个Python列表（数组）中，并在第5行将这些GPIO初始化为输出。我们将GPIO存储在列表中，因为我们将在稍后使用`rotate()`函数时对这些GPIO进行迭代。我们还在第6行有`off()`函数，用于关闭所有线圈：
- en: '[PRE17]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'At line 7, we''re setting the two enable GPIO pins `HIGH` in code because we
    are reusing the circuit from our previous DC motor control example. The alternative
    non-code approach would be to connect the L293D EN1 and EN2 pins directly to +5
    volts (that is, pull them `HIGH` manually):'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7行，我们在代码中将两个使能GPIO引脚设置为`HIGH`，因为我们正在重用之前直流电机控制示例中的电路。另一种非代码方法是直接将L293D EN1和EN2引脚连接到+5伏特（即手动将它们拉高）：
- en: '[PRE18]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Starting at line 8, we define two stepping sequences in a multi-dimension (2
    x 2) array named `COIL_HALF_SEQUENCE` and `COIL_FULL_SEQUENCE`, and we thus encounter
    the parts of the code where it starts to become obvious that stepper motor control
    is more complex than DC motor or servo control!
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 从第8行开始，我们在一个名为`COIL_HALF_SEQUENCE`和`COIL_FULL_SEQUENCE`的多维（2 x 2）数组中定义了两个步进序列，因此我们遇到了代码的部分，从这里开始，步进电机控制变得比直流电机或伺服控制更复杂！
- en: 'A stepping sequence defines how we must turn on (energize) and off (not energized)
    each coil in the stepper motor to make it step. Each row in the sequence has four
    elements, each relating to a coil:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 步进序列定义了我们必须如何打开（通电）和关闭（不通电）步进电机中的每个线圈，以使其步进。序列中的每一行都有四个元素，每个元素都与一个线圈相关：
- en: '[PRE19]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A sequence with eight steps is known as a *half-step* sequence, while a *full-step*
    sequence has four rows and is a subset of the half-sequence (match up the *(a)*,
    *(b)*, *(c)*, and *(d)* rows in the preceding code).
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 具有八个步骤的序列称为*半步*序列，而*全步*序列有四行，是半序列的子集（在前面的代码中匹配*(a)*、*(b)*、*(c)*和*(d)*行）。
- en: A half-sequence will give you more resolution (for example, 4,096 steps for
    a 360-degree revolution), while a full-step sequence will give you half the resolution
    (2,048 steps) but twice the stepping speed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 半序列将为您提供更高的分辨率（例如，360度革命的4,096步），而全步序列将提供一半的分辨率（2,048步），但步进速度加倍。
- en: A stepping sequence for a stepper can usually be found in its datasheet – but
    not always, as our reference 28BYJ-48 datasheet mentioned in the *Technical requirements*
    section proves, so sometimes some research may be necessary.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 步进电机的步进序列通常可以在其数据表中找到 - 但并非总是如此，正如我们在*技术要求*部分提到的28BYJ-48数据表所证明的那样，因此有时可能需要进行一些研究。
- en: If a stepper motor is not rotating, but it is making a sound and vibrating,
    it's a sign that the stepping sequence and coil order is incorrectly matched.
    This is a common frustration with stepper motors when you try to just connect
    them blindly and hope they work. To avoid this trial-and-error approach, take
    the time to identify your stepper motor type and how it is being wired (for example,
    bipolar or unipolar), and work out the coil numbering and what a suitable coil
    stepping sequence looks like. Consulting your stepper motor's datasheet is the
    best place to start.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果步进电机没有旋转，但发出声音和振动，这表明步进序列和线圈顺序不匹配。当您尝试盲目连接它们并希望它们工作时，这是步进电机的常见挫折。为了避免这种反复试验的方法，请花时间识别您的步进电机类型以及它的接线方式（例如，双极或单极），并找出线圈编号以及适合的线圈步进序列是什么样的。查阅您的步进电机的数据表是开始的最佳地方。
- en: 'Next, at line 9, we defined the global variable, `sequence = COIL_HALF_SEQUENCE`,
    to use a half-step sequence when stepping our motor. You can change this to `sequence
    = COIL_FULL_SEQUENCE` to use a full-step sequence – all other code remains the
    same:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在第9行，我们定义了全局变量`sequence = COIL_HALF_SEQUENCE`，以在步进电机步进时使用半步序列。您可以将其更改为`sequence
    = COIL_FULL_SEQUENCE`以使用全步序列 - 所有其他代码保持不变：
- en: '[PRE20]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'At line 10, we have the `rotate(steps)` method, which is where all the magic
    happens, so to speak. Examining and understanding what this method does is the
    key to understanding how to control our stepper motor. The `steps` parameter can
    be a positive or a negative number to rotate the stepper motor in the reverse
    direction:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在第10行，我们有`rotate(steps)`方法，这是发生所有魔术的地方，可以这么说。检查和理解这个方法做了什么是理解如何控制我们的步进电机的关键。`steps`参数可以是正数或负数，以使步进电机向相反方向旋转：
- en: '[PRE21]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The core of the `rotate()` function is within the two `for` loops, starting
    at line 11:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`rotate()`函数的核心部分在两个`for`循环中，从第11行开始：'
- en: '[PRE22]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As the code loops for `step` iterations, we get the next coil state's form,
    `sequence[sequence_row]`, at line 12 (for example, `[0, 1, 1, 1]`), before looping
    through and getting the corresponding coil GPIO at line 13, and its `HIGH`/`LOW`
    state at line 14\. At line 15, we set the `HIGH`/`LOW` state of the coil with `pi.write()`,
    which makes our motor move (that is, step), before sleeping for a short delay.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当代码循环进行`step`次迭代时，我们在第12行得到下一个线圈状态的形式，`sequence[sequence_row]`（例如，`[0, 1, 1,
    1]`），然后在第13行循环获取相应的线圈GPIO，并在第14行得到其`HIGH`/`LOW`状态。在第15行，我们使用`pi.write()`设置线圈的`HIGH`/`LOW`状态，这使我们的电机移动（即步进），然后休眠一小段时间。
- en: 'Next, starting at line 16, the `sequence_row` index is updated based on the
    direction of rotation (that is, whether the `steps` parameter was positive or
    negative):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从第16行开始，根据旋转方向（即`steps`参数是正数还是负数），更新`sequence_row`索引：
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the end of this block of code, if there are more steps to complete, the code
    then goes back to line 11 for the next `for steps in ...` iteration.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码块的末尾，如果还有更多的步骤要完成，代码将返回到第11行进行下一个`for steps in ...`迭代。
- en: 'Finally, at line 17, we come to the part of the code that made our stepper
    motor rotate when we ran the example. Remember, if you switch line 9 to be `sequence
    = COIL_FULL_SEQUENCE`, then the number of steps will be `2048`:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在第17行，我们来到了使我们的步进电机在运行示例时旋转的代码部分。请记住，如果您将第9行切换为`sequence = COIL_FULL_SEQUENCE`，则步数将为`2048`：
- en: '[PRE24]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Congratulations! You have just completed a crash course on stepper motor control.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您刚刚完成了关于步进电机控制的速成课程。
- en: I understand that if you are new to steppers, there is some multi-dimensional
    thinking required and that you have been introduced to many concepts and terms
    that we have not been able to cover in detail. Stepper motors will take time to
    understand; however, once you grasp the basic process of controlling one stepper
    motor, then you are well on your way to understanding the broader concepts in
    more detail.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我明白，如果您是步进电机的新手，需要进行一些多维思考，并且您已经接触到了许多概念和术语，我们无法详细介绍。步进电机需要时间来理解；然而，一旦您掌握了控制一个步进电机的基本过程，那么您就已经在更深入地理解更广泛的概念的道路上了。
- en: There are many stepper motor tutorials and examples scattered across the internet.
    The goal of many examples is to just make the stepper motor work, and it's not
    always clearly explained how this is being achieved due to the underlying complexity.
    As you read up on stepper motors and explore code examples, remember that the
    definition of a step can vary greatly and depends on the context in which it is
    being used. This is a reason why two examples may cite significantly different
    step numbers for the same stepper motor.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网上有许多步进电机教程和示例。许多示例的目标只是让步进电机工作，但由于底层复杂性，这并不总是清楚地解释了如何实现这一点。当您阅读步进电机的资料并探索代码示例时，请记住，步长的定义可能会有很大的差异，这取决于它的使用环境。这就是为什么两个示例可能会针对同一个步进电机引用显著不同的步数的原因。
- en: Summary
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to use three common types of motors to create
    complex movement with your Raspberry Pi – a servo motor for creating an angular
    moment, a DC motor with an H-Bridge driver to create direction movement and speed
    control, and a stepper motor for precision movement. If you have grasped the general
    concepts of each of these types of motors, then you deserve a pat on the back!
    This is an achievement. While motors are simple in principle and their movement
    is something we take for granted daily in everyday appliances and toys, as you
    have discovered, there is a lot going on behind the scenes to make that movement
    occur.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用三种常见类型的电机来利用树莓派创建复杂的运动 - 使用舵机创建角动量，使用带H桥驱动器的直流电机创建方向运动和速度控制，以及使用步进电机进行精确运动。如果您掌握了这些类型电机的一般概念，那么您值得表扬！这是一个成就。虽然电机在原理上很简单，它们的运动在日常用品和玩具中是我们每天都习以为常的，但正如您发现的那样，背后有很多事情在发生，以使得运动发生。
- en: What you have learned in this chapter, together with the example circuits and
    code, provides you with a foundation that you can use to start building your own
    applications where movement and motion are required. A simple and fun project
    could be to create a program to control a robotic car or robotic arm – you'll
    find DIY kits and robotic parts for cars and arms on sites such as eBay.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 本章学到的知识，加上示例电路和代码，为您提供了一个基础，您可以用它来开始构建自己的应用程序，其中需要运动和动作。一个简单有趣的项目可以是创建一个程序来控制一个机器人汽车或机械臂
    - 您可以在eBay等网站上找到汽车和机械臂的DIY套件和零件。
- en: In the next chapter, we will explore ways we can measure distance and detect
    movement with our Raspberry Pi, Python, and various electronic components.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用树莓派、Python和各种电子元件来测量距离和检测运动的方法。
- en: Questions
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    of this chapter''s material. You will find the answers in the *Assessments* section
    of the book:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些问题供您测试本章材料的知识。您将在书的“评估”部分找到答案：
- en: Your servo does not rotate fully to the left or right. Why is this and how can
    you fix this?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的舵机无法完全向左或向右旋转。这是为什么，如何解决？
- en: Your servo is groaning at one or both of its extreme left/right positions. Why?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的舵机在极左/右位置发出嘎吱声。为什么？
- en: What advantage does an H-Bridge provide over a single transistor when controlling
    DC motors?
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制直流电机时，H桥相比单个晶体管有什么优势？
- en: You are using an L293D H-Bridge IC. You follow the instructions as per the datasheet
    but cannot get your motor to brake. Why?
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您正在使用L293D H桥集成电路。您按照数据表上的说明操作，但无法使电机制动。为什么？
- en: Why do your 5-volt motors spin slower when connected to an H-Bridge using an
    L293D compared to connecting the motor directly to a 5-volt source?
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么将5伏电机连接到使用L293D的H桥时会比直接连接到5伏电源时转速较慢？
- en: You have a stepper motor that will not work – it vibrates, but will not turn.
    What could be the problem?
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您有一个步进电机无法工作 - 它会震动，但不会转动。可能是什么问题？
- en: Can you drive a stepper motor directly from four Raspberry Pis' GPIO pins?
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能直接从四个树莓派的GPIO引脚驱动步进电机吗？
