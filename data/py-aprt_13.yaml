- en: Chapter 8 – Defining new types with classes
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章 - 使用类定义新类型
- en: You can get a long way in Python using the built in scalar and collections types.
    For many problems the built in types, together with those available in the Python
    Standard Library, are completely sufficient. Sometimes though, they aren’t quite
    what’s required, and the ability to create custom types is where *classes* come
    in.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的标量和集合类型可以在Python中走得很远。对于许多问题，内置类型以及Python标准库中提供的类型完全足够。但有时候，它们并不完全符合要求，创建自定义类型的能力就是*类*的用武之地。
- en: 'As we’ve seen, all objects in Python have a type, and when we report that type
    using the `type()` built-in function the result is couched in terms of the *class*
    of that type:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Python中的所有对象都有一个类型，当我们使用内置的`type()`函数报告该类型时，结果是以该类型的*类*为基础的：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A class is used to define the structure and behaviour of one or more objects,
    each of which we refer to as an *instance* of the class. By and large, objects
    in Python have a fixed type^([20](chap21.xhtml#fn-fixed)) from the time they are
    created – or *instantiated* – to the time they are destroyed^([21](chap21.xhtml#fn-unreachable)).
    It may be helpful to think of a class as a sort of template or cookie-cutter used
    to construct new objects. The class of an object controls its initialization and
    which attributes and methods are available through that object. For example, on
    a string object the methods we can use on that object, such as `split()`, are
    defined in the `str` class.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 类用于定义一个或多个对象的结构和行为，我们称之为类的*实例*。总的来说，Python中的对象在创建时具有固定的类型^([20](chap21.xhtml#fn-fixed))
    - 或者在被销毁之前^([21](chap21.xhtml#fn-unreachable))。将类视为一种模板或模具，用于构建新对象可能有所帮助。对象的类控制其初始化以及通过该对象可用的属性和方法。例如，在字符串对象上，我们可以使用的方法，如`split()`，是在`str`类中定义的。
- en: Classes are an important piece of machinery for Object-Oriented Programming
    (OOP) in Python, and although it’s true that OOP can be useful for making complex
    problems more tractable, it often has the effect of making the solution to simple
    problems unnecessarily complex. A great thing about Python is that it’s highly
    object-oriented without forcing you to deal with classes until you really need
    them. This sets the language starkly apart from Java and C#.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 类是Python中面向对象编程（OOP）的重要机制，尽管OOP可以用于使复杂问题更易处理，但它往往会使简单问题的解决方案变得不必要复杂。Python的一个很棒的地方是它高度面向对象，而不会强迫你处理类，直到你真正需要它们。这使得该语言与Java和C#截然不同。
- en: Defining classes
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义类
- en: Class definitions are introduced by the `class` keyword followed by the class
    name. By convention, new class names in Python use camel case – sometimes known
    as Pascal case – with an initial capital letter for each and every component word,
    without separating underscores. Since classes are a bit awkward to define at the
    REPL, we’ll be using a Python module file to hold the class definitions we use
    in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义由`class`关键字引入，后面跟着类名。按照惯例，在Python中，新的类名使用驼峰命名法 - 有时被称为帕斯卡命名法 - 每个组件单词的首字母都大写，不使用下划线分隔。由于在REPL中定义类有点麻烦，我们将使用Python模块文件来保存我们在本章中使用的类定义。
- en: 'Let’s start with the very simplest class, to which we’ll progressively add
    features. In our example we’ll model a passenger aircraft flight between two airports
    by putting this code into `airtravel.py`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从非常简单的类开始，逐步添加功能。在我们的示例中，我们将通过将此代码放入`airtravel.py`来模拟两个机场之间的客机航班：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `class` statement introduces a new block, so we indent on the next line.
    Empty blocks aren’t allowed, so the simplest possible class needs at least a do-nothing
    `pass` statement to be syntactically admissible.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`class`语句引入了一个新的块，所以我们在下一行缩进。空块是不允许的，所以最简单的类至少需要一个无用的`pass`语句才能在语法上被接受。'
- en: Just as with `def` for defining functions, `class` is a *statement* that can
    occur anywhere in a program and which binds a class definition to a class name.
    When the top-level code in the `airtravel` module is executed, the class will
    be defined.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 就像使用`def`来定义函数一样，`class`是一个*语句*，可以出现在程序的任何地方，并将类定义绑定到类名。当执行`airtravel`模块中的顶层代码时，类将被定义。
- en: We can now import our new class into the REPL and try it out.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将我们的新类导入REPL并尝试它。
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The thing we’ve just imported is the class object. Everything is an object in
    Python, and classes are no exception.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚导入的东西是类对象。在Python中，一切都是对象，类也不例外。
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To use this class to mint a new object, we must call its constructor, which
    is done by *calling* the class, as we would a function. The constructor returns
    a new object, which here we assign to a name `f`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个类来创建一个新对象，我们必须调用它的构造函数，这是通过*调用*类来完成的，就像调用函数一样。构造函数返回一个新对象，这里我们将其赋给一个名为`f`的变量：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we use the `type()` function to request the type of `f`, we get `airtravel.Flight`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用`type()`函数来请求`f`的类型，我们会得到`airtravel.Flight`：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The type of `f` literally *is* the class.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`的类型就是类。'
- en: Instance methods
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例方法
- en: Let’s make our class a little more interesting, by adding a so-called *instance
    method* which returns the flight number. Methods are just functions defined within
    the class block, and instance methods are functions which can be called on objects
    which are instances of our class, such as `f`. Instance methods must accept a
    reference to the instance on which the method was called as the first formal argument^([22](chap21.xhtml#fn-formal)),
    and by convention this argument is **always** called `self`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加所谓的*实例方法*来使我们的类更有趣，该方法返回航班号。方法只是在类块内定义的函数，实例方法是可以在我们的类的实例对象上调用的函数，比如`f`。实例方法必须接受对其调用方法的实例的引用作为第一个形式参数^([22](chap21.xhtml#fn-formal))，按照惯例，这个参数**总是**被称为`self`。
- en: 'We have no way of configuring the flight number value yet, so we’ll just return
    a constant string:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有办法配置航班号的值，所以我们将返回一个常量字符串：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'and from a fresh REPL:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 并从一个新的REPL开始：
- en: '[PRE7]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that when we call the method, we do not provide the instance `f` for
    the actual argument^([23](chap21.xhtml#fn-actual)) `self` in the argument list.
    That’s because the standard method invocation form with the dot, like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当我们调用该方法时，我们不会为实际参数`self`在参数列表中提供实例`f`。这是因为标准的方法调用形式与点一起，就像这样：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'is syntactic sugar for:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 是语法糖：
- en: '[PRE9]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you try the latter, you’ll find that it works as expected, although you’ll
    almost never see this form used for real.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试后者，你会发现它按预期工作，尽管你几乎永远不会看到这种形式被真正使用。
- en: Instance initializers
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实例初始化程序
- en: This class isn’t very useful, because it can only represent one particular flight.
    We need to make the flight number configurable at the point a `Flight` is created.
    To do that we need to write an initializer method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类并不是很有用，因为它只能表示一个特定的航班。我们需要在创建`Flight`时使航班号可配置。为此，我们需要编写一个初始化程序方法。
- en: If provided, the initializer method is called as part of the process of creating
    a new object when we call the constructor. The initializer method must be called
    `__init__()` delimited by the double underscores used for Python runtime machinery.
    Like all other instance methods, the first argument to `__init__()` must be `self`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供，初始化程序方法将作为创建新对象的过程的一部分被调用，当我们调用构造函数时。初始化程序方法必须被称为`__init__()`，用于Python运行时机制的双下划线限定。与所有其他实例方法一样，`__init__()`的第一个参数必须是`self`。
- en: 'In this case, we also pass a second formal argument to `__init__()` which is
    the flight number:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们还向`__init__()`传递了第二个形式参数，即航班号：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The initializer should not return anything – it modifies the object referred
    to by `self`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化程序不应返回任何东西-它修改了由`self`引用的对象。
- en: If you’re coming from a Java, C#, or C++ background it’s tempting to think of
    `__init__()` as being the constructor. This isn’t quite accurate; in Python the
    the purpose of `__init__()` is to *configure* an object that already exists by
    the time `__init__()` is called. The `self` argument is, however, analogous to
    `this` in Java, C#, or C++. In Python the actual constructor is provided by the
    Python runtime system and one of the things it does is check for the existence
    of an instance initializer and call it when present.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自Java、C#或C++背景，很容易认为`__init__()`是构造函数。这并不完全准确；在Python中，`__init__()`的目的是在调用`__init__()`时配置已经存在的对象。然而，`self`参数在Python中类似于Java、C#或C++中的`this`。在Python中，实际的构造函数是由Python运行时系统提供的，它的其中一个功能是检查实例初始化程序的存在并在存在时调用它。
- en: Within the initializer we assign to an *attribute* of the newly created instance
    called `_number` . Assigning to an object attribute that doesn’t yet exist is
    sufficient to bring it into existence.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化程序中，我们分配给新创建实例的*属性*称为`_number`。分配给尚不存在的对象属性足以使其存在。
- en: Just as we don’t need to declare variables until we create them, neither do
    we need to declare object attributes before we create them. We choose `_number`
    with a leading underscore for two reasons. First, because it avoids a name clash
    with the method of the same name. Methods are functions, functions are objects,
    and these functions are bound to attributes of the object, so we already have
    an attribute called `number` and we don’t want to replace it. Second, there is
    a widely followed convention that the implementation details of objects which
    are not intended for consumption or manipulation by clients of the object should
    be prefixed with an underscore.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们不需要在创建变量之前声明它们一样，我们也不需要在创建对象属性之前声明它们。我们选择了带有前导下划线的`_number`有两个原因。首先，因为它避免了与同名方法的名称冲突。方法是函数，函数是对象，这些函数绑定到对象的属性，所以我们已经有一个名为`number`的属性，我们不想替换它。其次，有一个广泛遵循的约定，即对象的实现细节不应该由对象的客户端消费或操作，应该以下划线开头。
- en: We also modify our `number()` method to access the `_number` attribute and return
    it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还修改了我们的`number()`方法来访问`_number`属性并返回它。
- en: 'Any actual arguments passed to the flight constructor will be forwarded to
    the initializer, so to create and configure our `Flight` object we can now do
    this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给飞行构造函数的任何实际参数都将转发到初始化程序，因此要创建和配置我们的`Flight`对象，我们现在可以这样做：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also directly access the implementation details:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以直接访问实现细节：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Although this is not recommended for production code, it’s very handy for debugging
    and early testing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这不建议用于生产代码，但对于调试和早期测试非常方便。
- en: A lack of access modifiers
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缺乏访问修饰符
- en: If you’re coming from a bondage and discipline language like Java or C# with
    `public`, `private` and `protected` access modifiers, Python’s “everything is
    public” approach can seem excessively open-minded.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自像Java或C#这样的束缚和纪律语言，具有`public`、`private`和`protected`访问修饰符，Python的“一切都是公开的”方法可能看起来过于开放。
- en: The prevailing culture among Pythonistas is that “We’re all consenting adults
    here”. In practice, the leading underscore convention has proven sufficient protection
    even in large and complex Python systems we have worked with. People know not
    to use these attributes directly, and in fact they tend not to. Like so many doctrines,
    lack of access modifiers is a much bigger problem in theory than in practice.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Pythonista之间普遍的文化是“我们都是自愿成年人”。实际上，前导下划线约定已经被证明足以保护我们所使用的大型和复杂的Python系统。人们知道不直接使用这些属性，事实上他们也不倾向于这样做。就像许多教条一样，缺乏访问修饰符在理论上比在实践中更成问题。
- en: Validation and invariants
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证和不变量
- en: It’s good practice for the initializer of an object to establish so-called *class
    invariants*. The invariants are truths about objects of that class that should
    endure for the lifetime of the object. One such invariant for flights is that
    the flight number always begins with an upper case two-letter airline code followed
    by a three or four digit route number.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对象的初始化程序来说，建立所谓的*类不变量*是一个好的做法。不变量是关于该类的对象应该在对象的生命周期内持续存在的真理。对于航班来说，这样的不变量是，航班号始终以大写的两个字母航空公司代码开头，后面跟着三位或四位数字路线号。
- en: 'In Python, we establish class invariants in the `__init__()` method and raise
    exceptions if they can’t be attained:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，我们在`__init__()`方法中建立类不变量，并在无法实现时引发异常：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We use string slicing and various methods of the string class to perform validation.
    For the first time in this book we also see the logical negation operator `not`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字符串切片和字符串类的各种方法进行验证。在本书中，我们还首次看到逻辑否定运算符`not`。
- en: '*Ad hoc* testing in the REPL is a very effective technique during development:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中的*Ad hoc*测试是开发过程中非常有效的技术：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now that we’re sure of having a valid flight number, we’ll add a second method
    to return just the airline code. Once the class invariants have been established,
    most query methods can be very simple:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们确信有一个有效的航班号，我们将添加第二个方法，只返回航空公司代码。一旦类不变量被建立，大多数查询方法都可以非常简单：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Adding a second class
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加第二个类
- en: 'One of the things we’d like to do with our flight is accept seat bookings.
    To do that we need to know the seating layout, and for that we need to know the
    type of aircraft. Let’s make a second class to model different kinds of aircraft:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要做的事情之一是接受座位预订。为此，我们需要知道座位布局，为此我们需要知道飞机的类型。让我们制作第二个类来模拟不同类型的飞机：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The initializer creates four attributes for the aircraft: registration number,
    a model name, the number of rows of seats, and the number of seats per row. In
    a production code scenario we could validate these arguments to ensure, for example,
    that the number of rows is not negative.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化程序为飞机创建了四个属性：注册号、型号名称、座位行数和每行座位数。在生产代码场景中，我们可以验证这些参数，以确保例如行数不是负数。
- en: This is straightforward enough, but for the seating plan we’d like something
    a little more in line with our booking system. Rows in aircraft are numbered from
    one, and the seats within each row are designated with letters from an alphabet
    which omits ‘I’ to avoid confusion with ‘1’.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这足够简单了，但对于座位计划，我们希望有一些更符合我们预订系统的东西。飞机的行数从一开始编号，每行的座位用字母表示，字母表中省略了‘I’，以避免与‘1’混淆。
- en: '![The aircraft seating plan.](images/m08----seating-plan.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![飞机座位计划。](images/m08----seating-plan.png)'
- en: The aircraft seating plan.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 飞机座位计划。
- en: 'We’ll add a `seating_plan()` method which returns the allowed rows and seats
    as a 2-tuple containing a `range` object and a string of seat letters:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加一个`seating_plan()`方法，它返回允许的行和座位，包含一个`range`对象和一个座位字母的字符串的2元组：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It’s worth pausing for a second to make sure you understand how this function
    works. The call to the `range()` constructor produces a range object which can
    be used as an iterable series of row numbers, up to the number of rows in the
    plane. The string and its slice method return a string with one character per
    seat. These two objects – the range and the string – are bundled up into a tuple.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 值得停顿一下，确保你理解这个函数是如何工作的。对`range()`构造函数的调用产生一个范围对象，它可以用作飞机行数的可迭代系列。字符串及其切片方法返回一个每个座位一个字符的字符串。这两个对象-范围和字符串-被捆绑成一个元组。
- en: 'Let’s construct a plane with a seating plan:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构造一个有座位计划的飞机：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See how we used keyword arguments for the rows and seats for documentary purposes.
    Recall the ranges are half-open, so 23 is correctly one-beyond-the-end of the
    range.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我们如何为行和座位使用关键字参数进行文档目的。回想一下，范围是半开放的，所以23正确地超出了范围的末端。
- en: Collaborating classes
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合作类
- en: 'The Law of Demeter is an object-oriented design principle that says you should
    never call methods on objects you receive from other calls. Or, put another way:
    Only talk to your immediate friends.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 德米特尔法则是一个面向对象的设计原则，它说你不应该调用从其他调用中接收到的对象的方法。换句话说：只与你直接的朋友交谈。
- en: '![The Law of Demeter – Only talk to your immediate friends. The law is really'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![德米特尔法则-只与你直接的朋友交谈。这个法则实际上只是一个指导方针，是以一个面向方面的编程项目命名的，而这个项目又是以象征着自下而上哲学的希腊农业女神的名字命名的'
- en: only a guideline and is named after an aspect-oriented programming project,
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 只是一个指导方针，是以一个面向方面的编程项目命名的，
- en: which was, in turn, named after the Greek goddess of agriculture who signified
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是以农业女神的名字命名的，她象征着自下而上的哲学
- en: its bottom-up philosophy](images/m08----law-of-demeter.png)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其自下而上的哲学](images/m08----law-of-demeter.png)
- en: The Law of Demeter – Only talk to your immediate friends. The law is really
    only a guideline and is named after an aspect-oriented programming project, which
    was, in turn, named after the Greek goddess of agriculture who signified its bottom-up
    philosophy
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 德米特尔法则-只与你直接的朋友交谈。这个法则实际上只是一个指导方针，是以一个面向方面的编程项目命名的，而这个项目又是以象征着自下而上哲学的希腊农业女神的名字命名的
- en: 'We’ll now modify our `Flight` class to accept an aircraft object when it is
    constructed, and we’ll follow the Law of Demeter by adding a method to report
    the aircraft model. This method will delegate to `Aircraft` on behalf of the client
    rather than allowing the client to “reach through” the `Flight` and interrogate
    the `Aircraft` object directly:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将修改我们的`Flight`类，以在构造时接受一个飞机对象，并且我们将遵循德米特尔法则，通过添加一个方法来报告飞机型号。这个方法将代表客户委托`Aircraft`，而不是允许客户“通过”`Flight`并询问`Aircraft`对象：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve also added a docstring to the class. These work just like function and
    module docstrings, and must be the first non-comment line within the body of the
    class.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为类添加了一个文档字符串。这些工作方式就像函数和模块的文档字符串一样，并且必须是类主体内的第一个非注释行。
- en: 'We can now construct a flight with a specific aircraft:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以用特定的飞机构造一个航班：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Notice that we construct the `Aircraft` object and directly pass it to the `Flight`
    constructor without needing an intermediate named reference for it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们构造了`Aircraft`对象，并直接将其传递给`Flight`构造函数，而无需为其命名中间引用。
- en: '* * *'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Moment of zen
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禅宗时刻
- en: '![](images/m08----zen-complex-is-better-than-complicated.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](images/m08----zen-complex-is-better-than-complicated.png)'
- en: 'The `aircraft_model()` method is an example of ‘complex is better than complicated’:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`aircraft_model()`方法是“复杂比复杂好”的一个例子：'
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The Flight class is more *complex* – it contains additional code to drill down
    through the aircraft reference to find the model. However, all clients of `Flight`
    can now be less *complicated*; none of them need to know about the `Aircraft`
    class, dramatically simplifying the system.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Flight类更加*复杂*——它包含额外的代码来深入到飞机引用中找到模型。然而，所有的`Flight`客户端现在可以更少*复杂*；它们都不需要知道`Aircraft`类，从而大大简化了系统。
- en: '* * *'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: Booking seats
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预订座位
- en: Now we can proceed with implementing a simple booking system. For each flight
    we need to keep track of who is sitting in each seat. We’ll represent the seat
    allocations using a list of dictionaries. The list will contain one entry for
    each seat row, and each entry will be a dictionary mapping from seat-letter to
    occupant name. If a seat is unoccupied, the corresponding dictionary value will
    contain `None`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续实现一个简单的预订系统。对于每个航班，我们需要跟踪谁坐在每个座位上。我们将使用一个字典列表来表示座位分配。列表将包含每个座位行的一个条目，每个条目将是一个从座位字母到乘客姓名的映射的字典。如果一个座位没有被占用，相应的字典值将包含`None`。
- en: 'We initialize the seating plan in `Flight.__init__()` using this fragment:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Flight.__init__()`中使用这个片段初始化座位计划：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the first line we retrieve the seating plan for the aircraft and use tuple
    unpacking to put the row and seat identifiers into local variables `rows` and
    `seats`. In the second line we create a list for the seat allocations. Rather
    than continually deal with the fact that row indexes are one-based whereas Python
    lists use zero-based indexes, we choose to waste one entry at the beginning of
    the list. This first wasted entry is the single element list containing `None`.
    To this single element list we concatenate another list containing one entry for
    each real row in the aircraft. This list is constructed by a list comprehension
    which iterates over the `rows` object, which is the `range` of row numbers retrieved
    from the `_aircraft` on the previous line.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们检索飞机的座位计划，并使用元组解包将行和座位标识符放入本地变量`rows`和`seats`中。在第二行中，我们为座位分配创建一个列表。我们选择浪费列表开头的一个条目，而不是不断处理行索引是基于一的事实，而Python列表使用基于零的索引。这个第一个浪费的条目是包含`None`的单元素列表。对于飞机中的每一行，我们将这个列表连接到另一个列表中。这个列表是通过列表推导构建的，它遍历了从前一行的`_aircraft`中检索到的行号的`range`对象。
- en: '![The object graph for the seating-plan data structure, which is a list'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![座位计划数据结构的对象图，这是一个列表'
- en: of dictionaries.](images/m08----seating-data-structure.png)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 的字典。](images/m08----seating-data-structure.png)
- en: The object graph for the seating-plan data structure, which is a list of dictionaries.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 座位计划数据结构的对象图，这是一个字典列表。
- en: We’re not actually interested in the row number, since we know it will match
    up with the list index in the final list, so we discard it by using the dummy
    underscore variable.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上对行号不感兴趣，因为我们知道它将与最终列表中的列表索引匹配，所以我们通过使用虚拟下划线变量将其丢弃。
- en: The item expression part of the list comprehension is itself a comprehension;
    specifically a dictionary comprehension! This iterates over each row letter, and
    creates a mapping from the single character string to `None` to indicate an empty
    seat.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导的项目表达式本身就是一个推导；具体来说是一个字典推导！这遍历每个行字母，并创建从单个字符字符串到`None`的映射，以指示空座位。
- en: We use a list comprehension, rather than list replication with the multiplication
    operator, because we want a distinct dictionary object to be created for each
    row; remember, repetition is shallow.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用列表推导，而不是使用乘法运算符进行列表复制，因为我们希望为每一行创建一个不同的字典对象；记住，重复是浅层的。
- en: 'Here’s the code after we put it into the initializer:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将代码放入初始化程序后，代码如下：
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Before we go further, let’s test our code in the REPL:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步之前，让我们在REPL中测试我们的代码：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Thanks to the fact that everything is “public” we can access implementation
    details during development. It’s clear enough that we’re deliberately defying
    convention here during development, since the leading underscore reminds us what’s
    “public” and what’s “private”:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都是“公开的”，我们可以在开发过程中访问实现细节。很明显，我们在开发过程中故意违反了惯例，因为前导下划线提醒我们什么是“公开的”和什么是“私有的”：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That’s accurate, but not particularly beautiful. Let’s try again with pretty-print:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是准确的，但不是特别美观。让我们尝试用漂亮的打印：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Perfect!
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！
- en: Allocating seats to passengers
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为乘客分配座位
- en: 'Now we’ll add behavior to `Flight` to allocate seats to passengers. To keep
    this simple, a passenger will be a string name:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将为`Flight`添加行为，将座位分配给乘客。为了保持简单，乘客将是一个字符串名称：
- en: '[PRE27]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Most of this code is validation of the seat designator and it contains some
    interesting snippets:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码都是座位指示符的验证，其中包含一些有趣的片段：
- en: 'Line 6: Methods are functions, so deserve docstrings too.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第6行：方法是函数，因此也应该有文档字符串。
- en: 'Line 17: We get the seat letter by using negative indexing into the `seat`
    string.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第17行：我们通过在`seat`字符串中使用负索引来获取座位字母。
- en: 'Line 18: We test that the seat letter is valid by checking for membership of
    `seat_letters` using the `in` membership testing operator.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第18行：我们通过使用`in`成员测试运算符检查`seat_letters`的成员资格来测试座位字母是否有效。
- en: 'Line 21: We extract the row number using string slicing to take all but the
    last character.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第21行：我们使用字符串切片提取行号，以去掉最后一个字符。
- en: 'Line 23: We try to convert the row number substring to an integer using the
    `int()` constructor. If this fails, we catch the `ValueError` and in the handler
    raise a *new* `ValueError` with a more appropriate message payload.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第23行：我们尝试使用`int()`构造函数将行号子字符串转换为整数。如果失败，我们捕获`ValueError`，并在处理程序中引发一个更合适的消息负载的*新*`ValueError`。
- en: 'Line 27: We conveniently validate the row number by using the `in` operator
    against the `rows` object which is a `range`. We can do this because `range()`
    objects support the *container* protocol.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第27行：我们通过使用`in`运算符对`rows`对象进行验证行号。我们可以这样做，因为`range()`对象支持*容器*协议。
- en: 'Line 30: We check that the requested seat is unoccupied using an identity test
    with `None`. If it’s occupied we raise a `ValueError`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第30行：我们使用`None`进行身份测试来检查请求的座位是否空闲。如果被占用，我们会引发`ValueError`。
- en: 'Line 33: If we get this far, everything is is good shape, and we can assign
    the seat.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第33行：如果我们走到这一步，一切都很好，我们可以分配座位。
- en: This code also contains a bug, which we’ll discover soon enough!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也包含一个错误，我们很快就会发现！
- en: 'Trying our seat allocator at the REPL:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在REPL中尝试我们的座位分配器：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Oh dear! Early on in your object-oriented Python career you’re likely to see
    `TypeError` messages like this quite often. The problem has occurred because we
    forgot to include the `self` argument in the definition of the `allocate_seat()`
    method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，天哪！在你的面向对象的Python职业生涯早期，你很可能经常会看到像这样的`TypeError`消息。问题出现在我们忘记在`allocate_seat()`方法的定义中包含`self`参数：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we fix that, we can try again:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们修复了这个问题，我们可以再试一次：
- en: '[PRE30]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The Dutchman is quite lonely there in row 12, so we’d like to move him back
    to row 15 with the Danes. To do so, we’ll need a `relocate_passenger()` method.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 荷兰人在12排有些孤单，所以我们想把他和丹麦人一起移回15排。为此，我们需要一个`relocate_passenger()`方法。
- en: Naming methods for implementation details
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为实现细节命名方法
- en: 'First we’ll perform a small refactoring and extract the seat designator parsing
    and validation logic into it’s own method, `_parse_seat()`. We use a leading underscore
    here because this method is an implementation detail:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将进行一些小的重构，并将座位标识符解析和验证逻辑提取到它自己的方法`_parse_seat()`中。我们在这里使用了前导下划线，因为这个方法是一个实现细节：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The new `_parse_seat()` method returns a tuple with an integer row number and
    a seat letter string. This has made `allocate_seat()` much simpler:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`_parse_seat()`方法返回一个整数行号和一个座位字母字符串的元组。这使得`allocate_seat()`变得更简单：
- en: '[PRE32]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice how the call to `_parse_seat()` also requires explicit qualification
    with the `self` prefix.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到调用`_parse_seat()`也需要使用`self`前缀进行显式限定。
- en: Implementing `relocate_passenger()`
  id: totrans-138
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实现`relocate_passenger()`
- en: 'Now we’ve laid the groundwork for our `relocate_passenger()` method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为我们的`relocate_passenger()`方法奠定了基础：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This parses and validates the `from_seat` and `to_seat` arguments and then moves
    the passenger to the new location.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这解析和验证了`from_seat`和`to_seat`参数，然后将乘客移动到新位置。
- en: 'It’s also getting tiresome recreating the `Flight` object each time, so we’ll
    add a *module* level convenience function for that too:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 每次重新创建`Flight`对象也变得很烦人，所以我们也会为此添加一个*模块*级别的便利函数：
- en: '[PRE34]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In Python it’s quite normal to mix related functions and classes in the same
    module. Now, from the REPL:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，将相关的函数和类混合放在同一个模块中是非常正常的。现在，从REPL：
- en: '[PRE35]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You may find it remarkable that we have access to the `Flight` class when we
    have only imported a single function, `make_flight`. This is quite normal and
    it’s a powerful aspect of Python’s dynamic type system that facilitates this very
    loose coupling between code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得很奇怪，我们只导入了一个函数`make_flight`，但我们却可以访问`Flight`类。这是非常正常的，这是Python动态类型系统的一个强大方面，它促进了代码之间的这种非常松散的耦合。
- en: 'Let’s get on and move Guido back to row 15 with his fellow Europeans:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续把Guido移回到15排和他的欧洲同胞一起：
- en: '[PRE36]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Counting available seats
  id: totrans-149
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 计算可用座位
- en: 'It’s important during booking to know how many seats are available. To this
    end we’ll write a `num_available_seats()` method. This uses two nested generator
    expressions. The outer expression filters for all rows which are not `None` to
    exclude our dummy first row. The value of each item in the outer expression is
    the sum of the number of `None` values in each row. This inner expression iterates
    over values of the dictionary and adds 1 for each `None` found:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在预订期间知道有多少个座位是很重要的。为此，我们将编写一个`num_available_seats()`方法。这使用了两个嵌套的生成器表达式。外部表达式过滤出所有不是`None`的行，以排除我们的虚拟第一行。外部表达式中每个项目的值是每行中`None`值的总和。内部表达式遍历字典的值，并为每个找到的`None`添加1：
- en: '[PRE37]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Notice how we have split the outer expression over three lines to improve readability.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将外部表达式分成三行以提高可读性。
- en: '[PRE38]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A quick check shows that our new calculation is correct:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 快速检查显示我们的新计算是正确的：
- en: '[PRE39]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Sometimes the only object you need is a function
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有时你只需要一个函数
- en: Now we’ll show how it’s quite possible to write nice object-oriented code without
    needing classes. We have a requirement to produce boarding cards for our passengers
    in alphabetical order. However, we realize that the flight class is probably not
    a good home for details of printing boarding passes. We could go ahead and create
    a `BoardingCardPrinter` class, although that is probably overkill. Remember that
    functions are objects too and are perfectly sufficient for many cases. Don’t feel
    compelled to make classes without good reason.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将展示如何在不需要类的情况下编写良好的面向对象代码是完全可能的。我们需要按字母顺序为乘客制作登机牌。但是，我们意识到航班类可能不是打印登机牌的细节的好位置。我们可以继续创建一个`BoardingCardPrinter`类，尽管这可能有些过度。记住，函数也是对象，对于许多情况来说完全足够。不要觉得没有充分理由就要创建类。
- en: Rather than have a card printer query all the passenger details from the flight,
    we’ll follow the object-oriented design principle of “Tell! Don’t Ask.” and have
    the `Flight` *tell* a simple card printing function what to do.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望让卡片打印机从航班中查询所有乘客的详细信息，我们将遵循面向对象设计原则“告诉！不要问。”，让`Flight` *告诉*一个简单的卡片打印函数该做什么。
- en: 'First the card printer, which is just a module level function:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是卡片打印机，它只是一个模块级函数：
- en: '[PRE40]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: A Python feature we’re introducing here is the use of line continuation backslash
    characters, ‘\’, which allow us to split long statements over several lines. This
    is used here, together with implicit string concatenation of adjacent strings,
    to produce one long string with no line breaks.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入的一个Python特性是使用行继续反斜杠字符‘\’，它允许我们将长语句分成几行。这里使用了它，连同相邻字符串的隐式连接，以产生一个没有换行的长字符串。
- en: We measure the length of this output line, build some banners and borders around
    it and, concatenate the lines together using the `join()` method called on a newline
    separator. The whole card is then printed, followed by a blank line. The card
    printer doesn’t know anything about `Flights` or `Aircraft` – it’s very loosely
    coupled. You can probably easily envisage an HTML card printer that has the same
    interface.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们测量这个输出行的长度，围绕它建立一些横幅和边框，然后使用`join()`方法将行连接在一起，该方法在换行符上调用。然后打印整张卡片，然后是一个空行。卡片打印机对`Flights`或`Aircraft`一无所知-它们之间的耦合非常松散。您可能很容易想象具有相同接口的HTML卡片打印机。
- en: Making `Flight` create boarding cards
  id: totrans-163
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使`Flight`创建登机牌
- en: 'To the `Flight` class we add a new method `make_boarding_cards()` which accepts
    a `card_printer`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`Flight`类添加一个新方法`make_boarding_cards()`，它接受一个`card_printer`：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This tells the `card_printer` to print each passenger, having sorted a list
    of passenger-seat tuples obtained from a `_passenger_seats()` implementation detail
    method (note the leading underscore). This method is in fact a generator function
    which searches all seats for occupants, yielding the passenger and the seat number
    as they are found:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉`card_printer`打印每个乘客，已经排序了从`_passenger_seats()`实现细节方法（注意前导下划线）获得的乘客-座位元组列表。实际上，这个方法是一个生成器函数，它搜索所有座位的占用情况，找到后产生乘客和座位号：
- en: '[PRE42]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now if we run this on the REPL, we can see that the new boarding card printing
    system works:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们在REPL上运行这个，我们可以看到新的登机牌打印系统起作用了：
- en: '[PRE43]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Polymorphism and duck-typing
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态和鸭子类型
- en: Polymorphism is a programming language feature which allows us to use objects
    of different types through a uniform interface. The concept of polymorphism applies
    to both functions and more complex objects. We’ve just seen an example of polymorphism
    with the card printing example. The `make_boarding_card()` method didn’t need
    to know about an actual – or as we say “concrete” – card printing type, only the
    abstract details of its interface. This interface is essentially just the order
    of it’s arguments. Replacing our `console_card_printer` with a putative `html_card_printer`
    would exercise polymorphism.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是一种编程语言特性，它允许我们通过统一接口使用不同类型的对象。多态的概念适用于函数和更复杂的对象。我们刚刚在卡片打印示例中看到了多态的一个例子。`make_boarding_card()`方法不需要知道实际的-或者我们说“具体的”-卡片打印类型，只需要知道其接口的抽象细节。这个接口本质上只是它的参数顺序。用假想的`html_card_printer`替换我们的`console_card_printer`将会实现多态。
- en: Polymorphism in Python is achieved through duck typing. Duck typing is in turn
    named after the “duck test”, attributed to James Whitcomb Riley, the American
    poet.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Python中的多态是通过鸭子类型实现的。鸭子类型又以美国诗人詹姆斯·惠特科姆·赖利的“鸭子测试”而命名。
- en: '![James Whitcomb Riley – American poet and author](images/m08----james-whitcomb-riley.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![詹姆斯·惠特科姆·赖利-美国诗人和作家](images/m08----james-whitcomb-riley.png)'
- en: James Whitcomb Riley – American poet and author
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 詹姆斯·惠特科姆·赖利-美国诗人和作家
- en: When I see a bird that walks like a duck and swims like a duck and quacks like
    a duck, I call that bird a duck.
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当我看到一只走路像鸭子、游泳像鸭子、嘎嘎叫像鸭子的鸟时，我就称那只鸟为鸭子。
- en: Duck typing, where an object’s fitness for a particular use is only determined
    at runtime, is the cornerstone of Python’s object system. This is different from
    many statically typed languages where a compiler determines if an object can be
    used. In particular, it means that an object’s suitability is not based on inheritance
    hierarchies, base classes, or anything except the attributes an object has *at
    the time of use*.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型，其中对象的适用性仅在运行时确定，是Python对象系统的基石。这与许多静态类型的语言不同，其中编译器确定对象是否可以使用。特别是，这意味着对象的适用性不是基于继承层次结构、基类或除了对象在使用时具有的属性之外的任何东西。
- en: This is in stark contrast to languages such as Java which depend on what is
    called *nominal sub-typing* through inheritance from base classes and interfaces.
    We’ll talk more about inheritance in the context of Python shortly.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这与诸如Java之类的语言形成鲜明对比，后者依赖于所谓的*名义子类型*，通过从基类和接口继承。我们很快会在Python的上下文中更多地讨论继承。
- en: Refactoring `Aircraft`
  id: totrans-178
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 重构`Aircraft`
- en: 'Let’s return to our `Aircraft` class:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`Aircraft`类：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The design of this class is somewhat flawed, in that objects instantiated using
    it depend on being supplied with a seating configuration that matches the aircraft
    model. For the purposes of this exercise we can assume that the seating arrangement
    is fixed per aircraft model.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的设计有些缺陷，因为使用它实例化的对象依赖于提供与飞机型号匹配的座位配置。在这个练习中，我们可以假设每架飞机型号的座位安排是固定的。
- en: 'Better, and simpler, perhaps to get rid of the `Aircraft` class entirely and
    make separate classes for each specific model of aircraft with a fixed seating
    configuration. Here’s an Airbus A319:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也许更好、更简单的方法是完全摆脱`Aircraft`类，并为每种特定型号的飞机制作单独的类，具有固定的座位配置。这是空中客车A319：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'And here’s a Boeing 777:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是波音777：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: These two aircraft classes have no explicit relationship to each other, or to
    our original `Aircraft` class, beyond having identical interfaces (with the exception
    of the initializer, which now takes fewer arguments). As such we can use these
    new types in place of each other.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个飞机类与彼此或我们原始的`Aircraft`类之间没有明确的关系，除了具有相同的接口（初始化程序除外，现在需要的参数更少）。因此，我们可以在彼此之间使用这些新类型。
- en: 'Let’s change our `make_flight()` method to `make_flights()` so we can use them:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的`make_flight()`方法更改为`make_flights()`，这样我们就可以使用它们了：
- en: '[PRE47]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The different types of aircraft both work fine when used with `Flight` because
    they both quack like ducks. Or fly like planes. Or something:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不同类型的飞机在与`Flight`一起使用时都可以正常工作，因为它们都像鸭子一样嘎嘎叫。或者像飞机一样飞。或者其他什么：
- en: '[PRE48]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Duck typing and polymorphism is very important in Python. In fact it’s the basis
    for the collection protocols we discussed such as *iterator*, *iterable* and *sequence*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 鸭子类型和多态在Python中非常重要。事实上，它是我们讨论的集合协议的基础，如*迭代器*、*可迭代*和*序列*。
- en: Inheritance and implementation sharing
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承和实现共享
- en: Inheritance is a mechanism whereby one class can be *derived* from a base-class
    allowing us to make behavior more specific in the subclass. In nominally typed
    languages such as Java, class-based inheritance is the means by which run-time
    polymorphism is achieved. Not so in Python, as we have just demonstrated. The
    fact that no Python method calls or attribute lookups are bound to actual objects
    until the point at which they are called – known as *late-binding* – means we
    can attempt polymorphism with any object and it will succeed if the object fits.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一种机制，其中一个类可以从基类*派生*，从而使我们能够在子类中使行为更具体。在像Java这样的名义类型语言中，基于类的继承是实现运行时多态性的手段。但在Python中并非如此，正如我们刚刚展示的那样。直到调用方法或属性查找的实际对象绑定到对象时，即*延迟绑定*，我们才能尝试使用任何对象进行多态，并且如果对象合适，它将成功。
- en: Although inheritance in Python can be used to facilitate polymorphism – after
    all, derived classes will have the same interfaces as base classes – inheritance
    in Python is most useful for sharing implementation between classes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Python中的继承可以用于促进多态性——毕竟，派生类将具有与基类相同的接口——但Python中的继承最有用的是在类之间共享实现。
- en: A base class for aircraft
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 飞机的基类
- en: 'As usual, this will make much more sense with an example. We would like our
    aircraft classes `AirbusA319` and `Boeing777` to provide a way of returning the
    total number of seats. We’ll add a method called `num_seats()` to both classes
    to do this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，通过示例会更容易理解。我们希望我们的飞机类`AirbusA319`和`Boeing777`提供一种返回总座位数的方法。我们将在两个类中添加一个名为`num_seats()`的方法来实现这一点：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The implementation can be identical in both classes, since it can be calculated
    from the seating plan.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可以从座位计划中计算出来，所以两个类中的实现可以是相同的。
- en: Unfortunately, we now have duplicate code across two classes, and as we add
    more aircraft types the code duplication will worsen.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，现在我们在两个类中有重复的代码，随着我们添加更多的飞机类型，代码重复将变得更糟。
- en: 'The solution is to extract the common elements of `AirbusA319` and `Boeing777`
    into a base class from which both aircraft types will derive. Let’s recreate the
    class `Aircraft`, this time with the goal of using it as a base class:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是将`AirbusA319`和`Boeing777`的共同元素提取到一个基类中，两种飞机类型都将从中派生。让我们重新创建`Aircraft`类，这次的目标是将其用作基类：
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The `Aircraft` class contains just the method we want to inherit into the derived
    classes. This class isn’t usable on its own because it depends on a method called
    `seating_plan()` which isn’t available at this level. Any attempt to use it standalone
    will fail:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`Aircraft`类只包含我们想要继承到派生类中的方法。这个类本身无法使用，因为它依赖于一个叫做`seating_plan()`的方法，这个方法在这个级别不可用。任何尝试单独使用它都会失败：'
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The class is *abstract* insofar as it is never useful to instantiate it alone.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 类在*抽象*方面是不可用的，因为单独实例化它是没有用的。
- en: Inheriting from `Aircraft`
  id: totrans-205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从`Aircraft`继承
- en: Now for the derived classes. We specify inheritance in Python using parentheses
    containing the base class name immediately after the class name in the `class`
    statement.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是派生类。我们使用括号在`class`语句中的类名后面立即包含基类名来指定Python中的继承。
- en: 'Here’s the Airbus class:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这是空客类：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'And this is the Boeing class:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是波音类：
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Let’s exercise them at the REPL:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在REPL中练习一下：
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We can see that both subtype aircraft inherited the `num_seats method()`, which
    now works as expected because the call to `seating_plan()` is successfully resolved
    on the `self` object at runtime.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到两个子类型飞机都继承了`num_seats`方法，现在它可以正常工作，因为在运行时成功解析了对`seating_plan()`的调用。
- en: Hoisting common functionality into a base class
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将通用功能提升到基类
- en: 'Now we have the base `Aircraft` class we can refactor by hoisting into it other
    common functionality. For example, both the initializer and `registration()` methods
    are identical between the two subtypes:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本的`Aircraft`类，我们可以通过将其他通用功能提升到其中来进行重构。例如，初始化程序和`registration()`方法在两个子类型之间是相同的：
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: These derived classes only contain the specifics for that aircraft type. All
    general functionality is shared from the base class by inheritance.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这些派生类只包含该飞机类型的具体信息。所有通用功能都是通过继承从基类中共享的。
- en: Thanks to duck-typing, inheritance is less used on Python than in other languages.
    This is generally seen as a good thing because inheritance is a very tight coupling
    between classes.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于鸭子类型的存在，继承在Python中的使用要少于其他语言。这通常被认为是一件好事，因为继承是类之间非常紧密的耦合。
- en: Summary
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: All types in Python have a ‘class’.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的所有类型都有一个“类”。
- en: Classes define the structure and behavior of an object.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类定义了对象的结构和行为。
- en: The class of an object is determined when the object is created and is almost
    always fixed for the lifetime of the object.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象的类是在创建对象时确定的，几乎总是在对象的生命周期内固定的。
- en: Classes are the key support for Object-Oriented Programming in Python.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是Python中面向对象编程的关键支持。
- en: Classes are defined using the `class` keyword followed by the class name, which
    is in CamelCase.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是使用`class`关键字定义的，后面跟着类名，类名采用驼峰命名法。
- en: Instances of a class are created by calling the class as if it were a function.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类的实例是通过调用类来创建的，就好像它是一个函数一样。
- en: Instance methods are functions defined inside the class which should accept
    an object instance called `self` as the first parameter.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法是在类内部定义的函数，应该接受一个名为`self`的对象实例作为第一个参数。
- en: Methods are called using the `instance.method()` syntax which is syntactic sugar
    for passing the instance as the formal `self` argument to the method.
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法是使用`instance.method()`语法调用的，这是将实例作为形式参数`self`传递给方法的语法糖。
- en: An optional special initializer method called `__init__()` can be provided which
    is used to configure the `self` object at creation time.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以提供一个可选的特殊初始化方法`__init__()`，用于在创建时配置`self`对象。
- en: The constructor calls the `__init__()` method if one is present.
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在构造函数，则调用`__init__()`方法。
- en: The `__init__()` method is *not* the constructor. The object has been already
    constructed by the time the initializer is called. The initializer configures
    the newly created object before it it returned to the caller of the constructor.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__init__()`方法*不是*构造函数。在初始化程序被调用时，对象已经被构造。初始化程序在返回给构造函数的调用者之前配置新创建的对象。'
- en: Arguments passed to the constructor are forwarded to the initializer.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递给构造函数的参数将转发到初始化程序。
- en: Instance attributes are brought into existence by assigning to them.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例属性通过分配给它们而存在。
- en: Attributes and methods which are implementation details are by convention prefixed
    with an underscore. There are no public, protected or private access modifiers
    in Python.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照惯例，实现细节的属性和方法以下划线为前缀。Python中没有公共、受保护或私有访问修饰符。
- en: Access to implementation details from outside the class can be very useful during
    development, testing and debugging.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类外部访问实现细节在开发、测试和调试过程中非常有用。
- en: Class invariants should be established in the initializer. If the invariants
    can’t be established raise exceptions to signal failure.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类不变量应该在初始化程序中建立。如果不变量无法建立，则引发异常以表示失败。
- en: Methods can have docstrings, just like regular functions.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法可以有文档字符串，就像常规函数一样。
- en: Classes can have docstrings.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类可以有文档字符串。
- en: Even within an object method calls must be qualified with `self`.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使在对象方法内部，方法调用也必须用`self`限定。
- en: You can have as many classes and functions in a module as you wish. Related
    classes and global functions are usually grouped together this way.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在一个模块中拥有任意多的类和函数。相关的类和全局函数通常以这种方式分组在一起。
- en: Polymorphism in Python is achieved through duck typing where attributes and
    methods are only resolved at point of use - a behaviour called late-binding.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的多态是通过鸭子类型实现的，其中属性和方法仅在使用时解析 - 这种行为称为延迟绑定。
- en: Polymorphism in Python does not require shared base classes or named interfaces.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的多态不需要共享基类或命名接口。
- en: Class inheritance in Python is primarily useful for sharing implementation rather
    than being necessary for polymorphism.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python中的类继承主要用于共享实现，而不是必须的多态。
- en: All methods are inherited, including special methods like the initialiser.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有方法都被继承，包括初始方法。
- en: 'Along the way we found that:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们发现：
- en: Strings support slicing, because they implement the *sequence* protocol.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串支持切片，因为它们实现了*序列*协议。
- en: Following the Law of Demeter can reduce coupling.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循迪米特法则可以减少耦合。
- en: We can nest comprehensions.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以嵌套理解。
- en: It can sometimes be useful to discard the current item in a comprehension using
    a dummy reference, conventionally the underscore.
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，在理解中丢弃当前项目是有用的，使用一个虚拟引用，通常是下划线。
- en: When dealing with one-based collections it’s often easier just to waste the
    zeroth list entry.
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理基于一的集合时，通常更容易只浪费第零个列表条目。
- en: Don’t feel compelled to use classes when a simple function will suffice. Functions
    are also objects.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个简单的函数足够时，不要感到被迫使用类。函数也是对象。
- en: Complex comprehensions or generator expressions can be split over multiple lines
    to aid readability.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的理解或生成器表达式可以分成多行以帮助可读性。
- en: Statements can be split over multiple lines using the backslash line continuation
    character. Use this feature sparingly and only when it improves readability.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句可以使用反斜杠行继续字符分成多行。只有在提高可读性时才节俭地使用这个功能。
- en: Object-oriented design where one object *tells* another information can be more
    loosely coupled than those where one object queries another. “Tell! Don’t ask.”
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的设计，其中一个对象*告诉*另一个对象信息，可以比其中一个对象查询另一个对象更松散耦合。“告诉！不要问。”
