- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Visualizing Data Using the Canvas Widget
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Canvas小部件可视化数据
- en: With months of experimental data logged in the database, it's time to begin
    the process of visualizing and interpreting it. Rather than exporting data into
    a spreadsheet to create charts and graphs, your fellow analysts have asked whether
    the program itself can create graphical data visualizations. Indeed it can! To
    implement this feature, you're going to need to learn about Tkinter's `Canvas`
    widget.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库中记录了几个月的实验数据后，是时候开始可视化和解释这些数据的过程了。与其将数据导出到电子表格中创建图表和图形，你的同事分析师们询问程序本身是否可以创建图形数据可视化。确实可以！为了实现这个功能，你需要了解Tkinter的`Canvas`小部件。
- en: 'In this chapter, you''ll implement data visualizations as you learn the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将在学习以下主题的同时实现数据可视化：
- en: In *Drawing and animation with Tkinter's Canvas*, you'll learn to use the `Canvas`
    widget for drawing and animation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“使用Tkinter的Canvas进行绘制和动画”中，你将学习如何使用`Canvas`小部件进行绘制和动画
- en: In *Creating simple graphs using Canvas*, we'll build a simple line graph using
    the Tkinter `Canvas`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“使用Canvas创建简单图表”中，我们将使用Tkinter `Canvas`构建一个简单的线形图
- en: In *Advanced graphs using Matplotlib*, we'll learn to integrate the Matplotlib
    library for more powerful charting and graphic capabilities
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在“使用Matplotlib创建高级图表”中，我们将学习如何集成Matplotlib库以获得更强大的图表和图形功能
- en: Drawing and animation with Tkinter's Canvas
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Tkinter的Canvas进行绘制和动画
- en: The `Canvas` widget is undoubtedly one of the most powerful widgets available
    in Tkinter. It can be used to build anything from custom widgets and views to
    complete user interfaces.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`小部件无疑是Tkinter中最强大的小部件之一。它可以用来构建从自定义小部件和视图到完整用户界面的任何东西。'
- en: As the name implies, a `Canvas` widget is a blank area on which figures and
    images can be drawn. To understand its basic usage, let's create a small demo
    script.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，`Canvas`小部件是一个空白区域，可以在其上绘制图形和图像。为了理解其基本用法，让我们创建一个小型演示脚本。
- en: 'Begin the script by creating a root window and a `Canvas` object:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建根窗口和`Canvas`对象开始脚本：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Creating a `Canvas` object is just like creating any other Tkinter widget. In
    addition to the parent widget and `background` argument, we can also specify `width`
    and `height` arguments to set the size of the `Canvas`. Setting the size of a
    `Canvas` widget is important, because it defines not only the size of the widget
    but also the **viewport**; that is, the area in which our drawn objects will be
    visible. We can actually draw anywhere on the `Canvas`'s virtually infinite surface,
    but only the area inside the viewport will be visible.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Canvas`对象就像创建任何其他Tkinter小部件一样。除了父小部件和`background`参数外，我们还可以指定`width`和`height`参数来设置`Canvas`的大小。设置`Canvas`小部件的大小很重要，因为它不仅定义了小部件的大小，还定义了**视口**；即我们的绘制对象将可见的区域。我们实际上可以在`Canvas`的几乎无限表面上绘制任何地方，但只有视口内的区域才是可见的。
- en: We'll learn how to see the area outside the viewport below in the *Scrolling
    the Canvas* section.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在“滚动画布”部分学习如何查看视口下方的区域。
- en: Drawing on the Canvas
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布上绘制
- en: Once we have a `Canvas` object, we can start drawing items on it using its many
    `create_()` methods. These methods allow us to draw shapes, lines, images, and
    text. Let's explore these methods in more detail as we develop the `simple_canvas_demo.py`
    script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Canvas`对象，我们就可以开始使用其许多`create_()`方法在其上绘制项目。这些方法允许我们绘制形状、线条、图像和文本。随着我们开发`simple_canvas_demo.py`脚本，让我们更详细地探讨这些方法。
- en: Rectangles and squares
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形和正方形
- en: 'Rectangles or squares can be drawn on the `Canvas` using the `create_rectangle()`
    method, like so:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`create_rectangle()`方法在`Canvas`上绘制矩形或正方形，如下所示：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first four arguments of `create_rectangle()` are the coordinates of the
    upper-left and lower-right corners, counted in pixels from the upper-left corner
    of the `Canvas`. Each `create_()` method begins with positional arguments that
    define the position and size of the shape. Following those, we can specify a variety
    of keyword arguments to describe other aspects of the shape; for example, the
    `fill` option used here specifies the color of the inside of the object.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_rectangle()`的前四个参数是上左角和下右角的坐标，从`Canvas`的上左角开始计算像素。每个`create_()`方法都以位置参数开始，这些参数定义了形状的位置和大小。随后，我们可以指定各种关键字参数来描述形状的其他方面；例如，这里使用的`fill`选项指定了对象内部的颜色。'
- en: It's vital to understand that vertical coordinates on the `Canvas`, unlike coordinates
    on a typical chart, extend *down* from the top. For example, the coordinate (200,
    100) is 100 pixels *above* (200, 200). The same is true for coordinates on all
    Tkinter widgets, and in many other GUI programming environments as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理解`Canvas`上的垂直坐标非常重要，与典型图表上的坐标不同，它们是从顶部向下延伸的。例如，坐标(200, 100)比(200, 200)高100像素。对于所有Tkinter小部件上的坐标，以及许多其他GUI编程环境中的坐标也是如此。
- en: 'Coordinates can also be specified as tuple pairs, like so:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标也可以指定为元组对，如下所示：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Although this requires more characters, it improves readability considerably.
    The `create_rectangle()` method supports several other keyword arguments to configure
    the rectangle''s fill and outline, including the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这需要更多的字符，但它大大提高了可读性。`create_rectangle()`方法支持其他几个关键字参数来配置矩形的填充和轮廓，包括以下内容：
- en: '| Argument | Values | Description |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `dash` | Tuple of integers | Defines a dash pattern (see below) for the outline
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `dash` | 整数元组 | 定义轮廓的虚线模式（见下文）|'
- en: '| `outline` | Color string | Specifies a color for the border |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `outline` | 颜色字符串 | 指定边框的颜色 |'
- en: '| `width` | Integer | Specifies a width for the border |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `width` | 整数 | 指定边框的宽度 |'
- en: '| `stipple` | Bitmap name | Name of a bitmap pattern to use for the fill |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `stipple` | 位图名称 | 使用该位图模式进行填充的位图名称 |'
- en: Dashed or dotted lines can be defined on `Canvas` objects using a **dash pattern**.
    This is a tuple of integers that describes the number of pixels before switching
    between line and blank. For example, a `dash` value of `(5, 1, 2, 1)` would produce
    a repeating pattern of five pixels of line, one blank pixel, two pixels of line,
    and one blank.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`Canvas`对象上使用**虚线模式**定义虚线或点线。这是一个整数元组，描述了在切换线与空白之间的像素数。例如，`dash`值为`(5, 1,
    2, 1)`将产生一个重复的模式，包括五像素的线、一个空像素、两个像素的线和一个空像素。
- en: The `stipple` value allows you to specify a bitmap to be used for filling the
    shape instead of a solid fill. Tkinter comes with some built-in bitmap files,
    such as `gray75`, `gray50`, `gray25`, and `gray12` (each of which is filled with
    evenly spaced pixels at the specified percentage), or you can load in a `.xbm`
    file of your own using the format `@filename.xbm`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`stipple`值允许您指定用于填充形状的位图，而不是实心填充。Tkinter自带一些内置的位图文件，例如`gray75`、`gray50`、`gray25`和`gray12`（每个都填充了均匀分布的像素，百分比由指定），或者您可以使用格式`@filename.xbm`加载自己的`.xbm`文件。'
- en: Ovals, circles, and arcs
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 椭圆、圆形和圆弧
- en: 'In addition to rectangles, we can also create ovals and circles using the `create_oval()`
    method. Add an oval to the demo as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了矩形外，我们还可以使用`create_oval()`方法创建椭圆和圆形。以下是将椭圆添加到演示中的方法：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As with creating a rectangle, we begin by specifying the coordinates to describe
    the shape; however, this time the coordinates determine the upper-left and lower-right
    corners of its **bounding box**. A bounding box is the smallest rectangle that
    will contain an item. For example, in the case of this oval, the bounding box
    has corners at `(350, 200)` and `(450, 250)`. To make a circle, of course, we
    simply define an oval with a square bounding box.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建矩形类似，我们首先指定坐标来描述形状；然而，这次坐标决定了其**边界框**的左上角和右下角。边界框是包含一个项目的最小矩形。例如，在这个椭圆的情况下，边界框的角位于`(350,
    200)`和`(450, 250)`。要画一个圆形，当然，我们只需定义一个具有正方形边界框的椭圆。
- en: '`create_oval()` allows the same keyword arguments as `create_rectangle()` to
    configure the fill and outline of the shape.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_oval()`允许与`create_rectangle()`相同的关键字参数来配置形状的填充和轮廓。'
- en: 'If we want to draw only a sector of the oval, we can use the `create_arc()`
    method. This method works identically to `create_oval()`, but also takes `extent`
    and `start` keyword arguments. The `start` argument specifies the number of degrees
    from the origin at the left middle of the circle to the point where the drawing
    starts, and the `extent` argument specifies how many degrees counter-clockwise
    the arc will extend. For example, an `extent` of `90` and `start` of `180` will
    draw a quarter of the oval starting at the right side and going to the bottom,
    as shown here:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只想画椭圆的一部分，可以使用`create_arc()`方法。此方法与`create_oval()`工作方式相同，但也接受`extent`和`start`关键字参数。`start`参数指定从圆的左中点起原点到绘图开始点的角度数，而`extent`参数指定逆时针延伸的角度数。例如，`extent`为`90`和`start`为`180`将绘制从右侧开始到底部的四分之一椭圆，如图所示：
- en: '![](img/Image77828.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Image77828.png)'
- en: 'Figure 15.1: Drawing an arc'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：绘制圆弧
- en: 'Let''s add an arc to our demo:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的演示中添加一个圆弧：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Lines
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线条
- en: We can also draw lines on the `Canvas` using the `create_line()` method. As
    with rectangles, ovals, and arcs, we begin by specifying coordinates to define
    the line. Unlike with the shapes, the coordinates do not define a bounding box,
    but rather a set of points that define the line.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`create_line()`方法在`Canvas`上绘制线条。与矩形、椭圆和圆弧一样，我们首先指定坐标来定义线条。与形状不同，坐标不定义边界框，而是定义一组定义线条的点。
- en: 'Let''s add a line to our demo script, like so:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的演示脚本中添加一条线，如下所示：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, a straight line will be drawn from the first point at `(0,
    180)` to the second at `(1024, 180)`. The `fill` argument in this case defines
    the color of the line, and `width` determines how wide it is.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，将绘制一条从第一个点`(0, 180)`到第二个点`(1024, 180)`的直线。在这种情况下，`fill`参数定义了线的颜色，而`width`决定了它的宽度。
- en: 'The `create_line()` method is not limited to a single line between two points.
    We can specify any number of coordinate pairs as positional arguments, and Tkinter
    will connect them all from first to last. For example, add this to the demo:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`create_line()`方法不仅限于两点之间的一条线。我们可以指定任意数量的坐标对作为位置参数，Tkinter将从第一个到最后一个连接它们。例如，将以下内容添加到演示中：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This time we've created a more complex line with six points.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们创建了一条包含六个点的更复杂的线。
- en: 'Some of the additional arguments for `create_line()` are shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示了`create_line()`的一些附加参数：
- en: '| Argument | Values | Description |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 值 | 描述 |'
- en: '| `arrow` | `FIRST`, `LAST`, or `BOTH` | If specified, will draw arrows at
    the end of the line. Default is no value, indicating no arrows. |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| `arrow` | `FIRST`，`LAST`或`BOTH` | 如果指定，将在线条的末端绘制箭头。默认值为无值，表示没有箭头。|'
- en: '| `capstyle` | `BUTT`, `PROJECTING`, or `ROUND` | Specifies the style for the
    end of the line. Default is `BUTT`. |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| `capstyle` | `BUTT`，`PROJECTING`或`ROUND` | 指定线条末端的样式。默认为`BUTT`。|'
- en: '| `dash` | Tuple of integers | Defines the dash style for the line. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| `dash` | 整数元组 | 定义线的虚线样式。|'
- en: '| `joinstyle` | `ROUND`, `BEVEL`, or `MITER` | Specifies the style of corner
    joins. Default is `ROUND`. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `joinstyle` | `ROUND`，`BEVEL`或`MITER` | 指定角落连接的样式。默认为`ROUND`。|'
- en: '| `smooth` | Boolean | Whether to draw the line with spline curves or straight
    lines. Default is `False` (straight lines). |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `smooth` | 布尔值 | 是否用样条曲线绘制线条。默认为`False`（直线）。|'
- en: '| `tags` | Tuple of strings | Any number of tags to assign to the line. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `tags` | 字符串元组 | 可分配给线条的任意数量的标签。|'
- en: Polygons
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多边形
- en: The `Canvas` also allows us to draw arbitrary polygons; it works in a similar
    fashion to lines, in which each coordinate defines a point that will be connected
    to draw the outline of the polygon. The difference is that the last point and
    the first point will also be connected to form a closed shape.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`还允许我们绘制任意多边形；它的工作方式与线条类似，其中每个坐标定义一个点，该点将被连接以绘制多边形的轮廓。区别在于最后一个点和第一个点也将被连接以形成一个封闭形状。'
- en: 'Add a polygon to our demo script like so:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按如下方式将多边形添加到我们的演示脚本中：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that, unlike with `create_line()`, the `fill` argument defines the color
    of the polygon's interior, not the color of the outline. The appearance of the
    polygon's outline can be configured using the same arguments that `create_rectangle()`
    and `create_oval()` use.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与`create_line()`不同，`fill`参数定义的是多边形内部的颜色，而不是轮廓的颜色。多边形轮廓的外观可以通过与`create_rectangle()`和`create_oval()`相同的参数进行配置。
- en: Text
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本
- en: In addition to simple shapes, we can also place text directly on the `Canvas`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的形状，我们还可以直接在`Canvas`上放置文本。
- en: 'For example, let''s add some text to our demo:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们在我们的演示中添加一些文本：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The single coordinate argument determines the point where the text will be anchored
    to the `Canvas`. By default, the text is attached at its own center point to the
    anchor point. In this case, that means that the middle of our string (somewhere
    around the "a") will be at `x=500`, `y=100`. However, the `anchor` argument can
    be used to specify which part of the text item is attached to the anchor point;
    it can be any of the cardinal direction constants (`N`, `NW`, `W`, and so on)
    or `CENTER`, which is the default.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 单一坐标参数确定文本将锚定到`Canvas`上的位置。默认情况下，文本以其自身的中心点锚定到锚点。在这种情况下，这意味着我们字符串的中间（大约在“a”的位置）将在`x=500`，`y=100`。然而，`anchor`参数可以用来指定文本项的哪一部分被锚定到锚点；它可以是指定的任何基本方向常量（`N`，`NW`，`W`等）或`CENTER`，这是默认值。
- en: The `fill` argument in this case determines the color of the text, and we can
    use `font` to determine the font properties of the text. Tkinter 8.6 and later
    also offers an `angle` argument that can rotate the text by the given number of
    degrees.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`fill` 参数确定文本的颜色，我们可以使用 `font` 来确定文本的字体属性。Tkinter 8.6 及以后的版本还提供了一个 `angle`
    参数，可以旋转文本指定的角度。
- en: Images
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像
- en: 'Of course, we aren''t limited to just drawing lines and simple shapes on the
    `Canvas`; we can also place raster images using the `create_image()` method. This
    method allows us to place a `PhotoImage` or `BitmapImage` object on the `Canvas`,
    like so:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不仅限于在 `Canvas` 上绘制线条和简单的形状；我们还可以使用 `create_image()` 方法放置位图图像。此方法允许我们在 `Canvas`
    上放置 `PhotoImage` 或 `BitmapImage` 对象，如下所示：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As with text, the image is attached to the anchor coordinate at its center by
    default, but the `anchor` argument can be used to change that to any side or corner
    of the image's bounding box.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与文本一样，图像默认情况下通过其中心锚定坐标连接，但可以使用 `anchor` 参数将其更改为图像边界框的任何一边或角。
- en: Tkinter widgets
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tkinter 小部件
- en: The last thing we can place on the `Canvas` is another Tkinter widget. Of course,
    since the `Canvas` is a widget, we can just do this using a geometry manager like
    `pack()` or `grid()`, but we gain a lot more control if we add it as a `Canvas`
    item using `create_window()`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 `Canvas` 上放置的最后一件东西是另一个 Tkinter 小部件。当然，由于 `Canvas` 是一个小部件，我们可以使用 `pack()`
    或 `grid()` 这样的布局管理器来做到这一点，但如果我们将它作为 `Canvas` 项目使用 `create_window()` 添加，我们会获得更多的控制。
- en: To add a widget using `create_window()`, the widget need only be a child of
    a widget on the same parent window as the `Canvas` widget. We can then pass a
    reference to the widget to the method's `window` argument. We can also specify
    a `width` and `height` argument to determine the size of the window area to which
    the widget will be added; the widget will expand into that area by default.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `create_window()` 添加小部件，该小部件只需是 `Canvas` 小部件同一父窗口上的小部件的子项。然后我们可以将小部件的引用传递给方法的
    `window` 参数。我们还可以指定 `width` 和 `height` 参数来确定要添加小部件的窗口区域的大小；小部件将默认扩展到该区域。
- en: 'For example, let''s add a quit button to the demo:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们向演示中添加一个退出按钮：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just as with text and images, the widget is anchored to the given coordinate
    at its center by default, and the `anchor` argument can be used to attach it at
    a side or corner instead.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像文本和图像一样，小部件默认情况下通过其中心锚定到给定的坐标，可以使用 `anchor` 参数将其锚定到一边或角。
- en: Canvas items and state
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Canvas 项目和状态
- en: 'Note the use of the `activeforeground` and `activebackground` arguments in
    the code example above. Just like widgets, `Canvas` items can have various states
    set that can be used to dynamically change the appearance. The table below shows
    the available states for items, and what result they have:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上述代码示例中 `activeforeground` 和 `activebackground` 参数的使用。就像小部件一样，`Canvas` 项目可以设置各种状态，这些状态可以用来动态改变外观。下表显示了项目的可用状态及其结果：
- en: '| State | Trigger | Result |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 状态 | 触发 | 结果 |'
- en: '| `normal` | Default | Normal appearance |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `normal` | 默认 | 正常外观 |'
- en: '| `disabled` | Manual setting | Disabled appearance |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `disabled` | 手动设置 | 禁用外观 |'
- en: '| `active` | Mouse hovers over | Active appearance |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `active` | 鼠标悬停 | 活跃外观 |'
- en: '| `hidden` | Manual setting | Not shown |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `hidden` | 手动设置 | 不显示 |'
- en: All drawn items (that is, not images) have state-based versions of their `fill`,
    `outline`, `dash`, `width`, `stipple`, and `outlinestipple` arguments, which are
    simply the argument with `active` or `disabled` prefixed to it. For example, `activefill`
    sets the `fill` value when the item is hovered over by the mouse, while `disabledoutline`
    sets the outline color when the item is set to a `disabled` state. Image items
    have `disabledimage` and `activeimage` arguments that can be set to display a
    different image when the item is disabled or active.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有绘制的项目（即不是图像的项目）都有基于状态的 `fill`、`outline`、`dash`、`width`、`stipple` 和 `outlinestipple`
    参数的版本，这些参数只是前面加上 `active` 或 `disabled` 的参数。例如，`activefill` 在项目被鼠标悬停时设置 `fill`
    值，而 `disabledoutline` 在项目设置为 `disabled` 状态时设置轮廓颜色。图像项目有 `disabledimage` 和 `activeimage`
    参数，可以在项目禁用或活跃时显示不同的图像。
- en: The `active` state is automatically set when an item is hovered over by the
    mouse; the `disabled` and `hidden` states can be set using the `Canvas.itemconfigure()`
    method, which is discussed below in the *Canvas object methods* section.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当鼠标悬停在项目上时，会自动设置 `active` 状态；可以使用 `Canvas.itemconfigure()` 方法设置 `disabled` 和
    `hidden` 状态，该方法将在下面的 *Canvas 对象方法* 部分中讨论。
- en: Canvas object methods
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Canvas 对象方法
- en: '`Canvas` items are not represented by a Python object; instead, the return
    value of any `create_()` method is an integer that uniquely identifies the item
    in the context of the `Canvas` object. To manipulate `Canvas` items after they''ve
    been created, we need to save that identification value and pass it to various
    `Canvas` methods.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` 项目不是由一个 Python 对象表示；相反，任何 `create_()` 方法的返回值都是一个整数，它唯一地标识了在 `Canvas`
    对象上下文中该项目。为了在创建后操作 `Canvas` 项目，我们需要保存该标识值并将其传递给各种 `Canvas` 方法。'
- en: 'For example, we could save the ID of the image we added, then bind the image
    to a callback using the `Canvas.tag_bind()` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以保存我们添加的图像的 ID，然后使用 `Canvas.tag_bind()` 方法将图像绑定到一个回调：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we've used the `tag_bind()` method to bind a left-mouse click on our image
    object to the `Canvas`'s `delete()` method, which (when given an item identifier)
    deletes the item.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 `tag_bind()` 方法将我们的图像对象上的左键单击绑定到 `Canvas` 的 `delete()` 方法，该方法（当给定项目标识符时）会删除该项目。
- en: 'The `Canvas` object has many methods that can operate on a `Canvas` item; some
    of the more useful ones are listed in this table:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas` 对象具有许多可以对 `Canvas` 项目执行操作的方法；其中一些更有用的方法列在这个表中：'
- en: '| Method | Arguments | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 参数 | 描述 |'
- en: '| `bbox()` | Item ID | Returns a tuple describing the bounding box of the item.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `bbox()` | 项目 ID | 返回一个描述项目边界的元组。|'
- en: '| `coords()` | Item ID, coordinates | If only the ID is provided, returns the
    coordinates of the item. Otherwise, moves the item to the given coordinates. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `coords()` | 项目 ID，坐标 | 如果只提供 ID，则返回项目的坐标。否则，将项目移动到给定的坐标。|'
- en: '| `delete()` | Item ID | Deletes the item from the `Canvas`. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `delete()` | 项目 ID | 从 `Canvas` 中删除项目。|'
- en: '| `find_overlapping()` | Box coordinates | Returns a list of item IDs that
    overlap the box described by the coordinates. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `find_overlapping()` | 矩形坐标 | 返回一个列表，包含与由坐标描述的矩形重叠的项目 ID。|'
- en: '| `itemcget()` | Item ID, option | Returns the value of `option` for the given
    item. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `itemcget()` | 项目 ID，选项 | 返回给定项目的 `option` 值。|'
- en: '| `itemconfigure()` | Item ID, option | Sets one or more configuration options
    on the specified item. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `itemconfigure()` | 项目 ID，选项 | 在指定的项目上设置一个或多个配置选项。|'
- en: '| `move()` | Item ID, X, Y | Moves the item on the `Canvas` relative to its
    current position by the given `X` and `Y` amounts. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `move()` | 项目 ID，X，Y | 将项目在 `Canvas` 上相对于其当前位置移动给定 `X` 和 `Y` 的量。|'
- en: '| `type()` | Item ID | Returns a string describing the type of object (rectangle,
    oval, arc, and so on). |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `type()` | 项目 ID | 返回一个描述对象类型（矩形、椭圆、弧等）的字符串。|'
- en: Note that any of these methods that take an item ID can also take a **tag**.
    Recall from *Chapter 9*, *Improving the Look with Styles and Themes*, that a tag
    is just a string that can be assigned to an item when created, allowing us to
    refer to multiple items at once. The `Canvas` has two tags built in by default,
    `all` and `current`. As you might expect, `all` refers to all items on the `Canvas`,
    and `current` refers to the item that currently has focus.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何接受项目 ID 的这些方法也可以接受一个 **标签**。回想一下 *第 9 章*，*通过样式和主题改进外观*，标签只是一个字符串，可以在创建项目时分配给它，允许我们一次引用多个项目。`Canvas`
    默认有两个内置标签，`all` 和 `current`。正如你所期望的，`all` 指的是 `Canvas` 上的所有项目，而 `current` 指的是当前具有焦点的项目。
- en: All `create_()` methods allow the option of specifying a tuple of tag strings
    to attach to the object.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `create_()` 方法都允许指定一个字符串元组，将其附加到对象上。
- en: By the way, if you haven't yet, add `root.mainloop()` to the demo script and
    execute it to see what we've drawn!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，如果你还没有这样做，请将 `root.mainloop()` 添加到演示脚本中并执行它，以查看我们绘制了什么！
- en: Scrolling the Canvas
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动画布
- en: As mentioned earlier, the width and height of a `Canvas` widget determines the
    size of the viewport, but the actual drawable area on the widget stretches endlessly
    out in all directions. To actually see objects outside the viewport area, we need
    to enable scrolling.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`Canvas` 小部件的宽度和高度决定了视口的大小，但实际的绘制区域在部件的所有方向上无限延伸。要实际看到视口区域外的对象，我们需要启用滚动。
- en: 'To see how this works, let''s create a scrollable starfield; open a new file
    called `canvas_scroll.py` and let''s begin like so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解这是如何工作的，让我们创建一个可滚动的星系；打开一个名为 `canvas_scroll.py` 的新文件，并开始如下：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, we've imported `tkinter` and some functions from `random`, then created
    a root window and a `Canvas` object with a viewport size of 1024x768\. Finally,
    we've placed the `Canvas` on the root window using `grid()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们导入了 `tkinter` 和 `random` 的一些函数，然后创建了一个根窗口和一个具有 1024x768 视口大小的 `Canvas`
    对象。最后，我们使用 `grid()` 将 `Canvas` 放置在根窗口上。
- en: 'Now, let''s draw some "stars":'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制一些“星星”：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We begin by defining a list of color values, then start a `for` loop that will
    iterate 1000 times. Inside the loop, we'll generate random `X` and `Y` coordinates,
    a random size (`Z`), and choose one of the colors at random. We'll then have the
    `Canvas` draw a circle centered on the random point filled with the random color.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义一个颜色值列表，然后启动一个将迭代1000次的`for`循环。在循环内部，我们将生成随机的`X`和`Y`坐标，一个随机的大小（`Z`），并随机选择一种颜色。然后，我们将让`Canvas`在随机点上绘制一个填充随机颜色的圆。
- en: Notice that the ranges supplied for `X` and `Y` are double the size of the `Canvas`
    object. Because of this, the loop will be creating circles out to the right and
    down from our viewport area.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为`X`和`Y`提供的范围是`Canvas`对象大小的两倍。正因为如此，循环将创建从视口区域右侧和下方延伸出去的圆。
- en: 'To enable scrolling of the `Canvas`, we first have to define a `scrollregion`
    value for it, like so:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`Canvas`的滚动，我们首先必须为它定义一个`scrollregion`值，如下所示：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `scrollregion` value is a tuple of four integers that describe the bounding
    box of the area we want to be able to scroll. Essentially, the first two integers
    are the `X` and `Y` coordinates of the upper-left corner of the box, and the second
    two are the coordinates of the lower right.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`scrollregion`的值是一个包含四个整数的元组，描述了我们想要能够滚动的区域的边界框。本质上，前两个整数是框左上角的`X`和`Y`坐标，后两个是右下角的坐标。'
- en: To actually scroll the `Canvas`, we'll need some `Scrollbar` widgets. We've
    already encountered these in *Chapter 8*, *Navigating Records with Treeview and
    Notebook*, remember that to use them we need to create the widgets, add them to
    the layout, and connect the appropriate callbacks so that the scrollbars can communicate
    with the widget being scrolled.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际滚动`Canvas`，我们需要一些`Scrollbar`小部件。我们在*第8章*，*使用Treeview和Notebook导航记录*中已经遇到过这些小部件，记得要使用它们，我们需要创建小部件，将它们添加到布局中，并连接适当的回调函数，以便滚动条可以与被滚动的小部件通信。
- en: 'Add the following code to the script:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下代码添加到脚本中：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we've created two `Scrollbar` widgets, one for horizontal scrolling and
    one for vertical. We've added them to the layout just below and to the right of
    the `Canvas`, respectively. Then, we connect each scrollbar's `command` argument
    to the `Canvas`'s `xview` or `yview` method, and configure the `Canvas`'s `yscrollcommand`
    and `xscrollcommand` arguments to call the respective scrollbar's `set()` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了两个`Scrollbar`小部件，一个用于水平滚动，一个用于垂直滚动。我们将它们分别添加到`Canvas`下方和右侧的布局中。然后，我们将每个滚动条的`command`参数连接到`Canvas`的`xview`或`yview`方法，并将`Canvas`的`yscrollcommand`和`xscrollcommand`参数配置为调用相应滚动条的`set()`方法。
- en: 'Finish off this script with a call to `root.mainloop()` and execute it; you
    should see something like the picture here:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`root.mainloop()`来完成此脚本，并执行它；你应该会看到这里所示的内容：
- en: '![Figure 15.1: Scrolling through the stars!](img/B17578_15_02.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图15.1：滚动星星！](img/B17578_15_02.png)'
- en: 'Figure 15.2: Scrolling through the stars!'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：滚动星星！
- en: A handy trick to properly configure the scroll region after drawing runtime-defined
    points on the `Canvas` (for example, drawing based on user input) is to set `scrollregion`
    to the output of `canvas.bbox('all')` after creating the items. When passed a
    tag of `all`, the `bbox()` method returns a bounding box that contains the entirety
    of all items on the `Canvas`. You can set this value directly to `scrollregion`
    to make sure all your items can be viewed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Canvas`上绘制基于运行时定义的点（例如，基于用户输入）后正确配置滚动区域的一个实用技巧是将`scrollregion`设置为创建项目后`canvas.bbox('all')`的输出。当传递一个`all`标签时，`bbox()`方法返回一个包含`Canvas`上所有项目全部内容的边界框。您可以直接将此值设置为`scrollregion`，以确保您可以看到所有项目。
- en: Animating Canvas objects
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画Canvas对象
- en: Tkinter's `Canvas` widget doesn't have a built-in animation framework, but we
    can still create simple animations by combining its `move()` method with our understanding
    of the event queue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Tkinter的`Canvas`小部件没有内置的动画框架，但我们可以通过结合其`move()`方法与我们对事件队列的理解来创建简单的动画。
- en: To demonstrate this, we'll create a bug race simulator, in which two bugs (represented
    by colored circles) will race haphazardly toward a finish line on the other side
    of the screen. Like real bugs, they won't have any notion that they're in a race
    and will move relatively randomly, the winner being whichever bug incidentally
    hits the finish line first.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，我们将创建一个虫子赛跑模拟器，其中两个虫子（用彩色圆圈表示）将随意向屏幕另一侧的终点线冲刺。像真正的虫子一样，它们不会意识到自己在比赛中，并且会相对随机地移动，获胜者是偶然第一个撞到终点线的虫子。
- en: 'To begin, open a new Python file and start with a basic object-oriented pattern,
    like so:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开一个新的 Python 文件，并从一个基本的面向对象模式开始，如下所示：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is just a simple OOP Tkinter boilerplate application with a `Canvas` object
    added to the root window. This will be the basic platform on which we'll build
    our game code.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的 OOP Tkinter 模板应用程序，其中添加了一个 `Canvas` 对象到根窗口。这将是我们将构建游戏代码的基本平台。
- en: Setting up the playing field
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置比赛场地
- en: 'Now that we have the basic framework, let''s set up the playing field. We want
    to be able to reset the playing field after each round, so rather than doing this
    in the initializer, we''ll create a separate method called `setup()`, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了基本框架，让我们设置比赛场地。我们希望在每一轮之后能够重置比赛场地，因此我们不会在初始化器中这样做，而是创建一个单独的方法，称为 `setup()`，如下所示：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `setup()` method begins by calculating some relative locations on the `Canvas`
    object and saving them as instance properties, which will simplify the placement
    of objects on the `Canvas` object. Calculating these at runtime means we can resize
    the window between rounds for a longer or shorter racecourse.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup()` 方法首先在 `Canvas` 对象上计算一些相对位置，并将它们保存为实例属性，这将简化在 `Canvas` 对象上放置对象的过程。在运行时计算这些位置意味着我们可以在回合之间调整窗口大小，以适应更长或更短的赛道。'
- en: The finish line is implemented as a rectangle across the right edge of the window.
    Note the use of the `stipple` argument to specify a bitmap that will overlay the
    solid color to give it some texture; in this case, `gray50` is a built-in bitmap
    that alternates filled and transparent pixels. This gives us something a little
    more interesting than a flat color.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 终点线实现为一个横跨窗口右侧的矩形。注意使用 `stipple` 参数指定一个位图，该位图将叠加到纯色上，以给它一些纹理；在这种情况下，`gray50`
    是一个内置的位图，交替填充和不填充像素。这让我们得到一个比纯色更有趣的东西。
- en: 'Add a call to `setup()` at the end of `App.__init__()` as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `App.__init__()` 的末尾添加对 `setup()` 的调用，如下所示：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Because `setup()` relies on the width and height values of the `Canvas` object,
    we need to make sure it isn't called until the operating system's window manager
    has drawn and sized the window. The simplest way of doing this is to call `wait_visibility()`
    on the `Canvas` object, which will block execution until the object has been drawn.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `setup()` 依赖于 `Canvas` 对象的宽度和高度值，我们需要确保它不会在操作系统的窗口管理器绘制和调整窗口大小之前被调用。最简单的方法是在
    `Canvas` 对象上调用 `wait_visibility()`，这将阻塞执行，直到对象被绘制。
- en: Setting our players
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置我们的玩家
- en: 'Now that we have the playing field, we need to create our players. We''ll create
    a `Racer` class to represent a player; start it like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了比赛场地，我们需要创建我们的玩家。我们将创建一个 `Racer` 类来表示一个玩家；如下启动它：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `Racer` class will be created with a reference to the `Canvas` object and
    a color string, from which its color and name will be derived. We'll draw the
    racer initially at the middle left of the screen and make it 50 pixels in size.
    Finally, we save a reference to its item ID string in `self.id`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`Racer` 类将通过引用 `Canvas` 对象和一个颜色字符串来创建，其颜色和名称将从该字符串中派生。我们将最初在屏幕的左中位置绘制赛车，并使其大小为
    50 像素。最后，我们将其项目 ID 字符串的引用保存到 `self.id` 中。'
- en: 'Now, back in `App.setup()`, we''ll create two racers by adding the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到 `App.setup()`，我们将通过添加以下内容创建两个赛车：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: At this point, all the objects in our game are set up. Run the program and you
    should see a yellow-stippled finish line on the right and a green circle on the
    left (the red circle will be hidden under the green, since they're at the same
    coordinates).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们游戏中的所有对象都已设置。运行程序，你应该在右侧看到一个带有黄色斑点的终点线，在左侧看到一个绿色圆圈（红色圆圈将隐藏在绿色圆圈下面，因为它们位于相同的坐标）。
- en: Animating the racers
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画赛车
- en: To animate our racers, we're going to use the `Canvas.move()` method. As we
    learned earlier, `move()` takes an item ID, a number of `X` pixels, and a number
    of `Y` pixels, and moves the item by that amount. By combining this with the `random.randint()`
    function and some simple logic, we can generate a series of moves that will send
    each racer on a meandering path toward the finish line.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了动画赛车，我们将使用 `Canvas.move()` 方法。正如我们之前所学的，`move()` 接收一个项目 ID、一个 `X` 像素数和一个 `Y`
    像素数，并将项目移动这个量。通过结合这个方法与 `random.randint()` 函数和一些简单的逻辑，我们可以生成一系列移动，将每辆赛车引导到终点线的蜿蜒路径上。
- en: 'A simple implementation may look like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的实现可能看起来像这样：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method generates a random forward `X` movement, a random up-or-down `Y`
    movement, and a random time interval. We then use the `after()` method to schedule
    a call to `move()` for the generated `X` and `Y` movements after the random time
    interval. The `if` statement determines whether the racer's bounding box is currently
    at or beyond the right side of the screen; if this test evaluates to `False`,
    we schedule another call to `move_racer()`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法生成一个随机的向前`X`移动，一个随机的上下`Y`移动，以及一个随机的时间间隔。然后我们使用`after()`方法在随机时间间隔后安排对`move()`的调用，以生成`X`和`Y`移动。`if`语句确定赛车者的边界框是否当前位于屏幕的右侧或更远；如果此测试结果为`False`，我们将安排对`move_racer()`的另一次调用。
- en: This method gets the racers to the finish line, but it isn't quite what we want.
    The problem is that `move()` acts instantaneously, causing the bug to jump across
    the screen in jerky movements rather than moving smoothly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将赛车带到终点线，但这并不是我们想要的。问题是`move()`是瞬间发生的，导致错误在屏幕上跳跃，而不是平滑移动。
- en: 'To make the bugs move smoothly, we''re going to need to take a more complex
    approach:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使虫子移动得更平滑，我们需要采取更复杂的方法：
- en: First, we'll calculate a series of linear moves, each with a random delta `x`,
    delta `y`, and interval, that will reach the finish line
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将计算一系列线性移动，每个移动都有一个随机的`delta x`、`delta y`和间隔，这将达到终点线
- en: Then, we'll break each individual move into a number of steps determined by
    dividing the movement interval into a regular animation frame interval
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将每个单独的动作分解成由将移动间隔除以常规动画帧间隔确定的步骤数
- en: Next, we'll add each step of each movement to a queue
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将每个动作的每一步添加到队列中
- en: Finally, we'll call a method once each animation frame interval that will pull
    the next step from the queue and pass it to `move()`
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将在每个动画帧间隔调用一个方法，该方法将从队列中拉取下一个步骤并将其传递给`move()`
- en: 'Let''s start by defining our frame interval; in the `Racer` class, create a
    class attribute for this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先定义我们的帧间隔；在`Racer`类中，创建一个类属性来表示这个：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`FRAME_RES` (short for frame resolution) defines the number of milliseconds
    between each `Canvas.move()` call. 50 milliseconds gives us 20 frames per second
    and should be sufficient for smooth movements.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`FRAME_RES`（代表帧分辨率）定义了每个`Canvas.move()`调用之间的毫秒数。50毫秒给我们20帧每秒，应该足够平滑地移动。'
- en: 'Next, we need to import the `Queue` class and create an instance inside the
    `Racer` object''s initializer:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要导入`Queue`类并在`Racer`对象的初始化器中创建一个实例：
- en: '[PRE23]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we will create the method that will plot the course to the finish line:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个绘制到终点线路线的方法：
- en: '[PRE24]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This method plots a course from the left center of the `Canvas` to a random
    point on the right side by generating random `x` and `y` movements until the total
    change in `x` is greater than the width of the `Canvas` object. The change in
    `x` will always be positive, keeping our bugs moving toward the finish line, but
    the change in `y` can be positive or negative, to allow both upward and downward
    movement. To keep our bugs on the screen, we constrain the total `y` movements
    by negating any change in `y` that would put the player outside the top or bottom
    bounds of the `Canvas`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法通过生成随机的`x`和`y`移动，直到`x`的总变化量大于`Canvas`对象的宽度，从而在`Canvas`的左中心绘制一条路线到右侧的随机点。`x`的变化量始终为正，使我们的虫子向终点线移动，但`y`的变化量可以是正的或负的，以允许向上和向下移动。为了使我们的虫子保持在屏幕上，我们将通过否定任何将玩家置于`Canvas`顶部或底部边界之外的`y`变化来约束总的`y`移动。
- en: In addition to the random `dx` and `dy` values, we generate a random time interval
    for the move to take, between half a second and two seconds. Finally, the generated
    `dx`, `dy`, and `time` values are passed to a `queue_move()` method.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了随机的`dx`和`dy`值之外，我们还需要为移动生成一个随机的时间间隔，介于半秒和两秒之间。最后，生成的`dx`、`dy`和`time`值被传递给`queue_move()`方法。
- en: The `queue_move()` method will need to break the large move into individual
    frames of movement that describe how the racer should move in one `FRAME_RES`
    interval. To make this calculation, we will need a **partition function**, a mathematical
    function that will break an integer `N` into `K` approximately equal integers.
    For example, if we wanted to break `-10` into four parts, our function should
    return a list like `[-2, -2, -3, -3]`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`queue_move()`方法需要将大动作分解成单个动作帧，这些动作帧描述了赛车应该在`FRAME_RES`间隔内如何移动。为了进行这个计算，我们需要一个**分区函数**，这是一个数学函数，它将整数`N`分解成`K`个大约相等的整数。例如，如果我们想将`-10`分解成四个部分，我们的函数应该返回一个类似`[-2,
    -2, -3, -3]`的列表。'
- en: 'Let''s create `partition()` as a static method on `Racer`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 `Racer` 上创建一个名为 `partition()` 的静态方法：
- en: '[PRE25]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We start the method with the easy case: when `n` is `0`, return a list of `k`
    zeros.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从简单的情况开始这个方法：当 `n` 为 `0` 时，返回一个包含 `k` 个零的列表。
- en: 'Now, we''ll deal with the more complicated cases:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将处理更复杂的情况：
- en: '[PRE26]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For a non-zero `n`, we first calculate the `base_step` by dividing `n` by `k`
    using floor division, which rounds our result down to the nearest integer. Then,
    we create a list of length `k` that is made up of `base_step` values. Next, we
    need to distribute the remainder of `n / k` among this list as evenly as we can.
    To accomplish this, we will add 1 to the first `n % k` items in the parts list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非零的 `n`，我们首先通过使用向下取整将 `n` 除以 `k` 来计算 `base_step`，这会将我们的结果向下取整到最接近的整数。然后，我们创建一个长度为
    `k` 的列表，该列表由 `base_step` 值组成。接下来，我们需要尽可能均匀地将 `n / k` 的余数分配到这个列表中。为了完成这个任务，我们将第一个
    `n % k` 项添加到部分列表中。
- en: 'Follow the math here using our example of `n = -10` and `k = 4`:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的 `n = -10` 和 `k = 4` 的例子来遵循这里的数学：
- en: The base step is calculated as `-10 / 4 = -3` (remember, floor division always
    rounds down, so `-2.5` gets rounded to `-3`).
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本步长计算为 `-10 / 4 = -3`（记住，向下取整总是向下取整，所以 `-2.5` 被四舍五入到 `-3`）。
- en: 'We then create a list of four base step values: `[-3, -3, -3, -3]`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包含四个基本步长值的列表：`[-3, -3, -3, -3]`。
- en: '`-10 % 4 = 2`, so we add `1` to the first two items in the list.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-10 % 4 = 2`，所以我们向列表中的前两项添加 `1`。'
- en: We arrive at an answer of `[-2, -2, -3, -3]`. Perfect!
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们得到了一个答案 `[-2, -2, -3, -3]`。完美！
- en: Operations like this partition function are part of **discrete mathematics**,
    a branch of mathematics that deals with operations on whole numbers. Discrete
    mathematics is often used for solving spatial problems such as those encountered
    in drawing and animation.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样的分区函数是 **离散数学** 的组成部分，离散数学是处理整数运算的数学分支。离散数学常用于解决绘图和动画中遇到的空间问题。
- en: 'Now that we have the partition method, we can write the `queue_move()` method:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了分区方法，我们可以编写 `queue_move()` 方法：
- en: '[PRE27]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We first determine the necessary number of steps in this move by dividing the
    time interval by `FRAME_RES` using floor division. We then create a list of `X`
    moves and a list of `Y` moves by passing `dx` and `dy` each to our `partition()`
    method. Those two lists are combined with `zip()` to form a single list of `(dx,
    dy)` pairs, which we iterate to add each pair to the animation queue.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先通过将时间间隔除以 `FRAME_RES` 使用向下取整来确定这次移动所需的步数。然后，我们通过将 `dx` 和 `dy` 分别传递给我们的 `partition()`
    方法来创建一个 `X` 移动列表和一个 `Y` 移动列表。这两个列表通过 `zip()` 组合形成一个单一的 `(dx, dy)` 对列表，我们迭代这个列表，将每一对添加到动画队列中。
- en: 'To make the animation actually happen, we''ll need a method to check the queue
    and make each move; we''ll call it `next_move()`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要使动画真正发生，我们需要一个方法来检查队列并执行每个移动；我们将称之为 `next_move()`：
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `next_move()` method first checks the queue for a movement step. If there
    is one, `canvas.move()` is called with the racer's ID and the `X` and `Y` values
    for the step. When the game starts, this method will be called repeatedly from
    the `App` object until one of the racers has won.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`next_move()` 方法首先检查队列中是否有移动步骤。如果有，则使用赛车者的 ID 和步骤的 `X` 和 `Y` 值调用 `canvas.move()`。当游戏开始时，此方法将从
    `App` 对象中反复调用，直到其中一名赛车者获胜。'
- en: 'Finally, we need to add a call to `plot_course()` to the `Racer` class''s initializer,
    like so:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `plot_course()` 调用添加到 `Racer` 类的初始化器中，如下所示：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Thus, as soon as a `Racer` object is created, it will plot the course to the
    finish line, and wait for the `App` class to tell it to move.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦创建了一个 `Racer` 对象，它就会绘制到终点的赛道，并等待 `App` 类告诉它移动。
- en: Running the game loop and detecting a win condition
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行游戏循环并检测获胜条件
- en: To actually run the game, we need to start a game loop. Of course, we know from
    *Chapter 14*, *Asynchronous Programming with Thread and Queue*, that we can't
    simply use a Python `for` or `while` loop, since this would block Tkinter drawing
    operations and simply make the game freeze up until it was over. Instead, we need
    to create a method that executes a single "frame" of the game animation, then
    schedules itself on the Tkinter event loop to run again.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际运行游戏，我们需要启动一个游戏循环。当然，我们知道从 *第14章*，*使用线程和队列进行异步编程*，我们不能简单地使用 Python 的 `for`
    或 `while` 循环，因为这会阻塞 Tkinter 绘图操作，并使游戏冻结直到结束。相反，我们需要创建一个方法来执行游戏动画的单个“帧”，然后将其调度到
    Tkinter 事件循环中再次运行。
- en: 'That method begins like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 那个方法开始是这样的：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It begins by iterating through the racer objects and executing their `next_move()`
    methods. After moving each racer, our next step is to determine if one of them
    has crossed the finish line and won.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先遍历赛车对象并执行它们的 `next_move()` 方法。移动每个赛车后，我们的下一步是确定是否有任何一个赛车手已经越过终点线并获胜。
- en: To detect this condition, we need to check whether a racer is overlapping with
    the finish line item.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测这种条件，我们需要检查赛车是否与终点线项目重叠。
- en: Collision detection between items is slightly awkward with the Tkinter `Canvas`
    widget. We have to pass a set of bounding box coordinates to `find_overlapping()`,
    which returns a tuple of item identifiers that overlap with the bounding box.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Tkinter `Canvas` 小部件进行项目之间的碰撞检测稍微有些棘手。我们必须传递一组边界框坐标到 `find_overlapping()`，它返回一个重叠边界框的项目标识符元组。
- en: 'Let''s create an `overlapping()` method for our `Racer` class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为我们的 `Racer` 类创建一个 `overlapping()` 方法：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This method retrieves the bounding box of the `Racer` item using the `Canvas`'s
    `bbox()` method. It then fetches a tuple of items overlapping this bounding box
    using `find_overlapping()`. Since this would include the ID of the `Racer` item
    itself, we'll filter that out of the tuple using a list comprehension. The result
    is a list of items overlapping with this `Racer` object's `Canvas` item. Since
    this method doesn't require any arguments and only returns a value, we've made
    it a property.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `Canvas` 的 `bbox()` 方法检索 `Racer` 项目的边界框。然后，它使用 `find_overlapping()` 获取与该边界框重叠的项目元组的列表。由于这包括
    `Racer` 项目的 ID，我们将使用列表推导从元组中过滤掉它。结果是与这个 `Racer` 对象的 `Canvas` 项目重叠的项目列表。由于此方法不需要任何参数并且只返回一个值，我们将其制作为一个属性。
- en: 'Back in our `execute_frame()` method, we''ll check each racer to see if it
    has crossed the finish line:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `execute_frame()` 方法中，我们将检查每个赛车手是否已经越过终点线：
- en: '[PRE32]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: If the `finish_line` ID is in the list returned by the racer's `overlapping()`
    method, the racer has hit the finish line and will be declared the winner by calling
    a `declare_winner()` method and returning from the method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果赛车手的 `overlapping()` 方法返回的列表中包含 `finish_line` ID，则赛车手已经撞到终点线，将通过调用 `declare_winner()`
    方法并从该方法返回来宣布其为获胜者。
- en: If no player was declared the winner, the `execute_frame()` method is scheduled
    to run again after `Racer.FRAME_RES` milliseconds. This effectively implements
    a game loop using the Tkinter event loop, which will run until one racer wins.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有玩家被宣布为获胜者，`execute_frame()` 方法将在 `Racer.FRAME_RES` 毫秒后再次运行。这实际上使用 Tkinter
    事件循环实现了一个游戏循环，它将一直运行，直到有赛车获胜。
- en: 'We handle a win condition in the `declare_winner()` method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `declare_winner()` 方法中处理获胜条件：
- en: '[PRE33]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this method, we've just created a text item declaring `racer.name` as the
    winner in the center of the `Canvas`. The `activefill` argument causes the color
    to appear violet when the mouse is hovered over it, indicating to the user that
    this text is clickable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们只是在 `Canvas` 的中心创建了一个文本项目，宣布 `racer.name` 为获胜者。`activefill` 参数使得当鼠标悬停时颜色呈现紫色，这向用户表明此文本是可点击的。
- en: 'When that text is clicked, it calls the `reset()` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击该文本时，它会调用 `reset()` 方法：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `reset()` method needs to clear off the `Canvas`, so it calls the `delete()`
    method with an argument of `all`. Remember that `all` is a built-in tag that applies
    to all items on the `Canvas`, so this line effectively deletes all `Canvas` items.
    Once the `Canvas` is clear, we call `setup()` to reset and restart the game.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset()` 方法需要清除 `Canvas`，因此它使用 `all` 参数调用 `delete()` 方法。记住，`all` 是一个应用于 `Canvas`
    上所有项目的内置标签，因此这一行实际上删除了所有 `Canvas` 项目。一旦 `Canvas` 清空，我们就调用 `setup()` 来重置并重新开始游戏。'
- en: 'The last thing we need to do is make sure the game starts whenever `setup()`
    is called. To do that, add a call to `execute_frame()` to the end of `setup()`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要确保每次调用 `setup()` 时游戏都会开始。要做到这一点，将 `execute_frame()` 的调用添加到 `setup()` 的末尾：
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The game is now complete; run the script and you should see something like
    this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏现在已完成；运行脚本，你应该会看到类似这样的结果：
- en: '![](img/B17578_15_03.png)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_15_03.png)'
- en: 'Figure 15.3: The bug race game. Red wins!'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：虫子赛跑游戏。红色获胜！
- en: While not exactly simple, animation in Tkinter can provide smooth and satisfactory
    results with some careful planning and a bit of math. Enough games, though; let's
    get back to the lab and figure out how to use the Tkinter `Canvas` widget to visualize
    data.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并不完全简单，但经过一些仔细规划和数学计算，Tkinter 中的动画可以提供平滑且令人满意的结果。不过，既然我们已经足够了解游戏，就让我们回到实验室，看看如何使用
    Tkinter 的 `Canvas` 小部件来可视化数据。
- en: Creating simple graphs using Canvas
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Canvas 创建简单的图表
- en: The first graph we want to produce is a simple line graph that shows the growth
    of our plants over time. Each lab has varying climate conditions, and we want
    to see how those conditions are affecting the growth of all plants, so the chart
    will have one line per lab showing the average of the median height measurements
    for all plots in the lab over the days of the experiment.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要生成的第一个图表是一个简单的线形图，显示我们的植物随时间增长的情况。每个实验室都有不同的气候条件，我们想看看这些条件是如何影响所有植物的生长的，因此图表将包含每个实验室的一条线，显示实验期间实验室中所有地块的中位数高度测量的平均值。
- en: We'll start by creating a model method to return the raw data, then create a
    `Canvas`-based line-chart view, and finally create an application callback to
    pull the data and send it to the chart view.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个模型方法来返回原始数据，然后创建基于 `Canvas` 的线形图表视图，最后创建一个应用程序回调来获取数据并将其发送到图表视图。
- en: Creating the model method
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型方法
- en: 'Working with another data analyst at ABQ, you develop a SQL query that determines
    the day number of a plot check by subtracting its date from the oldest date in
    the `plot_checks` table, then pulls `lab_id` and the average of `median_height`
    for all plants in the given lab on the given day. The query looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 与 ABQ 的另一位数据分析师合作，你开发了一个 SQL 查询，通过从 `plot_checks` 表中的最老日期减去其日期来确定地块检查的日期编号，然后提取
    `lab_id` 和给定日期给定实验室中所有植物的中位数高度的平均值。查询如下所示：
- en: '[PRE36]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The query returns a table of data that looks something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回一个看起来像这样的数据表：
- en: '| Day | lab_id | Average Height (cm) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| Day | lab_id | Average Height (cm) |'
- en: '| 0 | A | 1.4198750000000000 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 0 | A | 1.4198750000000000 |'
- en: '| 0 | B | 1.3320000000000000 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| 0 | B | 1.3320000000000000 |'
- en: '| 0 | C | 1.5377500000000000 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 0 | C | 1.5377500000000000 |'
- en: '| 1 | A | 1.7266250000000000 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 1 | A | 1.7266250000000000 |'
- en: '| 1 | B | 1.8503750000000000 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 1 | B | 1.8503750000000000 |'
- en: '| 1 | C | 1.4633750000000000 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| 1 | C | 1.4633750000000000 |'
- en: 'Using this query, let''s create a new `SQLModel` method called `get_growth_by_lab()`
    to return the needed data:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此查询，让我们创建一个新的 `SQLModel` 方法 `get_growth_by_lab()` 来返回所需的数据：
- en: '[PRE37]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is a fairly straightforward method; it just runs the query and returns
    the results. Recall that the `SQLModel.query()` method returns results as a list
    of dictionaries; in this case, each of the dictionaries contains three fields:
    `Day`, `lab_id`, and `Avg Height (cm)`. Now we just need to develop a chart view
    that can visualize this data for the user.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当直接的方法；它只是运行查询并返回结果。回想一下，`SQLModel.query()` 方法返回的结果是一个字典列表；在这种情况下，每个字典包含三个字段：`Day`、`lab_id`
    和 `Avg Height (cm)`。现在我们只需要开发一个可以为此数据可视化给用户的图表视图。
- en: Creating the chart view
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建图表视图
- en: 'The chart view we''re going to create will need to take the data structure
    from our model method and use it to plot a line chart. Head over to `views.py`,
    where we''ll create the `LineChartView` class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要创建的图表视图需要从我们的模型方法中获取数据结构，并使用它来绘制线形图。前往 `views.py` 文件，我们将创建 `LineChartView`
    类：
- en: '[PRE38]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '`LineChartView` is a subclass of `Canvas`, so we''ll be able to draw items
    directly on it. This view will not only contain the data plots, but the axes,
    labels, and legend as well. It will be constructed for re-usability, so we''re
    going to design it without any specific reference to the data we''re charting
    in this instance. Ideally, we''d like to be able to send arbitrary datasets to
    it to generate line graphs. The two class attributes defined here provide a default
    value for the `margin` around the chart (in pixels) and a list of `colors` to
    use for each subsequent line plot. The growth chart we''re making only has three
    plots (one for each lab), but the additional colors allow us to specify up to
    seven. You could provide additional colors in this list if you wanted to use it
    for charts with more than seven plots.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineChartView` 是 `Canvas` 的子类，因此我们可以在其上直接绘制项目。这个视图不仅包含数据图表，还包括坐标轴、标签和图例。它将为了可重用性而构建，因此我们将设计它时不会针对我们在此实例中绘制的具体数据进行任何特定参考。理想情况下，我们希望能够向它发送任意数据集以生成线形图。这里定义的两个类属性为图表周围的
    `margin`（以像素为单位）提供了一个默认值，并为每个后续线形图提供了一组 `colors`。我们制作的增长图表只有三个图表（每个实验室一个），但额外的颜色允许我们指定多达七个。如果您想使用具有七个以上图表的图表，则可以在该列表中提供额外的颜色。'
- en: 'Now, we''ll begin the initializer method:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将开始初始化方法：
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Apart from the usual parent widget argument, we''ve specified these additional
    positional arguments:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 除了通常的父小部件参数外，我们还指定了这些额外的位置参数：
- en: '`data` will be our list of dictionaries containing the data from the query.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`data` 将是我们的包含查询数据的字典列表。'
- en: '`plot_size` will be a tuple of integers specifying the width and height of
    the plot area in pixels.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plot_size`将是一个整数元组，指定绘图区域的宽度和高度（以像素为单位）。'
- en: '`x_field` and `y_field` will be the field names to use for the `X` and `Y`
    values of the plot. For the growth chart this will be `Day` and `Avg Height (cm)`,
    respectively.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x_field`和`y_field`将是用于绘图`X`和`Y`值的字段名称。对于增长图表，这将是`Day`和`Avg Height (cm)`。'
- en: '`plot_by_field` will be the field whose value will be used to categorize the
    rows into individual plots. For the growth chart, this will be `lab_id`, since
    we want one line plot for each lab.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plot_by_field`将是用于将行分类为单独图表的值所在的字段。对于增长图表，这将是一个`lab_id`，因为我们希望为每个实验室绘制一个线条图表。'
- en: All these values are stored to instance variables so we can access them from
    our methods.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些值都存储在实例变量中，这样我们就可以从我们的方法中访问它们。
- en: 'We''re going to implement the plot area of this widget as a second `Canvas`
    placed on the `LineChartView`. The size of the `LineChartView` then will need
    to be the size of the chart plus the margins around the outside where the axes
    and labels will be drawn. We''ll calculate that size, then pass it to the `LineChartView`
    superclass initializer, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现这个小部件的绘图区域作为一个放置在`LineChartView`上的第二个`Canvas`。然后，`LineChartView`的大小将是图表的大小加上围绕轴和标签的外部边距。我们将计算这个大小，然后将其传递给`LineChartView`超类初始化器，如下所示：
- en: '[PRE40]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that we've saved the plot area's width and height as instance variables,
    as we'll need them in some of our methods.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经将绘图区域的宽度和高度保存为实例变量，因为我们将在某些方法中需要它们。
- en: 'Now that we''ve initialized the superclass, we can begin drawing on the main
    `Canvas`; to begin, let''s draw the axes:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经初始化了超类，我们就可以开始在主`Canvas`上绘制了；首先，让我们绘制轴：
- en: '[PRE41]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Our chart's origin will be `self.margin` pixels from the bottom-left corner,
    and we'll draw the `X` and `Y` axes as simple black lines moving right and up
    from the origin to the edge of the chart. Remember that the `Canvas` `Y` coordinates
    count down from the top, not up from the bottom, so the `Y` coordinate for the
    origin is the height of the view area minus the margin.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的图表原点将距离左下角`self.margin`像素，我们将从原点向图表边缘绘制简单的黑色线条，表示`X`和`Y`轴。记住，`Canvas`的`Y`坐标是从顶部向下计算的，而不是从底部向上，所以原点的`Y`坐标是视图区域的高度减去边距。
- en: 'Next, we''ll label the axes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将标注轴：
- en: '[PRE42]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we're creating the text items set to the labels for the `X` and `Y` axes,
    using the field names passed into the object for the text labels. Note the use
    of `anchor` to set which side of the text's bounding box is attached to the coordinates
    provided. In the case of the `X` axis, for instance, we've specified `n` (north),
    so the top of our text will be under the `X`-axis line. For the `Y`-axis label,
    we want the text to be sideways, so we've specified `angle=90` to rotate it. Also,
    note that we've used south (`s`) as the `anchor` position for the rotated text;
    even though it's rotated, the cardinal directions here are relative to the object
    *before* rotation. Thus, "south" will always be the bottom of the text as normally
    written, even if the object is rotated.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在创建文本项，将其设置为`X`和`Y`轴的标签，使用传递给对象的字段名称作为文本标签。注意使用`anchor`来设置文本边界框的哪一侧与提供的坐标相连接。例如，对于`X`轴，我们指定了`n`（北），因此文本的顶部将在`X`轴线下方。对于`Y`轴标签，我们希望文本是侧放的，所以我们指定了`angle=90`来旋转它。此外，请注意，我们已将旋转文本的`anchor`位置指定为`s`（南）；即使它已旋转，这里的四个基本方向是相对于旋转前的对象。因此，“南”始终是文本的正常书写的底部，即使对象已旋转。
- en: 'With the axes labeled, we need to create a second `Canvas` that will contain
    the plot area:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在标注了轴之后，我们需要创建一个包含绘图区域的第二个`Canvas`：
- en: '[PRE43]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This `Canvas` object is where the actual plots will be drawn. While we could
    draw our plots on the `LineChartView` directly, embedding a second `Canvas` makes
    it easier to calculate the coordinate points for the plot, since we won't have
    to factor in the margin. It also allows us to use a different background color
    for a nicer look.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Canvas`对象是实际绘图的地方。虽然我们可以在`LineChartView`上直接绘制图表，但嵌入第二个`Canvas`使得计算图表的坐标点更容易，因为我们不需要考虑边距。这也允许我们使用不同的背景颜色，使其看起来更美观。
- en: 'Before we can draw data on the chart, we need to create a method that can do
    so. Let''s create a private instance method called `_plot_line()` to draw a single
    line plot on the chart, which begins like this:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以在图表上绘制数据之前，我们需要创建一个可以这样做的方法。让我们创建一个名为`_plot_line()`的私有实例方法，用于在图表上绘制单个线条图表，其开始如下：
- en: '[PRE44]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This method will receive a `data` argument containing the `X` and `Y` points
    for the line as a list of tuples. Since our chart is a fixed number of pixels,
    and our data values may have any arbitrary range, the first thing we need to do
    is scale the data to fit just inside the size of our chart. To do this, we first
    find the maximum values of the `X` and `Y` fields, then create a scaling ratio
    for each axis by dividing the set height of the chart by the maximum value (note
    that this assumes the minimum value is 0\. This particular chart class isn't designed
    to handle negative values).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将接收一个包含线`X`和`Y`点的列表的`data`参数。由于我们的图表是固定像素数，而我们的数据值可能有任意范围，我们首先需要将数据缩放以适应图表的大小。为此，我们首先找到`X`和`Y`字段的极大值，然后为每个轴创建一个缩放比例，通过将图表的总高度除以极大值来计算（注意，这假设最小值是0。这个特定的图表类不是为处理负值而设计的）。
- en: 'Once we have the scale values, we can then transform our data points to coordinates
    by using a list comprehension that multiplies each data point by the scale value,
    as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了刻度值，我们就可以通过使用列表推导式将每个数据点乘以刻度值来将数据点转换为坐标，如下所示：
- en: '[PRE45]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Note that we are rounding the values, since we can't plot to fractional pixel
    values. Also, once again, since data is usually graphed with the origin in the
    bottom left, but coordinates on the `Canvas` measure from the top left, we'll
    need to flip the `Y` coordinates; this is done in our list comprehension as well
    by subtracting the new `Y` value from the plot height.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在四舍五入值，因为我们不能绘制到分数像素值。同样，由于数据通常以左下角为原点进行绘图，但`Canvas`上的坐标从左上角开始测量，我们需要翻转`Y`坐标；这也在我们的列表推导式中完成，通过从绘图高度中减去新的`Y`值。
- en: 'These coordinates can now be passed to `create_line()` along with a reasonable
    width and the color argument passed in by the caller, like so:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标现在可以传递给`create_line()`，同时传递一个合理的宽度和调用者传入的颜色参数，如下所示：
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that we've also used the `smooth` argument to round out the curve a bit
    and make it appear more organic.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还使用了`smooth`参数来使曲线更加圆润，使其看起来更自然。
- en: To use this method, we need to head back to the initializer and do some calculations.
    Since the `_plot_line()` method only handles one plot at a time, we'll need to
    filter out our data by the `plot_by_field` field and render the lines one at a
    time.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这个方法，我们需要回到初始化器并做一些计算。由于`_plot_line()`方法一次只处理一个绘图，我们需要通过`plot_by_field`字段过滤我们的数据，并逐个渲染线条。
- en: 'Add this code at the end of `LineChartView.__init__()`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LineChartView.__init__()`的末尾添加此代码：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: First, we get the individual plot names by retrieving the unique `plot_by_field`
    values from the data. These are sorted and cast to a `set` object so that we only
    have the unique values. Then, we create a color mapping using `zip()` to build
    a list of name-to-color tuples. Since `zip()` returns a generator and we're going
    to want to use this map more than once, it's cast to a `list` object.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过从数据中检索唯一的`plot_by_field`值来获取单个绘图名称。这些值被排序并转换为`set`对象，这样我们就只能得到唯一的值。然后，我们使用`zip()`来创建一个名称到颜色的元组列表。由于`zip()`返回一个生成器，而我们打算多次使用这个映射，所以将其转换为`list`对象。
- en: 'Now, let''s plot our lines:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们绘制我们的线条：
- en: '[PRE48]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: For each distinct plot name and color, we first format the data into a list
    of (`X`, `Y`) pairs using a list comprehension. Then we call `_plot_line()` with
    the data and the color. Our lines are now plotted!
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个独特的绘图名称和颜色，我们首先使用列表推导式将数据格式化为一个包含(`X`，`Y`)对的列表。然后我们调用`_plot_line()`方法，传递数据和颜色。我们的线条现在已经被绘制了！
- en: 'One last thing we need is a legend, to tell the user what each color on the
    chart represents. Without that, this chart would be meaningless to the user. To
    create it, we''ll write a `_draw_legend()` method:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个图例，以告诉用户图表上每种颜色代表什么。没有它，这个图表对用户来说就没有意义。为此，我们将编写一个`_draw_legend()`方法：
- en: '[PRE49]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Our method takes the color map list that we created in the initializer and iterates
    over it, using the `enumerate()` function to also generate an incrementing number
    for each iteration. For each mapping, we simply draw a text item containing the
    label text with the associated fill color. This is drawn starting at ten pixels
    from the top-left corner of the chart, with each item twenty pixels below the
    last.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法接受在初始化器中创建的颜色映射列表，并遍历它，使用`enumerate()`函数为每个迭代生成一个递增的数字。对于每个映射，我们简单地绘制一个包含标签文本和相关填充颜色的文本项。这是从图表左上角开始绘制的，每个项目比上一个项目低二十像素。
- en: 'Finally, let''s call this method from the initializer:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们从初始化器调用这个方法：
- en: '[PRE50]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `LineChartView` is ready to go; now we just need to create the supporting
    code to invoke it.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`LineChartView` 已经准备就绪；现在我们只需要创建调用它的支持代码。'
- en: Updating the application
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新应用程序
- en: 'Back in the `Application` class, create a new method for showing our chart:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Application` 类中，创建一个新的方法来显示我们的图表：
- en: '[PRE51]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The first order of business is to fetch the data from our `get_growth_by_lab()`
    method. Then, we build a `TopLevel` widget to hold our `LineChartView` object.
    On this widget, we add the `LineChartView` object, configuring it to be `800`
    by `400` pixels and specifying the fields for `X` (`Day`), `Y` (`Avg Height (cm)`),
    and the `plot_by_field` value (`lab_id`). This chart gets packed into the `Toplevel`.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 第一要务是从我们的 `get_growth_by_lab()` 方法获取数据。然后，我们创建一个 `TopLevel` 小部件来容纳我们的 `LineChartView`
    对象。在这个小部件上，我们添加 `LineChartView` 对象，配置它为 `800` x `400` 像素，并指定 `X`（`Day`）、`Y`（`Avg
    Height (cm)`）和 `plot_by_field` 值（`lab_id`）。这个图表被打包进 `Toplevel`。
- en: The `Toplevel` widget creates a new, blank window outside the root window. You
    should use it as a base for new windows that aren't simple dialogs or message
    boxes.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '`Toplevel` 小部件创建了一个新的、空白的窗口，位于根窗口之外。你应该将其用作创建新窗口的基础，这些新窗口不是简单的对话框或消息框。'
- en: 'With this method complete, add it to the `event_callbacks` dictionary in the
    `Application` initializer:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成此方法后，将其添加到 `Application` 初始化器中的 `event_callbacks` 字典中：
- en: '[PRE52]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we need to add a menu item to launch the chart. Add the following
    method to the `GenericMainMenu` class:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加一个菜单项来启动图表。将以下方法添加到 `GenericMainMenu` 类中：
- en: '[PRE53]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Then use this method in each menu class''s `_build_menu()` method to add this
    option to the **Tools** menu. For example:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在每个菜单类的 `_build_menu()` 方法中使用此方法将此选项添加到 **工具** 菜单中。例如：
- en: '[PRE54]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'When you call your function, you should see something like this:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用你的函数时，你应该看到类似以下的内容：
- en: '![The growth chart on Ubuntu Linux](img/B17578_15_04.png)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![Ubuntu Linux 上的增长图表](img/B17578_15_04.png)'
- en: 'Figure 15.4: The growth chart on Ubuntu Linux'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4：Ubuntu Linux 上的增长图表
- en: Your graph won't look like much without some sample data. Unless you just like
    doing data entry, there is a script for loading sample data in the `sql` directory.
    Run this script against your database before testing your chart.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有一些样本数据，你的图表看起来可能不会太好。除非你只是喜欢做数据录入，`sql` 目录中有一个用于加载样本数据的脚本。在测试你的图表之前，在数据库上运行此脚本。
- en: Advanced graphs using Matplotlib
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Matplotlib 的高级图表
- en: 'Our line graph is pretty, but it still needs considerable work to be a truly
    professional-looking visualization: it lacks a scale, grid lines, zoom capabilities,
    and other features that would make it a completely useful chart.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的折线图看起来很漂亮，但还需要做相当多的工作才能成为一个真正专业的可视化：它缺少刻度、网格线、缩放功能和其他使其成为一个完全有用的图表的功能。
- en: 'We could spend a lot of time making it more complete, but there''s a faster
    way to get much more satisfactory graphs and charts in our Tkinter application:
    Matplotlib.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以花更多的时间使其更加完整，但有一个更快的方法可以在我们的 Tkinter 应用程序中获得更多令人满意的图表和图形：Matplotlib。
- en: Matplotlib is a third-party Python library for generating professional-quality,
    interactive graphs of all types. It's a vast library with many add-ons, and we
    won't cover much of its actual usage, but we will look at how to integrate Matplotlib
    charts into a Tkinter application. To demonstrate this, we'll create a bubble
    chart showing the yield of each plot as it relates to humidity and temperature.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib 是一个用于生成所有类型专业质量、交互式图表的第三方 Python 库。它是一个庞大的库，拥有许多附加组件，我们不会过多地介绍其实际用法，但我们将探讨如何将
    Matplotlib 图表集成到 Tkinter 应用程序中。为了演示这一点，我们将创建一个气泡图，展示每个绘图与湿度和温度的关系。
- en: 'You should be able to install the `matplotlib` library using `pip` with this
    command:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能够使用以下命令通过 `pip` 安装 `matplotlib` 库：
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: For complete instructions on installation, please see [https://matplotlib.org/users/installing.html](https://matplotlib.org/users/installing.html).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 关于安装的完整说明，请参阅 [https://matplotlib.org/users/installing.html](https://matplotlib.org/users/installing.html)。
- en: Data model method
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据模型方法
- en: 'Before we can make a chart, we''ll need another `SQLModel` method to extract
    the data for the chart. Once again, you''ve been provided with a SQL query that
    returns the required data:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够制作图表之前，我们需要另一个 `SQLModel` 方法来提取图表所需的数据。再次提醒，你已经提供了一个返回所需数据的 SQL 查询：
- en: '[PRE56]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The purpose of this chart is to find the sweet spot of temperature and humidity
    for each seed sample. Therefore, we need one row per plot that includes the maximum
    fruit measurement, average humidity and temperature at the plot column, and the
    seed sample. Since we don't want any bad data, we'll filter out rows that have
    an Equipment Fault.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表的目的是找到每个种子样本的温度和湿度的最佳点。因此，我们需要为每个图表包含最大果实测量值、图表列的平均湿度和温度以及种子样本的每一行。由于我们不希望有任何不良数据，我们将过滤掉包含设备故障的行。
- en: 'The query returns data that looks something like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 查询返回的数据看起来像这样：
- en: '| seed_sample | yield | avg_humidity | avg_temperature |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| seed_sample | yield | avg_humidity | avg_temperature |'
- en: '| AXM480 | 11 | 27.7582142857142857 | 23.7485714285714286 |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| AXM480 | 11 | 27.7582142857142857 | 23.7485714285714286 |'
- en: '| AXM480 | 20 | 27.2146428571428571 | 23.8032142857142857 |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| AXM480 | 20 | 27.2146428571428571 | 23.8032142857142857 |'
- en: '| AXM480 | 15 | 26.2896428571428571 | 23.6750000000000000 |'
  id: totrans-307
  prefs: []
  type: TYPE_TB
  zh: '| AXM480 | 15 | 26.2896428571428571 | 23.6750000000000000 |'
- en: '| AXM478 | 31 | 27.2928571428571429 | 23.8317857142857143 |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '| AXM478 | 31 | 27.2928571428571429 | 23.8317857142857143 |'
- en: '| AXM477 | 39 | 27.1003571428571429 | 23.7360714285714286 |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '| AXM477 | 39 | 27.1003571428571429 | 23.7360714285714286 |'
- en: '| AXM478 | 39 | 26.8550000000000000 | 23.7632142857142857 |'
  id: totrans-310
  prefs: []
  type: TYPE_TB
  zh: '| AXM478 | 39 | 26.8550000000000000 | 23.7632142857142857 |'
- en: 'To provide this data to the application, let''s put the query into another
    model method called `get_yield_by_plot()`:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将此数据提供给应用程序，让我们将查询放入另一个名为`get_yield_by_plot()`的方法中：
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: That's all the model needs, so let's move on to the views.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是模型所需的所有内容，让我们继续到视图部分。
- en: Creating the bubble chart view
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建气泡图视图
- en: To integrate Matplotlib into a Tkinter application, there are several module
    imports we need to make into `views.py`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 要将Matplotlib集成到Tkinter应用程序中，我们需要在`views.py`中进行几个模块导入。
- en: 'The first is `matplotlib` itself:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`matplotlib`本身：
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: It may seem odd to execute methods in the import section of a script, and your
    code editor or IDE may even complain about it. According to Matplotlib's documentation,
    though, `use()` should be called before other modules are imported from `matplotlib`
    to tell it which rendering backend it should use. In this case, we want the `TkAgg`
    backend, which is made to integrate into Tkinter.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本导入部分执行方法可能看起来很奇怪，你的代码编辑器或IDE甚至可能会对此提出警告。然而，根据Matplotlib的文档，`use()`应该在从`matplotlib`导入其他模块之前调用，以告诉它应该使用哪个渲染后端。在这种情况下，我们想要`TkAgg`后端，它是为了集成到Tkinter而设计的。
- en: Matplotlib has backends for a variety of GUI toolkits such as PyQt, wxWidgets,
    and Gtk3, as well as backends for non-GUI situations (for example, rendering plots
    directly to a file) like SVG rendering or web usage. See the documentation at
    [https://matplotlib.org/stable/api/index_backend_api.html](https://matplotlib.org/stable/api/index_backend_api.html)
    for more details.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: Matplotlib为各种GUI工具包提供了后端，例如PyQt、wxWidgets和Gtk3，以及用于非GUI情况（例如，直接将图表渲染到文件）的后端，如SVG渲染或网络使用。有关更多详细信息，请参阅[https://matplotlib.org/stable/api/index_backend_api.html](https://matplotlib.org/stable/api/index_backend_api.html)文档。
- en: 'Now that we''ve set the backend, we can import a few other items from `matplotlib`:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了后端，我们可以从`matplotlib`导入一些其他项目：
- en: '[PRE59]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The `Figure` class represents the basic drawing area on which `matplotlib` charts
    can be drawn. The `FigureCanvasTkAgg` class is an interface between the `Figure`
    and the Tkinter `Canvas`, and `NavigationToolbar2Tk` allows us to place a pre-made
    navigation toolbar for the `Figure` object on our GUI.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '`Figure`类代表`matplotlib`图表可以绘制的基本绘图区域。`FigureCanvasTkAgg`类是`Figure`和Tkinter
    `Canvas`之间的接口，`NavigationToolbar2Tk`允许我们在我们的GUI上放置一个预先制作的导航工具栏，用于`Figure`对象。'
- en: 'To see how these fit together, let''s start our `YieldChartView` class in `views.py`:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解这些是如何结合在一起的，让我们从`views.py`中的`YieldChartView`类开始：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: After calling the superclass initializer to create the `Frame` object, we create
    a `Figure` object to hold our chart. Instead of a size in pixels, the `Figure`
    object takes a size in inches and a dots-per-inch (`dpi`) setting. In this case,
    our arguments of 6 by 4 inches and 100 dots per inch result in a 600-by-400-pixel
    `Figure` object. Next, we create a `FigureCanvasTkAgg` object that will be used
    to connect our `Figure` object with a Tkinter `Canvas`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用超类初始化器以创建`Frame`对象之后，我们创建一个`Figure`对象来保存我们的图表。与像素大小不同，`Figure`对象接受英寸大小和每英寸点数（`dpi`）设置。在这种情况下，我们的6英寸乘以4英寸和每英寸100点的参数产生了一个600乘以400像素的`Figure`对象。接下来，我们创建一个`FigureCanvasTkAgg`对象，它将用于将我们的`Figure`对象与Tkinter
    `Canvas`连接。
- en: 'The `FigureCanvasTkAgg` object is not itself a `Canvas` object or subclass,
    but it contains a `Canvas` object we can place in our application. A reference
    to this `Canvas` object can be retrieved using the `FigureCanvasTkAgg` object''s
    `get_tk_widget()` method. We''ll go ahead and get a reference to the `Canvas`
    and pack it into the `YieldChartView` widget:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`FigureCanvasTkAgg` 对象本身不是一个 `Canvas` 对象或其子类，但它包含一个我们可以放置在我们的应用程序中的 `Canvas`
    对象。可以通过 `FigureCanvasTkAgg` 对象的 `get_tk_widget()` 方法检索对这个 `Canvas` 对象的引用。我们将获取一个引用并将其打包到
    `YieldChartView` 小部件中：'
- en: '[PRE61]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, we''ll add the toolbar and attach it to our `FigureCanvasTkAgg` object:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加工具栏并将其附加到我们的 `FigureCanvasTkAgg` 对象上：
- en: '[PRE62]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note that we don't need to use a geometry manager to add the toolbar; instead
    we just pass the `FigureCanvasTkAgg` object and the parent widget (`self`, which
    is our `YiedChartView` object in this case) to the toolbar's initializer, and
    this will attach it to our `Figure`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要使用几何管理器来添加工具栏；相反，我们只需将 `FigureCanvasTkAgg` 对象和父小部件（在这种情况下是 `self`，即我们的
    `YieldChartView` 对象）传递给工具栏的初始化器，这将将其附加到我们的 `Figure` 上。
- en: 'The next step is to set up the axes:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是设置坐标轴：
- en: '[PRE63]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In `matplotlib`, an `Axes` object represents a single set of `X` and `Y` axes
    on which data can be plotted, and is created using the `Figure.add_subplot()`
    method. The three integers passed to `add_subplot()` establish that this is the
    first set of axes out of one row of one column of subplots. Our figure could conceivably
    contain multiple subplots arranged in a table-like format, but we only need one,
    thus we're passing all 1s here. After it's created, we set the labels on the `Axes`
    object.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `matplotlib` 中，`Axes` 对象代表一个单一的 `X` 和 `Y` 轴集合，可以在其上绘制数据，它通过 `Figure.add_subplot()`
    方法创建。传递给 `add_subplot()` 的三个整数确定这是第一组轴，位于一个行一个列的子图的第一组。我们的图可能包含多个以表格格式排列的子图，但我们只需要一个，因此我们在这里传递所有
    1。创建后，我们在 `Axes` 对象上设置标签。
- en: To create a bubble chart, we're going to use the **scatter plot** feature of
    Matplotlib, using the size of each dot to indicate the fruit yield. We'll also
    color code the dots to indicate which seed sample the data point represents.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个气泡图，我们将使用 Matplotlib 的 **散点图** 功能，使用每个点的尺寸来表示水果产量。我们还将对点进行着色编码，以表示数据点代表哪个种子样本。
- en: 'Let''s implement a method to draw our scatter plots:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现一个绘制我们的散点图的方法：
- en: '[PRE64]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The data passed in should contain three columns per record, and we're breaking
    those out into three separate lists containing the `x`, `y`, and `size` values.
    Next, we're going to amplify the differences between the `size` values to make
    them more apparent by squaring each value then dividing it by two. This isn't
    strictly necessary, but it helps make the chart more readable when differences
    are relatively small.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 传入的数据应包含每条记录的三个列，我们将它们拆分为包含 `x`、`y` 和 `size` 值的三个单独的列表。接下来，我们将通过将每个值平方然后除以二来放大
    `size` 值之间的差异，使它们更明显。这并不是严格必要的，但它有助于在差异相对较小时使图表更易于阅读。
- en: Finally, we draw the data onto the `axes` object by calling `scatter()`, also
    passing along the color and label values for the dots, and making them semi-transparent
    with the `alpha` argument.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过调用 `scatter()` 将数据绘制到 `axes` 对象上，同时传递点颜色和标签值，并通过 `alpha` 参数使它们半透明。
- en: '`zip(*data)` is a Python idiom for breaking a list of n-length tuples into
    n lists of values, essentially the reverse of `zip(x, y, s)`.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip(*data)` 是 Python 中的一个惯用语，用于将长度为 n 的元组列表拆分为 n 个值列表，本质上与 `zip(x, y, s)`
    相反。'
- en: 'To draw a legend for our `Axes` object, we need two things: a list of our scatter
    objects and a list of their labels. To get these, we''ll have to create a couple
    of blank lists in `__init__()` and append the appropriate values to them whenever
    `draw_scatter()` is called.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 要为我们的 `Axes` 对象绘制图例，我们需要两样东西：一个包含我们的散点对象的列表以及一个包含它们标签的列表。为了获取这些，我们将在 `__init__()`
    中创建几个空列表，并在每次调用 `draw_scatter()` 时将适当的值追加到它们中。
- en: 'In `__init__()`, add some empty lists:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__init__()` 中添加一些空列表：
- en: '[PRE65]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, at the end of `draw_scatter()`, append the lists and update the `legend()`
    method:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在 `draw_scatter()` 的末尾，追加列表并更新 `legend()` 方法：
- en: '[PRE66]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Note that we can call `legend()` repeatedly and it will simply destroy and redraw
    the legend each time.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以反复调用 `legend()`，它将简单地每次都销毁并重新绘制图例。
- en: Updating the Application class
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新应用程序类
- en: Back in `Application`, let's create the method to show our yield data chart.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Application` 中，让我们创建一个方法来显示我们的产量数据图表。
- en: 'Start by creating a method to display a `Toplevel` widget with our chart view:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个方法来显示带有我们的图表视图的 `Toplevel` 小部件：
- en: '[PRE67]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Now let''s set up the data for our scatters:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们设置散点图所需的数据：
- en: '[PRE68]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We''ve retrieved the yield data from the data model and created a dictionary
    that will hold the colors we want to use for each seed sample. Now we just need
    to iterate through the seed samples and draw the scatters:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已从数据模型中检索出产量数据，并创建了一个字典，将保存我们想要为每个种子样本使用的颜色。现在我们只需要遍历种子样本并绘制散点图：
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Once again, we're formatting and filtering down our data using a list comprehension,
    providing average humidity for `x`, average temperature for `y`, and yield for
    `s`.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们使用列表推导式对数据进行格式化和筛选，为 `x` 提供平均湿度，为 `y` 提供平均温度，以及为 `s` 提供产量。
- en: Add the method to the callbacks dictionary and create a menu item for it just
    under the growth chart option.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 将该方法添加到回调字典中，并在生长图表选项下方创建一个菜单项。
- en: 'Your bubble chart should look something like this:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 你的气泡图应该看起来像这样：
- en: '![](img/B17578_15_05.png)'
  id: totrans-357
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17578_15_05.png)'
- en: 'Figure 15.5: Our scatter plot showing how seed samples performed under different
    conditions'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：我们的散点图显示了种子样本在不同条件下的表现
- en: Take a moment to play with this chart using the navigation toolbar. Notice how
    you can zoom and pan, adjust the size of the chart, and save the image. These
    powerful tools are provided by Matplotlib automatically, and make for very professional-looking
    charts.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间使用导航工具栏来操作这个图表。注意你可以缩放和平移，调整图表的大小，并保存图像。这些强大的工具由 Matplotlib 自动提供，使得图表看起来非常专业。
- en: This wraps up our charting needs for the time being, but as you've seen it's
    quite simple to integrate Matplotlib's powerful charts and graphs into our application.
    And, of course, with enough effort, the sky is the limit with generating visualizations
    using the `Canvas` widget.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这暂时结束了我们的图表需求，但正如你所看到的，将 Matplotlib 的强大图表和图形集成到我们的应用程序中非常简单。当然，只要付出足够的努力，使用
    `Canvas` 小部件生成可视化就没有极限。
- en: Summary
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about Tkinter's graphical capabilities. You learned
    about the `Canvas` widget, and how to draw shapes, lines, images, text, and widgets
    on it. You implemented animations on the `Canvas` by queuing item movements in
    the Tkinter event queue. You implemented a simple line chart class using a plain
    `Canvas` to provide basic data visualization for SQL query results. Finally, you
    learned how to integrate the powerful Matplotlib library with its wide variety
    of charts and graphs into your application.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 Tkinter 的图形功能。你了解了 `Canvas` 小部件，以及如何在上面绘制形状、线条、图像、文本和小部件。你通过在 Tkinter
    事件队列中排队项目移动来实现 `Canvas` 上的动画。你使用纯 `Canvas` 实现了一个简单的折线图类，为 SQL 查询结果提供基本的数据可视化。最后，你学习了如何将强大的
    Matplotlib 库及其丰富的图表和图形集成到你的应用程序中。
- en: In the next chapter, we'll learn how to package up our application for distribution.
    We'll learn how to arrange the directory for distribution as Python code, and
    how to use third-party tools to create executables across Windows, macOS, and
    Linux.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何打包我们的应用程序以进行分发。我们将学习如何以 Python 代码的形式安排分发目录，以及如何使用第三方工具在 Windows、macOS
    和 Linux 上创建可执行文件。
