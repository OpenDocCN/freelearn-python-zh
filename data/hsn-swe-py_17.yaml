- en: Handling Service Transactions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理服务交易
- en: There is a substantial amount of interaction potential between system components
    and the data objects that they individually manage. While we've worked out some
    of the mechanisms that determine what transmitting a data change or command message
    looks like, we've not yet started to explore the specifics of those interactions.
    In a nutshell, we still need to address what the data flows (and, thus, message
    transmissions) look like for all of the local CRUD operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 系统组件之间以及它们各自管理的数据对象之间存在大量的交互潜力。虽然我们已经解决了一些确定数据更改或命令消息传输的机制，但我们还没有开始探索这些交互的具体细节。简而言之，我们仍然需要解决所有本地CRUD操作的数据流（因此，消息传输）是什么样子的问题。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creation of products by artisans
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠创建产品
- en: Activation and deactivation of products by artisans and Central Office staff
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠和中央办公室工作人员对产品的激活和停用
- en: Making changes to Product data by artisans and Central Office staff
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由工匠和中央办公室工作人员对产品数据进行更改
- en: Deletion of products by artisans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由工匠删除产品
- en: Creation of artisans by Central Office staff
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由中央办公室工作人员创建工匠
- en: Making changes to Artisan data by artisans and Central Office staff
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由工匠和中央办公室工作人员对工匠数据进行更改
- en: Deletion of artisans by Central Office staff
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由中央办公室工作人员删除工匠
- en: Creation of orders by the Web Storefront, and relaying that information to artisans
    for fulfillment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web商店创建订单，并将该信息传达给工匠以便履行
- en: Cancellation of orders from the Web Storefront, and relaying that information
    to artisans
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从Web商店取消订单，并将该信息传达给工匠
- en: Order-item fulfillment by artisans
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工匠履行订单项目
- en: Remaining stories
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 剩余的故事
- en: 'Since our work in [Chapter 16](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml), *The
    Artisan Gateway Service,* only (tentatively) closed three stories, there are still
    several (eleven) that need to be addressed. The implementation of `RabbitMQSender`
    and the RabbitMQ message transmission strategy that was adopted also raised questions
    about how to propagate some of the artifacts needed for those processes—the signing
    key in particular—and there''s also a decision pending about whether the Artisan
    Gateway will use one message queue for inbound traffic from artisans, or one per
    Artisan, and that may add another story:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在[第16章](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml)中的工匠网关服务，只（暂时）关闭了三个故事，还有几个（十一个）需要解决。采用的`RabbitMQSender`和RabbitMQ消息传输策略的实施也引发了关于如何传播一些这些过程所需的工件的问题，特别是签名密钥，还有一个待定的决定，即工匠网关是否会使用一个消息队列来处理工匠的入站流量，还是每个工匠一个消息队列，这可能会增加另一个故事：
- en: As an Artisan, I need a message queue created and assigned to me so that I can
    send my data changes to the Artisan Gateway
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为工匠，我需要创建一个消息队列并分配给我，以便我可以将我的数据更改发送到工匠网关
- en: 'The bulk of the stories still pending each represent a data flow process, a
    data transaction tied to a specific action that''s undertaken by a specific user
    in the context of the system. Each process, in turn, is some variation of a CRUD
    operation—generally creating, updating, or deleting one or more data objects,
    as instructed by the relevant message. In reviewing the possibilities of all of
    the various CRUD operations against all of the business objects available to each
    user role in the system, five new stories surfaced:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分尚未完成的故事都代表了一个数据流程，一个与系统上下文中特定用户执行的特定操作相关联的数据交易。每个流程又是CRUD操作的某种变体，通常是根据相关消息的指示创建、更新或删除一个或多个数据对象。在审查系统中每个用户角色可用的各种业务对象上进行各种CRUD操作的可能性时，出现了五个新故事：
- en: As an Artisan, I need to be able to deactivate `Product` objects so that I can
    manage `Product` availability (which may be handled by a general Update operation)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为工匠，我需要能够停用“产品”对象，以便我可以管理“产品”的可用性（这可能由一般的更新操作处理）
- en: As an Artisan, I need to be informed when an Order has been placed that includes
    one of my Product offerings so that I can fulfil my part of that Order (ultimately,
    the creation of an Artisan-resident `Order` object, triggered by some activity
    on the Central Office side)
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为工匠，我需要在下订单时被通知，其中包括我的产品供应之一，以便我可以履行订单的部分（最终，由中央办公室一侧的某些活动触发的工匠驻地“订单”对象的创建）
- en: As a Customer, I need the relevant parts of my Order to be relayed to the appropriate
    artisans so that they can fulfill their part of my Order (the other half of the
    previous story, but it might add some functional needs to that)
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为客户，我需要将我的订单的相关部分传达给适当的工匠，以便他们可以履行我的订单的部分（前一个故事的另一半，但可能会增加一些功能需求）
- en: As a Customer who's canceled an Order, I need the relevant parts of that cancellation
    to be relayed to the appropriate artisans so that they won't fulfill their part
    of the Order (essentially a deletion of an Artisan-resident `Order`-object, but
    with notification on the Artisan Application side)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为取消订单的客户，我需要将取消订单的相关部分传达给适当的工匠，以便他们不会履行订单的部分（基本上是删除工匠驻地的“订单”对象，但在工匠应用程序方面通知）
- en: As an Artisan, I need to be informed when an Order has been canceled that includes
    one of my Product offerings so that I can stop any in-process fulfillment activities
    related to it and update my `Product` status as needed (again, the other half
    of the previous story)
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为工匠，我需要在订单被取消时被通知，其中包括我的产品供应之一，以便我可以停止与之相关的任何进行中的履行活动，并根据需要更新我的“产品”状态（再次是前一个故事的另一半）
- en: 'All of these transactions follow a similar pattern:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些交易都遵循相似的模式：
- en: The relevant **message data** of the **O****bject** whose data needs to be sent
    along is used to create a **message** (with `DaemonMessage`).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要发送的**对象**的相关**消息数据**用于创建一个**消息**（使用`DaemonMessage`）。
- en: That **message** is sent by a sender (an instance of `RabbitMQSender`) to the
    **Artisan Gateway service**.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该**消息**由发送方（`RabbitMQSender`的一个实例）发送到**工匠网关服务**。
- en: The service reads the **message**, and calls the appropriate `[process-method]`,
    which will probably interact with the **Artisan Gateway data store**.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务读取消息，并调用适当的 `[process-method]`，这可能会与**工匠网关数据存储**进行交互。
- en: 'The `[process-method]` itself may need to send other messages, either back
    to the **Artisan Gateway service** itself for further local processing, or through
    the service back to an Artisan. The processes for sending subsequent messages
    will be very similar, with the potential for an additional variation—the destination
    of the new message:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`[process-method]` 本身可能需要发送其他消息，要么返回给**工匠网关服务**本身进行进一步的本地处理，要么通过服务返回给工匠。发送后续消息的过程将非常相似，但可能会有额外的变化——新消息的目的地：'
- en: '![](assets/a6e5d401-fe16-451f-9f01-b11ff6370e4c.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/a6e5d401-fe16-451f-9f01-b11ff6370e4c.png)'
- en: The primary points of variation are, then, in the **message data** itself, and
    those variations should be shaped, in turn, by business rules around what the
    user role is allowed to do to those objects.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 主要的变化点在于**消息数据**本身，这些变化应该由业务规则来塑造，规则规定了用户角色对这些对象可以做什么。
- en: A bit of reorganization
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一点重组
- en: Before digging into the details of the individual transactions, some minor reorganization
    of recent code seems in order. The `RabbitMQSender` and `DaemonMessage` classes
    were originally written in the `hms_core.daemons` module, because that seemed
    a logical place to keep them—they are still relevant to the daemon, but also have
    relevance to parts of the Artisan Application (and perhaps the Central Office
    application) that don't have any ties to the various daemon classes themselves.
    Since we've also uncovered a need for various objects to be able to generate message
    data structures, and that feels like it should be handled by a different abstraction,
    it feels logical to move those two classes into a new `hms_core` module (`hms_core.messaging`),
    and add the new abstraction there instead—that way, all of the messaging-related
    classes are in one place. Moving the custom exception, `InvalidMessageError`,
    to the new module also feels like a sensible step, since it is also strictly message-related.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究各个事务的细节之前，最近的代码需要进行一些微小的重组。`RabbitMQSender`和`DaemonMessage`类最初是在`hms_core.daemons`模块中编写的，因为那似乎是一个合乎逻辑的地方来保存它们——它们仍然与守护进程相关，但也与工匠应用程序的某些部分（也许是中央办公室应用程序）相关，这些部分与各种守护进程类本身没有任何联系。由于我们还发现了各种对象需要能够生成消息数据结构的需求，并且感觉这应该由不同的抽象来处理，因此将这两个类移动到一个新的`hms_core`模块（`hms_core.messaging`）中，并在那里添加新的抽象是合乎逻辑的——这样，所有与消息相关的类都在一个地方。将自定义异常`InvalidMessageError`移动到新模块中也感觉像是一个明智的步骤，因为它也严格与消息相关。
- en: 'Those code moves require some trivial changes to the Artisan Gateway service''s
    main module, such as changing the original imports from this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码移动需要对工匠网关服务的主模块进行一些微不足道的更改，例如从这里更改原始导入：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To the following:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到以下位置：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Similar changes are also necessary in any of the test scripts that have been
    generated in order for them to still be useful.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的变化在任何已生成的测试脚本中也是必要的，以便它们仍然有用。
- en: 'This sort of code reorganization is probably inevitable, at least on a long-term
    basis: it''s just a matter of time before something just doesn''t feel right where
    it lives, and needs to be moved to a better location. In general, the earlier
    the need for a reorganization like this is caught, the better, as it will tend
    to be less troublesome or disruptive because there''s less chance of broken interactions
    with code if there''s less code to interact with. It also probably goes without
    saying, but it''s always a good idea to rerun any test code that might have been
    created to assure that nothing is egregiously broken before moving on. In this
    case, the final test script for the daemon (`scratch-space/daemon-artisan-tests.py`)
    revealed some minor issues that had to be resolved—not because of the code-move,
    but because it wasn''t rerun before closing out the code in [Chapter 16](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml), *The
    Artisan Gateway Service*. Still, the issue was caught before it became a real
    bug.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这种代码重组可能是不可避免的，至少从长期来看：只是一个时间问题，总会有一些东西在原来的位置感觉不对，需要移动到更好的位置。一般来说，越早发现这种重组的需求，越好，因为如果要交互的代码越少，就越不容易出现问题或干扰。另外，可能不用说，但在继续之前重新运行可能已创建的任何测试代码总是一个好主意，以确保在继续之前没有明显的错误。在这种情况下，守护进程的最终测试脚本（`scratch-space/daemon-artisan-tests.py`）显示出一些小问题，这些问题必须解决——不是因为代码移动，而是因为在关闭 [第16章](9e235ce2-5611-4e7d-a16b-3332561fe85b.xhtml) *工匠网关服务*的代码之前没有重新运行。不过，问题在变成真正的错误之前就被发现了。
- en: Preparation for object transactions
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象事务的准备
- en: The preceding code reorganization gives us a solid, logical place to create
    the new **Abstract Base Class** (**ABC**) that we mentioned earlier. The goal
    of this new ABC is to require derived classes to be able to provide a message-data-ready
    data structure that can be passed to `DaemonMessage` as the data argument in its
    `__init__` method, both streamlining the process of creating a message for any
    given object that needs one, and allowing the code for that process to exist as
    part of the individual data object classes themselves. In keeping with the naming
    convention that's evolved in the code so far, this would probably be best written
    as an instance method named `to_message_data`. Another option considered was `to_message_dict`,
    but that method name already exists elsewhere, and it doesn't relate to the `DaemonMessage`
    argument quite as well.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码重组为我们提供了一个坚实而合乎逻辑的地方，可以创建我们之前提到的新**抽象基类**（**ABC**）。这个新ABC的目标是要求派生类能够提供一个准备好的消息数据结构，可以作为`DaemonMessage`的数据参数传递给其`__init__`方法，从而简化为任何需要消息的对象创建消息的过程，并允许该过程的代码存在于各个数据对象类本身的一部分。与迄今为止在代码中演变的命名约定保持一致，这可能最好写成一个名为`to_message_data`的实例方法。另一个考虑的选项是`to_message_dict`，但该方法名称已经存在于其他地方，并且与`DaemonMessage`参数的关系不那么密切。
- en: The `to_message_data` method can be completely abstract, with no concrete implementation
    provided in the abstract method itself—unlike many of the abstract methods defined
    thus far in the `hms_sys` code-base, there really isn't any common functionality
    to fall back on.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_message_data`方法可以完全抽象，抽象方法本身没有提供具体实现——与迄今为止在`hms_sys`代码库中定义的许多抽象方法不同，实际上没有任何通用功能可以回退。'
- en: 'And that''s it, really. The new ABC doesn''t need anything else that comes
    to mind. It just defines a requirement for the new method. It doesn''t even need
    an `__init__` method, since there''s nothing that would need to be passed as an
    instance property value (though it will still inherit the `__init__` method from
    the object class that all classes ultimately derive from). Its entire definition,
    then, is as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，真的。新的ABC不需要任何其他想法。它只是定义了一个新方法的要求。它甚至不需要一个`__init__`方法，因为没有需要作为实例属性值传递的东西（尽管它仍然会继承所有类最终派生自的对象类的`__init__`方法）。因此，它的整个定义如下：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: An ABC defined with no concrete functionality is about as close as Python code
    can get to the sort of formal interface declaration that other object-oriented
    languages provide. It's still just an Abstract Base Class, just like the other
    ABCs that have been built for the project so far, but all it does is generate
    a set of functional requirements that derived classes have to implement before
    they can be instantiated. In this case, when we apply `HasMessageData` to the
    various data object classes that have already been defined in the `hms_core.co_objects`
    and `hms_artisan.artisan_objects` namespaces (`Artisan` and `Product` classes
    in both, and `Order` in the `hms_artisan` namespace), this immediately establishes
    a requirement that those classes implement `to_message_data`, without caring how
    they get implemented.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个没有具体功能定义的ABC与其他面向对象语言提供的形式接口声明几乎一样接近Python代码。它仍然只是一个抽象基类，就像迄今为止为项目构建的其他ABC一样，但它所做的只是生成派生类在实例化之前必须实现的一组功能要求。在这种情况下，当我们将`HasMessageData`应用于已在`hms_core.co_objects`和`hms_artisan.artisan_objects`命名空间中定义的各种数据对象类（`Artisan`和`Product`类以及`hms_artisan`命名空间中的`Order`），这立即建立了这些类必须实现`to_message_data`的要求，而不关心它们如何实现。
- en: In `hms_sys`, since the concrete `Artisan`, `Order`, and `Product` classes all
    derive from ABCs defined in `hms_core`, we could actually attach `HasMessageData`
    to those ABCs, rather than to the concrete classes. The end result would be the
    same—the concrete classes would be required to implement `to_message_data`—and
    there would be (very slightly) less work. The trade-off would be that any future
    classes that derived from `BaseArtisan`, `BaseOrder`, or `BaseProduct` would also
    be required to implement `to_message_data`, even if there was no need for that
    functionality. While that doesn't feel horrible, it does impose some functional
    requirements on future development that may not be warranted. For the time being,
    since we know that the current concrete classes should derive from `HasMessageData`,
    we'll derive them from it directly—if that needs to be changed in the future,
    it's a safer effort to move the requirement deeper into the inheritance tree.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在`hms_sys`中，由于具体的`Artisan`、`Order`和`Product`类都是从`hms_core`中定义的ABC派生的，我们实际上可以将`HasMessageData`附加到这些ABC上，而不是具体类。最终结果将是一样的——具体类将被要求实现`to_message_data`——并且工作量会（非常轻微地）减少。权衡的是，任何将来从`BaseArtisan`、`BaseOrder`或`BaseProduct`派生的类也将被要求实现`to_message_data`，即使没有必要。虽然这并不感觉可怕，但它确实对未来的开发施加了一些功能要求，这可能是不合理的。目前，由于我们知道当前的具体类应该派生自`HasMessageData`，我们将直接从中派生它们——如果将来需要更改，将要求深入继承树的工作量更小。
- en: The concrete implementations of `to_message_data` provides a logical hook in
    the code for the implementation of business rule restrictions regarding what each
    object is allowed to send in a message. That is, neither Artisan nor Central Office
    users are allowed to alter or set all state data for all objects—they each have
    specific properties that they control. Even in cases where the user type owns
    the object type (artisans and products), there are properties that the other user
    owns (products and `store_available`, for example). Since `to_message_data` will
    be used to actually generate the message data that will, in turn, be used to make
    changes on the receiving end of each message transaction, the simple expedient
    of limiting the data structure generated by it to the values that the user type
    can create or alter prevents illegal changes to object data by each user. We'll
    dig into that as we work through the specific transactions for each user/object/action
    combination.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`to_message_data`的具体实现在代码中提供了一个逻辑挂钩，用于实施关于每个对象允许在消息中发送什么的业务规则限制。也就是说，工匠和中央办公室用户都不被允许更改或设置所有对象的所有状态数据——它们各自控制特定属性。即使用户类型拥有对象类型（工匠和产品），也有其他用户拥有的属性（例如产品和`store_available`）。由于`to_message_data`将用于实际生成消息数据，而这些数据将用于在每个消息事务的接收端进行更改，因此通过将其生成的数据结构限制为用户类型可以创建或更改的值，可以防止每个用户对对象数据进行非法更改。当我们逐步处理每个用户/对象/操作组合的具体交易时，我们将深入研究这一点。'
- en: Product object transactions
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 产品对象交易
- en: Since the set of Product data transactions have the largest number of individual
    transactions (seven), we'll start with those in the hopes that they will expose
    any gaps in the design sooner rather than later. Each transaction ties back to
    one of the original iteration stories, and the specific story that relates to
    the transaction process will be called out. The specific implementation of `to_message_data`
    for the user/object combination will be defined in the first transaction for that
    combination, and refined if/as needed in subsequent transaction details. Any other
    specific needs for that particular combination will also be addressed.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于产品数据交易的一组具有最多个体交易（七个），我们将从这些交易开始，希望它们能更早地暴露出设计中的任何差距。每个交易都与原始迭代故事之一相关联，并且与交易过程相关的特定故事将被调用。用户/对象组合的`to_message_data`的特定实现将在该组合的第一个交易中定义，并在后续交易细节中根据需要进行细化。还将解决该特定组合的任何其他特定需求。
- en: 'Since all of the varied operations against any objects require the object to
    be identified, the one constant in all `to_message_data` outputs is the `oid`
    property of the object being transmitted. It plays a significant role in each
    of the operations:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对任何对象的各种操作都需要对对象进行标识，因此在所有`to_message_data`输出中，对象被传输的`oid`属性是唯一的常量。它在每个操作中都起着重要作用。
- en: When creating a new object, the `oid` has to be provided in the message so that
    we don't end up with different unique identifiers across different application
    installations or environments. That's already taken care of by the generation
    of the `oid` value, which is inherited from `BaseDataObject`, where the `oid`
    is created if it doesn't exist.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建新对象时，必须在消息中提供`oid`，以便我们不会在不同的应用程序安装或环境中得到不同的唯一标识符。这已经通过继承自`BaseDataObject`的`oid`值的生成来处理，如果不存在，则创建`oid`。
- en: When updating an existing object, the `oid` has to be provided so that the original
    object can be retrieved and altered.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更新现有对象时，必须提供`oid`，以便检索和更改原始对象。
- en: When deleting an existing object, the same identification need exists—the `oid`
    has to be provided in order to identify which object is being deleted.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在删除现有对象时，同样需要提供相同的标识 - 必须提供`oid`以标识正在被删除的对象。
- en: Although we don't have a use case yet for a response message (more or less equivalent
    to a read in the standard CRUD operations structure), it, too would require an
    `oid` value in order to identify which object should be fetched and returned.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们目前还没有响应消息的用例（在标准CRUD操作结构中更或多等同于读取），但它也需要一个`oid`值，以便识别应该被获取和返回的对象。
- en: Artisan – creating a product
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工匠 - 创建产品
- en: 'The relevant story for an Artisan''s need to create a Product, from the list
    earlier, is:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠需要创建产品的相关故事，来自先前的列表。
- en: As an Artisan, I need to be able to create `Product` objects so that I can manage
    my `Product` offerings
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为工匠，我需要能够创建`Product`对象，以便管理我的`Product`产品
- en: 'Artisan users own the majority of the data points for a `Product` object. In
    fact, the only property that they really shouldn''t be able to create or alter
    is the `store_available` flag that controls whether a given Product is available
    on the Web Storefront that the Central Office runs. As a result, the output of `to_message_data`
    for `hms_artisan.artisan_objects.Product` looks very much like its `to_data_dict`
    method:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠用户拥有`Product`对象的大部分数据点。实际上，他们真正不应该能够创建或更改的唯一属性是`store_available`标志，该标志控制给定产品是否在中央办公室运行的Web商店上可用。因此，`hms_artisan.artisan_objects.Product`的`to_message_data`输出看起来非常像它的`to_data_dict`方法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `created` and `modified` values are included in this data structure, operating
    under the assumption that they should also be kept in sync across the Artisan
    and Central Office data stores—that might, if nothing else, allow the UI logic
    to more easily detect when something has changed that the UI needs to be aware
    of before displaying instance data, though it would almost certainly require some
    standardization of a common time—one across all application and service instances.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`created`和`modified`值包含在此数据结构中，基于这样的假设，它们也应该在工匠和中央办公室的数据存储中保持同步 - 这可能会使UI逻辑更容易地检测到在显示实例数据之前需要注意的任何更改，尽管这几乎肯定需要一些标准化的共同时间
    - 在所有应用程序和服务实例中都是一致的。'
- en: 'Given a new `Product` object (`new_product`) and the signing key for the Artisan
    (`signing_key`), transmission of the `new_product` to the Artisan Gateway service
    becomes very simple:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个新的`Product`对象（`new_product`）和工匠的签名密钥（`signing_key`），将`new_product`传输到工匠网关服务变得非常简单：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The Artisan Gateway method that accepts those messages and actually creates
    the new `Product` is `ArtisanGatewayDaemon.create_product`. Since it''s a method
    in a service, and especially since it makes changes to data (creating new data,
    in this case), there''s nearly as much logging of its processes as there is process
    itself, though much of it is debugging logging, and will only be logged if the
    service is configured to log events at that level:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 接受这些消息并实际创建新`Product`的工匠网关方法是`ArtisanGatewayDaemon.create_product`。由于这是一个服务中的方法，特别是因为它对数据进行更改（在这种情况下创建新数据），因此它的过程几乎与其本身一样多地记录了大部分日志，尽管其中大部分是调试日志，并且只有在服务配置为以该级别记录事件时才会记录：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At this point, the various Gateway methods aren't making any determination about
    whether the incoming message is authorized to make the changes that the method
    is making. We'll examine this later on.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，各种网关方法并不确定传入消息是否被授权进行方法所做的更改。我们将在以后进行检查。
- en: Central Office – approving/listing a product
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央办公室 - 批准/列出产品
- en: 'The relevant Story for Central Office staff being able to activate products,
    from the earlier collection of stories is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室工作人员能够激活产品的相关故事，来自先前的故事集合是：
- en: As a Product Manager, I need to be able to activate `Product` objects so that
    I can manage `Product` availability
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够激活“产品”对象，以便我可以管理“产品”的可用性
- en: 'The Central Office owns the `store_available` flag of products, so their version
    of `to_message_dict`, living in `hms_code.co_objects.Product`, is, at least initially,
    much simpler:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室拥有产品的“store_available”标志，因此他们的“to_message_dict”版本，位于“hms_code.co_objects.Product”中，至少最初，要简单得多：
- en: '[PRE6]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The related message transmission, with a `product_to_activate` `Product` object
    and the Central Office `signing_key` is just as easy as the new-Product transmission
    that we looked at prior:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相关的消息传输，使用“product_to_activate”“Product”对象和中央办公室的“signing_key”一样简单，就像我们之前看过的新产品传输一样：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The same message structure and transmission process will also address the Central
    Office''s need to be able to deactivate products, another of the original iteration
    stories:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的消息结构和传输过程也将解决中央办公室需要能够停用产品的问题，这是最初的迭代故事之一：
- en: As a Product Manager, I need to be able to deactivate `Product` objects so that
    I can manage `Product` availability
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够停用“产品”对象，以便我可以管理“产品”的可用性
- en: 'The Artisan Gateway method that accepts those messages and updates the relevant
    `Product` is `ArtisanGatewayDaemon.update_product`. Like `create_product`, it
    logs fairly extensively through its execution:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 接受这些消息并更新相关“Product”的Artisan Gateway方法是“ArtisanGatewayDaemon.update_product”。与“create_product”一样，它在执行过程中记录得相当详细：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Central Office – altering product data
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央办公室 - 修改产品数据
- en: 'The relevant story for a Central Office need to alter Product data, from the
    list earlier, is:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室需要更改产品数据的相关故事，如前面的列表所示：
- en: As a Product Manager, I need to be able to update `Product` objects so that
    I can manage `Product` information that an Artisan can't
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为产品经理，我需要能够更新“产品”对象，以便我可以管理工匠无法管理的“产品”信息
- en: 'It''s not unreasonable to assume that the Central Office will want to be able
    to make changes to specific Product properties without having to send them through
    an Artisan—making minor spelling corrections, or similar, simple changes to Product
    content that''s carried over to their Web Storefront. Since there isn''t any solid
    definition of what properties would be involved, let''s assume that those properties
    include the `name`, `description`, and `summary` of a Product. In that case, the
    `to_message_data` that was created for `hms_code.co_objects.Product` needs to
    be altered to include those values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以合理地假设中央办公室希望能够对特定产品属性进行更改，而无需通过工匠发送它们 - 对产品内容进行简单的拼写更正或类似的更改，这些更改会传递到他们的Web商店。由于没有明确定义哪些属性会涉及，让我们假设这些属性包括产品的“名称”、“描述”和“摘要”。在这种情况下，为“hms_code.co_objects.Product”创建的“to_message_data”需要更改以包括这些值：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This implementation introduces a potentially unwanted side effect: any update
    operation executed by a Central Office user can update all of these properties
    at once. If that behavior is not desired, then there are options that could be
    pursued:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此实施引入了一个可能不希望的副作用：中央办公室用户执行的任何更新操作都可以一次更新所有这些属性。如果不希望出现这种行为，则可以追求一些选项：
- en: 'Additional methods could be added to `ArtisanGatewayDaemon` to handle more
    specific actions, such as `set_product_availability`, which would only change
    the `store_available` flag value. That would likely require the following:'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以向“ArtisanGatewayDaemon”添加其他方法来处理更具体的操作，例如“set_product_availability”，它只会更改“store_available”标志值。这可能需要以下操作：
- en: The addition of a corresponding allowed `operation` to `DaemonMessage`
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向“DaemonMessage”添加相应的允许“操作”
- en: To check messages that originate with an Artisan so that they can't accidentally
    or intentionally perform a store availability change that they shouldn't be allowed
    to
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查起源于工匠的消息，以便他们不会意外或故意执行不应被允许的商店可用性更改
- en: 'Filtering of the outbound message data, to remove any elements from it that
    don''t apply to a specific operation, could be implemented as part of the message
    generation:'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出站消息数据的过滤，以删除其中不适用于特定操作的任何元素，可以作为消息生成的一部分实施：
- en: Helper methods could be added to the concrete `Product` classes to perform that
    filtering
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以向具体的“Product”类添加辅助方法来执行该过滤
- en: The UI could be made responsible for determining what kind of message should
    be sent, and it could perform that filtering
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI可以负责确定应发送何种类型的消息，并且可以执行该过滤
- en: At present, there doesn't appear to be any real harm in allowing any update
    action to update across multiple logical operations, though, so it can be left
    alone for now.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，允许任何更新操作跨多个逻辑操作进行更新似乎没有任何实际伤害，因此现在可以放任不管。
- en: Alterations by this Central Office role, for now, can be handled by the same
    message construction, transmission and, handling processes in use by the approval/listing
    action—it's just another variant of a data update.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，中央办公室角色的修改可以通过与批准/上市操作使用的相同消息构造、传输和处理过程来处理 - 这只是数据更新的另一种变体。
- en: Artisan – updating product data
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工匠 - 更新产品数据
- en: 'The relevant story for an Artisan''s need to update Product data, from the
    list earlier, is:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠需要更新产品数据的相关故事，如前面的列表所示：
- en: As an Artisan, I need to be able to update `Product` objects so that I can manage
    my `Product` offerings
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为工匠，我需要能够更新“产品”对象，以便我可以管理我的“产品”提供
- en: 'The only real difference between Artisan update and create transactions is
    the `operation` associated with the outgoing message—we''ve already included the
    `modified` property in the results of `to_message_data` in Artisan `Product` objects:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 工匠更新和创建交易之间唯一的真正区别是与传出消息相关联的“操作” - 我们已经在工匠“Product”对象的“to_message_data”结果中包含了“modified”属性：
- en: '[PRE10]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Data alterations originating from an Artisan are, from a process standpoint,
    identical to data changes that originate from a Central Office user—they can use
    the same `ArtisanGatewayDaemon.update_product` method to actually execute those
    changes—so there's no new code needed for them.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 从工匠发起的数据更改在流程上与从中央办公室用户发起的数据更改相同-他们可以使用相同的`ArtisanGatewayDaemon.update_product`方法来实际执行这些更改-因此不需要新代码。
- en: 'Since artisans also control a Product availability flag (available), the same
    considerations noted for the Central Office Product approval listing would apply
    at the Artisan level. Those encompass two stories that weren''t part of the original
    iteration story set, but should be included for the sake of completeness:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工匠还控制产品可用性标志（available），因此在工匠级别也适用于中央办公室产品批准清单中指出的相同考虑因素。这包括两个原始迭代故事集中没有的故事，但应为完整起见包括：
- en: As an Artisan, I need to be able to activate `Product` objects so that I can
    manage `Product` availability
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够激活“Product”对象，以便我可以管理“Product”的可用性
- en: As an Artisan, I need to be able to deactivate `Product` objects so that I can
    manage `Product` availability
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够停用“Product”对象，以便我可以管理“Product”的可用性
- en: These, too, can be handled by the same, existing data update process already
    defined, so long as there's no requirement to isolate activation/deactivation
    changes from other changes to the data structure. Even if such a requirement were
    to surface, it would be feasible to handle them at the message origination side
    of the transaction, limiting the content of the message to only the `active` flag
    and the `oid` that identifies the product to be activated or deactivated.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些也可以通过相同的现有数据更新过程来处理，只要没有要求将激活/停用更改与数据结构的其他更改隔离开来。即使出现这样的要求，也可以在事务的消息发起端处理它们，将消息的内容限制为仅`active`标志和标识要激活或停用的产品的`oid`。
- en: Artisan – deleting a product
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工匠-删除产品
- en: 'The relevant story for an Artisan''s need to delete a Product, from the list
    earlier, is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan需要删除产品的相关故事，如前所述，是：
- en: As an Artisan, I need to be able to delete `Product` objects so that I can manage
    my `Product` offerings
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠，我需要能够删除“Product”对象，以便我可以管理我的“Product”产品
- en: 'As noted earlier, deletion actions really only require the `oid` of the item
    being deleted in order to successfully execute. Any other information would be
    wasted bandwidth, though if that''s not a concern, the code for a deletion really
    only differs in the `operation` sent in the message again:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，删除操作实际上只需要被删除项目的`oid`才能成功执行。任何其他信息都将是浪费带宽，尽管如果这不是一个问题，删除的代码实际上只是在消息中再次发送`operation`：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Executing a more tightly focused message is not difficult—it doesn''t require
    anything more, ultimately, than taking more direct control of the message data,
    limiting it to just the relevant object ID. One approach would be to create the
    message data directly, like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 执行更紧密的消息并不困难-最终，它不需要更多的东西，只需要更直接地控制消息数据，将其限制为仅相关的对象ID。一种方法是直接创建消息数据，如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The corresponding deletion method in the Artisan Gateway (`delete_product`)
    is a lot simpler than those corresponding to the create or update processes for
    the same reason: all that''s really needed is the `oid` of the object whose data
    is to be deleted:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Artisan网关（`delete_product`）中的相应删除方法比创建或更新相同原因的过程要简单得多：实际上只需要被删除数据的`oid`：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Artisan object transactions
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Artisan对象交易
- en: 'The processes for sending `Artisan` object messages will not deviate significantly
    from the examples shown previously for `Product` objects. The creation and transmission
    of `create` and `update` messages will typically follow a structure that looks
    something like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 发送“Artisan”对象消息的过程不会与先前显示的“Product”对象的示例有显著偏差。 “create”和“update”消息的创建和传输通常会遵循以下类似结构：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Deletion messages, depending on what decision is made regarding sending the
    full object dataset, or just the required `oid` value, will typically follow one
    of these two structures:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 删除消息，取决于关于发送完整对象数据集还是只发送所需的`oid`值的决定，通常会遵循以下两种结构之一：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`Artisan` objects, like `Product` objects, are not complicated from the standpoint
    of their CRUD operations methods in the Artisan Gateway service. Indeed, apart
    from the specifics of which objects are being worked on, and the specific expected
    structure of the command messages associated with the various methods involved
    in executing those operations, they are identical to their `Product` object counterparts. For
    example, the `update_artisan` method of the Artisan Gateway service looks like
    this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与“Product”对象一样，“Artisan”对象在Artisan Gateway服务中的CRUD操作方法从技术上讲并不复杂。实际上，除了正在处理的对象的具体细节以及与执行这些操作所涉及的各种方法相关的命令消息的特定预期结构之外，它们与其“Product”对象对应物是相同的。例如，Artisan
    Gateway服务的`update_artisan`方法如下所示：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Across the board, then, the various `Artisan` operations follow the same patterns
    as those established by/for the `Product` operations.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，各种“Artisan”操作都遵循与“Product”操作建立的/为其建立的相同模式。
- en: Central Office – creating an artisan
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央办公室-创建工匠
- en: 'The relevant Story for Central Office staff being able to create an Artisan,
    from the earlier collection of stories is:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室工作人员能够创建工匠的相关故事，如前面的故事集是：
- en: As an Artisan Manager, I need to be able to create `Artisan` objects so that
    I can manage artisans
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠经理，我需要能够创建“Artisan”对象，以便我可以管理工匠
- en: '`Artisan` objects are unusual, in that while they are logically owned by the
    Artisan that they represent, they are created by the Central Office. This implies
    that two radically different message formats will be needed by the Central Office
    code-base: one to create an `Artisan` and one to update it. If we start with a
    complete message structure for creation purposes, we can better evaluate whether
    it presents any risks or complications in the update process later:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: “工匠”对象是不寻常的，因为它们在逻辑上由它们所代表的工匠拥有，但是它们是由中央办公室创建的。这意味着中央办公室代码库将需要两种根本不同的消息格式：一种用于创建“工匠”，一种用于更新它。如果我们从创建目的的完整消息结构开始，我们可以更好地评估它是否在以后的更新过程中存在任何风险或复杂性：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Since the process for creating an `Artisan` should almost certainly involve
    the creation and storage of the identifier of the message queue that's associated
    with Artisan (`queue_id`) and an initial `signing_key`, those values are included
    in the Central Office's `Artisan.to_message_data` method. We still have to define
    how signing keys and queue identifiers are actually created within the `Artisan`
    objects, but they will have to be sent along to the Artisan Gateway in some fashion
    so that they'll be available for use in sending, receiving, and validating messages
    to and from an Artisan Application instance.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于创建“工匠”的过程几乎肯定涉及创建和存储与工匠相关联的消息队列的标识符（“queue_id”）和初始的“signing_key”，这些值包括在中央办公室的“Artisan.to_message_data”方法中。我们仍然需要定义签名密钥和队列标识符如何在“工匠”对象内部实际创建，但它们必须以某种方式发送到工匠网关，以便它们可以用于发送、接收和验证消息到和从工匠应用实例。
- en: 'These processes are significant from a security perspective: remember that
    the signing key is considered a **secret** data value, one that should be treated
    with caution, and not transmitted needlessly or without some attention to safeguarding
    the data. In many respects, it''s equivalent to a user password—a secret value
    that is associated with one and only one user. If the signing key is a password,
    then the queue identifier could be considered roughly equivalent to a username—data
    that is, perhaps, not quite as secret, but that should still be treated with caution
    because it potentially uniquely identifies a user, and is associated with a true
    secret, together forming a set of user credentials. As the implementation- details
    around `queue_id` and `signing_key` creation and management unfold, it''s quite
    probable that we''ll have to revisit this message structure, so for now, we''ll
    leave it in its current state.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全的角度来看，这些流程非常重要：请记住，签名密钥被视为**秘密**数据值，应该谨慎对待，不要毫无必要地传输或在保护数据时不加注意。在许多方面，它相当于用户密码
    - 与一个且仅一个用户相关联的秘密值。如果签名密钥是密码，那么队列标识符可以被视为大致相当于用户名 - 这些数据可能不太保密，但仍应谨慎对待，因为它可能唯一标识一个用户，并与一个真正的秘密相关联，共同形成一组用户凭据。随着“queue_id”和“signing_key”创建和管理的实施细节的展开，我们很可能需要重新审视这个消息结构，所以目前我们将它保持在当前状态。
- en: Central Office – updating artisan data
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央办公室 - 更新工匠数据
- en: 'The relevant Story for Central Office staff being able to update an Artisan''s
    data, from the earlier collection of stories is:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室工作人员能够更新工匠数据的相关故事，来自先前的故事集合：
- en: As an Artisan Manager, I need to be able to update `Artisan` objects so that
    I can manage artisans
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠经理，我需要能够更新“工匠”对象，以便我可以管理工匠
- en: Once an `Artisan` object has been created, most of its properties are arguably
    owned by the Artisan that the object represents. Certainly, from a common sense
    standpoint, the Artisan user is in the best position to know whether their data
    is current, and it's in their best interests to keep that data current. That said,
    and setting aside the `queue_id` and `signing_key` properties until their processes
    have been fleshed out in more detail, the risks of allowing Central Office users
    to modify Artisan data don't feel significant, provided that changes made are
    propagated to, and can also be changed by the Artisan users themselves. The caveat
    to this scenario is that the `oid` property shouldn't be changeable by anyone—Central
    Office or Artisan users—but that almost goes without saying. It is, after all,
    the unique identifier for the `Artisan` object, and unique identifiers should
    never be changed lightly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了“工匠”对象，它的大部分属性可以说是由该对象所代表的工匠拥有。从常识的角度来看，工匠用户最了解他们的数据是否是最新的，而且保持数据最新对他们最有利。也就是说，暂且不考虑“queue_id”和“signing_key”属性，直到它们的流程被更详细地阐述出来，允许中央办公室用户修改工匠数据的风险并不显著，前提是所做的更改被传播到工匠用户自己那里，并且也可以由他们自己进行更改。这种情况的警告是，“oid”属性不应该被任何人更改
    - 中央办公室或工匠用户 - 但这几乎是不言而喻的。毕竟，这是“工匠”对象的唯一标识符，唯一标识符不应该轻易更改。
- en: With all of that in mind, no modifications to the Central Office's `Artisan.to_message_data`
    method are needed to fulfil this story yet, though alterations may well surface,
    as with the creation process, as the `queue_id` and `signing_key` management processes
    are defined and implemented.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些，目前不需要对中央办公室的“Artisan.to_message_data”方法进行修改，以满足这个故事，尽管随着创建过程一样，随着“queue_id”和“signing_key”管理流程的定义和实施，可能会出现变化。
- en: Central Office – deleting an artisan
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中央办公室 - 删除工匠
- en: 'The relevant Story for Central Office staff being able to delete an Artisan''s
    data, from the earlier collection of stories is:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 中央办公室工作人员能够删除工匠数据的相关故事，来自先前的故事集合：
- en: As an Artisan Manager, I need to be able to delete `Artisan` objects so that
    I can manage artisans
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名工匠经理，我需要能够删除“工匠”对象，以便我可以管理工匠
- en: Although the process of deleting an Artisan may have other implications—removal,
    or at least deactivation of all their products, for example—there aren't any that
    come to mind from the perspective of generating deletion command messages. Like
    the deletion process for `Product` objects, the only property value that's really
    needed is the `oid` of the Artisan to be deleted, and whatever decision is made
    about using the full message body or creating a specific one for deletion process
    purposes in that context will probably apply to this context as well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管删除Artisan的过程可能会有其他影响，例如删除或至少停用其所有产品，但从生成删除命令消息的角度来看，没有任何想到的影响。与`Product`对象的删除过程一样，真正需要的唯一属性值是要删除的Artisan的`oid`，以及关于在该上下文中使用完整消息正文还是为删除过程目的创建特定消息的任何决定，可能也适用于这个上下文。
- en: Artisan – updating Artisan data
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Artisan – 更新Artisan数据
- en: 'The relevant Story for Artisan being able to update an Artisan''s data, from
    the earlier collection of stories is:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 早期故事集中与Artisan能够更新Artisan数据相关的故事是：
- en: As an Artisan, I need to be able to update my own `Artisan` object so that I
    can manage my information at the HMS Central Office.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个Artisan，我需要能够更新自己的`Artisan`对象，以便我可以在HMS中央办公室管理我的信息。
- en: 'No matter what the eventual shape of the processes surrounding the `queue_id`
    and `signing_key` properties of an `Artisan` turns out to be, those values, as
    secrets, should never be sent across the open internet without some protection—encrypting
    them while in motion, at a minimum. Without those values, changes to Artisan data
    by Artisan users can travel unencrypted, so the base message structure for Artisan
    updates is nearly a duplicate of the equivalent in the Central Office''s namespace:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 无论最终围绕`Artisan`的`queue_id`和`signing_key`属性的过程的形状如何，作为机密信息的这些值在没有保护的情况下永远不应该通过开放的互联网发送——至少在传输过程中加密它们。没有这些值，Artisan用户对Artisan数据的更改可以以未加密的方式传输，因此Artisan更新的基本消息结构几乎是中央办公室命名空间中等效的复制：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Between the Central Office and Artisan code-bases, we're allowing either user
    type to alter most of an Artisan's data. The majority of it is some variation
    of contact information, none of which has any functional implications, and the
    balance has policies that have already been set down, if not implemented yet (`oid`),
    or is still pending further definition (`queue_id` and `signing_key`). The worst
    risk that seems even remotely likely with both user types having full control
    over these properties is either simultaneous conflicting changes (probably best
    handled at the UI level), or ongoing conflicting changes (one user changing a
    value, the other changing it back, the first changing it again, and so on).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在中央办公室和Artisan代码库之间，我们允许任一用户类型修改大部分Artisan数据。其中大部分是一些联系信息的变化，没有任何功能上的影响，而余下的政策已经制定，尚未实施（`oid`），或者仍在等待进一步定义（`queue_id`和`signing_key`）。两种用户类型对这些属性拥有完全控制权可能存在的最大风险是同时发生冲突的更改（可能最好在UI级别处理），或者持续发生冲突的更改（一个用户更改一个值，另一个用户再次更改，如此往复）。
- en: Order object transactions
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 订单对象交易
- en: orders, and their corresponding objects in the system, haven't been discussed
    much since the definition of the concrete `Order` class in the `artisan_objects`
    module. In part, this is because the other classes (particularly `Artisan` and
    `Product`) are representations of data that originate in the `hms_sys` code-bases.
    Still, the `artisan_objects.Order` class was left in about as complete a state
    as could be expected, with full data persistence and a concrete implementation
    that was expected to deal with all the requirements against it up to that point.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 自从在`artisan_objects`模块中定义了具体的`Order`类以来，订单及其在系统中对应的对象并没有被讨论过多。部分原因是其他类（特别是`Artisan`和`Product`）是源自`hms_sys`代码库的数据表示。不过，`artisan_objects.Order`类的状态基本上是完整的，具有完整的数据持久性和一个具体的实现，预期能够处理到目前为止的所有要求。
- en: As a result, though, several aspects of orders fell off the radar. The original
    set of stories for this iteration only included one Order-related story—an Artisan's
    need to be able to update an Order as part of a fulfillment process—with nothing
    that provided any path for that Order to get to an Artisan to begin with, let
    alone anything prior to that. There also wasn't any accommodation for the potential
    of an order being canceled before its fulfillment was complete. Accounting for
    the customer-to-gateway and gateway-to-Artisan paths of those items, they adds
    four new stories that will be addressed first.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于这些原因，订单的几个方面被忽略了。这次迭代的原始故事集只包括一个与订单相关的故事——Artisan需要能够在履行过程中更新订单——没有提供任何路径让订单首先到达Artisan，更不用说在此之前的任何事情了。在订单完成履行之前取消订单的可能性也没有考虑进去。考虑到这些项目的客户到网关和网关到Artisan的路径，这增加了四个新的故事，将首先解决。
- en: 'Dealing with orders is also complicated somewhat by the fact that the specifics
    of the Web Storefront system have been left intentionally vague. There are dozens
    of options available, if not hundreds, written in most of the popular/mainstream
    languages, and with varying degrees of extensibility. Rather than picking any
    one, a fundamental assumption was made that `hms_sys` integration could be accomplished
    in some fashion, which could include at least the following possibilities:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 处理订单也受到Web Storefront系统细节故意模糊的影响。有数十种甚至数百种选项，大多数是用流行的/主流语言编写的，并具有不同程度的可扩展性。与其选择任何一种，我们基本上假设`hms_sys`集成可以以某种方式完成，这可能包括至少以下可能性：
- en: A brute-force process, executing on a schedule, could acquire new, raw Order
    information from the store's data, and fire off the Artisan Gateway's Order creation
    process
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个蛮力过程，按计划执行，可以从商店的数据中获取新的原始订单信息，并触发Artisan Gateway的订单创建过程
- en: The store system, through some sort of small, custom extension, could fire off
    a create Order message to the Artisan Gateway, either directly or through the
    message queue, executing its Order creation process
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商店系统通过某种小型的自定义扩展，可以向Artisan Gateway发送创建订单消息，直接或通过消息队列，执行其订单创建过程
- en: If the store system were written in Python (there are at least eleven options
    in this field), it might actually be able to import whatever `hms_sys` code is
    needed, perhaps add some configuration, and directly execute the relevant `hms_sys`
    code
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果商店系统是用Python编写的（在这个领域至少有十一个选项），它实际上可能能够导入所需的任何`hms_sys`代码，或许添加一些配置，并直接执行相关的`hms_sys`代码
- en: In a real-world scenario, the cross-system integration would probably have been
    a significant set of very specific requirements—but for the purposes of illustration,
    and to keep focused on the project, those were intentionally left aside.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界的情况下，跨系统集成可能已经是一组非常具体的要求，但为了说明问题，并且专注于项目，这些故意被搁置了。
- en: Customer – relaying order items to artisans
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户-将订单项目传达给工匠
- en: 'The relevant Story for Customer being able to relay Order items to artisans,
    from the earlier collection of stories is:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 客户能够将订单项目传达给工匠的相关故事，从早期的故事集合中：
- en: As a Customer, I need the relevant parts of my Order to be relayed to the appropriate
    artisans so that they can fulfill their part of my Order.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为客户，我需要我的订单的相关部分被传达给适当的工匠，以便他们能够完成订单的部分。
- en: orders have a significantly more complex life cycle than any of the other objects
    in `hms_sys`. Unlike `Artisan` objects, or perhaps `Product` objects, they are
    expected to have a short active lifespan; being created, processed once, then
    archived or perhaps even deleted. `Artisan` objects, in contrast, once created,
    are expected to persist for as long as the Central Office/Artisan relationship
    lasts. `Product` objects may or may not persist in an active state for long periods
    of time, but can also last as long as the Central Office/Artisan relationship
    of their owning artisans continues. In both of these cases, though the length
    of their life cycles may vary substantially, they are basically created and persisted
    (with or without modification) indefinitely.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 订单在`hms_sys`中的生命周期比其他对象复杂得多。与`Artisan`对象或者`Product`对象不同，订单预计具有较短的活跃寿命；被创建后进行一次处理，然后存档或者甚至被删除。相比之下，一旦创建，`Artisan`对象预计会持续存在，直到中央办公室/工匠关系结束。`Product`对象可能会在活跃状态下存在很长一段时间，但也可能会持续存在，只要其所属工匠的中央办公室/工匠关系持续存在。尽管它们的生命周期长度可能会有很大差异，但它们基本上是被创建并持续存在（无论是否有修改）。
- en: 'By contrast, a relatively simple `Order`, moving through a simple subset of
    what `hms_sys` could support, might look like this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个相对简单的`Order`，通过`hms_sys`支持的简单子集，可能看起来像这样：
- en: '![](assets/1da2c5ed-b34c-4306-bfc4-2fcd0c08a21e.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/1da2c5ed-b34c-4306-bfc4-2fcd0c08a21e.png)'
- en: 'Where:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: The initial **Order** (for `Product` objects **P1**, **P2**, and **P3**) is
    created by the **Web Storefront** and is handed off to the **Artisan Gateway**
    for distribution to and handling by the relevant Artisan users
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始的**Order**（用于产品**P1**，**P2**和**P3**）由**Web Storefront**创建，并移交给**Artisan Gateway**进行分发和处理，由相关的工匠用户处理
- en: 'The **Artisan Gateway** sends **Order** messages to the **Artisan Applications**
    associated with the artisans whose products are in the **Order** (**Artisan #2**,
    in this example, exists, but the Order doesn''t contain any of their products):'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Artisan Gateway**将**Order**消息发送到与订单中产品相关的**Artisan Applications**（在这个例子中是**Artisan
    #2**，但订单中没有包含他们的产品）：'
- en: 'One **Order**, for products **P1** and **P3**, is sent to **Artisan #1**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个用于产品**P1**和**P3**的**Order**被发送到**Artisan #1**'
- en: 'One **Order** for Product **P2** is sent to **Artisan #3**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个用于产品**P2**的**Order**被发送到**Artisan #3**'
- en: '**Artisan #1** fulfils the part of the order for Product **P1** (**P1 Fulfilled**),
    which sends an update message for the **Order** back to the **Artisan Gateway**,
    where the fulfillment of that portion is noted and stored'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Artisan #1**完成了产品**P1**的订单部分（**P1 Fulfilled**），并将更新消息发送回**Artisan Gateway**，在那里该部分的完成情况被记录和存储。'
- en: 'A similar cycle occurs (**P2 Fulfilled**) for **Artisan #3**, with respect
    to Product **P2** from the original Order'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '类似的循环（**P2 Fulfilled**）发生在**Artisan #3**身上，与原始订单中的产品**P2**有关。'
- en: 'The final fulfillment cycle (**P3 Fulfilled**) is executed by **Artisan #1**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '最终的完成循环（**P3 Fulfilled**）由**Artisan #1**执行'
- en: The Order, with all of its fulfillment complete, can be archived, deleted, or
    handled in whatever other way is needed
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订单及其所有的完成情况完成后，可以进行存档、删除或者以其他需要的方式处理
- en: Since no concrete `Order` class was ever created that the Artisan Gateway service
    would be able to access, that's the first thing that needs to be done. Without
    knowing precisely how Order data is going to be relayed to the service, but still
    needing to be able to perform round trip testing of the process later, there's
    little more that can be done than to define it as a basic class derived from `HMSMongoDataObject`
    (like the other data object classes in the `co_objects` module) and from `BaseOrder`
    (from the `business_objects` module). Additions or changes to it may surface later,
    but deriving `Order` from those two classes will provide enough functionality
    for it to be testable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从未创建过能够访问Artisan Gateway服务的具体`Order`类，这是需要做的第一件事。虽然不知道订单数据将如何被传达到服务，但仍然需要能够执行后续的往返测试，因此除了将其定义为从`HMSMongoDataObject`（就像`co_objects`模块中的其他数据对象类一样）和`BaseOrder`（来自`business_objects`模块）派生的基本类之外，几乎没有其他更多的事情可做。它可能会在后期出现添加或更改，但是从这两个类中派生`Order`将为其提供足够的功能，以便进行测试。
- en: After going through all of the analysis effort with the Artisan Application's
    Order class definition, that feels like a better starting point for the corresponding
    class in the Central Office code (`co_objects`), though it will need some modification/conversion
    in the process. First and foremost, it needs to derive from `HMSMongoDataObject`
    instead of `JSONFileDataObject`—but since both of those, in turn, are derived
    from `BaseDataObject`, a fair portion of the new `Order` class is already implemented
    with that inheritance change.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在对Artisan应用程序的Order类定义进行了所有分析工作之后，这似乎是中央办公室代码（`co_objects`）中相应类的更好起点，尽管在过程中需要进行一些修改/转换。首先，它需要从`JSONFileDataObject`而不是`HMSMongoDataObject`派生，但由于这两者又都是从`BaseDataObject`派生的，新的`Order`类的相当部分已经通过这种继承变化实现了。
- en: There's enough common code between the two `Order` classes that it would almost
    certainly be worth spending time moving those common items back down into `BaseOrder`.
    Designing, or even implementing concrete classes, then gathering their common
    functionality into common parent classes is just as valid a design or implementation
    approach as starting from the foundations and building out, though it happened
    accidentally in this case.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个`Order`类之间有足够的共同代码，几乎肯定值得花时间将这些共同项目移回`BaseOrder`中。设计，甚至实现具体类，然后将它们的共同功能聚集到共同的父类中，与从基础开始构建的设计或实现方法一样有效，尽管在这种情况下是意外发生的。
- en: 'Beyond that, we''ll need a mechanism that will allow the Web Storefront system
    to create an `Order`. So far, we don''t have any specifications around that process,
    but that doesn''t stop us from creating a class method that will (hopefully) eventually
    be used in that capacity. For near future testing purposes, it will be set up
    to accept a `BaseCustomer` object that''s derived as a `customer`, and a list
    of Product identifiers, with an eye toward the `customer` being revised at some
    point in the future. To start with, all we''re concerned with is a method that
    can be called to create a complete `Order` with the relevant `Product` objects
    attached to it:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，我们需要一个机制，让Web商店系统能够创建一个`Order`。到目前为止，我们还没有关于这个过程的任何规范，但这并不妨碍我们创建一个类方法，希望最终能够在这个容量中使用。为了近期的测试目的，它将被设置为接受一个作为`customer`派生的`BaseCustomer`对象，以及一个产品标识符的列表，目的是在将来的某个时候对`customer`进行修订。起初，我们只关心一个可以被调用来创建一个完整的`Order`并附加相关`Product`对象的方法：
- en: '[PRE19]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It feels reasonably safe to assume that the storefront will be able to pass
    Product identifiers and their quantities in the Order along as some sort of `dict` value,
    and that it won''t be keeping track of entire `Product` objects, at least not
    in the same structure that `hms_sys` code uses. Given the list of Product `oid`
    values available in the `keys()` of the `order_items`, retrieving products to
    be added to the `order` instance on creation is simply a matter of filtering all
    available products down into a collection of the specific items in the Order,
    while preserving their associated quantities:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 可以合理地假设商店前端将能够将产品标识符及其数量作为Order的一种`dict`值传递，并且它不会跟踪整个`Product`对象，至少不是以`hms_sys`代码使用的相同结构。在`order_items`的`keys()`中提供的Product
    `oid`值列表中，检索要添加到创建的`order`实例中的产品只是将所有可用产品过滤为Order中特定项目的集合，同时保留它们的相关数量：
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The products generated here are dicts, generated by a dictionary comprehension,
    whose keys are `Product` objects, and values are the quantities of those products
    in the Order. Then, we need to acquire the `customer`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里生成的产品是由字典生成的，由字典理解生成，其键是`Product`对象，值是订单中这些产品的数量。然后，我们需要获取`customer`：
- en: '[PRE22]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, the new `Order` instance is created, saved (assuring that its data
    is persisted), and returned (in case the calling code needs to reference it immediately
    after it''s been created):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，新的`Order`实例被创建，保存（确保其数据被持久化），并返回（以防调用代码在创建后立即引用它）：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Order` class will also need a `to_message_data` method, just like their
    Product and Artisan counterparts, and with one defined, can use a message transmission
    process that is basically identical to what was established earlier:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Order`类也需要一个`to_message_data`方法，就像它们的Product和Artisan对应物一样，一旦定义了一个，就可以使用基本上与之前建立的相同的消息传输过程：'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This process implies a new story that will probably be needed mostly for UI
    development, but that might have some implications in additional design and implementation
    of the Artisan Applications:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程意味着一个新的故事，可能主要用于UI开发，但可能对Artisan应用的设计和实现也有一些影响：
- en: As an Artisan, I need to be informed when an Order has been placed that includes
    one of my Product offerings so that I can fulfill my part of that Order
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一名Artisan，我需要在包含我的产品供应之一的订单被下达时得到通知，以便我能够履行我的订单部分。
- en: 'Since the creation of a new `Order` by the Web Storefront also needs to relay
    new `Order` objects to each Artisan (looking back at the Order flow diagram),
    and since it seems reasonable to expect that only the store-to-Gateway-service
    portion of that flow would be calling `create_order_from_store`, that seems like
    a reasonable place to implement that messaging at first glance, but in doing so,
    there would be no access to the service''s logging facilities, so any failures
    in communication between the two systems would potentially be lost. If, instead,
    the Web Storefront were to issue a create Order message to the Artisan Gateway,
    the Gateway service could in turn call `create_order_from_store` with the applicable
    data, and log events as needed/desired while it executes. For the purposes of
    illustration, this is the approach that is going to be assumed. In this case,
    `create_order_from_store` is complete as it stands, and the Artisan/Order messaging
    happens as part of the Gateway service''s `create_order` method. The first major
    chunk of its code looks very much like the other create processes:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Web商店前端创建新`Order`还需要将新`Order`对象传递给每个工匠（回顾订单流程图），并且合理地预期只有流程的商店到网关服务部分会调用`create_order_from_store`，乍一看，这似乎是一个合理的地方来实现消息传递，但这样做将无法访问服务的日志记录设施，因此两个系统之间的通信失败可能会丢失。相反，如果Web商店前端向工匠网关发出创建订单消息，网关服务可以调用`create_order_from_store`并在执行时记录所需的事件。为了说明这一点，将假定采用这种方法。在这种情况下，`create_order_from_store`已经完整，工匠/订单消息作为网关服务的`create_order`方法的一部分发生。其代码的第一个主要部分看起来非常像其他创建过程：
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Since the `create_order_from_store` method already saves the new Order, we don't
    need to save it here—it will already exist in the data store, and can be retrieved
    by other processes as soon as this point in the code has been reached. In order
    to proceed, and send the necessary `Order` messages to the individual artisans
    who need to be aware of them, we need to sort out which products (and in what
    quantities) are associated with each Artisan in the system.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`create_order_from_store`方法已经保存了新订单，我们不需要在这里保存它——它已经存在于数据存储中，并且可以在代码到达这一点后立即被其他进程检索到。为了继续，并发送必要的`Order`消息给需要知道它们的各个工匠，我们需要弄清楚系统中每个工匠与哪些产品（以及数量）相关联。
- en: Since the `Artisan` can have a `Product`, but a `Product` doesn't keep track
    of which `Artisan` they belong to (which might be a good thing to add, in retrospect),
    the best option we have right now is to load up the `Artisan`, and search for
    it for each product. This is not optimal, and definitely worth looking at changing,
    but it will work for now.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Artisan`可以拥有`Product`，但`Product`不会跟踪它们属于哪个`Artisan`（回顾起来可能是一个不错的添加），我们现在唯一的选择是加载`Artisan`，并为每个产品搜索它。这并不是最佳选择，肯定值得考虑更改，但现在可以使用。
- en: 'The `new_order` variable is holding on to an `Order` object that, if expressed
    as a dict, would look like this:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`new_order`变量持有一个`Order`对象，如果表示为字典，将如下所示：'
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Rendering that down into a dict of Artisan/item:quantity values is simple,
    if done in a brute-force manner:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 将其转换为Artisan/item:quantity值的字典是简单的，如果以一种蛮力的方式完成：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If an Artisan is found that''s associated with the Product, then one of two
    cases needs to execute: either the `artisan` already exists as a key in the `artisan_orders
    dict`, in which case we just append the item data to the current list of items
    associated with the `artisan`, or they haven''t had a Product match yet, in which
    case we create an entry for the `artisan`, whose value is a list containing the
    item data in question:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到与产品相关联的工匠，那么需要执行两种情况中的一种：要么`artisan`已经存在于`artisan_orders dict`中，这种情况下我们只需将项目数据附加到与`artisan`相关的当前项目列表中，要么他们还没有产品匹配，这种情况下我们为`artisan`创建一个条目，其值是包含相关项目数据的列表：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Although it shouldn''t happen, it''s possible that an Order could come in with
    a Product that has no identifiable `artisan` to associate with it. The specifics
    of how that error case should be handled may be dependent on the web store system.
    Even setting that consideration aside, it should be handled in some fashion that
    hasn''t been defined yet. At a minimum, however, the failure should be logged:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管不应该发生，但有可能出现订单中出现没有可识别的`artisan`与之关联的产品。如何处理该错误情况的具体细节可能取决于网络商店系统。即使将这种考虑放在一边，也应该以某种尚未定义的方式处理。但至少，失败应该被记录下来：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once this sorting has completed, the `artisan_orders` dict will look something
    like this, with each key in `artisan_orders` being an actual `Artisan` object,
    with all of the properties and methods of any such instance, with the Product `oid`
    and quantities associated:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这种排序后，`artisan_orders`字典将看起来像这样，其中`artisan_orders`中的每个键都是一个实际的`Artisan`对象，具有任何此类实例的属性和方法，与产品`oid`和相关的数量：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Python dict instances can use *almost* anything as a key: any immutable built-in
    type (like `str` and `int` values, and even `tuple` values, but not `list` or
    other `dict` values) can be used as a key in a `dict`. In addition, instances
    of user-defined classes, or even those classes themselves, are viable. Instances
    of built-in classes, or the built-in classes themselves, may not be valid `dict` keys,
    though.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Python字典实例可以使用*几乎*任何东西作为键：任何不可变的内置类型（如`str`和`int`值，甚至`tuple`值，但不是`list`或其他`dict`值）都可以用作`dict`中的键。此外，用户定义类的实例，甚至这些类本身，也是可行的。内置类的实例，或者内置类本身，可能不是有效的`dict`键。
- en: 'With a complete and well-formed `artisan_orders`, the process of sending Order
    messages to each Artisan is relatively simple—iterating over each Artisan key,
    building the message data in the structure that the Artisan Application''s `Order`
    class expects, creating a `DaemonMessage` to sign the message, and sending it:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 有了完整和完整的`artisan_orders`，向每个工匠发送订单消息的过程相对简单——遍历每个工匠键，构建消息数据的结构，工匠应用程序的`Order`类期望创建一个`DaemonMessage`来签署消息，并发送它：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Sending a message to a specific Artisan requires another change: the `send_message`
    method of `RabbitMQSender` was not originally built to send messages to a queue
    other than the default it was configured with. It makes sense for each Artisan
    to have their own message queue for several reasons, and in order to use that
    specific queue, it has to be accepted as a `send_message` argument. The Gateway
    side call to send the message reflects that (passing `artisan.queue_id` as an
    argument):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 向特定手艺人发送消息需要另一个更改：`RabbitMQSender`的`send_message`方法最初并不是用来发送消息到除了默认队列之外的队列。每个手艺人有自己的消息队列是有道理的，为了使用特定的队列，它必须被接受为`send_message`的参数。网关端调用发送消息反映了这一点（将`artisan.queue_id`作为参数传递）：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The related changes in `RabbitMQSender.send_message` are not complicated: the
    addition of an optional `queue_name` argument, and a check to see if it has been
    provided, falling back to the configured default queue name is all that was needed:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`RabbitMQSender.send_message`中的相关更改并不复杂：添加一个可选的`queue_name`参数，并检查是否已提供，如果没有提供，则返回到配置的默认队列名称就足够了。'
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Customer – canceling an order
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顾客 - 取消订单
- en: 'The relevant Story for Customer being able to cancel an Order, from the earlier
    collection of stories is:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 顾客能够取消订单的相关故事，来自先前的故事集合是：
- en: As a Customer who has canceled an Order, I need the relevant parts of that cancellation
    to be relayed to the appropriate artisans so that they won't fulfill their part
    of the Order.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为取消订单的顾客，我需要相关部分的取消被传达给适当的手艺人，以便他们不会履行他们的订单部分。
- en: 'Order cancellation has one aspect in common with Order creation: the origin
    point of a cancellation should be with a customer, almost certainly as some functionality
    available through the Web Storefront. Operating under the same assumptions that
    shaped the creation of an Order, so that the Web Storefront will be able to send
    a message to the Artisan Gateway service to indicate that a cancellation has been
    initiated, similarly allows the Gateway to handle it in a single message handler
    method: `delete_order`, in this case.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 订单取消与订单创建有一个共同点：取消的起点应该是顾客，几乎肯定是通过Web商店前端可用的某些功能。在与订单创建形成相同假设的情况下，Web商店前端将能够向手艺人网关服务发送消息，指示已启动取消，同样允许网关在一个单一的消息处理程序方法中处理它：在这种情况下是`delete_order`。
- en: 'The `delete_order` message handler method is, ultimately, two tasks that it
    must perform:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete_order`消息处理程序方法最终必须执行两个任务：'
- en: Given an Order, identified by an `oid`, it has to track down which artisans
    were involved with the initial Order. That part of the process can be identical
    to the identification of artisans and products in `create_order`. The Product
    identification aspect of that code may not be needed, but it doesn't do any harm
    to include it, and it might even be leveraged later on to prevent the cancellation
    of orders that have been partially fulfilled.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个由`oid`标识的订单，它必须追踪哪些手艺人参与了最初的订单。该过程的一部分可以与`create_order`中的手艺人和产品的识别相同。该代码的产品识别方面可能不需要，但包含它并不会造成任何伤害，甚至可能在以后利用它来防止部分履行的订单被取消。
- en: 'It has to generate and send a message to each Artisan Application associated
    with an Artisan who''s associated with the Order: a delete message with the Order''s
    `oid` as the data payload.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须生成并发送消息给与订单相关联的手艺人应用程序：一个带有订单`oid`作为数据有效负载的删除消息。
- en: 'The Artisan/Product association, yielding `artisan_orders` in the `create_order`
    and `delete_order` code, would probably be worth moving into a common helper method
    in the `ArtisanGatewayDaemon` class: it''s identical to being written in those
    methods as things stand right now. With only two instances of that code present
    right now, and those being close together in the code, it''s not an imperative,
    perhaps, but as long as there are two instances of the same code, any changes
    to one have to be made to the other as well.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 手艺人/产品关联，在`create_order`和`delete_order`代码中产生`artisan_orders`，可能值得将其移入`ArtisanGatewayDaemon`类中的一个通用辅助方法：它与当前的方法中写的内容完全相同。目前只有两个该代码的实例，并且这些代码在代码中是相邻的，这可能不是一个必须的，但只要有两个相同的代码实例，对其中一个的任何更改也必须对另一个进行更改。
- en: 'Like the Order creation process, Order cancellation implies a new story, again
    probably needed mostly for UI development, but that might have some additional
    design and implementation implications for the Artisan Applications:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 与订单创建过程一样，订单取消意味着一个新的故事，可能主要用于UI开发，但对手艺人应用程序可能有一些额外的设计和实现影响：
- en: As an Artisan, I need to be informed when an Order has been canceled that includes
    one of my Product offerings so that I can stop any in-process fulfillment activities
    related to it and update my Product status as needed
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为手艺人，我需要在订单被取消时得到通知，其中包括我的产品供应，以便我可以停止与之相关的任何进行中的履行活动，并根据需要更新我的产品状态。
- en: The foundation for resolving this story, when it does become active, should
    be mostly–if not entirely–in place as a result of the Order deletion messaging.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个故事的基础，当它变得活跃时，应该大部分 - 如果不是全部 - 已经在订单删除消息中就位。
- en: Artisan – fulfilling an item in an order
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手艺人 - 完成订单中的物品
- en: 'The relevant Story for Artisan being able to fulfil an item in an Order, from
    the earlier collection of stories is:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 手艺人能够完成订单中的物品的相关故事，来自先前的故事集合是：
- en: As an Artisan, I need to be able to update Order objects so that I can indicate
    to the Central Office when my part of an Order is fulfilled.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为手艺人，我需要能够更新订单对象，以便我可以在订单的我的部分完成时向中央办公室指示。
- en: 'Ultimately, the act of fulfilling all or part of an Order by an Artisan is
    just another update process, at least from a messaging standpoint. So far, though,
    there isn''t a mechanism for keeping track of fulfilled items in any of the `Order`
    classes, and that''s going to be problematic until it''s addressed. Fortunately,
    the model for fulfilled items can be essentially identical to the model for the
    original Order items—a collection (a `dict`, specifically) of Product `oid` keys
    and `int` quantities. Adding that property to `artisan_objects.Order`, using the
    `items` property as a model or guideline, requires the following:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，由工匠履行订单的全部或部分行为只是另一个更新过程，至少从消息传递的角度来看是这样。到目前为止，尽管在任何`Order`类中都没有跟踪已履行项目的机制，但在解决这个问题之前，这将是有问题的。幸运的是，已履行项目的模型基本上可以与原始订单项目的模型相同
    - 一个Product `oid`键和`int`数量的集合（特指`dict`）。将该属性添加到`artisan_objects.Order`，并使用`items`属性作为模型或指南，需要以下步骤：
- en: Including `fulfilled_items`, a `dict`, as an argument in `__init__`, and integrating
    it the same way that the `items` argument/property is integrated
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`__init__`中包括`fulfilled_items`，一个`dict`，作为参数，并以与`items`参数/属性集成相同的方式集成它
- en: Creating the `getter`, `setter`, and `deleter` methods for it
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为其创建`getter`，`setter`和`deleter`方法
- en: Creating the `fulfilled_items` property, associated with `_get_fulfilled_items`
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`fulfilled_items`属性，与`_get_fulfilled_items`相关联
- en: Making sure that the `to_data_dict` method includes a representation of `fulfilled_items`
    in its output results
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`to_data_dict`方法在其输出结果中包含`fulfilled_items`的表示
- en: Making sure that the `from_data_dict` class method doesn't need any special
    handling of an incoming `fulfilled_items` value
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保`from_data_dict`类方法不需要对传入的`fulfilled_items`值进行任何特殊处理
- en: 'Since `fulfilled_items` will follow the same constraints as the `items` property
    of an `Order`, direct modification of the members of `fulfilled_items` is prohibited.
    The underlying rationale for that prohibition is similar: we want modifications
    of those members to be tightly controlled in order to prevent bad data changes
    as much as possible. At the same time, we need to allow artisans to fulfill Order
    items (while performing all the relevant checks to make certain that the data
    changes are valid).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`fulfilled_items`将遵循`Order`的`items`属性的相同约束，禁止直接修改`fulfilled_items`的成员。这种禁止的基本原理是相似的：我们希望尽可能严格地控制这些成员的修改，以防止坏数据的更改。同时，我们需要允许工匠履行订单项目（同时执行所有相关检查，以确保数据更改是有效的）。
- en: 'To facilitate that, the `artisan_objects.Order` class needs a method that will
    be called to allow an Artisan user to mark items as fulfilled:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，`artisan_objects.Order`类需要一个方法，允许工匠用户标记项目为已履行：
- en: '[PRE34]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Order fulfillment data is, for an Artisan, one of the more important datasets,
    so we''re going to check every argument in several different ways before allowing
    the change to be saved. The check processes starts with standard type and value
    checking (stripping the error messaging out to keep the listing short):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工匠来说，订单履行数据是更重要的数据之一，因此在允许更改保存之前，我们将以几种不同的方式检查每个参数。检查过程从标准类型和值检查开始（剥离错误消息以保持列表的简洁）：
- en: '[PRE35]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We''re also going to check to make sure that the item being fulfilled is actually
    part of the Order:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将检查以确保正在履行的项目实际上是订单的一部分：
- en: '[PRE36]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'And we''ll check to make sure that the fulfillment quantity isn''t greater
    than the quantity in the Order:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查以确保履行数量不大于订单中的数量：
- en: '[PRE37]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Similar changes, minus the `fulfill_items` method, will also need to be made
    to the Central Office `Order` class (`co_objects.Order`) to handle fulfillment messages.
    For the time being, until we can focus on the round trip message testing in the
    next chapter, these can be accommodated by simply copying the code from `artisan_objects.Order`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的更改，减去`fulfill_items`方法，还需要对中央办公室`Order`类（`co_objects.Order`）进行处理以处理履行消息。目前，直到我们可以专注于下一章中的往返消息测试，这些可以通过简单地从`artisan_objects.Order`复制代码来实现。
- en: Copying that much code around is another argument for refactoring the `Order`
    classes, re-defining `BaseOrder`, and deriving the concrete classes from it instead.
    Time and space constraints in this book may not allow for much discussion of this
    process, but we'll take at least a brief look at it, either during or after testing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这么多代码之间进行复制是重构`Order`类的另一个理由，重新定义`BaseOrder`，并从中派生具体的类。本书中的时间和空间限制可能不允许对这个过程进行太多讨论，但我们至少会在测试期间或之后简要地看一下。
- en: When do messages get sent?
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时发送消息？
- en: 'Up until this point, we''ve spent a fair length of time digging in to how the
    relevant messaging will be generated and sent, but very little about when it happens,
    apart from the examination of Order creation and cancellation. Since messages
    correspond directly to various local CRUD operations, it''s tempting to simply
    add the messaging calls into the `_create` and `_update` methods that they already
    have, making sure to account for the `is_dirty` and `is_new` flags that we defined
    in `BaseDataObject`. Before going down that path, though, it would be a good idea
    to take a look at all of the messaging processes, from origination to completion,
    to make sure that they have a clear process termination. The scenario that we
    need to make sure to avoid, using a `Product` update process as an example, looks
    like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经花了相当长的时间来深入研究相关消息将如何生成和发送，但很少关于何时发生，除了对订单创建和取消的检查。由于消息直接对应于各种本地CRUD操作，很容易将消息调用简单地添加到它们已经具有的`_create`和`_update`方法中，确保考虑我们在`BaseDataObject`中定义的`is_dirty`和`is_new`标志。然而，在走下这条路之前，最好看一下所有的消息处理过程，从起源到完成，以确保它们有一个清晰的过程终止。我们需要确保避免的情况，以`Product`更新过程为例，看起来像这样：
- en: '![](assets/86daf41f-7f54-4593-ab2c-11e9ac83b1cc.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/86daf41f-7f54-4593-ab2c-11e9ac83b1cc.png)'
- en: 'Where:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在哪里：
- en: 'An **Artisan** makes a change to one of their products:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**工匠**对其产品进行更改：'
- en: The local data change is executed
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地数据更改已执行
- en: 'Their **Artisan Application** sends a message to the **Artisan Gateway: Update
    Product "X"**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们的**Artisan应用程序**向**Artisan网关**发送消息：更新产品“X”
- en: 'The **Artisan Gateway** receives the message:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Artisan网关**接收到消息：'
- en: The local data change is executed
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行本地数据更改
- en: 'A message is sent to the corresponding **Artisan Application: Update Product
    "X"**'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向相应的**Artisan应用程序**发送消息：更新产品“X”
- en: 'The **Artisan Application** receives the message:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Artisan应用程序**接收到消息：'
- en: The local data change, which likely doesn't have any updated data, is executed
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行本地数据更改，可能没有任何更新的数据
- en: 'A message is sent to the **Artisan Gateway: Update Product "X"**'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向**Artisan网关**发送消息：更新产品“X”
- en: 'At the end of the last step, the process would, without some check process
    or exit condition, jump back to the second step, and into an infinite loop of
    update messages that don''t actually do anything. The same scenario could occur
    with any of the update processes where more than one origin point for data changes
    could be in play: the `Artisan` objects can be updated by the artisans they represent
    and by Central Office staff. `Order` objects are currently exempt, but it''s not
    difficult to imagine a future need for a customer to alter an Order after it''s
    been transmitted to the artisans who''d be fulfilling items in it.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步结束时，如果没有一些检查过程或退出条件，该过程将回到第二步，并进入一个实际上不执行任何操作的更新消息的无限循环。在任何可以发生多个数据更改起点的更新过程中，都可能出现相同的情况：`Artisan`对象可以由它们代表的工匠和中央办公室工作人员更新。`Order`对象目前是豁免的，但很容易想象在将来需要顾客在订单传递给将履行其中物品的工匠后修改订单的情况。
- en: 'Ultimately, because the `save` methods of the various data object classes have
    no awareness of where the data change they''re executing came from, they cannot
    make any decisions about whether or not it''s appropriate to send a message out
    after the data change has been executed. A possible solution, then, would be to
    allow (or even require) an additional argument in each `save` that provides that
    information, and that could be used to determine whether a message needs to be
    sent or not. The structure of this modification might look something like this
    (for a data object living in the Artisan Application''s code-base):'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，由于各种数据对象类的`save`方法对其正在执行的数据更改的来源没有意识，它们无法对数据更改执行后是否适合发送消息做出任何决定。因此，一个可能的解决方案是允许（甚至要求）在每个`save`中提供该信息的额外参数，并且可以用于确定是否需要发送消息。这种修改的结构可能看起来像这样（对于存储在Artisan应用程序代码库中的数据对象）：
- en: '[PRE38]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: It would be feasible to add an additional abstraction layer between `BaseDataObject`
    (where `save` is defined currently) and each of the concrete data objects that
    would override the `BaseDataObject.save` method. This abstraction–an additional
    ABC–would need to be created in the Artisan Application and Artisan Gateway code-bases,
    at a minimum, and another variant might be needed in the Central Office application
    as well, depending on implementation details that haven't been fully explored
    yet.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在`BaseDataObject`（当前定义了`save`）和每个具体数据对象之间添加一个额外的抽象层，该抽象层将覆盖`BaseDataObject.save`方法。这种抽象-额外的ABC-至少需要在Artisan应用程序和Artisan网关代码库中创建，并且根据尚未完全探索的实现细节，中央办公室应用程序可能也需要另一个变体。
- en: The trade-off is that all data objects would have to pay attention to where
    their data changes originated from. This feels… messy, complicated, and potentially
    difficult to maintain, at least at first blush.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 权衡之处在于所有数据对象都必须注意其数据更改的来源。这感觉…混乱、复杂，至少乍一看可能难以维护。
- en: 'Another possibility would be to alter `DaemonMessage`: if the messages themselves
    contain something, such as data that indicates where they originated from, then
    the handlers for those messages would be able to tell whether or not a message
    needs to be sent after the data change had been dealt with. In that design scenario,
    a `Product` update message that originated with an Artisan, including an `origin`
    specification, might look like this (before being converted to JSON):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是修改`DaemonMessage`：如果消息本身包含某些内容，比如指示其来源的数据，那么这些消息的处理程序就能够判断在处理完数据更改后是否需要发送消息。在这种设计方案中，由Artisan发起的`Product`更新消息，包括`origin`规范，可能如下所示（在转换为JSON之前）：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The corresponding `update_product` handler method in the `ArtisanGatewayDaemon`
    service class, along with other handler methods, currently expects a `dict` (`properties`)
    to act upon, and is called by `ArtisanGatewayDaemon._handle_message` as the `main`
    loop of the service reads messages to be acted upon. We could change what the
    individual handler methods expect, passing the original `message` (a `DaemonMessage`
    instance) instead, making the handler methods responsible for breaking down the
    incoming `message` into the `properties` and acting upon them as they already
    do, and giving them the responsibility for determining whether a message needs
    to be sent and sending it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArtisanGatewayDaemon`服务类中对应的`update_product`处理程序方法，以及其他处理程序方法，目前期望一个`dict`（`properties`）来执行，并且在服务的`main`循环中由`ArtisanGatewayDaemon._handle_message`调用以读取消息进行处理。我们可以改变各个处理程序方法的期望，传递原始的`message`（`DaemonMessage`实例）而不是，使处理程序方法负责将传入的`message`分解为`properties`并对其进行处理，就像它们已经做的那样，并让它们负责确定是否需要发送消息并发送消息。'
- en: 'Given a `DaemonMessage` with an `origin`, and a globally accessible value to
    compare that origin with, the decision to send a message or not, and sending it
    if needed, isn''t complex. If it were anywhere in the Gateway service (that is,
    `self` is the service instance), it would look more or less like this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个带有`origin`的`DaemonMessage`，以及一个全局可访问的值来与该来源进行比较，决定是否发送消息，并在需要时发送消息并不复杂。如果它在网关服务的任何地方（即`self`是服务实例），它看起来会更或多少像这样：
- en: '[PRE40]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The data used to create the `outbound_message` might differ, depending on whether
    the data dictionary or message dictionary of the newly created or recently updated
    object was used instead.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 用于创建“outbound_message”的数据可能会有所不同，这取决于是使用新创建或最近更新的对象的数据字典还是消息字典。
- en: 'So, when an incoming `message` is acted upon:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当一个传入的“消息”被执行时：
- en: Its `origin` is checked
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查了它的“origin”
- en: If that `origin` is local, then a corresponding `outbound_message` is created
    and sent, using the original `operation` of the incoming `message`, the local `origin`
    and `signing_key`, and whatever `data` is appropriate
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果“origin”是本地的，那么将创建并发送相应的“outbound_message”，使用传入“message”的原始“operation”，本地“origin”和“signing_key”，以及适当的“data”
- en: Otherwise, that entire branch is skipped
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，整个分支都会被跳过
- en: 'That''s not a lot of code to add—a mere nine lines, assuming that the sender
    isn''t created elsewhere. The changes to `DaemonMessage` are pretty trivial: adding
    the `origin` property and making sure it''s accounted for everywhere (basically,
    anywhere that the `operation` property is already in use). At this point, this
    doesn''t represent a major change to existing code either—we''ve only created
    outbound messages for Order creation and updates so far.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的代码不多——仅仅九行，假设发送方没有在其他地方创建。对“DaemonMessage”的更改相当琐碎：添加“origin”属性并确保它在所有地方都被考虑到（基本上是在“operation”属性已经被使用的任何地方）。在这一点上，这也不代表对现有代码的重大更改——到目前为止，我们只为订单创建和更新创建了出站消息。
- en: If there is a sticking point, it's in the need to acquire the `Artisan` instance
    that relates to the operation  so that the outbound message can use the appropriate
    message queue (`artisan.queue_id`). This would be necessary no matter what approach
    we decide to pursue, though, so it's probably a wash in this case (and it would
    complicate the idea of modifying `save`, which we saw previously, even more).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一个瓶颈，那就是需要获取与操作相关的“Artisan”实例，以便出站消息可以使用适当的消息队列（“artisan.queue_id”）。无论我们决定追求什么方法，这都是必要的，所以在这种情况下可能是一个平衡（它还会使我们之前看到的修改“save”的想法变得更加复杂）。
- en: 'Even with that, this feels like a solid approach. The changes to `_handle_message`
    are mostly argument and variable name changes at this point:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有了这一点，这种方法仍然感觉很可靠。在这一点上，“_handle_message”的更改主要是参数和变量名称的更改：
- en: '[PRE41]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The handler methods (using `update_product`, as an example) remain largely
    unchanged:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 处理程序方法（以“update_product”为例）基本保持不变：
- en: '[PRE42]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We still need the `properties`; we''re just acquiring them in the individual
    handler methods instead of in `_handle_message`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要“properties”；我们只是在个别处理程序方法中获取它们，而不是在“_handle_message”中获取：
- en: '[PRE43]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The code, from that point until the modified object is saved, remains unchanged:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 从那一点到修改的对象保存为止，代码保持不变：
- en: '[PRE44]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'And then we can check to see if an outbound message needs to be sent, acquire
    the relevant `Artisan`, create the `message`, and send it:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以检查是否需要发送出站消息，获取相关的“Artisan”，创建“message”并发送：
- en: '[PRE45]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Since acquiring an `Artisan` from a `Product` is going to be a recurring theme,
    a helper method (`get_artisan_from_product`) was created to streamline that process.
    It also highlights the eventual need for a more direct association between products
    and artisans, but a data object query-based process will suffice for now:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从“Product”中获取“Artisan”将是一个经常出现的主题，因此创建了一个辅助方法（“get_artisan_from_product”）来简化该过程。这也突出了产品和工匠之间更直接关联的最终需求，但是基于数据对象查询的过程现在足够了：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'A final consideration before ending this chapter: when we started this chunk
    of development, there was still a decision pending with respect to whether message
    queues were going to be implemented as a "one for all artisans" or "one for each
    Artisan." No formal decision was made, but there are other considerations that
    may have arisen as the messaging processes were being thought out:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前的最后一个考虑：当我们开始这一部分开发时，关于消息队列是作为“所有工匠的一个”还是“每个工匠的一个”实施的决定仍在等待。虽然没有做出正式决定，但在思考消息处理过程时可能出现了其他考虑：
- en: 'Each Artisan needs at least two separate message queues: one for traffic to
    the Artisan, and one for traffic from them. If a single queue for all traffic
    is implemented, then:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个工匠至少需要两个单独的消息队列：一个用于发送到工匠的流量，一个用于从他们那里发送的流量。如果实施了所有流量的单一队列，那么：
- en: The code would have to be altered to include both an `origin` (already done)
    and a `destination` in order to assure that, for example, messages dropped in
    a queue by the Gateway weren't also read by the Gateway
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码必须被修改以包括“origin”（已完成）和“destination”，以确保例如，网关放入队列的消息不会被网关读取
- en: Even with that in place, a message that hasn't been read and acted upon by the
    appropriate destination would almost certainly block other messages in the queue
    from being read and acted upon, without still more code changes and the attendant
    complexity
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使有了这个，一个尚未被适当目的地读取和执行的消息几乎肯定会阻止队列中的其他消息被读取和执行，而不是仍然需要更多的代码更改和相关的复杂性
- en: If each Artisan has a distinct message queue for inbound and outbound messages,
    that entire set of complications will simply go away. There is some additional
    work that will be necessary—providing some means of identifying individual inbound
    and outbound queues—but if each queue handles only traffic in one direction, to
    or from one Artisan Application and the Gateway service, this simplifies things
    considerably, and the development cost should be pretty minimal.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果每个工匠都有一个独特的消息队列用于传入和传出的消息，那么整套复杂性将会消失。还需要一些额外的工作——提供一些标识单个传入和传出队列的手段——但是如果每个队列只处理单向流量，到或从一个工匠应用和网关服务，这将大大简化事情，并且开发成本应该是相当小的。
- en: As a side benefit, since each message in a queue would, simply because it came
    from that queue, be immediately associable with the Artisan that the queue belongs
    to.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个附带的好处，由于队列中的每条消息，仅仅因为它来自该队列，就可以立即与该队列所属的工匠相关联。
- en: The only remaining cost in having multiple message queues is that multiple queues
    would exist—and that, in the main, is a cost that will be borne by the message
    queue server.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有多个消息队列的唯一剩下的成本是会存在多个队列，而这主要是由消息队列服务器承担的成本。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: The development efforts in this chapter have been scattered all over the system's
    code-base, largely because of some requirement gaps or implementation needs and
    details that surfaced as specific functionality unfolded. Ideally, in a real-world
    effort, much of that would have surfaced considerably earlier, and been expressed
    as specific tasks that were attached to the stories in the iteration, though some
    might still have occurred—we've made some decisions, both in this chapter and
    the one before, that shaped how things needed to work, that might not have been
    captured in an initial story analysis exercise.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的开发工作在整个系统的代码库中分散进行，主要是因为一些需求差距或实现需要和细节的出现，这些需求和细节是特定功能展开时出现的。理想情况下，在实际的努力中，很多东西本应该早早地出现，并且被表达为附加到迭代故事中的具体任务，尽管一些可能仍然发生——我们在本章和之前的章节中做出了一些决定，这些决定塑造了工作的需要，可能没有被捕捉在最初的故事分析练习中。
- en: 'As a result, the code at this point is quite probably broken. Perhaps drastically
    broken. Still, there''s been a lot of progress against the iteration''s stories,
    even if none of them can be formally closed yet:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目前的代码很可能是错误的。也许是严重错误的。尽管如此，在这个迭代的故事中取得了很大的进展，即使它们还不能正式关闭：
- en: Fundamental functionality for dealing with all the data flow between system
    components has been defined, with a few concrete implementations that will serve
    as starting points for other concrete implementations
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经定义了处理系统组件之间所有数据流的基本功能，并有一些具体的实现作为其他具体实现的起点。
- en: Changes needed to accomplish the transmission and receipt of messages have been
    scoped, if not implemented
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经确定需要进行更改以完成消息的传输和接收，即使还没有实施。
- en: A solid (if basic) understanding of how and when those messages need to be sent
    has been established
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已经建立了对何时以及如何发送这些消息的基本理解。
- en: There's still work to be done on most of the iteration stories before they can
    be considered complete—even setting aside the UI considerations, we still don't
    have demonstrable, provable message flows in place. Getting those finalized will
    be the focus of the next chapter, and it will take a decidedly test-driven approach,
    even if it's not a formal TDD process.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数迭代故事完成之前仍然有工作要做——即使不考虑UI方面的考虑，我们仍然没有可证明的消息流。在下一章中，将专注于完成这些工作，并且将采用明显的测试驱动方法，即使这不是一个正式的TDD过程。
