- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Creating Your Add-Ons
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建您的扩展插件
- en: Add-ons are extensions that expand the capabilities of Blender and can be enabled
    in the preferences. Some of them, such as Math Vis, encountered in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033),
    are official features distributed as optional functionalities. Others are third-party
    expansions that can be installed by a user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展插件是扩展Blender功能的插件，可以在首选项中启用。其中一些，如在第[*2章*](B18375_02.xhtml#_idTextAnchor033)中遇到的Math
    Vis，是作为可选功能分发的官方功能。其他的是第三方扩展，用户可以安装。
- en: At their core, add-ons are Python modules that contain information used by Blender
    to install, enable, and remove them like in a plugin system.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本质上，扩展插件是包含Blender安装、启用和删除所需信息的Python模块，就像插件系统一样。
- en: In this chapter, you will learn how to write and install an add-on in Blender,
    and how to enable add-ons while they are still in the making. We will also implement
    a new command that groups objects into collections and make it part of the object
    context menu.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在Blender中编写和安装扩展插件，以及如何在制作过程中启用扩展插件。我们还将实现一个新的命令，将对象分组到集合中，并将其作为对象上下文菜单的一部分。
- en: 'This chapter will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Scripting Blender extensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写Blender扩展插件脚本
- en: Running and updating our add-on
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和更新我们的扩展插件
- en: Fixing errors and improving our code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复错误和改进我们的代码
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术需求
- en: We will use Blender and **Visual Studio Code** (**VS Code**). The examples created
    in this chapter can be found at [https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Blender和**Visual Studio Code**（**VS Code**）。本章创建的示例可以在[https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3](https://github.com/PacktPublishing/Python-Scripting-in-Blender/tree/main/ch3)找到。
- en: Installing our add-ons in Blender
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Blender中安装我们的扩展插件
- en: We can write a very simple add-on using VS Code. This add-on doesn’t really
    do anything; it just shows up in the extensions list.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用VS Code编写一个非常简单的扩展插件。这个扩展插件实际上并没有做什么；它只是在扩展列表中显示。
- en: 'First, we must create a folder for the code of this chapter. We can use the
    file manager or the navigation sidebar that comes with most IDEs. In this example,
    we will use VS Code, which we met in the *External editors* section of [*Chapter
    1*](B18375_01.xhtml#_idTextAnchor014):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须为本章的代码创建一个文件夹。我们可以使用文件管理器或大多数IDE附带的重定向侧边栏。在这个例子中，我们将使用我们在[*第1章*](B18375_01.xhtml#_idTextAnchor014)的*外部编辑器*部分遇到的VS
    Code：
- en: Open your **PythonScriptingBlender** project in VS Code.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开您的**PythonScriptingBlender**项目。
- en: Create a new folder by clicking the **New** **Folder** icon.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建文件夹**图标创建一个新文件夹。
- en: '![Figure 3.1: Creating a folder in Visual Studio Code](img/Figure_3.01_B18375.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：在Visual Studio Code中创建文件夹](img/Figure_3.01_B18375.jpg)'
- en: 'Figure 3.1: Creating a folder in Visual Studio Code'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1：在Visual Studio Code中创建文件夹
- en: Name the new folder `ch3`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹命名为`ch3`。
- en: 'Now, we can create a Python file for our add-on:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以为我们的扩展插件创建一个Python文件：
- en: Make sure the `ch3` folder is selected in the **VS Code** explorer, and then
    create a new file by clicking the **New** **File** icon.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**VS Code**资源管理器中选择`ch3`文件夹，然后点击**新建文件**图标创建一个新文件。
- en: '![Figure 3.2: Creating a file in VS Code](img/Figure_3.02_B18375.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2：在VS Code中创建文件](img/Figure_3.02_B18375.jpg)'
- en: 'Figure 3.2: Creating a file in VS Code'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2：在VS Code中创建文件
- en: Name the new file `the_simplest_add_on.py`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`the_simplest_add_on.py`。
- en: Open the file via a double click.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击打开文件。
- en: We are ready to write our add-on; let’s look at what is required.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好编写我们的扩展插件了；让我们看看需要什么。
- en: Add-on requirements
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展插件需求
- en: 'To be considered an add-on, our code must contain three things:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要被视为扩展插件，我们的代码必须包含三样东西：
- en: '**Script meta info** – that is, information about the add-on'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚本元信息**——即有关扩展插件的信息'
- en: A `register()` function to enable the add-on
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于启用扩展插件的`register()`函数
- en: An `unregister()` function to disable the add-on
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于禁用扩展插件的`unregister()`函数
- en: Script meta info
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本元信息
- en: 'The information displayed in the preferences tab comes from the `bl_info` variable,
    a dictionary located at the top of the `.py` file. The dictionary must contain
    the name of the author, a short description of the add-on, and the version of
    Blender for which it is written. Here is the info for our simple add-on:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首选项标签页中显示的信息来自`bl_info`变量，这是一个位于`.py`文件顶部的字典。该字典必须包含作者的姓名、扩展插件的简短描述以及为其编写的Blender版本。以下是我们的简单扩展插件的详细信息：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Start with a blank!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从空白开始！
- en: It is better to leave a blank line at the start and the end of our code – `.py`
    files that do not start with a blank line might fail to register as add-ons and
    cause a `missing` `bl_info` error.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码开始和结束处留一个空行会更好——不以空行开始的`.py`文件可能无法注册为附加组件并导致`missing` `bl_info`错误。
- en: Registration
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册
- en: 'The `register()` function is executed when an add-on is enabled. There is not
    much going on for now – only a `pass` statement, as our function doesn’t do anything:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加组件启用时，会执行`register()`函数。目前并没有什么动作发生——只有一个`pass`语句，因为我们的函数没有做任何事情：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `unregister()` function is invoked when the add-on is disabled. Much like
    `register()`, it doesn’t do anything yet, but it is required as an add-on:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当附加组件禁用时，会调用`unregister()`函数。与`register()`类似，它目前还没有做什么，但它是一个附加组件所必需的。
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Installation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装
- en: 'Now, it’s time to install our add-on in Blender:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在 Blender 中安装我们的附加组件了：
- en: Open the preferences window via **Edit** | **Preferences** from the top menu.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过顶部菜单中的**编辑** | **首选项**打开首选项窗口。
- en: Select the **Add-ons** tab in the left column.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列中选择**附加组件**选项卡。
- en: Click the **Install** button at the top right of the add-ons preferences.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在附加组件首选项的右上角点击**安装**按钮。
- en: In the file browser, navigate to `PythonScriptingBlender\ch3` and select `the_simplest_add_on.py`.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件浏览器中导航到`PythonScriptingBlender\ch3`并选择`the_simplest_add_on.py`。
- en: Click the **Install Add-on** button at the bottom
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在底部点击**安装附加组件**按钮。
- en: Our add-on has been copied and installed in Blender; the filter entry on the
    top left is filled so that only the new add-on is displayed. We can click the
    add-on checkbox to enable it. Expanding the disclosure triangle displays more
    information from `bl_info`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的附加组件已经被复制并安装到 Blender 中；左上角的过滤器输入被填充，以便只显示新的附加组件。我们可以点击附加组件复选框来启用它。展开展开三角形可以显示更多来自`bl_info`的信息。
- en: '![Figure 3.3: A very simple add-on as listed in Blender](img/Figure_3.3_B18375.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.3：Blender 中列出的一个非常简单的附加组件](img/Figure_3.3_B18375.jpg)'
- en: 'Figure 3.3: A very simple add-on as listed in Blender'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3：Blender 中列出的一个非常简单的附加组件
- en: The `warning` entry from our dictionary is displayed with a triangle icon. That
    line is to warn the users of potentially unstable code.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们字典中的`warning`条目以三角形图标显示。这一行是为了警告用户可能不稳定的代码。
- en: Now that our add-on has served its purpose, it’s time to remove it.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了附加组件的功能，是时候移除它了。
- en: Uninstall
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载
- en: 'Clicking the big **Remove** button in the add-on preferences will display a
    confirmation dialog that asks whether it is fine to delete the add-on. This operation
    cannot be undone, but in this case, it is fine to go along and remove **The**
    **Simplest Add-on**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在附加组件首选项中点击大的**移除**按钮将显示一个确认对话框，询问是否可以删除附加组件。这个操作不能撤销，但在这个情况下，继续移除**最简单的附加组件**是可以的：
- en: '![Figure 3.4: Add-on removal in Blender](img/Figure_3.4_B18375.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4：Blender 中附加组件的移除](img/Figure_3.4_B18375.jpg)'
- en: 'Figure 3.4: Add-on removal in Blender'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4：Blender 中附加组件的移除
- en: The path displayed in the **Remove** dialog informs that the add-on was installed
    inside Blender user preferences. That’s not always the case, as we will see how
    to point the scripts path to our working directory in the next paragraph.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**移除**对话框中显示的路径表明附加组件被安装在了 Blender 用户首选项中。这并不总是情况，正如我们将在下一段中看到如何将脚本路径指向我们的工作目录。'
- en: The scripts path
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 脚本路径
- en: Reinstalling an add-on at every change during development would end up being
    impractical. Programmers usually set up a **system path** for Python scripts and
    work on their add-ons from there.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中每次更改时重新安装附加组件将变得不切实际。程序员通常会为 Python 脚本设置一个**系统路径**并在那里工作附加组件。
- en: System paths can be found in **Blender Preferences**, by choosing the **File
    Paths** tab in the left column.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 系统路径可以在**Blender 首选项**中找到，通过在左侧列中选择**文件路径**选项卡。
- en: '![Figure 3.5: The File Paths preferences window](img/Figure_3.5_B18375.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5：文件路径首选项窗口](img/Figure_3.5_B18375.jpg)'
- en: 'Figure 3.5: The File Paths preferences window'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5：文件路径首选项窗口
- en: We can set this path to the directory that we will use for scripting, such as
    the `PythonScriptingBlender/ch3` folder that hosts the code of this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个路径设置为我们将用于脚本处理的目录，例如托管本章代码的`PythonScriptingBlender/ch3`文件夹。
- en: The addons folder
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加组件文件夹
- en: 'Now that blender will look in our scripting folder, we can create a directory
    for our add-ons. We can do that from VS Code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在Blender将查看我们的脚本文件夹，我们可以为我们的附加组件创建一个目录。我们可以从 VS Code 中这样做：
- en: Select `PythonScriptingBlender/ch3` in VS Code.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中选择`PythonScriptingBlender/ch3`。
- en: Create a new folder by clicking the **New** **Folder** icon.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建** **文件夹**图标创建一个新的文件夹。
- en: Name the new folder `addons`.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件夹命名为`addons`。
- en: It is important that `addons` is the exact name of this folder; otherwise, Blender
    will not look for extensions. We need to restart Blender for the **File Paths**
    settings to take effect, but once we do, Blender will be able to load the add-ons
    on which we are working, with no installation needed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是`addons`是这个文件夹的确切名称；否则，Blender将不会寻找扩展。我们需要重新启动Blender以使**文件路径**设置生效，但一旦我们这样做，Blender将能够加载我们正在工作的插件，无需安装。
- en: Now, we can work on a new add-on that adds functionality to Blender. In the
    next section, we will write an add-on that groups the objects of a scene into
    collections.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始工作于一个新的插件，该插件为Blender添加功能。在下一节中，我们将编写一个插件，将场景中的对象分组到集合中。
- en: Creating our first add-on – object collector
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的第一个插件 – 对象收集器
- en: We are going to write an add-on that groups the objects of a scene in collections
    that reflect their type – one collection for all the meshes, one for all the lights,
    one for the curves, and so on.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个插件，将场景中的对象分组到反映它们类型的集合中 – 一个集合用于所有网格，一个用于所有灯光，一个用于曲线，等等。
- en: 'Since we have set up `PythonScriptingBlender/ch3` as the directory for our
    add-ons, we will proceed in VS Code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将`PythonScriptingBlender/ch3`设置为我们的插件目录，我们将在VS Code中继续操作：
- en: Select `PythonScriptingBlender/ch3/addons` in VS Code.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中选择`PythonScriptingBlender/ch3/addons`。
- en: Create a new file by clicking the **New** **File** icon.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**新建****文件**图标创建一个新文件。
- en: Name the new file `object_collector.py`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`object_collector.py`。
- en: Open the file via a double click.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过双击打开文件。
- en: This Python script’s name starts with `object`, since it affects object data.
    It is a *soft convention*, as this filename scheme is suggested but not enforced.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个Python脚本的名称以`object`开头，因为它影响对象数据。这是一个*软约定*，因为这个文件名方案是建议的，但不是强制的。
- en: 'At this stage, the add-on is very similar to the previous one – we haven’t
    added any code yet. Note how, besides the obvious difference in names and descriptions,
    we haven’t put a `warning` entry – we intend to make a non-experimental add-on:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，插件与之前的非常相似 – 我们还没有添加任何代码。注意，除了明显的名称和描述差异之外，我们还没有添加`warning`条目 – 我们打算制作一个非实验性插件：
- en: object_collector.py
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: object_collector.py
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Remove carefully!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 请小心删除！
- en: It is better to not remove add-ons loaded from the script path using the **Remove**
    button – we risk erasing our working (and perhaps only) copy!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最好不要使用**删除**按钮删除从脚本路径加载的插件 – 我们可能会删除我们的工作（可能也是唯一的）副本！
- en: Blender will show up this add-on in the preferences panel. In order to add functionalities,
    our add-on must contain an **operator**. Operators are the entities that carry
    on the execution of code; we will now learn how to write them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Blender将在首选项面板中显示此插件。为了添加功能，我们的插件必须包含一个**操作符**。操作符是执行代码的实体；我们现在将学习如何编写它们。
- en: Operators
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作符
- en: The `Operator` class allows calling functions from the graphic interface. They
    are, essentially, commands that can be run in Blender.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operator`类允许从图形界面调用函数。它们本质上是可以运行在Blender中的命令。'
- en: Therefore, we subclass the `bpy.types.Operator` class to make our code available
    to users.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过子类化`bpy.types.Operator`类来使我们的代码对用户可用。
- en: Operator requirements
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 操作符要求
- en: 'A class deriving `bpy.types.Operators` must implement these members:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 从`bpy.types.Operators`派生的类必须实现这些成员：
- en: A static string named `bl_idname` that contains a unique name by which the operator
    goes internally
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`bl_idname`的静态字符串，其中包含操作符在内部使用的唯一名称。
- en: A static string named `bl_label` that contains the displayed name of the operator
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`bl_label`的静态字符串，其中包含操作符的显示名称。
- en: A `poll()` class method that verifies that the conditions for executing the
    operator are met and return either `True` or `False`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`poll()`类方法，用于验证执行操作的条件是否满足，并返回`True`或`False`
- en: An `execute()` method that runs when the operator is executed, returning a set
    of possible running states
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`execute()`方法，当操作符执行时运行，返回一组可能的运行状态。
- en: Optionally, a docstring that Blender will display as additional information
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的，一个docstring，Blender将显示为附加信息。
- en: We are going to fill in this information so that our add-on will contain an
    operator that can be executed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将填写这些信息，以便我们的插件包含一个可以执行的操作符。
- en: Writing a basic operator
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写基本操作符
- en: 'Let’s start to create our operator class. Following the Blender guidelines,
    the name starts with `OBJECT_OT`. Soon after the (optional) docstring comes `bl_idname`
    and `bl_label`, the two attributes that Blender uses respectively as an identifier
    and description of the operator:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始创建我们的操作符类。遵循Blender指南，名称以`OBJECT_OT`开头。在可选的docstring之后，是`bl_idname`和`bl_label`，这两个属性分别是Blender用作操作符标识符和描述的属性：
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `poll()` and `execute()` methods, at this stage, neither allow nor perform
    any action. We are going to implement them in the following pages, using what
    we have learned in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033), when dealing
    with Blender data.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，`poll()`和`execute()`方法既不允许也不执行任何操作。我们将在接下来的几页中实现它们，使用我们在[*第二章*](B18375_02.xhtml#_idTextAnchor033)中学习的内容，当处理Blender数据时。
- en: Implementing the poll() method
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现poll()方法
- en: '`poll()` verifies that the conditions for running the operator are met. That
    restricts the possibility of error and makes the intended use of the operator
    more evident. This method is marked with a `@classmethod` decorator that allows
    us to validate the conditions before the operator is run.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`poll()`验证运行操作符的条件是否满足。这限制了错误的可能性，并使操作符的预期用途更加明显。此方法使用`@classmethod`装饰器标记，允许我们在操作符运行之前验证条件。'
- en: 'Since our operator collects objects in the scene, we should not be able to
    use it if the scene is empty:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的操作符收集场景中的对象，如果场景为空，我们不应能够使用它：
- en: '[PRE5]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Implementing the execute() method
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现execute()方法
- en: After an operator is invoked, Blender runs its `execute()` method. This `execute()`
    function contains our operations. Breaking them down into single steps will help
    to code them in Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作符被调用后，Blender运行其`execute()`方法。这个`execute()`函数包含我们的操作。将它们分解成单个步骤将有助于用Python编写代码。
- en: Planning our execution
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 规划我们的执行过程
- en: We must know what to expect when we execute our operator. For instance, running
    it on the default scene, we would end up with three new collections – **Mesh**
    for the **Cube** object, **Camera** for the **Camera** object, and **Light** for
    the **Light** object.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须知道执行我们的操作符时预期会发生什么。例如，在默认场景上运行它，我们最终会得到三个新的集合——**网格**用于**立方体**对象，**相机**用于**相机**对象，**灯光**用于**灯光**对象。
- en: '![Figure 3.6: The expected result after running Collector](img/Figure_3.6_B18375.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图3.6：运行收集器后的预期结果](img/Figure_3.6_B18375.jpg)'
- en: 'Figure 3.6: The expected result after running Collector'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6：运行收集器后的预期结果
- en: There is more than one way to reach this result, but to accomplish it by hand,
    we will need to create the **Mesh**, **Light**, and **Camera** collections and
    bring each object under each one of them.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 达到这个结果的方式不止一种，但要通过手工完成，我们需要创建**网格**、**灯光**和**相机**集合，并将每个对象置于每个集合之下。
- en: Now, we will translate these actions into Python.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将这些操作转换为Python代码。
- en: Writing the execution code
  id: totrans-112
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 编写执行代码
- en: 'We have seen in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033) how new collections
    can be created and linked to `scene.collection.children`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第二章*](B18375_02.xhtml#_idTextAnchor033)中看到了如何创建新的集合并将其链接到`scene.collection.children`：
- en: '[PRE6]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we can process the objects using a `for` loop:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用`for`循环来处理对象：
- en: '[PRE7]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we always return an operation state when we exit the function:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们退出函数时，我们总是返回一个操作状态：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This operator is still in progress and needs refining, but we can already use
    it. To do that, we must inform Blender of its existence using the `register_class()`
    function from `bpy.utils`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此操作符仍在开发中，需要进一步完善，但我们已经可以使用它。为此，我们必须使用`bpy.utils.register_class()`函数通知Blender其存在。
- en: Loading operators in our add-on
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的插件中加载操作符
- en: 'Our add-on adds an operator to Blender when enabled and removes it when it
    is disabled. This is done via the `bpy.utils.register_class()` and `bpy.utils.unregister_class()`
    functions that we call, respectively, inside the add-on’s `register()` and `unregister()`
    functions:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用时，我们的插件向Blender添加一个操作符，并在禁用时将其移除。这是通过调用插件中的`register()`和`unregister()`函数内的`bpy.utils.register_class()`和`bpy.utils.unregister_class()`函数来完成的：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Enabling the **Collector** add-on will add **Create Type Collections** to Blender
    and allow you to call it from the user interface.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 启用**收集器**插件将**创建类型集合**添加到Blender中，并允许您从用户界面调用它。
- en: Running our add-on
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行我们的插件
- en: Even if we have yet to add any graphic element, our add-on is ready for its
    first launch. We can use two tricks in order to run add-ons that are not yet listed,
    which is quite common in development.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我们还没有添加任何图形元素，我们的附加组件也准备好首次启动。我们可以使用两个技巧来运行尚未列出的附加组件，这在开发中相当常见。
- en: Refreshing the add-on list
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刷新附加组件列表
- en: Since we have added a new script folder and just changed its content, we need
    to either restart Blender or refresh the add-on information. To do that, we can
    click the **Refresh** button at the top right in the **Add-ons** preferences window.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已添加一个新的脚本文件夹并刚刚更改了其内容，我们需要重新启动 Blender 或刷新附加组件信息。为此，我们可以在 **附加组件** 预设窗口的右上角点击
    **刷新** 按钮。
- en: '![Figure 3.7: The Collector add-on, loaded from the project folder](img/Figure_3.7_B18375.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7：从项目文件夹加载的 Collector 附加组件](img/Figure_3.7_B18375.jpg)'
- en: 'Figure 3.7: The Collector add-on, loaded from the project folder'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7：从项目文件夹加载的 Collector 附加组件
- en: If we start typing the name of our add-on in the filter bar, the entries in
    the list will narrow down until **Collector** becomes easy to find and enable.
    Now, it’s time to execute our operator via the **Blender** **Source Bar**.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在过滤器栏中开始输入我们附加组件的名称，列表中的条目将缩小，直到 **收集器** 变得容易找到并启用。现在，是时候通过 **Blender**
    **源栏** 执行我们的操作符了。
- en: Running from the Search Toolbar
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从搜索工具栏运行
- en: Operators that are not part of any graphic element are for internal usage –
    that is, callable by other operators but not by the user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于任何图形元素的操作符是用于内部使用的 – 也就是说，可以被其他操作符调用，但不能被用户调用。
- en: 'To make every operator searchable, make sure that **Developers Extra** is enabled
    in the **Preferences** | **Interface** tab, as we did in [*Chapter 2*](B18375_02.xhtml#_idTextAnchor033).
    If this option is active, here is how we can call our operator:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要使每个操作符可搜索，请确保在 **首选项** | **界面** 选项卡中启用了 **开发者额外**，就像我们在[第 2 章](B18375_02.xhtml#_idTextAnchor033)中做的那样。如果此选项处于活动状态，以下是我们可以调用我们的操作符的方法：
- en: Press the *F3* button.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F3* 按钮。
- en: Start typing `create type`, and the operator will show up in the search box.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始键入 `create type`，操作符将在搜索框中显示。
- en: '![Figure 3.8: The Create Type Collections operator, showing up in the search
    bar](img/Figure_3.8_B18375.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8：创建类型集合操作符，显示在搜索栏中](img/Figure_3.8_B18375.jpg)'
- en: 'Figure 3.8: The Create Type Collections operator, showing up in the search
    bar'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8：创建类型集合操作符，显示在搜索栏中
- en: Click on the operator to execute it.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击操作符以执行它。
- en: We can see in the outliner that our operator succeeded.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在大纲视图中看到我们的操作符已成功执行。
- en: '![](img/Figure_3.9_B18375.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_3.9_B18375.jpg)'
- en: 'figure 3.9: Each object is grouped under its type collection'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9：每个对象都按其类型集合分组
- en: Our add-on is at an early stage; it has a few bugs and limitations that we are
    going to fix. For instance, the **Mesh**, **Light**, and **Camera** collections
    are created without checking whether they already exist, which will create duplicates.
    Also, we are only handling these three categories, skipping **Curves**, **Armatures**,
    and all the other object types entirely.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的附加组件处于早期阶段；它有一些错误和限制，我们将修复。例如，**网格**、**灯光**和**相机**集合在没有检查它们是否已经存在的情况下创建，这将创建重复项。此外，我们只处理这三个类别，完全跳过了**曲线**、**骨架**和所有其他对象类型。
- en: Nevertheless, if we are using version control for our folder, as seen in [*Chapter
    1*](B18375_01.xhtml#_idTextAnchor014), we can commit our new files. We are going
    to improve our add-on in the next section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，如果我们为我们文件夹使用版本控制，如[第 1 章](B18375_01.xhtml#_idTextAnchor014)中所示，我们可以提交我们的新文件。我们将在下一节中改进我们的附加组件。
- en: Improving our code
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化我们的代码
- en: Fixing bugs or starting with a row prototype that will be completed at a later
    stage is common practice in development. In this section, we will complete our
    add-on to its finished form, reload it in Blender, and deal with the versioning
    of the scripts path.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发中，修复错误或从稍后阶段完成的行原型开始是常见做法。在本节中，我们将完成我们的附加组件，并在 Blender 中重新加载它，并处理脚本路径的版本控制。
- en: Saving our edits automatically
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动保存我们的编辑
- en: 'The **Auto Save** option will make VS Code save every file change to disk automatically.
    To activate this option, follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动保存** 选项将使 VS Code 自动将每个文件更改保存到磁盘。要激活此选项，请按照以下步骤操作：'
- en: Open the **File** menu in the **Visual Studio Code** menu bar.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Visual Studio Code** 菜单栏中打开 **文件** 菜单。
- en: Click on **Auto Save** to enable this entry.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **自动保存** 以启用此条目。
- en: There are developers that prefer to save manually to have more control of their
    files. Which solution is better depends on personal tastes and workflows. Generally,
    if version control is used, the advantage of **Auto Save** outweighs the danger
    of unwanted changes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有些开发者更喜欢手动保存以更好地控制他们的文件。哪种解决方案更好取决于个人品味和工作流程。一般来说，如果使用版本控制，**自动保存**的优势超过了不希望更改的危险。
- en: In some cases, we want to turn off version control on specific files. For instance,
    there are files that Python generates when it executes code; we have no interest
    in tracking them. In the following paragraph, we are going to see how to ignore
    specific files.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，我们希望关闭特定文件的版本控制。例如，有些文件是Python在执行代码时生成的；我们对此没有兴趣跟踪。在接下来的段落中，我们将看到如何忽略特定文件。
- en: Ignoring bytecode files (.pyc)
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 忽略字节码文件（.pyc）
- en: If we execute code from our development folder, the `.pyc` file, along with
    our `.``py` files.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们从开发文件夹中执行代码，`.pyc`文件，以及我们的`.py`文件。
- en: '![Figure 3.10: A temporary .pyc file can be seen alongside our scripts](img/Figure_3.10_B18375.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图3.10：可以看到一个临时的.pyc文件与我们的脚本并列](img/Figure_3.10_B18375.jpg)'
- en: 'Figure 3.10: A temporary .pyc file can be seen alongside our scripts'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10：可以看到一个临时的.pyc文件与我们的脚本并列
- en: When a `.py` file is executed, Python translates it to an internal format and
    saves it as `.pyc`. We don’t need to concern ourselves with `.pyc` files, and
    usually, we don’t need to keep track of them.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个`.py`文件被执行时，Python将其转换为内部格式并保存为`.pyc`。我们不需要关心`.pyc`文件，通常我们也不需要跟踪它们。
- en: Creating a .gitignore file
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建.gitignore文件
- en: 'A text file named `.gitignore`, containing the names of files and directories
    that we don’t want to track, will have an immediate effect when placed in a version
    control-managed folder. We can create it manually or follow these steps inside
    VS Code:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`.gitignore`的文本文件，包含我们不希望跟踪的文件和目录的名称，当放置在版本控制管理的文件夹中时将立即生效。我们可以手动创建它，或者遵循以下步骤在VS
    Code中操作：
- en: In the `.pyc` file listed under **Changes**.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**更改**下列出的`.pyc`文件中。
- en: From the context menu, select **Add** **to .gitignore**.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从上下文菜单中选择**添加到 .gitignore**。
- en: '![Figure 3.11: Adding to the git ignore list in VS Code](img/Figure_3.11_B18375.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图3.11：在VS Code中添加到git忽略列表](img/Figure_3.11_B18375.jpg)'
- en: 'Figure 3.11: Adding to the git ignore list in VS Code'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.11：在VS Code中添加到git忽略列表
- en: Once the`.gitignore` file is created, the `.pyc` file stops showing up in the
    changes.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦`.gitignore`文件创建，`.pyc`文件就不再显示在更改中。
- en: 'If we open the `.gitignore` file, we will see that it contains the full path
    of the `.``pyc` file:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们打开`.gitignore`文件，我们会看到它包含了`.pyc`文件的完整路径：
- en: '[PRE10]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We don’t need to ignore that specific file; we can blacklist all the directories
    called `__pycache__`. To do that, we take the following code:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要忽略那个特定的文件；我们可以将所有名为`__pycache__`的目录列入黑名单。为此，我们采取以下代码：
- en: '[PRE11]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'And change it to this, then save:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其更改为以下内容，然后保存：
- en: '[PRE12]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Source control applies to the `.gitignore` file itself; we have to stage and
    commit this file, along with the other changes made in this chapter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 版本控制适用于`.gitignore`文件本身；我们必须将此文件与其他章节中做出的更改一起暂存和提交。
- en: '![Figure 3.12: Staging the current changes for this chapter](img/Figure_3.12_B18375.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图3.12：暂存本章当前更改](img/Figure_3.12_B18375.jpg)'
- en: 'Figure 3.12: Staging the current changes for this chapter'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.12：暂存本章当前更改
- en: Once we have committed our changes, we can go back to working on our script,
    fixing its flows, and expanding its capabilities. We will see how simplifying
    the logic of a script improves readability, behavior, and functionality at the
    same time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提交了我们的更改，我们就可以回到我们的脚本工作，修复其流程，并扩展其功能。我们将看到简化脚本逻辑如何同时提高可读性、行为和功能。
- en: Fixing the operator logic
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修复操作符逻辑
- en: The most evident flow in our operator is that it tries to recreate existing
    collections. Running it twice in a row creates the **Mesh.001** and **Light.001**
    collections, and so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们操作符中最明显的流程是它试图重新创建现有的集合。连续运行两次会创建**Mesh.001**和**Light.001**集合，等等。
- en: '![Figure 3.13: Unwanted collections are created](img/Figure_3.13_B18375.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图3.13：创建了不想要的集合](img/Figure_3.13_B18375.jpg)'
- en: 'Figure 3.13: Unwanted collections are created'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13：创建了不想要的集合
- en: Avoiding duplicate collections
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免重复集合
- en: 'We should create the mesh collection only if it doesn’t exist already. Note
    the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该只在它不存在的情况下创建网格集合。注意以下内容：
- en: '[PRE13]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Instead of that, we should create a new one, only if looking it up causes a
    `KeyError` error:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是那样，我们应该创建一个新的，只有当查找它时才会引发`KeyError`错误：
- en: '[PRE14]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To be more generic, we can write a function that takes the collection name as
    an argument.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更通用，我们可以编写一个函数，该函数接受集合名称作为参数。
- en: 'The function presented in the following code block starts with a very descriptive
    docstring that can help to give a better idea of what a function should do and
    how to implement it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块中展示的函数以一个非常描述性的文档字符串开头，这有助于更好地了解函数应该做什么以及如何实现它：
- en: '[PRE15]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Querying object types
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询对象类型
- en: 'We could create unique collections using the preceding function – for instance,
    `get_collection("Mesh")` – but we don’t need to mention the object type explicitly;
    the `Object.type` parameter returns the type as a string:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面的函数创建唯一的集合 - 例如，`get_collection("Mesh")` - 但我们不需要明确提及对象类型；`Object.type`
    参数以字符串形式返回类型：
- en: '[PRE16]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Strings can also be formatted nicely via their `.``title()` method:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串也可以通过它们的 `.title()` 方法进行格式化：
- en: '[PRE17]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here is our operator execution block after the rewrite:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重写后的操作符执行块：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This version is more elegant and supports objects of any type. There is still
    a bug that we will fix shortly. Before we come to that, we need to reload the
    script to use this new version.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本更优雅，支持任何类型的对象。尽管如此，我们仍将很快修复一个错误。在我们到达那里之前，我们需要重新加载脚本以使用这个新版本。
- en: Reloading scripts
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新加载脚本
- en: 'Blender and Python store used scripts in memory; therefore, changes made to
    the code will not have an immediate effect. There is a Blender command that reloads
    the scripts, which we can look up in the search bar:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: Blender 和 Python 将使用的脚本存储在内存中；因此，对代码所做的更改不会立即生效。有一个 Blender 命令可以重新加载脚本，我们可以在搜索栏中查找：
- en: Press the *F3* key to go to the search bar.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下 *F3* 键进入搜索栏。
- en: Start typing `reload scr` in the search field.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索字段中开始键入 `reload scr`。
- en: Click the operator, **script.reload ·** **Reload Scripts**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击操作符，**script.reload ·** **重新加载脚本**。
- en: '![Figure 3.14: Invoking the Reload Scripts operator](img/Figure_3.14_B18375.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图3.14：调用重新加载脚本操作符](img/Figure_3.14_B18375.jpg)'
- en: 'Figure 3.14: Invoking the Reload Scripts operator'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.14：调用重新加载脚本操作符
- en: This command reloads all the scripts and spares us from having to restart Blender
    every time. Our add-ons now use the latest `.py` files on disk, and we can verify
    that our collections are created only once.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令重新加载所有脚本，并使我们免于每次都需要重新启动 Blender。我们的插件现在使用磁盘上的最新 `.py` 文件，并且我们可以验证我们的集合只创建一次。
- en: Avoiding re-assignment errors
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免重新赋值错误
- en: 'While executing `RuntimeError` error. We’ll see this error pop up if we run
    our operator a second time:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行 `RuntimeError` 错误时。如果我们第二次运行我们的操作符，我们会看到这个错误出现：
- en: '[PRE19]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to enclose object linking in a `try`/`catch` statement to avoid that:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将对象链接放在 `try`/`catch` 语句中，以避免以下情况：
- en: '[PRE20]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This should be replaced with the following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该替换为以下内容：
- en: '[PRE21]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This way, no action is taken for objects that were already collected and the
    operator moves on to the rest of the scene.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对于已经收集的对象不会采取任何操作，操作符将继续处理场景中的其余部分。
- en: Don’t try too hard!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不要太过努力！
- en: We should always make sure that the actions contained inside a `try` block are
    minimal – these statements should not be used lightly. There is no obvious rule,
    but if we are trying more than two lines in a block, we should probably rethink
    our code so that it is less error-prone.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终确保 `try` 块内的操作尽可能少 - 这些语句不应轻易使用。没有明显的规则，但如果我们在一个块中尝试超过两行，我们可能需要重新思考我们的代码，使其更不容易出错。
- en: Our final operator
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们最终的操作符
- en: We can add more objects to the scene by invoking the **Add** menu from the viewport
    or using the *Shift* + *A* shortcut. We can add objects of different types, such
    as **Text**, **Speaker**, **Empty** | **Plain Axes**, and even a few new meshes
    such as **Cylinder** and **Sphere**, and run **Create Type Collections** again.
    We can see that each object is assigned to a collection named after its type.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过从视图中调用 **添加** 菜单或使用 *Shift* + *A* 快捷键来向场景添加更多对象。我们可以添加不同类型的对象，例如 **文本**、**说话者**、**空**
    | **平面坐标轴**，甚至一些新的网格，如 **圆柱体** 和 **球体**，然后再次运行 **创建类型集合**。我们可以看到每个对象都被分配给了以其类型命名的集合。
- en: '![Figure 3.15: Every object type gets its own collection](img/Figure_3.15_B18375.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15：每个对象类型都有自己的集合](img/Figure_3.15_B18375.jpg)'
- en: 'Figure 3.15: Every object type gets its own collection'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15：每个对象类型都有自己的集合
- en: The nice thing is we didn’t have to account manually for all the object types
    – once a procedural workflow is in place, it will work with objects of all types,
    even those that will be added in future releases of Blender.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于我们不必手动为所有对象类型进行计数——一旦程序化工作流程就位，它将适用于所有类型的对象，甚至包括Blender未来版本中添加的对象。
- en: Our operator is complete; what is missing is an easy way to invoke it. We will
    finish the chapter by learning how to display an operator inside a menu of the
    interface.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的操作符已经完整；缺少的是一种调用它的简单方法。我们将通过学习如何在界面菜单中显示操作符来结束本章。
- en: Extending menus
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展菜单
- en: Menus present many advantages – they are everywhere in the application, they
    cover a specific aspect of the 3D workflow, and new items can be added easily.
    We are going to handle the addition and removal of new menu entries in our add-on
    – our operator will be displayed only when our add-on is enabled.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单具有许多优点——它们在应用程序中无处不在，它们涵盖了3D工作流程的特定方面，并且可以轻松添加新项目。我们将在我们的附加组件中处理新菜单项的添加和删除——我们的操作符只有在我们的附加组件启用时才会显示。
- en: Draw functions
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绘制函数
- en: 'Blender menus accept new items in the form of functions. These functions describe
    how a menu should draw a new entry; they must accept the `self` and `context`
    arguments passed by their menu and have the following form:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Blender菜单以函数的形式接受新项目。这些函数描述了菜单应该如何绘制新条目；它们必须接受由菜单传递的`self`和`context`参数，并具有以下形式：
- en: '[PRE22]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We will gain a better grasp of UI elements in [*Chapter 5*](B18375_05.xhtml#_idTextAnchor100).
    For now, we will only add our operator to a menu row. This is how our function
    will look:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第5章*](B18375_05.xhtml#_idTextAnchor100)中更好地掌握UI元素。现在，我们只会将我们的操作符添加到菜单行。我们的函数将如下所示：
- en: '[PRE23]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can now append this function to a Blender menu and let it display our operator.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将这个函数添加到Blender菜单中，并让它显示我们的操作符。
- en: Adding menu entries
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加菜单项
- en: 'Blender menus are stored in the `bpy.types` namespace. By convention, the name
    of a menu type follows the following scheme:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Blender菜单存储在`bpy.types`命名空间中。按照惯例，菜单类型的名称遵循以下方案：
- en: '[PRE24]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For instance, menus in the 3D view start with `bpy.types.VIEW3D_MT_`. Typing
    that in the Python console and pressing *Tab* will show the menus available in
    the viewport as a suggestion:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，3D视图中的菜单以`bpy.types.VIEW3D_MT_`开头。在Python控制台中输入并按*Tab*键将显示视口中可用的菜单作为建议：
- en: '[PRE25]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Since `bpy.types.VIEW3D_MT_object` menus:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`bpy.types.VIEW3D_MT_object`菜单：
- en: '[PRE26]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `bpy.types.VIEW3D_MT_object` is the `VIEW3D_MT_pose_context_menu`. We use
    this one in our example, but we could very well use any other menu.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`bpy.types.VIEW3D_MT_object`是`VIEW3D_MT_pose_context_menu`。我们在我们的示例中使用这个，但我们可以非常容易地使用任何其他菜单。'
- en: 'The `append()` and `remove()` methods add and remove a draw function from a
    menu. That can be done in the `register()`/`unregister()` functions of our add-on,
    so it becomes the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '`append()`和`remove()`方法将绘制函数添加到或从菜单中删除。这可以在我们的附加组件的`register()`/`unregister()`函数中完成，因此它变成了以下形式：'
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Reloading the scripts, and invoking the right-click menu while in **Object Mode**
    displays our option at the bottom. Now that there is a way to invoke our operator
    in the UI, we can consider our add-on complete and commit our changes.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 重新加载脚本，并在**对象模式**下右键单击菜单显示我们的选项在底部。现在，我们有了一种在UI中调用我们的操作符的方法，我们可以认为我们的附加组件已经完成，并提交我们的更改。
- en: '![Figure 3.16: Our operator added to the context menu](img/Figure_3.16_B18375.jpg)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16：添加到上下文菜单中的我们的操作符](img/Figure_3.16_B18375.jpg)'
- en: 'Figure 3.16: Our operator added to the context menu'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16：添加到上下文菜单中的我们的操作符
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have coded a complete add-on that expands Blender functionalities
    and integrates seamlessly into an application. We have also learned how to work
    on our code while it is being used and improve our tools through consecutive steps
    of refinement.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们编写了一个完整的附加组件，它扩展了Blender的功能，并无缝集成到应用程序中。我们还学习了如何在代码被使用的同时对其进行工作，并通过连续的细化步骤改进我们的工具。
- en: In [*Chapter 4*](B18375_04.xhtml#_idTextAnchor075)*,* we will learn how to affect
    the position and rotation of Blender objects via Python, and we will add interactive
    properties to our operator.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第4章*](B18375_04.xhtml#_idTextAnchor075)*中，我们将学习如何通过Python影响Blender对象的定位和旋转，并将交互式属性添加到我们的操作符中。
- en: Questions
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a Python script and a Blender add-on?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Python脚本和Blender附加组件之间的区别是什么？
- en: Which advantages does an add-on provide over sparse code?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用附加组件相比稀疏代码有哪些优势？
- en: What do operators do?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作符有什么作用？
- en: How do we define the conditions under which an operator can be executed?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何定义操作符可以执行的条件？
- en: Can we work on an add-on while it is being used? How do we update it?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否在插件被使用时进行修改？我们如何更新它？
- en: How do we ignore bytecode (`.pyc`) files in Git version control?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Git 版本控制中忽略字节码（`.pyc`）文件？
- en: How do we avoid creating duplicates?
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何避免创建重复项？
