- en: 'Chapter 5. When Doctest isn''t Enough: Unittest to the Rescue'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。当Doctest不够用时：unittest来拯救
- en: '*As the tests get more detailed (or complex), or they require more setup code
    to prepare the way for them, doctest begins to get a little bit annoying. The
    very simplicity that makes it the best way to write testable specifications and
    other simple tests starts to interfere with writing tests for complicated things.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*随着测试变得更加详细（或复杂），或者它们需要更多的设置代码来为它们做准备时，doctest开始变得有点烦人。正是这种简单性使其成为编写可测试规范和其他简单测试的最佳方式，但它开始干扰编写复杂事物的测试。*'
- en: 'In this chapter we shall:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Learn how to write and execute tests in the unittest framework
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何在unittest框架中编写和执行测试
- en: Learn how to express familiar testing concepts using unittest
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用unittest表达熟悉的测试概念
- en: Discuss the specific features that make unittest suitable for more complicated
    testing scenarios
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论使unittest适合更复杂测试场景的具体特性
- en: Learn about of couple of Mocker's features that integrate well with unittest
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解几个与unittest很好地集成的Mocker特性
- en: So let's get on with it!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们就开始吧！
- en: Basic unittest
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本unittest
- en: Before we start talking about new concepts and features, let's take a look at
    how to use unittest to express the ideas that we've already learned about. That
    way, we'll have something solid to ground our new understanding into.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论新的概念和特性之前，让我们看看如何使用unittest来表达我们已经学过的想法。这样，我们就能有一个坚实的基础来巩固我们的新理解。
- en: Time for action – testing PID with unittest
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用unittest测试PID
- en: We'll revisit the PID class (or at least the tests for the PID class) from Chapter
    3\. We'll rewrite the tests so that they operate within the unittest framework.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重新审视第三章中的PID类（或者至少是PID类的测试）。我们将重写测试，以便它们在unittest框架内运行。
- en: Before moving on, take a moment to refer back to the final version of the `pid.txt`
    file from Chapter 3\. We'll be implementing the same tests using the unittest
    framework.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，花点时间回顾一下第三章中`pid.txt`文件的最终版本。我们将使用unittest框架实现相同的测试。
- en: 'Create a new file called `test_pid.py` in the same directory as `pid.py`. Notice
    that this is a `.py` file: unittest tests are pure python source code, rather
    than being plain text with source code embedded in it. That means the tests will
    be less useful from a documentary point of view, but grants other benefits in
    exchange.'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与`pid.py`相同的目录下创建一个名为`test_pid.py`的新文件。请注意，这是一个`.py`文件：unittest测试是纯Python源代码，而不是包含源代码的纯文本。这意味着测试在文档方面可能不太有用，但会带来其他好处。
- en: 'Insert the following code into your newly-created `test_pid.py` (and please
    note that a few lines are long enough to get wrapped on the book''s page):'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码插入你新创建的`test_pid.py`文件中（请注意，有几行足够长，可能会在书的页面上换行）：
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the tests by typing:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入以下命令来运行测试：
- en: '[PRE1]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Time for action – testing PID with unittest](img/8846_05_01.jpg)'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 使用unittest测试PID](img/8846_05_01.jpg)'
- en: '*What just happened?*'
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Let's go through the code section and see what each part does. After that, we'll
    talk about what it all means when put together.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行查看代码部分，看看每个部分的作用。之后，我们将讨论将这些部分组合在一起时的意义。
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After a little bit of setup code, we have a test that the PID controller works
    correctly when not given a `when` parameter. Mocker is used to replace `time.time`
    with a mock that always returns a predictable value, and then we use several assertions
    to confirm that the attributes of the controller have been initialized to the
    expected values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在一点设置代码之后，我们有一个测试，当没有提供`when`参数时，PID控制器能正确工作。Mocker被用来替换`time.time`，使其总是返回一个可预测的值，然后我们使用几个断言来确认控制器的属性已被初始化为预期的值。
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This test confirms that the PID constructor works correctly when the `when`
    parameter is supplied. Unlike the previous test, there's no need to use Mocker,
    because the outcome of the test is not supposed to be dependant on anything except
    the parameter values—the current time is irrelevant.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试确认当提供`when`参数时，PID构造函数能正确工作。与之前的测试不同，不需要使用Mocker，因为测试的结果不应该依赖于任何东西，除了参数值——当前时间是不相关的。
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The tests in this class describe the intended behavior of the `calculate_response`
    method. This first test checks the behavior when the optional `when` parameter
    is not supplied, and mocks `time.time` to make that behavior predictable.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类中的测试描述了`calculate_response`方法预期的行为。这个第一个测试检查当可选的`when`参数未提供时的行为，并模拟`time.time`以使该行为可预测。
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this test, the `when` parameter is supplied, so there is no need to mock
    `time.time`. We just have to check that the result is what we expected.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，提供了`when`参数，因此不需要模拟`time.time`。我们只需检查结果是否符合预期。
- en: The actual tests that we performed are the same ones that were written in the
    doctest. So far, all that we see is a different way of expressing them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际执行的测试与doctest中编写的测试相同。到目前为止，我们看到的是表达它们的不同方式。
- en: The first thing to notice is that the test file is divided up into classes that
    inherit from `unittest.TestCase`, each of which contains one or more test methods.
    The name of each test method begins with the word *test*, which is how unittest
    recognizes that they are tests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，测试文件被划分为继承自`unittest.TestCase`的类，每个类包含一个或多个测试方法。每个测试方法的名称都以单词*test*开头，这是unittest识别它们为测试的方式。
- en: Each test method embodies a single test of a single unit. This gives us a convenient
    way to structure our tests, grouping together related tests into the same class,
    so that they're easier to find.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试方法体现了一个单一单元的单一测试。这为我们提供了一个方便的方式来组织测试，将相关的测试组合到同一个类中，以便更容易找到。
- en: Putting each test into its own method means that each test executes in an isolated
    namespace, which makes it somewhat easier to keep unittest-style tests from interfering
    with each other, relative to doctest-style tests. It also means that unittest
    knows how many unit tests are in your test file, instead of simply knowing how
    many expressions there are (you may have noticed that doctest counts each `>>>`
    line as a separate test). Finally, putting each test in its own method means that
    each test has a name, which can be a valuable feature.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 将每个测试放入自己的方法意味着每个测试都在一个独立的命名空间中执行，这使得相对于doctest风格的测试，unittest风格的测试之间相互干扰的可能性降低。这也意味着unittest知道你的测试文件中有多少个单元测试，而不是简单地知道有多少个表达式（你可能已经注意到doctest将每行`>>>`视为一个单独的测试）。最后，将每个测试放入自己的方法意味着每个测试都有一个名称，这可以是一个非常有价值的特性。
- en: Tests in unittest don't directly care about anything that isn't part of a call
    to one of the assert methods of `TestCase`. That means that when we're using Mocker,
    we don't have to be bothered about the mock objects that get returned from demonstration
    expressions, unless we want to use them. It also means that we need to remember
    to write an assert describing every aspect of the test that we want to have checked.
    We'll go over the various assertion methods of `TestCase` shortly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: unittest中的测试不直接关心`TestCase`的assert方法调用之外的任何内容。这意味着当我们使用Mocker时，除非我们想要使用它们，否则不需要担心从演示表达式返回的模拟对象。这也意味着我们需要记住为想要检查的测试的每个方面编写一个断言。我们将在稍后介绍`TestCase`的各种断言方法。
- en: Tests aren't of much use, if you can't execute them. For the moment, the way
    we'll be doing that is by calling `unittest.main` when our test file is executed
    as a program by the Python interpreter. That's about the simplest way to run unittest
    code, but it's cumbersome when you have lots of tests spread across lots of files.
    We'll be learning about tools to address that problem in the next chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不能执行测试，测试就没有多大用处。目前，我们将通过在Python解释器将我们的测试文件作为程序执行时调用`unittest.main`来实现这一点。这是运行unittest代码最简单的方法，但当你有很多分散在多个文件中的测试时，这会很麻烦。我们将在下一章学习关于解决这个问题的工具。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`if __name__ == ''__main__'':` might look strange to you, but its meaning is
    fairly straight forward. When Python loads any module, it stores that module''s
    name in a variable called `__name__` within the module (unless the module is the
    one passed to the interpreter on the command line). That module always gets the
    string `''__main__''` bound to its `__name__` variable. So, `if __name__ == ''__main__'':`
    means—if this module was executed directly from the command line.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`if __name__ == ''__main__'':`可能看起来有些奇怪，但它的意义相当直接。当Python加载任何模块时，它会将模块的名称存储在模块内的一个名为`__name__`的变量中（除非模块是传递给解释器的命令行上的模块）。该模块总是将字符串`''__main__''`绑定到其`__name__`变量。因此，`if
    __name__ == ''__main__'':`意味着——如果这个模块直接从命令行执行。'
- en: Assertions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言
- en: Assertions are the mechanism that we use to tell unittest what the important
    outcomes of the test are. By using appropriate assertions, we can tell unittest
    exactly what to expect from each test.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 断言是我们用来告诉unittest测试的重要结果的机制。通过使用适当的断言，我们可以告诉unittest每个测试期望得到什么。
- en: assertTrue
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertTrue
- en: When we call `self.assertTrue(expression)`, we're telling unittest that the
    expression must be true in order for the test to be a success.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `self.assertTrue(expression)` 时，我们正在告诉 unittest，表达式必须为真，测试才能成功。
- en: This is a very flexible assertion, since you can check for nearly anything by
    writing the appropriate boolean expression. It's also one of the last assertions
    you should consider using, because it doesn't tell unittest anything about the
    kind of comparison you're making, which means that unittest can't tell you as
    clearly what's gone wrong if the test fails.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常灵活的断言，因为你可以通过编写适当的布尔表达式来检查几乎所有东西。它也是你最后应该考虑使用的断言之一，因为它没有告诉 unittest 你正在进行的比较类型，这意味着如果测试失败，unittest
    不能清楚地告诉你出了什么问题。
- en: 'For an example of this, consider the following test code which contains two
    tests that are guaranteed to fail:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这个问题，考虑以下包含两个保证失败的测试的测试代码：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It might seem like the two tests are interchangeable, since both test the same
    thing. Certainly they'll both fail (or in the unlikely event that one equals two,
    they'll both pass), so why prefer one over the other?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来这两个测试是可以互换的，因为它们都测试相同的东西。当然，它们都会失败（或者在极不可能的情况下，一个等于两个，它们都会通过），那么为什么偏爱其中一个而不是另一个呢？
- en: 'Take a look at what happens when we run the tests (and also notice that the
    tests were not executed in the same order as they were written; tests are totally
    independent of each other, so that''s okay, right?):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 看看当我们运行测试时会发生什么（同时注意测试的执行顺序并不与它们编写的顺序相同；测试彼此完全独立，所以这是可以接受的，对吧？）：
- en: '![assertTrue](img/8846_05_02.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![assertTrue](img/8846_05_02.jpg)'
- en: 'Do you see the difference? The `assertTrue` test was able to correctly determine
    that the test should fail, but it didn''t know enough to report any useful information
    about why it failed. The `assertEqual` test, on the other hand, knew first of
    all that it was checking that two expressions were equal, and second it knew how
    to present the results, so that they would be most useful: by evaluating each
    of the expressions that it was comparing and placing a `!=` symbol between the
    results. It tells us both what expectation failed, and what the relevant expressions
    evaluate to.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到区别了吗？`assertTrue` 测试能够正确地确定测试应该失败，但它不知道足够的信息来报告任何关于失败原因的有用信息。另一方面，`assertEqual`
    测试首先知道它正在检查两个表达式是否相等，其次它知道如何呈现结果，以便它们最有用：通过评估它比较的每个表达式，并在结果之间放置一个 `!=` 符号。它告诉我们哪些期望失败了，以及相关的表达式评估结果是什么。
- en: assertFalse
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertFalse
- en: The `assertFalse` method will succeed when the `assertTrue` method would fail,
    and vice versa. It has the same limits in terms of producing useful output that
    `assertTrue` has, and the same flexibility in terms of being able to test nearly
    any condition.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `assertTrue` 方法失败时，`assertFalse` 方法将成功，反之亦然。它在产生有用输出方面的限制与 `assertTrue` 相同，并且在能够测试几乎所有条件方面的灵活性也相同。
- en: assertEqual
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertEqual
- en: As mentioned in the `assertTrue` discussion, the `assertEqual` assertion checks
    that its two parameters are in fact equal, and reports a failure if they are not,
    along with the actual values of the parameters.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在 `assertTrue` 讨论中提到的，`assertEqual` 断言检查其两个参数实际上是否相等，如果它们不相等，则报告失败，并附带参数的实际值。
- en: assertNotEqual
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertNotEqual
- en: The `assertNotEqual` assertion fails whenever the `assertEqual` assertion would
    have succeeded, and vice versa. When it reports a failure, its output indicates
    that the values of the two expressions are equal, and provides you with those
    values.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `assertEqual` 断言成功时，`assertNotEqual` 断言将失败，反之亦然。当它报告失败时，其输出表明两个表达式的值相等，并提供了这些值。
- en: assertAlmostEqual
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertAlmostEqual
- en: As we've seen before, comparing floating point numbers can be troublesome. In
    particular, checking that two floating point numbers are equal is problematic,
    because things that you might expect to be equal—things that, mathematically,
    are equal—may still end up differing down among the least significant bits. Floating
    point numbers only compare equal when every bit is the same.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，比较浮点数可能会有麻烦。特别是，检查两个浮点数是否相等是有问题的，因为那些你可能期望相等的东西——在数学上相等的东西——最终可能仍然在最低有效位上有所不同。只有当每个位都相同时，浮点数才相等。
- en: To address that problem, unittest provides `assertAlmostEqual`, which checks
    that two floating point values are almost the same; a small amount of difference
    between them is tolerated.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，unittest 提供了 `assertAlmostEqual`，它检查两个浮点值几乎相同；它们之间的一小部分差异是可以容忍的。
- en: 'Lets look at this problem in action. If you take the square root of 7, and
    then square it, the result should be `7`. Here''s a pair of tests that check that
    fact:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个问题在实际中的应用。如果你对 7 开平方，然后再平方，结果应该是 `7`。这里有一对测试来检查这个事实：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `test_assertEqual` method checks that ![assertAlmostEqual](img/8846_05_01a.jpg),
    which is true in reality. In the more specialized number system available to computers,
    though, taking the square root of 7 and then squaring it doesn't quite get us
    back to 7, so this test will fail. More on that in a moment.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`test_assertEqual` 方法检查 ![assertAlmostEqual](img/8846_05_01a.jpg)，这在现实中是正确的。然而，在计算机可用的更专业的数字系统中，对
    7 开平方后再平方并不完全回到 7，因此这个测试会失败。关于这一点，稍后会有更多说明。'
- en: Test `test_assertAlmostEqual` method checks that ![assertAlmostEqual](img/8846_05_01b.jpg),
    which even the computer will agree is true, so this test should pass.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 `test_assertAlmostEqual` 方法检查 ![assertAlmostEqual](img/8846_05_01b.jpg)，即使是计算机也会同意这是正确的，因此这个测试应该通过。
- en: 'Running those tests produces the following, although the specific number that
    you get back instead of `7` may vary depending on the details of the computer
    the tests are being run on:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些测试会产生以下结果，尽管你得到的数字可能因测试运行的计算机的具体细节而异：
- en: '![assertAlmostEqual](img/8846_05_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![assertAlmostEqual](img/8846_05_03.jpg)'
- en: Unfortunately, floating point numbers are not precise, because the majority
    of numbers on the real number line can not be represented with a finite, non-repeating
    sequence of digits, much less a mere 64 bits. Consequently, what you get back
    from evaluating the mathematical expression is not quite `7`. It's close enough
    for government work though—or practically any other sort of work as well—so we
    don't want our test to quibble over that tiny difference. Because of that, we
    should use `assertAlmostEqual` and `assertNotAlmostEqual` when we're comparing
    floating point numbers for equality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，浮点数并不精确，因为实数线上的大多数数字不能用有限的非重复数字序列来表示，更不用说只有 64 位了。因此，从评估数学表达式得到的并不完全是 `7`。虽然对于政府工作或几乎所有其他类型的工作来说已经足够接近，但我们不希望我们的测试对那个微小的差异斤斤计较。正因为如此，当我们比较浮点数是否相等时，我们应该使用
    `assertAlmostEqual` 和 `assertNotAlmostEqual`。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This problem doesn't generally carry over into other comparison operators. Checking
    that one floating point number is less than the other, for example, is very unlikely
    to produce the wrong result due to insignificant errors. It's only in cases of
    equality that this problem bites us.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题通常不会影响到其他比较运算符。例如，检查一个浮点数是否小于另一个浮点数，由于微小的误差，产生错误结果的可能性非常低。只有在相等的情况下，这个问题才会困扰我们。
- en: assertNotAlmostEqual
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertNotAlmostEqual
- en: The `assertNotAlmostEqual` assertion fails whenever the `assertAlmostEqual`
    assertion would have succeeded, and vice versa. When it reports a failure, its
    output indicates that the values of the two expressions are nearly equal, and
    provides you with those values.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertNotAlmostEqual` 断言在 `assertAlmostEqual` 断言成功时失败，反之亦然。当它报告失败时，其输出表明两个表达式的值几乎相等，并提供了这些值。'
- en: assertRaises
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: assertRaises
- en: As always, we need to make sure that our units correctly signal errors. Doing
    the right thing when they receive good inputs is only half the job; they need
    to do something reasonable when they receive bad inputs, as well.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 总是，我们需要确保我们的单元能够正确地报告错误。当它们接收到良好输入时做正确的事情只是工作的一半；它们还需要在接收到不良输入时做合理的事情。
- en: The `assertRaises` method checks that a callable (a callable is a function,
    a method, or a class. A callable can also be an object of any arbitrary type,
    so long as it has a `__call__` method) raises a specified exception, when passed
    a specified set of parameters.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`assertRaises` 方法检查一个可调用对象（可调用对象是一个函数、一个方法或一个类。可调用对象也可以是任何具有 `__call__` 方法的任意类型的对象）在传递指定的参数集时是否会引发指定的异常。'
- en: This assertion only works with callables, which means that you don't have a
    way of checking that other sorts of expressions raise an expected exception. If
    that doesn't fit the needs of your test, it's possible to construct your own test
    using the `fail` method, described below.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这个断言只适用于可调用对象，这意味着你没有方法来检查其他类型的表达式是否会引发预期的异常。如果这不符合你的测试需求，你可以使用下面描述的 `fail`
    方法来构建自己的测试。
- en: To use `assertRaises`, first pass it the expected exception, then pass the callable,
    and then the parameters that should be passed to the callable when it's invoked.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `assertRaises`，首先传递预期的异常，然后传递可调用对象，最后传递在调用可调用对象时应传递的参数。
- en: Here's an example test using `assertRaises`. This test ought to fail, because
    the callable won't raise the expected exception. `'8ca2'` is perfectly acceptable
    input to `int`, when you're also passing it `base = 16`. Notice that `assertRaises`
    will accept any number of positional or keyword arguments, and pass them on to
    the callable on invocation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`assertRaises`的示例测试。这个测试应该会失败，因为可调用函数不会抛出预期的异常。当你也传递`base = 16`时，`'8ca2'`是`int`的完全可接受的输入。注意，`assertRaises`将接受任意数量的位置参数或关键字参数，并在调用时将它们传递给可调用函数。
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When we run that test, it fails (as we knew it would) because `int` didn't raise
    the exception we told `assertRaises` to expect.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个测试时，它会失败（正如我们所预料的），因为`int`没有抛出我们告诉`assertRaises`期望的异常。
- en: '![assertRaises](img/8846_05_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![assertRaises](img/8846_05_04.jpg)'
- en: If an exception is raised, but it's not the one you told unittest to expect,
    unittest considers that an error. An error is different from a failure. A failure
    means that one of your tests has detected a problem in the unit it's testing.
    An error means that there's a problem with the test itself.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果抛出了一个异常，但不是你告诉unittest期望的异常，unittest会将其视为一个错误。错误与失败不同。失败意味着你的某个测试检测到了它所测试的单元中的问题。错误意味着测试本身存在问题。
- en: fail
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: fail
- en: When all else fails, you can fall back on `fail`. When the code in your test
    calls `fail`, the test fails.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有其他方法都失败时，你可以退回到`fail`。当你的测试代码调用`fail`时，测试就会失败。
- en: What good does that do? When none of the assert methods does what you need,
    you can instead write your checks in such a way that `fail` will be called if
    the test does not pass. This allows you to use the full expressiveness of Python
    to describe checks for your expectations.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么好处？当没有assert方法能满足你的需求时，你可以将你的检查编写成这样，如果测试没有通过，就会调用`fail`。这允许你使用Python的全部表达能力来描述你的期望检查。
- en: Let's take a look at an example. This time, we're going to test on a less-than
    operation, which isn't one of the operations directly supported by an assert method.
    Using `fail`, it's easy to implement the test anyhow.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个示例。这次，我们将对一个小于操作进行测试，这不是assert方法直接支持的操作之一。使用`fail`，我们仍然可以轻松实现这个测试。
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'A couple of things to notice here: first of all, take note of the `not` in
    the `if` statement. Since we want to run `fail` if the test should not pass, but
    we''re used to describing the circumstances when the test should succeed, a good
    way to write the test is to write the success condition, and then invert it with
    `not`. That way we can continue thinking in the way we''re used to when we use
    fail. The second thing to note is that you can pass a message to fail when you
    call it, which will be printed out in unittest''s report of failed tests. If you
    choose your message carefully, it can be a big help.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方：首先，注意`if`语句中的`not`。由于我们希望在测试不应该通过时运行`fail`，但我们习惯于描述测试应该成功的情况，因此编写测试的一个好方法是先写出成功条件，然后用`not`取反。这样我们就可以继续以我们习惯的方式使用fail。其次，需要注意的是，当你调用`fail`时，可以传递一个消息，这个消息将在unittest的失败测试报告中打印出来。如果你选择一个恰当的消息，它可能会非常有帮助。
- en: There's no screen capture of what to expect from running this test, because
    the test should pass, and the report wouldn't contain anything interesting. You
    might experiment with changing the test around and running it, to see what happens.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个测试应该通过，报告中不会包含任何有趣的内容，因此没有屏幕截图显示运行这个测试的预期结果。你可以尝试改变测试并运行它，看看会发生什么。
- en: Pop quiz – basic unittest knowledge
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 - 基本的unittest知识
- en: What is the unittest equivalent of this doctest?
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个doctest的unittest等价物是什么？
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How do you check whether two floating point numbers are equal?
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何检查两个浮点数是否相等？
- en: When would you choose to use `assertTrue`? How about `fail`?
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在什么情况下选择使用`assertTrue`？又或者`fail`？
- en: Have a go hero – translating into unittest
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 转换为unittest
- en: Look back at some of the tests we write in the previous chapters, and translate
    them from doctests into unittests. Given what you already know of unittest, you
    should be able to translate any of the tests.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下我们在前几章中编写的某些测试，并将它们从doctests转换为unittests。鉴于你已经对unittest有所了解，你应该能够将任何测试进行转换。
- en: While you're doing this, think about the relative merits of unittest and doctest
    for each of the tests you translate. The two systems have different strengths,
    so it makes sense that each will be the more appropriate choice for different
    situations. When is doctest the better choice, and when is unittest?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你这样做的时候，考虑一下unittest和doctest对于每个翻译的测试的相对优点。这两个系统有不同的优势，因此对于每种情况都将是更合适的选择。doctest何时是更好的选择，何时是unittest？
- en: Test fixtures
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试夹具
- en: Unittest has an important and highly useful capability that doctest lacks. You
    can tell unittest how to create a standardized environment for your unit tests
    to run inside, and how to clean up that environment when it's done. This ability
    to create and destroy a standardized test environment is a test fixture. While
    test fixtures doesn't actually make any tests possible that were impossible before,
    they can certainly make them shorter and less repetitive.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest具有一个重要且非常有用的功能，这是doctest所缺乏的。你可以告诉unittest如何为你的单元测试创建一个标准化的环境，以及如何在测试完成后清理该环境。能够创建和销毁一个标准化的测试环境是测试夹具的功能。虽然测试夹具并没有使之前不可能进行的任何测试成为可能，但它们确实可以使测试更短、更少重复。
- en: Time for action – testing database-backed units
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 测试数据库支持的单元
- en: 'Many programs need to access a database for their operation, which means that
    many of the units those programs are made of also access a database. The point
    is that the purpose of a database is to store information and make it accessible
    in arbitrary other places (in other words, databases exist to break the isolation
    of units). (The same problem applies to other information stores as well: for
    example, files in permanent storage.)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 许多程序需要访问数据库以进行操作，这意味着这些程序由许多也访问数据库的单元组成。关键是数据库的目的是存储信息并使其在其他任意位置可访问（换句话说，数据库的存在是为了打破单元的隔离）。（同样的问题也适用于其他信息存储：例如，永久存储中的文件。）
- en: How do we deal with that? After all, just leaving the units that interact with
    the database untested is no solution. We need to create an environment where the
    database connection works as usual, but where any changes that are made do not
    last. There are a few different ways we could do that, but no matter what the
    details are, we need to set up the special database connection before each test
    that uses it, and we need to destroy any changes after each such test.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何处理这个问题？毕竟，仅仅不测试与数据库交互的单元并不是解决方案。我们需要创建一个环境，其中数据库连接按常规工作，但所做的任何更改都不会持续。我们可以以几种不同的方式做到这一点，但无论细节如何，我们都需要在每次使用它的测试之前设置特殊的数据库连接，并在每次此类测试之后销毁任何更改。
- en: Unittest helps us to do that by providing test fixtures via the `setUp` and
    `tearDown` methods of the `TestCase` class. These methods exist for us to override,
    with the default versions doing nothing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Unittest通过提供`TestCase`类的`setUp`和`tearDown`方法来帮助我们做到这一点。这些方法供我们重写，默认版本不执行任何操作。
- en: 'Here''s some database-using code (let''s say it exists in a file called `employees.py`),
    for which we''ll write tests:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些使用数据库的代码（假设它存在于一个名为`employees.py`的文件中），我们将为它编写测试：
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This code uses the `sqlite3` database which ships with Python. Since the `sqlite3`
    interface is compatible with Python's DB-API 2.0, any database backend that you
    find yourself using will have a similar interface to what you see here.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码使用随Python一起提供的`sqlite3`数据库。由于`sqlite3`接口与Python的DB-API 2.0兼容，因此你使用的任何数据库后端都将具有与这里看到类似的接口。
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We'll start writing the tests by importing the modules that we need and introducing
    our `TestCase` class.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始编写测试，通过导入所需的模块并介绍我们的`TestCase`类。
- en: '[PRE12]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need a `setUp` method to create the environment that our tests depend on.
    In this case, that means creating a new database connection to an in-memory-only
    database, and populating that database with the needed tables and rows.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个`setUp`方法来创建我们的测试所依赖的环境。在这种情况下，这意味着创建一个新的数据库连接到仅内存的数据库，并使用所需的表和行填充该数据库。
- en: '[PRE13]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We need a `tearDown` method to undo whatever the `setUp` method did, so that
    each test can run in an untouched version of the environment. Since the database
    is only in memory, all we have to do is close the connection, and it goes away.
    `tearDown` may end up being much more complicated in other scenarios.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个`tearDown`方法来撤销`setUp`方法所做的任何操作，以便每个测试都可以在一个未受干扰的环境中运行。由于数据库仅在内存中，我们只需关闭连接，它就会消失。`tearDown`在其他场景中可能变得更为复杂。
- en: '[PRE14]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Finally, we need the tests themselves, and the code to execute the tests.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要测试本身以及执行测试的代码。
- en: '[PRE15]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*What just happened?*'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We used a `setUp` method for our `TestCase`, along with a matching `tearDown`
    method. Between them, these methods made sure that the environment in which the
    tests were executed was the one they needed (that was `setUp`'s job) and that
    the environment of each test was cleaned up after the test was run, so that the
    tests didn't interfere with each other (which was the job of `tearDown`). Unittest
    made sure that `setUp` was run once before each test method, and that `tearDown`
    was run once after each test method.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`TestCase`使用了`setUp`方法以及相应的`tearDown`方法。它们之间确保了测试执行的 环境（这是`setUp`的工作）以及每个测试的环境在测试运行后被清理，这样测试就不会相互干扰（这是`tearDown`的工作）。Unittest确保在每次测试方法之前运行一次`setUp`，在每次测试方法之后运行一次`tearDown`。
- en: Because a test fixture—as defined by `setUp` and `tearDown`—gets wrapped around
    every test in a `TestCase` class, the `setUp` and `tearDown` for `TestCase` classes
    that contain too many tests can get very complicated and waste a lot of time dealing
    with details that are unnecessary for some of the tests. You can avoid that problem
    by simply grouping together, those tests that require specific aspects of the
    environment into their own `TestCase` classes. Give each `TestCase` an appropriate
    `setUp` and `tearDown`, only dealing with those aspects of the environment that
    are necessary for the tests it contains. You can have as many `TestCase` classes
    as you want, so there's no need to skimp on them when you're deciding which tests
    to group together.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因为测试用例——根据`setUp`和`tearDown`的定义——被包裹在`TestCase`类中的每个测试周围，所以包含太多测试的`TestCase`类的`setUp`和`tearDown`可能会变得非常复杂，并且浪费大量时间处理对某些测试不必要的细节。你可以通过将需要特定环境方面的测试组合在一起，为它们创建自己的`TestCase`类来避免这个问题。为每个`TestCase`提供一个适当的`setUp`和`tearDown`，只处理包含的测试所必需的环境方面。你可以有任意多的`TestCase`类，所以在决定将哪些测试组合在一起时，没有必要在这方面节省。
- en: 'Notice how simple the `tearDown` method that we used was. That''s usually a
    good sign: when the changes that need to be undone in the `tearDown` method are
    simple to describe, it often means that you can be sure of doing it perfectly.
    Since any imperfection of the `tearDown` makes it possible for tests to leave
    behind stray data that might alter how other tests behave, getting it right is
    important. In this case, all of our changes were confined to the database, so
    getting rid of the database does the trick.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用的`tearDown`方法有多简单。这通常是一个好兆头：当需要撤销的`tearDown`方法中的更改简单到可以描述时，这通常意味着你可以确信能够完美地完成它。由于`tearDown`的任何不完美都可能使测试留下可能改变其他测试行为的散乱数据，因此正确执行它非常重要。在这种情况下，我们所有的更改都局限于数据库中，因此删除数据库就能解决问题。
- en: Pop quiz – test fixtures
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验——测试用例
- en: What is the purpose of a test fixture?
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试用例的目的是什么？
- en: How is a test fixture created?.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试用例是如何创建的？
- en: Can a test fixture have a `tearDown` method without a `setUp`? How about `setUp`
    without `tearDown`?
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试用例能否在没有`setUp`方法的情况下有`tearDown`方法？又或者`setUp`方法在没有`tearDown`方法的情况下呢？
- en: Have a go hero – file path abstraction
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来试试英雄般的挑战——文件路径抽象
- en: Below is a class definition that describes an abstraction of file paths. Your
    challenge is to write unit tests (using unittest) that check each of the methods
    of the class, making sure that they behave as advertised. You will need to use
    a test fixture to create and destroy a sandbox area in the filesystem for your
    tests to operate on.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个描述文件路径抽象的类定义。你的挑战是编写单元测试（使用unittest），检查该类的每个方法，确保它们的行为符合预期。你需要使用测试用例来创建和销毁文件系统中的沙盒区域，以便你的测试可以运行。
- en: Because doctest doesn't support test fixtures, writing these tests using that
    framework would be quite annoying. You'd have to duplicate the code to create
    the environment before each test, and the code to clean it up after each test.
    By using `unittest`, we can avoid that duplication.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于doctest不支持测试用例，使用该框架编写这些测试会很烦人。你必须在每次测试之前复制创建环境的代码，并在每次测试之后复制清理代码。通过使用`unittest`，我们可以避免这种重复。
- en: There are several things about this class that are wrong, or at least not as
    right as they ought to be. See if you can catch them with your tests.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这门课程有几个地方是错误的，或者至少没有像应该的那样正确。看看你是否能在你的测试中捕捉到它们。
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Integrating with Python Mocker
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与Python Mocker集成
- en: You've used Mocker enough to see the repetitiveness involved in creating a mocking
    context at the beginning of the text and calling its `verify` and `restore` methods
    at the end. Mocker simplifies this for you by providing a class called `MockerTestCase`
    in the mocker module. `MockerTestCase` behaves just like a normal unittest `TestCase`,
    except that for each test, it automatically creates a mocking context, which it
    then verifies and restores after the test. The mocking context is stored in `self.mocker`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经足够熟悉Mocker，可以看到在文本开头创建模拟上下文以及在结尾调用其`verify`和`restore`方法中的重复性。Mocker通过在mocker模块中提供一个名为`MockerTestCase`的类来简化这一点。`MockerTestCase`的行为就像一个普通的unittest
    `TestCase`一样，除了对于每个测试，它会自动创建一个模拟上下文，然后在测试之后验证和恢复它。模拟上下文存储在`self.mocker`中。
- en: The following example demonstrates `MockerTestCase` by using it to write a test
    involving a mock of `time.time`. Before the test gets executed, a mocking context
    is stored in `self.mocker`. After the test is run, the context is automatically
    verified and restored.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过使用它来编写一个涉及`time.time`模拟的测试来演示`MockerTestCase`。在测试执行之前，一个模拟上下文被存储在`self.mocker`中。在测试运行之后，上下文会自动验证和恢复。
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The above is a simple test that checks that the current time is `1.0`, which
    it would not be if we didn't mock `time.time`. Instead of creating a new Mocker
    instance, we have one already available to us as `self.mocker`, so we use that.
    We also get to leave off the calls to `verify` and `restore`, because the `MockerTestCase`
    takes care of that for us.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的测试是一个简单的测试，它检查当前时间是否为`1.0`，如果不是因为我们没有模拟`time.time`，它就不会是。我们不是创建一个新的Mocker实例，而是已经有一个名为`self.mocker`的实例可用，所以我们使用它。我们还能够省略对`verify`和`restore`的调用，因为`MockerTestCase`会为我们处理这些。
- en: Summary
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter contained a lot of information about how to use the unittest framework
    to write your tests.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含了大量关于如何使用unittest框架编写测试的信息。
- en: Specifically, we covered how to use unittest to express concepts that you were
    already familiar with from doctest, differences and similarities between unittest
    and doctest, how to use test fixtures to embed your tests in a controlled and
    temporary environment, and how to use Python Mocker's `MockerTestCase` to simplify
    the integration of unittest and Mocker.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了如何使用unittest来表达你从doctest中已经熟悉的概念，unittest和doctest之间的差异和相似之处，如何使用测试固定装置将你的测试嵌入到一个受控和临时的环境中，以及如何使用Python
    Mocker的`MockerTestCase`来简化unittest和Mocker的集成。
- en: Until now, we've been running tests individually, or in small groups, by directly
    instructing Python to run them. Now that we've learned about unittest, we're ready
    to talk about managing and executing large bodies of tests, which is the topic
    of the next chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是通过直接指示Python运行它们来单独或以小批量运行测试。现在我们已经学习了unittest，我们准备讨论管理和执行大量测试的话题，这是下一章的主题。
